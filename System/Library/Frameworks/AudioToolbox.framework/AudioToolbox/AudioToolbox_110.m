float normcorr(const float *a1, const float *__B, vDSP_Length __N)
{
  __C = NAN;
  v5 = __N;
  vDSP_dotpr(a1, 1, __B, 1, &__C, __N);
  v8 = NAN;
  vDSP_svesq(a1, 1, &v8, v5);
  v7 = NAN;
  vDSP_svesq(__B, 1, &v7, v5);
  return fmaxf(__C / sqrtf(v8 * v7), 0.0);
}

unint64_t ltpf::Encoder::Quantizer::Quantize(uint64_t a1, const void *a2, float *a3, int a4)
{
  v56 = *MEMORY[0x1E69E9840];
  v8 = a3[1];
  v9 = *(a1 + 932);
  MEMORY[0x1EEE9AC00](a1);
  v12 = &v49[-v11];
  if (!v10)
  {
    v13 = v12 + 928;
    memcpy(&v49[-v11], a1, 0x3A0uLL);
    v15 = 0x3FFFFFC60;
    goto LABEL_8;
  }

  v13 = v12 + 928;
  if (v10 >= 0xE9)
  {
    v14 = 4 * v10 - 928;
  }

  else
  {
    v14 = 0;
  }

  memset(v12 + 928, 255, v14);
  memcpy(v12, a1, 0x3A0uLL);
  if (v9 != -2)
  {
    v15 = 4 * (v9 + 2);
LABEL_8:
    memcpy(v13, a2, v15);
  }

  memcpy(a1, &v12[4 * v9], 0x3A0uLL);
  if (v8 > 0.6)
  {
    v50 = a4;
    v16 = 2 * *a3;
    if (v16 <= 36)
    {
      v17 = 36;
    }

    else
    {
      v17 = v16;
    }

    if (v16 >= 224)
    {
      v18 = 224;
    }

    else
    {
      v18 = 2 * *a3;
    }

    memset(v51, 255, sizeof(v51));
    v19 = (v18 + 8);
    if (v17 - 8 <= v19)
    {
      v20 = v17 - 9;
      v21 = &v51[v17 - 8];
      v22 = &v13[-4 * v17 + 32];
      do
      {
        vDSP_dotpr(v13, 1, v22, 1, v21, *(a1 + 932));
        ++v20;
        ++v21;
        --v22;
      }

      while (v20 < v19);
    }

    __I = 0xAAAAAAAAAAAAAAAALL;
    __C = NAN;
    vDSP_maxvi(&v51[(v17 - 4)], 1, &__C, &__I, v18 - v17 + 9);
    v23 = v17 - 4 + __I;
    v24 = 2;
    v25 = 3;
    v26 = 1;
    v27 = 3;
    if (v23 != 32)
    {
      v27 = 0;
    }

    if (v23 > 32)
    {
      v28 = -3;
    }

    else
    {
      v26 = 1;
      v25 = v27;
      v28 = 0;
    }

    if (v23 <= 126)
    {
      v24 = v25;
    }

    else
    {
      v26 = 2;
    }

    if (v23 > 126)
    {
      v28 = -2;
    }

    if (v23 <= 156)
    {
      v29 = v26;
    }

    else
    {
      v29 = 1;
    }

    if (v23 <= 156)
    {
      v30 = v28;
    }

    else
    {
      v24 = 0;
      v30 = 0;
    }

    __I = 0;
    v54[0] = 0;
    v55 = 0;
    v54[1] = 0;
    v31 = v30;
    v32 = (&gRPhases + 32 * v30 + 112);
    do
    {
      v33 = &v51[v23 - 4 + (v31 >= 0)];
      v34 = vmlaq_f32(vmulq_f32(*v32, v33[1]), *v33, v32[-1]);
      v35 = vaddv_f32(vadd_f32(*v34.i8, *&vextq_s8(v34, v34, 8uLL)));
      *(v54 + v31 + 1) = v35;
      if (v35 > *(v54 + v30 + 1))
      {
        v30 = v31;
      }

      v31 += v29;
      v32 += 2 * v29;
    }

    while (v31 <= v24);
    v36 = v23 + (v30 >> 31);
    v37 = v30 + 4 * (v30 >> 31);
    v38 = v37 + 4 * v36;
    v39 = -128;
    v40 = (v37 >> 1) + 2 * v36;
    if (v36 >= 127)
    {
      v39 = 126;
    }

    else
    {
      LOWORD(v40) = v37 + 4 * v36;
    }

    if (v36 <= 156)
    {
      v41 = v40;
    }

    else
    {
      v41 = v36;
    }

    if (v36 <= 156)
    {
      v42 = v39;
    }

    else
    {
      v42 = 283;
    }

    v43 = InterpCorr(v13, *(a1 + 932), v36, v37);
    v44 = vcvts_n_f32_s32(v38, 2uLL);
    if ((v50 & 1) == 0)
    {
      goto LABEL_62;
    }

    if (*(a1 + 936))
    {
      v45 = 0xAAAA000100000000;
      if (v43 <= 0.9 && (vabds_f32(v44, *(a1 + 948)) >= 2.0 || v43 <= 0.84 || (v43 - *(a1 + 940)) <= -0.1))
      {
LABEL_62:
        v47 = 0;
        v45 = 0xAAAA000000000000;
        goto LABEL_63;
      }
    }

    else
    {
      if (*(a1 + 928) != 1000 && *(a1 + 944) <= 0.94 || *(a1 + 940) <= 0.94 || v43 <= 0.94)
      {
        goto LABEL_62;
      }

      v45 = 0xAAAA000100000000;
    }

    v47 = 1;
LABEL_63:
    *(a1 + 936) = v47;
    *(a1 + 944) = *(a1 + 940);
    *(a1 + 940) = v43;
    *(a1 + 948) = v44;
    v46 = v45 | ((v42 + v41) << 16);
    return v46 | (v8 > 0.6);
  }

  *(a1 + 936) = 0;
  *(a1 + 944) = *(a1 + 940);
  *(a1 + 940) = 0;
  *(a1 + 948) = 0;
  v46 = 0xAAAA000000000000;
  return v46 | (v8 > 0.6);
}

float InterpCorr(const float *a1, vDSP_Length a2, int a3, int a4)
{
  v24[1] = *MEMORY[0x1E69E9840];
  v8 = MEMORY[0x1EEE9AC00](a1);
  v11 = (v24 - v10);
  if (v12)
  {
    v13 = 4 * v9;
    v14 = memset(v24 - v10, 255, 4 * v9);
    MEMORY[0x1EEE9AC00](v14);
    memset(v24 - ((v13 + 15) & 0x7FFFFFFF0), 255, v13);
    v15 = 0;
    v16 = kInterpCoef[a4];
    do
    {
      v17 = vmulq_f32(*&a1[v15 / 4 - 2], xmmword_19B0B3350);
      v11[v15 / 4] = vaddv_f32(vadd_f32(*v17.i8, *&vextq_s8(v17, v17, 8uLL)));
      v18 = vmulq_f32(v16, *&a1[v15 / 4 - 2 - a3]);
      *(v24 + v15 - ((v13 + 15) & 0x7FFFFFFF0)) = vaddv_f32(vadd_f32(*v18.i8, *&vextq_s8(v18, v18, 8uLL)));
      v15 += 4;
    }

    while (v13 != v15);
    v19 = v11;
    v20 = (v24 - ((v13 + 15) & 0x7FFFFFFF0));
    v21 = a2;
  }

  else
  {
    MEMORY[0x1EEE9AC00](v8);
    v20 = (v24 - ((v22 + 15) & 0x7FFFFFFF0));
    v19 = v11;
    v21 = 0;
  }

  return normcorr(v19, v20, v21);
}

unint64_t ltpf::Encoder::Encode(ltpf::Encoder *this, const float *a2, unsigned int a3)
{
  v17 = *MEMORY[0x1E69E9840];
  MEMORY[0x1EEE9AC00](this);
  v7 = &v13[-v6];
  memset(&v13[-v6], 255, ((4 * v8 + 1020) & 0x3FC) + 4);
  ltpf::Encoder::PreProcessor::PreProcess(this + 2, a2, v7);
  v14 = -1431655766;
  v15 = 0xAAAAAAAAFFFFFFFFLL;
  v16 = -1;
  ltpf::Encoder::PitchAnalyzer::Analyze(&v14, this + 28, v7);
  v9 = *this;
  v10 = 4 * a3 / 3;
  if (*(this + 1) == 1000)
  {
    v10 = a3;
  }

  v11 = 560;
  if (v9 <= 31999)
  {
    if (v9 == 24000)
    {
      v11 = 720;
    }

    else
    {
      v11 = 560;
    }

    if (v9 == 16000)
    {
      v11 = 640;
    }
  }

  else if (v9 == 32000)
  {
    v11 = 800;
  }

  else if (v9 == 44100 || v9 == 48000)
  {
    v11 = 880;
  }

  return ltpf::Encoder::Quantizer::Quantize(this + 592, v7, &v14, v10 < v11);
}

void *band::GetIndices(int a1, int a2)
{
  if (a2 == 1000)
  {
    result = &gI_8000;
    if (a1 > 31999)
    {
      if (a1 == 32000)
      {
        return &gI_32000;
      }

      if (a1 == 44100 || a1 == 48000)
      {
        return &gI_48000;
      }

      return result;
    }

    v4 = &gI_16000;
    v5 = a1 == 24000;
    v6 = &gI_24000;
    goto LABEL_15;
  }

  result = &gI_8000_7p5;
  if (a1 <= 31999)
  {
    v4 = &gI_16000_7p5;
    v5 = a1 == 24000;
    v6 = &gI_24000_7p5;
LABEL_15:
    if (!v5)
    {
      v6 = result;
    }

    if (a1 == 16000)
    {
      return v4;
    }

    else
    {
      return v6;
    }
  }

  if (a1 == 32000)
  {
    return &gI_32000_7p5;
  }

  if (a1 == 44100 || a1 == 48000)
  {
    return &gI_48000_7p5;
  }

  return result;
}

void MPVQdeenum(int a1, uint64_t a2, int a3, unsigned int a4, __int16 *a5)
{
  v9 = a1;
  bzero(a5, (2 * a1));
  v10 = 0;
  if (a3)
  {
    v11 = -1;
  }

  else
  {
    v11 = 1;
  }

  while (a4)
  {
    v12 = a2;
    do
    {
      v13 = v12;
      v14 = sns::gMPVQ_offsets[11 * ~v10 + 11 * v9 + v12];
      v12 = (v12 - 1);
      v15 = a4 >= v14;
      v16 = a4 - v14;
    }

    while (!v15);
    if (a2 == v13)
    {
      v13 = a2;
    }

    else
    {
      if (v11 >= 0)
      {
        v17 = a2 - v13;
      }

      else
      {
        v17 = v13 - a2;
      }

      a5[v10] = v17;
      if (v16)
      {
        v11 = -1;
      }

      else
      {
        v11 = 1;
      }

      v16 >>= 1;
    }

    ++v10;
    a2 = v13;
    a4 = v16;
    if (v10 == v9)
    {
      return;
    }
  }

  if (v11 >= 0)
  {
    LOWORD(v18) = a2;
  }

  else
  {
    v18 = -a2;
  }

  a5[v10] = v18;
}

void *atak::AttackDetector::PreProcessor::Process(void *a1, uint64_t a2, int a3, int a4, float32x4_t *a5)
{
  v33[1] = *MEMORY[0x1E69E9840];
  if (a4 == 1000)
  {
    v10 = 160;
  }

  else
  {
    v10 = 120;
  }

  MEMORY[0x1EEE9AC00](a1);
  v12 = (v33 - v11);
  result = memset(v33 - v11, 255, v13);
  v15 = 0;
  v16 = 0;
  v17 = 3 * a3 / 400;
  if (a3 == 44100)
  {
    v17 = 360;
    v18 = 480;
  }

  else
  {
    v18 = a3 / 100;
  }

  *v12 = *a1;
  v19 = (v12 + 1);
  if (a4 == 1000)
  {
    v17 = v18;
  }

  v20 = v17 / v10;
  if (v17 / v10 <= 1)
  {
    v21 = 1;
  }

  else
  {
    v21 = v20;
  }

  do
  {
    v22 = 0.0;
    if (v10 <= v17)
    {
      v23 = v15;
      v24 = v21;
      do
      {
        v22 = v22 + *(a2 + 4 * v23++);
        --v24;
      }

      while (v24);
    }

    v19->f32[v16++] = v22;
    v15 += v20;
  }

  while (v16 != v10);
  v25.i64[0] = 0xBF000000BF000000;
  v25.i64[1] = 0xBF000000BF000000;
  __asm { FMOV            V1.4S, #0.375 }

  v31.i64[0] = 0x3E0000003E000000;
  v31.i64[1] = 0x3E0000003E000000;
  v32 = v10;
  do
  {
    *a5++ = vmlaq_f32(vmlaq_f32(vmulq_f32(*(v19 - 4), v25), _Q1, *v19), v31, *(v19 - 8));
    ++v19;
    v32 -= 4;
  }

  while (v32);
  *a1 = v12[v10 / 2];
  return result;
}

BOOL atak::AttackDetector::Process(atak::AttackDetector *this, const float *a2, int a3)
{
  v30 = *MEMORY[0x1E69E9840];
  if (*this != 32000)
  {
    if (*this >= 44100)
    {
      if (*(this + 1) == 1000)
      {
        if (a3 > 99)
        {
          goto LABEL_10;
        }
      }

      else if ((a3 - 75) <= 0x4A)
      {
        goto LABEL_10;
      }
    }

    return 0;
  }

  if (*(this + 1) != 1000)
  {
    if ((a3 - 61) < 0x59)
    {
      goto LABEL_10;
    }

    return 0;
  }

  if (a3 <= 80)
  {
    return 0;
  }

LABEL_10:
  MEMORY[0x1EEE9AC00](this);
  v6 = (v26 - v5);
  memset(v26 - v5, 255, ((4 * v7 + 1020) & 0x3FC) + 4);
  atak::AttackDetector::PreProcessor::Process((this + 12), a2, *this, *(this + 1), v6);
  v8 = 0;
  v9 = *(this + 1);
  v26[0] = 0;
  v26[1] = 0;
  v10 = 3;
  if (v9 == 1000)
  {
    v10 = 4;
  }

  do
  {
    v11 = 0;
    v12 = *(v26 + v8);
    do
    {
      v13 = vmulq_f32(v6[v11], v6[v11]);
      v12 = (((v12 + v13.f32[0]) + v13.f32[1]) + v13.f32[2]) + v13.f32[3];
      ++v11;
    }

    while (v11 != 10);
    *(v26 + v8) = v12;
    v6 += 10;
    ++v8;
  }

  while (v8 != v10);
  if (v9 == 1000)
  {
    v14 = 4;
  }

  else
  {
    v14 = 3;
  }

  v29 = -1;
  v28 = -1;
  v15 = *(this + 5) * 0.25;
  if (v15 < *(this + 6))
  {
    v15 = *(this + 6);
  }

  v27 = v15;
  v16 = v26;
  v17 = 1;
  v18 = v15;
  do
  {
    v18 = v18 * 0.25;
    v19 = *v16++;
    v20 = v19;
    if (v18 < v19)
    {
      v18 = v20;
    }

    *(&v27 + v17++) = v18;
  }

  while (v14 != v17);
  v21 = 0;
  v22 = v14 - 1;
  v23 = *(v26 + v22);
  *(this + 5) = *(&v27 + v22);
  *(this + 6) = v23;
  v27 = v15;
  v24 = -1;
  do
  {
    if (*(v26 + v21) > (*(&v27 + v21) * 8.5))
    {
      v24 = v21;
    }

    ++v21;
  }

  while (v10 != v21);
  result = (v24 & 0x80000000) == 0 || *(this + 7) > 1;
  *(this + 7) = v24;
  return result;
}

uint64_t *BitWriter::ArithEncShift(uint64_t *this)
{
  v1 = *(this + 6);
  if (v1 < 0xFF0000 || *(this + 9) == 1)
  {
    v2 = *(this + 8);
    if ((v2 & 0x80000000) == 0)
    {
      v3 = *(this + 9) + v2;
      v4 = *this;
      v5 = *(this + 4);
      *(this + 4) = v5 + 1;
      *(v4 + v5) = v3;
    }

    if (*(this + 10) >= 1)
    {
      do
      {
        v6 = *(this + 36) - 1;
        v7 = *this;
        v8 = *(this + 4);
        *(this + 4) = v8 + 1;
        *(v7 + v8) = v6;
        v9 = *(this + 10);
        v10 = __OFSUB__(v9--, 1);
        *(this + 10) = v9;
      }

      while (!((v9 < 0) ^ v10 | (v9 == 0)));
    }

    v1 = *(this + 6);
    this[4] = HIWORD(v1);
  }

  else
  {
    ++*(this + 10);
  }

  *(this + 6) = v1 << 8;
  return this;
}

uint64_t *BitWriter::ArithEncode(uint64_t *this, int a2, int a3)
{
  v3 = this;
  v4 = *(this + 7) >> 10;
  v5 = *(this + 6) + v4 * a2;
  if (HIBYTE(v5))
  {
    *(this + 9) = 1;
  }

  v6 = v4 * a3;
  *(this + 6) = v5 & 0xFFFFFF;
  *(this + 7) = v6;
  if (!HIWORD(v6))
  {
    do
    {
      *(v3 + 28) = v6 << 8;
      this = BitWriter::ArithEncShift(v3);
      v6 = *(v3 + 28);
    }

    while (v6 < 0x10000);
  }

  return this;
}

void *mdct::SynthesisFilterbank::FrequencyToTime(mdct::SynthesisFilterbank *this, DSPSplitComplex *a2)
{
  v34[1] = *MEMORY[0x1E69E9840];
  v4 = *this;
  v5 = *(this + 3);
  MEMORY[0x1EEE9AC00](this);
  v7 = v34 - v6;
  v9 = (v8 - v5);
  if (v9)
  {
    memset(v34 - v6, 255, 4 * v9);
  }

  v10 = *(this + 1);
  if (v10 < v4)
  {
    bzero(a2 + 4 * v10, 4 * (v4 + ~v10) + 4);
  }

  v11 = &v7[4 * v4 + -4 * v5];
  if (*(this + 12))
  {
    DCT_IV::OutOfPlaceTransform((this + 48), a2, &v7[4 * v4 + -4 * v5], 1.0);
    LODWORD(v12) = *this;
  }

  else if (v10 == 60 && v4 == 60)
  {
    v13 = 0;
    LODWORD(v12) = 60;
    v14 = &v7[4 * v4 + -4 * v5];
    v15 = &mdct::gDCT_60_60;
    do
    {
      vDSP_dotpr(a2, 1, v15, v12, v14, *(this + 1));
      ++v13;
      v12 = *this;
      ++v14;
      ++v15;
    }

    while (v13 < v12);
  }

  else if (v4)
  {
    for (i = 0; i != v4; ++i)
    {
      *(v11 + 4 * i) = 0;
      if (v10)
      {
        v18 = 0;
        v19 = 0.0;
        do
        {
          v20 = *(&a2->realp + v18);
          v17 = 3.14159265 / v4;
          v19 = v19 + (v20 * cosf(((i + 0.5) * v17) * (v18++ + 0.5)));
        }

        while (v10 != v18);
        *(v11 + 4 * i) = v19;
      }
    }

    LODWORD(v12) = v4;
  }

  else
  {
    LODWORD(v12) = 0;
  }

  MEMORY[0x19EAE6090](&v7[4 * v4 + -4 * v5], 1, this + 8, &v7[4 * v4 + -4 * v5], 1, v12);
  v21 = *this;
  v22 = v21 >> 1;
  v23 = *(this + 3);
  v24 = v21 >> 1;
  if (*this >> 1 != v23)
  {
    memmove(v7, (v11 + 4 * v23 + 4 * v22), 4 * (v22 - v23));
    v24 = v23;
  }

  MEMORY[0x19EAE5FB0](v11 + 4 * v21 - 4, -1, &v7[4 * v22 + -4 * v24], 1, v21 >> 1);
  MEMORY[0x19EAE5FB0](&v7[4 * v4 + -4 * v5], 1, &v7[4 * *this + 4 * v22 + -4 * *(this + 3)], 1, v21 >> 1);
  v25 = *this;
  v26 = *(this + 3);
  if (v25 != v22)
  {
    v27 = &v7[4 * v25 + -4 * v26];
    v28 = 4 * v22 - 4 * v25;
    v29 = &v7[4 * v25 + 4 * v4 - 4 * v5 - 4];
    do
    {
      v30 = *v29;
      v29 -= 4;
      *v27 = v30;
      v27 += 4;
      v28 += 4;
    }

    while (v28);
  }

  MEMORY[0x19EAE5FA0](*(this + 2), -1, v7, 1, v7, 1, (2 * v25 - v26));
  result = MEMORY[0x19EAE5DC0](*(this + 3), 1, v7, 1, a2, 1, (*this - *(this + 3)));
  v32 = *(this + 3);
  if (v32)
  {
    result = memcpy(a2 + 4 * *this + -4 * v32, &v7[4 * *this + -4 * v32], 4 * v32);
    LODWORD(v32) = *(this + 3);
  }

  v33 = *this;
  if (v33 != v32)
  {
    return memmove(*(this + 3), &v7[4 * v33], 4 * (v33 - v32));
  }

  return result;
}

float *Candidate::AddPulse(float *this, int a2)
{
  v2 = 0;
  v3 = 0;
  v4 = this[11];
  v5 = *this;
  v6 = (this + 2);
  v7 = 1.0;
  v8 = 0.0;
  do
  {
    v9 = *(this + 12) + 1 + 2 * *(v6 + v2);
    if ((v7 * ((v4 + *(v5 + 4 * v2)) * (v4 + *(v5 + 4 * v2)))) > ((v8 * v8) * v9))
    {
      v7 = v9;
      v8 = v4 + *(v5 + 4 * v2);
      v3 = v2;
    }

    ++v2;
  }

  while (a2 != v2);
  ++*(v6 + v3);
  this[11] = v8;
  *(this + 12) = v7;
  ++*(this + 10);
  return this;
}

uint64_t MPVQenum(uint64_t result, const __int16 *a2, unsigned int *a3, unsigned int *a4)
{
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = result - 1;
  v8 = 0x80000000;
  v9 = sns::gMPVQ_offsets;
  do
  {
    v10 = a2[v7];
    if ((v8 & 0x80000000) != 0 || !a2[v7])
    {
      if (!a2[v7])
      {
        goto LABEL_7;
      }
    }

    else
    {
      v6 = v8 + 2 * v6;
    }

    v8 = v10 < 1;
LABEL_7:
    v6 += *v9;
    *a3 = v6;
    if (v10 >= 0)
    {
      v11 = v10;
    }

    else
    {
      v11 = -v10;
    }

    v4 += v11;
    if (v7-- != 0)
    {
      ++v5;
    }

    v9 = &sns::gMPVQ_offsets[11 * v5 + v4];
  }

  while ((v7 + 2) > 1);
  *a4 = v8;
  return result;
}

uint64_t mdct::GetNumLeadingZeros(int a1, int a2)
{
  if (a2 == 1000)
  {
    result = 30;
    if (a1 > 31999)
    {
      if (a1 == 32000)
      {
        return 120;
      }

      if (a1 == 44100 || a1 == 48000)
      {
        return 180;
      }

      return result;
    }

    v4 = 60;
    v5 = a1 == 24000;
    v6 = 90;
    goto LABEL_15;
  }

  result = 14;
  if (a1 <= 31999)
  {
    v4 = 28;
    v5 = a1 == 24000;
    v6 = 42;
LABEL_15:
    if (!v5)
    {
      v6 = result;
    }

    if (a1 == 16000)
    {
      return v4;
    }

    else
    {
      return v6;
    }
  }

  if (a1 == 32000)
  {
    return 56;
  }

  if (a1 == 44100 || a1 == 48000)
  {
    return 84;
  }

  return result;
}

void *mdct::GetWindowPointer(int a1, int a2)
{
  if (a2 == 1000)
  {
    result = &gWin_10ms_8kHz;
    if (a1 > 31999)
    {
      if (a1 == 32000)
      {
        return &gWin_10ms_32kHz;
      }

      if (a1 == 44100 || a1 == 48000)
      {
        return &gWin_10ms_48kHz;
      }

      return result;
    }

    v4 = &gWin_10ms_16kHz;
    v5 = a1 == 24000;
    v6 = &gWin_10ms_24kHz;
    goto LABEL_15;
  }

  result = &gWin_7p5ms_8kHz;
  if (a1 <= 31999)
  {
    v4 = &gWin_7p5ms_16kHz;
    v5 = a1 == 24000;
    v6 = &gWin_7p5ms_24kHz;
LABEL_15:
    if (!v5)
    {
      v6 = result;
    }

    if (a1 == 16000)
    {
      return v4;
    }

    else
    {
      return v6;
    }
  }

  if (a1 == 32000)
  {
    return &gWin_7p5ms_32kHz;
  }

  if (a1 == 44100 || a1 == 48000)
  {
    return &gWin_7p5ms_48kHz;
  }

  return result;
}

unint64_t opus_packet_pad(unsigned __int8 *a1, int a2, int a3)
{
  if (a2 < 1)
  {
    return 0xFFFFFFFFLL;
  }

  if (a2 == a3)
  {
    return 0;
  }

  if (a2 > a3)
  {
    return 0xFFFFFFFFLL;
  }

  result = memset(v10, 170, sizeof(v10));
  v10[1] = 0;
  v7 = &a1[a3];
  if (v7 < a1 || (v8 = &v7[-a2], v8 > v7) || v8 < a1)
  {
    __break(0x5519u);
  }

  else
  {
    memmove(&v7[-a2], a1, a2);
    result = opus_repacketizer_cat_impl(v10, v8, a2);
    if (!result)
    {
      v9 = opus_repacketizer_out_range_impl(v10, v10[1], a1, a3, 1);
      return v9 & (v9 >> 31);
    }
  }

  return result;
}

uint64_t opus_repacketizer_out_range_impl(uint64_t result, int a2, char *a3, int a4, int a5)
{
  v5 = (a2 - 1);
  if (a2 < 1)
  {
    return 0xFFFFFFFFLL;
  }

  v6 = result;
  if (*(result + 4) < a2)
  {
    return 0xFFFFFFFFLL;
  }

  v8 = (result + 776);
  v9 = result + 872;
  v79 = &a3[a4];
  if (a2 == 2)
  {
    v14 = *(result + 778);
    v15 = *(result + 776);
    if (v14 == v15)
    {
      if (2 * v15 >= a4)
      {
        return 4294967294;
      }

      if (v79 <= a3)
      {
        goto LABEL_140;
      }

      v16 = (2 * v15) | 1;
      *a3 = *result & 0xFC | 1;
      v12 = a3 + 1;
    }

    else
    {
      v17 = v14 + v15;
      if (v15 > 251)
      {
        ++v17;
      }

      v16 = v17 + 2;
      if (v17 + 2 > a4)
      {
        return 4294967294;
      }

      if (v79 <= a3)
      {
        goto LABEL_140;
      }

      *a3 = *result & 0xFC | 2;
      if (a4 < 3)
      {
        goto LABEL_140;
      }

      v18 = a3 + 1;
      if (a3 + 1 < a3 || v18 > v79)
      {
        goto LABEL_140;
      }

      v19 = *v8;
      if (v19 >= 252)
      {
        a3[2] = (v19 - (v19 | 0xFCu)) >> 2;
        v20 = 2;
        LOBYTE(v19) = v19 | 0xFC;
      }

      else
      {
        v20 = 1;
      }

      *v18 = v19;
      v12 = &v18[v20];
    }

    v76 = v16;
    if (!a5 || v16 >= a4)
    {
      goto LABEL_106;
    }

LABEL_28:
    v21 = (result + 778);
    v23 = result + 778 > v9 || v8 > v21;
    v24 = a2 - 1;
    v25 = 1;
    v26 = 2;
    while (1)
    {
      v27 = (v21 + 1) > v9 || v21 > v21 + 1;
      v28 = !v27 && v21 >= v8;
      v29 = !v28;
      if (v29 || v23)
      {
        goto LABEL_140;
      }

      if (*v21 != *v8)
      {
        v34 = 2;
        v35 = (result + 776);
        v36 = (a2 - 1);
        while (1)
        {
          v37 = (v35 + 1) > v9 || v35 > v35 + 1;
          if (v37 || v35 < v8)
          {
            goto LABEL_140;
          }

          v40 = *v35++;
          v39 = v40;
          if (v40 <= 251)
          {
            v41 = 1;
          }

          else
          {
            v41 = 2;
          }

          v34 += v39 + v41;
          if (!--v36)
          {
            v42 = &v8[v5];
            if ((v42 + 1) <= v9 && v42 <= v42 + 1 && v42 >= v8)
            {
              v30 = v34 + *v42;
              if (v30 > a4)
              {
                return 4294967294;
              }

              if (v79 > a3)
              {
                v43 = a3 + 1;
                *a3 = *result | 3;
                if (a3 + 1 >= a3 && v43 < v79)
                {
                  v13 = 0;
                  v33 = a2 | 0x80;
                  *v43 = a2 | 0x80;
                  v32 = !v25;
                  goto LABEL_75;
                }
              }
            }

            goto LABEL_140;
          }
        }
      }

      v25 = v26 < a2;
      ++v21;
      ++v26;
      if (!--v24)
      {
        v13 = 0;
        goto LABEL_48;
      }
    }
  }

  if (a2 != 1)
  {
    goto LABEL_28;
  }

  v10 = *v8;
  if (v10 >= a4)
  {
    return 4294967294;
  }

  if (v79 <= a3)
  {
    goto LABEL_140;
  }

  v11 = v10 + 1;
  *a3 = *result & 0xFC;
  v12 = a3 + 1;
  v76 = v11;
  if (!a5 || v11 >= a4)
  {
LABEL_106:
    v54 = 0;
    v55 = 0;
    v78 = result + 8;
    v75 = a4;
    v56 = a2;
    while (1)
    {
      v57 = v12;
      v58 = (v6 + v54 + 8);
      v59 = v6 + v54 + 24;
      v60 = v59 > v8 || v58 > v59;
      if (v60 || v58 < v78)
      {
        goto LABEL_140;
      }

      v62 = v6 + v55;
      v63 = v6 + v55 + 778;
      if (v63 > v9)
      {
        goto LABEL_140;
      }

      v64 = (v62 + 776);
      if (v62 + 776 > v63 || v64 < v8)
      {
        goto LABEL_140;
      }

      v65 = *v58;
      v66 = *(v6 + v54 + 16);
      v67 = *v64;
      v28 = v66 >= v65;
      v68 = v66 - v65;
      v69 = v28 && v68 >= v67;
      v70 = !v69 || v57 > v79;
      v71 = !v70 && v57 >= a3;
      if (!v71 || v79 - v57 < v67)
      {
        goto LABEL_140;
      }

      result = memmove(v57, v65, *v64);
      if (v57 > &v57[v67])
      {
        goto LABEL_140;
      }

      v73 = *v64;
      v12 = &v57[v73];
      v55 += 2;
      v54 += 16;
      if (!--v56)
      {
        if (!a5 || v12 >= v79)
        {
          return v76;
        }

        v74 = &a3[v75] - v57 - v73;
        while (v12 >= a3)
        {
          *v12++ = 0;
          if (!--v74)
          {
            return v76;
          }
        }

        goto LABEL_140;
      }
    }
  }

  v13 = 1;
LABEL_48:
  v30 = *v8 * a2 + 2;
  if (v30 > a4)
  {
    return 4294967294;
  }

  if (v79 > a3)
  {
    v31 = a3 + 1;
    *a3 = *result | 3;
    if (a3 + 1 >= a3 && v31 < v79)
    {
      *v31 = a2;
      v32 = 1;
      v33 = a2;
LABEL_75:
      v12 = a3 + 2;
      v44 = v30;
      v45 = a4 - v30;
      if (!a5 || !v45)
      {
LABEL_89:
        v76 = v44;
        if (((v32 | v13) & 1) == 0)
        {
          v49 = (result + 776);
          while (1)
          {
            v50 = (v49 + 1) > v9 || v49 > v49 + 1;
            v51 = !v50 && v49 >= v8;
            if (!v51 || v79 < v12 || v12 < a3 || v79 - v12 < 2)
            {
              goto LABEL_140;
            }

            v52 = *v49;
            if (v52 >= 252)
            {
              v12[1] = (v52 - (v52 | 0xFCu)) >> 2;
              LOBYTE(v52) = v52 | 0xFC;
              v53 = 2;
            }

            else
            {
              v53 = 1;
            }

            *v12 = v52;
            v12 += v53;
            ++v49;
            if (!--v5)
            {
              goto LABEL_106;
            }
          }
        }

        goto LABEL_106;
      }

      v46 = a3 + 1;
      if (a3 + 1 >= a3 && v46 < v79)
      {
        *v46 = v33 | 0x40;
        v47 = (v45 - 1) / 255;
        if (v45 >= 256)
        {
          if (v47 <= 1)
          {
            v48 = 1;
          }

          else
          {
            v48 = (v45 - 1) / 255;
          }

          while (v12 < v79 && v12 >= a3)
          {
            *v12++ = -1;
            if (!--v48)
            {
              goto LABEL_86;
            }
          }

          goto LABEL_140;
        }

LABEL_86:
        if (v12 < v79 && v12 >= a3)
        {
          *v12++ = v47 + v45 - 1;
          v44 = a4;
          goto LABEL_89;
        }
      }
    }
  }

LABEL_140:
  __break(0x5519u);
  return result;
}

unint64_t stereo_fade(unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4, int a5, int a6, float *a7, unint64_t a8, float a9, float a10, int a11)
{
  v11 = a5 / (48000 / a11);
  v12 = 1.0 - a10;
  if (v11 >= 1)
  {
    v13 = 0;
    v14 = 1.0 - a9;
    v15 = a7;
    while (v15 >= a7)
    {
      if ((v15 + 1) > a8)
      {
        break;
      }

      if (v15 > v15 + 1)
      {
        break;
      }

      v16 = (result + v13);
      if (result + v13 < result)
      {
        break;
      }

      if ((v16 + 1) > a2)
      {
        break;
      }

      if (v16 > v16 + 1)
      {
        break;
      }

      v17 = (result + v13 + 4);
      if (v17 < result)
      {
        break;
      }

      v18 = result + v13 + 8;
      if (v18 > a2)
      {
        break;
      }

      if (v17 > v18)
      {
        break;
      }

      v19 = a3 + v13;
      if (a3 + v13 < a3)
      {
        break;
      }

      if (v19 + 4 > a4)
      {
        break;
      }

      if (v19 > v19 + 4)
      {
        break;
      }

      v20 = ((v14 * (1.0 - (*v15 * *v15))) + ((*v15 * *v15) * v12)) * ((*v16 - *v17) * 0.5);
      v21 = (a3 + v13 + 4);
      *(a3 + v13) = *(a3 + v13) - v20;
      v22 = a3 + v13 + 8;
      if (v21 < a3)
      {
        break;
      }

      if (v22 > a4 || v21 > v22)
      {
        break;
      }

      *v21 = v20 + *v21;
      v15 += 48000 / a11;
      v13 += 8;
      if (8 * (a5 / (48000 / a11)) == v13)
      {
        goto LABEL_23;
      }
    }

    goto LABEL_51;
  }

  v11 = 0;
LABEL_23:
  if (v11 < a6)
  {
    v24 = a6 - v11;
    v25 = 8 * v11;
    v26 = a3;
    for (i = result; ; i += 8)
    {
      v28 = (i + v25);
      v29 = (i + v25 + 4);
      v30 = i + v25 < result || v29 > a2;
      v31 = v30 || v28 > v29;
      v32 = v28 + 2;
      v33 = !v31 && v29 >= result;
      v34 = !v33 || v32 > a2;
      if (v34 || v29 > v32)
      {
        break;
      }

      v36 = v26 + v25;
      if (v26 + v25 < a3)
      {
        break;
      }

      if (v36 + 4 > a4)
      {
        break;
      }

      if (v36 > v36 + 4)
      {
        break;
      }

      v37 = v12 * ((*v28 - *v29) * 0.5);
      v38 = (v26 + v25 + 4);
      *(v26 + v25) = *(v26 + v25) - v37;
      v39 = v26 + v25 + 8;
      if (v38 < a3)
      {
        break;
      }

      if (v39 > a4 || v38 > v39)
      {
        break;
      }

      *v38 = v37 + *v38;
      v26 += 8;
      if (!--v24)
      {
        return result;
      }
    }

LABEL_51:
    __break(0x5519u);
  }

  return result;
}

uint64_t intensity_stereo(uint64_t result, float *a2, unint64_t a3, float *a4, unint64_t a5, unint64_t a6, unint64_t a7, int a8, int a9)
{
  v9 = (a6 + 4 * a8);
  v10 = v9 + 1;
  v12 = v9 < a6 || v10 > a7 || v9 > v10;
  if (v12 || ((v13 = (a6 + 4 * (*(result + 8) + a8)), v14 = v13 + 1, v13 >= a6) ? (v15 = v14 > a7) : (v15 = 1), !v15 ? (v16 = v13 > v14) : (v16 = 1), v16))
  {
LABEL_25:
    __break(0x5519u);
    return result;
  }

  v17 = a9;
  if (a9 >= 1)
  {
    v18 = sqrtf(((*v9 * *v9) + 1.0e-15) + (*v13 * *v13)) + 1.0e-15;
    v19 = *v9 / v18;
    v20 = *v13 / v18;
    v21 = a2;
    v22 = a4;
    while (v21 >= a2 && (v21 + 1) <= a3 && v21 <= v21 + 1 && v22 >= a4 && (v22 + 1) <= a5 && v22 <= v22 + 1)
    {
      v23 = *v22++;
      *v21 = (v20 * v23) + (v19 * *v21);
      ++v21;
      if (!--v17)
      {
        return result;
      }
    }

    goto LABEL_25;
  }

  return result;
}

uint64_t silk_stereo_encode_pred(uint64_t a1, char *a2)
{
  ec_enc_icdf(a1, 5 * a2[2] + a2[5], &silk_stereo_pred_joint_iCDF, &silk_uniform3_iCDF, 8);
  ec_enc_icdf(a1, *a2, &silk_uniform3_iCDF, &silk_uniform5_iCDF, 8);
  ec_enc_icdf(a1, a2[1], &silk_uniform5_iCDF, &silk_stereo_only_code_mid_iCDF, 8);
  ec_enc_icdf(a1, a2[3], &silk_uniform3_iCDF, &silk_uniform5_iCDF, 8);
  v4 = a2[4];

  return ec_enc_icdf(a1, v4, &silk_uniform5_iCDF, &silk_stereo_only_code_mid_iCDF, 8);
}

unint64_t silk_stereo_LR_to_MS(uint64_t a1, void *a2, void *a3, uint64_t a4, _BYTE *a5, int *a6, int a7, int a8, int a9, int a10)
{
  v183 = a8;
  v179 = a7;
  v180 = a6;
  v181 = a4;
  v182 = a5;
  v184 = v176;
  v195[1] = *MEMORY[0x1E69E9840];
  v195[0] = 0xAAAAAAAAAAAAAAAALL;
  v12 = a2[1];
  v13 = a2[2];
  v14 = MEMORY[0x1EEE9AC00](a1);
  v18 = v17;
  v19 = v14;
  result = &v176[-v20];
  v22 = 2 * v16;
  v23 = &v176[2 * v16 - v20];
  v190 = v17;
  v191 = v19;
  v188 = v23;
  v189 = &v176[-v20];
  v192 = v15;
  if (v16)
  {
    memset(result, 170, 2 * v16);
    v19 = v191;
    LODWORD(v15) = v192;
    v23 = v188;
    result = v189;
    v18 = v190;
    if (v192 >= -1)
    {
      v24 = 0;
      v25 = a2[2];
      while (1)
      {
        v26 = *a2 + v24;
        v27 = (v26 - 4);
        v28 = v26 - 2;
        v29 = v28 > a2[1] || v27 > v28;
        if (v29 || v27 < v25)
        {
          break;
        }

        v31 = *a3 + v24;
        v32 = (v31 - 4);
        v33 = v31 - 2;
        v34 = v33 > a3[1] || v32 > v33;
        if (v34 || v32 < a3[2])
        {
          break;
        }

        v36 = v18 + v24;
        v37 = v18 + v24 - 2;
        if (v37 > v12)
        {
          break;
        }

        v38 = (v36 - 4);
        if (v36 - 4 > v37)
        {
          break;
        }

        if (v38 < v13)
        {
          break;
        }

        v39 = *v27;
        v40 = *v32;
        *v38 = ((*v32 + v39) & 1) + ((v40 + v39) >> 1);
        v41 = (result + v24);
        if (result + v24 < result || v41 + 1 > v23 || v41 > v41 + 1)
        {
          break;
        }

        v42 = ((v39 - v40) & 1) + ((v39 - v40) >> 1);
        if (v42 >= 0x7FFF)
        {
          LOWORD(v42) = 0x7FFF;
        }

        *v41 = v42;
        v24 += 2;
        if (v22 == v24)
        {
          goto LABEL_29;
        }
      }

LABEL_206:
      __break(0x5519u);
    }
  }

LABEL_29:
  v43 = v18 - 4;
  if (v18 - 4 > v12 || v13 > v43)
  {
    goto LABEL_206;
  }

  if (v12 - v43 < 4)
  {
    goto LABEL_206;
  }

  *(v18 - 4) = v19[1];
  if (v43 > v18)
  {
    goto LABEL_206;
  }

  if (v15 > 0xFFFFFFFD)
  {
    goto LABEL_206;
  }

  v45 = v19[2];
  *result = v45;
  if (result >= result + 4)
  {
    goto LABEL_206;
  }

  v46 = (v43 + 2 * v15);
  if (v12 < v46)
  {
    goto LABEL_206;
  }

  if (v13 > v46)
  {
    goto LABEL_206;
  }

  if (v12 - v46 < 4)
  {
    goto LABEL_206;
  }

  v19[1] = *v46;
  v186 = v15;
  v47 = (result + 2 * v15);
  if (v47 > v23)
  {
    goto LABEL_206;
  }

  if (result > v47)
  {
    goto LABEL_206;
  }

  if ((v22 - 2 * v186) < 4)
  {
    goto LABEL_206;
  }

  v19[2] = *v47;
  v185 = v19 + 3;
  if (v19 + 2 > v19 + 3)
  {
    goto LABEL_206;
  }

  if (v15 >= 1)
  {
    v187 = a10;
    v178 = a9;
    v48 = 2 * v15;
    MEMORY[0x1EEE9AC00](result);
    v49 = &v176[-((v48 + 15) & 0x3FFFFFFF0)];
    v50 = memset(v49, 170, v48);
    MEMORY[0x1EEE9AC00](v50);
    v51 = v49;
    v52 = memset(v49, 170, v48);
    v53 = v192;
    v54 = v190;
    v55 = 0;
    do
    {
      v56 = (v54 + v55);
      v57 = (v54 + v55 - 4);
      v58 = (v54 + v55 - 2);
      v59 = v58 > v12 || v57 > v58;
      v60 = v56 + 1;
      v63 = !v59 && v60 <= v12 && v56 <= v60 && v56 >= v13;
      if (!v63 || v56 > v12 || v58 > v56 || v58 < v13)
      {
        goto LABEL_206;
      }

      v64 = *v58;
      v65 = v64 + ((*v56 + *v57) >> 1) + 1;
      *&v49[v55] = v65 >> 1;
      *&v49[v55] = v64 - (v65 >> 1);
      v55 += 2;
    }

    while (v48 != v55);
    v66 = 2 * v53;
    MEMORY[0x1EEE9AC00](v52);
    v67 = &v176[-((v66 + 15) & 0x3FFFFFFF0)];
    v68 = memset(v67, 170, v48);
    MEMORY[0x1EEE9AC00](v68);
    memset(v67, 170, v48);
    v70 = v191;
    v69 = v192;
    v72 = v188;
    v71 = v189;
    v73 = 0;
    do
    {
      v74 = &v71[v73 + 4];
      v75 = &v71[v73 + 6];
      if (v75 > v72 || v74 > v75)
      {
        goto LABEL_206;
      }

      v77 = *v74 + v45;
      LOWORD(v45) = *&v71[v73 + 2];
      v78 = (v77 >> 1) + v45 + 1;
      *&v67[v73] = v78 >> 1;
      *&v67[v73] = v45 - (v78 >> 1);
      v73 += 2;
    }

    while (v66 != v73);
    v194 = -1431655766;
    v177 = 5 * v187;
    v79 = 10 * v187;
    v80 = 655;
    if (10 * v187 == v69)
    {
      v80 = 328;
    }

    v81 = (v80 * (v183 * v183)) >> 16;
    v82 = v70 + 14;
    LODWORD(v195[0]) = silk_stereo_find_predictor(&v194, &v176[-((v48 + 15) & 0x3FFFFFFF0)], v67, v185, v69, v81);
    v83 = (v191 + 10);
    if (v191 + 10 > v82 || v185 > v83)
    {
      goto LABEL_206;
    }

    v193 = -1431655766;
    predictor = silk_stereo_find_predictor(&v193, v51, v67, v83, v192, v81);
    HIDWORD(v195[0]) = predictor;
    v85 = 3 * v194 + v193;
    if (v85 >= 0x10000)
    {
      v85 = 0x10000;
    }

    if (v79 == v192)
    {
      v86 = -1200;
    }

    else
    {
      v86 = -600;
    }

    v87 = v86 + v179;
    if (v87 <= 1)
    {
      v88 = 1;
    }

    else
    {
      v88 = v87;
    }

    v89 = 900 * v187 + 2000;
    v90 = __clz(v88);
    v91 = v88 << (v90 - 1);
    v92 = -851968 - 3 * v85;
    if (3 * v85 + 851968 >= 0)
    {
      v92 = 3 * v85 + 851968;
    }

    v93 = __clz(v92);
    v94 = (3 * v85 + 851968) << (v93 - 1);
    v95 = (0x1FFFFFFF / (v94 >> 16) * v91) >> 16;
    v96 = ((0x1FFFFFFF / (v94 >> 16) * (v91 - (((v95 * v94) >> 29) & 0xFFFFFFF8))) >> 16) + v95;
    v97 = v90 - v93;
    if ((v97 + 10) >= 0x20)
    {
      v98 = 0;
    }

    else
    {
      v98 = v96 >> (v97 + 10);
    }

    v99 = 0x80000000 >> (-10 - v97);
    if (v99 <= v96)
    {
      v99 = v96;
    }

    if ((0x7FFFFFFFu >> (-10 - v97)) >= v96)
    {
      v100 = v99;
    }

    else
    {
      v100 = 0x7FFFFFFFu >> (-10 - v97);
    }

    v101 = v100 << (-10 - v97);
    if (v97 <= -11)
    {
      v102 = v101;
    }

    else
    {
      v102 = v98;
    }

    v103 = v180;
    *v180 = v102;
    if (v102 >= v89)
    {
      v103[1] = v88 - v102;
      v121 = 0x4000;
    }

    else
    {
      *v103 = v89;
      v103[1] = v88 - v89;
      v104 = 2 * (v88 - v89) - v89;
      v105 = (v89 * (3 * v85 + 0x10000)) >> 16;
      if (v104 >= 0)
      {
        v106 = 2 * (v88 - v89) - v89;
      }

      else
      {
        v106 = v89 - 2 * (v88 - v89);
      }

      v107 = __clz(v106);
      v108 = v104 << (v107 - 1);
      if ((v105 & 0x80000000) == 0)
      {
        v109 = (v89 * (3 * v85 + 0x10000)) >> 16;
      }

      else
      {
        v109 = -v105;
      }

      v110 = __clz(v109);
      v111 = v105 << (v110 - 1);
      v112 = (0x1FFFFFFF / (v111 >> 16) * v108) >> 16;
      v113 = ((0x1FFFFFFF / (v111 >> 16) * (v108 - (((v112 * v111) >> 29) & 0xFFFFFFF8))) >> 16) + v112;
      v114 = v107 - v110;
      v115 = v107 - v110 + 13;
      v116 = v113 >> (v107 - v110 + 13);
      if (v115 >= 0x20)
      {
        v117 = 0;
      }

      else
      {
        v117 = v116;
      }

      v118 = 0x80000000 >> (-13 - v114);
      if (v118 <= v113)
      {
        v118 = v113;
      }

      if ((0x7FFFFFFFu >> (-13 - v114)) >= v113)
      {
        v119 = v118;
      }

      else
      {
        v119 = 0x7FFFFFFFu >> (-13 - v114);
      }

      v120 = v119 << (-13 - v114);
      if (v114 > -14)
      {
        v120 = v117;
      }

      v121 = v120 & ~(v120 >> 31);
      if (v121 >= 0x4000)
      {
        v121 = 0x4000;
      }
    }

    v122 = v182;
    v123 = v178;
    *v82 += (v81 * (v121 - *v82)) >> 16;
    *v122 = 0;
    if (v123)
    {
      v195[0] = 0;
      result = silk_stereo_quant_pred(v195, v181);
      v124 = 0;
      goto LABEL_127;
    }

    v125 = 8 * v88;
    v126 = v191[14];
    if (v191[15])
    {
      if (v125 < 11 * v89 || ((v191[14] * v85) >> 16) <= 327)
      {
        LODWORD(v195[0]) = (SLOWORD(v195[0]) * v126) >> 14;
        HIDWORD(v195[0]) = (predictor * v126) >> 14;
        result = silk_stereo_quant_pred(v195, v181);
        v124 = 0;
        v195[0] = 0;
        goto LABEL_127;
      }
    }

    else if (v125 < 13 * v89 || ((v191[14] * v85) >> 16) <= 818)
    {
      LODWORD(v195[0]) = (SLOWORD(v195[0]) * v126) >> 14;
      HIDWORD(v195[0]) = (predictor * v126) >> 14;
      result = silk_stereo_quant_pred(v195, v181);
      v127 = v191;
      v128 = v192;
      v124 = 0;
      v195[0] = 0;
      *v103 = v88;
      v103[1] = 0;
      *v122 = 1;
      v130 = v189;
      v129 = v190;
      v131 = v188;
      goto LABEL_128;
    }

    if (v126 < 15566)
    {
      LODWORD(v195[0]) = (SLOWORD(v195[0]) * v126) >> 14;
      HIDWORD(v195[0]) = (predictor * v126) >> 14;
      result = silk_stereo_quant_pred(v195, v181);
      v124 = *v82;
    }

    else
    {
      result = silk_stereo_quant_pred(v195, v181);
      v124 = 0x4000;
    }

LABEL_127:
    v129 = v190;
    v127 = v191;
    v131 = v188;
    v130 = v189;
    v128 = v192;
    if (*v122 != 1)
    {
      v191[16] = 0;
      goto LABEL_132;
    }

LABEL_128:
    v132 = v127[16] + v128 - 8 * v187;
    v127[16] = v132;
    if (v177 > v132)
    {
      *v122 = 0;
      goto LABEL_133;
    }

    v127[16] = 10000;
LABEL_132:
    if (*v122)
    {
LABEL_137:
      v134 = 8 * v187;
      v135 = v195[0];
      v136 = WORD2(v195[0]);
      if (v187 >= 1)
      {
        v137 = 0;
        v138 = *v127;
        v139 = v127[1];
        v140 = (0x10000 / v134);
        v141 = (((v140 * (LOWORD(v195[0]) - v138)) >> 15) + 1) >> 1;
        v142 = (((v140 * (WORD2(v195[0]) - v139)) >> 15) + 1) >> 1;
        v143 = v127[15];
        v144 = (((0x10000 / v134) * (v124 - v143)) >> 6) & 0xFFFFFFFFFFFFFC00;
        v145 = v144 + (v143 << 10);
        v146 = -v139 - v142;
        LODWORD(result) = -v138 - v141;
        v147 = (8 * v187);
        do
        {
          v148 = (v129 + v137);
          v149 = (v129 + v137 - 4);
          v150 = (v129 + v137 - 2);
          v151 = v150 > v12 || v149 > v150;
          v152 = !v151 && v149 >= v13;
          v153 = v148 + 1;
          v154 = !v152 || v153 > v12;
          v155 = v154 || v148 > v153;
          if (v155 || v148 < v13)
          {
            goto LABEL_206;
          }

          if (v148 > v12)
          {
            goto LABEL_206;
          }

          if (v150 > v148)
          {
            goto LABEL_206;
          }

          if (v150 < v13)
          {
            goto LABEL_206;
          }

          v157 = &v130[v137 / 2 + 1];
          if (v157 < v130)
          {
            goto LABEL_206;
          }

          v158 = &v130[v137 / 2 + 2];
          if (v158 > v131)
          {
            goto LABEL_206;
          }

          if (v157 > v158)
          {
            goto LABEL_206;
          }

          v159 = *a3 + v137;
          if (v159 > a3[1])
          {
            goto LABEL_206;
          }

          v160 = (v159 - 2);
          if (v159 < 2 || v160 < a3[2])
          {
            goto LABEL_206;
          }

          v161 = (((((*v150 * v146) >> 5) + ((v145 * *v157) >> 16) + ((result * (((*v148 + *v149) << 9) + (*v150 << 10))) >> 16)) >> 7) + 1) >> 1;
          if (v161 <= -32768)
          {
            v161 = -32768;
          }

          if (v161 >= 0x7FFF)
          {
            LOWORD(v161) = 0x7FFF;
          }

          *v160 = v161;
          v145 += v144;
          v137 += 2;
          LOWORD(v146) = v146 - v142;
          result = (result - v141);
        }

        while (--v147);
      }

      if (v134 < v128)
      {
        v162 = 2 * v134;
        v163 = v186 - v134;
        do
        {
          result = v129 + v162;
          v164 = (v129 + v162 - 4);
          v165 = (v129 + v162 - 2);
          v166 = v165 > v12 || v164 > v165;
          v167 = !v166 && v164 >= v13;
          v168 = result + 2;
          v169 = !v167 || v168 > v12;
          v170 = v169 || result > v168;
          if (v170 || result < v13)
          {
            goto LABEL_206;
          }

          if (result > v12)
          {
            goto LABEL_206;
          }

          if (v165 > result)
          {
            goto LABEL_206;
          }

          if (v165 < v13)
          {
            goto LABEL_206;
          }

          v172 = &v130[v162 / 2 + 1];
          if (v172 < v130)
          {
            goto LABEL_206;
          }

          v173 = &v130[v162 / 2 + 2];
          if (v173 > v131)
          {
            goto LABEL_206;
          }

          if (v172 > v173)
          {
            goto LABEL_206;
          }

          v174 = *a3 + v162;
          if (v174 > a3[1])
          {
            goto LABEL_206;
          }

          v175 = (v174 - 2);
          if (v174 < 2 || v175 < a3[2])
          {
            goto LABEL_206;
          }

          LODWORD(result) = (((((*v165 * -v136) >> 5) + ((*v172 * (v124 << 10)) >> 16) + ((-v135 * (((*result + *v164) << 9) + (*v165 << 10))) >> 16)) >> 7) + 1) >> 1;
          if (result <= -32768)
          {
            LODWORD(result) = -32768;
          }

          if (result >= 0x7FFF)
          {
            result = 0x7FFFLL;
          }

          else
          {
            result = result;
          }

          *v175 = result;
          v162 += 2;
        }

        while (--v163);
      }

      *v127 = v135;
      v127[1] = v136;
      v127[15] = v124;
      return result;
    }

LABEL_133:
    if (v103[1] <= 0)
    {
      v133 = v88 - 1;
      if (v88 - 1 <= 1)
      {
        v133 = 1;
      }

      *v103 = v133;
      v103[1] = 1;
    }

    goto LABEL_137;
  }

  return result;
}

void *silk_NSQ_c(uint64_t a1, unint64_t a2, char *a3, int *a4, unint64_t a5, unint64_t a6, unint64_t a7, unint64_t a8, unint64_t a9, unint64_t a10, unint64_t a11, unint64_t a12, unint64_t a13, unint64_t a14, unint64_t a15, __int16 a16, __int16 a17, __int16 a18)
{
  v315 = a8;
  v313 = a7;
  v350 = a6;
  v304 = a5;
  v351 = *MEMORY[0x1E69E9840];
  *(a2 + 4368) = a3[34];
  v18 = (&silk_Quantization_Offsets_Q10 + 4 * (a3[29] >> 1));
  v309 = a3;
  v19 = &v18[a3[30]];
  v20 = (v19 + 1);
  if (v19 < v18 || v20 > (v18 + 2) || v19 > v20)
  {
    goto LABEL_376;
  }

  v318 = *(a2 + 4356);
  v25 = *v19;
  v26 = v309[31];
  v27 = *(a1 + 4616);
  v28 = (*(a1 + 4608) + v27);
  v29 = MEMORY[0x1EEE9AC00](a1);
  v31 = &v284 - v30;
  v32 = 2 * v28;
  v310 = v29;
  if (v28)
  {
    v33 = memset(v31, 170, 4 * v28);
    MEMORY[0x1EEE9AC00](v33);
    v308 = &v284 - ((v32 + 15) & 0x3FFFFFFF0);
    memset(v308, 170, 2 * v28);
    v34 = v310;
  }

  else
  {
    v34 = MEMORY[0x1EEE9AC00](v29);
    v308 = &v284 - ((v32 + 15) & 0x3FFFFFFF0);
  }

  v35 = MEMORY[0x1EEE9AC00](v34);
  v38 = &v284 - v36;
  v346 = &v284 - v36;
  if (v37)
  {
    v39 = v37;
    memset(&v284 - v36, 170, 4 * v37);
    v38 = v346;
    v37 = v39;
    v35 = v310;
  }

  v40 = a15;
  *(a2 + 4364) = v27;
  *(a2 + 4360) = v27;
  v41 = a2 + 1280;
  v42 = v35[1151];
  if (v42 > 0)
  {
    v285 = 2 * v28;
    v43 = 0;
    v291 = v31 + 8;
    v290 = a2 + 1284;
    v44 = v26 == 4;
    v301 = v26 == 4;
    v348 = a2 + 2 * v27;
    v306 = v315 + 64;
    v293 = a9;
    v289 = a9 + 40;
    v45 = a10 + 128;
    v303 = a11;
    v302 = a11 + 16;
    v311 = a15 + 16;
    if (v44)
    {
      v46 = 3;
    }

    else
    {
      v46 = 1;
    }

    v287 = v46;
    v47 = v308;
    v307 = &v308[2 * v28];
    v349 = &v31[4 * v28];
    v300 = a14;
    v299 = a14 + 16;
    v286 = a18;
    v48 = v25;
    v49 = (a2 + 3840);
    v50 = (a2 + 4352);
    v51 = (a2 + 4288);
    v298 = a12;
    v297 = a12 + 16;
    v317 = (944 - v48) * a16;
    v323 = v48 + 944;
    v322 = (v48 + 944) * a16;
    v52 = xmmword_19B0B33F0;
    v319 = (a2 + 4292);
    v53 = v27;
    v296 = a13;
    v295 = a13 + 16;
    v288 = a2 + 3964;
    v316 = v48 - 944;
    v339 = a16;
    v347 = v48;
    v335 = a16 * v48;
    v336 = v48 - 80;
    v292 = a10;
    v321 = (a10 + 4);
    v54 = v37;
    v294 = v37;
    v340 = &v38[4 * v37];
    v55 = a4;
    v305 = a15;
    v284 = xmmword_19B0B33F0;
    do
    {
      v56 = (v303 + 4 * v43);
      if (v56 < v303 || (v56 + 1) > v302 || v56 > v56 + 1)
      {
        goto LABEL_376;
      }

      v57 = (v315 + 32 * (v301 | (v43 >> 1)));
      LODWORD(v345) = *v56;
      *(a2 + 4376) = 0;
      v58 = (v40 + 4 * v43);
      v44 = v309[29] == 2;
      v314 = v43;
      if (v44)
      {
        if (v58 < v40 || (v58 + 1) > v311 || v58 > v58 + 1)
        {
          goto LABEL_376;
        }

        v59 = *v58;
        v318 = *v58;
        if ((v287 & v43) != 0)
        {
          v61 = 1;
          v60 = 1;
        }

        else
        {
          v62 = v35[1166];
          v63 = v35[1154] - v62 - v59 - 2;
          v64 = &v47[v63];
          if (v64 > v307)
          {
            goto LABEL_376;
          }

          if (v47 > v64)
          {
            goto LABEL_376;
          }

          v65 = 2 - (-v62 - v59);
          if (v65 < 0)
          {
            goto LABEL_376;
          }

          if ((v285 - 2 * v63) >> 1 < v65)
          {
            goto LABEL_376;
          }

          v66 = a2 + 2 * (v63 + v54 * v43);
          if (v66 < a2 || v57 < v315)
          {
            goto LABEL_376;
          }

          v67 = v55;
          silk_LPC_analysis_filter(v64, v66, a2 + 1280, v57, v306, v65, v62);
          v52 = v284;
          v43 = v314;
          v40 = v305;
          v47 = v308;
          v55 = v67;
          v35 = v310;
          v61 = 0;
          *(a2 + 4376) = 1;
          v53 = v35[1154];
          *(a2 + 4360) = v53;
          v60 = v309[29] == 2;
        }

        v320 = v60;
      }

      else
      {
        v320 = 0;
        v61 = 1;
      }

      v68 = v304;
      v69 = v346;
      v70 = v307;
      if (v58 < v40)
      {
        goto LABEL_376;
      }

      if ((v58 + 1) > v311)
      {
        goto LABEL_376;
      }

      if (v58 > v58 + 1)
      {
        goto LABEL_376;
      }

      v71 = (v300 + 4 * v43);
      if (v71 < v300 || (v71 + 1) > v299 || v71 > v71 + 1)
      {
        goto LABEL_376;
      }

      v72 = *v71;
      if (*v71 <= 1)
      {
        v73 = 1;
      }

      else
      {
        v73 = *v71;
      }

      v74 = __clz(v73);
      v75 = (((-((((0x1FFFFFFF / ((v73 << (v74 - 1)) >> 16)) << 19) * (v73 << (v74 - 1))) & 0xFFFFFFF800000000) >> 32) * (0x1FFFFFFF / ((v73 << (v74 - 1)) >> 16))) >> 16) + ((0x1FFFFFFF / ((v73 << (v74 - 1)) >> 16)) << 16);
      v76 = v75 >> (15 - v74);
      v77 = v74 - 15;
      v78 = 0x80000000 >> v77;
      if (v75 > 0x80000000 >> v77)
      {
        v78 = v75;
      }

      if (v75 <= (0x7FFFFFFFu >> v77))
      {
        v79 = v78;
      }

      else
      {
        v79 = 0x7FFFFFFFu >> v77;
      }

      v80 = v79 << v77;
      if (v72 < 0x20000)
      {
        v76 = v80;
      }

      v81 = *(a2 + 4372);
      if (v72 == v81)
      {
        v82 = 0x10000;
      }

      else
      {
        if (v81 >= 0)
        {
          v83 = *(a2 + 4372);
        }

        else
        {
          v83 = -v81;
        }

        v84 = __clz(v83);
        v85 = v81 << (v84 - 1);
        if (v72 >= 0)
        {
          v86 = *v71;
        }

        else
        {
          v86 = -v72;
        }

        v87 = __clz(v86);
        v88 = v72 << (v87 - 1);
        v89 = (0x1FFFFFFF / (v88 >> 16) * v85) >> 16;
        v90 = ((0x1FFFFFFF / (v88 >> 16) * (v85 - (((v89 * v88) >> 29) & 0xFFFFFFF8))) >> 16) + v89;
        v91 = v84 - v87;
        if ((v91 + 29) >= 0x30)
        {
          v92 = 0;
        }

        else
        {
          v92 = v90 >> (v91 + 13);
        }

        v93 = 0x80000000 >> (-13 - v91);
        if (v93 <= v90)
        {
          v93 = v90;
        }

        if ((0x7FFFFFFFu >> (-13 - v91)) >= v90)
        {
          v94 = v93;
        }

        else
        {
          v94 = 0x7FFFFFFFu >> (-13 - v91);
        }

        v82 = v94 << (-13 - v91);
        if (v91 > -14)
        {
          v82 = v92;
        }
      }

      v95 = *v58;
      v96 = v35[1153];
      if (v96 >= 1)
      {
        v97 = v55;
        v98 = v346;
        do
        {
          if (v97 < v55 || (v97 + 1) > v68 || v97 > v97 + 1 || v98 < v69 || (v98 + 4) > v340 || v98 > v98 + 4)
          {
            goto LABEL_376;
          }

          v99 = *v97++;
          *v98 = (v99 * (((v76 >> 7) + 1) >> 1)) >> 16;
          v98 += 4;
          --v96;
        }

        while (v96);
      }

      *(a2 + 4372) = v72;
      if ((v61 & 1) == 0)
      {
        v100 = v53 - v95 - 2;
        if (v100 < v53)
        {
          v101 = ((v286 * v76) >> 14) & 0xFFFFFFFC;
          v102 = v53 - v100;
          if (v43)
          {
            LODWORD(v101) = v76;
          }

          v103 = &v31[4 * v100];
          v104 = &v47[v100];
          do
          {
            if (v104 < v47 || (v104 + 1) > v70 || v104 > v104 + 1 || v103 < v31 || (v103 + 4) > v349 || v103 > v103 + 4)
            {
              goto LABEL_376;
            }

            v105 = *v104++;
            *v103 = (v105 * v101) >> 16;
            v103 += 4;
            --v102;
          }

          while (v102);
        }
      }

      if (v82 != 0x10000)
      {
        v106 = v35[1154];
        if (v106 >= 1)
        {
          v107 = *(a2 + 4364) - v106;
          v108 = 4 * v107;
          do
          {
            v109 = a2 + v108 + 1280;
            v110 = a2 + v108 + 1284;
            if (v109 < v41 || v110 > v49 || v109 > v110)
            {
              goto LABEL_376;
            }

            *(a2 + 4 * v107 + 1280) = (*(a2 + 4 * v107 + 1280) * v82) >> 16;
            ++v107;
            v108 += 4;
          }

          while (v107 < *(a2 + 4364));
        }

        if (v320 && !*(a2 + 4376))
        {
          v113 = *(a2 + 4360);
          v114 = v113 - v95 - 2;
          if (v114 < v113)
          {
            v115 = v113 - v114;
            v116 = &v31[4 * v114];
            do
            {
              if (v116 < v31 || (v116 + 1) > v349 || v116 > v116 + 1)
              {
                goto LABEL_376;
              }

              *v116 = (*v116 * v82) >> 16;
              ++v116;
              --v115;
            }

            while (v115);
          }
        }

        v117 = v82;
        *v50 = (*v50 * v82) >> 16;
        v118 = (a2 + 3840);
        v119 = 32;
        do
        {
          if (v118 + 1 > v51 || v118 > v118 + 1)
          {
            goto LABEL_376;
          }

          *v118 = (*v118 * v117) >> 16;
          ++v118;
          --v119;
        }

        while (v119);
        v121 = (a2 + 4288);
        v122 = 16;
        do
        {
          if (v121 + 1 > v50 || v121 > v121 + 1)
          {
            goto LABEL_376;
          }

          *v121 = (*v121 * v117) >> 16;
          ++v121;
          --v122;
        }

        while (v122);
      }

      v124 = (v298 + 4 * v43);
      if (v124 < v298)
      {
        goto LABEL_376;
      }

      if ((v124 + 1) > v297)
      {
        goto LABEL_376;
      }

      if (v124 > v124 + 1)
      {
        goto LABEL_376;
      }

      v125 = (v296 + 4 * v43);
      if (v125 < v296)
      {
        goto LABEL_376;
      }

      if ((v125 + 1) > v295)
      {
        goto LABEL_376;
      }

      if (v125 > v125 + 1)
      {
        goto LABEL_376;
      }

      if (v348 > v41)
      {
        goto LABEL_376;
      }

      if (v348 < a2)
      {
        goto LABEL_376;
      }

      v126 = v35[1153];
      if (v126 > v294)
      {
        goto LABEL_376;
      }

      if ((v313 - v350) < v126)
      {
        goto LABEL_376;
      }

      if (v350 > v313)
      {
        goto LABEL_376;
      }

      if ((v126 & 0x80000000) != 0)
      {
        goto LABEL_376;
      }

      if ((v41 - v348) >> 1 < v126)
      {
        goto LABEL_376;
      }

      if (v57 < v315)
      {
        goto LABEL_376;
      }

      v127 = (v293 + 10 * v43);
      if (v127 < v293)
      {
        goto LABEL_376;
      }

      v128 = (v292 + 32 * v43);
      if (v128 < v292)
      {
        goto LABEL_376;
      }

      v129 = v57 + 2;
      if (v57 + 2 > v306)
      {
        goto LABEL_376;
      }

      if (v129 < v57)
      {
        goto LABEL_376;
      }

      v130 = v57 + 4;
      if (v57 + 4 > v306)
      {
        goto LABEL_376;
      }

      if (v129 > v130)
      {
        goto LABEL_376;
      }

      v131 = v57 + 6;
      if (v57 + 6 > v306)
      {
        goto LABEL_376;
      }

      if (v130 > v131)
      {
        goto LABEL_376;
      }

      v132 = v57 + 1;
      if (&v57[1] > v306)
      {
        goto LABEL_376;
      }

      if (v131 > v132)
      {
        goto LABEL_376;
      }

      v133 = (v57 + 10);
      v134 = *v57;
      if (&v57[1] + 2 > v306)
      {
        goto LABEL_376;
      }

      if (v132 > v133)
      {
        goto LABEL_376;
      }

      v135 = (v57 + 12);
      if (&v57[1] + 4 > v306)
      {
        goto LABEL_376;
      }

      if (v133 > v135)
      {
        goto LABEL_376;
      }

      v136 = &v57[1] + 6;
      if (&v57[1] + 6 > v306)
      {
        goto LABEL_376;
      }

      if (v135 > v136)
      {
        goto LABEL_376;
      }

      v137 = v57 + 2;
      if (&v57[2] > v306)
      {
        goto LABEL_376;
      }

      if (v136 > v137)
      {
        goto LABEL_376;
      }

      v138 = (v57 + 18);
      if (&v57[2] + 2 > v306)
      {
        goto LABEL_376;
      }

      if (v137 > v138)
      {
        goto LABEL_376;
      }

      v139 = (v57 + 20);
      if (&v57[2] + 4 > v306 || v138 > v139)
      {
        goto LABEL_376;
      }

      v140 = *v124;
      v141 = *v125;
      v142 = *v71;
      v143 = v35[1165];
      v144 = v35[1166];
      v53 = *(a2 + 4360);
      v145 = *(a2 + 4364);
      v146 = v57[1];
      v147.i32[0] = v137->i16[0];
      v147.i32[1] = v57[2].i16[1];
      v148.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      v148.u64[1] = vrev64_s32(vshl_n_s32(v147, 0xFuLL));
      if (v144 == 16)
      {
        v149 = &v57[2] + 6;
        if (&v57[2] + 6 > v306)
        {
          goto LABEL_376;
        }

        if (v139 > v149)
        {
          goto LABEL_376;
        }

        v150 = v57 + 3;
        if (&v57[3] > v306)
        {
          goto LABEL_376;
        }

        if (v149 > v150)
        {
          goto LABEL_376;
        }

        v151 = (v57 + 26);
        if (&v57[3] + 2 > v306)
        {
          goto LABEL_376;
        }

        if (v150 > v151)
        {
          goto LABEL_376;
        }

        v152 = &v57[3] + 2;
        if (&v57[3] + 4 > v306)
        {
          goto LABEL_376;
        }

        if (v151 > v152)
        {
          goto LABEL_376;
        }

        v153 = &v57[3] + 3;
        if (&v57[3] + 6 > v306 || v152 > v153 || &v57[4] > v306 || v153 > &v57[4])
        {
          goto LABEL_376;
        }

        v154.i32[0] = v57[2].i16[2];
        v154.i32[1] = v57[2].i16[3];
        *v155.i8 = vrev64_s32(vshl_n_s32(v154, 0xFuLL));
        v155.i64[1] = vextq_s8(v148, v148, 8uLL).u64[0];
        v157.i32[0] = v150->i16[0];
        v157.i32[1] = v57[3].i16[1];
        v156 = vrev64_s32(vshl_n_s32(*v157.i8, 0xFuLL));
        v157.i32[1] = *v152 << 15;
        v157.u64[1] = v156;
        v158 = *v153 << 15;
      }

      else
      {
        v158 = 0;
        v155.i64[0] = 0;
        v155.i64[1] = v148.i64[1];
        v157 = v52;
      }

      v312 = v55;
      if (v126)
      {
        v159 = 0;
        v160 = v345 >> 2;
        v161 = (v345 >> 2) | (v345 << 15);
        v341 = (v142 >> 6);
        v162 = &v291[4 * (v53 - v318)];
        v163 = (v290 + 4 * (v145 - v318));
        v164 = vrev64q_s32(vshll_n_s16(v134, 0xFuLL));
        v165 = vextq_s8(v164, v164, 8uLL);
        v166 = vrev64q_s32(vshll_n_s16(v146, 0xFuLL));
        v167 = vextq_s8(v166, v166, 8uLL);
        v157.i32[0] = v158;
        v168 = v127 + 1;
        v170 = (v127 + 1) > v289 || v168 < v127;
        v171 = v127 + 2;
        v173 = (v127 + 2) > v289 || v168 > v171;
        v333 = v173;
        v334 = v170;
        v174 = v127 + 3;
        v177 = (v127 + 3) > v289 || v171 > v174 || v171 < v127;
        v178 = (v127 + 4);
        v181 = (v127 + 4) > v289 || v174 > v178 || v174 < v127;
        v331 = v181;
        v332 = v177;
        v184 = (v127 + 5) > v289 || v178 > (v127 + 5) || v178 < v127;
        v330 = v184;
        v345 = v140;
        v185 = v318;
        v343 = v141 >> 16;
        v344 = v141;
        v338 = v160;
        v337 = v161 >> 16;
        v186 = *(a2 + 4368);
        v342 = v144 >> 1;
        v188 = v128 + 2 <= v45 && &v128->i16[1] >= v128;
        v328 = v143 >> 1;
        v329 = v188;
        v189 = v143 - 1;
        v190 = &v51[4 * v143 - 4];
        v191 = v190 + 4 > v50 || v190 > v190 + 4;
        v326 = &v51[4 * v189];
        v193 = !v191 && v190 >= v51;
        v327 = v193;
        v194 = v128 + 2 * v189;
        v195 = v194 + 2 > v45 || v194 > v194 + 2;
        v324 = v128 + v189;
        v197 = !v195 && v194 >= v128;
        v325 = v197;
        v198 = v288;
        v199 = v320;
        while (1)
        {
          v200 = v126;
          *(a2 + 4368) = 196314165 * v186 + 907633515;
          v201 = *(v198 - 60);
          v202 = *(v198 - 44);
          v203 = *(v198 - 28);
          v204 = *(v198 - 12);
          if (v199)
          {
            v206 = (v162 + 1) <= v349 && v162 <= v162 + 1 && v162 >= v31;
            v207 = v334;
            if (!v206)
            {
              v207 = 1;
            }

            if (v207)
            {
              goto LABEL_376;
            }

            v208 = (v162 - 1);
            v209 = v162 >= 4 && v208 >= v31;
            v210 = v333;
            if (!v209)
            {
              v210 = 1;
            }

            if (v210)
            {
              goto LABEL_376;
            }

            v211 = (v162 - 2);
            v212 = (v162 - 2) <= v208 && v211 >= v31;
            v213 = v332;
            if (!v212)
            {
              v213 = 1;
            }

            if (v213)
            {
              goto LABEL_376;
            }

            v214 = (v162 - 3);
            v215 = (v162 - 3) <= v211 && v214 >= v31;
            v216 = v331;
            if (!v215)
            {
              v216 = 1;
            }

            if (v216)
            {
              goto LABEL_376;
            }

            v217 = (v162 - 4) <= v214 && v162 - 4 >= v31;
            v218 = v330;
            if (!v217)
            {
              v218 = 1;
            }

            if (v218)
            {
              goto LABEL_376;
            }

            v219 = ((v127[4] * *(v162 - 4)) >> 16) + ((((*v162 * *v127) << 16) + ((*(v162 - 1) * v127[1]) >> 16 << 32) + ((*(v162 - 2) * v127[2]) >> 16 << 32) + ((*(v162 - 3) * v127[3]) >> 16 << 32) + 0x200000000) >> 32);
            ++v162;
          }

          else
          {
            v219 = 0;
          }

          if (v198 < v49)
          {
            goto LABEL_376;
          }

          v220 = (v198 + 4);
          v222 = v198 + 4 <= v51 && v220 >= v198;
          if (v143 == 8)
          {
            if (!v222)
            {
              goto LABEL_376;
            }

            v223 = vextq_s8(v204, *(a2 + 4288), 0xCuLL);
            v224 = *(a2 + 4300);
            v225 = vmovl_s16(*v128);
            v226 = vmovl_high_s16(*v128->i8);
            v227 = vmlal_high_s32(vmlal_s32(vmlal_high_s32(vmull_s32(*v223.i8, *v225.i8), v223, v225), *v224.i8, *v226.i8), v224, v226);
            v228 = vrshrd_n_s64(v227.i64[0] + vextq_s8(v227, v227, 8uLL).u64[0], 0xFuLL);
            *(a2 + 4288) = v223;
            *(a2 + 4304) = v224;
          }

          else
          {
            if (!v222)
            {
              goto LABEL_376;
            }

            v229 = *v51;
            *v51 = v204.i32[3];
            if (!v329)
            {
              goto LABEL_376;
            }

            v230 = v328 + ((v128->i16[0] * v204.i32[3]) >> 16);
            if (v143 >= 3)
            {
              v231 = v319;
              v232 = v321;
              v233 = 2;
              while (v231 >= v51)
              {
                if (v231 + 4 > v50)
                {
                  break;
                }

                if (v231 > v231 + 4)
                {
                  break;
                }

                v234 = *v231;
                *v231 = v229;
                v235 = v232 - 1;
                if (v232 - 1 < v128)
                {
                  break;
                }

                if (v232 > v45)
                {
                  break;
                }

                if (v235 > v232)
                {
                  break;
                }

                v236 = (v231 + 4);
                if (v231 + 4 < v51)
                {
                  break;
                }

                if (v231 + 8 > v50)
                {
                  break;
                }

                if (v236 > v231 + 2)
                {
                  break;
                }

                v237 = *v235;
                v238 = *v236;
                *v236 = v234;
                if (v232 < v128 || (v232 + 1) > v45 || v232 > v232 + 1)
                {
                  break;
                }

                v239 = *v232;
                v232 += 2;
                v230 += ((v237 * v229) >> 16) + ((v239 * v234) >> 16);
                v233 += 2;
                v231 += 8;
                v229 = v238;
                if (v233 >= v143)
                {
                  goto LABEL_303;
                }
              }

              goto LABEL_376;
            }

            v238 = v229;
LABEL_303:
            if (!v327)
            {
              goto LABEL_376;
            }

            *v326 = v238;
            if (!v325)
            {
              goto LABEL_376;
            }

            v228 = 2 * (v230 + ((*v324 * v238) >> 16));
            v145 = *(a2 + 4364);
          }

          v240 = v41 + 4 * v145;
          v241 = (v240 - 4);
          if (v240 - 4 < v41 || v240 > v49 || v241 > v240)
          {
            goto LABEL_376;
          }

          v242 = vpaddlq_s32(vaddq_s32(vaddq_s32(vqdmulhq_s32(v155, v202), vqdmulhq_s32(v157, v201)), vaddq_s32(vqdmulhq_s32(v167, v203), vqdmulhq_s32(v165, v204))));
          v243 = v242.i32[0] + vextq_s8(v242, v242, 8uLL).u32[0] + v342;
          v244 = v228 + ((v345 * *v50) >> 16);
          v245 = ((v344 * *v241) >> 16) + ((*v50 * v343) >> 16);
          v246 = 4 * v243 - v245 - v244;
          if (v185 < 1)
          {
            v248 = v246 >> 1;
          }

          else
          {
            if (v163 + 1 > v49)
            {
              goto LABEL_376;
            }

            if (v163 > v163 + 1)
            {
              goto LABEL_376;
            }

            if (v163 < v41)
            {
              goto LABEL_376;
            }

            v247 = (v163 - 1);
            if (v163 - 1 > v49 || (v163 - 2) > v247 || (v163 - 2) < v41 || v247 > v163)
            {
              goto LABEL_376;
            }

            v248 = (v219 + 2 * v246 - 2 * (((v338 * (*(v163 - 2) + *v163)) >> 16) + ((*(v163 - 1) * v337) >> 16))) >> 2;
            ++v163;
          }

          v249 = *&v346[4 * v159] - ((v248 + 1) >> 1);
          if (*(a2 + 4368) < 0)
          {
            v249 = -v249;
          }

          if (v249 <= -31744)
          {
            v249 = -31744;
          }

          v250 = v249 >= 30720 ? 30720 : v249;
          v251 = v347;
          v252 = v250 - v347;
          v253 = (v250 - v347) >> 10;
          if (v253 < 1)
          {
            v256 = v322;
            v255 = v335;
            v254 = v323;
            if (v252 >= 0x400)
            {
              v257 = v347 + (v252 & 0xFFFFFC00);
              v258 = v257 + 80;
              v254 = v257 + 1104;
              v259 = (-80 - v257) * v339;
              v199 = v320;
              v256 = (-1104 - v257) * v339;
              if (v253 == -1)
              {
                v256 = v335;
                v255 = v317;
              }

              else
              {
                v255 = v259;
              }

              if (v253 == -1)
              {
                v254 = v347;
              }

              v185 = v318;
              if (v253 == -1)
              {
                v251 = v316;
              }

              else
              {
                v251 = v258;
              }
            }
          }

          else
          {
            v251 = v336 + (v252 & 0xFFFFFC00);
            v254 = v251 + 1024;
            v255 = (v336 + (v252 & 0xFC00)) * v339;
            v256 = (v336 + (v252 & 0xFC00) + 1024) * v339;
          }

          if (v256 + (v250 - v254) * (v250 - v254) >= v255 + (v250 - v251) * (v250 - v251))
          {
            v260 = v251;
          }

          else
          {
            v260 = v254;
          }

          *(v350 + v159) = ((v260 >> 9) + 1) >> 1;
          v261 = 16 * v260;
          if (*(a2 + 4368) < 0)
          {
            v261 = -v261;
          }

          v262 = v261 + 2 * v219;
          v263 = v262 + 16 * v243;
          v264 = ((((v341 * v263) >> 16) >> 7) + 1) >> 1;
          if (v264 <= -32768)
          {
            v264 = -32768;
          }

          if (v264 >= 0x7FFF)
          {
            LOWORD(v264) = 0x7FFF;
          }

          *(v348 + 2 * v159) = v264;
          if (v198 + 8 > v51)
          {
            goto LABEL_376;
          }

          if (v220 > v198 + 8)
          {
            goto LABEL_376;
          }

          if (v220 < v49)
          {
            goto LABEL_376;
          }

          *v220 = v263;
          v265 = v263 - 4 * v244;
          *(a2 + 4352) = v265;
          v266 = (v41 + 4 * *(a2 + 4364));
          if (v266 < v41)
          {
            goto LABEL_376;
          }

          if (v266 + 1 > v49)
          {
            goto LABEL_376;
          }

          if (v266 > v266 + 1)
          {
            goto LABEL_376;
          }

          *v266 = v265 - 4 * v245;
          v267 = *(a2 + 4360);
          v268 = &v31[4 * v267];
          if (v268 < v31 || (v268 + 4) > v349 || v268 > v268 + 4)
          {
            goto LABEL_376;
          }

          *v268 = 2 * v262;
          v145 = *(a2 + 4364) + 1;
          *(a2 + 4364) = v145;
          v53 = v267 + 1;
          *(a2 + 4360) = v267 + 1;
          v186 = *(a2 + 4368) + *(v350 + v159);
          *(a2 + 4368) = v186;
          ++v159;
          v198 += 4;
          v126 = v200;
          if (v159 == v200)
          {
            goto LABEL_358;
          }
        }
      }

      v126 = 0;
LABEL_358:
      v269 = &v49[v126];
      if (v51 < v269 || v49 > v269 || (v51 - v269) < 0x80 || (v270 = *v269, v271 = *(v269 + 1), v272 = *(v269 + 3), *(a2 + 3872) = *(v269 + 2), *(a2 + 3888) = v272, *v49 = v270, *(a2 + 3856) = v271, v273 = *(v269 + 4), v274 = *(v269 + 5), v275 = *(v269 + 7), *(a2 + 3936) = *(v269 + 6), *(a2 + 3952) = v275, *(a2 + 3904) = v273, *(a2 + 3920) = v274, v35 = v310, v54 = v310[1153], v47 = v308, v40 = v305, v312 + 4 * v54 < v312) || v350 + v54 < v350)
      {
LABEL_376:
        __break(0x5519u);
      }

      v348 += 2 * v54;
      v43 = v314 + 1;
      v42 = v310[1151];
      v321 += 16;
      v55 = (v312 + 4 * v54);
      v350 += v54;
    }

    while (v314 + 1 < v42);
  }

  v276 = v40 + 4 * v42;
  v277 = (v276 - 4);
  if (v276 - 4 < v40)
  {
    goto LABEL_376;
  }

  if (v276 > v40 + 16)
  {
    goto LABEL_376;
  }

  if (v277 > v276)
  {
    goto LABEL_376;
  }

  *(a2 + 4356) = *v277;
  v278 = v35[1152];
  v279 = (a2 + 2 * v278);
  if (v279 > v41)
  {
    goto LABEL_376;
  }

  if (v279 < a2)
  {
    goto LABEL_376;
  }

  v280 = 2 * v35[1154];
  if (v280 > 1280 - 2 * v278)
  {
    goto LABEL_376;
  }

  if (v280 > 0x500)
  {
    goto LABEL_376;
  }

  memmove(a2, v279, v280);
  v281 = (v41 + 4 * v310[1152]);
  if (a2 + 3840 < v281)
  {
    goto LABEL_376;
  }

  if (v41 > v281)
  {
    goto LABEL_376;
  }

  v282 = 4 * v310[1154];
  if (v282 > 0xA00 || v282 > a2 + 3840 - v281)
  {
    goto LABEL_376;
  }

  return memmove((a2 + 1280), v281, v282);
}

void silk_LPC_analysis_filter(char *a1, unint64_t a2, unint64_t a3, int16x4_t *a4, unint64_t a5, int a6, int a7)
{
  if (a7 < a6)
  {
    v8 = a4 + 2;
    v10 = a4 + 2 > a5 || v8 < a4;
    v11 = a4 + 4;
    v13 = a4 + 4 > a5 || v8 > v11;
    v14 = a4 + 6;
    v17 = a4 + 6 > a5 || v11 > v14 || v11 < a4;
    v18 = a4 + 1;
    v21 = &a4[1] > a5 || v14 > v18 || v14 < a4;
    v22 = &a4[1] + 2;
    v25 = &a4[1] + 2 > a5 || v18 > v22 || v18 < a4;
    v28 = &a4[1] + 4 > a5 || v22 > &a4[1] + 4 || v22 < a4;
    v29 = a7;
    v30 = a2 + 2 * a7 - 16;
    v31 = a7;
    while (1)
    {
      v32 = (a2 + 2 * v31);
      v33 = v32 - 1;
      v34 = v32 > a3 || v33 > v32;
      v35 = !v34 && v33 >= a2;
      if (!v35 || v10)
      {
        goto LABEL_129;
      }

      v37 = v32 - 2;
      v38 = (v32 - 2) < a2 || v37 > v33;
      v39 = v38 || v13;
      if (v39)
      {
        goto LABEL_129;
      }

      v40 = v32 - 3;
      v41 = (v32 - 3) < a2 || v40 > v37;
      v42 = v41 || v17;
      if (v42)
      {
        goto LABEL_129;
      }

      v43 = (v32 - 4);
      v44 = (v32 - 4) < a2 || v43 > v40;
      v45 = v44 || v21;
      if (v45)
      {
        goto LABEL_129;
      }

      v46 = v32 - 5;
      v47 = (v32 - 5) < a2 || v46 > v43;
      v48 = v47 || v25;
      if (v48)
      {
        goto LABEL_129;
      }

      v49 = v32 - 6;
      v50 = (v32 - 6) < a2 || v49 > v46;
      v51 = v50 || v28;
      if (v51)
      {
        goto LABEL_129;
      }

      v52 = vaddvq_s32(vmull_s16(vrev64_s16(*v43), *a4)) + a4[1].i16[0] * *v46 + a4[1].i16[1] * *v49;
      if (a7 >= 7)
      {
        v53 = a4 + 2;
        v54 = v30;
        for (i = 6; i < a7; i += 2)
        {
          v56 = (v54 + 2);
          v57 = (v54 + 1) < a2 || v56 > a3;
          if (v57 || (v54 + 1) > v56)
          {
            goto LABEL_129;
          }

          v59 = &v53[-1] + 2;
          if (&v53[-1].u8[4] < a4)
          {
            goto LABEL_129;
          }

          v60 = &v53[-1] + 6;
          if (&v53[-1] + 6 > a5)
          {
            goto LABEL_129;
          }

          if (v59 > v60)
          {
            goto LABEL_129;
          }

          if (v54 < a2)
          {
            goto LABEL_129;
          }

          v61 = v54[1];
          if ((v54 + 1) > a3 || v54 > v54 + 1 || v60 < a4 || v53 > a5 || v60 > v53)
          {
            goto LABEL_129;
          }

          v62 = *v54;
          v54 -= 2;
          v52 += *v59 * v61 + v53[-1].i16[3] * v62;
          v53 = (v53 + 4);
        }
      }

      if ((v32 + 1) > a3)
      {
        goto LABEL_129;
      }

      if (v32 > v32 + 1)
      {
        goto LABEL_129;
      }

      v63 = &a1[2 * v31];
      if (v63 < a1 || v63 + 2 > &a1[2 * a6] || v63 > v63 + 2)
      {
        goto LABEL_129;
      }

      v64 = ((((*v32 << 12) - v52) >> 11) + 1) >> 1;
      if (v64 <= -32768)
      {
        v64 = -32768;
      }

      if (v64 >= 0x7FFF)
      {
        LOWORD(v64) = 0x7FFF;
      }

      *v63 = v64;
      ++v31;
      v30 += 2;
      if (v31 == a6)
      {
        goto LABEL_127;
      }
    }
  }

  v29 = a7;
LABEL_127:
  v65 = 2 * v29;
  if (2 * v29 > (2 * a6) || (bzero(a1, 2 * v29), &a1[v65] < a1))
  {
LABEL_129:
    __break(0x5519u);
  }
}

unint64_t silk_interpolate(unint64_t result, unint64_t a2, unint64_t a3, __int16 a4, int a5)
{
  if (a5 >= 1)
  {
    v5 = 0;
    while (1)
    {
      v6 = (a2 + v5);
      v7 = a2 + v5 + 2;
      v8 = a2 + v5 < a2 || v7 > a2 + 32;
      if (v8 || v6 > v7)
      {
        break;
      }

      v10 = (a3 + v5);
      if (a3 + v5 < a3)
      {
        break;
      }

      if ((v10 + 1) > a3 + 32)
      {
        break;
      }

      if (v10 > v10 + 1)
      {
        break;
      }

      v11 = (result + v5);
      if (result + v5 < result || (v11 + 1) > result + 32 || v11 > v11 + 1)
      {
        break;
      }

      *v11 = *v6 + ((a4 * (*v10 - *v6)) >> 2);
      v5 += 2;
      if (2 * a5 == v5)
      {
        return result;
      }
    }

    __break(0x5519u);
  }

  return result;
}

int *silk_NLSF2A_find_poly(int *result, unint64_t a2, int *a3, unint64_t a4, int a5)
{
  v5 = result + 1;
  v6 = (result + 1) <= a2 && v5 >= result;
  if (!v6 || (*result = 0x10000, (a3 + 1) > a4) || a3 + 1 < a3 || (result + 2) > a2 || v5 > result + 2)
  {
LABEL_47:
    __break(0x5519u);
    return result;
  }

  *v5 = -*a3;
  if (a5 >= 2)
  {
    v7 = 2;
    v8 = 1;
    while (1)
    {
      v9 = &a3[2 * v8];
      v10 = v9 + 1;
      v11 = v9 < a3 || v10 > a4;
      if (v11 || v9 > v10)
      {
        goto LABEL_47;
      }

      v13 = &result[v8];
      if (v13 - 1 < result)
      {
        goto LABEL_47;
      }

      v14 = v8 + 1;
      v15 = &result[v8 + 1];
      if (v15 < result || (v15 + 1) > a2 || v15 > v15 + 1)
      {
        goto LABEL_47;
      }

      v16 = *v9;
      *v15 = 2 * *(v13 - 1) - ((((*v13 * v16) >> 15) + 1) >> 1);
      if (v8 >= 2)
      {
        v17 = v7;
        do
        {
          v18 = &result[--v17];
          v19 = (v18 - 1);
          v20 = v18 - 2 < result || v19 > a2;
          v21 = v20 || (v18 - 2) > v19;
          v22 = v21 || v18 > a2;
          v23 = v22 || v19 > v18;
          v24 = v18 + 1;
          v25 = v23 || v24 > a2;
          if (v25 || v18 > v24)
          {
            goto LABEL_47;
          }

          *v18 = *v18 + *(v18 - 2) - ((((*(v18 - 1) * v16) >> 15) + 1) >> 1);
        }

        while (v17 > 2);
      }

      *v5 -= v16;
      ++v7;
      v8 = v14;
      if (v14 == a5)
      {
        return result;
      }
    }
  }

  return result;
}

int *silk_bwexpander_32(int *result, int a2, int a3)
{
  v3 = &result[a2];
  if (a2 < 2)
  {
LABEL_7:
    v7 = &result[a2 - 1];
    if (v7 >= result && (v7 + 1) <= v3 && v7 <= v7 + 1)
    {
      *v7 = (*v7 * a3) >> 16;
      return result;
    }
  }

  else
  {
    v4 = a3 - 0x10000;
    v5 = result;
    v6 = (a2 - 1);
    while (v5 >= result && (v5 + 1) <= v3 && v5 <= v5 + 1)
    {
      *v5 = (*v5 * a3) >> 16;
      ++v5;
      a3 += (((a3 * v4) >> 15) + 1) >> 1;
      if (!--v6)
      {
        goto LABEL_7;
      }
    }
  }

  __break(0x5519u);
  return result;
}

unsigned int *silk_A2NLSF_eval_poly(unsigned int *result, unint64_t a2, int a3, unsigned int a4)
{
  v4 = &result[a4];
  v5 = v4 + 1;
  if (v4 >= result && v5 <= a2 && v4 < v5)
  {
    v8 = *v4;
    v9 = 16 * a3;
    if (a4 == 8)
    {
      if ((result + 8) <= a2 && (result + 7) <= a2)
      {
        return (*result + (((result[1] + (((result[2] + (((result[3] + (((result[4] + (((result[5] + (((result[6] + (((result[7] + ((v8 * v9) >> 16)) * v9) >> 16)) * v9) >> 16)) * v9) >> 16)) * v9) >> 16)) * v9) >> 16)) * v9) >> 16)) * v9) >> 16));
      }
    }

    else
    {
      if (a4 < 1)
      {
        return v8;
      }

      v10 = a4 + 1;
      for (i = &result[a4 - 1]; i >= result && (i + 1) <= a2 && i <= i + 1; --i)
      {
        v12 = *i;
        v8 = v12 + ((v9 * v8) >> 16);
        if (--v10 <= 1)
        {
          return v8;
        }
      }
    }
  }

  __break(0x5519u);
  return result;
}

uint64_t silk_stereo_find_predictor(int *a1, unint64_t a2, __int16 *a3, int *a4, unsigned int a5, int a6)
{
  v10 = a2;
  v67 = -1431655766;
  v68 = -1431655766;
  v65 = -1431655766;
  v66 = -1431655766;
  silk_sum_sqr_shift(&v66, &v68, a2, a5);
  silk_sum_sqr_shift(&v65, &v67, a3, a5);
  v12 = 0;
  if (v68 <= v67)
  {
    v13 = v67;
  }

  else
  {
    v13 = v68;
  }

  v14 = (v13 & 1) + v13;
  v15 = v66 >> (v14 - v68);
  v16 = a5;
  do
  {
    v18 = *v10++;
    v17 = v18;
    v19 = *a3++;
    v12 += (v19 * v17) >> v14;
    --v16;
  }

  while (v16);
  v20 = v65 >> (v14 - v67);
  if (v15 <= 1)
  {
    v21 = 1;
  }

  else
  {
    v21 = v15;
  }

  if (v12 >= 0)
  {
    v22 = v12;
  }

  else
  {
    v22 = -v12;
  }

  v23 = __clz(v22);
  v24 = v12 << (v23 - 1);
  v25 = __clz(v21);
  v26 = v21 << (v25 - 1);
  v27 = (0x1FFFFFFF / (v26 >> 16) * v24) >> 16;
  v28 = ((0x1FFFFFFF / (v26 >> 16) * (v24 - (((v27 * v26) >> 29) & 0xFFFFFFF8))) >> 16) + v27;
  v29 = v23 - v25;
  if ((v29 + 16) >= 0x20)
  {
    v30 = 0;
  }

  else
  {
    v30 = v28 >> (v29 + 16);
  }

  v31 = 0x80000000 >> (-16 - v29);
  if (v31 <= v28)
  {
    v31 = v28;
  }

  if ((0x7FFFFFFFu >> (-16 - v29)) >= v28)
  {
    v32 = v31;
  }

  else
  {
    v32 = 0x7FFFFFFFu >> (-16 - v29);
  }

  v33 = v32 << (-16 - v29);
  if (v29 <= -17)
  {
    v34 = v33;
  }

  else
  {
    v34 = v30;
  }

  if (v34 <= -16384)
  {
    v34 = -16384;
  }

  if (v34 >= 0x4000)
  {
    result = 0x4000;
  }

  else
  {
    result = v34;
  }

  v36 = (result * result) >> 16;
  if ((v36 & 0x80000000) == 0)
  {
    v37 = (result * result) >> 16;
  }

  else
  {
    v37 = -v36;
  }

  if (a6 <= v37)
  {
    v38 = v37;
  }

  else
  {
    v38 = a6;
  }

  v39 = v14 >> 1;
  LOBYTE(v40) = v21;
  if (v25 != 24)
  {
    v40 = v21 << (v25 - 24);
    if (v15 > 127)
    {
      LOBYTE(v40) = (v21 << (v25 + 8)) | (v21 >> (24 - v25));
    }
  }

  if (v25)
  {
    v41 = 0x8000;
  }

  else
  {
    v41 = 46214;
  }

  v42 = *a4 + ((v38 * ((((v41 >> (v25 >> 1)) + ((213 * (v41 >> (v25 >> 1)) * (v40 & 0x7F)) >> 16)) << v39) - *a4)) >> 16);
  *a4 = v42;
  v43 = v20 - (((result * v12) >> 12) & 0xFFFFFFF0) + (((v36 * v21) >> 10) & 0xFFFFFFC0);
  if (v43 < 1)
  {
    v49 = 0;
  }

  else
  {
    v44 = __clz(v43);
    if (v44 != 24)
    {
      v45 = v43 > 0x7F;
      v46 = (v43 << (v44 + 8)) | (v43 >> (24 - v44));
      v43 <<= v44 - 24;
      if (v45)
      {
        LOBYTE(v43) = v46;
      }
    }

    v47 = v43 & 0x7F;
    if (v44)
    {
      v48 = 0x8000;
    }

    else
    {
      v48 = 46214;
    }

    v49 = (v48 >> (v44 >> 1)) + ((213 * (v48 >> (v44 >> 1)) * v47) >> 16);
  }

  v50 = a4[1] + ((v38 * ((v49 << v39) - a4[1])) >> 16);
  a4[1] = v50;
  if (v42 <= 1)
  {
    v51 = 1;
  }

  else
  {
    v51 = v42;
  }

  if (v50 >= 0)
  {
    v52 = v50;
  }

  else
  {
    v52 = -v50;
  }

  v53 = __clz(v52);
  v54 = v50 << (v53 - 1);
  v55 = __clz(v51);
  v56 = v51 << (v55 - 1);
  v57 = (0x1FFFFFFF / (v56 >> 16) * v54) >> 16;
  v58 = ((0x1FFFFFFF / (v56 >> 16) * (v54 - (((v57 * v56) >> 29) & 0xFFFFFFF8))) >> 16) + v57;
  v59 = v53 - v55;
  if (v53 - v55 + 15 >= 0x20)
  {
    v60 = 0;
  }

  else
  {
    v60 = v58 >> (v59 + 15);
  }

  v61 = 0x80000000 >> (-15 - v59);
  if (v61 <= v58)
  {
    v61 = v58;
  }

  if ((0x7FFFFFFFu >> (-15 - v59)) >= v58)
  {
    v62 = v61;
  }

  else
  {
    v62 = 0x7FFFFFFFu >> (-15 - v59);
  }

  v63 = v62 << (-15 - v59);
  if (v59 > -16)
  {
    v63 = v60;
  }

  v64 = v63 & ~(v63 >> 31);
  if (v64 >= 0x7FFF)
  {
    v64 = 0x7FFF;
  }

  *a1 = v64;
  return result;
}

_DWORD *silk_stereo_quant_pred(_DWORD *result, uint64_t a2)
{
  v2 = 0;
  v3 = 0;
  v4 = 1;
  do
  {
    v5 = 0;
    v6 = v4;
    v7 = (a2 + 3 * v2);
    v8 = 0x7FFFFFFF;
    v9 = -13732;
    while (1)
    {
      v10 = silk_stereo_pred_quant_Q13[v5 + 1];
      v11 = (6554 * (v10 - v9)) >> 16;
      v12 = v11 + v9;
      v13 = result[v2] - v12;
      if (v13 < 0)
      {
        v13 = v12 - result[v2];
      }

      if (v13 >= v8)
      {
        LOBYTE(v5) = *v7;
        goto LABEL_27;
      }

      *v7 = v5;
      v7[1] = 0;
      v3 = 3 * v11 + v9;
      if (result[v2] - v3 >= 0)
      {
        v14 = result[v2] - v3;
      }

      else
      {
        v14 = v3 - result[v2];
      }

      if (v14 >= v13)
      {
        v3 = v11 + v9;
        goto LABEL_27;
      }

      v7[1] = 1;
      if (result[v2] - (5 * v11 + v9) >= 0)
      {
        v15 = result[v2] - (5 * v11 + v9);
      }

      else
      {
        v15 = 5 * v11 + v9 - result[v2];
      }

      if (v15 >= v14)
      {
        goto LABEL_27;
      }

      v7[1] = 2;
      v16 = v9 - v11 + 8 * v11;
      if (result[v2] - v16 >= 0)
      {
        v17 = result[v2] - v16;
      }

      else
      {
        v17 = v16 - result[v2];
      }

      if (v17 >= v15)
      {
        v3 = 5 * v11 + v9;
        goto LABEL_27;
      }

      v3 = v12 + 8 * v11;
      v7[1] = 3;
      v8 = result[v2] - v3;
      if (v8 < 0)
      {
        v8 = v3 - result[v2];
      }

      if (v8 >= v17)
      {
        break;
      }

      ++v5;
      v9 = v10;
      v7[1] = 4;
      if (v5 == 15)
      {
        LOBYTE(v5) = 14;
        goto LABEL_27;
      }
    }

    v3 = v9 - v11 + 8 * v11;
LABEL_27:
    v4 = 0;
    v18 = (((86 * v5) >> 15) & 1) + ((86 * v5) >> 8);
    v7[2] = v18;
    *v7 = -3 * v18 + v5;
    result[v2] = v3;
    v2 = 1;
  }

  while ((v6 & 1) != 0);
  if (result + 1 > result + 2 || result + 1 < result)
  {
    __break(0x5519u);
  }

  else
  {
    *result -= result[1];
  }

  return result;
}

unsigned int *silk_sum_sqr_shift(unsigned int *result, int *a2, unint64_t a3, unsigned int a4)
{
  v4 = a4 - 1;
  if (a4 >= 2)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = a3 + 2 * a4;
    while (1)
    {
      v9 = (a3 + v5);
      v10 = a3 + v5 + 2;
      v11 = a3 + v5 < a3 || v10 > v8;
      v12 = v11 || v9 > v10;
      v13 = v9 + 2;
      v14 = !v12 && v10 >= a3;
      v15 = !v14 || v13 > v8;
      if (v15 || v10 > v13)
      {
        goto LABEL_56;
      }

      v17 = v7 + *v9 * *v9;
      v18 = *(a3 + 2 * v6 + 2);
      v7 = v17 + v18 * v18;
      if ((v7 & 0x80000000) != 0)
      {
        v7 >>= 2;
        LODWORD(v6) = v6 + 2;
        v19 = 2;
        goto LABEL_24;
      }

      v6 += 2;
      v5 += 4;
      if (v4 <= v6)
      {
        v19 = 0;
        goto LABEL_24;
      }
    }
  }

  v7 = 0;
  v19 = 0;
  LODWORD(v6) = 0;
LABEL_24:
  if (v6 < v4)
  {
    v20 = a3 + 2 * a4;
    v21 = v6;
    v22 = (a3 + 2 * v6 + 2);
    while (1)
    {
      v23 = (v22 - 1) < a3 || v22 > v20;
      v24 = v23 || v22 - 1 >= v22;
      v25 = v22 + 1;
      v26 = v24 || v25 > v20;
      if (v26 || v22 >= v25)
      {
        goto LABEL_56;
      }

      v7 += (*(v22 - 1) * *(v22 - 1) + *v22 * *v22) >> v19;
      v28 = (v7 & 0x80000000) != 0;
      if ((v7 & 0x80000000) != 0)
      {
        v7 >>= 2;
      }

      if (v28)
      {
        v19 += 2;
      }

      v21 += 2;
      v22 += 2;
      if (v21 >= v4)
      {
        LODWORD(v6) = v21;
        break;
      }
    }
  }

  if (v6 == v4)
  {
    v29 = (a3 + 2 * v4);
    if (v29 < a3 || (v29 + 1) > a3 + 2 * a4 || v29 > v29 + 1)
    {
LABEL_56:
      __break(0x5519u);
      return result;
    }

    v7 += (*v29 * *v29) >> v19;
  }

  v30 = v7 >> 30;
  if (v7 >> 30)
  {
    v7 >>= 2;
  }

  if (v30)
  {
    v31 = v19 + 2;
  }

  else
  {
    v31 = v19;
  }

  *a2 = v31;
  *result = v7;
  return result;
}

unint64_t opus_repacketizer_cat_impl(unint64_t result, unsigned __int8 *a2, int a3)
{
  if (a3 < 1)
  {
    return 4294967292;
  }

  v5 = result;
  v6 = *(result + 4);
  if (v6)
  {
    v7 = *a2;
    if ((*a2 ^ *result) > 3u)
    {
      return 4294967292;
    }
  }

  else
  {
    v8 = *a2;
    *v5 = *a2;
    result = opus_packet_get_samples_per_frame(v8, 8000);
    *(v5 + 872) = result;
    v7 = *a2;
  }

  v9 = v7 & 3;
  if (v9)
  {
    if (v9 == 3)
    {
      if (a3 == 1)
      {
        return 4294967292;
      }

      if (a2 + 1 >= &a2[a3])
      {
LABEL_21:
        __break(0x5519u);
        return result;
      }

      v10 = a2[1] & 0x3F;
      if ((a2[1] & 0x3F) == 0)
      {
        return 4294967292;
      }
    }

    else
    {
      v10 = 2;
    }
  }

  else
  {
    v10 = 1;
  }

  if ((v6 + v10) * *(v5 + 872) > 960)
  {
    return 4294967292;
  }

  v11 = (v5 + 8 + 16 * v6);
  if (v11 < v5 + 8)
  {
    goto LABEL_21;
  }

  v12 = (v5 + 776 + 2 * v6);
  if (v12 < v5 + 776)
  {
    goto LABEL_21;
  }

  result = opus_packet_parse_impl(a2, a3, &v13, v11, v5 + 776, v12, v5 + 872, 0);
  if (result >= 1)
  {
    result = 0;
    *(v5 + 4) += v10;
  }

  return result;
}

uint64_t optimize_framesize(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, uint64_t a7, int a8)
{
  v139 = a6;
  LODWORD(v144) = a4;
  v143 = a2;
  v129[1] = v129;
  v165 = *MEMORY[0x1E69E9840];
  v12 = (a5 / 400);
  MEMORY[0x1EEE9AC00](a1);
  v14 = (v129 - v13);
  v142 = v15;
  if ((v15 + 399) >= 0x31F)
  {
    memset(v14, 255, 4 * v12);
  }

  *&v16 = -1;
  *(&v16 + 1) = -1;
  *&v160[12] = v16;
  *v160 = v16;
  v159 = v16;
  v158 = v16;
  v157 = v16;
  v156 = v16;
  v155 = v16;
  v147 = v16;
  v148 = v16;
  v149 = v16;
  v150 = v16;
  v151 = v16;
  v152 = v16;
  v153 = -1;
  v154 = *a7;
  v146 = 1.0 / (v154 + 1.0e-15);
  if (a8)
  {
    v141 = (2 * v12 - a8);
    a3 -= v141;
    *&v155 = *(a7 + 4);
    __asm { FMOV            V1.2S, #1.0 }

    *&v147 = vdiv_f32(_D1, vadd_f32(*&v155, vdup_n_s32(0x26901D7Du)));
    v21 = 3;
  }

  else
  {
    v141 = 0;
    v21 = 1;
  }

  v130 = a8;
  v131 = a7;
  v132 = v161;
  v22 = a3 / v12;
  if (a3 / v12 >= 24)
  {
    v23 = 24;
  }

  else
  {
    v23 = v22;
  }

  v145 = v23;
  LODWORD(v140) = a3 / v12;
  if (v22 < 1)
  {
    v40 = 0;
  }

  else
  {
    v24 = 0;
    v26 = v14 + 1 <= &v14[v12] && v14 < v14 + 1;
    LODWORD(v138) = v21;
    v27 = v21;
    v28 = 0.0;
    do
    {
      v163[0] = a1;
      v163[1] = v143;
      v163[2] = a1;
      if (!v26)
      {
        goto LABEL_179;
      }

      downmix_float(v163, v14, v12, v141 + v24 * v12, 0, 0xFFFFFFFE, v144);
      if (!v24)
      {
        v28 = *v14;
      }

      if (v142 < 400)
      {
        v32 = 1.0e-15;
      }

      else
      {
        v29 = v14;
        v30 = v12;
        v31 = v28;
        v32 = 1.0e-15;
        do
        {
          v33 = *v29++;
          v28 = v33;
          v32 = v32 + ((v33 - v31) * (v33 - v31));
          v31 = v33;
          --v30;
        }

        while (v30);
      }

      v34 = v24 + v27;
      v35 = &v154 + v24 + v27;
      v36 = v35 + 1;
      v37 = v35 < &v154 || v36 > v132;
      if (v37 || v35 >= v36)
      {
        goto LABEL_179;
      }

      *(&v154 + v34) = v32;
      v39 = &v146 + v34;
      if (v39 < &v146 || v39 + 1 > &v154 || v39 > v39 + 1)
      {
        goto LABEL_179;
      }

      *v39 = 1.0 / v32;
      v24 = (v24 + 1);
    }

    while (v24 != v145);
    v40 = v145;
    v21 = v138;
  }

  v41 = &v154 + v40 + v21;
  if (v41 - 1 < &v154 || v41 > v132 || v41 - 1 > v41 || v41 + 1 > v132 || v41 > v41 + 1)
  {
    goto LABEL_179;
  }

  *v41 = *(v41 - 1);
  v42 = v140 >= 22 ? 22 : v140;
  v43 = v42 + 2;
  v44 = v130 ? v43 : v145;
  if ((v44 & 0x80000000) != 0)
  {
    goto LABEL_179;
  }

  v45 = v139 / 400;
  v46 = 0.0;
  if (v139 >= 32000)
  {
    v46 = 1.0;
    if (v45 <= 0xA0)
    {
      v46 = (v45 + -80.0) / 80.0;
    }
  }

  v142 = (60 * v144 + 40);
  LODWORD(v143) = v139 / 400;
  memset(v164, 255, sizeof(v164));
  memset(v162, 170, sizeof(v162));
  *&v47 = -1;
  *(&v47 + 1) = -1;
  v161[0] = v47;
  v161[1] = v47;
  v161[2] = v47;
  v161[3] = v47;
  memset_pattern16(v163, &unk_19B0B39F0, 0x40uLL);
  v48 = 0;
  v144 = &v146 + v44;
  v145 = &v154 + v44;
  v134 = v44;
  do
  {
    v49 = (1 << v48);
    transient_boost(&v154, v145, &v146, v144, v48, v44 + 1);
    v51 = v163 + 4 * v49;
    v52 = v51 + 4;
    if (v51 < v163 || v52 > v164 || v51 >= v52)
    {
      goto LABEL_179;
    }

    *(v163 + v49) = ((v46 * v50) + 1.0) * ((v143 << v48) + v142);
    v55 = v161 + v49;
    v56 = v55 + 1;
    v57 = v55 < v161 || v56 > v162;
    if (v57 || v55 >= v56)
    {
      goto LABEL_179;
    }

    *v55 = v48++;
    LODWORD(v44) = v134;
  }

  while (v48 != 4);
  if (v134 >= 2)
  {
    v141 = v163;
    v140 = v161;
    v59 = 1;
    do
    {
      v60 = 0;
      v61 = &v163[8 * v59];
      v62 = v61 - 16;
      v63 = (v61 + 16);
      v133 = v59;
      v64 = &v161[4 * v59];
      v65 = v64 + 16;
      v66 = 1;
      do
      {
        v67 = (v141 + v60);
        v68 = (v141 + v60 + 4);
        v69 = v141 + v60 + 8;
        v71 = v68 < v62 || v69 > v61 || v68 > v69;
        v72 = (v67 + 72);
        v73 = (v67 + 76);
        if (v71 || v72 < v61 || v73 > v63 || v72 > v73)
        {
          goto LABEL_179;
        }

        *v72 = *v68;
        v77 = (v140 + v60 + 72);
        if (v77 < v64)
        {
          goto LABEL_179;
        }

        v78 = v140 + v60 + 76;
        if (v78 > v65 || v77 > v78)
        {
          goto LABEL_179;
        }

        *v77 = v66;
        v60 += 4;
        ++v66;
      }

      while (v60 != 56);
      v79 = 0;
      v80 = (v61 - 15);
      v81 = v61 < 0x38 || v80 > (v61 - 14);
      v138 = v61 - 15;
      v83 = !v81 && v80 >= v62;
      v139 = v83;
      v84 = v134 - v133;
      v135 = &v146 + v133;
      v136 = &v154 + v133;
      v86 = v136 < &v154 || &v146 + v133 < &v146;
      v137 = v86;
      do
      {
        v87 = (1 << v79);
        v88 = &v64[v87];
        v89 = v88 + 1;
        if (v88 < v64 || v89 > v65 || v88 >= v89)
        {
          goto LABEL_179;
        }

        *v88 = 1;
        if (!v139)
        {
          goto LABEL_179;
        }

        v92 = *v138;
        for (i = 1; i != 4; ++i)
        {
          v94 = (2 << i) - 1;
          v95 = &v62[v94];
          v96 = v95 + 1;
          if (v95 < v62 || v96 > v61 || v95 >= v96)
          {
            goto LABEL_179;
          }

          v99 = *v95;
          if (*v95 < v92)
          {
            *v88 = v94;
            v92 = v99;
          }
        }

        if (v137)
        {
          goto LABEL_179;
        }

        transient_boost(v136, v145, v135, v144, v79, v84 + 1);
        v101 = &v61[v87];
        if (v101 < v61 || (v101 + 1) > v63 || v101 > v101 + 1)
        {
          goto LABEL_179;
        }

        v102 = ((v46 * v100) + 1.0) * ((v143 << v79) + v142);
        if (v84 < v87)
        {
          v102 = (v102 * v84) / v87;
        }

        *v101 = v92 + v102;
        ++v79;
      }

      while (v79 != 4);
      LODWORD(v44) = v134;
      v59 = v133 + 1;
      v140 += 4;
      v141 += 64;
    }

    while (v133 + 1 != v134);
  }

  v103 = v44 - 1;
  v104 = &v163[8 * v103];
  v105 = v104 + 1;
  if (v104 + 1 < v104 || v104 + 2 > v104 + 16 || v105 > v104 + 2)
  {
LABEL_179:
    __break(0x5519u);
  }

  v106 = *v105;
  v107 = v103 << 6;
  LODWORD(result) = 1;
  for (j = 2; j != 16; ++j)
  {
    v110 = (&v163[1] + v107);
    v111 = (&v163[1] + v107 + 4);
    if (v110 < v104 || v111 > v104 + 16 || v110 > v111)
    {
      goto LABEL_179;
    }

    if (*v110 >= v106)
    {
      result = result;
    }

    else
    {
      result = j;
    }

    if (*v110 < v106)
    {
      v106 = *v110;
    }

    v107 += 4;
  }

  LODWORD(v114) = v134;
  if (v134)
  {
    do
    {
      v114 = (v114 - 1);
      v115 = &v161[4 * v114];
      v116 = &v115[result];
      v117 = (v116 + 1);
      v118 = v116 < v115 || v117 > (v115 + 16);
      if (v118 || v116 >= v117)
      {
        goto LABEL_179;
      }

      result = *v116;
    }

    while (v114 > 0);
  }

  v120 = &v154 + (1 << result);
  v121 = v120 + 1;
  if (v120 < &v154 || v121 > v132 || v120 >= v121)
  {
    goto LABEL_179;
  }

  *v131 = *v120;
  if (v130)
  {
    v124 = v120 + 2;
    if (v120 + 2 > v132 || v121 > v124)
    {
      goto LABEL_179;
    }

    v126 = v132;
    v131[1] = *(v120 + 1);
    v127 = v120 + 3;
    if (v127 > v126 || v124 > v127)
    {
      goto LABEL_179;
    }

    v131[2] = *v124;
  }

  return result;
}

float *transient_boost(float *result, unint64_t a2, float *a3, unint64_t a4, char a5, int a6)
{
  if ((1 << a5) + 1 < a6)
  {
    v6 = (1 << a5) + 1;
  }

  else
  {
    v6 = a6;
  }

  v7 = 0.0;
  if (a6 >= 1)
  {
    if (v6 <= 1)
    {
      v8 = 1;
    }

    else
    {
      v8 = v6;
    }

    v9 = result;
    v10 = a3;
    v11 = 0.0;
    while (v9 >= result && (v9 + 1) <= a2 && v9 <= v9 + 1 && v10 >= a3 && (v10 + 1) <= a4 && v10 <= v10 + 1)
    {
      v12 = *v9++;
      v7 = v7 + v12;
      v13 = *v10++;
      v11 = v11 + v13;
      if (!--v8)
      {
        return result;
      }
    }

    __break(0x5519u);
  }

  return result;
}

void silk_init_decoder(_DWORD *a1)
{
  bzero(a1, 0x10E0uLL);
  if (a1 + 1080 < a1)
  {
    __break(0x5519u);
  }

  else
  {
    a1[594] = 1;
    *a1 = 0x10000;
    silk_CNG_Reset(a1);
    a1[1056] = a1[582] << 7;
    *(a1 + 537) = 0x1000000010000;
    *(a1 + 1077) = 0x1400000002;
  }
}

void celt_decode_lost(uint64_t a1)
{
  v1 = MEMORY[0x1EEE9AC00](a1);
  LODWORD(v275) = v3;
  v4 = 0;
  *v289 = *MEMORY[0x1E69E9840];
  v5 = *(v1 + 12);
  *&v6 = 0xAAAAAAAAAAAAAAAALL;
  *(&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v287[1] = v6;
  v287[2] = v6;
  v286[2] = v6;
  v287[0] = v6;
  v286[0] = v6;
  v286[1] = v6;
  v7 = *v1;
  v259 = *v1 + 224;
  v8 = *(v7 + 4);
  v9 = *(v7 + 8);
  v262 = v8;
  v263 = v8;
  v11 = *(v7 + 32);
  v10 = *(v7 + 40);
  v257 = v7;
  v274 = v10;
  v270 = v288;
  v267 = v2;
  v268 = v1;
  v258 = -v2;
  LODWORD(v264) = v5;
  if (v5 <= 1)
  {
    v12 = 1;
  }

  else
  {
    v12 = v5;
  }

  v271 = v12;
  v13 = 8 * (v12 + 2 * v12);
  v265 = v2;
  v14 = 0x2000 - 4 * v2;
  v15 = 0;
  do
  {
    v16 = v287 + v15;
    v17 = &v287[1] + v15 + 8;
    if ((v287 + v15) < v287 || v17 > v270 || v16 > v17)
    {
      goto LABEL_344;
    }

    v20 = *(v268 + 40);
    v21 = v20 + 4 * *(v268 + 88);
    *v16 = v20 + v4;
    *(v16 + 1) = v21;
    *(v16 + 2) = v20;
    v22 = v286 + v15;
    if ((v286 + v15) < v286 || v22 + 24 > v287 || v22 > v22 + 24)
    {
      goto LABEL_344;
    }

    v23 = v20 + v14 + v4;
    v24 = (v286 + v15);
    *v24 = v23;
    v24[1] = v21;
    v24[2] = v20;
    v15 += 24;
    v4 += 4 * (v8 + 2048);
  }

  while (v13 != v15);
  v25 = *(v268 + 96);
  v277 = *(v268 + 56);
  v26 = *(v268 + 108);
  v27 = *(v268 + 80);
  v28 = *(v268 + 24);
  v261 = *(v268 + 124);
  if (v261 <= 4 && !v28 && !*(v268 + 128))
  {
    v92 = *(v268 + 92);
    v260 = *(v268 + 48);
    if (v261)
    {
      v266 = *(v268 + 120);
      v93 = 0.8;
    }

    else
    {
      LODWORD(v278) = -1431655766;
      memset(v288, 255, sizeof(v288));
      pitch_downsample(v287, v288, v289, 0x800u, v264);
      v23 = pitch_search(&v288[90], v289, v288[0].f32, v289, 0x530u, 0x26Cu, &v278);
      v266 = 720 - v278;
      *(v268 + 120) = 720 - v278;
      v93 = 1.0;
    }

    v238 = &v234;
    v94 = 4 * v262;
    MEMORY[0x1EEE9AC00](v23);
    v95 = &v234 - ((v94 + 15) & 0x7FFFFFFF0);
    if (v263)
    {
      memset(&v234 - ((v94 + 15) & 0x7FFFFFFF0), 255, v94);
    }

    v264 = v260 + 4 * v92;
    memset(v288, 255, sizeof(v288));
    v96 = 0;
    v259 = 4 * v92 - 92;
    v97 = *(v257 + 96);
    v272 = *(v257 + 104);
    v99 = v262 < 0 || v263 > (v272 - v97) >> 2;
    if (2 * v266 >= 1024)
    {
      v100 = 1024;
    }

    else
    {
      v100 = 2 * v266;
    }

    v101 = &v289[-v100];
    v253 = v101;
    v103 = v289 < v101 || v288 > v101;
    v256 = v103;
    v255 = v266 >= 0;
    LODWORD(v104) = v100 >> 1;
    v275 = 4 * (2048 - v265);
    v245 = 1024 - v266;
    v244 = 1024 - v266 - v265 + 1024;
    v276 = (v262 + v265);
    v277 = v262 + v265;
    v250 = &v95[4 * v262];
    if (v100 >> 1 <= 1)
    {
      v104 = 1;
    }

    else
    {
      v104 = v104;
    }

    v248 = v104;
    v242 = v272 < v97 || v99;
    LODWORD(v257) = 2047 - v100;
    v247 = 1024 - v100;
    v254 = v100;
    v246 = 1024 - (v100 >> 1);
    v252 = 2047 - v265;
    v239 = -4 * v267;
    v243 = 4 * v263;
    v236 = 4 * v263 + 0x2000;
    v237 = 8196 - 4 * v267;
    v235 = 4 * v263 + 8196;
    v249 = (2 * v262) & 0x1FFFFFFFCLL;
    v240 = vdupq_n_s32(0xB88637BE);
    v241 = xmmword_19B0B1640;
    v251 = v94;
    while (1)
    {
      v273 = v96;
      v105 = v287 + 24 * v96;
      v106 = v105 + 24;
      if (v105 < v287 || v106 > v270 || v105 > v106)
      {
        goto LABEL_344;
      }

      v109 = 0;
      v110 = *v105;
      v111 = *(v105 + 1);
      v112 = *v105 + 4096;
      v113 = *(v105 + 2);
      v114 = *v105 + 4100;
      do
      {
        v115 = (v112 + v109 * 4);
        if (v114 + v109 * 4 > v111 || v115 > v114 + v109 * 4 || v115 < v113)
        {
          goto LABEL_344;
        }

        v288[0].i32[v109++] = *v115;
      }

      while (v109 != 1024);
      v118 = 3 * v273;
      if (!v261)
      {
        v284 = -1;
        *&v119 = -1;
        *(&v119 + 1) = -1;
        v282 = v119;
        v283 = v119;
        v280 = v119;
        v281 = v119;
        v278 = v119;
        v279 = v119;
        if (v242)
        {
          goto LABEL_344;
        }

        _celt_autocorr(v288, &v278, v285, v97, v262, 0x18u, 0x400u);
        *&v278 = *&v278 * 1.0001;
        v120 = 4;
        v122 = v240;
        v121 = v241;
        v123.i64[0] = 0x400000004;
        v123.i64[1] = 0x400000004;
        do
        {
          v124 = vcvtq_f32_u32(v121);
          *(&v278 + v120) = vmlaq_f32(*(&v278 + v120), v124, vmulq_f32(vmulq_f32(*(&v278 + v120), v122), v124));
          v121 = vaddq_s32(v121, v123);
          v120 += 16;
        }

        while (v120 != 100);
        v125 = (v260 + 32 * v118);
        v126 = v125 > v264 || v260 > v125;
        if (v126 || 32 * v118 >= v259)
        {
          goto LABEL_344;
        }

        _celt_lpc(v125, &v278, v285, 0x18u);
      }

      v128 = 0;
      *&v129 = -1;
      *(&v129 + 1) = -1;
      v282 = v129;
      v283 = v129;
      v280 = v129;
      v281 = v129;
      v130 = v257;
      v278 = v129;
      v279 = v129;
      do
      {
        v131 = &v110[v130];
        if ((v131 + 1) > v111 || v131 > v131 + 1 || v131 < v113)
        {
          goto LABEL_344;
        }

        *(&v278 + v128) = *v131;
        v128 += 4;
        --v130;
      }

      while (v128 != 96);
      if (v256)
      {
        goto LABEL_344;
      }

      v134 = (v260 + 32 * v118);
      v274 = v134;
      v135 = v134 > v264 || v260 > v134;
      v136 = v255;
      if (v135)
      {
        v136 = 0;
      }

      if (!v136 || 32 * v118 >= v259)
      {
        goto LABEL_344;
      }

      celt_fir_c(v253, v274, v253, v254, &v278);
      if (v266)
      {
        v138 = 1.0;
        v139 = v246;
        v140 = v247;
        v141 = v248;
        v142 = 1.0;
        do
        {
          v143 = &v288[0].f32[v139];
          v144 = v143 + 1;
          v146 = v143 < v288 || v144 > v289 || v143 > v144;
          v147 = &v288[0].f32[v140];
          v148 = v147 + 1;
          if (v146 || v147 < v288 || v148 > v289 || v147 > v148)
          {
            goto LABEL_344;
          }

          v138 = v138 + (*v143 * *v143);
          v142 = v142 + (*v147 * *v147);
          ++v140;
          ++v139;
          --v141;
        }

        while (v141);
      }

      else
      {
        v142 = 1.0;
        v138 = 1.0;
      }

      if (v138 >= v142)
      {
        v152 = v142;
      }

      else
      {
        v152 = v138;
      }

      v153 = &v110[v267];
      if (v153 > v111)
      {
        goto LABEL_344;
      }

      if (v113 > v153)
      {
        goto LABEL_344;
      }

      if (v275 > v111 - v153)
      {
        goto LABEL_344;
      }

      if (v110 > v111)
      {
        goto LABEL_344;
      }

      if (v113 > v110)
      {
        goto LABEL_344;
      }

      if (v275 > v111 - v110)
      {
        goto LABEL_344;
      }

      v154 = v275;
      memmove(v110, v153, v275);
      v155 = (v110 + v154);
      if (v110 > v155)
      {
        goto LABEL_344;
      }

      v156 = v276;
      if (v277 < 1)
      {
        v160 = 0.0;
      }

      else
      {
        v157 = 0;
        v158 = sqrtf(v152 / v142);
        v159 = v93 * v158;
        v160 = 0.0;
        v161 = v155;
        v162 = v266;
        v164 = v244;
        v163 = v245;
        do
        {
          if (v157 >= v162)
          {
            v165 = v162;
          }

          else
          {
            v165 = 0;
          }

          if (v157 >= v162)
          {
            v159 = v158 * v159;
          }

          v166 = v157 - v165;
          v167 = &v288[0].f32[v166 + v163];
          v168 = v167 + 1;
          v170 = v167 < v288 || v168 > v289 || v167 > v168;
          v171 = v161 + 1;
          if (v170 || v171 > v111 || v161 > v171 || v161 < v113)
          {
            goto LABEL_344;
          }

          *v161 = v159 * *v167;
          v175 = &v110[v164 + v166];
          v176 = (v175 + 1) > v111 || v175 > v175 + 1;
          if (v176 || v175 < v113)
          {
            goto LABEL_344;
          }

          v160 = v160 + (*v175 * *v175);
          v157 = v166 + 1;
          ++v161;
          --v156;
        }

        while (v156);
      }

      v178 = 0;
      *&v179 = -1;
      *(&v179 + 1) = -1;
      v282 = v179;
      v283 = v179;
      v280 = v179;
      v281 = v179;
      v180 = v252;
      v278 = v179;
      v279 = v179;
      do
      {
        v181 = &v110[v180];
        if ((v181 + 1) > v111 || v181 > v181 + 1 || v181 < v113)
        {
          goto LABEL_344;
        }

        *(&v278 + v178) = *v181;
        v178 += 4;
        --v180;
      }

      while (v178 != 96);
      v269 = (v110 + 2048);
      v184 = &v110[v258 + 2048];
      if (v184 > v111 || v113 > v184 || (v276 & 0x80000000) != 0 || (v111 - v184) >> 2 < v277)
      {
        goto LABEL_344;
      }

      v185 = v276;
      celt_iir(v184, v274, &v110[v258 + 2048], v276, &v278);
      v187 = 0.0;
      if (v277 < 1)
      {
        v190 = v251;
        v191 = v272;
        if (v160 > 0.0)
        {
          goto LABEL_291;
        }
      }

      else
      {
        v188 = v155;
        v189 = v185;
        v190 = v251;
        v191 = v272;
        do
        {
          if ((v188 + 1) > v111 || v188 > v188 + 1 || v188 < v113)
          {
            goto LABEL_344;
          }

          v194 = *v188++;
          v187 = v187 + (v194 * v194);
          --v189;
        }

        while (v189);
        v195 = v276;
        if (v160 > (v187 * 0.2))
        {
LABEL_291:
          if (v160 < v187)
          {
            v198 = sqrtf((v160 + 1.0) / (v187 + 1.0));
            if (v263 >= 1)
            {
              v199 = 0;
              v200 = &v110[v239 / 4];
              v201 = v110 + v237;
              do
              {
                v202 = (v97 + v199);
                v203 = v97 + v199 + 4;
                v205 = v203 <= v191 && v202 <= v203 && v202 >= v97;
                v206 = &v200[v199 / 4 + 2048];
                v207 = &v201[v199];
                if (!v205 || v207 > v111 || v206 > v207 || v206 < v113)
                {
                  goto LABEL_344;
                }

                *v206 = (1.0 - (*v202 * (1.0 - v198))) * *v206;
                v199 += 4;
              }

              while (v190 != v199);
            }

            if (v265 >= 1)
            {
              v211 = &v110[v239 / 4];
              v212 = v235;
              v213 = v236;
              v214 = v263;
              do
              {
                if (v211 + v212 > v111 || v211 + v213 > v211 + v212 || v211 + v213 < v113)
                {
                  goto LABEL_344;
                }

                v211[v214 + 2048] = v198 * v211[v214 + 2048];
                ++v214;
                v213 += 4;
                v212 += 4;
              }

              while (v214 < v277);
            }
          }

          goto LABEL_318;
        }

        do
        {
          if ((v155 + 1) > v111 || v155 > v155 + 1 || v155 < v113)
          {
            goto LABEL_344;
          }

          *v155++ = 0.0;
          --v195;
        }

        while (v195);
      }

LABEL_318:
      if ((v262 & 0x80000000) != 0)
      {
        goto LABEL_344;
      }

      v215 = *(v268 + 148);
      v216 = -*(v268 + 140);
      v217 = *(v268 + 132);
      *&v278 = v269;
      *(&v278 + 1) = v111;
      *&v279 = v113;
      comb_filter(v95, &v278, v217, v217, v263, v215, v215, v186, v216, v216, 0, 0, 0);
      v219 = v249;
      v218 = v250;
      v220 = v272;
      if (v262 >= 2)
      {
        v221 = 0;
        v222 = (v110 + 2049);
        v223 = v243;
        do
        {
          v224 = (v97 + v221);
          v225 = v97 + v221 + 4;
          if (v225 > v220 || v224 > v225 || v224 < v97)
          {
            goto LABEL_344;
          }

          v228 = &v95[v223];
          v229 = &v95[v223 - 4];
          if (v229 < v95)
          {
            goto LABEL_344;
          }

          if (v228 > v218)
          {
            goto LABEL_344;
          }

          if (v229 > v228)
          {
            goto LABEL_344;
          }

          v230 = v97 + v223;
          if (v97 + v223 > v220)
          {
            goto LABEL_344;
          }

          v231 = (v230 - 4);
          if (v230 < 4)
          {
            goto LABEL_344;
          }

          if (v231 < v97)
          {
            goto LABEL_344;
          }

          v232 = &v95[v221];
          if (&v95[v221] < v95)
          {
            goto LABEL_344;
          }

          if ((v232 + 1) > v218)
          {
            goto LABEL_344;
          }

          if (v232 > v232 + 1)
          {
            goto LABEL_344;
          }

          if (&v222[v221] > v111)
          {
            goto LABEL_344;
          }

          v233 = &v110[v221 / 4 + 2048];
          if (v233 > &v222[v221] || v233 < v113)
          {
            goto LABEL_344;
          }

          *v233 = (*v231 * *v232) + (*v224 * *v229);
          v221 += 4;
          v223 -= 4;
        }

        while (v219 != v221);
      }

      v96 = v273 + 1;
      if (v273 + 1 == v271)
      {
        v91 = v268;
        goto LABEL_112;
      }
    }
  }

  v238 = &v234;
  v276 = v277 + 4 * v25;
  v29 = *(v268 + 28);
  LODWORD(v25) = *(v257 + 12);
  if (v29 < v25)
  {
    LODWORD(v25) = *(v268 + 28);
  }

  LODWORD(v263) = v25;
  if (v28 <= v25)
  {
    v25 = v25;
  }

  else
  {
    v25 = v28;
  }

  v260 = v25;
  v30 = (v264 * v265);
  MEMORY[0x1EEE9AC00](v23);
  v33 = (&v234 - v31);
  v269 = v32;
  if (v30)
  {
    memset(&v234 - v31, 255, 4 * v30);
    v32 = v269;
  }

  v273 = 4 * v30;
  v34 = 0;
  v35 = 0.5;
  if (!v261)
  {
    v35 = 1.5;
  }

  v36 = v29 - v32;
  v37 = 4 * v32;
  v38 = 4 * v9;
  v39 = v27;
  v40 = v276;
  v41 = v277;
  do
  {
    if (v32 < v29)
    {
      v42 = v39;
      v43 = v41;
      v44 = v36;
      while (1)
      {
        v45 = (v42 + v37);
        v46 = v42 + v37 + 4;
        v47 = v46 > v27 + 4 * v26 || v45 > v46;
        v48 = !v47 && v45 >= v27;
        v49 = (v43 + v37);
        v50 = v43 + v37 + 4;
        v51 = !v48 || v50 > v40;
        v52 = v51 || v49 > v50;
        if (v52 || v49 < v277)
        {
          break;
        }

        v54 = *v45;
        if (*v45 <= (*v49 - v35))
        {
          v54 = *v49 - v35;
        }

        *v49 = v54;
        v43 += 4;
        v42 += 4;
        if (!--v44)
        {
          goto LABEL_51;
        }
      }

LABEL_344:
      __break(0x5519u);
    }

LABEL_51:
    ++v34;
    v41 += v38;
    v39 += v38;
    v32 = v269;
  }

  while (v34 != v271);
  v55 = *(v268 + 112);
  v56 = &v33[v30];
  if (v264 >= 1)
  {
    LODWORD(v272) = 0;
    v57 = 0;
    v58 = v260;
    while (1)
    {
      v266 = v57;
      if (v263 > v32)
      {
        break;
      }

LABEL_84:
      v57 = v266 + 1;
      LODWORD(v272) = v272 + v265;
      v32 = v269;
      if (v266 + 1 == v264)
      {
        goto LABEL_85;
      }
    }

    v59 = v57 * v265;
    v60 = v32;
    while (1)
    {
      v61 = (v11 + 2 * v60);
      v63 = v61 + 1 <= v274 && v61 <= v61 + 1 && v61 >= v11;
      v64 = (v11 + 2 * ++v60);
      v65 = (v64 + 1);
      if (!v63 || v65 > v274 || v64 > v65 || v64 < v11)
      {
        goto LABEL_344;
      }

      v69 = *v61;
      v70 = v69 << v275;
      v71 = ((*v64 - v69) << v275);
      if (v71 >= 1)
      {
        break;
      }

LABEL_79:
      v74 = v70 + v59;
      v75 = &v33[v74];
      if (v75 > v56 || v33 > v75 || (v71 & 0x80000000) != 0 || (v273 - 4 * v74) >> 2 < v71)
      {
        goto LABEL_344;
      }

      renormalise_vector(v75, v71, 1.0);
      if (v60 == v58)
      {
        goto LABEL_84;
      }
    }

    v72 = &v33[v272 + v70];
    v73 = v71;
    while (v72 >= v33 && (v72 + 1) <= v56 && v72 <= v72 + 1)
    {
      v55 = 1664525 * v55 + 1013904223;
      *v72++ = (v55 >> 20);
      if (!--v73)
      {
        goto LABEL_79;
      }
    }

    goto LABEL_344;
  }

LABEL_85:
  *(v268 + 112) = v55;
  v76 = 4 * ((v262 >> 1) - v265 + 2048);
  v77 = v287;
  do
  {
    v78 = v77 + 24;
    if (v77 < v287 || v78 > v270 || v77 > v78)
    {
      goto LABEL_344;
    }

    v82 = *v77;
    v81 = *(v77 + 1);
    v83 = *(v77 + 2);
    v84 = (*v77 + 4 * v267);
    if (v84 > v81 || v83 > v84)
    {
      goto LABEL_344;
    }

    v86 = v81 - v84;
    v48 = v81 >= v82;
    v87 = v81 - v82;
    v88 = !v48 || v76 > v86;
    v89 = v88 || v83 > v82;
    if (v89 || v76 > v87)
    {
      goto LABEL_344;
    }

    memmove(*v77, v84, v76);
    if (v82 > &v82[v76])
    {
      goto LABEL_344;
    }

    v77 = (v77 + 24);
    --v271;
  }

  while (v271);
  if (v264 > 2 || v257 > v259)
  {
    goto LABEL_344;
  }

  v91 = v268;
  celt_synthesis(v257, v33, v56, v286, v277, v276, v269, v260, v264, v264, 0, v275, *(v268 + 20), 0);
LABEL_112:
  *(v91 + 124) = v261 + 1;
}

float celt_fir_c(int *a1, unint64_t a2, unint64_t a3, int a4, unint64_t a5)
{
  v71 = *MEMORY[0x1E69E9840];
  *&v9 = -1;
  *(&v9 + 1) = -1;
  v68[0] = v9;
  v68[1] = v9;
  v68[2] = v9;
  v68[3] = v9;
  v68[4] = v9;
  v68[5] = v9;
  v10 = (a4 + 24);
  MEMORY[0x1EEE9AC00](a1);
  v13 = &v66 - v12;
  v67 = v11;
  if (v10)
  {
    memset(&v66 - v12, 255, 4 * v10);
    LODWORD(v11) = v67;
  }

  v14 = 0;
  v15 = (a2 + 92);
  do
  {
    if (v15 < a2 || (v15 + 1) > a2 + 96 || v15 > v15 + 1)
    {
      goto LABEL_77;
    }

    v16 = *v15--;
    *(v68 + v14) = v16;
    v14 += 4;
  }

  while (v14 != 96);
  v17 = 0;
  v18 = (a5 + 92);
  v19 = &v13[4 * v10];
  do
  {
    if (v18 < a5)
    {
      goto LABEL_77;
    }

    if ((v18 + 1) > a5 + 96)
    {
      goto LABEL_77;
    }

    if (v18 > v18 + 1)
    {
      goto LABEL_77;
    }

    v20 = &v13[v17];
    if (&v13[v17] < v13 || (v20 + 4) > v19 || v20 > v20 + 4)
    {
      goto LABEL_77;
    }

    v21 = *v18--;
    *v20 = v21;
    v17 += 4;
  }

  while (v17 != 96);
  v22 = v11 - 1;
  if (v11 >= 1)
  {
    v23 = v11;
    v24 = v13 + 96;
    v25 = a1;
    while ((v24 + 1) <= v19 && v24 <= v24 + 1)
    {
      v27 = *v25++;
      *v24++ = v27;
      if (!--v23)
      {
        goto LABEL_23;
      }
    }

LABEL_77:
    __break(0x5519u);
  }

LABEL_23:
  v28 = 0;
  v66 = v11;
  v29 = &a1[v11];
  do
  {
    v30 = &a1[v22];
    v31 = v30 + 1;
    if (v30 < a1 || v31 > v29 || v30 > v31)
    {
      goto LABEL_77;
    }

    result = *v30;
    *(a5 + v28) = *v30;
    v28 += 4;
    --v22;
  }

  while (v28 != 96);
  if (v11 >= 4)
  {
    v35 = 0;
    v36 = 0;
    v37 = v11 - 3;
    v38 = &a1[v11];
    v39 = a3 + 4 * v11;
    while (1)
    {
      v69 = 0;
      v70 = 0;
      if (&v13[v35 * 4] < v13)
      {
        goto LABEL_77;
      }

      xcorr_kernel_c(v68, &v13[v35 * 4], v19, &v69);
      LODWORD(v11) = v67;
      v40 = &a1[v35];
      if (&a1[v35] < a1)
      {
        goto LABEL_77;
      }

      if (v40 + 4 > v38)
      {
        goto LABEL_77;
      }

      if (v40 > v40 + 4)
      {
        goto LABEL_77;
      }

      v41 = (a3 + v35 * 4);
      if (a3 + v35 * 4 < a3)
      {
        goto LABEL_77;
      }

      if ((v41 + 1) > v39)
      {
        goto LABEL_77;
      }

      if (v41 > v41 + 1)
      {
        goto LABEL_77;
      }

      v42 = &a1[v35 + 1];
      v43 = &a1[v35 + 2];
      *v41 = *&a1[v35] + *&v69;
      if (v42 < a1)
      {
        goto LABEL_77;
      }

      if (v43 > v38)
      {
        goto LABEL_77;
      }

      if (v42 > v43)
      {
        goto LABEL_77;
      }

      v44 = (a3 + v35 * 4 + 4);
      if (v44 < a3)
      {
        goto LABEL_77;
      }

      v45 = a3 + v35 * 4 + 8;
      if (v45 > v39)
      {
        goto LABEL_77;
      }

      if (v44 > v45)
      {
        goto LABEL_77;
      }

      *v44 = *v42 + *(&v69 + 1);
      v46 = &a1[v35 + 2];
      if (v46 < a1)
      {
        goto LABEL_77;
      }

      v47 = &a1[v35 + 3];
      if (v47 > v38)
      {
        goto LABEL_77;
      }

      if (v46 > v47)
      {
        goto LABEL_77;
      }

      v48 = (a3 + v35 * 4 + 8);
      if (v48 < a3)
      {
        goto LABEL_77;
      }

      v49 = a3 + v35 * 4 + 12;
      if (v49 > v39)
      {
        goto LABEL_77;
      }

      if (v48 > v49)
      {
        goto LABEL_77;
      }

      *v48 = *v46 + *&v70;
      v50 = &a1[v35 + 3];
      if (v50 < a1)
      {
        goto LABEL_77;
      }

      v51 = &a1[v35 + 4];
      if (v51 > v38)
      {
        goto LABEL_77;
      }

      if (v50 > v51)
      {
        goto LABEL_77;
      }

      v52 = (a3 + v35 * 4 + 12);
      if (v52 < a3)
      {
        goto LABEL_77;
      }

      v53 = a3 + v35 * 4 + 16;
      if (v53 > v39 || v52 > v53)
      {
        goto LABEL_77;
      }

      result = *v50 + *(&v70 + 1);
      *v52 = result;
      v36 += 4;
      v35 += 4;
      if (v37 <= v36)
      {
        goto LABEL_62;
      }
    }
  }

  v36 = 0;
LABEL_62:
  if (v36 < v11)
  {
    v54 = a3 + 4 * v66;
    v55 = v36;
    for (i = &v13[4 * v36]; ; ++i)
    {
      v57 = 0.0;
      v58 = v68;
      v59 = i;
      v60 = 24;
      do
      {
        if (v59 < v13 || (v59 + 1) > v19 || v59 > v59 + 1)
        {
          goto LABEL_77;
        }

        v61 = *v58++;
        v62 = v61;
        v63 = *v59++;
        v57 = v57 + (v62 * v63);
        --v60;
      }

      while (v60);
      v64 = &a1[v55];
      if (v64 < a1)
      {
        break;
      }

      if ((v64 + 1) > v29)
      {
        break;
      }

      if (v64 > v64 + 1)
      {
        break;
      }

      v65 = (a3 + 4 * v55);
      if (v65 < a3 || (v65 + 1) > v54 || v65 > v65 + 1)
      {
        break;
      }

      result = v57 + *v64;
      *v65 = result;
      if (++v55 >= v11)
      {
        return result;
      }
    }

    goto LABEL_77;
  }

  return result;
}

uint64_t celt_iir(unint64_t a1, float *a2, unint64_t a3, int a4, unint64_t a5)
{
  v8 = a1;
  v96 = *MEMORY[0x1E69E9840];
  *&v9 = -1;
  *(&v9 + 1) = -1;
  v91[0] = v9;
  v91[1] = v9;
  v91[2] = v9;
  v91[3] = v9;
  v91[4] = v9;
  v91[5] = v9;
  v87 = a4;
  v10 = (a4 + 24);
  MEMORY[0x1EEE9AC00](a1);
  v12 = &v86[-v11];
  memset(&v86[-v11], 255, v13);
  v14 = a5;
  v15 = 0;
  v16 = a2 + 23;
  do
  {
    if (v16 < a2 || v16 + 1 > a2 + 24 || v16 > v16 + 1)
    {
      goto LABEL_94;
    }

    v17 = *v16--;
    *(v91 + v15) = v17;
    v15 += 4;
  }

  while (v15 != 96);
  v18 = 0;
  v19 = a5 + 96;
  v20 = (a5 + 92);
  v21 = &v12[4 * v10];
  do
  {
    if (v20 < v14)
    {
      goto LABEL_94;
    }

    if ((v20 + 1) > v19)
    {
      goto LABEL_94;
    }

    if (v20 > v20 + 1)
    {
      goto LABEL_94;
    }

    v22 = &v12[v18];
    if (&v12[v18] < v12 || (v22 + 1) > v21 || v22 > v22 + 1)
    {
      goto LABEL_94;
    }

    v23 = *v20--;
    *v22 = -v23;
    v18 += 4;
  }

  while (v18 != 96);
  LODWORD(result) = v87 - 1;
  if (v87 >= 1)
  {
    v25 = v10 - 24;
    v26 = v12 + 96;
    do
    {
      if (v26 < v12 || (v26 + 1) > v21 || v26 > v26 + 1)
      {
        goto LABEL_94;
      }

      *v26++ = 0;
      --v25;
    }

    while (v25);
    if (v87 >= 4)
    {
      v27 = 0;
      v28 = 0;
      v88 = v87 - 3;
      v89 = result;
      v29 = v8 + 4 * v87;
      v30 = a3 + 4 * v87;
      while (1)
      {
        v90 = v28;
        v31 = (v8 + v27);
        v32 = (v8 + v27 + 4);
        v33 = v8 + v27 < v8 || v32 > v29;
        if (v33 || v31 > v32)
        {
          break;
        }

        v36 = *v31;
        v35 = v31 + 2;
        v92 = v36;
        if (v32 < v8)
        {
          break;
        }

        if (v35 > v29)
        {
          break;
        }

        if (v32 > v35)
        {
          break;
        }

        v93 = *v32;
        v37 = (v8 + v27 + 8);
        if (v37 < v8)
        {
          break;
        }

        v38 = v8 + v27 + 12;
        if (v38 > v29)
        {
          break;
        }

        if (v37 > v38)
        {
          break;
        }

        v94 = *v37;
        v39 = (v8 + v27 + 12);
        if (v39 < v8)
        {
          break;
        }

        v40 = v8 + v27 + 16;
        if (v40 > v29)
        {
          break;
        }

        if (v39 > v40)
        {
          break;
        }

        v95 = *v39;
        v41 = &v12[v27];
        if (&v12[v27] < v12)
        {
          break;
        }

        v42 = v14;
        v43 = v8;
        v44 = v29;
        v45 = v30;
        xcorr_kernel_c(v91, &v12[v27], v21, &v92);
        LODWORD(result) = v89;
        v46 = (v41 + 96);
        if (v41 + 96 < v12)
        {
          break;
        }

        v47 = (v41 + 100);
        if ((v41 + 100) > v21)
        {
          break;
        }

        if (v46 > v47)
        {
          break;
        }

        v48 = v92;
        v49 = -v92;
        *v46 = -v92;
        v50 = (a3 + v27);
        if (a3 + v27 < a3)
        {
          break;
        }

        v30 = v45;
        if ((v50 + 1) > v45)
        {
          break;
        }

        if (v50 > v50 + 1)
        {
          break;
        }

        *v50 = v48;
        v51 = &v12[v27 + 104];
        if (v51 > v21)
        {
          break;
        }

        if (v47 > v51)
        {
          break;
        }

        v52 = v93 + (v49 * *a2);
        v53 = -v52;
        *v47 = -v52;
        v54 = (a3 + v27 + 4);
        if (v54 < a3)
        {
          break;
        }

        v55 = a3 + v27 + 8;
        if (v55 > v45)
        {
          break;
        }

        if (v54 > v55)
        {
          break;
        }

        *v54 = v52;
        v56 = &v12[v27 + 108];
        if (v56 > v21)
        {
          break;
        }

        if (v51 > v56)
        {
          break;
        }

        v57 = (v94 + (v53 * *a2)) + (v49 * a2[1]);
        *v51 = -v57;
        v58 = (a3 + v27 + 8);
        if (v58 < a3)
        {
          break;
        }

        v59 = a3 + v27 + 12;
        if (v59 > v45)
        {
          break;
        }

        if (v58 > v59)
        {
          break;
        }

        *v58 = v57;
        v60 = &v12[v27 + 112];
        if (v60 > v21)
        {
          break;
        }

        if (v56 > v60)
        {
          break;
        }

        v61 = ((v95 + (-v57 * *a2)) + (v53 * a2[1])) + (v49 * a2[2]);
        *v56 = -v61;
        v62 = (a3 + v27 + 12);
        if (v62 < a3)
        {
          break;
        }

        v63 = a3 + v27 + 16;
        if (v63 > v45 || v62 > v63)
        {
          break;
        }

        v29 = v44;
        v8 = v43;
        v14 = v42;
        *v62 = v61;
        v28 = (v90 + 4);
        v27 += 16;
        if (v88 <= v28)
        {
          goto LABEL_63;
        }
      }

LABEL_94:
      __break(0x5519u);
    }
  }

  LODWORD(v28) = 0;
LABEL_63:
  v64 = v87;
  v65 = a3 + 4 * v87;
  if (v28 < v87)
  {
    v66 = v28;
    v67 = v8 + 4 * v87;
    do
    {
      v68 = (v8 + 4 * v66);
      v69 = v68 + 1;
      v70 = v68 < v8 || v69 > v67;
      if (v70 || v68 > v69)
      {
        goto LABEL_94;
      }

      v72 = &v12[4 * v66];
      v73 = *v68;
      v74 = v91;
      v75 = 24;
      do
      {
        if (v72 < v12 || (v72 + 1) > v21 || v72 > v72 + 1)
        {
          goto LABEL_94;
        }

        v76 = *v74++;
        v77 = v76;
        v78 = *v72++;
        v73 = v73 - (v77 * v78);
        --v75;
      }

      while (v75);
      v79 = &v12[4 * v66 + 96];
      if (v79 < v12)
      {
        goto LABEL_94;
      }

      if ((v79 + 1) > v21)
      {
        goto LABEL_94;
      }

      if (v79 > v79 + 1)
      {
        goto LABEL_94;
      }

      *v79 = v73;
      v80 = (a3 + 4 * v66);
      if (v80 < a3 || (v80 + 1) > v65 || v80 > v80 + 1)
      {
        goto LABEL_94;
      }

      *v80 = v73;
    }

    while (++v66 != v64);
  }

  for (i = 0; i != 96; i += 4)
  {
    v82 = (a3 + 4 * result);
    v83 = v82 + 1;
    if (v82 < a3 || v83 > v65 || v82 > v83)
    {
      goto LABEL_94;
    }

    *(v14 + i) = *v82;
    result = (result - 1);
  }

  return result;
}

unint64_t xcorr_kernel_c(unint64_t result, float *a2, unint64_t a3, float *a4)
{
  v4 = a2 + 1;
  if ((a2 + 1) <= a3 && v4 >= a2)
  {
    v6 = a2 + 2;
    v7 = *a2;
    if ((a2 + 2) <= a3 && v4 <= v6 && v6 >= a2 && (a2 + 3) <= a3 && v6 <= a2 + 3)
    {
      v8 = 0;
      v9 = result + 96;
      v10 = *v6;
      v11 = *v4;
      v12 = -4;
      while (1)
      {
        v13 = result + v8 * 4;
        if (result + v8 * 4 < result)
        {
          break;
        }

        v14 = (v13 + 4);
        if (v13 + 4 > v9)
        {
          break;
        }

        if (v13 > v14)
        {
          break;
        }

        v15 = &a2[v8 + 3];
        if (v15 < a2)
        {
          break;
        }

        v16 = &a2[v8 + 4];
        if (v16 > a3)
        {
          break;
        }

        if (v15 > v16)
        {
          break;
        }

        v17 = (result + v8 * 4 + 8);
        v18 = *(result + v8 * 4);
        v19 = *v15;
        v20 = *a4 + (v18 * v7);
        v21 = a4[1] + (v18 * v11);
        *a4 = v20;
        a4[1] = v21;
        v22 = a4[2] + (v18 * v10);
        v23 = a4[3] + (v18 * v19);
        a4[2] = v22;
        a4[3] = v23;
        if (v17 > v9)
        {
          break;
        }

        if (v14 > v17)
        {
          break;
        }

        v24 = &a2[v8 + 5];
        if (v24 > a3)
        {
          break;
        }

        if (v16 > v24)
        {
          break;
        }

        v25 = *v14;
        v7 = *v16;
        v26 = v20 + (*v14 * v11);
        v27 = v21 + (*v14 * v10);
        *a4 = v26;
        a4[1] = v27;
        v28 = v22 + (v25 * v19);
        v29 = v23 + (v25 * v7);
        a4[2] = v28;
        a4[3] = v29;
        v30 = (result + v8 * 4 + 12);
        if (v30 > v9)
        {
          break;
        }

        if (v17 > v30)
        {
          break;
        }

        v31 = &a2[v8 + 6];
        if (v31 > a3)
        {
          break;
        }

        if (v24 > v31)
        {
          break;
        }

        v32 = *v17;
        v11 = *v24;
        v33 = v26 + (*v17 * v10);
        v34 = v27 + (*v17 * v19);
        *a4 = v33;
        a4[1] = v34;
        v35 = v28 + (v32 * v7);
        v36 = v29 + (v32 * v11);
        a4[2] = v35;
        a4[3] = v36;
        v37 = result + v8 * 4 + 16;
        if (v37 > v9)
        {
          break;
        }

        if (v30 > v37)
        {
          break;
        }

        v38 = &a2[v8 + 7];
        if (v38 > a3 || v31 > v38)
        {
          break;
        }

        v39 = *v30;
        v10 = *v31;
        v40 = v34 + (*v30 * v7);
        *a4 = v33 + (*v30 * v19);
        a4[1] = v40;
        a4[2] = v35 + (v39 * v11);
        a4[3] = v36 + (v39 * v10);
        v12 += 4;
        v8 += 4;
        if (v12 >= 0x11)
        {
          return result;
        }
      }
    }
  }

  __break(0x5519u);
  return result;
}

uint64_t silk_stereo_decode_pred(uint64_t a1, _DWORD *a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v4 = ec_dec_icdf(a1, &silk_stereo_pred_joint_iCDF, &silk_uniform3_iCDF, 8);
  v18[2] = v4 / 5;
  v19[2] = v4 % 5;
  v18[0] = ec_dec_icdf(a1, &silk_uniform3_iCDF, &silk_uniform5_iCDF, 8);
  v18[1] = ec_dec_icdf(a1, &silk_uniform5_iCDF, &silk_stereo_only_code_mid_iCDF, 8);
  v5 = v18;
  v19[0] = ec_dec_icdf(a1, &silk_uniform3_iCDF, &silk_uniform5_iCDF, 8);
  result = ec_dec_icdf(a1, &silk_uniform5_iCDF, &silk_stereo_only_code_mid_iCDF, 8);
  v7 = 0;
  v19[1] = result;
  v8 = 1;
  do
  {
    v9 = v8;
    v10 = *v5 + 3 * v5[2];
    *v5 = v10;
    v11 = &silk_stereo_pred_quant_Q13[v10];
    v12 = v11 + 1;
    v14 = v11 < silk_stereo_pred_quant_Q13 || v12 > &word_19B3B50BE || v11 >= v12;
    v15 = v11 + 2;
    if (v14 || v15 > &word_19B3B50BE || v12 > v15)
    {
      goto LABEL_19;
    }

    v8 = 0;
    a2[v7] = *v11 + ((6554 * (v11[1] - *v11)) >> 16) * ((2 * *(v5 + 2)) | 1);
    v5 = v19;
    v7 = 1;
  }

  while ((v9 & 1) != 0);
  if (a2 + 1 > a2 + 2 || a2 + 1 < a2)
  {
LABEL_19:
    __break(0x5519u);
  }

  *a2 -= a2[1];
  return result;
}

int32x4_t silk_PLC_conceal(uint64_t a1, int32x4_t *a2, unint64_t a3, unint64_t a4)
{
  v156 = a4;
  v157 = a3;
  v149 = &v146;
  *&v167 = *MEMORY[0x1E69E9840];
  *&v6 = 0xAAAAAAAAAAAAAAAALL;
  *(&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v165 = v6;
  v166 = v6;
  v7 = (*(a1 + 2328) + *(a1 + 2336));
  v8 = MEMORY[0x1EEE9AC00](a1);
  v10 = &v146 - v9;
  if (v7)
  {
    v8 = memset(&v146 - v9, 170, 4 * v7);
  }

  v11 = *(a1 + 2336);
  MEMORY[0x1EEE9AC00](v8);
  v155 = &v146 - ((2 * v11 + 15) & 0x3FFFFFFF0);
  if (v11)
  {
    memset(&v146 - ((2 * v11 + 15) & 0x3FFFFFFF0), 170, 2 * v11);
  }

  v162 = -1431655766;
  v163 = -1431655766;
  v160 = -1431655766;
  v161 = -1431655766;
  *&v12 = vshr_n_s32(*(a1 + 4296), 6uLL);
  v146 = v12;
  v164 = v12;
  if (*(a1 + 2376))
  {
    *(a1 + 4238) = 0u;
    *(a1 + 4254) = 0u;
  }

  v13 = a1 + 4;
  v14 = (a1 + 1284);
  silk_PLC_energy(&v161, &v163, &v160, &v162, a1 + 4, a1 + 1284, &v164, *(a1 + 2332), *(a1 + 2324));
  v15 = *(a1 + 4308);
  v150 = a2;
  v153 = v7;
  v154 = 2 * v11;
  v158 = v11;
  if (v161 >> v162 >= v160 >> v163)
  {
    v16 = *(a1 + 4312) * v15;
  }

  else
  {
    v16 = (v15 - 1) * *(a1 + 4312);
  }

  if (v16 <= 128)
  {
    v16 = 128;
  }

  v148 = v16;
  if (*(a1 + 4216) >= 1)
  {
    v17 = 1;
  }

  else
  {
    v17 = *(a1 + 4216);
  }

  v18 = &HARM_ATT_Q15[v17];
  if (v18 < HARM_ATT_Q15 || v18 + 1 > PLC_RAND_ATTENUATE_V_Q15 || v18 > v18 + 1)
  {
    goto LABEL_219;
  }

  LOWORD(v19) = *(a1 + 4280);
  v20 = *v18;
  if (*(a1 + 4220) == 2)
  {
    v21 = &PLC_RAND_ATTENUATE_V_Q15[v17];
    if (v21 < PLC_RAND_ATTENUATE_V_Q15)
    {
      goto LABEL_219;
    }

    v22 = v21 + 2;
    v23 = PLC_RAND_ATTENUATE_UV_Q15;
  }

  else
  {
    v21 = &PLC_RAND_ATTENUATE_UV_Q15[2 * v17];
    if (v21 < PLC_RAND_ATTENUATE_UV_Q15)
    {
      goto LABEL_219;
    }

    v22 = v21 + 2;
    v23 = &silk_stereo_pred_joint_iCDF;
  }

  if (v22 > v23)
  {
    goto LABEL_219;
  }

  if (v21 > v22)
  {
    goto LABEL_219;
  }

  v24 = *(a1 + 2340);
  if (v24 > 0x10)
  {
    goto LABEL_219;
  }

  v25 = a1 + 4238;
  v26 = *v21;
  silk_bwexpander((a1 + 4238), v24, 64881);
  v27 = *(a1 + 2340);
  if ((2 * v27) >= 0x21)
  {
    goto LABEL_219;
  }

  v28 = __memcpy_chk();
  if (v28 > v28 + 2 * v27)
  {
    goto LABEL_219;
  }

  v159 = (a1 + 4228);
  if (*(a1 + 4216))
  {
    v147 = v26;
    v29 = v155;
    v30 = v27;
  }

  else
  {
    v30 = v27;
    if (*(a1 + 4220) == 2)
    {
      v147 = v26;
      LOWORD(v31) = 0x4000;
      v32 = 5;
      v33 = v159;
      v29 = v155;
      do
      {
        if ((v33 + 2) > v25 || v33 > v33 + 2)
        {
          goto LABEL_219;
        }

        v35 = *v33;
        v33 += 2;
        LOWORD(v31) = v31 - v35;
        --v32;
      }

      while (v32);
      v31 = v31;
      if (v31 <= 3277)
      {
        v31 = 3277;
      }

      v19 = (*(a1 + 4292) * v31) >> 14;
    }

    else
    {
      v36 = silk_LPC_inverse_pred_gain((a1 + 4238), v27);
      if (v36 >= 0x8000000)
      {
        v37 = 0x8000000;
      }

      else
      {
        v37 = v36;
      }

      if (v37 <= 0x400000)
      {
        v37 = 0x400000;
      }

      v147 = (8 * v37 * v26) >> 30;
      v30 = *(a1 + 2340);
      LOWORD(v19) = 0x4000;
      v29 = v155;
    }
  }

  v38 = *(a1 + 2336);
  v151 = (*(a1 + 4224) >> 7) + 1;
  v39 = v38 - (v30 + (v151 >> 1)) - 2;
  v40 = &v29[2 * v39];
  v41 = v40 > &v29[2 * v158] || v29 > v40;
  if (v41 || (v42 = v30 + (v151 >> 1) + 2, v42 < 0) || ((v43 = a1 + 1348 + 2 * v39, (v154 - 2 * v39) >> 1 >= v42) ? (v44 = v43 >= a1 + 1348) : (v44 = 0), !v44))
  {
LABEL_219:
    __break(0x5519u);
  }

  v45 = *(a1 + 4276);
  v152 = &v29[2 * v158];
  v154 = (v38 - (v30 + (v151 >> 1)) - 2);
  silk_LPC_analysis_filter(v40, v43, a1 + 2308, &v165, &v167, v42, v30);
  v46 = v152;
  v47 = v155;
  v48 = *(a1 + 4300);
  if (v48 >= 0)
  {
    v49 = *(a1 + 4300);
  }

  else
  {
    v49 = -v48;
  }

  v50 = __clz(v49);
  v51 = (((-((((0x1FFFFFFF / (v48 << (v50 - 1) >> 16)) << 19) * (v48 << (v50 - 1))) & 0xFFFFFFF800000000) >> 32) * (0x1FFFFFFF / (v48 << (v50 - 1) >> 16))) >> 16) + ((0x1FFFFFFF / (v48 << (v50 - 1) >> 16)) << 16);
  v52 = HIWORD(v49);
  v53 = v51 >> (16 - v50);
  v54 = v50 - 16;
  v55 = 0x80000000 >> v54;
  if (v51 > 0x80000000 >> v54)
  {
    v55 = v51;
  }

  if (v51 <= (0x7FFFFFFFu >> v54))
  {
    v56 = v55;
  }

  else
  {
    v56 = 0x7FFFFFFFu >> v54;
  }

  v57 = v56 << v54;
  if (v52)
  {
    v58 = v53;
  }

  else
  {
    v58 = v57;
  }

  v158 = *(a1 + 2340);
  v59 = v158 + v154;
  v60 = &v10[4 * v153];
  v154 = *(a1 + 2336);
  if (v59 < v154)
  {
    v61 = v154 - v59;
    if (v58 >= 0x3FFFFFFF)
    {
      v58 = 0x3FFFFFFF;
    }

    v62 = &v10[4 * v59];
    v63 = &v155[2 * v59];
    while (v63 >= v47 && (v63 + 1) <= v46 && v63 <= v63 + 1 && v62 >= v10 && (v62 + 4) <= v60 && v62 <= v62 + 4)
    {
      v64 = *v63++;
      *v62 = (v64 * v58) >> 16;
      v62 += 4;
      if (!--v61)
      {
        goto LABEL_78;
      }
    }

    goto LABEL_219;
  }

LABEL_78:
  v65 = v151 >> 1;
  v66 = *(a1 + 2324);
  if (v66 >= 1)
  {
    v67 = 0;
    v68 = v13 + 4 * v148 - 512;
    LODWORD(v155) = v147;
    v69 = *(a1 + 2332);
    do
    {
      if (v69 >= 1)
      {
        v70 = v38;
        v71 = &v10[4 * v38];
        v72 = v69;
        v73 = -4 * v65;
        do
        {
          v74 = &v71[v73];
          v75 = &v71[v73 + 8];
          v76 = &v71[v73 + 12];
          v78 = v75 < v10 || v76 > v60 || v75 > v76;
          v79 = (v74 + 4);
          if (v78 || v79 < v10 || v79 > v75 || v74 < v10 || v74 > v79)
          {
            goto LABEL_219;
          }

          v84 = (v74 - 4);
          if (v74 - 4 < v10)
          {
            goto LABEL_219;
          }

          if (v84 > v74)
          {
            goto LABEL_219;
          }

          v85 = &v71[v73 - 8];
          if (v85 < v10)
          {
            goto LABEL_219;
          }

          if (v85 > v84)
          {
            goto LABEL_219;
          }

          v45 = 196314165 * v45 + 907633515;
          v86 = (v68 + 4 * (v45 >> 25));
          if (v86 + 1 > v14 || v86 > v86 + 1 || v86 < v13 || v71 < v10 || (v71 + 4) > v60 || v71 > v71 + 4)
          {
            goto LABEL_219;
          }

          *v71 = 4 * (((((*v75 * *(a1 + 4228)) << 16) + ((*v79 * *(a1 + 4230)) >> 16 << 32) + ((*&v71[v73] * *(a1 + 4232)) >> 16 << 32) + ((*v84 * *(a1 + 4234)) >> 16 << 32) + 0x200000000 + (((*v85 * *(a1 + 4236)) << 16) & 0x3FFFFFFF00000000)) >> 32) + ((*v86 * v19) >> 16));
          v71 += 4;
          ++v70;
          --v72;
        }

        while (v72);
        v38 = v70;
      }

      v87 = v159;
      v88 = 5;
      do
      {
        if ((v87 + 1) > v25 || v87 > v87 + 1)
        {
          goto LABEL_219;
        }

        *v87 = (*v87 * v20) >> 15;
        ++v87;
        --v88;
      }

      while (v88);
      v19 = (v19 * v155) >> 15;
      v90 = *(a1 + 4224) + ((655 * *(a1 + 4224)) >> 16);
      if (v90 >= 4608 * *(a1 + 2316))
      {
        v90 = 4608 * *(a1 + 2316);
      }

      *(a1 + 4224) = v90;
      v65 = ((v90 >> 7) + 1) >> 1;
      ++v67;
    }

    while (v67 != v66);
  }

  v159 = &v10[4 * v154];
  v91 = v159 - 64;
  if ((v159 - 64) > v60)
  {
    goto LABEL_219;
  }

  if (v10 > v91)
  {
    goto LABEL_219;
  }

  if (v60 - v91 < 0x40)
  {
    goto LABEL_219;
  }

  v92 = *(a1 + 1300);
  *v91 = *v14;
  *(v91 + 1) = v92;
  v93 = *(a1 + 1332);
  *(v91 + 2) = *(a1 + 1316);
  *(v91 + 3) = v93;
  if (v91 > v159)
  {
    goto LABEL_219;
  }

  v94 = *(a1 + 2328);
  if (v94 >= 1)
  {
    v95 = 0;
    LODWORD(v155) = v158 >> 1;
    v96 = DWORD1(v146);
    v97 = 2 * v158 - 20;
    v98 = &v10[4 * v154 - 44];
    while (1)
    {
      v99 = &v91[4 * v95];
      v100 = v99 + 15;
      v101 = (v99 + 16);
      v103 = v99 + 15 < v10 || v101 > v60 || v100 > v101;
      v104 = v99 + 14;
      v106 = v103 || v104 < v10 || v104 > v100;
      v107 = v99 + 13;
      v109 = v106 || v107 < v10 || v107 > v104;
      v110 = v99 + 12;
      v112 = v109 || v110 < v10 || v110 > v107;
      v113 = v99 + 11;
      v115 = v112 || v113 < v10 || v113 > v110;
      v116 = v99 + 10;
      v118 = v115 || v116 < v10 || v116 > v113;
      v119 = v99 + 9;
      v121 = v118 || v119 < v10 || v119 > v116;
      v122 = v99 + 8;
      v124 = v121 || v122 < v10 || v122 > v119;
      v125 = v99 + 7;
      v127 = v124 || v125 < v10 || v125 > v122;
      v128 = v99 + 6;
      if (v127 || v128 < v10 || v128 > v125)
      {
        goto LABEL_219;
      }

      v131 = v155 + ((v165 * *v100) >> 16) + ((SWORD1(v165) * *v104) >> 16) + ((SWORD2(v165) * *v107) >> 16) + ((SWORD3(v165) * *v110) >> 16) + ((SWORD4(v165) * *v113) >> 16) + ((SWORD5(v165) * *v116) >> 16) + ((SWORD6(v165) * *v119) >> 16) + ((SHIWORD(v165) * *v122) >> 16) + ((v166 * *v125) >> 16) + ((SWORD1(v166) * *v128) >> 16);
      if (v158 >= 11)
      {
        break;
      }

LABEL_198:
      v136 = &v159[4 * v95];
      if (v136 < v10 || (v136 + 1) > v60 || v136 > v136 + 1)
      {
        goto LABEL_219;
      }

      if (v131 <= -134217728)
      {
        v137 = -134217728;
      }

      else
      {
        v137 = v131;
      }

      if (v137 >= 0x7FFFFFF)
      {
        v137 = 0x7FFFFFF;
      }

      v138 = vqadds_s32(*v136, 16 * v137);
      *v136 = v138;
      v139 = (v157 + 2 * v95);
      if (v139 < v157 || (v139 + 1) > v156 || v139 > v139 + 1)
      {
        goto LABEL_219;
      }

      v140 = ((((v96 * v138) >> 16) >> 7) + 1) >> 1;
      if (v140 <= -32768)
      {
        v140 = -32768;
      }

      if (v140 >= 0x7FFF)
      {
        LOWORD(v140) = 0x7FFF;
      }

      *v139 = v140;
      ++v95;
      v98 += 4;
      if (v95 == v94)
      {
        goto LABEL_214;
      }
    }

    v132 = 0;
    v133 = v98;
    while (v133 >= v10)
    {
      if ((v133 + 4) > v60)
      {
        break;
      }

      if (v133 > v133 + 4)
      {
        break;
      }

      v134 = (&v166 + v132 + 4);
      if ((&v166 + v132 + 4) < &v165 || (&v166 + v132 + 6) > &v167 || v134 > (&v166 + v132 + 6))
      {
        break;
      }

      v135 = *v133;
      v133 -= 4;
      v131 += (*v134 * v135) >> 16;
      v132 += 2;
      if (v97 == v132)
      {
        goto LABEL_198;
      }
    }

    goto LABEL_219;
  }

LABEL_214:
  v141 = &v91[4 * v94];
  v44 = v60 >= v141;
  v142 = v60 - v141;
  if (!v44 || v10 > v141 || v142 < 0x40)
  {
    goto LABEL_219;
  }

  v143 = *(v141 + 1);
  *v14 = *v141;
  *(a1 + 1300) = v143;
  v144 = *(v141 + 3);
  *(a1 + 1316) = *(v141 + 2);
  *(a1 + 1332) = v144;
  *(a1 + 4276) = v45;
  *(a1 + 4280) = v19;
  result = vdupq_n_s32(v65);
  *v150 = result;
  return result;
}

unsigned int *silk_PLC_energy(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, signed int a8, int a9)
{
  v39 = *MEMORY[0x1E69E9840];
  v15 = (2 * a8);
  MEMORY[0x1EEE9AC00](a1);
  v18 = &v36 - v17;
  v37 = v19;
  v38 = v20;
  if (v21)
  {
    v22 = 2 * v15;
    v23 = v16;
    memset(&v36 - v17, 170, 2 * v15);
    v16 = v23;
  }

  else
  {
    v22 = 0;
  }

  v24 = 0;
  v25 = &v18[v22];
  v26 = 1;
  v27 = v18;
  do
  {
    v28 = v26;
    if (a8 >= 1)
    {
      v29 = 0;
      v30 = (a5 + 4 * (a9 - 2 + v24) * a8);
      while (v30 >= a5)
      {
        if ((v30 + 1) > a6)
        {
          break;
        }

        if (v30 > v30 + 1)
        {
          break;
        }

        v31 = &v27[v29];
        if (&v27[v29] < v18 || (v31 + 2) > v25 || v31 > v31 + 2)
        {
          break;
        }

        v32 = *v30++;
        v33 = ((*(a7 + 4 * v24) * v32) >> 16) >> 8;
        if (v33 <= -32768)
        {
          v33 = -32768;
        }

        if (v33 >= 0x7FFF)
        {
          LOWORD(v33) = 0x7FFF;
        }

        *v31 = v33;
        v29 += 2;
        if (2 * a8 == v29)
        {
          goto LABEL_18;
        }
      }

LABEL_25:
      __break(0x5519u);
    }

LABEL_18:
    v26 = 0;
    v27 += 2 * a8;
    v24 = 1;
  }

  while ((v28 & 1) != 0);
  if (a8 < 0)
  {
    goto LABEL_25;
  }

  if (a8 > v15)
  {
    goto LABEL_25;
  }

  silk_sum_sqr_shift(a1, v16, v18, a8);
  v34 = &v18[2 * a8];
  if (v34 > v25 || v18 > v34 || a8 > (v22 - 2 * a8) >> 1)
  {
    goto LABEL_25;
  }

  return silk_sum_sqr_shift(v37, v38, v34, a8);
}

__int16 *silk_bwexpander(__int16 *result, int a2, int a3)
{
  if (a2 < 2)
  {
LABEL_7:
    v6 = &result[a2 - 1];
    v7 = (v6 + 1);
    if (v6 >= result && v7 <= &result[a2] && v6 < v7)
    {
      *v6 = (((a3 * *v6) >> 15) + 1) >> 1;
      return result;
    }
  }

  else
  {
    v3 = a3 - 0x10000;
    v4 = result;
    v5 = (a2 - 1);
    while (v4 >= result && v4 + 1 <= &result[a2] && v4 <= v4 + 1)
    {
      *v4 = (((a3 * *v4) >> 15) + 1) >> 1;
      ++v4;
      a3 += (((a3 * v3) >> 15) + 1) >> 1;
      if (!--v5)
      {
        goto LABEL_7;
      }
    }
  }

  __break(0x5519u);
  return result;
}

int *speex_packet_to_header(_OWORD *a1, int a2)
{
  for (i = 0; i != 8; ++i)
  {
    if (*(a1 + i) != aSpeex[i])
    {
      v4 = *MEMORY[0x1E69E9848];
      v5 = "This doesn't look like a Speex file";
LABEL_7:
      fprintf(v4, "notification: %s\n", v5);
      return 0;
    }
  }

  if (a2 <= 79)
  {
    v4 = *MEMORY[0x1E69E9848];
    v5 = "Speex header too small";
    goto LABEL_7;
  }

  v8 = malloc_type_calloc(0x50uLL, 1uLL, 0x6CE94CD7uLL);
  v6 = v8;
  v9 = a1[3];
  v10 = a1[4];
  v11 = a1[1];
  *(v8 + 2) = a1[2];
  *v8 = *a1;
  *(v8 + 1) = v11;
  *(v8 + 3) = v9;
  *(v8 + 4) = v10;
  if (v8[10] >= 3)
  {
    fprintf(*MEMORY[0x1E69E9848], "notification: %s\n", "Invalid mode specified in Speex header");
    free(v6);
    return 0;
  }

  v12 = v8[12];
  if (v12 >= 3)
  {
    v13 = 2;
LABEL_16:
    v8[12] = v13;
    return v6;
  }

  if (v12 <= 0)
  {
    v13 = 1;
    goto LABEL_16;
  }

  return v6;
}

_DWORD *speex_bits_pack(_DWORD *result, unsigned int a2, int a3)
{
  v5 = result;
  if (result[3] + ((result[4] + a3) >> 3) >= result[7])
  {
    v6 = MEMORY[0x1E69E9848];
    fprintf(*MEMORY[0x1E69E9848], "notification: %s\n", "Buffer too small to pack bits");
    if (v5[5])
    {
      v7 = 3 * v5[7] + 15;
      result = malloc_type_realloc(*v5, v7 >> 1, 0x8BF1E735uLL);
      if (result)
      {
        v5[7] = v7 >> 1;
        *v5 = result;
        goto LABEL_5;
      }

      v11 = "Could not resize input buffer: not packing";
    }

    else
    {
      v11 = "Do not own input buffer: not packing";
    }

    return fprintf(*v6, "warning: %s\n", v11);
  }

LABEL_5:
  if (a3)
  {
    v8 = a3 - 1;
    do
    {
      *(*v5 + v5[3]) |= ((a2 >> v8) & 1) << (7 - v5[4]);
      v9 = v5[4] + 1;
      v5[4] = v9;
      if (v9 == 8)
      {
        v10 = v5[3] + 1;
        *(v5 + 3) = v10;
        *(*v5 + v10) = 0;
      }

      ++v5[2];
      --v8;
    }

    while (v8 != -1);
  }

  return result;
}

uint64_t sb_decoder_ctl(uint64_t a1, int a2, void *a3)
{
  v3 = a3;
  if (a2 > 99)
  {
    if (a2 <= 103)
    {
      switch(a2)
      {
        case 'd':
          if (*(a1 + 28) >= 1)
          {
            v21 = 0;
            v22 = *(a1 + 104);
            do
            {
              result = 0;
              *(a3 + v21) = *(v22 + 4 * v21);
              ++v21;
            }

            while (v21 < *(a1 + 28));
            return result;
          }

          break;
        case 'e':
          v18 = *(a1 + 28);
          if (v18 >= 1)
          {
            v19 = *(a1 + 112);
            result = 0;
            do
            {
              v20 = *v19++;
              *v3++ = v20;
              --v18;
            }

            while (v18);
            return result;
          }

          break;
        case 'g':
LABEL_15:
          v7 = *(**(a1 + 8) + 88);
LABEL_39:
          v7();
          return 0;
        default:
LABEL_51:
          fprintf(*MEMORY[0x1E69E9848], "warning: %s %d\n", "Unknown nb_ctl request: ", a2);
          return 0xFFFFFFFFLL;
      }

      return 0;
    }

    if (a2 == 104)
    {
      result = 0;
      *(a1 + 120) = a3;
      return result;
    }

    if (a2 != 105)
    {
      if (a2 == 106)
      {
        result = 0;
        *a3 = *(a1 + 48);
        return result;
      }

      goto LABEL_51;
    }

    goto LABEL_15;
  }

  switch(a2)
  {
    case 0:
      (*(**(a1 + 8) + 88))(*(a1 + 8), 0, a3);
      result = 0;
      *(a1 + 44) = *v3;
      return result;
    case 1:
      result = 0;
      v9 = *(a1 + 44);
      goto LABEL_54;
    case 3:
      result = 0;
      v9 = *(a1 + 16);
      goto LABEL_54;
    case 4:
    case 6:
      v5 = *a3 & ~(*a3 >> 31);
      if (v5 >= 10)
      {
        v5 = 10;
      }

      v6 = *(a1 + 8);
      *(a1 + 152) = *(**a1 + 4 * v5 + 144);
      v7 = *(*v6 + 88);
      goto LABEL_39;
    case 8:
      v7 = *(**(a1 + 8) + 88);
      goto LABEL_39;
    case 9:
      v7 = *(**(a1 + 8) + 88);
      goto LABEL_39;
    case 10:
      result = 0;
      *(a1 + 152) = *a3;
      return result;
    case 19:
      (*(**(a1 + 8) + 88))(*(a1 + 8), 19, a3);
      v15 = *(*(a1 + 144) + 8 * *(a1 + 152));
      v16 = *(a1 + 40);
      result = 0;
      if (v15)
      {
        v17 = *(v15 + 84) * v16;
      }

      else
      {
        v17 = 4 * v16;
      }

      v9 = *v3 + v17 / *(a1 + 16);
      goto LABEL_54;
    case 20:
      v7 = *(**(a1 + 8) + 88);
      goto LABEL_39;
    case 22:
      v7 = *(**(a1 + 8) + 88);
      goto LABEL_39;
    case 24:
      *(a1 + 40) = *a3;
      v7 = *(**(a1 + 8) + 88);
      goto LABEL_39;
    case 25:
      result = 0;
      v9 = *(a1 + 40);
      goto LABEL_54;
    case 26:
      if (*(a1 + 32) >= 1)
      {
        v10 = 0;
        v11 = *(a1 + 96);
        do
        {
          *(v11 + 4 * v10++) = 0;
        }

        while (v10 < 2 * *(a1 + 32));
      }

      v12 = 0;
      v14 = *(a1 + 56);
      v13 = *(a1 + 64);
      do
      {
        *(v13 + v12) = 0;
        *(v14 + v12) = 0;
        v12 += 2;
      }

      while (v12 != 128);
      result = 0;
      *(a1 + 128) = 0;
      return result;
    case 36:
      *(a1 + 136) = *a3;
      v7 = *(**(a1 + 8) + 88);
      goto LABEL_39;
    case 37:
      result = 0;
      v9 = *(a1 + 136);
      goto LABEL_54;
    case 39:
      (*(**(a1 + 8) + 88))(*(a1 + 8), 39, a3);
      result = 0;
      v9 = 2 * *v3;
LABEL_54:
      *v3 = v9;
      break;
    case 44:
      v7 = *(**(a1 + 8) + 88);
      goto LABEL_39;
    case 45:
      v7 = *(**(a1 + 8) + 88);
      goto LABEL_39;
    case 47:
      v7 = *(**(a1 + 8) + 88);
      goto LABEL_39;
    default:
      goto LABEL_51;
  }

  return result;
}

uint64_t sb_encoder_ctl(uint64_t a1, uint64_t a2, void *a3)
{
  v3 = a3;
  if (a2 > 99)
  {
    if (a2 <= 103)
    {
      if (a2 == 100)
      {
        if (*(a1 + 28) >= 1)
        {
          v55 = 0;
          v56 = *(a1 + 152);
          do
          {
            result = 0;
            *(a3 + v55) = *(v56 + 4 * v55);
            ++v55;
          }

          while (v55 < *(a1 + 28));
          return result;
        }
      }

      else
      {
        if (a2 != 101)
        {
LABEL_96:
          fprintf(*MEMORY[0x1E69E9848], "warning: %s %d\n", "Unknown nb_ctl request: ", a2);
          return 0xFFFFFFFFLL;
        }

        v7 = *(a1 + 28);
        if (v7 >= 1)
        {
          v8 = *(a1 + 160);
          result = 0;
          do
          {
            v9 = *v8++;
            *v3++ = v9;
            --v7;
          }

          while (v7);
          return result;
        }
      }
    }

    else
    {
      if (a2 == 104)
      {
        result = 0;
        *(a1 + 168) = a3;
        return result;
      }

      if (a2 != 105)
      {
        if (a2 == 106)
        {
          result = 0;
          *a3 = *(a1 + 56);
          return result;
        }

        goto LABEL_96;
      }

      (*(**(a1 + 8) + 80))(*(a1 + 8), a2, a3);
    }

    return 0;
  }

  switch(a2)
  {
    case 3:
      result = 0;
      v6 = *(a1 + 16);
      goto LABEL_101;
    case 4:
      v19 = *a3 & ~(*a3 >> 31);
      if (v19 >= 10)
      {
        v19 = 10;
      }

      v20 = *(a1 + 8);
      v21 = **a1 + 4 * v19;
      v22 = *(v21 + 144);
      *(a1 + 232) = v22;
      *(a1 + 236) = v22;
      v60 = *(v21 + 100);
      (*(*v20 + 80))(v20, 6, &v60);
      return 0;
    case 5:
      v60 = -1431655766;
      (*(**(a1 + 8) + 80))(*(a1 + 8), 7, &v60);
      result = 0;
      v6 = v60;
      goto LABEL_101;
    case 6:
      (*(*a1 + 80))(a1, 4, a3);
      return 0;
    case 7:
      result = 0;
      v6 = *(a1 + 232);
      goto LABEL_101;
    case 8:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 8, a3);
      return 0;
    case 9:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 9, a3);
      return 0;
    case 10:
      result = 0;
      v18 = *a3;
      *(a1 + 232) = *a3;
      *(a1 + 236) = v18;
      return result;
    case 12:
      *(a1 + 180) = *a3;
      (*(**(a1 + 8) + 80))(*(a1 + 8), 12, a3);
      return 0;
    case 13:
      result = 0;
      v6 = *(a1 + 180);
      goto LABEL_101;
    case 14:
      v24 = *a3;
      v25 = *a3;
      v26 = v25 + 0.6;
      v59 = v26;
      *(a1 + 176) = v24;
      if (v26 > 10.0)
      {
        v59 = 10.0;
      }

      v27 = vcvtmd_s64_f64(v25 + 0.5);
      if (v27 >= 10)
      {
        v27 = 10;
      }

      v60 = v27;
      (*(**(a1 + 8) + 80))(*(a1 + 8), 14, &v59);
      goto LABEL_84;
    case 15:
      result = 0;
      v12 = *(a1 + 176);
      goto LABEL_38;
    case 16:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 16, a3);
      result = 0;
      v23 = *v3;
      if (*v3 <= 1)
      {
        v23 = 1;
      }

      *(a1 + 240) = v23;
      return result;
    case 17:
      result = 0;
      v6 = *(a1 + 240);
      goto LABEL_101;
    case 18:
      v52 = 0.0;
      v59 = 0.0;
      v60 = 10;
      v53 = *a3;
      do
      {
        (*(*a1 + 80))(a1, 4, &v60);
        (*(*a1 + 80))(a1, 19, &v59);
        if (v53 >= SLODWORD(v59))
        {
          break;
        }

        v54 = v60--;
        v52 = v59;
      }

      while (v54 > 0);
      if (LODWORD(v52) - v53 >= v53 - LODWORD(v59))
      {
        return 0;
      }

      ++v60;
LABEL_84:
      (*(*a1 + 80))(a1, 4, &v60);
      return 0;
    case 19:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 19, a3);
      v13 = *(*(a1 + 224) + 8 * *(a1 + 232));
      v14 = *(a1 + 244);
      result = 0;
      if (v13)
      {
        v15 = *(v13 + 84) * v14;
      }

      else
      {
        v15 = 4 * v14;
      }

      v6 = *v3 + v15 / *(a1 + 16);
      goto LABEL_101;
    case 24:
      v28 = *a3;
      *(a1 + 244) = *a3;
      v60 = v28 >> 1;
      (*(**(a1 + 8) + 80))(*(a1 + 8), 24, &v60);
      return 0;
    case 25:
      result = 0;
      v6 = *(a1 + 244);
      goto LABEL_101;
    case 26:
      *(a1 + 40) = 1;
      v29 = *(a1 + 36);
      if (v29 >= 1)
      {
        v30 = v29 + 1;
        v31 = (v29 + 7) & 0xFFFFFFF8;
        v32 = vdupq_n_s64(v29 - 1);
        v33 = xmmword_19B0B2390;
        v34 = xmmword_19B0B23A0;
        v35 = xmmword_19B0A5840;
        v36 = xmmword_19B0A5850;
        v37 = (*(a1 + 104) + 8);
        v38.i64[0] = 0x1000000010000;
        v38.i64[1] = 0x1000000010000;
        v39 = vdupq_n_s32(0x6488u);
        v40 = vdupq_n_s64(8uLL);
        do
        {
          v41 = vmovn_s64(vcgeq_u64(v32, v36));
          v42 = vmulq_s32(vshrq_n_s32(vaddq_s32(vshlq_n_s32(vuzp1q_s32(v36, v35), 0x10uLL), v38), 0x10uLL), v39);
          if (vuzp1_s8(vuzp1_s16(v41, *v32.i8), *v32.i8).u8[0])
          {
            *(v37 - 4) = v42.i32[0] / v30;
          }

          if (vuzp1_s8(vuzp1_s16(v41, *&v32), *&v32).i8[1])
          {
            *(v37 - 3) = v42.i32[1] / v30;
          }

          if (vuzp1_s8(vuzp1_s16(*&v32, vmovn_s64(vcgeq_u64(v32, *&v35))), *&v32).i8[2])
          {
            *(v37 - 2) = v42.i32[2] / v30;
            *(v37 - 1) = v42.i32[3] / v30;
          }

          v43 = vmulq_s32(vshrq_n_s32(vaddq_s32(vshlq_n_s32(vuzp1q_s32(v34, v33), 0x10uLL), v38), 0x10uLL), v39);
          v44 = vmovn_s64(vcgeq_u64(v32, v34));
          if (vuzp1_s8(*&v32, vuzp1_s16(v44, *&v32)).i32[1])
          {
            *v37 = v43.i32[0] / v30;
          }

          if (vuzp1_s8(*&v32, vuzp1_s16(v44, *&v32)).i8[5])
          {
            v37[1] = v43.i32[1] / v30;
          }

          if (vuzp1_s8(*&v32, vuzp1_s16(*&v32, vmovn_s64(vcgeq_u64(v32, *&v33)))).i8[6])
          {
            v37[2] = v43.i32[2] / v30;
            v37[3] = v43.i32[3] / v30;
          }

          v34 = vaddq_s64(v34, v40);
          v35 = vaddq_s64(v35, v40);
          v36 = vaddq_s64(v36, v40);
          v37 += 8;
          v33 = vaddq_s64(v33, v40);
          v31 -= 8;
        }

        while (v31);
        v45 = 0;
        v47 = *(a1 + 128);
        v46 = *(a1 + 136);
        v48 = *(a1 + 144);
        do
        {
          *(v46 + 4 * v45) = 0;
          *(v47 + 4 * v45) = 0;
          *(v48 + 4 * v45++) = 0;
        }

        while (v45 < *(a1 + 36));
      }

      v49 = 0;
      v51 = *(a1 + 72);
      v50 = *(a1 + 80);
      do
      {
        result = 0;
        *(v50 + v49) = 0;
        *(v51 + v49) = 0;
        v49 += 2;
      }

      while (v49 != 128);
      return result;
    case 29:
      result = 0;
      v12 = *(a1 + 216);
LABEL_38:
      *a3 = v12;
      return result;
    case 30:
      *(a1 + 212) = *a3;
      (*(**(a1 + 8) + 80))(*(a1 + 8), 30, a3);
      return 0;
    case 31:
      result = 0;
      v6 = *(a1 + 212);
      goto LABEL_101;
    case 32:
      v10 = *a3;
      *(a1 + 180) = *a3 != 0;
      *(a1 + 192) = v10;
      (*(**(a1 + 8) + 80))(*(a1 + 8), 12, a1 + 180);
      if (!*(a1 + 180))
      {
        return 0;
      }

      v59 = -3.0316e-13;
      v60 = 10;
      v58 = -1431655766;
      (*(*a1 + 80))(a1, 19, &v58);
      break;
    case 33:
      result = 0;
      v6 = *(a1 + 192);
      goto LABEL_101;
    case 34:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 34, a3);
      return 0;
    case 35:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 35, a3);
      return 0;
    case 36:
      *(a1 + 220) = *a3;
      (*(**(a1 + 8) + 80))(*(a1 + 8), 36, a3);
      return 0;
    case 37:
      result = 0;
      v6 = *(a1 + 220);
      goto LABEL_101;
    case 39:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 39, a3);
      result = 0;
      v6 = 2 * *v3 + 63;
      goto LABEL_101;
    case 40:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 40, a3);
      return 0;
    case 41:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 41, a3);
      return 0;
    case 42:
      v16 = *a3;
      *(a1 + 184) = *a3;
      if (v16 < 42200)
      {
        if (v16 < 27800)
        {
          if (v16 < 20601)
          {
            *(a1 + 188) = 1800;
            v17 = -1800;
          }

          else
          {
            *(a1 + 188) = 5600;
            v17 = -5600;
          }
        }

        else
        {
          *(a1 + 188) = 9600;
          v17 = -9600;
        }
      }

      else
      {
        *(a1 + 188) = 17600;
        v17 = -17600;
      }

      if (*(a1 + 24) == 80)
      {
        *(a1 + 188) = 1800;
        v17 = -1800;
      }

      v60 = v17 + v16;
      (*(**(a1 + 8) + 80))(*(a1 + 8), 42, &v60);
      return 0;
    case 43:
      result = 0;
      v6 = *(a1 + 184);
LABEL_101:
      *v3 = v6;
      return result;
    case 44:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 44, a3);
      return 0;
    case 45:
      (*(**(a1 + 8) + 80))(*(a1 + 8), 45, a3);
      return 0;
    default:
      goto LABEL_96;
  }

  while (1)
  {
    (*(*a1 + 80))(a1, 4, &v60);
    (*(*a1 + 80))(a1, 19, &v59);
    v11 = v60;
    if (SLODWORD(v59) <= v58)
    {
      break;
    }

    --v60;
    if (v11 <= 0)
    {
      --v11;
      break;
    }
  }

  v57 = (v11 & ~(v11 >> 31));
  (*(*a1 + 80))(a1, 14, &v57);
  result = 0;
  *(a1 + 200) = 0;
  *(a1 + 196) = 0;
  return result;
}

uint64_t sb_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = a3;
  v143 = *MEMORY[0x1E69E9840];
  v142 = -1431655766;
  v6 = *(a1 + 48);
  v7 = **a1;
  v8 = a3 + 2 * *(a1 + 20);
  (*(**(a1 + 8) + 88))(*(a1 + 8), 104, v8);
  v9 = (*(**(a1 + 8) + 72))(*(a1 + 8), a2, v3);
  (*(**(a1 + 8) + 88))(*(a1 + 8), 103, &v142);
  if (v9)
  {
    return v9;
  }

  if (!a2)
  {
    v11 = v142;
    v12 = a1;
    v13 = v3;
    goto LABEL_17;
  }

  if (!*(a1 + 136))
  {
    v10 = *(a1 + 152);
    goto LABEL_8;
  }

  if (*(a2 + 24))
  {
    goto LABEL_5;
  }

  v31 = *(a2 + 8);
  v32 = *(a2 + 12);
  v33 = *(a2 + 16);
  v34 = v33 + 8 * v32;
  if (v31 - v34 < 1)
  {
    goto LABEL_5;
  }

  if (v31 <= v34)
  {
    *(a2 + 24) = 1;
    goto LABEL_5;
  }

  if (((*(*a2 + v32) >> (7 - v33)) & 1) == 0)
  {
LABEL_5:
    v10 = 0;
    *(a1 + 152) = 0;
    goto LABEL_8;
  }

  speex_bits_unpack_unsigned(a2, 1);
  v10 = speex_bits_unpack_unsigned(a2, 3);
  *(a1 + 152) = v10;
  if (v10 && !*(*(a1 + 144) + 8 * v10))
  {
    fprintf(*MEMORY[0x1E69E9848], "notification: %s\n", "Invalid mode encountered. The stream is corrupted.");
    return 4294967294;
  }

LABEL_8:
  if (!*(*(a1 + 144) + 8 * v10))
  {
    if (!v142)
    {
      v125 = *(a1 + 20);
      v126 = v125;
      if (v125 >= 1)
      {
        bzero((v3 + 2 * v125), 2 * v125);
      }

      *(a1 + 36) = 1;
      iir_mem16(v3 + 2 * v126, *(a1 + 88), v3 + 2 * v126, v126, *(a1 + 32), *(a1 + 96));
      qmf_synth(v3, v3 + 2 * *(a1 + 20), v3, *(a1 + 16), *(a1 + 56), *(a1 + 64));
      return 0;
    }

    v12 = a1;
    v13 = v3;
    v11 = 1;
LABEL_17:
    sb_decode_lost(v12, v13, v11);
    return 0;
  }

  v127 = &v127;
  v14 = MEMORY[0x1EEE9AC00](v10);
  v16 = &v127 - ((v15 + 15) & 0x7FFFFFFF0);
  if (v17)
  {
    v14 = memset(&v127 - ((v15 + 15) & 0x7FFFFFFF0), 170, v15);
  }

  v129 = v7;
  MEMORY[0x1EEE9AC00](v14);
  v19 = &v127 - ((v18 + 15) & 0x3FFFFFFF0);
  if (v20)
  {
    memset(&v127 - ((v18 + 15) & 0x3FFFFFFF0), 170, v18);
  }

  v21 = *(a1 + 8);
  v22 = *(*v21 + 88);
  v136 = v16;
  v22(v21, 100, v16);
  v23 = *(a1 + 8);
  v24 = *(*v23 + 88);
  v131 = v19;
  v25 = v24(v23, 101, v19);
  v26 = *(a1 + 32);
  v27 = MEMORY[0x1EEE9AC00](v25);
  v28 = (2 * v26 + 15) & 0x3FFFFFFF0;
  v29 = (&v127 - v28);
  if (v26)
  {
    v30 = memset(&v127 - v28, 170, 2 * v26);
    MEMORY[0x1EEE9AC00](v30);
    v135 = (&v127 - v28);
    memset(&v127 - v28, 170, 2 * v26);
  }

  else
  {
    MEMORY[0x1EEE9AC00](v27);
    v135 = (&v127 - v28);
  }

  v35 = (*(*(*(a1 + 144) + 8 * *(a1 + 152)) + 24))(&v127 - v28, v26, a2);
  if (*(a1 + 36) && *(a1 + 32) > 0)
  {
    v36 = *(a1 + 80);
    v37 = (&v127 - v28);
    v38 = *(a1 + 32);
    do
    {
      v39 = *v37++;
      *v36++ = v39;
      --v38;
    }

    while (v38);
  }

  v40 = MEMORY[0x1EEE9AC00](v35);
  v42 = (&v127 - ((v41 + 15) & 0x3FFFFFFF0));
  if (v43)
  {
    v40 = memset(&v127 - ((v41 + 15) & 0x3FFFFFFF0), 170, v41);
  }

  if (*(a1 + 28) >= 1)
  {
    v133 = v3;
    v134 = v6;
    v137 = a2;
    v44 = 0;
    v45 = 0;
    v128 = v8 + 2;
    while (1)
    {
      v46 = *(a1 + 24);
      if (v46 < 1)
      {
        return 0xFFFFFFFFLL;
      }

      v141 = v45;
      v140 = &v127;
      v138 = *(a1 + 20);
      MEMORY[0x1EEE9AC00](v40);
      v48 = (&v127 - ((v47 + 15) & 0x7FFFFFFF0));
      memset(v48, 170, v47);
      v49 = *(a1 + 120);
      v139 = v46 * v44;
      if (v49)
      {
        v50 = (v49 + 2 * (2 * v46 * v44));
        bzero(v50, 4 * *(a1 + 24));
      }

      else
      {
        v50 = 0;
      }

      v51 = *(a1 + 32);
      v52 = v135;
      lsp_interpolate(*(a1 + 80), v29, v135, *(a1 + 32), v44, *(a1 + 28));
      lsp_enforce_margin(v52, v51, 410);
      lsp_to_lpc(v52, v42, v51);
      v53 = *(a1 + 104);
      *(v53 + 4 * v44) = 0x2000;
      if (*(a1 + 32) < 1)
      {
        v59 = 8274;
      }

      else
      {
        v54 = 0;
        v55 = 0x2000;
        v56 = 0x2000;
        do
        {
          v57 = &v42[v54];
          v58 = v57[1];
          LODWORD(v57) = *v57;
          v56 = v56 + v58 - v57;
          v55 += v57 + v58;
          *(v53 + 4 * v44) = v55;
          v54 += 2;
        }

        while (v54 < *(a1 + 32));
        v59 = v56 + 82;
      }

      v60 = ((v59 >> 1) + (*&v136[4 * v44] << 7) + 10496) / v59;
      if (v60 <= -32767)
      {
        v60 = -32767;
      }

      v61 = v60 >= 0x7FFF ? 0x7FFF : v60;
      bzero(v48, 4 * *(a1 + 24));
      if (*(*(*(a1 + 144) + 8 * *(a1 + 152)) + 64))
      {
        break;
      }

      v83 = (speex_bits_unpack_unsigned(v137, 5) << 16) + 16121856;
      if ((v83 >> 8) <= 21290)
      {
        v75 = v138;
        if ((v83 >> 8) >= -21290)
        {
          v86 = 23637 * (v83 >> 8) + 0x2000;
          v87 = (v86 >> 14);
          v88 = (v86 >> 14 << 16) >> 27;
          v89 = ((((4 * ((v86 >> 11) & 0x3FF8) * (((1301 * ((v86 >> 11) & 0x3FF8)) >> 14) + 3726) + 744226816) >> 16) * ((v86 >> 11) & 0x3FF8)) >> 14) + 0x4000;
          v90 = -2 - (v87 >> 11);
          v91 = v89 >> v90;
          v92 = v89 << -v90;
          if (v88 >= -2)
          {
            v84 = v92;
          }

          else
          {
            v84 = v91;
          }
        }

        else
        {
          v84 = 0;
        }
      }

      else
      {
        v84 = 0x7FFFFFFF;
        v75 = v138;
      }

      v66 = *(a1 + 24);
      if (v66 >= 1)
      {
        v93 = 0;
        v94 = (v84 + (v61 >> 1)) / v61;
        v95 = 2 * *(v129 + 26);
        v96 = (v94 >> 9);
        v97 = (v94 & 0x1FF) << 6;
        v98 = (v128 + 2 * (v46 * v44));
        v99 = v48 + 1;
        do
        {
          v100 = (v95 * *(v98 - 1)) >> 16;
          v101 = -16384 * (((v95 * *v98) >> 16) * v96 + ((((v95 * *v98) >> 16) * v97 + 0x4000) >> 15));
          *(v99 - 1) = (v100 * v96 + ((v100 * v97 + 0x4000) >> 15)) << 14;
          *v99 = v101;
          v93 += 2;
          v98 += 2;
          v99 += 2;
        }

        while (v93 < v66);
        goto LABEL_74;
      }

      v3 = v133;
      v85 = v139;
LABEL_80:
      iir_mem16(*(a1 + 72), *(a1 + 88), v3 + 2 * v75 + 2 * v85, v66, *(a1 + 32), *(a1 + 96));
      v105 = *(a1 + 24);
      if (v105 >= 1)
      {
        v106 = *(a1 + 72);
        v107 = *(a1 + 24);
        do
        {
          v108 = *v48++;
          *v106++ = (v108 + 0x2000) >> 14;
          --v107;
        }

        while (v107);
      }

      v109 = *(a1 + 32);
      if (v109 >= 1)
      {
        v110 = *(a1 + 88);
        v111 = v42;
        do
        {
          v112 = *v111++;
          *v110++ = v112;
          --v109;
        }

        while (v109);
      }

      v40 = compute_rms16(*(a1 + 72), v105);
      *(*(a1 + 112) + 2 * v44) = v40;
      v45 = v40 * v40 / *(a1 + 28) + v141;
      if (++v44 >= *(a1 + 28))
      {
        goto LABEL_90;
      }
    }

    v62 = (28626 * gc_quant_bound[speex_bits_unpack_unsigned(v137, 4)]) >> 15;
    if (*(a1 + 24) == 80)
    {
      LOWORD(v62) = (23170 * v62 + 0x2000) >> 14;
    }

    v63 = (8 * *&v131[2 * v44] * v62 + (v61 >> 1)) / v61;
    v64 = *(*(a1 + 144) + 8 * *(a1 + 152));
    v65 = (*(v64 + 64))(v48, *(v64 + 72));
    LODWORD(v66) = *(a1 + 24);
    if (v66 >= 1)
    {
      v67 = v48;
      v68 = *(a1 + 24);
      do
      {
        *v67 = ((*v67 >> 7) * (v63 >> 3) + (((*v67 >> 7) * ((v63 << 11) & 0x3800)) >> 14)) << 7;
        ++v67;
        --v68;
      }

      while (v68);
    }

    if (*(*(*(a1 + 144) + 8 * *(a1 + 152)) + 12))
    {
      v130 = v63 << 11;
      v132 = &v127;
      MEMORY[0x1EEE9AC00](v65);
      v70 = (&v127 - ((v69 + 15) & 0x7FFFFFFF0));
      if (v71)
      {
        memset(&v127 - ((v69 + 15) & 0x7FFFFFFF0), 170, v69);
      }

      v72 = *(a1 + 24);
      bzero(v70, 4 * v72);
      v73 = *(*(a1 + 144) + 8 * *(a1 + 152));
      (*(v73 + 64))(v70, *(v73 + 72), v72, v137, v134, a1 + 132);
      v74 = *(a1 + 24);
      v75 = v138;
      if (v74 >= 1)
      {
        v76 = 13107 * (v63 >> 4) + ((13107 * (v130 & 0x7800u) + 0x4000) >> 15);
        v77 = v76 >> 14;
        v78 = v76 & 0x3FFF;
        v79 = v70;
        v80 = *(a1 + 24);
        do
        {
          *v79 = ((*v79 >> 7) * v77 + (((*v79 >> 7) * v78) >> 14)) << 7;
          ++v79;
          --v80;
        }

        while (v80);
        v81 = v48;
        do
        {
          v82 = *v70++;
          *v81++ += v82;
          --v74;
        }

        while (v74);
      }

      LODWORD(v66) = *(a1 + 24);
LABEL_74:
      v85 = v139;
    }

    else
    {
      v85 = v139;
      v75 = v138;
    }

    v3 = v133;
    if (v50 && *(a1 + 120) && v66 >= 1)
    {
      v102 = v66;
      v103 = v48;
      do
      {
        v104 = *v103++;
        *v50 = (v104 + 0x2000) >> 14;
        v50 += 2;
        --v102;
      }

      while (v102);
    }

    goto LABEL_80;
  }

  v45 = 0;
LABEL_90:
  v113 = HIWORD(v45);
  if (!HIWORD(v45))
  {
    v113 = v45;
  }

  if (v113 <= 0xFF)
  {
    v114 = 8 * (HIWORD(v45) != 0);
  }

  else
  {
    v113 >>= 8;
    v114 = (8 * (HIWORD(v45) != 0)) | 4;
  }

  if (v113 > 0xF)
  {
    v113 >>= 4;
    v114 |= 2u;
  }

  if (v113 <= 3)
  {
    v115 = v114;
  }

  else
  {
    v115 = v114 + 1;
  }

  v116 = v45 >> (2 * v115 - 12);
  if (v115 <= 6)
  {
    LOWORD(v116) = v45 << (12 - 2 * v115);
  }

  v117 = (((((16816 * v116 - 827523072) >> 16) * 4 * v116 + 1387593728) >> 16) * 4 * v116 + 238157824) >> 16;
  v118 = v117 >> (13 - v115);
  v119 = v115 >= 0xD;
  v120 = v117 << (v115 - 13);
  if (!v119)
  {
    LOWORD(v120) = v118;
  }

  *(a1 + 128) = v120;
  qmf_synth(v3, v3 + 2 * *(a1 + 20), v3, *(a1 + 16), *(a1 + 56), *(a1 + 64));
  v121 = *(a1 + 32);
  if (v121 >= 1)
  {
    v122 = *(a1 + 80);
    do
    {
      v123 = *v29++;
      *v122++ = v123;
      --v121;
    }

    while (v121);
  }

  v9 = 0;
  *(a1 + 36) = 0;
  return v9;
}

void sb_decode_lost(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    v6 = *(a1 + 152);
    *(a1 + 152) = 1;
  }

  else
  {
    v7 = *(a1 + 32);
    if (v7 >= 1)
    {
      v8 = *(a1 + 88);
      LOWORD(v9) = 32440;
      do
      {
        *v8 = (v9 * *v8 + 0x4000) >> 15;
        ++v8;
        v9 = (32440 * v9 + 0x4000) >> 15;
        --v7;
      }

      while (v7);
    }

    v6 = 0;
    *(a1 + 128) = (29491 * *(a1 + 128)) >> 15;
  }

  *(a1 + 36) = 1;
  v10 = *(a1 + 20);
  v11 = v10;
  if (v10 >= 1)
  {
    v12 = *(a1 + 132);
    v13 = (a2 + 2 * v10);
    do
    {
      v12 = 1664525 * v12 + 1013904223;
      *v13++ = ((v12 >> 16) * *(a1 + 128) - (((v12 >> 16) * *(a1 + 128)) >> 3) + 0x2000) >> 14;
      --v10;
    }

    while (v10);
    *(a1 + 132) = v12;
  }

  iir_mem16(a2 + 2 * v11, *(a1 + 88), a2 + 2 * v11, v11, *(a1 + 32), *(a1 + 96));
  qmf_synth(a2, a2 + 2 * *(a1 + 20), a2, *(a1 + 16), *(a1 + 56), *(a1 + 64));
  if (a3)
  {
    *(a1 + 152) = v6;
  }
}

uint64_t speex_bits_unpack_unsigned(uint64_t *a1, int a2)
{
  v2 = *(a1 + 3);
  v3 = *(a1 + 4);
  if (v3 + a2 + 8 * v2 <= *(a1 + 2))
  {
    if (*(a1 + 6))
    {
      v5 = 1;
    }

    else
    {
      v5 = a2 == 0;
    }

    if (v5)
    {
      return 0;
    }

    else
    {
      v6 = 0;
      v7 = *a1;
      do
      {
        v8 = *(v7 + v2);
        v9 = v3 + 1;
        *(a1 + 4) = v3 + 1;
        if (v3 == 7)
        {
          v9 = 0;
          *(a1 + 12) = ++v2;
        }

        v4 = (v8 >> (7 - v3)) & 1 | (2 * v6);
        v3 = v9;
        v6 = v4;
        --a2;
      }

      while (a2);
    }
  }

  else
  {
    v4 = 0;
    *(a1 + 6) = 1;
  }

  return v4;
}

uint64_t iir_mem16(uint64_t result, __int16 *a2, uint64_t a3, int a4, int a5, _DWORD *a6)
{
  if (a4 >= 1)
  {
    v6 = 0;
    v7 = a4;
    do
    {
      v8 = *(result + 2 * v6) + ((*a6 + 4096) >> 13);
      if (v8 <= -32767)
      {
        v8 = -32767;
      }

      if (v8 >= 0x7FFF)
      {
        LOWORD(v8) = 0x7FFF;
      }

      v9 = -v8;
      if (a5 >= 2)
      {
        v10 = (a5 - 1);
        v11 = a2;
        v12 = a6 + 1;
        do
        {
          v13 = *v11++;
          *(v12 - 1) = *v12 + v9 * v13;
          ++v12;
          --v10;
        }

        while (v10);
      }

      a6[a5 - 1] = v9 * a2[a5 - 1];
      *(a3 + 2 * v6++) = v8;
    }

    while (v6 != v7);
  }

  return result;
}

void qmf_synth(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  v65 = a3;
  v66 = *MEMORY[0x1E69E9840];
  v10 = (a4 >> 1);
  v11 = MEMORY[0x1EEE9AC00](a1);
  v14 = &v63 - v13;
  if (v12)
  {
    v15 = 2 * v12;
    MEMORY[0x1EEE9AC00](v11);
    v16 = &v63 - ((v15 + 15) & 0x3FFFFFFF0);
    bzero(v14, v15);
    bzero(v16, v15);
    if (v10 < 1)
    {
      v19 = 0;
    }

    else
    {
      v17 = 2 * v10;
      v18 = v14;
      do
      {
        *v18++ = *(a1 - 2 + v17);
        v17 -= 2;
      }

      while (v17);
      v19 = 1;
    }
  }

  else
  {
    MEMORY[0x1EEE9AC00](v11);
    v16 = &v63 - ((v20 + 15) & 0x3FFFFFFF0);
    v19 = v10 > 0;
  }

  for (i = 0; i != 64; i += 2)
  {
    *&v14[2 * v10 + i] = *(a5 + 2 + 2 * i);
  }

  if (v19)
  {
    v22 = v16;
    v23 = v10;
    do
    {
      *v22++ = *(a2 - 2 + 2 * v23--);
    }

    while (v23);
  }

  v63 = a5;
  v64 = a6;
  for (j = 0; j != 64; j += 2)
  {
    *&v16[2 * v10 + j] = *(a6 + 2 + 2 * j);
  }

  if (v19)
  {
    v25 = 0;
    v26 = 0;
    v27 = &v16[2 * v10];
    v28 = v10 - 2;
    v29 = &v14[2 * v10];
    v30 = &v16[2 * (v10 - 1)];
    v31 = &v14[2 * (v10 - 1)];
    do
    {
      v32 = 0;
      v33 = 0;
      v34 = 0;
      v35 = 0;
      v36 = 0;
      v37 = *&v16[2 * v26 + 2 * v28];
      v38 = *&v14[2 * v26 + 2 * v28];
      v39 = &word_19B3BA8C6;
      do
      {
        v40 = *(v39 - 2);
        v41 = *(v39 - 1);
        v42 = *&v31[2 * v32];
        v43 = *&v30[2 * v32];
        v44 = -v40;
        v45 = v36 + v42 * v40 + v43 * v44;
        v46 = v34 + v40 * v38 + v44 * v37;
        v47 = *v39;
        v48 = v39[1];
        v49 = *&v29[2 * v32];
        v50 = v37 + v38;
        v38 = *&v29[2 * v32];
        v51 = *&v27[2 * v32];
        v37 = *&v27[2 * v32];
        v52 = -*v39;
        v36 = v45 + v49 * v47 + v51 * v52;
        v35 += (v43 + v42) * v41 + (v51 + v49) * v48;
        v34 = v46 + v47 * v42 + v52 * v43;
        v33 += v50 * v41 + (v43 + v42) * v48;
        v39 += 4;
        v53 = v32 >= 0x1E;
        v32 += 2;
      }

      while (!v53);
      v54 = (v33 + 0x4000) >> 15;
      v55 = (v35 + 0x4000) >> 15;
      v56 = (v36 + 0x4000) >> 15;
      if (v56 <= -32767)
      {
        v56 = -32767;
      }

      if (v56 >= 0x7FFF)
      {
        LOWORD(v56) = 0x7FFF;
      }

      v57 = (v65 + 4 * v25);
      *v57 = v56;
      if (v55 <= -32767)
      {
        v55 = -32767;
      }

      if (v55 >= 0x7FFF)
      {
        LOWORD(v55) = 0x7FFF;
      }

      v57[1] = v55;
      if ((v34 + 0x4000) >> 15 <= -32767)
      {
        v58 = -32767;
      }

      else
      {
        v58 = (v34 + 0x4000) >> 15;
      }

      if (v58 >= 0x7FFF)
      {
        LOWORD(v58) = 0x7FFF;
      }

      v57[2] = v58;
      if (v54 <= -32767)
      {
        v54 = -32767;
      }

      if (v54 >= 0x7FFF)
      {
        LOWORD(v54) = 0x7FFF;
      }

      v57[3] = v54;
      v25 += 2;
      v26 -= 2;
      v27 -= 4;
      v29 -= 4;
      v30 -= 4;
      v31 -= 4;
    }

    while (v25 < v10);
  }

  v59 = 0;
  v60 = v63 + 2;
  do
  {
    *(v60 + 2 * v59) = *&v14[v59];
    v59 += 2;
  }

  while (v59 != 64);
  v61 = 0;
  v62 = v64 + 2;
  do
  {
    *(v62 + 2 * v61) = *&v16[v61];
    v61 += 2;
  }

  while (v61 != 64);
}

__int16 *lsp_interpolate(__int16 *result, __int16 *a2, _WORD *a3, int a4, int a5, __int16 a6)
{
  if (a4 >= 1)
  {
    v6 = ((a5 << 14) + 0x4000) / a6;
    v7 = a4;
    do
    {
      v8 = *result++;
      v9 = ((0x40000000 - (v6 << 16)) >> 16) * v8 + 0x2000;
      v10 = *a2++;
      *a3++ = ((v6 * v10 + 0x2000) >> 14) + (v9 >> 14);
      --v7;
    }

    while (v7);
  }

  return result;
}

__int16 *lsp_enforce_margin(__int16 *result, int a2, int a3)
{
  v3 = 25736 - a3;
  if (*result < a3)
  {
    *result = a3;
  }

  v4 = a2 - 1;
  if (result[v4] > v3)
  {
    result[v4] = v3;
  }

  if (a2 >= 3)
  {
    v5 = v4;
    v6 = result[1];
    ++result;
    LOWORD(v4) = v6;
    v7 = v5 - 1;
    do
    {
      v8 = *(result - 1) + a3;
      if (v8 <= v4)
      {
        LODWORD(v4) = v4;
      }

      else
      {
        *result = v8;
        LODWORD(v4) = v8;
      }

      v9 = result[1];
      if (v9 - a3 < v4)
      {
        *result = ((v9 - a3) >> 1) + (v4 >> 1);
      }

      LOWORD(v4) = v9;
      ++result;
      --v7;
    }

    while (v7);
  }

  return result;
}

void lsp_to_lpc(__int16 *a1, _WORD *a2, uint64_t a3)
{
  v5 = a1;
  v79 = *MEMORY[0x1E69E9840];
  v6 = (a3 >> 1);
  v7 = MEMORY[0x1EEE9AC00](a1);
  v9 = (&v76 - v8);
  v10 = (v6 + 1);
  v77 = a3;
  if (v6 == -1)
  {
    v76 = (a3 + 3);
    MEMORY[0x1EEE9AC00](v7);
    v12 = &v76 - ((v11 + 15) & 0xFFFFFFFF0);
    v13 = 0;
    v14 = 0;
    v15 = v78;
    v16 = v78;
  }

  else
  {
    v14 = 8 * v10;
    v17 = memset(&v76 - v8, 170, 8 * v10);
    v18 = (v10 * (a3 + 3));
    v19 = MEMORY[0x1EEE9AC00](v17);
    v15 = &v76 - v20;
    if (v21)
    {
      v76 = v21;
      v13 = 4 * v18;
      v22 = memset(&v76 - v20, 170, 4 * v18);
      MEMORY[0x1EEE9AC00](v22);
      v12 = &v76 - ((v14 + 15) & 0xFFFFFFFF0);
      v23 = memset(v12, 170, 8 * v10);
      MEMORY[0x1EEE9AC00](v23);
      v16 = &v76 - ((4 * v18 + 15) & 0x7FFFFFFF0);
      memset(&v76 - ((v13 + 15) & 0x7FFFFFFF0), 170, v13);
    }

    else
    {
      MEMORY[0x1EEE9AC00](v19);
      v12 = &v76 - ((v14 + 15) & 0xFFFFFFFF0);
      v24 = memset(v12, 170, 8 * v10);
      MEMORY[0x1EEE9AC00](v24);
      v16 = &v76 - ((v25 + 15) & 0x7FFFFFFF0);
      v13 = 0;
      v76 = 0;
    }
  }

  bzero(v9, v14);
  bzero(v15, v13);
  bzero(v12, v14);
  bzero(v16, v13);
  if ((v6 & 0x80000000) != 0)
  {
    v31 = v77;
    MEMORY[0x1EEE9AC00](v26);
    v33 = &v76 - v44;
    bzero(&v76 - v44, v45);
  }

  else
  {
    v27 = 4 * v76;
    v28 = v9;
    v29 = v12;
    v30 = (v6 + 1);
    do
    {
      *v28++ = v15;
      *v29++ = v16;
      v16 += v27;
      v15 += v27;
      --v30;
    }

    while (v30);
    v31 = v77;
    MEMORY[0x1EEE9AC00](v26);
    v33 = &v76 - v32;
    if (v31)
    {
      v34 = v31;
      bzero(&v76 - v32, 2 * v31);
      if (v31 >= 1)
      {
        v35 = v33;
        do
        {
          v36 = *v5++;
          v37 = (8 * (25736 - v36) * (25736 - v36) + 0x8000) >> 16;
          v38 = -8192 - ((((8 * v37 * (((536870902 * v37 + 4096) >> 13) + 340) - 268402688) >> 16) * v37 + 4096) >> 13);
          v39 = ((((8 * ((8 * v36 * v36 + 0x8000) >> 16) * (((536870902 * ((8 * v36 * v36 + 0x8000) >> 16) + 4096) >> 13) + 340) - 268402688) >> 16) * ((8 * v36 * v36 + 0x8000) >> 16) + 4096) >> 13) + 0x2000;
          if (v36 <= 12867)
          {
            v40 = v39;
          }

          else
          {
            v40 = v38;
          }

          *v35++ = 4 * v40;
          --v34;
        }

        while (v34);
      }
    }

    v41 = 0;
    do
    {
      v42 = v9[v41 / 8];
      *(v42 + 4) = 0x10000000000000;
      v43 = *&v12[v41];
      *(v42 + v41 + 8) = 0x100000;
      *(v43 + 4) = 0x10000000000000;
      *(v43 + v41 + 8) = 0x100000;
      v41 += 8;
      --v10;
    }

    while (v10);
  }

  v46 = v9[1];
  *(v46 + 12) = -((*(*v9 + 8) >> 14) * *v33 + (((*(*v9 + 8) & 0x3FFF) * *v33) >> 14));
  v47 = *(v12 + 1);
  *(v47 + 12) = -((*(*v12 + 8) >> 14) * *(v33 + 1) + (((*(*v12 + 8) & 0x3FFF) * *(v33 + 1)) >> 14));
  if (v6 > 1)
  {
    v48 = -2;
    v49 = 3;
    v50 = 1;
    do
    {
      v51 = &v33[4 * v50++];
      v52 = *v51;
      v53 = v9[v50];
      v54 = *(v51 + 1);
      v55 = *&v12[8 * v50];
      v56 = (v47 + 8);
      v57 = (v46 + 12);
      v58 = 3;
      v59 = (v47 + 8);
      do
      {
        v61 = *(v57 - 2);
        v60 = *(v57 - 1);
        v62 = *v57++;
        *(v53 + 4 * v58) = v61 + v62 - ((v60 >> 14) * v52 + (((v60 & 0x3FFF) * v52) >> 14));
        v63 = v59[1];
        ++v59;
        *(v55 + 4 * v58++) = *(v56 - 1) + v63 - ((*v56 >> 14) * v54 + (((*v56 & 0x3FFF) * v54) >> 14));
        v56 = v59;
      }

      while (v48 + v58 != 3);
      v64 = 4 * v49 + 4;
      *(v53 + 4 * (v49 + 2)) = *(v46 + 4 * v49) - ((*(v46 + v64) >> 14) * v52 + (((*(v46 + v64) & 0x3FFF) * v52) >> 14));
      *(v55 + 4 * (v49 + 2)) = *(v47 + 4 * v49) - ((*(v47 + v64) >> 14) * v54 + (((*(v47 + v64) & 0x3FFF) * v54) >> 14));
      v48 -= 2;
      v47 = v55;
      v46 = v53;
      v49 += 2;
    }

    while (v50 != v6);
  }

  if (v31 >= 1)
  {
    v65 = 0;
    v66 = 0;
    v67 = (v31 + 1) - 1;
    v68 = (*&v12[8 * v6] + 12);
    v69 = (v9[v6] + 12);
    do
    {
      v70 = v65 - v66;
      v72 = *v69++;
      v71 = v72;
      v74 = *v68++;
      v73 = v74;
      v75 = (v70 + v71 + v74 + 128) >> 8;
      if (v75 <= -32767)
      {
        v75 = -32767;
      }

      if (v75 >= 0x7FFF)
      {
        LOWORD(v75) = 0x7FFF;
      }

      *a2++ = v75;
      v65 = v71;
      v66 = v73;
      --v67;
    }

    while (v67);
  }
}

uint64_t compute_rms16(int16x4_t *a1, int a2)
{
  if (a2 < 1)
  {
LABEL_28:
    v21 = 3;
    goto LABEL_29;
  }

  v2 = 10;
  v3 = a1;
  v4 = a2;
  do
  {
    v6 = v3->i16[0];
    v3 = (v3 + 2);
    v5 = v6;
    if (v6 < 0)
    {
      v5 = -v5;
    }

    if (v5 > v2)
    {
      v2 = v5;
    }

    --v4;
  }

  while (v4);
  if (v2 >= 0x4000)
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = *a1++;
      v10 = vshr_n_s16(v9, 1uLL);
      v8 += vaddvq_s32(vmull_s16(v10, v10)) >> 6;
      v7 += 4;
    }

    while (v7 < a2);
    v11 = v8 / a2;
    v12 = (v8 / a2) >> 16;
    v13 = v12 != 0;
    if (!v12)
    {
      v12 = v11;
    }

    if (v12 <= 0xFF)
    {
      v14 = 8 * v13;
    }

    else
    {
      v12 >>= 8;
      v14 = (8 * v13) | 4;
    }

    if (v12 > 0xF)
    {
      v12 >>= 4;
      v14 |= 2u;
    }

    if (v12 <= 3)
    {
      v15 = v14;
    }

    else
    {
      v15 = v14 + 1;
    }

    v16 = v11 >> (2 * v15 - 12);
    v17 = v11 << (12 - 2 * v15);
    if (v15 > 6)
    {
      LOWORD(v17) = v16;
    }

    v18 = (((((16816 * v17 - 827523072) >> 16) * 4 * v17 + 1387593728) >> 16) * 4 * v17 + 238157824) >> 16;
    v19 = v18 >> (13 - v15);
    v20 = v18 << (v15 - 13);
    if (v15 < 0xD)
    {
      LOWORD(v20) = v19;
    }

    LOWORD(v20) = 16 * v20;
    return v20;
  }

  v21 = v2 < 0x2000;
  if (v2 <= 4095)
  {
    if (v2 > 2047)
    {
      v21 = 2;
      goto LABEL_29;
    }

    goto LABEL_28;
  }

LABEL_29:
  if (a2 < 1)
  {
    v23 = 0;
  }

  else
  {
    v22 = 0;
    v23 = 0;
    v24 = vdupq_n_s32(v21);
    do
    {
      v25 = *a1++;
      v26 = vshrq_n_s32(vshlq_n_s32(vshlq_u32(vmovl_u16(v25), v24), 0x10uLL), 0x10uLL);
      v23 += vaddvq_s32(vmulq_s32(v26, v26)) >> 6;
      v22 += 4;
    }

    while (v22 < a2);
  }

  v27 = v23 / a2;
  v28 = (v23 / a2) >> 16;
  v29 = v28 != 0;
  if (!v28)
  {
    v28 = v27;
  }

  if (v28 <= 0xFF)
  {
    v30 = 8 * v29;
  }

  else
  {
    v28 >>= 8;
    v30 = (8 * v29) | 4;
  }

  if (v28 > 0xF)
  {
    v28 >>= 4;
    v30 |= 2u;
  }

  if (v28 <= 3)
  {
    v31 = v30;
  }

  else
  {
    v31 = v30 + 1;
  }

  v32 = v27 >> (2 * v31 - 12);
  v33 = v27 << (12 - 2 * v31);
  if (v31 > 6)
  {
    LOWORD(v33) = v32;
  }

  v34 = (((((16816 * v33 - 827523072) >> 16) * 4 * v33 + 1387593728) >> 16) * 4 * v33 + 238157824) >> 16;
  v35 = v34 >> (13 - v31);
  v36 = v34 << (v31 - 13);
  if (v31 < 0xD)
  {
    v36 = v35;
  }

  v20 = v36 << (v21 ^ 3);
  return v20;
}

void sb_decoder_destroy(uint64_t a1)
{
  (*(**(a1 + 8) + 64))(*(a1 + 8));
  free(*(a1 + 56));
  free(*(a1 + 64));
  free(*(a1 + 72));
  free(*(a1 + 80));
  free(*(a1 + 88));
  free(*(a1 + 104));
  free(*(a1 + 112));
  free(*(a1 + 96));

  free(a1);
}

_DWORD *sb_decoder_init(_DWORD **a1)
{
  v2 = malloc_type_calloc(0xA0uLL, 1uLL, 0x6CE94CD7uLL);
  v3 = v2;
  if (v2)
  {
    *v2 = a1;
    v4 = *a1;
    v2[34] = 1;
    v5 = (*(*v4 + 56))();
    *(v3 + 1) = v5;
    *(v3 + 6) = 0;
    v6 = v4[2];
    v7 = v4[3];
    v3[4] = 2 * v6;
    v3[5] = v6;
    v3[6] = v7;
    v3[7] = v6 / v7;
    v3[8] = v4[4];
    (*(*v5 + 88))(v5, 25, v3 + 10);
    v3[10] *= 2;
    v9 = 1;
    (*(**(v3 + 1) + 88))(*(v3 + 1), 105, &v9);
    *(v3 + 18) = v4 + 8;
    v3[38] = v4[24];
    v3[9] = 1;
    *(v3 + 7) = malloc_type_calloc(0x80uLL, 1uLL, 0x6CE94CD7uLL);
    *(v3 + 8) = malloc_type_calloc(0x80uLL, 1uLL, 0x6CE94CD7uLL);
    *(v3 + 9) = malloc_type_calloc(2 * v3[6], 1uLL, 0x6CE94CD7uLL);
    *(v3 + 10) = malloc_type_calloc(2 * v3[8], 1uLL, 0x6CE94CD7uLL);
    *(v3 + 11) = malloc_type_calloc(2 * v3[8], 1uLL, 0x6CE94CD7uLL);
    *(v3 + 13) = malloc_type_calloc(4 * v3[7], 1uLL, 0x6CE94CD7uLL);
    *(v3 + 14) = malloc_type_calloc(2 * v3[7], 1uLL, 0x6CE94CD7uLL);
    *(v3 + 12) = malloc_type_calloc(8 * v3[8], 1uLL, 0x6CE94CD7uLL);
    *(v3 + 15) = 0;
    v3[11] = 0;
    v3[33] = 1000;
  }

  return v3;
}

BOOL sb_encode(uint64_t a1, int16x4_t *a2, _DWORD *a3)
{
  v286 = *MEMORY[0x1E69E9840];
  v265 = *(a1 + 56);
  v279 = **a1;
  v6 = *(a1 + 20);
  v7 = (a2 + 2 * v6);
  qmf_decomp(a2, a2, v7, *(a1 + 16), *(a1 + 72));
  if (*(a1 + 180) || *(a1 + 212) || *(a1 + 208))
  {
    v9 = *(a1 + 20);
    v10 = compute_rms16(a2, v9);
    v8 = compute_rms16(v7, v9);
    v11 = v8 + 1.0;
    v12 = v10 + 1.0;
  }

  else
  {
    v11 = 1.0;
    v12 = 1.0;
  }

  v257[1] = v257;
  MEMORY[0x1EEE9AC00](v8);
  v14 = v257 - ((v13 + 15) & 0x3FFFFFFF0);
  if (v15)
  {
    memset(v257 - ((v13 + 15) & 0x3FFFFFFF0), 170, v13);
  }

  v285 = -1431655766;
  (*(**(a1 + 8) + 80))(*(a1 + 8), 104, v14);
  v16 = *(a1 + 8);
  v17 = *(*v16 + 48);
  v259 = a3;
  v17(v16, a2, a3);
  v18 = *(a1 + 32);
  v19 = *(a1 + 20);
  v20 = v7 - 2 * (v18 - v19);
  memcpy(v20, *(a1 + 64), 2 * (v18 - v19));
  v21 = *(a1 + 64);
  v22 = *(a1 + 20);
  v272 = v20;
  v23 = memcpy(v21, &v20[2 * v22], 2 * (*(a1 + 32) - v22));
  LODWORD(v20) = *(a1 + 28);
  v24 = MEMORY[0x1EEE9AC00](v23);
  v26 = v257 - ((v25 + 15) & 0x7FFFFFFF0);
  v258 = v14;
  if (v20)
  {
    v27 = memset(v257 - ((v25 + 15) & 0x7FFFFFFF0), 170, v25);
    MEMORY[0x1EEE9AC00](v27);
    v29 = v257 - ((v28 + 15) & 0x3FFFFFFF0);
    memset(v29, 170, v28);
  }

  else
  {
    MEMORY[0x1EEE9AC00](v24);
    v29 = v257 - ((v30 + 15) & 0x3FFFFFFF0);
  }

  v31 = *(a1 + 8);
  v32 = *(*v31 + 80);
  v264 = v26;
  v32(v31, 100, v26);
  v33 = *(a1 + 8);
  v34 = *(*v33 + 80);
  v260 = v29;
  v34(v33, 101, v29);
  v35 = (*(**(a1 + 8) + 80))(*(a1 + 8), 9, &v285);
  v285 = v285 == 0;
  v36 = *(a1 + 36);
  v37 = MEMORY[0x1EEE9AC00](v35);
  v38 = (2 * v36 + 15) & 0x3FFFFFFF0;
  v39 = (v257 - v38);
  if (!v36)
  {
    v53 = MEMORY[0x1EEE9AC00](v37);
    v263 = (v257 - v38);
    v54 = MEMORY[0x1EEE9AC00](v53);
    v282 = (v257 - v38);
    v55 = MEMORY[0x1EEE9AC00](v54);
    v281 = (v257 - v38);
    v56 = MEMORY[0x1EEE9AC00](v55);
    v271 = (v257 - v38);
    v57 = MEMORY[0x1EEE9AC00](v56);
    v270 = (v257 - v38);
    v58 = MEMORY[0x1EEE9AC00](v57);
    v262 = (v257 - v38);
    v59 = MEMORY[0x1EEE9AC00](v58);
    v261 = (v257 - v38);
    MEMORY[0x1EEE9AC00](v59);
    v51 = &v255;
    v49 = 1;
    goto LABEL_14;
  }

  v40 = memset(v257 - v38, 170, 2 * v36);
  MEMORY[0x1EEE9AC00](v40);
  v263 = (v257 - v38);
  v41 = memset(v257 - v38, 170, 2 * v36);
  MEMORY[0x1EEE9AC00](v41);
  v282 = (v257 - v38);
  v42 = memset(v257 - v38, 170, 2 * v36);
  MEMORY[0x1EEE9AC00](v42);
  v281 = (v257 - v38);
  v43 = memset(v257 - v38, 170, 2 * v36);
  MEMORY[0x1EEE9AC00](v43);
  v271 = (v257 - v38);
  v44 = memset(v257 - v38, 170, 2 * v36);
  MEMORY[0x1EEE9AC00](v44);
  v270 = (v257 - v38);
  v45 = memset(v257 - v38, 170, 2 * v36);
  MEMORY[0x1EEE9AC00](v45);
  v262 = (v257 - v38);
  v46 = memset(v257 - v38, 170, 2 * v36);
  MEMORY[0x1EEE9AC00](v46);
  v261 = (v257 - v38);
  v47 = memset(v257 - v38, 170, 2 * v36);
  v48 = MEMORY[0x1EEE9AC00](v47);
  v51 = (v257 - v50);
  if ((v52 & 1) == 0)
  {
LABEL_14:
    v48 = memset(v51, 170, 2 * v49);
  }

  v60 = *(a1 + 32);
  MEMORY[0x1EEE9AC00](v48);
  v62 = (v257 - ((v61 + 15) & 0x3FFFFFFF0));
  if (!v60)
  {
    v280 = (a1 + 24);
LABEL_22:
    v66 = v259;
LABEL_23:
    v67 = v271;
    goto LABEL_24;
  }

  memset(v257 - ((v61 + 15) & 0x3FFFFFFF0), 170, v61);
  v63 = *(a1 + 24);
  v280 = (a1 + 24);
  if (v63 == 80)
  {
    if (v60 >= 1)
    {
      v64 = 0;
      v65 = *(a1 + 88);
      do
      {
        v62[v64] = (*(v65 + (v64 & 0xFFFFFFFE)) * *(&a2->i16[v64] + 2 * v6 + 2 * v19 - 2 * v18)) >> 14;
        ++v64;
      }

      while (v60 != v64);
    }

    goto LABEL_22;
  }

  v66 = v259;
  if (v60 < 1)
  {
    goto LABEL_23;
  }

  v101 = *(a1 + 88);
  v67 = v271;
  v102 = v272;
  v103 = v62;
  v104 = v60;
  do
  {
    v106 = *v102++;
    v105 = v106;
    v107 = *v101++;
    *v103++ = (v107 * v105) >> 14;
    --v104;
  }

  while (v104);
LABEL_24:
  _spx_autocorr(v62, v51, *(a1 + 36) + 1, v60);
  *v51 += (*(a1 + 44) * *v51) >> 15;
  v68 = *(a1 + 36);
  if ((v68 & 0x80000000) == 0)
  {
    v69 = *(a1 + 96);
    v70 = v68 + 1;
    v71 = v51;
    do
    {
      v72 = *v69++;
      *v71 = (v72 * *v71) >> 14;
      ++v71;
      --v70;
    }

    while (v70);
  }

  _spx_lpc(v39, v51, v68);
  v73 = lpc_to_lsp(v39, *(a1 + 36), v67, 6553);
  v74 = *(a1 + 36);
  if (v73 != v74)
  {
    v75 = lpc_to_lsp(v39, v74, v67, 1638);
    v76 = *(a1 + 36);
    if (v75 != v76 && v76 >= 1)
    {
      v78 = *(a1 + 104);
      v79 = v67;
      do
      {
        v80 = *v78++;
        *v79++ = v80;
        --v76;
      }

      while (v76);
    }
  }

  if ((*(a1 + 180) || *(a1 + 212) || *(a1 + 208)) && !v285)
  {
    if (*(a1 + 192))
    {
      v81 = *(a1 + 196);
      v82 = 0.0;
      v83 = 0.0;
      if ((*(a1 + 200) * v81) > 0.0)
      {
        v83 = v81 * -0.00001 / (*(a1 + 204) + 1.0);
        if (v83 > 0.1)
        {
          v83 = 0.1;
        }

        if (v83 < -0.1)
        {
          v83 = -0.1;
        }
      }

      v84 = v83 + *(a1 + 176);
      if (v84 > 10.0)
      {
        v84 = 10.0;
      }

      if (v84 >= 0.0)
      {
        v82 = v84;
      }

      *(a1 + 176) = v82;
    }

    (*(**(a1 + 8) + 80))(*(a1 + 8), 29, a1 + 216);
    if (*(a1 + 180))
    {
      v85 = log((v11 / v12));
      v86 = v85 + v85;
      if (v86 < -4.0)
      {
        v86 = -4.0;
      }

      if (v86 > 2.0)
      {
        v86 = 2.0;
      }

      v87 = v279;
      v88 = *(v279 + 200);
      v89 = (v86 + 2.0) + *(a1 + 216);
      if (v89 < -1.0)
      {
        v89 = -1.0;
      }

      *(a1 + 216) = v89;
      v90 = v88 - 1;
      v284 = v88 - 1;
      if (v88 != 1)
      {
        v91 = *(a1 + 176);
        v92 = vcvtms_s32_f32(v91);
        v93 = v91 - floorf(v91);
        v94 = (v92 + 1) - v91;
        v95 = *(v87 + 192);
        v96 = v88 - 2;
        v97 = (v95 + 44 * v88 - 4);
        do
        {
          if (v92 == 10)
          {
            v98 = *v97;
          }

          else
          {
            v98 = (v94 * v97[v92 - 10]) + (v93 * v97[v92 - 9]);
          }

          if (v89 >= v98 && *(*(*(a1 + 224) + 8 * v90) + 84) * *(a1 + 244) / *(a1 + 16) <= *(a1 + 188))
          {
            break;
          }

          v284 = v96--;
          v97 -= 11;
          --v90;
        }

        while (v90);
      }

      (*(*a1 + 80))(a1, 10, &v284);
      if (*(a1 + 192))
      {
        v283 = -1431655766;
        (*(*a1 + 80))(a1, 19, &v283);
        v99 = v283 - *(a1 + 192);
        v100 = v99 * 0.05 + *(a1 + 200) * 0.95;
        *(a1 + 196) = *(a1 + 196) + v99;
        *(a1 + 200) = v100;
        *(a1 + 204) = *(a1 + 204) + 1.0;
      }
    }

    else
    {
      if (*(a1 + 216) >= 2.0)
      {
        v108 = *(a1 + 236);
      }

      else
      {
        v108 = 1;
      }

      *(a1 + 232) = v108;
    }
  }

  if (*(a1 + 220))
  {
    speex_bits_pack(v66, 1u, 1);
    if (v285)
    {
      v109 = 0;
    }

    else
    {
      v109 = *(a1 + 232);
    }

    speex_bits_pack(v66, v109, 3);
  }

  if (v285 || (v115 = *(*(a1 + 224) + 8 * *(a1 + 232))) == 0)
  {
    v110 = *(a1 + 20);
    if (v110 >= 1)
    {
      bzero(v272, 2 * v110);
    }

    LODWORD(v111) = *(a1 + 36);
    if (v111 >= 1)
    {
      v112 = 0;
      v113 = *(a1 + 144);
      do
      {
        *(v113 + 4 * v112++) = 0;
        v111 = *(a1 + 36);
      }

      while (v112 < v111);
      LODWORD(v110) = *(a1 + 20);
    }

    *(a1 + 40) = 1;
    iir_mem16(v272, *(a1 + 120), v272, v110, v111, *(a1 + 128));
    return v285 == 0;
  }

  else
  {
    v116 = (*(v115 + 16))(v67, v270, *(a1 + 36), v66);
    v117 = *(a1 + 36);
    if (*(a1 + 40) && v117 > 0)
    {
      v118 = *(a1 + 104);
      v119 = v67;
      v120 = *(a1 + 36);
      do
      {
        v121 = *v119++;
        *v118++ = v121;
        --v120;
      }

      while (v120);
      v122 = *(a1 + 112);
      v123 = v270;
      v124 = v117;
      do
      {
        v125 = *v123++;
        *v122++ = v125;
        --v124;
      }

      while (v124);
    }

    v126 = MEMORY[0x1EEE9AC00](v116);
    v128 = (v257 - ((v127 + 15) & 0x7FFFFFFF0));
    if (v117)
    {
      v126 = memset(v257 - ((v127 + 15) & 0x7FFFFFFF0), 170, v127);
    }

    v129 = 2 * *v280;
    MEMORY[0x1EEE9AC00](v126);
    v130 = (v129 + 15) & 0x3FFFFFFF0;
    v131 = v257 - v130;
    v133 = 4 * v132;
    v273 = (v257 - v130);
    if (v132)
    {
      v134 = memset(v131, 170, v129);
      MEMORY[0x1EEE9AC00](v134);
      v277 = (v257 - ((v133 + 15) & 0x7FFFFFFF0));
      v135 = memset(v277, 170, v133);
      MEMORY[0x1EEE9AC00](v135);
      v274 = (v257 - v130);
      v136 = memset(v257 - v130, 170, v129);
    }

    else
    {
      v137 = MEMORY[0x1EEE9AC00](v131);
      v277 = (v257 - ((v133 + 15) & 0x7FFFFFFF0));
      v136 = MEMORY[0x1EEE9AC00](v137);
      v274 = (v257 - v130);
    }

    if (*(a1 + 28) >= 1)
    {
      v138 = 0;
      do
      {
        v276 = v257;
        v139 = *v280;
        v140 = MEMORY[0x1EEE9AC00](v136);
        v142 = (v257 - ((v141 + 15) & 0x3FFFFFFF0));
        if (v139)
        {
          v140 = memset(v257 - ((v141 + 15) & 0x3FFFFFFF0), 170, v141);
        }

        v278 = v142;
        v143 = 2 * *v280;
        v144 = MEMORY[0x1EEE9AC00](v140);
        v145 = (v143 + 15) & 0x3FFFFFFF0;
        v146 = (v257 - v145);
        if (v147)
        {
          v148 = memset(v257 - v145, 170, v143);
          MEMORY[0x1EEE9AC00](v148);
          v279 = v257 - v145;
          memset(v257 - v145, 170, v143);
        }

        else
        {
          MEMORY[0x1EEE9AC00](v144);
          v279 = v257 - v145;
        }

        v149 = v262;
        lsp_interpolate(*(a1 + 104), v67, v262, *(a1 + 36), v138, *(a1 + 28));
        v150 = v261;
        lsp_interpolate(*(a1 + 112), v270, v261, *(a1 + 36), v138, *(a1 + 28));
        lsp_enforce_margin(v149, *(a1 + 36), 410);
        lsp_enforce_margin(v150, *(a1 + 36), 410);
        v151 = v149;
        v152 = v263;
        lsp_to_lpc(v151, v263, *(a1 + 36));
        lsp_to_lpc(v150, *(a1 + 120), *(a1 + 36));
        v153 = *(a1 + 36);
        if (v153 >= 1)
        {
          v154 = *(a1 + 46);
          LOWORD(v155) = *(a1 + 46);
          v156 = v152;
          v157 = v282;
          v158 = *(a1 + 36);
          do
          {
            v159 = *v156++;
            *v157++ = (v159 * v155 + 0x4000) >> 15;
            v155 = (v155 * v154 + 0x4000) >> 15;
            --v158;
          }

          while (v158);
          v160 = *(a1 + 48);
          v161 = *(a1 + 48);
          v162 = v281;
          do
          {
            v163 = *v152++;
            *v162++ = (v163 * v161 + 0x4000) >> 15;
            LODWORD(v161) = (v161 * v160 + 0x4000) >> 15;
            --v153;
          }

          while (v153);
        }

        v164 = *(a1 + 152);
        *(v164 + 4 * v138) = 0x2000;
        LODWORD(v165) = *(a1 + 36);
        v166 = *(a1 + 120);
        if (v165 < 1)
        {
          v172 = 8274;
        }

        else
        {
          v167 = 0;
          v168 = 0x2000;
          v169 = 0x2000;
          do
          {
            v170 = &v166[v167];
            v171 = v170[1];
            LODWORD(v170) = *v170;
            v169 = v169 + v171 - v170;
            v168 += v170 + v171;
            *(v164 + 4 * v138) = v168;
            v167 += 2;
            v165 = *(a1 + 36);
          }

          while (v167 < v165);
          v172 = v169 + 82;
        }

        v173 = &v272[2 * v139 * v138];
        v174 = ((v172 >> 1) + (*&v264[4 * v138] << 7) + 10496) / v172;
        if (v174 <= -32767)
        {
          v174 = -32767;
        }

        if (v174 >= 0x7FFF)
        {
          v175 = 0x7FFF;
        }

        else
        {
          v175 = v174;
        }

        v176 = v278;
        fir_mem16(v173, v166, v278, *(a1 + 24), v165, *(a1 + 136));
        v177 = *(a1 + 24);
        v178 = compute_rms16(v176, v177);
        v179 = v178;
        v180 = *(*(*(a1 + 224) + 8 * *(a1 + 232)) + 56);
        if (v180)
        {
          v275 = v173;
          v181 = 0;
          v269 = (*&v260[2 * v138] + 1);
          v182 = (v175 * (v178 + 1) + (v269 >> 1)) / v269;
          if (v177 == 80)
          {
            LOWORD(v182) = (23171 * v182 + 0x4000) >> 15;
          }

          v266 = v175;
          while (gc_quant_bound[v181] < v182)
          {
            if (++v181 == 15)
            {
              LODWORD(v181) = 15;
              break;
            }
          }

          speex_bits_pack(v66, v181, 4);
          v183 = (28626 * gc_quant_bound[v181]) >> 15;
          v184 = *v280;
          v185 = v184;
          if (v184 == 80)
          {
            v183 = (23170 * v183 + 0x2000) >> 14;
          }

          v267 = v183;
          v186 = *(a1 + 120);
          v187 = *(a1 + 36);
          compute_impulse_response(v186, v282, v281, v273, v184, *(a1 + 36));
          if (v184 >= 1)
          {
            bzero(v146, 2 * v184);
          }

          v268 = v186;
          if (v187 < 1)
          {
            v204 = v186;
            v194 = v66;
            v193 = v266;
            iir_mem16(v146, v204, v146, v184, v187, v128);
            filter_mem16(v146, v282, v281, v146, v184, v187, v128);
          }

          else
          {
            v188 = 0;
            v189 = *(a1 + 128);
            v190 = 4 * v187;
            do
            {
              v128[v188 / 4] = *(v189 + v188);
              v188 += 4;
            }

            while (v190 != v188);
            iir_mem16(v146, v186, v146, v184, v187, v128);
            v191 = 0;
            v192 = *(a1 + 144);
            do
            {
              v128[v191 / 4] = *(v192 + v191);
              v191 += 4;
            }

            while (v190 != v191);
            v193 = v266;
            filter_mem16(v146, v282, v281, v146, v184, v187, v128);
            v194 = v259;
            v195 = *(a1 + 144);
            v196 = v128;
            v197 = v187;
            do
            {
              v198 = *v195++;
              *v196++ = v198;
              --v197;
            }

            while (v197);
          }

          filter_mem16(v275, v282, v281, v279, v184, v187, v128);
          if (v184 >= 1)
          {
            v205 = v279;
            v206 = v274;
            v207 = v184;
            do
            {
              v209 = *v205++;
              v208 = v209;
              v210 = *v146++;
              *v206++ = v208 - v210;
              --v207;
            }

            while (v207);
          }

          v269 *= (((v267 << 8) + (v193 >> 1)) / v193);
          v211 = v269 << 6;
          v212 = v274;
          signal_div(v274, v274, v269 << 6, v184);
          v213 = 4 * v184;
          v214 = v277;
          bzero(v277, v213);
          v215 = *(*(a1 + 224) + 8 * *(a1 + 232));
          v216 = *(v215 + 56);
          v217 = *(v215 + 72);
          LODWORD(v215) = *(v215 + 12);
          LODWORD(v256) = *(a1 + 240);
          HIDWORD(v256) = v215;
          v218 = v216(v212, v268, v282, v281, v217, v187, v185, v214, v273, v194, v265, v256);
          v219 = *(a1 + 24);
          if (v219 >= 1)
          {
            v220 = (v269 >> 8);
            v221 = v277;
            v222 = *(a1 + 24);
            do
            {
              v221->i32[0] = ((v221->i32[0] >> 7) * v220 + (((v221->i32[0] >> 7) * (v211 & 0x3FC0)) >> 14)) << 7;
              v221 = (v221 + 4);
              --v222;
            }

            while (v222);
          }

          if (*(*(*(a1 + 224) + 8 * *(a1 + 232)) + 12))
          {
            MEMORY[0x1EEE9AC00](v218);
            v224 = (v257 - ((v223 + 15) & 0x7FFFFFFF0));
            v66 = v194;
            if (v219)
            {
              memset(v257 - ((v223 + 15) & 0x7FFFFFFF0), 170, v223);
            }

            v225 = *v280;
            bzero(v224, 4 * v225);
            if (v225 >= 1)
            {
              v226 = v274;
              v227 = v225;
              do
              {
                *v226 = (20480 * *v226 + 4096) >> 13;
                ++v226;
                --v227;
              }

              while (v227);
            }

            v228 = *(*(a1 + 224) + 8 * *(a1 + 232));
            (*(v228 + 56))(v274, *(a1 + 120), v282, v281, *(v228 + 72), *(a1 + 36), v225, v224, v273, v194, v265, *(a1 + 240));
            v229 = *(a1 + 24);
            if (v229 >= 1)
            {
              v230 = 13107 * (v269 >> 9) + ((13107 * (v211 & 0x7FC0u) + 0x4000) >> 15);
              v231 = v230 >> 14;
              v232 = v230 & 0x3FFF;
              v233 = v224;
              v234 = *(a1 + 24);
              do
              {
                *v233 = ((*v233 >> 7) * v231 + (((*v233 >> 7) * v232) >> 14)) << 7;
                ++v233;
                --v234;
              }

              while (v234);
              v235 = v277;
              do
              {
                v236 = *v224++;
                v235->i32[0] += v236;
                v235 = (v235 + 4);
                --v229;
              }

              while (v229);
            }

            v219 = *v280;
          }

          else
          {
            v66 = v194;
          }

          v67 = v271;
          v201 = v278;
          if (v219 >= 1)
          {
            v237 = v219;
            v238 = v277;
            v239 = v278;
            do
            {
              v240 = v238->i32[0];
              v238 = (v238 + 4);
              v239->i16[0] = (v240 + 0x2000) >> 14;
              v239 = (v239 + 2);
              --v237;
            }

            while (v237);
          }

          v241 = *(a1 + 168);
          if (v241)
          {
            *(v241 + 2 * v138) = (23171 * compute_rms(v277, v219)) >> 15;
          }

          v179 = compute_rms16(v201, v219);
          v173 = v275;
        }

        else
        {
          v199 = (*&v258[2 * v138] + 1);
          v200 = (v175 * v178 + (v199 >> 1)) / v199;
          v67 = v271;
          v201 = v278;
          while (fold_quant_bound[v180] < v200)
          {
            if (++v180 == 31)
            {
              LODWORD(v180) = 31;
              break;
            }
          }

          if (v180 >= 0x1F)
          {
            v202 = 31;
          }

          else
          {
            v202 = v180;
          }

          speex_bits_pack(v66, v202, 5);
          v203 = *(a1 + 168);
          if (v203)
          {
            *(v203 + 2 * v138) = v179;
          }
        }

        *(*(a1 + 160) + 2 * v138) = v179;
        v242 = *(a1 + 36);
        v243 = *(a1 + 128);
        if (v242 >= 1)
        {
          v244 = *(a1 + 128);
          v245 = v128;
          v246 = *(a1 + 36);
          do
          {
            v247 = *v244++;
            *v245++ = v247;
            --v246;
          }

          while (v246);
        }

        iir_mem16(v201, *(a1 + 120), v173, *(a1 + 24), v242, v243);
        v136 = filter_mem16(v173, v282, v281, v279, *(a1 + 24), *(a1 + 36), *(a1 + 144));
        ++v138;
      }

      while (v138 < *(a1 + 28));
      LODWORD(v117) = *(a1 + 36);
    }

    v248 = v270;
    if (v117 >= 1)
    {
      v249 = *(a1 + 104);
      v250 = v117;
      v251 = v117;
      do
      {
        v252 = *v67++;
        *v249++ = v252;
        --v251;
      }

      while (v251);
      v253 = *(a1 + 112);
      do
      {
        v254 = *v248++;
        *v253++ = v254;
        --v250;
      }

      while (v250);
    }

    *(a1 + 40) = 0;
    return 1;
  }
}

void qmf_decomp(__int16 *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  v43 = *MEMORY[0x1E69E9840];
  *&v10 = 0xAAAAAAAAAAAAAAAALL;
  *(&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v42[0] = v10;
  v42[1] = v10;
  v42[2] = v10;
  v42[3] = v10;
  v42[4] = v10;
  v42[5] = v10;
  v42[6] = v10;
  v42[7] = v10;
  v11 = (a4 + 63);
  MEMORY[0x1EEE9AC00](a1);
  v13 = v42 - v12;
  if (v11)
  {
    memset(v42 - v12, 170, 2 * v11);
  }

  bzero(v13, 2 * v11);
  v14 = &h0;
  for (i = 7; i != -1; --i)
  {
    v16 = *v14++;
    v17 = vrev64q_s16(v16);
    v42[i] = vextq_s8(v17, v17, 8uLL);
  }

  v18 = 124;
  v19 = v13;
  do
  {
    *v19++ = *(a5 + v18);
    v18 -= 2;
  }

  while (v18 != -2);
  if (a4 > 0)
  {
    v20 = v13 + 126;
    v21 = a4;
    v22 = a1;
    do
    {
      v23 = *v22++;
      *v20++ = v23 >> 1;
      --v21;
    }

    while (v21);
  }

  v24 = 0;
  v25 = a4 - 1;
  do
  {
    *(a5 + v24) = a1[v25] >> 1;
    v24 += 2;
    --v25;
  }

  while (v24 != 126);
  if (a4 >= 1)
  {
    v26 = 0;
    do
    {
      v27 = 0;
      v28 = 0uLL;
      v29 = 96;
      v30 = 0uLL;
      v31 = 0uLL;
      v32 = 0uLL;
      do
      {
        v33 = &v42[v27];
        v44 = vld2q_s16(v33);
        v34 = &v13[v27 * 16];
        v45 = vld2q_s16(v34);
        v35 = &v13[v29];
        v46 = vld2q_s16(v35);
        v36 = vrev64q_s16(v46.val[0]);
        v37 = vextq_s8(v36, v36, 8uLL);
        v46.val[0] = vrev64q_s16(v46.val[1]);
        v46.val[0] = vextq_s8(v46.val[0], v46.val[0], 8uLL);
        v46.val[1] = vaddq_s16(v46.val[0], v45.val[0]);
        v46.val[0] = vsubq_s16(v45.val[0], v46.val[0]);
        v38 = vmlsl_s16(v28, *v46.val[0].i8, *v44.val[0].i8);
        v39 = vmlsl_high_s16(v30, v46.val[0], v44.val[0]);
        v46.val[0] = vaddq_s16(v37, v45.val[1]);
        v32 = vmlal_high_s16(vmlal_high_s16(v32, v46.val[1], v44.val[0]), v46.val[0], v44.val[1]);
        v31 = vmlal_s16(vmlal_s16(v31, *v46.val[1].i8, *v44.val[0].i8), *v46.val[0].i8, *v44.val[1].i8);
        v45.val[0] = vsubq_s16(v45.val[1], v37);
        v30 = vmlal_high_s16(v39, v45.val[0], v44.val[1]);
        v28 = vmlal_s16(v38, *v45.val[0].i8, *v44.val[1].i8);
        v27 += 2;
        v29 -= 32;
      }

      while (v29 != 32);
      v40 = (vaddvq_s32(vaddq_s32(v28, v30)) + 0x4000) >> 15;
      v41 = (vaddvq_s32(vaddq_s32(v31, v32)) + 0x4000) >> 15;
      if (v41 <= -32767)
      {
        v41 = -32767;
      }

      if (v41 >= 0x7FFF)
      {
        LOWORD(v41) = 0x7FFF;
      }

      *(a2 + 2 * v26) = v41;
      if (v40 <= -32767)
      {
        v40 = -32767;
      }

      if (v40 >= 0x7FFF)
      {
        LOWORD(v40) = 0x7FFF;
      }

      *(a3 + 2 * v26++) = v40;
      v13 += 4;
    }

    while (v26 != ((a4 - 1) >> 1) + 1);
  }
}

__int16 *_spx_autocorr(__int16 *result, uint64_t a2, int a3, int a4)
{
  v4 = a4;
  v5 = 1;
  if (a4 >= 1)
  {
    v6 = result;
    v7 = a4;
    do
    {
      v8 = *v6++;
      v5 += (v8 * v8) >> 8;
      --v7;
    }

    while (v7);
  }

  v9 = v5 + a4;
  if (v5 + a4 > 0x3FFFFFFF)
  {
    LOBYTE(v11) = 18;
    LOBYTE(v10) = 8;
  }

  else
  {
    v10 = 8;
    do
    {
      v9 *= 2;
      --v10;
    }

    while (v10 && v9 < 0x40000000);
    if (v9 > 0x3FFFFFFF)
    {
      LOBYTE(v11) = 18;
    }

    else
    {
      v11 = 18;
      do
      {
        if (!--v11)
        {
          break;
        }

        v9 *= 2;
      }

      while (v9 < 0x40000000);
    }
  }

  if (a3 >= 1)
  {
    v12 = 0;
    v13 = 0;
    do
    {
      if (v13 >= a4)
      {
        v14 = 0;
      }

      else
      {
        v14 = 0;
        v15 = result;
        v16 = v4;
        do
        {
          v14 += (*v15 * v15[v12]) >> v10;
          ++v15;
          --v16;
        }

        while (v16);
      }

      *(a2 + 2 * v13++) = v14 >> v11;
      --v4;
      ++v12;
    }

    while (v13 != a3);
  }

  return result;
}

void _spx_lpc(__int16 *a1, _WORD *a2, int a3)
{
  v3 = *a2;
  if (*a2)
  {
    if (a3 >= 1)
    {
      v4 = 0;
      v5 = 0;
      v6 = a1 - 1;
      v7 = a3;
      do
      {
        if (v5 >> 1 <= 1)
        {
          v8 = 1;
        }

        else
        {
          v8 = v5 >> 1;
        }

        if (v5 >> 1 <= 1)
        {
          v9 = 1;
        }

        else
        {
          v9 = v5 >> 1;
        }

        v10 = v5 + 1;
        v11 = -8192 * a2[v5 + 1];
        if (v5)
        {
          v12 = a1;
          v13 = v4;
          do
          {
            v14 = *v12++;
            v11 -= *(a2 + v13) * v14;
            v13 -= 2;
          }

          while (v13);
        }

        v15 = (v11 + ((v3 + 1) >> 1)) / (v3 + 8);
        a1[v5] = v15;
        if (v5 >= 2)
        {
          v16 = a1;
          v17 = v6;
          do
          {
            v18 = *v16;
            *v16++ = v18 + ((v15 * *v17 + 4096) >> 13);
            *v17-- += (v15 * v18 + 4096) >> 13;
            --v8;
          }

          while (v8);
        }

        else
        {
          v9 = 0;
        }

        if (v5)
        {
          v19 = v15;
          a1[v9] += (v15 * a1[v9] + 4096) >> 13;
        }

        else
        {
          v19 = v15;
        }

        v3 -= (((v3 * v19) >> 13) * v19) >> 13;
        v4 += 2;
        ++v6;
        v5 = v10;
      }

      while (v10 != v7);
    }
  }

  else if (a3 >= 1)
  {
    bzero(a1, (2 * a3));
  }
}

uint64_t lpc_to_lsp(__int16 *a1, int a2, uint64_t a3, int a4)
{
  v102 = a3;
  v6 = a1;
  v103 = *MEMORY[0x1E69E9840];
  v7 = (a2 / 2);
  v8 = MEMORY[0x1EEE9AC00](a1);
  v10 = (&v96 - v9);
  v11 = (v7 + 1);
  v12 = 4 * v11;
  if (v7 == -1)
  {
    MEMORY[0x1EEE9AC00](v8);
    v13 = (&v96 - ((v12 + 15) & 0x7FFFFFFF0));
    v12 = 0;
  }

  else
  {
    v14 = memset(&v96 - v9, 170, 4 * v11);
    MEMORY[0x1EEE9AC00](v14);
    v13 = (&v96 - ((v12 + 15) & 0x7FFFFFFF0));
    memset(v13, 170, 4 * v11);
  }

  bzero(v10, v12);
  bzero(v13, v12);
  *v13 = 0x2000;
  *v10 = 0x2000;
  if (a2 >= 2)
  {
    v16 = &v6[a2 - 1];
    v17 = v10 + 1;
    v18 = v13 + 1;
    v19 = 0x2000;
    v20 = v7;
    v21 = 0x2000;
    do
    {
      v23 = *v6++;
      v22 = v23;
      v24 = *v16--;
      v21 = v24 + v22 - v21;
      *v18++ = v21;
      v19 += v22 - v24;
      *v17++ = v19;
      --v20;
    }

    while (v20);
    v25 = v7;
    v26 = v10;
    v27 = v13;
    do
    {
      *v27 = (*v27 + 2) >> 2;
      ++v27;
      *v26 = (*v26 + 2) >> 2;
      ++v26;
      --v25;
    }

    while (v25);
  }

  v13[v7] = (v13[v7] + 4) >> 3;
  v10[v7] = (v10[v7] + 4) >> 3;
  v28 = 2 * v11;
  MEMORY[0x1EEE9AC00](v15);
  v29 = (2 * v11 + 15) & 0x3FFFFFFF0;
  v30 = &v96 - v29;
  v101 = &v96 - v29;
  if (v7 == -1)
  {
    v33 = MEMORY[0x1EEE9AC00](v30);
    v32 = &v96 - v29;
    v28 = 0;
  }

  else
  {
    v31 = memset(v30, 170, 2 * v11);
    MEMORY[0x1EEE9AC00](v31);
    v32 = &v96 - v29;
    memset(&v96 - v29, 170, 2 * v11);
    v33 = v101;
  }

  bzero(v33, v28);
  bzero(v32, v28);
  if (a2 < -1)
  {
    return 0;
  }

  v34 = 0;
  v100 = v7;
  v35 = v101;
  do
  {
    *&v35[2 * v34] = v13[v34];
    *&v32[2 * v34] = v10[v34];
    ++v34;
  }

  while (v11 != v34);
  if (a2 < 1)
  {
    return 0;
  }

  v36 = 0;
  LOWORD(v37) = 0;
  result = 0;
  v39 = v11 - 2;
  v98 = 2 * v100 - 4;
  v99 = v32;
  v40 = 0x4000;
  v97 = a2;
  do
  {
    if (v36)
    {
      v41 = v99;
    }

    else
    {
      v41 = v35;
    }

    v42 = v40;
    if (v40 >= 0x3FFF)
    {
      v42 = 0x3FFF;
    }

    if (v42 <= -16383)
    {
      v43 = -16383;
    }

    else
    {
      v43 = v42;
    }

    v44 = &v41[2 * v100];
    v45 = *v44;
    v46 = *(v44 - 1);
    v47 = v45 + ((v46 * v43 + 0x2000) >> 14);
    if (a2 >= 4)
    {
      v48 = &v41[v98];
      v49 = 0x4000;
      v50 = v39;
      v51 = v43;
      do
      {
        v52 = ((v51 * v43) >> 13) - v49;
        v53 = *v48;
        v48 -= 2;
        v47 += ((((v51 * v43) >> 13) - v49) * v53 + 0x2000) >> 14;
        v49 = v51;
        v51 = v52;
        --v50;
      }

      while (v50);
    }

    if (v37 >= -16384)
    {
      v54 = &v41[v98];
      do
      {
        v55 = ((0x40000000 - ((56000 * ((v40 * v40) >> 14)) & 0xFFFF0000)) >> 16) * a4;
        v56 = v55 >> 15;
        v57 = ((v55 >> 15) + 1) >> 1;
        if ((v47 + 511) >= 0x3FF)
        {
          v57 = v56;
        }

        v37 = v40 - v57;
        v58 = (v40 - v57);
        if (v58 >= 0x3FFF)
        {
          v58 = 0x3FFF;
        }

        if (v58 <= -16383)
        {
          v59 = -16383;
        }

        else
        {
          v59 = v58;
        }

        v60 = v45 + ((v59 * v46 + 0x2000) >> 14);
        if (a2 >= 4)
        {
          v61 = 0x4000;
          v62 = v54;
          v63 = v39;
          v64 = v59;
          do
          {
            v65 = ((v64 * v59) >> 13) - v61;
            v66 = *v62--;
            v60 += ((((v64 * v59) >> 13) - v61) * v66 + 0x2000) >> 14;
            v61 = v64;
            v64 = v65;
            --v63;
          }

          while (v63);
        }

        v67 = ((v60 ^ v47) & 0x70000000) != 0 || v47 == 0;
        v68 = !v67;
        if (v67)
        {
          v69 = 0;
          do
          {
            v70 = (((v40 << 16 >> 1) + 0x8000) >> 16) + ((((v37 << 16) >> 1) + 0x8000) >> 16);
            v71 = ((((v40 << 16 >> 1) + 0x8000) >> 16) + ((((v37 << 16) >> 1) + 0x8000) >> 16));
            if (v71 >= 0x3FFF)
            {
              v72 = 0x3FFF;
            }

            else
            {
              v72 = ((((v40 << 16 >> 1) + 0x8000) >> 16) + ((((v37 << 16) >> 1) + 0x8000) >> 16));
            }

            if (v72 <= -16383)
            {
              v73 = -16383;
            }

            else
            {
              v73 = v72;
            }

            v74 = v45 + ((v73 * v46 + 0x2000) >> 14);
            if (a2 >= 4)
            {
              v75 = 0x4000;
              v76 = v54;
              v77 = v39;
              v78 = v73;
              do
              {
                v79 = ((v78 * v73) >> 13) - v75;
                v80 = *v76--;
                v74 += ((((v78 * v73) >> 13) - v75) * v80 + 0x2000) >> 14;
                v75 = v78;
                v78 = v79;
                --v77;
              }

              while (v77);
            }

            v81 = ((v74 ^ v47) & 0x70000000) != 0 || v47 == 0;
            if (v81)
            {
              v37 = (((v40 << 16 >> 1) + 0x8000) >> 16) + ((((v37 << 16) >> 1) + 0x8000) >> 16);
            }

            else
            {
              v47 = v74;
            }

            if (!v81)
            {
              v40 = v70;
            }

            v67 = v69++ == 10;
          }

          while (!v67);
          if (v71 >= 0)
          {
            v82 = v71;
          }

          else
          {
            v82 = -v71;
          }

          v83 = (8 * ((0x4000 - v82) << 16 >> 17) * (((((11888 * ((0x4000 - v82) << 16 >> 17) + 146931712) >> 16) * ((0x4000 - v82) << 16 >> 17)) >> 13) + 16469)) >> 3;
          v84 = v83 & 0xFFFFE000;
          v85 = HIWORD(v83);
          v86 = v85 != 0;
          if (!v85)
          {
            v85 = v84;
          }

          if (v85 <= 0xFF)
          {
            v87 = 8 * v86;
          }

          else
          {
            v85 >>= 8;
            v87 = (8 * v86) | 4;
          }

          if (v85 > 0xF)
          {
            v85 >>= 4;
            v87 |= 2u;
          }

          if (v85 <= 3)
          {
            v88 = v87;
          }

          else
          {
            v88 = v87 + 1;
          }

          v89 = v84 >> (2 * v88 - 12);
          v90 = v84 << (12 - 2 * v88);
          if (v88 > 6)
          {
            LOWORD(v90) = v89;
          }

          v91 = (((((16816 * v90 - 827523072) >> 16) * 4 * v90 + 1387593728) >> 16) * 4 * v90 + 238157824) >> 16;
          v92 = v91 >> (13 - v88);
          v93 = v88 >= 0xD;
          v94 = v91 << (v88 - 13);
          if (!v93)
          {
            LOWORD(v94) = v92;
          }

          result = (result + 1);
          if (v71 < 0)
          {
            LOWORD(v94) = 25736 - v94;
          }

          *(v102 + 2 * v36) = v94;
          v40 = v71;
        }

        else
        {
          v47 = v60;
          v40 = v37;
        }

        if (v37 > -16385)
        {
          v95 = v68;
        }

        else
        {
          v95 = 0;
        }
      }

      while ((v95 & 1) != 0);
    }

    ++v36;
    v35 = v101;
  }

  while (v36 != v97);
  return result;
}

uint64_t fir_mem16(uint64_t result, __int16 *a2, uint64_t a3, int a4, int a5, _DWORD *a6)
{
  if (a4 >= 1)
  {
    v6 = 0;
    v7 = a4;
    do
    {
      v8 = *(result + 2 * v6);
      v9 = v8 + ((*a6 + 4096) >> 13);
      if (v9 <= -32767)
      {
        v9 = -32767;
      }

      if (v9 >= 0x7FFF)
      {
        LOWORD(v9) = 0x7FFF;
      }

      if (a5 >= 2)
      {
        v10 = (a5 - 1);
        v11 = a2;
        v12 = a6 + 1;
        do
        {
          v13 = *v11++;
          *(v12 - 1) = *v12 + v13 * v8;
          ++v12;
          --v10;
        }

        while (v10);
      }

      a6[a5 - 1] = a2[a5 - 1] * v8;
      *(a3 + 2 * v6++) = v9;
    }

    while (v6 != v7);
  }

  return result;
}

void compute_impulse_response(__int16 *a1, __int16 *a2, __int16 *a3, _WORD *a4, int a5, int a6)
{
  v37[1] = *MEMORY[0x1E69E9840];
  v12 = a6;
  v13 = MEMORY[0x1EEE9AC00](a1);
  v15 = (v37 - v14);
  v16 = 4 * v12;
  if (v17)
  {
    v18 = memset(v37 - v14, 170, 4 * v12);
    MEMORY[0x1EEE9AC00](v18);
    v19 = (v37 - ((v16 + 15) & 0x7FFFFFFF0));
    memset(v19, 170, 4 * v12);
    *a4 = 0x2000;
    if (a6 < 1)
    {
      v22 = 0;
      v23 = 0;
    }

    else
    {
      v20 = a4 + 1;
      do
      {
        v21 = *a2++;
        *v20++ = v21;
        --v12;
      }

      while (v12);
      v22 = 1;
      v23 = a6;
    }
  }

  else
  {
    MEMORY[0x1EEE9AC00](v13);
    v19 = (v37 - ((v16 + 15) & 0x7FFFFFFF0));
    v22 = 0;
    v23 = 0;
    *a4 = 0x2000;
  }

  if (v23 + 1 < a5)
  {
    bzero(a4 + (2 * v23) + 2, 2 * (a5 - v23 - 2) + 2);
  }

  if (v22)
  {
    bzero(v19, v16);
    bzero(v15, v16);
  }

  if (a5 >= 1)
  {
    v24 = 0;
    v25 = a6 - 1;
    do
    {
      v26 = a4[v24] + ((8 * *v15 + 0x8000) >> 16);
      v27 = -v26;
      v28 = *v19 + (v26 << 14) + 4096;
      a4[v24] = v28 >> 13;
      v29 = -(v28 >> 13);
      if (a6 >= 2)
      {
        v30 = (a6 - 1);
        v31 = a3;
        v32 = v15 + 1;
        v33 = a1;
        v34 = v19 + 1;
        do
        {
          v35 = *v31++;
          *(v32 - 1) = *v32 + v35 * v27;
          v36 = *v33++;
          *(v34 - 1) = *v34 + v29 * v36;
          ++v34;
          ++v32;
          --v30;
        }

        while (v30);
      }

      v15[v25] = v27 * a3[v25];
      v19[v25] = v29 * a1[v25];
      ++v24;
    }

    while (v24 != a5);
  }
}

uint64_t filter_mem16(uint64_t result, __int16 *a2, __int16 *a3, uint64_t a4, int a5, int a6, _DWORD *a7)
{
  if (a5 >= 1)
  {
    v7 = 0;
    v8 = a5;
    do
    {
      v9 = *(result + 2 * v7);
      v10 = v9 + ((*a7 + 4096) >> 13);
      if (v10 <= -32767)
      {
        v10 = -32767;
      }

      if (v10 >= 0x7FFF)
      {
        LOWORD(v10) = 0x7FFF;
      }

      v11 = -v10;
      if (a6 >= 2)
      {
        v12 = (a6 - 1);
        v13 = a2;
        v14 = a3;
        v15 = a7 + 1;
        do
        {
          v16 = *v13++;
          v17 = *v15 + v16 * v9;
          v18 = *v14++;
          *(v15++ - 1) = v17 + v11 * v18;
          --v12;
        }

        while (v12);
      }

      a7[a6 - 1] = a2[a6 - 1] * v9 + v11 * a3[a6 - 1];
      *(a4 + 2 * v7++) = v10;
    }

    while (v7 != v8);
  }

  return result;
}

__int16 *signal_div(__int16 *result, _WORD *a2, int a3, int a4)
{
  if (a3 <= 0x400000)
  {
    if (a3 <= 4096)
    {
      if (a4 >= 1)
      {
        if ((a3 + 64) >> 7 <= 5)
        {
          v8 = 5;
        }

        else
        {
          v8 = (a3 + 64) >> 7;
        }

        v9 = a4;
        v10 = 0x20000 / v8;
        do
        {
          v11 = *result++;
          *a2++ = (v10 * (4 * v11) + 32) >> 6;
          --v9;
        }

        while (v9);
      }
    }

    else if (a4 >= 1)
    {
      v6 = a4;
      do
      {
        v7 = *result++;
        *a2++ = (0x20000 / ((a3 + 256) >> 9) * (4 * v7) + 128) >> 8;
        --v6;
      }

      while (v6);
    }
  }

  else if (a4 >= 1)
  {
    v4 = a4;
    do
    {
      v5 = *result++;
      *a2++ = (((((4 * a3 + 0x8000) >> 17) + 0x200000) / ((4 * a3 + 0x8000) >> 16)) * v5 + 0x4000) >> 15;
      --v4;
    }

    while (v4);
  }

  return result;
}

uint64_t compute_rms(int32x4_t *a1, int a2)
{
  if (a2 < 1)
  {
    v9 = 0;
    v10 = 3;
  }

  else
  {
    v2 = 1;
    v3 = a1;
    v4 = a2;
    do
    {
      v6 = *v3++;
      v5 = v6;
      if (v6 < 0)
      {
        v5 = -v5;
      }

      if (v5 > v2)
      {
        v2 = v5;
      }

      --v4;
    }

    while (v4);
    if (v2 < 0x4000)
    {
      v7 = 0;
    }

    else
    {
      v7 = 0;
      do
      {
        ++v7;
        v8 = v2 >> 15;
        v2 >>= 1;
      }

      while (v8);
    }

    v11 = 0;
    v9 = 0;
    v12 = vnegq_s32(vdupq_n_s32(v7));
    do
    {
      v13 = *a1++;
      v14 = vshrq_n_s32(vshlq_n_s32(vshlq_s32(v13, v12), 0x10uLL), 0x10uLL);
      v9 += vaddvq_s32(vmulq_s32(v14, v14)) >> 6;
      v11 += 4;
    }

    while (v11 < a2);
    v10 = v7 + 3;
  }

  v15 = v9 / a2;
  v16 = (v9 / a2) >> 16;
  v17 = v16 != 0;
  if (!v16)
  {
    v16 = v15;
  }

  if (v16 <= 0xFF)
  {
    v18 = 8 * v17;
  }

  else
  {
    v16 >>= 8;
    v18 = (8 * v17) | 4;
  }

  if (v16 > 0xF)
  {
    v16 >>= 4;
    v18 |= 2u;
  }

  if (v16 <= 3)
  {
    v19 = v18;
  }

  else
  {
    v19 = v18 + 1;
  }

  v20 = v15 >> (2 * v19 - 12);
  v21 = v15 << (12 - 2 * v19);
  if (v19 > 6)
  {
    LOWORD(v21) = v20;
  }

  v22 = (((((16816 * v21 - 827523072) >> 16) * 4 * v21 + 1387593728) >> 16) * 4 * v21 + 238157824) >> 16;
  v23 = v22 >> (13 - v19);
  v24 = v22 << (v19 - 13);
  if (v19 < 0xD)
  {
    LOWORD(v24) = v23;
  }

  return (((v24 << v10) + 0x2000) >> 14);
}

void sb_encoder_destroy(uint64_t a1)
{
  (*(**(a1 + 8) + 40))(*(a1 + 8));
  free(*(a1 + 64));
  free(*(a1 + 72));
  free(*(a1 + 80));
  free(*(a1 + 104));
  free(*(a1 + 112));
  free(*(a1 + 120));
  free(*(a1 + 152));
  free(*(a1 + 160));
  free(*(a1 + 128));
  free(*(a1 + 136));
  free(*(a1 + 144));

  free(a1);
}

void *sb_encoder_init(uint64_t *a1)
{
  v2 = malloc_type_calloc(0xF8uLL, 1uLL, 0x6CE94CD7uLL);
  v3 = v2;
  if (v2)
  {
    *v2 = a1;
    v4 = *a1;
    v5 = (*(*v4 + 32))();
    v3[1] = v5;
    v3[7] = 0;
    v6 = *(v4 + 8);
    v7 = *(v4 + 12);
    *(v3 + 4) = 2 * v6;
    *(v3 + 5) = v6;
    *(v3 + 6) = v7;
    *(v3 + 7) = v6 / v7;
    v8 = v7 + v6;
    v9 = *(v4 + 16);
    *(v3 + 8) = v8;
    *(v3 + 9) = v9;
    *(v3 + 55) = 1;
    v3[28] = v4 + 32;
    v10 = *(v4 + 96);
    *(v3 + 58) = v10;
    *(v3 + 59) = v10;
    v28 = 9;
    (*(*v5 + 80))(v5, 4, &v28);
    v28 = 1;
    (*(*v3[1] + 80))(v3[1], 105, &v28);
    *(v3 + 22) = *(v4 + 24);
    *(v3 + 46) = *(v4 + 20);
    *(v3 + 10) = 1;
    v3[8] = malloc_type_calloc(2 * (*(v3 + 8) - *(v3 + 5)), 1uLL, 0x6CE94CD7uLL);
    v3[9] = malloc_type_calloc(0x80uLL, 1uLL, 0x6CE94CD7uLL);
    v3[10] = malloc_type_calloc(0x80uLL, 1uLL, 0x6CE94CD7uLL);
    v3[11] = &lpc_window;
    v3[12] = &lag_window;
    v3[13] = malloc_type_calloc(2 * *(v3 + 9), 1uLL, 0x6CE94CD7uLL);
    v3[14] = malloc_type_calloc(2 * *(v3 + 9), 1uLL, 0x6CE94CD7uLL);
    v3[15] = malloc_type_calloc(2 * *(v3 + 9), 1uLL, 0x6CE94CD7uLL);
    v3[19] = malloc_type_calloc(4 * *(v3 + 7), 1uLL, 0x6CE94CD7uLL);
    v3[20] = malloc_type_calloc(2 * *(v3 + 7), 1uLL, 0x6CE94CD7uLL);
    v3[21] = 0;
    v3[16] = malloc_type_calloc(4 * *(v3 + 9), 1uLL, 0x6CE94CD7uLL);
    v3[17] = malloc_type_calloc(4 * *(v3 + 9), 1uLL, 0x6CE94CD7uLL);
    v3[18] = malloc_type_calloc(4 * *(v3 + 9), 1uLL, 0x6CE94CD7uLL);
    v11 = *(v3 + 9);
    if (v11 >= 1)
    {
      v12 = v11 + 1;
      v13 = (v11 + 7) & 0xFFFFFFF8;
      v14 = vdupq_n_s64(v11 - 1);
      v15 = xmmword_19B0B2390;
      v16 = xmmword_19B0B23A0;
      v17 = xmmword_19B0A5840;
      v18 = xmmword_19B0A5850;
      v19 = (v3[13] + 8);
      v20.i64[0] = 0x1000000010000;
      v20.i64[1] = 0x1000000010000;
      v21 = vdupq_n_s32(0x6488u);
      v22 = vdupq_n_s64(8uLL);
      do
      {
        v23 = vmovn_s64(vcgeq_u64(v14, v18));
        v24 = vmulq_s32(vshrq_n_s32(vaddq_s32(vshlq_n_s32(vuzp1q_s32(v18, v17), 0x10uLL), v20), 0x10uLL), v21);
        if (vuzp1_s8(vuzp1_s16(v23, *v14.i8), *v14.i8).u8[0])
        {
          *(v19 - 4) = v24.i32[0] / v12;
        }

        if (vuzp1_s8(vuzp1_s16(v23, *&v14), *&v14).i8[1])
        {
          *(v19 - 3) = v24.i32[1] / v12;
        }

        if (vuzp1_s8(vuzp1_s16(*&v14, vmovn_s64(vcgeq_u64(v14, *&v17))), *&v14).i8[2])
        {
          *(v19 - 2) = v24.i32[2] / v12;
          *(v19 - 1) = v24.i32[3] / v12;
        }

        v25 = vmulq_s32(vshrq_n_s32(vaddq_s32(vshlq_n_s32(vuzp1q_s32(v16, v15), 0x10uLL), v20), 0x10uLL), v21);
        v26 = vmovn_s64(vcgeq_u64(v14, v16));
        if (vuzp1_s8(*&v14, vuzp1_s16(v26, *&v14)).i32[1])
        {
          *v19 = v25.i32[0] / v12;
        }

        if (vuzp1_s8(*&v14, vuzp1_s16(v26, *&v14)).i8[5])
        {
          v19[1] = v25.i32[1] / v12;
        }

        if (vuzp1_s8(*&v14, vuzp1_s16(*&v14, vmovn_s64(vcgeq_u64(v14, *&v15)))).i8[6])
        {
          v19[2] = v25.i32[2] / v12;
          v19[3] = v25.i32[3] / v12;
        }

        v16 = vaddq_s64(v16, v22);
        v17 = vaddq_s64(v17, v22);
        v18 = vaddq_s64(v18, v22);
        v19 += 8;
        v15 = vaddq_s64(v15, v22);
        v13 -= 8;
      }

      while (v13);
    }

    *(v3 + 44) = 1090519040;
    v3[26] = 1;
    *(v3 + 180) = xmmword_19B0B3410;
    *(v3 + 54) = 0;
    *(v3 + 60) = 2;
    (*(*v3[1] + 80))(v3[1], 25, v3 + 244);
    *(v3 + 61) *= 2;
  }

  return v3;
}

uint64_t wb_mode_query(uint64_t a1, int a2, int *a3)
{
  if (a2 == 1)
  {
    v6 = *a3;
    if (v6)
    {
      v7 = *(a1 + 8 * v6 + 32);
      result = 0;
      if (v7)
      {
        v5 = *(v7 + 84);
      }

      else
      {
        v5 = -1;
      }
    }

    else
    {
      result = 0;
      v5 = 4;
    }
  }

  else
  {
    if (a2)
    {
      fprintf(*MEMORY[0x1E69E9848], "warning: %s %d\n", "Unknown wb_mode_query request: ", a2);
      return 0xFFFFFFFFLL;
    }

    result = 0;
    v5 = 2 * *(a1 + 8);
  }

  *a3 = v5;
  return result;
}

uint64_t lsp_unquant_high(_WORD *a1, int a2, uint64_t *a3)
{
  if (a2 <= 0)
  {
    speex_bits_unpack_unsigned(a3, 6);

    return speex_bits_unpack_unsigned(a3, 6);
  }

  else
  {
    v5 = a1;
    v6 = 0;
    v7 = a2;
    v8 = vdupq_n_s64(a2 - 1);
    v9 = xmmword_19B0B2390;
    v10 = xmmword_19B0B23A0;
    v11 = xmmword_19B0A5840;
    v12 = xmmword_19B0A5850;
    v13 = a1 + 4;
    v14 = vdupq_n_s64(8uLL);
    do
    {
      v15 = vmovn_s64(vcgeq_u64(v8, v12));
      if (vuzp1_s8(vuzp1_s16(v15, *v8.i8), *v8.i8).u8[0])
      {
        *(v13 - 4) = WORD1(v6) + 6144;
      }

      if (vuzp1_s8(vuzp1_s16(v15, *&v8), *&v8).i8[1])
      {
        *(v13 - 3) = WORD1(v6) + 8704;
      }

      if (vuzp1_s8(vuzp1_s16(*&v8, vmovn_s64(vcgeq_u64(v8, *&v11))), *&v8).i8[2])
      {
        *(v13 - 2) = ((v6 + 335544320) >> 16) + 6144;
        *(v13 - 1) = ((v6 + 503316480) >> 16) + 6144;
      }

      v16 = vmovn_s64(vcgeq_u64(v8, v10));
      if (vuzp1_s8(*&v8, vuzp1_s16(v16, *&v8)).i32[1])
      {
        *v13 = ((v6 + 671088640) >> 16) + 6144;
      }

      if (vuzp1_s8(*&v8, vuzp1_s16(v16, *&v8)).i8[5])
      {
        v13[1] = ((v6 + 838860800) >> 16) + 6144;
      }

      if (vuzp1_s8(*&v8, vuzp1_s16(*&v8, vmovn_s64(vcgeq_u64(v8, *&v9)))).i8[6])
      {
        v13[2] = ((v6 + 1006632960) >> 16) + 6144;
        v13[3] = ((v6 + 1174405120) >> 16) + 6144;
      }

      v10 = vaddq_s64(v10, v14);
      v11 = vaddq_s64(v11, v14);
      v12 = vaddq_s64(v12, v14);
      v9 = vaddq_s64(v9, v14);
      v6 += 1342177280;
      v13 += 8;
    }

    while (1342177280 * ((a2 + 7) >> 3) != v6);
    v17 = &high_lsp_cdbk + speex_bits_unpack_unsigned(a3, 6) * a2;
    v18 = v5;
    v19 = v7;
    do
    {
      v20 = *v17++;
      *v18++ += 32 * v20;
      --v19;
    }

    while (v19);
    result = speex_bits_unpack_unsigned(a3, 6);
    v22 = &high_lsp_cdbk2 + a2 * result;
    do
    {
      v23 = *v22++;
      *v5++ += 16 * v23;
      --v7;
    }

    while (v7);
  }

  return result;
}

_DWORD *lsp_quant_high(__int16 *a1, __int16 *a2, int a3, _DWORD *a4)
{
  v6 = a2;
  v7 = a1;
  v21[3] = *MEMORY[0x1E69E9840];
  memset(v21, 170, 20);
  v8 = a3;
  if (a3 <= 0)
  {
    compute_quant_weights(a2, v21, a3);
  }

  else
  {
    for (i = 0; i != a3; ++i)
    {
      a2[i] = a1[i];
    }

    compute_quant_weights(a2, v21, a3);
    v10 = 402653184;
    v11 = v6;
    v12 = v8;
    do
    {
      *v11++ -= HIWORD(v10);
      v10 += 167772160;
      --v12;
    }

    while (v12);
  }

  v13 = lsp_quant(v6, &high_lsp_cdbk, a3);
  speex_bits_pack(a4, v13, 6);
  if (a3 < 1)
  {
    v20 = lsp_weight_quant(v6, v21, &high_lsp_cdbk2, a3);

    return speex_bits_pack(a4, v20, 6);
  }

  else
  {
    v14 = 0;
    do
    {
      v6[v14++] *= 2;
    }

    while (a3 != v14);
    v15 = lsp_weight_quant(v6, v21, &high_lsp_cdbk2, a3);
    result = speex_bits_pack(a4, v15, 6);
    v17 = v6;
    v18 = v8;
    do
    {
      *v17 = (*v17 + 1) >> 1;
      ++v17;
      --v18;
    }

    while (v18);
    do
    {
      v19 = *v7++;
      *v6 = v19 - *v6;
      ++v6;
      --v8;
    }

    while (v8);
  }

  return result;
}

__int16 *compute_quant_weights(__int16 *result, uint64_t a2, int a3)
{
  if (a3 >= 1)
  {
    for (i = 0; i != a3; ++i)
    {
      if (i * 2)
      {
        v4 = result[i] - result[i - 1];
      }

      else
      {
        v4 = *result;
      }

      if (a3 - 1 == i)
      {
        v5 = 25736;
        v6 = &result[a3 - 1];
      }

      else
      {
        v6 = &result[i];
        v5 = result[i + 1];
      }

      v7 = (v5 - *v6);
      if (v7 < v4)
      {
        v4 = v7;
      }

      *(a2 + i * 2) = 81920 / (v4 + 300);
    }
  }

  return result;
}

uint64_t lsp_quant(_WORD *a1, uint64_t a2, int a3)
{
  LODWORD(v3) = 0;
  v4 = 0;
  v5 = a3;
  v6 = 0x7FFFFFFF;
  v7 = a2;
  do
  {
    LODWORD(v8) = v3;
    v9 = v6;
    v10 = v4;
    while (a3 < 1)
    {
      v11 = v9 <= 0;
      v9 &= v9 >> 31;
      if (v11)
      {
        v8 = v8;
      }

      else
      {
        v8 = v10;
      }

      if (++v10 == 64)
      {
        return v8;
      }
    }

    v12 = 0;
    v13 = 0;
    do
    {
      v14 = (a1[v12] - 32 * *(v7 + v12));
      v13 += v14 * v14;
      ++v12;
    }

    while (a3 != v12);
    v7 += (a3 - 1) + 1;
    if (v13 >= v6)
    {
      v3 = v3;
    }

    else
    {
      v6 = v13;
      v3 = v4;
    }

    ++v4;
  }

  while (v4 != 64);
  v15 = (a2 + v3 * a3);
  do
  {
    v16 = *v15++;
    *a1++ -= 32 * v16;
    --v5;
  }

  while (v5);
  return v3;
}

uint64_t lsp_weight_quant(_WORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  LODWORD(v4) = 0;
  v5 = 0;
  v6 = a4;
  v7 = 0x7FFFFFFF;
  v8 = a3;
  do
  {
    LODWORD(v9) = v4;
    v10 = v7;
    v11 = v5;
    while (a4 < 1)
    {
      v12 = v10 <= 0;
      v10 &= v10 >> 31;
      if (v12)
      {
        v9 = v9;
      }

      else
      {
        v9 = v11;
      }

      if (++v11 == 64)
      {
        return v9;
      }
    }

    v13 = 0;
    v14 = 0;
    do
    {
      v15 = (a1[v13] - 32 * *(v8 + v13));
      v14 += ((((v15 * v15) & 0x7FFF) * *(a2 + 2 * v13)) >> 15) + ((v15 * v15) >> 15) * *(a2 + 2 * v13);
      ++v13;
    }

    while (a4 != v13);
    v8 += (a4 - 1) + 1;
    if (v14 >= v7)
    {
      v4 = v4;
    }

    else
    {
      v7 = v14;
      v4 = v5;
    }

    ++v5;
  }

  while (v5 != 64);
  v16 = (a3 + v4 * a4);
  do
  {
    v17 = *v16++;
    *a1++ -= 32 * v17;
    --v6;
  }

  while (v6);
  return v4;
}

uint64_t split_cb_shape_sign_unquant(_DWORD *a1, int *a2, uint64_t a3, uint64_t *a4)
{
  v6 = a1;
  v33 = *MEMORY[0x1E69E9840];
  v7 = a2[1];
  v8 = *a2;
  v9 = *(a2 + 1);
  v10 = a2[5];
  result = MEMORY[0x1EEE9AC00](a1);
  v12 = (4 * v7 + 15) & 0x7FFFFFFF0;
  if (v7)
  {
    v32 = &v30 - v12;
    v13 = memset(&v30 - v12, 170, 4 * v7);
    MEMORY[0x1EEE9AC00](v13);
    v14 = &v30 - v12;
    result = memset(&v30 - v12, 170, 4 * v7);
    v15 = v32;
    if (v7 >= 1)
    {
      v30 = v9;
      v31 = v8;
      v16 = v8;
      v17 = v14;
      v18 = v7;
      do
      {
        if (v10)
        {
          v19 = speex_bits_unpack_unsigned(a4, 1);
        }

        else
        {
          v19 = 0;
        }

        *v17++ = v19;
        result = speex_bits_unpack_unsigned(a4, a2[4]);
        *v15++ = result;
        --v18;
      }

      while (v18);
      v20 = 0;
      v22 = v30;
      v21 = v31;
      v23 = v32;
      do
      {
        if (*&v14[4 * v20])
        {
          if (v21 >= 1)
          {
            v24 = (v22 + *&v23[4 * v20] * v21);
            v25 = v6;
            v26 = v16;
            do
            {
              v27 = *v24++;
              *v25++ = -512 * v27;
              --v26;
            }

            while (v26);
          }
        }

        else if (v16 >= 1)
        {
          v28 = 0;
          v29 = v22 + *&v23[4 * v20] * v16;
          do
          {
            v6[v28] = *(v29 + v28) << 9;
            ++v28;
          }

          while (v16 != v28);
        }

        ++v20;
        v6 += v21;
      }

      while (v20 != v7);
    }
  }

  return result;
}

void split_cb_search_shape_sign(_WORD *a1, __int16 *a2, __int16 *a3, __int16 *a4, unsigned int *a5, unsigned int a6, uint64_t a7, _DWORD *a8, __int16 *a9, _DWORD *a10, uint64_t a11, int a12, int a13)
{
  v226 = *MEMORY[0x1E69E9840];
  if (a12 >= 10)
  {
    v16 = 10;
  }

  else
  {
    v16 = a12;
  }

  v17 = (2 * v16 / 3);
  v210 = v17;
  if (v17 <= 1)
  {
    v18 = 1;
  }

  else
  {
    v18 = v17;
  }

  if (a12 > 2)
  {
    v222 = a9;
    v193 = a13;
    v194 = a8;
    v186 = a2;
    v187 = a3;
    v188 = a4;
    v196 = a1;
    v189 = a6;
    v190 = &v184;
    MEMORY[0x1EEE9AC00](a1);
    v19 = &v184 - ((8 * v18 + 15) & 0xFFFFFFFF0);
    v20 = memset(v19, 170, 8 * v18);
    MEMORY[0x1EEE9AC00](v20);
    v207 = v19;
    v21 = memset(v19, 170, 8 * v18);
    MEMORY[0x1EEE9AC00](v21);
    v22 = memset(v19, 170, 8 * v18);
    MEMORY[0x1EEE9AC00](v22);
    v201 = v19;
    v23 = memset(v19, 170, 8 * v18);
    v24 = *a5;
    v203 = a5[1];
    v25 = a5[5];
    v26 = 1 << a5[4];
    v202 = *(a5 + 1);
    v27 = MEMORY[0x1EEE9AC00](v23);
    v30 = (&v184 - v29);
    if (v28)
    {
      v27 = memset(&v184 - v29, 170, 2 * v28);
    }

    v217 = v30;
    v215 = v25;
    MEMORY[0x1EEE9AC00](v27);
    v216 = &v184 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
    v32 = memset(v216, 170, v31);
    MEMORY[0x1EEE9AC00](v32);
    v35 = &v184 - v34;
    v192 = v33;
    v36 = 4 * v33;
    v191 = 2 * v33;
    v225 = &v184 - v34;
    if (a7)
    {
      v37 = memset(v35, 170, 2 * v33);
      MEMORY[0x1EEE9AC00](v37);
      v38 = &v184 - ((v36 + 15) & 0x7FFFFFFF0);
      memset(v38, 170, v36);
    }

    else
    {
      MEMORY[0x1EEE9AC00](v35);
      v38 = &v184 - ((v36 + 15) & 0x7FFFFFFF0);
    }

    v224 = (&v184 - ((8 * v18 + 15) & 0xFFFFFFFF0));
    v184 = a10;
    v198 = v38;
    bzero(v38, 4 * a7);
    v40 = MEMORY[0x1EEE9AC00](v39);
    v42 = &v184 - ((v41 + 15) & 0x7FFFFFFF0);
    if (v43)
    {
      v40 = memset(&v184 - ((v41 + 15) & 0x7FFFFFFF0), 170, v41);
    }

    v197 = v42;
    v205 = v24;
    v44 = v203;
    v45 = a7;
    LODWORD(v213) = 2 * v18;
    v46 = MEMORY[0x1EEE9AC00](v40);
    v49 = &v184 - v48;
    if (a7)
    {
      v46 = memset(&v184 - v48, 170, 2 * v47);
    }

    v218 = &v184 - ((8 * v18 + 15) & 0xFFFFFFFF0);
    v185 = a5;
    v195 = a7;
    v50 = 0;
    v51 = 2 * a7;
    v214 = v45;
    v52 = v207;
    v53 = v224;
    do
    {
      *&v53[v50] = v49;
      *&v52[v50] = &v49[v51];
      v50 += 4;
      v49 += 4 * v45;
    }

    while (4 * v18 != v50);
    v219 = 8 * v18;
    MEMORY[0x1EEE9AC00](v46);
    v54 = (4 * v18 + 15) & 0x7FFFFFFF0;
    v220 = &v184 - v54;
    v55 = memset(&v184 - v54, 170, 4 * v18);
    MEMORY[0x1EEE9AC00](v55);
    v56 = (&v184 - v54);
    v57 = memset(&v184 - v54, 170, 4 * v18);
    v58 = MEMORY[0x1EEE9AC00](v57);
    v59 = &v184 - v54;
    v60 = MEMORY[0x1EEE9AC00](v58);
    v223 = &v184 - v54;
    MEMORY[0x1EEE9AC00](v60);
    v61 = &v184 - v54;
    v62 = memset(&v184 - v54, 170, 4 * v18);
    v204 = 4 * v18;
    v63 = MEMORY[0x1EEE9AC00](v62);
    v221 = &v184 - v54;
    MEMORY[0x1EEE9AC00](v63);
    v66 = (&v184 - v65);
    if (v44)
    {
      memset(&v184 - v65, 170, 4 * v64);
    }

    v67 = 0;
    v68 = v218;
    v69 = v219;
    v70 = v201;
    do
    {
      v70[v67 / 8] = v66;
      *&v68[v67] = &v66[v44];
      v67 += 8;
      v66 += 2 * v44;
    }

    while (v69 != v67);
    memcpy(v225, v196, v51);
    v71 = 0;
    v72 = v224;
    do
    {
      memcpy(*&v72[v71 / 2], v225, v51);
      v71 += 8;
    }

    while (v69 != v71);
    v73 = v222;
    compute_weighted_codebook(v202, v222, v217, v216, v26, v24);
    v74 = v204;
    bzero(v221, v204);
    v76 = v205;
    v77 = v198;
    if (v203 >= 1)
    {
      v209 = 0;
      v78 = 0;
      v79 = v73;
      v80 = (v18 - 1);
      v213 = v18 - 1;
      v212 = &v223[v74 - 4];
      v211 = &v59[v74 - 4];
      v225 = &v61[v74 - 4];
      v81 = v214 - v205;
      v199 = &v79[v205];
      v200 = 2 * v205;
      v208 = 2 * v205;
      v206 = v24;
      v82 = v224;
      do
      {
        v224 = v78;
        v222 = v82;
        memset_pattern16(v61, &unk_19B0B3A10, v74);
        bzero(v223, v74);
        bzero(v59, v74);
        v83 = 0;
        v219 = v224 * v76;
        v84 = v220;
        do
        {
          v85 = *&v222[4 * v83];
          if (v24 < 1)
          {
            v90 = 0;
          }

          else
          {
            v86 = 0;
            v87 = (v85 + v209);
            v88 = v24;
            do
            {
              v89 = *v87++;
              v86 += v89 * v89;
              --v88;
            }

            while (v88);
            v90 = v86 >> 1;
          }

          v91 = (v85 + 2 * v219);
          if (v215)
          {
            vq_nbest_sign(v91, v217, v24, v26, v216, v18, v84, v56);
          }

          else
          {
            vq_nbest(v91, v217, v24, v26, v216, v18, v84, v56);
          }

          v92 = 0;
          v84 = v220;
          v93 = *&v221[4 * v83] + v90;
          v94 = v218;
          v95 = v213;
          v96 = v214;
          v97 = v223;
          v99 = v211;
          v98 = v212;
          do
          {
            v100 = v93 + v56[v92];
            if (v100 < *&v61[4 * v80])
            {
              v101 = 0;
              while (v100 >= *&v61[4 * v101])
              {
                if (v18 == ++v101)
                {
                  goto LABEL_50;
                }
              }

              v102 = (v18 - 1);
              if (v80 > v101)
              {
                v103 = v225;
                v104 = v99;
                v105 = v98;
                v106 = v95;
                v107 = v225;
                v108 = v99;
                v109 = v98;
                do
                {
                  v110 = *(v107 - 1);
                  v107 -= 4;
                  --v106;
                  *v103 = v110;
                  v112 = *(v108 - 1);
                  v108 -= 4;
                  v111 = v112;
                  v113 = *(v109 - 1);
                  v109 -= 4;
                  *v104 = v111;
                  *v105 = v113;
                  v103 = v107;
                  v104 = v108;
                  v105 = v109;
                }

                while (v106 > v101);
                v102 = v106;
              }

              *&v61[4 * v101] = v100;
              *&v59[4 * v102] = v84[v92];
              *&v97[4 * v102] = v83;
            }

LABEL_50:
            ++v92;
          }

          while (v92 != v18);
          if (!v224)
          {
            break;
          }

          ++v83;
        }

        while (v83 < v210);
        v114 = 0;
        v115 = v207;
        v116 = v206;
        v219 = v224 + 1;
        v117 = (v224 + 1) * v205;
        v118 = v203;
        v119 = v202;
        v120 = v201;
        v121 = v199;
        do
        {
          if (v96 > v117)
          {
            v122 = *&v222[4 * *&v97[4 * v114]];
            v123 = *&v115[4 * v114];
            v124 = v116;
            do
            {
              *(v123 + 2 * v124) = *(v122 + 2 * v124);
              ++v124;
            }

            while (v124 < v96);
          }

          if (v24 >= 1)
          {
            v125 = 0;
            v126 = (*&v115[4 * v114] + v208);
            v127 = v121;
            do
            {
              if (v96 - v117 >= 1)
              {
                v128 = *&v59[4 * v114];
                if (v128 >= v26)
                {
                  v129 = v26;
                }

                else
                {
                  v129 = 0;
                }

                v130 = v119[v125 + (v128 - v129) * v24];
                if (v128 < v26)
                {
                  v131 = v130;
                }

                else
                {
                  v131 = -v130;
                }

                v132 = 8 * v131;
                v133 = v126;
                v134 = v127;
                v135 = v81;
                do
                {
                  v136 = *v134++;
                  *v133++ -= (v132 * v136 + 0x8000) >> 16;
                  --v135;
                }

                while (v135);
              }

              ++v125;
              --v127;
            }

            while (v125 != v24);
          }

          v137 = v120[v114];
          v97 = v223;
          v138 = *&v94[8 * *&v223[4 * v114]];
          v139 = v137;
          v140 = v118;
          do
          {
            v141 = *v138++;
            *v139++ = v141;
            --v140;
          }

          while (v140);
          v137[v224] = *&v59[4 * v114++];
        }

        while (v114 != v18);
        for (i = 0; i != v18; ++i)
        {
          v143 = v120[i];
          v144 = *&v94[8 * i];
          v145 = v118;
          do
          {
            v146 = *v143++;
            *v144++ = v146;
            --v145;
          }

          while (v145);
        }

        memcpy(v221, v61, v204);
        v206 = (v206 + v24);
        v209 += v200;
        v76 = v205;
        v81 -= v205;
        v208 += v200;
        v78 = v219;
        v82 = v207;
        v207 = v222;
        v147 = v219 == v118;
        v74 = v204;
      }

      while (!v147);
      v148 = *v201;
      v149 = v197;
      v150 = v203;
      v151 = v185;
      v152 = v184;
      v153 = v215;
      do
      {
        v154 = *v148++;
        *v149++ = v154;
        speex_bits_pack(v152, v154, v151[4] + v153);
        --v150;
      }

      while (v150);
      v155 = 0;
      v75 = v205;
      v77 = v198;
      v156 = v198;
      v157 = v203;
      v158 = v202;
      v159 = v197;
      do
      {
        v160 = v159[v155];
        if (v160 >= v26)
        {
          v161 = v26;
        }

        else
        {
          v161 = 0;
        }

        v162 = v160 - v161;
        if (v160 >= v26)
        {
          if (v24 >= 1)
          {
            v165 = &v158[v75 * v162];
            v166 = v156;
            v167 = v24;
            do
            {
              v168 = *v165++;
              *v166++ = -512 * v168;
              --v167;
            }

            while (v167);
          }
        }

        else if (v24 >= 1)
        {
          v163 = 0;
          v164 = &v158[v75 * v162];
          do
          {
            v156[v163] = v164[v163] << 9;
            ++v163;
          }

          while (v24 != v163);
        }

        ++v155;
        v156 += v75;
      }

      while (v155 != v157);
    }

    v169 = v195;
    v170 = v194;
    v171 = v192;
    if (v195 >= 1)
    {
      v172 = v77;
      v173 = v192;
      do
      {
        v174 = *v172++;
        *v170++ += v174;
        --v173;
      }

      while (v173);
    }

    if (v193)
    {
      MEMORY[0x1EEE9AC00](v75);
      v176 = (&v184 - ((v175 + 15) & 0x3FFFFFFF0));
      if (v169 && (memset(&v184 - ((v175 + 15) & 0x3FFFFFFF0), 170, v175), v169 >= 1))
      {
        v177 = 0;
        v178 = v189;
        v179 = v188;
        v180 = v187;
        v181 = v186;
        do
        {
          v176[v177] = (v77[v177] + 32) >> 6;
          ++v177;
        }

        while (v171 != v177);
        syn_percep_zero16(v176, v181, v180, v179, v176, v169, v178);
        v182 = v196;
        do
        {
          v183 = *v176++;
          *v182++ -= ((v183 << 14) + 0x8000) >> 16;
          --v171;
        }

        while (v171);
      }

      else
      {
        syn_percep_zero16(v176, v186, v187, v188, v176, v169, v189);
      }
    }
  }

  else
  {

    split_cb_search_shape_sign_N1(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a13);
  }
}

uint64_t split_cb_search_shape_sign_N1(_WORD *a1, __int16 *a2, __int16 *a3, __int16 *a4, int *a5, unsigned int a6, uint64_t a7, _DWORD *a8, __int16 *a9, _DWORD *a10, int a11)
{
  v88 = a7;
  v86 = a6;
  v84 = a3;
  v85 = a4;
  v83 = a2;
  v101 = *MEMORY[0x1E69E9840];
  v14 = *a5;
  v97 = a5[1];
  v15 = a5[4];
  v98 = a5[5];
  v16 = 1 << v15;
  v95 = a5;
  v93 = *(a5 + 1);
  v17 = MEMORY[0x1EEE9AC00](a1);
  v20 = (&v80 - v19);
  if (v18)
  {
    v17 = memset(&v80 - v19, 170, 2 * v18);
  }

  MEMORY[0x1EEE9AC00](v17);
  v96 = &v80 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = memset(v96, 170, v21);
  v23 = v88;
  v24 = MEMORY[0x1EEE9AC00](v22);
  v26 = &v80 - v25;
  v87 = &v80;
  v82 = 2 * v23;
  if (v27)
  {
    v28 = memset(&v80 - v25, 170, 2 * v23);
    MEMORY[0x1EEE9AC00](v28);
    v30 = &v80 - ((v29 + 15) & 0x7FFFFFFF0);
    memset(v30, 170, v29);
    v31 = v30;
  }

  else
  {
    MEMORY[0x1EEE9AC00](v24);
    v31 = &v80 - ((v32 + 15) & 0x7FFFFFFF0);
  }

  v99 = -1431655766;
  v100 = -1431655766;
  v33 = v88;
  v92 = v31;
  bzero(v31, 4 * v88);
  v81 = a1;
  memcpy(v26, a1, 2 * v33);
  result = compute_weighted_codebook(v93, a9, v20, v96, v16, v14);
  if (v97 >= 1)
  {
    v35 = 0;
    v94 = a10;
    v90 = v88;
    v91 = 4 * v14;
    v89 = &a9[v14];
    do
    {
      v36 = v35 * v14;
      v37 = &v26[2 * v35 * v14];
      if (v98)
      {
        vq_nbest_sign(v37, v20, v14, v16, v96, 1u, &v100, &v99);
      }

      else
      {
        vq_nbest(v37, v20, v14, v16, v96, 1u, &v100, &v99);
      }

      v38 = v100;
      result = speex_bits_pack(v94, v100, v95[4] + v98);
      if (v38 >= v16)
      {
        v39 = v16;
      }

      else
      {
        v39 = 0;
      }

      v40 = (v38 - v39) * v14;
      v41 = v20 + v40;
      if (v38 >= v16)
      {
        if (v14 >= 1)
        {
          v45 = &v26[2 * v36];
          v46 = v14;
          do
          {
            v47 = *v41++;
            *v45 += v47;
            v45 += 2;
            --v46;
          }

          while (v46);
          goto LABEL_22;
        }
      }

      else if (v14 >= 1)
      {
        v42 = &v26[2 * v36];
        v43 = v14;
        do
        {
          v44 = *v41++;
          *v42 -= v44;
          v42 += 2;
          --v43;
        }

        while (v43);
LABEL_22:
        if (v38 >= v16)
        {
          v52 = &v93[v40];
          v53 = (v92 + v91 * v35);
          v54 = v14;
          do
          {
            v55 = *v52++;
            *v53++ = -512 * v55;
            --v54;
          }

          while (v54);
        }

        else
        {
          v48 = &v93[v40];
          v49 = (v92 + v91 * v35);
          v50 = v14;
          do
          {
            v51 = *v48++;
            *v49++ = v51 << 9;
            --v50;
          }

          while (v50);
        }

        v56 = 0;
        v57 = v90 - ++v35 * v14;
        v58 = &v93[v40];
        v59 = v89;
        do
        {
          if (v57 >= 1)
          {
            v60 = v58[v56];
            if (v38 >= v16)
            {
              v60 = -v60;
            }

            v61 = 8 * v60;
            v62 = &v26[2 * v35 * v14];
            v63 = v59;
            v64 = v57;
            do
            {
              v65 = *v63++;
              result = (v61 * v65 + 0x8000);
              *v62 -= WORD1(result);
              v62 += 2;
              --v64;
            }

            while (v64);
          }

          ++v56;
          --v59;
        }

        while (v56 != v14);
        continue;
      }

      ++v35;
    }

    while (v35 != v97);
  }

  v66 = v88;
  if (v88 >= 1)
  {
    v67 = v92;
    v68 = v23;
    do
    {
      v69 = *v67++;
      *a8++ += v69;
      --v68;
    }

    while (v68);
  }

  if (a11)
  {
    MEMORY[0x1EEE9AC00](result);
    v71 = (&v80 - ((v70 + 15) & 0x3FFFFFFF0));
    if (v66 && (memset(&v80 - ((v70 + 15) & 0x3FFFFFFF0), 170, v70), v66 >= 1))
    {
      v72 = 0;
      v73 = v86;
      v74 = v84;
      v75 = v85;
      v76 = v83;
      v77 = v92;
      do
      {
        v71[v72] = (v77[v72] + 32) >> 6;
        ++v72;
      }

      while (v23 != v72);
      result = syn_percep_zero16(v71, v76, v74, v75, v71, v66, v73);
      v78 = v81;
      do
      {
        v79 = *v71++;
        *v78++ -= ((v79 << 14) + 0x8000) >> 16;
        --v23;
      }

      while (v23);
    }

    else
    {
      return syn_percep_zero16(v71, v83, v84, v85, v71, v66, v86);
    }
  }

  return result;
}

char *compute_weighted_codebook(char *result, __int16 *a2, uint64_t a3, _DWORD *a4, int a5, int a6)
{
  v41 = *MEMORY[0x1E69E9840];
  v6 = cb_subvect_sizelist;
  if (cb_subvect_sizelist < 1)
  {
    LODWORD(v7) = 0;
  }

  else
  {
    v7 = 0;
    while (cb_subvect_size[v7] != a6)
    {
      if (cb_subvect_sizelist == ++v7)
      {
        goto LABEL_8;
      }
    }
  }

  if (v7 == cb_subvect_sizelist)
  {
LABEL_8:
    cb_subvect_size[cb_subvect_sizelist] = a6;
    cb_subvect_sizecnt[v6] = 1;
    v8 = &cb_subvect_sizelist;
  }

  else
  {
    v8 = &cb_subvect_sizecnt[v7];
    LODWORD(v6) = *v8;
  }

  *v8 = v6 + 1;
  if (a6 == 8)
  {
    if (a5 >= 1)
    {
      v21 = a5;
      v22 = (a3 + 8);
      do
      {
        v23 = *result;
        result += 8;
        v24 = vmovl_s8(v23);
        v25 = vmovl_s16(*v24.i8);
        v26 = vrev64_s16(*v24.i8);
        v27 = (v25.i32[0] * *a2) >> 13;
        *(v22 - 4) = v27;
        v28 = (v25.i32[0] * a2[1] + v25.i32[1] * *a2) >> 13;
        *(v22 - 3) = v28;
        v29 = (v25.i32[0] * a2[2] + v25.i32[1] * a2[1] + v25.i32[2] * *a2) >> 13;
        *(v22 - 2) = v29;
        v30 = vaddvq_s32(vmull_s16(v26, *a2)) >> 13;
        *(v22 - 1) = v30;
        v31 = vmovl_high_s16(v24);
        v32 = (vaddvq_s32(vmull_s16(v26, *(a2 + 1))) + v31.i32[0] * *a2) >> 13;
        *v22 = v32;
        v33 = (vaddvq_s32(vmull_s16(v26, *(a2 + 2))) + v31.i32[0] * a2[1] + v31.i32[1] * *a2) >> 13;
        v22[1] = v33;
        v34 = (vaddvq_s32(vmull_s16(v26, *(a2 + 3))) + v31.i32[0] * a2[2] + v31.i32[2] * *a2 + v31.i32[1] * a2[1]) >> 13;
        v22[2] = v34;
        v35 = vaddvq_s32(vmlal_s16(vmull_s16(vrev64_s16(*&vextq_s8(v24, v24, 8uLL)), *a2), v26, *&vextq_s8(*a2, *a2, 8uLL)));
        v36.i64[0] = __PAIR64__(v33, v32);
        v36.i32[2] = v34;
        v36.i32[3] = v35 >> 13;
        v24.i64[0] = __PAIR64__(v27, v28);
        v24.i64[1] = __PAIR64__(v30, v29);
        v37 = vshrq_n_s32(vshlq_n_s32(v36, 0x10uLL), 0x10uLL);
        v38 = vshrq_n_s32(vshlq_n_s32(v24, 0x10uLL), 0x10uLL);
        *a4++ = vaddvq_s32(vmlaq_s32(vmulq_s32(v37, v37), v38, v38));
        v22[3] = v35 >> 13;
        v22 += 8;
        --v21;
      }

      while (v21);
    }
  }

  else if (a6 == 5)
  {
    v39 = 0xAAAAAAAAAAAAAAAALL;
    v40 = -21846;
    if (a5 >= 1)
    {
      for (i = 0; i != a5; ++i)
      {
        for (j = 0; j != 5; ++j)
        {
          v39.i16[j] = result[j];
        }

        v11 = (a3 + 10 * i);
        v12 = v39;
        v13 = vmovl_s16(v39);
        v14 = (v13.i32[0] * *a2) >> 13;
        *v11 = v14;
        v15 = (v13.i32[0] * a2[1] + v13.i32[1] * *a2) >> 13;
        v11[1] = v15;
        v16 = vrev64_s16(v12);
        v17 = (v13.i32[0] * a2[2] + v13.i32[1] * a2[1] + v13.i32[2] * *a2) >> 13;
        v11[2] = v17;
        v18 = vaddvq_s32(vmull_s16(v16, *a2)) >> 13;
        v13.i64[0] = __PAIR64__(v14, v15);
        v13.i64[1] = __PAIR64__(v18, v17);
        v19 = vshrq_n_s32(vshlq_n_s32(v13, 0x10uLL), 0x10uLL);
        v11[3] = v18;
        v20 = vaddvq_s32(vmull_s16(v16, *(a2 + 1))) + *a2 * v40;
        a4[i] = vaddvq_s32(vmulq_s32(v19, v19)) + (v20 >> 13) * (v20 >> 13);
        v11[4] = v20 >> 13;
        result += 5;
      }
    }
  }

  else
  {

    return compute_weighted_codebook_general(result, a2, a3, a4, a5, a6);
  }

  return result;
}

__int16 *vq_nbest_sign(__int16 *result, __int16 *a2, int a3, int a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8)
{
  if (a4 >= 1)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      if (a3 < 1)
      {
        v10 = 0;
      }

      else
      {
        v10 = 0;
        v11 = result;
        v12 = a3;
        v13 = a2;
        do
        {
          v15 = *v11++;
          v14 = v15;
          v16 = *v13++;
          v10 += v16 * v14;
          --v12;
        }

        while (v12);
        a2 += (a3 - 1) + 1;
      }

      if (v10 >= 0)
      {
        v17 = v10;
      }

      else
      {
        v17 = -v10;
      }

      v18 = (*(a5 + 4 * v8) >> 1) - v17;
      if (v8 < a6 || v18 < *(a8 - 4 + 4 * a6))
      {
        LODWORD(v19) = a6 - 1;
        if (a6 > 1)
        {
          v20 = 4 * a6 - 8;
          v21 = a6 + 4294967294;
          v19 = a6 - 1;
          while (v19 > v9 || v18 < *(a8 + v20))
          {
            v22 = 4 * v21;
            *(a8 + 4 * v19) = *(a8 + v22);
            *(a7 + 4 * v19) = *(a7 + v22);
            --v21;
            v20 -= 4;
            if (v19-- <= 1)
            {
              LODWORD(v19) = 0;
              break;
            }
          }
        }

        *(a8 + 4 * v19) = v18;
        *(a7 + 4 * v19) = v8;
        ++v9;
        if (v10 < 1)
        {
          *(a7 + 4 * v19) = v8 + a4;
        }
      }

      ++v8;
    }

    while (v8 != a4);
  }

  return result;
}

uint64_t vq_nbest(uint64_t result, int16x4_t *a2, int a3, int a4, uint64_t a5, unsigned int a6, _DWORD *a7, _DWORD *a8)
{
  v22 = *MEMORY[0x1E69E9840];
  v8 = vq_listlen;
  if (vq_listlen < 1)
  {
    LODWORD(v9) = 0;
  }

  else
  {
    v9 = 0;
    while (vq_lens[v9] != a3 || vq_entries[v9] != a4)
    {
      if (vq_listlen == ++v9)
      {
        goto LABEL_9;
      }
    }
  }

  if (v9 == vq_listlen)
  {
LABEL_9:
    vq_lens[vq_listlen] = a3;
    vq_entries[v8] = a4;
    vq_listlen = v8 + 1;
  }

  if (a3 == 5 && a6 == 1)
  {
    v10 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    do
    {
      *(&v19 + v10) = *(result + 2 * v10);
      ++v10;
    }

    while (v10 != 5);
    if (a4 >= 1)
    {
      v11 = 0;
      v12 = v19;
      v13 = SWORD2(v19);
      v14 = v20;
      v15 = SWORD2(v20);
      v16 = v21;
      while (1)
      {
        result = a2->i16[3];
        v17 = (*(a5 + 4 * v11) >> 1) - (v12 * a2->i16[0] + v13 * a2->i16[1] + v14 * a2->i16[2] + v15 * result + v16 * a2[1].i16[0]);
        if (!v11)
        {
          break;
        }

        if (v17 < *a8)
        {
          *a8 = v17;
          v18 = v11;
LABEL_20:
          *a7 = v18;
        }

        ++v11;
        a2 = (a2 + 10);
        if (a4 == v11)
        {
          return result;
        }
      }

      v18 = 0;
      *a8 = v17;
      goto LABEL_20;
    }
  }

  else
  {

    return vq_nbest_general(result, a2, a3, a4, a5, a6, a7, a8);
  }

  return result;
}

uint64_t syn_percep_zero16(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, uint64_t a5, int a6, unsigned int a7)
{
  v13 = a1;
  v24[1] = *MEMORY[0x1E69E9840];
  MEMORY[0x1EEE9AC00](a1);
  v15 = v24 - v14;
  if (v16)
  {
    memset(v15, 170, 4 * a7);
    if (a7 <= 0)
    {
      iir_mem16(v13, a2, a5, a6, a7, v15);
    }

    else
    {
      bzero(v15, 4 * a7);
      iir_mem16(v13, a2, a5, a6, a7, v15);
      bzero(v15, 4 * a7);
    }
  }

  else if (a6 >= 1)
  {
    v17 = a6;
    v18 = a5;
    do
    {
      v20 = *v13++;
      v19 = v20;
      if (v20 <= -32767)
      {
        v21 = -32767;
      }

      else
      {
        v21 = v19;
      }

      v22 = *(a2 - 1);
      *v18++ = v21;
      --v17;
    }

    while (v17);
    *(v15 - 1) = -v21 * v22;
  }

  return filter_mem16(a5, a3, a4, a5, a6, a7, v15);
}

uint64_t vq_nbest_general(__int16 *a1, int16x4_t *a2, int a3, int a4, uint64_t a5, unsigned int a6, _DWORD *a7, _DWORD *a8)
{
  v15 = a1;
  v41[1] = *MEMORY[0x1E69E9840];
  v16 = a3;
  result = MEMORY[0x1EEE9AC00](a1);
  v19 = (v41 - v18);
  if (v20 && (result = memset(v41 - v18, 170, 4 * v16), a3 >= 1))
  {
    v21 = v19;
    v22 = v16;
    do
    {
      v23 = *v15++;
      v21->i32[0] = v23;
      v21 = (v21 + 4);
      --v22;
    }

    while (v22);
    v24 = 1;
  }

  else
  {
    v24 = 0;
  }

  v25 = vq_listlen;
  if (vq_listlen < 1)
  {
    LODWORD(v26) = 0;
  }

  else
  {
    v26 = 0;
    while (vq_lens[v26] != a3 || vq_entries[v26] != a4)
    {
      if (vq_listlen == ++v26)
      {
        goto LABEL_15;
      }
    }
  }

  if (v26 == vq_listlen)
  {
LABEL_15:
    vq_lens[vq_listlen] = a3;
    vq_entries[v25] = a4;
    vq_listlen = v25 + 1;
  }

  if (a4 >= 1)
  {
    v27 = 0;
    v28 = 0;
    do
    {
      if (a3 == 5)
      {
        v29 = vaddvq_s32(vmulq_s32(vshrq_n_s32(vshlq_n_s32(*v19, 0x10uLL), 0x10uLL), vmovl_s16(*a2))) + v19[1].i16[0] * a2[1].i16[0];
        a2 = (a2 + 10);
      }

      else
      {
        v29 = 0;
        if (v24)
        {
          v30 = v19;
          v31 = v16;
          v32 = a2;
          do
          {
            v34 = v30->i16[0];
            v30 = (v30 + 4);
            v33 = v34;
            v35 = v32->i16[0];
            v32 = (v32 + 2);
            v29 += v33 * v35;
            --v31;
          }

          while (v31);
          a2 = (a2 + 2 * (a3 - 1) + 2);
        }
      }

      result = ((*(a5 + 4 * v27) >> 1) - v29);
      if (a6 == 1)
      {
        if (v27)
        {
          if (result < *a8)
          {
            *a8 = result;
            *a7 = v27;
          }
        }

        else
        {
          *a8 = result;
          *a7 = 0;
        }
      }

      else if (v27 < a6 || result < a8[a6 - 1])
      {
        LODWORD(v36) = a6 - 1;
        if (a6 >= 2)
        {
          v37 = 4 * a6 - 8;
          v38 = a6 + 4294967294;
          v36 = a6 - 1;
          while (v36 > v28 || result < *(a8 + v37))
          {
            v39 = v38;
            a8[v36] = a8[v39];
            a7[v36] = a7[v39];
            --v38;
            v37 -= 4;
            if (v36-- <= 1)
            {
              LODWORD(v36) = 0;
              break;
            }
          }
        }

        a8[v36] = result;
        a7[v36] = v27;
        ++v28;
      }

      ++v27;
    }

    while (v27 != a4);
  }

  return result;
}

char *compute_weighted_codebook_general(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  v28[1] = *MEMORY[0x1E69E9840];
  v12 = a6;
  result = MEMORY[0x1EEE9AC00](a1);
  v15 = v28 - v14;
  if (v16)
  {
    result = memset(v28 - v14, 170, 2 * v12);
  }

  if (a5 >= 1)
  {
    v17 = 0;
    v18 = 0;
    do
    {
      if (a6 < 1)
      {
        v24 = 0;
      }

      else
      {
        v19 = (a1 + v17);
        v20 = v15;
        v21 = v12;
        do
        {
          v22 = *v19++;
          *v20++ = v22;
          --v21;
        }

        while (v21);
        v23 = 0;
        v24 = 0;
        do
        {
          v25 = 0;
          v26 = v15;
          result = v23;
          do
          {
            v27 = *v26++;
            v25 += *&result[a2] * v27;
            result -= 2;
          }

          while (result != -2);
          v24 += (v25 >> 13) * (v25 >> 13);
          *(a3 + 2 * v18 * a6 + 2 * v21++) = v25 >> 13;
          v23 += 2;
        }

        while (v21 != v12);
      }

      *(a4 + 4 * v18++) = v24;
      v17 += a6;
    }

    while (v18 != a5);
  }

  return result;
}

uint64_t nb_decoder_ctl(uint64_t a1, int a2, int *a3)
{
  v3 = a3;
  if (a2 > 43)
  {
    if (a2 <= 100)
    {
      if (a2 <= 46)
      {
        if (a2 == 44)
        {
          result = 0;
          *(a1 + 872) = *a3;
          return result;
        }

        if (a2 == 45)
        {
          result = 0;
          v6 = *(a1 + 872);
LABEL_55:
          *v3 = v6;
          return result;
        }

LABEL_52:
        fprintf(*MEMORY[0x1E69E9848], "warning: %s %d\n", "Unknown nb_ctl request: ", a2);
        return 0xFFFFFFFFLL;
      }

      if (a2 == 47)
      {
        v17 = *(a1 + 124);
        v18 = log((*(a1 + 120) / v17));
        v19 = log((*(a1 + 122) / v17));
        result = 0;
        v20 = v18 / v19;
        if (v20 > 1.0)
        {
          v20 = 1.0;
        }

        v6 = (fmaxf(v20, 0.0) * 100.0);
        goto LABEL_55;
      }

      if (a2 != 100)
      {
        goto LABEL_52;
      }

      if (*(a1 + 24) >= 1)
      {
        v7 = 0;
        v8 = *(a1 + 104);
        do
        {
          result = 0;
          a3[v7] = *(v8 + 4 * v7);
          ++v7;
        }

        while (v7 < *(a1 + 24));
        return result;
      }
    }

    else
    {
      if (a2 > 103)
      {
        switch(a2)
        {
          case 'h':
            result = 0;
            *(a1 + 112) = a3;
            return result;
          case 'i':
            result = 0;
            *(a1 + 868) = *a3;
            return result;
          case 'j':
            result = 0;
            *a3 = *(a1 + 48);
            return result;
        }

        goto LABEL_52;
      }

      if (a2 != 101)
      {
        if (a2 == 103)
        {
          result = 0;
          v6 = *(a1 + 864);
          goto LABEL_55;
        }

        goto LABEL_52;
      }

      v21 = *(a1 + 24);
      if (v21 >= 1)
      {
        v22 = 0;
        v23 = *(a1 + 64);
        v24 = *(a1 + 20);
        do
        {
          v25 = compute_rms16((v23 + 2 * v22), v24);
          result = 0;
          *v3 = v25;
          v3 = (v3 + 2);
          v22 += v24;
          --v21;
        }

        while (v21);
        return result;
      }
    }

    return 0;
  }

  switch(a2)
  {
    case 0:
      result = 0;
      *(a1 + 164) = *a3;
      break;
    case 1:
      result = 0;
      v6 = *(a1 + 164);
      goto LABEL_55;
    case 3:
      result = 0;
      v6 = *(a1 + 16);
      goto LABEL_55;
    case 6:
    case 8:
      result = 0;
      *(a1 + 160) = *a3;
      break;
    case 7:
    case 9:
      result = 0;
      v6 = *(a1 + 160);
      goto LABEL_55;
    case 19:
      v14 = *(*(a1 + 152) + 8 * *(a1 + 160));
      v15 = *(a1 + 40);
      result = 0;
      if (v14)
      {
        v16 = *(v14 + 84) * v15;
      }

      else
      {
        v16 = 5 * v15;
      }

      v6 = v16 / *(a1 + 16);
      goto LABEL_55;
    case 20:
      result = 0;
      v9 = *a3;
      v10 = a1 + 40 * *a3;
      *(v10 + 176) = *(a3 + 2);
      *(v10 + 168) = v9;
      break;
    case 22:
      result = 0;
      *(a1 + 816) = *(a3 + 2);
      *(a1 + 808) = *a3;
      break;
    case 24:
      result = 0;
      *(a1 + 40) = *a3;
      break;
    case 25:
      result = 0;
      v6 = *(a1 + 40);
      goto LABEL_55;
    case 26:
      if (*(a1 + 28) >= 1)
      {
        v11 = 0;
        v12 = *(a1 + 88);
        do
        {
          *(v12 + 4 * v11++) = 0;
        }

        while (v11 < *(a1 + 28));
      }

      v13 = *(a1 + 36) + *(a1 + 16);
      if (v13 >= 0)
      {
        bzero(*(a1 + 56), 2 * (v13 + 1));
      }

      return 0;
    case 36:
      result = 0;
      *(a1 + 148) = *a3;
      break;
    case 37:
      result = 0;
      v6 = *(a1 + 148);
      goto LABEL_55;
    case 39:
      result = 0;
      v6 = *(a1 + 20);
      goto LABEL_55;
    default:
      goto LABEL_52;
  }

  return result;
}

uint64_t nb_encoder_ctl(uint64_t a1, int a2, int *a3)
{
  v3 = a3;
  if (a2 > 99)
  {
    if (a2 > 103)
    {
      switch(a2)
      {
        case 'h':
          result = 0;
          *(a1 + 208) = a3;
          return result;
        case 'i':
          result = 0;
          *(a1 + 304) = *a3;
          return result;
        case 'j':
          result = 0;
          *a3 = *(a1 + 72);
          return result;
      }

      goto LABEL_88;
    }

    if (a2 == 100)
    {
      if (*(a1 + 20) >= 1)
      {
        v50 = 0;
        v51 = *(a1 + 200);
        do
        {
          result = 0;
          a3[v50] = *(v51 + 4 * v50);
          ++v50;
        }

        while (v50 < *(a1 + 20));
        return result;
      }
    }

    else
    {
      if (a2 != 101)
      {
LABEL_88:
        fprintf(*MEMORY[0x1E69E9848], "warning: %s %d\n", "Unknown nb_ctl request: ", a2);
        return 0xFFFFFFFFLL;
      }

      v7 = *(a1 + 20);
      if (v7 >= 1)
      {
        v8 = 0;
        v9 = *(a1 + 96);
        v10 = *(a1 + 16);
        do
        {
          v11 = compute_rms16((v9 + 2 * v8), v10);
          result = 0;
          *v3 = v11;
          v3 = (v3 + 2);
          v8 += v10;
          --v7;
        }

        while (v7);
        return result;
      }
    }

    return 0;
  }

  switch(a2)
  {
    case 3:
      result = 0;
      v12 = *(a1 + 12);
      goto LABEL_91;
    case 4:
      result = 0;
      v45 = *a3 & ~(*a3 >> 31);
      if (v45 >= 10)
      {
        v45 = 10;
      }

      v6 = *(**a1 + 4 * v45 + 164);
      goto LABEL_63;
    case 6:
    case 8:
      result = 0;
      v6 = *a3;
LABEL_63:
      *(a1 + 296) = v6;
      *(a1 + 300) = v6;
      return result;
    case 7:
    case 9:
      result = 0;
      v12 = *(a1 + 296);
      goto LABEL_91;
    case 12:
      result = 0;
      *(a1 + 232) = *a3;
      return result;
    case 13:
      result = 0;
      v12 = *(a1 + 232);
      goto LABEL_91;
    case 14:
      result = 0;
      *(a1 + 224) = *a3;
      return result;
    case 15:
      result = 0;
      v46 = *(a1 + 224);
      goto LABEL_77;
    case 16:
      result = 0;
      *(a1 + 272) = *a3 & ~(*a3 >> 31);
      return result;
    case 17:
      result = 0;
      v12 = *(a1 + 272);
      goto LABEL_91;
    case 18:
      v54 = -1431655766;
      v55 = 10;
      v48 = *a3;
      do
      {
        (*(*a1 + 80))(a1, 4, &v55);
        (*(*a1 + 80))(a1, 19, &v54);
        if (v54 <= v48)
        {
          break;
        }

        v49 = v55--;
      }

      while (v49 > 0);
      return 0;
    case 19:
      v42 = *(*(a1 + 288) + 8 * *(a1 + 296));
      v43 = *(a1 + 276);
      result = 0;
      if (v42)
      {
        v44 = *(v42 + 84) * v43;
      }

      else
      {
        v44 = 5 * v43;
      }

      v12 = v44 / *(a1 + 12);
      goto LABEL_91;
    case 24:
      result = 0;
      *(a1 + 276) = *a3;
      return result;
    case 25:
      result = 0;
      v12 = *(a1 + 276);
      goto LABEL_91;
    case 26:
      *(a1 + 44) = 1;
      *(a1 + 8) = 1;
      v15 = *(a1 + 28);
      if (v15 >= 1)
      {
        v16 = v15 + 1;
        v17 = (v15 + 7) & 0xFFFFFFF8;
        v18 = vdupq_n_s64(v15 - 1);
        v19 = xmmword_19B0B2390;
        v20 = xmmword_19B0B23A0;
        v21 = xmmword_19B0A5840;
        v22 = xmmword_19B0A5850;
        v23 = (*(a1 + 136) + 8);
        v24.i64[0] = 0x1000000010000;
        v24.i64[1] = 0x1000000010000;
        v25 = vdupq_n_s32(0x6488u);
        v26 = vdupq_n_s64(8uLL);
        do
        {
          v27 = vmovn_s64(vcgeq_u64(v18, v22));
          v28 = vmulq_s32(vshrq_n_s32(vaddq_s32(vshlq_n_s32(vuzp1q_s32(v22, v21), 0x10uLL), v24), 0x10uLL), v25);
          if (vuzp1_s8(vuzp1_s16(v27, *v18.i8), *v18.i8).u8[0])
          {
            *(v23 - 4) = v28.i32[0] / v16;
          }

          if (vuzp1_s8(vuzp1_s16(v27, *&v18), *&v18).i8[1])
          {
            *(v23 - 3) = v28.i32[1] / v16;
          }

          if (vuzp1_s8(vuzp1_s16(*&v18, vmovn_s64(vcgeq_u64(v18, *&v21))), *&v18).i8[2])
          {
            *(v23 - 2) = v28.i32[2] / v16;
            *(v23 - 1) = v28.i32[3] / v16;
          }

          v29 = vmulq_s32(vshrq_n_s32(vaddq_s32(vshlq_n_s32(vuzp1q_s32(v20, v19), 0x10uLL), v24), 0x10uLL), v25);
          v30 = vmovn_s64(vcgeq_u64(v18, v20));
          if (vuzp1_s8(*&v18, vuzp1_s16(v30, *&v18)).i32[1])
          {
            *v23 = v29.i32[0] / v16;
          }

          if (vuzp1_s8(*&v18, vuzp1_s16(v30, *&v18)).i8[5])
          {
            v23[1] = v29.i32[1] / v16;
          }

          if (vuzp1_s8(*&v18, vuzp1_s16(*&v18, vmovn_s64(vcgeq_u64(v18, *&v19)))).i8[6])
          {
            v23[2] = v29.i32[2] / v16;
            v23[3] = v29.i32[3] / v16;
          }

          v20 = vaddq_s64(v20, v26);
          v21 = vaddq_s64(v21, v26);
          v22 = vaddq_s64(v22, v26);
          v23 += 8;
          v19 = vaddq_s64(v19, v26);
          v17 -= 8;
        }

        while (v17);
        v31 = 0;
        v33 = *(a1 + 168);
        v32 = *(a1 + 176);
        v34 = *(a1 + 152);
        v35 = *(a1 + 160);
        do
        {
          *(v32 + 4 * v31) = 0;
          *(v34 + 4 * v31) = 0;
          *(v33 + 4 * v31) = 0;
          *(v35 + 4 * v31++) = 0;
        }

        while (v31 < *(a1 + 28));
      }

      v36 = *(a1 + 12);
      v37 = *(a1 + 36) + v36;
      if (v37 >= 0)
      {
        v38 = *(a1 + 104);
        v39 = *(a1 + 88);
        v40 = (v37 + 1);
        do
        {
          *v38++ = 0;
          *v39++ = 0;
          --v40;
        }

        while (v40);
      }

      v41 = *(a1 + 24);
      if (v41 > v36)
      {
        bzero(*(a1 + 80), 2 * (v41 + ~v36) + 2);
      }

      return 0;
    case 29:
      result = 0;
      v46 = *(a1 + 228);
LABEL_77:
      *a3 = v46;
      return result;
    case 30:
      result = 0;
      *(a1 + 244) = *a3;
      return result;
    case 31:
      result = 0;
      v12 = *(a1 + 244);
      goto LABEL_91;
    case 32:
      v13 = *a3;
      *(a1 + 256) = *a3;
      *(a1 + 232) = v13 != 0;
      if (!v13)
      {
        return 0;
      }

      v54 = -1431655766;
      v55 = 10;
      v53 = -1431655766;
      (*(*a1 + 80))(a1, 19, &v53);
      break;
    case 33:
      result = 0;
      v12 = *(a1 + 256);
      goto LABEL_91;
    case 34:
      result = 0;
      *(a1 + 248) = *a3;
      return result;
    case 35:
      result = 0;
      v12 = *(a1 + 248);
      goto LABEL_91;
    case 36:
      result = 0;
      *(a1 + 284) = *a3;
      return result;
    case 37:
      result = 0;
      v12 = *(a1 + 284);
      goto LABEL_91;
    case 39:
      result = 0;
      v12 = *(a1 + 24) - *(a1 + 12);
      goto LABEL_91;
    case 40:
      result = 0;
      v47 = *a3;
      if (*a3 >= 100)
      {
        v47 = 100;
      }

      *(a1 + 280) = v47;
      return result;
    case 41:
      result = 0;
      v12 = *(a1 + 280);
      goto LABEL_91;
    case 42:
      result = 0;
      *(a1 + 236) = *a3;
      return result;
    case 43:
      result = 0;
      v12 = *(a1 + 236);
      goto LABEL_91;
    case 44:
      result = 0;
      *(a1 + 308) = *a3;
      return result;
    case 45:
      result = 0;
      v12 = *(a1 + 308);
LABEL_91:
      *a3 = v12;
      return result;
    default:
      goto LABEL_88;
  }

  while (1)
  {
    (*(*a1 + 80))(a1, 4, &v55);
    (*(*a1 + 80))(a1, 19, &v54);
    v14 = v55;
    if (v54 <= v53)
    {
      break;
    }

    --v55;
    if (v14 <= 0)
    {
      --v14;
      break;
    }
  }

  v52 = (v14 & ~(v14 >> 31));
  (*(*a1 + 80))(a1, 14, &v52);
  result = 0;
  *(a1 + 260) = 0;
  *(a1 + 264) = 0;
  return result;
}

uint64_t nb_decode(uint64_t a1, uint64_t a2, int16x4_t *a3)
{
  v264 = *MEMORY[0x1E69E9840];
  v263 = -1431655766;
  v261 = -1431655766;
  v262 = -21846;
  v259 = *(a1 + 48);
  if (!a2)
  {
    if (!*(a1 + 864))
    {
      v57 = *(a1 + 12);
      if (v57 > 9)
      {
        v58 = 0;
      }

      else
      {
        v58 = 2 * attenuation[v57];
      }

      v207 = *(a1 + 134);
      v208 = *(a1 + 136);
      v209 = *(a1 + 138);
      if (v209 >= v207)
      {
        v210 = *(a1 + 134);
      }

      else
      {
        v210 = *(a1 + 138);
      }

      if (v209 < v208)
      {
        v210 = *(a1 + 136);
      }

      if (v207 <= v209)
      {
        v211 = *(a1 + 138);
      }

      else
      {
        v211 = *(a1 + 134);
      }

      if (v208 >= v209)
      {
        v212 = v211;
      }

      else
      {
        v212 = *(a1 + 136);
      }

      if (v207 < v208)
      {
        v213 = v212;
      }

      else
      {
        v213 = v210;
      }

      v214 = *(a1 + 132);
      if (v214 > v213)
      {
        *(a1 + 132) = v213;
        LOWORD(v214) = v213;
      }

      if (v214 >= 54)
      {
        LOWORD(v214) = 54;
      }

      v215 = (v214 << 9);
      v216 = *(a1 + 16);
      v217 = compute_rms16(*(a1 + 64), *(a1 + 16));
      v218 = (v58 * v215) >> 16;
      memmove(*(a1 + 56), (*(a1 + 56) + 2 * v216), 2 * (*(a1 + 20) + 2 * *(a1 + 36) + 12));
      v219 = *(a1 + 128);
      v220 = 1664525 * *(a1 + 144) + 1013904223;
      *(a1 + 144) = v220;
      v221 = *(a1 + 16);
      if (v221 >= 1)
      {
        v222 = v219 + ((((v220 >> 16) * (*(a1 + 12) + 1) - (((v220 >> 16) * (*(a1 + 12) + 1)) >> 3) + 0x2000) >> 14) >> 14);
        v223 = *(a1 + 32);
        if (v222 >= *(a1 + 36))
        {
          v222 = *(a1 + 36);
        }

        if (v222 > v223)
        {
          v223 = v222;
        }

        v224 = *(a1 + 64);
        v226 = 0x7FFFFFFFFFFFFFFFLL * v223;
        v227 = *(a1 + 16);
        do
        {
          v220 = 1664525 * v220 + 1013904223;
          v225 = ((v217 * (((((2 * v218 * v218) & 0xFFFF0000 ^ 0x7FFF0000) >> 16) * v58) >> 16)) >> 15);
          *v224 = (((v220 >> 16) * v225 - (((v220 >> 16) * v225) >> 3) + 0x2000) >> 14) + ((v218 * v224[v226]) >> 15);
          ++v224;
          --v227;
        }

        while (v227);
        *(a1 + 144) = v220;
      }

      v228 = *(a1 + 80);
      v229 = *(a1 + 28);
      if (v229 >= 1)
      {
        v230 = *(a1 + 80);
        v231 = *(a1 + 28);
        LOWORD(v232) = 32113;
        do
        {
          *v230 = (v232 * *v230 + 0x4000) >> 15;
          ++v230;
          v232 = (32113 * v232 + 0x4000) >> 15;
          --v231;
        }

        while (v231);
      }

      iir_mem16(*(a1 + 64) - 2 * *(a1 + 20), v228, a3, v221, v229, *(a1 + 88));
      highpass(a3, a3, *(a1 + 16), 1, (a1 + 96));
      result = 0;
      v233 = *(a1 + 12) + 1;
      *(a1 + 8) = 0;
      *(a1 + 12) = v233;
      v234 = *(a1 + 140);
      *(a1 + 140) = v234 + 1;
      *(a1 + 134 + 2 * v234) = (v218 + 256) >> 9;
      if (v234 > 1)
      {
        result = 0;
        *(a1 + 140) = 0;
      }

      return result;
    }

    v14 = 0;
    goto LABEL_41;
  }

  if (!*(a1 + 148))
  {
LABEL_42:
    v260 = a2;
    v23 = memmove(*(a1 + 56), (*(a1 + 56) + 2 * *(a1 + 16)), 2 * (*(a1 + 20) + 2 * *(a1 + 36) + 12));
    MEMORY[0x1EEE9AC00](v23);
    v26 = (v240 - ((v24 + 15) & 0x3FFFFFFF0));
    if (v27)
    {
      if (v25)
      {
        memset(v240 - ((v24 + 15) & 0x3FFFFFFF0), 170, v24);
      }

      (*(*(*(a1 + 152) + 8 * *(a1 + 160)) + 24))(v26, *(a1 + 28), v260);
      if (*(a1 + 12))
      {
        v28 = *(a1 + 28);
        if (v28 >= 1)
        {
          v29 = 0;
          v30 = *(a1 + 72);
          v31 = v26;
          do
          {
            v33 = *v30++;
            v32 = v33;
            v34 = *v31++;
            v35 = v32 - v34;
            if (v35 < 0)
            {
              v35 = -v35;
            }

            v29 += v35;
            --v28;
          }

          while (v28);
          v36 = 0x4CCDu >> (v29 >> 15);
          v37 = *(a1 + 88);
          do
          {
            *(v37 + 4 * v28) = (*(v37 + 4 * v28) >> 15) * v36 + (((*(v37 + 4 * v28) & 0x7FFF) * v36) >> 15);
            ++v28;
          }

          while (v28 < *(a1 + 28));
        }
      }

      if (*(a1 + 8) || *(a1 + 12))
      {
        v38 = *(a1 + 28);
        if (v38 >= 1)
        {
          v39 = *(a1 + 72);
          v40 = v26;
          do
          {
            v41 = *v40++;
            *v39++ = v41;
            --v38;
          }

          while (v38);
        }
      }

      v42 = *(*(a1 + 152) + 8 * *(a1 + 160));
      if (*v42 == -1)
      {
        v44 = 0;
      }

      else
      {
        v43 = *(a1 + 32);
        v44 = speex_bits_unpack_unsigned(v260, 7) + v43;
        v42 = *(*(a1 + 152) + 8 * *(a1 + 160));
      }

      v251 = v44;
      if (v42[1])
      {
        v59 = v260;
        v249 = (2185 * (speex_bits_unpack_unsigned(v260, 4) << 6) + 0x4000) >> 15;
      }

      else
      {
        v249 = 0;
        v59 = v260;
      }

      v60 = speex_bits_unpack_unsigned(v59, 5);
      v61 = ol_gain_table[v60];
      v62 = MEMORY[0x1EEE9AC00](v60);
      v64 = (v240 - ((v63 + 15) & 0x3FFFFFFF0));
      if (v65)
      {
        v62 = memset(v240 - ((v63 + 15) & 0x3FFFFFFF0), 170, v63);
      }

      v66 = (v61 >> 15);
      v67 = v61 & 0x7FFF;
      v68 = 4 * *(a1 + 20);
      MEMORY[0x1EEE9AC00](v62);
      v69 = (v68 + 15) & 0x7FFFFFFF0;
      v70 = v240 - v69;
      v256 = v240 - v69;
      if (v71)
      {
        v72 = memset(v70, 170, v68);
        MEMORY[0x1EEE9AC00](v72);
        v258 = (v240 - v69);
        v73 = memset(v240 - v69, 170, v68);
      }

      else
      {
        v73 = MEMORY[0x1EEE9AC00](v70);
        v258 = (v240 - v69);
      }

      v74 = *(a1 + 160);
      if (v74 == 1)
      {
        v73 = speex_bits_unpack_unsigned(v260, 4);
        *(a1 + 864) = v73 == 15;
        v74 = *(a1 + 160);
      }

      v248 = 28406 * v66 + ((28406 * v67) >> 15);
      v75 = v251;
      if (v74 > 1)
      {
        *(a1 + 864) = 0;
      }

      if (*(a1 + 24) >= 1)
      {
        v240[0] = v26;
        v240[1] = v240;
        v241 = a3;
        v76 = 0;
        v252 = 0;
        v77 = 0;
        v243 = v75 + 1;
        v246 = v248 & 0x3FFF;
        v247 = (v248 >> 14);
        v78 = v75;
        v79 = 24576 * (v249 - 13) + 0x2000;
        v80 = (v79 >> 14);
        if (v80 >= 64)
        {
          v80 = 64;
        }

        if ((v79 & 0x20000000) != 0)
        {
          v81 = 0;
        }

        else
        {
          v81 = v80;
        }

        v82 = 2 * v78;
        v83 = HIWORD(v82);
        if (!HIWORD(v82))
        {
          v83 = 2 * v78;
        }

        if (v83 <= 0xFF)
        {
          v84 = 8 * (HIWORD(v82) != 0);
        }

        else
        {
          v83 >>= 8;
          v84 = (8 * (HIWORD(v82) != 0)) | 4;
        }

        if (v83 > 0xF)
        {
          v83 >>= 4;
          v84 |= 2u;
        }

        if (v83 <= 3)
        {
          v85 = v84;
        }

        else
        {
          v85 = v84 + 1;
        }

        v86 = v82 >> (2 * v85 - 12);
        v87 = v82 << (12 - 2 * v85);
        if (v85 > 6)
        {
          LOWORD(v87) = v86;
        }

        v88 = (((((16816 * v87 - 827523072) >> 16) * 4 * v87 + 1387593728) >> 16) * 4 * v87 + 238157824) >> 16;
        v89 = v88 >> (13 - v85);
        v90 = v88 << (v85 - 13);
        if (v85 < 0xD)
        {
          v90 = v89;
        }

        v242 = ((((v81 * ((4 * v248 + 0x8000) >> 16)) << 10) + 0x8000) >> 16) * v90;
        v244 = (77 * v81);
        v245 = (-435 * v81 + 0x7FFF);
        LODWORD(v91) = *(a1 + 20);
        v92 = 40;
        v93 = v260;
        while (1)
        {
          v254 = v77;
          v255 = v76;
          v94 = v91 * v76;
          v95 = (*(a1 + 64) + 2 * v91 * v76);
          v96 = *(a1 + 112);
          if (v96)
          {
            v97 = (v96 + 2 * v94);
          }

          else
          {
            v97 = 0;
          }

          bzero((*(a1 + 64) + 2 * v94), 2 * v91);
          v98 = *(*(a1 + 152) + 8 * *(a1 + 160));
          v99 = *(v98 + 5);
          if (!v99)
          {
            fprintf(*MEMORY[0x1E69E9848], "Fatal (internal) error in %s, line %d: %s\n", "/Library/Caches/com.apple.xbs/Sources/AudioCodecs/Source/Codecs/Speex/libspeex/nb_celp.c", 1335, "assertion failed: SUBMODE(ltp_unquant)");
            goto LABEL_299;
          }

          v100 = *v98;
          if (*v98 == -1)
          {
            v102 = *(a1 + 32);
            v101 = *(a1 + 36);
          }

          else
          {
            v101 = v251;
            v102 = v251;
            if (v100)
            {
              v103 = *(a1 + 32);
              v104 = *(a1 + 36);
              if ((v243 - v100) <= v103)
              {
                v102 = v103;
              }

              else
              {
                v102 = v243 - v100;
              }

              v105 = v100 + v251;
              if (v105 >= v104)
              {
                v101 = v104;
              }

              else
              {
                v101 = v105;
              }
            }
          }

          LOWORD(v239) = *(a1 + 132);
          LODWORD(v238) = *(a1 + 12);
          HIDWORD(v238) = v94;
          v99(v95, v258, v102, v101, v249, *(v98 + 6), *(a1 + 20), &v263, &v261, v93, v259, v238, v239);
          v106 = *(a1 + 20);
          v107 = v256;
          v108 = v252;
          if (v106 >= 1)
          {
            v109 = v258;
            v110 = *(a1 + 20);
            do
            {
              v111 = *v109;
              if ((*v109 - 262144001) <= 0xE0BFFFFE)
              {
                if (v111 <= 262144000)
                {
                  v112 = 0;
                }

                else
                {
                  v112 = 262144000;
                }

                if (v111 >= -262144000)
                {
                  v113 = v112;
                }

                else
                {
                  v113 = -262144000;
                }

                *v109 = v113;
              }

              ++v109;
              --v110;
            }

            while (v110);
          }

          v114 = SHIWORD(v261);
          if (v261 < 0)
          {
            v114 = -SHIWORD(v261);
          }

          v115 = v261;
          if (v261 <= 0)
          {
            v115 = -(v261 >> 1);
          }

          v116 = v115 + v114;
          v117 = v262;
          if (v262 <= 0)
          {
            v117 = -(v262 >> 1);
          }

          v118 = v116 + v117;
          v119 = (v116 + v117);
          v253 = v118;
          if (v119 > v108)
          {
            v120 = v263;
            v121 = 2 * v92 - v263;
            if (v121 < 0)
            {
              v121 = v263 - 2 * v92;
            }

            if (v121 >= 3)
            {
              v122 = 3 * v92 - v263;
              if (v122 < 0)
              {
                v122 = v263 - 3 * v92;
              }

              if (v122 >= 4)
              {
                v123 = 4 * v92 - v263;
                if (v123 < 0)
                {
                  v123 = v263 - 4 * v92;
                }

                if (v123 > 4)
                {
                  goto LABEL_166;
                }
              }
            }
          }

          if (v119 > ((19661 * v108) >> 15))
          {
            v120 = v263;
            v124 = v92 - 2 * v263;
            if (v124 < 0)
            {
              v124 = 2 * v263 - v92;
            }

            if (v124 < 3)
            {
              goto LABEL_166;
            }

            v125 = -3 * v263 + v92;
            if (v125 < 0)
            {
              v125 = -v125;
            }

            if (v125 < 4)
            {
              goto LABEL_166;
            }

            v126 = v92 - 4 * v263;
            if (v126 < 0)
            {
              v126 = 4 * v263 - v92;
            }

            if (v126 < 5)
            {
              goto LABEL_166;
            }
          }

          if (v108 < (21955 * v119) >> 15)
          {
            v120 = v263;
            v127 = 2 * v92 - v263;
            if (v127 < 0)
            {
              v127 = v263 - 2 * v92;
            }

            if (v127 < 3)
            {
              goto LABEL_166;
            }

            v128 = 3 * v92 - v263;
            if (v128 < 0)
            {
              v128 = v263 - 3 * v92;
            }

            if (v128 < 4)
            {
              goto LABEL_166;
            }

            v129 = 4 * v92 - v263;
            if (v129 < 0)
            {
              v129 = v263 - 4 * v92;
            }

            if (v129 <= 4)
            {
LABEL_166:
              if (v119 <= v108)
              {
                v119 = v108;
              }

              v252 = v119;
              v92 = v120;
            }
          }

          v257 = v92;
          bzero(v107, 4 * v106);
          v130 = *(*(a1 + 152) + 8 * *(a1 + 160));
          v131 = *(v130 + 8);
          if (v131 == 1)
          {
            v133 = speex_bits_unpack_unsigned(v93, 1);
            v134 = &exc_gain_quant_scal1;
          }

          else
          {
            v132 = v248;
            if (v131 != 3)
            {
              goto LABEL_174;
            }

            v133 = speex_bits_unpack_unsigned(v260, 3);
            v134 = &exc_gain_quant_scal3;
          }

          v135 = v134[v133];
          v132 = v247 * v135 + ((v246 * v135) >> 14);
          v130 = *(*(a1 + 152) + 8 * *(a1 + 160));
LABEL_174:
          v136 = *(v130 + 64);
          if (!v136)
          {
            fprintf(*MEMORY[0x1E69E9848], "Fatal (internal) error in %s, line %d: %s\n", "/Library/Caches/com.apple.xbs/Sources/AudioCodecs/Source/Codecs/Speex/libspeex/nb_celp.c", 1411, "assertion failed: SUBMODE(innovation_unquant)");
LABEL_299:
            exit(1);
          }

          v73 = v136(v107, *(v130 + 72), *(a1 + 20), v260, v259, a1 + 144);
          LODWORD(v91) = *(a1 + 20);
          if (v91 >= 1)
          {
            v137 = v107;
            v138 = *(a1 + 20);
            do
            {
              *v137 = ((*v137 >> 7) * (v132 >> 14) + (((*v137 >> 7) * (v132 & 0x3FFF)) >> 14)) << 7;
              ++v137;
              --v138;
            }

            while (v138);
          }

          if (*(*(*(a1 + 152) + 8 * *(a1 + 160)) + 12))
          {
            v250 = v240;
            MEMORY[0x1EEE9AC00](v73);
            v140 = (v240 - ((v139 + 15) & 0x7FFFFFFF0));
            if (v141)
            {
              memset(v240 - ((v139 + 15) & 0x7FFFFFFF0), 170, v139);
            }

            v142 = *(a1 + 20);
            bzero(v140, 4 * v142);
            v143 = *(*(a1 + 152) + 8 * *(a1 + 160));
            v73 = (*(v143 + 64))(v140, *(v143 + 72), v142, v260, v259, a1 + 144);
            v144 = *(a1 + 20);
            if (v144 >= 1)
            {
              v145 = 14895 * (v132 >> 15) + ((14895 * (v132 & 0x7FFFu)) >> 15);
              v146 = v145 >> 14;
              v147 = v145 & 0x3FFF;
              v148 = v140;
              v149 = *(a1 + 20);
              do
              {
                *v148 = ((*v148 >> 7) * v146 + (((*v148 >> 7) * v147) >> 14)) << 7;
                ++v148;
                --v149;
              }

              while (v149);
              v150 = v256;
              do
              {
                v151 = *v140++;
                *v150++ += v151;
                --v144;
              }

              while (v144);
            }

            LODWORD(v91) = *(a1 + 20);
            v107 = v256;
          }

          v93 = v260;
          v92 = v257;
          if (v91 >= 1)
          {
            v152 = v91;
            v153 = v258;
            v154 = v107;
            v155 = v95;
            v156 = v91;
            do
            {
              v158 = *v153++;
              v157 = v158;
              v159 = *v154++;
              v160 = (v159 + 2 * v157 + 0x2000) >> 14;
              if (v160 <= -32767)
              {
                v160 = -32767;
              }

              if (v160 >= 0x7FFF)
              {
                LOWORD(v160) = 0x7FFF;
              }

              *v155++ = v160;
              --v156;
            }

            while (v156);
            if (v97)
            {
              v161 = v107;
              do
              {
                v162 = *v161++;
                *v97++ = (v162 + 0x2000) >> 14;
                --v152;
              }

              while (v152);
            }
          }

          if (*(a1 + 160) == 1)
          {
            bzero(v95, 2 * v91);
            v91 = *(a1 + 20);
            v163 = *(a1 + 860);
            if (v163 >= v91)
            {
              v167 = v244;
              v166 = v245;
              v168 = v253;
            }

            else
            {
              v164 = v251;
              v165 = v242;
              v167 = v244;
              v166 = v245;
              v168 = v253;
              do
              {
                if ((v163 & 0x80000000) == 0)
                {
                  v95[v163] = v165;
                }

                v163 += v164;
              }

              while (v163 < v91);
            }

            *(a1 + 860) = v163 - v91;
            if (v91 >= 1)
            {
              v171 = *(a1 + 852);
              v172 = v91;
              v73 = 45876;
              do
              {
                v173 = *v95;
                v174 = 4 * v171;
                v175 = *v107++;
                v171 = v175;
                *v95 = ((((4 * v175 + 0x8000) >> 16) * v166) >> 15) + ((((45876 * v173) & 0xFFFF0000) + 19660 * *(a1 + 848)) >> 16) - ((((v174 + 0x8000) >> 16) * v167) >> 15);
                *(a1 + 848) = v173;
                v176 = 6554 * *v95 + 26214 * *(a1 + 856) + 0x4000;
                *(a1 + 856) = v176 >> 15;
                *v95++ -= v176 >> 15;
                --v172;
              }

              while (v172);
              *(a1 + 852) = v171;
            }

            v170 = v254;
            v169 = v255;
          }

          else
          {
            v170 = v254;
            v169 = v255;
            v168 = v253;
          }

          v77 = v168 + v170;
          v76 = v169 + 1;
          if (v76 >= *(a1 + 24))
          {
            v177 = (v77 + 2) >> 2;
            a3 = v241;
            v26 = v240[0];
            goto LABEL_214;
          }
        }
      }

      LOWORD(v177) = 0;
      v257 = 40;
LABEL_214:
      MEMORY[0x1EEE9AC00](v73);
      v179 = (v240 - ((v178 + 15) & 0x3FFFFFFF0));
      if (v180)
      {
        memset(v240 - ((v178 + 15) & 0x3FFFFFFF0), 170, v178);
      }

      if (*(a1 + 164) && (v181 = *(*(*(a1 + 152) + 8 * *(a1 + 160)) + 80), v181 >= 1) && !*(a1 + 12))
      {
        v235 = v257;
        multicomb((*(a1 + 64) - 2 * *(a1 + 20)), a3, 2 * *(a1 + 20), v257, v181);
        multicomb((*(a1 + 64) + 2 * *(a1 + 20)), (a3 + 4 * *(a1 + 20)), 2 * *(a1 + 20), v235, *(*(*(a1 + 152) + 8 * *(a1 + 160)) + 80));
      }

      else
      {
        memcpy(a3, (*(a1 + 64) - 2 * *(a1 + 20)), 2 * *(a1 + 16));
      }

      if (*(a1 + 12))
      {
        v182 = *(a1 + 64);
        v183 = *(a1 + 16);
        v184 = compute_rms16(v182, *(a1 + 16));
        if (v183 >= 1)
        {
          v185 = (v248 + ((v184 + 1) >> 1)) / (v184 + 1);
          if (v185 >= 0x7FFF)
          {
            LOWORD(v185) = 0x7FFF;
          }

          v186 = 0x7FFFFFFFFFFFFFFFLL * *(a1 + 20);
          v187 = a3;
          do
          {
            v182->i16[0] = (v185 * v182->i16[0]) >> 14;
            v187->i16[0] = v182->i16[v186];
            v187 = (v187 + 2);
            v182 = (v182 + 2);
            --v183;
          }

          while (v183);
        }
      }

      LODWORD(v188) = *(a1 + 24);
      if (v188 >= 1)
      {
        v189 = 0;
        v190 = *(a1 + 28);
        do
        {
          v191 = *(a1 + 20);
          lsp_interpolate(*(a1 + 72), v26, v179, v190, v189, v188);
          lsp_enforce_margin(v179, v190, 16);
          lsp_to_lpc(v179, v64, v190);
          v192 = *(a1 + 28);
          if (v192 < 1)
          {
            v194 = 0x2000;
          }

          else
          {
            v193 = 0;
            v194 = 0x2000;
            do
            {
              v194 = v194 + v64[v193 + 1] - v64[v193];
              v193 += 2;
            }

            while (v193 < v192);
          }

          *(*(a1 + 104) + 4 * v189) = v194;
          iir_mem16(a3 + 2 * v191 * v189, *(a1 + 80), a3 + 2 * v191 * v189, *(a1 + 20), *(a1 + 28), *(a1 + 88));
          v190 = *(a1 + 28);
          if (v190 >= 1)
          {
            v195 = *(a1 + 80);
            v196 = v64;
            v197 = *(a1 + 28);
            do
            {
              v198 = *v196++;
              *v195++ = v198;
              --v197;
            }

            while (v197);
          }

          ++v189;
          v188 = *(a1 + 24);
        }

        while (v189 < v188);
      }

      if (*(a1 + 872))
      {
        if (*(a1 + 868))
        {
          v199 = 3;
        }

        else
        {
          v199 = 1;
        }

        highpass(a3, a3, *(a1 + 16), v199, (a1 + 96));
      }

      v200 = (v248 + 0x2000) >> 14;
      *(a1 + 120) = v200 + 1;
      v201 = (32440 * *(a1 + 122)) >> 15;
      if (v201 <= (v200 + 1))
      {
        LOWORD(v201) = v200 + 1;
      }

      *(a1 + 122) = v201;
      if ((66192 * *(a1 + 124) + 0x10000) >> 16 >= (v200 + 1))
      {
        v202 = v200 + 1;
      }

      else
      {
        v202 = (66192 * *(a1 + 124) + 0x10000) >> 16;
      }

      *(a1 + 124) = v202;
      if (v202 >= v201)
      {
        *(a1 + 122) = v202 + 1;
      }

      v203 = *(a1 + 28);
      if (v203 >= 1)
      {
        v204 = *(a1 + 72);
        do
        {
          v205 = *v26++;
          *v204++ = v205;
          --v203;
        }

        while (v203);
      }

      *(a1 + 8) = 0;
      *(a1 + 128) = v257;
      *(a1 + 132) = v177;
      v206 = *(a1 + 140);
      *(a1 + 140) = v206 + 1;
      *(a1 + 2 * v206 + 134) = v177;
      if (v206 > 1)
      {
        *(a1 + 140) = 0;
      }

      *(a1 + 44) = v248;
    }

    else
    {
      if (v25)
      {
        memset(v240 - ((v24 + 15) & 0x3FFFFFFF0), 170, v24);
      }

      v45 = *(a1 + 28);
      if (v45 >= 1)
      {
        v46 = *(a1 + 80);
        v47 = v26;
        v48 = *(a1 + 28);
        LOWORD(v49) = 30474;
        do
        {
          v50 = *v46++;
          *v47++ = (v49 * v50 + 0x4000) >> 15;
          v49 = (30474 * v49 + 0x4000) >> 15;
          --v48;
        }

        while (v48);
      }

      v51 = *(a1 + 64);
      v52 = *(a1 + 16);
      v53 = compute_rms16(v51, *(a1 + 16));
      if (v52 >= 1)
      {
        v54 = *(a1 + 144);
        v55 = v51;
        v56 = v52;
        do
        {
          v54 = 1664525 * v54 + 1013904223;
          v55->i16[0] = ((v54 >> 16) * v53 - (((v54 >> 16) * v53) >> 3) + 0x2000) >> 14;
          v55 = (v55 + 2);
          --v56;
        }

        while (v56);
        *(a1 + 144) = v54;
      }

      *(a1 + 8) = 1;
      iir_mem16(v51, v26, a3, v52, v45, *(a1 + 88));
      *(a1 + 12) = 0;
    }

    return 0;
  }

  while (1)
  {
    if (*(a2 + 24) || *(a2 + 8) - (*(a2 + 16) + 8 * *(a2 + 12)) < 5)
    {
      return 0xFFFFFFFFLL;
    }

    if (speex_bits_unpack_unsigned(a2, 1))
    {
      v6 = speex_bits_unpack_unsigned(a2, 3);
      v7 = *(a2 + 12);
      v8 = wb_skip_table[v6] + *(a2 + 16) - 4;
      v9 = *(a2 + 8);
      if (v8 + 8 * v7 > v9 || *(a2 + 24))
      {
        *(a2 + 24) = 1;
        return 0xFFFFFFFFLL;
      }

      v10 = v7 + (v8 >> 3);
      *(a2 + 12) = v10;
      *(a2 + 16) = v8 & 7;
      if (v9 - (v8 & 7 | (8 * v10)) < 5)
      {
        return 0xFFFFFFFFLL;
      }

      if (speex_bits_unpack_unsigned(a2, 1))
      {
        v11 = speex_bits_unpack_unsigned(a2, 3);
        v12 = *(a2 + 12);
        v13 = wb_skip_table[v11] + *(a2 + 16) - 4;
        if (v13 + 8 * v12 > *(a2 + 8) || *(a2 + 24))
        {
          *(a2 + 24) = 1;
        }

        else
        {
          *(a2 + 12) = v12 + (v13 >> 3);
          *(a2 + 16) = v13 & 7;
        }

        if (speex_bits_unpack_unsigned(a2, 1))
        {
          break;
        }
      }
    }

    if (*(a2 + 24) || *(a2 + 8) - (*(a2 + 16) + 8 * *(a2 + 12)) < 4)
    {
      return 0xFFFFFFFFLL;
    }

    v14 = speex_bits_unpack_unsigned(a2, 4);
    if (v14 == 13)
    {
      v17 = *(a1 + 816);
      v18 = *(a1 + 824);
      goto LABEL_21;
    }

    if (v14 != 14)
    {
      if (v14 == 15)
      {
        return 0xFFFFFFFFLL;
      }

      if (v14 >= 9)
      {
        v236 = *MEMORY[0x1E69E9848];
        v237 = "Invalid mode encountered. The stream is corrupted.";
        goto LABEL_296;
      }

LABEL_41:
      *(a1 + 160) = v14;
      goto LABEL_42;
    }

    v15 = speex_bits_unpack_unsigned(a2, 4);
    v16 = a1 + 168 + 40 * v15;
    v17 = *(v16 + 8);
    if (v17)
    {
      v18 = *(v16 + 16);
LABEL_21:
      result = v17(a2, a1, v18);
      if (result)
      {
        return result;
      }
    }

    else
    {
      if (v15 >= 2)
      {
        if (v15 >= 8)
        {
          if (v15 >= 0xA)
          {
            if (v15 >= 0xC)
            {
              if (v15 >= 0xE)
              {
                v20 = 64;
              }

              else
              {
                v20 = 32;
              }
            }

            else
            {
              v20 = 16;
            }
          }

          else
          {
            v20 = 8;
          }
        }

        else
        {
          v20 = 4;
        }
      }

      else
      {
        v20 = 1;
      }

      v21 = *(a2 + 12);
      v22 = *(a2 + 16) + v20;
      if (v22 + 8 * v21 > *(a2 + 8) || *(a2 + 24))
      {
        *(a2 + 24) = 1;
      }

      else
      {
        *(a2 + 12) = v21 + (v22 >> 3);
        *(a2 + 16) = v22 & 7;
      }
    }
  }

  v236 = *MEMORY[0x1E69E9848];
  v237 = "More than two wideband layers found. The stream is corrupted.";
LABEL_296:
  fprintf(v236, "notification: %s\n", v237);
  return 4294967294;
}

__int16 *highpass(__int16 *result, _WORD *a2, int a3, int a4, int *a5)
{
  v32 = *MEMORY[0x1E69E9840];
  v27 = 982484399;
  v28 = 999392431;
  v29 = 1004569667;
  v30 = 1045135815;
  v31 = 428451922;
  v22 = xmmword_19B0B3420;
  v23 = 0x3F2281BE3F223DE7;
  v24 = -1889781678;
  v25 = 14418;
  if (a3 >= 1)
  {
    if (a4 >= 4)
    {
      v5 = 4;
    }

    else
    {
      v5 = a4;
    }

    v6 = &v22 + 3 * v5;
    v7 = &v26[6 * v5];
    v8 = *v6;
    v9 = v6[1];
    v10 = -*(v7 + 1);
    v11 = v6[2];
    v12 = -*(v7 + 2);
    v14 = *a5;
    v13 = a5[1];
    v15 = a3;
    do
    {
      v17 = *result++;
      v16 = v17;
      v18 = v14 + v17 * v8;
      v19 = (v18 + 0x2000) >> 14;
      if (v19 <= -32767)
      {
        v19 = -32767;
      }

      if (v19 >= 0x7FFF)
      {
        LOWORD(v19) = 0x7FFF;
      }

      v20 = (v18 >> 15);
      v21 = v18 & 0x7FFF;
      v14 = v13 + v9 * v16 + 2 * (v20 * v10 + ((v21 * v10) >> 15));
      v13 = v11 * v16 + 2 * (v20 * v12 + ((v21 * v12) >> 15));
      *a2++ = v19;
      --v15;
    }

    while (v15);
    *a5 = v14;
    a5[1] = v13;
  }

  return result;
}

uint64_t multicomb(int16x4_t *a1, int16x4_t *a2, int a3, int a4, int a5)
{
  v9 = a1;
  v110[1] = *MEMORY[0x1E69E9840];
  v10 = (2 * a3);
  MEMORY[0x1EEE9AC00](a1);
  v12 = (v110 - v11);
  if (v13)
  {
    memset(v110 - v11, 170, 2 * v10);
  }

  interp_pitch(v9, v12, a4);
  if (a4 <= 40)
  {
    v14 = -a4;
  }

  else
  {
    v14 = 2 * a4;
  }

  interp_pitch(v9, v12 + 2 * a3, v14);
  v15 = a3;
  if (a3 < 1)
  {
    v17 = 0;
    v18 = a3;
  }

  else
  {
    v16 = v9->i16[0];
    if (v16 < 0)
    {
      v16 = -v16;
    }

    if ((v16 & 0xC000) != 0)
    {
      v17 = 1;
LABEL_18:
      v21 = v9;
      v22 = a3;
      do
      {
        v21->i16[0] = v21->i16[0] >> 1;
        v21 = (v21 + 2);
        --v22;
      }

      while (v22);
      if (v10 <= 1)
      {
        v23 = 1;
      }

      else
      {
        v23 = v10;
      }

      v24 = v12;
      do
      {
        v24->i16[0] = v24->i16[0] >> 1;
        v24 = (v24 + 2);
        --v23;
      }

      while (v23);
    }

    else
    {
      v19 = 0;
      while (a3 - 1 != v19)
      {
        v20 = v9->i16[v19 + 1];
        if (v20 < 0)
        {
          v20 = -v20;
        }

        ++v19;
        if (v20 >= 0x4000)
        {
          v17 = v19 < a3;
          goto LABEL_18;
        }
      }

      v17 = 0;
    }

    v18 = a3;
  }

  if (a3 >= 4)
  {
    v26 = 0;
    v27 = a3 >> 2;
    v28 = v12;
    do
    {
      v29 = *v28++;
      v26 += vaddvq_s32(vmull_s16(v29, v29)) >> 6;
      --v27;
    }

    while (v27);
    v25 = v26 + 1000;
  }

  else
  {
    v25 = 1000;
  }

  v30 = HIWORD(v25);
  if (!HIWORD(v25))
  {
    v30 = v25;
  }

  if (v30 <= 0xFF)
  {
    v31 = 8 * (HIWORD(v25) != 0);
  }

  else
  {
    v30 >>= 8;
    v31 = (8 * (HIWORD(v25) != 0)) | 4;
  }

  if (v30 > 0xF)
  {
    v30 >>= 4;
    v31 |= 2u;
  }

  if (v30 <= 3)
  {
    v32 = v31;
  }

  else
  {
    v32 = v31 + 1;
  }

  v33 = v25 >> (2 * v32 - 12);
  v34 = v25 << (12 - 2 * v32);
  if (v32 > 6)
  {
    LOWORD(v34) = v33;
  }

  v35 = (((((16816 * v34 - 827523072) >> 16) * 4 * v34 + 1387593728) >> 16) * 4 * v34 + 238157824) >> 16;
  v36 = v35 >> (13 - v32);
  v37 = v35 << (v32 - 13);
  if (v32 < 0xD)
  {
    LOWORD(v37) = v36;
  }

  if (a3 >= 4)
  {
    v39 = 0;
    v42 = (v12 + 2 * v18);
    v43 = a3 >> 2;
    v44 = v42;
    v45 = a3 >> 2;
    do
    {
      v46 = *v44++;
      v39 += vaddvq_s32(vmull_s16(v46, v46)) >> 6;
      --v45;
    }

    while (v45);
    v40 = 0;
    v47 = v9;
    v48 = a3 >> 2;
    do
    {
      v49 = *v47++;
      v40 += vaddvq_s32(vmull_s16(v49, v49)) >> 6;
      --v48;
    }

    while (v48);
    v50 = 0;
    v51 = v12;
    v52 = a3 >> 2;
    v53 = v9;
    do
    {
      v54 = *v51++;
      v55 = v54;
      v56 = *v53++;
      v50 += vaddvq_s32(vmull_s16(v56, v55)) >> 6;
      --v52;
    }

    while (v52);
    v41 = 0;
    v38 = v50 & ~(v50 >> 31);
    v57 = v9;
    do
    {
      v58 = *v42++;
      v59 = v58;
      v60 = *v57++;
      v41 += vaddvq_s32(vmull_s16(v60, v59)) >> 6;
      --v43;
    }

    while (v43);
  }

  else
  {
    v38 = 0;
    v39 = 0;
    v40 = 0;
    v41 = 0;
  }

  v61 = vadd_s32(__PAIR64__(v40, v39), 0x1000003E8);
  v62 = vcgt_u32(v61, 0xFFFF0000FFFFLL);
  v63 = vbsl_s8(v62, vshr_n_u32(v61, 0x10uLL), v61);
  v64 = vand_s8(v62, 0x800000008);
  v65 = vcgt_u32(v63, 0xFF000000FFLL);
  v66 = vbsl_s8(v65, vshr_n_u32(v63, 8uLL), v63);
  v67 = vbsl_s8(v65, (*&v64 | 0x400000004), v64);
  v68 = vcgt_u32(v66, 0xF0000000FLL);
  v69 = vsub_s32(vbsl_s8(v68, (*&v67 | 0x200000002), v67), vcgt_u32(vbsl_s8(v68, vshr_n_u32(v66, 4uLL), v66), 0x300000003));
  v70 = vsub_s32(0xC0000000CLL, vadd_s32(v69, v69));
  v71 = vshl_n_s32(vbsl_s8(vcgt_u32(v69, 0x600000006), vshl_s32(v61, v70), vshl_u32(v61, v70)), 0x10uLL);
  v72 = vshr_n_s32(vmla_s32(vdup_n_s32(0xCEAD0000), vshr_n_s32(v71, 0x10uLL), vdup_n_s32(0x41B0u)), 0x10uLL);
  v73 = vshr_n_s32(v71, 0xEuLL);
  v74 = vshr_n_s32(vmla_s32(vdup_n_s32(0xE320000u), vshr_n_s32(vmla_s32(vdup_n_s32(0x52B50000u), v72, v73), 0x10uLL), v73), 0x10uLL);
  v75 = vbsl_s8(vcgt_u32(0xD0000000DLL, v69), vshl_s32(v74, vsub_s32(v69, 0xD0000000DLL)), vshl_u32(v74, vadd_s32(v69, 0xC0000000CLL)));
  v76 = vshl_n_s32(v75, 0x10uLL);
  v77 = vshl_s32(v76, 0xFFFFFFF0FFFFFFF6);
  v78 = v41 & ~(v41 >> 31);
  v79 = v75.i16[0];
  v80 = ((v76.i32[1] >> 6) + 0x8000) >> 16;
  if (v77.i32[1] > v37 << 6)
  {
    LOWORD(v37) = v80 + 1;
  }

  if (v77.i32[0] < v77.i32[1])
  {
    v79 = v80 + 1;
  }

  v81 = v37;
  if (v38 <= v77.i32[1] * v37)
  {
    v82 = (((((v38 + (v76.i32[1] >> 17)) / v77.i32[1]) << 14) + (v37 >> 1)) / v37);
  }

  else
  {
    v82 = 0x4000;
  }

  v83 = v79;
  v84 = v79 >> 1;
  if (v78 > v77.i32[1] * v79)
  {
    v85 = 0x4000;
  }

  else
  {
    v85 = (((((v78 + (v76.i32[1] >> 17)) / v77.i32[1]) << 14) + (v79 >> 1)) / v79);
  }

  if (a5 < 1)
  {
    v87 = 0;
    v88 = 0;
  }

  else
  {
    v86 = (13107 * a5) >> 15;
    v87 = v86 + 2294;
    v88 = (112720 * v86 + 0x40000000) >> 16;
  }

  if (a3 >= 1)
  {
    v89 = 0;
    v90 = ((v81 >> 1) + (v76.i32[1] >> 8)) / v81;
    v91 = (v84 + (v76.i32[1] >> 8)) / v83;
    v92 = (((((v85 * v88) >> 15) * v85) >> 13) ^ 0x7FFF);
    if (v92 <= v87)
    {
      LOWORD(v92) = v87;
    }

    v93 = (4 * v91 * (((v92 >> 1) | (v87 << 14)) / v92)) >> 16;
    v94 = (((((v82 * v88) >> 15) * v82) >> 13) ^ 0x7FFF);
    if (v94 <= v87)
    {
      LOWORD(v94) = v87;
    }

    if (a4 <= 40)
    {
      v95 = 19661;
    }

    else
    {
      v95 = 9830;
    }

    v96 = (4 * v90 * (((v94 >> 1) | (v87 << 14)) / v94)) >> 16;
    if (a4 <= 40)
    {
      v97 = 19661;
    }

    else
    {
      v97 = 22938;
    }

    v98 = (v96 * v97) >> 7;
    do
    {
      a2->i16[v89] = v9->i16[v89] + (((v98 & 0xFFFFFF00) * v12->i16[v89] + (((v93 * v95) >> 7) & 0xFFFFFF00) * v12->i16[a3 + v89] + 0x8000) >> 16);
      ++v89;
    }

    while (a3 != v89);
  }

  v99 = compute_rms16(a2, a3);
  result = compute_rms16(v9, a3);
  if (a3 >= 1)
  {
    if (v99 <= 1)
    {
      v101 = 1;
    }

    else
    {
      v101 = v99;
    }

    if (result <= v101)
    {
      v102 = result;
    }

    else
    {
      v102 = v99;
    }

    if (v102 <= 1)
    {
      v102 = 1;
    }

    v103 = (((v102 << 14) | (v101 >> 1)) / v101);
    v104 = a2;
    v105 = a3;
    do
    {
      v104->i16[0] = (v103 * v104->i16[0]) >> 14;
      v104 = (v104 + 2);
      --v105;
    }

    while (v105);
    if (v17)
    {
      v106 = a3;
      do
      {
        v9->i16[0] *= 2;
        v9 = (v9 + 2);
        --v106;
      }

      while (v106);
      do
      {
        v107 = a2->i16[0];
        v108 = 2 * v107;
        if (v107 < -16383)
        {
          v108 = -32766;
        }

        if (v107 < 0x4000)
        {
          v109 = v108;
        }

        else
        {
          v109 = 32766;
        }

        a2->i16[0] = v109;
        a2 = (a2 + 2);
        --v15;
      }

      while (v15);
    }
  }

  return result;
}

int16x4_t *interp_pitch(int16x4_t *result, uint64_t a2, int a3)
{
  v3 = 0;
  v34 = *MEMORY[0x1E69E9840];
  *&v4 = 0xAAAAAAAAAAAAAAAALL;
  *(&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v33[5] = v4;
  v33[6] = v4;
  v33[3] = v4;
  v33[4] = v4;
  v33[1] = v4;
  v33[2] = v4;
  v33[0] = v4;
  v5 = -6 - 2 * a3;
  do
  {
    v6 = 0;
    v7 = -20;
    v8 = result;
    do
    {
      v9 = *v8;
      v10 = *(v8++ + v5);
      v6 += vaddvq_s32(vmull_s16(v10, v9)) >> 6;
    }

    while (!__CFADD__(v7++, 1));
    *(v33 + v3++) = v6;
    v5 += 2;
  }

  while (v3 != 7);
  v12 = 0;
  v13 = shift_filt;
  do
  {
    v14 = 0;
    ++v12;
    v15 = 3;
    v16 = -3;
    do
    {
      LODWORD(v17) = 10 - v14;
      if ((10 - v14) >= 7)
      {
        v17 = 7;
      }

      else
      {
        v17 = v17;
      }

      if (((3 - v14) & ~((3 - v14) >> 31)) >= v17)
      {
        v18 = 0;
      }

      else
      {
        v18 = 0;
        v19 = v15 & ~(v15 >> 31);
        v20 = v33 + v19 + v16;
        do
        {
          v21 = *v20++;
          v18 += (((v21 & 0x7FFF) * v13[v19]) >> 15) + (v21 >> 15) * v13[v19];
          ++v19;
        }

        while (v19 < v17);
      }

      *(v33 + 7 * v12 + v14++) = v18;
      --v15;
      ++v16;
    }

    while (v14 != 7);
    v13 += 7;
  }

  while (v12 != 3);
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = v33;
  v26 = v33[0];
  do
  {
    for (i = 0; i != 7; ++i)
    {
      if (*(v25 + i) > v26)
      {
        v26 = *(v25 + i);
        v24 = v22;
        v23 = i;
      }
    }

    ++v22;
    v25 = (v25 + 28);
  }

  while (v22 != 4);
  v28 = 0;
  v29 = v23 - a3 - 3;
  v30 = v29;
  do
  {
    if (v24 < 1)
    {
      v32 = result->i16[v29 + v28] << 15;
    }

    else
    {
      v31 = 0;
      v32 = 0;
      do
      {
        v32 += shift_filt[7 * (v24 - 1) + v31] * result[-1].i16[v30 + 1 + v31];
        ++v31;
      }

      while (v31 != 7);
    }

    *(a2 + 2 * v28++) = (v32 + 0x4000) >> 15;
    ++v30;
  }

  while (v28 != 80);
  return result;
}

void nb_decoder_destroy(void **a1)
{
  free(a1[7]);
  free(a1[10]);
  free(a1[9]);
  free(a1[11]);
  free(a1[13]);

  free(a1);
}

void *nb_decoder_init(int **a1)
{
  v2 = *a1;
  v3 = malloc_type_calloc(0x370uLL, 1uLL, 0x6CE94CD7uLL);
  v4 = v3;
  if (v3)
  {
    v3[6] = 0;
    *v3 = a1;
    *(v3 + 37) = 1;
    *(v3 + 2) = 1;
    v5 = *v2;
    v6 = v2[1];
    v7 = *v2 / v6;
    *(v3 + 5) = v6;
    *(v3 + 6) = v7;
    *(v3 + 4) = v5;
    *(v3 + 28) = *(v2 + 1);
    v8 = v2[4];
    *(v3 + 9) = v8;
    v3[19] = v2 + 8;
    *(v3 + 40) = v2[40];
    *(v3 + 41) = 1;
    v9 = malloc_type_calloc(4 * v8 + 2 * (v6 + v5) + 24, 1uLL, 0x6CE94CD7uLL);
    v10 = *(v4 + 9);
    v11 = *(v4 + 4);
    v12 = v9 + 4 * v10 + 2 * *(v4 + 5) + 12;
    v4[7] = v9;
    v4[8] = v12;
    bzero(v9, 2 * (v11 + v10));
    v4[10] = malloc_type_calloc(2 * *(v4 + 7), 1uLL, 0x6CE94CD7uLL);
    v4[9] = malloc_type_calloc(2 * *(v4 + 7), 1uLL, 0x6CE94CD7uLL);
    v4[11] = malloc_type_calloc(4 * *(v4 + 7), 1uLL, 0x6CE94CD7uLL);
    v4[13] = malloc_type_calloc(4 * *(v4 + 6), 1uLL, 0x6CE94CD7uLL);
    *(v4 + 32) = 40;
    *(v4 + 3) = 0;
    *(v4 + 134) = 0;
    *(v4 + 71) = 0;
    *(v4 + 36) = 1000;
    *(v4 + 10) = 8000;
    *(v4 + 22) = 0;
    v4[102] = speex_default_user_handler;
    v13 = 22;
    v4[103] = 0;
    do
    {
      v4[v13] = 0;
      v13 += 5;
    }

    while (v13 != 102);
    *(v4 + 428) = 0;
    *(v4 + 213) = 0;
    *(v4 + 424) = 0;
    *(v4 + 860) = xmmword_19B0B1930;
  }

  return v4;
}

uint64_t speex_default_user_handler(uint64_t a1)
{
  v2 = speex_bits_unpack_unsigned(a1, 4);
  v3 = *(a1 + 12);
  v4 = *(a1 + 16) + 8 * v2 + 5;
  if (v4 + 8 * v3 > *(a1 + 8) || *(a1 + 24))
  {
    *(a1 + 24) = 1;
  }

  else
  {
    *(a1 + 12) = v3 + (v4 >> 3);
    *(a1 + 16) = v4 & 7;
  }

  return 0;
}

uint64_t nb_encode(uint64_t a1, __int16 *a2, _DWORD *a3)
{
  v392 = a3;
  v400[3] = *MEMORY[0x1E69E9840];
  v386 = *(a1 + 72);
  v5 = 2 * *(a1 + 28);
  v6 = MEMORY[0x1EEE9AC00](a1);
  v7 = (v5 + 15) & 0x3FFFFFFF0;
  v8 = (&v368 - v7);
  if (v9)
  {
    v10 = memset(&v368 - v7, 170, v5);
    MEMORY[0x1EEE9AC00](v10);
    v397 = (&v368 - v7);
    v11 = memset(&v368 - v7, 170, v5);
    MEMORY[0x1EEE9AC00](v11);
    v396 = (&v368 - v7);
    v12 = memset(&v368 - v7, 170, v5);
    MEMORY[0x1EEE9AC00](v12);
    v13 = (&v368 - v7);
    v14 = memset(&v368 - v7, 170, v5);
    MEMORY[0x1EEE9AC00](v14);
    v15 = (&v368 - v7);
    v16 = memset(&v368 - v7, 170, v5);
    MEMORY[0x1EEE9AC00](v16);
    v379 = (&v368 - v7);
    v17 = memset(&v368 - v7, 170, v5);
    MEMORY[0x1EEE9AC00](v17);
    v377 = (&v368 - v7);
    v18 = memset(&v368 - v7, 170, v5);
    MEMORY[0x1EEE9AC00](v18);
    v384 = (&v368 - v7);
    v19 = memset(&v368 - v7, 170, v5);
    MEMORY[0x1EEE9AC00](v19);
    v20 = &v368 - v7;
    memset(v20, 170, v5);
  }

  else
  {
    v21 = MEMORY[0x1EEE9AC00](v6);
    v397 = (&v368 - v7);
    v22 = MEMORY[0x1EEE9AC00](v21);
    v396 = (&v368 - v7);
    v23 = MEMORY[0x1EEE9AC00](v22);
    v13 = (&v368 - v7);
    v24 = MEMORY[0x1EEE9AC00](v23);
    v15 = (&v368 - v7);
    v25 = MEMORY[0x1EEE9AC00](v24);
    v379 = (&v368 - v7);
    v26 = MEMORY[0x1EEE9AC00](v25);
    v377 = (&v368 - v7);
    v27 = MEMORY[0x1EEE9AC00](v26);
    v384 = (&v368 - v7);
    MEMORY[0x1EEE9AC00](v27);
    v20 = &v368 - v7;
  }

  memmove(*(a1 + 88), (*(a1 + 88) + 2 * *(a1 + 12)), 2 * *(a1 + 36) + 4);
  v28 = memmove(*(a1 + 104), (*(a1 + 104) + 2 * *(a1 + 12)), 2 * *(a1 + 36) + 4);
  if (*(a1 + 308))
  {
    v28 = highpass(a2, a2, *(a1 + 12), 2 * (*(a1 + 304) != 0), (a1 + 192));
  }

  v395 = v20;
  v29 = MEMORY[0x1EEE9AC00](v28);
  v31 = (&v368 - ((v30 + 15) & 0x3FFFFFFF0));
  if (v32)
  {
    v29 = memset(&v368 - ((v30 + 15) & 0x3FFFFFFF0), 170, v30);
  }

  v33 = *(a1 + 28);
  v34 = (v33 + 1);
  MEMORY[0x1EEE9AC00](v29);
  v36 = (&v368 - v35);
  if ((v37 & 1) == 0)
  {
    memset(&v368 - v35, 170, 2 * v34);
  }

  v38 = *(a1 + 24);
  v39 = *(a1 + 12);
  v40 = v38 - v39;
  if (v38 - v39 < 1)
  {
    v40 = 0;
  }

  else
  {
    v41 = *(a1 + 80);
    v42 = *(a1 + 120);
    v43 = v31;
    v44 = (v38 - v39);
    do
    {
      v46 = *v41++;
      v45 = v46;
      v47 = *v42++;
      *v43++ = (v47 * v45) >> 14;
      --v44;
    }

    while (v44);
  }

  if (v40 < v38)
  {
    v48 = v38 - v40;
    v49 = &v31[v40];
    v50 = (*(a1 + 120) + 2 * v40);
    v51 = v39 + v40 - v38;
    do
    {
      v52 = *v50++;
      *v49++ = (v52 * a2[v51++]) >> 14;
      --v48;
    }

    while (v48);
  }

  _spx_autocorr(v31, v36, v33 + 1, v38);
  *v36 += (*(a1 + 68) * *v36) >> 15;
  if ((v33 & 0x80000000) == 0)
  {
    v53 = *(a1 + 128);
    v54 = v36;
    do
    {
      v55 = *v53++;
      *v54 = (v55 * *v54) >> 14;
      ++v54;
      --v34;
    }

    while (v34);
  }

  _spx_lpc(v8, v36, v33);
  if (lpc_to_lsp(v8, v33, v13, 6553) != v33 && v33 >= 1)
  {
    v56 = *(a1 + 136);
    v57 = v13;
    do
    {
      v58 = *v56++;
      *v57++ = v58;
      --v33;
    }

    while (v33);
  }

  v59 = *(a1 + 8);
  v60 = *(a1 + 24) - *(a1 + 12);
  v61 = v379;
  v380 = v13;
  if (v59)
  {
    v62 = *(a1 + 28);
    if (v62 >= 1)
    {
      memcpy(v379, v13, 2 * v62);
    }
  }

  else
  {
    v62 = *(a1 + 28);
    lsp_interpolate(*(a1 + 136), v13, v379, *(a1 + 28), *(a1 + 20), 2 * *(a1 + 20));
  }

  lsp_enforce_margin(v61, v62, 16);
  lsp_to_lpc(v61, v384, v62);
  v63 = *(*(a1 + 288) + 8 * *(a1 + 296));
  if (!v63 || *(a1 + 272) >= 3 && v63[2] < 3 || v63[1] || *v63 != -1 || *(a1 + 240) || *(a1 + 244) || *(a1 + 232))
  {
    memset(v400, 170, 24);
    v399 = -1431655766;
    v398 = 0xAAAAAAAAAAAAAAAALL;
    v64 = *(a1 + 28);
    if (v64 >= 1)
    {
      v65 = *(a1 + 64);
      LOWORD(v66) = *(a1 + 64);
      v67 = v384;
      v68 = v397;
      v69 = *(a1 + 28);
      do
      {
        v70 = *v67++;
        *v68++ = (v70 * v66 + 0x4000) >> 15;
        v66 = (v66 * v65 + 0x4000) >> 15;
        --v69;
      }

      while (v69);
      v71 = *(a1 + 66);
      v72 = *(a1 + 66);
      v73 = v384;
      v74 = v396;
      do
      {
        v75 = *v73++;
        *v74++ = (v75 * v72 + 0x4000) >> 15;
        LODWORD(v72) = (v72 * v71 + 0x4000) >> 15;
        --v64;
      }

      while (v64);
    }

    v76 = v60;
    v77 = 2 * v60;
    memcpy(*(a1 + 112), *(a1 + 80), v77);
    memcpy((*(a1 + 112) + v77), a2, 2 * (*(a1 + 12) - v60));
    filter_mem16(*(a1 + 112), v397, v396, *(a1 + 112), *(a1 + 12), *(a1 + 28), *(a1 + 168));
    open_loop_nbest_pitch(*(a1 + 112), *(a1 + 32), *(a1 + 36), *(a1 + 12), v400, &v398);
    v78 = v400[0];
    v381 = v398;
    for (i = 1; i != 6; ++i)
    {
      if ((27853 * v398) >> 15 < *(&v398 + i))
      {
        v80 = *(v400 + i);
        v81 = 2 * v80 - v78;
        if (v81 < 0)
        {
          v81 = v78 - 2 * v80;
        }

        if (v81 < 3)
        {
          goto LABEL_56;
        }

        v82 = 3 * v80 - v78;
        if (v82 < 0)
        {
          v82 = v78 - 3 * v80;
        }

        if (v82 < 4)
        {
          goto LABEL_56;
        }

        v83 = 4 * v80 - v78;
        if (v83 < 0)
        {
          v83 = v78 - 4 * v80;
        }

        if (v83 < 5)
        {
          goto LABEL_56;
        }

        v84 = 5 * v80 - v78;
        if (v84 < 0)
        {
          v84 = v78 - 5 * v80;
        }

        if (v84 <= 5)
        {
LABEL_56:
          v78 = *(v400 + i);
        }
      }
    }
  }

  else
  {
    v381 = 0;
    v78 = 0;
    v77 = 2 * v60;
    v76 = v60;
  }

  memcpy(*(a1 + 96), *(a1 + 80), v77);
  memcpy((*(a1 + 96) + 2 * v76), a2, 2 * (*(a1 + 12) - v60));
  fir_mem16(*(a1 + 96), v384, *(a1 + 96), *(a1 + 12), *(a1 + 28), *(a1 + 176));
  v85 = *(a1 + 12);
  v86 = compute_rms16(*(a1 + 96), *(a1 + 12));
  if (*(a1 + 296) == 1 || v78 < 1)
  {
    v97 = v86 << 14;
  }

  else
  {
    v87 = -26214 * (2 * v381 * v381);
    v88 = (v87 + 0x10000000) >> 16;
    v89 = v88 != 0;
    if (!v88)
    {
      v88 = v87 + 0x10000000;
    }

    if (v88 <= 0xFF)
    {
      v90 = 8 * v89;
    }

    else
    {
      v88 >>= 8;
      v90 = (8 * v89) | 4;
    }

    if (v88 > 0xF)
    {
      v88 >>= 4;
      v90 |= 2u;
    }

    if (v88 <= 3)
    {
      v91 = v90;
    }

    else
    {
      v91 = v90 + 1;
    }

    v92 = (v87 + 0x10000000) >> (2 * v91 - 12);
    v93 = v87 << (12 - 2 * v91);
    if (v91 > 6)
    {
      LOWORD(v93) = v92;
    }

    v94 = (((((16816 * v93 - 827523072) >> 16) * 4 * v93 + 1387593728) >> 16) * 4 * v93 + 238157824) >> 16;
    v95 = v94 >> (13 - v91);
    v96 = v94 << (v91 - 13);
    if (v91 < 0xD)
    {
      LOWORD(v96) = v95;
    }

    v97 = ((72088 * v96) >> 16) * v86;
  }

  v98 = *(a1 + 216);
  if (!v98 || (v99 = *(a1 + 232)) == 0 && !*(a1 + 244) && !*(a1 + 240))
  {
    *(a1 + 228) = -1082130432;
LABEL_206:
    v163 = v392;
    goto LABEL_207;
  }

  v100 = *(a1 + 28);
  if (v100 < 1)
  {
    LODWORD(v378) = 0;
  }

  else
  {
    v101 = *(a1 + 136);
    v102 = 0.0;
    v103 = v380;
    do
    {
      v105 = *v101++;
      v104 = v105;
      v106 = *v103++;
      v102 = v102 + ((v104 - v106) * (v104 - v106));
      --v100;
    }

    while (v100);
    LODWORD(v378) = (v102 * 0.000000014901) > 0.05;
  }

  if (*(a1 + 256))
  {
    v107 = *(a1 + 260);
    v108 = 0.0;
    v109 = 0.0;
    if ((*(a1 + 264) * v107) > 0.0)
    {
      v109 = v107 * -0.00001 / (*(a1 + 268) + 1.0);
      if (v109 > 0.05)
      {
        v109 = 0.05;
      }

      if (v109 < -0.05)
      {
        v109 = -0.05;
      }
    }

    v110 = v109 + *(a1 + 224);
    if (v110 > 10.0)
    {
      v110 = 10.0;
    }

    if (v110 >= 0.0)
    {
      v108 = v110;
    }

    *(a1 + 224) = v108;
  }

  v111 = (v85 >> 1);
  v112 = 0.0;
  v113 = 0.0;
  if (v111 >= 1)
  {
    v114 = a2;
    v115 = (v85 >> 1);
    do
    {
      v116 = *v114++;
      v113 = v113 + (v116 * v116);
      --v115;
    }

    while (v115);
  }

  v117 = vcvtd_n_f64_s32(v381, 6uLL);
  if (v85 >= 1)
  {
    v112 = 0.0;
    do
    {
      v118 = a2[v111];
      v112 = v112 + (v118 * v118);
      ++v111;
    }

    while (v111 < v85);
  }

  v119 = v117;
  v120 = v113 + v112;
  LODWORD(v387) = 1169915904;
  v121 = log(((v113 + v112) + 6000.0));
  v122 = 0.0;
  for (j = 12; j != 32; j += 4)
  {
    v122 = v122 + ((v121 - *(v98 + j)) * (v121 - *(v98 + j)));
  }

  v124 = v122 / 150.0;
  if (v124 > 1.0)
  {
    v124 = 1.0;
  }

  *&v385 = v124;
  *&v393 = v119;
  *&v390 = -0.4;
  v389 = v119;
  v391 = v119 + -0.4;
  v125 = v391 * 3.0 * fabs(v391);
  *&v382 = (v120 * *v98) + ((1.0 - *v98) * *(v98 + 4));
  *(v98 + 4) = v382;
  v127 = *(v98 + 52);
  v126 = *(v98 + 56);
  v128 = v127 / v126;
  *(v98 + 48) = v127 / v126;
  *&v383 = v120;
  v394 = 0.3;
  v129.n128_f32[0] = pow(v120, 0.3);
  LODWORD(v388) = v99;
  if (v126 >= 0.06)
  {
    v134 = v113 + v112;
    v133 = *&v387;
  }

  else
  {
    v133 = *&v387;
    v134 = v113 + v112;
    if (v120 > *&v387)
    {
      v127 = v129.n128_f32[0] * 0.05;
      *(v98 + 52) = v127;
    }
  }

  v135 = v125;
  v136 = *&v385;
  if (v125 < v394 && v136 < 0.2 && v128 * 1.2 > v129.n128_f32[0])
  {
    goto LABEL_127;
  }

  v137 = v129.n128_f32[0];
  if (v135 < v394)
  {
    v138 = v136 >= 0.05 || v128 * 1.5 <= v137;
    if (!v138)
    {
      goto LABEL_127;
    }
  }

  if (v135 < 0.4 && v136 < 0.05)
  {
    if (v128 * 1.2 > v137 || v125 < 0.0)
    {
      goto LABEL_127;
    }

LABEL_131:
    v140 = 0;
    *(v98 + 60) = 0;
    goto LABEL_132;
  }

  if (v125 >= 0.0 || v136 >= 0.05)
  {
    goto LABEL_131;
  }

LABEL_127:
  v139 = *(v98 + 60);
  v140 = v139 + 1;
  *(v98 + 60) = v139 + 1;
  if (v139 >= 3)
  {
    v141 = v128 * 3.0;
    if ((v128 * 3.0) >= v129.n128_f32[0])
    {
      v141 = v129.n128_f32[0];
    }

    v127 = v141 * 0.05 + v127 * 0.95;
    v126 = v126 * 0.95 + 0.05;
    *(v98 + 52) = v127;
    *(v98 + 56) = v126;
  }

LABEL_132:
  v142 = v134;
  if (v128 > v129.n128_f32[0] && v134 > v133)
  {
    v143 = v129.n128_f32[0] * 0.05 + v127 * 0.95;
    v144 = v126 * 0.95 + 0.05;
    *(v98 + 52) = v143;
    *(v98 + 56) = v144;
  }

  if (v134 >= 30000.0)
  {
    v149 = v134;
    v150 = v134 + 1.0;
    v151 = log(((v134 + 1.0) / (*(v98 + 8) + 1.0)));
    v129.n128_f32[0] = log((v150 / (*&v382 + 1.0)));
    if (v129.n128_f32[0] < -5.0)
    {
      v129.n128_f32[0] = -5.0;
    }

    if (v129.n128_f32[0] > 2.0)
    {
      v129.n128_f32[0] = 2.0;
    }

    v152 = v129.n128_f32[0];
    v153 = v129.n128_f32[0] * 0.6 + 7.0;
    v154 = v129.n128_f32[0] < 0.0;
    v138 = v129.n128_f32[0] <= 0.0;
    v145 = 7.0;
    if (!v138)
    {
      v145 = v153;
    }

    v155 = v145 + v152 * 0.5;
    if (v154)
    {
      v145 = v155;
    }

    if (v151 > 0.0)
    {
      v156 = 5.0;
      if (v151 <= 5.0)
      {
        v156 = v151;
      }

      v145 = v145 + v156 * 0.5;
    }

    v146 = v393;
    v147 = v391;
    v148 = *&v390;
    v132.n128_f64[0] = v389;
    if (v113 * 1.6 < v112)
    {
      v145 = v145 + 0.5;
    }

    v142 = v149;
  }

  else
  {
    v145 = flt_19B0B0440[v134 < 10000.0];
    v146 = v393;
    if (v134 < 3000.0)
    {
      v145 = v145 + -0.7;
    }

    v147 = v391;
    v148 = *&v390;
    v132.n128_f64[0] = v389;
  }

  v157 = *(v98 + 44);
  v131.n128_f64[0] = v132.n128_f64[0] * 0.4;
  v132.n128_u32[1] = 1071854387;
  v158 = v131.n128_f64[0] + *(v98 + 40) * 0.6;
  *(v98 + 8) = v142;
  *&v158 = v158;
  *(v98 + 40) = LODWORD(v158);
  v130.n128_f64[0] = v147 + *&v158 + v148;
  v131.n128_u32[1] = 1073846681;
  v159 = v145 + v130.n128_f64[0] * 2.2;
  if (v157 > v159)
  {
    v130.n128_u64[0] = 0.5;
    v159 = v157 * 0.5 + v159 * 0.5;
  }

  v160 = v388;
  if (v159 < 4.0)
  {
    v159 = 4.0;
  }

  if (v159 > 10.0)
  {
    v159 = 10.0;
  }

  if (v140 <= 2)
  {
    v161 = v159;
  }

  else
  {
    v161 = 4.0;
  }

  if (v140)
  {
    v161 = v161 - (log(v140 + 3.0) + -1.09861229);
  }

  v129.n128_u32[1] = 0;
  if (v161 < 0.0)
  {
    v161 = 0.0;
  }

  if (v142 >= 60000.0)
  {
    v163 = v392;
  }

  else
  {
    if (v140 >= 3)
    {
      v162 = log((v140 + 3)) + -1.09861229;
      v161 = v161 + v162 * -0.5;
      if (v142 < 10000.0)
      {
        v161 = v161 + v162 * -0.5;
      }
    }

    v163 = v392;
    if (v161 < 0.0)
    {
      v161 = 0.0;
    }

    v129.n128_f64[0] = log(*&v383 / 60000.0 + 0.0001);
    v130.n128_u32[1] = HIDWORD(v394);
    v129.n128_f64[0] = v161 + v129.n128_f64[0] * v394;
    v161 = v129.n128_f64[0];
  }

  v129.n128_u32[0] = -1.0;
  if (v161 >= -1.0)
  {
    v129.n128_f32[0] = v161;
  }

  *(v98 + 36) = v146;
  *(v98 + 44) = v129.n128_u32[0];
  v164 = *(v98 + 12);
  *(v98 + 16) = v164;
  *(v98 + 12) = v121;
  *(a1 + 228) = v129.n128_u32[0];
  if (v160)
  {
    v165 = 0;
    v166 = *(a1 + 224);
    v167 = vcvtms_s32_f32(v166);
    v164.n128_f32[0] = v166 - floorf(v166);
    v130.n128_f32[0] = (v167 + 1) - v166;
    v168 = &unk_19B3B937C;
    v131.n128_u32[0] = 1120403456;
    v169 = 8;
    do
    {
      if (v167 == 10)
      {
        v170 = v168[10];
      }

      else
      {
        v170 = (v130.n128_f32[0] * v168[v167]) + (v164.n128_f32[0] * v168[v167 + 1]);
      }

      v138 = v129.n128_f32[0] <= v170;
      v132.n128_f32[0] = v129.n128_f32[0] - v170;
      if (!v138 && v132.n128_f32[0] < v131.n128_f32[0])
      {
        v165 = v169;
        v131.n128_u32[0] = v132.n128_u32[0];
      }

      v168 -= 11;
      --v169;
    }

    while (v169);
    LODWORD(v400[0]) = v165;
    if (v165)
    {
      v172 = 0;
    }

    else
    {
      v175 = *(a1 + 252);
      if ((v175 == 0) | v378 & 1 || v175 > 20 || !*(a1 + 248))
      {
        v172 = 1;
        LODWORD(v400[0]) = 1;
      }

      else
      {
        LODWORD(v400[0]) = 0;
        v172 = v175 + 1;
      }
    }

    *(a1 + 252) = v172;
    (*(*a1 + 80))(a1, 6, v400, v129, v164, v130, v131, v132);
    if (*(a1 + 236) >= 1)
    {
      LODWORD(v398) = -1431655766;
      (*(*a1 + 80))(a1, 19, &v398);
      if (v398 > *(a1 + 236))
      {
        LODWORD(v398) = *(a1 + 236);
        (*(*a1 + 80))(a1, 18, &v398);
      }
    }

    if (*(a1 + 256))
    {
      LODWORD(v398) = -1431655766;
      (*(*a1 + 80))(a1, 19, &v398);
      v176 = v398 - *(a1 + 256);
      *(a1 + 260) = *(a1 + 260) + v176;
      v177 = v176 * 0.05 + *(a1 + 264) * 0.95;
      *(a1 + 264) = v177;
      *(a1 + 268) = *(a1 + 268) + 1.0;
    }

    goto LABEL_206;
  }

  if (v129.n128_f32[0] >= 2.0)
  {
    *(a1 + 252) = 0;
    v174 = *(a1 + 300);
  }

  else
  {
    v173 = *(a1 + 252);
    if ((v173 == 0) | v378 & 1 || v173 > 20 || !*(a1 + 248))
    {
      v174 = 1;
      *(a1 + 252) = 1;
    }

    else
    {
      v174 = 0;
      *(a1 + 252) = v173 + 1;
    }
  }

  *(a1 + 296) = v174;
LABEL_207:
  if (*(a1 + 284))
  {
    speex_bits_pack(v163, 0, 1);
    speex_bits_pack(v163, *(a1 + 296), 4);
  }

  v178 = *(*(a1 + 288) + 8 * *(a1 + 296));
  if (v178)
  {
    v179 = *(a1 + 28);
    if (*(a1 + 8) && v179 >= 1)
    {
      v180 = *(a1 + 136);
      v181 = v380;
      v182 = *(a1 + 28);
      do
      {
        v183 = *v181++;
        *v180++ = v183;
        --v182;
      }

      while (v182);
    }

    (*(v178 + 16))(v380, v15, v179, v163);
    v184 = *(*(a1 + 288) + 8 * *(a1 + 296));
    if (*v184 != -1)
    {
      speex_bits_pack(v163, v78 - *(a1 + 32), 7);
      v184 = *(*(a1 + 288) + 8 * *(a1 + 296));
    }

    if (v184[1])
    {
      v185 = (15 * ((58982 * v381) >> 16) + 32) >> 6;
      if (v185 >= 15)
      {
        v185 = 15;
      }

      v186 = v185 & ~(v185 >> 31);
      speex_bits_pack(v392, v186, 4);
      v187 = 139840 * v186 + 0x4000;
      v163 = v392;
      v381 = v187 >> 15;
    }

    v188 = 0;
    while (ol_gain_table[v188] < v97)
    {
      if (++v188 == 31)
      {
        LODWORD(v188) = 31;
        break;
      }
    }

    v189 = ol_gain_table[v188];
    v190 = speex_bits_pack(v163, v188, 5);
    if (*(a1 + 8))
    {
      v191 = *(a1 + 28);
      if (v191 >= 1)
      {
        v192 = *(a1 + 144);
        v193 = v15;
        do
        {
          v194 = *v193++;
          *v192++ = v194;
          --v191;
        }

        while (v191);
      }
    }

    v376 = v78;
    v195 = *(a1 + 16);
    MEMORY[0x1EEE9AC00](v190);
    v196 = (2 * v195 + 15) & 0x3FFFFFFF0;
    v197 = &v368 - v196;
    v198 = 4 * v195;
    v387 = (&v368 - v196);
    if (v195)
    {
      v199 = memset(v197, 170, 2 * v195);
      MEMORY[0x1EEE9AC00](v199);
      v200 = (v198 + 15) & 0x7FFFFFFF0;
      *&v391 = &v368 - v200;
      v201 = memset(&v368 - v200, 170, 4 * v195);
      MEMORY[0x1EEE9AC00](v201);
      v388 = &v368 - v200;
      v202 = memset(&v368 - v200, 170, 4 * v195);
      MEMORY[0x1EEE9AC00](v202);
      *&v389 = &v368 - v196;
      v203 = memset(&v368 - v196, 170, 2 * v195);
      MEMORY[0x1EEE9AC00](v203);
      v393 = (&v368 - v196);
      v204 = memset(&v368 - v196, 170, 2 * v195);
      MEMORY[0x1EEE9AC00](v204);
      v205 = &v368 - v196;
      memset(&v368 - v196, 170, 2 * v195);
    }

    else
    {
      v215 = MEMORY[0x1EEE9AC00](v197);
      *&v391 = &v368 - ((v198 + 15) & 0x7FFFFFFF0);
      v216 = MEMORY[0x1EEE9AC00](v215);
      v388 = &v368 - v217;
      v218 = MEMORY[0x1EEE9AC00](v216);
      *&v389 = &v368 - v196;
      v219 = MEMORY[0x1EEE9AC00](v218);
      v393 = (&v368 - v196);
      MEMORY[0x1EEE9AC00](v219);
      v205 = &v368 - v196;
    }

    v378 = v15;
    v369 = a2;
    v383 = v205;
    bzero(v205, 2 * v195);
    MEMORY[0x1EEE9AC00](v220);
    v222 = (&v368 - ((v221 + 15) & 0x7FFFFFFF0));
    if (v223)
    {
      memset(&v368 - ((v221 + 15) & 0x7FFFFFFF0), 170, v221);
    }

    LODWORD(v224) = *(a1 + 20);
    if (v224 >= 1)
    {
      v225 = 0;
      v226 = 28406 * (v189 >> 15) + ((28406 * (v189 & 0x7FFFu)) >> 15);
      v374 = a1 + 40;
      v373 = (v226 + 0x2000) >> 14;
      v372 = v373 >> 1;
      v371 = (v226 >> 14);
      v375 = v226;
      v370 = v226 & 0x3FFF;
      v385 = -2;
      while (1)
      {
        LODWORD(v390) = *(a1 + 16);
        v382 = *(a1 + 96);
        v394 = *(a1 + 112);
        v227 = *(a1 + 28);
        v228 = v379;
        lsp_interpolate(*(a1 + 136), v380, v379, *(a1 + 28), v225, v224);
        v229 = v377;
        lsp_interpolate(*(a1 + 144), v378, v377, v227, v225, v224);
        lsp_enforce_margin(v228, v227, 16);
        lsp_enforce_margin(v229, v227, 16);
        lsp_to_lpc(v228, v384, v227);
        v230 = v229;
        v231 = v395;
        lsp_to_lpc(v230, v395, *(a1 + 28));
        v232 = *(a1 + 28);
        if (v232 < 1)
        {
          v234 = 0x2000;
        }

        else
        {
          v233 = 0;
          v234 = 0x2000;
          do
          {
            v234 = v234 + v231[v233 + 1] - v231[v233];
            v233 += 2;
          }

          while (v233 < v232);
        }

        *(*(a1 + 200) + 4 * v225) = v234;
        v235 = *(a1 + 28);
        v236 = v383;
        if (v235 >= 1)
        {
          v237 = *(a1 + 64);
          LOWORD(v238) = *(a1 + 64);
          v239 = v384;
          v240 = v397;
          v241 = *(a1 + 28);
          do
          {
            v242 = *v239++;
            *v240++ = (v242 * v238 + 0x4000) >> 15;
            v238 = (v238 * v237 + 0x4000) >> 15;
            --v241;
          }

          while (v241);
          v243 = *(a1 + 66);
          if (v243 < 0)
          {
            bzero(v396, 2 * v235);
          }

          else
          {
            v244 = v384;
            v245 = v396;
            v246 = v235;
            LOWORD(v247) = *(a1 + 66);
            do
            {
              v248 = *v244++;
              *v245++ = (v248 * v247 + 0x4000) >> 15;
              v247 = (v247 * v243 + 0x4000) >> 15;
              --v246;
            }

            while (v246);
          }
        }

        v249 = (*(a1 + 24) - *(a1 + 12));
        if (v249 != *(a1 + 16))
        {
          break;
        }

        v250 = v390 * v225;
        *&v394 += 2 * v390 * v225;
        if (v225)
        {
          if (v249 >= 1)
          {
            v251 = (v369 + v385 * v249);
            v252 = v394;
            v253 = v236;
            v254 = v249;
            do
            {
              v255 = *v251++;
              **&v252 = v255;
              *&v252 += 2;
              *v253++ = v255;
              --v254;
            }

            while (v254);
          }
        }

        else if (v249 >= 1)
        {
          v256 = *(a1 + 80);
          v257 = v394;
          v258 = v236;
          v259 = v249;
          do
          {
            v260 = *v256++;
            **&v257 = v260;
            *&v257 += 2;
            *v258++ = v260;
            --v259;
          }

          while (v259);
        }

        fir_mem16(v236, v231, v236, v249, v235, *(a1 + 184));
        v261 = v390 >> (*(a1 + 272) == 0);
        v262 = *(a1 + 28);
        compute_impulse_response(v231, v397, v396, v393, v261, *(a1 + 28));
        v263 = *(a1 + 16);
        if (v261 < v263)
        {
          bzero(&v393[v261], 2 * (v263 + ~v261) + 2);
        }

        if (v262 >= 1)
        {
          v264 = *(a1 + 152);
          v265 = v222;
          v266 = v262;
          do
          {
            v267 = *v264++;
            *v265++ = 2 * v267;
            --v266;
          }

          while (v266);
        }

        v268 = *&v389;
        if (v263 >= 1)
        {
          bzero(*&v389, 2 * v263);
          v268 = *&v389;
        }

        v269 = v268;
        iir_mem16(v268, v395, v268, v263, v262, v222);
        if (v262 < 1)
        {
          filter_mem16(v269, v397, v396, v269, v263, v262, v222);
          v275 = v383;
        }

        else
        {
          v270 = 0;
          v271 = *(a1 + 160);
          do
          {
            v222[v270] = 2 * *(v271 + v270 * 4);
            ++v270;
          }

          while (v262 != v270);
          filter_mem16(*&v389, v397, v396, *&v389, v263, v262, v222);
          v272 = *(a1 + 160);
          v273 = v222;
          v274 = v262;
          v275 = v383;
          do
          {
            v276 = *v272++;
            *v273++ = v276;
            --v274;
          }

          while (v274);
        }

        filter_mem16(*&v394, v397, v396, *&v394, v263, v262, v222);
        if (!*(a1 + 272) && *(a1 + 28) >= 1)
        {
          v277 = 0;
          v278 = *(a1 + 160);
          do
          {
            *(v278 + 4 * v277) = v222[v277];
            ++v277;
          }

          while (v277 < *(a1 + 28));
        }

        v279 = *(a1 + 16);
        v280 = v387;
        if (v279 >= 1)
        {
          v281 = v394;
          v282 = v389;
          v283 = v387;
          v284 = *(a1 + 16);
          do
          {
            v286 = **&v281;
            *&v281 += 2;
            v285 = v286;
            v287 = **&v282;
            *&v282 += 2;
            v288 = v285 - ((v287 + 1) >> 1);
            if (v288 <= -32767)
            {
              v288 = -32767;
            }

            if (v288 >= 0x7FFF)
            {
              LOWORD(v288) = 0x7FFF;
            }

            *v283++ = v288;
            --v284;
          }

          while (v284);
        }

        v289 = (v382 + 2 * v250);
        bzero(v289, 2 * v279);
        v290 = *(*(a1 + 288) + 8 * *(a1 + 296));
        v291 = *(v290 + 4);
        if (!v291)
        {
          fprintf(*MEMORY[0x1E69E9848], "Fatal (internal) error in %s, line %d: %s\n", "/Library/Caches/com.apple.xbs/Sources/AudioCodecs/Source/Codecs/Speex/libspeex/nb_celp.c", 773, "assertion failed: SUBMODE(ltp_quant)");
          goto LABEL_382;
        }

        v292 = *v290;
        if (*v290 == -1)
        {
          v294 = *(a1 + 32);
          v293 = *(a1 + 36);
        }

        else if (v292)
        {
          v295 = v292 + *(a1 + 32) - 1;
          if (v376 > v295)
          {
            v295 = v376;
          }

          v296 = *(a1 + 36) - v292;
          if (v295 < v296)
          {
            v296 = v295;
          }

          v294 = (v296 - v292 + 1);
          v376 = v296;
          v293 = v296 + v292;
        }

        else
        {
          v293 = v376;
          v294 = v376;
        }

        if (v293 >= v250)
        {
          v297 = v250;
        }

        else
        {
          v297 = v293;
        }

        if (*(a1 + 44))
        {
          v293 = v297;
        }

        LODWORD(v366) = *(a1 + 28);
        HIDWORD(v366) = *(a1 + 16);
        WORD2(v365) = v381;
        LODWORD(v365) = v293;
        *(*(a1 + 56) + 4 * v225) = v291(v280, *&v394, v395, v397, v396, v388, *(v290 + 6), v294, v365, v366, v392, v386, v289, v393, *(a1 + 272), *(a1 + 280), v374);
        v298 = *(a1 + 16);
        bzero(*&v391, 4 * v298);
        if (v298 >= 1)
        {
          v299 = v275;
          v300 = v388;
          v301 = v298;
          do
          {
            v302 = *v300++;
            *v299++ -= (v302 + 4096) >> 13;
            --v301;
          }

          while (v301);
        }

        v303 = compute_rms16(v275, v298);
        v304 = (v372 + (v303 << 14)) / v373;
        if (v304 >= 0x8000)
        {
          LOWORD(v304) = 0x7FFF;
        }

        v305 = *(*(*(a1 + 288) + 8 * *(a1 + 296)) + 8);
        v306 = v375;
        if (v305)
        {
          if (v305 == 3)
          {
            v307 = 0;
            while (exc_gain_quant_scal3_bound[v307] < v304)
            {
              if (++v307 == 7)
              {
                LODWORD(v307) = 7;
                break;
              }
            }

            speex_bits_pack(v392, v307, 3);
            v308 = &exc_gain_quant_scal3 + 2 * v307;
          }

          else
          {
            v309 = v304 > 14385;
            speex_bits_pack(v392, v309, 1);
            v308 = &exc_gain_quant_scal1 + 2 * v309;
          }

          v306 = v371 * *v308 + ((v370 * *v308) >> 14);
          v298 = *(a1 + 16);
        }

        v310 = v387;
        signal_div(v387, v387, v306, v298);
        v311 = *(*(a1 + 288) + 8 * *(a1 + 296));
        v312 = *(v311 + 56);
        if (!v312)
        {
          fprintf(*MEMORY[0x1E69E9848], "Fatal (internal) error in %s, line %d: %s\n", "/Library/Caches/com.apple.xbs/Sources/AudioCodecs/Source/Codecs/Speex/libspeex/nb_celp.c", 855, "assertion failed: SUBMODE(innovation_quant)");
          goto LABEL_382;
        }

        v313 = *(v311 + 72);
        v314 = *(a1 + 28);
        LODWORD(v367) = *(a1 + 272);
        HIDWORD(v367) = *(v311 + 12);
        v315 = v310;
        v316 = v391;
        v317 = v312(v315, v395, v397, v396, v313, v314, v298, *&v391, v393, v392, v386, v367);
        v318 = *(a1 + 16);
        if (v318 < 1)
        {
          if (*(*(*(a1 + 288) + 8 * *(a1 + 296)) + 12))
          {
            fprintf(*MEMORY[0x1E69E9848], "Fatal (internal) error in %s, line %d: %s\n", "/Library/Caches/com.apple.xbs/Sources/AudioCodecs/Source/Codecs/Speex/libspeex/nb_celp.c", 872, "assertion failed: st->subframeSize > 0");
LABEL_382:
            exit(1);
          }
        }

        else
        {
          v319 = *&v316;
          v320 = *(a1 + 16);
          do
          {
            *v319 = ((*v319 >> 7) * (v306 >> 14) + (((*v319 >> 7) * (v306 & 0x3FFF)) >> 14)) << 7;
            ++v319;
            --v320;
          }

          while (v320);
          v321 = v388;
          v322 = v316;
          v323 = v289;
          v324 = v318;
          do
          {
            v326 = *v321++;
            v325 = v326;
            v327 = **&v322;
            *&v322 += 4;
            v328 = (v327 + 2 * v325 + 0x2000) >> 14;
            if (v328 <= -32767)
            {
              v328 = -32767;
            }

            if (v328 >= 0x7FFF)
            {
              LOWORD(v328) = 0x7FFF;
            }

            *v323++ = v328;
            --v324;
          }

          while (v324);
          if (*(*(*(a1 + 288) + 8 * *(a1 + 296)) + 12))
          {
            *&v390 = COERCE_DOUBLE(&v368);
            MEMORY[0x1EEE9AC00](v317);
            v330 = (&v368 - ((v329 + 15) & 0x7FFFFFFF0));
            memset(v330, 170, v329);
            v331 = *(a1 + 16);
            bzero(v330, 4 * v331);
            if (v331 >= 1)
            {
              v332 = v387;
              v333 = v331;
              do
              {
                *v332 = (18022 * *v332 + 4096) >> 13;
                ++v332;
                --v333;
              }

              while (v333);
            }

            v334 = *(*(a1 + 288) + 8 * *(a1 + 296));
            (*(v334 + 56))(v387, v395, v397, v396, *(v334 + 72), *(a1 + 28), v331, v330, v393, v392, v386, *(a1 + 272));
            v335 = *(a1 + 16);
            v316 = v391;
            if (v335 >= 1)
            {
              v336 = 14895 * (v306 >> 15) + ((14895 * (v306 & 0x7FFFu)) >> 15);
              v337 = v336 >> 14;
              v338 = v336 & 0x3FFF;
              v339 = v330;
              v340 = *(a1 + 16);
              do
              {
                *v339 = ((*v339 >> 7) * v337 + (((*v339 >> 7) * v338) >> 14)) << 7;
                ++v339;
                --v340;
              }

              while (v340);
              v341 = v316;
              do
              {
                v342 = *v330++;
                **&v341 += v342;
                *&v341 += 4;
                --v335;
              }

              while (v335);
            }

            LODWORD(v318) = *(a1 + 16);
          }

          if (v318 >= 1)
          {
            v343 = v388;
            v344 = v289;
            v345 = v318;
            do
            {
              v347 = *v343++;
              v346 = v347;
              v348 = **&v316;
              *&v316 += 4;
              v349 = (v348 + 2 * v346 + 0x2000) >> 14;
              if (v349 <= -32767)
              {
                v349 = -32767;
              }

              if (v349 >= 0x7FFF)
              {
                LOWORD(v349) = 0x7FFF;
              }

              *v344++ = v349;
              --v345;
            }

            while (v345);
          }
        }

        v350 = *(a1 + 208);
        if (v350)
        {
          *(v350 + 2 * v225) = compute_rms(*&v391, v318);
        }

        v351 = *&v394;
        iir_mem16(v289, v395, *&v394, v318, *(a1 + 28), *(a1 + 152));
        if (*(a1 + 272))
        {
          filter_mem16(v351, v397, v396, v351, *(a1 + 16), *(a1 + 28), *(a1 + 160));
        }

        ++v225;
        v224 = *(a1 + 20);
        v385 += 2;
        if (v225 >= v224)
        {
          goto LABEL_356;
        }
      }

      fprintf(*MEMORY[0x1E69E9848], "Fatal (internal) error in %s, line %d: %s\n", "/Library/Caches/com.apple.xbs/Sources/AudioCodecs/Source/Codecs/Speex/libspeex/nb_celp.c", 721, "assertion failed: st->windowSize-st->frameSize == st->subframeSize");
      goto LABEL_382;
    }

LABEL_356:
    v352 = *(a1 + 296);
    v353 = v369;
    if (v352 >= 1)
    {
      v354 = *(a1 + 28);
      v355 = v378;
      if (v354 >= 1)
      {
        v356 = *(a1 + 136);
        v357 = *(a1 + 28);
        v358 = v380;
        do
        {
          v359 = *v358++;
          *v356++ = v359;
          --v357;
        }

        while (v357);
        v360 = *(a1 + 144);
        do
        {
          v361 = *v355++;
          *v360++ = v361;
          --v354;
        }

        while (v354);
      }

      if (v352 == 1)
      {
        if (*(a1 + 252))
        {
          v362 = 15;
        }

        else
        {
          v362 = 0;
        }

        speex_bits_pack(v392, v362, 4);
      }
    }

    *(a1 + 8) = 0;
    memcpy(*(a1 + 80), &v353[2 * *(a1 + 12) - *(a1 + 24)], 2 * (*(a1 + 24) - *(a1 + 12)));
    if (*(a1 + 296))
    {
      v363 = *(*(*(a1 + 288) + 8 * *(a1 + 296)) + 56) == noise_codebook_quant;
    }

    else
    {
      v363 = 1;
    }

    v364 = v363;
    *(a1 + 44) = v364;
    return 1;
  }

  else
  {
    v206 = *(a1 + 12);
    if (v206 >= 1)
    {
      v207 = *(a1 + 112);
      v208 = *(a1 + 96);
      v209 = *(a1 + 12);
      do
      {
        *v207++ = 0;
        *v208++ = 0;
        --v209;
      }

      while (v209);
    }

    if (*(a1 + 28) >= 1)
    {
      v210 = 0;
      v211 = *(a1 + 160);
      do
      {
        *(v211 + 4 * v210++) = 0;
      }

      while (v210 < *(a1 + 28));
      v206 = *(a1 + 12);
    }

    *(a1 + 8) = 1;
    *(a1 + 44) = 1;
    memcpy(*(a1 + 80), &a2[2 * v206 - *(a1 + 24)], 2 * (*(a1 + 24) - v206));
    if (*(a1 + 28) >= 1)
    {
      v212 = 0;
      v213 = *(a1 + 152);
      do
      {
        *(v213 + 4 * v212++) = 0;
      }

      while (v212 < *(a1 + 28));
    }

    return 0;
  }
}

uint64_t open_loop_nbest_pitch(int16x4_t *a1, int a2, uint64_t a3, uint64_t a4, int *a5, _WORD *a6)
{
  v140 = a4;
  v144 = *MEMORY[0x1E69E9840];
  v138 = a3;
  v10 = MEMORY[0x1EEE9AC00](a1);
  v12 = (&v132 - v11);
  v14 = (v13 + 1);
  v143 = v15;
  v139 = v14;
  v136 = v13;
  if (v13 == -1)
  {
    v16 = MEMORY[0x1EEE9AC00](v10);
    v142 = &v132 - ((v17 + 15) & 0x3FFFFFFF0);
    v18 = MEMORY[0x1EEE9AC00](v16);
    v137 = &v132 - ((v20 + 15) & 0x7FFFFFFF0);
  }

  else
  {
    v21 = 2 * v14;
    v22 = memset(&v132 - v11, 170, 2 * v14);
    MEMORY[0x1EEE9AC00](v22);
    v142 = &v132 - ((v21 + 15) & 0x3FFFFFFF0);
    v23 = memset(v142, 170, v21);
    MEMORY[0x1EEE9AC00](v23);
    v137 = &v132 - ((v24 + 15) & 0x7FFFFFFF0);
    v18 = memset(v137, 170, v24);
    v19 = v143;
  }

  v25 = v19;
  v26 = MEMORY[0x1EEE9AC00](v18);
  v28 = &v132 - v27;
  v29 = 4 * v25;
  if (!v30)
  {
    MEMORY[0x1EEE9AC00](v26);
    v32 = &v132 - ((v29 + 15) & 0x7FFFFFFF0);
    goto LABEL_16;
  }

  v31 = memset(&v132 - v27, 170, 4 * v25);
  MEMORY[0x1EEE9AC00](v31);
  v32 = &v132 - ((v29 + 15) & 0x7FFFFFFF0);
  memset(v32, 170, 4 * v25);
  if (v143 < 1)
  {
LABEL_16:
    v135 = 0;
    v39 = v137;
    v40 = v138;
    v41 = v140;
    goto LABEL_17;
  }

  memset(v28, 255, 4 * v25);
  bzero(&v132 - ((v29 + 15) & 0x7FFFFFFF0), 4 * v25);
  v33 = (v25 + 3) & 0xFFFFFFFC;
  v34 = vdupq_n_s64(v25 - 1);
  v35 = xmmword_19B0A5840;
  v36 = xmmword_19B0A5850;
  v37 = a5 + 2;
  v38 = vdupq_n_s64(4uLL);
  v39 = v137;
  v40 = v138;
  v41 = v140;
  do
  {
    v42 = vmovn_s64(vcgeq_u64(v34, v36));
    if (vuzp1_s16(v42, *v34.i8).u8[0])
    {
      *(v37 - 2) = a2;
    }

    if (vuzp1_s16(v42, *&v34).i8[2])
    {
      *(v37 - 1) = a2;
    }

    if (vuzp1_s16(*&v34, vmovn_s64(vcgeq_u64(v34, *&v35))).i32[1])
    {
      *v37 = a2;
      v37[1] = a2;
    }

    v35 = vaddq_s64(v35, v38);
    v36 = vaddq_s64(v36, v38);
    v37 += 4;
    v33 -= 4;
  }

  while (v33);
  v135 = 1;
LABEL_17:
  v43 = 0;
  v44 = -v40;
  if (-v40 < v41)
  {
    v45 = a1->i16[v44];
    if (v45 < 0)
    {
      v45 = -v45;
    }

    if ((v45 & 0xC000) != 0)
    {
      v43 = 1;
LABEL_28:
      v50 = v41 + v40;
      v51 = a1 - v40;
      do
      {
        *v51 = *v51 >> 1;
        ++v51;
        --v50;
      }

      while (v50);
    }

    else
    {
      v46 = v44;
      v47 = (v41 + v40 - 1);
      v48 = v47 - v40 + 1;
      while (v47)
      {
        v49 = a1->i16[v46 + 1];
        if (v49 < 0)
        {
          v49 = -v49;
        }

        LODWORD(v47) = v47 - 1;
        ++v46;
        if (v49 >= 0x4000)
        {
          v43 = v46 < v41;
          goto LABEL_28;
        }
      }

      v43 = v48 < v41;
    }
  }

  v141 = v12;
  v52 = v41 >> 2;
  v133 = v43;
  v53 = 0;
  if (v41 > 3)
  {
    v55 = (a1 - 2 * a2);
    v56 = v41 >> 2;
    do
    {
      v57 = *v55++;
      v53 += vaddvq_s32(vmull_s16(v57, v57)) >> 6;
      --v56;
    }

    while (v56);
    v54 = 0;
    *v39 = v53;
    v58 = a1;
    v59 = v41 >> 2;
    do
    {
      v60 = *v58++;
      v54 += vaddvq_s32(vmull_s16(v60, v60)) >> 6;
      --v59;
    }

    while (v59);
  }

  else
  {
    v54 = 0;
    *v39 = 0;
  }

  v134 = -v40;
  if (v40 > a2)
  {
    v61 = v39 + 1;
    v62 = v40 - a2;
    v63 = ~a2;
    v64 = ~a2 + v41;
    do
    {
      v65 = a1->i16[v63];
      v66 = v53 + ((v65 * v65) >> 6);
      v67 = a1->i16[v64];
      v53 = (v66 - ((v67 * v67) >> 6)) & ~((v66 - ((v67 * v67) >> 6)) >> 31);
      *v61++ = v53;
      --v64;
      --v63;
      --v62;
    }

    while (v62);
  }

  v132 = v40;
  v68 = normalize16(v39, v142, 32766, v139);
  v69 = v137;
  v70 = v139;
  v71 = v140;
  if ((v136 & 0x80000000) == 0)
  {
    v72 = 0;
    v73 = -2 * v132;
    do
    {
      if (v71 >= 4)
      {
        v74 = 0;
        v75 = a1;
        v76 = v52;
        do
        {
          v77 = *v75;
          v78 = *(v75++ + v73);
          v74 += vaddvq_s32(vmull_s16(v78, v77)) >> 6;
          --v76;
        }

        while (v76);
      }

      else
      {
        v74 = 0;
      }

      v69[v70 + ~v72++] = v74;
      v73 += 2;
    }

    while (v72 != v70);
  }

  v136 = v68;
  v79 = v141;
  result = normalize16(v69, v141, 180, v70);
  v81 = !v133;
  if (v134 >= v140)
  {
    v81 = 1;
  }

  v82 = v138;
  if ((v81 & 1) == 0)
  {
    v83 = v140 + v138;
    v84 = a1 - v138;
    do
    {
      *v84++ *= 2;
      --v83;
    }

    while (v83);
  }

  v85 = v142;
  v86 = v143;
  if (v82 >= a2)
  {
    v87 = (v143 - 1);
    v140 = v143 - 1;
    v88 = v82 + 1;
    v89 = 4 * v143 - 4;
    v90 = (a5 + v89);
    v91 = &v32[v89];
    v92 = &v28[v89];
    v93 = a2;
    do
    {
      v94 = (v79[v93 - a2] * v79[v93 - a2]);
      v95 = *&v85[2 * (v93 - a2)] + 1;
      v96 = (*&v85[2 * (v93 - a2)] + 1);
      if (*&v32[4 * v87] * v94 > *&v28[4 * v87] * v96)
      {
        *&v28[4 * v87] = v94;
        *&v32[4 * v87] = v95;
        a5[v87] = v93;
        if (v86 >= 2)
        {
          v97 = 0;
          while (*&v32[4 * v97] * v94 <= *&v28[4 * v97] * v96)
          {
            if (v87 == ++v97)
            {
              goto LABEL_65;
            }
          }

          if (v87 > v97)
          {
            v98 = v92;
            v99 = v91;
            v100 = v90;
            v101 = v140;
            v102 = v92;
            v103 = v91;
            v104 = v90;
            do
            {
              v105 = *(v102 - 1);
              v102 -= 4;
              --v101;
              *v98 = v105;
              v107 = *(v103 - 1);
              v103 -= 4;
              v106 = v107;
              v108 = *--v104;
              *v99 = v106;
              *v100 = v108;
              v98 = v102;
              v99 = v103;
              v100 = v104;
            }

            while (v101 > v97);
          }

          *&v28[4 * v97] = v94;
          *&v32[4 * v97] = v95;
          a5[v97] = v93;
          v79 = v141;
          v85 = v142;
          v86 = v143;
        }
      }

LABEL_65:
      ++v93;
    }

    while (v88 != v93);
  }

  v109 = v136;
  v110 = v135 ^ 1;
  if (!a6)
  {
    v110 = 1;
  }

  if ((v110 & 1) == 0)
  {
    v111 = HIWORD(v54);
    if (!HIWORD(v54))
    {
      v111 = v54;
    }

    if (v111 <= 0xFF)
    {
      v112 = 8 * (HIWORD(v54) != 0);
    }

    else
    {
      v111 >>= 8;
      v112 = (8 * (HIWORD(v54) != 0)) | 4;
    }

    if (v111 > 0xF)
    {
      v111 >>= 4;
      v112 |= 2u;
    }

    if (v111 <= 3)
    {
      v113 = v112;
    }

    else
    {
      v113 = v112 + 1;
    }

    v114 = v54 << (12 - 2 * v113);
    if (v113 > 6)
    {
      LOWORD(v114) = v54 >> (2 * v113 - 12);
    }

    v115 = (((((16816 * v114 - 827523072) >> 16) * 4 * v114 + 1387593728) >> 16) * 4 * v114 + 238157824) >> 16;
    v116 = v115 >> (13 - v113);
    v117 = v113 >= 0xD;
    v118 = v115 << (v113 - 13);
    if (!v117)
    {
      LOWORD(v118) = v116;
    }

    do
    {
      v119 = *a5++;
      v120 = v119 - a2;
      v121 = *&v85[2 * (v119 - a2)] << v109;
      v122 = HIWORD(v121);
      if (!HIWORD(v121))
      {
        v122 = v121;
      }

      if (v122 <= 0xFF)
      {
        v123 = 8 * (HIWORD(v121) != 0);
      }

      else
      {
        v122 >>= 8;
        v123 = (8 * (HIWORD(v121) != 0)) | 4;
      }

      if (v122 > 0xF)
      {
        v122 >>= 4;
        v123 |= 2u;
      }

      if (v122 <= 3)
      {
        v124 = v123;
      }

      else
      {
        v124 = v123 + 1;
      }

      v125 = v121 >> (2 * v124 - 12);
      v126 = v121 << (12 - 2 * v124);
      if (v124 > 6)
      {
        LOWORD(v126) = v125;
      }

      v127 = v79[v120] << result;
      v128 = (((((16816 * v126 - 827523072) >> 16) * 4 * v126 + 1387593728) >> 16) * 4 * v126 + 238157824) >> 16;
      v129 = v128 >> (13 - v124);
      v130 = v128 << (v124 - 13);
      if (v124 < 0xD)
      {
        LOWORD(v130) = v129;
      }

      v131 = v127 / (((v130 * v118) >> 6) + 10);
      if ((v131 & 0x8000) != 0)
      {
        LOWORD(v131) = 0;
      }

      *a6++ = v131;
      --v25;
    }

    while (v25);
  }

  return result;
}

void noise_codebook_quant(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, uint64_t a5, unsigned int a6, int a7, _DWORD *a8)
{
  v20[1] = *MEMORY[0x1E69E9840];
  MEMORY[0x1EEE9AC00](a1);
  v16 = (v20 - v15);
  if (v17)
  {
    v18 = a7;
    memset(v20 - v15, 170, 2 * a7);
    residue_percep_zero16(a1, a2, a3, a4, v16, a7, a6);
    if (a7 >= 1)
    {
      do
      {
        v19 = *v16++;
        *a8++ += v19 << 8;
        --v18;
      }

      while (v18);
    }
  }

  else
  {
    residue_percep_zero16(a1, a2, a3, a4, v20 - v15, 0, a6);
  }

  bzero(a1, 2 * a7);
}

uint64_t residue_percep_zero16(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, uint64_t a5, int a6, unsigned int a7)
{
  v13 = a1;
  v26[1] = *MEMORY[0x1E69E9840];
  MEMORY[0x1EEE9AC00](a1);
  v15 = v26 - v14;
  if (v16)
  {
    memset(v15, 170, 4 * a7);
    if (a7 <= 0)
    {
      filter_mem16(v13, a2, a3, a5, a6, a7, v15);
    }

    else
    {
      bzero(v15, 4 * a7);
      filter_mem16(v13, a2, a3, a5, a6, a7, v15);
      bzero(v15, 4 * a7);
    }
  }

  else if (a6 >= 1)
  {
    v17 = a5;
    v18 = a6;
    do
    {
      v20 = *v13++;
      v19 = v20;
      if (v20 <= -32767)
      {
        v21 = -32767;
      }

      else
      {
        v21 = v19;
      }

      if (v21 >= 0x7FFF)
      {
        v22 = 0x7FFF;
      }

      else
      {
        v22 = v21;
      }

      v23 = *(a2 - 1);
      v24 = *(a3 - 1);
      *v17++ = v22;
      --v18;
    }

    while (v18);
    *(v15 - 1) = v23 * v19 + -v22 * v24;
  }

  return fir_mem16(a5, a4, a5, a6, a7, v15);
}

uint64_t normalize16(int *a1, _WORD *a2, int a3, int a4)
{
  v4 = a4;
  v5 = 1;
  if (a4 >= 1)
  {
    v6 = a1;
    v7 = a4;
    do
    {
      v9 = *v6++;
      v8 = v9;
      if (v9 < 0)
      {
        v8 = -v8;
      }

      if (v8 > v5)
      {
        v5 = v8;
      }

      --v7;
    }

    while (v7);
  }

  if (v5 <= a3)
  {
    v10 = 0;
  }

  else
  {
    LODWORD(v10) = 0;
    do
    {
      v10 = (v10 + 1);
      v5 = v5 >> 1;
    }

    while (v5 > a3);
  }

  if (a4 >= 1)
  {
    do
    {
      v11 = *a1++;
      *a2++ = v11 >> v10;
      --v4;
    }

    while (v4);
  }

  return v10;
}

void nb_encoder_destroy(void **a1)
{
  free(a1[10]);
  free(a1[11]);
  free(a1[18]);
  free(a1[13]);
  free(a1[17]);
  free(a1[19]);
  free(a1[20]);
  free(a1[21]);
  free(a1[22]);
  free(a1[23]);
  free(a1[25]);
  free(a1[7]);
  free(a1[27]);

  free(a1);
}

char *nb_encoder_init(int **a1)
{
  v2 = *a1;
  v3 = malloc_type_calloc(0x138uLL, 1uLL, 0x6CE94CD7uLL);
  v4 = v3;
  if (v3)
  {
    *(v3 + 9) = 0;
    *v3 = a1;
    v5 = *v2;
    v6 = v2[1];
    v7 = *v2 / v6;
    *(v3 + 3) = *v2;
    *(v3 + 4) = v6;
    *(v3 + 5) = v7;
    *(v3 + 6) = v6 + v5;
    *(v3 + 7) = v2[2];
    *(v3 + 32) = *(v2 + 10);
    *(v3 + 66) = *(v2 + 22);
    *(v3 + 4) = *(v2 + 3);
    *(v3 + 36) = v2 + 8;
    v8 = v2[40];
    *(v3 + 75) = v8;
    *(v3 + 74) = v8;
    *(v3 + 71) = 1;
    *(v3 + 5) = 0x100000400;
    *(v3 + 10) = malloc_type_calloc(2 * v6, 1uLL, 0x6CE94CD7uLL);
    v9 = malloc_type_calloc(2 * (v2[4] + *v2) + 4, 1uLL, 0x6CE94CD7uLL);
    v10 = v2[4];
    *(v4 + 11) = v9;
    *(v4 + 12) = &v9[2 * v10 + 4];
    v11 = malloc_type_calloc(2 * (*v2 + v10) + 4, 1uLL, 0x6CE94CD7uLL);
    v12 = v11 + 2 * v2[4] + 4;
    *(v4 + 13) = v11;
    *(v4 + 14) = v12;
    *(v4 + 15) = &lpc_window;
    *(v4 + 16) = &lag_window;
    *(v4 + 17) = malloc_type_calloc(2 * *(v4 + 7), 1uLL, 0x6CE94CD7uLL);
    *(v4 + 18) = malloc_type_calloc(2 * *(v4 + 7), 1uLL, 0x6CE94CD7uLL);
    *(v4 + 2) = 1;
    v13 = *(v4 + 7);
    if (v13 >= 1)
    {
      v14 = v13 + 1;
      v15 = (v13 + 7) & 0xFFFFFFF8;
      v16 = vdupq_n_s64(v13 - 1);
      v17 = xmmword_19B0B2390;
      v18 = xmmword_19B0B23A0;
      v19 = xmmword_19B0A5840;
      v20 = xmmword_19B0A5850;
      v21 = (*(v4 + 17) + 8);
      v22.i64[0] = 0x1000000010000;
      v22.i64[1] = 0x1000000010000;
      v23 = vdupq_n_s32(0x6488u);
      v24 = vdupq_n_s64(8uLL);
      do
      {
        v25 = vmovn_s64(vcgeq_u64(v16, v20));
        v26 = vmulq_s32(vshrq_n_s32(vaddq_s32(vshlq_n_s32(vuzp1q_s32(v20, v19), 0x10uLL), v22), 0x10uLL), v23);
        if (vuzp1_s8(vuzp1_s16(v25, *v16.i8), *v16.i8).u8[0])
        {
          *(v21 - 4) = v26.i32[0] / v14;
        }

        if (vuzp1_s8(vuzp1_s16(v25, *&v16), *&v16).i8[1])
        {
          *(v21 - 3) = v26.i32[1] / v14;
        }

        if (vuzp1_s8(vuzp1_s16(*&v16, vmovn_s64(vcgeq_u64(v16, *&v19))), *&v16).i8[2])
        {
          *(v21 - 2) = v26.i32[2] / v14;
          *(v21 - 1) = v26.i32[3] / v14;
        }

        v27 = vmulq_s32(vshrq_n_s32(vaddq_s32(vshlq_n_s32(vuzp1q_s32(v18, v17), 0x10uLL), v22), 0x10uLL), v23);
        v28 = vmovn_s64(vcgeq_u64(v16, v18));
        if (vuzp1_s8(*&v16, vuzp1_s16(v28, *&v16)).i32[1])
        {
          *v21 = v27.i32[0] / v14;
        }

        if (vuzp1_s8(*&v16, vuzp1_s16(v28, *&v16)).i8[5])
        {
          v21[1] = v27.i32[1] / v14;
        }

        if (vuzp1_s8(*&v16, vuzp1_s16(*&v16, vmovn_s64(vcgeq_u64(v16, *&v17)))).i8[6])
        {
          v21[2] = v27.i32[2] / v14;
          v21[3] = v27.i32[3] / v14;
        }

        v18 = vaddq_s64(v18, v24);
        v19 = vaddq_s64(v19, v24);
        v20 = vaddq_s64(v20, v24);
        v21 += 8;
        v17 = vaddq_s64(v17, v24);
        v15 -= 8;
      }

      while (v15);
    }

    *(v4 + 19) = malloc_type_calloc(4 * v13, 1uLL, 0x6CE94CD7uLL);
    *(v4 + 20) = malloc_type_calloc(4 * *(v4 + 7), 1uLL, 0x6CE94CD7uLL);
    *(v4 + 21) = malloc_type_calloc(4 * *(v4 + 7), 1uLL, 0x6CE94CD7uLL);
    *(v4 + 22) = malloc_type_calloc(4 * *(v4 + 7), 1uLL, 0x6CE94CD7uLL);
    *(v4 + 23) = malloc_type_calloc(4 * *(v4 + 7), 1uLL, 0x6CE94CD7uLL);
    *(v4 + 25) = malloc_type_calloc(4 * *(v4 + 5), 1uLL, 0x6CE94CD7uLL);
    *(v4 + 26) = 0;
    *(v4 + 7) = malloc_type_calloc(4 * *(v4 + 5), 1uLL, 0x6CE94CD7uLL);
    v29 = malloc_type_calloc(0x40uLL, 1uLL, 0x6CE94CD7uLL);
    *(v4 + 27) = v29;
    v29[2] = 1065353216;
    *v29 = 1036831949;
    *(v29 + 4) = 0;
    *(v29 + 5) = 0;
    *(v29 + 7) = 1028443341;
    *(v29 + 6) = 0x3F2E0AE241598D9ALL;
    memset_pattern16(v29 + 3, "61\vA61\vA61\vA61\vA@", 0x14uLL);
    *(v4 + 56) = 1090519040;
    *(v4 + 232) = xmmword_19B0A5850;
    *(v4 + 31) = 0;
    *(v4 + 32) = 0;
    *(v4 + 66) = 0;
    *(v4 + 70) = 2;
    *(v4 + 34) = 0x1F4000000002;
    *(v4 + 38) = 0x100000000;
  }

  return v4;
}

uint64_t nb_mode_query(int *a1, int a2, int *a3)
{
  if (a2 == 1)
  {
    v6 = *a3;
    if (v6)
    {
      v7 = *&a1[2 * v6 + 8];
      result = 0;
      if (v7)
      {
        v5 = *(v7 + 84);
      }

      else
      {
        v5 = -1;
      }
    }

    else
    {
      result = 0;
      v5 = 5;
    }
  }

  else
  {
    if (a2)
    {
      fprintf(*MEMORY[0x1E69E9848], "warning: %s %d\n", "Unknown nb_mode_query request: ", a2);
      return 0xFFFFFFFFLL;
    }

    result = 0;
    v5 = *a1;
  }

  *a3 = v5;
  return result;
}

_WORD *forced_pitch_unquant(_WORD *result, int *a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, _DWORD *a8, _WORD *a9)
{
  if (a5 >= 63)
  {
    v9 = 63;
  }

  else
  {
    v9 = a5;
  }

  if (a7 >= 1)
  {
    v10 = a7;
    do
    {
      v11 = result[-a3] * (v9 << 7);
      *a2++ = v11;
      *result++ = (v11 + 4096) >> 13;
      --v10;
    }

    while (v10);
  }

  *a8 = a3;
  a9[2] = 0;
  *a9 = 0;
  a9[1] = v9;
  return result;
}

uint64_t forced_pitch_quant(__int16 *a1, uint64_t a2, __int16 *a3, __int16 *a4, __int16 *a5, _DWORD *a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, unsigned int a11, unsigned int a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  v20 = a1;
  v21 = a12;
  v22 = a10;
  v38[1] = *MEMORY[0x1E69E9840];
  MEMORY[0x1EEE9AC00](a1);
  v24 = (v38 - v23);
  if (a12)
  {
    memset(v38 - v23, 170, 2 * a12);
  }

  if (v22 >= 63)
  {
    v25 = 63;
  }

  else
  {
    v25 = v22;
  }

  if (v21 >= a8)
  {
    v26 = a8;
  }

  else
  {
    v26 = v21;
  }

  if (v26 < 1)
  {
    LODWORD(v26) = 0;
  }

  else
  {
    v27 = (a15 - 2 * a8);
    v28 = a6;
    v29 = v26;
    do
    {
      v30 = *v27++;
      *v28++ = v30 * (v25 << 7);
      --v29;
    }

    while (v29);
  }

  if (v26 < v21)
  {
    v31 = (v25 << 9);
    v32 = v21 - v26;
    v33 = &a6[v26];
    do
    {
      *v33 = (v33[-a8] >> 15) * v31 + (((v33[-a8] & 0x7FFF) * v31) >> 15);
      ++v33;
      --v32;
    }

    while (v32);
  }

  if (v21 < 1)
  {
    syn_percep_zero16(v24, a3, a4, a5, v24, v21, a11);
  }

  else
  {
    for (i = 0; i != v21; ++i)
    {
      v24[i] = (a6[i] + 4096) >> 13;
    }

    syn_percep_zero16(v24, a3, a4, a5, v24, v21, a11);
    do
    {
      v35 = *v24++;
      v36 = *v20 - v35;
      if (v36 <= -32700)
      {
        v36 = -32700;
      }

      if (v36 >= 32700)
      {
        LOWORD(v36) = 32700;
      }

      *v20++ = v36;
      --v21;
    }

    while (v21);
  }

  return a8;
}

uint64_t lsp_unquant_lbr(uint64_t a1, int a2, uint64_t *a3)
{
  if (a2 >= 1)
  {
    v5 = (a2 + 7) & 0xFFFFFFF8;
    v6 = vdupq_n_s64(a2 - 1);
    v7 = xmmword_19B0B2390;
    v8 = xmmword_19B0B23A0;
    v9 = xmmword_19B0A5840;
    v10 = xmmword_19B0A5850;
    v11 = (a1 + 8);
    v12 = vdupq_n_s64(1uLL);
    v13 = vdupq_n_s64(8uLL);
    do
    {
      v14 = vmovn_s64(vcgeq_u64(v6, v10));
      v15 = vaddq_s64(v10, v12);
      if (vuzp1_s8(vuzp1_s16(v14, *v6.i8), *v6.i8).u8[0])
      {
        *(v11 - 4) = v15.i16[0] << 11;
      }

      if (vuzp1_s8(vuzp1_s16(v14, *&v6), *&v6).i8[1])
      {
        *(v11 - 3) = v15.i16[4] << 11;
      }

      v16 = vaddq_s64(v9, v12);
      if (vuzp1_s8(vuzp1_s16(*&v6, vmovn_s64(vcgeq_u64(v6, *&v9))), *&v6).i8[2])
      {
        *(v11 - 2) = v16.i16[0] << 11;
        *(v11 - 1) = v16.i16[4] << 11;
      }

      v17 = vaddq_s64(v8, v12);
      v18 = vmovn_s64(vcgeq_u64(v6, v8));
      if (vuzp1_s8(*&v6, vuzp1_s16(v18, *&v6)).i32[1])
      {
        *v11 = v17.i16[0] << 11;
      }

      if (vuzp1_s8(*&v6, vuzp1_s16(v18, *&v6)).i8[5])
      {
        v11[1] = v17.i16[4] << 11;
      }

      v19 = vaddq_s64(v7, v12);
      if (vuzp1_s8(*&v6, vuzp1_s16(*&v6, vmovn_s64(vcgeq_u64(v6, *&v7)))).i8[6])
      {
        v11[2] = v19.i16[0] << 11;
        v11[3] = v19.i16[4] << 11;
      }

      v8 = vaddq_s64(v8, v13);
      v9 = vaddq_s64(v9, v13);
      v10 = vaddq_s64(v10, v13);
      v11 += 8;
      v7 = vaddq_s64(v7, v13);
      v5 -= 8;
    }

    while (v5);
  }

  v20 = speex_bits_unpack_unsigned(a3, 6);
  for (i = 0; i != 10; ++i)
  {
    *(a1 + 2 * i) += 32 * cdbk_nb[10 * v20 + i];
  }

  v22 = speex_bits_unpack_unsigned(a3, 6);
  for (j = 0; j != 5; ++j)
  {
    *(a1 + 2 * j) += 16 * cdbk_nb_low1[5 * v22 + j];
  }

  result = speex_bits_unpack_unsigned(a3, 6);
  for (k = 0; k != 5; ++k)
  {
    *(a1 + 10 + 2 * k) += 16 * cdbk_nb_high1[5 * result + k];
  }

  return result;
}

_DWORD *lsp_quant_lbr(__int16 *a1, __int16 *a2, int a3, _DWORD *a4)
{
  v6 = a2;
  v7 = a1;
  v23[3] = *MEMORY[0x1E69E9840];
  memset(v23, 170, 20);
  v8 = a3;
  if (a3 <= 0)
  {
    compute_quant_weights(a2, v23, a3);
  }

  else
  {
    for (i = 0; i != a3; ++i)
    {
      a2[i] = a1[i];
    }

    compute_quant_weights(a2, v23, a3);
    v10 = 1;
    v11 = v6;
    v12 = v8;
    do
    {
      *v11++ -= v10++ << 11;
      --v12;
    }

    while (v12);
  }

  v13 = lsp_quant(v6, cdbk_nb, a3);
  speex_bits_pack(a4, v13, 6);
  if (a3 < 1)
  {
    v21 = lsp_weight_quant(v6, v23, cdbk_nb_low1, 5);
    speex_bits_pack(a4, v21, 6);
    v22 = lsp_weight_quant(v6 + 5, &v23[1] + 2, cdbk_nb_high1, 5);

    return speex_bits_pack(a4, v22, 6);
  }

  else
  {
    v14 = 0;
    do
    {
      v6[v14++] *= 2;
    }

    while (a3 != v14);
    v15 = lsp_weight_quant(v6, v23, cdbk_nb_low1, 5);
    speex_bits_pack(a4, v15, 6);
    v16 = lsp_weight_quant(v6 + 5, &v23[1] + 2, cdbk_nb_high1, 5);
    result = speex_bits_pack(a4, v16, 6);
    v18 = v6;
    v19 = v8;
    do
    {
      *v18 = (*v18 + 1) >> 1;
      ++v18;
      --v19;
    }

    while (v19);
    do
    {
      v20 = *v7++;
      *v6 = v20 - *v6;
      ++v6;
      --v8;
    }

    while (v8);
  }

  return result;
}

void pitch_unquant_3tap(uint64_t a1, void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, _DWORD *a8, _WORD *a9, uint64_t *a10, uint64_t a11, int a12, int a13, __int16 a14, int a15)
{
  v20 = *a6 + (4 << *(a6 + 8)) * a15;
  v21 = speex_bits_unpack_unsigned(a10, *(a6 + 12));
  v50 = a3;
  v22 = v21 + a3;
  v23 = 4 * speex_bits_unpack_unsigned(a10, *(a6 + 8));
  v24 = *(v20 + v23);
  v25 = v24 + 32;
  v51 = *(v20 + v23) + 32;
  v26 = v20 + v23;
  v27 = *(v26 + 1) + 32;
  v52 = *(v26 + 1) + 32;
  v28 = *(v26 + 2);
  v29 = v28 + 32;
  v53 = v28 + 32;
  if (a12 && v22 > a13)
  {
    v30 = a14 >> (a12 > 3);
    if (v30 >= 62)
    {
      v30 = 62;
    }

    if (v27 >= 0)
    {
      LOWORD(v31) = v27;
    }

    else
    {
      v31 = -v27;
    }

    if (v24 <= -32)
    {
      v24 = -(v25 >> 1);
    }

    else
    {
      LOWORD(v24) = v24 + 32;
    }

    v32 = v31 + v24;
    if (v28 <= -32)
    {
      v28 = -(v29 >> 1);
    }

    else
    {
      LOWORD(v28) = v28 + 32;
    }

    v33 = (v32 + v28);
    if (v33 > v30)
    {
      for (i = 0; i != 6; i += 2)
      {
        *(&v51 + i) = (((v30 << 16 >> 2) / v33) * *(&v51 + i)) >> 14;
      }

      LOWORD(v25) = v51;
      LOWORD(v27) = v52;
      LOWORD(v29) = v53;
    }
  }

  *a8 = v22;
  *a9 = v25;
  a9[1] = v27;
  a9[2] = v29;
  v51 = v25 << 7;
  v52 = v27 << 7;
  v53 = v29 << 7;
  bzero(a2, 4 * a7);
  v35 = 0;
  v36 = v22 + 1;
  v37 = ~(2 * v21 + 2 * v50);
  v38 = v22 + 1;
  do
  {
    if (a7 >= v38)
    {
      v39 = v38;
    }

    else
    {
      v39 = a7;
    }

    v40 = v36 - v35;
    if (v36 - v35 >= a7)
    {
      v41 = a7;
    }

    else
    {
      v41 = v36 - v35;
    }

    if (v41 >= 1)
    {
      v42 = (a1 - 2 * v38);
      v43 = *(&v51 + 2 - v35);
      v44 = a2;
      v45 = v39;
      do
      {
        v46 = *v42++;
        *v44++ += v46 * v43;
        --v45;
      }

      while (v45);
    }

    v47 = v40 + v22;
    if (v40 + v22 >= a7)
    {
      v47 = a7;
    }

    if (v40 < v47)
    {
      v39 = v39;
      v48 = *(&v51 + 2 - v35);
      do
      {
        *(a2 + v39) += *(a1 + 2 * (v37 + v39)) * v48;
        ++v39;
      }

      while (v39 < v47);
    }

    ++v35;
    --v38;
    ++v37;
  }

  while (v35 != 3);
}

uint64_t pitch_search_3tap(__int16 *a1, int16x4_t *a2, __int16 *a3, __int16 *a4, __int16 *a5, void *a6, uint64_t *a7, uint64_t a8, int a9, int a10, unsigned int a11, int a12, _DWORD *a13, uint64_t a14, uint64_t a15, __int16 *a16, int a17, int a18, int a19, int *a20)
{
  v79 = a4;
  v80 = a5;
  v78 = a3;
  v24 = a1;
  v25 = a12;
  v27 = a17;
  v86 = *MEMORY[0x1E69E9840];
  v74 = *(a7 + 2);
  v69 = *a7;
  if (a17 >= 10)
  {
    v27 = 10;
  }

  if (v27 <= 1)
  {
    v28 = 1;
  }

  else
  {
    v28 = v27;
  }

  MEMORY[0x1EEE9AC00](a1);
  v84 = &v64[-v29];
  bzero(&v64[-v29], v30);
  v32 = a9 - a8;
  if (a9 >= a8)
  {
    v67 = a13;
    if (a12 < 1)
    {
LABEL_14:
      v81 = 0;
    }

    else
    {
      v33 = a12;
      v34 = v24;
      while (1)
      {
        v36 = *v34++;
        v35 = v36;
        if (v36 < 0)
        {
          v35 = -v35;
        }

        if (v35 >= 0x4000)
        {
          break;
        }

        if (!--v33)
        {
          goto LABEL_14;
        }
      }

      v81 = 1;
    }

    v68 = a7;
    if (-a9 < a12)
    {
      v38 = (a15 - 2 * a9);
      v39 = a12 + a9;
      while (1)
      {
        v41 = *v38++;
        v40 = v41;
        if (v41 < 0)
        {
          v40 = -v40;
        }

        if (v40 >= 0x4000)
        {
          break;
        }

        if (!--v39)
        {
          goto LABEL_24;
        }
      }

      v81 = 1;
    }

LABEL_24:
    if (v28 >= v32 + 1)
    {
      v42 = v32 + 1;
    }

    else
    {
      v42 = v28;
    }

    if (a9 == a8)
    {
      *v84 = a9;
    }

    else
    {
      v31 = open_loop_nbest_pitch(a2, a8, a9, a12, v84, 0);
    }

    if (a12 <= 0)
    {
      fprintf(*MEMORY[0x1E69E9848], "Fatal (internal) error in %s, line %d: %s\n", "/Library/Caches/com.apple.xbs/Sources/AudioCodecs/Source/Codecs/Speex/libspeex/ltp.c", 616, "assertion failed: nsf > 0");
      exit(1);
    }

    v65 = a8;
    v83 = a6;
    v66 = v64;
    v77 = a20;
    MEMORY[0x1EEE9AC00](v31);
    v73 = &v64[-v43];
    v82 = v44;
    v45 = memset(&v64[-v43], 170, v44);
    MEMORY[0x1EEE9AC00](v45);
    v46 = &v64[-((2 * v25 + 15) & 0x3FFFFFFF0)];
    v47 = memset(v46, 170, 2 * v25);
    MEMORY[0x1EEE9AC00](v47);
    v71 = v46;
    v72 = 2 * v25;
    memset(v46, 170, v72);
    if ((a9 - a8) > 0x7FFFFFFE)
    {
      v70 = 0;
      v53 = 0;
    }

    else
    {
      v76 = a15;
      v70 = 0;
      v75 = a19;
      v48 = (4 << v74) * a18;
      LODWORD(v74) = 1 << v74;
      v49 = v69 + v48;
      v85 = -1431655766;
      if (v42 <= 1)
      {
        v50 = 1;
      }

      else
      {
        v50 = v42;
      }

      v51 = -1;
      do
      {
        v52 = v83;
        v53 = *v84++;
        bzero(v83, v82);
        v54 = pitch_gain_search_3tap(v24, v78, v79, v80, v52, v49, v74, v53, a11, v25, v76, a16, v46, &v85, v75, *v77, v81);
        v55 = v54;
        if (v51 < 0 || v54 < v51)
        {
          memcpy(v73, v83, v82);
          memcpy(v71, v46, v72);
          v70 = __PAIR64__(v85, v53);
          v51 = v55;
        }

        --v50;
      }

      while (v50);
    }

    v57 = v67;
    v56 = v68;
    speex_bits_pack(v67, v70 - v65, *(v68 + 3));
    v58 = v57;
    LODWORD(v57) = HIDWORD(v70);
    speex_bits_pack(v58, HIDWORD(v70), *(v56 + 2));
    v59 = (*(*v56 + 4 * v57 + 3) << 8);
    v60 = (*v77 >> 13);
    if (*v77 < 1024)
    {
      v60 = 0;
    }

    v61 = v60 * v59;
    v62 = *v77 & 0x1FFF;
    if (*v77 < 1024)
    {
      v62 = 1024;
    }

    *v77 = v61 + ((v62 * v59) >> 13);
    memcpy(v83, v73, v82);
    memcpy(v24, v71, v72);
    if (v81)
    {
      do
      {
        *v24++ *= 2;
        --v25;
      }

      while (v25);
      return v53;
    }

    else
    {
      return v53;
    }
  }

  else
  {
    speex_bits_pack(a13, 0, *(a7 + 3));
    speex_bits_pack(a13, 0, *(a7 + 2));
    bzero(a6, 4 * a12);
  }

  return a8;
}

uint64_t pitch_gain_search_3tap(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, void *a5, uint64_t a6, int a7, int a8, unsigned int a9, unsigned int a10, uint64_t a11, __int16 *a12, int16x4_t *a13, _DWORD *a14, int a15, int a16, int a17)
{
  v144 = a7;
  v148 = a6;
  v143 = a4;
  v142 = a3;
  v139 = a2;
  v19 = a1;
  v147 = v135;
  v141 = a17;
  v136 = a16;
  v145 = a15;
  v146 = a14;
  v23 = a10;
  v140 = a9;
  v164[3] = *MEMORY[0x1E69E9840];
  v161 = -1431655766;
  *&v24 = 0xAAAAAAAAAAAAAAAALL;
  *(&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v159 = v24;
  v160 = v24;
  MEMORY[0x1EEE9AC00](a1);
  v26 = &v135[-v25];
  v28 = memset(&v135[-v25], 170, v27);
  MEMORY[0x1EEE9AC00](v28);
  v30 = &v135[-v29];
  v32 = memset(&v135[-v29], 170, v31);
  v164[0] = v26;
  v164[1] = &v26[v23];
  v150 = 2 * v23;
  v138 = &v26[v150];
  v164[2] = v138;
  v33 = a13;
  v34 = v23;
  do
  {
    v35 = *v19++;
    v33->i16[0] = v35;
    v33 = (v33 + 2);
    --v34;
  }

  while (v34);
  v137 = v135;
  v36 = v140;
  MEMORY[0x1EEE9AC00](v32);
  v38 = &v135[-v37];
  v151 = a8;
  if (v36)
  {
    v39 = &v135[-v37];
    memset(v38, 170, 4 * v36);
    v38 = v39;
    a8 = v151;
  }

  v40 = 0;
  v41 = (-2 * a8) | 1;
  v42 = v141;
  do
  {
    if (1 - a8 + v40 < 0)
    {
      v43 = v40 - a8 + 1;
    }

    else
    {
      v43 = v41 + v40;
      if (((v41 + v40) & 0x80000000) == 0)
      {
        v44 = 0;
        goto LABEL_11;
      }
    }

    v44 = *(a11 + 2 * v43);
LABEL_11:
    v30[v40++] = v44;
  }

  while (v23 != v40);
  if (v42)
  {
    v45 = v30;
    v46 = v23;
    do
    {
      *v45 = *v45 >> 1;
      ++v45;
      --v46;
    }

    while (v46);
    v47 = a13;
    v48 = v23;
    do
    {
      v47->i16[0] = v47->i16[0] >> 1;
      v47 = (v47 + 2);
      --v48;
    }

    while (v48);
  }

  v149 = a13;
  v49 = v42;
  v50 = v38;
  if (v36 <= 0)
  {
    iir_mem16(v30, v139, v30, v23, v36, v38);
  }

  else
  {
    bzero(v38, 4 * v36);
    iir_mem16(v30, v139, v30, v23, v36, v50);
    bzero(v50, 4 * v36);
  }

  filter_mem16(v30, v142, v143, v30, v23, v36, v50);
  memcpy(v138, v30, v150);
  v51 = a11 + 2 * ~v151;
  v52 = 1;
  v53 = v144;
  v54 = v149;
  do
  {
    v55 = v52;
    v56 = *(v51 + 2 * v52) >> (v49 != 0);
    v57 = v164[v55];
    *v57 = (*a12 * v56) >> 14;
    if (v23 >= 2)
    {
      v58 = v164[v55 + 1];
      v59 = v57 + 1;
      v60 = a12 + 1;
      v61 = (v23 - 1);
      do
      {
        v63 = *v58++;
        v62 = v63;
        v64 = *v60++;
        *v59++ = v62 + ((v64 * v56 + 0x2000) >> 14);
        --v61;
      }

      while (v61);
    }

    v52 = v55 - 1;
  }

  while (v55);
  v65 = 0;
  v162 = 0xAAAAAAAAAAAAAAAALL;
  v163 = -1431655766;
  v66 = v23 >> 2;
  do
  {
    if (v23 >= 4)
    {
      v67 = 0;
      v68 = v164[v65];
      v69 = v23 >> 2;
      v70 = v54;
      do
      {
        v71 = *v68++;
        v72 = v71;
        v73 = *v70++;
        v67 += vaddvq_s32(vmull_s16(v73, v72)) >> 6;
        --v69;
      }

      while (v69);
    }

    else
    {
      v67 = 0;
    }

    *(&v162 + v65++) = v67;
  }

  while (v65 != 3);
  v74 = 0;
  v75 = 1;
  do
  {
    v76 = 0;
    v77 = v164[v74];
    do
    {
      if (v23 >= 4)
      {
        v78 = 0;
        v79 = v164[v76];
        v80 = v77;
        v81 = v23 >> 2;
        do
        {
          v82 = *v80++;
          v83 = v82;
          v84 = *v79++;
          v78 += vaddvq_s32(vmull_s16(v84, v83)) >> 6;
          --v81;
        }

        while (v81);
      }

      else
      {
        v78 = 0;
      }

      *(&v159 + 3 * v76 + v74) = v78;
      *(&v159 + 3 * v74 + v76++) = v78;
    }

    while (v76 != v75);
    ++v74;
    ++v75;
  }

  while (v74 != 3);
  v85 = 0;
  memset(v153, 170, 18);
  if (v145 <= 2)
  {
    v87 = 2;
  }

  else
  {
    v87 = v145;
  }

  if (v87 >= 30)
  {
    v88 = 30;
  }

  else
  {
    v88 = v87;
  }

  v86.i64[0] = v162;
  v86.i64[1] = __PAIR64__(DWORD1(v160), v163);
  v89 = vrev64q_s32(vaddq_s32(v86, v86));
  v154 = vextq_s8(v89, v89, 0xCuLL);
  v155 = vadd_s32(*(&v159 + 4), *(&v159 + 4));
  v90 = 655 * v88;
  v156 = v161 + (((v161 & 0x7FFFu) * v90) >> 15) + (v161 >> 15) * v90;
  v157 = v160 + (((v160 & 0x7FFF) * v90) >> 15) + (v160 >> 15) * v90;
  v158 = v159 + (((v159 & 0x7FFF) * v90) >> 15) + (v159 >> 15) * v90;
  v91 = 1;
  do
  {
    v92 = v154.i32[v85];
    if (v92 < 0)
    {
      v92 = -v92;
    }

    if (v92 > v91)
    {
      v91 = v92;
    }

    ++v85;
  }

  while (v85 != 9);
  if (v91 < 0x8000)
  {
    v93 = 0;
  }

  else
  {
    v93 = 0;
    do
    {
      ++v93;
      v94 = HIWORD(v91);
      v91 >>= 1;
    }

    while (v94);
  }

  for (i = 0; i != 9; ++i)
  {
    *(v153 + i) = v154.i32[i] >> v93;
  }

  if (v53 < 1)
  {
    v97 = 0;
  }

  else
  {
    v96 = 0;
    v97 = 0;
    v98 = (v148 + 3);
    v99 = -2147483647;
    do
    {
      v100 = *(v98 - 3) + 32;
      v101 = *(v98 - 2) + 32;
      v102 = *(v98 - 1) + 32;
      v103 = ((v101 * SWORD1(v153[0])) << 6) + ((v100 * SLOWORD(v153[0])) << 6) + ((v102 * SWORD2(v153[0])) << 6) - ((v100 * v100) * SWORD2(v153[1]) + (v101 * v101) * SHIWORD(v153[1]) + (v101 * v100) * SHIWORD(v153[0]) + (v102 * v100) * SWORD1(v153[1]) + (v102 * v102) * SLOWORD(v153[2]) + (v102 * v101) * SLOWORD(v153[1]));
      v104 = *v98;
      v98 += 4;
      v105 = v104;
      if ((v136 <= 0x40000 || v105 <= 31) && v103 > v99)
      {
        v97 = v96;
        v99 = v103;
      }

      ++v96;
    }

    while (v53 != v96);
  }

  v109 = 4 * v97;
  v110 = *(v148 + v109) + 32;
  v152[0] = *(v148 + v109) + 32;
  v111 = v148 + v109;
  v112 = *(v111 + 1) + 32;
  v152[1] = *(v111 + 1) + 32;
  v113 = *(v111 + 2) + 32;
  v152[2] = *(v111 + 2) + 32;
  *v146 = v97;
  bzero(a5, 4 * v23);
  v114 = 0;
  v115 = v151;
  v116 = v151 + 1;
  v117 = (2 * ~v151) | 1;
  v118 = v151 + 1;
  v119 = v150;
  v120 = v149;
  do
  {
    if (v23 >= v118)
    {
      v121 = v118;
    }

    else
    {
      v121 = v23;
    }

    v122 = v116 - v114;
    if (v116 - v114 >= v23)
    {
      v123 = v23;
    }

    else
    {
      v123 = v116 - v114;
    }

    if (v123 >= 1)
    {
      v124 = (a11 - 2 * v118);
      v125 = (v152[2 - v114] << 7);
      v126 = a5;
      v127 = v121;
      do
      {
        v128 = *v124++;
        *v126++ += v125 * v128;
        --v127;
      }

      while (v127);
    }

    v129 = v122 + v115;
    if (v122 + v115 >= v23)
    {
      v129 = v23;
    }

    if (v122 < v129)
    {
      v121 = v121;
      v130 = (v152[2 - v114] << 7);
      do
      {
        *(a5 + v121) += v130 * *(a11 + 2 * (v117 + v121));
        ++v121;
      }

      while (v121 < v129);
    }

    ++v114;
    --v118;
    ++v117;
  }

  while (v114 != 3);
  v131 = v120;
  v132 = v23;
  do
  {
    v131->i16[0] -= ((v110 << 10) * v26[v119] + (v112 << 10) * v26[v23] + (v113 << 10) * *v26 + 0x8000) >> 16;
    v131 = (v131 + 2);
    ++v26;
    --v132;
  }

  while (v132);
  if (v23 < 4)
  {
    return 0;
  }

  LODWORD(result) = 0;
  do
  {
    v134 = *v120++;
    result = (result + (vaddvq_s32(vmull_s16(v134, v134)) >> 6));
    --v66;
  }

  while (v66);
  return result;
}

uint64_t lsp_unquant_nb(uint64_t a1, int a2, uint64_t *a3)
{
  if (a2 >= 1)
  {
    v5 = (a2 + 7) & 0xFFFFFFF8;
    v6 = vdupq_n_s64(a2 - 1);
    v7 = xmmword_19B0B2390;
    v8 = xmmword_19B0B23A0;
    v9 = xmmword_19B0A5840;
    v10 = xmmword_19B0A5850;
    v11 = (a1 + 8);
    v12 = vdupq_n_s64(1uLL);
    v13 = vdupq_n_s64(8uLL);
    do
    {
      v14 = vmovn_s64(vcgeq_u64(v6, v10));
      v15 = vaddq_s64(v10, v12);
      if (vuzp1_s8(vuzp1_s16(v14, *v6.i8), *v6.i8).u8[0])
      {
        *(v11 - 4) = v15.i16[0] << 11;
      }

      if (vuzp1_s8(vuzp1_s16(v14, *&v6), *&v6).i8[1])
      {
        *(v11 - 3) = v15.i16[4] << 11;
      }

      v16 = vaddq_s64(v9, v12);
      if (vuzp1_s8(vuzp1_s16(*&v6, vmovn_s64(vcgeq_u64(v6, *&v9))), *&v6).i8[2])
      {
        *(v11 - 2) = v16.i16[0] << 11;
        *(v11 - 1) = v16.i16[4] << 11;
      }

      v17 = vaddq_s64(v8, v12);
      v18 = vmovn_s64(vcgeq_u64(v6, v8));
      if (vuzp1_s8(*&v6, vuzp1_s16(v18, *&v6)).i32[1])
      {
        *v11 = v17.i16[0] << 11;
      }

      if (vuzp1_s8(*&v6, vuzp1_s16(v18, *&v6)).i8[5])
      {
        v11[1] = v17.i16[4] << 11;
      }

      v19 = vaddq_s64(v7, v12);
      if (vuzp1_s8(*&v6, vuzp1_s16(*&v6, vmovn_s64(vcgeq_u64(v6, *&v7)))).i8[6])
      {
        v11[2] = v19.i16[0] << 11;
        v11[3] = v19.i16[4] << 11;
      }

      v8 = vaddq_s64(v8, v13);
      v9 = vaddq_s64(v9, v13);
      v10 = vaddq_s64(v10, v13);
      v11 += 8;
      v7 = vaddq_s64(v7, v13);
      v5 -= 8;
    }

    while (v5);
  }

  v20 = speex_bits_unpack_unsigned(a3, 6);
  for (i = 0; i != 10; ++i)
  {
    *(a1 + 2 * i) += 32 * cdbk_nb[10 * v20 + i];
  }

  v22 = speex_bits_unpack_unsigned(a3, 6);
  for (j = 0; j != 5; ++j)
  {
    *(a1 + 2 * j) += 16 * cdbk_nb_low1[5 * v22 + j];
  }

  v24 = speex_bits_unpack_unsigned(a3, 6);
  for (k = 0; k != 5; ++k)
  {
    *(a1 + 2 * k) += 8 * cdbk_nb_low2[5 * v24 + k];
  }

  v26 = speex_bits_unpack_unsigned(a3, 6);
  v27 = 0;
  v28 = a1 + 10;
  do
  {
    *(v28 + 2 * v27) += 16 * cdbk_nb_high1[5 * v26 + v27];
    ++v27;
  }

  while (v27 != 5);
  result = speex_bits_unpack_unsigned(a3, 6);
  for (m = 0; m != 5; ++m)
  {
    *(v28 + 2 * m) += 8 * cdbk_nb_high2[5 * result + m];
  }

  return result;
}

_DWORD *lsp_quant_nb(__int16 *a1, __int16 *a2, int a3, _DWORD *a4)
{
  v6 = a2;
  v7 = a1;
  v26[3] = *MEMORY[0x1E69E9840];
  memset(v26, 170, 20);
  v8 = a3;
  if (a3 <= 0)
  {
    compute_quant_weights(a2, v26, a3);
  }

  else
  {
    for (i = 0; i != a3; ++i)
    {
      a2[i] = a1[i];
    }

    compute_quant_weights(a2, v26, a3);
    v10 = 1;
    v11 = v6;
    v12 = v8;
    do
    {
      *v11++ -= v10++ << 11;
      --v12;
    }

    while (v12);
  }

  v13 = lsp_quant(v6, cdbk_nb, a3);
  speex_bits_pack(a4, v13, 6);
  if (a3 >= 1)
  {
    v14 = v6;
    v15 = v8;
    do
    {
      *v14++ *= 2;
      --v15;
    }

    while (v15);
  }

  v16 = lsp_weight_quant(v6, v26, cdbk_nb_low1, 5);
  speex_bits_pack(a4, v16, 6);
  for (j = 0; j != 5; ++j)
  {
    v6[j] *= 2;
  }

  v18 = lsp_weight_quant(v6, v26, cdbk_nb_low2, 5);
  speex_bits_pack(a4, v18, 6);
  v19 = lsp_weight_quant(v6 + 5, &v26[1] + 2, cdbk_nb_high1, 5);
  speex_bits_pack(a4, v19, 6);
  for (k = 0; k != 5; ++k)
  {
    v6[k + 5] *= 2;
  }

  v21 = lsp_weight_quant(v6 + 5, &v26[1] + 2, cdbk_nb_high2, 5);
  result = speex_bits_pack(a4, v21, 6);
  if (a3 >= 1)
  {
    v23 = v6;
    v24 = v8;
    do
    {
      *v23 = (*v23 + 2) >> 2;
      ++v23;
      --v24;
    }

    while (v24);
    do
    {
      v25 = *v7++;
      *v6 = v25 - *v6;
      ++v6;
      --v8;
    }

    while (v8);
  }

  return result;
}

unsigned int *noise_codebook_unquant(unsigned int *result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (a3 >= 1)
  {
    v6 = a3;
    do
    {
      v7 = 1664525 * *a6 + 1013904223;
      *a6 = v7;
      *result++ = ((4 * ((v7 >> 16) - (v7 >> 19)) + 0x8000) >> 2) & 0xFFFFC000;
      --v6;
    }

    while (v6);
  }

  return result;
}

std::vector<char> *MPEG_D::USAC::ContextData::ContextData(std::vector<char> *this, std::vector<char>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<unsigned char>::__append(this, __n);
  }

  return this;
}

void sub_19B055CD4(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void MPEG_D::USAC::ArithDecoder::~ArithDecoder(MPEG_D::USAC::ArithDecoder *this)
{
  *this = &unk_1F0E21BB0;
  v2 = *(this + 2);
  if (v2)
  {
    *(this + 3) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x19EAE53E0);
}

{
  *this = &unk_1F0E21BB0;
  v2 = *(this + 2);
  if (v2)
  {
    *(this + 3) = v2;
    operator delete(v2);
  }
}

_DWORD *USACBitstreamReader::USACBitstreamReader(_DWORD *a1, uint64_t a2)
{
  v4 = *(a2 + 20) - *(a2 + 4);
  v5 = v4 >> 3;
  v6 = *(a2 + 40);
  v7 = v6 >= v4 >> 3;
  v8 = v6 - (v4 >> 3);
  if (v7)
  {
    v9 = v8;
  }

  else
  {
    v9 = 0;
  }

  v10 = TBitstreamReader<unsigned int>::TBitstreamReader(a1, *(a2 + 32) + v5, v9);
  *(v10 + 32) = a2;
  TBitstreamReader<unsigned int>::SkipBits(v10, (*(a2 + 20) - *(a2 + 4)) & 7);
  a1[10] = a1[6] + 8 * (a1[2] - *a1);
  return a1;
}

uint64_t USACBitstreamReader::CDKSkipBits(uint64_t result, unsigned int a2)
{
  v2 = result;
  v3 = *(result + 4);
  v4 = v3 - a2;
  if (v3 < a2)
  {
    v5 = a2 - v3;
    result += 8;
    v2[2] -= (a2 - v3) & 0xFFFFFFE0;
    v6 = (v2[11] - 1) & (v2[6] + ((a2 - v3) & 0xFFFFFFE0));
    v2[5] += v5 & 0xFFFFFFE0;
    v2[6] = v6;
    v7 = v5 & 0x1F;
    if ((v5 & 0x1F) != 0)
    {
      result = CDK_get32(result);
      *v2 = result;
      v4 = 32 - v7;
    }

    else
    {
      v4 = 0;
    }
  }

  v2[1] = v4;
  return result;
}

void *DCTWrapper::Instance(DCTWrapper *this)
{
  {
    DCTWrapper::DCTWrapper(&DCTWrapper::Instance(void)::instance);
  }

  return &DCTWrapper::Instance(void)::instance;
}

uint64_t DCTWrapper::getDct(DCTWrapper *this, int a2)
{
  v2 = 0;
  if (a2 > 255)
  {
    if (a2 <= 511)
    {
      if (a2 == 256)
      {
        this = (this + 56);
        return *this;
      }

      if (a2 == 384)
      {
        this = (this + 24);
        return *this;
      }
    }

    else
    {
      switch(a2)
      {
        case 512:
          this = (this + 64);
          return *this;
        case 768:
          this = (this + 32);
          return *this;
        case 1024:
          this = (this + 72);
          return *this;
      }
    }
  }

  else if (a2 <= 95)
  {
    if (a2 == 48)
    {
      return *this;
    }

    if (a2 == 64)
    {
      this = (this + 40);
      return *this;
    }
  }

  else
  {
    switch(a2)
    {
      case 96:
        this = (this + 8);
        return *this;
      case 128:
        this = (this + 48);
        return *this;
      case 192:
        this = (this + 16);
        return *this;
    }
  }

  return v2;
}

void DCTWrapper::DCTWrapper(DCTWrapper *this)
{
  Setup = vDSP_DCT_CreateSetup(0, 0x30uLL, vDSP_DCT_IV);
  *this = Setup;
  v3 = vDSP_DCT_CreateSetup(Setup, 0x60uLL, vDSP_DCT_IV);
  *(this + 1) = v3;
  v4 = vDSP_DCT_CreateSetup(v3, 0xC0uLL, vDSP_DCT_IV);
  *(this + 2) = v4;
  v5 = vDSP_DCT_CreateSetup(v4, 0x180uLL, vDSP_DCT_IV);
  *(this + 3) = v5;
  *(this + 4) = vDSP_DCT_CreateSetup(v5, 0x300uLL, vDSP_DCT_IV);
  v6 = vDSP_DCT_CreateSetup(0, 0x40uLL, vDSP_DCT_IV);
  *(this + 5) = v6;
  v7 = vDSP_DCT_CreateSetup(v6, 0x80uLL, vDSP_DCT_IV);
  *(this + 6) = v7;
  v8 = vDSP_DCT_CreateSetup(v7, 0x100uLL, vDSP_DCT_IV);
  *(this + 7) = v8;
  v9 = vDSP_DCT_CreateSetup(v8, 0x200uLL, vDSP_DCT_IV);
  *(this + 8) = v9;
  *(this + 9) = vDSP_DCT_CreateSetup(v9, 0x400uLL, vDSP_DCT_IV);
}

uint64_t CDK_get32(uint64_t a1)
{
  v1 = *(a1 + 16);
  v2 = *(a1 + 36);
  *(a1 + 12) += 32;
  *(a1 + 16) = (v2 - 1) & (v1 + 32);
  *a1 -= 32;
  v3 = (v1 + 31) >> 3;
  if (v1 + 32 <= v2)
  {
    v5 = *(a1 + 24);
    result = (*(v5 + (v3 - 3)) << 24) | (*(v5 + (v3 - 2)) << 16) | (*(v5 + (v3 - 1)) << 8) | *(v5 + v3);
    v7 = v1 & 7;
    if (!v7)
    {
      return result;
    }

    v8 = result >> (8 - v7);
    v9 = v3 - 4;
  }

  else
  {
    v4 = *(a1 + 32) - 1;
    v5 = *(a1 + 24);
    result = (*(v5 + (v4 & (v3 - 3))) << 24) | (*(v5 + (v4 & (v3 - 2))) << 16) | (*(v5 + (v4 & (v3 - 1))) << 8) | *(v5 + (v4 & v3));
    v7 = v1 & 7;
    if (!v7)
    {
      return result;
    }

    v8 = result >> (8 - v7);
    v9 = v4 & (v3 - 4);
  }

  return (*(v5 + v9) << (v7 | 0x18)) | v8;
}

uint64_t aacDecoder_ConfigRaw(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, DRCConfiguration *a6, double a7)
{
  v46 = *MEMORY[0x1E69E9840];
  v11 = *(a1 + 12);
  *(a1 + 2360) = a6;
  v12 = a7;
  result = MPEG_D::USAC::DynRangeCompressor::Initialize((a1 + 2072), a6, v12, a4, a5, a5);
  if (result)
  {
    return result;
  }

  if (!v11)
  {
    return 0;
  }

  v14 = 0;
  result = 0;
  v38 = a5;
  v36 = v11;
  v37 = a3;
  v35 = a2;
  while (1)
  {
    v15 = *(a3 + 4 * v14);
    if (v15)
    {
      break;
    }

LABEL_50:
    if (++v14 == v11)
    {
      return result;
    }
  }

  v16 = *(a1 + 24);
  v17 = *(a2 + 8 * v14);
  v40 = 0;
  if (v15 >= 0x401)
  {
LABEL_55:
    result = 8195;
    if (v14)
    {
LABEL_58:
      result = 0;
      *(a1 + 12) = v14;
    }

    return result;
  }

  v39 = result;
  v44 = 0xAAAAAAAAAAAAAAAALL;
  *&v18 = 0xAAAAAAAAAAAAAAAALL;
  *(&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v42 = v18;
  v43 = v18;
  v41 = v18;
  memset(__b, 170, sizeof(__b));
  CDKmemcpy(__b, v17, v15);
  v19 = 8 * v15;
  CDK_InitBitBuffer(&v41 + 8, __b, 0x400u, v19);
  v20 = 0;
  v21 = 0;
  *&v41 = 0;
  LODWORD(v44) = 0;
  v22 = (v16 + 212 + 1328 * v14);
  v23 = 1;
  v24 = 1;
  while (1)
  {
    v25 = v23;
    if ((v20 & 1) == 0)
    {
      goto LABEL_24;
    }

    v26 = v44;
    if (v44)
    {
      if (DWORD1(v41))
      {
        CDK_put(&v41 + 8, v41, SDWORD1(v41));
        v26 = v44;
      }
    }

    else
    {
      DWORD1(v42) -= DWORD1(v41);
      DWORD2(v41) += DWORD1(v41);
      DWORD2(v42) = (HIDWORD(v43) - 1) & (DWORD2(v42) - DWORD1(v41));
    }

    *&v41 = 0;
    v27 = v19 - DWORD2(v41);
    if (v19 - DWORD2(v41) > 0x1F)
    {
      if (v26)
      {
LABEL_17:
        v28 = DWORD1(v42);
        v29 = DWORD2(v42);
        v30 = HIDWORD(v43);
      }

      else
      {
        v28 = DWORD1(v42);
        v30 = HIDWORD(v43);
        v29 = (HIDWORD(v43) - 1) & DWORD2(v42);
      }

      *&v41 = 0;
      v31 = v28 - v27;
      if (v26)
      {
        v32 = DWORD2(v41) - v27;
      }

      else
      {
        v32 = v19;
      }

      DWORD2(v41) = v32;
      DWORD1(v42) = v31;
      DWORD2(v42) = (v30 - 1) & (v29 - v27);
      goto LABEL_23;
    }

    if (v26)
    {
      goto LABEL_17;
    }

    DWORD1(v42) -= v27;
    DWORD2(v41) = v19;
    DWORD2(v42) = (HIDWORD(v43) - 1) & (DWORD2(v42) - v27);
    *&v41 = 0;
LABEL_23:
    v24 = 2;
LABEL_24:
    if (*v16 <= 0xAu && ((1 << *v16) & 0x4C0) != 0)
    {
      break;
    }

    v40 = 1;
    v34 = AudioSpecificConfig_Parse((v16 + 1540), &v41, (v16 + 8), v24, v21, 0, a1 + 2072);
    if (!v34)
    {
      memcpy((v16 + 212 + 1328 * v14), (v16 + 1540), 0x530uLL);
      if ((*(v16 + 8))(*(v16 + 16), v16 + 212 + 1328 * v14, v22[806], v22 + 807))
      {
        v34 = 1025;
      }

      else
      {
        v34 = 0;
      }
    }

    if (!(v34 | v20))
    {
      goto LABEL_31;
    }

    if (v34)
    {
      goto LABEL_53;
    }

LABEL_36:
    v23 = 0;
    v20 = 1;
    if ((v25 & 1) == 0)
    {
LABEL_45:
      v11 = v36;
      if (v40)
      {
        *(v16 + 2916) |= 0x20u;
      }

      a3 = v37;
      result = v39;
      a2 = v35;
      if (*a1 > v38 || *(a1 + 332) > v38)
      {
        result = 8199;
      }

      goto LABEL_50;
    }
  }

  if (v14)
  {
    goto LABEL_57;
  }

  v34 = CLatmDemux_ReadStreamMuxConfig(&v41, v16 + 168, (v16 + 8), v16 + 212, &v40, v24, v21, a1 + 2072);
  if (!v34)
  {
    if ((v25 & 1) == 0)
    {
      goto LABEL_45;
    }

LABEL_31:
    if (v22[807] || v22[808] || v22[809])
    {
      if ((*(v16 + 24))(*(v16 + 32), v16 + 212 + 1328 * v14))
      {
        goto LABEL_57;
      }

      v21 = 1;
    }

    goto LABEL_36;
  }

LABEL_53:
  if (v34 != 515)
  {
    if (v34 == 1026)
    {
      goto LABEL_55;
    }

LABEL_57:
    result = 5;
    if (!v14)
    {
      return result;
    }

    goto LABEL_58;
  }

  result = 8203;
  if (v14)
  {
    goto LABEL_58;
  }

  return result;
}

uint64_t MPEG_D::USAC::DynRangeCompressor::Initialize(MPEG_D::USAC::DynRangeCompressor::USACDRCExtensionPayload **this, DRCConfiguration *a2, float a3, unsigned int a4, int a5, int a6)
{
  v38 = *MEMORY[0x1E69E9840];
  if (gDRCScope)
  {
    v10 = *gDRCScope;
    if (!*gDRCScope)
    {
      goto LABEL_7;
    }
  }

  else
  {
    v10 = MEMORY[0x1E69E9C10];
  }

  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    buf = 136315906;
    buf_4 = "USACDRCExtension.cpp";
    buf_12 = 1024;
    buf_14 = 246;
    v34 = 1024;
    v35 = a5;
    v36 = 1024;
    v37 = a6;
    _os_log_impl(&dword_19AA99000, v10, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Base channel count = %d, Target channel count = %d\n", &buf, 0x1Eu);
  }

LABEL_7:
  DRCConfiguration::LogStatus(a2);
  std::unique_ptr<MPEG_D::USAC::DynRangeCompressor::USACDRCExtensionPayload>::reset[abi:ne200100](this + 8, 0);
  this[5] = a2;
  *(this + 12) = a5;
  *(this + 13) = a6;
  *(this + 32) = 0;
  v29 = this;
  if (a4 < 0x401)
  {
    goto LABEL_14;
  }

  if (a4 == 2048 || a4 == 4096)
  {
    v11 = 0;
    v27 = (this + 30);
    v28 = (this + 24);
    v26 = (this + 12);
    v12 = (this + 18);
    v13 = 1;
    do
    {
      v14 = v13;
      v15 = &v28[24 * v11];
      std::vector<std::vector<float>>::resize(v15, 0x4CuLL);
      v16 = &v27[24 * v11];
      std::vector<std::vector<float>>::resize(v16, 0x4CuLL);
      v17 = &v26[24 * v11];
      std::vector<float *>::resize(v17, 0x4CuLL);
      v18 = &v12[24 * v11];
      std::vector<float *>::resize(v18, 0x4CuLL);
      v19 = 0;
      for (i = 0; i != 1824; i += 24)
      {
        std::vector<float>::resize((*v15 + i), 0x48uLL);
        std::vector<float>::resize((*v16 + i), 0x48uLL);
        *(*v17 + v19) = *(*v15 + i);
        *(*v18 + v19) = *(*v16 + i);
        v19 += 8;
      }

      v13 = 0;
      v21 = *v18;
      v22 = &v29[2 * v11];
      *v22 = *v17;
      v22[1] = v21;
      v11 = 1;
    }

    while ((v14 & 1) != 0);
LABEL_14:
    operator new();
  }

  if (gDRCScope)
  {
    v23 = *gDRCScope;
    if (!*gDRCScope)
    {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    v23 = MEMORY[0x1E69E9C10];
  }

  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    buf = 136315394;
    buf_4 = "USACDRCExtension.cpp";
    buf_12 = 1024;
    buf_14 = 260;
    _os_log_impl(&dword_19AA99000, v23, OS_LOG_TYPE_ERROR, "%25s:%-5d Error: uniDrcDomain cannot be inferred.\n", &buf, 0x12u);
  }

  return 0xFFFFFFFFLL;
}

void sub_19B058470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29)
{
  mpddrc::UniDrcInterface::~UniDrcInterface(&a29);
  if (__p)
  {
    operator delete(__p);
  }

  mpddrc::UniDrc::~UniDrc(v30);
  MEMORY[0x19EAE53E0](v29, v31);
  _Unwind_Resume(a1);
}

void *CDKmemcpy(_BYTE *a1, _BYTE *a2, size_t __n)
{
  if (a1 - a2 < __n && a2 - a1 < __n)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void CDKmemcpy(void *, const void *, const UINT)";
    exception[2] = 513;
  }

  return memcpy(a1, a2, __n);
}

uint64_t CDK_InitBitBuffer(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4)
{
  *result = a4;
  *(result + 12) = 0;
  *(result + 4) = 0;
  *(result + 24) = a2;
  *(result + 32) = a3;
  *(result + 36) = 8 * a3;
  if (8 * a3 < a4)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void CDK_InitBitBuffer(HANDLE_CDK_BITBUF, UCHAR *, UINT, UINT)";
    v5 = 63;
    goto LABEL_6;
  }

  if (1 << -__clz(a3 >> 1) != a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void CDK_InitBitBuffer(HANDLE_CDK_BITBUF, UCHAR *, UINT, UINT)";
    v5 = 69;
LABEL_6:
    exception[2] = v5;
  }

  return result;
}

uint64_t CDK_put(uint64_t result, int a2, int a3)
{
  v3 = *(result + 16);
  v4 = v3 >> 3;
  v5 = *(result + 16) & 7;
  v6 = *(result + 32);
  LODWORD(v3) = (*(result + 36) - 1) & (v3 + a3);
  *(result + 12) += a3;
  *(result + 16) = v3;
  *result += a3;
  v7 = v6 - 1;
  v8 = (v6 - 1) & (v4 + 1);
  v9 = (v6 - 1) & (v4 + 2);
  v10 = v7 & (v4 + 3);
  v11 = *(result + 24);
  v12 = ((*(v11 + v4) << 24) | (*(v11 + v8) << 16) | (*(v11 + v9) << 8) | *(v11 + v10)) & ~(BitMask[a3] << -a3 >> v5) | ((a2 << -a3) >> v5);
  *(v11 + v4) = HIBYTE(v12);
  *(*(result + 24) + v8) = BYTE2(v12);
  *(*(result + 24) + v9) = BYTE1(v12);
  *(*(result + 24) + v10) = v12;
  v13 = v5 + a3;
  if (v13 >= 0x21)
  {
    *(*(result + 24) + (v7 & (v4 + 4))) = *(*(result + 24) + (v7 & (v4 + 4))) & ~(LOBYTE(BitMask[v13 & 7]) << (8 - (v13 & 7))) | (a2 << (8 - (v13 & 7)));
  }

  return result;
}

uint64_t CLatmDemux_ReadStreamMuxConfig(unsigned int *a1, uint64_t a2, void *a3, uint64_t a4, _DWORD *a5, int a6, char a7, uint64_t a8)
{
  v128 = *MEMORY[0x1E69E9840];
  *(a2 + 38) = 0;
  v12 = a1[1];
  if (1 - v12 <= 0)
  {
    v13 = 0;
    v14 = *a1;
  }

  else
  {
    if (v12 == -31)
    {
      v13 = 0;
    }

    else
    {
      v13 = *a1 << (1 - v12);
    }

    v14 = CDK_get32((a1 + 2));
    *a1 = v14;
    v12 = a1[1] + 32;
  }

  v15 = v12 - 1;
  a1[1] = v12 - 1;
  *(a2 + 29) = ((v14 >> (v12 - 1)) | v13) & 1;
  if (((v14 >> (v12 - 1)) | v13))
  {
    if (2 - v12 < 1)
    {
      v17 = 0;
    }

    else
    {
      if (v12 == -30)
      {
        v17 = 0;
      }

      else
      {
        v17 = v14 << (2 - v12);
      }

      v14 = CDK_get32((a1 + 2));
      *a1 = v14;
      v15 = a1[1] + 32;
    }

    a1[1] = --v15;
    *(a2 + 30) = ((v14 >> v15) | v17) & 1;
    if (((v14 >> v15) | v17))
    {
      goto LABEL_144;
    }

    if (*(a2 + 29) == 1)
    {
      *(a2 + 16) = CLatmDemux_GetValue(a1);
      v15 = a1[1];
    }
  }

  else
  {
    *(a2 + 30) = 0;
  }

  if (1 - v15 <= 0)
  {
    LOBYTE(v16) = 0;
    LODWORD(v18) = *a1;
  }

  else
  {
    if (v15 == -31)
    {
      LOBYTE(v16) = 0;
    }

    else
    {
      v16 = *a1 << (1 - v15);
    }

    LODWORD(v18) = CDK_get32((a1 + 2));
    *a1 = v18;
    v15 = a1[1] + 32;
  }

  v19 = v15 - 1;
  a1[1] = v15 - 1;
  *(a2 + 31) = ((v18 >> (v15 - 1)) | v16) & 1;
  if (7 - v15 < 1)
  {
    v20 = 0;
  }

  else
  {
    if (v15 == -25)
    {
      v20 = 0;
    }

    else
    {
      v20 = v18 << (7 - v15);
    }

    LODWORD(v18) = CDK_get32((a1 + 2));
    *a1 = v18;
    v19 = a1[1] + 32;
  }

  v21 = v19 - 6;
  a1[1] = v19 - 6;
  *(a2 + 32) = (((v18 >> (v19 - 6)) | v20) & 0x3F) + 1;
  if (10 - v19 < 1)
  {
    v22 = 0;
  }

  else
  {
    if (v19 == -22)
    {
      v22 = 0;
    }

    else
    {
      v22 = v18 << (10 - v19);
    }

    LODWORD(v18) = CDK_get32((a1 + 2));
    *a1 = v18;
    v21 = a1[1] + 32;
  }

  v23 = v21 - 4;
  a1[1] = v21 - 4;
  v24 = ((v18 >> (v21 - 4)) | v22) & 0xF;
  *(a2 + 33) = v24 + 1;
  if (v24)
  {
LABEL_144:
    result = 1026;
    goto LABEL_165;
  }

  v81 = a5;
  memset(__b, 170, sizeof(__b));
  v25 = 0;
  v84 = 0;
  v89 = a2 + 34;
  v90 = 0;
  v82 = (a2 + 12);
  v83 = __b;
  v80 = a4;
  do
  {
    if (3 - v23 < 1)
    {
      v26 = 0;
    }

    else
    {
      if (v23 == -29)
      {
        v26 = 0;
      }

      else
      {
        v26 = v18 << (3 - v23);
      }

      LODWORD(v18) = CDK_get32((a1 + 2));
      *a1 = v18;
      v23 = a1[1] + 32;
    }

    a1[1] = v23 - 3;
    *(v89 + v25) = (((v18 >> (v23 - 3)) | v26) & 7) + 1;
    if ((((v18 >> (v23 - 3)) | v26) & 7) != 0)
    {
      goto LABEL_144;
    }

    v27 = 0;
    v28 = 0;
    v29 = v82;
    do
    {
      *(v29 - 1) = v90 + v28;
      *v29 = 0;
      if (!(v28 | v25) || ((v30 = a1[1], 1 - v30 <= 0) ? (v31 = 0, v32 = *a1) : (v30 != -31 ? (v31 = *a1 << (1 - v30)) : (v31 = 0), v32 = CDK_get32((a1 + 2)), *a1 = v32, v30 = a1[1] + 32), v33 = v30 - 1, a1[1] = v33, (((v32 >> v33) | v31) & 1) == 0))
      {
        *&v34 = 0xAAAAAAAAAAAAAAAALL;
        *(&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v125 = v34;
        v126 = v34;
        v123 = v34;
        v124 = v34;
        v121 = v34;
        v122 = v34;
        v119 = v34;
        v120 = v34;
        v117 = v34;
        v118 = v34;
        v115 = v34;
        v116 = v34;
        v113 = v34;
        v114 = v34;
        v111 = v34;
        v112 = v34;
        v109 = v34;
        v110 = v34;
        v107 = v34;
        v108 = v34;
        v105 = v34;
        v106 = v34;
        v103 = v34;
        v104 = v34;
        v101 = v34;
        v102 = v34;
        v99 = v34;
        v100 = v34;
        v97 = v34;
        v98 = v34;
        __s1 = v34;
        v96 = v34;
        if (*(a2 + 39) || *(a4 + v27 + 772) != 42)
        {
          v36 = 0;
        }

        else
        {
          v35 = *(a4 + v27 + 768);
          if (v35 > 0x1000)
          {
            goto LABEL_164;
          }

          v36 = (v35 + 7) >> 3;
          v125 = 0u;
          v126 = 0u;
          v123 = 0u;
          v124 = 0u;
          v121 = 0u;
          v122 = 0u;
          v119 = 0u;
          v120 = 0u;
          v117 = 0u;
          v118 = 0u;
          v115 = 0u;
          v116 = 0u;
          v113 = 0u;
          v114 = 0u;
          v111 = 0u;
          v112 = 0u;
          v109 = 0u;
          v110 = 0u;
          v107 = 0u;
          v108 = 0u;
          v105 = 0u;
          v106 = 0u;
          v103 = 0u;
          v104 = 0u;
          v101 = 0u;
          v102 = 0u;
          v99 = 0u;
          v100 = 0u;
          v97 = 0u;
          v98 = 0u;
          __s1 = 0u;
          v96 = 0u;
          CDKmemcpy(&__s1, (a4 + v27 + 255), v36);
        }

        if (*(a2 + 29) == 1)
        {
          v94 = 0xAAAAAAAAAAAAAAAALL;
          *&v37 = 0xAAAAAAAAAAAAAAAALL;
          *(&v37 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v92 = v37;
          v93 = v37;
          v91 = v37;
          Value = CLatmDemux_GetValue(a1);
          v39 = a1[1];
          if (a1[12])
          {
            if (v39)
            {
              CDK_put((a1 + 2), *a1, v39);
            }
          }

          else
          {
            v41 = a1[6];
            v42 = a1[5] - v39;
            a1[2] += v39;
            v43 = (a1[11] - 1) & (v41 - v39);
            a1[5] = v42;
            a1[6] = v43;
          }

          *a1 = 0;
          if (Value > a1[2])
          {
            goto LABEL_164;
          }

          if (!a1[12])
          {
            a1[6] &= a1[11] - 1;
          }

          *a1 = 0;
          v44 = *(a1 + 1);
          v91 = *a1;
          v92 = v44;
          v93 = *(a1 + 2);
          v94 = *(a1 + 6);
          DWORD2(v91) = Value;
          if (*(a2 + 39))
          {
            result = AudioSpecificConfig_Parse((a4 + v27), &v91, a3, a6, a7, 0, a8);
          }

          else
          {
            result = AudioSpecificConfig_Parse(__b, &v91, a3, a6, a7, 0, a8);
          }

          if (result)
          {
LABEL_165:
            v71 = *(a2 + 39);
            *(a2 + 28) = 0u;
            *a2 = 0u;
            *(a2 + 16) = 0u;
            *(a2 + 39) = v71;
            return result;
          }

          if (v94)
          {
            if (DWORD1(v91))
            {
              CDK_put(&v91 + 8, v91, SDWORD1(v91));
            }
          }

          else
          {
            DWORD1(v92) -= DWORD1(v91);
            DWORD2(v91) += DWORD1(v91);
            DWORD2(v92) = (HIDWORD(v93) - 1) & (DWORD2(v92) - DWORD1(v91));
          }

          *&v91 = 0;
          if ((DWORD2(v91) & 0x80000000) != 0)
          {
            goto LABEL_164;
          }

          v45 = a1[1];
          v46 = a1[12];
          if (v45 <= Value)
          {
            if (v46)
            {
              if (v45)
              {
                goto LABEL_84;
              }
            }

            else
            {
              v47 = a1[6];
              v48 = a1[5] - v45;
              a1[2] += v45;
              v49 = (a1[11] - 1) & (v47 - v45);
              a1[5] = v48;
              a1[6] = v49;
            }
          }

          else
          {
            if (!v46)
            {
              a1[1] = v45 - Value;
              goto LABEL_90;
            }

LABEL_84:
            CDK_put((a1 + 2), *a1, v45);
          }

          *a1 = 0;
          if (*(a1 + 48))
          {
            v50 = Value;
          }

          else
          {
            v50 = -Value;
          }

          a1[2] += v50;
          v51 = (a1[11] - 1) & (a1[6] + Value);
          a1[5] += Value;
          a1[6] = v51;
        }

        else
        {
          if (*(a2 + 39))
          {
            result = AudioSpecificConfig_Parse((a4 + v27), a1, a3, a6, a7, 0, a8);
          }

          else
          {
            result = AudioSpecificConfig_Parse(__b, a1, a3, a6, a7, 0, a8);
          }

          if (result)
          {
            goto LABEL_165;
          }
        }

LABEL_90:
        if (*(a2 + 39))
        {
          v84 = 1;
          goto LABEL_103;
        }

        if (*&v83[v27 / 2 + 386] == 42)
        {
          if (__b[384] > 0x1000u)
          {
            goto LABEL_164;
          }

          v52 = __b[384] + 7;
          if (v36 == v52 >> 3)
          {
            if (!memcmp(&__s1, &__b[127] + 1, v36))
            {
LABEL_99:
              if (*&v83[v27 / 2 + 4] && HIBYTE(v83[v27 / 2 + 16]))
              {
                v84 = 0;
                *(a2 + 40) = 1;
                goto LABEL_103;
              }

              goto LABEL_102;
            }
          }

          else
          {
            v36 = v52 >> 3;
          }

          *(a4 + v27 + 255) = 0u;
          v53 = a4 + v27 + 255;
          *(v53 + 480) = 0u;
          *(v53 + 496) = 0u;
          *(v53 + 448) = 0u;
          *(v53 + 464) = 0u;
          *(v53 + 416) = 0u;
          *(v53 + 432) = 0u;
          *(v53 + 384) = 0u;
          *(v53 + 400) = 0u;
          *(v53 + 352) = 0u;
          *(v53 + 368) = 0u;
          *(v53 + 320) = 0u;
          *(v53 + 336) = 0u;
          *(v53 + 288) = 0u;
          *(v53 + 304) = 0u;
          *(v53 + 256) = 0u;
          *(v53 + 272) = 0u;
          *(v53 + 224) = 0u;
          *(v53 + 240) = 0u;
          *(v53 + 192) = 0u;
          *(v53 + 208) = 0u;
          *(v53 + 160) = 0u;
          *(v53 + 176) = 0u;
          *(v53 + 128) = 0u;
          *(v53 + 144) = 0u;
          *(v53 + 96) = 0u;
          *(v53 + 112) = 0u;
          *(v53 + 64) = 0u;
          *(v53 + 80) = 0u;
          *(v53 + 32) = 0u;
          *(v53 + 48) = 0u;
          *(v53 + 16) = 0u;
          CDKmemcpy(v53, &__b[127] + 1, v36);
          *(a4 + v27 + 768) = __b[384];
          *(a2 + 38) = 1;
          goto LABEL_99;
        }

LABEL_102:
        v84 = 0;
        goto LABEL_103;
      }

      if (!v27)
      {
        goto LABEL_164;
      }

      CDKmemcpy((a4 + v27), (a4 + v27 - 1328), 0x530uLL);
LABEL_103:
      v54 = a1[1];
      if (3 - v54 <= 0)
      {
        LOBYTE(v55) = 0;
        v18 = *a1;
      }

      else
      {
        if (v54 == -29)
        {
          LOBYTE(v55) = 0;
        }

        else
        {
          v55 = *a1 << (3 - v54);
        }

        v18 = CDK_get32((a1 + 2));
        *a1 = v18;
        v54 = a1[1] + 32;
      }

      v56 = v54 - 3;
      a1[1] = v54 - 3;
      v57 = ((v18 >> (v54 - 3)) | v55) & 7;
      *(v29 - 3) = v57;
      if (v57 == 1)
      {
        if (12 - v54 < 1)
        {
          v59 = 0;
        }

        else
        {
          if (v54 == -20)
          {
            v59 = 0;
          }

          else
          {
            v59 = v18 << (12 - v54);
          }

          v18 = CDK_get32((a1 + 2));
          *a1 = v18;
          v56 = a1[1] + 32;
        }

        v23 = v56 - 9;
        a1[1] = v56 - 9;
        *v29 = ((v18 >> (v56 - 9)) | v59) & 0x1FF;
      }

      else
      {
        if ((((v18 >> (v54 - 3)) | v55) & 7) != 0)
        {
          goto LABEL_164;
        }

        if (11 - v54 < 1)
        {
          v58 = 0;
        }

        else
        {
          if (v54 == -21)
          {
            v58 = 0;
          }

          else
          {
            v58 = v18 << (11 - v54);
          }

          v18 = CDK_get32((a1 + 2));
          *a1 = v18;
          v56 = a1[1] + 32;
        }

        v23 = v56 - 8;
        a1[1] = v56 - 8;
        *(v29 - 2) = ((v18 >> (v56 - 8)) | v58);
        if (v27)
        {
          if (!*(a2 + 31))
          {
            v60 = *(a4 + v27 + 772);
            if ((v60 == 20 || v60 == 6) && (*(a4 + v27 - 556) | 0x10) == 0x18)
            {
              if (v56 - 15 <= -2)
              {
                v18 = CDK_get32((a1 + 2));
                *a1 = v18;
                v23 = a1[1] + 32;
              }

              v23 -= 6;
              a1[1] = v23;
            }
          }
        }
      }

      ++v28;
      v27 += 1328;
      v29 += 4;
    }

    while (v28 < *(v89 + v25));
    v90 += v28;
    ++v25;
    a4 += 1328;
    v82 += 4;
    v83 += 664;
  }

  while (v25 < *(a2 + 33));
  if (1 - v23 < 1)
  {
    v61 = 0;
  }

  else
  {
    if (v23 == -31)
    {
      v61 = 0;
    }

    else
    {
      v61 = v18 << (1 - v23);
    }

    v18 = CDK_get32((a1 + 2));
    *a1 = v18;
    v23 = a1[1] + 32;
  }

  v62 = v80;
  v63 = v23 - 1;
  a1[1] = v23 - 1;
  *(a2 + 35) = ((v18 >> (v23 - 1)) | v61) & 1;
  *(a2 + 20) = 0;
  if (((v18 >> (v23 - 1)) | v61))
  {
    if (*(a2 + 29) == 1)
    {
      v64 = CLatmDemux_GetValue(a1);
      *(a2 + 20) = v64;
    }

    else
    {
      v64 = 0;
      do
      {
        *(a2 + 20) = v64 << 8;
        if (1 - v63 < 1)
        {
          v65 = 0;
        }

        else
        {
          if (v63 == -31)
          {
            v65 = 0;
          }

          else
          {
            v65 = v18 << (1 - v63);
          }

          v18 = CDK_get32((a1 + 2));
          *a1 = v18;
          v63 = a1[1] + 32;
        }

        v66 = v63 - 1;
        a1[1] = v63 - 1;
        if (9 - v63 < 1)
        {
          v67 = 0;
          v68 = v18;
          v69 = v63 - 1;
        }

        else
        {
          if (v63 == -23)
          {
            v67 = 0;
          }

          else
          {
            v67 = v18 << (9 - v63);
          }

          v68 = CDK_get32((a1 + 2));
          *a1 = v68;
          v69 = a1[1] + 32;
        }

        v70 = (v18 >> v66) | v65;
        v63 = v69 - 8;
        a1[1] = v63;
        v64 = *(a2 + 20) + ((v68 >> v63) | v67);
        *(a2 + 20) = v64;
        v18 = v68;
      }

      while ((v70 & 1) != 0);
    }

    if (*(a2 + 24) < v64 >> 3)
    {
LABEL_164:
      result = 1025;
      goto LABEL_165;
    }

    v63 = a1[1];
    v62 = v80;
  }

  if (1 - v63 <= 0)
  {
    v72 = 0;
    v73 = *a1;
  }

  else
  {
    if (v63 == -31)
    {
      v72 = 0;
    }

    else
    {
      v72 = *a1 << (1 - v63);
    }

    v73 = CDK_get32((a1 + 2));
    *a1 = v73;
    v63 = a1[1] + 32;
  }

  v74 = v63 - 1;
  a1[1] = v63 - 1;
  *(a2 + 36) = ((v73 >> (v63 - 1)) | v72) & 1;
  if (((v73 >> (v63 - 1)) | v72))
  {
    if (v63 - 10 <= -2)
    {
      *a1 = CDK_get32((a1 + 2));
      v74 = a1[1] + 32;
    }

    a1[1] = v74 - 8;
  }

  v75 = *(a2 + 33);
  if (*(a2 + 33))
  {
    v76 = 0;
    v77 = v62 + 807;
    do
    {
      if (*(v89 + v76))
      {
        v78 = 0;
        v79 = v77;
        while (1)
        {
          if (v84 && (result = (*a3)(a3[1], v79 - 807, *(v79 - 1), v79), result))
          {
            if (result == 515)
            {
              *v81 = 0;
              goto LABEL_165;
            }

            *v81 = 0;
            if (!v78)
            {
              result = 258;
              goto LABEL_165;
            }
          }

          else
          {
            *v81 = 1;
          }

          ++v78;
          v79 += 1328;
          if (v78 >= *(v89 + v76))
          {
            v75 = *(a2 + 33);
            break;
          }
        }
      }

      ++v76;
      v77 += 1328;
    }

    while (v76 < v75);
  }

  result = 0;
  if (a6 == 2)
  {
    *(a2 + 39) = 0;
  }

  return result;
}

uint64_t AudioSpecificConfig_Parse(char *a1, int *a2, void *a3, char a4, char a5, int a6, uint64_t a7)
{
  if (a2[12])
  {
    v14 = a2[1];
    if (v14)
    {
      CDK_put((a2 + 2), *a2, v14);
    }
  }

  else
  {
    v15 = a2[1];
    v16 = a2[6];
    v17 = a2[5] - v15;
    a2[2] += v15;
    v18 = (a2[11] - 1) & (v16 - v15);
    a2[5] = v17;
    a2[6] = v18;
  }

  *a2 = 0;
  v19 = a2[2];
  bzero(a1, 0x530uLL);
  *(a1 + 193) = -1;
  a1[803] = 15;
  a1[797] = -1;
  a1[806] = a4;
  a1[807] = a5;
  a1[808] = a5;
  a1[809] = a5;
  if (a6)
  {
    *(a1 + 193) = a6;
  }

  else
  {
    *(a1 + 193) = getAOT(a2);
    SampleRate = getSampleRate(a2, a1 + 803, 4);
    *(a1 + 194) = SampleRate;
    if ((SampleRate - 96001) < 0xFFFE8900)
    {
      return 1025;
    }

    v24 = a2[1];
    if (4 - v24 <= 0)
    {
      LOBYTE(v25) = 0;
      v34 = *a2;
    }

    else
    {
      if (v24 == -28)
      {
        LOBYTE(v25) = 0;
      }

      else
      {
        v25 = *a2 << (4 - v24);
      }

      v34 = CDK_get32((a2 + 2));
      *a2 = v34;
      v24 = a2[1] + 32;
    }

    v35 = v24 - 4;
    a2[1] = v35;
    a1[796] = ((v34 >> v35) | v25) & 0xF;
    *(a1 + 801) = 0;
    a6 = *(a1 + 193);
    if (a6 == 29 || a6 == 5)
    {
      *(a1 + 197) = 5;
      a1[801] = 1;
      if (a6 == 29)
      {
        a1[802] = 1;
      }

      *(a1 + 198) = getSampleRate(a2, a1 + 804, 4);
      AOT = getAOT(a2);
      *(a1 + 193) = AOT;
      if (AOT != 22)
      {
        return 1026;
      }

      v37 = a2[1];
      if (4 - v37 <= 0)
      {
        LOBYTE(v38) = 0;
        v49 = *a2;
        a6 = 22;
      }

      else
      {
        if (v37 == -28)
        {
          LOBYTE(v38) = 0;
        }

        else
        {
          v38 = *a2 << (4 - v37);
        }

        v49 = CDK_get32((a2 + 2));
        *a2 = v49;
        v37 = a2[1] + 32;
        a6 = *(a1 + 193);
      }

      v50 = v37 - 4;
      a2[1] = v50;
      a1[805] = ((v49 >> v50) | v38) & 0xF;
    }

    else
    {
      *(a1 + 197) = 0;
    }
  }

  if (a6 == 42)
  {
    v26 = a2[1];
    if (a2[12])
    {
      if (v26)
      {
        CDK_put((a2 + 2), *a2, v26);
      }
    }

    else
    {
      v27 = a2[6];
      v28 = a2[5] - v26;
      a2[2] += v26;
      v29 = (a2[11] - 1) & (v27 - v26);
      a2[5] = v28;
      a2[6] = v29;
    }

    *a2 = 0;
    v30 = a2[2];
    v31 = getSampleRate(a2, a1 + 803, 5);
    if (v31 < 7350)
    {
      return 1025;
    }

    *(a1 + 194) = v31;
    v32 = a2[1];
    if (3 - v32 <= 0)
    {
      LOBYTE(v33) = 0;
      v39 = *a2;
    }

    else
    {
      if (v32 == -29)
      {
        LOBYTE(v33) = 0;
      }

      else
      {
        v33 = *a2 << (3 - v32);
      }

      v39 = CDK_get32((a2 + 2));
      *a2 = v39;
      v32 = a2[1] + 32;
    }

    v40 = v32 - 3;
    a2[1] = v40;
    v41 = ((v39 >> v40) | v33) & 7;
    if (v41 > 4)
    {
      return 1025;
    }

    a1[1] = v41;
    v42 = usacFrameLength[v41];
    *(a1 + 195) = v42;
    v43 = sbrRatioIndex[v41];
    a1[2] = v43;
    if ((v41 - 5) >= 0xFFFFFFFFFFFFFFFDLL)
    {
      a1[801] = 1;
      v44 = *(a1 + 194);
      *(a1 + 198) = v44;
      a1[804] = a1[803];
      switch(v43)
      {
        case 3:
          v45 = v44 >> 1;
          *(a1 + 194) = v44 >> 1;
          v46 = v42 >> 1;
          break;
        case 2:
          v45 = (3 * v44) >> 3;
          *(a1 + 194) = v45;
          v46 = (3 * v42) >> 3;
          break;
        case 1:
          v45 = v44 >> 2;
          *(a1 + 194) = v44 >> 2;
          v46 = v42 >> 2;
          break;
        default:
          return 1025;
      }

      v55 = 0;
      *(a1 + 195) = v46;
      while (SamplingRateTable[v55] != v45)
      {
        if (++v55 == 15)
        {
          v56 = 15;
          goto LABEL_76;
        }
      }

      if (v55 <= 0xF)
      {
        v56 = v55;
      }

      else
      {
        v56 = 14;
      }

LABEL_76:
      a1[803] = v56;
    }

    v57 = a2[1];
    if (5 - v57 <= 0)
    {
      LOBYTE(v58) = 0;
      v59 = *a2;
    }

    else
    {
      if (v57 == -27)
      {
        LOBYTE(v58) = 0;
      }

      else
      {
        v58 = *a2 << (5 - v57);
      }

      v59 = CDK_get32((a2 + 2));
      *a2 = v59;
      v57 = a2[1] + 32;
    }

    v60 = v57 - 5;
    a2[1] = v57 - 5;
    v61 = ((v59 >> (v57 - 5)) | v58) & 0x1F;
    if ((v61 - 3) < 0xFFFFFFFE)
    {
      return 1025;
    }

    v259 = ((v59 >> (v57 - 5)) | v58) & 0x1F;
    a1[796] = v61;
    v62 = 9 - v57;
    if (v62 < 1)
    {
      v64 = 0;
    }

    else
    {
      v63 = v59 << v62;
      if (v60 == -28)
      {
        v64 = 0;
      }

      else
      {
        v64 = v63;
      }

      v59 = CDK_get32((a2 + 2));
      *a2 = v59;
      v60 = a2[1] + 32;
    }

    v65 = v60 - 4;
    a2[1] = v60 - 4;
    v66 = (v59 >> (v60 - 4)) | v64;
    v67 = v66 & 0xF;
    if (v67 == 15)
    {
      if (12 - v60 < 1)
      {
        v68 = 0;
      }

      else
      {
        if (v60 == -20)
        {
          v68 = 0;
        }

        else
        {
          v68 = v59 << (12 - v60);
        }

        v59 = CDK_get32((a2 + 2));
        *a2 = v59;
        v65 = a2[1] + 32;
      }

      v197 = v65 - 8;
      a2[1] = v65 - 8;
      v198 = ((v59 >> (v65 - 8)) | v68);
      v199 = v198 + 15;
      if (v198 == 255)
      {
        if (24 - v65 < 1)
        {
          v200 = 0;
        }

        else
        {
          if (v65 == -8)
          {
            v200 = 0;
          }

          else
          {
            v200 = v59 << (24 - v65);
          }

          v59 = CDK_get32((a2 + 2));
          *a2 = v59;
          v197 = a2[1] + 32;
        }

        v201 = v197 - 16;
        a2[1] = v201;
        v199 += ((v59 >> v201) | v200);
      }

      v195 = v199 + 1;
      result = 1026;
      v196 = 8;
LABEL_341:
      *&a1[v196] = v195;
      return result;
    }

    *(a1 + 2) = v67 + 1;
    if (v67 > 9)
    {
      return 1026;
    }

    v260 = 0;
    v261 = 0;
    a1[3] = 0;
    v69 = a1[796];
    a1[4] = v69;
    if (*(a1 + 193) != 42)
    {
      goto LABEL_103;
    }

    v70 = &sc_chan_config_tab[4 * v69];
    if (*v70 <= 2)
    {
      BYTE4(v260) = v70[1];
      v261 = v70[2];
      LOBYTE(v260) = v70[3];
LABEL_103:
      v71 = 0;
      v265 = 0;
      v264 = 0;
      v258 = a1 + 808;
      v263 = 24 * (v66 & 0xF) + 24;
      v262 = v30;
      while (1)
      {
        v72 = a2[1];
        if (2 - v72 <= 0)
        {
          LOBYTE(v73) = 0;
          v74 = *a2;
        }

        else
        {
          if (v72 == -30)
          {
            LOBYTE(v73) = 0;
          }

          else
          {
            v73 = *a2 << (2 - v72);
          }

          v74 = CDK_get32((a2 + 2));
          *a2 = v74;
          v72 = a2[1] + 32;
        }

        v75 = v72 - 2;
        a2[1] = v72 - 2;
        v76 = ((v74 >> (v72 - 2)) | v73) & 3 | 0x10;
        *&a1[v71 + 12] = v76;
        v77 = *(a1 + 193);
        if (v77 == 42)
        {
          if (v76 > 17)
          {
            if (v76 == 18)
            {
              LOBYTE(v260) = v260 - 1;
            }
          }

          else if (v76 == 16)
          {
            --BYTE4(v260);
          }

          else
          {
            --v261;
          }

          if (a1[4])
          {
            result = 1025;
            if (v261 < 0 || (v260 & 0x8000000000) != 0 || (v260 & 0x80) != 0)
            {
              return result;
            }
          }
        }

        if (v76 <= 17)
        {
          break;
        }

        if (v76 != 18)
        {
          v85 = 6 - v72;
          if (v85 < 1)
          {
            v87 = 0;
          }

          else
          {
            v86 = v74 << v85;
            if (v75 == -28)
            {
              v87 = 0;
            }

            else
            {
              v87 = v86;
            }

            v74 = CDK_get32((a2 + 2));
            *a2 = v74;
            v75 = a2[1] + 32;
          }

          v90 = v75 - 4;
          a2[1] = v75 - 4;
          v91 = ((v74 >> (v75 - 4)) | v87) & 0xF;
          if (v91 == 15)
          {
            if (12 - v75 < 1)
            {
              v92 = 0;
            }

            else
            {
              if (v75 == -20)
              {
                v92 = 0;
              }

              else
              {
                v92 = v74 << (12 - v75);
              }

              v74 = CDK_get32((a2 + 2));
              *a2 = v74;
              v90 = a2[1] + 32;
            }

            v106 = v90 - 8;
            a2[1] = v90 - 8;
            v107 = ((v74 >> (v90 - 8)) | v92);
            v91 = v107 + 15;
            if (v107 == 255)
            {
              if (24 - v90 < 1)
              {
                v110 = 0;
              }

              else
              {
                v108 = v74 << (24 - v90);
                if (v90 == -8)
                {
                  LOWORD(v108) = 0;
                }

                v255 = v108;
                v109 = CDK_get32((a2 + 2));
                v110 = v255;
                v74 = v109;
                *a2 = v109;
                v106 = a2[1] + 32;
              }

              v90 = v106 - 16;
              a2[1] = v106 - 16;
              v91 += ((v74 >> (v106 - 16)) | v110);
            }

            else
            {
              v90 -= 8;
            }
          }

          v153 = v91 >= 5 && v77 == 42;
          if (v153)
          {
            v154 = 255;
          }

          else
          {
            v154 = v91;
          }

          v253 = v154;
          if (4 - v90 < 1)
          {
            v155 = 0;
          }

          else
          {
            if (v90 == -28)
            {
              v155 = 0;
            }

            else
            {
              v155 = v74 << (4 - v90);
            }

            v74 = CDK_get32((a2 + 2));
            *a2 = v74;
            v90 = a2[1] + 32;
          }

          v156 = v90 - 4;
          a2[1] = v90 - 4;
          v157 = ((v74 >> (v90 - 4)) | v155) & 0xF;
          if (v157 == 15)
          {
            if (12 - v90 < 1)
            {
              v158 = 0;
            }

            else
            {
              if (v90 == -20)
              {
                v158 = 0;
              }

              else
              {
                v158 = v74 << (12 - v90);
              }

              v74 = CDK_get32((a2 + 2));
              *a2 = v74;
              v156 = a2[1] + 32;
            }

            v159 = v156 - 8;
            a2[1] = v156 - 8;
            v160 = ((v74 >> (v156 - 8)) | v158);
            v157 = v160 + 15;
            if (v160 == 255)
            {
              if (24 - v156 < 1)
              {
                v161 = 0;
              }

              else
              {
                if (v156 == -8)
                {
                  v161 = 0;
                }

                else
                {
                  v161 = v74 << (24 - v156);
                }

                v74 = CDK_get32((a2 + 2));
                *a2 = v74;
                v159 = a2[1] + 32;
              }

              v156 = v159 - 16;
              a2[1] = v159 - 16;
              v157 += ((v74 >> (v159 - 16)) | v161);
            }

            else
            {
              v156 -= 8;
            }
          }

          if (a2[12])
          {
            if (v156)
            {
              CDK_put((a2 + 2), v74, v156);
            }
          }

          else
          {
            v162 = a2[6];
            v163 = a2[5] - v156;
            a2[2] += v156;
            v164 = (a2[11] - 1) & (v162 - v156);
            a2[5] = v163;
            a2[6] = v164;
          }

          *a2 = 0;
          v257 = 8 * v157;
          if (8 * v157 > a2[2])
          {
            return 1025;
          }

          v165 = &a1[v71];
          *&a1[v71 + 28] = v157;
          v166 = CDK_get32((a2 + 2));
          *a2 = v166;
          a2[1] = 31;
          if ((v166 & 0x80000000) != 0)
          {
            v169 = (v166 >> 23);
            if (v169 == 255)
            {
              v170 = 7;
            }

            else
            {
              v170 = 23;
            }

            if (v169 == 255)
            {
              v168 = 6;
            }

            else
            {
              v168 = 22;
            }

            a2[1] = v170;
            if (v169 == 255)
            {
              LOWORD(v169) = (v166 >> 7) + 255;
            }

            v167 = v169 + 1;
          }

          else
          {
            v167 = 0;
            v168 = 30;
          }

          v171 = v253;
          *(v165 + 15) = v167;
          a2[1] = v168;
          v165[32] = (v166 >> v168) & 1;
          if (a2[12])
          {
            CDK_put((a2 + 2), v166, v168);
          }

          else
          {
            v172 = a2[6];
            v173 = a2[11] - 1;
            v174 = a2[5] - v168;
            a2[2] += v168;
            a2[5] = v174;
            a2[6] = v173 & (v172 - v168);
          }

          v30 = v262;
          v175 = 0;
          *a2 = 0;
          v176 = a2[2];
          if (v253 > 3)
          {
            if (v253 == 4)
            {
              if (!a2[12])
              {
                a2[2] = v176;
                a2[6] &= a2[11] - 1;
              }

              v254 = v176;
              *a2 = 0;
              v270[0] = v257;
              *&v177 = 0xAAAAAAAAAAAAAAAALL;
              *(&v177 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v268 = v177;
              v269 = v177;
              v267 = v177;
              USACBitstreamReader::USACBitstreamReader(&v267, a2);
              MPEG_D::USAC::DynRangeCompressor::Deserialize(*(a7 + 64), &v267, v270, 1u);
              if (DWORD2(v269))
              {
                USACBitstreamReader::CDKSkipBits(v269, DWORD2(v269) - DWORD2(v268) + 8 * (v267 - DWORD2(v267)));
              }

              v175 = a2[1];
              v171 = 4;
              v176 = v254;
              goto LABEL_309;
            }

            if (v253 != 255)
            {
              goto LABEL_303;
            }
          }

          else if (v253)
          {
            if (v253 == 3)
            {
              v175 = 0;
              a1[v71 + 33] = 1;
              goto LABEL_309;
            }

LABEL_303:
            v175 = 0;
            v171 = 255;
          }

LABEL_309:
          *&a1[v71 + 24] = v171;
          if (a2[12])
          {
            if (v175)
            {
              v178 = v176;
              CDK_put((a2 + 2), *a2, v175);
              v176 = v178;
            }
          }

          else
          {
            v179 = a2[6];
            v180 = a2[5] - v175;
            a2[2] += v175;
            v181 = (a2[11] - 1) & (v179 - v175);
            a2[5] = v180;
            a2[6] = v181;
          }

          *a2 = 0;
          v182 = a2[2];
          v183 = v182 - v176 + v257;
          if (v183 < 0)
          {
            return 1025;
          }

          v184 = a2[5];
          v185 = a2[12];
          v186 = a2[11] - 1;
          if (v185)
          {
            v187 = -1;
          }

          else
          {
            v187 = a2[11] - 1;
          }

          v188 = a2[6] & v187;
          *a2 = 0;
          v189 = v184 + v183;
          if (v185)
          {
            v190 = v183;
          }

          else
          {
            v190 = -v183;
          }

          a2[2] = v182 + v190;
          a2[5] = v189;
          a2[6] = v186 & (v188 + v183);
          goto LABEL_321;
        }

        a1[v71 + 16] = 0;
        ++a1[3];
        if (a1[2])
        {
          v81 = a3[8];
          if (!v81)
          {
            return 513;
          }

          v82 = &a1[v71];
          *(v82 + 17) = 0;
          v82[19] = 0;
          BYTE4(v251) = 0;
          LODWORD(v251) = 1;
          BYTE2(v250) = a1[806];
          BYTE1(v250) = a1[v71 + 20];
          LOBYTE(v250) = 0;
          if (v81(a3[9], a2, *(a1 + 194), *(a1 + 198), *(a1 + 195), v77, 3, v264, v250, v258, v251))
          {
            return 1025;
          }
        }

LABEL_247:
        ++v264;
LABEL_321:
        ++v265;
        v71 += 24;
        if (v263 == v71)
        {
          if (*(a1 + 193) == 42)
          {
            if (a1[4])
            {
              if ((v261 | BYTE4(v260)) | v260)
              {
                return 1025;
              }
            }

            else if (-(v260 + SBYTE4(v260) + 2 * v261) < a1[252])
            {
              return 1025;
            }
          }

          v202 = a2[1];
          if (1 - v202 <= 0)
          {
            v203 = 0;
            v204 = *a2;
          }

          else
          {
            if (v202 == -31)
            {
              v203 = 0;
            }

            else
            {
              v203 = *a2 << (1 - v202);
            }

            v204 = CDK_get32((a2 + 2));
            *a2 = v204;
            v202 = a2[1] + 32;
          }

          v205 = v202 - 1;
          a2[1] = v202 - 1;
          if (((v204 >> (v202 - 1)) | v203))
          {
            v208 = 3 - v202;
            if (v208 < 1)
            {
              v210 = 0;
            }

            else
            {
              v209 = v204 << v208;
              if (v205 == -30)
              {
                v210 = 0;
              }

              else
              {
                v210 = v209;
              }

              v204 = CDK_get32((a2 + 2));
              *a2 = v204;
              v205 = a2[1] + 32;
            }

            v211 = v205 - 2;
            a2[1] = v205 - 2;
            v266 = ((v204 >> (v205 - 2)) | v210) & 3;
            if (v266 == 3)
            {
              if (6 - v205 < 1)
              {
                v212 = 0;
              }

              else
              {
                if (v205 == -26)
                {
                  v212 = 0;
                }

                else
                {
                  v212 = v204 << (6 - v205);
                }

                v204 = CDK_get32((a2 + 2));
                *a2 = v204;
                v211 = a2[1] + 32;
              }

              v213 = v211 - 4;
              a2[1] = v211 - 4;
              v214 = ((v204 >> (v211 - 4)) | v212) & 0xF;
              v266 = v214 + 3;
              if (v214 == 15)
              {
                if (12 - v211 < 1)
                {
                  v215 = 0;
                }

                else
                {
                  if (v211 == -20)
                  {
                    v215 = 0;
                  }

                  else
                  {
                    v215 = v204 << (12 - v211);
                  }

                  v204 = CDK_get32((a2 + 2));
                  *a2 = v204;
                  v213 = a2[1] + 32;
                }

                v211 = v213 - 8;
                a2[1] = v213 - 8;
                v266 += ((v204 >> (v213 - 8)) | v215);
              }

              else
              {
                v211 -= 4;
              }
            }

            v216 = 0;
            do
            {
              if (4 - v211 < 1)
              {
                v217 = 0;
              }

              else
              {
                if (v211 == -28)
                {
                  v217 = 0;
                }

                else
                {
                  v217 = v204 << (4 - v211);
                }

                v204 = CDK_get32((a2 + 2));
                *a2 = v204;
                v211 = a2[1] + 32;
              }

              v218 = v211 - 4;
              a2[1] = v211 - 4;
              v219 = ((v204 >> (v211 - 4)) | v217) & 0xF;
              if (v219 == 15)
              {
                if (12 - v211 < 1)
                {
                  v220 = 0;
                }

                else
                {
                  if (v211 == -20)
                  {
                    v220 = 0;
                  }

                  else
                  {
                    v220 = v204 << (12 - v211);
                  }

                  v204 = CDK_get32((a2 + 2));
                  *a2 = v204;
                  v218 = a2[1] + 32;
                }

                v221 = v218 - 8;
                a2[1] = v218 - 8;
                v222 = ((v204 >> (v218 - 8)) | v220);
                v219 = v222 + 15;
                if (v222 == 255)
                {
                  if (24 - v218 < 1)
                  {
                    v223 = 0;
                  }

                  else
                  {
                    if (v218 == -8)
                    {
                      v223 = 0;
                    }

                    else
                    {
                      v223 = v204 << (24 - v218);
                    }

                    v204 = CDK_get32((a2 + 2));
                    *a2 = v204;
                    v221 = a2[1] + 32;
                  }

                  v218 = v221 - 16;
                  a2[1] = v221 - 16;
                  v219 += ((v204 >> (v221 - 16)) | v223);
                }

                else
                {
                  v218 -= 8;
                }
              }

              if (4 - v218 < 1)
              {
                v224 = 0;
              }

              else
              {
                if (v218 == -28)
                {
                  v224 = 0;
                }

                else
                {
                  v224 = v204 << (4 - v218);
                }

                v204 = CDK_get32((a2 + 2));
                *a2 = v204;
                v218 = a2[1] + 32;
              }

              v225 = v218 - 4;
              a2[1] = v218 - 4;
              v226 = ((v204 >> (v218 - 4)) | v224) & 0xF;
              if (v226 == 15)
              {
                if (12 - v218 < 1)
                {
                  v227 = 0;
                }

                else
                {
                  if (v218 == -20)
                  {
                    v227 = 0;
                  }

                  else
                  {
                    v227 = v204 << (12 - v218);
                  }

                  v204 = CDK_get32((a2 + 2));
                  *a2 = v204;
                  v225 = a2[1] + 32;
                }

                v228 = v225 - 8;
                a2[1] = v225 - 8;
                v229 = ((v204 >> (v225 - 8)) | v227);
                v226 = v229 + 15;
                if (v229 == 255)
                {
                  if (24 - v225 < 1)
                  {
                    v230 = 0;
                  }

                  else
                  {
                    if (v225 == -8)
                    {
                      v230 = 0;
                    }

                    else
                    {
                      v230 = v204 << (24 - v225);
                    }

                    v204 = CDK_get32((a2 + 2));
                    *a2 = v204;
                    v228 = a2[1] + 32;
                  }

                  v225 = v228 - 16;
                  a2[1] = v228 - 16;
                  v226 += ((v204 >> (v228 - 16)) | v230);
                }

                else
                {
                  v225 -= 8;
                }
              }

              if (a2[12])
              {
                if (v225)
                {
                  CDK_put((a2 + 2), v204, v225);
                }
              }

              else
              {
                v231 = a2[6];
                v232 = a2[5] - v225;
                a2[2] += v225;
                v233 = (a2[11] - 1) & (v231 - v225);
                a2[5] = v232;
                a2[6] = v233;
              }

              *a2 = 0;
              v234 = a2[2];
              if (v234 < 8 * v226)
              {
                return 1025;
              }

              v235 = 8 * v226;
              if (v219 == 2)
              {
                v270[0] = 8 * v226;
                *&v239 = 0xAAAAAAAAAAAAAAAALL;
                *(&v239 + 1) = 0xAAAAAAAAAAAAAAAALL;
                v268 = v239;
                v269 = v239;
                v267 = v239;
                USACBitstreamReader::USACBitstreamReader(&v267, a2);
                MPEG_D::USAC::DynRangeCompressor::Deserialize(*(a7 + 64), &v267, v270, 2u);
                if (DWORD2(v269))
                {
                  USACBitstreamReader::CDKSkipBits(v269, DWORD2(v269) - DWORD2(v268) + 8 * (v267 - DWORD2(v267)));
                }

                v237 = a2[1];
              }

              else
              {
                if (!v219 && v226 >= 1)
                {
                  v236 = 0;
                  v237 = 0;
                  while (1)
                  {
                    if (8 - v237 < 1)
                    {
                      v238 = 0;
                    }

                    else
                    {
                      v238 = v237 == -24 ? 0 : v236 << (8 - v237);
                      v236 = CDK_get32((a2 + 2));
                      *a2 = v236;
                      v237 = a2[1] + 32;
                    }

                    v237 -= 8;
                    a2[1] = v237;
                    if (((v236 >> v237) | v238) != 0xA5)
                    {
                      return 1025;
                    }

                    if (!--v226)
                    {
                      goto LABEL_445;
                    }
                  }
                }

                v237 = 0;
              }

LABEL_445:
              if (a2[12])
              {
                v30 = v262;
                if (v237)
                {
                  CDK_put((a2 + 2), *a2, v237);
                }
              }

              else
              {
                v240 = a2[6];
                v241 = a2[5] - v237;
                a2[2] += v237;
                v242 = (a2[11] - 1) & (v240 - v237);
                a2[5] = v241;
                a2[6] = v242;
                v30 = v262;
              }

              *a2 = 0;
              v243 = a2[2];
              v244 = v243 - v234 + v235;
              if (v244 < 0)
              {
                return 1025;
              }

              v204 = 0;
              v211 = 0;
              v245 = a2[5];
              v246 = a2[11] - 1;
              if (a2[12])
              {
                v247 = -1;
              }

              else
              {
                v247 = a2[11] - 1;
              }

              v248 = a2[6] & v247;
              if (a2[12])
              {
                v249 = v243 - v234 + v235;
              }

              else
              {
                v249 = -v244;
              }

              *a2 = 0;
              a2[2] = v243 + v249;
              a2[5] = v245 + v244;
              a2[6] = v246 & (v248 + v244);
              v153 = v216++ == v266;
            }

            while (!v153);
          }

          if (sc_chan_config_tab[4 * v259] != a1[3])
          {
            return 1025;
          }

          CDKsyncCache(a2);
          v206 = a2[2] - v30;
          StoreConfigAsBitstream(a2, v206, a1 + 255);
          if (v206 >= 0)
          {
            LOWORD(v207) = v206;
          }

          else
          {
            v207 = -v206;
          }

          *(a1 + 384) = v207;
          goto LABEL_11;
        }
      }

      v78 = &a1[24 * v265 + 12];
      if (v76 == 16)
      {
        if (v72 == 2)
        {
          v74 = CDK_get32((a2 + 2));
          *a2 = v74;
          v80 = v74 >> 31;
          v79 = 31;
        }

        else
        {
          v79 = v72 - 3;
          v80 = (v74 >> (v72 - 3)) & 1;
        }

        a2[1] = v79;
        if (v80)
        {
          return 1026;
        }

        if (1 - v79 < 1)
        {
          v88 = 0;
        }

        else
        {
          if (v79 == -31)
          {
            v88 = 0;
          }

          else
          {
            v88 = v74 << (1 - v79);
          }

          v74 = CDK_get32((a2 + 2));
          *a2 = v74;
          v79 = a2[1] + 32;
        }

        a2[1] = v79 - 1;
        a1[v71 + 16] = ((v74 >> (v79 - 1)) | v88) & 1;
        v30 = v262;
        if (!a1[2])
        {
          goto LABEL_187;
        }

        if (!a3[8])
        {
          return 513;
        }

        if (v79 == 1)
        {
          v74 = CDK_get32((a2 + 2));
          *a2 = v74;
          v93 = v78 + 5;
          a1[v71 + 17] = (v74 & 0x80000000) != 0;
          v104 = (v74 >> 30) & 1;
          v94 = 30;
        }

        else
        {
          a2[1] = v79 - 2;
          a1[v71 + 17] = (v74 >> (v79 - 2)) & 1;
          v93 = &a1[v71 + 17];
          if (v79 != 2)
          {
            v94 = v79 - 3;
            a2[1] = v94;
            a1[v71 + 18] = (v74 >> v94) & 1;
            if (!v94)
            {
              v95 = CDK_get32((a2 + 2));
              *a2 = v95;
              v96 = v95 >> 31;
              v97 = 31;
              goto LABEL_186;
            }

LABEL_185:
            v97 = v94 - 1;
            v96 = (v74 >> v97) & 1;
LABEL_186:
            a2[1] = v97;
            a1[v71 + 19] = v96;
            BYTE4(v251) = 0;
            LODWORD(v251) = 1;
            BYTE2(v250) = a1[806];
            BYTE1(v250) = a1[v71 + 20];
            LOBYTE(v250) = *v93;
            if ((a3[8])(a3[9], a2, *(a1 + 194), *(a1 + 198), *(a1 + 195), *(a1 + 193), 0, v264, v250, v258, v251))
            {
              return 1025;
            }

LABEL_187:
            v111 = a1[3] + 1;
LABEL_246:
            a1[3] = v111;
            goto LABEL_247;
          }

          v74 = CDK_get32((a2 + 2));
          *a2 = v74;
          v104 = v74 >> 31;
          v94 = 31;
        }

        a1[v71 + 18] = v104;
        goto LABEL_185;
      }

      if (v72 == 2)
      {
        v74 = CDK_get32((a2 + 2));
        *a2 = v74;
        v84 = v74 >> 31;
        v83 = 31;
      }

      else
      {
        v83 = v72 - 3;
        v84 = (v74 >> (v72 - 3)) & 1;
      }

      a2[1] = v83;
      if (v84)
      {
        return 1026;
      }

      if (1 - v83 < 1)
      {
        v89 = 0;
      }

      else
      {
        if (v83 == -31)
        {
          v89 = 0;
        }

        else
        {
          v89 = v74 << (1 - v83);
        }

        v74 = CDK_get32((a2 + 2));
        *a2 = v74;
        v83 = a2[1] + 32;
      }

      a2[1] = v83 - 1;
      a1[v71 + 16] = ((v74 >> (v83 - 1)) | v89) & 1;
      if (!a1[2])
      {
        a1[v71 + 20] = 0;
        v30 = v262;
LABEL_245:
        v111 = a1[3] + 2;
        goto LABEL_246;
      }

      if (!a3[8])
      {
        return 513;
      }

      if (v83 == 1)
      {
        v74 = CDK_get32((a2 + 2));
        *a2 = v74;
        v98 = v78 + 5;
        a1[v71 + 17] = (v74 & 0x80000000) != 0;
        v105 = (v74 >> 30) & 1;
        v99 = 30;
      }

      else
      {
        a2[1] = v83 - 2;
        a1[v71 + 17] = (v74 >> (v83 - 2)) & 1;
        v98 = &a1[v71 + 17];
        if (v83 != 2)
        {
          v99 = v83 - 3;
          a2[1] = v99;
          a1[v71 + 18] = (v74 >> v99) & 1;
          if (!v99)
          {
            v100 = CDK_get32((a2 + 2));
            v74 = v100;
            v101 = 31;
            *a2 = v100;
            a2[1] = 31;
            a1[v71 + 19] = v100 < 0;
            v252 = &a1[v71 + 17];
            if (!a2[12])
            {
              v102 = (v100 >> 22) & 1;
              v103 = 22;
              a2[1] = 22;
              goto LABEL_202;
            }

            goto LABEL_196;
          }

LABEL_190:
          v101 = v99 - 1;
          a2[1] = v99 - 1;
          a1[v71 + 19] = (v74 >> (v99 - 1)) & 1;
          v112 = a2[12];
          v252 = v98;
          if (v101 < 9)
          {
            if (!v112)
            {
              v115 = a2[6];
              v116 = a2[5] - v101;
              a2[2] += v101;
              v117 = (a2[11] - 1) & (v115 - v101);
              a2[5] = v116;
              a2[6] = v117;
              goto LABEL_198;
            }

            if (!v101)
            {
LABEL_198:
              if (v112)
              {
                v118 = 8;
              }

              else
              {
                v118 = -8;
              }

              a2[2] += v118;
              v119 = a2[5];
              v120 = (a2[11] - 1) & (a2[6] + 8);
              *a2 = 0;
              a2[5] = v119 + 8;
              a2[6] = v120;
              v74 = CDK_get32((a2 + 2));
              *a2 = v74;
              v102 = v74 >> 31;
              v103 = 31;
              goto LABEL_202;
            }
          }

          else if (!v112)
          {
            v103 = v101 - 9;
            v102 = (v74 >> (v101 - 9)) & 1;
            a2[1] = v101 - 9;
            if (v101 == 9)
            {
              v74 = CDK_get32((a2 + 2));
              *a2 = v74;
              v113 = v74 >> 31;
              v114 = 31;
              goto LABEL_203;
            }

LABEL_202:
            v114 = v103 - 1;
            v113 = (v74 >> (v103 - 1)) & 1;
LABEL_203:
            a2[1] = v114;
            v121 = (v102 | (4 * v102)) + 6 * v113;
            v122 = a2[12];
            v123 = v114 - v121;
            if (v114 <= v121)
            {
              if (!v122)
              {
                v124 = a2[6];
                v125 = a2[5] - v114;
                a2[2] += v114;
                v126 = (a2[11] - 1) & (v124 - v114);
                a2[5] = v125;
                a2[6] = v126;
                goto LABEL_210;
              }

              if (!v114)
              {
LABEL_210:
                v74 = 0;
                v123 = 0;
                v127 = a2[11];
                v122 = a2[12];
                if (v122)
                {
                  v128 = v121;
                }

                else
                {
                  v128 = -v121;
                }

                a2[2] += v128;
                v129 = (v127 - 1) & (a2[6] + v121);
                a2[5] += v121;
                a2[6] = v129;
                *a2 = 0;
                goto LABEL_214;
              }
            }

            else if (!v122)
            {
              a2[1] = v123;
LABEL_214:
              if (2 - v123 < 1)
              {
                v130 = 0;
              }

              else
              {
                if (v123 == -30)
                {
                  v130 = 0;
                }

                else
                {
                  v130 = v74 << (2 - v123);
                }

                v74 = CDK_get32((a2 + 2));
                *a2 = v74;
                v123 = a2[1] + 32;
                v122 = a2[12];
              }

              v131 = v123 - 2;
              a2[1] = v123 - 2;
              v132 = ((v74 >> (v123 - 2)) | v130) & 3;
              v256 = &a1[v71];
              a1[v71 + 20] = v132;
              v133 = v121 + 12;
              v134 = v131 + v121 + 12;
              if (v134 > 0x1F)
              {
                if (!v122)
                {
                  v138 = a2[6];
                  v139 = a2[5] - v131;
                  a2[2] += v131;
                  v140 = (a2[11] - 1) & (v138 - v131);
                  a2[5] = v139;
                  a2[6] = v140;
LABEL_227:
                  *a2 = 0;
                  if (v122)
                  {
                    v141 = -12 - v121;
                  }

                  else
                  {
                    v141 = v121 + 12;
                  }

                  v142 = a2[6];
                  v143 = a2[5] - v133;
                  a2[2] += v141;
                  v144 = (a2[11] - 1) & (v142 - v133);
                  a2[5] = v143;
                  a2[6] = v144;
LABEL_231:
                  BYTE4(v251) = 0;
                  LODWORD(v251) = 1;
                  BYTE2(v250) = a1[806];
                  BYTE1(v250) = v132;
                  LOBYTE(v250) = *v252;
                  v30 = v262;
                  if ((a3[8])(a3[9], a2, *(a1 + 194), *(a1 + 198), *(a1 + 195), *(a1 + 193), (v132 - 3) < 0xFEu, v264, v250, v258, v251))
                  {
                    return 1025;
                  }

                  v145 = a2[1];
                  if (2 - v145 <= 0)
                  {
                    LOBYTE(v146) = 0;
                    v147 = *a2;
                  }

                  else
                  {
                    if (v145 == -30)
                    {
                      LOBYTE(v146) = 0;
                    }

                    else
                    {
                      v146 = *a2 << (2 - v145);
                    }

                    v147 = CDK_get32((a2 + 2));
                    *a2 = v147;
                    v145 = a2[1] + 32;
                  }

                  v148 = v145 - 2;
                  a2[1] = v148;
                  v256[20] = ((v147 >> v148) | v146) & 3;
                  if ((((v147 >> v148) | v146) & 3) != 0)
                  {
                    v149 = a3[6];
                    if (!v149)
                    {
                      return 513;
                    }

                    v150 = *(a1 + 195);
                    v151 = a1[2];
                    v152 = 4 * v150;
                    if (v151 != 1)
                    {
                      v152 = *(a1 + 195);
                    }

                    if (v151 == 2)
                    {
                      v152 = 8 * v150 / 3;
                    }

                    BYTE4(v250) = a1[806];
                    BYTE3(v250) = 0;
                    if (v149(a3[7], a2, *(a1 + 193), *(a1 + 198), (v152 << (v151 == 3)), 1))
                    {
                      return 1025;
                    }
                  }

                  goto LABEL_245;
                }
              }

              else if (!v122)
              {
                v135 = a2[6];
                v136 = a2[5] - v134;
                a2[2] += v134;
                v137 = (a2[11] - 1) & (v135 - v134);
                a2[5] = v136;
                a2[6] = v137;
                *a2 = 0;
                goto LABEL_231;
              }

              if (v131)
              {
                CDK_put((a2 + 2), v74, v131);
                LOBYTE(v122) = *(a2 + 48);
                v132 = v256[20];
              }

              goto LABEL_227;
            }

            CDK_put((a2 + 2), v74, v114);
            goto LABEL_210;
          }

LABEL_196:
          CDK_put((a2 + 2), v74, v101);
          LOBYTE(v112) = *(a2 + 48);
          goto LABEL_198;
        }

        v74 = CDK_get32((a2 + 2));
        *a2 = v74;
        v105 = v74 >> 31;
        v99 = 31;
      }

      a1[v71 + 18] = v105;
      goto LABEL_190;
    }

    return 1025;
  }

  if (a6 != 30)
  {
    return 1026;
  }

  v20 = a3[6];
  if (!v20)
  {
    return 1026;
  }

  BYTE4(v250) = a1[806];
  LODWORD(v250) = 0;
  if (v20(a3[7], a2, 30, *(a1 + 194), *(a1 + 195), a1[796], 1, 0xFFFFFFFFLL, v250, a1 + 809))
  {
    return 1026;
  }

LABEL_11:
  v21 = *(a1 + 193);
  if (v21 > 0x27)
  {
    goto LABEL_62;
  }

  if (((1 << v21) & 0x520044) == 0)
  {
    if (((1 << v21) & 0x8003800000) != 0)
    {
      goto LABEL_50;
    }

LABEL_62:
    if (v21 != 42)
    {
      return 0;
    }

    v54 = a2[1];
    if (a2[12])
    {
      if (v54)
      {
        CDK_put((a2 + 2), *a2, v54);
      }
    }

    else
    {
      v191 = a2[6];
      v192 = a2[5] - v54;
      a2[2] += v54;
      v193 = (a2[11] - 1) & (v191 - v54);
      a2[5] = v192;
      a2[6] = v193;
    }

    *a2 = 0;
    v194 = a2[2] - v19;
    StoreConfigAsBitstream(a2, v194, a1 + 810);
    result = 0;
    if (v194 >= 0)
    {
      v195 = v194;
    }

    else
    {
      v195 = -v194;
    }

    v196 = 1324;
    goto LABEL_341;
  }

  result = 0;
  *(a1 + 195) = 960;
  if (v21 <= 0x16 && ((1 << v21) & 0x520000) != 0)
  {
LABEL_50:
    v47 = a2[1];
    if (2 - v47 <= 0)
    {
      LOBYTE(v48) = 0;
      v51 = *a2;
    }

    else
    {
      if (v47 == -30)
      {
        LOBYTE(v48) = 0;
      }

      else
      {
        v48 = *a2 << (2 - v47);
      }

      v51 = CDK_get32((a2 + 2));
      *a2 = v51;
      v47 = a2[1] + 32;
    }

    v52 = v47 - 2;
    a2[1] = v52;
    v53 = ((v51 >> v52) | v48) & 3;
    a1[797] = v53;
    if (v53 <= 1)
    {
      v21 = *(a1 + 193);
      goto LABEL_62;
    }

    return 1026;
  }

  return result;
}

uint64_t getAOT(unsigned int *a1)
{
  v2 = a1[1];
  if (5 - v2 <= 0)
  {
    LOBYTE(v3) = 0;
    v4 = *a1;
  }

  else
  {
    if (v2 == -27)
    {
      LOBYTE(v3) = 0;
    }

    else
    {
      v3 = *a1 << (5 - v2);
    }

    v4 = CDK_get32((a1 + 2));
    *a1 = v4;
    v2 = a1[1] + 32;
  }

  v5 = v2 - 5;
  a1[1] = v2 - 5;
  v6 = ((v4 >> (v2 - 5)) | v3) & 0x1F;
  if (v6 == 31)
  {
    if (11 - v2 < 1)
    {
      v7 = 0;
    }

    else
    {
      if (v2 == -21)
      {
        v7 = 0;
      }

      else
      {
        v7 = v4 << (11 - v2);
      }

      v4 = CDK_get32((a1 + 2));
      *a1 = v4;
      v5 = a1[1] + 32;
    }

    a1[1] = v5 - 6;
    return (((v4 >> (v5 - 6)) | v7) & 0x3Fu) + 32;
  }

  return v6;
}

uint64_t getSampleRate(unsigned int *a1, _BYTE *a2, int a3)
{
  v6 = a1[1];
  v7 = a3 - v6;
  if (a3 - v6 <= 0)
  {
    v8 = 0;
    v9 = *a1;
  }

  else
  {
    if (v7 == 32)
    {
      v8 = 0;
    }

    else
    {
      v8 = *a1 << v7;
    }

    v9 = CDK_get32((a1 + 2));
    *a1 = v9;
    v6 = a1[1] + 32;
  }

  v10 = v6 - a3;
  a1[1] = v6 - a3;
  v11 = ((v9 >> (v6 - a3)) | v8) & BitMask[a3];
  if ((v11 ^ (-1 << a3)) != 0xFFFFFFFF)
  {
    result = SamplingRateTable[v11];
LABEL_15:
    *a2 = v11;
    return result;
  }

  if (a1[12])
  {
    if (v6 != a3)
    {
      CDK_put((a1 + 2), v9, v10);
    }
  }

  else
  {
    v13 = a1[6];
    v14 = a1[5] - v10;
    a1[2] += v10;
    v15 = (a1[11] - 1) & (v13 - v10);
    a1[5] = v14;
    a1[6] = v15;
  }

  result = 0;
  *a1 = 0;
  if (a1[2] >= 0x18)
  {
    v16 = CDK_get32((a1 + 2));
    v17 = a1[1] + 8;
    *a1 = v16;
    a1[1] = v17;
    result = (v16 >> v17) & 0xFFFFFF;
    goto LABEL_15;
  }

  return result;
}

void MPEG_D::USAC::DynRangeCompressor::Deserialize(uint64_t *a1, _DWORD *a2, int *a3, unsigned int a4)
{
  v35 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    return;
  }

  v8 = a2[2] - *a2;
  v9 = a2[6];
  if (a4 != 3 && mpddrc::UniDrcHeader::Deserialize((a1 + 2), a2, a4))
  {
    goto LABEL_4;
  }

  if ((a1[91] & 1) == 0)
  {
    *(a1 + 2452) = 1;
    if (gDRCScope)
    {
      v12 = *gDRCScope;
      if (!*gDRCScope)
      {
        goto LABEL_18;
      }
    }

    else
    {
      v12 = MEMORY[0x1E69E9C10];
    }

    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v13 = *(a1 + 612);
      v27 = 136315650;
      v28 = "MPDDRC.cpp";
      v29 = 1024;
      v30 = 2041;
      v31 = 1024;
      v32 = v13;
      _os_log_impl(&dword_19AA99000, v12, OS_LOG_TYPE_INFO, "%25s:%-5d No UniDrcConfig is set before parsing UniDrcGain, mNumFramesMissingDrcConfig = %d\n", &v27, 0x18u);
    }

LABEL_18:
    v14 = *(a1 + 611);
    if (!v14)
    {
      goto LABEL_22;
    }

    v15 = *(a1 + 612);
    if (v15 < v14)
    {
      *(a1 + 612) = ++v15;
    }

    if (v15 < v14)
    {
LABEL_22:
      v10 = 1;
      goto LABEL_31;
    }

    if (gDRCScope)
    {
      v16 = *gDRCScope;
      if (!*gDRCScope)
      {
LABEL_4:
        v10 = 0;
        goto LABEL_31;
      }
    }

    else
    {
      v16 = MEMORY[0x1E69E9C10];
    }

    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v27 = 136315650;
      v28 = "MPDDRC.cpp";
      v29 = 1024;
      v30 = 2046;
      v31 = 1024;
      v32 = v15;
      _os_log_impl(&dword_19AA99000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d ERROR: DRC configuration payload not present in the first %d frames. DRC tool disabled.\n", &v27, 0x18u);
    }

    goto LABEL_4;
  }

  *(a1 + 612) = 0;
  *(a1 + 2452) = 0;
  if (a4 != 3 && a4 || !mpddrc::UniDrcGain::Deserialize(a1 + 424, a2, (a1 + 3)))
  {
    goto LABEL_30;
  }

  if (!gDRCScope)
  {
    v11 = MEMORY[0x1E69E9C10];
LABEL_27:
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v27 = 136315394;
      v28 = "MPDDRC.cpp";
      v29 = 1024;
      v30 = 2059;
      _os_log_impl(&dword_19AA99000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d ERROR: Deserialization of UniDrcGain failed. DRC gain is reset to 0 dB.\n", &v27, 0x12u);
    }

    goto LABEL_29;
  }

  v11 = *gDRCScope;
  if (*gDRCScope)
  {
    goto LABEL_27;
  }

LABEL_29:
  mpddrc::UniDrcGain::Reset((a1 + 212), (a1 + 3));
LABEL_30:
  v10 = 1;
  *(a1 + 2441) = 1;
LABEL_31:
  v17 = v9 - a2[6] + 8 * (*a2 - a2[2] + v8);
  v18 = *a3;
  v19 = *a3 - v17;
  if (*a3 < v17)
  {
    if (gDRCScope)
    {
      v20 = *gDRCScope;
      if (!*gDRCScope)
      {
LABEL_44:
        v19 = 0;
LABEL_45:
        *a3 = v19;
        v22 = *a1;
        *(v22 + 32) = 0;
        *(v22 + 34) = 0;
        *(a1 + 612) = 0;
        *(a1 + 2452) = 0;
        *(a1 + 615) = 0;
        *(a1 + 2472) = 0;
        if (gDRCScope)
        {
          v23 = *gDRCScope;
          if (!*gDRCScope)
          {
            return;
          }
        }

        else
        {
          v23 = MEMORY[0x1E69E9C10];
        }

        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          v27 = 136315394;
          v28 = "USACDRCExtension.cpp";
          v29 = 1024;
          v30 = 222;
          v24 = "%25s:%-5d Deserialization error: DRC tool disabled.\n";
          v25 = v23;
          v26 = OS_LOG_TYPE_ERROR;
LABEL_51:
          _os_log_impl(&dword_19AA99000, v25, v26, v24, &v27, 0x12u);
          return;
        }

        return;
      }
    }

    else
    {
      v20 = MEMORY[0x1E69E9C10];
    }

    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v27 = 136315906;
      v28 = "USACDRCExtension.cpp";
      v29 = 1024;
      v30 = 212;
      v31 = 1024;
      v32 = v18;
      v33 = 1024;
      v34 = v17;
      _os_log_impl(&dword_19AA99000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d Error insufficient bits from UniDrc payload, available = %d, consumed = %d\n", &v27, 0x1Eu);
    }

    goto LABEL_44;
  }

  if ((v10 & 1) == 0)
  {
    goto LABEL_45;
  }

  *a3 = v19;
  if ((*(*a1 + 32) & 1) == 0 && *(a1 + 728) == 1)
  {
    *(*a1 + 32) = 1;
    if (gDRCScope)
    {
      v21 = *gDRCScope;
      if (!*gDRCScope)
      {
        return;
      }
    }

    else
    {
      v21 = MEMORY[0x1E69E9C10];
    }

    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      v27 = 136315394;
      v28 = "USACDRCExtension.cpp";
      v29 = 1024;
      v30 = 228;
      v24 = "%25s:%-5d DRC processing activated.\n";
      v25 = v21;
      v26 = OS_LOG_TYPE_INFO;
      goto LABEL_51;
    }
  }
}

uint64_t StoreConfigAsBitstream(uint64_t result, int a2, _OWORD *a3)
{
  if (a2 >= 0)
  {
    v3 = a2;
  }

  else
  {
    v3 = -a2;
  }

  if (v3 > 0x1000)
  {
    return result;
  }

  v5 = result;
  *&v6 = 0xAAAAAAAAAAAAAAAALL;
  *(&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40[1] = v6;
  v41 = v6;
  v40[0] = v6;
  *a3 = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[31] = 0u;
  result = CDK_InitBitBuffer(v40, a3, 0x200u, v3);
  DWORD2(v41) = 1;
  if (a2 < 0)
  {
    v7 = v5[1];
    v8 = v7 + v3;
    v9 = v5[12];
    if (v7 + v3 > 0x1F)
    {
      if (!v9)
      {
        v13 = v5[6];
        v14 = v5[5] - v7;
        v5[2] += v7;
        v15 = (v5[11] - 1) & (v13 - v7);
        v5[5] = v14;
        v5[6] = v15;
LABEL_13:
        if (v9)
        {
          v16 = -v3;
        }

        else
        {
          v16 = v3;
        }

        v5[2] += v16;
        v17 = v5[5];
        v18 = (v5[11] - 1) & (v5[6] - v3);
        *v5 = 0;
        v5[5] = v17 - v3;
        v5[6] = v18;
        goto LABEL_17;
      }
    }

    else if (!v9)
    {
      v10 = v5[6];
      v11 = v5[5] - v8;
      v5[2] += v8;
      v12 = (v5[11] - 1) & (v10 - v8);
      v5[5] = v11;
      v5[6] = v12;
      *v5 = 0;
      goto LABEL_17;
    }

    if (v7)
    {
      result = CDK_put((v5 + 2), *v5, v7);
      LOBYTE(v9) = *(v5 + 48);
    }

    goto LABEL_13;
  }

LABEL_17:
  if (v3 < 0x20)
  {
    v24 = 0;
    i = v3;
    if (!v3)
    {
      goto LABEL_38;
    }

    goto LABEL_29;
  }

  for (i = v3; i > 0x1F; i -= 32)
  {
    v20 = v5[1];
    if (32 - v20 <= 0)
    {
      v21 = 0;
      v22 = *v5;
      v23 = v20 - 32;
    }

    else
    {
      if (v20)
      {
        v21 = *v5 << (32 - v20);
      }

      else
      {
        v21 = 0;
      }

      v22 = CDK_get32((v5 + 2));
      *v5 = v22;
      v23 = v5[1];
    }

    v5[1] = v23;
    v24 = (v22 >> v23) | v21;
    result = CDK_put(v40, v24, 32);
  }

  if (i)
  {
LABEL_29:
    v25 = v5[1];
    v26 = i - v25;
    if ((i - v25) <= 0)
    {
      v27 = 0;
      result = *v5;
    }

    else
    {
      if (v26 == 32)
      {
        v27 = 0;
      }

      else
      {
        v27 = *v5 << v26;
      }

      result = CDK_get32((v5 + 2));
      *v5 = result;
      v25 = v5[1] + 32;
    }

    v28 = v25 - i;
    v5[1] = v28;
    if (DWORD2(v41) && i)
    {
      result = CDK_put(v40, (v24 << i) | ((result >> v28) | v27) & BitMask[i], i);
    }
  }

LABEL_38:
  if (a2 < 1)
  {
    return result;
  }

  v29 = v5[1];
  v30 = v29 + v3;
  v31 = v5[12];
  if (v29 + v3 <= 0x1F)
  {
    if (!v31)
    {
      v32 = v5[6];
      v33 = v5[5] - v30;
      v5[2] += v30;
      v34 = (v5[11] - 1) & (v32 - v30);
      v5[5] = v33;
      v5[6] = v34;
      *v5 = 0;
      return result;
    }

    goto LABEL_43;
  }

  if (v31)
  {
LABEL_43:
    if (v29)
    {
      result = CDK_put((v5 + 2), *v5, v29);
      LOBYTE(v31) = *(v5 + 48);
    }

    goto LABEL_46;
  }

  v35 = v5[6];
  v36 = v5[5] - v29;
  v5[2] += v29;
  v37 = (v5[11] - 1) & (v35 - v29);
  v5[5] = v36;
  v5[6] = v37;
LABEL_46:
  *v5 = 0;
  if (v31)
  {
    v38 = -v3;
  }

  else
  {
    v38 = v3;
  }

  v5[2] += v38;
  v39 = (v5[11] - 1) & (v5[6] - v3);
  v5[5] -= v3;
  v5[6] = v39;
  return result;
}

uint64_t CLatmDemux_GetValue(unsigned int *a1)
{
  v2 = a1[1];
  if (2 - v2 <= 0)
  {
    LOBYTE(v3) = 0;
    v4 = *a1;
  }

  else
  {
    if (v2 == -30)
    {
      LOBYTE(v3) = 0;
    }

    else
    {
      v3 = *a1 << (2 - v2);
    }

    v4 = CDK_get32((a1 + 2));
    *a1 = v4;
    v2 = a1[1] + 32;
  }

  LODWORD(v5) = 0;
  v6 = v2 - 2;
  a1[1] = v6;
  v7 = (((v4 >> v6) | v3) & 3) + 1;
  do
  {
    if (8 - v6 < 1)
    {
      v8 = 0;
    }

    else
    {
      if (v6 == -24)
      {
        v8 = 0;
      }

      else
      {
        v8 = v4 << (8 - v6);
      }

      v4 = CDK_get32((a1 + 2));
      *a1 = v4;
      v6 = a1[1] + 32;
    }

    v6 -= 8;
    a1[1] = v6;
    v5 = ((v4 >> v6) | v8) | (v5 << 8);
    --v7;
  }

  while (v7);
  return v5;
}

MPEG_D::USAC::DynRangeCompressor::USACDRCExtensionPayload *std::unique_ptr<MPEG_D::USAC::DynRangeCompressor::USACDRCExtensionPayload>::reset[abi:ne200100](MPEG_D::USAC::DynRangeCompressor::USACDRCExtensionPayload **a1, MPEG_D::USAC::DynRangeCompressor::USACDRCExtensionPayload *a2)
{
  result = *a1;
  *a1 = a2;
  if (result)
  {
    MPEG_D::USAC::DynRangeCompressor::USACDRCExtensionPayload::~USACDRCExtensionPayload(result);

    JUMPOUT(0x19EAE53E0);
  }

  return result;
}

void mpddrc::UniDrc::SetRequestTargetLoudness(uint64_t a1, float a2)
{
  v23 = 0xAAAAAAAAAAAAAAAALL;
  *&v4 = 0xAAAAAAAAAAAAAAAALL;
  *(&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *__p = v4;
  v22 = v4;
  *v19 = v4;
  v20 = v4;
  v17[4] = v4;
  *v18 = v4;
  v17[2] = v4;
  v17[3] = v4;
  v17[0] = v4;
  v17[1] = v4;
  v15 = v4;
  v16 = v4;
  v13 = v4;
  v14 = v4;
  v11 = v4;
  v12 = v4;
  v9 = v4;
  *v10 = v4;
  v7 = v4;
  *v8 = v4;
  mpddrc::UniDrcInterface::UniDrcInterface(&v7, a1 + 2056);
  v5.i32[1] = -1040187392;
  *v5.i32 = fmaxf((a2 * -32.0) + 0.5, 0.0);
  v6 = *v5.i32;
  BYTE2(v7) = 1;
  if (*v5.i32 >= 0xFFF)
  {
    v6 = 4095;
  }

  DWORD1(v12) = v6;
  LOBYTE(v12) = 1;
  if (!mpddrc::UniDrcInterface::operator==(&v7, (a1 + 2056), v5))
  {
    *(a1 + 2432) = 1;
    mpddrc::UniDrcInterface::operator=(a1 + 2056, &v7);
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v19[1])
  {
    *&v20 = v19[1];
    operator delete(v19[1]);
  }

  if (v18[0])
  {
    operator delete(v18[0]);
  }

  v24 = v17;
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v24);
  if (v10[0])
  {
    v10[1] = v10[0];
    operator delete(v10[0]);
  }

  if (v8[0])
  {
    v8[1] = v8[0];
    operator delete(v8[0]);
  }
}

void mpddrc::UniDrc::SetRequestFromProfile(uint64_t a1, unsigned int a2)
{
  v35 = 0xAAAAAAAAAAAAAAAALL;
  *&v4 = 0xAAAAAAAAAAAAAAAALL;
  *(&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *__p = v4;
  v34 = v4;
  *v31 = v4;
  v32 = v4;
  v29[4] = v4;
  *v30 = v4;
  v29[2] = v4;
  v29[3] = v4;
  v29[0] = v4;
  v29[1] = v4;
  v27 = v4;
  v28 = v4;
  v25 = v4;
  v26 = v4;
  v23 = v4;
  v24 = v4;
  v21 = v4;
  *v22 = v4;
  v19 = v4;
  *v20 = v4;
  mpddrc::UniDrcInterface::UniDrcInterface(&v19, a1 + 2056);
  BYTE4(v19) = 1;
  if (a2 >= 9)
  {
    std::__throw_out_of_range[abi:ne200100]();
  }

  v36 = 0;
  v37 = 0;
  v38 = 0;
  std::vector<mpddrc::DrcFeatureRequest>::resize(&v36, 1uLL);
  v5 = &mpddrc::dynamicRangeControlProfile + 40 * a2;
  v6 = v36;
  *v36 = 0;
  v6[2] = v6[1];
  v7 = *(v5 + 1);
  std::vector<float>::resize((v6 + 1), v7);
  v8 = v36;
  if (v7)
  {
    v9 = (v5 + 12);
    v10 = v36[1];
    do
    {
      v11 = *v9++;
      *v10++ = v11;
      --v7;
    }

    while (v7);
  }

  *(v8 + 1) = 1;
  v13 = *(&v29[0] + 1);
  v12 = *&v29[0];
  if (*(&v29[0] + 1) != *&v29[0])
  {
    v14 = 0;
    v15 = 1;
    do
    {
      std::vector<mpddrc::DrcFeatureRequest>::push_back[abi:ne200100](&v36, v12 + 56 * v14);
      v14 = v15;
      v13 = *(&v29[0] + 1);
      v12 = *&v29[0];
    }

    while (0x6DB6DB6DB6DB6DB7 * ((*(&v29[0] + 1) - *&v29[0]) >> 3) > v15++);
  }

  while (v13 != v12)
  {
    v17 = *(v13 - 48);
    if (v17)
    {
      *(v13 - 40) = v17;
      operator delete(v17);
    }

    v13 -= 56;
  }

  *(&v29[0] + 1) = v12;
  std::vector<mpddrc::DrcFeatureRequest>::__assign_with_size[abi:ne200100]<mpddrc::DrcFeatureRequest*,mpddrc::DrcFeatureRequest*>(v29, v36, v37, 0x6DB6DB6DB6DB6DB7 * ((v37 - v36) >> 3));
  BYTE8(v28) = 1;
  v39 = &v36;
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v39);
  if (!mpddrc::UniDrcInterface::operator==(&v19, (a1 + 2056), v18))
  {
    *(a1 + 2432) = 1;
    mpddrc::UniDrcInterface::operator=(a1 + 2056, &v19);
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v31[1])
  {
    *&v32 = v31[1];
    operator delete(v31[1]);
  }

  if (v30[0])
  {
    operator delete(v30[0]);
  }

  v36 = v29;
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v36);
  if (v22[0])
  {
    v22[1] = v22[0];
    operator delete(v22[0]);
  }

  if (v20[0])
  {
    v20[1] = v20[0];
    operator delete(v20[0]);
  }
}

void mpddrc::UniDrc::SetRequestCompressBoost(uint64_t a1, float a2, float a3)
{
  v30 = 0xAAAAAAAAAAAAAAAALL;
  *&v6 = 0xAAAAAAAAAAAAAAAALL;
  *(&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *__p = v6;
  v29 = v6;
  *v26 = v6;
  v27 = v6;
  v24 = v6;
  *v25 = v6;
  v22 = v6;
  v23 = v6;
  v20 = v6;
  v21 = v6;
  v18 = v6;
  v19 = v6;
  v16 = v6;
  v17 = v6;
  v14 = v6;
  v15 = v6;
  v12 = v6;
  *v13 = v6;
  v10 = v6;
  *v11 = v6;
  mpddrc::UniDrcInterface::UniDrcInterface(&v10, a1 + 2056);
  BYTE5(v10) = 1;
  v8 = (((1.0 - a2) * 256.0) + 0.5);
  if (v8 >= 255)
  {
    v8 = 255;
  }

  HIDWORD(v21) = v8 & ~(v8 >> 31);
  *v7.i32 = ((1.0 - a3) * 256.0) + 0.5;
  v9 = *v7.i32;
  BYTE8(v21) = 1;
  if (*v7.i32 >= 255)
  {
    v9 = 255;
  }

  DWORD1(v22) = v9 & ~(v9 >> 31);
  LOBYTE(v22) = 1;
  if (!mpddrc::UniDrcInterface::operator==(&v10, (a1 + 2056), v7))
  {
    *(a1 + 2432) = 1;
    mpddrc::UniDrcInterface::operator=(a1 + 2056, &v10);
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v26[1])
  {
    *&v27 = v26[1];
    operator delete(v26[1]);
  }

  if (v25[0])
  {
    operator delete(v25[0]);
  }

  v31 = &v20;
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v31);
  if (v13[0])
  {
    v13[1] = v13[0];
    operator delete(v13[0]);
  }

  if (v11[0])
  {
    v11[1] = v11[0];
    operator delete(v11[0]);
  }
}

uint64_t mpddrc::UniDrc::SetRequestOutputPeakLevelMax(uint64_t a1, float a2)
{
  v24 = 0xAAAAAAAAAAAAAAAALL;
  *&v4 = 0xAAAAAAAAAAAAAAAALL;
  *(&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *__p = v4;
  v23 = v4;
  *v20 = v4;
  v21 = v4;
  v18[4] = v4;
  *v19 = v4;
  v18[2] = v4;
  v18[3] = v4;
  v18[0] = v4;
  v18[1] = v4;
  v16 = v4;
  v17 = v4;
  v14 = v4;
  v15 = v4;
  v12 = v4;
  v13 = v4;
  v10 = v4;
  *v11 = v4;
  v8 = v4;
  *v9 = v4;
  mpddrc::UniDrcInterface::UniDrcInterface(&v8, a1 + 2056);
  BYTE3(v8) = 1;
  v6 = 0xFFFFFFFFLL;
  if (a2 >= -8.0 && a2 <= 24.0)
  {
    LOBYTE(v17) = 1;
    *v5.i32 = roundf(a2 + a2);
    if (a2 < -0.5)
    {
      *v5.i32 = *v5.i32 + 64.0;
    }

    DWORD1(v17) = *v5.i32;
    if (!mpddrc::UniDrcInterface::operator==(&v8, (a1 + 2056), v5))
    {
      *(a1 + 2432) = 1;
      mpddrc::UniDrcInterface::operator=(a1 + 2056, &v8);
    }

    v6 = 0;
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v20[1])
  {
    *&v21 = v20[1];
    operator delete(v20[1]);
  }

  if (v19[0])
  {
    operator delete(v19[0]);
  }

  v25 = v18;
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v25);
  if (v11[0])
  {
    v11[1] = v11[0];
    operator delete(v11[0]);
  }

  if (v9[0])
  {
    v9[1] = v9[0];
    operator delete(v9[0]);
  }

  return v6;
}

void mpddrc::UniDrc::SetRequestLoudnessEqStrength(uint64_t a1, char a2)
{
  v24 = 0xAAAAAAAAAAAAAAAALL;
  *&v4 = 0xAAAAAAAAAAAAAAAALL;
  *(&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *__p = v4;
  v23 = v4;
  *v20 = v4;
  v21 = v4;
  v18 = v4;
  *v19 = v4;
  v16[2] = v4;
  v17 = v4;
  v16[0] = v4;
  v16[1] = v4;
  v14 = v4;
  v15 = v4;
  v12 = v4;
  v13 = v4;
  v10 = v4;
  v11 = v4;
  v8 = v4;
  *v9 = v4;
  v6 = v4;
  *v7 = v4;
  mpddrc::UniDrcInterface::UniDrcInterface(&v6, a1 + 2056);
  BYTE6(v6) = 1;
  LOBYTE(v17) = 1;
  BYTE9(v17) = 1;
  BYTE10(v17) = a2;
  if (!mpddrc::UniDrcInterface::operator==(&v6, (a1 + 2056), v5))
  {
    *(a1 + 2432) = 1;
    mpddrc::UniDrcInterface::operator=(a1 + 2056, &v6);
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v20[1])
  {
    *&v21 = v20[1];
    operator delete(v20[1]);
  }

  if (v19[0])
  {
    operator delete(v19[0]);
  }

  v25 = v16;
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v25);
  if (v9[0])
  {
    v9[1] = v9[0];
    operator delete(v9[0]);
  }

  if (v7[0])
  {
    v7[1] = v7[0];
    operator delete(v7[0]);
  }
}

void mpddrc::UniDrc::SetRequestLoudnessEqSensitivity(uint64_t a1, float a2)
{
  v25 = 0xAAAAAAAAAAAAAAAALL;
  *&v4 = 0xAAAAAAAAAAAAAAAALL;
  *(&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *__p = v4;
  v24 = v4;
  *v21 = v4;
  v22 = v4;
  v19 = v4;
  *v20 = v4;
  v17[2] = v4;
  v18 = v4;
  v17[0] = v4;
  v17[1] = v4;
  v15 = v4;
  v16 = v4;
  v13 = v4;
  v14 = v4;
  v11 = v4;
  v12 = v4;
  v9 = v4;
  *v10 = v4;
  v7 = v4;
  *v8 = v4;
  mpddrc::UniDrcInterface::UniDrcInterface(&v7, a1 + 2056);
  BYTE6(v7) = 1;
  LOBYTE(v18) = 1;
  BYTE11(v18) = 1;
  v6 = vcvtms_u32_f32(a2 + 0.5);
  if (v6 >= BYTE4(v18))
  {
    v6 = BYTE4(v18);
  }

  if (v6 < BYTE5(v18))
  {
    LOBYTE(v6) = BYTE5(v18);
  }

  BYTE12(v18) = v6 - 23;
  *v5.i32 = a2 + 0.5;
  if (!mpddrc::UniDrcInterface::operator==(&v7, (a1 + 2056), v5))
  {
    *(a1 + 2432) = 1;
    mpddrc::UniDrcInterface::operator=(a1 + 2056, &v7);
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v21[1])
  {
    *&v22 = v21[1];
    operator delete(v21[1]);
  }

  if (v20[0])
  {
    operator delete(v20[0]);
  }

  v26 = v17;
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v26);
  if (v10[0])
  {
    v10[1] = v10[0];
    operator delete(v10[0]);
  }

  if (v8[0])
  {
    v8[1] = v8[0];
    operator delete(v8[0]);
  }
}

void mpddrc::UniDrc::SetRequestLoudnessEqPlaybackGain(uint64_t a1, float a2)
{
  v25 = 0xAAAAAAAAAAAAAAAALL;
  *&v4 = 0xAAAAAAAAAAAAAAAALL;
  *(&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *__p = v4;
  v24 = v4;
  *v21 = v4;
  v22 = v4;
  v19 = v4;
  *v20 = v4;
  v17[2] = v4;
  v18 = v4;
  v17[0] = v4;
  v17[1] = v4;
  v15 = v4;
  v16 = v4;
  v13 = v4;
  v14 = v4;
  v11 = v4;
  v12 = v4;
  v9 = v4;
  *v10 = v4;
  v7 = v4;
  *v8 = v4;
  mpddrc::UniDrcInterface::UniDrcInterface(&v7, a1 + 2056);
  BYTE6(v7) = 1;
  LOBYTE(v18) = 1;
  BYTE13(v18) = 1;
  v6 = vcvtms_s32_f32(a2 + 0.5);
  if (v6 >= SBYTE6(v18))
  {
    v6 = SBYTE6(v18);
  }

  if (v6 < SBYTE7(v18))
  {
    LOBYTE(v6) = BYTE7(v18);
  }

  BYTE14(v18) = -v6;
  *v5.i32 = a2 + 0.5;
  if (!mpddrc::UniDrcInterface::operator==(&v7, (a1 + 2056), v5))
  {
    *(a1 + 2432) = 1;
    mpddrc::UniDrcInterface::operator=(a1 + 2056, &v7);
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v21[1])
  {
    *&v22 = v21[1];
    operator delete(v21[1]);
  }

  if (v20[0])
  {
    operator delete(v20[0]);
  }

  v26 = v17;
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v26);
  if (v10[0])
  {
    v10[1] = v10[0];
    operator delete(v10[0]);
  }

  if (v8[0])
  {
    v8[1] = v8[0];
    operator delete(v8[0]);
  }
}

void mpddrc::UniDrc::SetAlbumMode(uint64_t a1, char a2)
{
  v22 = 0xAAAAAAAAAAAAAAAALL;
  *&v4 = 0xAAAAAAAAAAAAAAAALL;
  *(&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *__p = v4;
  v21 = v4;
  *v18 = v4;
  v19 = v4;
  v16[4] = v4;
  *v17 = v4;
  v16[2] = v4;
  v16[3] = v4;
  v16[0] = v4;
  v16[1] = v4;
  v14 = v4;
  v15 = v4;
  v12 = v4;
  v13 = v4;
  v10 = v4;
  v11 = v4;
  v8 = v4;
  *v9 = v4;
  v6 = v4;
  *v7 = v4;
  mpddrc::UniDrcInterface::UniDrcInterface(&v6, a1 + 2056);
  BYTE3(v6) = 1;
  BYTE8(v11) = a2;
  if (!mpddrc::UniDrcInterface::operator==(&v6, (a1 + 2056), v5))
  {
    *(a1 + 2432) = 1;
    mpddrc::UniDrcInterface::operator=(a1 + 2056, &v6);
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v18[1])
  {
    *&v19 = v18[1];
    operator delete(v18[1]);
  }

  if (v17[0])
  {
    operator delete(v17[0]);
  }

  v23 = v16;
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v23);
  if (v9[0])
  {
    v9[1] = v9[0];
    operator delete(v9[0]);
  }

  if (v7[0])
  {
    v7[1] = v7[0];
    operator delete(v7[0]);
  }
}

void sub_19B05CA4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<MP4LoudnessInfo>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

uint64_t mpddrc::LoudnessInfoSet::LoudnessInfoSet(uint64_t a1, uint64_t *a2)
{
  v4 = *a2;
  *(a1 + 8) = *(a2 + 2);
  *a1 = v4;
  *(a1 + 16) = 0;
  *(a1 + 24) = 0;
  *(a1 + 32) = 0;
  std::vector<MP4LoudnessInfo>::__init_with_size[abi:ne200100]<MP4LoudnessInfo*,MP4LoudnessInfo*>(a1 + 16, a2[2], a2[3], 0xCCCCCCCCCCCCCCCDLL * ((a2[3] - a2[2]) >> 3));
  *(a1 + 40) = 0;
  *(a1 + 48) = 0;
  *(a1 + 56) = 0;
  std::vector<MP4LoudnessInfo>::__init_with_size[abi:ne200100]<MP4LoudnessInfo*,MP4LoudnessInfo*>(a1 + 40, a2[5], a2[6], 0xCCCCCCCCCCCCCCCDLL * ((a2[6] - a2[5]) >> 3));
  v5 = *(a2 + 16);
  *(a1 + 72) = 0;
  *(a1 + 64) = v5;
  *(a1 + 80) = 0;
  *(a1 + 88) = 0;
  std::vector<mpddrc::LoudnessInfoV8>::__init_with_size[abi:ne200100]<mpddrc::LoudnessInfoV8*,mpddrc::LoudnessInfoV8*>(a1 + 72, a2[9], a2[10], 0xCCCCCCCCCCCCCCCDLL * ((a2[10] - a2[9]) >> 4));
  *(a1 + 96) = 0;
  *(a1 + 104) = 0;
  *(a1 + 112) = 0;
  std::vector<mpddrc::LoudnessInfoV8>::__init_with_size[abi:ne200100]<mpddrc::LoudnessInfoV8*,mpddrc::LoudnessInfoV8*>(a1 + 96, a2[12], a2[13], 0xCCCCCCCCCCCCCCCDLL * ((a2[13] - a2[12]) >> 4));
  v6 = *(a2 + 120);
  v7 = *(a2 + 128);
  *(a1 + 136) = 0;
  *(a1 + 120) = v6;
  *(a1 + 128) = v7;
  *(a1 + 144) = 0;
  *(a1 + 152) = 0;
  v8 = a2[17];
  v9 = a2[18];
  if (v9 != v8)
  {
    std::vector<mpddrc::LoudnessInfoSource>::__vallocate[abi:ne200100](a1 + 136, 0xCCCCCCCCCCCCCCCDLL * ((v9 - v8) >> 3));
  }

  *(a1 + 160) = 0;
  *(a1 + 168) = 0;
  *(a1 + 176) = 0;
  std::vector<unsigned short>::__init_with_size[abi:ne200100]<unsigned short *,unsigned short *>(a1 + 160, a2[20], a2[21], (a2[21] - a2[20]) >> 1);
  v10 = *(a2 + 46);
  *(a1 + 192) = 0;
  *(a1 + 184) = v10;
  *(a1 + 200) = 0;
  *(a1 + 208) = 0;
  std::vector<float>::__init_with_size[abi:ne200100]<float *,float *>(a1 + 192, a2[24], a2[25], (a2[25] - a2[24]) >> 2);
  *(a1 + 216) = 0;
  *(a1 + 224) = 0;
  *(a1 + 232) = 0;
  std::vector<float>::__init_with_size[abi:ne200100]<float *,float *>(a1 + 216, a2[27], a2[28], (a2[28] - a2[27]) >> 2);
  return a1;
}

void sub_19B05CEB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, void **a11)
{
  *(v12 + 144) = v11;
  std::vector<mpddrc::LoudnessInfoSource>::__destroy_vector::operator()[abi:ne200100](&a11);
  std::vector<mpddrc::LoudnessInfoV8>::__destroy_vector::operator()[abi:ne200100](&a11);
  std::vector<mpddrc::LoudnessInfoV8>::__destroy_vector::operator()[abi:ne200100](&a11);
  std::vector<MP4LoudnessInfo>::__destroy_vector::operator()[abi:ne200100](&a11);
  a11 = a10;
  std::vector<MP4LoudnessInfo>::__destroy_vector::operator()[abi:ne200100](&a11);
  _Unwind_Resume(a1);
}

uint64_t mpddrc::UniDrc::~UniDrc(uint64_t a1)
{
  *a1 = &unk_1F0E21B70;
  v2 = a1 + 4616;
  v3 = -4288;
  do
  {
    v2 = mpddrc::UniDrcProcessor::~UniDrcProcessor(v2) - 2144;
    v3 += 2144;
  }

  while (v3);
  v4 = *(a1 + 2384);
  if (v4)
  {
    *(a1 + 2392) = v4;
    operator delete(v4);
  }

  v5 = *(a1 + 2344);
  if (v5)
  {
    *(a1 + 2352) = v5;
    operator delete(v5);
  }

  v6 = *(a1 + 2320);
  if (v6)
  {
    *(a1 + 2328) = v6;
    operator delete(v6);
  }

  v7 = *(a1 + 2296);
  if (v7)
  {
    operator delete(v7);
  }

  v16 = (a1 + 2216);
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v16);
  v8 = *(a1 + 2104);
  if (v8)
  {
    *(a1 + 2112) = v8;
    operator delete(v8);
  }

  v9 = *(a1 + 2072);
  if (v9)
  {
    *(a1 + 2080) = v9;
    operator delete(v9);
  }

  v10 = *(a1 + 2016);
  if (v10)
  {
    *(a1 + 2024) = v10;
    operator delete(v10);
  }

  v11 = *(a1 + 1992);
  if (v11)
  {
    *(a1 + 2000) = v11;
    operator delete(v11);
  }

  v12 = *(a1 + 1968);
  if (v12)
  {
    operator delete(v12);
  }

  v16 = (a1 + 1888);
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v16);
  v13 = *(a1 + 1776);
  if (v13)
  {
    *(a1 + 1784) = v13;
    operator delete(v13);
  }

  v14 = *(a1 + 1744);
  if (v14)
  {
    *(a1 + 1752) = v14;
    operator delete(v14);
  }

  return mpddrc::UniDrcBase::~UniDrcBase(a1);
}

uint64_t mpddrc::UniDrcProcessor::~UniDrcProcessor(uint64_t a1)
{
  v2 = *(a1 + 2120);
  if (v2)
  {
    v3 = *(a1 + 2128);
    v4 = *(a1 + 2120);
    if (v3 != v2)
    {
      v5 = *(a1 + 2128);
      do
      {
        v7 = *(v5 - 24);
        v5 -= 24;
        v6 = v7;
        if (v7)
        {
          *(v3 - 16) = v6;
          operator delete(v6);
        }

        v3 = v5;
      }

      while (v5 != v2);
      v4 = *(a1 + 2120);
    }

    *(a1 + 2128) = v2;
    operator delete(v4);
  }

  v8 = *(a1 + 2096);
  if (v8)
  {
    *(a1 + 2104) = v8;
    operator delete(v8);
  }

  v9 = *(a1 + 2072);
  if (v9)
  {
    *(a1 + 2080) = v9;
    operator delete(v9);
  }

  v10 = *(a1 + 2048);
  if (v10)
  {
    *(a1 + 2056) = v10;
    operator delete(v10);
  }

  v11 = *(a1 + 1992);
  if (v11)
  {
    *(a1 + 2000) = v11;
    operator delete(v11);
  }

  v41 = (a1 + 1960);
  std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v41);
  v41 = (a1 + 1936);
  std::vector<mpddrc::QmfComplexBuffer>::__destroy_vector::operator()[abi:ne200100](&v41);
  v41 = (a1 + 1912);
  std::vector<mpddrc::QmfComplexBuffer>::__destroy_vector::operator()[abi:ne200100](&v41);
  v41 = (a1 + 1888);
  std::vector<mpddrc::QmfComplexBufferPtr>::__destroy_vector::operator()[abi:ne200100](&v41);
  v41 = (a1 + 1864);
  std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v41);
  v41 = (a1 + 1840);
  std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v41);
  v41 = (a1 + 1816);
  std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v41);
  v41 = (a1 + 1792);
  std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v41);
  if (*(a1 + 1768))
  {
    std::vector<mpddrc::EqCoefficients::FilterBlock>::clear[abi:ne200100]((a1 + 1768));
    operator delete(*(a1 + 1768));
  }

  v12 = *(a1 + 1744);
  if (v12)
  {
    *(a1 + 1752) = v12;
    operator delete(v12);
  }

  v13 = *(a1 + 1720);
  if (v13)
  {
    *(a1 + 1728) = v13;
    operator delete(v13);
  }

  v14 = *(a1 + 1696);
  if (v14)
  {
    v15 = *(a1 + 1704);
    v16 = *(a1 + 1696);
    if (v15 != v14)
    {
      do
      {
        v41 = (v15 - 32);
        std::vector<mpddrc::GainSetParams>::__destroy_vector::operator()[abi:ne200100](&v41);
        v41 = (v15 - 56);
        std::vector<mpddrc::ShapeFilterBlock>::__destroy_vector::operator()[abi:ne200100](&v41);
        v41 = (v15 - 80);
        std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v41);
        v41 = (v15 - 104);
        std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v41);
        v15 -= 128;
      }

      while (v15 != v14);
      v16 = *(a1 + 1696);
    }

    *(a1 + 1704) = v14;
    operator delete(v16);
  }

  v41 = (a1 + 1616);
  std::vector<mpddrc::ShapeFilterBlock>::__destroy_vector::operator()[abi:ne200100](&v41);
  v17 = *(a1 + 1592);
  if (v17)
  {
    v18 = *(a1 + 1600);
    v19 = *(a1 + 1592);
    if (v18 != v17)
    {
      v20 = *(a1 + 1600);
      do
      {
        v22 = *(v20 - 24);
        v20 -= 24;
        v21 = v22;
        if (v22)
        {
          *(v18 - 16) = v21;
          operator delete(v21);
        }

        v18 = v20;
      }

      while (v20 != v17);
      v19 = *(a1 + 1592);
    }

    *(a1 + 1600) = v17;
    operator delete(v19);
  }

  v23 = *(a1 + 1560);
  if (v23)
  {
    v24 = *(a1 + 1568);
    v25 = *(a1 + 1560);
    if (v24 != v23)
    {
      do
      {
        LinkwitzRileyFilterbank::~LinkwitzRileyFilterbank((v24 - 56));
      }

      while (v24 != v23);
      v25 = *(a1 + 1560);
    }

    *(a1 + 1568) = v23;
    operator delete(v25);
  }

  for (i = 0; i != -600; i -= 120)
  {
    v27 = a1 + i;
    v41 = (a1 + i + 1528);
    std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne200100](&v41);
    v41 = (a1 + i + 1504);
    std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne200100](&v41);
    v28 = *(a1 + i + 1480);
    if (v28)
    {
      *(v27 + 1488) = v28;
      operator delete(v28);
    }

    v41 = (v27 + 1456);
    std::vector<mpddrc::GainSetParams>::__destroy_vector::operator()[abi:ne200100](&v41);
  }

  v29 = *(a1 + 928);
  if (v29)
  {
    v30 = *(a1 + 936);
    v31 = *(a1 + 928);
    if (v30 != v29)
    {
      do
      {
        v32 = *(v30 - 24);
        if (v32)
        {
          *(v30 - 16) = v32;
          operator delete(v32);
        }

        v33 = *(v30 - 96);
        if (v33)
        {
          *(v30 - 88) = v33;
          operator delete(v33);
        }

        v34 = *(v30 - 120);
        if (v34)
        {
          *(v30 - 112) = v34;
          operator delete(v34);
        }

        v35 = *(v30 - 168);
        if (v35)
        {
          *(v30 - 160) = v35;
          operator delete(v35);
        }

        mpddrc::ParametricDrcInstance::DrcTypeFeedForward::~DrcTypeFeedForward((v30 - 536));
        v36 = *(v30 - 560);
        if (v36)
        {
          *(v30 - 552) = v36;
          operator delete(v36);
        }

        v30 -= 568;
      }

      while (v30 != v29);
      v31 = *(a1 + 928);
    }

    *(a1 + 936) = v29;
    operator delete(v31);
  }

  v37 = *(a1 + 136);
  if (v37)
  {
    *(a1 + 144) = v37;
    operator delete(v37);
  }

  v38 = *(a1 + 112);
  if (v38)
  {
    *(a1 + 120) = v38;
    operator delete(v38);
  }

  v39 = *(a1 + 88);
  if (v39)
  {
    operator delete(v39);
  }

  return a1;
}

uint64_t mpddrc::UniDrcBase::~UniDrcBase(uint64_t a1)
{
  *a1 = &unk_1F0E21B90;
  v2 = (a1 + 16);
  v4 = (a1 + 1696);
  std::vector<mpddrc::EqInstructions::TdFilterCascade>::__destroy_vector::operator()[abi:ne200100](&v4);
  mpddrc::LoudnessInfoSet::~LoudnessInfoSet((a1 + 1432));
  mpddrc::UniDrcConfig::~UniDrcConfig((a1 + 728));
  mpddrc::UniDrcConfig::~UniDrcConfig(v2);
  return a1;
}

void mpddrc::UniDrcBase::~UniDrcBase(uint64_t a1)
{
  mpddrc::UniDrcBase::~UniDrcBase(a1);

  JUMPOUT(0x19EAE53E0);
}

void mpddrc::UniDrc::~UniDrc(uint64_t a1)
{
  *a1 = &unk_1F0E21B70;
  v2 = a1 + 4616;
  v3 = -4288;
  do
  {
    v2 = mpddrc::UniDrcProcessor::~UniDrcProcessor(v2) - 2144;
    v3 += 2144;
  }

  while (v3);
  v4 = *(a1 + 2384);
  if (v4)
  {
    *(a1 + 2392) = v4;
    operator delete(v4);
  }

  v5 = *(a1 + 2344);
  if (v5)
  {
    *(a1 + 2352) = v5;
    operator delete(v5);
  }

  v6 = *(a1 + 2320);
  if (v6)
  {
    *(a1 + 2328) = v6;
    operator delete(v6);
  }

  v7 = *(a1 + 2296);
  if (v7)
  {
    operator delete(v7);
  }

  v15 = (a1 + 2216);
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v15);
  v8 = *(a1 + 2104);
  if (v8)
  {
    *(a1 + 2112) = v8;
    operator delete(v8);
  }

  v9 = *(a1 + 2072);
  if (v9)
  {
    *(a1 + 2080) = v9;
    operator delete(v9);
  }

  v10 = *(a1 + 2016);
  if (v10)
  {
    *(a1 + 2024) = v10;
    operator delete(v10);
  }

  v11 = *(a1 + 1992);
  if (v11)
  {
    *(a1 + 2000) = v11;
    operator delete(v11);
  }

  v12 = *(a1 + 1968);
  if (v12)
  {
    operator delete(v12);
  }

  v15 = (a1 + 1888);
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v15);
  v13 = *(a1 + 1776);
  if (v13)
  {
    *(a1 + 1784) = v13;
    operator delete(v13);
  }

  v14 = *(a1 + 1744);
  if (v14)
  {
    *(a1 + 1752) = v14;
    operator delete(v14);
  }

  mpddrc::UniDrcBase::~UniDrcBase(a1);

  JUMPOUT(0x19EAE53E0);
}

void sub_19B05D680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<mpddrc::LoudnessInfoV8>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

uint64_t mpddrc::UniDrcInterface::UniDrcInterface(uint64_t a1, uint64_t a2)
{
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *(a1 + 24) = 0;
  *(a1 + 32) = 0;
  *(a1 + 40) = 0;
  *(a1 + 48) = 0u;
  *(a1 + 64) = 0u;
  *(a1 + 80) = 0;
  *(a1 + 84) = 0;
  *(a1 + 87) = 0;
  *(a1 + 92) = 63;
  *(a1 + 96) = 0;
  *(a1 + 100) = 0;
  *(a1 + 104) = 0;
  *(a1 + 108) = 0;
  *(a1 + 112) = 0;
  *(a1 + 116) = 0;
  *(a1 + 120) = 0;
  *(a1 + 124) = 0;
  *(a1 + 128) = 0;
  *(a1 + 132) = 0;
  *(a1 + 136) = 0;
  *(a1 + 140) = 0;
  *(a1 + 144) = 0;
  *(a1 + 148) = 0;
  *(a1 + 152) = 0;
  *(a1 + 188) = 0;
  *(a1 + 192) = 0;
  *(a1 + 196) = 0;
  *(a1 + 200) = 0;
  *(a1 + 204) = 0;
  *(a1 + 208) = 0;
  *(a1 + 160) = 0;
  *(a1 + 184) = 0;
  *(a1 + 168) = 0;
  *(a1 + 176) = 0;
  *(a1 + 212) = 2164266902;
  *(a1 + 219) = 0;
  *(a1 + 224) = 0;
  *(a1 + 232) = 0;
  *(a1 + 314) = 0;
  *(a1 + 316) = 0;
  *(a1 + 256) = 0u;
  *(a1 + 272) = 0u;
  *(a1 + 288) = 0u;
  *(a1 + 240) = 0u;
  *(a1 + 297) = 0u;
  *(a1 + 320) = 0;
  *(a1 + 322) = 0;
  mpddrc::UniDrcInterface::operator=(a1, a2);
  return a1;
}

void sub_19B05D7AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  v13 = v11;
  mpddrc::UniDrcInterfaceExtension::~UniDrcInterfaceExtension((v10 + 26));
  a10 = v13;
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&a10);
  v15 = v10[6];
  if (v15)
  {
    v10[7] = v15;
    operator delete(v15);
  }

  v16 = *v12;
  if (*v12)
  {
    v10[3] = v16;
    operator delete(v16);
  }

  _Unwind_Resume(a1);
}

void sub_19B05D994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<mpddrc::DrcFeatureRequest>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

void std::__throw_out_of_range[abi:ne200100]()
{
  exception = __cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne200100](exception);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne200100](std::logic_error *a1)
{
  result = std::logic_error::logic_error(a1, "array::at");
  result->__vftable = (MEMORY[0x1E69E55B8] + 16);
  return result;
}

void MPEG_D::USAC::DynRangeCompressor::USACDRCExtensionPayload::~USACDRCExtensionPayload(MPEG_D::USAC::DynRangeCompressor::USACDRCExtensionPayload *this)
{
  v2 = this + 8;
  *(this + 1) = &unk_1F0E21B70;
  v3 = this + 4624;
  v4 = -4288;
  do
  {
    v3 = (mpddrc::UniDrcProcessor::~UniDrcProcessor(v3) - 2144);
    v4 += 2144;
  }

  while (v4);
  v5 = *(this + 299);
  if (v5)
  {
    *(this + 300) = v5;
    operator delete(v5);
  }

  v6 = *(this + 294);
  if (v6)
  {
    *(this + 295) = v6;
    operator delete(v6);
  }

  v7 = *(this + 291);
  if (v7)
  {
    *(this + 292) = v7;
    operator delete(v7);
  }

  v8 = *(this + 288);
  if (v8)
  {
    operator delete(v8);
  }

  v16 = (this + 2224);
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v16);
  v9 = *(this + 264);
  if (v9)
  {
    *(this + 265) = v9;
    operator delete(v9);
  }

  v10 = *(this + 260);
  if (v10)
  {
    *(this + 261) = v10;
    operator delete(v10);
  }

  v11 = *(this + 253);
  if (v11)
  {
    *(this + 254) = v11;
    operator delete(v11);
  }

  v12 = *(this + 250);
  if (v12)
  {
    *(this + 251) = v12;
    operator delete(v12);
  }

  v13 = *(this + 247);
  if (v13)
  {
    operator delete(v13);
  }

  v16 = (this + 1896);
  std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v16);
  v14 = *(this + 223);
  if (v14)
  {
    *(this + 224) = v14;
    operator delete(v14);
  }

  v15 = *(this + 219);
  if (v15)
  {
    *(this + 220) = v15;
    operator delete(v15);
  }

  mpddrc::UniDrcBase::~UniDrcBase(v2);
}

uint64_t aacDecoder_Open()
{
  if ((__CDKinit_magic & 1) == 0)
  {
    __CDKinit_magic = 1;
  }

  v0 = malloc_type_calloc(1uLL, 0xB78uLL, 0x5142B0E1uLL);
  v18 = v0;
  if (!v0)
  {
    return 0;
  }

  v1 = v0;
  *v0 = 0;
  v2 = malloc_type_calloc(0x2000uLL, 1uLL, 0x5142B0E1uLL);
  *(v1 + 20) = v2;
  if (!v2)
  {
    goto LABEL_18;
  }

  v1[32] = 0;
  *(v1 + 15) = 0;
  *(v1 + 17) = v2;
  *(v1 + 18) = 0x1000000002000;
  *(v1 + 26) = 0u;
  v1[38] = 0;
  v1[727] = 0;
  v18 = v1;
  v3 = malloc_type_calloc(1uLL, 0x940uLL, 0x5142B0E1uLL);
  v4 = v3;
  if (!v3)
  {
LABEL_17:
    CAacDecoder_Close(v4);
LABEL_18:
    transportDec_Close(&v18);
    return 0;
  }

  v5 = 0;
  *(v3 + 53) = 0;
  *(v3 + 54) = 0;
  *(v3 + 55) = 0;
  *(v3 + 85) = 0u;
  *(v3 + 86) = 0u;
  *(v3 + 87) = 0u;
  *(v3 + 237) = 0;
  *(v3 + 1688) = 0u;
  *(v3 + 1704) = 0u;
  *(v3 + 1720) = 0u;
  *(v3 + 1736) = 0u;
  *(v3 + 1752) = 0u;
  *(v3 + 1768) = 0u;
  *(v3 + 1784) = 0u;
  *(v3 + 1800) = 0u;
  *(v3 + 1816) = 0u;
  *(v3 + 1832) = 0u;
  *(v3 + 1848) = 0u;
  *(v3 + 1864) = 0u;
  *(v3 + 1880) = 0u;
  *(v3 + 209) = 0;
  *(v3 + 1640) = 0u;
  *(v3 + 1656) = 0u;
  *(v3 + 1608) = 0u;
  *(v3 + 1624) = 0u;
  *(v3 + 1576) = 0u;
  *(v3 + 1592) = 0u;
  *(v3 + 1544) = 0u;
  *(v3 + 1560) = 0u;
  *(v3 + 1512) = 0u;
  *(v3 + 1528) = 0u;
  *(v3 + 1480) = 0u;
  *(v3 + 1496) = 0u;
  *(v3 + 1448) = 0u;
  *(v3 + 1464) = 0u;
  *(v3 + 1416) = 0u;
  *(v3 + 1432) = 0u;
  v3[2104] = 0;
  *(v3 + 1053) = 0;
  *(v3 + 132) = 0u;
  *(v3 + 133) = 0u;
  *(v3 + 268) = 0;
  v3[2152] = 1;
  *(v3 + 2156) = 0x3F800000C1F80000;
  *(v3 + 2168) = 0u;
  *(v3 + 2184) = 0u;
  *(v3 + 2200) = 0u;
  *(v3 + 2216) = 0u;
  *(v3 + 2232) = 0u;
  *(v3 + 2248) = 0u;
  *(v3 + 2264) = 0u;
  *(v3 + 2280) = 0u;
  *(v3 + 2296) = 0u;
  *(v3 + 2312) = 0u;
  *(v3 + 2328) = 0u;
  *(v3 + 2344) = 0u;
  *(v3 + 38) = v3 + 248;
  *(v3 + 39) = v3 + 256;
  v3[826] = 1;
  *(v3 + 348) = 0xFFFFFFFFLL;
  v3[364] = -1;
  v6 = v3 + 864;
  v3[864] = 0;
  *(v3 + 231) = 0;
  v3[866] = 0;
  v3[868] = 0;
  v3[929] = 0;
  *(v3 + 466) = 0;
  v3[935] = 0;
  v3[937] = 0;
  v3[939] = 0;
  v3[941] = 0;
  *(v3 + 121) = 0u;
  *(v3 + 122) = 0u;
  *(v3 + 123) = 0u;
  *(v3 + 20) = xmmword_19B0B3430;
  *(v3 + 42) = 0;
  *(v3 + 90) = 0;
  *(v3 + 75) = 0;
  *(v3 + 36) = 0;
  *(v3 + 89) = 0;
  *(v3 + 97) = -1;
  *(v3 + 281) = 0;
  *(v3 + 724) = xmmword_19B0B3440;
  *(v3 + 185) = 0x100000;
  *(v3 + 117) = 1060439283;
  v7 = 0.70711;
  *(v3 + 149) = 1060439283;
  do
  {
    v7 = v7 * 0.70711;
    v8 = &v3[v5];
    v8[118] = v7;
    v8[150] = v7;
    v5 += 4;
  }

  while (v5 != 124);
  *(v3 + 186) = -1;
  v9 = malloc_type_calloc(1uLL, 0x2010uLL, 0x5142B0E1uLL);
  if (!v9)
  {
    *(v4 + 448) = 0;
    goto LABEL_17;
  }

  v10 = v9 + (-(v9 + 8) & 7) + 8;
  *(v10 - 8) = v9;
  *(v4 + 448) = v10;
  v11 = malloc_type_calloc(1uLL, 0x10010uLL, 0x5142B0E1uLL);
  if (!v11)
  {
    *(v4 + 456) = 0;
    *(v4 + 464) = 65552;
    goto LABEL_17;
  }

  v12 = v11 + (-(v11 + 8) & 7) + 8;
  *(v12 - 8) = v11;
  *(v4 + 456) = v12;
  *(v4 + 464) = 65552;
  *(v4 + 24) = v1;
  *(v4 + 12) = 1;
  *(v4 + 264) = &mapInfoTabDflt;
  *(v4 + 272) = 15;
  *(v1 + 1) = aacDecoder_ConfigCallback;
  *(v1 + 2) = v4;
  *(v1 + 3) = aacDecoder_FreeMemCallback;
  *(v1 + 4) = v4;
  *(v1 + 5) = aacDecoder_CtrlCFGChangeCallback;
  *(v1 + 6) = v4;
  bzero((v4 + 864), 0x410uLL);
  v13 = malloc_type_calloc(1uLL, 0x220uLL, 0x5142B0E1uLL);
  if (!v13)
  {
    goto LABEL_14;
  }

  v13[62] = v6;
  *(v13 + 532) = 0;
  *(v13 + 4) = 0;
  *(v13 + 64) = 0;
  *(v4 + 832) = v13;
  *(v4 + 1908) = -1;
  v14 = *(v4 + 24);
  if (v14)
  {
    *(v14 + 72) = aacDecoder_SbrCallback;
    *(v14 + 80) = v13;
  }

  if (mpegSurroundDecoder_Open((v4 + 1912), v4 + 864))
  {
    goto LABEL_14;
  }

  *(v4 + 1920) = 0;
  *(v1 + 7) = aacDecoder_SscCallback;
  *(v1 + 8) = v4;
  v16 = *(v4 + 724);
  v17 = *(v4 + 832);
  if (v16 >= 2 && (*(v4 + 68) & 0x4300) != 0)
  {
    goto LABEL_23;
  }

  if ((v16 + 1) > 2)
  {
    if ((v16 & 0xFFFFFFFE) == 2)
    {
LABEL_14:
      aacDecoder_Close(v4);
      return 0;
    }

LABEL_23:
    if (v17)
    {
      *(v17 + 532) = 0;
    }

    goto LABEL_14;
  }

  if (v17)
  {
    *(v17 + 532) = 0;
  }

  *(v4 + 844) = 0;
  return v4;
}

void transportDec_Close(void **a1)
{
  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      free(v2[20]);
      v2[20] = 0;
      free(*a1);
      *a1 = 0;
    }
  }
}

uint64_t mpegSurroundDecoder_Open(void **a1, uint64_t a2)
{
  v3 = *a1;
  if (*a1)
  {
    v4 = v3[21];
    if (v4)
    {
LABEL_3:
      *(v4 + 1216) = *v3;
      v3[21] = v4;
      *(v3 + 864) = 0x1000000;
      *(v3 + 3460) = xmmword_19B0B3490;
      *(v3 + 334) = 1;
      *(v3 + 166) = 0;
      *(v3 + 869) = 0;
      v5 = v3 + 4 * *(v3 + 3453);
      *(v5 + 870) |= 1u;
      *(v5 + 872) = 0;
      *(v3 + 871) = 1;
      *a1 = v3;
      *(v3 + 3492) = mpegSurroundDecoder_Create(MpegSurroundDecoder **,int,CDK_QMF_DOMAIN *)::decConfig;
      SpatialDecInitParserContext(v3[21]);
      return 0;
    }

    v19 = malloc_type_calloc(1uLL, 0x558uLL, 0x5142B0E1uLL);
    v4 = v19;
    if (v19)
    {
      *(v19 + 20) = xmmword_19B0B3450;
      *(v19 + 36) = xmmword_19B0B3460;
      *(v19 + 52) = xmmword_19B0B3470;
      *(v19 + 68) = 0x200000001;
      v20 = malloc_type_calloc(0x1DuLL, 4uLL, 0x5142B0E1uLL);
      *(v4 + 232) = v20;
      if (v20)
      {
        v21 = malloc_type_calloc(1uLL, 4uLL, 0x5142B0E1uLL);
        *(v4 + 392) = v21;
        if (v21)
        {
          v22 = malloc_type_calloc(9uLL, 4uLL, 0x5142B0E1uLL);
          *(v4 + 408) = v22;
          if (v22)
          {
            v23 = cdkCallocMatrix2D(9uLL, 28, 1u);
            *(v4 + 416) = v23;
            if (v23)
            {
              v24 = cdkCallocMatrix3D(1uLL, 9u, 1u);
              *(v4 + 488) = v24;
              if (v24)
              {
                v25 = cdkCallocMatrix3D(1uLL, 9u, 1u);
                *(v4 + 496) = v25;
                if (v25)
                {
                  v26 = cdkCallocMatrix3D(1uLL, 9u, 1u);
                  *(v4 + 520) = v26;
                  if (v26)
                  {
                    v27 = cdkCallocMatrix2D(1uLL, 28, 1u);
                    *(v4 + 424) = v27;
                    if (v27)
                    {
                      v28 = cdkCallocMatrix2D(1uLL, 28, 1u);
                      *(v4 + 432) = v28;
                      if (v28)
                      {
                        v29 = cdkCallocMatrix3D(1uLL, 9u, 1u);
                        *(v4 + 472) = v29;
                        if (v29)
                        {
                          v30 = cdkCallocMatrix2D(1uLL, 28, 1u);
                          *(v4 + 440) = v30;
                          if (v30)
                          {
                            v31 = cdkCallocMatrix2D(1uLL, 28, 1u);
                            *(v4 + 456) = v31;
                            if (v31)
                            {
                              v32 = cdkCallocMatrix2D(1uLL, 28, 1u);
                              *(v4 + 464) = v32;
                              if (v32)
                              {
                                v33 = cdkCallocMatrix3D(1uLL, 9u, 1u);
                                *(v4 + 448) = v33;
                                if (v33)
                                {
                                  v34 = cdkCallocMatrix2D(1uLL, 28, 1u);
                                  *(v4 + 480) = v34;
                                  if (v34)
                                  {
                                    v35 = cdkCallocMatrix3D_int();
                                    *(v4 + 984) = v35;
                                    if (v35)
                                    {
                                      v36 = cdkCallocMatrix3D(2uLL, 2u, 4u);
                                      *(v4 + 992) = v36;
                                      if (v36)
                                      {
                                        v37 = cdkCallocMatrix3D_int();
                                        *(v4 + 1000) = v37;
                                        if (v37)
                                        {
                                          v38 = cdkCallocMatrix3D(2uLL, 2u, 4u);
                                          *(v4 + 1008) = v38;
                                          if (v38)
                                          {
                                            v39 = cdkCallocMatrix2D_int_aligned();
                                            *(v4 + 1040) = v39;
                                            if (v39)
                                            {
                                              v40 = cdkCallocMatrix2D_int_aligned();
                                              *(v4 + 1048) = v40;
                                              if (v40)
                                              {
                                                v41 = cdkCallocMatrix2D_int(1uLL, 71);
                                                *(v4 + 1056) = v41;
                                                if (v41)
                                                {
                                                  v42 = cdkCallocMatrix2D_int(1uLL, 71);
                                                  *(v4 + 1064) = v42;
                                                  if (v42)
                                                  {
                                                    v43 = malloc_type_calloc(1uLL, 8uLL, 0x5142B0E1uLL);
                                                    *(v4 + 1096) = v43;
                                                    if (v43)
                                                    {
                                                      v44 = malloc_type_calloc(1uLL, 8uLL, 0x5142B0E1uLL);
                                                      *(v4 + 1104) = v44;
                                                      if (v44)
                                                      {
                                                        v45 = malloc_type_calloc(1uLL, 8uLL, 0x5142B0E1uLL);
                                                        *(v4 + 1112) = v45;
                                                        if (v45)
                                                        {
                                                          v46 = malloc_type_calloc(1uLL, 8uLL, 0x5142B0E1uLL);
                                                          *(v4 + 1120) = v46;
                                                          if (v46)
                                                          {
                                                            v47 = cdkCallocMatrix2D_int_aligned();
                                                            **(v4 + 1096) = v47;
                                                            if (v47)
                                                            {
                                                              v48 = cdkCallocMatrix2D_int_aligned();
                                                              **(v4 + 1104) = v48;
                                                              if (v48)
                                                              {
                                                                v49 = malloc_type_calloc(0x47uLL, 4uLL, 0x5142B0E1uLL);
                                                                **(v4 + 1112) = v49;
                                                                if (v49)
                                                                {
                                                                  v50 = malloc_type_calloc(0x47uLL, 4uLL, 0x5142B0E1uLL);
                                                                  **(v4 + 1120) = v50;
                                                                  if (v50)
                                                                  {
                                                                    v51 = cdkCallocMatrix2D_int(2uLL, 71);
                                                                    *(v4 + 1160) = v51;
                                                                    if (v51)
                                                                    {
                                                                      v52 = cdkCallocMatrix2D_int(2uLL, 71);
                                                                      *(v4 + 1168) = v52;
                                                                      if (v52)
                                                                      {
                                                                        v53 = cdkCallocMatrix2D_int(2uLL, 71);
                                                                        *(v4 + 1176) = v53;
                                                                        if (v53)
                                                                        {
                                                                          v54 = cdkCallocMatrix2D_int(2uLL, 71);
                                                                          *(v4 + 1184) = v54;
                                                                          if (v54)
                                                                          {
                                                                            v55 = cdkCallocMatrix2D_int(2uLL, 71);
                                                                            *(v4 + 1192) = v55;
                                                                            if (v55)
                                                                            {
                                                                              v56 = cdkCallocMatrix2D_int(2uLL, 71);
                                                                              *(v4 + 1200) = v56;
                                                                              if (v56)
                                                                              {
                                                                                v57 = malloc_type_calloc(2uLL, 0x10uLL, 0x5142B0E1uLL);
                                                                                *(v4 + 1232) = v57;
                                                                                if (v57)
                                                                                {
                                                                                  v58 = malloc_type_calloc(2uLL, 0x138uLL, 0x5142B0E1uLL);
                                                                                  *(v4 + 1224) = v58;
                                                                                  if (v58)
                                                                                  {
                                                                                    v59 = cdkCallocMatrix2D_int(1uLL, 78);
                                                                                    *(v4 + 1240) = v59;
                                                                                    if (v59)
                                                                                    {
                                                                                      v60 = cdkCallocMatrix2D(1uLL, 732, 4u);
                                                                                      *(v4 + 1248) = v60;
                                                                                      if (v60)
                                                                                      {
                                                                                        v61 = *v60;
                                                                                        v62 = *(v4 + 1224);
                                                                                        v62[35] = **(v4 + 1240);
                                                                                        v62[36] = v61;
                                                                                        v62[37] = 0xB7000000138;
                                                                                        v63 = cdkCallocMatrix2D_int(1uLL, 78);
                                                                                        *(v4 + 1256) = v63;
                                                                                        if (v63)
                                                                                        {
                                                                                          v64 = cdkCallocMatrix2D(1uLL, 732, 4u);
                                                                                          *(v4 + 1264) = v64;
                                                                                          if (v64)
                                                                                          {
                                                                                            v65 = *(v4 + 1224);
                                                                                            v66 = *v64;
                                                                                            v65[74] = **(v4 + 1256);
                                                                                            v65[75] = v66;
                                                                                            v65[76] = 0xB7000000138;
                                                                                            v67 = malloc_type_calloc(1uLL, 0x104uLL, 0x5142B0E1uLL);
                                                                                            *(v4 + 1288) = v67;
                                                                                            if (v67)
                                                                                            {
                                                                                              v68 = malloc_type_calloc(1uLL, 0xE4uLL, 0x5142B0E1uLL);
                                                                                              *(v4 + 1296) = v68;
                                                                                              if (v68)
                                                                                              {
                                                                                                v69 = malloc_type_calloc(1uLL, 0xA40uLL, 0x5142B0E1uLL);
                                                                                                *(v4 + 1272) = v69;
                                                                                                if (v69)
                                                                                                {
                                                                                                  v70 = cdkCallocMatrix2D_int(1uLL, 2304);
                                                                                                  *(v4 + 1280) = v70;
                                                                                                  if (v70)
                                                                                                  {
                                                                                                    v71 = *(v4 + 1272);
                                                                                                    *(v71 + 8) = *v70;
                                                                                                    *v71 = 0;
                                                                                                    *(v71 + 24) = 0;
                                                                                                    *(v71 + 16) = 0;
                                                                                                    v72 = malloc_type_calloc(1uLL, 0x38uLL, 0x5142B0E1uLL);
                                                                                                    if (v72)
                                                                                                    {
                                                                                                      *(v4 + 1312) = v72;
                                                                                                      *(v4 + 8) = 0;
                                                                                                      *(v4 + 16) = -1;
                                                                                                      *(v4 + 192) = 0;
                                                                                                      *(v4 + 1332) = xmmword_19B0B3480;
                                                                                                      *(v4 + 1348) = 3;
                                                                                                      goto LABEL_3;
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    SpatialDecClose(v4);
    goto LABEL_64;
  }

  v8 = malloc_type_calloc(1uLL, 0xDB8uLL, 0x5142B0E1uLL);
  *a1 = v8;
  if (!v8)
  {
LABEL_65:
    *a1 = 0;
    return 4294966297;
  }

  v9 = v8;
  v10 = malloc_type_calloc(0x4ECuLL, 1uLL, 0x5142B0E1uLL);
  v9[400] = v10;
  if (!v10 || (v11 = malloc_type_calloc(6uLL, 0x30uLL, 0x5142B0E1uLL), (v9[397] = v11) == 0) || (v12 = malloc_type_calloc(6uLL, 0x30uLL, 0x5142B0E1uLL), (v9[398] = v12) == 0) || (v13 = malloc_type_calloc(6uLL, 0x30uLL, 0x5142B0E1uLL), (v9[399] = v13) == 0))
  {
    v3 = *a1;
    if (*a1)
    {
LABEL_64:
      mpegSurroundDecoder_Close(v3);
      goto LABEL_65;
    }

    goto LABEL_65;
  }

  *(v9 + 337) = 256;
  v14 = v9[397];
  v15 = v9[398];
  v16 = v9 + 430;
  for (i = 40; i != 328; i += 48)
  {
    *(v14 + i) = v16 - 3;
    *(v15 + i) = v16 - 12;
    *&v13[i] = v16;
    v16 = (v16 + 2);
  }

  result = 0;
  **a1 = a2;
  v18 = *a1;
  *(v18 + 3454) = 1;
  *(v18 + 1726) = 0;
  return result;
}

void aacDecoder_Close(uint64_t a1)
{
  if (a1)
  {
    v2 = *(a1 + 1912);
    if (v2)
    {
      mpegSurroundDecoder_Close(v2);
    }

    v3 = *(a1 + 832);
    if (v3)
    {
      sbrDecoder_DestroyElement(*(a1 + 832), 0);
      sbrDecoder_DestroyElement(v3, 1);
      free(*(a1 + 832));
      *(a1 + 832) = 0;
    }

    if (*(a1 + 24))
    {
      transportDec_Close((a1 + 24));
    }

    CAacDecoder_Close(a1);
  }
}

void mpegSurroundDecoder_Close(uint64_t *a1)
{
  SpatialDecClose(a1[21]);
  a1[21] = 0;
  v2 = a1[400];
  if (v2)
  {
    free(v2);
  }

  a1[400] = 0;
  v3 = a1[399];
  if (v3)
  {
    free(v3);
  }

  a1[399] = 0;
  v4 = a1[397];
  if (v4)
  {
    free(v4);
  }

  a1[397] = 0;
  v5 = a1[398];
  if (v5)
  {
    free(v5);
  }

  free(a1);
}

void CAacDecoder_Close(void *a1)
{
  if (a1)
  {
    CAacDecoder_DeInit(a1);
    v2 = 0;
    v3 = a1 + 249;
    v4 = 1;
    do
    {
      v5 = v4;
      v6 = v3[v2];
      if (v6)
      {
        free(v6);
        v3[v2] = 0;
      }

      v4 = 0;
      v2 = 1;
    }

    while ((v5 & 1) != 0);
    v7 = a1[56];
    if (v7)
    {
      free(*(v7 - 8));
      a1[56] = 0;
    }

    v8 = a1[57];
    if (v8)
    {
      free(*(v8 - 8));
      a1[57] = 0;
    }

    CDK_QmfDomain_FreeWorkBuffer(a1 + 108);
    CDK_QmfDomain_FreePersistentMemory((a1 + 108));
    for (i = 292; i != 286; i -= 3)
    {
      v20 = &a1[i];
      std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v20);
    }

    do
    {
      v20 = &a1[i];
      std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v20);
      i -= 3;
    }

    while (i != 280);
    for (j = 0; j != -6; j -= 3)
    {
      v11 = a1[j + 280];
      if (v11)
      {
        a1[j + 281] = v11;
        operator delete(v11);
      }
    }

    for (k = 0; k != -6; k -= 3)
    {
      v13 = a1[k + 274];
      if (v13)
      {
        a1[k + 275] = v13;
        operator delete(v13);
      }
    }

    v14 = a1[268];
    a1[268] = 0;
    if (v14)
    {
      (*(*v14 + 16))(v14);
    }

    v15 = a1[267];
    a1[267] = 0;
    if (v15)
    {
      MPEG_D::USAC::DynRangeCompressor::USACDRCExtensionPayload::~USACDRCExtensionPayload(v15);
      MEMORY[0x19EAE53E0]();
    }

    UsacQmf::~UsacQmf((a1 + 204));
    UsacQmf::~UsacQmf((a1 + 170));
    v16 = a1[53];
    if (v16)
    {
      v17 = a1[54];
      v18 = a1[53];
      if (v17 != v16)
      {
        do
        {
          v19 = v17 - 5952;
          tcx_dec::tcxDecoder::~tcxDecoder((v17 - 1808));
          v17 = v19;
        }

        while (v19 != v16);
        v18 = a1[53];
      }

      a1[54] = v16;
      operator delete(v18);
    }

    free(a1);
  }
}

void CAacDecoder_DeInit(uint64_t a1)
{
  v2 = *(a1 + 1984);
  if (v2)
  {
    v3 = 0;
    while (1)
    {
      v4 = v3;
      if (v3 == 19)
      {
        break;
      }

      ++v3;
      if (*(a1 + 148 + 4 * v4) == 7)
      {
        if (!v4)
        {
          goto LABEL_11;
        }

        break;
      }
    }

    v5 = 0;
    do
    {
      v6 = *(*(a1 + 1984) + 8 * v5);
      if (v6)
      {
        (*(*v6 + 8))(v6);
      }

      ++v5;
    }

    while (v4 != v5);
    v2 = *(a1 + 1984);
LABEL_11:
    free(v2);
    *(a1 + 1984) = 0;
  }

  v7 = 0;
  *(a1 + 4) = 0;
  *(a1 + 148) = 7;
  v8 = a1 + 392;
  v9 = a1 + 408;
  v10 = 1;
  do
  {
    v11 = v10;
    v12 = *(v8 + 8 * v7);
    if (!v12)
    {
      goto LABEL_30;
    }

    v13 = *(v12 + 64);
    if (v13)
    {
      if (*v13 == 0 || (v10 & 1) == 0)
      {
        if ((v10 & 1) == 0)
        {
LABEL_21:
          free(*(v12 + 64));
          *(*(v8 + 8 * v7) + 64) = 0;
          v12 = *(v8 + 8 * v7);
          goto LABEL_22;
        }
      }

      else
      {
        free(*(*v13 - 8));
        *v13 = 0;
        v12 = *(v8 + 8 * v7);
      }

      v14 = *(a1 + 400);
      if (v14 && *(v14 + 64) == *(v12 + 64))
      {
        *(v14 + 64) = 0;
        v12 = *(v8 + 8 * v7);
      }

      goto LABEL_21;
    }

LABEL_22:
    v15 = *(v12 + 56);
    if (v15)
    {
      if (v11)
      {
        v16 = *(a1 + 400);
        if (v16 && *(v16 + 56) == v15)
        {
          *(v16 + 56) = 0;
          v12 = *(v8 + 8 * v7);
          v15 = *(v12 + 56);
        }

        free(*(v15 - 8));
        *(v12 + 56) = 0;
      }

      else
      {
        free(*(v15 - 8));
      }

      *(*(v8 + 8 * v7) + 56) = 0;
    }

LABEL_30:
    v17 = *(v9 + 8 * v7);
    if (v17)
    {
      if (*v17)
      {
        free(*(*v17 - 8));
        *v17 = 0;
        v17 = *(v9 + 8 * v7);
      }

      v18 = v17[9];
      if (v18)
      {
        if (*v18)
        {
          (*(**v18 + 8))(*v18);
        }

        MEMORY[0x19EAE53E0](v18, 0x80C40803F642BLL);
        v17 = *(v9 + 8 * v7);
      }

      free(v17);
      *(v9 + 8 * v7) = 0;
    }

    v19 = *(v8 + 8 * v7);
    if (v19)
    {
      free(*(v19 - 8));
      *(v8 + 8 * v7) = 0;
    }

    v10 = 0;
    v7 = 1;
  }

  while ((v11 & 1) != 0);
  v20 = *(a1 + 2056);
  if (v20)
  {
    free(v20);
  }

  *(a1 + 2056) = 0;
  *(a1 + 2064) = 0;
  *(a1 + 2066) = 0;
  *a1 = 0;
  *(a1 + 320) = 0;
  *(a1 + 288) = 0;
  *(a1 + 56) = 0;
}

void UsacQmf::~UsacQmf(UsacQmf *this)
{
  v2 = *(this + 31);
  if (v2)
  {
    *(this + 32) = v2;
    operator delete(v2);
  }

  v3 = *(this + 28);
  if (v3)
  {
    *(this + 29) = v3;
    operator delete(v3);
  }

  v4 = *(this + 25);
  if (v4)
  {
    *(this + 26) = v4;
    operator delete(v4);
  }

  v5 = *(this + 22);
  if (v5)
  {
    *(this + 23) = v5;
    operator delete(v5);
  }

  v6 = *(this + 19);
  if (v6)
  {
    *(this + 20) = v6;
    operator delete(v6);
  }

  v7 = (this + 128);
  std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v7);
  v7 = (this + 104);
  std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v7);
  v7 = (this + 80);
  std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v7);
  v7 = (this + 56);
  std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v7);
  if (*(this + 3))
  {
    std::vector<std::unique_ptr<SynthesisSBRQMF>>::clear[abi:ne200100](this + 3);
    operator delete(*(this + 3));
  }

  if (*this)
  {
    std::vector<std::unique_ptr<AnalysisSBRQMF>>::clear[abi:ne200100](this);
    operator delete(*this);
  }
}

void tcx_dec::tcxDecoder::~tcxDecoder(vDSP_DFT_Setup *this)
{
  *this = &unk_1F0E21E48;
  vDSP_DFT_DestroySetup(this[34]);
  vDSP_DFT_DestroySetup(this[35]);
}

{
  tcx_dec::tcxDecoder::~tcxDecoder(this);

  JUMPOUT(0x19EAE53E0);
}

void CDK_QmfDomain_FreeWorkBuffer(void *a1)
{
  v2 = a1[2];
  if (v2)
  {
    free(*(v2 - 8));
    a1[2] = 0;
  }

  v3 = a1[3];
  if (v3)
  {
    free(*(v3 - 8));
    a1[3] = 0;
  }

  v4 = a1[4];
  if (v4)
  {
    free(*(v4 - 8));
    a1[4] = 0;
  }

  v5 = a1[5];
  if (v5)
  {
    free(*(v5 - 8));
    a1[5] = 0;
  }

  v6 = a1[6];
  if (v6)
  {
    free(*(v6 - 8));
    a1[6] = 0;
  }
}

void CDK_QmfDomain_FreePersistentMemory(uint64_t a1)
{
  v2 = 0;
  v3 = a1 + 80;
  v4 = 1;
  do
  {
    v5 = v4;
    v6 = (v3 + (v2 << 7));
    v7 = v6[11];
    if (v7)
    {
      free(v7);
      v6[11] = 0;
    }

    v8 = v6[12];
    if (v8)
    {
      free(*(v8 - 8));
      v6[12] = 0;
    }

    v9 = v6[14];
    if (v9)
    {
      free(v9);
      v6[14] = 0;
    }

    v10 = v6[15];
    if (v10)
    {
      if (*(a1 + 70) == 16)
      {
        free(v10);
        v10 = 0;
        v6[15] = 0;
      }

      free(v10);
      v6[15] = 0;
    }

    v4 = 0;
    v2 = 1;
  }

  while ((v5 & 1) != 0);
  v11 = 0;
  v12 = a1 + 336;
  v13 = 1;
  do
  {
    v14 = v13;
    v15 = v12 + 80 * v11;
    v18 = *(v15 + 72);
    v17 = (v15 + 72);
    v16 = v18;
    if (v18)
    {
      free(v16);
      *v17 = 0;
    }

    v13 = 0;
    v11 = 1;
  }

  while ((v14 & 1) != 0);
}

void sbrDecoder_DestroyElement(uint64_t a1, int a2)
{
  if (*(a1 + 8 * a2))
  {
    v4 = 0;
    v5 = 1;
    do
    {
      v6 = v5;
      v7 = *(*(a1 + 8 * a2) + 8 * v4);
      if (v7)
      {
        v8 = *(v7 + 13888);
        if (v8)
        {
          cdkFreeMatrix2D_aligned(v8);
          *(v7 + 13888) = 0;
        }

        cdkFreeMatrix2D_aligned(*(v7 + 13904));
        *(v7 + 13904) = 0;
        v9 = *(v7 + 13864);
        if (v9)
        {
          QmfTransposerClose(v9);
        }

        v10 = *(v7 + 13912);
        if (v10)
        {
          cdkFreeMatrix2D_aligned(v10);
          *(v7 + 13912) = 0;
        }

        v11 = *(v7 + 13920);
        if (v11)
        {
          cdkFreeMatrix2D_aligned(v11);
          *(v7 + 13920) = 0;
        }

        v12 = *(a1 + 8 * a2);
        if (v12)
        {
          free(*(v12 + 8 * v4));
          *(v12 + 8 * v4) = 0;
        }

        --*(a1 + 512);
      }

      v5 = 0;
      v4 = 1;
    }

    while ((v6 & 1) != 0);
    free(*(a1 + 8 * a2));
    *(a1 + 8 * a2) = 0;
    --*(a1 + 508);
  }
}

void cdkFreeMatrix2D_aligned(void ***a1)
{
  if (a1)
  {
    if (*a1)
    {
      free(*(*a1 - 1));
    }

    free(a1);
  }
}

void QmfTransposerClose(uint64_t a1)
{
  v2 = *(a1 + 64);
  if (v2)
  {
    free(v2);
  }

  v3 = *(a1 + 72);
  if (v3)
  {
    if (*(a1 + 32) >= 1)
    {
      v4 = 0;
      do
      {
        free(*(*(*(a1 + 72) + 8 * v4++) - 8));
      }

      while (v4 < *(a1 + 32));
      v3 = *(a1 + 72);
    }

    free(v3);
  }

  v5 = *(a1 + 80);
  if (v5)
  {
    if (*(a1 + 32) >= 1)
    {
      v6 = 0;
      do
      {
        free(*(*(*(a1 + 80) + 8 * v6++) - 8));
      }

      while (v6 < *(a1 + 32));
      v5 = *(a1 + 80);
    }

    free(v5);
  }

  if (*(a1 + 2656))
  {
    for (i = 0; i != 88; i += 8)
    {
      free(*(*(a1 + 2656) + i));
    }

    free(*(a1 + 2656));
  }

  if (*(a1 + 2664))
  {
    for (j = 0; j != 88; j += 8)
    {
      free(*(*(a1 + 2664) + j));
    }

    free(*(a1 + 2664));
  }

  free(*(a1 + 88));

  free(a1);
}

void SpatialDecClose(uint64_t a1)
{
  if (a1)
  {
    v2 = *(a1 + 1272);
    if (v2)
    {
      v3 = *(a1 + 44);
      if (v3 >= 1)
      {
        v4 = v2 + 16;
        do
        {
          *(v4 - 1) = 0;
          *(v4 - 4) = 0;
          *(v4 + 1) = 0;
          *v4 = 0;
          v4 += 2624;
          --v3;
        }

        while (v3);
      }

      free(v2);
      *(a1 + 1272) = 0;
    }

    v5 = *(a1 + 1280);
    if (v5)
    {
      cdkFreeMatrix2D(v5);
      *(a1 + 1280) = 0;
    }

    v6 = *(a1 + 1312);
    if (v6)
    {
      free(v6);
    }

    *(a1 + 1312) = 0;
    v7 = *(a1 + 1296);
    if (v7)
    {
      free(v7);
    }

    *(a1 + 1296) = 0;
    v8 = *(a1 + 1288);
    if (v8)
    {
      free(v8);
    }

    *(a1 + 1288) = 0;
    cdkFreeMatrix2D(*(a1 + 1240));
    *(a1 + 1240) = 0;
    cdkFreeMatrix2D(*(a1 + 1248));
    *(a1 + 1248) = 0;
    cdkFreeMatrix2D(*(a1 + 1256));
    *(a1 + 1256) = 0;
    cdkFreeMatrix2D(*(a1 + 1264));
    *(a1 + 1264) = 0;
    v9 = *(a1 + 1224);
    if (v9)
    {
      free(v9);
    }

    *(a1 + 1224) = 0;
    v10 = *(a1 + 1232);
    if (v10)
    {
      free(v10);
    }

    *(a1 + 1232) = 0;
    cdkFreeMatrix2D(*(a1 + 1200));
    *(a1 + 1200) = 0;
    cdkFreeMatrix2D(*(a1 + 1192));
    *(a1 + 1192) = 0;
    cdkFreeMatrix2D(*(a1 + 1184));
    *(a1 + 1184) = 0;
    cdkFreeMatrix2D(*(a1 + 1176));
    *(a1 + 1176) = 0;
    cdkFreeMatrix2D(*(a1 + 1168));
    *(a1 + 1168) = 0;
    cdkFreeMatrix2D(*(a1 + 1160));
    *(a1 + 1160) = 0;
    if (*(a1 + 60))
    {
      if (*(a1 + 56) >= 1)
      {
        v11 = 0;
        do
        {
          v12 = *(a1 + 1120);
          if (v12)
          {
            v13 = *(v12 + 8 * v11);
            if (v13)
            {
              free(v13);
              v12 = *(a1 + 1120);
            }

            *(v12 + 8 * v11) = 0;
          }

          v14 = *(a1 + 1112);
          if (v14)
          {
            v15 = *(v14 + 8 * v11);
            if (v15)
            {
              free(v15);
              v14 = *(a1 + 1112);
            }

            *(v14 + 8 * v11) = 0;
          }

          v16 = *(a1 + 1104);
          if (v16)
          {
            cdkFreeMatrix2D_aligned(*(v16 + 8 * v11));
            *(*(a1 + 1104) + 8 * v11) = 0;
          }

          v17 = *(a1 + 1096);
          if (v17)
          {
            cdkFreeMatrix2D_aligned(*(v17 + 8 * v11));
            *(*(a1 + 1096) + 8 * v11) = 0;
          }

          ++v11;
        }

        while (v11 < *(a1 + 56));
      }

      v18 = *(a1 + 1120);
      if (v18)
      {
        free(v18);
      }

      *(a1 + 1120) = 0;
      v19 = *(a1 + 1112);
      if (v19)
      {
        free(v19);
      }

      *(a1 + 1112) = 0;
      v20 = *(a1 + 1104);
      if (v20)
      {
        free(v20);
      }

      *(a1 + 1104) = 0;
      v21 = *(a1 + 1096);
      if (v21)
      {
        free(v21);
      }

      *(a1 + 1096) = 0;
    }

    cdkFreeMatrix2D(*(a1 + 1064));
    *(a1 + 1064) = 0;
    cdkFreeMatrix2D(*(a1 + 1056));
    *(a1 + 1056) = 0;
    cdkFreeMatrix2D_aligned(*(a1 + 1048));
    *(a1 + 1048) = 0;
    cdkFreeMatrix2D_aligned(*(a1 + 1040));
    *(a1 + 1040) = 0;
    cdkFreeMatrix3D(*(a1 + 1008));
    *(a1 + 1008) = 0;
    cdkFreeMatrix3D(*(a1 + 1000));
    *(a1 + 1000) = 0;
    cdkFreeMatrix3D(*(a1 + 992));
    *(a1 + 992) = 0;
    cdkFreeMatrix3D(*(a1 + 984));
    *(a1 + 984) = 0;
    cdkFreeMatrix3D(*(a1 + 520));
    *(a1 + 520) = 0;
    cdkFreeMatrix3D(*(a1 + 496));
    *(a1 + 496) = 0;
    cdkFreeMatrix3D(*(a1 + 488));
    *(a1 + 488) = 0;
    cdkFreeMatrix2D(*(a1 + 424));
    *(a1 + 424) = 0;
    cdkFreeMatrix2D(*(a1 + 432));
    *(a1 + 432) = 0;
    cdkFreeMatrix3D(*(a1 + 472));
    *(a1 + 472) = 0;
    cdkFreeMatrix2D(*(a1 + 440));
    *(a1 + 440) = 0;
    cdkFreeMatrix2D(*(a1 + 456));
    *(a1 + 456) = 0;
    cdkFreeMatrix2D(*(a1 + 464));
    *(a1 + 464) = 0;
    cdkFreeMatrix3D(*(a1 + 448));
    *(a1 + 448) = 0;
    cdkFreeMatrix2D(*(a1 + 480));
    *(a1 + 480) = 0;
    cdkFreeMatrix2D(*(a1 + 416));
    *(a1 + 416) = 0;
    v22 = *(a1 + 408);
    if (v22)
    {
      free(v22);
    }

    *(a1 + 408) = 0;
    v23 = *(a1 + 392);
    if (v23)
    {
      free(v23);
    }

    *(a1 + 392) = 0;
    v24 = *(a1 + 232);
    if (v24)
    {
      free(v24);
    }

    free(a1);
  }
}

void cdkFreeMatrix2D(void **a1)
{
  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      free(v2);
    }

    free(a1);
  }
}

void cdkFreeMatrix3D(void ***a1)
{
  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      if (!*v2 || (free(*v2), (v2 = *a1) != 0))
      {
        free(v2);
      }
    }

    free(a1);
  }
}

uint64_t aacDecoder_SscCallback(uint64_t a1, unsigned int *a2, unsigned int a3, int a4, uint64_t a5, int a6, int a7, int a8, int a9, char a10, _BYTE *a11)
{
  v14 = *(a1 + 1912);
  v32 = v14;
  if (a3 != 147 && a3 != 42)
  {
    goto LABEL_31;
  }

  *&v15 = 0xAAAAAAAAAAAAAAAALL;
  *(&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(v31 + 12) = v15;
  v30 = v15;
  v31[0] = v15;
  v28 = v15;
  v29 = v15;
  v26 = v15;
  v27 = v15;
  v24 = v15;
  v25 = v15;
  v23 = v15;
  if (a10 == 1)
  {
    v30 = 0u;
    memset(v31, 0, 28);
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v23 = 0u;
    v16 = &v23;
    v17 = SpatialDecParseMps212Config(a2, &v23, a4, a3, a7, a8);
    v18 = &v25 + 3;
    if (v17)
    {
      goto LABEL_7;
    }
  }

  else
  {
    v16 = (v14 + 22);
    v17 = SpatialDecParseMps212Config(a2, (v14 + 22), a4, a3, a7, a8);
    v18 = v14 + 55;
    if (v17)
    {
      goto LABEL_7;
    }
  }

  if (*v18 != a6)
  {
    goto LABEL_17;
  }

  v20 = *(v16 + 1);
  if (v20 - 96001 < 0xFFFEA83F || *(v16 + 4) > 7u || *(v16 + 5) > 2u || a3 != 147 && a3 != 42)
  {
    goto LABEL_17;
  }

  if (v20 > 0xD881)
  {
    goto LABEL_17;
  }

  if (a10)
  {
LABEL_30:
    result = 0;
    *(a1 + 1922) = 1;
    return result;
  }

  if ((a10 & 2) == 0 || !*a11)
  {
    goto LABEL_26;
  }

  v17 = mpegSurroundDecoder_Open(&v32, 0);
  if (!v17)
  {
    v14 = v32;
LABEL_26:
    v21 = *(v14 + 3452);
    if (!memcmp(v14 + 22, v14 + 156 * v21 + 8, 0x9CuLL))
    {
LABEL_29:
      *(v14 + 333) = 1;
      goto LABEL_30;
    }

    *(v14 + v21 + 870) |= 0x80u;
    v22 = v14[21];
    if (v22)
    {
      SpatialDecInitParserContext(v22);
      *(v14[21] + 376) = v14 + 156 * *(v14 + 3453) + 8;
      goto LABEL_29;
    }

LABEL_31:
    *(a1 + 1922) = 0;
    return 513;
  }

LABEL_7:
  if (v17 != -982)
  {
    if (v17 == -983)
    {
      result = 0;
      *(a1 + 1921) = 0;
      return result;
    }

    goto LABEL_31;
  }

LABEL_17:
  *(a1 + 1921) = 0;
  result = 1025;
  if ((a3 > 0x2A || ((1 << a3) & 0x48000800000) == 0) && a3 != 147)
  {
    return 0;
  }

  return result;
}

uint64_t SpatialDecParseMps212Config(unsigned int *a1, uint64_t a2, int a3, int a4, int a5, int a6)
{
  *(a2 + 128) = a5;
  *(a2 + 129) = a6;
  v12 = a1[1];
  if (3 - v12 <= 0)
  {
    LOBYTE(v13) = 0;
    v14 = *a1;
  }

  else
  {
    if (v12 == -29)
    {
      LOBYTE(v13) = 0;
    }

    else
    {
      v13 = *a1 << (3 - v12);
    }

    v14 = CDK_get32((a1 + 2));
    *a1 = v14;
    v12 = a1[1] + 32;
  }

  v15 = v12 - 3;
  a1[1] = v12 - 3;
  v16 = freqResTable[((v14 >> (v12 - 3)) | v13) & 7];
  *(a2 + 12) = v16;
  if (!v16)
  {
    return 4294966314;
  }

  if (a4 != 42)
  {
    return 4294966303;
  }

  if (6 - v12 < 1)
  {
    v17 = 0;
  }

  else
  {
    v17 = v12 == -26 ? 0 : v14 << (6 - v12);
    v14 = CDK_get32((a1 + 2));
    *a1 = v14;
    v15 = a1[1] + 32;
  }

  v19 = v15 - 3;
  a1[1] = v15 - 3;
  *(a2 + 32) = ((v14 >> (v15 - 3)) | v17) & 7;
  if (5 - v15 < 1)
  {
    v20 = 0;
  }

  else
  {
    v20 = v15 == -27 ? 0 : v14 << (5 - v15);
    v14 = CDK_get32((a1 + 2));
    *a1 = v14;
    v19 = a1[1] + 32;
  }

  v21 = v19 - 2;
  a1[1] = v19 - 2;
  *(a2 + 36) = ((v14 >> (v19 - 2)) | v20) & 3;
  if (4 - v19 < 1)
  {
    v22 = 0;
  }

  else
  {
    v22 = v19 == -28 ? 0 : v14 << (4 - v19);
    v14 = CDK_get32((a1 + 2));
    *a1 = v14;
    v21 = a1[1] + 32;
  }

  v23 = v21 - 2;
  a1[1] = v21 - 2;
  v24 = ((v14 >> (v21 - 2)) | v22) & 3;
  *(a2 + 40) = v24;
  if (v24 == 3)
  {
    return 4294966314;
  }

  *(a2 + 131) = 0;
  if (a6 == 4)
  {
    v25 = 64;
  }

  else
  {
    v25 = 32;
  }

  *(a2 + 8) = v25;
  if (3 - v21 < 1)
  {
    v26 = 0;
  }

  else
  {
    if (v21 == -29)
    {
      v26 = 0;
    }

    else
    {
      v26 = v14 << (3 - v21);
    }

    v14 = CDK_get32((a1 + 2));
    *a1 = v14;
    v23 = a1[1] + 32;
  }

  v27 = v23 - 1;
  a1[1] = v23 - 1;
  *(a2 + 130) = ((v14 >> (v23 - 1)) | v26) & 1;
  if (2 - v23 < 1)
  {
    v28 = 0;
  }

  else
  {
    if (v23 == -30)
    {
      v28 = 0;
    }

    else
    {
      v28 = v14 << (2 - v23);
    }

    v14 = CDK_get32((a1 + 2));
    *a1 = v14;
    v27 = a1[1] + 32;
  }

  v29 = v27 - 1;
  a1[1] = v27 - 1;
  *(a2 + 133) = ((v14 >> (v27 - 1)) | v28) & 1;
  if (2 - v27 < 1)
  {
    v30 = 0;
  }

  else
  {
    if (v27 == -30)
    {
      v30 = 0;
    }

    else
    {
      v30 = v14 << (2 - v27);
    }

    v14 = CDK_get32((a1 + 2));
    *a1 = v14;
    v29 = a1[1] + 32;
  }

  v31 = v29 - 1;
  a1[1] = v29 - 1;
  *(a2 + 134) = ((v14 >> (v29 - 1)) | v30) & 1;
  if (((v14 >> (v29 - 1)) | v30))
  {
    if (6 - v29 < 1)
    {
      v32 = 0;
    }

    else
    {
      if (v29 == -26)
      {
        v32 = 0;
      }

      else
      {
        v32 = v14 << (6 - v29);
      }

      v14 = CDK_get32((a1 + 2));
      *a1 = v14;
      v31 = a1[1] + 32;
    }

    v31 -= 5;
    a1[1] = v31;
    v33 = ((v14 >> v31) | v32) & 0x1F;
    *(a2 + 136) = v33;
    if (v33 > 0x1C)
    {
      return 4294966314;
    }
  }

  else
  {
    *(a2 + 136) = 0;
  }

  if (a5 >= 2)
  {
    *(a2 + 28) = 1;
    *(a2 + 80) = 1;
    v34 = *(a2 + 12);
    if (5 - v31 < 1)
    {
      v35 = 0;
    }

    else
    {
      if (v31 == -27)
      {
        v35 = 0;
      }

      else
      {
        v35 = v14 << (5 - v31);
      }

      v14 = CDK_get32((a1 + 2));
      *a1 = v14;
      v31 = a1[1] + 32;
    }

    v36 = v31 - 5;
    a1[1] = v31 - 5;
    v37 = ((v14 >> (v31 - 5)) | v35) & 0x1F;
    *(a2 + 84) = v37;
    if (v34 >= v37)
    {
      if (*(a2 + 136) > v37)
      {
        v37 = *(a2 + 136);
      }

      *(a2 + 136) = v37;
      if (6 - v31 < 1)
      {
        v38 = 0;
      }

      else
      {
        if (v31 == -26)
        {
          v38 = 0;
        }

        else
        {
          v38 = v14 << (6 - v31);
        }

        v14 = CDK_get32((a1 + 2));
        *a1 = v14;
        v36 = a1[1] + 32;
      }

      v31 = v36 - 1;
      a1[1] = v36 - 1;
      *(a2 + 132) = ((v14 >> (v36 - 1)) | v38) & 1;
      if (*(a2 + 133))
      {
        *(a2 + 133) = 3;
      }

      goto LABEL_79;
    }

    return 4294966314;
  }

  *(a2 + 28) = 0;
  *(a2 + 80) = 0;
LABEL_79:
  if (*(a2 + 36) == 2)
  {
    if (1 - v31 < 1)
    {
      v39 = 0;
    }

    else
    {
      if (v31 == -31)
      {
        v39 = 0;
      }

      else
      {
        v39 = v14 << (1 - v31);
      }

      v14 = CDK_get32((a1 + 2));
      *a1 = v14;
      v31 = a1[1] + 32;
    }

    v40 = v31 - 1;
    a1[1] = v40;
    *(a2 + 120) = ((v14 >> v40) | v39) & 1;
  }

  *(a2 + 4) = a3;
  *(a2 + 16) = 7;
  *(a2 + 24) = 0;
  *(a2 + 44) = xmmword_19B0B34A0;
  *(a2 + 124) = 42;
  SpatialDecDecodeHelperInfo(a2);
  return 0;
}

uint64_t SpatialDecInitParserContext(uint64_t result)
{
  if (*(result + 68) >= 1)
  {
    v1 = 0;
    do
    {
      for (i = 0; i != 28; ++i)
      {
        *(*(*(result + 424) + 8 * v1) + i) = 0;
        *(*(*(result + 432) + 8 * v1) + i) = 0;
        *(*(*(result + 456) + 8 * v1) + i) = 0;
        *(*(*(result + 464) + 8 * v1) + i) = 0;
      }

      ++v1;
    }

    while (v1 < *(result + 68));
  }

  return result;
}

uint64_t SpatialDecDecodeHelperInfo(uint64_t result)
{
  if (*(result + 124) == 42)
  {
    *result = 2;
    if (*(result + 16) == 7)
    {
      *(result + 140) = 0;
      v1 = *(result + 134);
      if (*(result + 134))
      {
        v2 = *(result + 136);
      }

      else
      {
        v7 = *(result + 12);
        if (v7 > 13)
        {
          if (v7 == 14)
          {
            v2 = 7;
          }

          else
          {
            if (v7 != 20 && v7 != 28)
            {
              return result;
            }

            v2 = 10;
          }
        }

        else if ((v7 - 4) < 2)
        {
          v2 = 2;
        }

        else if (v7 == 7)
        {
          v2 = 3;
        }

        else
        {
          if (v7 != 10)
          {
            return result;
          }

          v2 = 5;
        }
      }

      *(result + 145) = v2;
      v3 = *(result + 52);
      if (v3 >= 1)
      {
        v4 = *(result + 12);
        v5 = (result + 151);
        v6 = (result + 84);
        do
        {
          *(v5 - 5) = v4;
          *v5 = v4;
          if (!v1 && *(result + 28) && *(v6 - 1) && *v6 > v2)
          {
            v2 = *v6;
            *(result + 145) = *v6;
          }

          v6 += 2;
          ++v5;
          --v3;
        }

        while (v3);
      }
    }
  }

  return result;
}

void *cdkCallocMatrix2D(size_t count, int a2, unsigned int a3)
{
  v5 = count;
  v6 = count;
  v7 = malloc_type_calloc(count, 8uLL, 0x5142B0E1uLL);
  if (v7)
  {
    v8 = malloc_type_calloc((a2 * v5), a3, 0x5142B0E1uLL);
    if (v8)
    {
      v9 = 0;
      do
      {
        v7[v9] = v8;
        v8 += a3 * a2;
        ++v9;
      }

      while (v6 != v9);
    }

    else
    {
      free(v7);
      return 0;
    }
  }

  return v7;
}

char *cdkCallocMatrix3D(size_t count, unsigned int a2, unsigned int a3)
{
  v5 = count;
  v6 = count;
  v7 = malloc_type_calloc(count, 8uLL, 0x5142B0E1uLL);
  if (!v7)
  {
    return v7;
  }

  v8 = a2 * v5;
  v9 = malloc_type_calloc(a2 * v5, 8uLL, 0x5142B0E1uLL);
  if (!v9)
  {
    v10 = v7;
LABEL_11:
    free(v10);
    return 0;
  }

  v10 = v9;
  *v7 = v9;
  v11 = malloc_type_calloc((28 * v8), a3, 0x5142B0E1uLL);
  if (!v11)
  {
    free(v7);
    goto LABEL_11;
  }

  v12 = 0;
  do
  {
    v13 = 0;
    *&v7[8 * v12] = v10;
    do
    {
      *&v10[8 * v13] = v11;
      v11 += 28 * a3;
      ++v13;
    }

    while (a2 != v13);
    v10 += 8 * a2;
    ++v12;
  }

  while (v12 != v6);
  return v7;
}

void *cdkCallocMatrix3D_int()
{
  v0 = malloc_type_calloc(2uLL, 8uLL, 0x5142B0E1uLL);
  if (v0)
  {
    v1 = malloc_type_calloc(4uLL, 8uLL, 0x5142B0E1uLL);
    if (v1)
    {
      v2 = v1;
      *v0 = v1;
      v3 = malloc_type_calloc(0x70uLL, 4uLL, 0x5142B0E1uLL);
      if (v3)
      {
        v4 = 0;
        v5 = 0;
        do
        {
          v6 = v4;
          v0[v5] = v2;
          *v2 = v3;
          v2[1] = v3 + 112;
          v2 += 2;
          v3 += 224;
          v4 = 1;
          v5 = 1;
        }

        while ((v6 & 1) == 0);
        return v0;
      }

      free(v0);
    }

    else
    {
      v2 = v0;
    }

    free(v2);
    return 0;
  }

  return v0;
}

void *cdkCallocMatrix2D_int_aligned()
{
  v0 = malloc_type_calloc(1uLL, 8uLL, 0x5142B0E1uLL);
  if (v0)
  {
    v1 = malloc_type_calloc(1uLL, 0x110uLL, 0x5142B0E1uLL);
    if (v1)
    {
      v2 = v1 + (-(v1 + 8) & 7) + 8;
      *(v2 - 8) = v1;
      *v0 = v2;
    }

    else
    {
      free(v0);
      return 0;
    }
  }

  return v0;
}

void *cdkCallocMatrix2D_int(size_t count, int a2)
{
  v3 = count;
  v4 = count;
  v5 = malloc_type_calloc(count, 8uLL, 0x5142B0E1uLL);
  if (v5)
  {
    v6 = malloc_type_calloc((a2 * v3), 4uLL, 0x5142B0E1uLL);
    if (v6)
    {
      v7 = 0;
      do
      {
        v5[v7] = v6;
        v6 += (4 * a2);
        ++v7;
      }

      while (v4 != v7);
    }

    else
    {
      free(v5);
      return 0;
    }
  }

  return v5;
}

uint64_t aacDecoder_SbrCallback(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, unsigned int a7, int a8, unsigned __int8 a9, char a10, char a11, _BYTE *a12, int a13)
{
  result = 6;
  if (a6 == 42 && a1 && a8 <= 1)
  {
    if (a11)
    {
      v18 = *(a1 + 536);
    }

    else
    {
      v18 = 0;
    }

    result = sbrDecoder_InitElement(a1, a3, a4, a5, 42, a7, a8, a9, a11, a12, a13);
    if (a7 != 3 && !result)
    {
      if (a11)
      {
        v19 = 0;
      }

      else
      {
        v19 = a1 + 240 * a8 + 16;
      }

      sbrGetHeaderData(v19, a2, *(a1 + 536), 0, a11);
      result = 0;
    }

    if (a11)
    {
      *(a1 + 536) = v18;
    }
  }

  return result;
}

uint64_t sbrDecoder_InitElement(uint64_t a1, int a2, int a3, int a4, int a5, unsigned int a6, int a7, int a8, char a9, _BYTE *a10, int a11)
{
  if (!a1)
  {
    return 1;
  }

  v14 = *(a1 + 508);
  v15 = *(a1 + 512);
  v16 = 6;
  if (a5 == 42 && a7 <= 1 && a6 <= 3 && a6 != 2)
  {
    if (*(a1 + 516) == a2 && *(a1 + 524) == a4 && *(a1 + 504) == 42)
    {
      v20 = *(a1 + 8 * a7);
      if (v20)
      {
        if (*(v20 + 104) == a6 && (*(a1 + 537) & 0x80) == 0 && (!a3 || *(a1 + 520) == a3) && (a8 == 2 || *(a1 + 533) == a8))
        {
          return 0;
        }
      }
    }

    if (a9)
    {
      *a10 = 1;
    }

    v21 = a2 == a3 / 4 ? 132 : 4;
    *(a1 + 536) = v21 | ((a8 == 1) << 8) | *(a1 + 536) & 0xC000;
    if (a9)
    {
      return 0;
    }

    *(a1 + 516) = a2;
    *(a1 + 524) = a4;
    *(a1 + 504) = 42;
    *(a1 + 533) = a8;
    *(a1 + 528) = a11;
    v23 = *(a1 + 8 * a7);
    if (v23)
    {
      *(a1 + 512) -= v23[27];
    }

    else
    {
      v24 = v15;
      v23 = malloc_type_calloc(1uLL, 0x78uLL, 0x5142B0E1uLL);
      *(a1 + 8 * a7) = v23;
      if (!v23)
      {
LABEL_39:
        v16 = 4;
        v15 = v24;
        goto LABEL_88;
      }

      ++*(a1 + 508);
      v15 = v24;
    }

    v23[26] = a6;
    if (a6 != 3)
    {
      if (a6 == 1)
      {
        v25 = 2;
LABEL_33:
        v26 = v23[27];
        if (v25 >= v26)
        {
          v24 = v15;
          v27 = 0;
          v23[27] = v25;
          v28 = 8 * v25;
          while (1)
          {
            if (!*&v23[v27 / 4])
            {
              *(*(a1 + 8 * a7) + v27) = malloc_type_calloc(1uLL, 0x3670uLL, 0x5142B0E1uLL);
              v23 = *(a1 + 8 * a7);
              if (!*&v23[v27 / 4])
              {
                goto LABEL_39;
              }
            }

            ++*(a1 + 512);
            v27 += 8;
            if (v28 == v27)
            {
              goto LABEL_43;
            }
          }
        }

LABEL_41:
        *(a1 + 512) += v26;
        v16 = 5;
        goto LABEL_88;
      }

      if (a6)
      {
        v26 = v23[27];
        if (v26 <= 0)
        {
          v24 = v15;
          v23[27] = 0;
LABEL_43:
          v29 = *(a1 + 496);
          if (!*v29)
          {
            v30 = *(a1 + 512);
            v29[2] = v30;
            if (v30 <= v29[4])
            {
              LOBYTE(v30) = v29[4];
            }

            v29[4] = v30;
          }

          v31 = *(a1 + 508);
          v15 = v24;
          if (v31 >= 1)
          {
            v32 = 0;
            v33 = 0;
            v34 = v29 + 336;
            v35 = v29 + 80;
            do
            {
              v36 = *(a1 + 8 * v32);
              if (v36)
              {
                LODWORD(v37) = *(v36 + 108);
                if (v37 >= 1)
                {
                  v38 = 0;
                  if (v33 <= 2)
                  {
                    v39 = 2;
                  }

                  else
                  {
                    v39 = v33;
                  }

                  v40 = (v39 - v33);
                  v41 = &v34[80 * v33];
                  v42 = &v35[128 * v33];
                  do
                  {
                    if (v40 == v38)
                    {
                      exception = __cxa_allocate_exception(0x10uLL);
                      *exception = "void sbrDecoder_AssignQmfChannels2SbrChannels(HANDLE_SBRDECODER)";
                      exception[2] = 248;
                    }

                    *(*(v36 + 8 * v38) + 13872) = v42;
                    *(*(*(a1 + 8 * v32) + 8 * v38++) + 13880) = v41;
                    v36 = *(a1 + 8 * v32);
                    v37 = *(v36 + 108);
                    v41 += 80;
                    v42 += 128;
                  }

                  while (v38 < v37);
                }

                v33 += v37;
              }

              ++v32;
            }

            while (v32 != v31);
            v23 = *(a1 + 8 * a7);
          }

          *(v23 + 112) = 0;
          v43 = *(a1 + 536);
          if ((v43 & 0x80) != 0)
          {
            v44 = 12;
          }

          else
          {
            v44 = 6;
          }

          v86 = v44;
          v45 = *(a1 + 504);
          if (v45 == 150)
          {
            v46 = 2000;
          }

          else
          {
            v46 = 6400;
          }

          if (v45 == 50)
          {
            v46 = 2000;
          }

          if (v45 == 42)
          {
            v47 = 2000;
          }

          else
          {
            v47 = v46;
          }

          v16 = 6;
          if (a3 <= 96000 && a2 <= 24000 && v47 <= a2)
          {
            v84 = v15;
            if (a3)
            {
              v48 = a3;
            }

            else
            {
              v48 = 2 * a2;
            }

            *(a1 + 536) = v43 & 0xFFFFDFFF | ((v48 == a2) << 13);
            if (v48 == a2)
            {
              v49 = 2;
            }

            else
            {
              v49 = 1;
            }

            *(a1 + 526) = v49;
            *(a1 + 520) = v48;
            v50 = a1 + 240 * a7;
            v52 = *(v50 + 16);
            v51 = v50 + 16;
            if (v52)
            {
              v53 = (v43 >> 15) & 1;
            }

            else
            {
              v53 = 1;
            }

            inited = initHeaderData(v51, a2, v48, *(a1 + 528), a4, v43, v53);
            v55 = *v51;
            if (*v51 >= 1)
            {
              v55 = 1;
            }

            *v51 = v55;
            if (!inited)
            {
              v58 = *(a1 + 496);
              if (!*v58)
              {
                *(v58 + 60) |= (v43 >> 5) & 1;
                *(v58 + 65) = *(v51 + 7);
                if (v48 == a2)
                {
                  v59 = 32;
                }

                else
                {
                  v59 = 64;
                }

                *(v58 + 68) = v59 / *(a1 + 528);
                *(v58 + 71) = *(v51 + 8) * *(v51 + 6);
                *(v58 + 73) = v86;
                *(v58 + 75) = 64;
                *(v58 + 77) = 1;
              }

              v60 = *(a1 + 8 * a7);
              if (*(v60 + 108) < 1)
              {
LABEL_114:
                v16 = 0;
                *(v60 + 113) = 0;
                return v16;
              }

              v61 = 0;
              v62 = 0uLL;
              while (1)
              {
                v63 = *(v60 + 8 * v61);
                v64 = *(a1 + 536);
                v65 = *(a1 + 524);
                v66 = *(v51 + 6);
                v67 = *(v51 + 8);
                *(v63 + 13852) = 0;
                v85 = v65;
                *(v63 + 13856) = v65;
                *(v63 + 2708) = 0;
                *(v63 + 2864) = 0;
                *(v63 + 2716) = 0;
                *(v63 + 2724) = v62;
                *(v63 + 2737) = 0;
                *(v63 + 2854) = 0;
                *(v63 + 2857) = 0;
                *(v63 + 2704) = -1;
                *(v63 + 2696) = 1;
                if (!v61)
                {
                  v68 = v64;
                  v83 = v66;
                  inited = resetFreqBandTables(v51, v64);
                  v66 = v83;
                  v64 = v68;
                  v62 = 0uLL;
                  if (inited)
                  {
                    break;
                  }
                }

                *(v63 + 2208) = 0;
                *(v63 + 2192) = v62;
                v69 = (v67 * v66);
                *(v63 + 2184) = 0;
                *(v63 + 1944) = v62;
                *(v63 + 1960) = v62;
                *(v63 + 1976) = v62;
                *(v63 + 1992) = v62;
                *(v63 + 2008) = v62;
                *(v63 + 2024) = v62;
                *(v63 + 2040) = v62;
                *(v63 + 2056) = v62;
                *(v63 + 2072) = v62;
                *(v63 + 2088) = v62;
                *(v63 + 2104) = v62;
                *(v63 + 2120) = v62;
                *(v63 + 2136) = v62;
                *(v63 + 2152) = v62;
                *(v63 + 2168) = v62;
                *(v63 + 2213) = v66;
                *(v63 + 2212) = 0;
                *(v63 + 2232) = 0;
                *(v63 + 2237) = 0;
                *(v63 + 2216) = v62;
                v70 = *(v51 + 44);
                v71 = *(v51 + 43);
                v72 = *(v51 + 45);
                v73 = *(v51 + 42);
                v74 = *(v51 + 12);
                *(v63 + 2872) = v60 + 16;
                *(v60 + 16) = v69;
                *(v60 + 88) = v86;
                if ((v66 - 15) > 1)
                {
                  v16 = 6;
                  goto LABEL_87;
                }

                if (!v61)
                {
                  v75 = v64;
                  resetLppTransposer((v60 + 16), v70, (v51 + 172), v71, v51 + 166, v73, v72, v74);
                  v64 = v75;
                  v62 = 0uLL;
                  if (inited)
                  {
                    break;
                  }
                }

                if ((v64 & 0x100) != 0)
                {
                  v76 = (v64 >> 7) & 1;
                  v77 = 0x40u / (2 * v76 + 2);
                  v78 = cdkCallocMatrix2D_aligned(v69, v77);
                  *(v63 + 13888) = v78;
                  if (!v78 || (*(v63 + 13896) = v78, v79 = cdkCallocMatrix2D_aligned(v69, v77), (*(v63 + 13904) = v79) == 0) || (v80 = cdkCallocMatrix2D_aligned(v69, v77), (*(v63 + 13912) = v80) == 0) || (v81 = cdkCallocMatrix2D_aligned(v69, v77), (*(v63 + 13920) = v81) == 0))
                  {
                    v16 = 4;
                    goto LABEL_87;
                  }

                  inited = QmfTransposerCreate(v63 + 13864, v85, v76);
                  v62 = 0uLL;
                  if (inited)
                  {
                    break;
                  }
                }

                ++v61;
                v60 = *(a1 + 8 * a7);
                if (v61 >= *(v60 + 108))
                {
                  goto LABEL_114;
                }
              }
            }

            v16 = inited;
LABEL_87:
            v15 = v84;
          }

          goto LABEL_88;
        }

        goto LABEL_41;
      }
    }

    v25 = 1;
    goto LABEL_33;
  }

LABEL_88:
  if (v14 >= *(a1 + 508) && v15 >= *(a1 + 512))
  {
    if (a7 <= 1)
    {
      v57 = *(a1 + 8 * a7);
      if (v57)
      {
        *(v57 + *(v57 + 113) + 112) = 1;
      }
    }
  }

  else
  {
    sbrDecoder_DestroyElement(a1, a7);
  }

  return v16;
}

uint64_t sbrGetHeaderData(uint64_t a1, int *a2, char a3, int a4, char a5)
{
  if (a5)
  {
    v16 = a2[1];
    v17 = a2[12];
    if (v16 < 9)
    {
      if (!v17)
      {
        v39 = a2[6];
        v40 = a2[5] - v16;
        a2[2] += v16;
        v41 = (a2[11] - 1) & (v39 - v16);
        a2[5] = v40;
        a2[6] = v41;
        goto LABEL_47;
      }

      if (!v16)
      {
LABEL_47:
        if (*(a2 + 48))
        {
          v42 = 8;
        }

        else
        {
          v42 = -8;
        }

        a2[2] += v42;
        v43 = a2[5];
        v44 = (a2[11] - 1) & (a2[6] + 8);
        *a2 = 0;
        a2[5] = v43 + 8;
        a2[6] = v44;
        v18 = CDK_get32((a2 + 2));
        *a2 = v18;
        v20 = v18 >> 31;
        v19 = 31;
        goto LABEL_51;
      }
    }

    else if (!v17)
    {
      v18 = *a2;
      v19 = v16 - 9;
      v20 = (v18 >> (v16 - 9)) & 1;
      a2[1] = v16 - 9;
      if (v16 == 9)
      {
        v18 = CDK_get32((a2 + 2));
        *a2 = v18;
        v21 = v18 >> 31;
        v22 = 31;
        goto LABEL_52;
      }

LABEL_51:
      v22 = v19 - 1;
      v21 = (v18 >> (v19 - 1)) & 1;
LABEL_52:
      a2[1] = v22;
      v45 = (v20 | (4 * v20)) + 6 * v21;
      v46 = a2[12];
      if (v22 <= v45)
      {
        if (!v46)
        {
          v49 = a2[6];
          v50 = a2[5] - v22;
          a2[2] += v22;
          v51 = (a2[11] - 1) & (v49 - v22);
          a2[5] = v50;
          a2[6] = v51;
          goto LABEL_65;
        }

        if (!v22)
        {
LABEL_65:
          *a2 = 0;
          if (*(a2 + 48))
          {
            v52 = v45;
          }

          else
          {
            v52 = -v45;
          }

          a2[2] += v52;
          v53 = (a2[11] - 1) & (a2[6] + v45);
          a2[5] += v45;
          a2[6] = v53;
          return 2;
        }
      }

      else if (!v46)
      {
        a2[1] = v22 - v45;
        return 2;
      }

      CDK_put((a2 + 2), v18, v22);
      goto LABEL_65;
    }

    CDK_put((a2 + 2), *a2, v16);
    goto LABEL_47;
  }

  v66 = *(a1 + 16);
  v7 = *(a1 + 17);
  v8 = *(a1 + 18);
  v9 = *(a1 + 19);
  v10 = *(a1 + 20);
  v11 = *(a1 + 35);
  if (a4)
  {
    v12 = 1;
  }

  else
  {
    v12 = (a3 & 0xC) == 0;
  }

  if (v12)
  {
    v13 = (a1 + 16);
  }

  else
  {
    v13 = (a1 + 25);
  }

  v14 = a2[1];
  if (4 - v14 <= 0)
  {
    LOBYTE(v15) = 0;
    v23 = *a2;
  }

  else
  {
    if (v14 == -28)
    {
      LOBYTE(v15) = 0;
    }

    else
    {
      v15 = *a2 << (4 - v14);
    }

    v23 = CDK_get32((a2 + 2));
    *a2 = v23;
    v14 = a2[1] + 32;
  }

  v24 = v14 - 4;
  a2[1] = v14 - 4;
  *v13 = ((v23 >> (v14 - 4)) | v15) & 0xF;
  if (8 - v14 < 1)
  {
    v25 = 0;
  }

  else
  {
    if (v14 == -24)
    {
      v25 = 0;
    }

    else
    {
      v25 = v23 << (8 - v14);
    }

    v23 = CDK_get32((a2 + 2));
    *a2 = v23;
    v24 = a2[1] + 32;
  }

  v26 = v24 - 4;
  a2[1] = v24 - 4;
  v13[1] = ((v23 >> (v24 - 4)) | v25) & 0xF;
  if (5 - v24 < 1)
  {
    v27 = 0;
  }

  else
  {
    if (v24 == -27)
    {
      v27 = 0;
    }

    else
    {
      v27 = v23 << (5 - v24);
    }

    v23 = CDK_get32((a2 + 2));
    *a2 = v23;
    v26 = a2[1] + 32;
  }

  v28 = v26 - 1;
  a2[1] = v26 - 1;
  v29 = (v23 >> (v26 - 1)) | v27;
  if (2 - v26 < 1)
  {
    v30 = 0;
  }

  else
  {
    if (v26 == -30)
    {
      v30 = 0;
    }

    else
    {
      v30 = v23 << (2 - v26);
    }

    v23 = CDK_get32((a2 + 2));
    *a2 = v23;
    v28 = a2[1] + 32;
  }

  v31 = v28 - 1;
  a2[1] = v28 - 1;
  v32 = (v23 >> (v28 - 1)) | v30;
  if (v29)
  {
    v65 = v7;
    v34 = v8;
    v35 = v9;
    v36 = v10;
    v37 = v11;
    if (3 - v28 < 1)
    {
      v38 = 0;
    }

    else
    {
      if (v28 == -29)
      {
        v38 = 0;
      }

      else
      {
        v38 = v23 << (3 - v28);
      }

      v23 = CDK_get32((a2 + 2));
      *a2 = v23;
      v31 = a2[1] + 32;
    }

    v47 = v31 - 2;
    a2[1] = v31 - 2;
    v13[2] = ((v23 >> (v31 - 2)) | v38) & 3;
    if (3 - v31 < 1)
    {
      v48 = 0;
    }

    else
    {
      if (v31 == -29)
      {
        v48 = 0;
      }

      else
      {
        v48 = v23 << (3 - v31);
      }

      v23 = CDK_get32((a2 + 2));
      *a2 = v23;
      v47 = a2[1] + 32;
    }

    v11 = v37;
    v55 = v47 - 1;
    a2[1] = v47 - 1;
    v13[3] = ((v23 >> (v47 - 1)) | v48) & 1;
    v10 = v36;
    if (3 - v47 < 1)
    {
      v56 = 0;
    }

    else
    {
      if (v47 == -29)
      {
        v56 = 0;
      }

      else
      {
        v56 = v23 << (3 - v47);
      }

      v23 = CDK_get32((a2 + 2));
      *a2 = v23;
      v55 = a2[1] + 32;
    }

    v9 = v35;
    v31 = v55 - 2;
    a2[1] = v31;
    v33 = ((v23 >> v31) | v56) & 3;
    v8 = v34;
    v7 = v65;
  }

  else
  {
    *(v13 + 1) = 258;
    v33 = 2;
  }

  v13[4] = v33;
  if (v32)
  {
    if (2 - v31 < 1)
    {
      v58 = 0;
    }

    else
    {
      if (v31 == -30)
      {
        v58 = 0;
      }

      else
      {
        v58 = v23 << (2 - v31);
      }

      v23 = CDK_get32((a2 + 2));
      *a2 = v23;
      v31 = a2[1] + 32;
    }

    v59 = v31 - 2;
    a2[1] = v31 - 2;
    v13[5] = ((v23 >> (v31 - 2)) | v58) & 3;
    if (4 - v31 < 1)
    {
      v60 = 0;
    }

    else
    {
      if (v31 == -28)
      {
        v60 = 0;
      }

      else
      {
        v60 = v23 << (4 - v31);
      }

      v23 = CDK_get32((a2 + 2));
      *a2 = v23;
      v59 = a2[1] + 32;
    }

    v61 = v59 - 2;
    a2[1] = v59 - 2;
    v13[6] = ((v23 >> (v59 - 2)) | v60) & 3;
    if (3 - v59 < 1)
    {
      v62 = 0;
    }

    else
    {
      if (v59 == -29)
      {
        v62 = 0;
      }

      else
      {
        v62 = v23 << (3 - v59);
      }

      v23 = CDK_get32((a2 + 2));
      *a2 = v23;
      v61 = a2[1] + 32;
    }

    v63 = v61 - 1;
    a2[1] = v61 - 1;
    v13[7] = ((v23 >> (v61 - 1)) | v62) & 1;
    if (2 - v61 < 1)
    {
      v64 = 0;
    }

    else
    {
      if (v61 == -30)
      {
        v64 = 0;
      }

      else
      {
        v64 = v23 << (2 - v61);
      }

      v23 = CDK_get32((a2 + 2));
      *a2 = v23;
      v63 = a2[1] + 32;
    }

    a2[1] = v63 - 1;
    v57 = ((v23 >> (v63 - 1)) | v64) & 1;
  }

  else
  {
    *(v13 + 5) = 514;
    v57 = 1;
    v13[7] = 1;
  }

  v13[8] = v57;
  if (*a1 < 2 || v66 != *v13 || v7 != v13[1] || v8 != v13[2] || v9 != v13[3] || v10 != v13[4])
  {
    return 3;
  }

  if (v11 == *(a1 + 35))
  {
    return 2;
  }

  return 3;
}

uint64_t initHeaderData(uint64_t a1, int a2, int a3, int a4, int a5, char a6, int a7)
{
  v7 = a4 * a3;
  if ((a6 & 0xC) != 0)
  {
LABEL_5:
    v10 = a4 * a3;
  }

  else
  {
    v8 = 11;
    while (1)
    {
      v9 = v8;
      if (stdSampleRatesMapping[2 * v8] <= v7)
      {
        break;
      }

      --v8;
      if (!v9)
      {
        goto LABEL_5;
      }
    }

    v10 = stdSampleRatesMapping[2 * v8 + 1];
  }

  if (a2 == a3)
  {
    *(a1 + 12) = 2 * v10;
LABEL_9:
    v11 = 32;
    goto LABEL_10;
  }

  *(a1 + 12) = v10;
  if (a2 == a3 >> 1)
  {
    goto LABEL_9;
  }

  if (a2 == a3 >> 2)
  {
    v11 = 16;
  }

  else
  {
    if (a2 != (3 * a3) >> 3)
    {
      return 6;
    }

    v11 = 24;
  }

LABEL_10:
  v12 = v11 / a4;
  if (a7)
  {
    *a1 = 0;
    *(a1 + 4) = 0;
    *(a1 + 34) = 1;
    *(a1 + 16) = 0x102020201000005;
    *(a1 + 24) = 1;
    if (v7 > 95999)
    {
      v13 = 4;
LABEL_15:
      *(a1 + 16) = v13;
      *(a1 + 17) = 3;
      goto LABEL_16;
    }

    if (v7 >= 24001)
    {
      v13 = 7;
      goto LABEL_15;
    }
  }

LABEL_16:
  v14 = a3 >> 2;
  if (a6)
  {
    v15 = 1;
  }

  else
  {
    v15 = 2;
  }

  if (v14 == a2)
  {
    v15 = 4;
  }

  v16 = (a5 / v12) >> (v15 - 1);
  *(a1 + 8) = v15;
  *(a1 + 64) = a1 + 80;
  *(a1 + 72) = a1 + 109;
  if (v16 <= 0x10u)
  {
    v17 = 0;
  }

  else
  {
    v17 = 6;
  }

  *(a1 + 6) = v16;
  *(a1 + 7) = v12;
  if (v14 == a2)
  {
    *(a1 + 6) = 2 * v16;
  }

  return v17;
}

char *cdkCallocMatrix2D_aligned(size_t count, int a2)
{
  if (!count)
  {
    return 0;
  }

  v3 = count;
  v4 = count;
  v5 = malloc_type_calloc(count, 8uLL, 0x5142B0E1uLL);
  if (!v5)
  {
    return v5;
  }

  v6 = (4 * a2);
  v7 = malloc_type_calloc(1uLL, (v6 * v3 + 16), 0x5142B0E1uLL);
  if (!v7)
  {
    free(v5);
    return 0;
  }

  v8 = 0;
  v9 = v7 + (-(v7 + 8) & 7) + 8;
  *(v7 + (-(v7 + 8) & 7)) = v7;
  do
  {
    *&v5[v8] = v9;
    v9 += v6;
    v8 += 8;
  }

  while (8 * v4 != v8);
  return v5;
}

uint64_t QmfTransposerCreate(uint64_t result, unsigned int a2, int a3)
{
  if (result)
  {
    v5 = result;
    v6 = malloc_type_calloc(1uLL, 0xA88uLL, 0x5142B0E1uLL);
    if (v6)
    {
      v7 = v6;
      v6[334] = 0x100000001;
      *(v6 + 670) = 1;
      v8 = ((2 * a3 + 2) * a2) >> 6;
      if (a2 == 768)
      {
        v8 = 32;
      }

      *(v6 + 10) = v8;
      *(v6 + 11) = a2 / v8;
      *(v6 + 7) = a2;
      *(v6 + 8) = 13;
      *(v6 + 9) = (v8 & 0x3FFFFFE) + 24;
      v9 = malloc_type_calloc(0x55uLL, 4uLL, 0x5142B0E1uLL);
      *(v7 + 64) = v9;
      if (v9)
      {
        *(v7 + 72) = malloc_type_calloc(*(v7 + 32), 8uLL, 0x5142B0E1uLL);
        v10 = malloc_type_calloc(*(v7 + 32), 8uLL, 0x5142B0E1uLL);
        *(v7 + 80) = v10;
        if (*(v7 + 72))
        {
          if (v10)
          {
            if (*(v7 + 32) < 1)
            {
LABEL_19:
              *(v7 + 2656) = malloc_type_calloc(0xBuLL, 8uLL, 0x5142B0E1uLL);
              v18 = malloc_type_calloc(0xBuLL, 8uLL, 0x5142B0E1uLL);
              *(v7 + 2664) = v18;
              if (*(v7 + 2656) && v18)
              {
                v19 = 0;
                while (1)
                {
                  *(*(v7 + 2656) + v19) = malloc_type_calloc(0x40uLL, 4uLL, 0x5142B0E1uLL);
                  *(*(v7 + 2664) + v19) = malloc_type_calloc(0x40uLL, 4uLL, 0x5142B0E1uLL);
                  if (!*(*(v7 + 2656) + v19) || !*(*(v7 + 2664) + v19))
                  {
                    break;
                  }

                  v19 += 8;
                  if (v19 == 88)
                  {
                    v20 = malloc_type_calloc(0x20uLL, 4uLL, 0x5142B0E1uLL);
                    *(v7 + 88) = v20;
                    if (!v20)
                    {
                      break;
                    }

                    result = 0;
                    *(v7 + 56) = a3;
                    *v5 = v7;
                    return result;
                  }
                }
              }
            }

            else
            {
              v11 = 0;
              while (1)
              {
                v12 = malloc_type_calloc(1uLL, 0x110uLL, 0x5142B0E1uLL);
                if (v12)
                {
                  v13 = -(v12 + 8) & 7;
                  v14 = &v12[v13 + 8];
                  *&v12[v13] = v12;
                }

                else
                {
                  v14 = 0;
                }

                *(*(v7 + 72) + 8 * v11) = v14;
                v15 = malloc_type_calloc(1uLL, 0x110uLL, 0x5142B0E1uLL);
                if (v15)
                {
                  v16 = -(v15 + 8) & 7;
                  v17 = &v15[v16 + 8];
                  *&v15[v16] = v15;
                }

                else
                {
                  v17 = 0;
                }

                *(*(v7 + 80) + 8 * v11) = v17;
                if (!*(*(v7 + 72) + 8 * v11) || !*(*(v7 + 80) + 8 * v11))
                {
                  break;
                }

                if (++v11 >= *(v7 + 32))
                {
                  goto LABEL_19;
                }
              }
            }
          }
        }
      }

      QmfTransposerClose(v7);
    }

    return 4;
  }

  return result;
}

double resetLppTransposer(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int a4, uint64_t a5, unsigned int a6, unsigned int a7, unsigned int a8)
{
  v9 = a1 + 14;
  v10 = *a1;
  v11 = *a3;
  v12 = a3[a4];
  if (a7 >= v12)
  {
    v13 = a3[a4];
  }

  else
  {
    v13 = a7;
  }

  if (v10 == 64)
  {
    if (v11 < 4)
    {
      return result;
    }
  }

  else if (v11 < 5)
  {
    return result;
  }

  v14 = (0x3E8000 / a8 + 1) >> 1;
  v15 = *a3;
  if (v11 < v14)
  {
    v15 = a3[a4];
    if (v12 > v14)
    {
      v16 = 0;
      do
      {
        v17 = v16;
        v18 = a3[v16++];
      }

      while (v18 < v14);
      v15 = a3[v17];
    }
  }

  if (v13 <= a2)
  {
    a1[1] = 0;
    a1[2] = a2;
    a1[3] = 0;
LABEL_45:
    if (!a6)
    {
      goto LABEL_49;
    }

    v37 = a1 + 4;
    v38 = a6;
    v39 = (a5 + 1);
    do
    {
      v40 = *v39++;
      *v37++ = v40;
      --v38;
    }

    while (v38);
    if (a6 <= 9)
    {
LABEL_49:
      memset(&a1[a6 + 4], 255, 10 - a6);
    }

    result = 0.0000976562733;
    *(a1 + 52) = xmmword_19B0B34B0;
    *(a1 + 17) = 1065017672;
  }

  else
  {
    v19 = 0;
    v20 = a4;
    v21 = a2 - v11 + 1;
    while (v19 <= 6)
    {
      v22 = &v9[6 * v19];
      v22[2] = a2;
      v22[3] = a2;
      v23 = v15 - a2;
      v24 = v15 - a2;
      if ((v15 - a2) >= (v11 - v21))
      {
        v25 = ((a2 - v21) & 0xFE) + v11;
        v26 = *a3;
        if (v26 < v25)
        {
          v26 = a3[v20];
          if (v26 > v25)
          {
            v27 = v20;
            do
            {
              v28 = v27;
              v29 = a3[v27--];
            }

            while (v29 > v25);
            v26 = a3[v28];
          }
        }

        v24 = v26 - a2;
      }

      if (v10 == 64 && !v24 && v21 == 1)
      {
        break;
      }

      if (v24 >= 1)
      {
        v30 = (a2 - v11 + v24 + 1) & 0xFE;
        *v22 = a2 - v30;
        v22[4] = v30;
        v22[5] = v24;
        v22[1] = a2 - v30 + v24;
        a2 += v24;
        ++v19;
        v23 = v15 - a2;
      }

      if (v23 < 3)
      {
        v15 = v13;
      }

      v21 = 1;
      if (a2 >= v13)
      {
        LODWORD(v31) = v19 - 1;
        if (v19 < 2)
        {
          goto LABEL_36;
        }

        if (v9[6 * v31 + 5] <= 2u)
        {
          LOBYTE(a2) = v9[6 * (v19 - 2) + 5] + v9[6 * (v19 - 2) + 3];
          LODWORD(v31) = v19 - 2;
        }

        if (v31 <= 5)
        {
LABEL_36:
          v32 = v31;
          LOWORD(v31) = v31 + 1;
          a1[1] = v32 + 1;
          a1[2] = a2;
          a1[3] = 0;
          if ((v31 & 0x100) == 0)
          {
            v33 = 0;
            v31 = v31;
            v34 = a1 + 15;
            do
            {
              if (a2 >= *(v34 - 1))
              {
                LOBYTE(a2) = *(v34 - 1);
              }

              v36 = *v34;
              v34 += 6;
              v35 = v36;
              if (v33 <= v36)
              {
                v33 = v35;
              }

              --v31;
            }

            while (v31);
            a1[2] = a2;
            a1[3] = v33;
          }

          goto LABEL_45;
        }

        return result;
      }
    }
  }

  return result;
}

uint64_t resetFreqBandTables(uint64_t a1, unsigned int a2)
{
  v127 = *MEMORY[0x1E69E9840];
  v3 = *(a1 + 12);
  v4 = (a2 >> 7) & 1;
  v5 = v3 >> ((a2 & 0x80) != 0);
  v6 = a2 & 0xC;
  if ((a2 & 0xC) != 0)
  {
    v7 = 9;
    while (1)
    {
      v8 = v7;
      if (stdSampleRatesMappingUsac[2 * v7] <= v5)
      {
        break;
      }

      --v7;
      if (!v8)
      {
        goto LABEL_7;
      }
    }

    v9 = stdSampleRatesMappingUsac[2 * v7 + 1];
  }

  else
  {
    v4 = 0;
LABEL_7:
    v9 = v3 >> ((a2 & 0x80) != 0);
  }

  if (v9 > 44099)
  {
    if (v9 <= 63999)
    {
      if (v9 == 44100)
      {
        v10 = &CDK_sbrDecoder_sbr_start_freq_44;
      }

      else
      {
        if (v9 != 48000)
        {
          return 6;
        }

        v10 = &CDK_sbrDecoder_sbr_start_freq_48;
      }
    }

    else
    {
      v10 = &CDK_sbrDecoder_sbr_start_freq_88;
      if (v9 != 96000 && v9 != 88200)
      {
        if (v9 != 64000)
        {
          return 6;
        }

        v10 = &CDK_sbrDecoder_sbr_start_freq_64;
      }
    }
  }

  else if (v9 <= 23999)
  {
    if (v9 == 16000)
    {
      v10 = &CDK_sbrDecoder_sbr_start_freq_16;
    }

    else
    {
      if (v9 != 22050)
      {
        return 6;
      }

      v10 = &CDK_sbrDecoder_sbr_start_freq_22;
    }
  }

  else
  {
    switch(v9)
    {
      case 24000:
        v10 = &CDK_sbrDecoder_sbr_start_freq_24;
        break;
      case 32000:
        v10 = &CDK_sbrDecoder_sbr_start_freq_32;
        break;
      case 40000:
        v10 = &CDK_sbrDecoder_sbr_start_freq_40;
        break;
      default:
        return 6;
    }
  }

  v11 = v10[16 * v4 + *(a1 + 16)];
  if (v11 == 255)
  {
    return 6;
  }

  v12 = a2 & 0x80;
  v13 = *(a1 + 17);
  if (v13 > 0xD)
  {
    v28 = 3 * v11;
    if (v13 == 14)
    {
      v28 = 2 * v11;
    }
  }

  else
  {
    *&v14 = 0xAAAAAAAAAAAAAAAALL;
    *(&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *&v125[63] = v14;
    *&v125[32] = v14;
    *&v125[48] = v14;
    *v125 = v14;
    *&v125[16] = v14;
    if ((a2 & 0x80) != 0)
    {
      v15 = 1280000;
    }

    else
    {
      v15 = 2560000;
    }

    if ((a2 & 0x80) != 0)
    {
      v16 = 1024000;
    }

    else
    {
      v16 = 2048000;
    }

    if (v5 >> 9 <= 0x7C)
    {
      v17 = v16;
    }

    else
    {
      v17 = v15;
    }

    if ((a2 & 0x80) != 0)
    {
      v18 = 768000;
    }

    else
    {
      v18 = 1536000;
    }

    if (v5 >> 8 <= 0x7C)
    {
      v19 = v18;
    }

    else
    {
      v19 = v17;
    }

    v20 = v19 / v5 + 1;
    v21 = pow(vcvts_n_f32_u32((v20 >> 1), 6uLL), 0.0769230798);
    LOBYTE(v22) = 64;
    v23 = 64.0;
    v24 = 12;
    do
    {
      v23 = v23 * v21;
      v125[v24] = v22 - (v23 + 0.5);
      v25 = v24-- + 1;
      v22 = (v23 + 0.5);
    }

    while (v25 > 1);
    v26 = v20 >> 1;
    shellsort(v125, 13);
    v27 = 0;
    v125[29] = v20 >> 1;
    do
    {
      v26 += v125[v27];
      v125[v27++ + 30] = v26;
    }

    while (v27 != 13);
    v28 = v125[v13 + 29];
  }

  if ((v28 & 0xC0) != 0)
  {
    v29 = 64;
  }

  else
  {
    v29 = v28;
  }

  v30 = v29 - v11;
  v32 = v29 <= v11 || v30 > 56;
  if (v12 || v32)
  {
    if (v32)
    {
      return 6;
    }
  }

  else
  {
    if (v6)
    {
      if (v3 >> 4 >= 0xA41 && v30 > 35)
      {
        return 6;
      }

      if (v3 < 0xB3B9)
      {
        goto LABEL_71;
      }
    }

    else
    {
      if (v3 == 44100 && v30 > 35)
      {
        return 6;
      }

      if (v3 >> 7 < 0x177)
      {
        goto LABEL_71;
      }
    }

    if (v30 > 32)
    {
      return 6;
    }
  }

LABEL_71:
  *&v33 = 0xAAAAAAAAAAAAAAAALL;
  *(&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *&v124[15] = v33;
  v123[1] = v33;
  *v124 = v33;
  __b = v33;
  v123[0] = v33;
  v34 = *(a1 + 18);
  if (*(a1 + 18))
  {
    v121 = (a1 + 172);
    v35 = 12.0;
    v36 = 8.0;
    if (v34 == 2)
    {
      v36 = 10.0;
    }

    if (v34 != 1)
    {
      v35 = v36;
    }

    if (v35 <= v11 || v12 == 0)
    {
      v38 = v35;
    }

    else
    {
      v38 = (v11 & 0xFE);
    }

    if (1000 * v29 <= 2245 * v11)
    {
      v60 = log(v29);
      v61 = (log(v11) * -1.44269504 + v60 * 1.44269504) * v38;
      v42 = 2 * ((v61 * 0.5) + 0.5);
      v62 = (2 * ((v61 * 0.5) + 0.5));
      if (!(2 * ((v61 * 0.5) + 0.5)))
      {
        return 6;
      }

      CalcBands(&__b, v11, v29, (2 * ((v61 * 0.5) + 0.5)));
      shellsort(&__b, v42);
      if (!__b)
      {
        return 6;
      }

      *v121 = v11;
      if (!v42)
      {
        *(a1 + 43) = 0;
        return 6;
      }

      v63 = (a1 + 173);
      p_b = &__b;
      v65 = v11;
      do
      {
        v66 = *p_b++;
        v65 += v66;
        *v63++ = v65;
        --v62;
      }

      while (v62);
    }

    else
    {
      v39 = 2 * v11;
      v40 = log((2 * v11));
      v41 = (log(v11) * -1.44269504 + v40 * 1.44269504) * v38;
      v42 = ((v41 * 0.5) + 0.5);
      v43 = *(a1 + 19);
      v44 = (v40 * -1.44269504 + log(v29) * 1.44269504) * v38;
      if (v43)
      {
        v44 = v44 / 1.3;
      }

      v45 = 2 * (v42 & 0x7F);
      if (!v45)
      {
        return 6;
      }

      v46 = 2 * ((v44 * 0.5) + 0.5);
      v47 = (2 * ((v44 * 0.5) + 0.5));
      if (!(2 * ((v44 * 0.5) + 0.5)))
      {
        return 6;
      }

      CalcBands(&__b, v11, (2 * v11), (2 * v42));
      shellsort(&__b, (2 * v42));
      if (!__b)
      {
        return 6;
      }

      *v121 = v11;
      if (2 * v42)
      {
        v48 = (a1 + 173);
        v49 = &__b;
        v50 = 2 * (v42 & 0x7F);
        v51 = v11;
        do
        {
          v52 = *v49++;
          v51 += v52;
          *v48++ = v51;
          --v50;
        }

        while (v50);
      }

      CalcBands(v123 + 13, (2 * v11), v29, v46);
      shellsort(v123 + 13, v46);
      v54 = *(&v123[-1] + v45 - 1);
      v105 = v54 >= BYTE13(v123[0]);
      v55 = v54 - BYTE13(v123[0]);
      if (v55 != 0 && v105)
      {
        v56 = v123 + v47 + 13;
        if (v55 >= (*(v56 - 1) - BYTE13(v123[0]) + (((*(v56 - 1) - BYTE13(v123[0])) & 0x8000u) >> 15)) >> 1)
        {
          LOBYTE(v55) = (*(v56 - 1) - BYTE13(v123[0]) + (((*(v56 - 1) - BYTE13(v123[0])) & 0x8000u) >> 15)) >> 1;
        }

        BYTE13(v123[0]) += v55;
        *(v56 - 1) -= v55;
        shellsort(v123 + 13, v46);
      }

      v121[2 * (v42 & 0x7F)] = v39;
      if (v46)
      {
        v57 = (v45 + a1 + 173);
        v58 = v123 + 13;
        do
        {
          v59 = *v58++;
          v39 += v59;
          *v57++ = v39;
          --v47;
        }

        while (v47);
      }

      LOBYTE(v42) = v46 + 2 * v42;
    }
  }

  else
  {
    v67 = vcvts_n_f32_s32(v30, 1uLL);
    v68 = vcvts_n_f32_s32(v30, 2uLL) + 0.5;
    if (*(a1 + 19))
    {
      v67 = v68;
    }

    v42 = 2 * v67;
    if (!(2 * v67))
    {
      return 6;
    }

    v69 = (2 * v67) << (*(a1 + 19) != 0);
    if (*(a1 + 19))
    {
      v70 = 2;
    }

    else
    {
      v70 = 1;
    }

    memset(&__b, v70, 2 * (v67 & 0x7Fu));
    v71 = v42;
    v72 = v29 - v11 - v69;
    v73 = v72 >> 31;
    if (v72 > 0)
    {
      v73 = -1;
    }

    if (v72)
    {
      v74 = v72 <= 0;
      if (v72 >= 0)
      {
        v75 = v42;
      }

      else
      {
        v75 = 0;
      }

      if (!v74)
      {
        v75 = v42 - 1;
      }

      v76 = v69 + v11 - v29;
      do
      {
        *(&v123[-1] + v75) -= v73;
        v75 += v73;
        v76 -= v73;
      }

      while (v76);
    }

    *(a1 + 172) = v11;
    v77 = (a1 + 173);
    v78 = &__b;
    v79 = v11;
    do
    {
      v80 = *v78++;
      v79 += v80;
      *v77++ = v79;
      --v71;
    }

    while (v71);
  }

  *(a1 + 43) = v42;
  if (!v12 || !v42)
  {
    if (v42)
    {
      goto LABEL_137;
    }

    return 6;
  }

  if (v42 >= 2u)
  {
    v81 = v42 - 1;
    v82 = (a1 + 173);
    while (*v82 - *(v82 - 1) <= (v11 - 2))
    {
      ++v82;
      if (!--v81)
      {
        goto LABEL_137;
      }
    }

    return 6;
  }

LABEL_137:
  v83 = *(a1 + 35);
  if (v83 > v42)
  {
    return 6;
  }

  v84 = *(a1 + 72);
  v85 = (v83 + a1 + 172);
  v86 = v42 - v83 + 1;
  do
  {
    v87 = *v85++;
    *v84++ = v87;
    --v86;
  }

  while (v86);
  v88 = v42 - v83;
  v89 = *(a1 + 64);
  v90 = *(a1 + 72);
  if (v88)
  {
    v95 = *v90;
    v94 = v90 + 1;
    v96 = v88 + 1;
    *v89 = v95;
    v97 = v89 + 1;
    v98 = (v88 + 1) >> 1;
    do
    {
      v99 = *v94;
      v94 += 2;
      *v97++ = v99;
      --v98;
    }

    while (v98);
    v91 = v96 >> 1;
    *(a1 + 40) = v96 >> 1;
    *(a1 + 41) = v88;
  }

  else
  {
    v91 = v88 >> 1;
    v92 = (v91 + 1);
    do
    {
      v93 = *v90;
      v90 += 2;
      *v89++ = v93;
      --v92;
    }

    while (v92);
    *(a1 + 40) = v91;
    *(a1 + 41) = v88;
    if (v88 < 2u)
    {
      return 6;
    }
  }

  if (*(a1 + 7) == 16)
  {
    v100 = 28;
  }

  else
  {
    v100 = 24;
  }

  if (v100 < v91)
  {
    return 6;
  }

  v101 = *(a1 + 64);
  v102 = *v101;
  v103 = v101[v91];
  v104 = v12 ? 16 : 32;
  v105 = v104 < v102 || v102 >= v103;
  if (v105)
  {
    return 6;
  }

  v106 = *(a1 + 20);
  if (*(a1 + 20))
  {
    v107 = *(a1 + 72);
    LOBYTE(v53) = v107[v88];
    *&v108 = log(v53);
    v109 = *&v108;
    LOBYTE(v108) = *v107;
    v110 = log(v108) * -1.44269504 + v109 * 1.44269504;
    if (((v106 * v110) + 0.5) <= 1)
    {
      LOBYTE(v111) = 1;
    }

    else
    {
      LOBYTE(v111) = ((v106 * v110) + 0.5);
    }

    *(a1 + 42) = v111;
    *(a1 + 61) = v111;
    if (v111 > 5u)
    {
      return 6;
    }
  }

  else
  {
    LOBYTE(v111) = 1;
    *(a1 + 42) = 1;
    *(a1 + 61) = 1;
  }

  *&v113 = 0xAAAAAAAAAAAAAAAALL;
  *(&v113 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *&v126[12] = v113;
  *v126 = v113;
  *&v125[68] = v113;
  *&v125[52] = v113;
  *&v125[36] = v113;
  *&v125[20] = v113;
  *&v125[4] = v113;
  *v125 = 0;
  if (v91)
  {
    v114 = 0;
    v111 = v111;
    v115 = &v125[4];
    v116 = -1;
    do
    {
      v117 = v91 / v111--;
      v114 += v117;
      *v115++ = v114;
      ++v116;
      v118 = __OFSUB__(v91, v117);
      v91 -= v117;
    }

    while (!((v91 < 0) ^ v118 | (v91 == 0)));
    v119 = (v116 + 2);
  }

  else
  {
    v119 = 1;
  }

  v120 = 0;
  do
  {
    *(a1 + 166 + v120) = v101[*&v125[4 * v120]];
    ++v120;
  }

  while (v119 != v120);
  result = 0;
  *(a1 + 46) = *(a1 + 45);
  *(a1 + 44) = v102;
  *(a1 + 45) = v103;
  return result;
}

void CalcBands(unsigned __int8 *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  v5 = a3;
  v7 = a3;
  v8 = pow((a2 / a3), (1.0 / a4));
  if (a4)
  {
    v9 = v8;
    v10 = a4;
    do
    {
      v7 = v7 * v9;
      v11 = v5 - (v7 + 0.5);
      v5 = (v7 + 0.5);
      a1[v10 - 1] = v11;
    }

    while (v10-- > 1);
  }
}

uint64_t shellsort(uint64_t result, int a2)
{
  v2 = 1;
  do
  {
    v3 = 3 * v2;
    v2 = 3 * v2 + 1;
  }

  while (v3 < a2);
  do
  {
    v4 = v2 / 3;
    if (v2 / 3 < a2)
    {
      v5 = 0;
      v6 = v4;
      do
      {
        v7 = *(result + v6);
        v8 = v5;
        while (1)
        {
          v9 = *(result + v8);
          if (v9 <= v7)
          {
            break;
          }

          v10 = v8;
          *(result + v4 + v8) = v9;
          v11 = __OFSUB__(v8, v4);
          v8 -= v4;
          if (v8 < 0 != v11)
          {
            goto LABEL_11;
          }
        }

        v10 = v4 + v8;
LABEL_11:
        *(result + v10) = v7;
        ++v6;
        ++v5;
      }

      while (v6 != a2);
    }

    v12 = v2 <= 5;
    v2 /= 3;
  }

  while (!v12);
  return result;
}

uint64_t aacDecoder_CtrlCFGChangeCallback(_BYTE *a1, char *a2)
{
  if (!a1)
  {
    return 513;
  }

  result = 0;
  v4 = *a2;
  v5 = a2[3];
  v6 = a2[2];
  a1[2024] = a2[1];
  a1[2025] = v4;
  a1[2026] = v5;
  a1[2027] = v6;
  return result;
}

uint64_t aacDecoder_FreeMemCallback(uint64_t a1)
{
  if (!a1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "INT aacDecoder_FreeMemCallback(void *, const CSAudioSpecificConfig *)";
    exception[2] = 214;
  }

  CAacDecoder_DeInit(a1);
  v2 = *(a1 + 832);
  if (v2)
  {
    sbrDecoder_DestroyElement(v2, 0);
    sbrDecoder_DestroyElement(*(a1 + 832), 1);
    v3 = *(a1 + 832);
    *(v3 + 16) = 0;
    *(v3 + 256) = 0;
  }

  v4 = *(a1 + 1912);
  if (v4)
  {
    SpatialDecClose(*(v4 + 168));
    *(v4 + 168) = 0;
  }

  CDK_QmfDomain_FreeWorkBuffer((a1 + 864));
  CDK_QmfDomain_FreePersistentMemory(a1 + 864);
  *(a1 + 1016) = 0;
  *(a1 + 984) = 0u;
  *(a1 + 1000) = 0u;
  *(a1 + 952) = 0u;
  *(a1 + 968) = 0u;
  *(a1 + 1080) = 0u;
  *(a1 + 1096) = 0u;
  *(a1 + 1112) = 0u;
  *(a1 + 1128) = 0u;
  *(a1 + 1144) = 0;
  *(a1 + 1200) = 0u;
  *(a1 + 1216) = 0u;
  *(a1 + 1232) = 0u;
  *(a1 + 1248) = 0u;
  *(a1 + 1264) = 0;
  *(a1 + 1280) = 0u;
  *(a1 + 1296) = 0u;
  *(a1 + 1312) = 0u;
  *(a1 + 1328) = 0u;
  *(a1 + 1344) = 0;
  *(a1 + 868) = 0;
  *(a1 + 864) = 0;
  *(a1 + 934) = 0;
  *(a1 + 920) = 0u;
  return 0;
}

uint64_t aacDecoder_ConfigCallback(uint64_t SamplingRateInfo, uint64_t a2, char a3, _BYTE *a4)
{
  if (!SamplingRateInfo)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "INT aacDecoder_ConfigCallback(void *, const CSAudioSpecificConfig *, UCHAR, UCHAR *)";
    v117 = 183;
    goto LABEL_252;
  }

  v7 = SamplingRateInfo;
  v8 = *(SamplingRateInfo + 826);
  v9 = *(a2 + 772);
  ChanElementList = 8194;
  if (v9 > 28)
  {
    if (v9 != 29 && v9 != 42)
    {
      goto LABEL_239;
    }
  }

  else if (v9 == 2)
  {
    *(SamplingRateInfo + 324) = 1;
  }

  else if (v9 != 5)
  {
    goto LABEL_239;
  }

  *(SamplingRateInfo + 281) = 0;
  v11 = *(a2 + 796);
  v12 = v11;
  v13 = *(a2 + 796);
  if ((v11 - 1) >= 2)
  {
    if (*(a2 + 796) || *(a2 + 772) != 42)
    {
      goto LABEL_238;
    }

    *(SamplingRateInfo + 280) = 0;
    v13 = *(a2 + 3);
  }

  v14 = 0;
  v15 = v13;
  v16 = *(a2 + 772);
  if (v16 != 150)
  {
    if (v16 != 42)
    {
      v18 = 0;
      goto LABEL_32;
    }

    if (v13 >= 2u)
    {
      v14 = 2;
    }

    else
    {
      v14 = v13;
    }
  }

  v17 = *(a2 + 8);
  if (v17 < 1)
  {
    v18 = 0;
  }

  else
  {
    v18 = 0;
    v19 = (a2 + 17);
    do
    {
      v20 = v19[3];
      if (v20 == 2)
      {
        if (*v19)
        {
          v18 += *(a2 + 780);
        }

        if (*(a2 + 1) == 4)
        {
          v18 += 96;
        }
      }

      else if (v20 == 1)
      {
        --v15;
      }

      v19 += 24;
      --v17;
    }

    while (v17);
  }

LABEL_32:
  if (v15 < 1)
  {
LABEL_238:
    ChanElementList = 8199;
    goto LABEL_239;
  }

  ChanElementList = 8199;
  if (v12 > 2 || v15 > 2)
  {
    goto LABEL_239;
  }

  *(SamplingRateInfo + 68) = 0u;
  v21 = (SamplingRateInfo + 68);
  *(SamplingRateInfo + 116) = 0u;
  *(SamplingRateInfo + 132) = 0u;
  *(SamplingRateInfo + 84) = 0u;
  *(SamplingRateInfo + 100) = 0u;
  v22 = *(a2 + 796);
  v23 = *(a2 + 772);
  if (v22 <= 0)
  {
    if (v23 != 42 && v23 != 150)
    {
      v26 = 0;
      goto LABEL_94;
    }

    goto LABEL_43;
  }

  if (v23 == 42 || v23 == 150)
  {
LABEL_43:
    *(SamplingRateInfo + 800) = a2;
    LODWORD(v28) = *(a2 + 8);
    if (v28 > 0x13)
    {
      goto LABEL_44;
    }

    v26 = *(SamplingRateInfo + 776) != v28;
    if ((a3 & 2) != 0)
    {
      *(SamplingRateInfo + 776) = v28;
      LODWORD(v28) = *(a2 + 8);
    }

    *(SamplingRateInfo + 1921) = 0;
    if (v28 >= 1)
    {
      v29 = 0;
      v30 = (SamplingRateInfo + 148);
      v31 = SamplingRateInfo + 780;
      v32 = (a2 + 20);
      v33 = 12;
      v34 = a2;
      do
      {
        v35 = *(v34 + v33);
        if (*v30 != v35 || *(v31 + v29) != *v32)
        {
          v26 = 1;
        }

        if ((a3 & 2) != 0)
        {
          *v30 = v35;
          v37 = *v32;
          *(v31 + v29) = v37;
          if (*v30 == 17)
          {
            *(SamplingRateInfo + 1921) |= v37 != 0;
          }
        }

        v38 = *(v30 - 19) | (2 * (*(v32 - 4) != 0));
        *(v30 - 19) = v38;
        v39 = v38 | (16 * (*v32 != 0));
        *(v30 - 19) = v39;
        v40 = v39 | (4 * (*(v32 - 2) != 0));
        *(v30 - 19) = v40;
        v41 = v40 | (8 * (*(v32 - 1) != 0));
        *(v30 - 19) = v41;
        v42 = v41 | (32 * (*(v32 - 2) == 18));
        *(v30 - 19) = v42;
        v43 = v42 | ((*(v32 - 2) == 18) << 13);
        *(v30 - 19) = v43;
        if (*(v32 - 2) == 17 && !*(v31 + v29))
        {
          *(v30 - 19) = v43 | 0x40;
        }

        ++v29;
        v34 = *(SamplingRateInfo + 800);
        v28 = *(v34 + 8);
        ++v30;
        v32 += 24;
        v33 += 24;
      }

      while (v29 < v28);
    }

    *(SamplingRateInfo + 2028) = 0;
    if (v28)
    {
      *(SamplingRateInfo + 2028) = *(a2 + 33);
    }

    if ((a3 & 2) != 0)
    {
      *(SamplingRateInfo + 4 * v28 + 148) = 7;
    }

    goto LABEL_65;
  }

  v24 = 0;
  v25 = &elementsTab + 28 * *(a2 + 796) - 28;
  do
  {
    *(SamplingRateInfo + 148 + v24) = *&v25[v24];
    v24 += 4;
  }

  while (v24 != 28);
  v26 = 0;
  *&v27 = -1;
  *(&v27 + 1) = -1;
  *(SamplingRateInfo + 192) = v27;
  *(SamplingRateInfo + 208) = v27;
  *(SamplingRateInfo + 176) = v27;
LABEL_65:
  v44 = vdupq_n_s64(v15 - 1);
  v45 = vmovn_s64(vcgeq_u64(v44, xmmword_19B0A5850));
  if (vuzp1_s8(vuzp1_s16(v45, *v44.i8), *v44.i8).u8[0])
  {
    *(SamplingRateInfo + 243) = 0;
  }

  if (vuzp1_s8(vuzp1_s16(v45, *&v44), *&v44).i8[1])
  {
    *(SamplingRateInfo + 244) = 1;
  }

  if (vuzp1_s8(vuzp1_s16(*&v44, vmovn_s64(vcgeq_u64(v44, xmmword_19B0A5840))), *&v44).i8[2])
  {
    *(SamplingRateInfo + 245) = 2;
    *(SamplingRateInfo + 246) = 3;
  }

  v46 = vmovn_s64(vcgeq_u64(v44, xmmword_19B0B23A0));
  if (vuzp1_s8(*&v44, vuzp1_s16(v46, *&v44)).i32[1])
  {
    *(SamplingRateInfo + 247) = 4;
  }

  if (vuzp1_s8(*&v44, vuzp1_s16(v46, *&v44)).i8[5])
  {
    *(SamplingRateInfo + 248) = 5;
  }

  if (vuzp1_s8(*&v44, vuzp1_s16(*&v44, vmovn_s64(vcgeq_u64(v44, xmmword_19B0B2390)))).i8[6])
  {
    *(SamplingRateInfo + 249) = 6;
    *(SamplingRateInfo + 250) = 7;
  }

  v47 = vmovn_s64(vcgeq_u64(v44, xmmword_19B0B2460));
  if (vuzp1_s8(vuzp1_s16(v47, *v44.i8), *v44.i8).u8[0])
  {
    *(SamplingRateInfo + 251) = 8;
  }

  if (vuzp1_s8(vuzp1_s16(v47, *&v44), *&v44).i8[1])
  {
    *(SamplingRateInfo + 252) = 9;
  }

  if (vuzp1_s8(vuzp1_s16(*&v44, vmovn_s64(vcgeq_u64(v44, xmmword_19B0B2450))), *&v44).i8[2])
  {
    *(SamplingRateInfo + 253) = 10;
    *(SamplingRateInfo + 254) = 11;
  }

  v48 = vmovn_s64(vcgeq_u64(v44, xmmword_19B0B2440));
  if (vuzp1_s8(*&v44, vuzp1_s16(v48, *&v44)).i32[1])
  {
    *(SamplingRateInfo + 255) = 12;
  }

  if (vuzp1_s8(*&v44, vuzp1_s16(v48, *&v44)).i8[5])
  {
    *(SamplingRateInfo + 256) = 13;
  }

  v49 = vmovn_s64(vcgeq_u64(v44, xmmword_19B0B2430));
  if (vuzp1_s8(*&v49, vuzp1_s16(v49, v49)).i8[6])
  {
    *(SamplingRateInfo + 257) = 14;
  }

  v50 = vuzp1_s16(v49, v49);
  if (vuzp1_s8(v50, v50).i8[7])
  {
    *(SamplingRateInfo + 258) = 15;
  }

  if (v15 == 1)
  {
    *(SamplingRateInfo + 244) = -1;
  }

  LOBYTE(v22) = *(a2 + 796);
  *(SamplingRateInfo + 280) = v22;
  v23 = *(a2 + 772);
LABEL_94:
  *(SamplingRateInfo + 332) = v22;
  if (*(SamplingRateInfo + 328) != v23)
  {
    if ((a3 & 2) != 0)
    {
      *(SamplingRateInfo + 328) = v23;
    }

    v26 = 1;
  }

  if (*(a2 + 780) % v8)
  {
    goto LABEL_99;
  }

  *(SamplingRateInfo + 336) = 0;
  *(SamplingRateInfo + 348) = *(a2 + 788);
  v51 = *(SamplingRateInfo + 352);
  v52 = *(a2 + 792);
  v53 = v51;
  if ((a3 & 2) != 0)
  {
    *(SamplingRateInfo + 352) = v52;
    v53 = v52;
  }

  v54 = *(a2 + 801);
  v55 = ((*(a2 + 801) != 0) << 15) | ((*(a2 + 802) != 0) << 17);
  *(SamplingRateInfo + 68) = v55;
  if (v54)
  {
    *(SamplingRateInfo + 840) = 257;
    if (*(a2 + 792))
    {
      if (v8 != 1 && (v8 & 1) != 0)
      {
LABEL_99:
        ChanElementList = 8200;
        goto LABEL_239;
      }

      if ((a3 & 2) != 0)
      {
        *(SamplingRateInfo + 352) = v53 / *(SamplingRateInfo + 826);
      }
    }
  }

  else
  {
    *(SamplingRateInfo + 840) = 0;
  }

  v56 = *(a2 + 798);
  if (*(a2 + 798))
  {
    v57 = v55 + 1;
  }

  else
  {
    v57 = v55;
  }

  *v21 = v57;
  if (v56 || (v58 = *(a2 + 799), v59 = v57 | (2 * (*(a2 + 799) != 0)), *v21 = v59, v58) || (v60 = *(a2 + 800), v61 = v59 | (4 * (*(a2 + 800) != 0)), *v21 = v61, v60))
  {
LABEL_116:
    ChanElementList = 8196;
    goto LABEL_239;
  }

  v62 = *(a2 + 797);
  v63 = ((v62 & 0x80) >> 1) ^ 0x40 | v61;
  *v21 = v63;
  if (v23 == 42)
  {
    *v21 = v63 | 0x100;
    *v21 = v63 | 0x100 | ((*(a2 + 20) != 0) << 18);
  }

  if ((v62 & 0x80000000) != 0)
  {
    *(SamplingRateInfo + 364) = v62;
  }

  else
  {
    if (v22 < 1)
    {
      goto LABEL_116;
    }

    *(SamplingRateInfo + 364) = v62;
    if (v62 > 1)
    {
      goto LABEL_116;
    }
  }

  v64 = *(SamplingRateInfo + 56);
  v65 = *(a2 + 776);
  v66 = *(SamplingRateInfo + 340);
  v67 = *(a2 + 780);
  if (v64 && v64 != v65)
  {
    goto LABEL_145;
  }

  if (v66 != v67 / v8)
  {
    if (v66)
    {
      goto LABEL_145;
    }

    if ((a3 & 2) == 0)
    {
      goto LABEL_139;
    }

    goto LABEL_137;
  }

  if (v51 != v52 || v64 != v65)
  {
    v26 = 1;
  }

  if ((a3 & 2) != 0 && v64 != v65)
  {
LABEL_137:
    SamplingRateInfo = getSamplingRateInfo(SamplingRateInfo + 32, v67, *(a2 + 803), v65);
    ChanElementList = SamplingRateInfo;
    if (SamplingRateInfo)
    {
      goto LABEL_239;
    }

    v69 = *(v7 + 826);
    *(v7 + 320) = *(v7 + 56) / v69;
    *(v7 + 340) = *(a2 + 780) / v69;
LABEL_139:
    v26 = 1;
  }

  v70 = *(v7 + 4);
  if (v70 == v15)
  {
    if (a3)
    {
      if (!v26)
      {
        ChanElementList = 0;
        goto LABEL_239;
      }

      goto LABEL_172;
    }

    goto LABEL_147;
  }

  if (v70)
  {
LABEL_145:
    ChanElementList = 16386;
    goto LABEL_239;
  }

  if (a3)
  {
LABEL_172:
    ChanElementList = 0;
    *a4 = 1;
    goto LABEL_239;
  }

LABEL_147:
  if (*(a2 + 772) == 42)
  {
    if (*(v7 + 840))
    {
      v71 = *(*(v7 + 800) + 8);
      if (v71 < 1)
      {
        goto LABEL_44;
      }

      v72 = (v7 + 148);
      v73 = (v7 + 780);
      v74 = 255;
      do
      {
        v75 = *v72++;
        if ((v75 - 16) <= 2)
        {
          if ((v74 & 0x80) != 0)
          {
            v74 = *v73;
          }

          else if (*v73 | v74)
          {
            goto LABEL_44;
          }
        }

        ++v73;
        --v71;
      }

      while (v71);
      if ((v74 & 0x80) != 0)
      {
        goto LABEL_44;
      }

      if (v74 == 3)
      {
        *v21 |= 0x8000000u;
      }

      if (!*a4)
      {
        goto LABEL_276;
      }

      v144 = 6160;
      v145 = 32;
      if (*(a2 + 2))
      {
        v76 = v74 == 3;
        *(v7 + 866) = v15;
        if (v74 == 1)
        {
          v77 = 2;
        }

        else
        {
          v77 = v15;
        }

        *(v7 + 868) = v77;
        *(v7 + 924) = 0;
        *(v7 + 929) = *(&v144 + *(a2 + 2) - 1);
        *(v7 + 932) = 64;
        if (*(a2 + 2) == 1)
        {
          v78 = 64;
        }

        else
        {
          v78 = 32;
        }

        *(v7 + 935) = v78;
        if (*(a2 + 2) == 1)
        {
          v79 = 12;
        }

        else
        {
          v79 = 6;
        }

        *(v7 + 937) = v79;
        *(v7 + 939) = 64;
        *(v7 + 941) = 1;
        *(v7 + 869) = v76;
        *(v7 + 870) = v76;
        *(v7 + 864) = 1;
LABEL_176:
        v81 = *(v7 + 424);
        v80 = *(v7 + 432);
        if (v80 != v81)
        {
          do
          {
            v82 = v80 - 5952;
            tcx_dec::tcxDecoder::~tcxDecoder((v80 - 1808));
            v80 = v82;
          }

          while (v82 != v81);
        }

        *(v7 + 432) = v81;
        std::vector<lpd_dec::lpdDecoder>::resize((v7 + 424), v15);
        v83 = 0;
        v84 = v7 + 392;
        do
        {
          if (v83 == 2)
          {
            goto LABEL_44;
          }

          v85 = malloc_type_calloc(1uLL, 0x60uLL, 0x5142B0E1uLL);
          if (!v85)
          {
            *(v84 + 8 * v83) = 0;
            goto LABEL_44;
          }

          v86 = v85 + (-(v85 + 8) & 7) + 8;
          *(v86 - 8) = v85;
          *(v7 + 8 * v83++ + 392) = v86;
        }

        while (v15 != v83);
        if ((*(v7 + 69) & 3) != 0)
        {
          v87 = *(a2 + 8);
          if (v87 < 1)
          {
LABEL_225:
            v105 = 0;
            v143 = v7 + 408;
            do
            {
              AacDecoderStaticChannelInfo = GetAacDecoderStaticChannelInfo(v105);
              v107 = v7 + 8 * v105;
              *(v107 + 408) = AacDecoderStaticChannelInfo;
              if (!AacDecoderStaticChannelInfo)
              {
                goto LABEL_44;
              }

              SamplingRateInfo = GetOverlapBuffer(v105);
              **(v107 + 408) = SamplingRateInfo;
              if (!**(v107 + 408))
              {
                goto LABEL_44;
              }

              if ((*(v7 + 69) & 0x43) != 0)
              {
                ArithDec_Create();
              }

              ++v105;
            }

            while (v15 != v105);
            v108 = *v21;
            if ((*v21 & 0x100) != 0)
            {
              LODWORD(v109) = v15;
              if (v14 >= 1)
              {
                v110 = 0;
                v111 = v7 + 1992;
                do
                {
                  v109 = v110;
                  if (!*(v111 + 8 * v110))
                  {
                    SamplingRateInfo = GetTimeDataFlush(v110);
                    *(v111 + 8 * v109) = SamplingRateInfo;
                    if (!SamplingRateInfo)
                    {
                      goto LABEL_44;
                    }
                  }

                  v110 = v109 + 1;
                }

                while (v14 != v109 + 1);
                v108 = *v21;
              }
            }

            else
            {
              LODWORD(v109) = v15;
            }

            if ((v108 & 0x300) != 0)
            {
              if (*(a2 + 8) >= 1)
              {
                v118 = 0;
                LODWORD(v109) = 0;
                v119 = v7 + 780;
                v120 = (a2 + 20);
                while (1)
                {
                  v121 = *(v119 + 4 * v118 - 632);
                  if (v121 <= 0x12)
                  {
                    break;
                  }

LABEL_262:
                  ++v118;
                  v120 += 24;
                  if (v118 >= *(a2 + 8))
                  {
                    goto LABEL_271;
                  }
                }

                if (((1 << v121) & 0x5000B) != 0)
                {
                  v122 = v109 + 1;
                  v123 = 12345;
                  goto LABEL_260;
                }

                if (v121 != 17)
                {
                  goto LABEL_262;
                }

                v124 = *(v119 + v118);
                *(*(v143 + 8 * v109) + 80) = 12345;
                if (v124 == 1)
                {
                  v125 = 1;
                }

                else
                {
                  v125 = 2;
                }

                v122 = v109 + v125;
                if (*v120 != 1)
                {
                  LODWORD(v109) = v109 + 1;
                  v123 = 67890;
LABEL_260:
                  *(*(v143 + 8 * v109) + 80) = v123;
                }

                LODWORD(v109) = v122;
                goto LABEL_262;
              }

              LODWORD(v109) = 0;
            }

LABEL_271:
            if (v15 != *v7)
            {
              *v7 = v109;
            }

            if (!v18 || (SamplingRateInfo = CDK_Delay_Create(v7 + 2056, v18), !SamplingRateInfo))
            {
              *(v7 + 4) = v15;
              *(v7 + 812) = 0;
              v70 = v15;
              goto LABEL_276;
            }

LABEL_44:
            CAacDecoder_DeInit(v7);
            ChanElementList = 2;
            goto LABEL_239;
          }
        }

        else
        {
          v87 = 7;
        }

        v142 = 0;
        v88 = (v7 + 148);
        v138 = v87 - 1;
        v139 = (v7 + 780);
        while (1)
        {
          if ((*v21 & 0x4370) != 0 && v142 >= v15)
          {
            goto LABEL_225;
          }

          v141 = v88;
          v90 = *v88;
          if (*v88 <= 0x12)
          {
            if (((1 << v90) & 0x50009) != 0)
            {
              v91 = 1;
            }

            else if (v90 == 1)
            {
              v91 = 2;
            }

            else
            {
              if (v90 != 17)
              {
                goto LABEL_220;
              }

              if (*v139 == 1)
              {
                v91 = 1;
              }

              else
              {
                v91 = 2;
              }
            }

            v140 = v91;
            *(*(v84 + 8 * v142) + 64) = malloc_type_calloc(1uLL, 8uLL, 0x5142B0E1uLL);
            if (!*(*(v84 + 8 * v142) + 64))
            {
              goto LABEL_44;
            }

            if (v142)
            {
              v92 = malloc_type_calloc(1uLL, 0x4E1uLL, 0x5142B0E1uLL);
              if (v92)
              {
                v93 = -(v92 + 8) & 7;
                v94 = &v92[v93 + 8];
                *&v92[v93] = v92;
              }

              else
              {
                v94 = 0;
              }

              *(*(v84 + 8 * v142) + 56) = v94;
              v98 = **(*v84 + 64);
            }

            else
            {
              v95 = malloc_type_calloc(1uLL, 0x2010uLL, 0x5142B0E1uLL);
              if (v95)
              {
                v96 = -(v95 + 8) & 7;
                v97 = &v95[v96 + 8];
                *&v95[v96] = v95;
              }

              else
              {
                v97 = 0;
              }

              *(*(v84 + 8 * v142) + 56) = v97;
              v99 = malloc_type_calloc(1uLL, 0x2010uLL, 0x5142B0E1uLL);
              if (v99)
              {
                v100 = -(v99 + 8) & 7;
                v98 = &v99[v100 + 8];
                *&v99[v100] = v99;
              }

              else
              {
                v98 = 0;
              }
            }

            **(*(v84 + 8 * v142) + 64) = v98;
            v101 = *(v84 + 8 * v142);
            v102 = *(v101 + 56);
            if (!v102 || !**(v101 + 64))
            {
              goto LABEL_44;
            }

            *(v101 + 48) = v102;
            v103 = *(v7 + 448);
            *(*(v84 + 8 * v142) + 8) = v103 + (v142 << 12);
            if (v140 == 2)
            {
              if (v142 > 0)
              {
                goto LABEL_238;
              }

              *(*(v84 + 8 * (v142 + 1)) + 56) = *(*(v84 + 8 * v142) + 56);
              *(*(v84 + 8 * (v142 + 1)) + 64) = *(*(v84 + 8 * v142) + 64);
              **(*(v84 + 8 * (v142 + 1)) + 64) = **(*(v84 + 8 * v142) + 64);
              *(*(v84 + 8 * (v142 + 1)) + 48) = *(*(v84 + 8 * v142) + 56) + 616;
              *(*(v84 + 8 * (v142 + 1)) + 8) = v103 + 4 * ((v142 + 1) << 10);
            }

            v142 += v140;
            v90 = *v141;
          }

LABEL_220:
          v104 = v90 == 7 || v138 == 0;
          v88 = v141 + 1;
          --v138;
          ++v139;
          if (v104)
          {
            goto LABEL_225;
          }
        }
      }

      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "AAC_DECODER_ERROR CAacDecoder_Init(HANDLE_AACDECODER, const CSAudioSpecificConfig *, UCHAR, UCHAR *)";
      v117 = 1606;
LABEL_252:
      exception[2] = v117;
    }

    if (*a4)
    {
      goto LABEL_176;
    }
  }

  else if (*a4)
  {
    *(v7 + 864) = 0;
    goto LABEL_176;
  }

LABEL_276:
  v126 = *(v7 + 392);
  if (v126)
  {
    *(v7 + 848) = **(v126 + 64);
    *(v7 + 856) = 512;
  }

  if (*a4 && v70 >= 1)
  {
    v127 = 0;
    v128 = (v7 + 408);
    do
    {
      v129 = *(v7 + 328);
      if (v129 == 39 || v129 == 23)
      {
        v131 = *(v7 + 340);
      }

      else
      {
        v131 = *(v7 + 340) / 8;
      }

      v132 = *(v128 - 2);
      *(v132 + 36) = v131;
      *(v132 + 44) = 1;
      v133 = *v128;
      v133[1] = **v128;
      *(v133 + 8) = 0;
      v133[3] = 0;
      *(v133 + 10) = 512;
      *(v133 + 44) = 0;
      v133[7] = 0;
      v133[8] = 0;
      SamplingRateInfo = DCTWrapper::Instance(SamplingRateInfo);
      v134 = *v128++;
      *(v134 + 236) = 0;
      *(v134 + 244) = 0;
      *(v134 + 252) = 0x3F0000003D4CCCCDLL;
      *(v134 + 65) = 1055286886;
      v134[11] = v7 + 468;
      *(v134 + 70) = -255;
      *(v134 + 36) = 0;
      *(v134 + 148) = 1;
      *(v134 + 38) = 0;
      *(v134 + 30) = 0;
      *(v134 + 13) = xmmword_19B0B32D0;
      *(v134 + 40) = 1065353216;
      *(v134 + 132) = 0;
      *(v134 + 124) = 0;
      ++v127;
    }

    while (*(v7 + 4) > v127);
  }

  *(v7 + 360) = *(v7 + 68);
  v135 = *(v7 + 800);
  if (*(v7 + 840) == 1 && *(v135 + 8))
  {
    v136 = 0;
    v137 = v7 + 780;
    do
    {
      if ((*(v137 + 4 * v136 - 632) - 16) <= 2)
      {
        if (MPEG_D::USAC::DynRangeCompressor::SetDrcQmfConfig((v7 + 2072), *(v135 + 2), *(v137 + v136)))
        {
          goto LABEL_44;
        }

        v135 = *(v7 + 800);
      }

      ++v136;
    }

    while (v136 < *(v135 + 8));
  }

  ChanElementList = CreateChanElementList((v7 + 1984), v135, v7 + 780);
LABEL_239:
  if (CDK_chMapDescr_isValid(v7 + 264))
  {
    v112 = ChanElementList;
  }

  else
  {
    v112 = 8199;
  }

  if ((v112 & 0x7000) == 0x2000)
  {
    v113 = 1026;
  }

  else
  {
    v113 = 513;
  }

  if (v112 == 8203)
  {
    v114 = 515;
  }

  else
  {
    v114 = v113;
  }

  if (v112)
  {
    return v114;
  }

  else
  {
    return 0;
  }
}

uint64_t CDK_chMapDescr_isValid(uint64_t result)
{
  if (result)
  {
    v1 = *(result + 8);
    if (v1)
    {
      v2 = 0;
      v3 = *result;
      while (v3)
      {
        v4 = v3 + 16 * v2;
        v5 = *(v4 + 8);
        if (v5 >= 0x20)
        {
          v10 = 0;
          v11 = *v4;
          v12 = (v5 - 1);
          do
          {
            v13 = v11[v10];
            result = v12 >= v13;
            if (v10 < v12 && v12 >= v13)
            {
              v14 = v5 - 2;
              do
              {
                v15 = v11[v14 + 1];
                v16 = v14--;
                v17 = v13 == v15;
                result = v13 != v15;
              }

              while (!v17 && v10 < v16);
            }

            ++v10;
          }

          while (v10 < v5 && (result & 1) != 0);
        }

        else
        {
          v6 = 0;
          if (*(v4 + 8))
          {
            v7 = *v4;
            v8 = v5;
            do
            {
              v9 = *v7++;
              v6 |= 1 << v9;
              --v8;
            }

            while (v8);
          }

          result = (v6 ^ (-1 << v5)) == -1;
        }

        ++v2;
        if (result)
        {
          v19 = v2 >= v1;
        }

        else
        {
          v19 = 1;
        }

        if (v19)
        {
          return result;
        }
      }

      return 0;
    }

    else
    {
      return 1;
    }
  }

  return result;
}

uint64_t getSamplingRateInfo(uint64_t a1, int a2, uint64_t a3, unsigned int a4)
{
  v16 = *MEMORY[0x1E69E9840];
  if (a2 == 768 || a3 >= 0xF)
  {
    a3 = 0;
    v15[0] = xmmword_19B0B34C0;
    v15[1] = xmmword_19B0B34D0;
    v15[2] = xmmword_19B0B34E0;
    v4 = 4 * a4 / 3;
    if (a2 != 768)
    {
      v4 = a4;
    }

    do
    {
      if (*(v15 + a3) > v4 && v4 >= *(v15 + a3 + 1))
      {
        break;
      }

      ++a3;
    }

    while (a3 != 11);
  }

  *(a1 + 20) = a3;
  *(a1 + 24) = a4;
  if (a2 == 1024)
  {
    v5 = 0;
  }

  else
  {
    if (a2 != 768)
    {
      return 8195;
    }

    v5 = 2;
  }

  v6 = (&sfbOffsetTables + 48 * v5 + 3 * a3);
  v8 = *v6;
  v7 = v6[1];
  *a1 = *v6;
  *(a1 + 8) = v7;
  v9 = *(v6 + 16);
  *(a1 + 16) = v9;
  v10 = *(v6 + 17);
  *(a1 + 17) = v10;
  if (v8)
  {
    v11 = v9 == 0;
  }

  else
  {
    v11 = 1;
  }

  if (v11)
  {
    *(a1 + 24) = 0;
    return 8195;
  }

  if (*(v8 + 2 * v9) != a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "AAC_DECODER_ERROR getSamplingRateInfo(SamplingRateInfo *, UINT, UINT, UINT)";
    v14 = 198;
    goto LABEL_25;
  }

  if (v7 && a2 != 8 * v7[v10])
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "AAC_DECODER_ERROR getSamplingRateInfo(SamplingRateInfo *, UINT, UINT, UINT)";
    v14 = 199;
LABEL_25:
    exception[2] = v14;
  }

  return 0;
}

void std::vector<lpd_dec::lpdDecoder>::resize(uint64_t *a1, unint64_t a2)
{
  v4 = *a1;
  v3 = a1[1];
  v5 = 0x4FD3F4FD3F4FD3F5 * ((v3 - *a1) >> 6);
  v6 = a2 - v5;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      for (i = v4 + 5952 * a2; v3 != i; v3 -= 5952)
      {
        tcx_dec::tcxDecoder::~tcxDecoder((v3 - 1808));
      }

      a1[1] = i;
    }
  }

  else
  {
    v7 = a1[2];
    if (0x4FD3F4FD3F4FD3F5 * ((v7 - v3) >> 6) < v6)
    {
      if (a2 <= 0xB02C0B02C0B02)
      {
        v8 = 0x9FA7E9FA7E9FA7EALL * ((v7 - v4) >> 6);
        if (v8 <= a2)
        {
          v8 = a2;
        }

        if ((0x4FD3F4FD3F4FD3F5 * ((v7 - v4) >> 6)) >= 0x5816058160581)
        {
          v9 = 0xB02C0B02C0B02;
        }

        else
        {
          v9 = v8;
        }

        if (v9 <= 0xB02C0B02C0B02)
        {
          operator new();
        }

        std::__throw_bad_array_new_length[abi:ne200100]();
      }

      std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
    }

    v11 = v3 + 5952 * v6;
    v12 = 5952 * a2 - ((v3 - *a1) >> 6 << 6);
    do
    {
      _ZNSt3__116allocator_traitsINS_9allocatorIN7lpd_dec10lpdDecoderEEEE9constructB8ne200100IS3_JEvLi0EEEvRS4_PT_DpOT0_(v3);
      v3 += 5952;
      v12 -= 5952;
    }

    while (v12);
    a1[1] = v11;
  }
}

void sub_19B0637B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<lpd_dec::lpdDecoder>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

void *GetAacDecoderStaticChannelInfo(int a1)
{
  if (a1 >= 2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "CAacDecoderStaticChannelInfo *GetAacDecoderStaticChannelInfo(int)";
    exception[2] = 46;
  }

  return malloc_type_calloc(1uLL, 0x110uLL, 0x5142B0E1uLL);
}

char *GetOverlapBuffer(int a1)
{
  if (a1 >= 2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "FLOAT *GetOverlapBuffer(int)";
    exception[2] = 54;
  }

  v1 = malloc_type_calloc(1uLL, 0x810uLL, 0x5142B0E1uLL);
  if (!v1)
  {
    return 0;
  }

  v2 = -(v1 + 8) & 7;
  v3 = &v1[v2 + 8];
  *&v1[v2] = v1;
  return v3;
}

void *GetTimeDataFlush(int a1)
{
  if (a1 >= 2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "FLOAT *GetTimeDataFlush(int)";
    exception[2] = 74;
  }

  return malloc_type_calloc(0x80uLL, 4uLL, 0x5142B0E1uLL);
}

uint64_t CDK_Delay_Create(uint64_t a1, size_t count)
{
  if (!a1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "INT CDK_Delay_Create(CDK_SignalDelay *, const USHORT, const UCHAR)";
    exception[2] = 30;
  }

  v2 = count;
  if (count)
  {
    v4 = malloc_type_calloc(count, 4uLL, 0x5142B0E1uLL);
    *a1 = v4;
    if (!v4)
    {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    *a1 = 0;
  }

  result = 0;
  *(a1 + 10) = 1;
  *(a1 + 8) = v2;
  return result;
}

uint64_t MPEG_D::USAC::DynRangeCompressor::SetDrcQmfConfig(MPEG_D::USAC::DynRangeCompressor *this, unsigned int a2, int a3)
{
  v24 = *MEMORY[0x1E69E9840];
  if ((a3 - 1) < 2)
  {
    v4 = 0;
    v5 = 4;
LABEL_5:
    v7 = 1;
    goto LABEL_6;
  }

  if (a2 - 1 < 3)
  {
    v4 = 0;
    v5 = 3;
    goto LABEL_5;
  }

  if (a2)
  {
    if (gDRCScope)
    {
      v15 = *gDRCScope;
      if (!*gDRCScope)
      {
        return 0xFFFFFFFFLL;
      }
    }

    else
    {
      v15 = MEMORY[0x1E69E9C10];
    }

    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v16 = 136315650;
      v17 = "USACDRCExtension.cpp";
      v18 = 1024;
      v19 = 364;
      v20 = 1024;
      v21 = a2;
      v12 = "%25s:%-5d Error: unexpected value of sbrRatioIndex = %d\n";
      v13 = v15;
      v14 = 24;
      goto LABEL_22;
    }

    return 0xFFFFFFFFLL;
  }

  v7 = 0;
  v4 = 1;
  v5 = 1;
LABEL_6:
  v8 = *(this + 17);
  if (v8 >= 2)
  {
    v7 = 0;
  }

  if (v8 <= 1)
  {
    v4 = 0;
  }

  if ((v7 & 1) != 0 || v4)
  {
    if (gDRCScope)
    {
      v11 = *gDRCScope;
      if (!*gDRCScope)
      {
        return 0xFFFFFFFFLL;
      }
    }

    else
    {
      v11 = MEMORY[0x1E69E9C10];
    }

    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v16 = 136315906;
      v17 = "USACDRCExtension.cpp";
      v18 = 1024;
      v19 = 371;
      v20 = 1024;
      v21 = v8;
      v22 = 1024;
      v23 = v5;
      v12 = "%25s:%-5d Error: transition of mDRCDomain not supported %d %d\n";
      v13 = v11;
      v14 = 30;
LABEL_22:
      _os_log_impl(&dword_19AA99000, v13, OS_LOG_TYPE_ERROR, v12, &v16, v14);
      return 0xFFFFFFFFLL;
    }

    return 0xFFFFFFFFLL;
  }

  *(this + 17) = v5;
  *(this + 14) = mpddrc::NumAudioCodecSubbands(v5);
  v9 = *(this + 8);
  if (!v9)
  {
    return 0;
  }

  *(v9 + 2436) = v5;
  mpddrc::UniDrcParametricDrc::UpdateUniDrcDomain(v9 + 3392, v5);
  mpddrc::UniDrcParametricDrc::UpdateUniDrcDomain(v9 + 5536, v5);
  result = 0;
  *(*(this + 8) + 96) = *(this + 14);
  return result;
}

uint64_t CreateChanElementList(void **a1, uint64_t a2, uint64_t a3)
{
  *a1 = malloc_type_malloc(8 * *(a2 + 8), 0x2004093837F09uLL);
  if (*(a2 + 8))
  {
    v4 = 0;
    for (i = (a2 + 12); ; i += 6)
    {
      v6 = *i;
      if (*i == 16)
      {
        goto LABEL_7;
      }

      if (v6 == 18)
      {
        operator new();
      }

      if (v6 == 17)
      {
        break;
      }

      *(*a1 + v4++) = 0;
      if (v4 >= *(a2 + 8))
      {
        return 0;
      }
    }

    if (*(a3 + v4) != 1)
    {
      operator new();
    }

LABEL_7:
    operator new();
  }

  return 0;
}

void MPEG_D::USAC::ChannelElement::~ChannelElement(MPEG_D::USAC::ChannelElement *this)
{
  *this = &unk_1F0E21AB8;
  MPEG_D::USAC::SpectralDataDecoder::~SpectralDataDecoder((this + 576));
  v2 = *(this + 3);
  if (v2)
  {
    *(this + 4) = v2;
    operator delete(v2);
  }
}

void MPEG_D::USAC::SpectralDataDecoder::~SpectralDataDecoder(MPEG_D::USAC::SpectralDataDecoder *this)
{
  *this = &unk_1F0E21B20;
  v17 = (this + 56);
  std::vector<mpddrc::EqCoefficients::FilterBlock>::__destroy_vector::operator()[abi:ne200100](&v17);
  v2 = *(this + 4);
  if (v2)
  {
    v3 = *(this + 5);
    v4 = *(this + 4);
    if (v3 != v2)
    {
      v5 = v3 - 2;
      v6 = v3 - 2;
      v7 = v3 - 2;
      do
      {
        v8 = *v7;
        v7 -= 2;
        (*v8)(v6);
        v5 -= 2;
        v9 = v6 == v2;
        v6 = v7;
      }

      while (!v9);
      v4 = *(this + 4);
    }

    *(this + 5) = v2;
    operator delete(v4);
  }

  v10 = *(this + 1);
  if (v10)
  {
    v11 = *(this + 2);
    v12 = *(this + 1);
    if (v11 != v10)
    {
      v13 = v11 - 6;
      v14 = v11 - 6;
      v15 = v11 - 6;
      do
      {
        v16 = *v15;
        v15 -= 6;
        (*v16)(v14);
        v13 -= 6;
        v9 = v14 == v10;
        v14 = v15;
      }

      while (!v9);
      v12 = *(this + 1);
    }

    *(this + 2) = v10;
    operator delete(v12);
  }
}

{
  MPEG_D::USAC::SpectralDataDecoder::~SpectralDataDecoder(this);

  JUMPOUT(0x19EAE53E0);
}

void MPEG_D::USAC::JointStereoDecoder::~JointStereoDecoder(MPEG_D::USAC::JointStereoDecoder *this)
{
  MPEG_D::USAC::JointStereoDecoder::~JointStereoDecoder(this);

  JUMPOUT(0x19EAE53E0);
}

{
  *this = &unk_1F0E21B40;
  v2 = *(this + 6);
  *(this + 6) = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = *(this + 5);
  *(this + 5) = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  v4 = *(this + 2);
  if (v4)
  {
    *(this + 3) = v4;
    operator delete(v4);
  }
}

uint64_t MPEG_D::USAC::ChannelPairElement::prevSpectrum(MPEG_D::USAC::ChannelPairElement *this, int a2)
{
  v2 = 800;
  if (!a2)
  {
    v2 = 24;
  }

  return this + v2;
}

uint64_t MPEG_D::USAC::ChannelPairElement::scalefactorData(MPEG_D::USAC::ChannelPairElement *this, int a2)
{
  v2 = 824;
  if (!a2)
  {
    v2 = 48;
  }

  return this + v2;
}

uint64_t MPEG_D::USAC::ChannelPairElement::Decode(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, int32x4_t a5, int32x4_t a6)
{
  if (*(*a4 + 5912) || *(*a4 + 11864))
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
  }

  else
  {
    v11 = *(*a2 + 32);
    v12 = *(a2[1] + 32);
    v23 = *(*a2 + 48);
    if (*(v23 + 611))
    {
      if (*(v23 + 615) == 1)
      {
        MPEG_D::USAC::JointStereoDecoder::Apply(a1 + 1352, *a2 + 16, **(a1 + 632), *(*(a1 + 632) + 24), *(*a2 + 32), *(a2[1] + 32));
      }
    }

    else
    {
      v24 = *(a1 + 1400);
      if (v24)
      {
        v25 = (v24 + 256);
        v26 = 8;
        do
        {
          bzero(*(v25 - 25), *(v25 - 24) - *(v25 - 25));
          bzero(*(v25 - 1), *v25 - *(v25 - 1));
          v25 += 3;
          --v26;
        }

        while (v26);
      }
    }

    v10 = 1;
  }

  v13 = 0;
  v14 = 1;
  do
  {
    v15 = v14;
    v16 = a2[v13];
    if (*(v16 + 44) == 3)
    {
      lpd_dec::lpdDecoder::Decode((*a4 + 5952 * v13), *(v16 + 8), *(v16 + 36), (*(a3 + 8 * v13) + 80), a5, a6);
    }

    v14 = 0;
    v13 = 1;
  }

  while ((v15 & 1) != 0);
  v17 = 0;
  v18 = 1;
  do
  {
    v19 = v18;
    if (*(a2[v17] + 44) != 3)
    {
      v20 = *(*(*a2 + 48) + 614) == 1 ? 0 : v10;
      if ((v20 & 1) == 0)
      {
        ApplyTools(a2, *(a1 + 16), v17);
      }
    }

    v18 = 0;
    v17 = 1;
  }

  while ((v19 & 1) != 0);
  if (v10)
  {
    v21 = *(*a2 + 48);
    if (*(v21 + 611))
    {
      if (!*(v21 + 615))
      {
        MPEG_D::USAC::JointStereoDecoder::Apply(a1 + 1352, *a2 + 16, **(a1 + 632), *(*(a1 + 632) + 24), v11, v12);
      }
    }
  }

  return 0;
}

void MPEG_D::USAC::JointStereoDecoder::Apply(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6)
{
  v129 = a2;
  if (*(a1 + 9) == 1)
  {
    v9 = *(a1 + 48);
    if (a5 <= a6)
    {
      v10 = a6;
    }

    else
    {
      v10 = a5;
    }

    v11 = *(v9 + 12);
    v121 = (&MPEG_D::USAC::ComplexPrediction::kMDSTCoefPrev + 28 * *(v9 + 12));
    v12 = *(a2 + 12);
    v13 = (*(v9 + 496) - *(v9 + 488)) >> 2;
    v14 = v13 >> 3;
    v15 = 40;
    if (v12 == 2)
    {
      v15 = 48;
      v16 = v13 >> 3;
    }

    else
    {
      v16 = (*(v9 + 496) - *(v9 + 488)) >> 2;
    }

    if (*(v9 + 9) == 1)
    {
      if (v12 == 3)
      {
        v121 = (&MPEG_D::USAC::ComplexPrediction::kMDSTCoefPrev + 28 * *(v9 + 12) + 56);
      }

      else if (v12 == 1)
      {
        v17 = (&MPEG_D::USAC::ComplexPrediction::kMDSTCoefPrev + 28 * *(v9 + 12));
        if (*(v9 + 11) - 1 <= 1)
        {
          v17 = (&MPEG_D::USAC::ComplexPrediction::kMDSTCoefPrev + 28 * *(v9 + 12) + 56);
        }

        v121 = v17;
      }
    }

    v58 = *(a2 + 10);
    if (v11 == 1 && v58 == 1)
    {
      v60 = 1;
    }

    else if (*(v9 + 12) || v58 != 1)
    {
      if (*(a2 + 10))
      {
        v61 = 0;
      }

      else
      {
        v61 = v11 == 1;
      }

      if (v61)
      {
        v60 = 3;
      }

      else
      {
        v60 = 0;
      }
    }

    else
    {
      v60 = 2;
    }

    if (v12 == 3)
    {
      v60 |= 8u;
    }

    else if (v12 == 1)
    {
      if (*(v9 + 11) - 1 > 1)
      {
        v60 |= 4u;
      }

      else
      {
        v60 |= 0xCu;
      }
    }

    v120 = (&MPEG_D::USAC::ComplexPrediction::kMDSTCoefCurr + 28 * v60);
    v62 = *(a2 + 8);
    if (*(a2 + 8))
    {
      v131 = 0;
      v63 = *(a2 + 17);
      v64 = *(v9 + v15);
      v119 = (*(v9 + 440) + 16);
      v65 = (*(v9 + 464) + 16);
      v66 = v16 >> 2;
      LODWORD(v67) = 7 * v14;
      if (v12 == 2)
      {
        v67 = v67;
      }

      else
      {
        v67 = 0;
      }

      v118 = v67;
      v117 = v66 - 2;
      v116 = v66 - 1;
      v122 = 4 * v16;
      v123 = 4 * (v16 + 8);
      v68 = 0;
      v115 = -v14;
      v126 = *(a2 + 12);
      v124 = v16;
      do
      {
        if (*(v129 + v68))
        {
          v128 = 0;
          v69 = 1 << v68;
          v133 = (v9 + 56 + 24 * v68);
          v125 = v68;
          do
          {
            if (*(v9 + 9) == 1)
            {
              v70 = v12 != 2 || v131 == 0;
              v71 = !v70;
              if ((*(v9 + 10) & 1) != 0 && !v71)
              {
                v72 = (*(v9 + 24) + 4 * v118);
                v73 = (*(v9 + 32) + 4 * v118);
                v75 = *v73;
                v74 = v73[1];
                v77 = *v72;
                v76 = v72[1];
                if (*(v9 + 8))
                {
                  v78 = vsubq_f32(v77, v75);
                  v79.i64[0] = 0x3F0000003F000000;
                  v79.i64[1] = 0x3F0000003F000000;
                  v80 = vmulq_f32(v78, v79);
                  v81 = v119;
                  if (v117)
                  {
                    v82 = v119;
                    v83 = 2;
                    v84 = v117;
                    do
                    {
                      *v82++ = v80;
                      v85 = v83;
                      v80 = vmulq_f32(vsubq_f32(v76, v74), v79);
                      v74 = v73[v85];
                      v76 = v72[v85];
                      ++v83;
                      --v84;
                    }

                    while (v84);
                  }

                  *&v119[4 * v117] = v80;
                  v86 = vsubq_f32(v76, v74);
                }

                else
                {
                  v87 = vaddq_f32(v77, v75);
                  v88.i64[0] = 0x3F0000003F000000;
                  v88.i64[1] = 0x3F0000003F000000;
                  v89 = vmulq_f32(v87, v88);
                  v81 = v119;
                  if (v117)
                  {
                    v90 = v119;
                    v91 = 2;
                    v92 = v117;
                    do
                    {
                      *v90++ = v89;
                      v93 = v91;
                      v89 = vmulq_f32(vaddq_f32(v74, v76), v88);
                      v74 = v73[v93];
                      v76 = v72[v93];
                      ++v91;
                      --v92;
                    }

                    while (v92);
                  }

                  *&v119[4 * v117] = v89;
                  v86 = vaddq_f32(v74, v76);
                }

                v94.i64[0] = 0x3F0000003F000000;
                v94.i64[1] = 0x3F0000003F000000;
                *&v81[4 * v116] = vmulq_f32(v86, v94);
              }
            }

            if (v10)
            {
              v95 = 0;
              do
              {
                v96 = *(v64 + 2 * v95);
                v97 = *(*(a1 + 16) + v95++);
                v98 = *(v64 + 2 * v95);
                if ((v69 & v97) != 0)
                {
                  memcpy(&v65[v96], (a3 + 4 * v96), 4 * (v98 - v96));
                }

                else if (*(v9 + 8))
                {
                  if (v96 < v98)
                  {
                    do
                    {
                      v65[v96] = (*(a3 + 4 * v96) - *(a4 + 4 * v96)) * 0.5;
                      ++v96;
                    }

                    while (v96 < v98);
                  }
                }

                else if (v96 < v98)
                {
                  do
                  {
                    v65[v96] = (*(a3 + 4 * v96) + *(a4 + 4 * v96)) * 0.5;
                    ++v96;
                  }

                  while (v96 < v98);
                }
              }

              while (v95 != v10);
            }

            bzero(&v65[*(v64 + 2 * v63)], 4 * (v124 - *(v64 + 2 * v63)));
            if (*(v9 + 9))
            {
              v100 = (*(v64 + 2 * v63) + 7);
              if (v100 >= v124)
              {
                v101 = v124;
              }

              else
              {
                v101 = v100;
              }

              if (v126 == 2 && v131)
              {
                v102 = 28 * *(v129 + 10);
                v121 = (&MPEG_D::USAC::ComplexPrediction::kMDSTCoefPrev + v102);
                v120 = (&MPEG_D::USAC::ComplexPrediction::kMDSTCoefCurr + v102);
                MPEG_D::USAC::ComplexPrediction::EstimateMDST(v9, v65, (&MPEG_D::USAC::ComplexPrediction::kMDSTCoefCurr + v102), *(v9 + 488), v101, 1);
                MPEG_D::USAC::ComplexPrediction::EstimateMDST(v9, &v65[v115 - 8], v121, *(v9 + 488), v101, 0);
              }

              else
              {
                MPEG_D::USAC::ComplexPrediction::EstimateMDST(v9, v65, v120, *(v9 + 488), v101, 1);
                if (*(v9 + 10) == 1)
                {
                  MPEG_D::USAC::ComplexPrediction::EstimateMDST(v9, v119, v121, *(v9 + 488), v101, 0);
                }
              }
            }

            v12 = v126;
            if (v63)
            {
              for (i = 0; i != v63; ++i)
              {
                if ((v69 & *(*(a1 + 16) + i)) != 0)
                {
                  v104 = (*v133 + 4 * i);
                  v99.f32[0] = *v104 * 0.1;
                  v99 = vdupq_lane_s32(*v99.f32, 0);
                  v105 = v104[1] * 0.1;
                  v106 = (v64 + 2 * i);
                  v107 = *v106;
                  v108 = *v106;
                  v109 = *(v9 + 488);
                  v110 = v106[1];
                  if (*(v9 + 8))
                  {
                    if (v108 < v110)
                    {
                      v111 = 4 * v108;
                      do
                      {
                        v112 = vsubq_f32(*(a4 + v111), vmlaq_f32(vmulq_n_f32(*(v109 + v111), v105), *&v65[v111 / 4], v99));
                        *(a4 + v111) = vsubq_f32(v112, *(a3 + v111));
                        *(a3 + v111) = vaddq_f32(*(a3 + v111), v112);
                        v107 += 4;
                        v111 += 16;
                      }

                      while (v107 < v110);
                    }
                  }

                  else if (v107 < v110)
                  {
                    v113 = 4 * v108;
                    do
                    {
                      v114 = vsubq_f32(*(a4 + v113), vmlaq_f32(vmulq_n_f32(*(v109 + v113), v105), *&v65[v113 / 4], v99));
                      *(a4 + v113) = vsubq_f32(*(a3 + v113), v114);
                      *(a3 + v113) = vaddq_f32(*(a3 + v113), v114);
                      v107 += 4;
                      v113 += 16;
                    }

                    while (v107 < v110);
                  }
                }
              }
            }

            v65 = (v65 + v123);
            a3 += v122;
            a4 += v122;
            ++v131;
            v68 = v125;
            ++v128;
          }

          while (v128 < *(v129 + v125));
          v62 = *(v129 + 8);
        }

        ++v68;
      }

      while (v68 < v62);
    }
  }

  else
  {
    v18 = *(a2 + 12);
    v19 = 24;
    if (v18 != 2)
    {
      v19 = 16;
    }

    v20 = *(a2 + 8);
    if (*(a2 + 8))
    {
      v21 = 0;
      v22 = *(a1 + 40);
      v23 = *(v22 + v19);
      if (v18 == 2)
      {
        v24 = *(v22 + 8) >> 3;
      }

      else
      {
        v24 = *(v22 + 8);
      }

      v25 = a5;
      v26 = 4 * v24;
      do
      {
        if (*(a2 + v21))
        {
          v27 = 0;
          v28 = 1 << v21;
          v130 = v21;
          do
          {
            if (*(a2 + 17))
            {
              v29 = 0;
              v30 = a5;
              do
              {
                if ((v28 & *(*(a1 + 16) + v29)) != 0)
                {
                  v33 = v23 + 2 * v29;
                  v31 = *v33;
                  v32 = *(v33 + 2) - v31;
                  LODWORD(v33) = v32 >> 2;
                  if (v32 <= 0xB)
                  {
                    if (v32 >= 4)
                    {
                      if (v33 <= 1)
                      {
                        v33 = 1;
                      }

                      else
                      {
                        v33 = v33;
                      }

                      v43 = 4 * v31;
                      do
                      {
                        v44 = *(a3 + v43);
                        v45 = *(a4 + v43);
                        *(a3 + v43) = vaddq_f32(v44, v45);
                        *(a4 + v43) = vsubq_f32(v44, v45);
                        v43 += 16;
                        --v33;
                      }

                      while (v33);
                    }
                  }

                  else
                  {
                    v34 = (a3 + 4 * v31);
                    v35 = (a4 + 4 * v31);
                    v36 = v35[1];
                    v37 = v34[1];
                    v38 = vaddq_f32(*v34, *v35);
                    v39 = vsubq_f32(*v34, *v35);
                    v40 = (v33 - 2);
                    if (v33 == 2)
                    {
                      v40 = 0;
                    }

                    else
                    {
                      v41 = 4 * v31;
                      v42 = (v33 - 2);
                      do
                      {
                        *(a3 + v41) = v38;
                        *(a4 + v41) = v39;
                        v38 = vaddq_f32(v36, v37);
                        v39 = vsubq_f32(v37, v36);
                        v36 = *(a4 + v41 + 32);
                        v37 = *(a3 + v41 + 32);
                        v41 += 16;
                        --v42;
                      }

                      while (v42);
                    }

                    v34[v40] = v38;
                    v35[v40] = v39;
                    v46 = v33 - 1;
                    v34[v46] = vaddq_f32(v36, v37);
                    v35[v46] = vsubq_f32(v37, v36);
                  }
                }

                ++v29;
                v47 = *(a2 + 17);
              }

              while (v29 < v47);
            }

            else
            {
              LODWORD(v47) = 0;
              v30 = a5;
            }

            if (v30 <= a6)
            {
              if (a6 > v30 && v47 < a6)
              {
                v50 = *(a1 + 16);
                v47 = v47;
                do
                {
                  if ((v28 & *(v50 + v47)) != 0)
                  {
                    v51 = *(v23 + 2 * v47++);
                    v52 = *(v23 + 2 * v47);
                    if (v51 < v52)
                    {
                      v53 = v51;
                      v54 = v52;
                      do
                      {
                        v55 = *(a4 + 4 * v53);
                        *(a3 + 4 * v53) = v55;
                        *(a4 + 4 * v53++) = -v55;
                      }

                      while (v53 < v54);
                    }
                  }

                  else
                  {
                    ++v47;
                  }
                }

                while (v47 != a6);
              }
            }

            else if (v47 < v30)
            {
              v48 = v47;
              do
              {
                if ((v28 & *(*(a1 + 16) + v48)) != 0)
                {
                  v49 = *(v23 + 2 * v48++);
                  memcpy((a4 + 4 * v49), (a3 + 4 * v49), 4 * (*(v23 + 2 * v48) - v49));
                }

                else
                {
                  ++v48;
                }
              }

              while (v48 != v25);
            }

            a3 += v26;
            a4 += v26;
            ++v27;
            a2 = v129;
            v21 = v130;
          }

          while (v27 < *(v129 + v130));
          v20 = *(v129 + 8);
        }

        ++v21;
      }

      while (v21 < v20);
    }

    if (*(a1 + 8) == 2)
    {
      v56 = *(a1 + 16);
      v57 = *(a1 + 24) - v56;

      bzero(v56, v57);
    }
  }
}

void lpd_dec::lpdDecoder::Decode(lpd_dec::lpdDecoder *this, float *a2, int a3, unsigned int *a4, int32x4_t a5, int32x4_t a6)
{
  v6 = a3;
  v8 = 0;
  v158 = *MEMORY[0x1E69E9840];
  v9 = this + 5924;
  v132 = this + 4144;
  v140 = this + 4440;
  v136 = (this + 4156);
  v137 = this + 1536;
  v135 = this + 4432;
  v134 = 2 * a3;
  v133 = this + 4464;
  v10 = (a3 / 2);
  v131 = this + 4436;
  a5.i32[0] = 96;
  a6.i32[0] = a3 & 0xFFFFFFFE;
  v11 = vdupq_lane_s32(*&vceqq_s32(a6, a5), 0);
  v130 = vbslq_s8(v11, xmmword_19B0B3500, xmmword_19B0B34F0);
  v129 = vbslq_s8(v11, xmmword_19B0B3520, xmmword_19B0B3510);
  v128 = vbslq_s8(v11, xmmword_19B0B3540, xmmword_19B0B3530);
  v127 = vbslq_s8(v11, xmmword_19B0B3560, xmmword_19B0B3550);
  v126 = vbslq_s8(v11, xmmword_19B0B3580, xmmword_19B0B3570);
  v125 = vbslq_s8(v11, xmmword_19B0B35A0, xmmword_19B0B3590);
  v124 = vbslq_s8(v11, xmmword_19B0B35C0, xmmword_19B0B35B0);
  v12 = (a3 + (a3 >> 31)) & 0xFFFFFFFE;
  v123 = &__C[4 * (v12 | 1)];
  v122 = vbslq_s8(v11, xmmword_19B0B35E0, xmmword_19B0B35D0);
  v121 = (&__Or + (v12 | 1));
  if ((a3 & 0xFFFFFFFE) == 0x60)
  {
    v13 = 280;
  }

  else
  {
    v13 = 272;
  }

  __Ii = &__Or + v12;
  __Oi = &__C[4 * v12];
  v14 = *(this + 1480);
  v117 = a2 + 3;
  v119 = this + 5924;
  do
  {
    v15 = v8;
    v16 = *&v9[4 * v8];
    if (!v16)
    {
      if (v14 < 1 || v14 == 255)
      {
        goto LABEL_87;
      }

      v32 = *(this + 1038);
      if (v14 >= 3)
      {
        v33 = 3;
      }

      else
      {
        v33 = v14;
      }

      goto LABEL_86;
    }

    v17 = v134 * v8;
    v18 = v134 * v15;
    v19 = &tcx_dec::lg_table_ccfl[4];
    if (v6 == 128)
    {
      v19 = tcx_dec::lg_table_ccfl;
    }

    v20 = v19[v16];
    v21 = (v20 >> 4);
    v22 = 2.0;
    if (v21 >= 3)
    {
      v23 = &v117[v17];
      v24 = 2;
      v25 = 0.0;
      v26 = 2;
      do
      {
        v27 = *v23 * *v23;
        if ((v27 + (*(v23 - 1) * *(v23 - 1))) > v25)
        {
          v26 = v24;
          v25 = v27 + (*(v23 - 1) * *(v23 - 1));
        }

        v24 += 2;
        v23 += 2;
      }

      while (v24 < v21);
      v22 = v26;
    }

    v28 = v20;
    v29 = (v28 + v28) / v22;
    if (v29 >= 256.0)
    {
      LOWORD(v31) = 256;
    }

    else
    {
      v30 = v29;
      do
      {
        v30 = v29 + v30;
      }

      while (v30 < 256.0);
      v31 = (v30 - v29);
    }

    v34 = v135[v15];
    v35 = &a2[v17];
    *(this + 2142) = v31;
    *(this + 4286) = v34;
    v36 = vcvts_n_f32_s32(8 - v34, 4uLL);
    v37 = v20 / 6;
    if (v20 / 6 < v20 - 7)
    {
      v38 = *a4;
      v39 = v37;
      v40 = &a2[v18 + v37];
      do
      {
        v41 = &v35[v39];
        if (*v41 == 0.0 && v41[1] == 0.0 && v41[2] == 0.0 && v41[3] == 0.0 && v41[4] == 0.0 && v41[5] == 0.0 && v41[6] == 0.0 && v41[7] == 0.0)
        {
          for (i = 0; i != 8; ++i)
          {
            v38 = 69069 * v38 + 5;
            if ((v38 & 0x10000) != 0)
            {
              v43 = -v36;
            }

            else
            {
              v43 = v36;
            }

            v40[i] = v43;
          }

          *a4 = v38;
        }

        v39 += 8;
        v40 += 8;
      }

      while (v39 < v20 - 7);
      v37 = v39;
    }

    v145 = v15;
    v44 = (v20 - v37);
    if (v44 >= 1)
    {
      if (v44 > 7)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "void tcx_dec::tcxDecoder::Decode(float *, const int32_t, uint32_t &, const array<array<float, kLpFilterOrder>, kNbDiv + 1> &, const lpdMode, const lpdMode, const int32_t, const BOOL)";
        exception[2] = 195;
      }

      v45 = 0;
      v46 = 0;
      do
      {
        while (v46)
        {
          ++v45;
          v46 = 1;
          if (v45 == v44)
          {
            goto LABEL_57;
          }
        }

        v47 = v35[v37 + v45];
        v46 = v47 != 0.0;
        ++v45;
      }

      while (v45 != v44);
      if (v20 > v37 && v47 == 0.0)
      {
        v48 = *a4;
        v49 = v20 - v37;
        v50 = &a2[v37 + v18];
        do
        {
          v48 = 69069 * v48 + 5;
          if ((v48 & 0x10000) != 0)
          {
            v51 = -v36;
          }

          else
          {
            v51 = v36;
          }

          *v50++ = v51;
          --v49;
        }

        while (v49);
        *a4 = v48;
      }
    }

LABEL_57:
    v138 = v20;
    v139 = v134 * v15;
    __N = v20;
    v52 = &v133[64 * v15];
    if (!v14)
    {
      v53 = v16;
      lpc_com::lsp2a(v147, &v137[64 * v145]);
      LODWORD(v16) = v53;
      v54 = v147[0];
      v55 = v147[1];
      v56 = v147[3];
      v52[2] = v147[2];
      v52[3] = v56;
      *v52 = v54;
      v52[1] = v55;
    }

    v57 = 1 << (v16 - 1);
    if (v16 <= 1)
    {
      v57 = 1;
    }

    v58 = v57 + v145;
    lpc_com::lsp2a(v146, &v137[64 * v58]);
    v59 = v146[0];
    v60 = v146[1];
    v61 = v146[3];
    v62 = &v133[64 * v58];
    v62[2] = v146[2];
    v62[3] = v61;
    *v62 = v59;
    v62[1] = v60;
    v59.i64[0] = -1;
    v59.i64[1] = -1;
    v157 = v59;
    v156 = v59;
    v155 = v59;
    *&__C[64] = v59;
    *&__C[48] = v59;
    *&__C[32] = v59;
    *&__C[16] = v59;
    *__C = v59;
    if (__N >= 4)
    {
      v63 = 0;
      v64 = v138 >> 2;
      v65 = 0.0;
      v66 = v35;
      do
      {
        v67 = 0;
        v68 = 0.0;
        do
        {
          v68 = (v68 + (v66[v67] * v66[v67])) + (v66[v67 + 1] * v66[v67 + 1]);
          v67 += 2;
        }

        while ((v67 * 4) != 32);
        v69 = v68 + 0.01;
        *&__C[v63 >> 1] = v69;
        if (v69 > v65)
        {
          v65 = v69;
        }

        v63 += 8;
        v66 += 8;
      }

      while (v63 < v64);
      v70 = 0;
      v71 = __C;
      v72 = 0.1;
      v73 = v35;
      v74 = v136;
      do
      {
        v75 = *v71++;
        v76 = sqrtf(v75 / v65);
        if (v76 > v72)
        {
          v72 = v76;
        }

        v77 = vmulq_n_f32(v73[1], v72);
        *v73 = vmulq_n_f32(*v73, v72);
        v73[1] = v77;
        v73 += 2;
        *v74++ = v72;
        v70 += 8;
      }

      while (v70 < v64);
    }

    v15 = v145;
    v78 = v131[v145];
    *__C = -1;
    vDSP_svesq(v35, 1, __C, __N);
    v79.i32[1] = -1;
    v79.f32[0] = *__C + 0.01;
    v80 = vrsqrte_f32(v79);
    v81 = vmul_f32(v80, vrsqrts_f32(v79, vmul_f32(v80, v80)));
    *&v140[4 * v145] = __exp10f(v78 / 28.0) * (v28 * vmul_f32(v81, vrsqrts_f32(v79, vmul_f32(v81, v81))).f32[0]);
    if (v10 != 48 && v10 != 64)
    {
      v116 = __cxa_allocate_exception(0x10uLL);
      *v116 = "void tcx_dec::tcxDecoder::lpc2mdctAndNoiseShaping(float *const, const int32_t, const int32_t, const simd_float16 &, const simd_float16 &)";
      v116[2] = 339;
    }

    bzero(&__C[64], 0x3C0uLL);
    bzero(&v153.u64[1] + 4, 0x3C0uLL);
    v82 = vmulq_f32(v52[3], xmmword_19B0B35F0);
    v83 = vmulq_f32(v52[2], xmmword_19B0B3600);
    v84 = vmulq_f32(v52[1], xmmword_19B0B3610);
    v85 = vmulq_f32(*v52, xmmword_19B0B3620);
    v86 = vmulq_f32(v62[3], xmmword_19B0B35F0);
    v87 = vmulq_f32(v62[2], xmmword_19B0B3600);
    v88 = vmulq_f32(v62[1], xmmword_19B0B3610);
    v89 = vmulq_f32(*v62, xmmword_19B0B3620);
    *&__C[52] = vmulq_f32(v130, v82);
    *&__C[36] = vmulq_f32(v129, v83);
    *&__C[20] = vmulq_f32(v128, v84);
    *&__C[4] = vmulq_f32(v127, v85);
    v123[2] = vmulq_f32(v125, vnegq_f32(v83));
    v123[3] = vmulq_f32(v126, vnegq_f32(v82));
    *v123 = vmulq_f32(v122, vnegq_f32(v85));
    v123[1] = vmulq_f32(v124, vnegq_f32(v84));
    v153 = vmulq_f32(v130, v86);
    v152 = vmulq_f32(v129, v87);
    v151 = vmulq_f32(v128, v88);
    v150 = vmulq_f32(v127, v89);
    v121[2] = vmulq_f32(v125, vnegq_f32(v87));
    v121[3] = vmulq_f32(v126, vnegq_f32(v86));
    *v121 = vmulq_f32(v122, vnegq_f32(v89));
    v121[1] = vmulq_f32(v124, vnegq_f32(v88));
    *__C = 1065353216;
    __Or = 1.0;
    vDSP_DFT_Execute(*&v132[v13], __C, __Oi, __C, __Oi);
    vDSP_DFT_Execute(*&v132[v13], &__Or, __Ii, &__Or, __Ii);
    __A.realp = __C;
    __A.imagp = __Oi;
    vDSP_zvmags(&__A, 1, __C, 1, v10);
    __A.realp = &__Or;
    __A.imagp = __Ii;
    vDSP_zvmags(&__A, 1, &__Or, 1, v10);
    v90 = 0;
    v91 = v10 >> 2;
    do
    {
      v92 = 4 * v90;
      v93 = *&__C[v92];
      v94 = vrsqrteq_f32(v93);
      v95 = vmulq_f32(v94, vrsqrtsq_f32(v93, vmulq_f32(v94, v94)));
      v96 = *(&__Or + v92);
      v97 = vrsqrteq_f32(v96);
      v98 = vmulq_f32(v95, vrsqrtsq_f32(v93, vmulq_f32(v95, v95)));
      v99 = vmulq_f32(v97, vrsqrtsq_f32(v96, vmulq_f32(v97, v97)));
      *&__C[v92] = v98;
      *(&__Or + v92) = vmulq_f32(v99, vrsqrtsq_f32(v96, vmulq_f32(v99, v99)));
      v90 += 4;
      --v91;
    }

    while (v91);
    v6 = a3;
    if (a3 >= 2)
    {
      v100 = 0;
      v101 = 0;
      v102 = __N / v10;
      v103 = 0.0;
      do
      {
        v104 = *&__C[4 * v100];
        if (v104 < 0.0)
        {
          v113 = __cxa_allocate_exception(0x10uLL);
          *v113 = "void tcx_dec::tcxDecoder::lpc2mdctAndNoiseShaping(float *const, const int32_t, const int32_t, const simd_float16 &, const simd_float16 &)";
          v113[2] = 441;
        }

        v105 = *(&__Or + v100);
        if (v105 < 0.0)
        {
          v114 = __cxa_allocate_exception(0x10uLL);
          *v114 = "void tcx_dec::tcxDecoder::lpc2mdctAndNoiseShaping(float *const, const int32_t, const int32_t, const simd_float16 &, const simd_float16 &)";
          v114[2] = 442;
        }

        v106 = v100 * v102;
        if (v106 < ++v100 * v102)
        {
          v107 = &a2[v139 + v101];
          v108 = 1.0 / (v104 + v105);
          v109 = ((v104 + v104) * v105) * v108;
          v110 = (v105 - v104) * v108;
          v111 = __N / v10;
          do
          {
            v103 = (v109 * *v107) + (v110 * v103);
            *v107++ = v103;
            --v111;
          }

          while (v111);
        }

        v101 += v102;
      }

      while (v100 != v10);
    }

    v32 = *&v140[4 * v145];
    *(this + 1038) = v32;
    v9 = v119;
    if (!*(this + 1480))
    {
      v33 = *&v119[4 * v145];
LABEL_86:
      fac_dec::facDecoder::ApplyGains(this + 4784, v15, v6, v136, v33, v32);
    }

LABEL_87:
    v14 = *&v9[4 * v15];
    *(this + 1480) = v14;
    v112 = 1 << (v14 - 1);
    if (v14 <= 1)
    {
      v112 = 1;
    }

    v8 = v112 + v15;
  }

  while (v8 < 4);
}

uint64_t ApplyTools(uint64_t result, uint64_t a2, unsigned int a3)
{
  v49 = *MEMORY[0x1E69E9840];
  v3 = *(result + 8 * a3);
  v4 = *(v3 + 48);
  if (v4[609])
  {
    v5 = 0;
    v6 = *(v3 + 32);
    v44 = *(v3 + 8);
    v43 = *(v3 + 36);
    v48 = 0xAAAAAAAAAAAAAAAALL;
    *&v7 = 0xAAAAAAAAAAAAAAAALL;
    *(&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v47[3] = v7;
    v47[4] = v7;
    v47[1] = v7;
    v47[2] = v7;
    v8 = *(v3 + 28);
    v9 = v4 + 600;
    result = 25;
    v47[0] = v7;
    v45 = v4;
    do
    {
      v10 = v9[v5];
      if (v10)
      {
        v11 = 0;
        v12 = &v45[75 * v5];
        v13 = v4;
        do
        {
          v14 = &v12[25 * v11];
          v15 = v14[24];
          if (v14[24])
          {
            v16 = v13;
            v17 = v14[24];
            v18 = v47;
            if (v14[23] == 3)
            {
              v19 = 0;
              do
              {
                *(v47 + v19) = CDKaacDec_tnsCoeff3[v13[v19] + 4];
                ++v19;
              }

              while (v15 != v19);
            }

            else
            {
              do
              {
                v20 = *v16++;
                *v18++ = CDKaacDec_tnsCoeff4[v20 + 8];
                --v17;
              }

              while (v17);
            }

            v21 = *(a2 + 20);
            v22 = v21 > 5;
            v23 = tns_max_bands_tbl[2 * v21 + (v8 == 2)];
            if (v22)
            {
              LOBYTE(v24) = v23 + 1;
            }

            else
            {
              LOBYTE(v24) = v23;
            }

            v25 = v14[20];
            if (v25 >= v24)
            {
              v25 = v24;
            }

            if (v25 >= v6)
            {
              v25 = v6;
            }

            v26 = *(a2 + 8 * (v8 == 2));
            v27 = *(v26 + 2 * v25);
            if (v14[21] >= v24)
            {
              v24 = v24;
            }

            else
            {
              v24 = v14[21];
            }

            if (v24 >= v6)
            {
              v24 = v6;
            }

            v28 = *(v26 + 2 * v24);
            if (v28 != v27)
            {
              memset(v46, 0, sizeof(v46));
              if (v15 >= 0x19)
              {
                exception = __cxa_allocate_exception(0x10uLL);
                *exception = "void CLpc_SynthesisLattice(FLOAT *, const int, const int, const FLOAT *, const int, FLOAT *)";
                exception[2] = 37;
              }

              v29 = v28 - v27;
              if (v29)
              {
                v30 = v44 + 4 * v5 * v43 + 4 * v27;
                v31 = v14[22];
                if (v31 == -1)
                {
                  v32 = (v30 + 4 * v29 - 4);
                }

                else
                {
                  v32 = v30;
                }

                v33 = v46 + v15;
                v34 = v47 + v15;
                v35 = v15 - 1;
                do
                {
                  v36 = *v32 - (*(v34 - 1) * *(v33 - 1));
                  if (v35)
                  {
                    v37 = v35;
                    v38 = v34 - 2;
                    v39 = v33 - 2;
                    do
                    {
                      v40 = *v38--;
                      v36 = v36 - (v40 * *v39);
                      v39[1] = *v39 + (v40 * v36);
                      --v39;
                      --v37;
                    }

                    while (v37);
                  }

                  else
                  {
                    v39 = v33 - 2;
                  }

                  v39[1] = v36;
                  *v32 = v36;
                  v32 += v31;
                  --v29;
                }

                while (v29);
                v10 = v9[v5];
              }
            }
          }

          ++v11;
          v13 += 25;
        }

        while (v11 < v10);
      }

      if (v8 != 2)
      {
        break;
      }

      v4 += 75;
    }

    while (v5++ < 7);
  }

  return result;
}

float fac_dec::facDecoder::ApplyGains(uint64_t a1, int a2, unsigned int a3, uint64_t a4, int a5, float result)
{
  v6 = a5;
  v9 = *(a1 + 8 * a2 + 512);
  if (a3 != 96 && a3 != 128)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void fac_dec::facDecoder::ApplyGains(const int32_t, const int32_t, const float, const array<float, kLFac / 4> &, const lpdMode)";
    exception[2] = 98;
  }

  if (v9)
  {
    v12 = fac_dec::gainFac[a5] * result;
    MEMORY[0x19EAE6090](v9, 1, &v12, v9, 1, a3);
    v10 = 0;
    do
    {
      result = *(a4 + 4 * (v10 >> (3 - v6))) * *(v9 + 4 * v10);
      *(v9 + 4 * v10++) = result;
    }

    while (a3 >> 2 != v10);
  }

  return result;
}

uint64_t lpc_com::lsp2a(_OWORD *a1, uint64_t a2)
{
  v34[0] = NAN;
  *&v4 = -1;
  *(&v4 + 1) = -1;
  v33[0] = v4;
  v33[1] = v4;
  v32[0] = NAN;
  v31[0] = v4;
  v31[1] = v4;
  lpc_com::get_lsppol(a2, v33, 1u);
  result = lpc_com::get_lsppol(a2, v31, 2u);
  v6 = 0;
  v7 = vld1q_dup_f32(v32);
  v8 = vld1q_dup_f32(v34);
  do
  {
    v9 = vrev64q_s32(v33[v6 + 1]);
    v10 = vextq_s8(v9, v9, 8uLL);
    v11 = vrev64q_s32(vaddq_f32(v10, vextq_s8(v8, v10, 0xCuLL)));
    *(&v33[v6 + 1] + 4) = vextq_s8(v11, v11, 8uLL);
    v12 = vrev64q_s32(v31[v6 + 1]);
    v13 = vextq_s8(v12, v12, 8uLL);
    v14 = vrev64q_s32(vsubq_f32(vextq_s8(v7, v13, 0xCuLL), v13));
    *(&v31[v6-- + 1] + 4) = vextq_s8(v14, v14, 8uLL);
    v7 = v13;
    v8 = v10;
  }

  while (v6 != -2);
  v15 = 0uLL;
  v16 = 15;
  v17 = 1;
  v18 = 0uLL;
  v19 = 0uLL;
  v20 = 0uLL;
  do
  {
    v21 = *(v33 + v17);
    v22 = *(v31 + v17);
    v27 = v15;
    v28 = v18;
    v29 = v19;
    v30 = v20;
    *(&v27 + ((v17 - 1) & 0xF)) = (v21 + v22) * 0.5;
    v25 = v29;
    v26 = v30;
    v23 = v27;
    v24 = v28;
    *(&v23 + (v16 & 0xF)) = (v21 - v22) * 0.5;
    v19 = v25;
    v20 = v26;
    v15 = v23;
    v18 = v24;
    ++v17;
    --v16;
  }

  while (v17 != 9);
  *a1 = v23;
  a1[1] = v18;
  a1[2] = v19;
  a1[3] = v20;
  return result;
}

uint64_t lpc_com::get_lsppol(uint64_t result, uint64_t a2, unsigned int a3)
{
  v3 = 0;
  v4 = result + 4 * a3;
  *a2 = 1065353216;
  v6 = *(v4 - 4);
  v5 = v4 - 4;
  *(a2 + 4) = v6 * -2.0;
  v7 = (a2 + 4);
  for (i = 2; i != 9; ++i)
  {
    v9 = *(v5 + 8);
    v5 += 8;
    v10 = v9 * -2.0;
    *(a2 + 4 * i) = (*(a2 + 4 * i - 8) + *(a2 + 4 * i - 8)) + ((v9 * -2.0) * *(a2 + 4 * i - 4));
    v11 = v3;
    if (i >= 3)
    {
      do
      {
        v7[v11] = (v7[v11] + (v10 * *(a2 + 4 * v11))) + *(a2 + 4 * (v11 - 1));
        v12 = v11-- + 1;
      }

      while (v12 > 2);
    }

    *v7 = v10 + *v7;
    ++v3;
  }

  return result;
}

void MPEG_D::USAC::ComplexPrediction::EstimateMDST(MPEG_D::USAC::ComplexPrediction *this, const float *a2, const float *a3, float *__C, vDSP_Length __N, char a6)
{
  v7 = __N;
  v9 = a2 - 3;
  if ((a6 & 1) == 0)
  {
    __C = *(this + 64);
  }

  v11 = 0;
  v12 = __N + 3;
  v13 = __N - 1;
  v14 = 0x3FFFFFFFFFFFFFFFLL;
  do
  {
    a2[v14] = a2[v11];
    v9[v12] = a2[v13];
    ++v11;
    ++v12;
    --v13;
    --v14;
  }

  while (v11 != 3);
  vDSP_conv(v9, 1, a3 + 6, -1, __C, 1, __N, 7uLL);
  if ((a6 & 1) == 0)
  {
    MEMORY[0x19EAE5FB0](__C, 2, __C, 2, v7 >> 1);

    JUMPOUT(0x19EAE5DC0);
  }
}

uint64_t MPEG_D::USAC::ChannelPairElement::Deserialize(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, int a5, uint64_t *a6)
{
  bzero(*(*a3 + 48), 0x262uLL);
  bzero(*(a3[1] + 48), 0x262uLL);
  *(*(*a3 + 48) + 614) = 0;
  *(*(*a3 + 48) + 615) = 0;
  v10 = a3[1];
  *(*(*a3 + 48) + 611) = 0;
  *(*(v10 + 48) + 611) = 0;
  v11 = *a6;
  *(v11 + 5912) = TBitstreamReader<unsigned int>::GetBit(a2);
  v12 = *a6;
  *(v12 + 11864) = TBitstreamReader<unsigned int>::GetBit(a2);
  if (*(*a6 + 5912) || *(*a6 + 11864))
  {
    v13 = *(a1 + 1400);
    if (v13)
    {
      v14 = (v13 + 256);
      v15 = 8;
      do
      {
        bzero(*(v14 - 25), *(v14 - 24) - *(v14 - 25));
        bzero(*(v14 - 1), *v14 - *(v14 - 1));
        v14 += 3;
        --v15;
      }

      while (v15);
    }

    v16 = 0;
    goto LABEL_7;
  }

  *(*(*a3 + 48) + 614) = TBitstreamReader<unsigned int>::GetBit(a2);
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  v31 = *a3;
  v30 = a3[1];
  *(*(*a3 + 48) + 611) = Bit;
  *(*(v30 + 48) + 611) = Bit;
  if (!Bit || a5)
  {
    v32 = *(a1 + 1400);
    if (v32)
    {
      v33 = (v32 + 256);
      v34 = 8;
      do
      {
        bzero(*(v33 - 25), *(v33 - 24) - *(v33 - 25));
        bzero(*(v33 - 1), *v33 - *(v33 - 1));
        v33 += 3;
        --v34;
      }

      while (v34);
      v31 = *a3;
    }

    if (!Bit)
    {
      goto LABEL_117;
    }
  }

  v35 = *(a1 + 1400);
  if (v35)
  {
    v36 = *(v31 + 26);
    *(v35 + 11) = *(v31 + 28);
    *(v35 + 12) = v36;
  }

  result = MPEG_D::USAC::ICSInfo::Deserialize(v31 + 8, a2, *(a1 + 16));
  if (result)
  {
    return result;
  }

  v37 = a3[1];
  v38 = *(*a3 + 16);
  *(v37 + 32) = *(*a3 + 32);
  *(v37 + 16) = v38;
  if (!TBitstreamReader<unsigned int>::GetBit(a2))
  {
    result = MPEG_D::USAC::ICSInfo::ReadMaxSfb(a3[1] + 8, a2, *(a1 + 16));
    if (result)
    {
      return result;
    }
  }

  v40 = *a3;
  v39 = a3[1];
  if (*(*a3 + 32) <= *(v39 + 32))
  {
    v41 = *(v39 + 32);
  }

  else
  {
    v41 = *(*a3 + 32);
  }

  *(v40 + 33) = v41;
  *(v39 + 33) = v41;
  v42 = *(a2 + 20);
  v43 = v42 >> 30;
  v44 = *(a2 + 24) - 2;
  *(a2 + 24) = v44;
  if (v44 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v47 = *(a2 + 20);
    v46 = *(a2 + 24);
    v43 |= v47 >> v46;
    *(a2 + 24) = v46 + 32;
    if (v46 == -32)
    {
      v45 = 0;
    }

    else
    {
      v45 = v47 << -v46;
    }
  }

  else
  {
    v45 = 4 * v42;
  }

  *(a2 + 20) = v45;
  *(a1 + 1360) = v43;
  bzero(*(a1 + 1368), *(a1 + 1376) - *(a1 + 1368));
  *(a1 + 1361) = 0;
  v48 = *(a1 + 1360);
  if (v48 != 3)
  {
    if (v48 != 2)
    {
      if (v48 == 1)
      {
        v49 = *(v40 + 24);
        if (*(v40 + 24))
        {
          v50 = 0;
          do
          {
            if (v41)
            {
              for (i = 0; i != v41; ++i)
              {
                *(*(a1 + 1368) + i) |= TBitstreamReader<unsigned int>::GetBit(a2) << v50;
              }

              v49 = *(v40 + 24);
            }

            ++v50;
          }

          while (v50 < v49);
        }
      }

      goto LABEL_62;
    }

    v52 = *(a1 + 1368);
    v53 = *(a1 + 1376) - v52;
    if (v53 < 1)
    {
      goto LABEL_62;
    }

    v54 = 255;
LABEL_61:
    memset(v52, v54, v53);
    goto LABEL_62;
  }

  if (!*(a1 + 1400))
  {
    return 16386;
  }

  *(a1 + 1361) = 1;
  if (TBitstreamReader<unsigned int>::GetBit(a2))
  {
    if (!v41)
    {
      goto LABEL_62;
    }

    v52 = *(a1 + 1368);
    v54 = ~(-1 << *(v40 + 24));
    v53 = v41;
    goto LABEL_61;
  }

  v109 = *(v40 + 24);
  if (*(v40 + 24))
  {
    v110 = 0;
    do
    {
      if (v41)
      {
        for (j = 0; j < v41; j += 2)
        {
          v112 = TBitstreamReader<unsigned int>::GetBit(a2) << v110;
          *(*(a1 + 1368) + j) |= v112;
          if (j + 1 < *(v40 + 35))
          {
            *(*(a1 + 1368) + j + 1) |= v112;
          }
        }

        v109 = *(v40 + 24);
      }

      ++v110;
    }

    while (v110 < v109);
  }

LABEL_62:
  v55 = *(a1 + 1400);
  if (!v55)
  {
    goto LABEL_116;
  }

  __dst = *(a1 + 1400);
  if (*(a1 + 1361) != 1)
  {
    v58 = *(v40 + 24);
    *(v55 + 8) = 0;
    *(v55 + 10) = 0;
    if (v58)
    {
      v59 = (v55 + 256);
      v60 = v58;
      do
      {
        bzero(*(v59 - 25), *(v59 - 24) - *(v59 - 25));
        bzero(*(v59 - 1), *v59 - *(v59 - 1));
        v59 += 3;
        --v60;
      }

      while (v60);
      __dst[13] = v58;
    }

    goto LABEL_116;
  }

  *(v55 + 8) = 0;
  *(v55 + 10) = 0;
  v56 = *(v55 + 11);
  if (*(v40 + 28) != 2)
  {
    if (v56 == 2)
    {
      goto LABEL_66;
    }

LABEL_72:
    v57 = 56;
    goto LABEL_73;
  }

  if (v56 == 2)
  {
    goto LABEL_72;
  }

LABEL_66:
  v57 = 248;
LABEL_73:
  v61 = (v57 + v55 + 8);
  v62 = 8;
  do
  {
    bzero(*(v61 - 1), *v61 - *(v61 - 1));
    v61 += 3;
    --v62;
  }

  while (v62);
  __dst[8] = TBitstreamReader<unsigned int>::GetBit(a2);
  v63 = TBitstreamReader<unsigned int>::GetBit(a2);
  __dst[9] = v63 != 0;
  if (!v63)
  {
    if (a5)
    {
      v65 = 1;
LABEL_82:
      v119 = v65;
      v64 = __dst;
      goto LABEL_83;
    }

LABEL_81:
    v65 = TBitstreamReader<unsigned int>::GetBit(a2) == 0;
    goto LABEL_82;
  }

  if (!a5)
  {
    __dst[10] = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
    goto LABEL_81;
  }

  v64 = __dst;
  __dst[10] = 0;
  v119 = 1;
LABEL_83:
  v124 = a2;
  v125 = 0;
  LOBYTE(v66) = *(v40 + 24);
  if (!v66)
  {
LABEL_112:
    v89 = 0;
    v64[13] = v66;
    goto LABEL_114;
  }

  v117 = 0;
  v118 = v41;
  v67 = v64 + 248;
  v113 = (4 * v41) | 2;
  v114 = v64 + 56;
  v115 = v40;
  v116 = a2;
  while (!v41)
  {
LABEL_107:
    v82 = &v114[24 * v117];
    v83 = *v82;
    v84 = (v82[1] - *v82) >> 2;
    if (v84 > v41)
    {
      v85 = v41 - v84;
      v86 = v67[3 * v117] + v113;
      v87 = v83 + v113;
      do
      {
        *(v87 - 2) = 0;
        *(v86 - 2) = 0;
        v86 += 4;
        v87 += 4;
      }

      while (!__CFADD__(v85++, 1));
    }

    v66 = *(v115 + 24);
    if (++v117 >= v66)
    {
      goto LABEL_112;
    }
  }

  v68 = 0;
  v69 = &v114[24 * v117];
  v70 = 2;
  while ((v119 & 1) != 0)
  {
    if (!v68)
    {
      LOWORD(v74) = 0;
      LOWORD(v73) = 0;
      goto LABEL_96;
    }

    v71 = v68 - 1;
    v72 = &v114[24 * v117];
LABEL_95:
    v73 = *(*v72 + 4 * v71);
    v74 = HIWORD(v73);
LABEL_96:
    if (((1 << v117) & *(*(a1 + 1368) + v68)) != 0)
    {
      v75 = a6;
      v76 = v67;
      v77 = MPEG_D::USAC::ComplexPrediction::DecodeHuffman(__dst, &v124);
      v78 = v77;
      v64 = __dst;
      if (__dst[9] == 1)
      {
        v79 = MPEG_D::USAC::ComplexPrediction::DecodeHuffman(__dst, &v124);
        v64 = __dst;
        *(*v69 + 4 * v68) = (v73 - v78) | ((v74 - v79) << 16);
        v80 = *v69;
      }

      else
      {
        v80 = *v69;
        v81 = (*v69 + v70);
        *(v81 - 1) = v73 - v77;
        *v81 = 0;
      }

      v67 = v76;
      a6 = v75;
      a2 = v116;
    }

    else
    {
      v80 = *v69;
      *(*v69 + v70 - 2) = 0;
    }

    v41 = v118;
    if (v68 + 1 < v118)
    {
      *(v80 + v70 + 2) = *(v80 + v70 - 2);
      v80 = *v69;
    }

    *(v67[3 * v117] + 4 * v68) = *(v80 + 4 * v68);
    v68 += 2;
    v70 += 8;
    if (v68 >= v118)
    {
      goto LABEL_107;
    }
  }

  v71 = v68;
  v72 = v69 - 3;
  if (v117)
  {
    goto LABEL_95;
  }

  v71 = v68;
  v72 = v67;
  if (*(v115 + 28) != 2)
  {
    goto LABEL_95;
  }

  v71 = v68;
  v72 = v67;
  if (v64[11] != 2)
  {
    goto LABEL_95;
  }

  if (v64[13])
  {
    v72 = &v67[3 * v64[13] - 3];
    v71 = v68;
    goto LABEL_95;
  }

  v89 = -1;
LABEL_114:
  TBitstreamReader<unsigned int>::PutBack(v124, SHIDWORD(v125));
  if (v89)
  {
    return 16386;
  }

LABEL_116:
  v31 = *a3;
LABEL_117:
  v90 = *(v31 + 48);
  if (!v90[614])
  {
    v16 = 1;
    v90[615] = 1;
    goto LABEL_7;
  }

  __dsta = *(a3[1] + 48);
  v91 = v90[611];
  v92 = USACBitstreamReader::operator CDK_BITSTREAM *(a2);
  v93 = v92;
  v94 = v92[5];
  v95 = v92[1];
  if (v91)
  {
    if (v95)
    {
      v96 = *v92;
      v92[1] = v95 - 1;
      v97 = v96 & (1 << (v95 - 1));
      if (v95 == 1)
      {
        v102 = CDK_get32((v92 + 2));
        v98 = v102 >> 31;
        *v93 = v102;
        v93[1] = 31;
      }

      else
      {
        v92[1] = v95 - 2;
        v98 = (v96 >> (v95 - 2)) & 1;
      }

      v90[615] = v98;
      if (v97)
      {
LABEL_129:
        v90[608] = 1;
        CTns_Read(v93, v90, v31 + 16);
        *(v90 + 304) = 256;
        memcpy(__dsta, v90, 0x263uLL);
        v103 = v93[1];
        goto LABEL_140;
      }
    }

    else
    {
      v101 = CDK_get32((v92 + 2));
      *v93 = v101;
      v93[1] = 30;
      v90[615] = (v101 & 0x40000000) != 0;
      if ((v101 & 0x80000000) != 0)
      {
        goto LABEL_129;
      }
    }
  }

  else
  {
    if (v95)
    {
      v99 = v95 - 1;
      v100 = (*v92 >> (v95 - 1)) & 1;
    }

    else
    {
      v104 = CDK_get32((v92 + 2));
      *v93 = v104;
      v100 = v104 >> 31;
      v99 = 31;
    }

    v93[1] = v99;
    v90[615] = v100;
  }

  v105 = v93[1];
  if (!v105)
  {
    v106 = CDK_get32((v93 + 2));
    v103 = 31;
    *v93 = v106;
    v93[1] = 31;
    if ((v106 & 0x80000000) == 0)
    {
      goto LABEL_137;
    }

    goto LABEL_139;
  }

  v103 = v105 - 1;
  v106 = *v93;
  v93[1] = v103;
  if ((v106 >> v103))
  {
LABEL_139:
    v90[608] = 1;
    __dsta[608] = 1;
    goto LABEL_140;
  }

  if (!v103)
  {
    v107 = CDK_get32((v93 + 2));
    *v93 = v107;
    v108 = v107 >> 31;
    v103 = 31;
    goto LABEL_138;
  }

LABEL_137:
  v108 = (v106 >> --v103) & 1;
LABEL_138:
  v93[1] = v103;
  __dsta[608] = v108;
  v90[608] = v108 ^ 1;
LABEL_140:
  TBitstreamReader<unsigned int>::SkipBits(a2, v95 + v93[5] - (v94 + v103));
  *(a2 + 40) = *(a2 + 24) + 8 * (*(a2 + 8) - *a2);
  v16 = 1;
LABEL_7:
  v17 = 0;
  v18 = 1;
  do
  {
    while (1)
    {
      v19 = v18;
      v20 = *a6;
      v21 = *a6 + 5952 * v17;
      if (!*(v21 + 5912))
      {
        break;
      }

      result = lpd_dec::lpdDecoder::Read(v21, a2, *(a3[v17] + 36), *(a3[v17] + 8), *(*(a4 + 8 * v17) + 112) != 0, *(*(a4 + 8 * v17) + 72), *(*(a1 + 16) + 24), a5);
      if (result)
      {
        return result;
      }

      v18 = 0;
      *(a3[v17] + 44) = 3;
      v17 = 1;
      if ((v19 & 1) == 0)
      {
        goto LABEL_16;
      }
    }

    if ((v16 & 1) == 0)
    {
      *(*(*a3 + 48) + 608) = TBitstreamReader<unsigned int>::GetBit(a2);
      v20 = *a6;
    }

    result = MPEG_D::USAC::ChannelElement::ReadFDChanStream(a1, a2, v17, a3[v17], a5, v20 + 5952 * v17);
    v18 = 0;
    v17 = 1;
  }

  while (((result == 0) & v19) != 0);
  if (result)
  {
    return result;
  }

LABEL_16:
  v23 = 0;
  v24 = 1;
  do
  {
    while (1)
    {
      v25 = v24;
      v26 = a3[v23];
      if (*(v26 + 44) != 1)
      {
        break;
      }

      v27 = *(a4 + 8 * v23);
      v28 = (*(*a1 + 40))(a1, v23);
      result = MPEG_D::USAC::SpectralDataDecoder::Reconstruct(a1 + 576, v26 + 8, v23, v26, v27, v28 + 8);
      v24 = 0;
      v23 = 1;
      if (((result == 0) & v25) == 0)
      {
        return result;
      }
    }

    v24 = 0;
    v23 = 1;
  }

  while ((v25 & 1) != 0);
  return 0;
}

uint64_t MPEG_D::USAC::SpectralDataDecoder::Reconstruct(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v84 = a2 + 8;
  v6 = *(a2 + 24);
  v7 = *(a1 + 216);
  v8 = 16;
  if (*(a2 + 20) == 2)
  {
    v8 = 17;
  }

  v9 = *(v7 + 8 * (*(a2 + 20) == 2));
  v82 = *(v7 + v8);
  v10 = *(a4 + 36);
  v11 = *(*(a1 + 56) + 24 * a3);
  *&v12 = 0x101010101010101;
  *(&v12 + 1) = 0x101010101010101;
  *(a1 + 80) = v12;
  *(a1 + 96) = v12;
  v13 = a1 + 80;
  *(a1 + 112) = v12;
  *(a1 + 128) = v12;
  *(a1 + 144) = v12;
  *(a1 + 160) = v12;
  *(a1 + 176) = v12;
  *(a1 + 192) = v12;
  v14 = *(a2 + 16);
  if (*(a2 + 16))
  {
    v15 = 0;
    v16 = 0;
    v81 = 4 * v10;
    do
    {
      if (*(v84 + v15))
      {
        v17 = 0;
        v83 = v15;
        do
        {
          if (v6)
          {
            v18 = 0;
            do
            {
              v19 = *(v9 + 2 * v18);
              v20 = v18 + 1;
              v21 = *(v9 + 2 * (v18 + 1));
              if (v19 >= v21)
              {
LABEL_13:
                *(v13 + v18 + v16) &= 1u;
              }

              else
              {
                v22 = v19;
                v23 = v22;
                v24 = v21;
                while (*(v11 + 4 * v22) == 0.0)
                {
                  if (++v22 >= v24)
                  {
                    goto LABEL_13;
                  }
                }

                v25 = v18 + v16;
                *(v13 + v25) = 0;
                v26 = (a6 + 4 * v25);
                v27 = vld1q_dup_f32(v26);
                v86 = v27;
                do
                {
                  v89 = MPEG_D::USAC::SpectralDataDecoder::InverseQuantize(*(v11 + 4 * v23));
                  v88 = MPEG_D::USAC::SpectralDataDecoder::InverseQuantize(*(v11 + 4 * (v23 + 1)));
                  v87 = MPEG_D::USAC::SpectralDataDecoder::InverseQuantize(*(v11 + 4 * (v23 + 2)));
                  v28 = MPEG_D::USAC::SpectralDataDecoder::InverseQuantize(*(v11 + 4 * (v23 + 3)));
                  v29.i64[0] = __PAIR64__(LODWORD(v88), LODWORD(v89));
                  v29.i64[1] = __PAIR64__(LODWORD(v28), LODWORD(v87));
                  *(v11 + 4 * v23) = vmulq_f32(v86, v29);
                  v23 += 4;
                }

                while (v23 < v24);
              }

              v18 = v20;
            }

            while (v20 != v6);
          }

          v30 = *(v9 + 2 * v6);
          v31 = *(v9 + 2 * v82) - v30;
          if (v31 >= 1)
          {
            bzero((v11 + 4 * v30), 4 * v31);
          }

          v11 += v81;
          ++v17;
          v15 = v83;
        }

        while (v17 < *(v84 + v83));
        v14 = *(a2 + 16);
      }

      v16 += 16;
      ++v15;
    }

    while (v15 < v14);
  }

  v32 = *(a1 + 32);
  if (v32 != *(a1 + 40))
  {
    v33 = *(*(a1 + 56) + 24 * a3);
    if (v33)
    {
      v34 = a6 == 0;
    }

    else
    {
      v34 = 1;
    }

    if (v34)
    {
      return 0xFFFFFFFFLL;
    }

    v36 = *(*(a4 + 48) + 613);
    v37 = MPEG_D::USAC::NoiseFillingDecoder::kNoiseLevelTab[v36 >> 5];
    v38 = (v36 & 0x1F) - 16;
    v39 = *(a4 + 36);
    LODWORD(v40) = MPEG_D::USAC::ScaleFactorData::kPow2_025[v38 & 3] + (v38 >> 2 << 23);
    v41 = *(a2 + 20);
    if (v41 == 2)
    {
      v42 = 20;
    }

    else
    {
      v42 = 160;
    }

    if (v39 == 96)
    {
      v42 = (3 * v42) >> 2;
    }

    v43 = *(*(v32 + 16 * a3 + 8) + 8 * (v41 == 2));
    LODWORD(v44) = -1;
    do
    {
      v44 = (v44 + 1);
    }

    while (v42 > *(v43 + 2 * v44));
    LOWORD(v45) = *(v43 + 2 * v44);
    v46 = v40;
    if (v41 == 2)
    {
      if (v14)
      {
        v47 = 0;
        v48 = *(a5 + 80);
        v49 = *(a2 + 24);
        do
        {
          v50 = *(v84 + v47);
          if (v44 < v49)
          {
            v51 = v45;
            v52 = v44;
            do
            {
              v53 = v52 + 16 * v47;
              ++v52;
              v54 = *(v43 + 2 * v52);
              v55 = v51;
              v56 = v37 * *(a6 + 4 * v53);
              if (*(v13 + v53))
              {
                if (v50)
                {
                  v57 = 0;
                  v58 = 0;
                  v59 = v56 * v46;
                  do
                  {
                    if (v55 < v54)
                    {
                      v60 = v55;
                      do
                      {
                        v48 = 69069 * v48 + 5;
                        if ((v48 & 0x10000) != 0)
                        {
                          v61 = -v59;
                        }

                        else
                        {
                          v61 = v59;
                        }

                        *(v33 + 4 * v57 + 4 * v60++) = v61;
                      }

                      while (v60 < v54);
                      *(a5 + 80) = v48;
                    }

                    ++v58;
                    v57 += v39;
                  }

                  while (v58 != v50);
                }
              }

              else if (v50)
              {
                v62 = 0;
                for (i = 0; i != v50; ++i)
                {
                  if (v55 < v54)
                  {
                    v64 = v33 + 4 * v62;
                    v65 = v55;
                    do
                    {
                      if (*(v64 + 4 * v65) == 0.0)
                      {
                        v48 = 69069 * v48 + 5;
                        *(a5 + 80) = v48;
                        if ((v48 & 0x10000) != 0)
                        {
                          v66 = -v56;
                        }

                        else
                        {
                          v66 = v56;
                        }

                        *(v64 + 4 * v65) = v66;
                      }

                      ++v65;
                    }

                    while (v65 < v54);
                  }

                  v62 += v39;
                }
              }

              v51 = v54;
            }

            while (v52 != v49);
          }

          v33 += 4 * (v39 * v50);
          ++v47;
        }

        while (v47 != v14);
      }
    }

    else
    {
      v67 = *(a2 + 24);
      if (v44 < v67)
      {
        v68 = *(a5 + 80);
        do
        {
          v69 = v45;
          v70 = *(a6 + 4 * v44);
          v71 = *(v13 + v44++);
          v45 = *(v43 + 2 * v44);
          v72 = v37 * v70;
          if (v71)
          {
            if (v69 < v45)
            {
              v73 = v72 * v40;
              do
              {
                v68 = 69069 * v68 + 5;
                if ((v68 & 0x10000) != 0)
                {
                  v74 = -v73;
                }

                else
                {
                  v74 = v73;
                }

                *(v33 + 4 * v69++) = v74;
              }

              while (v69 < v45);
              *(a5 + 80) = v68;
            }
          }

          else if (v69 < v45)
          {
            do
            {
              if (*(v33 + 4 * v69) == 0.0)
              {
                v68 = 69069 * v68 + 5;
                *(a5 + 80) = v68;
                if ((v68 & 0x10000) != 0)
                {
                  v75 = -v72;
                }

                else
                {
                  v75 = v72;
                }

                *(v33 + 4 * v69) = v75;
              }

              ++v69;
            }

            while (v69 < v45);
          }
        }

        while (v44 != v67);
      }
    }
  }

  return 0;
}

float MPEG_D::USAC::SpectralDataDecoder::InverseQuantize(MPEG_D::USAC::SpectralDataDecoder *this)
{
  if (this < 1)
  {
    v3 = -this;
    if (this < -1023)
    {
      return -powf(v3, 1.3333);
    }

    else
    {
      return -InverseQuantTable[v3];
    }
  }

  else if (this > 0x3FF)
  {

    return powf(this, 1.3333);
  }

  else
  {
    return InverseQuantTable[this];
  }
}

uint64_t MPEG_D::USAC::ICSInfo::Deserialize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a1 + 17) = 0;
  v6 = *(a2 + 20);
  v7 = v6 >> 30;
  v8 = *(a2 + 24) - 2;
  *(a2 + 24) = v8;
  if (v8 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v11 = *(a2 + 20);
    v10 = *(a2 + 24);
    v7 |= v11 >> v10;
    *(a2 + 24) = v10 + 32;
    if (v10 == -32)
    {
      v9 = 0;
    }

    else
    {
      v9 = v11 << -v10;
    }
  }

  else
  {
    v9 = 4 * v6;
  }

  *(a2 + 20) = v9;
  *(a1 + 20) = v7;
  *(a1 + 18) = TBitstreamReader<unsigned int>::GetBit(a2);
  if (*(a1 + 20) != 2)
  {
    *(a1 + 27) = *(a3 + 16);
    v16 = *(a2 + 20);
    v17 = v16 >> 26;
    v18 = *(a2 + 24) - 6;
    *(a2 + 24) = v18;
    if (v18 < 0)
    {
      TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      *a2 += 4;
      v27 = *(a2 + 20);
      v26 = *(a2 + 24);
      v17 |= v27 >> v26;
      *(a2 + 24) = v26 + 32;
      if (v26 == -32)
      {
        v19 = 0;
      }

      else
      {
        v19 = v27 << -v26;
      }
    }

    else
    {
      v19 = v16 << 6;
    }

    *(a2 + 20) = v19;
    v33 = v17;
    *(a1 + 24) = v17;
    *(a1 + 16) = 1;
    *(a1 + 8) = 1;
    goto LABEL_30;
  }

  *(a1 + 27) = *(a3 + 17);
  v12 = *(a2 + 20);
  v13 = v12 >> 28;
  v14 = *(a2 + 24) - 4;
  *(a2 + 24) = v14;
  if (v14 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    v20 = (*a2 + 4);
    *a2 = v20;
    v22 = *(a2 + 20);
    v21 = *(a2 + 24);
    v13 |= v22 >> v21;
    v14 = v21 + 32;
    if (v21 == -32)
    {
      v23 = 0;
      *(a1 + 24) = v13;
      *(a2 + 20) = 0xFFFFFFF900000000;
      goto LABEL_19;
    }

    v15 = v22 << -v21;
  }

  else
  {
    v15 = 16 * v12;
  }

  *(a1 + 24) = v13;
  v23 = v15 >> 25;
  v24 = v14 - 7;
  *(a2 + 20) = v15;
  *(a2 + 24) = v24;
  if (v24 >= 0)
  {
    v25 = v15 << 7;
    goto LABEL_22;
  }

  v20 = *a2;
LABEL_19:
  TBitstreamReader<unsigned int>::FillCacheFrom(a2, v20);
  *a2 += 4;
  v29 = *(a2 + 20);
  v28 = *(a2 + 24);
  v23 |= v29 >> v28;
  *(a2 + 24) = v28 + 32;
  if (v28 == -32)
  {
    v25 = 0;
  }

  else
  {
    v25 = v29 << -v28;
  }

LABEL_22:
  *(a2 + 20) = v25;
  *(a1 + 26) = v23;
  *(a1 + 16) = 0;
  v30 = 7;
  v31 = (a1 + 8);
  do
  {
    *v31 = 1;
    v32 = *(a1 + 16);
    if ((*(a1 + 26) >> (v30 - 1)))
    {
      ++*(a1 + 8 + v32);
    }

    else
    {
      *(a1 + 16) = v32 + 1;
    }

    ++v31;
    --v30;
  }

  while (v30);
  *(a1 + 15) = 1;
  ++*(a1 + 16);
  v33 = *(a1 + 24);
LABEL_30:
  if (v33 > *(a1 + 27))
  {
    return 16386;
  }

  result = 0;
  *(a1 + 17) = 1;
  return result;
}

uint64_t MPEG_D::USAC::ICSInfo::ReadMaxSfb(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(a1 + 20) == 2)
  {
    *(a1 + 27) = *(a3 + 17);
    v5 = *(a2 + 20);
    v6 = v5 >> 28;
    v7 = *(a2 + 24) - 4;
    *(a2 + 24) = v7;
    if (v7 >= 0)
    {
      v8 = 16 * v5;
      goto LABEL_9;
    }

LABEL_6:
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v12 = *(a2 + 20);
    v11 = *(a2 + 24);
    v6 |= v12 >> v11;
    *(a2 + 24) = v11 + 32;
    if (v11 == -32)
    {
      v8 = 0;
    }

    else
    {
      v8 = v12 << -v11;
    }

    goto LABEL_9;
  }

  *(a1 + 27) = *(a3 + 16);
  v9 = *(a2 + 20);
  v6 = v9 >> 26;
  v10 = *(a2 + 24) - 6;
  *(a2 + 24) = v10;
  if (v10 < 0)
  {
    goto LABEL_6;
  }

  v8 = v9 << 6;
LABEL_9:
  *(a2 + 20) = v8;
  *(a1 + 24) = v6;
  if (*(a1 + 27) >= v6)
  {
    return 0;
  }

  else
  {
    return 16386;
  }
}

uint64_t MPEG_D::USAC::ChannelElement::ReadFDChanStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  v12 = *(a4 + 48);
  v13 = *(a2 + 20);
  v14 = HIBYTE(v13);
  v15 = *(a2 + 24) - 8;
  *(a2 + 24) = v15;
  if (v15 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v18 = *(a2 + 20);
    v17 = *(a2 + 24);
    v14 |= v18 >> v17;
    v15 = v17 + 32;
    *(a2 + 24) = v17 + 32;
    if (v17 == -32)
    {
      v16 = 0;
    }

    else
    {
      v16 = v18 << -v17;
    }
  }

  else
  {
    v16 = v13 << 8;
  }

  *(a2 + 20) = v16;
  v12[612] = v14;
  if (*(a1 + 12) == 1)
  {
    v19 = HIBYTE(v16);
    v20 = v15 - 8;
    *(a2 + 24) = v20;
    if (v20 < 0)
    {
      TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      *a2 += 4;
      v23 = *(a2 + 20);
      v22 = *(a2 + 24);
      v19 |= v23 >> v22;
      *(a2 + 24) = v22 + 32;
      if (v22 == -32)
      {
        v21 = 0;
      }

      else
      {
        v21 = v23 << -v22;
      }
    }

    else
    {
      v21 = v16 << 8;
    }

    *(a2 + 20) = v21;
    v12[613] = v19;
  }

  if (*(*(a4 + 48) + 611) || (result = MPEG_D::USAC::ICSInfo::Deserialize(a4 + 8, a2, *(a1 + 16)), !result))
  {
    *(a4 + 72) = 0;
    v24 = (*(*a1 + 40))(a1, a3);
    MPEG_D::USAC::ScaleFactorData::Deserialize(v24, a2, *(a4 + 24), *(a4 + 32), v12[612]);
    v25 = USACBitstreamReader::operator CDK_BITSTREAM *(a2);
    v26 = *(v25 + 20);
    v27 = *(v25 + 4);
    CTns_Read(v25, v12, a4 + 16);
    TBitstreamReader<unsigned int>::SkipBits(a2, v27 + *(v25 + 20) - (v26 + *(v25 + 4)));
    *(a2 + 40) = *(a2 + 24) + 8 * (*(a2 + 8) - *a2);
    if (MPEG_D::USAC::SpectralDataDecoder::Deserialize(a1 + 576, a2, *(a4 + 28), *(a4 + 32), a3, a5))
    {
      return 0xFFFFFFFFLL;
    }

    else
    {
      *(a4 + 44) = 1;
      v29 = *(a4 + 28) != 2;
      v30 = *(a4 + 36);

      return lpd_dec::lpdDecoder::FacRead(a6, a2, v29, v30);
    }
  }

  return result;
}

uint64_t lpd_dec::lpdDecoder::Read(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5, uint64_t *a6, unsigned int a7, char a8)
{
  v347 = *MEMORY[0x1E69E9840];
  if (a7 > 0x5DC0)
  {
    return 0xFFFFFFFFLL;
  }

  v13 = *(a2 + 20);
  v14 = v13 >> 29;
  v15 = *(a2 + 24) - 3;
  *(a2 + 24) = v15;
  if (v15 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    v18 = (*a2 + 4);
    *a2 = v18;
    v20 = *(a2 + 20);
    v19 = *(a2 + 24);
    v15 = v19 + 32;
    v332 = (v20 >> v19) | v14;
    if (v19 == -32)
    {
      v22 = 0;
      v21 = (a1 + 5924);
      *(a2 + 20) = 0xFFFFFFFB00000000;
      goto LABEL_10;
    }

    v16 = v20 << -v19;
  }

  else
  {
    v17 = 8 * v13;
    v332 = HIDWORD(v17);
    v16 = v17;
  }

  v21 = (a1 + 5924);
  v22 = v16 >> 27;
  v23 = v15 - 5;
  *(a2 + 20) = v16;
  *(a2 + 24) = v23;
  if (v23 >= 0)
  {
    v24 = 32 * v16;
    goto LABEL_13;
  }

  v18 = *a2;
LABEL_10:
  TBitstreamReader<unsigned int>::FillCacheFrom(a2, v18);
  *a2 += 4;
  v26 = *(a2 + 20);
  v25 = *(a2 + 24);
  v22 |= v26 >> v25;
  *(a2 + 24) = v25 + 32;
  if (v25 == -32)
  {
    v24 = 0;
  }

  else
  {
    v24 = v26 << -v25;
  }

LABEL_13:
  *(a2 + 20) = v24;
  if (v22 > 0x19)
  {
    return 0xFFFFFFFFLL;
  }

  v319 = (a1 + 4096);
  if (v22 == 24)
  {
    v28 = 2;
    *(a1 + 5924) = 2;
    v29 = 0x200000002;
    goto LABEL_19;
  }

  if (v22 == 25)
  {
    v28 = 3;
    *(a1 + 5924) = 3;
    v29 = 0x300000003;
LABEL_19:
    *(a1 + 5928) = v29;
LABEL_20:
    v30 = 3;
    goto LABEL_21;
  }

  v28 = (v22 >> 1) & 1;
  if (v22 >> 2 != 5)
  {
    if (v22 >> 2 == 4)
    {
      *(a1 + 5924) = 0x200000002;
      *(a1 + 5932) = v22 & 1;
    }

    else
    {
      *(a1 + 5924) = v22 & 1;
      *(a1 + 5928) = v28;
      *(a1 + 5932) = (v22 >> 2) & 1;
      v28 = (v22 >> 3) & 1;
    }

    goto LABEL_20;
  }

  *(a1 + 5932) = 0x200000002;
  *(a1 + 5924) = v22 & 1;
  v30 = 1;
LABEL_21:
  v21[v30] = v28;
  *(a1 + 5336) = TBitstreamReader<unsigned int>::GetBit(a2);
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  v32 = TBitstreamReader<unsigned int>::GetBit(a2);
  v33 = v32;
  v34 = *(a1 + 1388);
  v35 = (a1 + 5916);
  v36 = *(a1 + 1392);
  *(a1 + 5920) = v36;
  v318 = Bit;
  if (Bit)
  {
    *v35 = 2;
    if ((v32 == 0) != (*v21 != 0))
    {
      v36 = 0;
    }

    else
    {
      if (v36)
      {
        goto LABEL_31;
      }

      v36 = 1;
    }
  }

  else
  {
    *v35 = 0;
    v36 = 255;
  }

  *(a1 + 5920) = v36;
LABEL_31:
  if (v34 != 2)
  {
    bzero(a1, 0x56CuLL);
    *(a1 + 1408) = lpd_rom::cdk_dec_lsf_init[0];
    *(a1 + 1424) = unk_19B3D5EF8;
    *(a1 + 1440) = xmmword_19B3D5F08;
    *(a1 + 1456) = unk_19B3D5F18;
    *(a1 + 5396) = 0u;
    *(a1 + 5412) = 0u;
    *(a1 + 5428) = 0u;
    *(a1 + 5444) = 0u;
    *(a1 + 5460) = 0u;
    *(a1 + 5476) = 0u;
    *(a1 + 5492) = 0u;
    *(a1 + 5508) = 0u;
    *(a1 + 5524) = 0u;
    *(a1 + 5540) = 0u;
    *(a1 + 5556) = 0u;
    *(a1 + 5572) = 0u;
    *(a1 + 5588) = 0u;
    *(a1 + 5604) = 0u;
    *(a1 + 5620) = 0u;
    *(a1 + 5636) = 0u;
    *(a1 + 5652) = 0u;
    *(a1 + 5668) = 0u;
    *(a1 + 5684) = 0u;
    *(a1 + 5337) = 0;
    memset_pattern16((a1 + 5340), "@", 0x1CuLL);
    *(a1 + 5368) = 0u;
    *(a1 + 5392) = 0;
    *(a1 + 5384) = 0;
    *(a1 + 3720) = 0u;
    *(a1 + 3736) = 0;
    *(a1 + 4020) = 64;
    *(a1 + 4022) = 0;
    *(a1 + 4128) = 0;
    *(a1 + 4284) = 256;
    *(a1 + 1400) = 0;
    *(a1 + 1404) = 0;
    if ((a5 & 1) == 0)
    {
      *(a1 + 1400) = Bit != 0;
    }
  }

  v37 = 0;
  v38 = (34 * a7 + 6400) / 0x3200;
  v321 = (a3 / 32);
  *(a1 + 5328) = 0;
  *(a1 + 5312) = 0u;
  *(a1 + 5296) = 0u;
  v335 = a1 + 4432;
  v334 = a1 + 4436;
  v39 = tcx_dec::lg_table_ccfl;
  if (a3 != 128)
  {
    v39 = &tcx_dec::lg_table_ccfl[4];
  }

  v333 = v39;
  v326 = a1 + 3738;
  v327 = (34 * a7 + 6400) / 0x3200;
  v324 = a3 & 0xFFFFFFE0;
  v325 = 6 * v38 + 27;
  v323 = 162 - v38;
  v342 = a1 + 4092;
  v341 = a1 + 4024;
  v339 = 1;
  v330 = a3;
  v329 = (a1 + 5916);
  v328 = v33;
  v40 = a4;
  v343 = a1;
  v331 = v21;
  v322 = a8;
  do
  {
    if (v37 || (*v35 == 2 ? (_ZF = v33 == 0) : (_ZF = 1), _ZF))
    {
      if (v36)
      {
        if (v36 == 255 || v36 < 1 || v21[v37])
        {
          goto LABEL_50;
        }
      }

      else if (v21[v37] <= 0)
      {
        goto LABEL_50;
      }
    }

    fac_dec::facDecoder::GetMemory(a1 + 4784, v40, a3, v21, v37);
    if (fac_dec::facDecoder::Read(a1 + 4784, a2, v37, a3, 0))
    {
      return 0xFFFFFFFFLL;
    }

LABEL_50:
    if (v21[v37])
    {
      v42 = *(a2 + 20);
      v43 = v42 >> 29;
      v44 = *(a2 + 24) - 3;
      *(a2 + 24) = v44;
      if (v44 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        *a2 += 4;
        v52 = *(a2 + 20);
        v51 = *(a2 + 24);
        v43 |= v52 >> v51;
        *(a2 + 24) = v51 + 32;
        if (v51 == -32)
        {
          v45 = 0;
        }

        else
        {
          v45 = v52 << -v51;
        }
      }

      else
      {
        v45 = 8 * v42;
      }

      *(a2 + 20) = v45;
      *(v335 + v37) = v43;
      v55 = *(a2 + 20);
      v56 = v55 >> 25;
      v57 = *(a2 + 24) - 7;
      *(a2 + 24) = v57;
      if (v57 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        *a2 += 4;
        v60 = *(a2 + 20);
        v59 = *(a2 + 24);
        v56 |= v60 >> v59;
        *(a2 + 24) = v59 + 32;
        if (v59 == -32)
        {
          v58 = 0;
        }

        else
        {
          v58 = v60 << -v59;
        }
      }

      else
      {
        v58 = v55 << 7;
      }

      *(a2 + 20) = v58;
      *(v334 + v37) = v56;
      v345 = *v333;
      if (v339)
      {
        a1 = v343;
        if ((a8 & 1) == 0)
        {
          v339 = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
        }
      }

      else
      {
        a1 = v343;
      }

      if (!*a6 || MPEG_D::USAC::ArithDecoder::Decode(*a6, a2, (v40 + 8 * v37 * a3), *(&v345 + v21[v37]), *(&v345 + v21[v37]), v339) || *(a2 + 24) + 8 * (*(a2 + 8) - *a2) < 0)
      {
        return 0xFFFFFFFFLL;
      }

      v339 = 0;
      v36 = v21[v37];
      v37 += 1 << (v36 - 1);
    }

    else
    {
      v46 = (v326 + 70 * v37);
      *v46 = v332;
      v47 = *(a2 + 20);
      v48 = v47 >> 30;
      v49 = *(a2 + 24) - 2;
      *(a2 + 24) = v49;
      if (v49 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        *a2 += 4;
        v54 = *(a2 + 20);
        v53 = *(a2 + 24);
        v48 |= v54 >> v53;
        *(a2 + 24) = v53 + 32;
        if (v53 == -32)
        {
          v50 = 0;
        }

        else
        {
          v50 = v54 << -v53;
        }
      }

      else
      {
        v50 = 4 * v47;
      }

      *(a2 + 20) = v50;
      v46[1] = v48;
      v336 = v37;
      *(v343 + 4088) = v37;
      *(v343 + 4112) = -1;
      *(v343 + 4108) = v325;
      if (v324 == 128)
      {
        *(v343 + 4096) = v327;
        *(v343 + 4100) = v323;
        *(v343 + 4104) = 160;
LABEL_77:
        v61 = 0;
        v62 = 0;
        v63 = v46 + 66;
        v340 = v46 + 2;
        v64 = v46 + 2;
        v65 = v321;
        while (2)
        {
          v66 = v61 >> 32;
          v67 = *(v342 + (v61 >> 32));
          if (v67 != 6 && v67 != 9)
          {
            exception = __cxa_allocate_exception(0x10uLL);
            *exception = "void ltp_dec::ltpDecoder::Read(BitstreamReader &, const int32_t)";
            v317 = 188;
            goto LABEL_387;
          }

          v69 = *(v343 + 4088);
          v70 = *(a2 + 20);
          v71 = *(a2 + 24);
          v72 = v70 >> -v67;
          *(a2 + 24) = v71 - v67;
          if (v71 - v67 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v75 = *(a2 + 20);
            v74 = *(a2 + 24);
            v72 |= v75 >> v74;
            *(a2 + 24) = v74 + 32;
            if (v74 == -32)
            {
              v73 = 0;
            }

            else
            {
              v73 = v75 << -v74;
            }
          }

          else
          {
            v73 = v70 << v67;
          }

          *(a2 + 20) = v73;
          if (v67 == 6)
          {
            v76 = *(v343 + 4120) + v72 / 4;
            v77 = v72 & 3;
          }

          else
          {
            v78 = *(v343 + 4100);
            v79 = *(v343 + 4096);
            if (v72 >= 4 * (v78 - v79))
            {
              v80 = 4 * (v78 - v79);
              v81 = *(v343 + 4104);
              v82 = v80 + 2 * (v81 - v78);
              v83 = v81 + v72 - v82;
              v76 = v78 + (v72 - v80) / 2;
              v77 = 2 * (v72 & 1);
              if (v72 >= v82)
              {
                v77 = 0;
                v76 = v83;
              }
            }

            else
            {
              v76 = v79 + v72 / 4;
              v77 = v72 & 3;
            }

            if (v76 - 8 > v79)
            {
              v79 = v76 - 8;
            }

            v84 = v79 + 15;
            v85 = *(v343 + 4108);
            if (v79 + 15 > v85)
            {
              v79 = v85 - 15;
            }

            if (v84 >= v85)
            {
              v84 = *(v343 + 4108);
            }

            *(v343 + 4120) = v79;
            *(v343 + 4124) = v84;
          }

          v86 = v341 + 16 * v69;
          *(v86 + 2 * v66) = v76;
          *(v86 + v66 + 8) = v77;
          *(v86 + v66 + 12) = TBitstreamReader<unsigned int>::GetBit(a2);
          HIDWORD(v88) = acelp_dec::MapCoreMode2NBits(unsigned char)::tab_coremode2nbits[v332] - 12;
          LODWORD(v88) = HIDWORD(v88);
          v87 = v88 >> 2;
          if (v87 <= 5)
          {
            if (v87 <= 1)
            {
              if (v87)
              {
                if (v87 != 1)
                {
                  goto LABEL_388;
                }

                *v64 = TBitstreamReader<unsigned int>::GetBit(a2);
                v89 = *(a2 + 20);
                v90 = v89 >> 27;
                v91 = *(a2 + 24) - 5;
                *(a2 + 24) = v91;
                if (v91 >= 0)
                {
                  v92 = 32 * v89;
                  goto LABEL_144;
                }

                TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
                v142 = (*a2 + 4);
                *a2 = v142;
                v144 = *(a2 + 20);
                v143 = *(a2 + 24);
                v90 |= v144 >> v143;
                v91 = v143 + 32;
                if (v143 == -32)
                {
                  v145 = 0;
                  v64[1] = v90;
                  *(a2 + 20) = 0xFFFFFFFB00000000;
                }

                else
                {
                  v92 = v144 << -v143;
LABEL_144:
                  *(a2 + 20) = v92;
                  v64[1] = v90;
                  v145 = v92 >> 27;
                  v146 = v91 - 5;
                  *(a2 + 24) = v146;
                  if (v146 >= 0)
                  {
                    v147 = 32 * v92;
                    goto LABEL_189;
                  }

                  v142 = *a2;
                }

                TBitstreamReader<unsigned int>::FillCacheFrom(a2, v142);
                v175 = (*a2 + 4);
                *a2 = v175;
                v177 = *(a2 + 20);
                v176 = *(a2 + 24);
                v145 |= v177 >> v176;
                v146 = v176 + 32;
                if (v176 == -32)
                {
                  v178 = 0;
                  v64[2] = v145;
                  *(a2 + 20) = 0xFFFFFFFB00000000;
                }

                else
                {
                  v147 = v177 << -v176;
LABEL_189:
                  *(a2 + 20) = v147;
                  v64[2] = v145;
                  v178 = v147 >> 27;
                  v161 = v146 - 5;
                  *(a2 + 24) = v161;
                  if (v161 >= 0)
                  {
                    v162 = 32 * v147;
                    goto LABEL_196;
                  }

                  v175 = *a2;
                }

                TBitstreamReader<unsigned int>::FillCacheFrom(a2, v175);
                *a2 += 4;
                v180 = *(a2 + 20);
                v179 = *(a2 + 24);
                v178 |= v180 >> v179;
                v161 = v179 + 32;
                *(a2 + 24) = v179 + 32;
                if (v179 == -32)
                {
                  v162 = 0;
                }

                else
                {
                  v162 = v180 << -v179;
                }

LABEL_196:
                *(a2 + 20) = v162;
                v64[3] = v178;
              }

              else
              {
                *v64 = TBitstreamReader<unsigned int>::GetBit(a2);
                v105 = *(a2 + 20);
                v106 = v105 >> 27;
                v107 = *(a2 + 24) - 5;
                *(a2 + 24) = v107;
                if (v107 < 0)
                {
                  TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
                  *a2 += 4;
                  v122 = *(a2 + 20);
                  v121 = *(a2 + 24);
                  v106 |= v122 >> v121;
                  *(a2 + 24) = v121 + 32;
                  if (v121 == -32)
                  {
                    v108 = 0;
                  }

                  else
                  {
                    v108 = v122 << -v121;
                  }
                }

                else
                {
                  v108 = 32 * v105;
                }

                *(a2 + 20) = v108;
                v64[1] = v106;
                v64[2] = TBitstreamReader<unsigned int>::GetBit(a2);
                v159 = *(a2 + 20);
                v160 = v159 >> 27;
                v161 = *(a2 + 24) - 5;
                *(a2 + 24) = v161;
                if (v161 < 0)
                {
                  TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
                  *a2 += 4;
                  v164 = *(a2 + 20);
                  v163 = *(a2 + 24);
                  v160 |= v164 >> v163;
                  v161 = v163 + 32;
                  *(a2 + 24) = v163 + 32;
                  if (v163 == -32)
                  {
                    v162 = 0;
                  }

                  else
                  {
                    v162 = v164 << -v163;
                  }
                }

                else
                {
                  v162 = 32 * v159;
                }

                *(a2 + 20) = v162;
                v64[3] = v160;
              }

LABEL_227:
              v199 = v162 >> 25;
              v200 = v161 - 7;
              *(a2 + 24) = v200;
              if (v200 < 0)
              {
                TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
                *a2 += 4;
                v203 = *(a2 + 20);
                v202 = *(a2 + 24);
                v199 |= v203 >> v202;
                *(a2 + 24) = v202 + 32;
                if (v202 == -32)
                {
                  v201 = 0;
                }

                else
                {
                  v201 = v203 << -v202;
                }
              }

              else
              {
                v201 = v162 << 7;
              }

              *(a2 + 20) = v201;
              *v63++ = v199;
              ++v62;
              v61 += 0x100000000;
              v64 += 8;
              if (!--v65)
              {
                goto LABEL_276;
              }

              continue;
            }

            if (v87 != 2)
            {
              if (v87 != 4)
              {
                goto LABEL_388;
              }

              v97 = *(a2 + 20);
              v98 = v97 >> 23;
              v99 = *(a2 + 24) - 9;
              *(a2 + 24) = v99;
              if (v99 >= 0)
              {
                v100 = v97 << 9;
                goto LABEL_154;
              }

              TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
              v129 = (*a2 + 4);
              *a2 = v129;
              v151 = *(a2 + 20);
              v150 = *(a2 + 24);
              v98 |= v151 >> v150;
              v99 = v150 + 32;
              if (v150 != -32)
              {
                v100 = v151 << -v150;
LABEL_154:
                *(a2 + 20) = v100;
                *v64 = v98;
                v132 = v100 >> 23;
                v133 = v99 - 9;
                *(a2 + 24) = v133;
                if (v133 >= 0)
                {
                  v134 = v100 << 9;
LABEL_156:
                  v141 = v64;
LABEL_214:
                  *(a2 + 20) = v134;
                  v141[1] = v132;
                  v192 = v134 >> 27;
                  v193 = v133 - 5;
                  *(a2 + 24) = v193;
                  if (v193 >= 0)
                  {
                    v194 = 32 * v134;
                    goto LABEL_220;
                  }

                  v189 = *a2;
LABEL_218:
                  TBitstreamReader<unsigned int>::FillCacheFrom(a2, v189);
                  v171 = (*a2 + 4);
                  *a2 = v171;
                  v196 = *(a2 + 20);
                  v195 = *(a2 + 24);
                  v192 |= v196 >> v195;
                  v193 = v195 + 32;
                  if (v195 == -32)
                  {
                    v174 = 0;
                    v141[2] = v192;
                    *(a2 + 20) = 0xFFFFFFFB00000000;
                  }

                  else
                  {
                    v194 = v196 << -v195;
LABEL_220:
                    *(a2 + 20) = v194;
                    v141[2] = v192;
                    v174 = v194 >> 27;
                    v161 = v193 - 5;
                    *(a2 + 24) = v161;
                    if (v161 >= 0)
                    {
                      v162 = 32 * v194;
                      goto LABEL_226;
                    }

LABEL_222:
                    v171 = *a2;
                  }

LABEL_223:
                  TBitstreamReader<unsigned int>::FillCacheFrom(a2, v171);
                  *a2 += 4;
                  v198 = *(a2 + 20);
                  v197 = *(a2 + 24);
                  v174 |= v198 >> v197;
                  v161 = v197 + 32;
                  *(a2 + 24) = v197 + 32;
                  if (v197 == -32)
                  {
                    v162 = 0;
                  }

                  else
                  {
                    v162 = v198 << -v197;
                  }

                  goto LABEL_226;
                }

LABEL_157:
                v141 = &v340[16 * v62];
                v129 = *a2;
LABEL_212:
                TBitstreamReader<unsigned int>::FillCacheFrom(a2, v129);
                v189 = (*a2 + 4);
                *a2 = v189;
                v191 = *(a2 + 20);
                v190 = *(a2 + 24);
                v132 |= v191 >> v190;
                v133 = v190 + 32;
                if (v190 != -32)
                {
                  v134 = v191 << -v190;
                  goto LABEL_214;
                }

                v192 = 0;
                v64[1] = v132;
                *(a2 + 20) = 0xFFFFFFFB00000000;
                goto LABEL_218;
              }

              v132 = 0;
              *v64 = v98;
              *(a2 + 20) = 0xFFFFFFF700000000;
LABEL_211:
              v141 = v64;
              goto LABEL_212;
            }

            v113 = *(a2 + 20);
            v114 = v113 >> 27;
            v115 = *(a2 + 24) - 5;
            *(a2 + 24) = v115;
            if (v115 < 0)
            {
              TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
              v129 = (*a2 + 4);
              *a2 = v129;
              v131 = *(a2 + 20);
              v130 = *(a2 + 24);
              v114 |= v131 >> v130;
              v115 = v130 + 32;
              if (v130 == -32)
              {
                v132 = 0;
                *v64 = v114;
                *(a2 + 20) = 0xFFFFFFFB00000000;
                goto LABEL_211;
              }

              v116 = v131 << -v130;
            }

            else
            {
              v116 = 32 * v113;
            }

            *(a2 + 20) = v116;
            *v64 = v114;
            v132 = v116 >> 27;
            v133 = v115 - 5;
            *(a2 + 24) = v133;
            if (v133 >= 0)
            {
              v134 = 32 * v116;
              goto LABEL_156;
            }

            goto LABEL_157;
          }

          break;
        }

        if (v87 <= 9)
        {
          if (v87 != 6)
          {
            if (v87 != 8)
            {
              goto LABEL_388;
            }

            v93 = *(a2 + 20);
            v94 = v93 >> 19;
            v95 = *(a2 + 24) - 13;
            *(a2 + 24) = v95;
            if (v95 >= 0)
            {
              v96 = v93 << 13;
              goto LABEL_148;
            }

            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            v123 = (*a2 + 4);
            *a2 = v123;
            v149 = *(a2 + 20);
            v148 = *(a2 + 24);
            v94 |= v149 >> v148;
            v95 = v148 + 32;
            if (v148 != -32)
            {
              v96 = v149 << -v148;
LABEL_148:
              *(a2 + 20) = v96;
              *v64 = v94;
              v126 = v96 >> 19;
              v127 = v95 - 13;
              *(a2 + 24) = v127;
              if (v127 >= 0)
              {
                v128 = v96 << 13;
LABEL_150:
                v141 = v64;
LABEL_201:
                *(a2 + 20) = v128;
                v141[1] = v126;
                v184 = v128 >> 23;
                v185 = v127 - 9;
                *(a2 + 24) = v185;
                if (v185 >= 0)
                {
                  v186 = v128 << 9;
                  goto LABEL_207;
                }

                v181 = *a2;
LABEL_205:
                TBitstreamReader<unsigned int>::FillCacheFrom(a2, v181);
                v171 = (*a2 + 4);
                *a2 = v171;
                v188 = *(a2 + 20);
                v187 = *(a2 + 24);
                v184 |= v188 >> v187;
                v185 = v187 + 32;
                if (v187 == -32)
                {
                  v174 = 0;
                  v141[2] = v184;
                  *(a2 + 20) = 0xFFFFFFF700000000;
                  goto LABEL_223;
                }

                v186 = v188 << -v187;
LABEL_207:
                *(a2 + 20) = v186;
                v141[2] = v184;
                v174 = v186 >> 23;
                v161 = v185 - 9;
                *(a2 + 24) = v161;
                if (v161 < 0)
                {
                  goto LABEL_222;
                }

                v162 = v186 << 9;
LABEL_226:
                *(a2 + 20) = v162;
                v141[3] = v174;
                goto LABEL_227;
              }

LABEL_151:
              v141 = &v340[16 * v62];
              v123 = *a2;
LABEL_199:
              TBitstreamReader<unsigned int>::FillCacheFrom(a2, v123);
              v181 = (*a2 + 4);
              *a2 = v181;
              v183 = *(a2 + 20);
              v182 = *(a2 + 24);
              v126 |= v183 >> v182;
              v127 = v182 + 32;
              if (v182 != -32)
              {
                v128 = v183 << -v182;
                goto LABEL_201;
              }

              v184 = 0;
              v64[1] = v126;
              *(a2 + 20) = 0xFFFFFFF700000000;
              goto LABEL_205;
            }

            v126 = 0;
            *v64 = v94;
            *(a2 + 20) = 0xFFFFFFF300000000;
LABEL_198:
            v141 = v64;
            goto LABEL_199;
          }

          v109 = *(a2 + 20);
          v110 = v109 >> 23;
          v111 = *(a2 + 24) - 9;
          *(a2 + 24) = v111;
          if (v111 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            v123 = (*a2 + 4);
            *a2 = v123;
            v125 = *(a2 + 20);
            v124 = *(a2 + 24);
            v110 |= v125 >> v124;
            v111 = v124 + 32;
            if (v124 == -32)
            {
              v126 = 0;
              *v64 = v110;
              *(a2 + 20) = 0xFFFFFFF700000000;
              goto LABEL_198;
            }

            v112 = v125 << -v124;
          }

          else
          {
            v112 = v109 << 9;
          }

          *(a2 + 20) = v112;
          *v64 = v110;
          v126 = v112 >> 23;
          v127 = v111 - 9;
          *(a2 + 24) = v127;
          if (v127 >= 0)
          {
            v128 = v112 << 9;
            goto LABEL_150;
          }

          goto LABEL_151;
        }

        if (v87 != 10)
        {
          if (v87 != 13)
          {
LABEL_388:
            exception = __cxa_allocate_exception(0x10uLL);
            *exception = "OSStatus acelp_dec::acelpDecoder::Read(BitstreamReader &, const int32_t, const int32_t, const int32_t, const int32_t)";
            v317 = 627;
LABEL_387:
            exception[2] = v317;
          }

          v101 = *(a2 + 20);
          v102 = v101 >> 30;
          v103 = *(a2 + 24) - 2;
          *(a2 + 24) = v103;
          if (v103 >= 0)
          {
            v104 = 4 * v101;
            goto LABEL_160;
          }

          TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
          v152 = (*a2 + 4);
          *a2 = v152;
          v154 = *(a2 + 20);
          v153 = *(a2 + 24);
          v102 |= v154 >> v153;
          v103 = v153 + 32;
          if (v153 == -32)
          {
            v155 = 0;
            *v64 = v102;
            *(a2 + 20) = 0xFFFFFFFE00000000;
            v158 = v64;
          }

          else
          {
            v104 = v154 << -v153;
LABEL_160:
            *(a2 + 20) = v104;
            *v64 = v102;
            v155 = v104 >> 30;
            v156 = v103 - 2;
            *(a2 + 24) = v156;
            if (v156 >= 0)
            {
              v157 = 4 * v104;
              v158 = v64;
              goto LABEL_238;
            }

            v158 = &v340[16 * v62];
            v152 = *a2;
          }

          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v152);
          v204 = (*a2 + 4);
          *a2 = v204;
          v206 = *(a2 + 20);
          v205 = *(a2 + 24);
          v155 |= v206 >> v205;
          v156 = v205 + 32;
          if (v205 == -32)
          {
            v207 = 0;
            v64[1] = v155;
            *(a2 + 20) = 0xFFFFFFFE00000000;
          }

          else
          {
            v157 = v206 << -v205;
LABEL_238:
            *(a2 + 20) = v157;
            v158[1] = v155;
            v207 = v157 >> 30;
            v208 = v156 - 2;
            *(a2 + 24) = v208;
            if (v208 >= 0)
            {
              v209 = 4 * v157;
              goto LABEL_244;
            }

            v204 = *a2;
          }

          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v204);
          v210 = (*a2 + 4);
          *a2 = v210;
          v212 = *(a2 + 20);
          v211 = *(a2 + 24);
          v207 |= v212 >> v211;
          v208 = v211 + 32;
          if (v211 == -32)
          {
            v213 = 0;
            v158[2] = v207;
            *(a2 + 20) = 0xFFFFFFFE00000000;
          }

          else
          {
            v209 = v212 << -v211;
LABEL_244:
            *(a2 + 20) = v209;
            v158[2] = v207;
            v213 = v209 >> 30;
            v214 = v208 - 2;
            *(a2 + 24) = v214;
            if (v214 >= 0)
            {
              v215 = 4 * v209;
              goto LABEL_250;
            }

            v210 = *a2;
          }

          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v210);
          v216 = (*a2 + 4);
          *a2 = v216;
          v218 = *(a2 + 20);
          v217 = *(a2 + 24);
          v213 |= v218 >> v217;
          v214 = v217 + 32;
          if (v217 == -32)
          {
            v219 = 0;
            v158[3] = v213;
            *(a2 + 20) = 0xFFFFFFF200000000;
          }

          else
          {
            v215 = v218 << -v217;
LABEL_250:
            *(a2 + 20) = v215;
            v158[3] = v213;
            v219 = v215 >> 18;
            v220 = v214 - 14;
            *(a2 + 24) = v220;
            if (v220 >= 0)
            {
              v221 = v215 << 14;
              goto LABEL_256;
            }

            v216 = *a2;
          }

          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v216);
          v222 = (*a2 + 4);
          *a2 = v222;
          v224 = *(a2 + 20);
          v223 = *(a2 + 24);
          v219 |= v224 >> v223;
          v220 = v223 + 32;
          if (v223 == -32)
          {
            v225 = 0;
            v158[4] = v219;
            *(a2 + 20) = 0xFFFFFFF200000000;
          }

          else
          {
            v221 = v224 << -v223;
LABEL_256:
            *(a2 + 20) = v221;
            v158[4] = v219;
            v225 = v221 >> 18;
            v226 = v220 - 14;
            *(a2 + 24) = v226;
            if (v226 >= 0)
            {
              v227 = v221 << 14;
              goto LABEL_262;
            }

            v222 = *a2;
          }

          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v222);
          v228 = (*a2 + 4);
          *a2 = v228;
          v230 = *(a2 + 20);
          v229 = *(a2 + 24);
          v225 |= v230 >> v229;
          v226 = v229 + 32;
          if (v229 == -32)
          {
            v231 = 0;
            v158[5] = v225;
            *(a2 + 20) = 0xFFFFFFF200000000;
          }

          else
          {
            v227 = v230 << -v229;
LABEL_262:
            *(a2 + 20) = v227;
            v158[5] = v225;
            v231 = v227 >> 18;
            v232 = v226 - 14;
            *(a2 + 24) = v232;
            if (v232 >= 0)
            {
              v233 = v227 << 14;
              goto LABEL_268;
            }

            v228 = *a2;
          }

          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v228);
          v234 = (*a2 + 4);
          *a2 = v234;
          v236 = *(a2 + 20);
          v235 = *(a2 + 24);
          v231 |= v236 >> v235;
          v232 = v235 + 32;
          if (v235 == -32)
          {
            v237 = 0;
            v158[6] = v231;
            *(a2 + 20) = 0xFFFFFFF200000000;
          }

          else
          {
            v233 = v236 << -v235;
LABEL_268:
            *(a2 + 20) = v233;
            v158[6] = v231;
            v237 = v233 >> 18;
            v161 = v232 - 14;
            *(a2 + 24) = v161;
            if (v161 >= 0)
            {
              v162 = v233 << 14;
LABEL_275:
              *(a2 + 20) = v162;
              v158[7] = v237;
              goto LABEL_227;
            }

            v234 = *a2;
          }

          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v234);
          *a2 += 4;
          v239 = *(a2 + 20);
          v238 = *(a2 + 24);
          v237 |= v239 >> v238;
          v161 = v238 + 32;
          *(a2 + 24) = v238 + 32;
          if (v238 == -32)
          {
            v162 = 0;
          }

          else
          {
            v162 = v239 << -v238;
          }

          goto LABEL_275;
        }

        v117 = *(a2 + 20);
        v118 = v117 >> 19;
        v119 = *(a2 + 24) - 13;
        *(a2 + 24) = v119;
        if (v119 >= 0)
        {
          v120 = v117 << 13;
          goto LABEL_140;
        }

        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        v135 = (*a2 + 4);
        *a2 = v135;
        v137 = *(a2 + 20);
        v136 = *(a2 + 24);
        v118 |= v137 >> v136;
        v119 = v136 + 32;
        if (v136 == -32)
        {
          v138 = 0;
          *v64 = v118;
          *(a2 + 20) = 0xFFFFFFF300000000;
          v141 = v64;
        }

        else
        {
          v120 = v137 << -v136;
LABEL_140:
          *(a2 + 20) = v120;
          *v64 = v118;
          v138 = v120 >> 19;
          v139 = v119 - 13;
          *(a2 + 24) = v139;
          if (v139 >= 0)
          {
            v140 = v120 << 13;
            v141 = v64;
            goto LABEL_175;
          }

          v141 = &v340[16 * v62];
          v135 = *a2;
        }

        TBitstreamReader<unsigned int>::FillCacheFrom(a2, v135);
        v165 = (*a2 + 4);
        *a2 = v165;
        v167 = *(a2 + 20);
        v166 = *(a2 + 24);
        v138 |= v167 >> v166;
        v139 = v166 + 32;
        if (v166 == -32)
        {
          v168 = 0;
          v64[1] = v138;
          *(a2 + 20) = 0xFFFFFFF300000000;
        }

        else
        {
          v140 = v167 << -v166;
LABEL_175:
          *(a2 + 20) = v140;
          v141[1] = v138;
          v168 = v140 >> 19;
          v169 = v139 - 13;
          *(a2 + 24) = v169;
          if (v169 >= 0)
          {
            v170 = v140 << 13;
LABEL_181:
            *(a2 + 20) = v170;
            v141[2] = v168;
            v174 = v170 >> 19;
            v161 = v169 - 13;
            *(a2 + 24) = v161;
            if (v161 < 0)
            {
              goto LABEL_222;
            }

            v162 = v170 << 13;
            goto LABEL_226;
          }

          v165 = *a2;
        }

        TBitstreamReader<unsigned int>::FillCacheFrom(a2, v165);
        v171 = (*a2 + 4);
        *a2 = v171;
        v173 = *(a2 + 20);
        v172 = *(a2 + 24);
        v168 |= v173 >> v172;
        v169 = v172 + 32;
        if (v172 == -32)
        {
          v174 = 0;
          v141[2] = v168;
          *(a2 + 20) = 0xFFFFFFF300000000;
          goto LABEL_223;
        }

        v170 = v173 << -v172;
        goto LABEL_181;
      }

      *(v343 + 4092) = 394761;
      *(v343 + 4096) = v327;
      *(v343 + 4100) = v323;
      *(v343 + 4104) = 160;
      if (a3 >= 32)
      {
        goto LABEL_77;
      }

LABEL_276:
      v36 = 0;
      v40 = a4;
      v37 = v336 + 1;
      a1 = v343;
      a3 = v330;
      v21 = v331;
      v35 = v319 + 455;
      v33 = v328;
      a8 = v322;
    }
  }

  while (v37 < 4);
  v240 = (*(a1 + 5924) & 3) == 0 && *(a1 + 1400) == 1 && *(a1 + 1388) != 2;
  v345 = 0uLL;
  v346 = 1;
  v241 = (a1 + 1792);
  lsf_dec::vlpc_1st_dec(a2, a1 + 1792);
  if (lsf_dec::vlpc_2st_dec(a2, (a1 + 1792), 0))
  {
    return 0xFFFFFFFFLL;
  }

  v242 = (v343 + 1408);
  v243 = (v343 + 1536);
  if (v318)
  {
    LODWORD(v345) = 1;
    v244 = *(v343 + 1424);
    *v243 = *v242;
    *(v343 + 1552) = v244;
    v245 = *(v343 + 1456);
    *(v343 + 1568) = *(v343 + 1440);
    *(v343 + 1584) = v245;
    v246 = 2;
  }

  else
  {
    v240 = 0;
    v246 = 0;
  }

  do
  {
    v247 = v246;
    if (v246 == 2 && *v331 == 3)
    {
      goto LABEL_308;
    }

    v248 = v40;
    *(&v345 + v246) = 1;
    v249 = &v243[4 * v246];
    if (TBitstreamReader<unsigned int>::GetBit(a2))
    {
      v250 = *v241;
      v251 = *(a1 + 1808);
      v252 = *(a1 + 1840);
      v249[2] = *(a1 + 1824);
      v249[3] = v252;
      *v249 = v250;
      v249[1] = v251;
      v253 = 3;
    }

    else
    {
      lsf_dec::vlpc_1st_dec(a2, &v243[4 * v247]);
      v253 = 0;
    }

    if (lsf_dec::vlpc_2st_dec(a2, v243[4 * v247].f32, v253))
    {
      return 0xFFFFFFFFLL;
    }

    v40 = v248;
    v246 = 2;
  }

  while (!v247);
  if (*v331 > 1)
  {
LABEL_308:
    if (v331[2] <= 1)
    {
      v264 = 0;
      HIDWORD(v345) = 1;
      while (TBitstreamReader<unsigned int>::GetBit(a2))
      {
        if (++v264 == 3)
        {
          v265 = v241[1];
          v266 = v343;
          *(v343 + 1728) = *v241;
          *(v343 + 1744) = v265;
          v267 = v241[3];
          *(v343 + 1760) = v241[2];
          *(v343 + 1776) = v267;
LABEL_317:
          v268 = 2;
          goto LABEL_321;
        }
      }

      if (v264 == 2)
      {
        v266 = v343;
        *(v343 + 1728) = *(v343 + 1664);
        *(v343 + 1744) = *(v343 + 1680);
        *(v343 + 1760) = *(v343 + 1696);
        *(v343 + 1776) = *(v343 + 1712);
        goto LABEL_317;
      }

      if (v264 == 1)
      {
        v266 = v343;
        lsf_dec::vlpc_1st_dec(a2, v343 + 1728);
        v268 = 0;
      }

      else
      {
        v266 = v343;
        v269 = 16;
        v270.i64[0] = 0x3F0000003F000000;
        v270.i64[1] = 0x3F0000003F000000;
        v271 = v241;
        do
        {
          v271[-4] = vaddq_f32(vmulq_f32(v271[-8], v270), vmulq_f32(*v271, v270));
          ++v271;
          v269 -= 4;
        }

        while (v269);
        v268 = 1;
      }

LABEL_321:
      if (lsf_dec::vlpc_2st_dec(a2, (v266 + 1728), v268))
      {
        return 0xFFFFFFFFLL;
      }
    }

    if (v240 && (a5 & 1) == 0)
    {
      v272 = (v343 + 1600);
      v273 = 1;
      while (!*(&v345 + v273))
      {
        ++v273;
        v272 += 4;
        if (v273 == 5)
        {
          goto LABEL_333;
        }
      }

      if (*v331 < 1)
      {
        v281 = &v243[4 * v273];
        v282 = v281[1];
        *v243 = *v281;
        *(v343 + 1552) = v282;
        v283 = v281[3];
        *(v343 + 1568) = v281[2];
        *(v343 + 1584) = v283;
      }

      else
      {
        v274 = 0;
        __asm
        {
          FMOV            V0.4S, #0.25
          FMOV            V1.4S, #0.75
        }

        do
        {
          v280 = *v272++;
          v243[v274] = vmlaq_f32(vmulq_f32(lpd_rom::cdk_dec_lsf_init[v274], _Q0), _Q1, v280);
          ++v274;
        }

        while (v274 != 4);
      }
    }

LABEL_333:
    v284 = 0;
    v285 = v241[1];
    *v242 = *v241;
    *(v343 + 1424) = v285;
    v286 = v241[3];
    *(v343 + 1440) = v241[2];
    *(v343 + 1456) = v286;
    v287 = 4;
    do
    {
      v288 = v287;
      v284 += *(&v345 + v287);
      _CF = v287-- != 0;
    }

    while (_CF && v284 < 3);
    v289 = 0;
    v290 = v287 + 1;
    v291 = 1.0;
    if (v284 == 2)
    {
      v291 = 0.5;
    }

    if (v284 == 3)
    {
      v291 = 0.33333;
    }

    v292 = (v343 + 1792);
    do
    {
      v293 = 0.0;
      if (v290 <= 4)
      {
        v294 = &v346;
        v295 = v292;
        v296 = 5;
        do
        {
          if (*v294--)
          {
            v293 = v293 + (*v295 * v291);
          }

          --v296;
          v295 -= 16;
        }

        while (v296 > v288);
      }

      *(v343 + 1856 + 4 * v289++) = v293;
      ++v292;
    }

    while (v289 != 16);
    if (v345 != 1 || v346 != 1)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "OSStatus lsf_dec::lsfDecoder::Read(BitstreamReader &, const array<lpdMode, kNbDiv> &, const BOOL, const BOOL, const BOOL)";
      v317 = 320;
      goto LABEL_387;
    }

    v299 = 0;
    v300 = 0;
    v301 = (v343 + 1536);
    do
    {
      if (*(&v345 + v299 + 1))
      {
        __C = 0.0;
        vDSP_distancesq(v301 + 16, 1, v301, 1, &__C, 0x10uLL);
        v302 = (__C / -400000.0) + 1.25;
        if (v302 < 0.0)
        {
          v302 = 0.0;
        }

        if (v302 > 1.0)
        {
          v302 = 1.0;
        }

        *(v343 + 1920 + 4 * v300) = v302;
        v300 = v299 + 1;
      }

      else
      {
        *(v343 + 1924 + 4 * v299) = -1082130432;
      }

      ++v299;
      v301 += 16;
    }

    while (v299 != 4);
    v303 = 0;
    v304 = v343 + 1536;
    do
    {
      if (*(&v345 + v303))
      {
        for (i = 0; i != 64; i += 4)
        {
          *(v304 + i) = __cospif (*(v304 + i) * 0.00015625);
        }
      }

      ++v303;
      v304 += 64;
    }

    while (v303 != 5);
    if (*(v343 + 1400) == 1 && (a5 & 1) == 0)
    {
      v306 = 0;
      do
      {
        v307 = v331[v306];
        if ((v307 & 3) != 0)
        {
          v308 = 1 << (v307 - 1);
        }

        else
        {
          v308 = 1;
        }

        v309 = v308 + v306;
        vDSP_vmin(v243[4 * v309].f32, 1, v243[4 * v306].f32, 1, v243[4 * v306].f32, 1, 0x10uLL);
        v306 = v309;
      }

      while (v309 < 4);
    }

    if ((a5 & 1) == 0)
    {
      goto LABEL_377;
    }

    v310 = v343;
    v311 = *(v343 + 1392);
    if (!v311)
    {
LABEL_379:
      if (v328 && *v329 != 2)
      {
        if (TBitstreamReader<unsigned int>::GetBit(a2))
        {
          *v329 = 0xFF00000001;
          if (*(v310 + 1388) != 1 && (a5 & 1) != 0)
          {
            return 0xFFFFFFFFLL;
          }
        }

        fac_dec::facDecoder::GetMemory(v310 + 4784, a4, v330, v331, 0);
        if (fac_dec::facDecoder::Read(v310 + 4784, a2, 0, v330 >> (*v329 == 1), 1))
        {
          return 0xFFFFFFFFLL;
        }
      }

      return 0;
    }

    if (v311 != 255)
    {
      v312 = (v343 + 4288);
    }

    else
    {
LABEL_377:
      v312 = &v345;
      lpc_com::lsp2a(&v345, v243);
    }

    v313 = *v312;
    v314 = v312[1];
    v315 = v312[3];
    v319[25] = v312[2];
    v319[26] = v315;
    v319[23] = v313;
    v319[24] = v314;
    v310 = v343;
    goto LABEL_379;
  }

  v254 = 0;
  DWORD1(v345) = 1;
  while (1)
  {
    v255 = v254;
    if (!TBitstreamReader<unsigned int>::GetBit(a2))
    {
      break;
    }

    v254 = 1;
    if (v255)
    {
      v256 = (v343 + 1664);
      if (v240)
      {
        v257 = *(v343 + 1680);
        *(v343 + 1600) = *v256;
        *(v343 + 1616) = v257;
        v258 = *(v343 + 1712);
        *(v343 + 1632) = *(v343 + 1696);
        *(v343 + 1648) = v258;
      }

      else
      {
        v262 = 16;
        v263.i64[0] = 0x3F0000003F000000;
        v263.i64[1] = 0x3F0000003F000000;
        do
        {
          v256[-4] = vaddq_f32(vmulq_f32(v256[-8], v263), vmulq_f32(*v256, v263));
          ++v256;
          v262 -= 4;
        }

        while (v262);
      }

      goto LABEL_308;
    }
  }

  if (v255)
  {
    lsf_dec::vlpc_1st_dec(a2, v343 + 1600);
    v259 = (v343 + 1600);
    v260 = a2;
    v261 = 0;
  }

  else
  {
    *(v343 + 1600) = *(v343 + 1664);
    *(v343 + 1616) = *(v343 + 1680);
    *(v343 + 1632) = *(v343 + 1696);
    *(v343 + 1648) = *(v343 + 1712);
    v259 = (v343 + 1600);
    v260 = a2;
    v261 = 2;
  }

  if (!lsf_dec::vlpc_2st_dec(v260, v259, v261))
  {
    goto LABEL_308;
  }

  return 0xFFFFFFFFLL;
}

uint64_t fac_dec::facDecoder::GetMemory(uint64_t result, uint64_t a2, int a3, uint64_t a4, int a5)
{
  v5 = *(result + 544);
  if (v5 > 7)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void fac_dec::facDecoder::GetMemory(float *, const int32_t, const array<lpdMode, kNbDiv> &, const int32_t)";
    exception[2] = 35;
  }

  while (1)
  {
    v6 = v5 + 1;
    if (!*(a4 + 4 * (v5 >> 1)))
    {
      break;
    }

    ++v5;
    if (v6 == 8)
    {
      *(result + 544) = 9;
      v7 = result;
      goto LABEL_6;
    }
  }

  *(result + 544) = v6;
  v7 = a2 + 4 * (v5 * a3);
LABEL_6:
  *(result + 8 * a5 + 512) = v7;
  return result;
}

uint64_t fac_dec::facDecoder::Read(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  if (a4 >= 129)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "OSStatus fac_dec::facDecoder::Read(BitstreamReader &, const int32_t, const int32_t, const BOOL)";
    exception[2] = 63;
  }

  v10 = 0.0;
  if (a5)
  {
    v11 = *(a2 + 20);
    v12 = v11 >> 25;
    v13 = *(a2 + 24) - 7;
    *(a2 + 24) = v13;
    if (v13 < 0)
    {
      TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      *a2 += 4;
      v16 = *(a2 + 20);
      v15 = *(a2 + 24);
      v12 |= v16 >> v15;
      *(a2 + 24) = v15 + 32;
      if (v15 == -32)
      {
        v14 = 0;
      }

      else
      {
        v14 = v16 << -v15;
      }
    }

    else
    {
      v14 = v11 << 7;
    }

    *(a2 + 20) = v14;
    v10 = __exp10f(v12 / 28.0);
  }

  *&v17 = 0xAAAAAAAAAAAAAAAALL;
  *(&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v28[30] = v17;
  v28[31] = v17;
  v28[28] = v17;
  v28[29] = v17;
  v28[26] = v17;
  v28[27] = v17;
  v28[24] = v17;
  v28[25] = v17;
  v28[22] = v17;
  v28[23] = v17;
  v28[20] = v17;
  v28[21] = v17;
  v28[18] = v17;
  v28[19] = v17;
  v28[16] = v17;
  v28[17] = v17;
  v28[14] = v17;
  v28[15] = v17;
  v28[12] = v17;
  v28[13] = v17;
  v28[10] = v17;
  v28[11] = v17;
  v28[8] = v17;
  v28[9] = v17;
  v28[6] = v17;
  v28[7] = v17;
  v28[4] = v17;
  v28[5] = v17;
  v28[2] = v17;
  v28[3] = v17;
  v28[0] = v17;
  v28[1] = v17;
  if (avq_dec::DecodeAVQ(a2, v28, 1, 1, a4))
  {
    return 0xFFFFFFFFLL;
  }

  if (a5)
  {
    if (a4 >= 1)
    {
      v19 = *(a1 + 8 * a3 + 512);
      v20 = a4;
      v21 = v28;
      do
      {
        v22 = *v21++;
        *v19++ = v10 * v22;
        --v20;
      }

      while (v20);
    }
  }

  else if (a4)
  {
    v23 = *(a1 + 8 * a3 + 512);
    v24 = 4 * a4;
    v25 = v28;
    do
    {
      v26 = *v25++;
      *v23++ = v26;
      v24 -= 4;
    }

    while (v24);
  }

  return 0;
}

__n128 lsf_dec::vlpc_1st_dec(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 20);
  v5 = HIBYTE(v4);
  v6 = *(a1 + 24) - 8;
  *(a1 + 24) = v6;
  if (v6 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a1, *a1);
    *a1 += 4;
    v9 = *(a1 + 20);
    v8 = *(a1 + 24);
    v5 |= v9 >> v8;
    *(a1 + 24) = v8 + 32;
    if (v8 == -32)
    {
      v7 = 0;
    }

    else
    {
      v7 = v9 << -v8;
    }
  }

  else
  {
    v7 = v4 << 8;
  }

  *(a1 + 20) = v7;
  v10 = &lpd_rom::cdk_dec_dico_lsf_abs_8b + 64 * v5;
  *a2 = *v10;
  *(a2 + 16) = *(v10 + 1);
  *(a2 + 32) = *(v10 + 2);
  result = *(v10 + 3);
  *(a2 + 48) = result;
  return result;
}

uint64_t lsf_dec::vlpc_2st_dec(uint64_t a1, float *a2, unsigned int a3)
{
  v24 = *MEMORY[0x1E69E9840];
  *&v5 = 0xAAAAAAAAAAAAAAAALL;
  *(&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[2] = v5;
  v19[3] = v5;
  v19[0] = v5;
  v19[1] = v5;
  if (avq_dec::DecodeAVQ(a1, v19, a3, 2, 16))
  {
    return 0xFFFFFFFFLL;
  }

  *&v7 = -1;
  *(&v7 + 1) = -1;
  *&v22[12] = v7;
  *v22 = v7;
  v21[1] = v7;
  v21[0] = v7;
  v20 = *a2;
  v23 = 6400.0 - a2[15];
  MEMORY[0x19EAE6100](a2, 1, a2 + 1, 1, v21, 1, 15);
  if (a3 > 2)
  {
    v8 = 63.0;
  }

  else
  {
    v8 = flt_19B3BF770[a3];
  }

  v9 = 0;
  v10 = vld1q_dup_f32(&v20);
  v11 = v8 / 400.0;
  do
  {
    v12 = v21[v9 / 0x10];
    *&a2[v9 / 4] = vmlaq_f32(*&a2[v9 / 4], vcvtq_f32_s32(v19[v9 / 0x10]), vmulq_n_f32(vsqrtq_f32(vmulq_f32(vextq_s8(v10, v12, 0xCuLL), v12)), v11));
    v9 += 16;
    v10 = v12;
  }

  while (v9 != 64);
  v13 = 0;
  v14 = 50.0;
  do
  {
    v15 = a2[v13];
    if (v15 < v14)
    {
      a2[v13] = v14;
      v15 = v14;
    }

    v14 = v15 + 50.0;
    ++v13;
  }

  while (v13 != 16);
  v16 = 6400.0;
  for (i = 15; i != -1; --i)
  {
    v18 = v16 + -50.0;
    v16 = a2[i];
    if (v16 > v18)
    {
      a2[i] = v18;
      v16 = v18;
    }
  }

  return 0;
}

uint64_t avq_dec::DecodeAVQ(uint64_t a1, uint64_t a2, int a3, int *a4, int a5)
{
  if (a5 < 1)
  {
    return 0;
  }

  v97 = v8;
  v98 = v7;
  v99 = v5;
  v100 = v6;
  v9 = a3;
  v10 = a2;
  v77 = a2;
  v78 = 0;
  v12 = a4;
  v74 = (8 * a4);
  v73 = a5;
  v79 = a4;
  while (2)
  {
    v85 = 0xAAAAAAAAAAAAAAAALL;
    if (v9 == 1)
    {
      v13 = 0;
      do
      {
        v14 = -1;
        do
        {
          v15 = v14++;
        }

        while (TBitstreamReader<unsigned int>::GetBit(a1) && v14 < 0x25);
        v16 = v15 + 2;
        if (!v14)
        {
          v16 = 0;
        }

        *(&v85 + v13++) = v16;
      }

      while (v13 != v12);
    }

    else
    {
      v18 = *(a1 + 20);
      v17 = *(a1 + 24);
      v19 = &v85;
      v20 = v12;
      do
      {
        v21 = v18 >> 30;
        v17 -= 2;
        *(a1 + 24) = v17;
        if (v17 < 0)
        {
          TBitstreamReader<unsigned int>::FillCacheFrom(a1, *a1);
          *a1 += 4;
          v23 = *(a1 + 20);
          v22 = *(a1 + 24);
          v21 |= v23 >> v22;
          v17 = v22 + 32;
          *(a1 + 24) = v22 + 32;
          if (v22 == -32)
          {
            v18 = 0;
          }

          else
          {
            v18 = v23 << -v22;
          }
        }

        else
        {
          v18 *= 4;
        }

        *(a1 + 20) = v18;
        *v19 = v21 + 2;
        v19 = (v19 + 4);
        --v20;
      }

      while (v20);
      if (v9 == 2)
      {
        v24 = 0;
        do
        {
          if (*(&v85 + v24) >= 5)
          {
            v25 = -1;
            do
            {
              ++v25;
            }

            while (TBitstreamReader<unsigned int>::GetBit(a1) && v25 < 0x25);
            *(&v85 + v24) = v25;
            if (v25)
            {
              *(&v85 + v24) = v25 + 4;
            }
          }

          ++v24;
        }

        while (v24 != v12);
      }

      else
      {
        v26 = 0;
        do
        {
          if (*(&v85 + v26) >= 5)
          {
            v27 = -1;
            do
            {
              ++v27;
            }

            while (TBitstreamReader<unsigned int>::GetBit(a1) && v27 < 0x25);
            if (v27 >= 3)
            {
              v28 = v27 + 4;
            }

            else
            {
              v28 = dword_19B3BF7E8[v27];
            }

            *(&v85 + v26) = v28;
          }

          ++v26;
        }

        while (v26 != v12);
      }
    }

    v29 = 0;
    v80 = v10 + 4 * v78;
    v30 = v77;
    do
    {
      v31 = 0;
      v32 = *(&v85 + v29);
      v33 = (v32 - 3) & 0xFFFFFFFE;
      v82 = (v32 - 3) >> 1;
      if (v32 <= 4)
      {
        v34 = 0;
      }

      else
      {
        v34 = (v32 - 3) >> 1;
      }

      if (v32 <= 4)
      {
        v33 = 0;
      }

      v35 = 4 * (v32 - v33);
      if ((v35 - 33) >= 0xFFFFFFE0)
      {
        v36 = *(a1 + 20);
        v37 = *(a1 + 24);
        v31 = v36 >> -v35;
        *(a1 + 24) = v37 - v35;
        if (v37 - v35 < 0)
        {
          TBitstreamReader<unsigned int>::FillCacheFrom(a1, *a1);
          *a1 += 4;
          v36 = *(a1 + 20);
          v38 = *(a1 + 24);
          v31 |= v36 >> v38;
          *(a1 + 24) = v38 + 32;
          if (v38 == -32)
          {
            v39 = 0;
            goto LABEL_50;
          }

          v35 = -v38;
        }

        v39 = v36 << v35;
LABEL_50:
        *(a1 + 20) = v39;
      }

      v83 = 0u;
      v84 = 0u;
      if (v34)
      {
        v81 = v31;
        for (i = 0; i != 32; i += 4)
        {
          if (v34 - 33 >= 0xFFFFFFE0)
          {
            v42 = *(a1 + 20);
            v41 = v42 >> (32 - v34);
            v43 = *(a1 + 24) - v34;
            *(a1 + 24) = v43;
            if (v43 < 0)
            {
              TBitstreamReader<unsigned int>::FillCacheFrom(a1, *a1);
              *a1 += 4;
              v46 = *(a1 + 20);
              v45 = *(a1 + 24);
              v41 |= v46 >> v45;
              *(a1 + 24) = v45 + 32;
              if (v45 == -32)
              {
                v44 = 0;
              }

              else
              {
                v44 = v46 << -v45;
              }
            }

            else
            {
              v44 = v42 << v34;
            }

            *(a1 + 20) = v44;
          }

          else
          {
            v41 = 0;
          }

          *(&v83 + i) = v41;
        }

        v12 = v79;
        v31 = v81;
        if (v32 > 36)
        {
          return 0xFFFFFFFFLL;
        }
      }

      else if (v32 >= 37)
      {
        return 0xFFFFFFFFLL;
      }

      v47 = (v80 + 32 * v29);
      if (v32 > 4)
      {
        avq_dec::re8_decode_base_index(v32 - ((v32 - 3) & 0xFFFFFFFE), v31, v47, a4);
        v86[0] = vdupq_n_s32(HIDWORD(v84));
        v86[1] = v86[0];
        v92 = -1;
        v91 = -1;
        v90 = -1;
        v48 = -v82;
        v49 = 0;
        v50 = ldexp(SHIDWORD(v84), -v82);
        v93 = v50;
        v51 = 6;
        do
        {
          v52 = *(&v83 + v51);
          v49 += 2 * v52;
          v53 = *(v86 + v51) + 2 * v52;
          *(v86 + v51) = v53;
          v54 = ldexp(v53, v48);
          *(&v89 + v51) = v54;
        }

        while (v51-- > 1);
        LODWORD(v86[0]) += v49 + 4 * v83;
        v56 = ldexp((LODWORD(v86[0]) - 2), v48);
        v89 = v56;
        v57.i64[0] = 0xAAAAAAAAAAAAAAAALL;
        v57.i64[1] = 0xAAAAAAAAAAAAAAAALL;
        v87 = v57;
        v88 = v57;
        avq_dec::nearest_neighbor_2D8(&v89, &v87);
        v58.i64[0] = -1;
        v58.i64[1] = -1;
        v96[0] = v58;
        v96[1] = v58;
        MEMORY[0x19EAE6000](&v89, 1, &avq_dec::RE8_PPV(std::array<float,8ul> const&,std::array<int,8ul> &)::neg1, v96, 1, 8);
        v59.i64[0] = 0xAAAAAAAAAAAAAAAALL;
        v59.i64[1] = 0xAAAAAAAAAAAAAAAALL;
        v94 = v59;
        v95 = v59;
        avq_dec::nearest_neighbor_2D8(v96, &v94);
        v60 = 0;
        v61.i64[0] = 0x100000001;
        v61.i64[1] = 0x100000001;
        v94 = vaddq_s32(v94, v61);
        v95 = vaddq_s32(v95, v61);
        v62 = 0.0;
        v63 = 0.0;
        do
        {
          v64 = *(&v89 + v60);
          v65 = vsubq_f32(v64, vcvtq_f32_s32(*(&v87 + v60)));
          v66 = vmulq_f32(v65, v65);
          v67 = vsubq_f32(v64, vcvtq_f32_s32(*(&v94 + v60)));
          v68 = vmulq_f32(v67, v67);
          v62 = (((v62 + v68.f32[0]) + v68.f32[1]) + v68.f32[2]) + v68.f32[3];
          v63 = (((v63 + v66.f32[0]) + v66.f32[1]) + v66.f32[2]) + v66.f32[3];
          v60 += 16;
        }

        while (v60 != 32);
        if (v63 > v62)
        {
          v87 = v94;
          v88 = v95;
        }

        v69 = 0;
        v70 = vdupq_n_s32(v82);
        do
        {
          v86[v69] = vsubq_s32(v86[v69], vshlq_u32(*(&v87 + v69 * 16), v70));
          ++v69;
        }

        while (v69 != 2);
        for (j = 0; j != 2; ++j)
        {
          *(v30 + j * 16) = vaddq_s32(vshlq_u32(*(v30 + j * 16), v70), v86[j]);
        }
      }

      else
      {
        avq_dec::re8_decode_base_index(v32, v31, v47, a4);
      }

      ++v29;
      v30 += 32;
    }

    while (v29 != v12);
    v77 += 4 * v74;
    v78 += v74;
    v9 = a3;
    v10 = a2;
    if (v78 < v73)
    {
      continue;
    }

    return 0;
  }
}

uint64_t avq_dec::re8_decode_base_index(uint64_t this, unsigned int a2, float32x4_t *a3, int *a4)
{
  *&v42[7] = *MEMORY[0x1E69E9840];
  if (this <= 1)
  {
    v4 = 0uLL;
LABEL_44:
    *a3 = v4;
    a3[1] = v4;
    return this;
  }

  v5 = 4;
  if ((this & 0x7FFFFFFE) == 2)
  {
    while (lpd_rom::cdk_dec_I3[v5] <= a2)
    {
      v6 = v5 >= 5;
      v5 += 4;
      if (v6)
      {
        LODWORD(v5) = 12;
        break;
      }
    }

    if (v5 >= 9)
    {
      LODWORD(v5) = 9;
    }

    if (lpd_rom::cdk_dec_I3[v5 - 2] > a2)
    {
      LODWORD(v5) = v5 - 2;
    }

    v7 = ~(lpd_rom::cdk_dec_I3[v5 - 1] > a2) + v5;
    v8 = &lpd_rom::cdk_dec_A3;
  }

  else
  {
    while (lpd_rom::cdk_dec_I4[v5] <= a2)
    {
      v6 = v5 >= 0x18;
      v5 += 4;
      if (v6)
      {
        LODWORD(v5) = 28;
        break;
      }
    }

    if (v5 >= 28)
    {
      LODWORD(v5) = 28;
    }

    if (lpd_rom::cdk_dec_I4[v5 - 2] > a2)
    {
      LODWORD(v5) = v5 - 2;
    }

    v7 = ~(lpd_rom::cdk_dec_I4[v5 - 1] > a2) + v5;
    v8 = &lpd_rom::cdk_dec_A4;
  }

  v9 = &v8[v7];
  v10 = 0;
  v11 = *v9;
  *&v12 = 0xAAAAAAAAAAAAAAAALL;
  *(&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v36[0] = v12;
  v36[1] = v12;
  do
  {
    *(v36 + v10) = lpd_rom::cdk_dec_Da[8 * v11 + v10];
    ++v10;
  }

  while (v10 != 8);
  v13 = lpd_rom::cdk_dec_Ia[v11];
  v14 = lpd_rom::cdk_dec_Ns[v11];
  v15 = &lpd_rom::cdk_dec_Is[v13];
  if (v14 < 5)
  {
    v16 = 4;
  }

  else
  {
    v16 = ((v14 - 5) & 0xFFFFFFFC) + 8;
    v17 = 4;
    while (*&v15[2 * v17] <= a2)
    {
      v17 += 4;
      if (v17 >= v14)
      {
        goto LABEL_31;
      }
    }

    v16 = v17;
  }

LABEL_31:
  if (v16 < v14)
  {
    LODWORD(v14) = v16;
  }

  if (*&v15[2 * v14 - 4] > a2)
  {
    LODWORD(v14) = v14 - 2;
  }

  v18 = ~(*&v15[2 * v14 - 2] > a2) + v13 + v14;
  v19 = 2 * lpd_rom::cdk_dec_Ds[v18];
  for (i = 28; i != -4; i -= 4)
  {
    *(v36 + i) -= *(v36 + i) * (v19 & 2);
    v19 >>= 1;
  }

  LODWORD(v21) = 0;
  v22 = lpd_rom::cdk_dec_Is[v18];
  memset(v42, 170, 20);
  v41 = 0xAAAAAAAAAAAAAAAALL;
  memset(v39, 170, sizeof(v39));
  v38 = 0xAAAAAAAAAAAAAAAALL;
  v37 = 1;
  v23 = 4;
  v24 = v36[0];
  v25 = 1;
  v40 = v36[0];
  do
  {
    v26 = v24;
    v24 = *(v36 + v23);
    if (v24 == v26)
    {
      v27 = *(&v37 + v21) + 1;
      *(&v37 + v21) = v27;
      v25 *= v27;
    }

    else
    {
      v21 = v21 + 1;
      *(&v37 + v21) = 1;
      *(&v40 + v21) = v24;
    }

    v23 += 4;
  }

  while (v23 != 32);
  if (v37 == 8)
  {
    v28 = &v40;
    v4 = vld1q_dup_f32(v28);
    goto LABEL_44;
  }

  v29 = 0;
  v30 = v25 * (a2 - v22);
  v31 = 1;
  do
  {
    v32 = -1;
    v33 = &v37;
    this = v30;
    do
    {
      v30 = this;
      ++v32;
      v35 = *v33++;
      v34 = v35;
      this = (this - lpd_rom::cdk_dec_tab_factorial[v29] * v31 * v35);
    }

    while ((this & 0x80000000) == 0);
    a3->i32[v29] = *(&v40 + v32);
    v31 *= v34;
    *(&v37 + v32) = v34 - 1;
    ++v29;
  }

  while (v29 != 8);
  return this;
}

void avq_dec::nearest_neighbor_2D8(float32x4_t *a1, int32x4_t *a2)
{
  v3 = 0;
  v15 = *MEMORY[0x1E69E9840];
  __asm { FMOV            V0.4S, #1.0 }

  do
  {
    a2[v3] = vbslq_s8(vcltzq_f32(a1[v3]), vnegq_s32((*&vcvtq_s32_f32(vsubq_f32(_Q0, a1[v3])) & __PAIR128__(0xFFFFFFFEFFFFFFFELL, 0xFFFFFFFEFFFFFFFELL))), (*&vcvtq_s32_f32(vaddq_f32(a1[v3], _Q0)) & __PAIR128__(0xFFFFFFFEFFFFFFFELL, 0xFFFFFFFEFFFFFFFELL)));
    ++v3;
  }

  while (v3 != 2);
  v9 = a2[1];
  if ((vaddvq_s32(vaddq_s32(v9, *a2)) & 3) != 0)
  {
    v10 = vsubq_f32(a1[1], vcvtq_f32_s32(v9));
    __A[0] = vsubq_f32(*a1, vcvtq_f32_s32(*a2));
    __A[1] = v10;
    __C = 0.0;
    v12 = 0;
    vDSP_maxmgvi(__A, 1, &__C, &v12, 8uLL);
    if (*(__A + v12) >= 0.0)
    {
      v11 = 2;
    }

    else
    {
      v11 = -2;
    }

    a2->i32[v12] += v11;
  }
}

uint64_t MPEG_D::USAC::ArithDecoder::Decode(uint64_t a1, uint64_t a2, float32x2_t *a3, unsigned int a4, unsigned int a5, int a6)
{
  if (a5 < a4)
  {
    return 0xFFFFFFFFLL;
  }

  v138 = v6;
  v139 = v7;
  v9 = a5;
  v13 = a1;
  if (a6)
  {
    bzero(*(a1 + 16), (a5 >> 1) + 2);
  }

  else
  {
    v14 = *(a1 + 40);
    if (v14 != a5)
    {
      if (!v14)
      {
        return 0xFFFFFFFFLL;
      }

      v15 = v14 >> 1;
      v16 = a5 >> 1;
      v17 = *(a1 + 16);
      v18 = v17 + v16;
      if (*(a1 + 40) >> 1 >= v16)
      {
        v27 = v14 >> 3;
        v28 = v27 > v16;
        if (v27 == v16)
        {
          v29 = 4;
        }

        else
        {
          v29 = 2;
        }

        if (v28)
        {
          v29 = 8;
        }

        if (a5 >= 2)
        {
          v30 = 0;
          v16 = v16;
          v31 = v16;
          v32 = *(a1 + 16);
          do
          {
            *v32++ = *(v17 + v30);
            v30 += v29;
            --v31;
          }

          while (v31);
        }

        else
        {
          v16 = 0;
        }

        *(v17 + v16) = *(v17 + v15);
        *(v18 + 1) = *(v17 + v15 + 1);
      }

      else
      {
        v19 = v17 + v15;
        *(v17 + v16) = *(v17 + v15);
        *(v18 + 1) = *(v17 + v15 + 1);
        v28 = a5 >> 3 > v15;
        v20 = a5 >> 3 == v15;
        if (v28)
        {
          v20 = 3;
        }

        v21 = 2 * v20;
        v22 = v17 + ~(2 * v20);
        v23 = (v19 - 1);
        v24 = v16 + 1;
        v25 = 2 * ~v20;
        do
        {
          v26 = *v23--;
          memset((v22 + v24 - 2), v26, v21 + 2);
          v24 += v25;
        }

        while (v24 > 1);
      }
    }
  }

  *(v13 + 40) = v9;
  if (a4)
  {
    v136 = 0;
    v137 = 0;
    MPEG_D::USAC::ArithDecoder::SymbolState::Begin(&v136, a2);
    v33 = a4 >> 1;
    if (a4 == 1)
    {
      TBitstreamReader<unsigned int>::PutBack(a2, 14);
      goto LABEL_26;
    }

    v114 = v9;
    v38 = 0;
    v39 = 0;
    v40 = 0;
    v41 = 0;
    v42 = *(v13 + 16);
    v43 = *v42 << 12;
    v116 = v13;
    v117 = a3;
    v118 = a4 >> 1;
    v115 = v42;
LABEL_35:
    v123 = v38 + 1;
    v44 = ((v43 >> 4) & 0xFF0) + v41 + (v42[v38 + 1] << 12);
    v45 = v44;
    v127 = v38;
    if (v38 >= 4)
    {
      if ((v40 + v41 + v39) >= 5)
      {
        v45 = v44;
      }

      else
      {
        v45 = v44 + 0x10000;
      }
    }

    v124 = v44;
    v125 = v41;
    v126 = v40;
    v46 = 0;
    v47 = 0;
    if (v45 >= 0xF000u)
    {
      v48 = 39;
    }

    else
    {
      v48 = 21;
    }

    v49 = v45 >> 12;
    if (v45 == 13394)
    {
      v50 = 21;
    }

    else
    {
      v50 = 39;
    }

    if (v45 < 0x3452u)
    {
      v50 = 17;
    }

    v122 = v50;
    v51 = v45 & 0xFFF;
    if (v51 >= 0x333)
    {
      v52 = 21;
    }

    else
    {
      v52 = 17;
    }

    v53 = (v45 >> 8) & 0xF;
    if (v53 <= 7)
    {
      v54 = 20;
    }

    else
    {
      v54 = 21;
    }

    v55 = v45 >> 4;
    if (((v45 >> 4) & 0xC) != 0)
    {
      v56 = 4;
    }

    else
    {
      v56 = v45 >> 4;
    }

    if (v45 >= 0xFu)
    {
      v57 = 15;
    }

    else
    {
      v57 = v45;
    }

    v131 = v57;
    if (v55 >= 6)
    {
      v55 = 6;
    }

    v58 = v55 - v53;
    if (v53 >= 6)
    {
      v59 = 6;
    }

    else
    {
      v59 = (v45 >> 8) & 0xF;
    }

    v60 = v58 + 8 * v53;
    if (v53 >= 6)
    {
      v61 = v53 + 36;
    }

    else
    {
      v61 = v60;
    }

    if (v45 == 2)
    {
      v62 = 1;
    }

    else
    {
      v62 = 39;
    }

    v120 = v62;
    if (v45 == 2)
    {
      v63 = 50;
    }

    else
    {
      v63 = 0;
    }

    if (v45 < 2u)
    {
      v63 = 49;
    }

    v133 = v63;
    if (v45 == 4352)
    {
      v48 = 23;
    }

    if (BYTE1(v45) >= 0x11u)
    {
      v64 = v48;
    }

    else
    {
      v64 = 39;
    }

    v132 = v64;
    if ((v45 & 0xFFF0) != 0)
    {
      v65 = 21;
    }

    else
    {
      v65 = 39;
    }

    v66 = v45 == 0xFFFF || v45 == 40959;
    v67 = 5 * v53 + v56;
    if (v66)
    {
      v68 = 23;
    }

    else
    {
      v68 = 39;
    }

    if (v45 >= 0x9FFFu)
    {
      v65 = v68;
    }

    v134 = v65;
    if (v51 >= 0x112)
    {
      v69 = 0;
    }

    else
    {
      v69 = 21;
    }

    if (v51 >= 0x112)
    {
      v70 = 0;
    }

    else
    {
      v70 = 39;
    }

    if (v51 >= 0x131)
    {
      v69 = 39;
    }

    if (((v45 >> 8) & 0xC) != 0)
    {
      v67 = v54;
    }

    v71 = v53 - 13;
    if (v53 < 0xD)
    {
      v71 = 0;
    }

    v72 = 2 * v49 + (v45 >> 12) + v71;
    if (v51 == 530)
    {
      v73 = 0;
    }

    else
    {
      v73 = 17;
    }

    if (v51 < 0x212)
    {
      v73 = 17;
    }

    if (v51 >= 0x132)
    {
      v69 = v73;
    }

    v130 = v69;
    if (v51 >= 0x221)
    {
      v74 = 21;
    }

    else
    {
      v74 = v70;
    }

    if (v51 < 0x233)
    {
      v52 = 0;
    }

    if (v51 >= 0x222)
    {
      v75 = v52;
    }

    else
    {
      v75 = v74;
    }

    v121 = v75;
    v76 = v59 - (v45 >> 12) + 8 * v49 - 7;
    v77 = v67 + 22 * v49 - 22;
    if ((v45 & 0xC000) != 0)
    {
      v77 = v72 + 54;
    }

    if (v45 >= 0x9000u)
    {
      v76 = v49 + 47;
    }

    v128 = (&MPEG_D::USAC::StateMapper::kHashTabESC01 + 8 * v76);
    v129 = (&MPEG_D::USAC::StateMapper::kHashTabESC02 + 8 * v77);
    while (1)
    {
      v78 = v45 + (v47 << 17);
      v79 = WORD1(v78);
      if (WORD1(v78))
      {
        if (WORD1(v78) > 3u)
        {
          if (v79 == 4)
          {
            v85 = (&MPEG_D::USAC::StateMapper::kHashTabESC04 + 8 * (v45 >> 11));
            goto LABEL_154;
          }

          v80 = v134;
          if (v79 != 6)
          {
            v80 = 39;
            if (v79 == 8)
            {
              v80 = v132;
            }
          }
        }

        else
        {
          if (v79 == 1)
          {
            v80 = v133;
            if (v45 < 0x1000u)
            {
              goto LABEL_156;
            }

            v85 = v128;
            goto LABEL_154;
          }

          if (v79 == 2)
          {
            if (v45 <= 0xFFFu)
            {
              v80 = MPEG_D::USAC::StateMapper::DecodeESC2const::kTab[v131];
              goto LABEL_156;
            }

            v85 = v129;
LABEL_154:
            v83 = *v85;
            v84 = v85[1];
            v78 = v45;
LABEL_155:
            v80 = MPEG_D::USAC::StateMapper::DecodeLowOrderContext(v78, v83, v84);
            goto LABEL_156;
          }

          v80 = 39;
          if (v79 == 3)
          {
            if ((v45 >> 12) > 1u)
            {
              v80 = v130;
              if (v49 != 2)
              {
                v80 = 39;
                if (v49 == 3)
                {
                  v80 = v122;
                }
              }
            }

            else if (v45 >> 12)
            {
              v80 = v121;
            }

            else if (v45)
            {
              v80 = v120;
              if (v45 == 1)
              {
                v80 = 39;
              }
            }

            else
            {
              v80 = 43;
            }
          }
        }
      }

      else
      {
        if (v78 >= 0x1000)
        {
          if (v78 >= 0x7000)
          {
            v81 = (v45 >> 8) & 0xF;
          }

          else
          {
            v81 = v61;
          }

          v82 = (MPEG_D::USAC::StateMapper::kHashTabPtrs[v78 >> 12] + 8 * v81);
          v83 = *v82;
          v84 = v82[1];
          goto LABEL_155;
        }

        if (v78 >= 0x10)
        {
          if (v78 <= 0x111)
          {
            v80 = 0;
          }

          else
          {
            v80 = 58;
          }
        }

        else
        {
          v80 = MPEG_D::USAC::StateMapper::kHashTabZeroC3[v78];
        }
      }

LABEL_156:
      Symbol = MPEG_D::USAC::ArithDecoder::GetSymbol(a2, &MPEG_D::USAC::ArithCodec::kMSBProbModelTab[17 * v80], &v136, 0);
      if (Symbol < 0x10)
      {
        if (Symbol)
        {
          v87 = Symbol >> 2;
          v88 = Symbol & 3;
          v89 = v127;
          if (v46)
          {
            for (i = 0; i < v46; ++i)
            {
              v91 = 2 * (v87 != 0);
              if (!v88)
              {
                v91 = 1;
              }

              v92 = MPEG_D::USAC::ArithDecoder::GetSymbol(a2, &MPEG_D::USAC::ArithCodec::kLSBProbModelTab[4 * v91], &v136, 1);
              v93 = v92 >> 1;
              Symbol = v92 & 1 | (2 * v88);
              LOWORD(v87) = v93 | (2 * v87);
              v88 = Symbol;
            }
          }

          else
          {
            LOWORD(Symbol) = Symbol & 3;
          }

          v13 = v116;
          a3 = v117;
          v95 = &v117[v127];
          *v95 = Symbol;
          v95[1] = v87;
          if ((v87 + Symbol + 1) >= 0xFu)
          {
            v94 = 15;
          }

          else
          {
            v94 = (v87 + Symbol + 1);
          }

LABEL_179:
          v42 = v115;
          v115[v89] = v94;
          v38 = v123;
          v40 = v125;
          v39 = v126;
          v41 = v94;
          v33 = v118;
          v43 = v124;
          if (v123 == v118)
          {
            goto LABEL_186;
          }

          goto LABEL_35;
        }

        v66 = v47 == 0;
        v89 = v127;
        if (v66)
        {
          v13 = v116;
          a3 = v117;
          v117[v127] = 0;
          v94 = 1;
          goto LABEL_179;
        }

        v33 = v127;
        v13 = v116;
        a3 = v117;
LABEL_186:
        TBitstreamReader<unsigned int>::PutBack(a2, 14);
        if (!v33)
        {
LABEL_26:
          v34 = v33;
          goto LABEL_27;
        }

        v119 = v33;
        v34 = v33;
        v97 = a3;
        v98 = v34;
        while (2)
        {
          *&v96 = *v97;
          v99 = vmvn_s8(vceqz_f32(*v97));
          v100 = v99.i32[1];
          v101 = v99.i32[0];
          v102 = v99.i32[0] + v99.i32[1];
          v103 = -(v99.i32[0] + v99.i32[1]);
          if ((v99.i32[0] + v99.i32[1]) < 0xFFFFFFE0)
          {
            if (v102)
            {
              v104 = 0;
LABEL_198:
              if ((v104 ^ (-1 << v103)) != 0xFFFFFFFF)
              {
                v110 = (v104 & 1) != 0 || v100 == 0;
                v111 = vneg_f32(*&v96);
                if (v110)
                {
                  v112 = 0;
                }

                else
                {
                  v112 = -1;
                }

                v113 = __PAIR64__(vbsl_s8(vdup_n_s32(v112), v111, *&v96).u32[1], v96);
                if (v101 && ((v104 >> ~v102) & 1) == 0)
                {
                  *&v113 = -*&v96;
                }

                *v97 = v113;
              }
            }

            ++v97;
            if (!--v98)
            {
              v13 = v116;
              a3 = v117;
              v9 = v114;
              v33 = v119;
LABEL_27:
              v35 = 2 * v33;
              v36 = v33 + ((v9 - 2 * v33) >> 1) - v34;
              if (v36 >= 1)
              {
                memset((*(v13 + 16) + v34), 1, v36);
              }

              v37 = v9 - v35;
              if (v37 >= 1)
              {
                a3 = (a3 + 4 * v35);
                goto LABEL_184;
              }

              return 0;
            }

            continue;
          }

          break;
        }

        v105 = *(a2 + 20);
        v104 = v105 >> v102;
        v106 = *(a2 + 24) + v102;
        *(a2 + 24) = v106;
        if (v106 < 0)
        {
          v135 = v96;
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
          *a2 += 4;
          v109 = *(a2 + 20);
          v108 = *(a2 + 24);
          v104 |= v109 >> v108;
          *(a2 + 24) = v108 + 32;
          if (v108 == -32)
          {
            v107 = 0;
          }

          else
          {
            v107 = v109 << -v108;
          }

          v96 = v135;
        }

        else
        {
          v107 = v105 << v103;
        }

        *(a2 + 20) = v107;
        goto LABEL_198;
      }

      if (v46 > 0x16)
      {
        return 0xFFFFFFFFLL;
      }

      ++v46;
      if (v47 < 7u)
      {
        ++v47;
      }
    }
  }

  if (v9 >= 2)
  {
    memset(*(v13 + 16), 1, v9 >> 1);
  }

  else if (!v9)
  {
    return 0;
  }

  v37 = v9;
LABEL_184:
  bzero(a3, 4 * v37);
  return 0;
}

_DWORD *MPEG_D::USAC::ArithDecoder::SymbolState::Begin(_DWORD *result, uint64_t a2)
{
  v3 = result;
  *result = 0xFFFF;
  v4 = *(a2 + 20);
  v5 = HIWORD(v4);
  v6 = *(a2 + 24) - 16;
  *(a2 + 24) = v6;
  if (v6 < 0)
  {
    result = TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v9 = *(a2 + 20);
    v8 = *(a2 + 24);
    v5 |= v9 >> v8;
    *(a2 + 24) = v8 + 32;
    if (v8 == -32)
    {
      v7 = 0;
    }

    else
    {
      v7 = v9 << -v8;
    }
  }

  else
  {
    v7 = v4 << 16;
  }

  *(a2 + 20) = v7;
  *(v3 + 2) = v5;
  return result;
}

uint64_t MPEG_D::USAC::ArithDecoder::GetSymbol(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, int a4)
{
  v7 = a3[1];
  v8 = *a3 - v7 + 1;
  v9 = ((a3[2] - v7) << 14) | 0x3FFF;
  v10 = a2 - 1;
  if (a4)
  {
    if (v8 * a2[1] <= v9)
    {
      v11 = 0x4000;
    }

    else
    {
      v10 = a2 + 1;
      v11 = a2[1];
    }

    v12 = v10[1];
    if (v8 * v12 > v9)
    {
      v11 = v10[1];
      v12 = v10[2];
      LODWORD(v10) = v10 + 2;
    }
  }

  else
  {
    v12 = *a2;
    if (v8 * v12 <= v9)
    {
      v13 = a3;
      v11 = 0x4000;
      goto LABEL_12;
    }

    LODWORD(v10) = a2 + 30;
    v11 = a2[15];
    if (v8 * v11 > v9)
    {
      v13 = a3;
      v12 = 0;
      goto LABEL_12;
    }

    v15 = a2 + 8;
    v16 = a2[8];
    if (v8 * v16 <= v9)
    {
      v15 = a2;
      v16 = *a2;
    }

    v17 = v15[4];
    if (v8 * v17 > v9)
    {
      v15 += 4;
      v16 = v17;
    }

    v18 = v15[2];
    if (v8 * v18 <= v9)
    {
      v10 = v15;
    }

    else
    {
      v10 = v15 + 2;
    }

    if (v8 * v18 <= v9)
    {
      v19 = v16;
    }

    else
    {
      v19 = v15[2];
    }

    v11 = v10[1];
    if (v8 * v11 <= v9)
    {
      v12 = v10[1];
      v11 = v19;
    }

    else
    {
      v12 = v10[2];
      LODWORD(v10) = v10 + 2;
    }
  }

  v13 = a3;
LABEL_12:
  MPEG_D::USAC::ArithDecoder::SymbolState::Update(v13, a1, v11, v12);
  return (((v10 - a2) >> 1) + 1);
}

_DWORD *MPEG_D::USAC::ArithDecoder::SymbolState::Update(_DWORD *result, uint64_t a2, int a3, int a4)
{
  v5 = result;
  v6 = *result;
  v7 = *(result + 1);
  v8 = v6 - v7 + 1;
  if ((a3 & 0xC000) == 0)
  {
    v6 = v7 + ((v8 * a3) >> 14) - 1;
    *result = v7 + ((v8 * a3) >> 14) - 1;
  }

  v9 = v7 + ((v8 * a4) >> 14);
  *(result + 1) = v9;
  v10 = v6;
  if (v6 != v9)
  {
    v11 = __clz((v6 ^ v9));
    v12 = v11 - 16;
    v13 = v9 << (v11 - 16);
    *(result + 1) = v13;
    v14 = v10 << (v11 - 16);
    v15 = *(result + 2) << (v11 - 16);
    *(result + 2) = v15;
    if ((v13 & 0x4000) != 0 && (v14 & 0x4000) == 0)
    {
      v16 = 2 * v14;
      v17 = 2 * v13;
      v18 = 2 * v15;
      v19 = __clz(v16 & 0xFFFE);
      v20 = __clz(~(2 * v13) << 16) | 0x10;
      if (v20 < v19)
      {
        LOWORD(v19) = v20;
      }

      v21 = v19 - 17;
      v12 = v11 + (v19 - 17) - 15;
      v14 = (v16 << v21) ^ 0xFFFF8000;
      *(result + 1) = (v17 << v21) ^ 0x8000;
      v15 = (v18 << v21) ^ 0xFFFF8000;
      *(result + 2) = v15;
    }

    *result = v14 | ~(-1 << v12);
    if ((v12 - 33) < 0xFFFFFFE0)
    {
      LOWORD(v22) = 0;
LABEL_19:
      *(v5 + 2) = v15 | v22;
      return result;
    }

    v23 = *(a2 + 20);
    v24 = *(a2 + 24);
    v22 = v23 >> -v12;
    *(a2 + 24) = v24 - v12;
    if (v24 - v12 < 0)
    {
      result = TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      *a2 += 4;
      v23 = *(a2 + 20);
      v25 = *(a2 + 24);
      v22 |= v23 >> v25;
      *(a2 + 24) = v25 + 32;
      if (v25 == -32)
      {
        v26 = 0;
        goto LABEL_18;
      }

      v12 = -v25;
    }

    v26 = v23 << v12;
LABEL_18:
    *(a2 + 20) = v26;
    LOWORD(v15) = *(v5 + 2);
    goto LABEL_19;
  }

  return MPEG_D::USAC::ArithDecoder::SymbolState::Begin(result, a2);
}

uint64_t MPEG_D::USAC::StateMapper::DecodeLowOrderContext(MPEG_D::USAC::StateMapper *this, unsigned int a2, unsigned int a3)
{
  v3 = (16 << (4 * (a2 & 3))) - 1;
  v4 = v3 & this;
  if ((v3 & this) != 0)
  {
    v5 = 6;
  }

  else
  {
    v5 = 0;
  }

  v6 = (((v3 & this) != 0) & (a2 >> 3)) + ((a2 & 0xFFF0) >> 4);
  if ((a2 & 8) != 0)
  {
    v7 = v5;
  }

  else
  {
    v7 = 6;
  }

  if (a3)
  {
    while (v4 > (a3 & v3))
    {
      a3 >>= 4 * (a2 & 3) + 4;
      LOWORD(v6) = v6 + 1;
      if (!a3)
      {
        return (MPEG_D::USAC::StateMapper::kProbModelIndexTab[v6] >> v7) & 0x3F;
      }
    }

    if (v4 == (a3 & v3))
    {
      v7 = 0;
    }
  }

  return (MPEG_D::USAC::StateMapper::kProbModelIndexTab[v6] >> v7) & 0x3F;
}

uint64_t MPEG_D::USAC::ScaleFactorData::Deserialize(uint64_t a1, uint64_t a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  v27 = a3;
  if (a3)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0x80000000 >> *(*(a1 + 520) + 8);
    v12 = a1 + 8;
    v13 = a4;
    v26 = a4;
    v28 = v11;
    do
    {
      if (a4)
      {
        v14 = 0;
        do
        {
          if (v10 | v14)
          {
            if (v9 < *(*(a1 + 520) + 8))
            {
              if (v9 <= 0x1F)
              {
                v16 = *(a2 + 20);
                v15 = v16 >> v9;
                v17 = *(a2 + 24) - (32 - v9);
                *(a2 + 24) = v17;
                if (v17 < 0)
                {
                  TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
                  *a2 += 4;
                  v20 = *(a2 + 20);
                  v19 = *(a2 + 24);
                  v15 |= v20 >> v19;
                  *(a2 + 24) = v19 + 32;
                  if (v19 == -32)
                  {
                    v18 = 0;
                  }

                  else
                  {
                    v18 = v20 << -v19;
                  }

                  v11 = v28;
                }

                else
                {
                  v18 = v16 << (32 - v9);
                }

                *(a2 + 20) = v18;
              }

              else
              {
                v15 = 0;
              }

              v8 |= v15;
              v9 = 32;
            }

            if (v8 < 0)
            {
              v21 = __clz(v11 | ~v8);
              v22 = **(a1 + 520) + 16 * v21;
              LOWORD(v21) = *(*(v22 + 8) + 2 * ((v8 << v21) >> *v22));
              v8 <<= v21;
              v9 -= v21 & 0x3F;
              v23 = a5 + (v21 >> 6);
              if (v23 > 0)
              {
                v24 = 255;
              }

              else
              {
                v24 = -256;
              }

              if ((v23 ^ (v23 >> 31)) >= 256)
              {
                a5 = v24;
              }

              else
              {
                a5 = v23;
              }
            }

            else
            {
              v8 *= 2;
              --v9;
            }
          }

          *(v12 + 4 * v14++) = MPEG_D::USAC::ScaleFactorData::kPow2_025[(a5 - 100) & 3] + ((a5 - 100) >> 2 << 23);
        }

        while (v13 != v14);
      }

      v12 += 64;
      ++v10;
      a4 = v26;
    }

    while (v10 != v27);
  }

  else
  {
    v9 = 0;
  }

  return TBitstreamReader<unsigned int>::PutBack(a2, v9);
}

uint64_t MPEG_D::USAC::SpectralDataDecoder::Deserialize(uint64_t a1, uint64_t a2, int a3, unsigned __int8 a4, unsigned int a5, char a6)
{
  if (a3 == 2)
  {
    v9 = 3;
  }

  else
  {
    v9 = 0;
  }

  if (a3 == 2)
  {
    v10 = 8;
  }

  else
  {
    v10 = 1;
  }

  v11 = *(*(*(a1 + 216) + 8 * (a3 == 2)) + 2 * a4);
  v12 = *(a1 + 212) >> v9;
  v13 = (a6 & 1) != 0 || TBitstreamReader<unsigned int>::GetBit(a2) != 0;
  v14 = 0;
  v15 = *(a1 + 8) + 48 * a5;
  v16 = *(*(a1 + 56) + 24 * a5);
  do
  {
    if (v14)
    {
      v17 = 0;
    }

    else
    {
      v17 = v13;
    }

    result = MPEG_D::USAC::ArithDecoder::Decode(v15, a2, v16, v11, v12, v17);
    if (result)
    {
      v19 = 1;
    }

    else
    {
      v19 = v10 - 1 == v14;
    }

    ++v14;
    v16 = (v16 + 4 * v12);
  }

  while (!v19);
  return result;
}

uint64_t lpd_dec::lpdDecoder::FacRead(uint64_t a1, uint64_t a2, char a3, int a4)
{
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  *(a1 + 5304) = 0;
  v9 = (a1 + 4784);
  *(a1 + 5320) = 0;
  *(a1 + 5312) = 0;
  *(a1 + 5328) = 0;
  *(a1 + 5296) = a1 + 4784;
  if (Bit)
  {
    *(a1 + 5916) = 2;

    return fac_dec::facDecoder::Read(v9, a2, 0, a4 >> (a3 ^ 1), 1);
  }

  else
  {
    if (*(a1 + 1388) == 2 && !*(a1 + 1392))
    {
      *(a1 + 5264) = 0u;
      *(a1 + 5280) = 0u;
      *(a1 + 5232) = 0u;
      *(a1 + 5248) = 0u;
      *(a1 + 5200) = 0u;
      *(a1 + 5216) = 0u;
      *(a1 + 5168) = 0u;
      *(a1 + 5184) = 0u;
      *(a1 + 5136) = 0u;
      *(a1 + 5152) = 0u;
      *(a1 + 5104) = 0u;
      *(a1 + 5120) = 0u;
      *(a1 + 5072) = 0u;
      *(a1 + 5088) = 0u;
      *(a1 + 5040) = 0u;
      *(a1 + 5056) = 0u;
      *(a1 + 5008) = 0u;
      *(a1 + 5024) = 0u;
      *(a1 + 4976) = 0u;
      *(a1 + 4992) = 0u;
      *(a1 + 4944) = 0u;
      *(a1 + 4960) = 0u;
      *(a1 + 4912) = 0u;
      *(a1 + 4928) = 0u;
      *(a1 + 4880) = 0u;
      *(a1 + 4896) = 0u;
      *(a1 + 4848) = 0u;
      *(a1 + 4864) = 0u;
      *(a1 + 4816) = 0u;
      *(a1 + 4832) = 0u;
      *v9 = 0u;
      *(a1 + 4800) = 0u;
    }

    return 0;
  }
}

uint64_t USACBitstreamReader::operator CDK_BITSTREAM *(uint64_t a1)
{
  v2 = *(a1 + 40);
  v3 = *(a1 + 24) + 8 * (*(a1 + 8) - *a1);
  if (v2 != v3)
  {
    USACBitstreamReader::CDKSkipBits(*(a1 + 32), v2 - v3);
    *(a1 + 40) = *(a1 + 24) + 8 * (*(a1 + 8) - *a1);
  }

  return *(a1 + 32);
}

uint64_t CTns_Read(uint64_t result, _BYTE *a2, uint64_t a3)
{
  if (a2[608])
  {
    v3 = a2;
    v4 = result;
    v5 = 0;
    v6 = *(a3 + 12);
    a2[610] = 0;
    v51 = v6;
    if (v6 == 2)
    {
      v7 = 1;
    }

    else
    {
      v7 = 2;
    }

    v53 = a2 + 600;
    v54 = a2;
    if (v6 == 2)
    {
      v8 = 4;
    }

    else
    {
      v8 = 6;
    }

    if (v6 == 2)
    {
      v9 = 3;
    }

    else
    {
      v9 = 4;
    }

    v52 = BitMask[v7];
    v57 = v8;
    v56 = v9;
    v50 = v7;
    while (1)
    {
      v10 = v4[1];
      v11 = v7 - v10;
      if (v7 - v10 <= 0)
      {
        v12 = 0;
        result = *v4;
      }

      else
      {
        if (v11 == 32)
        {
          v12 = 0;
        }

        else
        {
          v12 = *v4 << v11;
        }

        result = CDK_get32((v4 + 2));
        *v4 = result;
        v10 = v4[1] + 32;
      }

      v13 = v10 - v7;
      v4[1] = v13;
      v14 = ((result >> v13) | v12) & v52;
      v55 = v5;
      v53[v5] = v14;
      if (!v14)
      {
        goto LABEL_73;
      }

      v15 = v4[1];
      if (1 - v15 <= 0)
      {
        LOBYTE(v16) = 0;
        result = *v4;
      }

      else
      {
        if (v15 == -31)
        {
          LOBYTE(v16) = 0;
        }

        else
        {
          v16 = *v4 << (1 - v15);
        }

        result = CDK_get32((v4 + 2));
        *v4 = result;
        v15 = v4[1] + 32;
      }

      v17 = v15 - 1;
      v4[1] = v17;
      v64 = v14;
      if (!v14)
      {
        goto LABEL_73;
      }

      v18 = 0;
      v19 = *(a3 + 19);
      v20 = ((result >> v17) | v16) & 1;
      v60 = v20 + 3;
      v59 = (v20 + 1);
      v62 = BitMask[v9];
      v63 = BitMask[v8];
      v21 = v54;
      v61 = &v3[75 * v55];
      do
      {
        v22 = v4[1];
        v23 = v8 - v22;
        if (v8 - v22 <= 0)
        {
          v24 = 0;
          result = *v4;
        }

        else
        {
          if (v23 == 32)
          {
            v24 = 0;
          }

          else
          {
            v24 = *v4 << v23;
          }

          result = CDK_get32((v4 + 2));
          *v4 = result;
          v22 = v4[1] + 32;
        }

        v25 = &v61[25 * v18];
        v26 = v22 - v8;
        v4[1] = v26;
        if ((((result >> v26) | v24) & v63) <= v19)
        {
          v27 = v19 - (((result >> v26) | v24) & v63);
        }

        else
        {
          v27 = 0;
        }

        v25[20] = v27;
        v25[21] = v19;
        v28 = v9 - v26;
        if (v9 - v26 < 1)
        {
          v29 = 0;
        }

        else
        {
          if (v28 == 32)
          {
            v29 = 0;
          }

          else
          {
            v29 = result << v28;
          }

          result = CDK_get32((v4 + 2));
          *v4 = result;
          v26 = v4[1] + 32;
        }

        v30 = v26 - v9;
        v4[1] = v30;
        v31 = ((result >> v30) | v29) & v62;
        v25[24] = v31;
        if (v31 >= 0x15u)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "AAC_DECODER_ERROR CTns_Read(HANDLE_CDK_BITSTREAM, CTnsData *, const CIcsInfo *, const UINT)";
          v48 = 126;
LABEL_78:
          exception[2] = v48;
        }

        if (!v31)
        {
          goto LABEL_72;
        }

        v65 = v27;
        if (1 - v30 < 1)
        {
          v32 = 0;
        }

        else
        {
          if (v30 == -31)
          {
            v32 = 0;
          }

          else
          {
            v32 = result << (1 - v30);
          }

          LODWORD(result) = CDK_get32((v4 + 2));
          *v4 = result;
          v30 = v4[1] + 32;
        }

        v33 = v30 - 1;
        v4[1] = v30 - 1;
        if (((result >> (v30 - 1)) | v32))
        {
          v34 = -1;
        }

        else
        {
          v34 = 1;
        }

        v25[22] = v34;
        if (2 - v30 < 1)
        {
          v35 = 0;
        }

        else
        {
          if (v30 == -30)
          {
            v35 = 0;
          }

          else
          {
            v35 = result << (2 - v30);
          }

          LODWORD(result) = CDK_get32((v4 + 2));
          *v4 = result;
          v33 = v4[1] + 32;
        }

        v4[1] = v33 - 1;
        v25[23] = v60;
        v36 = ((result >> (v33 - 1)) | v35) & 1;
        v37 = CTns_Read(CDK_BITSTREAM *,CTnsData *,CIcsInfo const*,unsigned int)::sgn_mask[v59 - v36];
        v38 = CTns_Read(CDK_BITSTREAM *,CTnsData *,CIcsInfo const*,unsigned int)::neg_mask[v59 - v36];
        v39 = v31 & 0x1F;
        v66 = v21;
        do
        {
          v40 = v25[23] - v36;
          if (v40 >= 0x21)
          {
            exception = __cxa_allocate_exception(0x10uLL);
            *exception = "UINT CDKreadBits(HANDLE_CDK_BITSTREAM, const UINT)";
            v48 = 143;
            goto LABEL_78;
          }

          v41 = v4[1];
          v42 = v40 - v41;
          if ((v40 - v41) <= 0)
          {
            v43 = 0;
            result = *v4;
          }

          else
          {
            if (v42 == 32)
            {
              v43 = 0;
            }

            else
            {
              v43 = *v4 << v42;
            }

            result = CDK_get32((v4 + 2));
            *v4 = result;
            v41 = v4[1] + 32;
          }

          v44 = v41 - v40;
          v4[1] = v44;
          v45 = ((result >> v44) | v43) & BitMask[v40];
          if ((v45 & v37) != 0)
          {
            v46 = v38;
          }

          else
          {
            v46 = 0;
          }

          *v21++ = v46 | v45;
          --v39;
        }

        while (v39);
        v8 = v57;
        v3 = a2;
        a2[610] = 4;
        v9 = v56;
        v21 = v66;
        v27 = v65;
LABEL_72:
        ++v18;
        v21 += 25;
        v19 = v27;
      }

      while (v18 != v64);
LABEL_73:
      v7 = v50;
      if (v51 == 2)
      {
        v5 = v55 + 1;
        v54 += 75;
        if (v55 < 7)
        {
          continue;
        }
      }

      v3[609] = 1;
      return result;
    }
  }

  return result;
}

uint64_t MPEG_D::USAC::ComplexPrediction::DecodeHuffman(uint64_t a1, _DWORD *a2)
{
  {
    MPEG_D::USAC::ComplexPrediction::DecodeHuffman(TBitCache<TBitstreamReader<unsigned int>> &)const::kMask = 0x80000000 >> *(*(a1 + 16) + 8);
  }

  v4 = a2[3];
  if (v4 >= *(*(a1 + 16) + 8))
  {
    v6 = a2[2];
    if ((v6 & 0x80000000) == 0)
    {
LABEL_14:
      result = 0;
      v9 = 2 * v6;
      v10 = v4 - 1;
      goto LABEL_15;
    }
  }

  else
  {
    if (v4 <= 0x1F)
    {
      v12 = *a2;
      v13 = *(*a2 + 20);
      v14 = *(*a2 + 24);
      v5 = v13 >> v4;
      *(*a2 + 24) = v14 - (32 - v4);
      if ((v14 - (32 - v4)) < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(v12, *v12);
        *v12 += 4;
        v17 = *(v12 + 20);
        v16 = *(v12 + 24);
        v5 |= v17 >> v16;
        *(v12 + 24) = v16 + 32;
        if (v16 == -32)
        {
          v15 = 0;
        }

        else
        {
          v15 = v17 << -v16;
        }
      }

      else
      {
        v15 = v13 << (32 - v4);
      }

      *(v12 + 20) = v15;
    }

    else
    {
      v5 = 0;
    }

    v6 = a2[2] | v5;
    v4 = 32;
    if ((v6 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  v7 = __clz(MPEG_D::USAC::ComplexPrediction::DecodeHuffman(TBitCache<TBitstreamReader<unsigned int>> &)const::kMask | ~v6);
  v8 = **(a1 + 16) + 16 * v7;
  LOWORD(v7) = *(*(v8 + 8) + 2 * ((v6 << v7) >> *v8));
  v9 = v6 << v7;
  v10 = v4 - (v7 & 0x3F);
  result = (v7 >> 6);
LABEL_15:
  a2[2] = v9;
  a2[3] = v10;
  return result;
}

uint64_t MPEG_D::USAC::ChannelPairElement::Initialize(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  *(a1 + 8) = a3;
  *(a1 + 16) = a4;
  if (a4)
  {
    v7 = *(a2 + 4) != 0;
    *(a1 + 12) = v7;
    MPEG_D::USAC::SpectralDataDecoder::Initialize(a1 + 576, 2u, a3, a4, v7);
    std::vector<float>::resize((a1 + 24), 0x400uLL);
    std::vector<float>::resize((a1 + 800), 0x400uLL);
    bzero(*(a1 + 24), 0x1000uLL);
    bzero(*(a1 + 800), 0x1000uLL);
    v8 = *(a2 + 8);
    v9 = *(a4 + 16);
    v10 = *(a1 + 1368);
    v11 = *(a1 + 1376) - v10;
    if (v9 <= v11)
    {
      if (v9 < v11)
      {
        *(a1 + 1376) = v10 + v9;
      }
    }

    else
    {
      std::vector<unsigned char>::__append((a1 + 1368), v9 - v11);
    }

    if (v8)
    {
      v13 = *(a1 + 1400);
      *(a1 + 1400) = 0;
      if (v13)
      {
        (*(*v13 + 8))(v13);
      }

      operator new();
    }

    operator new();
  }

  return 0xFFFFFFFFLL;
}

double MPEG_D::USAC::SpectralDataDecoder::Initialize(uint64_t a1, unsigned int a2, int a3, uint64_t a4, int a5)
{
  v9 = *(a1 + 8);
  v10 = *(a1 + 16);
  v11 = a2;
  v12 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v9) >> 4);
  v13 = a2 - v12;
  if (a2 <= v12)
  {
    if (a2 >= v12)
    {
      goto LABEL_19;
    }

    v17 = (v9 + 48 * a2);
    if (v10 != v17)
    {
      v18 = v10 - 6;
      v19 = v18;
      v20 = v18;
      do
      {
        v21 = *v20;
        v20 -= 6;
        (*v21)(v19);
        v18 -= 6;
        v22 = v19 == v17;
        v19 = v20;
      }

      while (!v22);
    }
  }

  else
  {
    v14 = *(a1 + 24);
    if (0xAAAAAAAAAAAAAAABLL * ((v14 - v10) >> 4) < v13)
    {
      v15 = 0x5555555555555556 * ((v14 - v9) >> 4);
      if (v15 <= a2)
      {
        v15 = a2;
      }

      if (0xAAAAAAAAAAAAAAABLL * ((v14 - v9) >> 4) >= 0x2AAAAAAAAAAAAAALL)
      {
        v16 = 0x555555555555555;
      }

      else
      {
        v16 = v15;
      }

      if (v16 <= 0x555555555555555)
      {
        operator new();
      }

      goto LABEL_45;
    }

    v17 = &v10[6 * v13];
    v23 = 48 * a2 - 48 * v12;
    v24 = *(a1 + 16);
    do
    {
      *v24 = &unk_1F0E21BB0;
      MPEG_D::USAC::ContextData::ContextData((v24 + 16), 0x202uLL);
      *(v24 + 40) = 0;
      v24 += 48;
      v10 += 6;
      v23 -= 48;
    }

    while (v23);
  }

  *(a1 + 16) = v17;
LABEL_19:
  if (a5)
  {
    v25 = v11;
  }

  else
  {
    v25 = 0;
  }

  v27 = *(a1 + 32);
  v26 = *(a1 + 40);
  v28 = (v26 - v27) >> 4;
  if (v25 <= v28)
  {
    if (v25 < v28)
    {
      v32 = (v27 + 16 * v25);
      if (v26 != v32)
      {
        v33 = v26 - 2;
        v34 = v33;
        v35 = v33;
        do
        {
          v36 = *v35;
          v35 -= 2;
          (*v36)(v34);
          v33 -= 2;
          v22 = v34 == v32;
          v34 = v35;
        }

        while (!v22);
      }

      *(a1 + 40) = v32;
    }
  }

  else
  {
    v29 = *(a1 + 48);
    if (v25 - v28 > (v29 - v26) >> 4)
    {
      v30 = (v29 - v27) >> 3;
      if (v30 <= v25)
      {
        v30 = v25;
      }

      if ((v29 - v27) >= 0x7FFFFFFFFFFFFFF0)
      {
        v31 = 0xFFFFFFFFFFFFFFFLL;
      }

      else
      {
        v31 = v30;
      }

      if (!(v31 >> 60))
      {
        operator new();
      }

LABEL_45:
      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    v37 = &v26[2 * (v25 - v28)];
    v38 = *(a1 + 40);
    v39 = 16 * v25 - 16 * v28;
    do
    {
      *v38 = &unk_1F0E21BD0;
      v38 += 2;
      v26 += 2;
      v39 -= 16;
    }

    while (v39);
    *(a1 + 40) = v37;
  }

  std::vector<std::vector<float>>::resize((a1 + 56), v11);
  v40 = 0;
  v41 = 8;
  do
  {
    if (a5)
    {
      *(*(a1 + 32) + v41) = a4;
    }

    std::vector<float>::resize((*(a1 + 56) + v40), 0x400uLL);
    v40 += 24;
    v41 += 16;
    --v11;
  }

  while (v11);
  *(a1 + 208) = a2;
  *(a1 + 212) = a3;
  *(a1 + 216) = a4;
  result = 0.0;
  *(a1 + 80) = 0u;
  *(a1 + 96) = 0u;
  *(a1 + 112) = 0u;
  *(a1 + 128) = 0u;
  *(a1 + 144) = 0u;
  *(a1 + 160) = 0u;
  *(a1 + 176) = 0u;
  *(a1 + 192) = 0u;
  return result;
}

void MPEG_D::USAC::ComplexPrediction::~ComplexPrediction(MPEG_D::USAC::ComplexPrediction *this)
{
  MPEG_D::USAC::ComplexPrediction::~ComplexPrediction(this);

  JUMPOUT(0x19EAE53E0);
}

{
  *this = &unk_1F0E21980;
  v2 = *(this + 64);
  if (v2)
  {
    *(this + 65) = v2;
    operator delete(v2);
  }

  v3 = *(this + 61);
  if (v3)
  {
    *(this + 62) = v3;
    operator delete(v3);
  }

  v4 = *(this + 58);
  if (v4)
  {
    *(this + 59) = v4;
    operator delete(v4);
  }

  v5 = *(this + 55);
  if (v5)
  {
    *(this + 56) = v5;
    operator delete(v5);
  }

  for (i = 0; i != -192; i -= 24)
  {
    v7 = *(this + i + 416);
    if (v7)
    {
      *(this + i + 424) = v7;
      operator delete(v7);
    }
  }

  for (j = 0; j != -192; j -= 24)
  {
    v9 = *(this + j + 224);
    if (v9)
    {
      *(this + j + 232) = v9;
      operator delete(v9);
    }
  }
}

uint64_t std::__split_buffer<MPEG_D::USAC::ArithDecoder>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    v4 = *(i - 48);
    *(a1 + 16) = i - 48;
    (*v4)();
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void MPEG_D::USAC::ChannelPairElement::~ChannelPairElement(MPEG_D::USAC::ChannelPairElement *this)
{
  MPEG_D::USAC::ChannelPairElement::~ChannelPairElement(this);

  JUMPOUT(0x19EAE53E0);
}

{
  *this = &unk_1F0E21A28;
  MPEG_D::USAC::JointStereoDecoder::~JointStereoDecoder((this + 1352));
  v2 = *(this + 100);
  if (v2)
  {
    *(this + 101) = v2;
    operator delete(v2);
  }

  MPEG_D::USAC::ChannelElement::~ChannelElement(this);
}

uint64_t MPEG_D::USAC::SingleChannelElement::Decode(uint64_t a1, uint64_t a2, uint64_t a3, lpd_dec::lpdDecoder **a4, int32x4_t a5, int32x4_t a6)
{
  if (*(*a2 + 44) == 3)
  {
    lpd_dec::lpdDecoder::Decode(*a4, *(*a2 + 8), *(*a2 + 36), (*a3 + 80), a5, a6);
  }

  else
  {
    ApplyTools(a2, *(a1 + 16), 0);
  }

  return 0;
}

uint64_t MPEG_D::USAC::SingleChannelElement::Deserialize(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, char a5, uint64_t *a6)
{
  bzero(*(*a3 + 48), 0x262uLL);
  *(*(*a3 + 48) + 614) = 0;
  *(*(*a3 + 48) + 615) = 0;
  *(*(*a3 + 48) + 611) = 0;
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  v13 = *a6;
  *(*a6 + 5912) = Bit;
  if (Bit)
  {
    result = lpd_dec::lpdDecoder::Read(v13, a2, *(*a3 + 36), *(*a3 + 8), *(*a4 + 112) != 0, *(*a4 + 72), *(*(a1 + 16) + 24), a5);
    *(*a3 + 44) = 3;
    if (result)
    {
      return result;
    }
  }

  else
  {
    v15 = TBitstreamReader<unsigned int>::GetBit(a2);
    v16 = *a3;
    *(*(*a3 + 48) + 608) = v15;
    result = MPEG_D::USAC::ChannelElement::ReadFDChanStream(a1, a2, 0, v16, a5, *a6);
    if (result)
    {
      return result;
    }
  }

  v17 = *a3;
  if (*(*a3 + 44) != 1)
  {
    return 0;
  }

  v18 = *a4;

  return MPEG_D::USAC::SpectralDataDecoder::Reconstruct(a1 + 576, v17 + 8, 0, v17, v18, a1 + 56);
}

uint64_t MPEG_D::USAC::SingleChannelElement::Initialize(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  *(a1 + 8) = a3;
  *(a1 + 16) = a4;
  if (!a4)
  {
    return 0xFFFFFFFFLL;
  }

  v5 = *(a2 + 4) != 0;
  *(a1 + 12) = v5;
  MPEG_D::USAC::SpectralDataDecoder::Initialize(a1 + 576, 1u, a3, a4, v5);
  std::vector<float>::resize((a1 + 24), 0x400uLL);
  bzero(*(a1 + 24), 0x1000uLL);
  return 0;
}

void MPEG_D::USAC::SingleChannelElement::~SingleChannelElement(MPEG_D::USAC::SingleChannelElement *this)
{
  MPEG_D::USAC::ChannelElement::~ChannelElement(this);

  JUMPOUT(0x19EAE53E0);
}

uint64_t MPEG_D::USAC::LFEElement::Deserialize(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5, uint64_t *a6)
{
  bzero(*(*a3 + 48), 0x262uLL);
  *(*(*a3 + 48) + 614) = 0;
  *(*(*a3 + 48) + 615) = 0;
  v11 = *a3;
  v12 = *(*a3 + 48);
  *(v12 + 611) = 0;
  v13 = *(a2 + 20);
  v14 = HIBYTE(v13);
  v15 = *(a2 + 24) - 8;
  *(a2 + 24) = v15;
  if (v15 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v18 = *(a2 + 20);
    v17 = *(a2 + 24);
    v14 |= v18 >> v17;
    *(a2 + 24) = v17 + 32;
    if (v17 == -32)
    {
      v16 = 0;
    }

    else
    {
      v16 = v18 << -v17;
    }
  }

  else
  {
    v16 = v13 << 8;
  }

  *(a2 + 20) = v16;
  *(v12 + 612) = v14;
  result = MPEG_D::USAC::ICSInfo::Deserialize(v11 + 8, a2, *(a1 + 16));
  if (!result)
  {
    if (*(v11 + 28))
    {
      return 16386;
    }

    else
    {
      *(*a3 + 72) = 0;
      MPEG_D::USAC::ScaleFactorData::Deserialize(a1 + 48, a2, *(v11 + 24), *(v11 + 32), *(v12 + 612));
      result = MPEG_D::USAC::SpectralDataDecoder::Deserialize(a1 + 576, a2, *(v11 + 28), *(v11 + 32), 0, a5);
      if (!result)
      {
        v20 = *a3;
        *(*a3 + 44) = 1;
        v21 = *a6;
        v22 = *(v11 + 28) != 2;
        v23 = *(v20 + 36);

        return lpd_dec::lpdDecoder::FacRead(v21, a2, v22, v23);
      }
    }
  }

  return result;
}

void MPEG_D::USAC::LFEElement::~LFEElement(MPEG_D::USAC::LFEElement *this)
{
  MPEG_D::USAC::ChannelElement::~ChannelElement(this);

  JUMPOUT(0x19EAE53E0);
}

uint64_t mpddrc::UniDrcParametricDrc::UpdateUniDrcDomain(uint64_t result, int a2)
{
  v3 = *(result + 16);
  v2 = *(result + 24);
  if (v2 != v3)
  {
    v5 = result;
    v6 = 0;
    v7 = 1;
    do
    {
      v8 = v3 + 568 * v6;
      if (!*(v8 + 4) && *(v8 + 40) != a2)
      {
        v9 = (*(v8 + 176) - *(v8 + 168)) >> 3;
        *(v8 + 40) = a2;
        result = mpddrc::ParametricDrcInstance::DrcTypeFeedForward::initLvlEstFilterSubBand(v8 + 32, *(v8 + 44), v9);
        if (result)
        {
          return result;
        }

        v3 = *(v5 + 16);
        v2 = *(v5 + 24);
      }

      v6 = v7;
    }

    while (0x193D4BB7E327A977 * ((v2 - v3) >> 3) > v7++);
  }

  return result;
}

uint64_t mpddrc::ParametricDrcInstance::DrcTypeFeedForward::initLvlEstFilterSubBand(uint64_t a1, unsigned int a2, unsigned int a3)
{
  v80 = *MEMORY[0x1E69E9840];
  v6 = mpddrc::NumAudioCodecSubbands(*(a1 + 8));
  *(a1 + 12) = a2;
  std::vector<unsigned long long>::resize((a1 + 136), a3);
  std::vector<unsigned long long>::resize((a1 + 160), a3);
  v7 = *(a1 + 8);
  if (v7 == 3)
  {
    v8 = &mpddrc::f_bands_nrm_QMF64;
LABEL_5:
    v9 = v6;
    std::vector<unsigned long long>::resize((a1 + 232), v6);
    std::vector<unsigned long long>::resize((a1 + 256), v6);
    std::vector<float>::resize((a1 + 184), v6);
    if (v6)
    {
      memset_pattern16(*(a1 + 184), &unk_19B3D5A30, 4 * v6);
    }

    v10 = *(a1 + 88);
    if (v10 == 2)
    {
      v11 = a2;
      v12 = 9424.77796 / v11;
      v14 = __sincosf_stret(v12);
      if (!v6)
      {
        goto LABEL_13;
      }

      v15 = v14.__sinval * 0.5 * 1.41421354;
      v16 = (v14.__cosval * 0.25893) + 2.2589;
      v17.f32[0] = (v16 + (v15 * -2.244)) * 1.2589;
      v18 = (v14.__cosval * -0.25893) + 2.2589;
      *v13.i32 = v18 + (v15 * 2.244);
      v19 = vdup_lane_s32(v13, 0);
      v20 = vdiv_f32(vmul_f32(vmla_n_f32(vdup_n_s32(0x3E8491E0u), 0xC010923C4010923CLL, v14.__cosval), 0x40000000C0212478), v19);
      v17.f32[1] = v18 + (v15 * -2.244);
      v21 = vdiv_f32(v17, v19);
      v22 = vneg_f32(v20);
      v23 = vneg_f32(v21);
      v24 = *(a1 + 184);
      __asm { FMOV            V1.2S, #1.0 }

      _D1.f32[0] = ((v16 + (v15 * 2.244)) * 1.2589) / *v13.i32;
      v72 = _D1;
      v30 = v8;
      v31 = v6;
      do
      {
        v32 = *v30++;
        v33 = v32 * 3.14159265;
        v34 = __sincosf_stret(v33);
        v35 = v32 * 6.28318531;
        v36 = __sincosf_stret(v35);
        v37 = vmla_n_f32(vmla_n_f32(v72, v20, v34.__cosval), v21, v36.__cosval);
        v38 = vmla_n_f32(vmul_n_f32(v23, v36.__sinval), v22, v34.__sinval);
        v39 = vmla_f32(vmul_f32(v38, v38), v37, v37);
        *v24 = *v24 * sqrtf(vdiv_f32(v39, vdup_lane_s32(v39, 1)).f32[0]);
        ++v24;
        --v31;
      }

      while (v31);
    }

    if ((v10 - 1) > 1)
    {
      return 0;
    }

    v11 = a2;
LABEL_13:
    v40 = 238.761042 / v11;
    v41 = v40;
    v44 = __sincosf_stret(v41);
    v45 = *(a1 + 208);
    if (v6)
    {
      v46 = 0;
      v43.f32[0] = v44.__cosval + 1.0;
      v47.f32[0] = -(v44.__cosval + 1.0);
      v48.f32[0] = v44.__cosval + 1.0;
      v48.i32[1] = LODWORD(v44.__sinval);
      v49.i32[0] = vmul_f32(v43, 0x3F0000003F000000).u32[0];
      __asm { FMOV            V6.2S, #1.0 }

      v49.i32[1] = vsub_f32(_D6, v48).i32[1];
      *v42.i32 = v44.__sinval + 1.0;
      v47.f32[1] = v44.__cosval * -2.0;
      v51 = vdup_lane_s32(v42, 0);
      v52 = vdiv_f32(v47, v51);
      v53 = vdiv_f32(v49, v51);
      v54 = vneg_f32(v52);
      v71 = __PAIR64__(1.0, v53.u32[0]);
      v73 = v53;
      v55 = vneg_f32(v53);
      v56 = 4 * v9;
      do
      {
        if (v46 || v45 != 1)
        {
          v57 = *&v8[v46 / 4];
          v58 = v57 * 3.14159265;
          v59 = __sincosf_stret(v58);
          v60 = v57 * 6.28318531;
          v61 = __sincosf_stret(v60);
          v62 = vmla_n_f32(vmla_n_f32(v71, v52, v59.__cosval), v73, v61.__cosval);
          v63 = vmla_n_f32(vmul_n_f32(v55, v61.__sinval), v54, v59.__sinval);
          v64 = vmla_f32(vmul_f32(v63, v63), v62, v62);
          *(*(a1 + 184) + v46) = *(*(a1 + 184) + v46) * sqrtf(vdiv_f32(v64, vdup_lane_s32(v64, 1)).f32[0]);
        }

        v46 += 4;
      }

      while (v56 != v46);
    }

    if (v45 == 1)
    {
      v65 = v40 * 64.0;
      v66 = __sincosf_stret(v65);
      result = 0;
      *v68.i32 = v66.__sinval + 1.0;
      v69.f32[0] = (v66.__cosval + 1.0) * 0.5;
      v69.f32[1] = -(v66.__cosval + 1.0);
      v69.f32[2] = v69.f32[0];
      v69.f32[3] = v66.__cosval * -2.0;
      *(a1 + 212) = vdivq_f32(v69, vdupq_lane_s32(v68, 0));
      *(a1 + 228) = (1.0 - v66.__sinval) / (v66.__sinval + 1.0);
      return result;
    }

    return 0;
  }

  if (v7 == 4)
  {
    v8 = &mpddrc::f_bands_nrm_QMF71;
    goto LABEL_5;
  }

  if (!gDRCScope)
  {
    v70 = MEMORY[0x1E69E9C10];
LABEL_26:
    if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      v75 = "MPDDRCParametricDRC.cpp";
      v76 = 1024;
      v77 = 433;
      v78 = 1024;
      v79 = v7;
      _os_log_impl(&dword_19AA99000, v70, OS_LOG_TYPE_ERROR, "%25s:%-5d ERROR: Center frequencies missing for uniDrcDomain = %d.\n", buf, 0x18u);
    }

    return 0xFFFFFFFFLL;
  }

  v70 = *gDRCScope;
  if (*gDRCScope)
  {
    goto LABEL_26;
  }

  return 0xFFFFFFFFLL;
}

void ArithDecWrapper::~ArithDecWrapper(ArithDecWrapper *this)
{
  *this = &unk_1F0E21BB0;
  v2 = *(this + 2);
  if (v2)
  {
    *(this + 3) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x19EAE53E0);
}

{
  *this = &unk_1F0E21BB0;
  v2 = *(this + 2);
  if (v2)
  {
    *(this + 3) = v2;
    operator delete(v2);
  }
}

double _ZNSt3__116allocator_traitsINS_9allocatorIN7lpd_dec10lpdDecoderEEEE9constructB8ne200100IS3_JEvLi0EEEvRS4_PT_DpOT0_(uint64_t a1)
{
  v2 = a1 + 4096;
  bzero(a1, 0x1740uLL);
  *(a1 + 1392) = 0xFF000000FFLL;
  bzero((a1 + 1404), 0xA36uLL);
  *(a1 + 4020) = 64;
  v3 = (a1 + 4026);
  v4 = 64;
  do
  {
    *(v3 - 1) = 64;
    *v3 = 0;
    *(v3 + 6) = 0;
    v3 += 2;
    v4 -= 16;
  }

  while (v4);
  *(a1 + 4088) = 0x609060900000000;
  *(a1 + 4096) = 0u;
  *(a1 + 4112) = 0u;
  *(a1 + 4128) = 0;
  *(a1 + 4144) = &unk_1F0E21E48;
  *(a1 + 4280) = 0;
  *(a1 + 4152) = 0u;
  *(a1 + 4168) = 0u;
  *(a1 + 4184) = 0u;
  *(a1 + 4200) = 0u;
  *(a1 + 4216) = 0u;
  *(a1 + 4232) = 0u;
  *(a1 + 4248) = 0u;
  *(a1 + 4264) = 0u;
  *(a1 + 4284) = 256;
  *(v2 + 190) = 0;
  *(a1 + 4288) = 0u;
  *(a1 + 4304) = 0u;
  *(a1 + 4320) = 0u;
  *(a1 + 4336) = 0u;
  *(a1 + 4352) = 0u;
  *(a1 + 4368) = 0u;
  *(a1 + 4384) = 0u;
  *(a1 + 4400) = 0u;
  *(a1 + 4416) = vDSP_DFT_zop_CreateSetup(0, 0x80uLL, vDSP_DFT_FORWARD);
  *(a1 + 4424) = vDSP_DFT_zop_CreateSetup(0, 0x60uLL, vDSP_DFT_FORWARD);
  *(a1 + 4432) = 0;
  *(a1 + 4448) = 0;
  *(a1 + 4440) = 0;
  *(v2 + 1240) = 0;
  *(a1 + 5344) = 0;
  *(a1 + 5360) = 0;
  *(a1 + 5352) = 0;
  bzero((a1 + 4464), 0x364uLL);
  *(a1 + 5340) = 64;
  *(a1 + 5368) = 0u;
  *(a1 + 5384) = 0u;
  *(a1 + 5400) = 0u;
  *(a1 + 5416) = 0u;
  *(a1 + 5432) = 0u;
  *(a1 + 5448) = 0u;
  *(a1 + 5464) = 0u;
  *(a1 + 5480) = 0u;
  *(a1 + 5496) = 0u;
  *(a1 + 5512) = 0u;
  *(a1 + 5528) = 0u;
  *(a1 + 5544) = 0u;
  *(a1 + 5560) = 0u;
  *(a1 + 5576) = 0u;
  *(a1 + 5592) = 0u;
  *(a1 + 5608) = 0u;
  *(a1 + 5624) = 0u;
  *(a1 + 5640) = 0u;
  *(a1 + 5656) = 0u;
  *(a1 + 5672) = 0u;
  *(a1 + 5688) = 0u;
  *(a1 + 5704) = 0u;
  *(a1 + 5720) = 0u;
  *(a1 + 5736) = 0u;
  *(a1 + 5752) = 0u;
  *(a1 + 5768) = 0u;
  *(a1 + 5784) = 0;
  *(a1 + 5700) = 64;
  *(a1 + 5916) = 0;
  *(a1 + 5792) = 0u;
  *(a1 + 5808) = 0u;
  *(a1 + 5824) = 0u;
  *(a1 + 5840) = 0u;
  *(a1 + 5856) = 0u;
  *(a1 + 5872) = 0u;
  *(a1 + 5888) = 0u;
  *(a1 + 5897) = 0u;
  *&result = 0xFF000000FFLL;
  *(a1 + 5920) = 0xFF000000FFLL;
  *(a1 + 5928) = 0;
  *(a1 + 5936) = 0;
  return result;
}

uint64_t std::__split_buffer<lpd_dec::lpdDecoder>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 5952;
    tcx_dec::tcxDecoder::~tcxDecoder((i - 1808));
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

_DWORD *CDK_Feed(_DWORD *result, uint64_t a2, int a3, unsigned int *a4)
{
  v5 = *a4;
  if ((result[9] - *result) >> 3 >= *a4)
  {
    v6 = *a4;
  }

  else
  {
    v6 = (result[9] - *result) >> 3;
  }

  if (v6)
  {
    v7 = result;
    v8 = 0;
    v9 = (a2 + a3 - v5);
    v10 = result[8];
    v11 = result[1];
    do
    {
      v12 = v10 - v11;
      if (v12 >= v6)
      {
        v13 = v6;
      }

      else
      {
        v13 = v12;
      }

      result = CDKmemcpy((*(v7 + 3) + v11), v9, v13);
      v8 += v13;
      v9 += v13;
      v10 = v7[8];
      v11 = (v10 - 1) & (v7[1] + v13);
      *v7 += 8 * v13;
      v7[1] = v11;
      v6 -= v13;
    }

    while (v6);
    v5 = *a4;
  }

  else
  {
    v8 = 0;
  }

  *a4 = v5 - v8;
  return result;
}

uint64_t aacDecoder_DecodeFrame(uint64_t a1)
{
  v1 = MEMORY[0x1EEE9AC00](a1);
  v412 = v3;
  v445 = *MEMORY[0x1E69E9840];
  if (!v1)
  {
    return 8193;
  }

  v4 = v2;
  v5 = v1;
  *(v1 + 296) = 0;
  v6 = *(v1 + 24);
  if (v6[38])
  {
    v7 = v6[27];
    if (v7)
    {
      CDK_put((v6 + 28), v6[26], v7);
    }
  }

  else
  {
    v9 = v6[27];
    v10 = v6[32];
    v11 = v6[31] - v9;
    v6[28] += v9;
    v12 = (v6[37] - 1) & (v10 - v9);
    v6[31] = v11;
    v6[32] = v12;
  }

  v407 = (v5 + 288);
  v401 = v6;
  v14 = v6[28];
  v13 = (v6 + 28);
  v400 = v14;
  *(v13 - 8) = 0;
  v396 = v13;
  v15 = *(v5 + 2024);
  v424 = v5;
  if ((v15 & 0xFE) == 2 || *(v5 + 2026) == 5)
  {
    v16 = *(v5 + 368);
    v17 = 0;
    v18 = __OFSUB__(v16, 1);
    v19 = v16 - 1;
    if (v19 < 0 == v18)
    {
      *(v5 + 368) = v19;
    }

    v20 = 1;
    goto LABEL_12;
  }

  v20 = 1;
  if (*(v5 + 12) >= 1)
  {
    v306 = 0;
    v423 = 0;
    v307 = 0;
    v425 = v5 + 2072;
    v308 = v5;
    v309 = 104;
    v310 = 2884;
    while (1)
    {
      v311 = *(v308 + 24);
      if (!v311)
      {
        LODWORD(v21) = 0;
        LODWORD(v416) = 0;
        v22 = 0;
        v8 = 5;
        goto LABEL_732;
      }

      v312 = v311 + v309;
      if (*(v311 + v309 + 48))
      {
        v313 = *(v312 + 1);
        if (v313)
        {
          v314 = v310;
          CDK_put(v311 + v309 + 8, *(v311 + v309), v313);
          v310 = v314;
        }
      }

      else
      {
        v315 = *(v312 + 1);
        v316 = *(v312 + 6);
        v317 = *(v312 + 5) - v315;
        *(v312 + 2) += v315;
        v318 = (*(v312 + 11) - 1) & (v316 - v315);
        *(v312 + 5) = v317;
        *(v312 + 6) = v318;
      }

      v319 = 0;
      v320 = v311 + v309;
      *(v311 + v309) = 0;
      v322 = (v311 + v309 + 8);
      v321 = *v322;
      if (*v322 <= 0)
      {
        v311[722] = 0;
        v319 = 257;
      }

      v323 = *v311;
      if (*v311 <= 5)
      {
        break;
      }

      if ((v323 - 6) >= 2)
      {
        if (v323 != 10)
        {
LABEL_731:
          LODWORD(v21) = 0;
          LODWORD(v416) = 0;
          v381 = &v311[v306];
          v22 = 0;
          v381[720] = 0;
          v8 = 8195;
          goto LABEL_732;
        }

        goto LABEL_609;
      }

      if (v321 < 1)
      {
        goto LABEL_617;
      }

      v430.i64[0] = v309;
      v324 = v306;
      v325 = v322;
      v326 = v320;
      v444[0] = v311[729] & 0x20;
      v327 = v310;
      Header = transportDec_readHeader(v311, v312, 1, (v311 + v310), 0, 0, v444, 0, v425);
      v319 = Header;
      if (v444[0])
      {
        v311[729] |= 0x20u;
      }

      v310 = v327;
      v320 = v326;
      v322 = v325;
      v306 = v324;
      v309 = v430.i64[0];
      if (!Header)
      {
LABEL_635:
        v343 = *(v320 + 4);
        if (*(v312 + 12))
        {
          if (v343)
          {
            v344 = v310;
            CDK_put(v322, *v312, v343);
            v310 = v344;
          }
        }

        else
        {
          v345 = v311 + v309;
          v346 = *(v311 + v309 + 24);
          v347 = *(v311 + v309 + 20) - v343;
          *v322 += v343;
          v348 = (*(v311 + v309 + 44) - 1) & (v346 - v343);
          *(v345 + 5) = v347;
          *(v345 + 6) = v348;
        }

        *v312 = 0;
        v311[v306 + 720] = *v322;
        goto LABEL_640;
      }

LABEL_618:
      v311[v306 + 720] = 0;
      v8 = 5;
      if (v319 <= 514)
      {
        if (v319 != 258)
        {
          LODWORD(v21) = 0;
          LODWORD(v416) = 0;
          v22 = 0;
          v5 = v424;
          if (v319 != 257)
          {
            goto LABEL_688;
          }

          LODWORD(v21) = 0;
          LODWORD(v416) = 0;
          goto LABEL_723;
        }

        *(v424 + 368) = *(*(v424 + 24) + 2904);
        v423 = 1;
      }

      else
      {
        if (v319 != 1027)
        {
          if (v319 != 515)
          {
            LODWORD(v21) = 0;
            LODWORD(v416) = 0;
            v22 = 0;
            v5 = v424;
            if (v319 == 1026)
            {
              LODWORD(v21) = 0;
              LODWORD(v416) = 0;
              v22 = 0;
              v8 = 8195;
            }

            goto LABEL_688;
          }

          LODWORD(v21) = 0;
          LODWORD(v416) = 0;
          v22 = 0;
          v8 = 8203;
LABEL_732:
          v5 = v424;
          goto LABEL_688;
        }

        v307 = 1;
      }

LABEL_640:
      ++v306;
      v308 = v424;
      v309 += 56;
      v310 += 4;
      if (v306 >= *(v424 + 12))
      {
        v15 = *(v424 + 2024);
        v17 = v307;
        v20 = v423 == 0;
        v5 = v424;
        goto LABEL_12;
      }
    }

    if (!v323)
    {
      if (!*(v312 + 12))
      {
        *(v311 + v309 + 24) &= *(v311 + v309 + 44) - 1;
      }

      *v312 = 0;
      *(v311 + v310) = v321;
      v311[729] |= 1u;
LABEL_617:
      if (!v319)
      {
        goto LABEL_635;
      }

      goto LABEL_618;
    }

    if (v323 != 2)
    {
      goto LABEL_731;
    }

LABEL_609:
    v426 = v310;
    v427 = v306;
    v429.i64[0] = v311 + v309;
    v419 = v307;
    if (!*(v312 + 12))
    {
      *v322 = v321;
      *(v311 + v309 + 24) &= *(v311 + v309 + 44) - 1;
    }

    v430.i64[0] = v309;
    v444[0] = -1431655766;
    *v312 = 0;
    v428.i64[0] = v311 + v309 + 8;
    v329 = *v322;
    v319 = synchronization(v311, v444, v425);
    v320 = v429.i64[0];
    v330 = *(v429.i64[0] + 4);
    if (*(v312 + 12))
    {
      v306 = v427;
      v322 = v428.i64[0];
      v309 = v430.i64[0];
      if (v330)
      {
        CDK_put(v428.i64[0], *v312, v330);
      }
    }

    else
    {
      v309 = v430.i64[0];
      v331 = (v311 + v430.i64[0]);
      v332 = *(v311 + v430.i64[0] + 24);
      v333 = *(v311 + v430.i64[0] + 20) - v330;
      v306 = v427;
      v322 = v428.i64[0];
      *v428.i64[0] += v330;
      v334 = (v331[11] - 1) & (v332 - v330);
      v331[5] = v333;
      v331[6] = v334;
    }

    *v312 = 0;
    v335 = *v322;
    v336 = v329 - *v322;
    if (v336 < 0)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "TRANSPORTDEC_ERROR transportDec_readStream(HANDLE_TRANSPORTDEC, const UINT, MPEG_D::USAC::DynRangeCompressor &)";
      exception[2] = 1090;
    }

    v307 = v419;
    if (v319 != 258 && (v311[729] & 0x10) == 0 || (v337 = v311[723]) == 0 || (v338 = v311[248]) == 0 || (v339 = v311[247]) == 0)
    {
      v342 = -1;
      goto LABEL_634;
    }

    if (v319)
    {
      v340 = v311[729];
      if ((v340 & 0x10) != 0)
      {
        v341 = 0;
      }

      else
      {
        v311[729] = v340 | 0x10;
        v341 = -v311[724];
      }
    }

    else
    {
      v341 = 0;
      if (*v311 <= 0xA && ((1 << *v311) & 0x4C0) != 0)
      {
        v349 = v311[43];
        if (v349 == 255)
        {
          v341 = 0;
        }

        else
        {
          v341 = v349 & ~(v349 >> 31);
        }
      }

      v311[729] &= ~0x10u;
      v336 += v311[721];
    }

    v350 = v311[725] + (v341 + v336) * v339;
    v351 = v338 * v337;
    if (v350 < 1)
    {
      v311[725] = v350;
      v342 = -1;
      if (v319)
      {
        goto LABEL_634;
      }
    }

    else
    {
      v342 = v350 / v351;
      v350 %= v351;
      v311[725] = v350;
      if (v319)
      {
        if (v342 < 1)
        {
LABEL_634:
          v311[726] = v342;
          v310 = v426;
          if (!v319)
          {
            goto LABEL_635;
          }

          goto LABEL_618;
        }

LABEL_668:
        v319 = 258;
        goto LABEL_634;
      }
    }

    v342 -= v351 - v350 >= v350;
    if (v342 < 0)
    {
      transportDec_EndAccessUnit(v311);
      v319 = synchronization(v311, v444, v425);
      v311[725] = 0;
      v342 = -1;
      v307 = v419;
      v320 = v429.i64[0];
      v306 = v427;
      v322 = v428.i64[0];
      v309 = v430.i64[0];
      goto LABEL_634;
    }

    v311[725] = 0;
    if (!v342)
    {
      v319 = 0;
      goto LABEL_634;
    }

    v352 = v444[0];
    v353 = *(v312 + 12);
    if (v444[0] > 0x1Fu)
    {
      if (!v353)
      {
        v358 = *(v311 + v309 + 20);
        v360 = *(v311 + v309 + 44);
        v359 = (v360 - 1) & *(v311 + v309 + 24);
        *(v311 + v309 + 24) = v359;
        goto LABEL_664;
      }
    }

    else if (!v353)
    {
      v354 = v311 + v309;
      v355 = *(v311 + v309 + 24);
      v356 = *(v311 + v309 + 20) - v444[0];
      *v322 = v335 + v444[0];
      v357 = (*(v311 + v309 + 44) - 1) & (v355 - v352);
      *(v354 + 5) = v356;
      *(v354 + 6) = v357;
      *v354 = 0;
      goto LABEL_668;
    }

    v358 = *(v311 + v309 + 20);
    v359 = *(v311 + v309 + 24);
    v360 = *(v311 + v309 + 44);
LABEL_664:
    v361 = v311 + v309;
    *(v311 + v309) = 0;
    v362 = v358 - v352;
    if (v353)
    {
      v363 = -v352;
    }

    else
    {
      v363 = v352;
    }

    *v322 = v335 + v363;
    *(v361 + 5) = v362;
    *(v361 + 6) = (v360 - 1) & (v359 - v352);
    goto LABEL_668;
  }

  v17 = 0;
LABEL_12:
  v21 = 0;
  LODWORD(v416) = 0;
  v22 = 0;
  *(v5 + 64) = 1;
  v419 = v17;
  v442 = 0xAAAAAAAAAAAAAAAALL;
  if (v17)
  {
    v23 = 0;
  }

  else
  {
    v23 = v20;
  }

  v402 = v23;
  v408 = v5 + 2032;
  v409 = (v5 + 1912);
  v443 = -1431655766;
  v414 = v17 != 0;
  v24 = (v5 + 300);
  v440 = 0xAAAAAAAAAAAAAAAALL;
  v410 = v5 + 264;
  v406 = (v5 + 842);
  v441 = -1431655766;
  v413 = (v5 + 2072);
  v397 = (v5 + 256);
  v392 = (v5 + 1632);
  v404 = (v5 + 2144);
  *(v5 + 2032) = 0u;
  v427 = (v5 + 1992);
  v390 = "TRANSPORTDEC_ERROR transportDec_InBandConfig(HANDLE_TRANSPORTDEC, UCHAR *, const UINT, const UCHAR, UCHAR *, UINT, UCHAR *, MPEG_D::USAC::DynRangeCompressor &)";
  v398 = xmmword_19B0A5840;
  v403 = xmmword_19B0A5850;
  v428 = vdupq_n_s64(4uLL);
  v429 = vdupq_n_s64(0x27uLL);
  v393 = xmmword_19B0B34A0;
  v430 = vdupq_n_s64(2uLL);
  v389 = "int mpegSurroundDecoder_Apply(CMpegSurroundDecoder *, FLOAT *, FLOAT *, const int, int, int *, int *, int, AUDIO_OBJECT_TYPE, AUDIO_CHANNEL_TYPE *, UCHAR *, const CDK_channelMapDescr *const, UsacQmf &, MPEG_D::USAC::DynRangeCompressor &)";
  v417 = 1;
  v411 = 1;
  v418 = v20;
  v422 = (v5 + 300);
  while (1)
  {
    v423 = v22;
    if (v22 || v15 == 1)
    {
      goto LABEL_209;
    }

    if (!*(v5 + 2028))
    {
      break;
    }

    if (v402)
    {
      goto LABEL_26;
    }

LABEL_209:
    v117 = *(v5 + 24);
    if (v117[38])
    {
      v118 = v117[27];
      if (v118)
      {
        CDK_put((v117 + 28), v117[26], v118);
      }
    }

    else
    {
      v119 = v117[27];
      v120 = v117[32];
      v121 = v117[31] - v119;
      v117[28] += v119;
      v122 = (v117[37] - 1) & (v120 - v119);
      v117[31] = v121;
      v117[32] = v122;
    }

    v123 = v117[28];
    *(v117 + 13) = 0;
    *(v5 + 2048) = v22;
    if (v22 < v21)
    {
      v124 = v117[38];
      if (v124)
      {
        v125 = v117[32];
        v126 = v117[37];
      }

      else
      {
        v117[28] = v123;
        v126 = v117[37];
        v125 = (v126 - 1) & v117[32];
        v117[32] = v125;
      }

      v127 = *(&v442 + v22);
      v128 = v117[31];
      *(v117 + 13) = 0;
      v129 = v128 + v127;
      if (v124)
      {
        v130 = v127;
      }

      else
      {
        v130 = -v127;
      }

      v117[28] = v123 + v130;
      v117[31] = v129;
      v117[32] = (v126 - 1) & (v125 + v127);
    }

    if (!v20)
    {
      aacDecoder_SignalInterruption(v5);
      LODWORD(v416) = 0;
      v22 = 0;
      v8 = 4097;
      goto LABEL_688;
    }

    v415 = (v117 + 28);
    LODWORD(v420) = v123;
    v426 = v21;
    *(v5 + 356) = 0;
    v131 = *(v5 + 456);
    LODWORD(v425) = CAacDecoder_DecodeFrame(v5);
    v132 = *(v5 + 68);
    v8 = v425;
    if ((v132 & 0x100) != 0 && *(v5 + 2024) == 3 && v425)
    {
      v417 = 0;
      LOBYTE(v20) = v418;
      v22 = v423;
      v21 = v426;
      v24 = v422;
      goto LABEL_551;
    }

    LODWORD(v21) = v426;
    if (v419 || *(v5 + 2024) || (v425 ? (v133 = (v425 & 0xFFFFF000) == 0x4000) : (v133 = 1), !v133 ? (v134 = 0) : (v134 = 1), v134 == 1 ? (v135 = v423 >= v426) : (v135 = 1), !v135))
    {
      v421 = 1;
      if (v425 && (v425 & 0xFFFFF000) != 0x4000)
      {
        goto LABEL_687;
      }
    }

    else if (transportDec_EndAccessUnit(*(v5 + 24)))
    {
      *(v5 + 64) = 0;
      v421 = v416;
      if ((v134 & 1) == 0)
      {
        goto LABEL_687;
      }
    }

    else
    {
      v421 = v416;
      if (!v134)
      {
        goto LABEL_687;
      }
    }

    *(v5 + 288) = *(v5 + 320);
    v136 = *(v5 + 340);
    *(v5 + 292) = v136;
    *(v5 + 300) = *(v5 + 344);
    v137 = *(v5 + 2064);
    if (*(v5 + 2064))
    {
      memset(v444, 255, 0x1000uLL);
      if (v136 > 0x400)
      {
        v382 = 59;
      }

      else if (*(v5 + 2066))
      {
        if (v131)
        {
          v138 = v131 + 4 * v136;
          if (v136 >= v137)
          {
            CDKmemcpy(v444, (v138 + 4 * (v136 - v137)), 4 * v137);
            v142 = v424;
            memmove((v138 + 4 * *(v424 + 2064)), (v131 + 4 * v136), 4 * (v136 - *(v424 + 2064)));
            CDKmemcpy((v131 + 4 * v136), *(v142 + 2056), 4 * *(v142 + 2064));
            v141 = *(v142 + 2056);
            v139 = 4 * *(v142 + 2064);
          }

          else
          {
            v139 = (4 * v136);
            CDKmemcpy(v444, (v131 + 4 * v136), v139);
            v140 = v424;
            CDKmemcpy((v131 + 4 * v136), *(v424 + 2056), v139);
            CDKmemcpy(*(v140 + 2056), (*(v140 + 2056) + 4 * v136), 4 * (*(v140 + 2064) - v136));
            v141 = (*(v140 + 2056) + 4 * (*(v140 + 2064) - v136));
          }

          CDKmemcpy(v141, v444, v139);
          v5 = v424;
          goto LABEL_252;
        }

        v382 = 61;
      }

      else
      {
        v382 = 60;
      }

      v390 = "void CDK_Delay_Apply(CDK_SignalDelay *, FLOAT *, const UINT, const UCHAR)";
LABEL_750:
      v383 = __cxa_allocate_exception(0x10uLL);
      *v383 = v390;
      v383[2] = v382;
    }

LABEL_252:
    v143 = *(v5 + 68);
    if ((v143 & 0x4310) == 0)
    {
      LOBYTE(v144) = *(v5 + 1920);
      if (v144)
      {
        v145 = *(v5 + 328);
        v146 = *(v5 + 300);
        memset(v444, 170, 0xAF8uLL);
        v154 = 0;
        v155 = v403;
        v156 = v398;
        do
        {
          if (vuzp1_s16(vmovn_s64(vcgtq_u64(v429, v155)), *v155.i8).u8[0])
          {
            v444[v154 + 6] = 0;
          }

          if (vuzp1_s16(vmovn_s64(vcgtq_u64(vdupq_n_s64(0x27uLL), *&v155)), *&v155).i8[2])
          {
            v444[v154 + 24] = 0;
          }

          if (vuzp1_s16(*&v155, vmovn_s64(vcgtq_u64(vdupq_n_s64(0x27uLL), *&v156))).i32[1])
          {
            v444[v154 + 42] = 0;
            v444[v154 + 60] = 0;
          }

          v156 = vaddq_s64(v156, v428);
          v155 = vaddq_s64(v155, v428);
          v154 += 72;
        }

        while (v154 != 720);
        mpegSurroundDecoder_GetLibInfo(v444, v147, v148, v149, v150, v151, v152, v153);
        v157 = 0;
        while (v444[v157 + 6] != 9)
        {
          v157 += 18;
          if (v157 == 702)
          {
            v158 = 0;
            v159 = ((v145 - 23) & 0xFFFFFFEF) != 0;
LABEL_273:
            if (v145 == 42 || v145 == 150 || v145 == 50)
            {
              v159 = 0;
            }

            goto LABEL_277;
          }
        }

        v158 = v444[v157 + 8];
        v159 = ((v145 - 23) & 0xFFFFFFEF) != 0;
        if ((v158 & 2) != 0)
        {
          v160 = v145 == 23 || v145 == 39;
          v159 = (v143 >> 18) & 1;
          if (!v160)
          {
            v159 = 1;
          }
        }

        if ((v158 & 4) == 0)
        {
          goto LABEL_273;
        }

LABEL_277:
        if ((v158 & 1) == 0 && (v145 > 0x32 || ((1 << v145) & 0x4048000800000) == 0) && v145 != 150)
        {
          v159 = 0;
        }

        if ((v146 - 5) < 2)
        {
          v144 = v159 & (v158 >> 14);
        }

        else if (v146 == 2)
        {
          v144 = v159 & (v158 >> 13);
        }

        else if (v146 == 1)
        {
          v144 = v159 & (v158 >> 12);
        }

        else
        {
          LOBYTE(v144) = 0;
        }
      }

      *(v5 + 1921) = v144;
    }

    if (!*(v5 + 864) && *(v5 + 1921) && !*(*v409 + 168) && mpegSurroundDecoder_Open(v409, v5 + 864))
    {
      return 2;
    }

    CAacDecoder_SyncQmfMode(v5);
    isValid = CDK_QmfDomain_Configure(v5 + 864);
    if (isValid)
    {
      LODWORD(v21) = v426;
      if (isValid == 1)
      {
        v8 = 2;
      }

      else
      {
        v8 = 5;
      }

      LODWORD(v416) = v421;
      v5 = v424;
      goto LABEL_687;
    }

    v5 = v424;
    v21 = v426;
    v8 = v425;
    if (v425 || *(*(v424 + 408) + 152) >= 3)
    {
      *(v424 + 64) = 0;
    }

    v24 = v422;
    if (!*(v5 + 840))
    {
      if (!*(v5 + 1921))
      {
        goto LABEL_448;
      }

      v165 = *(v5 + 300);
      v166 = *(v5 + 292);
      goto LABEL_350;
    }

    if ((*(v5 + 71) & 8) == 0)
    {
      v162 = *(v5 + 300);
      v163 = *(v5 + 832);
      if (*(v5 + 844))
      {
LABEL_300:
        if (*(v5 + 2024) && v163)
        {
          *(v163 + 536) |= 0x4000u;
        }

        if (v163)
        {
          if (*(v5 + 1921))
          {
            v164 = *(v163 + 536) & 0xFF9FFFFF | 0x400000;
          }

          else
          {
            v164 = *(v163 + 536) & 0xFF9FFFFF;
          }

          *(v163 + 536) = v164;
        }
      }

      else if (v163)
      {
        *(v163 + 532) = 0;
        goto LABEL_300;
      }

      isValid = sbrDecoder_Apply(v163, v131, v4, v412, v24, v407, v410, *(v5 + 280), *(v5 + 64), v406, v413);
      if (isValid)
      {
        if (isValid == 8)
        {
          goto LABEL_680;
        }

        goto LABEL_347;
      }

      v167 = *(v5 + 68);
      *(v5 + 68) = v167 | 0x8000;
      v168 = *(v5 + 320);
      v169 = *(v5 + 288);
      if (v168 == v169)
      {
        *(v5 + 292) = *(v5 + 340);
      }

      else
      {
        if (v169 == v168 >> 2)
        {
          *(v5 + 292) = *(v5 + 340) >> 2;
          v170 = *(v5 + 356) >> 2;
        }

        else if (v169 == v168 >> 1)
        {
          *(v5 + 292) = *(v5 + 340) >> 1;
          v170 = *(v5 + 356) >> 1;
        }

        else if (v169 == 2 * v168)
        {
          *(v5 + 292) = 2 * *(v5 + 340);
          v170 = 2 * *(v5 + 356);
        }

        else
        {
          if (v169 != 4 * v168)
          {
            if (*(v5 + 292) != 768)
            {
              v8 = 8202;
              goto LABEL_686;
            }

            v305 = 11453246128 * *(v5 + 340);
            *(v5 + 292) = HIDWORD(v305) + (v305 >> 63);
            *(v5 + 356) = 8 * *(v5 + 356) / 3u;
            goto LABEL_330;
          }

          *(v5 + 292) = 4 * *(v5 + 340);
          v170 = 4 * *(v5 + 356);
        }

        *(v5 + 356) = v170;
      }

LABEL_330:
      v171 = *(v5 + 832);
      if (v171 && v171[128] >= 1 && v171[127] >= 1)
      {
        v172 = 0;
        v173 = v171[126];
        if (v173 != 42 && v173 != 50 && v173 != 150)
        {
          v174 = v171[134];
          if ((v174 & 0x2000) != 0)
          {
            v175 = 481;
          }

          else
          {
            v175 = 962;
          }

          if ((v174 & 0x400000) != 0)
          {
            v172 = v175 - 257;
          }

          else
          {
            v172 = v175;
          }
        }
      }

      else
      {
        v172 = 0;
      }

      *(v5 + 356) += v172;
      if (*(v5 + 842))
      {
        *(v5 + 68) = v167 | 0x28000;
      }

      v176 = v397;
      if (v162 < *v24)
      {
        do
        {
          *&v176[4 * v162 - 8] = 1;
          v176[v162] = v162;
          ++v162;
        }

        while (v162 < *v24);
      }
    }

LABEL_347:
    v177 = *(v5 + 840);
    if (!*(v5 + 1921))
    {
      v8 = v425;
      goto LABEL_436;
    }

    v165 = *(v5 + 300);
    v166 = *(v5 + 292);
    if (*(v5 + 840))
    {
      v178 = *(v5 + 832) == 0;
      goto LABEL_351;
    }

LABEL_350:
    v178 = 1;
LABEL_351:
    v179 = *(v5 + 328);
    if (v179 == 42 && (*(v5 + 71) & 8) != 0)
    {
      v178 = 1;
    }

    v180 = *v409;
    if (!*v409)
    {
      goto LABEL_420;
    }

    if (*(v180 + 334) != v178)
    {
      *(v180 + 334) = v178;
      v181 = v180 + 4 * *(v180 + 3453);
      *(v181 + 3480) |= 0x40u;
    }

    LODWORD(v416) = v165;
    v399 = *(v5 + 340);
    v182 = *(v5 + 288);
    v444[0] = 0;
    v183 = *(v180 + 168);
    if (!v183)
    {
      v384 = 913;
      goto LABEL_757;
    }

    isValid = CDK_chMapDescr_isValid(v410);
    if (!isValid || (v416 - 3) < 0xFFFFFFFE)
    {
      goto LABEL_420;
    }

    v192 = *(v180 + 3453);
    v388 = v180 + 8;
    *(v183 + 376) = v180 + 8 + 156 * v192;
    v193 = *(v180 + 3452);
    v395 = v180 + 336;
    v394 = *(v180 + 336 + 3080 * v193 + 1);
    v194 = *(v180 + 3457);
    v195 = v180 + 3480;
    v196 = *(v180 + 3480 + 4 * v192);
    v405 = v166;
    if (!v194)
    {
      if (v196)
      {
        inited = initMpegSurroundDecoder(v180);
        v192 = *(v180 + 3453);
        if (inited)
        {
          *(v180 + 4 * v192 + 3488) = 1;
          v198 = 2;
          v444[0] = 2;
          goto LABEL_372;
        }
      }

      if (*(v180 + 3488 + 4 * v192) == 2)
      {
        v198 = 0;
LABEL_372:
        v195 = v180 + 3480;
      }

      else
      {
        v195 = v180 + 3480;
        v198 = 0;
        if (*(v395 + 3080 * v192) == 1)
        {
          *(v180 + 3488 + 4 * v192) = 2;
        }
      }

      if (*(v180 + 4 * v192 + 3488) == 2)
      {
        goto LABEL_375;
      }

      goto LABEL_374;
    }

    *(v195 + 4 * v192) = v196 | 0x100;
    if (*(v180 + 333) && *(v180 + 3488 + 4 * v192) >= 1)
    {
      *(v180 + 3488 + 4 * v192) = 1;
    }

    else
    {
      *(v180 + 4 * v192 + 3488) = 0;
    }

    *(v180 + 3484) = 1;
LABEL_374:
    v198 = 2;
    v444[0] = 2;
LABEL_375:
    if (*(v180 + 3458))
    {
      v198 |= 1u;
      v444[0] = v198;
    }

    v391 = v195;
    v199 = *(v195 + 4 * v192);
    if (v199)
    {
      if (v199)
      {
        v200 = v405 + 63;
        if (v405 >= 0)
        {
          v200 = v405;
        }

        if (v179 == -1)
        {
          v384 = 239;
          goto LABEL_756;
        }

        if (v405 < 64)
        {
          v384 = 240;
LABEL_756:
          v389 = "int SpatialDecDefaultSpecificConfig(SPATIAL_SPECIFIC_CONFIG *, AUDIO_OBJECT_TYPE, int, int, int, int, int)";
LABEL_757:
          v386 = __cxa_allocate_exception(0x10uLL);
          *v386 = v389;
          v386[2] = v384;
        }

        if (v182 < 1)
        {
          v384 = 241;
          goto LABEL_756;
        }

        *(v180 + 300) = v179;
        *(v180 + 180) = v182;
        *(v180 + 184) = v200 >> 6;
        *(v180 + 188) = 0x70000001CLL;
        *(v180 + 196) = 0;
        *(v180 + 212) = 0;
        *(v180 + 204) = 0;
        v201 = (v388 + 156 * v192);
        *(v180 + 220) = v393;
        if (memcmp((v180 + 176), v201, 0x9CuLL))
        {
          *(v391 + 4 * v192) = v199 | 0x80;
          SpatialDecInitParserContext(*(v180 + 168));
        }

        isValid = initMpegSurroundDecoder(v180);
        v5 = v424;
        *(v180 + 4 * *(v180 + 3453) + 3488) = 0;
      }

      else
      {
        isValid = initMpegSurroundDecoder(v180);
        v5 = v424;
      }

      v198 |= 2u;
      v444[0] = v198;
      if (isValid)
      {
        goto LABEL_392;
      }
    }

    else
    {
      v5 = v424;
    }

    v202 = *(v180 + 168);
    if (*(v202 + 100) * v399 * *(*v180 + 66) / *(*v180 + 64) > v412)
    {
      isValid = 4294966304;
LABEL_392:
      v8 = v425;
      goto LABEL_416;
    }

    if (*(v180 + 334))
    {
      v203 = 1002;
    }

    else
    {
      v203 = 1001;
    }

    isValid = SpatialDecApplyFrame(v202, v395 + 3080 * *(v180 + 3453), v203, v131, v4, v405, v444, v416, v184, v185, v186, v187, v188, v189, v190, v191, v410, v392, v413);
    v204 = *(v180 + 168);
    LODWORD(v416) = v204[25];
    if (isValid)
    {
      v205 = *(v180 + 3453);
      *(v391 + 4 * v205) |= 1u;
      v8 = v425;
      if (*(v180 + 333) && *(v180 + 3488 + 4 * v205) >= 1)
      {
        *(v180 + 3488 + 4 * v205) = 1;
      }

      else
      {
        *(v180 + 4 * v205 + 3488) = 0;
      }

      v405 = 0;
      *(v180 + 3484) = 1;
    }

    else
    {
      v206 = v444[0];
      if ((v444[0] & 2) != 0 && (v198 & 2) == 0 || *v204)
      {
        v207 = *(v180 + 3453);
        *(v391 + 4 * v207) |= 0x100u;
        if (*(v180 + 333) && *(v180 + 3488 + 4 * v207) >= 1)
        {
          *(v180 + 3488 + 4 * v207) = 1;
        }

        else
        {
          *(v180 + 4 * v207 + 3488) = 0;
        }

        *(v180 + 3484) = 1;
      }

      if (v206)
      {
        isValid = 0;
        goto LABEL_392;
      }

      v8 = v425;
      if (*(v180 + 3476) != -1)
      {
        SpatialDecChannelProperties(v204, (v5 + 248), v397, v410);
      }

      isValid = 0;
    }

LABEL_416:
    if (v394)
    {
      *(*(v180 + 168) + 401) = *(v395 + 3080 * *(v180 + 3453) + 2);
    }

    if (isValid)
    {
      if (isValid == -992)
      {
        v8 = 8204;
        LODWORD(v416) = v421;
        v22 = v423;
        LODWORD(v21) = v426;
        goto LABEL_688;
      }

LABEL_420:
      v208 = *(v5 + 1924);
      if (v208 < 1)
      {
        v8 = 5;
        v21 = v426;
        v24 = v422;
      }

      else
      {
        v209 = *(v5 + 1928);
        v24 = v422;
        if (v209 < 1)
        {
          v8 = 5;
        }

        else
        {
          *(v5 + 300) = v208;
          *(v5 + 292) = v209;
          bzero(v4, (4 * v208 * v209));
          v8 = 16388;
        }

        v21 = v426;
      }

      goto LABEL_435;
    }

    v210 = v416;
    *(v5 + 300) = v416;
    *(v5 + 292) = v405;
    v211 = *(v5 + 1912);
    if (v211)
    {
      v212 = *(v211 + 156 * *(v211 + 3453) + 132);
      v21 = v426;
      v24 = v422;
      if (v212 >= 1)
      {
        if (v212 <= 41)
        {
          v213 = 256;
          if (v212 == 23 || v212 == 39)
          {
            goto LABEL_434;
          }

LABEL_493:
          if (*(v211 + 334))
          {
            v213 = 1281;
          }

          else
          {
            v213 = 577;
          }

          goto LABEL_434;
        }

        if (v212 != 42 && v212 != 50 && v212 != 150)
        {
          goto LABEL_493;
        }
      }

      v213 = 0;
    }

    else
    {
      v213 = 0;
      v21 = v426;
      v24 = v422;
    }

LABEL_434:
    *(v5 + 356) += v213;
    *(v5 + 1924) = v210;
    *(v5 + 1928) = v405;
LABEL_435:
    v177 = *(v5 + 840);
LABEL_436:
    v214 = *(v5 + 68);
    if (v177)
    {
      v215 = (v214 & 0x8000000) == 0;
    }

    else
    {
      v215 = 1;
    }

    if (v215)
    {
      goto LABEL_449;
    }

    v216 = *(v5 + 832);
    if (!*(v5 + 844))
    {
      if (!v216)
      {
        goto LABEL_446;
      }

      *(v216 + 532) = 0;
LABEL_445:
      *(v216 + 536) = *(v216 + 536) & 0xFF9FFFFF | 0x200000;
      goto LABEL_446;
    }

    if (v216)
    {
      goto LABEL_445;
    }

LABEL_446:
    isValid = sbrDecoder_Apply(v216, v131, v4, v412, v24, v407, v410, *(v5 + 280), *(v5 + 64), v406, v413);
    if (isValid)
    {
      if (isValid == 8)
      {
LABEL_680:
        v8 = 8204;
LABEL_686:
        LODWORD(v416) = v421;
LABEL_687:
        v22 = v423;
        goto LABEL_688;
      }

LABEL_448:
      v214 = *(v5 + 68);
LABEL_449:
      if ((v214 & 0x100) == 0)
      {
        goto LABEL_520;
      }

      goto LABEL_450;
    }

    v243 = *(v5 + 68) | 0x8000;
    *(v5 + 68) = v243;
    v244 = *(v5 + 320);
    v245 = *(v5 + 288);
    if (v244 != v245)
    {
      if (*(v5 + 292) == 768)
      {
        v246 = 11453246128 * *(v5 + 340);
        v247 = HIDWORD(v246) + (v246 >> 63);
      }

      else
      {
        v248 = *(v5 + 340);
        if (v245 == 4 * v244)
        {
          v247 = 4 * v248;
        }

        else
        {
          v247 = 2 * v248;
        }
      }

      *(v5 + 292) = v247;
    }

    v250 = v243 & 0xFFFDFFFF;
    *(v5 + 68) = v250;
    if ((v250 & 0x100) == 0)
    {
      goto LABEL_520;
    }

LABEL_450:
    v217 = *v24;
    LODWORD(v425) = v8;
    if (v217 < 2 || !*(v5 + 840) && !*(v5 + 1921))
    {
      v405 = 1;
      v221 = v131;
      goto LABEL_460;
    }

    v218 = *(v5 + 292);
    if ((8 * v217 * v218) > 0x10010)
    {
      v8 = 5;
      goto LABEL_686;
    }

    v219 = 0;
    v220 = 0;
    v221 = v131 + 4 * v218 * v217;
    do
    {
      v222 = v220;
      v223 = v219;
      v224 = v218;
      if (v218)
      {
        do
        {
          *(v221 + 4 * v223++) = *(v4 + v222);
          v222 += v217;
          --v224;
        }

        while (v224);
      }

      ++v220;
      v219 += v218;
    }

    while (v220 != v217);
    v405 = 0;
LABEL_460:
    v225 = *(v5 + 2124);
    LODWORD(v435) = *(v5 + 2120);
    MEMORY[0x1EEE9AC00](isValid);
    v227 = (&v387 - ((v226 + 15) & 0xFFFFFFFF0));
    if (v225)
    {
      memset(&v387 - ((v226 + 15) & 0xFFFFFFFF0), 170, v226);
      v228 = (v5 + 292);
      v229 = vdupq_n_s64(v225 - 1);
      v230 = (v225 + 1) & 0x1FFFFFFFELL;
      v231 = vld1_dup_f32(v228);
      v232 = v227 + 1;
      v233 = v403;
      v234 = 0x100000000;
      do
      {
        v235 = vmovn_s64(vcgeq_u64(v229, v233));
        v236 = vmul_s32(v231, v234);
        *&v237 = v236.u32[0];
        *(&v237 + 1) = v236.u32[1];
        v238 = v237;
        if (v235.i8[0])
        {
          *(v232 - 1) = v221 + 4 * v238;
        }

        if (v235.i8[4])
        {
          *v232 = v221 + 4 * *(&v238 + 1);
        }

        v233 = vaddq_s64(v233, v430);
        v234 = vadd_s32(v234, 0x200000002);
        v232 += 2;
        v230 -= 2;
      }

      while (v230);
    }

    v239 = *(v5 + 2104);
    v416 = &v387;
    if (v239 != 1)
    {
      goto LABEL_505;
    }

    v240 = *(v5 + 2136);
    if (*(v5 + 2106) != 1)
    {
      if (!v240)
      {
        goto LABEL_505;
      }

      if (MPEG_D::USAC::DynRangeCompressor::AdjustForHostInput(v413))
      {
        if (gDRCScope)
        {
          v364 = *gDRCScope;
          v22 = v423;
          LODWORD(v21) = v426;
          v8 = v425;
          v365 = v421;
          if (!*gDRCScope)
          {
            goto LABEL_728;
          }
        }

        else
        {
          v364 = MEMORY[0x1E69E9C10];
          v22 = v423;
          LODWORD(v21) = v426;
          v8 = v425;
          v365 = v421;
        }

        if (!os_log_type_enabled(v364, OS_LOG_TYPE_ERROR))
        {
          goto LABEL_728;
        }

        v444[0] = 136315394;
        *&v444[1] = "aacdecoder_lib.cpp";
        LOWORD(v444[3]) = 1024;
        *(&v444[3] + 2) = 1708;
        v380 = "%25s:%-5d Error Processing post subband domain DRC\n";
LABEL_727:
        _os_log_impl(&dword_19AA99000, v364, OS_LOG_TYPE_ERROR, v380, v444, 0x12u);
        goto LABEL_728;
      }

      if (!mpddrc::UniDrc::ProcessPostSubbandSynt(*(v5 + 2136) + 8, v227, v227, v225, *(*(v5 + 2136) + 2472)))
      {
        goto LABEL_505;
      }

      goto LABEL_472;
    }

    if (v240)
    {
      if (MPEG_D::USAC::DynRangeCompressor::AdjustForHostInput(v413))
      {
        if (gDRCScope)
        {
          v364 = *gDRCScope;
          v22 = v423;
          LODWORD(v21) = v426;
          v8 = v425;
          v365 = v421;
          if (!*gDRCScope)
          {
            goto LABEL_728;
          }
        }

        else
        {
          v364 = MEMORY[0x1E69E9C10];
          v22 = v423;
          LODWORD(v21) = v426;
          v8 = v425;
          v365 = v421;
        }

        if (!os_log_type_enabled(v364, OS_LOG_TYPE_ERROR))
        {
          goto LABEL_728;
        }

        v444[0] = 136315394;
        *&v444[1] = "aacdecoder_lib.cpp";
        LOWORD(v444[3]) = 1024;
        *(&v444[3] + 2) = 1701;
        v380 = "%25s:%-5d Error Processing time domain DRC\n";
        goto LABEL_727;
      }

      if (!mpddrc::UniDrc::Process(*(v5 + 2136) + 8, v227, v225, v227, v225, &v435))
      {
        v249 = *(v5 + 2112);
        if (*(v5 + 2144) || v249 && *(v249 + 103))
        {
          if (*(v249 + 102) && !*(v249 + 103) && *(*(v5 + 2136) + 2144 * *(*(v5 + 2136) + 2464) + 3385) == 1)
          {
            Limiter::Initialize(v404, *(v5 + 2132), v241);
          }
        }

        else if (*(*(v5 + 2136) + 2144 * *(*(v5 + 2136) + 2464) + 3385) == 1)
        {
          Limiter::Initialize(v404, *(v5 + 2132), v241);
        }

        v251 = *(*(v5 + 2136) + 2456);
        if (*(v249 + 96) != v251 && !*(v249 + 100))
        {
          *(v249 + 96) = v251;
          *(v249 + 101) = 1;
        }

        *(v249 + 101) = 1;
        goto LABEL_505;
      }

LABEL_472:
      *(v5 + 2104) = 0;
      *(v5 + 2106) = 0;
      v242 = *(v5 + 2136);
      *(v242 + 2448) = 0;
      *(v242 + 2452) = 0;
      *(v242 + 2460) = 0;
      *(v242 + 2472) = 0;
    }

LABEL_505:
    v252 = *v404;
    if (*v404)
    {
      LODWORD(v431) = 939524096;
      v439[0] = 1191182336;
      v253 = v227;
      v254 = v225;
      if (v225)
      {
        do
        {
          MEMORY[0x19EAE6090](*v253, 1, &v431, *v253, 1, *(v5 + 292));
          ++v253;
          --v254;
        }

        while (v254);
        v252 = *v404;
        if (!*v404)
        {
          goto LABEL_675;
        }
      }

      v255 = *(v5 + 292);
      v25 = (*(*v252 + 56))(v252, v227, v227, v255) == v255;
      v5 = v424;
      if (!v25)
      {
LABEL_675:
        if (gDRCScope)
        {
          v364 = *gDRCScope;
          v22 = v423;
          LODWORD(v21) = v426;
          v8 = v425;
          v365 = v421;
          if (!*gDRCScope)
          {
            goto LABEL_728;
          }
        }

        else
        {
          v364 = MEMORY[0x1E69E9C10];
          v22 = v423;
          LODWORD(v21) = v426;
          v8 = v425;
          v365 = v421;
        }

        if (os_log_type_enabled(v364, OS_LOG_TYPE_ERROR))
        {
          v444[0] = 136315394;
          *&v444[1] = "aacdecoder_lib.cpp";
          LOWORD(v444[3]) = 1024;
          *(&v444[3] + 2) = 1723;
          v380 = "%25s:%-5d Error applying limiter\n";
          goto LABEL_727;
        }

LABEL_728:
        LODWORD(v416) = v365;
        goto LABEL_688;
      }

      if (v225)
      {
        do
        {
          MEMORY[0x19EAE6090](*v227, 1, v439, *v227, 1, *(v5 + 292));
          ++v227;
          --v225;
        }

        while (v225);
      }
    }

    v21 = v426;
    v24 = v422;
    if ((v405 & 1) == 0)
    {
      v256 = *v422;
      if (*v422)
      {
        v257 = 0;
        v258 = 0;
        v259 = *(v5 + 292);
        do
        {
          v260 = v257;
          v261 = v258;
          v262 = v259;
          if (v259)
          {
            do
            {
              *(v4 + v261) = *(v221 + 4 * v260);
              v261 += v256;
              ++v260;
              --v262;
            }

            while (v262);
          }

          ++v258;
          v257 += v259;
        }

        while (v258 != v256);
      }
    }

    v8 = v425;
LABEL_520:
    if (*(v5 + 348) != 37 && !*(v5 + 840) && !*(v5 + 1921))
    {
      v263 = *(v5 + 292);
      if (v263)
      {
        v264 = 0;
        v265 = *(v5 + 300);
        v266 = v4;
        do
        {
          v267 = v131;
          for (i = v265; i; --i)
          {
            *v266++ = *v267;
            v267 += v263;
          }

          ++v264;
          v131 += 4;
        }

        while (v264 != v263);
      }
    }

    v132 = *(v5 + 68);
    v269 = *(v5 + 2024);
    if ((v132 & 0x100) == 0)
    {
      LOBYTE(v20) = v418;
      v22 = v423;
      if (!*(v5 + 2024))
      {
        goto LABEL_550;
      }

      goto LABEL_549;
    }

    LOBYTE(v20) = v418;
    v22 = v423;
    if (v269 == 3)
    {
      v270 = *v24;
      if (v270 >= 1)
      {
        v271 = 0;
        v272 = v4;
        do
        {
          v273 = 0;
          v274 = v427[v271];
          v275 = v272;
          do
          {
            *(v274 + v273) = *v275;
            v273 += 4;
            v275 += v270;
          }

          while (v273 != 512);
          ++v271;
          ++v272;
        }

        while (v271 != v270);
      }
    }

    v276 = *(v5 + 2052);
    if (!v417)
    {
      if (!*(v5 + 2052))
      {
        v417 = 0;
        if (!v269)
        {
          goto LABEL_550;
        }

        goto LABEL_549;
      }

      v299 = *v24;
      if (v299 >= 1)
      {
        v300 = v427;
        do
        {
          v301 = *v300++;
          v301[30] = 0uLL;
          v301[31] = 0uLL;
          v301[28] = 0uLL;
          v301[29] = 0uLL;
          v301[26] = 0uLL;
          v301[27] = 0uLL;
          v301[24] = 0uLL;
          v301[25] = 0uLL;
          v301[22] = 0uLL;
          v301[23] = 0uLL;
          v301[20] = 0uLL;
          v301[21] = 0uLL;
          v301[18] = 0uLL;
          v301[19] = 0uLL;
          v301[16] = 0uLL;
          v301[17] = 0uLL;
          v301[14] = 0uLL;
          v301[15] = 0uLL;
          v301[12] = 0uLL;
          v301[13] = 0uLL;
          v301[10] = 0uLL;
          v301[11] = 0uLL;
          v301[8] = 0uLL;
          v301[9] = 0uLL;
          v301[6] = 0uLL;
          v301[7] = 0uLL;
          v301[4] = 0uLL;
          v301[5] = 0uLL;
          v301[2] = 0uLL;
          v301[3] = 0uLL;
          *v301 = 0uLL;
          v301[1] = 0uLL;
          --v299;
        }

        while (v299);
      }
    }

    v417 = 1;
    if (v276 && v22 >= v21)
    {
      if (*(v5 + 2026) == 3)
      {
        v277 = *v24;
        if (v277 >= 1)
        {
          v278 = 0;
          v279 = v4;
          do
          {
            v280 = 0;
            v281 = v427[v278];
            v282 = v279;
            do
            {
              v283 = vcvts_n_f32_u32(v280, 7uLL);
              *v282 = (v281[v280] - (v281[v280] * v283)) + (*v282 * v283);
              ++v280;
              v282 += v277;
            }

            while (v280 != 128);
            ++v278;
            ++v279;
          }

          while (v278 != v277);
        }

        *(v5 + 2052) = 0;
      }

      v417 = 1;
    }

    if (!v269)
    {
      goto LABEL_550;
    }

LABEL_549:
    aacDecoder_SignalInterruption(v5);
    v132 = *(v5 + 68);
LABEL_550:
    *(v5 + 360) = v132;
    LODWORD(v416) = v421;
LABEL_551:
    if (v22 >= v21)
    {
      if (*(v5 + 2026) - 1 <= 2 && (v286 = *(v5 + 2027) - 1, *(v5 + 2027) = v286, v286 < 0))
      {
        *(v5 + 2026) = 0;
        if ((v132 & 0x100) != 0)
        {
LABEL_558:
          if (*(v5 + 2024) == 3)
          {
            *(v5 + 292) = 0;
          }
        }
      }

      else if ((v132 & 0x100) != 0)
      {
        goto LABEL_558;
      }
    }

    else
    {
      v284 = v117[38];
      v285 = v117[27];
      if (v284)
      {
        if (v285)
        {
          CDK_put(v415, v117[26], v285);
          v284 = v117[38];
        }
      }

      else
      {
        v287 = v117[32];
        v288 = v117[31] - v285;
        v117[28] += v285;
        v289 = (v117[37] - 1) & (v287 - v285);
        v117[31] = v288;
        v117[32] = v289;
      }

      *(v117 + 13) = 0;
      v290 = v117[28];
      v291 = v420;
      v292 = v420 - v290;
      if ((v420 - v290) > 0x1F)
      {
        if (v284)
        {
LABEL_565:
          v296 = v117[31];
          v297 = v117[32];
          v298 = v117[37];
        }

        else
        {
          v296 = v117[31];
          v298 = v117[37];
          v297 = (v298 - 1) & v117[32];
          v117[32] = v297;
        }

        *(v117 + 13) = 0;
        v302 = v296 - v292;
        v303 = v290 - v292;
        if (v284)
        {
          v304 = v303;
        }

        else
        {
          v304 = v291;
        }

        v117[28] = v304;
        v117[31] = v302;
        v117[32] = (v298 - 1) & (v297 - v292);
        goto LABEL_578;
      }

      if (v284)
      {
        goto LABEL_565;
      }

      v293 = v117[32];
      v294 = v117[31] - v292;
      v117[28] = v420;
      v295 = (v117[37] - 1) & (v293 - v292);
      v117[31] = v294;
      v117[32] = v295;
      *(v117 + 13) = 0;
    }

LABEL_578:
    v15 = *(v5 + 2024);
    if (v15 != 3 && ++v22 >= v411)
    {
      goto LABEL_688;
    }
  }

  v25 = *(v5 + 2026) == 5 && v20 && v419 == 0;
  if (!v25)
  {
    goto LABEL_209;
  }

LABEL_26:
  memset(v444, 0, 512);
  v26 = *(v5 + 24);
  v27 = *(v26 + 120);
  v431 = *(v26 + 104);
  v432 = v27;
  v433 = *(v26 + 136);
  v434 = *(v26 + 152);
  if (*(v26 + 152))
  {
    v28 = *(v26 + 108);
    if (v28)
    {
      CDK_put(v26 + 112, *(v26 + 104), v28);
    }
  }

  else
  {
    v29 = *(v26 + 108);
    v30 = *(v26 + 128);
    v31 = *(v26 + 124) - v29;
    *(v26 + 112) += v29;
    v32 = (*(v26 + 148) - 1) & (v30 - v29);
    *(v26 + 124) = v31;
    *(v26 + 128) = v32;
  }

  v34 = v26 + 112;
  v33 = *(v26 + 112);
  *(v26 + 104) = 0;
  v421 = v33;
  if (v33 < 1)
  {
    v366 = v432;
    *(v26 + 104) = v431;
    *(v26 + 120) = v366;
    *(v26 + 136) = v433;
    *(v26 + 152) = v434;
LABEL_723:
    v22 = 0;
    v8 = 4098;
    goto LABEL_688;
  }

  v35 = CDK_get32(v26 + 112);
  *(v26 + 104) = v35;
  *(v26 + 108) = 29;
  if ((v35 & 0x60000000) != 0x40000000)
  {
    if (*(v5 + 2024))
    {
LABEL_131:
      *(v5 + 2024) = 0;
      goto LABEL_198;
    }

    goto LABEL_195;
  }

  if ((~v35 & 0x1FE00000) != 0)
  {
    v36 = 17;
    *(v26 + 108) = 17;
    v37 = (v35 >> 17) & 0xF;
    if (v37 == 15)
    {
      v38 = 0;
      goto LABEL_39;
    }
  }

  else
  {
    v36 = 1;
    *(v26 + 108) = 1;
    v37 = (v35 >> 1) & 0xF;
    if (v37 == 15)
    {
      v38 = 8 * v35;
      v35 = CDK_get32(v26 + 112);
      *(v26 + 104) = v35;
      v36 = *(v26 + 108) + 32;
LABEL_39:
      v39 = v36 - 4;
      *(v26 + 108) = v36 - 4;
      v40 = ((v35 >> (v36 - 4)) | v38) & 0xF;
      v37 = v40 + 15;
      if (v40 == 15)
      {
        if (12 - v36 < 1)
        {
          v41 = 0;
        }

        else
        {
          if (v36 == -20)
          {
            v41 = 0;
          }

          else
          {
            v41 = v35 << (12 - v36);
          }

          v35 = CDK_get32(v26 + 112);
          *(v26 + 104) = v35;
          v39 = *(v26 + 108) + 32;
        }

        v36 = v39 - 8;
        *(v26 + 108) = v39 - 8;
        v37 += ((v35 >> (v39 - 8)) | v41);
      }

      else
      {
        v36 -= 4;
      }
    }
  }

  v42 = 0;
  v43 = *(v5 + 68) & 0x100;
  if (!v43 || !v37)
  {
    goto LABEL_127;
  }

  v426 = v21;
  v44 = 0;
  LODWORD(v425) = v37;
  do
  {
    if (8 - v36 < 1)
    {
      v45 = 0;
    }

    else
    {
      if (v36 == -24)
      {
        v45 = 0;
      }

      else
      {
        v45 = v35 << (8 - v36);
      }

      v35 = CDK_get32(v26 + 112);
      *(v26 + 104) = v35;
      v36 = *(v26 + 108) + 32;
    }

    v36 -= 8;
    *(v26 + 108) = v36;
    *(v444 + v44++) = (v35 >> v36) | v45;
  }

  while (v37 != v44);
  v46 = *(v5 + 24);
  v438 = 0xAAAAAAAAAAAAAAAALL;
  *&v47 = 0xAAAAAAAAAAAAAAAALL;
  *(&v47 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v436 = v47;
  v437 = v47;
  v435 = v47;
  v48 = *(v46 + 984);
  if (v48 != 150 && v48 != 42)
  {
    v382 = 254;
    goto LABEL_750;
  }

  v49 = 8 * v425;
  CDK_InitBitBuffer(&v435 + 8, v444, 0x200u, 8 * v425);
  v34 = v26 + 112;
  *&v435 = 0;
  LODWORD(v438) = 0;
  v50 = (v46 + 2868);
  v51 = *(v46 + 984);
  if (!*(v46 + 2869))
  {
    if (*(v46 + 2871) == 5)
    {
      goto LABEL_73;
    }

    if (v51 != 42)
    {
      LODWORD(v420) = 0;
      *(v46 + 2868) = 0;
      *(v46 + 2870) = 0;
      goto LABEL_125;
    }

    if (v425 == (*(v46 + 980) + 7) >> 3 && !memcmp(v444, (v46 + 467), v37))
    {
      if (!*(v46 + 206))
      {
        LODWORD(v420) = 0;
        goto LABEL_125;
      }

      v52 = 0;
      LODWORD(v420) = 0;
      *(v46 + 206) = 0;
      *(v46 + 2868) = 768;
      v53 = 1;
LABEL_63:
      if (v52 >= v53)
      {
        *(v46 + 2868) = 0;
        *(v46 + 2874) = 0;
        if (v53)
        {
          *(v46 + 2870) = 768;
        }
      }

      v54 = (*(v46 + 40))(*(v46 + 48), v46 + 2868);
      if (v54)
      {
        v55 = 1025;
      }

      else
      {
        v55 = 0;
      }

      if ((*(v46 + 2869) & 0xFE) == 2)
      {
        ++*v50;
        v21 = v426;
        v24 = v422;
        if (v54)
        {
          goto LABEL_197;
        }

        goto LABEL_126;
      }

      v57 = *(v46 + 984);
      if (v57 == 42 && !v54)
      {
        goto LABEL_83;
      }

      if (v57 == 42)
      {
        v56 = 1025;
      }

      else
      {
        v56 = v55;
      }

      if (v57 != 42 && !v54)
      {
        goto LABEL_125;
      }
    }

    else
    {
      if (*v46 > 0xAu || ((1 << *v46) & 0x4C0) == 0)
      {
        v52 = 0;
        *v50 = 768;
        v53 = 1;
        LODWORD(v420) = 1;
        goto LABEL_63;
      }

      (*(v46 + 24))(*(v46 + 32), v46 + 212);
      *(v46 + 206) = 256;
      v56 = 1025;
      LODWORD(v420) = 1;
    }

LABEL_117:
    *(v46 + 2888) = 0;
    *v50 = 0;
    *(v50 + 3) = 0;
    (*(v46 + 40))(*(v46 + 48), v50);
    v21 = v426;
    v24 = v422;
    if (v56)
    {
      goto LABEL_197;
    }

    goto LABEL_126;
  }

  if ((*(v46 + 2869) & 0xFE) == 2)
  {
    LODWORD(v420) = 0;
    v52 = *v50;
    v53 = v51 == 42;
    goto LABEL_63;
  }

LABEL_73:
  LODWORD(v420) = 0;
  if (v51 != 42)
  {
    goto LABEL_125;
  }

LABEL_83:
  v58 = v49;
  v415 = (v46 + 2868);
  v59 = 0;
  v60 = 0;
  v61 = 1;
  v62 = 1;
  while (2)
  {
    v63 = v61;
    if (v60)
    {
      v64 = v438;
      if (v438)
      {
        v65 = v58;
        if (DWORD1(v435))
        {
          CDK_put(&v435 + 8, v435, SDWORD1(v435));
          v64 = v438;
        }
      }

      else
      {
        DWORD1(v436) -= DWORD1(v435);
        DWORD2(v435) += DWORD1(v435);
        DWORD2(v436) = (HIDWORD(v437) - 1) & (DWORD2(v436) - DWORD1(v435));
        v65 = v58;
      }

      *&v435 = 0;
      v66 = v65 - DWORD2(v435);
      if ((v65 - DWORD2(v435)) > 0x1F)
      {
        if (v64)
        {
          goto LABEL_93;
        }

        v67 = DWORD1(v436);
        v69 = HIDWORD(v437);
        v68 = (HIDWORD(v437) - 1) & DWORD2(v436);
      }

      else
      {
        if (!v64)
        {
          DWORD1(v436) -= v66;
          DWORD2(v435) = v65;
          DWORD2(v436) = (HIDWORD(v437) - 1) & (DWORD2(v436) - v66);
          *&v435 = 0;
          goto LABEL_99;
        }

LABEL_93:
        v67 = DWORD1(v436);
        v68 = DWORD2(v436);
        v69 = HIDWORD(v437);
      }

      *&v435 = 0;
      v70 = v67 - v66;
      if (v64)
      {
        v71 = DWORD2(v435) - v66;
      }

      else
      {
        v71 = v65;
      }

      DWORD1(v436) = v70;
      DWORD2(v435) = v71;
      DWORD2(v436) = (v69 - 1) & (v68 - v66);
LABEL_99:
      v62 = 2;
    }

    v72 = AudioSpecificConfig_Parse((v46 + 1540), &v435, (v46 + 8), v62, v59, *(v46 + 984), v413);
    if (!v72)
    {
      memcpy((v46 + 212), (v46 + 1540), 0x530uLL);
      if ((*(v46 + 8))(*(v46 + 16), v46 + 212, *(v46 + 1018), v46 + 1019))
      {
        v72 = 1025;
      }

      else
      {
        v72 = 0;
      }
    }

    if (v72 | v60)
    {
      if (v72)
      {
        goto LABEL_116;
      }
    }

    else if (*(v46 + 1019) || *(v46 + 1020) || *(v46 + 1021))
    {
      if ((*(v46 + 24))(*(v46 + 32), v46 + 212))
      {
LABEL_116:
        v56 = 1025;
        v50 = v415;
        goto LABEL_117;
      }

      v59 = 1;
    }

    v61 = 0;
    v60 = 1;
    if (v63)
    {
      continue;
    }

    break;
  }

  if (*(v46 + 984) == 42)
  {
    *(v46 + 980) = v58;
    CDKmemcpy((v46 + 467), v444, v425);
    *v415 = 0;
  }

  *(v46 + 2916) |= 0x20u;
LABEL_125:
  v21 = v426;
  v24 = v422;
LABEL_126:
  v5 = v424;
  v43 = *(v424 + 68) & 0x100;
  v42 = v420;
LABEL_127:
  if (*v24 || (v42 & 1) != 0)
  {
    if (v43 && *(v5 + 2026) == 3)
    {
      goto LABEL_134;
    }
  }

  else if (v43)
  {
    *(v5 + 2026) = 3;
    if (*(v5 + 2024))
    {
      goto LABEL_131;
    }

LABEL_134:
    v73 = *(v26 + 108);
    if (v73)
    {
      v74 = *(v26 + 104);
      v75 = v73 - 1;
      *(v26 + 108) = v73 - 1;
      *(v5 + 2052) |= (v74 >> (v73 - 1)) & 1;
      if (v73 == 1)
      {
        v74 = CDK_get32(v34);
        v76 = 0;
        *(v26 + 104) = v74;
        v77 = 31;
        goto LABEL_144;
      }
    }

    else
    {
      v74 = CDK_get32(v34);
      *(v26 + 104) = v74;
      *(v5 + 2052) |= (v74 & 0x80000000) != 0;
      v75 = 31;
    }

    v77 = v75 - 1;
    *(v26 + 108) = v75 - 1;
    v78 = 3 - v75;
    if (v78 <= 0)
    {
      v76 = 0;
    }

    else
    {
      v79 = v74 << v78;
      if (v77 == -30)
      {
        v76 = 0;
      }

      else
      {
        v76 = v79;
      }

      v74 = CDK_get32(v34);
      *(v26 + 104) = v74;
      v77 = *(v26 + 108) + 32;
    }

LABEL_144:
    v80 = v77 - 2;
    *(v26 + 108) = v77 - 2;
    v21 = ((v74 >> (v77 - 2)) | v76) & 3;
    if (v21 == 3)
    {
      if (6 - v77 < 1)
      {
        v81 = 0;
      }

      else
      {
        if (v77 == -26)
        {
          v81 = 0;
        }

        else
        {
          v81 = v74 << (6 - v77);
        }

        v74 = CDK_get32(v34);
        *(v26 + 104) = v74;
        v80 = *(v26 + 108) + 32;
      }

      *(v26 + 108) = v80 - 4;
      v82 = ((v74 >> (v80 - 4)) | v81) & 0xF;
      v21 = (v82 + 3);
      if (v82 == 15)
      {
        v21 = CDKreadBits((v26 + 104), 0) + v21;
      }

      if (v21 > 3)
      {
        v21 = 0;
        goto LABEL_198;
      }
    }
  }

  if (!v21)
  {
LABEL_195:
    v112 = v432;
    *(v26 + 104) = v431;
    *(v26 + 120) = v112;
    *(v26 + 136) = v433;
    *(v26 + 152) = v434;
    goto LABEL_199;
  }

  v83 = 0;
  v84 = 0;
  v420 = 4 * v21;
  v85 = &v440;
  v426 = v21;
  while (1)
  {
    v86 = *(v26 + 108);
    if (16 - v86 <= 0)
    {
      LOWORD(v87) = 0;
      v88 = *(v26 + 104);
    }

    else
    {
      if (v86 == -16)
      {
        LOWORD(v87) = 0;
      }

      else
      {
        v87 = *(v26 + 104) << (16 - v86);
      }

      v88 = CDK_get32(v34);
      *(v26 + 104) = v88;
      v86 = *(v26 + 108) + 32;
    }

    v89 = v86 - 16;
    *(v26 + 108) = v86 - 16;
    v90 = ((v88 >> (v86 - 16)) | v87);
    if (v90 == 0xFFFF)
    {
      if (32 - v86 < 1)
      {
        v91 = 0;
      }

      else
      {
        if (v86)
        {
          v91 = v88 << (32 - v86);
        }

        else
        {
          v91 = 0;
        }

        v88 = CDK_get32(v34);
        *(v26 + 104) = v88;
        v89 = *(v26 + 108) + 32;
      }

      v93 = v89 - 16;
      *(v26 + 108) = v89 - 16;
      v94 = (v88 >> (v89 - 16)) | v91;
      if (v94 == 0xFFFF)
      {
        if (v89 - 17 <= -2)
        {
          v88 = CDK_get32(v34);
          *(v26 + 104) = v88;
          v93 = *(v26 + 108) + 32;
        }

        *(v26 + 108) = v93;
      }

      *v85 = v94 + 0xFFFF;
      v89 = v93;
      v92 = v85;
    }

    else
    {
      *v85 = v90;
      if (!((v88 >> (v86 - 16)) | v87))
      {
        break;
      }

      v92 = (&v440 + 4 * v84);
    }

    if (*(v26 + 152))
    {
      if (v89)
      {
        CDK_put(v34, v88, v89);
      }
    }

    else
    {
      v95 = *(v26 + 128);
      v96 = *(v26 + 124) - v89;
      *(v26 + 112) += v89;
      v97 = (*(v26 + 148) - 1) & (v95 - v89);
      *(v26 + 124) = v96;
      *(v26 + 128) = v97;
    }

    *(v26 + 104) = 0;
    v98 = v421 - *(v26 + 112);
    *(&v442 + v83) = v98;
    v99 = CDK_get32(v34);
    *(v26 + 104) = v99;
    *(v26 + 108) = 31;
    if (!v83 && (v99 & 0x80000000) == 0)
    {
      break;
    }

    v100 = v34;
    v425 = v92;
    v101 = 8 * *v92;
    v102 = v101 - 1;
    v103 = *(v26 + 152);
    if ((v101 - 1) > 0x1E)
    {
      if (v103)
      {
LABEL_187:
        CDK_put(v100, v99, 31);
      }

      else
      {
        v104 = *(v26 + 128);
        v105 = *(v26 + 124) - 31;
        *(v26 + 112) += 31;
        v106 = (*(v26 + 148) - 1) & (v104 - 31);
        *(v26 + 124) = v105;
        *(v26 + 128) = v106;
      }

      *(v26 + 104) = 0;
      if (*(v26 + 152))
      {
        v107 = v101 - 1;
      }

      else
      {
        v107 = 1 - v101;
      }

      v108 = *(v26 + 128);
      v109 = *(v26 + 124) + v102;
      *(v26 + 112) += v107;
      v110 = v108 + v102;
      v111 = *(v26 + 148) - 1;
      *(v26 + 124) = v109;
      *(v26 + 128) = v111 & v110;
      v101 = 8 * *v425;
      goto LABEL_193;
    }

    if (v103)
    {
      goto LABEL_187;
    }

    *(v26 + 108) = 32 - v101;
LABEL_193:
    *(v408 + v83) = v101 + v98;
    ++v84;
    v85 = (v85 + 4);
    v83 += 4;
    v34 = v100;
    if (v420 == v83)
    {
      v5 = v424;
      v21 = v426;
      goto LABEL_195;
    }
  }

  v21 = 0;
LABEL_197:
  v5 = v424;
LABEL_198:
  v113 = v432;
  *(v26 + 104) = v431;
  *(v26 + 120) = v113;
  *(v26 + 136) = v433;
  *(v26 + 152) = v434;
  *(v5 + 64) = 0;
LABEL_199:
  v114 = *(v5 + 24);
  LOBYTE(v20) = v418;
  v22 = v423;
  if (v114)
  {
    v115 = *(v114 + 992);
    v116 = *(v114 + 214);
    switch(v116)
    {
      case 3:
        v115 *= 2;
        break;
      case 2:
        v115 = 8 * v115 / 3;
        break;
      case 1:
        v115 *= 4;
        break;
    }
  }

  else
  {
    v115 = 0;
  }

  if (*(v5 + 4) * v115 <= v412)
  {
    v411 += v21;
    goto LABEL_209;
  }

  aacDecoder_FreeMemCallback(v5);
  v22 = 0;
  v8 = 8204;
LABEL_688:
  v367 = v22;
  v368 = v8 & 0xFFFFF000;
  if (v8)
  {
    v369 = v368 == 0x4000;
  }

  else
  {
    v369 = 1;
  }

  v370 = v369;
  if (v416 && (v370 & 1) == 0 && v367 < v21)
  {
    transportDec_EndAccessUnit(*(v5 + 24));
  }

  v371 = v401;
  v372 = v401[27];
  if (v401[38])
  {
    if (v372)
    {
      CDK_put(v396, v401[26], v372);
    }
  }

  else
  {
    v373 = v401[32];
    v374 = v401[31] - v372;
    v401[28] += v372;
    v375 = (v371[37] - 1) & (v373 - v372);
    v371[31] = v374;
    v371[32] = v375;
  }

  *(v371 + 13) = 0;
  v376 = v400 - v371[28];
  v377 = *(v5 + 292);
  if (v377 >= 1)
  {
    *(v5 + 336) = ((v376 * *(v5 + 288)) / v377);
  }

  *(v5 + 372) += v376 >> 3;
  if (v370)
  {
    ++*(v5 + 380);
  }

  if (v368 == 0x4000)
  {
    *(v5 + 376) += v376 >> 3;
    ++*(v5 + 384);
  }

  if (*(v5 + 300) < 1 || v377 < 1)
  {
    if (v370)
    {
      v378 = 5;
    }

    else
    {
      v378 = v8;
    }

    goto LABEL_719;
  }

  if ((v370 & (*v407 < 1)) != 0)
  {
    v378 = 5;
  }

  else
  {
    v378 = v8;
  }

  if (*v407 < 1 || ((v370 ^ 1) & 1) != 0)
  {
LABEL_719:
    *(v5 + 292) = 0;
    return v378;
  }

  return v8;
}

void sub_19B06FF6C(_Unwind_Exception *a1, int a2)
{
  if (a2 != 1)
  {
    _Unwind_Resume(a1);
  }

  v3 = __cxa_begin_catch(a1);
  if (gACScope)
  {
    v4 = *gACScope;
    if (!*gACScope)
    {
      goto LABEL_8;
    }
  }

  else
  {
    v4 = MEMORY[0x1E69E9C10];
  }

  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    v5 = *v3;
    v6 = v3[2];
    *(v2 + 512) = 136315906;
    *(v2 + 516) = "aacdecoder_lib.cpp";
    *(v2 + 524) = 1024;
    *(v2 + 526) = 1831;
    *(v2 + 530) = 2080;
    *(v2 + 532) = v5;
    *(v2 + 540) = 1024;
    *(v2 + 542) = v6;
    _os_log_impl(&dword_19AA99000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d USACDecoder internal error in %s, line %d", (v2 + 512), 0x22u);
  }

LABEL_8:
  __cxa_end_catch();
  JUMPOUT(0x19B06FC24);
}

uint64_t aacDecoder_SignalInterruption(uint64_t result)
{
  if ((*(result + 69) & 0x43) != 0)
  {
    v1 = *result;
    if (*result >= 1)
    {
      v2 = 0;
      do
      {
        v3 = *(result + 408 + 8 * v2);
        if (v3)
        {
          v4 = *(*(v3 + 72) + 8);
          if (v4)
          {
            *(v4 + 40) = 0;
            v1 = *result;
          }
        }

        v5 = v2 + 1;
        if (v1 >= 2)
        {
          v6 = 2;
        }

        else
        {
          v6 = v1;
        }

        v7 = v5 < v6;
        v2 = 1;
      }

      while (v7);
    }
  }

  v8 = *(result + 832);
  if (v8)
  {
    v9 = *(v8 + 508);
    if (v9 >= 1)
    {
      v10 = (v8 + 20);
      do
      {
        if (*v8)
        {
          *(v10 - 1) = 1;
          *v10 |= 2u;
        }

        v10 += 240;
        v8 += 8;
        --v9;
      }

      while (v9);
    }
  }

  if (*(result + 1920))
  {
    v11 = *(result + 1912);
    if (v11)
    {
      v12 = *(v11 + 3453);
      v13 = v11 + 4 * v12;
      *(v13 + 3480) |= 0x1000u;
      if (*(v11 + 333) && *(v11 + 3488 + 4 * v12) >= 1)
      {
        *(v11 + 3488 + 4 * v12) = 1;
      }

      else
      {
        *(v13 + 3488) = 0;
      }

      *(v11 + 3484) = 1;
    }
  }

  return result;
}

uint64_t CAacDecoder_DecodeFrame(uint64_t a1)
{
  v1 = MEMORY[0x1EEE9AC00](a1);
  v3 = v2;
  v804 = v4;
  v805 = v5;
  v831 = v6;
  v7 = v1;
  v925 = *MEMORY[0x1E69E9840];
  v8 = *(v1 + 24);
  if (v8[38])
  {
    v9 = v8[27];
    if (v9)
    {
      CDK_put((v8 + 28), v8[26], v9);
    }
  }

  else
  {
    v10 = v8[27];
    v11 = v8[32];
    v12 = v8[31] - v10;
    v8[28] += v10;
    v13 = (v8[37] - 1) & (v11 - v10);
    v8[31] = v12;
    v8[32] = v13;
  }

  v15 = v8 + 28;
  v14 = v8[28];
  *(v8 + 13) = 0;
  v16 = *(v7 + 320);
  v904 = 0;
  if (*v7 < 1)
  {
    return 8199;
  }

  AuBitsRemaining = transportDec_GetAuBitsRemaining(*(v7 + 24));
  if ((v831 & 3) != 0 || AuBitsRemaining > 14)
  {
    v26 = 0;
    v24 = (v7 + 281);
    *(v7 + 284) = 0;
    v25 = v7 + 1936;
    *(v7 + 1980) = 0;
    *(v7 + 1948) = 0u;
    *(v7 + 1964) = 0u;
    if ((v831 & 3) != 0)
    {
      goto LABEL_15;
    }
  }

  else
  {
    *(v7 + 64) = 0;
    v24 = (v7 + 281);
    *(v7 + 284) = 0;
    v25 = v7 + 1936;
    *(v7 + 1980) = 0;
    *(v7 + 1948) = 0u;
    *(v7 + 1964) = 0u;
    v26 = 16388;
  }

  if ((*(v7 + 69) & 3) == 0 && !*(v7 + 332))
  {
    *(v7 + 243) = -1;
    if (!*(v7 + 281))
    {
      *&v28 = -1;
      *(&v28 + 1) = -1;
      *(v7 + 208) = v28;
      *(v7 + 196) = v28;
      *(v7 + 180) = v28;
      *(v7 + 164) = v28;
      *(v7 + 148) = v28;
    }
  }

LABEL_15:
  if (*(v7 + 320) < 1)
  {
    return 8200;
  }

  if (v16 <= 23999)
  {
    if (v16 > 11999)
    {
      if (v16 != 12000 && v16 != 16000)
      {
        v29 = 22050;
        goto LABEL_34;
      }
    }

    else if (v16 != 7350 && v16 != 8000)
    {
      v29 = 11025;
      goto LABEL_34;
    }
  }

  else if (v16 <= 47999)
  {
    if (v16 != 24000 && v16 != 32000)
    {
      v29 = 44100;
      goto LABEL_34;
    }
  }

  else if (v16 > 88199)
  {
    if (v16 != 88200)
    {
      v29 = 96000;
      goto LABEL_34;
    }
  }

  else if (v16 != 48000)
  {
    v29 = 64000;
LABEL_34:
    if (v16 != v29)
    {
      result = 8200;
      if ((*(v7 + 69) & 0x43) == 0 || v16 < 7350)
      {
        return result;
      }
    }
  }

  v876 = v25;
  __A = v14;
  v867 = v24;
  v799 = v3;
  __src = 0;
  v30 = 0;
  v31 = 0;
  __dst = 0;
  *&v32 = 0xAAAAAAAAAAAAAAAALL;
  *(&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(v903 + 12) = v32;
  v794 = (v7 + 148);
  v834 = v7 + 408;
  v902[2] = v32;
  v903[0] = v32;
  v33 = v7 + 243;
  v781 = (v7 + 256);
  v782 = (v7 + 248);
  v785 = (v7 + 780);
  v902[0] = v32;
  v902[1] = v32;
  v806 = v7 + 392;
  v34 = 7;
  LODWORD(v35) = -1;
  memset(v901, 0, 84);
  v870 = v26;
  v827 = v7;
  do
  {
    if ((v831 & 3) != 0)
    {
      __srca = v870;
      goto LABEL_264;
    }

    if (!*(v7 + 64))
    {
      goto LABEL_234;
    }

    v36 = *(v7 + 68);
    if ((v36 & 0x4358) != 0)
    {
      if (v30 >= 0x13)
      {
        *(v7 + 64) = 0;
        v26 = 16386;
        goto LABEL_234;
      }

      v35 = *(v794 + v30);
    }

    else
    {
      v37 = v8[27];
      if (3 - v37 <= 0)
      {
        LOBYTE(v38) = 0;
        v39 = v8[26];
      }

      else
      {
        if (v37 == -29)
        {
          LOBYTE(v38) = 0;
        }

        else
        {
          v38 = v8[26] << (3 - v37);
        }

        v39 = CDK_get32(v15);
        v8[26] = v39;
        v37 = v8[27] + 32;
      }

      v40 = v37 - 3;
      v8[27] = v40;
      v35 = ((v39 >> v40) | v38) & 7;
      v36 = *(v7 + 68);
    }

    _ZF = (v36 & 0x4100) != 0 && v30 == 0;
    v42 = !_ZF;
    if ((v36 & 0x200) != 0 || (v42 & 1) == 0)
    {
      *(v7 + 68) = v36 & 0xFFEFFFFF;
      v43 = v8[27];
      if (v43)
      {
        v44 = v43 - 1;
        v45 = (v8[26] >> v44) & 1;
      }

      else
      {
        v46 = CDK_get32(v15);
        v8[26] = v46;
        v45 = v46 >> 31;
        v44 = 31;
      }

      v8[27] = v44;
      if (v45)
      {
        *(v7 + 68) |= 0x100000u;
      }

      v47 = *(v7 + 4);
      if (v31 < v47)
      {
        v48 = v31;
        v49 = *v7;
        if (v31 > *v7)
        {
          v49 = v31;
        }

        do
        {
          if (v49 == v48)
          {
            return 5;
          }

          if (!*(*(v834 + 8 * v48) + 112) && (*(v7 + 70) & 0x10) == 0)
          {
            *(v7 + 64) = 0;
          }

          ++v48;
        }

        while (v47 > v48);
      }
    }

    v50 = v8[27];
    if (v8[38])
    {
      if (v50)
      {
        CDK_put(v15, v8[26], v50);
      }
    }

    else
    {
      v51 = v8[32];
      v52 = v8[31] - v50;
      v8[28] += v50;
      v53 = (v8[37] - 1) & (v51 - v50);
      v8[31] = v52;
      v8[32] = v53;
    }

    *(v8 + 13) = 0;
    if ((*v15 & 0x80000000) != 0)
    {
      *(v7 + 64) = 0;
    }

    if (v35 <= 7)
    {
      if (v35 <= 3)
      {
        if (v35 >= 2)
        {
          if (v35 == 2)
          {
            *(v7 + 64) = 0;
            v26 = 16392;
            goto LABEL_179;
          }

          if (v35 != 3)
          {
            goto LABEL_105;
          }
        }

LABEL_83:
        if (v30 >= 0x13)
        {
          goto LABEL_84;
        }

        if (((1 << v35) & 0x50009) != 0)
        {
          v54 = 1;
        }

        else if (v35 == 1)
        {
          v54 = 2;
        }

        else if (v35 == 17)
        {
          if (v785[v30] == 1)
          {
            v54 = 1;
          }

          else
          {
            v54 = 2;
          }
        }

        else
        {
          v54 = 0;
        }

        v55 = *(v7 + 4);
        v56 = v901[v35];
        if (v56 >= v55 >> (v54 - 1) || v31 > v55 - v54)
        {
          goto LABEL_105;
        }

        if (!*(v7 + 64))
        {
          goto LABEL_96;
        }

        v57 = v54;
        v860 = v901[v35];
        v864 = v15;
        v58 = *(*(v7 + 1984) + 8 * v30);
        v59 = *(v7 + 68);
        *&v60 = 0xAAAAAAAAAAAAAAAALL;
        *(&v60 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *&v905[16] = v60;
        *&v905[32] = v60;
        *v905 = v60;
        USACBitstreamReader::USACBitstreamReader(v905, (v8 + 26));
        if ((*(*v58 + 24))(v58, v905, v806 + 8 * v31, v834 + 8 * v31, (v59 >> 20) & 1, v7 + 424))
        {
          v7 = v827;
          *(v827 + 64) = 0;
          v15 = v864;
          v26 = 16386;
          v56 = v860;
LABEL_96:
          v61 = v56 + 1;
LABEL_97:
          v901[v35] = v61;
          goto LABEL_179;
        }

        v7 = v827;
        v15 = v864;
        if (*&v905[40])
        {
          USACBitstreamReader::CDKSkipBits(*&v905[32], *&v905[40] - *&v905[24] + 8 * (*v905 - *&v905[8]));
        }

        if (!*(v827 + 64))
        {
          v26 = 0;
          v61 = v860 + 1;
          goto LABEL_97;
        }

        if ((v35 - 16) > 2)
        {
          if (v35 > 3)
          {
            goto LABEL_184;
          }

          v85 = v867;
          v86 = v867[3];
          *(v794 + v86) = v35;
        }

        else
        {
          v85 = v867;
          LOBYTE(v86) = v867[3];
        }

        __src = v86;
        v85[3] = v86 + 1;
LABEL_184:
        *(v902 + __dst) = v35;
        v31 = (v57 + v31);
        v107 = *(v827 + 68);
        if ((v107 & 0x8000) != 0)
        {
          if ((v107 & 0x100) == 0)
          {
LABEL_187:
            v7 = v827;
            if (sbrDecoder_InitElement(*(v827 + 832), *(v827 + 320), *(v827 + 352), *(v827 + 340), *(v827 + 328), v35, __src, 2, 2, v905, *(v827 + 826)))
            {
              *(v827 + 840) = 0;
            }

            v108 = *(v827 + 64);
            v901[v35] = v860 + 1;
            v15 = v864;
            if (!v108)
            {
              v26 = 0;
              ++__dst;
              goto LABEL_179;
            }

            v107 = *(v827 + 68);
            goto LABEL_193;
          }
        }

        else if ((v107 & 0x100) == 0 && *(v827 + 840) == 1)
        {
          goto LABEL_187;
        }

        v901[v35] = v860 + 1;
LABEL_193:
        if ((v107 & 0x100) != 0 && (v35 & 0xFFFFFFFE) == 0x10)
        {
          v62 = aacDecoder_ParseExplicitMpsAndSbr(v7, v8 + 26, v34, __src, v30, v901);
          if (v62)
          {
            v7 = v827;
            *(v827 + 64) = 0;
            ++__dst;
            v15 = v864;
LABEL_104:
            v26 = v62;
            goto LABEL_179;
          }

          ++__dst;
          v7 = v827;
          v15 = v864;
LABEL_166:
          v26 = 0;
        }

        else
        {
          ++__dst;
          v26 = 0;
        }

        goto LABEL_179;
      }

      if (v35 != 4)
      {
        if (v35 == 6)
        {
          v70 = CDK_get32(v15);
          v71 = v8[27];
          v72 = v71 + 28;
          v8[26] = v70;
          v8[27] = v71 + 28;
          v73 = (v70 >> (v71 + 28)) & 0xF;
          if (v73 == 15)
          {
            if (-20 - v71 < 1)
            {
              v74 = 0;
            }

            else
            {
              if (v71 == -52)
              {
                v74 = 0;
              }

              else
              {
                v74 = v70 << (-20 - v71);
              }

              v70 = CDK_get32(v15);
              v8[26] = v70;
              v72 = v8[27] + 32;
            }

            v97 = v72 - 8;
            v8[27] = v97;
            *v905 = 8 * ((v70 >> v97) | v74) + 112;
LABEL_164:
            while (1)
            {
              v98 = CAacDecoder_ExtPayloadParse(v7, v8 + 26, v905, v34, __src, 1);
              if (v98)
              {
                break;
              }

              v7 = v827;
              if (*v905 < 1)
              {
                goto LABEL_166;
              }
            }

            v26 = v98;
            v7 = v827;
            *(v827 + 64) = 0;
          }

          else
          {
            *v905 = 8 * v73;
            if (v73)
            {
              goto LABEL_164;
            }
          }

          goto LABEL_179;
        }

        if (v35 == 7)
        {
          goto LABEL_179;
        }

        goto LABEL_105;
      }

      v63 = CDK_get32(v15);
      v64 = v63;
      v65 = v8[27];
      v66 = v65 + 28;
      v8[26] = v63;
      v8[27] = v65 + 28;
      v67 = -27 - v65;
      v862 = v31;
      if (v67 < 1)
      {
        v865 = 0;
      }

      else
      {
        v68 = v63 << v67;
        if (v66 == -31)
        {
          v69 = 0;
        }

        else
        {
          v69 = v68;
        }

        v865 = v69;
        v64 = CDK_get32(v15);
        v8[26] = v64;
        v66 = v8[27] + 32;
      }

      v77 = v66 - 1;
      v8[27] = v66 - 1;
      if (9 - v66 < 1)
      {
        v78 = 0;
        v79 = v64;
        v80 = v66 - 1;
      }

      else
      {
        if (v66 == -23)
        {
          v78 = 0;
        }

        else
        {
          v78 = v64 << (9 - v66);
        }

        v79 = CDK_get32(v15);
        v8[26] = v79;
        v80 = v8[27] + 32;
      }

      v81 = v80 - 8;
      v8[27] = v80 - 8;
      v82 = ((v79 >> (v80 - 8)) | v78);
      if (v82 == 255)
      {
        if (16 - v80 < 1)
        {
          v83 = 0;
        }

        else
        {
          if (v80 == -16)
          {
            v83 = 0;
          }

          else
          {
            v83 = v79 << (16 - v80);
          }

          v79 = CDK_get32(v15);
          v8[26] = v79;
          v81 = v8[27] + 32;
        }

        v84 = v865;
        v81 -= 8;
        v8[27] = v81;
        v82 = ((v79 >> v81) | v83) + 255;
        v7 = v827;
      }

      else
      {
        v7 = v827;
        v84 = v865;
      }

      v87 = v8[38];
      if ((((v64 >> v77) | v84) & 1) == 0)
      {
        v31 = v862;
        if (!v87)
        {
          goto LABEL_173;
        }

LABEL_171:
        if (v81)
        {
          CDK_put(v15, v8[26], v81);
        }

        goto LABEL_174;
      }

      v31 = v862;
      if (v87)
      {
        if (v81)
        {
          CDK_put(v15, v79, v81);
          v88 = v8[38];
          v89 = v8[28];
          *(v8 + 13) = 0;
          if (!v88)
          {
            goto LABEL_161;
          }
        }

        else
        {
          *(v8 + 13) = 0;
          v89 = *v15;
        }

        CDK_put(v15, 0, (__A - v89) & 7);
        v81 = v8[27];
        if (v8[38])
        {
          goto LABEL_171;
        }

LABEL_173:
        v99 = v8[32];
        v100 = v8[31] - v81;
        v8[28] += v81;
        v101 = (v8[37] - 1) & (v99 - v81);
        v8[31] = v100;
        v8[32] = v101;
LABEL_174:
        *(v8 + 13) = 0;
        v102 = v8[28];
        CAacDecoder_AncDataParse(v876, v8 + 26, v82);
        v103 = v8[27];
        if (v8[38])
        {
          if (v103)
          {
            CDK_put(v15, v8[26], v103);
          }
        }

        else
        {
          v104 = v8[32];
          v105 = v8[31] - v103;
          v8[28] += v103;
          v106 = (v8[37] - 1) & (v104 - v103);
          v8[31] = v105;
          v8[32] = v106;
        }

        *(v8 + 13) = 0;
        CDKpushBiDirectional(v8 + 26, *v15 - v102 + 8 * v82);
        goto LABEL_179;
      }

      v90 = v8[32];
      v91 = v8[31] - v81;
      v89 = v8[28] + v81;
      v8[28] = v89;
      v92 = (v8[37] - 1) & (v90 - v81);
      v8[31] = v91;
      v8[32] = v92;
      *(v8 + 13) = 0;
LABEL_161:
      v81 = 0;
      v93 = (v89 - __A) & 7;
      v94 = v8[32];
      v95 = v8[31] + v93;
      v8[28] = v89 - v93;
      v96 = (v8[37] - 1) & (v94 + v93);
      v8[31] = v95;
      v8[32] = v96;
      goto LABEL_173;
    }

    if (v35 <= 18)
    {
      if ((v35 - 16) < 3)
      {
        goto LABEL_83;
      }

      if (v35 == 8)
      {
        if (v30 >= 0x13)
        {
          goto LABEL_84;
        }

        v62 = aacDecoder_ParseExplicitMpsAndSbr(v7, v8 + 26, v34, __src, v30, v901);
        v7 = v827;
        goto LABEL_104;
      }

LABEL_105:
      *(v7 + 64) = 0;
      v26 = 16388;
      goto LABEL_179;
    }

    if (v35 != 19)
    {
      if (v35 == 20)
      {
        goto LABEL_179;
      }

      goto LABEL_105;
    }

    if (v30 >= 0xA)
    {
LABEL_84:
      *(v7 + 64) = 0;
      v26 = 16386;
      goto LABEL_179;
    }

    v75 = CDK_get32(v15);
    v8[26] = v75;
    v8[27] = 31;
    if (v75 < 0)
    {
      v8[27] = 30;
      if ((v75 & 0x40000000) != 0)
      {
        v76 = *(*(v7 + 800) + 24 * v30 + 30);
      }

      else
      {
        v76 = CDKreadBits(v8 + 26, 8);
        if (v76 == 255)
        {
          v76 = CDKreadBits(v8 + 26, 16) + 253;
        }
      }

      if (v76 >= 1)
      {
        if (*(*(v7 + 800) + 24 * v30 + 32))
        {
          v109 = v8[27];
          if (v109)
          {
            v110 = v109 - 1;
            v8[27] = v110;
            if (!v110)
            {
              v8[26] = CDK_get32(v15);
              v111 = 31;
              goto LABEL_208;
            }
          }

          else
          {
            v8[26] = CDK_get32(v15);
            v110 = 31;
          }

          v111 = v110 - 1;
LABEL_208:
          v8[27] = v111;
        }

        v112 = v31;
        CDKsyncCache(v8 + 26);
        v113 = *v15;
        v114 = 8 * v76;
        if (*(*(v7 + 800) + 24 * v30 + 24) == 4)
        {
          LODWORD(v924[0]) = v114;
          *&v115 = 0xAAAAAAAAAAAAAAAALL;
          *(&v115 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *&v905[16] = v115;
          *&v905[32] = v115;
          *v905 = v115;
          USACBitstreamReader::USACBitstreamReader(v905, (v8 + 26));
          MPEG_D::USAC::DynRangeCompressor::Deserialize(*(v7 + 2136), v905, v924, 3u);
          if (*&v905[40])
          {
            USACBitstreamReader::CDKSkipBits(*&v905[32], *&v905[40] - *&v905[24] + 8 * (*v905 - *&v905[8]));
          }

          v7 = v827;
        }

        CDKsyncCache(v8 + 26);
        v116 = *v15 - v113 + v114;
        if (v116 < 0)
        {
          *(v7 + 64) = 0;
          v26 = 16386;
        }

        CDKpushBiDirectional(v8 + 26, v116);
        v31 = v112;
      }
    }

LABEL_179:
    ++v30;
    v34 = v35;
  }

  while (v35 != 7);
  if (*(v7 + 64) != 1 || !*(v7 + 840))
  {
    goto LABEL_233;
  }

  v117 = *(*(v7 + 832) + 512);
  v118 = *(v7 + 68);
  if (*v7 != v117)
  {
    if ((v118 & 0x100) != 0)
    {
      goto LABEL_227;
    }

    goto LABEL_231;
  }

  if ((v118 & 0x100) == 0)
  {
LABEL_233:
    LODWORD(v35) = 7;
    goto LABEL_234;
  }

LABEL_227:
  v119 = *v785;
  if (v117 != 1 && (v119 - 1) < 2 || (LODWORD(v35) = 7, v117 != 2) && v119 == 3)
  {
LABEL_231:
    *(v7 + 64) = 0;
    if (!v26)
    {
      v26 = 8201;
    }

    goto LABEL_233;
  }

LABEL_234:
  if ((*(v7 + 69) & 0x41) == 0 || *(v7 + 4 * *(v7 + 2048) + 2032))
  {
    v120 = v8[27];
    if (!v8[38])
    {
      v123 = v8[32];
      v124 = v8[31] - v120;
      v122 = v8[28] + v120;
      v8[28] = v122;
      v125 = (v8[37] - 1) & (v123 - v120);
      v8[31] = v124;
      v8[32] = v125;
      *(v8 + 13) = 0;
      goto LABEL_241;
    }

    if (v120)
    {
      CDK_put(v15, v8[26], v120);
      v121 = v8[38];
      v122 = v8[28];
      *(v8 + 13) = 0;
      if (!v121)
      {
LABEL_241:
        v126 = (v122 - __A) & 7;
        v127 = v8[32];
        v128 = v8[31] + v126;
        v8[28] = v122 - v126;
        v129 = (v8[37] - 1) & (v127 + v126);
        v8[31] = v128;
        v8[32] = v129;
        goto LABEL_244;
      }
    }

    else
    {
      v8[26] = 0;
      v122 = *v15;
    }

    CDK_put(v15, 0, (__A - v122) & 7);
  }

LABEL_244:
  v130 = *(v7 + 24);
  if (v130[721] < 1)
  {
    goto LABEL_257;
  }

  v131 = transportDec_GetAuBitsRemaining(v130);
  v132 = v131;
  v133 = *(v7 + 4 * *(v7 + 2048) + 2032);
  if (!v133)
  {
    v134 = *(v7 + 68) & 0x4100;
    if (!v134 || v131 <= 7)
    {
      goto LABEL_251;
    }

    goto LABEL_254;
  }

  v132 = v131 - *(*(v7 + 24) + 2884) + v133;
  v134 = *(v7 + 68) & 0x4100;
  if (v134 && v132 > 7)
  {
    v133 = 1;
    goto LABEL_252;
  }

LABEL_251:
  if (!v134)
  {
LABEL_253:
    if (!v132)
    {
      goto LABEL_257;
    }

LABEL_254:
    *(v7 + 64) = 0;
    if (!v26)
    {
      v26 = 16386;
    }

    CDKpushBiDirectional(v8 + 26, v132);
    goto LABEL_257;
  }

LABEL_252:
  if (v133)
  {
    goto LABEL_253;
  }

LABEL_257:
  if (v35 == 7 || !*(v7 + 64))
  {
    __srca = v26;
    if (*(v7 + 64))
    {
      *(v902 + __dst) = 7;
    }
  }

  else
  {
    if (!v26)
    {
      v26 = 16386;
    }

    __srca = v26;
    *(v7 + 64) = 0;
  }

LABEL_264:
  v135 = 0;
  v136 = 0;
  v137 = 0;
  while (2)
  {
    if ((v831 & 3) != 0)
    {
      v138 = *(v7 + 68);
      goto LABEL_267;
    }

    v138 = *(v7 + 68);
    if (*(v7 + 64))
    {
      if ((v138 & 0x380) != 0)
      {
        v142 = (v7 + v135 + 148);
      }

      else
      {
        v142 = (v902 + v135);
      }

      v141 = *v142;
      if (v141 > 0x12)
      {
        goto LABEL_296;
      }

LABEL_281:
      if (((1 << v141) & 0x50009) != 0)
      {
        v143 = 1;
        goto LABEL_284;
      }

      if (v141 == 1)
      {
        v143 = 2;
        goto LABEL_284;
      }

      if (v141 == 17)
      {
        if (v785[v136] == 1)
        {
          v143 = 1;
        }

        else
        {
          v143 = 2;
        }

LABEL_284:
        v144 = *(*(v827 + 1984) + 8 * v136);
        (*(*v144 + 32))(v144, v806 + 8 * v137, v834 + 8 * v137, v827 + 424);
        v137 += v143;
        v7 = v827;
      }

      else
      {
LABEL_296:
        if (v141 == -1)
        {
          v145 = v136 + 1;
          if (!v137)
          {
            v147 = __srca;
            goto LABEL_307;
          }

          goto LABEL_300;
        }
      }
    }

    else
    {
LABEL_267:
      v139 = *(v7 + 4 * v136 + 148);
      if (v139 == -1)
      {
        v140 = 7;
      }

      else
      {
        v140 = *(v7 + 4 * v136 + 148);
      }

      *(v902 + v136) = v140;
      if ((v138 & 0x380) != 0)
      {
        v141 = v139;
      }

      else
      {
        v141 = v140;
      }

      if ((v831 & 3) == 0 && *(v7 + 64))
      {
        goto LABEL_281;
      }
    }

    v145 = v136 + 1;
    v135 += 4;
    _CF = v141 == 7 || v136++ >= 0x12;
    if (!_CF)
    {
      continue;
    }

    break;
  }

  if (!v137)
  {
    v147 = __srca;
    if ((v831 & 3) != 0)
    {
      v137 = 0;
      goto LABEL_310;
    }

    goto LABEL_307;
  }

LABEL_300:
  v147 = __srca;
  if ((v831 & 3) != 0 || v137 <= *v7)
  {
    goto LABEL_310;
  }

LABEL_307:
  v137 = 0;
  if (!v147)
  {
    v147 = 16388;
  }

  *(v7 + 64) = 0;
LABEL_310:
  if (*(v7 + 64) | v147)
  {
    v148 = v147;
  }

  else
  {
    v148 = 16388;
  }

  if ((v831 & 2) != 0 && *(v7 + 64))
  {
LABEL_315:
    v137 = *(v7 + 812);
    goto LABEL_316;
  }

  if ((v831 & 1) != 0 || !*(v7 + 64))
  {
    v149 = *v7;
    if (*v7 >= 1)
    {
      if (*(v7 + 2026) - 1 > 2)
      {
        goto LABEL_315;
      }

      *(v7 + 812) = v149;
      v137 = v149;
LABEL_316:
      *(v7 + 248) = *(v7 + 816);
      *(v7 + 256) = *(v7 + 824);
      *(v7 + 840) = *(v7 + 841);
    }
  }

  else
  {
    *(v7 + 812) = v137;
    *(v7 + 816) = *(v7 + 248);
    *(v7 + 824) = *(v7 + 256);
    *(v7 + 841) = *(v7 + 840);
  }

  *(v7 + 344) = v137;
  if (v137)
  {
    result = v148;
  }

  else
  {
    result = 5;
  }

  if (result && (result & 0xFFFFF000) != 0x4000)
  {
    return result;
  }

  if (!*(v7 + 332) && !*v867)
  {
    if (v137 >= 7)
    {
      v150 = 0;
    }

    else
    {
      v150 = v137;
    }

    *(v7 + 280) = v150;
  }

  v890 = -1431655766;
  v151 = (v137 - 1);
  if (v137 >= 1)
  {
    for (i = 0; i != v137; *(&v890 + i++) = v153)
    {
      if (v137 == 1)
      {
        LOBYTE(v153) = 0;
      }

      else
      {
        v153 = 0;
        while (i != *(v33 + v153))
        {
          if (v151 == ++v153)
          {
            LOBYTE(v153) = v137 - 1;
            break;
          }
        }
      }
    }
  }

  v784 = result;
  v779 = v137;
  v154 = 0;
  v789 = 0;
  v155 = 0;
  v156 = 0;
  v780 = v7 + 72;
  if (v151 >= 1)
  {
    LODWORD(v151) = 1;
  }

  v788 = v151;
  v783 = v145;
  v157 = vdupq_n_s32(0xBF2E147B);
  v850 = v157;
  while (2)
  {
    v158 = v794;
    if ((*(v7 + 68) & 0x380) == 0)
    {
      v158 = v902;
    }

    v790 = v154;
    v159 = *(v158 + v154);
    if (v159 > 0x12)
    {
      goto LABEL_1058;
    }

    if (((1 << v159) & 0x50009) != 0)
    {
      v160 = 1;
    }

    else if (v159 == 1)
    {
      v160 = 2;
    }

    else
    {
      if (v159 != 17)
      {
        goto LABEL_1058;
      }

      if (v785[v154] == 1)
      {
        v160 = 1;
      }

      else
      {
        v160 = 2;
      }
    }

    v161 = v160 + v789;
    v789 = v161;
    if (v155 >= v161)
    {
      goto LABEL_1058;
    }

    v815 = 0;
    v162 = v155;
    v163 = v156;
    v778 = v161 + v156 - v155;
    v164 = v779;
    if (v779 <= v156)
    {
      v164 = v156;
    }

    v797 = v161;
    v798 = v164;
    v165 = v162;
    v166 = 5952 * v156;
    v167 = v166 + 1940;
    v813 = v166 + 3744;
    v814 = v166 + 3652;
    v811 = v166 + 1536;
    v812 = v166 + 3740;
    while (2)
    {
      if (v163 == v798)
      {
        return 5;
      }

      v168 = v163;
      v169 = *(&v890 + v165);
      v816 = v165;
      if (!*(v7 + 276))
      {
        v173 = *(v7 + 264);
        if (v173)
        {
          if (*(v7 + 272) > *(v7 + 280))
          {
            v174 = v173 + 16 * *(v7 + 280);
            if (*(v174 + 8) > v169)
            {
              LODWORD(v169) = *(*v174 + v169);
            }
          }
        }
      }

      v886 = v169;
      v170 = *(v806 + 8 * v163);
      v849 = *(v834 + 8 * *(&v890 + v163));
      if ((v831 & 2) != 0)
      {
        bzero(*(v170 + 8), (4 * *(v7 + 340)));
      }

      v171 = 0;
      v172 = *(v7 + 64);
      if ((v831 & 1) == 0 && *(v7 + 64))
      {
        v171 = *(v849 + 152) >= 3 && *(v849 + 116) < *(*(v849 + 88) + 268);
      }

      v175 = *(v170 + 32) > *(v170 + 35);
      v176 = *(v170 + 44);
      if (v176 == 3)
      {
        if (*(*(v7 + 424) + 5952 * v168 + 1392))
        {
          v177 = *(v170 + 32) > *(v170 + 35);
        }

        else
        {
          v177 = 0;
        }

        v175 = v177;
      }

      v828 = v167;
      if (!v171 && v175)
      {
        v172 = 0;
        *(v7 + 64) = 0;
      }

      v178 = *(v7 + 340);
      v179 = *(v7 + 424) + 5952 * v168;
      v180 = *(v179 + 1392);
      v181 = (v831 & 1) != 0 || v172 == 0;
      v182 = !v181;
      v822 = v168;
      if (v181)
      {
        v184 = 0;
        v183 = 1;
      }

      else if (*(v849 + 152) < 3)
      {
        v183 = 0;
        v184 = 0;
      }

      else
      {
        v183 = *(v849 + 116) < *(*(v849 + 88) + 268);
        v184 = v183;
      }

      if (*(v849 + 141) == 255)
      {
        *(v849 + 141) = *(v170 + 26);
        if (!v183)
        {
          goto LABEL_394;
        }

LABEL_390:
        v185 = *(v849 + 140);
        if (!v185)
        {
          v185 = 1;
          *(v849 + 140) = 1;
        }

        *(v170 + 44) = v185;
        v186 = v849;
      }

      else
      {
        if (v183)
        {
          goto LABEL_390;
        }

LABEL_394:
        *(v849 + 140) = v176;
        if (v176 == 3 && !*(v179 + 5936))
        {
          goto LABEL_399;
        }

        v187 = *(v170 + 8);
        *(v849 + 144) = *(v170 + 28);
        *(v849 + 141) = *(v170 + 26);
        *(v849 + 148) = *(v170 + 16 + *(v170 + 24) - 1);
        if (*(*(v849 + 88) + 256) <= 1)
        {
          CDKmemcpy(*(v849 + 96), v187, 0x1000uLL);
          v176 = *(v170 + 44);
        }

        if (v176 == 3)
        {
LABEL_399:
          v157 = *(v179 + 1408);
          v18 = *(v179 + 1424);
          v19 = *(v179 + 1440);
          v20 = *(v179 + 1456);
          *(v849 + 216) = v20;
          *(v849 + 200) = v19;
          *(v849 + 184) = v18;
          *(v849 + 168) = v157;
          v157.i32[0] = *(v179 + 4152);
          *(v849 + 232) = v157.i32[0];
        }

        v186 = v849;
        *(v849 + 104) = 0;
      }

      v188 = *(v186 + 88);
      if (v188[64] != 1)
      {
        goto LABEL_433;
      }

      v189 = *(v186 + 152);
      if (!v189)
      {
        if (v182)
        {
          goto LABEL_436;
        }

        v192 = v849;
        *(v849 + 124) = 0;
        *(v849 + 116) = 0;
        *(v849 + 132) = 0;
        if (v188[65] >= 1)
        {
          *(v849 + 152) = 1;
          CConcealment_ApplyFadeOut(0, v849 + 88, v178, v170, v180);
          goto LABEL_434;
        }

LABEL_1050:
        *(v192 + 152) = 3;
        goto LABEL_434;
      }

      if (v182)
      {
        v190 = v849;
        v191 = *(v849 + 116) + 1;
      }

      else
      {
        v191 = 0;
        v190 = v849;
      }

      *(v190 + 116) = v191;
      if (v189 > 2)
      {
        if (v189 == 3)
        {
          if (v191 <= v188[67])
          {
            if (v182)
            {
              *(v849 + 132) = 0;
              *(v849 + 124) = 0;
              goto LABEL_436;
            }

            goto LABEL_434;
          }

          v194 = v188[66];
          _VF = __OFSUB__(v194, 1);
          v196 = v194 - 1;
          if (v196 < 0 == _VF)
          {
            *(v849 + 152) = 2;
            *(v849 + 120) = v196;
            if (v182)
            {
              goto LABEL_436;
            }

            goto LABEL_434;
          }

LABEL_534:
          *(v849 + 152) = 0;
          if (v182)
          {
            goto LABEL_436;
          }

          goto LABEL_434;
        }

        if (v189 != 4)
        {
LABEL_1096:
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "void CConcealment_UpdateState(CConcealmentInfo *, int, CAacDecoderStaticChannelInfo *, const int, CAacDecoderChannelInfo *, UCHAR)";
          exception[2] = 957;
        }

        if (v191 > v188[67])
        {
          if (v188[66] >= 1)
          {
            *(v849 + 152) = 2;
            *(v849 + 120) = findEquiFadeFrame(v188, *(v849 + 120), 0);
            if (v182)
            {
              goto LABEL_436;
            }

            goto LABEL_434;
          }

          goto LABEL_534;
        }

        if (v182)
        {
          *(v849 + 132) = 0;
          *(v849 + 124) = 0;
        }

        if (*(v849 + 120) >= v188[65])
        {
          *(v849 + 152) = 3;
          if (v182)
          {
            goto LABEL_436;
          }

          goto LABEL_434;
        }

        CConcealment_ApplyFadeOut(0, v849 + 88, v178, v170, v180);
LABEL_433:
        if (v182)
        {
          goto LABEL_436;
        }

LABEL_434:
        v198 = *(v170 + 44);
        if (v198 == 1)
        {
          lsf_dec::lsfDecoder::Conceal((v179 + 1408), *(v849 + 140) == 1, *v157.i64, *&v18, *&v19, *&v20, *_Q4.i64, v22, v23);
          v157 = *(v179 + 1408);
          v18 = *(v179 + 1424);
          v19 = *(v179 + 1440);
          v20 = *(v179 + 1456);
          *(v849 + 216) = v20;
          *(v849 + 200) = v19;
          *(v849 + 184) = v18;
          *(v849 + 168) = v157;
          goto LABEL_436;
        }

        goto LABEL_437;
      }

      if (v189 == 1)
      {
        if (v182)
        {
          goto LABEL_422;
        }

        if (*(v849 + 120) >= v188[65])
        {
          *(v849 + 152) = 3;
        }

        else
        {
          *(v849 + 152) = 4;
          CConcealment_ApplyFadeOut(0, v849 + 88, v178, v170, v180);
        }

        goto LABEL_434;
      }

      if (v189 != 2)
      {
        goto LABEL_1096;
      }

      v193 = *(v849 + 120);
      *(v849 + 120) = v193 - 1;
      if (!v182)
      {
        if (v188[65] >= 1)
        {
          *(v849 + 152) = 4;
          EquiFadeFrame = findEquiFadeFrame(v188, v193, 1);
          *(v849 + 132) = 0;
          *(v849 + 124) = 0;
          *(v849 + 120) = EquiFadeFrame - 1;
          CConcealment_ApplyFadeOut(0, v849 + 88, v178, v170, v180);
          goto LABEL_434;
        }

        v192 = v849;
        goto LABEL_1050;
      }

      if (v193 <= 0)
      {
LABEL_422:
        *(v849 + 152) = 0;
      }

LABEL_436:
      v198 = *(v170 + 44);
LABEL_437:
      if (!v183)
      {
        if (!v180 && v198 == 3)
        {
          goto LABEL_463;
        }

LABEL_445:
        if (*(*(v849 + 88) + 256) != 1)
        {
          if ((v182 & 1) == 0)
          {
            bzero(*(v170 + 8), (4 * v178));
            *(v170 + 26) = *(v849 + 141);
          }

          goto LABEL_463;
        }

        if ((v178 - 120) >= 0x389)
        {
          v768 = __cxa_allocate_exception(0x10uLL);
          *v768 = "int CConcealment_ApplyNoise(CConcealmentInfo *, CAacDecoderChannelInfo *, CAacDecoderStaticChannelInfo *, const SamplingRateInfo *, const int, const UINT, UCHAR)";
          v768[2] = 638;
        }

        v201 = *(v849 + 152);
        if (v201 <= 1)
        {
          if (!v201)
          {
            goto LABEL_463;
          }

          if (v201 != 1)
          {
LABEL_1098:
            v777 = __cxa_allocate_exception(0x10uLL);
            *v777 = "int CConcealment_ApplyNoise(CConcealmentInfo *, CAacDecoderChannelInfo *, CAacDecoderStaticChannelInfo *, const SamplingRateInfo *, const int, const UINT, UCHAR)";
            v777[2] = 687;
          }
        }

        else
        {
          if (v201 == 2)
          {
            goto LABEL_463;
          }

          if (v201 == 3)
          {
            v202 = *(v170 + 8);
            *(v170 + 25) = 0;
            *(v170 + 26) = *(v849 + 141);
            if ((*(v849 + 144) - 1) >= 2)
            {
              v203 = 0;
            }

            else
            {
              v203 = 3;
            }

            *(v170 + 28) = v203;
            *(v849 + 144) = v203;
            v204 = 4 * v178;
            bzero(v202, v204);
            v199 = *(v849 + 96);
            v200 = v204;
LABEL_462:
            bzero(v199, v200);
            goto LABEL_463;
          }

          if (v201 != 4)
          {
            goto LABEL_1098;
          }
        }

        CConcealment_ApplyFadeOut(1, v849 + 88, v178, v170, v180);
        goto LABEL_463;
      }

      if (v198 != 3)
      {
        goto LABEL_445;
      }

      v157.i32[0] = *(v849 + 232);
      v18 = *(v849 + 168);
      v19 = *(v849 + 184);
      v20 = *(v849 + 200);
      _Q4 = *(v849 + 216);
      *(v179 + 1456) = _Q4;
      *(v179 + 1440) = v20;
      *(v179 + 1424) = v19;
      *(v179 + 1408) = v18;
      *(v179 + 4152) = v157.i32[0];
      if (v180 || *(v170 + 44) != 3)
      {
        goto LABEL_445;
      }

      v199 = *(v170 + 8);
      *(v170 + 28) = *(v849 + 144);
      *(v170 + 26) = *(v849 + 141);
      if (*(v849 + 152) == 3)
      {
        v200 = 4096;
        goto LABEL_462;
      }

      CDKmemcpy(v199, *(v849 + 96), 0x1000uLL);
LABEL_463:
      v205 = *(v849 + 112);
      *(v849 + 108) = v205;
      *(v849 + 112) = v182;
      v206 = v815;
      if (v184)
      {
        v206 = 1;
      }

      v815 = v206;
      v7 = v827;
      if (*v827 * v799 <= v804)
      {
        v809 = v886 * v799;
        if (*(v827 + 2024) && (v831 & 1) == 0 && *(v827 + 2025) >= 1)
        {
          bzero(&v805[v809], (4 * *(v827 + 340)));
          v207 = v816;
LABEL_532:
          v209 = v828;
          goto LABEL_983;
        }

        v208 = *(v170 + 44);
        v209 = v828;
        if (v208 != 3)
        {
          if (v208 != 1)
          {
            v784 = 5;
            goto LABEL_982;
          }

          if (*(v827 + 64))
          {
            if (v815)
            {
              v210 = 1;
            }

            else
            {
              v210 = v831 & 1;
            }
          }

          else
          {
            v210 = 1;
          }

          v211 = *(v827 + 340);
          v212 = *(v170 + 26);
          v213 = *(v170 + 28);
          v214 = v211;
          switch(v213)
          {
            case 1:
              v887 = v211 >> 3;
              __srcb = 1;
              __Aa = v211;
              v215 = v211;
              break;
            case 2:
              __srcb = 8;
              v215 = v211 >> 3;
              __Aa = v215;
              v887 = v215;
              break;
            case 3:
              v215 = v211 >> 3;
              __srcb = 1;
              __Aa = v211;
              v887 = v211;
              break;
            default:
              v223 = (3 * v211) >> 2;
              if (v212 != 2)
              {
                v223 = 0;
              }

              v224 = v211 - v223;
              v887 = v214 - v223;
              if (*(v849 + 24))
              {
                v215 = v214;
              }

              else
              {
                v215 = v224;
              }

              __srcb = 1;
              __Aa = v214;
              break;
          }

          v225 = &v805[v809];
          v877 = *(v170 + 8);
          v226 = *(v827 + 424) + 5952 * v822;
          if (*(v226 + 1388) == 2)
          {
            __dsta = **(v170 + 64);
            v868 = *(v780 + 4 * v790);
            v227 = 1388;
            if ((v868 & 0x1000) != 0)
            {
              v227 = 1644;
            }

            v871 = v227;
            if ((*(v226 + 1392) | 4) == 4)
            {
              v228 = v210;
              if (v213 == 2)
              {
                v229 = 4;
              }

              else
              {
                v229 = 3;
              }

              v230 = CDKgetWindowSlope(v887, v212);
              v231 = 0;
              *v905 = *(v226 + 1408);
              *&v905[16] = *(v226 + 1424);
              *&v905[32] = *(v226 + 1440);
              *&v905[48] = *(v226 + 1456);
              do
              {
                *&v905[v231] = __cospif (*&v905[v231] * 0.00015625);
                v231 += 4;
              }

              while (v231 != 64);
              lpc_com::lsp2a(v924, v905);
              v232 = v924[0];
              v233 = v924[1];
              v234 = v924[2];
              *(v226 + 4512) = v924[3];
              *(v226 + 4496) = v234;
              *(v226 + 4480) = v233;
              *(v226 + 4464) = v232;
              v235 = fac_dec::facDecoder::Acelp2Mdct((v226 + 4784), v849 + 8, __dsta + v871, v877, __srcb, v214 >> v229, v214, __Aa, 0.0, v230, v887, v226 + 4464, (v226 + 1940), *(v226 + 1400), v228, 1, *(v226 + 1392), 0);
              v225 = &v805[v809];
            }

            else
            {
              v240 = v215;
              v241 = CDKgetWindowSlope(v215, v212);
              v242 = CDKgetWindowSlope(v887, v212);
              v235 = imlt_block((v849 + 8), (__dsta + v871), v877, __srcb, v214, __Aa, v241, v240, 0.0, v242, v887);
            }

            v207 = v816;
            if (v235 != v214)
            {
              v772 = __cxa_allocate_exception(0x10uLL);
              *v772 = "void FrequencyToTime(mdct_t_fl &, float *const, const int16_t, const BOOL, float *const, uint32_t, CIcsInfo, float *const, const int32_t, const int32_t, lpd_dec::lpdDecoder &)";
              v772[2] = 647;
            }

            if ((v868 & 0x1000) == 0)
            {
              memmove(__dsta, v226, 0x56CuLL);
              bpf_dec::bassPostFilter::Configure((v226 + 5336), v214, (v868 >> 11) & 1);
              if (!*(v226 + 1392))
              {
                v243 = (v226 + 5700 + 4 * *(v226 + 5896));
                *v243 = *(v243 - 1);
                v244 = *(v226 + 5896);
                *(v226 + 5792 + 4 * v244) = *(v226 + 5792 + 4 * v244 - 4);
                if (v213 != 2)
                {
                  *(v226 + 5700 + 4 * v244 + 4) = *(v226 + 5700 + 4 * v244);
                  v245 = (v226 + 5792 + 4 * *(v226 + 5896));
                  v245[1] = *v245;
                }
              }

              bpf_dec::bassPostFilter::Process((v226 + 5336), __dsta + 411, v214, (*(v226 + 5908) << 6) + 192, v214 - (*(v226 + 5908) << 6) - 256, v225);
              v207 = v816;
            }
          }

          else
          {
            v236 = v215;
            v237 = CDKgetWindowSlope(v215, v212);
            v238 = CDKgetWindowSlope(v887, v212);
            v239 = imlt_block((v849 + 8), v225, v877, __srcb, v214, __Aa, v237, v236, 1.0, v238, v887);
            v207 = v816;
            if (v239 != v214)
            {
              v771 = __cxa_allocate_exception(0x10uLL);
              *v771 = "void FrequencyToTime(mdct_t_fl &, float *const, const int16_t, const BOOL, float *const, uint32_t, CIcsInfo, float *const, const int32_t, const int32_t, lpd_dec::lpdDecoder &)";
              v771[2] = 682;
            }
          }

          *(v226 + 1388) = v213 == 2;
          *(v226 + 1392) = 255;
          v7 = v827;
          goto LABEL_532;
        }

        v836 = v205 == 0;
        if (*(v827 + 64))
        {
          v835 = (v831 & 1 | v815) == 0;
        }

        else
        {
          v835 = 0;
        }

        v795 = *(v827 + 424);
        v820 = *(v170 + 8);
        v807 = *(v170 + 36);
        v823 = *(v170 + 26);
        *v840 = *(v827 + 340);
        v216 = *(v827 + 56);
        if (v840[0] != 768 && v840[0] != 1024)
        {
          v773 = __cxa_allocate_exception(0x10uLL);
          *v773 = "OSStatus lpd_dec::lpdDecoder::RenderTimeSignal(mdct_t_fl &, uint8_t, float *, const int32_t, const uint8_t, const int32_t, float *const, const int32_t, const uint32_t, BOOL, const BOOL, const uint32_t)";
          v773[2] = 369;
        }

        v217 = v795 + 5952 * v822;
        if ((v831 & 2) != 0)
        {
          *(v217 + 1408) = lpd_rom::cdk_dec_lsf_init[0];
          *(v217 + 1424) = unk_19B3D5EF8;
          *(v217 + 1440) = xmmword_19B3D5F08;
          *(v217 + 1456) = unk_19B3D5F18;
          *(v217 + 5396) = 0u;
          *(v217 + 5412) = 0u;
          *(v217 + 5428) = 0u;
          *(v217 + 5444) = 0u;
          *(v217 + 5460) = 0u;
          *(v217 + 5476) = 0u;
          *(v217 + 5492) = 0u;
          *(v217 + 5508) = 0u;
          *(v217 + 5524) = 0u;
          *(v217 + 5540) = 0u;
          *(v217 + 5556) = 0u;
          *(v217 + 5572) = 0u;
          *(v217 + 5588) = 0u;
          *(v217 + 5604) = 0u;
          *(v217 + 5620) = 0u;
          *(v217 + 5636) = 0u;
          *(v217 + 5652) = 0u;
          *(v217 + 5668) = 0u;
          *(v217 + 5684) = 0u;
          *(v217 + 5337) = 0;
          memset_pattern16((v217 + 5340), "@", 0x1CuLL);
          v835 = 0;
          v157.i64[0] = 0;
          *(v217 + 5368) = 0u;
          *(v217 + 5392) = 0;
          *(v217 + 5384) = 0;
          *(v217 + 3720) = 0u;
          *(v217 + 3736) = 0;
          *(v217 + 4020) = 64;
          *(v217 + 4022) = 0;
          *(v217 + 4128) = 0;
          *(v217 + 4284) = 256;
          *(v217 + 1400) = 0;
          *(v217 + 1404) = 0;
        }

        __srcc = (v795 + 5952 * v822);
        if (*(v217 + 1388) >= 2u)
        {
          v218 = *(v217 + 1392);
        }

        else
        {
          v218 = 255;
          *(v217 + 1392) = 255;
        }

        if (v835)
        {
          if (v218 == 4 && *(v217 + 5924) >= 1)
          {
            v219 = *(v217 + 4288);
            v220 = *(v217 + 4304);
            v221 = *(v217 + 4320);
            *(v217 + 4512) = *(v217 + 4336);
            *(v217 + 4496) = v221;
            *(v217 + 4480) = v220;
            *(v217 + 4464) = v219;
          }

          goto LABEL_547;
        }

        *(v217 + 5920) = v218;
        v222 = (v217 + 5924);
        switch(v218)
        {
          case 3:
            v157.i64[0] = 0x300000003;
            v157.i64[1] = 0x300000003;
            break;
          case 2:
            v157.i64[0] = 0x200000002;
            v157.i64[1] = 0x200000002;
            break;
          case 0:
            *v222 = 0;
            *(v217 + 5932) = 0;
            goto LABEL_540;
          default:
            v157.i64[0] = 0x400000004;
            v157.i64[1] = 0x400000004;
            break;
        }

        *v222 = v157;
LABEL_540:
        lsf_dec::lsfDecoder::Conceal((v217 + 1408), v218 == 255, *v157.i64, *&v18, *&v19, *&v20, *_Q4.i64, v22, v23);
        if ((*(v217 + 1392) - 1) <= 0xFD)
        {
          v246 = *(v217 + 4288);
          v247 = *(v217 + 4304);
          v248 = *(v217 + 4320);
          *(v217 + 4512) = *(v217 + 4336);
          *(v217 + 4496) = v248;
          *(v217 + 4480) = v247;
          *(v217 + 4464) = v246;
        }

        v249 = 0;
        v250 = *(v217 + 4152);
        do
        {
          *(v217 + 4440 + 4 * v249) = v250;
          v251 = *(v222 + v249);
          v177 = v251 <= 1;
          v252 = 1 << (v251 - 1);
          if (v177)
          {
            v252 = 1;
          }

          v249 += v252;
        }

        while (v249 < 4);
LABEL_547:
        memset(v906, 255, 0x1800uLL);
        memcpy(v905, v217, sizeof(v905));
        bpf_dec::bassPostFilter::Configure((v217 + 5336), v840[0], 0);
        v253 = 0;
        v847 = 0;
        v254 = (34 * v216 + 6400) / 0x3200u;
        v841 = v840[0] >> 2;
        v819 = 2 * v807;
        v255 = v840[0] >> 2;
        v256 = v836;
        *(v217 + 1400) |= v836;
        v257 = (v217 + 5924);
        v810 = (v217 + 4784);
        LODWORD(v258) = v840[0] / 2;
        if (v840[0] <= 857)
        {
          v258 = v258;
        }

        else
        {
          v258 = 428;
        }

        v808 = v258;
        v796 = &v924[4] + (428 - v258);
        v833 = v217 + 4464;
        v839 = (v217 + 1940);
        v787 = (v217 + 1940 + 4 * v255);
        v821 = v217 + 1920;
        v829 = v217 + 5700;
        v826 = v217 + 5792;
        __dstb = &lpd_rom::lsp_interpol_factor_fl + 16 * ((v840[0] >> 8) & 1);
        v832 = v217 + 4440;
        v259 = -(v840[0] >> 2);
        v800 = v217 + 5296;
        v818 = 6 * v254 + 27;
        v838 = (v217 + 3652);
        v872 = ((v255 - 1) >> 6) + 1;
        v792 = (v795 + v814 + 4 * v259);
        v793 = (&v924[107] + 4 * v259);
        v786 = 1712 - 4 * v255;
        v803 = v217 + 3738;
        v825 = v924 + 4 * v255;
        v824 = (&v896 + 4 * v255);
        v869 = v840[0] >> 8;
        v855 = (v840[0] >> 8) - 3;
        v801 = (&v896 + 4 * v255);
        v802 = v924 + 4 * v255;
        v791 = (428 - v258);
        v260 = (v795 + 5952 * v822);
        v830 = v840[0] >> 1;
        v817 = v795 + v811;
        v842 = (__srcc + 5924);
LABEL_551:
        v261 = *(v260 + 351);
        if (v835)
        {
          v262 = 0;
        }

        else
        {
          v262 = v261 + 1;
        }

        if (v261)
        {
          v263 = v835;
        }

        else
        {
          v263 = 0;
        }

        v256 |= v263;
        *(v260 + 351) = v262;
        v264 = v253;
        v265 = *&v257[4 * v253];
        v844 = v253;
        v846 = v253;
        if ((v265 | 4) != 4)
        {
          v268 = tcx_dec::lg_table_ccfl[4 * (v840[0] == 768) + v265];
          if ((*(v260 + 348) | 4) == 4)
          {
            v269 = CDKgetWindowSlope(v841, v823);
            v260 = (v795 + 5952 * v822);
            v270 = fac_dec::facDecoder::Acelp2Mdct(v810, v849 + 8, &v906[v847], (v820 + 4 * v819 * v844), 1, v807, v840[0] - v847, v268, *(v832 + 4 * v846), v269, v841, v833 + (v846 << 6), v839, v256 != 0, 0, 0, *(__srcc + 348), v844);
            v271 = v844;
            v272 = *(v260 + 1474) + *(v260 + 1472) * v844;
            v273 = 4 * v272 - 4;
            v274 = *(v829 + v273);
            *(v829 + 4 * v272) = v274;
            v275 = 4 * v272 + 4;
            *(v829 + v275) = v274;
            v276 = *(v826 + v273);
            *(v826 + 4 * v272) = v276;
            *(v826 + v275) = v276;
          }

          else
          {
            v260 = (v795 + 5952 * v822);
            v289 = CDKgetWindowSlope(v841, v823);
            v290 = CDKgetWindowSlope(v841, v823);
            v270 = imlt_block((v849 + 8), &v906[v847], (v820 + 4 * v819 * v844), 1u, v840[0] - v847, v268, v289, v841, *(v832 + 4 * v846), v290, v841);
            v271 = v844;
          }

          v847 += v270;
          v291 = *(v260 + 348);
          v257 = __srcc + 5924;
          v292 = v846;
          goto LABEL_877;
        }

        v266 = v847;
        v837 = v256;
        if ((*(v260 + 348) | 4) == 4)
        {
          v267 = *(v849 + 36);
          if (!v253 && v267 != v830)
          {
            *(v849 + 36) = v830;
            v267 = v840[0] >> 1;
          }

          if (v840[0] - v847 < 1)
          {
            v267 = 0;
          }

          else
          {
            if (v267 > v840[0] - v847)
            {
              v763 = __cxa_allocate_exception(0x10uLL);
              *v763 = "INT imdct_drain(H_MDCT_FL, FLOAT *, INT)";
              v763[2] = 69;
            }

            if (v267 < 1)
            {
              v257 = __srcc + 5924;
            }

            else
            {
              CDKmemcpy(&v906[v847], *(v849 + 8), (4 * v267));
              *(v849 + 36) = 0;
              v257 = __srcc + 5924;
              v266 = v847;
            }

            v264 = v846;
          }

          v293 = v267 + v266;
          v294 = __srcc + 1940;
          goto LABEL_596;
        }

        if (v256)
        {
          v277 = 0;
        }

        else
        {
          v277 = v835;
        }

        v278 = *(v260 + 347);
        v280 = v253 < 1 && v278 == 1;
        v281 = v840[0] >> 3 >> v280;
        if (v253)
        {
          v282 = 1;
        }

        else
        {
          v282 = v278 == 2;
        }

        v283 = !v282;
        if (v281 >= 0x81)
        {
          v765 = __cxa_allocate_exception(0x10uLL);
          *v765 = "int32_t fac_dec::facDecoder::Mdct2Acelp(mdct_t_fl &, float *const, const int32_t, const int32_t, const simd_float16 &, const int32_t, const int32_t, const int32_t, const uint8_t)";
          v765[2] = 161;
        }

        v284 = v281;
        v285 = 2 * v281;
        LODWORD(v924[0]) = 2 * v281;
        v286 = CDKgetWindowSlope(2 * v281, 0);
        v287 = v840[0] - v847;
        if (*(v849 + 32) != v285)
        {
          LODWORD(v896) = 0;
          imdct_adapt_parameters(v849 + 8, v924, &v896, v286, v840[0] - v847);
          if (v896)
          {
            v767 = __cxa_allocate_exception(0x10uLL);
            *v767 = "int32_t fac_dec::facDecoder::Mdct2Acelp(mdct_t_fl &, float *const, const int32_t, const int32_t, const simd_float16 &, const int32_t, const int32_t, const int32_t, const uint8_t)";
            v767[2] = 170;
          }
        }

        if (v287 < 1)
        {
          v288 = 0;
        }

        else
        {
          v288 = *(v849 + 36);
          if (v288)
          {
            memmove(&v906[v847], *(v849 + 8), 4 * v288);
          }

          *(v849 + 36) = 0;
        }

        v600 = v283;
        v601 = *(v849 + 8);
        v602 = *(v849 + 40);
        if (v288 >= v287)
        {
          v606 = *(v849 + 36);
          v603 = (v601 + 4 * v606);
          v604 = *(v849 + 28);
          v605 = v924[0];
          *(v849 + 36) = v604 + v606 + SLODWORD(v924[0]) / 2;
        }

        else
        {
          v603 = &v906[v847 + v288];
          v604 = *(v849 + 28);
          v605 = v924[0];
          v288 += v604 + SLODWORD(v924[0]) / 2;
        }

        v607 = (v601 + 4 * v602 - 4);
        if (v604 >= 1)
        {
          do
          {
            v608 = *v607--;
            *v603 = -v608;
            v603 = (v603 + 4);
            --v604;
          }

          while (v604);
        }

        v609 = v833 + (v846 << 6);
        *(v849 + 28) = 0;
        if (v277)
        {
          v610 = *(v800 + 8 * v846);
          if (!v610)
          {
            *(__srcc + 329) = 0u;
            *(__srcc + 330) = 0u;
            *(__srcc + 327) = 0u;
            *(__srcc + 328) = 0u;
            *(__srcc + 325) = 0u;
            *(__srcc + 326) = 0u;
            *(__srcc + 323) = 0u;
            *(__srcc + 324) = 0u;
            *(__srcc + 321) = 0u;
            *(__srcc + 322) = 0u;
            *(__srcc + 319) = 0u;
            *(__srcc + 320) = 0u;
            *(__srcc + 317) = 0u;
            *(__srcc + 318) = 0u;
            *(__srcc + 315) = 0u;
            *(__srcc + 316) = 0u;
            *(__srcc + 313) = 0u;
            *(__srcc + 314) = 0u;
            *(__srcc + 311) = 0u;
            *(__srcc + 312) = 0u;
            *(__srcc + 309) = 0u;
            *(__srcc + 310) = 0u;
            *(__srcc + 307) = 0u;
            *(__srcc + 308) = 0u;
            *(__srcc + 305) = 0u;
            *(__srcc + 306) = 0u;
            *(__srcc + 303) = 0u;
            *(__srcc + 304) = 0u;
            *(__srcc + 301) = 0u;
            *(__srcc + 302) = 0u;
            v610 = (__srcc + 4784);
            *v810 = 0u;
            *(__srcc + 300) = 0u;
            *(v800 + 8 * v846) = v810;
          }

          fac_dec::facDecoder::CalcFacSignal(v603, v610, v284, v609, v600);
          v605 = v924[0];
        }

        else if (v284)
        {
          bzero(v603, (4 * v284));
        }

        if (v605 < 2)
        {
          v616 = v849;
          if (*(v849 + 56))
          {
            goto LABEL_906;
          }
        }

        else
        {
          v611 = (v605 / 2);
          v612 = v611;
          do
          {
            v613 = *v607--;
            v614 = v613;
            v615 = *v286;
            v286 += 2;
            *v603 = *v603 - (v614 * v615);
            v603 = (v603 + 4);
            --v612;
          }

          while (v612);
          v616 = v849;
          v617 = *(v849 + 56);
          if (v617)
          {
            v618 = -4 * v611;
            do
            {
              v619 = *v617++;
              *(v603 + v618) = v619 + *(v603 + v618);
              v618 += 4;
              --v611;
            }

            while (v611);
LABEL_906:
            *(v616 + 56) = 0;
          }
        }

        *(v616 + 32) = 0;
        *(v616 + 24) = 0;
        v620 = *(v616 + 36);
        v621 = v795 + 5952 * v822;
        if (v620)
        {
          memmove(&v906[v288 + v847], *(v616 + 8), 4 * v620);
        }

        v848 = v288 + v847;
        v622 = &v906[(v840[0] >> 1) + (v844 * v841)];
        v623 = *(__srcc + 348);
        if (*(__srcc + 349) == 4)
        {
          v624 = 0;
        }

        else
        {
          v624 = *(__srcc + 349);
        }

        v625 = -1 << (v623 - 1);
        if (v623 <= 1)
        {
          v625 = -1;
        }

        v626 = (v625 + v844);
        _NF = v626 < 0;
        v627 = (v833 + (v626 << 6));
        if (_NF)
        {
          v627 = (__srcc + 4352);
        }

        if (v623 == 255)
        {
          v628 = (__srcc + 4464);
        }

        else
        {
          v628 = v627;
        }

        v629 = v842[v846];
        memset(v924, 255, 0x6F0uLL);
        if (v629 == 4)
        {
          memcpy(v924, v622 - 444, 0x6F0uLL);
          v630 = *(v622 - 1);
          *(__srcc + 932) = v630;
          v631 = v828;
        }

        else
        {
          v632 = &v900[(v840[0] >> 1) + 206 + (v844 * v841)];
          v633 = v924;
          v634 = 444;
          v631 = v828;
          do
          {
            v635 = *(v632 + 4);
            v636 = *v632++;
            *v633++ = vmlaq_f32(v635, v850, v636);
            v634 -= 4;
          }

          while (v634);
          v630 = *(v622 - 1);
          v621 = v795 + 5952 * v822;
        }

        *(v621 + 3716) = v630;
        *v838 = v924[107];
        *(__srcc + 3668) = v924[108];
        *(__srcc + 3684) = v924[109];
        *(__srcc + 3700) = v924[110];
        if (v623 == 1)
        {
          v294 = __srcc + 1940;
          if (v624)
          {
            v260 = (v795 + 5952 * v822);
            if (v624 >= 1)
            {
              v637 = vrev64q_s32(*v628);
              v638 = vextq_s8(v637, v637, 8uLL);
              v639 = vrev64q_s32(v628[1]);
              v640 = vextq_s8(v639, v639, 8uLL);
              v641 = vrev64q_s32(v628[2]);
              v642 = vextq_s8(v641, v641, 8uLL);
              v643 = vrev64q_s32(v628[3]);
              v644 = vextq_s8(v643, v643, 8uLL);
              v645 = &v924[4];
              v646 = v795;
              v647 = (428 - (v840[0] >> 2));
              do
              {
                v648 = vaddq_f32(vaddq_f32(vmulq_f32(v644, *(v645 - 16)), vmulq_f32(v640, *(v645 - 8))), vaddq_f32(vmulq_f32(v642, *(v645 - 12)), vmulq_f32(v638, *(v645 - 4))));
                *(v646 + v631) = *v645 + vaddv_f32(vadd_f32(*v648.i8, *&vextq_s8(v648, v648, 8uLL)));
                v646 += 4;
                ++v645;
                --v647;
              }

              while (v647);
            }

LABEL_943:
            v257 = __srcc + 5924;
            v293 = v848;
            v264 = v846;
            v687 = vrev64q_s32(*v609);
            v680 = vextq_s8(v687, v687, 8uLL);
            v688 = vrev64q_s32(*(v609 + 16));
            v682 = vextq_s8(v688, v688, 8uLL);
            v689 = vrev64q_s32(*(v609 + 32));
            v684 = vextq_s8(v689, v689, 8uLL);
            v690 = vrev64q_s32(*(v609 + 48));
            v686 = vextq_s8(v690, v690, 8uLL);
          }

          else
          {
            v260 = (v795 + 5952 * v822);
            if ((v840[0] & 0xFFFFFFFC) != 0x6B0)
            {
              memmove(v839, v787, v786);
              goto LABEL_943;
            }

            v679 = vrev64q_s32(*v609);
            v680 = vextq_s8(v679, v679, 8uLL);
            v681 = vrev64q_s32(*(v609 + 16));
            v682 = vextq_s8(v681, v681, 8uLL);
            v683 = vrev64q_s32(*(v609 + 32));
            v684 = vextq_s8(v683, v683, 8uLL);
            v685 = vrev64q_s32(*(v609 + 48));
            v686 = vextq_s8(v685, v685, 8uLL);
            v257 = __srcc + 5924;
            v293 = v848;
            v264 = v846;
          }

          v692 = v792;
          v691 = v793;
          v693 = (v840[0] >> 2);
          do
          {
            v694 = vaddq_f32(vaddq_f32(vmulq_f32(v686, *v691), vmulq_f32(v682, v691[2])), vaddq_f32(vmulq_f32(v684, v691[1]), vmulq_f32(v680, v691[3])));
            *v692++ = v691[4].f32[0] + vaddv_f32(vadd_f32(*v694.i8, *&vextq_s8(v694, v694, 8uLL)));
            v691 = (v691 + 4);
            --v693;
          }

          while (v693);
          goto LABEL_596;
        }

        v294 = __srcc + 1940;
        if (v808 > 427)
        {
          v669 = vrev64q_s32(*v609);
          v662 = vextq_s8(v669, v669, 8uLL);
          v670 = vrev64q_s32(*(v609 + 16));
          v664 = vextq_s8(v670, v670, 8uLL);
          v671 = vrev64q_s32(*(v609 + 32));
          v666 = vextq_s8(v671, v671, 8uLL);
          v672 = vrev64q_s32(*(v609 + 48));
          v668 = vextq_s8(v672, v672, 8uLL);
          v260 = (v795 + 5952 * v822);
          v257 = __srcc + 5924;
          v293 = v848;
          v264 = v846;
        }

        else
        {
          v649 = vrev64q_s32(*v628);
          v650 = vextq_s8(v649, v649, 8uLL);
          v651 = vrev64q_s32(v628[1]);
          v652 = vextq_s8(v651, v651, 8uLL);
          v653 = vrev64q_s32(v628[2]);
          v654 = vextq_s8(v653, v653, 8uLL);
          v655 = vrev64q_s32(v628[3]);
          v656 = vextq_s8(v655, v655, 8uLL);
          v657 = &v924[4];
          v658 = (v795 + v828);
          v659 = v791;
          v260 = (v795 + 5952 * v822);
          v257 = __srcc + 5924;
          v293 = v848;
          v264 = v846;
          do
          {
            v660 = vaddq_f32(vaddq_f32(vmulq_f32(v656, *(v657 - 16)), vmulq_f32(v652, *(v657 - 8))), vaddq_f32(vmulq_f32(v654, *(v657 - 12)), vmulq_f32(v650, *(v657 - 4))));
            *v658++ = *v657++ + vaddv_f32(vadd_f32(*v660.i8, *&vextq_s8(v660, v660, 8uLL)));
            --v659;
          }

          while (v659);
          if (v808 < 1)
          {
            goto LABEL_596;
          }

          v661 = vrev64q_s32(*v609);
          v662 = vextq_s8(v661, v661, 8uLL);
          v663 = vrev64q_s32(*(v609 + 16));
          v664 = vextq_s8(v663, v663, 8uLL);
          v665 = vrev64q_s32(*(v609 + 32));
          v666 = vextq_s8(v665, v665, 8uLL);
          v667 = vrev64q_s32(*(v609 + 48));
          v668 = vextq_s8(v667, v667, 8uLL);
        }

        v674 = v795 + 4 * v791;
        v673 = v796;
        v675 = v808;
        do
        {
          v676 = vaddq_f32(vaddq_f32(vmulq_f32(v668, *(v673 - 16)), vmulq_f32(v664, *(v673 - 8))), vaddq_f32(vmulq_f32(v666, *(v673 - 12)), vmulq_f32(v662, *(v673 - 4))));
          *(v674 + v631) = *v673 + vaddv_f32(vadd_f32(*v676.i8, *&vextq_s8(v676, v676, 8uLL)));
          v674 += 4;
          ++v673;
          --v675;
        }

        while (v675);
LABEL_596:
        if (v293 >= v840[0])
        {
          v295 = *(v849 + 36);
          v856 = (*(v849 + 8) + 4 * v295);
          *(v849 + 36) = v295 + v841;
        }

        else
        {
          v856 = &v906[v293];
          v293 += v841;
        }

        v847 = v293;
        if (*&v257[4 * v264] == 4)
        {
          v260[933] = *(v832 + 4 * v264);
          v296 = *(v260 + 2142);
          v297 = *(v260 + 351) < 2;
          memset(v900, 255, sizeof(v900));
          v298 = *(__srcc + 3668);
          v896 = *v838;
          v897 = v298;
          v299 = *(__srcc + 3700);
          v898 = *(__srcc + 3684);
          v899 = v299;
          memset(&v924[107], 255, 0x400uLL);
          memcpy(v924, v294, 0x6B0uLL);
          v891 = flt_19B0B04E8[v297];
          if (v296 >= 411)
          {
            v300 = 411;
          }

          else
          {
            v300 = v296;
          }

          MEMORY[0x19EAE6090](&v924[107] - 4 * v300, 1, &v891, &v924[107], 1, v840[0] >> 2);
          v260[933] = v891 * v260[933];
          v301 = HIDWORD(v924[106]);
          v260[932] = *(&v924[106] + 3);
          memset(v923 + 4, 255, 0x400uLL);
          LODWORD(v923[0]) = v301;
          v302 = v900;
          if (v855 > 1)
          {
            v766 = __cxa_allocate_exception(0x10uLL);
            *v766 = "simd_float16 lpc_com::intLpc(const array<float, kLpFilterOrder> &, const array<float, kLpFilterOrder> &, const int32_t, const int32_t)";
            v766[2] = 131;
          }

          v303 = 0;
          v304 = 0;
          v305 = v924;
          v306 = v923;
          v307 = &v896;
          v308 = v923 + 4;
          do
          {
            v309 = 0;
            *&v310 = -1;
            *(&v310 + 1) = -1;
            v910 = v310;
            v909 = v310;
            v908 = v310;
            v907 = v310;
            v311 = &__dstb[4 * v303];
            *v888 = v303;
            v312 = &__dstb[4 * v869 + 4 * ~v303];
            v313 = vld1q_dup_f32(v311);
            v314 = vld1q_dup_f32(v312);
            do
            {
              *(&v907 + v309) = vmlaq_f32(vmulq_f32(v313, *(v817 + ((v844 + 1) << 6) + v309)), v314, *(v817 + (v846 << 6) + v309));
              v309 += 16;
            }

            while (v309 != 64);
            lpc_com::lsp2a(&v892, &v907);
            v315 = v895;
            v316 = v894;
            v317 = v893;
            v318 = v892;
            v319 = &v900[v304];
            v320 = vrev64q_s32(v892);
            v321 = vextq_s8(v320, v320, 8uLL);
            v322 = vrev64q_s32(v893);
            v323 = vextq_s8(v322, v322, 8uLL);
            v324 = vrev64q_s32(v894);
            v325 = vextq_s8(v324, v324, 8uLL);
            v326 = vrev64q_s32(v895);
            v327 = vextq_s8(v326, v326, 8uLL);
            v328 = v302;
            for (j = 1712; j != 1968; j += 4)
            {
              v330 = vaddq_f32(vaddq_f32(vmulq_f32(v327, *(v328 - 16)), vmulq_f32(v323, *(v328 - 8))), vaddq_f32(vmulq_f32(v325, *(v328 - 12)), vmulq_f32(v321, *(v328 - 4))));
              *v328++ = *(v305 + j) - vaddv_f32(vadd_f32(*v330.i8, *&vextq_s8(v330, v330, 8uLL)));
            }

            v331 = 0;
            *&v332 = -1;
            *(&v332 + 1) = -1;
            v922 = v332;
            v921 = v332;
            v333.i32[1] = 1062776236;
            v920 = v332;
            v919 = v332;
            v918 = v332;
            v917 = v332;
            v916 = v332;
            v915 = v332;
            v914 = v332;
            v913 = v332;
            v912 = v332;
            v334 = vrev64q_s32(vmulq_f32(v318, xmmword_19B0B3620));
            v911 = v332;
            v335 = vextq_s8(v334, v334, 8uLL);
            v336 = vrev64q_s32(vmulq_f32(v317, xmmword_19B0B3610));
            v910 = v332;
            v337 = vextq_s8(v336, v336, 8uLL);
            v909 = v332;
            v338 = vrev64q_s32(vmulq_f32(v316, xmmword_19B0B3600));
            v339 = vextq_s8(v338, v338, 8uLL);
            v908 = v332;
            v340 = vrev64q_s32(vmulq_f32(v315, xmmword_19B0B35F0));
            v341 = vextq_s8(v340, v340, 8uLL);
            v342 = v302;
            v907 = v332;
            do
            {
              v343 = vaddq_f32(vaddq_f32(vmulq_f32(v341, *(v342 - 16)), vmulq_f32(v337, *(v342 - 8))), vaddq_f32(vmulq_f32(v339, *(v342 - 12)), vmulq_f32(v335, *(v342 - 4))));
              v344 = vadd_f32(*v343.i8, *&vextq_s8(v343, v343, 8uLL));
              *(&v907 + v331++) = *v342++ + vaddv_f32(v344);
            }

            while (v331 != 64);
            v345 = 0;
            v333.i32[0] = *(__srcc + 932);
            do
            {
              *v333.i32 = *(&v907 + v345) + (*v333.i32 * 0.68);
              *&v308[v345] = v333.i32[0];
              v345 += 4;
            }

            while (v345 != 256);
            v346 = 0;
            if (fabsf(*v333.i32) < 1.0e-10)
            {
              *v333.i32 = 0.0;
            }

            *(__srcc + 932) = v333.i32[0];
            v333.i32[0] = *(__srcc + 933);
            *v344.i32 = -*v333.i32;
            v347 = vdupq_lane_s32(v333, 0);
            v348 = vdupq_lane_s32(v344, 0);
            do
            {
              *&v308[v346] = vbslq_s8(vcgtq_f32(*&v308[v346], v347), v347, vbslq_s8(vcgtq_f32(v348, *&v308[v346]), v348, *&v308[v346]));
              v346 += 16;
            }

            while (v346 != 256);
            for (k = 0; k != 16; ++k)
            {
              *(&v907 + k * 16) = vmlaq_f32(*(&v306[k] + 4), v850, v306[k]);
            }

            for (m = 0; m != 256; m += 4)
            {
              v351 = vaddq_f32(vaddq_f32(vmulq_f32(v341, *(v307 + m)), vmulq_f32(v337, *(v307 + m + 32))), vaddq_f32(vmulq_f32(v339, *(v307 + m + 16)), vmulq_f32(v335, *(v307 + m + 48))));
              v302[m / 4] = *(&v907 + m) - vaddv_f32(vadd_f32(*v351.i8, *&vextq_s8(v351, v351, 8uLL)));
            }

            v352 = v319[13];
            v353 = &v856[v304];
            v304 += 64;
            *(v353 + 12) = v319[12];
            *(v353 + 13) = v352;
            v354 = v319[15];
            *(v353 + 14) = v319[14];
            *(v353 + 15) = v354;
            v355 = v319[9];
            *(v353 + 8) = v319[8];
            *(v353 + 9) = v355;
            v356 = v319[11];
            *(v353 + 10) = v319[10];
            *(v353 + 11) = v356;
            v357 = v319[5];
            *(v353 + 4) = v319[4];
            *(v353 + 5) = v357;
            v358 = v319[7];
            *(v353 + 6) = v319[6];
            *(v353 + 7) = v358;
            v359 = v319[1];
            *v353 = *v319;
            *(v353 + 1) = v359;
            v303 = *v888 + 1;
            v302 += 64;
            v305 += 16;
            v360 = v319[3];
            v308 += 256;
            v306 += 16;
            v307 += 16;
            *(v353 + 2) = v319[2];
            *(v353 + 3) = v360;
          }

          while (*v888 + 1 != v872);
          v260 = (v795 + 5952 * v822);
          v361 = *(__srcc + 932);
          memcpy(v839, v825, 0x6B0uLL);
          v362 = v824[1];
          *v838 = *v824;
          *(__srcc + 3668) = v362;
          v363 = v824[3];
          *(__srcc + 3684) = v824[2];
          *(__srcc + 3700) = v363;
          *(v260 + 929) = v361;
          goto LABEL_875;
        }

        v364 = *(v821 + 4 * v264);
        if (v364 < 0.0)
        {
          v762 = __cxa_allocate_exception(0x10uLL);
          *v762 = "OSStatus lpd_dec::lpdDecoder::RenderTimeSignal(mdct_t_fl &, uint8_t, float *, const int32_t, const uint8_t, const int32_t, float *const, const int32_t, const uint32_t, BOOL, const BOOL, const uint32_t)";
          v762[2] = 512;
        }

        v365 = *(v260 + 351);
        v366 = *(v260 + 1400);
        v367 = *(v260 + 1472);
        v368 = *(v260 + 1474);
        memset(v900, 255, sizeof(v900));
        v369 = *(__srcc + 3668);
        v896 = *v838;
        v897 = v369;
        v370 = *(__srcc + 3700);
        v898 = *(__srcc + 3684);
        v899 = v370;
        memcpy(v924, v294, 0x6B0uLL);
        bzero(&v924[107], 0x408uLL);
        *(v260 + 1022) = v844;
        *&v371 = -1;
        *(&v371 + 1) = -1;
        *(v260 + 514) = -1;
        *(v260 + 1027) = v818;
        *v889 = 0;
        v923[15] = v371;
        v923[14] = v371;
        v372 = v368 + v367 * v844;
        v854 = v829 + 4 * v372;
        v852 = v826 + 4 * v372;
        v373 = (v803 + 70 * v846);
        v374 = 0;
        v923[13] = v371;
        v923[12] = v371;
        v923[11] = v371;
        v923[10] = v371;
        v923[9] = v371;
        v923[8] = v371;
        v923[7] = v371;
        v923[6] = v371;
        v843 = v373 + 2;
        v923[5] = v371;
        v923[4] = v371;
        v858 = v373;
        v853 = v373 + 66;
        if (v844)
        {
          v375 = 0;
        }

        else
        {
          v375 = v366;
        }

        v851 = v375;
        v923[3] = v371;
        v923[2] = v371;
        v376 = v365;
        v378 = v364 < 0.25 && v365 == 1;
        v845 = v378;
        *v878 = v795 + v813 + 70 * v846;
        v379 = v795 + v812 + 70 * v846;
        v923[1] = v371;
        v380 = v900;
        v381 = &v924[107];
        v382 = &v924[107] + 1;
        v923[0] = v371;
        v857 = v376;
LABEL_634:
        v383 = &__srcc[16 * *(v260 + 1022) + 4024];
        v859 = v380;
        if (v376 < 1)
        {
          v384 = *(v383 + 2 * v889[0]);
          *(v260 + 1028) = v384;
          v387 = (v383 + v889[0] + 8);
        }

        else
        {
          v384 = *(v260 + 2010);
          v385 = *(v260 + 1027);
          if (v385 <= v384)
          {
            v386 = v385 - 5;
            *(v260 + 2010) = v386;
            v384 = v386;
          }

          *(v260 + 1028) = v384;
          v387 = __srcc + 4022;
        }

        v388 = v260;
        v863 = v374;
        __Ab = &v924[107] + v374;
        v389 = *v387;
        v390 = *v387 != 0;
        *(v388 + 1029) = v389;
        v391 = -4;
        if (!v389)
        {
          v391 = 0;
        }

        v392 = 4 * v390 - v389;
        v393 = *(&ltp_dec::PredLt4(float *,int,int)::tablePtrs + v392);
        v394 = vrev64q_s32(*v393);
        v395 = vextq_s8(v394, v394, 8uLL);
        v396 = vrev64q_s32(v393[1]);
        v397 = vextq_s8(v396, v396, 8uLL);
        v398 = vrev64q_s32(v393[2]);
        v399 = vextq_s8(v398, v398, 8uLL);
        v400 = vrev64q_s32(v393[3]);
        v401 = vextq_s8(v400, v400, 8uLL);
        v402 = *(&ltp_dec::PredLt4(float *,int,int)::tablePtrs + (4 - v392));
        v404 = v402[2];
        v403 = v402[3];
        v406 = *v402;
        v405 = v402[1];
        v407 = v391 - 4 * v384;
        v408 = v382;
        v409 = 65;
        do
        {
          v410 = vaddq_f32(vaddq_f32(vmulq_f32(v401, *(v408 + v407 - 64)), vmulq_f32(v397, *(v408 + v407 - 32))), vaddq_f32(vmulq_f32(v399, *(v408 + v407 - 48)), vmulq_f32(v395, *(v408 + v407 - 16))));
          *v410.i8 = vadd_f32(*v410.i8, *&vextq_s8(v410, v410, 8uLL));
          v411 = vaddq_f32(vaddq_f32(vmulq_f32(v406, *(v408 + v407)), vmulq_f32(v404, *(v408 + v407 + 32))), vaddq_f32(vmulq_f32(v405, *(v408 + v407 + 16)), vmulq_f32(v403, *(v408 + v407 + 48))));
          *v411.i8 = vadd_f32(*v411.i8, *&vextq_s8(v411, v411, 8uLL));
          *(v408++ - 1) = vaddv_f32(vadd_f32(vzip1_s32(*v410.i8, *v411.i8), vzip2_s32(*v410.i8, *v411.i8)));
          --v409;
        }

        while (v409);
        v861 = v379;
        v866 = v384;
        if (v376 <= 0)
        {
          if (!*(v383 + v889[0] + 12))
          {
            goto LABEL_648;
          }

          __srcc[4022] = v389;
          *(__srcc + 2010) = v384;
        }

        else
        {
          if (!v845)
          {
            v412 = v795 + 5952 * v822;
            __srcc[4022] = v389;
            *(__srcc + 2010) = v384;
            goto LABEL_651;
          }

LABEL_648:
          v413 = 0;
          v397.f32[0] = *__Ab;
          v401.f32[0] = *__Ab * 0.18;
          v395.f32[0] = *(__Ab - 1) * 0.18;
          v414 = vdupq_lane_s32(*v397.f32, 0);
          v415 = vdupq_lane_s32(*v395.f32, 0);
          v416 = vdupq_lane_s32(*v401.f32, 0);
          do
          {
            v417 = &v382[v413 / 4];
            v927 = vld2q_f32(v417);
            v418 = vdupq_n_s32(0x3E3851ECu);
            v419 = vmulq_f32(v927.val[0], v418);
            v420 = vdupq_n_s32(0x3F23D70Au);
            v421 = vmulq_f32(v927.val[1], v418);
            v926.val[0] = vaddq_f32(vmlaq_f32(vextq_s8(v415, v419, 0xCuLL), v420, vextq_s8(v414, v927.val[1], 0xCuLL)), v419);
            v926.val[1] = vaddq_f32(vmlaq_f32(vextq_s8(v416, v421, 0xCuLL), v420, v927.val[0]), v421);
            v422 = &v381[v413 / 0x10];
            vst2q_f32(v422, v926);
            v413 += 32;
            v414 = v927.val[1];
            v415 = v419;
            v416 = v421;
          }

          while (v413 != 256);
          v412 = v795 + 5952 * v822;
          __srcc[4022] = v389;
          *(__srcc + 2010) = v384;
          if (v376 >= 1)
          {
LABEL_651:
            v423 = 0;
            LOWORD(v412) = *(v412 + 3736);
            do
            {
              LODWORD(v412) = ((31821 * v412) >> 1) + 13849;
              *(v923 + v423) = (v412 >> 4);
              v423 += 4;
            }

            while (v423 != 256);
            *(__srcc + 1868) = v412;
            goto LABEL_830;
          }
        }

        v424 = acelp_dec::MapCoreMode2NBits(unsigned char)::tab_coremode2nbits[*v858];
        DWORD2(v907) = -1431655766;
        v425 = &v843[16 * *v889];
        *&v907 = 0xAAAAAAAAAAAAAAAALL;
        memset(v923, 0, 256);
        HIDWORD(v427) = v424 - 12;
        LODWORD(v427) = v424 - 12;
        v426 = v427 >> 2;
        if (v426 > 5)
        {
          if (v426 > 9)
          {
            if (v426 == 10)
            {
              for (n = 0; n != 4; ++n)
              {
                v520 = 0;
                v521 = *&v425[2 * n];
                v522 = (v521 >> 4) & 8 | (v521 >> 3) & 7;
                v523 = (v521 >> 4) & 8 | v521 & 7;
                if ((v521 & 0x40) != 0)
                {
                  LOWORD(v522) = v522 | 0x10;
                  v524 = v523 | 0x10;
                }

                else
                {
                  v524 = (*&v425[2 * n] >> 4) & 8 | *&v425[2 * n] & 7;
                }

                if ((v521 & 0x40) == 0)
                {
                  LOWORD(v523) = v523 | 0x10;
                }

                if ((v521 & 7) >= ((v521 >> 3) & 7))
                {
                  LOWORD(v523) = v524;
                }

                LOWORD(v907) = v522;
                WORD1(v907) = v523;
                WORD2(v907) = (v521 >> 8) & 0x1F;
                do
                {
                  if ((*(&v907 + v520) & 0x10) != 0)
                  {
                    v525 = -512.0;
                  }

                  else
                  {
                    v525 = 512.0;
                  }

                  *(v923 + ((4 * (*(&v907 + v520) & 0xF)) | n)) = *(v923 + ((4 * (*(&v907 + v520) & 0xF)) | n)) + v525;
                  v520 += 2;
                }

                while (v520 != 6);
              }
            }

            else
            {
              if (v426 != 13)
              {
LABEL_1086:
                v764 = __cxa_allocate_exception(0x10uLL);
                *v764 = "void d4t64_dec::Decode4t64(const array<int16_t, 8> &, const int32_t, array<float, kLSubFr> &)";
                v764[2] = 239;
              }

              for (ii = 0; ii != 4; ++ii)
              {
                v472 = &v425[2 * ii];
                v473 = *v472;
                v474 = *(v472 + 4);
                v475 = (v474 + (v473 << 14));
                v476 = (v474 + (v473 << 14)) >> 14;
                if (v476 > 1)
                {
                  if (v476 == 2)
                  {
                    v479 = (v475 >> 10) & 7;
                    v480 = (v475 >> 7) & 7;
                    v481 = v479 | 0x10;
                    v482 = v480 | 0x10;
                    if ((v474 & 0x2000) != 0)
                    {
                      v483 = v480 | 0x10;
                    }

                    else
                    {
                      v481 = (v475 >> 10) & 7;
                      v483 = (v475 >> 7) & 7;
                    }

                    if ((v474 & 0x2000) != 0)
                    {
                      v482 = (v475 >> 7) & 7;
                    }

                    if (v480 < v479)
                    {
                      v484 = v482;
                    }

                    else
                    {
                      v484 = v483;
                    }

                    LOWORD(v907) = v481;
                    WORD1(v907) = v484;
                    v485 = (v475 >> 3) & 7;
                    v486 = (v474 & 0x40) == 0;
                    if ((v474 & 0x40) != 0)
                    {
                      v487 = v485 | 0x18;
                    }

                    else
                    {
                      v487 = v485 | 8;
                    }

                    if (v486)
                    {
                      v488 = v475 & 7 | 8;
                    }

                    else
                    {
                      v488 = v475 & 7 | 0x18;
                    }

                    if (v486)
                    {
                      v489 = v475 & 7 | 0x18;
                    }

                    else
                    {
                      v489 = v475 & 7 | 8;
                    }

                    if ((v475 & 7u) < v485)
                    {
                      v488 = v489;
                    }

                    WORD2(v907) = v487;
                    WORD3(v907) = v488;
                  }

                  else
                  {
                    v494 = (v475 >> 7) & 4 | (v475 >> 6);
                    v495 = (v475 >> 7) & 4 | (v475 >> 4) & 3;
                    if ((v474 & 0x100) != 0)
                    {
                      LOWORD(v494) = v494 | 0x10;
                      v496 = v495 | 0x10;
                    }

                    else
                    {
                      v496 = (v475 >> 7) & 4 | (v475 >> 4) & 3;
                    }

                    if ((v474 & 0x100) == 0)
                    {
                      LOWORD(v495) = v495 | 0x10;
                    }

                    if (((v475 >> 4) & 3) >= v475 >> 6)
                    {
                      LOWORD(v495) = v496;
                    }

                    LOWORD(v907) = v494;
                    WORD1(v907) = v495;
                    WORD2(v907) = (v475 >> 9) & 0x10 | (v475 >> 10) & 7;
                    if ((v474 & 8) != 0)
                    {
                      v497 = 24;
                    }

                    else
                    {
                      v497 = 8;
                    }

                    WORD3(v907) = v497 & 0xFFF8 | v475 & 7;
                  }
                }

                else if (v476)
                {
                  LOWORD(v907) = (v475 >> 9) & 0x10 | (v475 >> 10) & 7;
                  v490 = (v475 >> 3) & 4 | 8 | (v475 >> 2) & 3;
                  v491 = (v475 >> 3) & 4 | 8 | v475 & 3;
                  if ((v474 & 0x10) != 0)
                  {
                    LOWORD(v490) = v490 | 0x10;
                    v492 = v491 | 0x10;
                  }

                  else
                  {
                    v492 = (v475 >> 3) & 4 | 8 | v475 & 3;
                  }

                  if ((v474 & 0x10) == 0)
                  {
                    LOWORD(v491) = v491 | 0x10;
                  }

                  if ((v475 & 3u) >= ((v475 >> 2) & 3))
                  {
                    LOWORD(v491) = v492;
                  }

                  WORD1(v907) = v490;
                  WORD2(v907) = v491;
                  if ((v474 & 0x200) != 0)
                  {
                    v493 = 24;
                  }

                  else
                  {
                    v493 = 8;
                  }

                  WORD3(v907) = v493 & 0xFFF8 | (v475 >> 6) & 7;
                }

                else
                {
                  v477 = v379;
                  if ((v474 & 0x2000) != 0)
                  {
                    v478 = 8;
                  }

                  else
                  {
                    v478 = 0;
                  }

                  d4t64_dec::D_ACELP_decode_4p_4N1(v475, v478, &v907);
                  v379 = v477;
                }

                for (jj = 0; jj != 8; jj += 2)
                {
                  if ((*(&v907 + jj) & 0x10) != 0)
                  {
                    v499 = -512.0;
                  }

                  else
                  {
                    v499 = 512.0;
                  }

                  *(v923 + ((4 * (*(&v907 + jj) & 0xF)) | ii)) = *(v923 + ((4 * (*(&v907 + jj) & 0xF)) | ii)) + v499;
                }
              }
            }
          }

          else if (v426 == 6)
          {
            for (kk = 0; kk != 4; ++kk)
            {
              v507 = 0;
              v508 = *&v425[2 * kk];
              v509 = v508 >> 4;
              v510 = v508 & 0xF;
              v511 = v508 & 0xF | 0x10;
              v512 = (v508 & 0x100) == 0;
              if ((v508 & 0x100) != 0)
              {
                v513 = v509 | 0x10;
              }

              else
              {
                v513 = v508 >> 4;
              }

              if (v512)
              {
                v514 = v510;
              }

              else
              {
                v514 = v511;
              }

              if (!v512)
              {
                v511 = v510;
              }

              if (v510 < v509)
              {
                v515 = v511;
              }

              else
              {
                v515 = v514;
              }

              LOWORD(v907) = v513;
              WORD1(v907) = v515;
              do
              {
                if ((*(&v907 + v507) & 0x10) != 0)
                {
                  v516 = -512.0;
                }

                else
                {
                  v516 = 512.0;
                }

                *(v923 + ((4 * (*(&v907 + v507) & 0xF)) | kk)) = *(v923 + ((4 * (*(&v907 + v507) & 0xF)) | kk)) + v516;
                v507 += 2;
              }

              while (v507 != 4);
            }
          }

          else
          {
            if (v426 != 8)
            {
              goto LABEL_1086;
            }

            v433 = 0;
            v434 = 1;
            do
            {
              v435 = 0;
              v436 = v434;
              v437 = *&v425[2 * v433];
              v438 = (v437 >> 4) & 8 | (v437 >> 3) & 7;
              v439 = (v437 >> 4) & 8 | v437 & 7;
              if ((v437 & 0x40) != 0)
              {
                LOWORD(v438) = v438 | 0x10;
                v440 = v439 | 0x10;
              }

              else
              {
                v440 = (*&v425[2 * v433] >> 4) & 8 | *&v425[2 * v433] & 7;
              }

              if ((v437 & 0x40) == 0)
              {
                LOWORD(v439) = v439 | 0x10;
              }

              if ((v437 & 7) >= ((v437 >> 3) & 7))
              {
                LOWORD(v439) = v440;
              }

              LOWORD(v907) = v438;
              WORD1(v907) = v439;
              WORD2(v907) = (v437 >> 8) & 0x1F;
              do
              {
                if ((*(&v907 + v435) & 0x10) != 0)
                {
                  v441 = -512.0;
                }

                else
                {
                  v441 = 512.0;
                }

                *(v923 + ((4 * (*(&v907 + v435) & 0xF)) | v433)) = *(v923 + ((4 * (*(&v907 + v435) & 0xF)) | v433)) + v441;
                v435 += 2;
              }

              while (v435 != 6);
              v434 = 0;
              v433 = 1;
            }

            while ((v436 & 1) != 0);
            v442 = 0;
            v443 = 2;
            do
            {
              v444 = 0;
              v445 = *&v425[2 * v443];
              v446 = v445 >> 4;
              v447 = v445 & 0xF;
              v448 = v446 | 0x10;
              v449 = v445 & 0xF | 0x10;
              if ((v445 & 0x100) != 0)
              {
                v450 = v445 & 0xF | 0x10;
              }

              else
              {
                v448 = v445 >> 4;
                v450 = v445 & 0xF;
              }

              if ((*&v425[2 * v443] & 0x100) != 0)
              {
                v449 = v445 & 0xF;
              }

              v451 = v442;
              if (v447 < v446)
              {
                v452 = v449;
              }

              else
              {
                v452 = v450;
              }

              LOWORD(v907) = v448;
              WORD1(v907) = v452;
              do
              {
                if ((*(&v907 + v444) & 0x10) != 0)
                {
                  v453 = -512.0;
                }

                else
                {
                  v453 = 512.0;
                }

                *(v923 + ((4 * (*(&v907 + v444) & 0xF)) | v443)) = *(v923 + ((4 * (*(&v907 + v444) & 0xF)) | v443)) + v453;
                v444 += 2;
              }

              while (v444 != 4);
              v442 = 1;
              v443 = 3;
            }

            while ((v451 & 1) == 0);
          }
        }

        else if (v426 > 1)
        {
          if (v426 == 2)
          {
            for (mm = 0; mm != 4; ++mm)
            {
              if ((*(v379 + 2 * mm) & 0x10) != 0)
              {
                v518 = -512.0;
              }

              else
              {
                v518 = 512.0;
              }

              *(v923 + ((4 * (*(v379 + 2 * mm) & 0xF)) | mm)) = *(v923 + ((4 * (*(v379 + 2 * mm) & 0xF)) | mm)) + v518;
            }
          }

          else
          {
            if (v426 != 4)
            {
              goto LABEL_1086;
            }

            v454 = 0;
            v455 = 1;
            do
            {
              v456 = 0;
              v457 = *&v425[2 * v454];
              v458 = v457 >> 4;
              v459 = v457 & 0xF;
              v460 = v458 | 0x10;
              v461 = v457 & 0xF | 0x10;
              if ((v457 & 0x100) != 0)
              {
                v462 = v457 & 0xF | 0x10;
              }

              else
              {
                v460 = v457 >> 4;
                v462 = v457 & 0xF;
              }

              if ((*&v425[2 * v454] & 0x100) != 0)
              {
                v461 = v457 & 0xF;
              }

              v463 = v455;
              if (v459 < v458)
              {
                v464 = v461;
              }

              else
              {
                v464 = v462;
              }

              LOWORD(v907) = v460;
              WORD1(v907) = v464;
              do
              {
                if ((*(&v907 + v456) & 0x10) != 0)
                {
                  v465 = -512.0;
                }

                else
                {
                  v465 = 512.0;
                }

                *(v923 + ((4 * (*(&v907 + v456) & 0xF)) | v454)) = *(v923 + ((4 * (*(&v907 + v456) & 0xF)) | v454)) + v465;
                v456 += 2;
              }

              while (v456 != 4);
              v455 = 0;
              v454 = 1;
            }

            while ((v463 & 1) != 0);
            v466 = *v878;
            for (nn = 2; nn != 4; ++nn)
            {
              v468 = *v466++;
              v469 = ((4 * (v468 & 0xF)) | nn);
              if ((v468 & 0x10) != 0)
              {
                v470 = -512.0;
              }

              else
              {
                v470 = 512.0;
              }

              *(v923 + v469) = *(v923 + v469) + v470;
            }
          }
        }

        else if (v426)
        {
          if (v426 != 1)
          {
            goto LABEL_1086;
          }

          v428 = 0;
          if (*v425)
          {
            v429 = 3;
          }

          else
          {
            v429 = 1;
          }

          v430 = 1;
          do
          {
            if (v429 != v428)
            {
              v431 = *&v425[2 * v430++];
              if ((v431 & 0x10) != 0)
              {
                v432 = -512.0;
              }

              else
              {
                v432 = 512.0;
              }

              *(v923 + ((4 * (v431 & 0xF)) | v428)) = *(v923 + ((4 * (v431 & 0xF)) | v428)) + v432;
            }

            ++v428;
          }

          while (v428 != 4);
        }

        else
        {
          v500 = 0;
          v501 = 1;
          do
          {
            v502 = v501;
            v503 = &v425[2 * v500];
            v504 = (4 * (*(v503 + 1) & 0xF) + ((2 * *v503) | (v500 >> 1)));
            if ((*(v503 + 1) & 0x10) != 0)
            {
              v505 = -512.0;
            }

            else
            {
              v505 = 512.0;
            }

            *(v923 + v504) = *(v923 + v504) + v505;
            v500 = 2;
            v501 = 0;
          }

          while ((v502 & 1) != 0);
        }

        v376 = v857;
LABEL_830:
        for (i1 = 0; i1 != 256; i1 += 4)
        {
          *(v923 + i1) = ldexpf(*(v923 + i1), -9);
        }

        v527 = 0;
        v528 = *(&v923[15] + 3);
        do
        {
          v529 = v923 + v527;
          v530 = v529[62];
          v529[63] = v528 + (v530 * -0.3);
          v531 = v527 + 63;
          --v527;
          v528 = v530;
        }

        while (v531 > 1);
        if (v389 <= 2)
        {
          v532 = v866;
        }

        else
        {
          v532 = v866 + 1;
        }

        if (v532 <= 63)
        {
          v533 = v866;
          if (v389 > 2)
          {
            v533 = v866 + 1;
          }

          v534 = v533 + 1;
          v535 = v923;
          do
          {
            v535[v532] = v535[v532] + (*v535 * 0.85);
            ++v535;
            _ZF = v534++ == 64;
          }

          while (!_ZF);
        }

        v536 = v376 > 0;
        if (*(__srcc + 1027) < v532)
        {
          LODWORD(v532) = *(__srcc + 1027);
        }

        *(v854 + 4 * *v889) = v532;
        v537 = v853[*v889];
        v538 = v858[1];
        LODWORD(v907) = 0;
        vDSP_svesq(v923, 1, &v907, 0x40uLL);
        v539 = *&v907;
        v540 = sqrtf(64.0 / (*&v907 + 0.01));
        if (v536)
        {
          v541 = (v795 + 5952 * v822);
          v542 = *(__srcc + 930);
          v543 = 0.5;
          if (v542 >= 0.5)
          {
            v543 = *(__srcc + 930);
          }

          if (v542 <= 0.95)
          {
            v544 = v543;
          }

          else
          {
            v544 = 0.95;
          }

          *(__srcc + 930) = v544 * 0.95;
          v545 = (1.4 - (v544 * 0.95)) * *(__srcc + 931);
          v546 = v540 * v545;
        }

        else
        {
          v544 = lpd_rom::t_qua_gain7b[2 * v537];
          v546 = (v540 * acelp_dec::pow_10_mean_energy[v538]) * lpd_rom::t_qua_gain7b[(2 * v537) | 1];
          v541 = (v795 + 5952 * v822);
          *(__srcc + 930) = v544;
          v545 = v546 / v540;
        }

        v541[931] = v545;
        *(v852 + 4 * *v889) = v544;
        LODWORD(v907) = 0;
        vDSP_svesq(__Ab, 1, &v907, 0x40uLL);
        v547 = 1.0;
        if ((v851 & (v544 > 1.0)) == 0)
        {
          v547 = v544;
        }

        v548 = v541[1032];
        v260 = v541;
        if (v548 <= v546)
        {
          if ((v546 * 0.84034) >= v548)
          {
            v548 = v546 * 0.84034;
          }
        }

        else if ((v546 + (v546 * 0.19)) <= v548)
        {
          v548 = v546 + (v546 * 0.19);
        }

        v376 = v857;
        v549 = ((v544 * (v544 * *&v907)) - ((v546 * v546) * v539)) / ((((v546 * v546) * v539) + (v544 * (v544 * *&v907))) + 0.01);
        v541[1032] = v548;
        v550 = (v364 + (-v364 * v549)) * 0.5;
        if (v550 < 0.0)
        {
          v760 = __cxa_allocate_exception(0x10uLL);
          *v760 = "float acelp_dec::noiseEnhancer::Process(const float, const float, const float)";
          v760[2] = 50;
        }

        v551 = 0;
        v552 = (v550 * v548) + (1.0 - v550) * v546;
        v553 = (v549 + 1.0) * 0.125;
        v554 = v547 * *__Ab;
        v555 = *v923;
        *__Ab = v554 + (*v923 * v546);
        v556 = v555 * v552;
        v557 = *(v923 + 1);
        v558 = *(v923 + 1) * v552;
        v559 = v554 + v556;
        v560 = v553 * (*(v923 + 1) * v552);
        *v923 = v559 - v560;
        v561 = v553 * v556;
        v562 = v923 + 1;
        do
        {
          v563 = v547 * v382[v551];
          v564 = (v558 + v563) - v561;
          v561 = v560;
          v565 = v562;
          v382[v551] = v563 + (v557 * v546);
          v566 = v562[1];
          ++v562;
          v557 = v566;
          v558 = v566 * v552;
          v560 = v553 * (v566 * v552);
          *v565 = v564 - v560;
          ++v551;
        }

        while ((v551 * 4) != 248);
        v567 = v547 * v382[v551];
        v382[v551] = v567 + (v557 * v546);
        *v562 = (v558 + v567) - v561;
        if (v855 >= 2)
        {
          v761 = __cxa_allocate_exception(0x10uLL);
          *v761 = "simd_float16 lpc_com::intLpc(const array<float, kLpFilterOrder> &, const array<float, kLpFilterOrder> &, const int32_t, const int32_t)";
          v761[2] = 131;
        }

        v568 = 0;
        *&v569 = -1;
        *(&v569 + 1) = -1;
        v910 = v569;
        v909 = v569;
        v908 = v569;
        v907 = v569;
        v570 = &__dstb[4 * *v889];
        v571 = &__dstb[4 * v869 + 4 * ~*v889];
        v572 = vld1q_dup_f32(v570);
        v573 = vld1q_dup_f32(v571);
        do
        {
          *(&v907 + v568) = vmlaq_f32(vmulq_f32(v572, *(v817 + ((v844 + 1) << 6) + v568)), v573, *(v817 + (v846 << 6) + v568));
          v568 += 16;
        }

        while (v568 != 64);
        lpc_com::lsp2a(&v892, &v907);
        v574 = vrev64q_s32(v892);
        v575 = vextq_s8(v574, v574, 8uLL);
        v576 = vrev64q_s32(v893);
        v577 = vextq_s8(v576, v576, 8uLL);
        v578 = vrev64q_s32(v894);
        v579 = vextq_s8(v578, v578, 8uLL);
        v580 = vrev64q_s32(v895);
        v581 = vextq_s8(v580, v580, 8uLL);
        v582 = v923;
        v583 = v859;
        v584 = 64;
        do
        {
          v585 = *v582++;
          v586 = vaddq_f32(vaddq_f32(vmulq_f32(v581, *(v583 - 16)), vmulq_f32(v577, *(v583 - 8))), vaddq_f32(vmulq_f32(v579, *(v583 - 12)), vmulq_f32(v575, *(v583 - 4))));
          *v583++ = v585 - vaddv_f32(vadd_f32(*v586.i8, *&vextq_s8(v586, v586, 8uLL)));
          --v584;
        }

        while (v584);
        v374 = v863 + 64;
        v382 += 64;
        v381 += 16;
        *v878 += 16;
        v379 = v861 + 16;
        v380 = v859 + 64;
        if (++*v889 == v872)
        {
          memcpy(v839, v802, 0x6B0uLL);
          v587 = v801[1];
          *v838 = *v801;
          *(__srcc + 3668) = v587;
          v588 = v801[3];
          *(__srcc + 3684) = v801[2];
          *(__srcc + 3700) = v588;
          v589 = v541[929];
          v590 = v900;
          v591 = (v840[0] >> 2);
          v592 = v856;
          do
          {
            v593 = *v590++;
            v589 = v593 + (v589 * 0.68);
            *v592++ = v589;
            --v591;
          }

          while (v591);
          if (fabsf(v589) < 1.0e-10)
          {
            v589 = 0.0;
          }

          v541[929] = v589;
          v541[932] = v589;
LABEL_875:
          v257 = __srcc + 5924;
          v271 = v844;
          v292 = v846;
          v291 = *(v260 + 348);
          if (v842[v846])
          {
            v256 = v837;
          }

          else
          {
            v256 = v837;
            if (v291 && *(v260 + 5336))
            {
              v596 = *(v260 + 347);
              v597 = *(v260 + 1474) + *(v260 + 1472) * v844;
              v598 = *(v829 + 4 * v597);
              v599 = v597 - 1;
              *(v829 + 4 * (v597 - 1)) = v598;
              if (v844 <= 0 && v596 == 1)
              {
                *(v826 + 4 * v599) = *(v826 + 4 * v597);
              }

              else
              {
                v677 = 4 * v597 - 8;
                *(v829 + v677) = v598;
                v678 = *(v826 + 4 * v597);
                *(v826 + 4 * v599) = v678;
                *(v826 + v677) = v678;
              }
            }
          }

LABEL_877:
          *(v260 + 349) = v291;
          v594 = *&v257[4 * v292];
          *(v260 + 348) = v594;
          *(v260 + 1400) = !v835;
          v595 = 1 << (v594 - 1);
          if (v594 <= 1)
          {
            v595 = 1;
          }

          v253 = v595 + v271;
          if (v253 >= 4)
          {
            if (v835)
            {
              v695 = *(v821 + 4 * v292);
              if (v695 < 0.0)
              {
                v774 = __cxa_allocate_exception(0x10uLL);
                *v774 = "void lsf_dec::lsfDecoder::Update(const int32_t, const BOOL)";
                v774[2] = 36;
              }

              v260[484] = v695;
              *(v260 + 92) = *(v260 + 116);
              *(v260 + 93) = *(v260 + 117);
              *(v260 + 94) = *(v260 + 118);
              *(v260 + 95) = *(v260 + 119);
            }

            if (v594 >= 1)
            {
              v696 = *(v260 + 296);
              v697 = *(v260 + 297);
              v698 = *(v260 + 298);
              *(v260 + 268) = *(v260 + 295);
              *(v260 + 271) = v698;
              *(v260 + 270) = v697;
              *(v260 + 269) = v696;
              v699 = (v833 + (v292 << 6));
              v701 = *v699;
              v700 = v699[1];
              v702 = v699[3];
              *(v260 + 274) = v699[2];
              *(v260 + 275) = v702;
              *(v260 + 272) = v701;
              *(v260 + 273) = v700;
            }

            if (v847 != v840[0])
            {
              v769 = __cxa_allocate_exception(0x10uLL);
              *v769 = "OSStatus lpd_dec::lpdDecoder::RenderTimeSignal(mdct_t_fl &, uint8_t, float *, const int32_t, const uint8_t, const int32_t, float *const, const int32_t, const uint32_t, BOOL, const BOOL, const uint32_t)";
              v769[2] = 584;
            }

            if (*(v260 + 1484))
            {
              v703 = v840[0] >> 3;
            }

            else
            {
              v703 = 0;
            }

            v704 = v830 - v703;
            if (*(v849 + 36) >= (v830 - v703))
            {
              v705 = v830 - v703;
            }

            else
            {
              v705 = *(v849 + 36);
            }

            if (*(v849 + 28) >= v704 - v705)
            {
              v706 = v704 - v705;
            }

            else
            {
              v706 = *(v849 + 28);
            }

            CDKmemcpy(&v906[*v840], *(v849 + 8), (4 * v705));
            if (v706 >= 1)
            {
              v707 = &v906[*v840 + v705];
              v708 = -v706;
              v709 = (*(v849 + 8) + 4 * *(v849 + 40) - 4);
              do
              {
                v710 = *v709--;
                *v707++ = -v710;
                _CF = __CFADD__(v708++, 1);
              }

              while (!_CF);
            }

            if (v706 + v705 != v704)
            {
              v770 = __cxa_allocate_exception(0x10uLL);
              *v770 = "OSStatus lpd_dec::lpdDecoder::RenderTimeSignal(mdct_t_fl &, uint8_t, float *, const int32_t, const uint8_t, const int32_t, float *const, const int32_t, const uint32_t, BOOL, const BOOL, const uint32_t)";
              v770[2] = 590;
            }

            v711 = __srcc[5336];
            if (v711)
            {
              v712 = *(__srcc + 1474);
            }

            else
            {
              v713 = *v842;
              if (*v842)
              {
                v713 = 2 * (__srcc[5337] != 0);
              }

              v712 = *(__srcc + 1474);
              v714 = *(__srcc + 1473) - v713;
              _VF = __OFSUB__(v714, 1);
              v715 = v714 - 1;
              if (v715 < 0 == _VF)
              {
                bzero((v826 + 4 * (v712 + v713)), 4 * v715 + 4);
              }
            }

            if (v712)
            {
              memmove(__srcc + 5340, (v829 + 4 * *(__srcc + 1473)), 4 * v712);
              v716 = *(__srcc + 1474);
              if (v716)
              {
                memmove(__srcc + 5368, (v826 + 4 * *(__srcc + 1473)), 4 * v716);
              }
            }

            __srcc[5337] = v711;
            if (*(__srcc + 1484))
            {
              v717 = v840[0] >> 3;
            }

            else
            {
              v717 = 0;
            }

            bpf_dec::bassPostFilter::Process((__srcc + 5336), &v906[64], v840[0], v840[0], *(__srcc + 1475) - v717, &v805[v809]);
            memcpy(__srcc, &v905[4 * v840[0]], 0x56CuLL);
            v718 = *(__srcc + 1474);
            v209 = v828;
            if (v718)
            {
              memmove(__srcc + 5340, (v829 + 4 * *(__srcc + 1473)), 4 * v718);
            }

            *(__srcc + 347) = 2;
            v7 = v827;
LABEL_982:
            v207 = v816;
LABEL_983:
            v719 = v822;
            if (*&v905[4 * v822 - 8])
            {
              goto LABEL_1043;
            }

            v720 = *(v834 + 8 * v822);
            v721 = *(v7 + 340);
            v722 = *(v720 + 88);
            v723 = *(v720 + 152);
            memset(&v905[4], 0, 28);
            v157.i32[1] = 0;
            memset(v924, 0, 32);
            LODWORD(v18) = *(v720 + 160);
            v724 = *(v720 + 120);
            if (v723 <= 1)
            {
              v726 = v723;
              if (v723)
              {
                if (v723 != 1)
                {
LABEL_1097:
                  v776 = __cxa_allocate_exception(0x10uLL);
                  *v776 = "INT CConcealment_TDFading(int, CAacDecoderStaticChannelInfo **, FLOAT *)";
                  v776[2] = 1268;
                }

LABEL_991:
                v725 = v722[65];
                if (v724 >= v725)
                {
                  goto LABEL_993;
                }

                v726 = v724 - (v722[64] == 1);
                v727 = v722;
LABEL_1001:
                if ((v726 & 0x80000000) != 0)
                {
                  v157.i32[0] = 1.0;
                }

                else
                {
                  v157.i32[0] = v727[v726];
                }

                *&v731 = 0x100000001;
                *(&v731 + 1) = 0x100000001;
                v924[1] = v731;
                v924[0] = v731;
                v730 = 3;
LABEL_1009:
                v729 = 1;
                goto LABEL_1010;
              }

LABEL_996:
              v727 = v722 + 32;
              if (!v723)
              {
                v726 = -1;
              }

              if (*(v720 + 156) != 3)
              {
                goto LABEL_1001;
              }

              if ((v726 & 0x80000000) != 0)
              {
                v157.i32[0] = 1.0;
              }

              else
              {
                v157.i32[0] = v727[v726];
              }

              if (!v722[66])
              {
                v729 = 0;
                LODWORD(v924[0]) = 1;
                v730 = 2;
                goto LABEL_1010;
              }

              *&v732 = 0x100000001;
              *(&v732 + 1) = 0x100000001;
              v924[1] = v732;
              v924[0] = v732;
              v730 = 2;
              goto LABEL_1009;
            }

            if (v723 == 2)
            {
              v726 = v724 - 1;
              goto LABEL_996;
            }

            if (v723 == 4)
            {
              goto LABEL_991;
            }

            if (v723 != 3)
            {
              goto LABEL_1097;
            }

            v725 = v722[65];
LABEL_993:
            if (v725)
            {
              v728 = 0x100000001;
              v157.i64[1] = 0x100000001;
              v924[1] = v157;
              v924[0] = v157;
              v157.i64[0] = 0;
              v729 = 1;
              v730 = 1;
            }

            else
            {
              v729 = 0;
              v730 = 1;
              LODWORD(v924[0]) = 1;
              v157.i64[0] = 0;
            }

LABEL_1010:
            v733 = 0;
            v734 = &v805[v809];
            v735 = (*v157.i32 - *&v18) / fmaxf(((v729 | (4 * v729) | (2 * v729)) + 1), 1.0);
            *v905 = v18;
            v736 = *&v18;
            do
            {
              _Q4.f32[0] = *(v924 + v733);
              v736 = v736 + (v735 * _Q4.f32[0]);
              *&v905[v733 + 4] = v736;
              v733 += 4;
            }

            while (v733 != 28);
            v737 = v721 >> 3;
            *&v905[32] = v157.i32[0];
            if (*v157.i32 != 1.0)
            {
              goto LABEL_1014;
            }

            v738.i64[0] = *&v905[20];
            v738.i64[1] = __PAIR64__(vdup_lane_s32(*&v18, 0).u32[1], *&v905[28]);
            __asm { FMOV            V4.4S, #1.0 }

            *&v20 = 0x8000400020001;
            if (vaddvq_s16(vbicq_s8(xmmword_19B0B3630, vuzp1q_s16(vceqq_f32(*&v905[4], _Q4), vceqq_f32(v738, _Q4)))))
            {
LABEL_1014:
              v739 = 0;
              v740 = 0;
              do
              {
                ++v739;
                LODWORD(v20) = *&v905[4 * v739];
                v741 = v740 + v737;
                if (v737 >= 1)
                {
                  _Q4.f32[0] = (*&v18 - *&v20) / v737;
                  do
                  {
                    *&v18 = *&v18 - _Q4.f32[0];
                    *&v22 = *&v18 * v734[v740];
                    v734[v740++] = *&v22;
                  }

                  while (v740 < v741);
                }

                LODWORD(v18) = v20;
                v740 = v741;
              }

              while (v739 != 8);
            }

            v742 = 69069 * *(v720 + 236) + 6;
            *(v720 + 236) = v742;
            *&v19 = 0x3000000037800000;
            *&v18 = (v722[68] * 4.6566e-10) * 0.000015259;
            if (v723)
            {
              if (v737 < 1)
              {
                goto LABEL_1041;
              }
            }

            else if (v737 < 1 || !*(v720 + 156))
            {
              goto LABEL_1041;
            }

            if (*&v18 != 0.0)
            {
              LODWORD(v743) = v721 & 0xFFFFFFF8;
              if (v743)
              {
                v743 = v743;
              }

              else
              {
                v743 = 1;
              }

              v744 = v742;
              do
              {
                v746 = *(v720 + 240);
                v745 = *(v720 + 244);
                *(v720 + 244) = v746;
                *(v720 + 248) = v745;
                v744 = 69069 * v744 + 5;
                *(v720 + 240) = v744;
                LODWORD(v22) = *(v720 + 252);
                v23.i32[0] = *(v720 + 256);
                v747 = *&v18 * (((v746 * v23.f32[0]) + (v744 * *&v22)) + (v745 * *(v720 + 260)));
                *&v20 = *v734;
                _Q4.f32[0] = 32767.0 - v747;
                v748 = v747 <= 0.0 || *&v20 <= _Q4.f32[0];
                if (!v748 || ((_Q4.i32[1] = -956301312, _Q4.f32[0] = -32768.0 - v747, v747 < 0.0) ? (_NF = *&v20 < _Q4.f32[0]) : (_NF = 0), _NF))
                {
                  v747 = -v747;
                }

                *&v19 = *&v20 + v747;
                *v734++ = v19;
                --v743;
              }

              while (v743);
            }

LABEL_1041:
            *(v720 + 164) = v730;
            *(v720 + 160) = v157.i32[0];
            *(v720 + 156) = v723;
            v719 = v822;
            *&v905[4 * v822 - 8] = 1;
            v207 = v816;
            if (v822 < v788)
            {
              *(*(v834 + 8 * v822 + 8) + 236) = v742;
            }

LABEL_1043:
            v163 = v719 + 1;
            v165 = v207 + 1;
            v167 = v209 + 5952;
            v814 += 5952;
            v813 += 5952;
            v812 += 5952;
            v811 += 5952;
            if (v165 >= v797)
            {
              v156 = v778;
              v155 = v789;
              goto LABEL_1058;
            }

            continue;
          }

          goto LABEL_551;
        }

        goto LABEL_634;
      }

      break;
    }

    v784 = 8204;
    v156 = v822;
    v155 = v816;
LABEL_1058:
    v154 = v790 + 1;
    if (v790 + 1 != v783)
    {
      continue;
    }

    break;
  }

  v750 = *(v7 + 68);
  result = v784;
  if ((v750 & 0x100) != 0)
  {
    v751 = *(v7 + 1912);
    if (v751)
    {
      if (v779 == 2)
      {
        if (*(v751 + 156 * *(v751 + 3453) + 140))
        {
          v752 = *(v7 + 340);
          if (v752 >= 1)
          {
            do
            {
              v753 = *v805 * 0.70711;
              v754 = v805[v799] * 0.70711;
              *v805 = v753 + v754;
              v805[v799] = v753 - v754;
              ++v805;
              --v752;
            }

            while (v752);
          }
        }
      }
    }
  }

  if ((*(v7 + 724) & 0xFFFFFFFE) == 2)
  {
    v755 = *(v7 + 340);
  }

  else
  {
    v755 = 0;
  }

  *(v7 + 356) += v755;
  if ((v750 & 0x200) == 0)
  {
    *v905 = 0xAAAAAAAAAAAAAAAALL;
    LOWORD(v924[0]) = -21846;
    CDKmemcpy(v905, v782, 8uLL);
    CDKmemcpy(v924, v781, 2uLL);
    v7 = v827;
    result = v784;
    if (v779 > 0)
    {
      for (i2 = 0; i2 != v779; v781[v757] = *(v924 + i2++))
      {
        if (*(v827 + 276) || (v758 = *(v827 + 264)) == 0 || *(v827 + 272) <= *(v827 + 280))
        {
          v757 = i2;
        }

        else
        {
          v759 = v758 + 16 * *(v827 + 280);
          v757 = i2;
          if (*(v759 + 8) > i2)
          {
            v757 = *(*v759 + i2);
          }
        }

        *&v782[4 * v757] = *&v905[4 * i2];
      }
    }
  }

  ++*(v7 + 8);
  return result;
}

uint64_t transportDec_EndAccessUnit(uint64_t a1)
{
  if (*a1 > 0xAu || ((1 << *a1) & 0x4C0) == 0)
  {
    goto LABEL_28;
  }

  if (*(a1 + 2888))
  {
    if (*(a1 + 152))
    {
      v3 = *(a1 + 108);
      if (v3)
      {
        CDK_put(a1 + 112, *(a1 + 104), v3);
      }
    }

    else
    {
      v6 = *(a1 + 108);
      v7 = *(a1 + 128);
      v8 = *(a1 + 124) - v6;
      *(a1 + 112) += v6;
      v9 = (*(a1 + 148) - 1) & (v7 - v6);
      *(a1 + 124) = v8;
      *(a1 + 128) = v9;
    }

    *(a1 + 104) = 0;
    if (*(a1 + 112) <= 0)
    {
      *(a1 + 2888) = 0;
    }

    goto LABEL_28;
  }

  if (!*(a1 + 203))
  {
LABEL_28:

    return transportDec_AdjustEndOfAccessUnit(a1);
  }

  v4 = *(a1 + 188);
  if (*(a1 + 152))
  {
    v5 = *(a1 + 108);
    if (v5)
    {
      CDK_put(a1 + 112, *(a1 + 104), v5);
    }
  }

  else
  {
    v10 = *(a1 + 108);
    v11 = *(a1 + 128);
    v12 = *(a1 + 124) - v10;
    *(a1 + 112) += v10;
    v13 = (*(a1 + 148) - 1) & (v11 - v10);
    *(a1 + 124) = v12;
    *(a1 + 128) = v13;
  }

  v14 = *(a1 + 112);
  *(a1 + 104) = 0;
  if (v14 >= v4)
  {
    v16 = *(a1 + 124);
    v17 = *(a1 + 152);
    v18 = *(a1 + 148) - 1;
    if (v17)
    {
      v19 = -1;
    }

    else
    {
      v19 = *(a1 + 148) - 1;
    }

    v20 = *(a1 + 128) & v19;
    *(a1 + 104) = 0;
    v21 = v16 + v4;
    if (v17)
    {
      v22 = v4;
    }

    else
    {
      v22 = -v4;
    }

    *(a1 + 112) = v14 + v22;
    *(a1 + 124) = v21;
    *(a1 + 128) = v18 & (v20 + v4);
    goto LABEL_28;
  }

  if (!*(a1 + 2888))
  {
    v15 = *(a1 + 2876);
    if (*(a1 + 152))
    {
      *(a1 + 104) = 0;
      CDK_put(a1 + 112, 0, (v15 - v14) & 7);
    }

    else
    {
      v24 = *(a1 + 124);
      v25 = *(a1 + 148) - 1;
      v26 = v25 & *(a1 + 128);
      *(a1 + 104) = 0;
      v27 = (v14 - v15) & 7;
      *(a1 + 112) = v14 - v27;
      *(a1 + 124) = v24 + v27;
      *(a1 + 128) = v25 & (v26 + v27);
    }
  }

  return 257;
}

uint64_t mpegSurroundDecoder_GetLibInfo(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    v8 = 0;
    v9 = (result + 24);
    while (1)
    {
      v10 = *v9;
      v9 += 18;
      if (!v10)
      {
        break;
      }

      if (++v8 == 39)
      {
        return result;
      }
    }

    v11 = result + 72 * v8;
    *(v11 + 8) = "Oct 10 2025";
    *(v11 + 16) = "20:41:49";
    *v11 = "MPEG Surround Decoder";
    *(v11 + 24) = 0x105000000000009;
    result = CDKsprintf((v11 + 36), a2, a3, a4, a5, a6, a7, a8, 1);
    *(v11 + 32) = 4372;
  }

  return result;
}

uint64_t CAacDecoder_SyncQmfMode(uint64_t result)
{
  v27 = *MEMORY[0x1E69E9840];
  v1 = *(result + 68);
  if ((~v1 & 0x60000) == 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void CAacDecoder_SyncQmfMode(HANDLE_AACDECODER)";
    exception[2] = 115;
  }

  v2 = result;
  v3 = 0;
  v4 = *(result + 1908);
  *(result + 1904) = v4;
  v5 = *(result + 328);
  if (v5 == 42 || v5 == 50 || v5 == 150)
  {
    goto LABEL_5;
  }

  v3 = v4;
  if (v4 == -1)
  {
    if ((v5 == 39 || v5 == 23) && (v1 & 0x40000) != 0)
    {
      goto LABEL_56;
    }

    if (*(result + 344) == 1)
    {
      if (v5 <= 0x32)
      {
        if (((1 << v5) & 0x20400024) != 0)
        {
          goto LABEL_41;
        }

        if (((1 << v5) & 0x4040000000000) != 0)
        {
          goto LABEL_56;
        }
      }

      if (v5 == 143)
      {
LABEL_41:
        if ((v1 & 0x40000) != 0)
        {
          v3 = ((v5 - 42) & 0xFFFFFFF7) != 0;
LABEL_5:
          *(result + 1904) = v3;
          goto LABEL_6;
        }

LABEL_56:
        v3 = 0;
        goto LABEL_5;
      }
    }

    v3 = 1;
    goto LABEL_5;
  }

LABEL_6:
  if (*(result + 1921))
  {
    if ((v5 == 39 || v5 == 23) && v3)
    {
      *(result + 1904) = 0;
    }

    memset(v26, 170, sizeof(v26));
    v15 = 0;
    v16 = xmmword_19B0A5840;
    v17 = xmmword_19B0A5850;
    v18 = vdupq_n_s64(0x27uLL);
    v19 = vdupq_n_s64(4uLL);
    do
    {
      if (vuzp1_s16(vmovn_s64(vcgtq_u64(v18, v17)), *v16.i8).u8[0])
      {
        *&v26[v15 + 24] = 0;
      }

      if (vuzp1_s16(vmovn_s64(vcgtq_u64(vdupq_n_s64(0x27uLL), *&v17)), *&v16).i8[2])
      {
        *&v26[v15 + 96] = 0;
      }

      if (vuzp1_s16(*&v16, vmovn_s64(vcgtq_u64(vdupq_n_s64(0x27uLL), *&v16))).i32[1])
      {
        *&v26[v15 + 168] = 0;
        *&v26[v15 + 240] = 0;
      }

      v16 = vaddq_s64(v16, v19);
      v17 = vaddq_s64(v17, v19);
      v15 += 288;
    }

    while (v15 != 2880);
    result = mpegSurroundDecoder_GetLibInfo(v26, v8, v9, v10, v11, v12, v13, v14);
    v20 = 0;
    while (*&v26[v20 + 24] != 9)
    {
      v20 += 72;
      if (v20 == 2808)
      {
        goto LABEL_32;
      }
    }

    v21 = *&v26[v20 + 32];
    if (((v21 & 0x20) == 0 || *(v2 + 1904) != 1) && ((v21 & 0x10) == 0 || *(v2 + 1904)))
    {
LABEL_32:
      if (*(v2 + 1908) == -1)
      {
        *(v2 + 1904) = *(v2 + 1904) != 1;
      }

      else
      {
        *(v2 + 1921) = 0;
      }
    }
  }

  v22 = *(v2 + 832);
  if (v22 && *(v2 + 1904) != 1)
  {
    *(v22 + 536) &= ~0x20u;
  }

  v23 = *(v2 + 328);
  if (v23 <= 0x1D && ((1 << v23) & 0x20400024) != 0 || v23 == 143)
  {
    v24 = 0;
    if (*(v2 + 344) == 1 && (*(v2 + 68) & 0x40000) == 0)
    {
      v24 = *(v2 + 1904) == 0;
    }
  }

  else
  {
    v24 = 0;
  }

  *(v2 + 842) = v24;
  return result;
}

uint64_t CDK_QmfDomain_Configure(uint64_t a1)
{
  if (!a1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "QMF_DOMAIN_ERROR CDK_QmfDomain_Configure(HANDLE_CDK_QMF_DOMAIN)";
    v95 = 656;
    goto LABEL_219;
  }

  v2 = *(a1 + 77);
  v3 = *(a1 + 75);
  if (*(a1 + 77) && v3 != 64)
  {
    return 2;
  }

  v4 = *(a1 + 65);
  if (v4 > v3)
  {
    return 2;
  }

  if (*(a1 + 76) == v2 && *(a1 + 74) == v3 && *(a1 + 70) == *(a1 + 71))
  {
    v6 = 1;
  }

  else
  {
    if (*(a1 + 77))
    {
      *(a1 + 74) = v3;
      v7 = *(a1 + 71);
      v8 = (a1 + 161);
      v9 = v2;
      do
      {
        *v8 = v3;
        *(v8 - 1) = v7;
        v8 += 128;
        --v9;
      }

      while (v9);
    }

    v6 = 0;
    *(a1 + 76) = v2;
  }

  v10 = *(a1 + 2);
  if (*(a1 + 1) == v10 && *(a1 + 64) == v4 && *(a1 + 70) == *(a1 + 71) && *(a1 + 72) == *(a1 + 73) && *(a1 + 3) == *(a1 + 4) && *(a1 + 66) == *(a1 + 68) && *(a1 + 5) == *(a1 + 6))
  {
    v11 = *(a1 + 60);
    goto LABEL_101;
  }

  *(a1 + 1) = v10;
  *(a1 + 64) = v4;
  *(a1 + 70) = *(a1 + 71);
  *(a1 + 72) = *(a1 + 73);
  v12 = *(a1 + 4);
  *(a1 + 3) = v12;
  *(a1 + 66) = *(a1 + 68);
  *(a1 + 5) = *(a1 + 6);
  if (v10 > 2 || v12 > 2)
  {
    goto LABEL_115;
  }

  if (!v10)
  {
    goto LABEL_86;
  }

  v13 = 0;
  v14 = (a1 + 168);
  do
  {
    v15 = ((*(a1 + 64) >> 3) | (32 * *(a1 + 64)));
    if (v15 > 2)
    {
      if (v15 == 3)
      {
        if (*v14)
        {
          goto LABEL_45;
        }

        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT *GetAnaQmfStates24(int)";
          v95 = 65;
          goto LABEL_219;
        }

        v16 = 240;
      }

      else
      {
        if (v15 != 4)
        {
          goto LABEL_37;
        }

        if (*v14)
        {
          goto LABEL_45;
        }

        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT *GetAnaQmfStates32(int)";
          v95 = 69;
          goto LABEL_219;
        }

        v16 = 320;
      }
    }

    else
    {
      if (!((*(a1 + 64) >> 3) | (32 * *(a1 + 64))))
      {
        *v14 = 0;
        goto LABEL_45;
      }

      if (v15 != 2)
      {
LABEL_37:
        if (*v14)
        {
          goto LABEL_45;
        }

        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT *GetAnaQmfStates(int)";
          v95 = 41;
          goto LABEL_219;
        }

        v16 = 640;
        goto LABEL_44;
      }

      if (*v14)
      {
        goto LABEL_45;
      }

      if (v13 >= 2)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "FLOAT *GetAnaQmfStates16(int)";
        v95 = 61;
        goto LABEL_219;
      }

      v16 = 160;
    }

LABEL_44:
    v17 = malloc_type_calloc(v16, 4uLL, 0x5142B0E1uLL);
    *v14 = v17;
    if (!v17)
    {
      goto LABEL_114;
    }

LABEL_45:
    v18 = *(a1 + 70);
    if (!(v18 | *(a1 + 72)))
    {
      v14[3] = 0;
      v14[4] = 0;
      goto LABEL_68;
    }

    v19 = v14[3];
    if (v18 == 32)
    {
      if (!v19)
      {
        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT **GetQmfSlotsReal32(int)";
          v95 = 77;
          goto LABEL_219;
        }

        v22 = malloc_type_calloc(0x26uLL, 8uLL, 0x5142B0E1uLL);
        v14[3] = v22;
        if (!v22)
        {
          goto LABEL_114;
        }
      }

      if (!v14[4])
      {
        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT **GetQmfSlotsImag32(int)";
          v95 = 85;
          goto LABEL_219;
        }

        v21 = 38;
        goto LABEL_67;
      }
    }

    else if (v18 == 16)
    {
      if (!v19)
      {
        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT **GetQmfSlotsReal16(int)";
          v95 = 73;
          goto LABEL_219;
        }

        v20 = malloc_type_calloc(0x13uLL, 8uLL, 0x5142B0E1uLL);
        v14[3] = v20;
        if (!v20)
        {
          goto LABEL_114;
        }
      }

      if (!v14[4])
      {
        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT **GetQmfSlotsImag16(int)";
          v95 = 81;
          goto LABEL_219;
        }

        v21 = 19;
        goto LABEL_67;
      }
    }

    else
    {
      if (!v19)
      {
        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT **GetQmfSlotsReal(int)";
          v95 = 49;
          goto LABEL_219;
        }

        v23 = malloc_type_calloc(0x4CuLL, 8uLL, 0x5142B0E1uLL);
        v14[3] = v23;
        if (!v23)
        {
          goto LABEL_114;
        }
      }

      if (!v14[4])
      {
        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT **GetQmfSlotsImag(int)";
          v95 = 53;
          goto LABEL_219;
        }

        v21 = 76;
LABEL_67:
        v24 = malloc_type_calloc(v21, 8uLL, 0x5142B0E1uLL);
        v14[4] = v24;
        if (!v24)
        {
          goto LABEL_114;
        }
      }
    }

LABEL_68:
    v25 = *(a1 + 72);
    if (*(a1 + 74) * v25)
    {
      v26 = v14[1];
      if (v25 == 6)
      {
        if (v26)
        {
          goto LABEL_84;
        }

        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT *GetQmfOverlapBuffer32(int)";
          v95 = 93;
          goto LABEL_219;
        }

        v27 = 3088;
      }

      else if (v25 == 3)
      {
        if (v26)
        {
          goto LABEL_84;
        }

        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT *GetQmfOverlapBuffer16(int)";
          v95 = 89;
          goto LABEL_219;
        }

        v27 = 1552;
      }

      else
      {
        if (v26)
        {
          goto LABEL_84;
        }

        if (v13 >= 2)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "FLOAT *GetQmfOverlapBuffer(int)";
          v95 = 57;
          goto LABEL_219;
        }

        v27 = 6160;
      }

      v29 = malloc_type_calloc(1uLL, v27, 0x5142B0E1uLL);
      if (!v29)
      {
        v14[1] = 0;
LABEL_114:
        CDK_QmfDomain_FreePersistentMemory(a1);
LABEL_115:
        CDK_QmfDomain_FreePersistentMemory(a1);
        *(a1 + 56) = 0;
        *(a1 + 1) = 0;
        *(a1 + 3) = 0;
        *(a1 + 64) = 0;
        *(a1 + 66) = 0;
        *(a1 + 70) = 0;
        *(a1 + 72) = 0;
        *(a1 + 74) = 0;
        result = 1;
        *(a1 + 76) = 0;
        return result;
      }

      v30 = -(v29 + 8) & 7;
      v28 = &v29[v30 + 8];
      *&v29[v30] = v29;
    }

    else
    {
      v28 = 0;
    }

    v14[1] = v28;
LABEL_84:
    ++v13;
    v14 += 16;
  }

  while (v13 < *(a1 + 1));
  v12 = *(a1 + 3);
LABEL_86:
  if (v12)
  {
    v31 = 0;
    v32 = (a1 + 408);
    do
    {
      if (*(a1 + 66))
      {
        if (!*v32)
        {
          if (v31 >= 2)
          {
            exception = __cxa_allocate_exception(0x10uLL);
            *exception = "FLOAT *GetSynQmfStates(int)";
            v95 = 45;
            goto LABEL_219;
          }

          v33 = malloc_type_calloc(0x240uLL, 4uLL, 0x5142B0E1uLL);
          *v32 = v33;
          if (!v33)
          {
            goto LABEL_114;
          }

          v12 = *(a1 + 3);
        }
      }

      else
      {
        *v32 = 0;
      }

      ++v31;
      v32 += 10;
    }

    while (v31 < v12);
  }

  v4 = *(a1 + 64);
  if (v4 == 32 && *(a1 + 66) == 32 && (*(a1 + 56) & 0x14) == 0)
  {
    *(a1 + 60) |= 0x40u;
  }

  v11 = *(a1 + 60);
  v6 = 0;
  if ((~v11 & 0x14) == 0)
  {
    v11 &= ~4u;
    *(a1 + 60) = v11;
  }

LABEL_101:
  if (*(a1 + 56) == v11)
  {
    if (v6)
    {
      return 0;
    }
  }

  else
  {
    *(a1 + 56) = v11;
  }

  v34 = 0;
  v35 = *(a1 + 76);
  if (*(a1 + 5) && v35 == 1)
  {
    *(a1 + 289) = v4;
    v36 = *(a1 + 70);
    *(a1 + 288) = v36;
    v34 = 2 * v4 * v36;
  }

  v37 = 2 * *(a1 + 161) * *(a1 + 160);
  v38 = v34 + v37 * v35;
  if (v38 > 0x2800)
  {
    goto LABEL_115;
  }

  v39 = (a1 + 16);
  if (v38)
  {
    if (!*v39)
    {
      v40 = malloc_type_calloc(1uLL, 0x2010uLL, 0x5142B0E1uLL);
      if (v40)
      {
        v41 = -(v40 + 8) & 7;
        v42 = &v40[v41 + 8];
        *&v40[v41] = v40;
      }

      else
      {
        v42 = 0;
      }

      *v39 = v42;
    }

    if (v38 >= 0x801)
    {
      if (!*(a1 + 24))
      {
        v43 = malloc_type_calloc(1uLL, 0x2010uLL, 0x5142B0E1uLL);
        if (v43)
        {
          v44 = -(v43 + 8) & 7;
          v45 = &v43[v44 + 8];
          *&v43[v44] = v43;
        }

        else
        {
          v45 = 0;
        }

        *(a1 + 24) = v45;
      }

      if (v38 > 0x1000)
      {
        if (!*(a1 + 32))
        {
          v46 = malloc_type_calloc(1uLL, 0x2010uLL, 0x5142B0E1uLL);
          if (v46)
          {
            v47 = -(v46 + 8) & 7;
            v48 = &v46[v47 + 8];
            *&v46[v47] = v46;
          }

          else
          {
            v48 = 0;
          }

          *(a1 + 32) = v48;
        }

        if (v38 >= 0x1801)
        {
          if (!*(a1 + 40))
          {
            v49 = malloc_type_calloc(1uLL, 0x2010uLL, 0x5142B0E1uLL);
            if (v49)
            {
              v50 = -(v49 + 8) & 7;
              v51 = &v49[v50 + 8];
              *&v49[v50] = v49;
            }

            else
            {
              v51 = 0;
            }

            *(a1 + 40) = v51;
          }

          if (v38 > 0x2000 && !*(a1 + 48))
          {
            v52 = malloc_type_calloc(1uLL, 0x2010uLL, 0x5142B0E1uLL);
            if (v52)
            {
              v53 = -(v52 + 8) & 7;
              v54 = &v52[v53 + 8];
              *&v52[v53] = v52;
            }

            else
            {
              v54 = 0;
            }

            *(a1 + 48) = v54;
          }
        }
      }
    }
  }

  v55 = *(a1 + 76);
  if (*(a1 + 76))
  {
    v56 = 0;
    v57 = (a1 + 160);
    v58 = *(a1 + 76);
    do
    {
      if (v37 >= 2 * v57[1] * *v57)
      {
        *(v57 + 3) = v39;
        *(v57 + 1) = v56;
        *(v57 + 2) = 2048;
      }

      v56 += v37;
      v57 += 128;
      --v58;
    }

    while (v58);
  }

  if (*(a1 + 5))
  {
    v59 = *(a1 + 1);
    if (v55 < v59)
    {
      v60 = 2 * *(a1 + 289) * *(a1 + 288);
      v61 = v37 * v55;
      v62 = v59 - v55;
      do
      {
        if (v60 <= v34)
        {
          *(a1 + 312) = v39;
          *(a1 + 290) = v61;
          *(a1 + 292) = 2048;
        }

        --v62;
      }

      while (v62);
    }
  }

  v63 = *(a1 + 3);
  if (*(a1 + 3))
  {
    v64 = (a1 + 388);
    v65 = *(a1 + 3);
    do
    {
      if (!*(v64 - 1) && !*v64)
      {
        v66 = *(a1 + 68);
        if (v66 >= 0x40)
        {
          v66 = 64;
        }

        *(v64 - 1) = *(a1 + 65);
        *v64 = v66;
      }

      v64 += 20;
      --v65;
    }

    while (v65);
  }

  if (*(a1 + 66) >= 0x40u)
  {
    v67 = 64;
  }

  else
  {
    v67 = *(a1 + 66);
  }

  v68 = *(a1 + 74);
  if ((v68 & 7) != 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int CDK_QmfDomain_InitFilterBank(HANDLE_CDK_QMF_DOMAIN, UINT)";
    v95 = 377;
LABEL_219:
    exception[2] = v95;
  }

  v69 = *(a1 + 70);
  v70 = *(a1 + 64);
  if (*(a1 + 1))
  {
    v71 = 0;
    v72 = 0;
    v73 = a1 + 80;
    v97 = v67;
    v98 = *(a1 + 70);
    v96 = *(a1 + 64);
    while (1)
    {
      v74 = v73 + (v71 << 7);
      v75 = *(v74 + 96);
      if (!v75)
      {
        if (*(a1 + 72))
        {
          return 2;
        }
      }

      v76 = *(a1 + 76);
      if (v76 <= 1)
      {
        v76 = 1;
      }

      LODWORD(v77) = v76 - 1;
      v77 = v71 >= v77 ? v77 : v71;
      v78 = v73 + (v77 << 7);
      v79 = *(v78 + 104);
      v80 = *(v78 + 82);
      v81 = *(v78 + 84);
      if (!v79)
      {
        if (*(a1 + 70))
        {
          return 2;
        }
      }

      v99 = v72;
      *v74 = a1;
      v82 = *(a1 + 72);
      if (*(a1 + 72))
      {
        v83 = 0;
        do
        {
          *(*(v74 + 112) + v83) = v75;
          *(*(v74 + 120) + v83) = v75 + 4 * v68;
          v83 += 8;
          v75 += 8 * v68;
        }

        while (8 * v82 != v83);
      }

      if (*(a1 + 70))
      {
        do
        {
          *(*(v74 + 112) + 8 * v82) = CDK_getWorkBuffer(v79, v80, v81, v68);
          v84 = v80 + v68;
          *(*(v74 + 120) + 8 * v82) = CDK_getWorkBuffer(v79, v84, v81, v68);
          v80 = v84 + v68;
          ++v82;
        }

        while (v82 < *(a1 + 70) + *(a1 + 72));
      }

      v70 = v96;
      v67 = v97;
      if (*(v74 + 56))
      {
        v85 = *(v74 + 56);
      }

      else
      {
        v85 = v96;
      }

      if (*(v74 + 60))
      {
        v86 = *(v74 + 60);
      }

      else
      {
        v86 = v97;
      }

      v69 = v98;
      v72 = qmfInitAnalysisFilterBank(v74 + 8, *(v74 + 88), v98, v85, v86, *(a1 + 64), *(a1 + 56)) | v99;
      ++v71;
      v87 = *(a1 + 1);
      v73 = a1 + 80;
      if (v71 >= v87)
      {
        v63 = *(a1 + 3);
        goto LABEL_190;
      }
    }
  }

  LODWORD(v87) = 0;
  v72 = 0;
LABEL_190:
  if (v63)
  {
    v88 = 0;
    v89 = a1 + 336;
    do
    {
      v90 = *(v89 + 60);
      if (*(v89 + 48))
      {
        v91 = *(v89 + 48);
      }

      else
      {
        v91 = v70;
      }

      if (*(v89 + 52))
      {
        v92 = *(v89 + 52);
      }

      else
      {
        v92 = v67;
      }

      inited = qmfInitSynthesisFilterBank(v89, *(v89 + 72), v69, v91, v92, *(a1 + 66), *(a1 + 56));
      if (v90 != 0.0)
      {
        *(v89 + 60) = v90;
      }

      v72 |= inited;
      ++v88;
      v89 += 80;
    }

    while (v88 < *(a1 + 3));
    LODWORD(v87) = *(a1 + 1);
  }

  UsacQmf::InitAnalysis((a1 + 496), v87, v69, *(a1 + 64));
  UsacQmf::InitSynthesis((a1 + 496), *(a1 + 3), v69, *(a1 + 66));
  UsacQmf::InitAnalysis((a1 + 768), *(a1 + 1), 1u, *(a1 + 64));
  UsacQmf::InitSynthesis((a1 + 768), *(a1 + 3), 1u, *(a1 + 66));
  return 2 * (v72 != 0);
}

uint64_t sbrDecoder_Apply(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int *a5, _DWORD *a6, uint64_t a7, unsigned int a8, int a9, BOOL *a10, uint64_t a11)
{
  v186 = *MEMORY[0x1E69E9840];
  result = 1;
  if (!a1 || !a3 || !a5 || !a6 || !a10)
  {
    return result;
  }

  if (!CDK_chMapDescr_isValid(a7))
  {
    return 1;
  }

  v20 = *a5;
  if (*a5 < 1)
  {
    return 1;
  }

  v21 = *(a1 + 508);
  if (v21 < 1)
  {
    return 3;
  }

  v22 = 0;
  v170 = *a10;
  do
  {
    if (!*(a1 + v22))
    {
      return 3;
    }

    v22 += 8;
  }

  while (8 * v21 != v22);
  if (v21 != 1 || *(*a1 + 104))
  {
    v170 = 0;
  }

  if (*(a1 + 512) > *(*(a1 + 496) + 1))
  {
    return 6;
  }

  v158 = a5;
  v159 = a6;
  v166 = a3;
  if ((*(a1 + 537) & 0x40) != 0)
  {
    v23 = *(a1 + 534) + 1;
  }

  else
  {
    v23 = 0;
  }

  v24 = 0;
  v176 = 0;
  *(a1 + 534) = v23;
  v163 = a1 + 16;
  if (v20 <= 2)
  {
    v25 = 2;
  }

  else
  {
    v25 = v20;
  }

  if (!v170)
  {
    v25 = v20;
  }

  v161 = v25;
  v181 = a1;
  v169 = a8;
  v167 = a2;
  v168 = a7;
  v162 = a4;
  v160 = v20;
  do
  {
    v26 = *(a1 + 8 * v24);
    v27 = *(v26 + 26);
    if (v27 == 1)
    {
      v28 = 2;
    }

    else
    {
      v28 = 1;
    }

    if (!a9)
    {
      *(v26 + 112) = 1;
      v26 = *(a1 + 8 * v24);
      v27 = *(v26 + 26);
    }

    v29 = *(v26 + 113);
    v30 = *(v26 + v29 + 114);
    v174 = *(a1 + 524);
    v180 = *(v26 + 27);
    v173 = *v26;
    v171 = v28;
    if (v27 == 1)
    {
      v175 = (v26[1] + 1944 * *(v26 + 113));
    }

    else
    {
      v175 = 0;
    }

    v177 = v27;
    v172 = v24;
    v31 = (v163 + 240 * v24);
    v32 = *(a1 + 536);
    if ((v32 & 0x4000) != 0 && *(a1 + 534) > *(a1 + 532))
    {
      *v31 = 1;
    }

    v33 = &v31[60 * v30];
    *(v33 + 5) = *(v26 + v29 + 112);
    v34 = *v33;
    if (*v33)
    {
      if ((*(v33 + 4) & 1) == 0)
      {
        goto LABEL_160;
      }
    }

    else
    {
      result = initHeaderData(v33, *(a1 + 516), *(a1 + 520), *(a1 + 528), v174, v32, 1);
      if (result)
      {
        return result;
      }

      *v33 = 1;
      result = resetFreqBandTables(v33, *(a1 + 536));
      if (result)
      {
        *v33 = 0;
        return result;
      }

      v34 = *v33;
      if (*v33 == 1)
      {
        v35 = *(v33 + 7);
        *(v33 + 44) = v35;
        *(v33 + 45) = v35;
      }

      *(v33 + 4) |= 1u;
    }

    v165 = v29;
    v36 = v34 == 3 || v34 == 2 && *(v33 + 5) == 0;
    v164 = v36;
    if (v180 >= 1)
    {
      for (i = 0; i != v180; ++i)
      {
        v39 = v26[i];
        v182 = *(a1 + 536);
        memset(__b, 170, sizeof(__b));
        memset(v184, 170, sizeof(v184));
        v40 = *(v39 + 13872);
        v41 = *(v33 + 44);
        if (*v33 == 3)
        {
          v42 = *(v39 + 13932);
        }

        else
        {
          v42 = *(v39 + 13932);
          if (*v33 != 2 || *(v33 + 5) != 0)
          {
            v44 = 0;
            v179 = *(v40 + 48);
            goto LABEL_66;
          }
        }

        v44 = 1;
        v179 = *(v33 + 44);
LABEL_66:
        v46 = *(v40 + 112);
        v45 = *(v40 + 120);
        if (v42)
        {
          v47 = *(v40 + 56);
        }

        else
        {
          v47 = *(v40 + 48);
        }

        v178 = v47;
        *(v39 + 2696) = 1;
        v48 = *(v39 + 13880);
        if (!v48)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "SBR_ERROR resetSbrDec(HANDLE_SBR_DEC, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_PREV_FRAME_DATA, const int, const UINT, HANDLE_SBR_FRAME_DATA)";
          exception[2] = 725;
        }

        v49 = v48[10];
        if (v49 >= v41)
        {
          v50 = v41;
        }

        else
        {
          v50 = v48[10];
        }

        v48[12] = v50;
        v51 = *(v33 + 45);
        if (v49 >= v51)
        {
          v49 = *(v33 + 45);
        }

        v48[13] = v49;
        *(v40 + 56) = v50;
        *(v40 + 60) = v49;
        v52 = *(v33 + 8);
        v53 = *(v39 + 2213);
        v54 = *(v33 + 6);
        resetLppTransposer(*(v39 + 2872), v41, (v33 + 172), *(v33 + 43), v33 + 166, *(v33 + 42), v51, *(v33 + 12));
        if (v55)
        {
          goto LABEL_76;
        }

        v56 = ((v53 - v54) * v52) & ~(((v53 - v54) * v52) >> 31);
        *(v39 + 13928) = 0;
        if ((v44 & (v182 >> 8) & 1) == 0)
        {
          v66 = *(v39 + 2872);
          goto LABEL_146;
        }

        v57 = *(v39 + 13864);
        if (!v57)
        {
          goto LABEL_119;
        }

        v58 = *(v33 + 64);
        v59 = *v58;
        *(v57 + 48) = v59;
        v60 = *(v57 + 56);
        if (v60)
        {
          v61 = 16;
        }

        else
        {
          v61 = 32;
        }

        if (v59 > v61)
        {
          v156 = __cxa_allocate_exception(0x10uLL);
          *v156 = "SBR_ERROR QmfTransposerReInit(HANDLE_HBE_TRANSPOSER, UCHAR **, UCHAR *)";
          v156[2] = 621;
        }

        *(v57 + 52) = v58[*(v33 + 40)];
        v62 = ((v59 + 4) >> 1) & 0xFC;
        v63 = v62 + 4;
        *(v57 + 2692) = v62 + 4;
        v64 = startSubband2kL[v59];
        *(v57 + 2688) = v64;
        if (v60)
        {
          if ((v64 + v63) > 16)
          {
            v65 = 12;
LABEL_93:
            v64 = v65 - v62;
            *(v57 + 2688) = v64;
          }
        }

        else if (*(v57 + 28) == 768 && (v64 + v63) >= 25)
        {
          v65 = 20;
          goto LABEL_93;
        }

        *(v57 + 240) = &preModCos + 4 * v64;
        *(v57 + 248) = &preModSin + 4 * v64;
        v67 = 2 * v63 - 8;
        if (v67 <= 0x27)
        {
          v68 = *(&off_1E7531298 + v67);
          v69 = *(&off_1E75312C0 + v67);
          if (!qmfInitSynthesisFilterBank(v57 + 168, v57 + 1856, *(v57 + 40), 0, v63, v63, 1) && !qmfInitAnalysisFilterBank(v57 + 96, v57 + 256, *(v57 + 40) / 2, 0, 2 * *(v57 + 2692), 2 * *(v57 + 2692), 0))
          {
            *(v57 + 120) = v68;
            *(v57 + 128) = v69;
            *(v57 + 8) = 0;
            *(v57 + 16) = 0;
            *v57 = 0;
            if (*(v57 + 56))
            {
              *(v57 + 24) = 4;
              v70 = 7;
            }

            else
            {
              v70 = 5;
            }

            LODWORD(v71) = 0;
            v72 = *(v33 + 64);
            v73 = 1;
            while (1)
            {
              v74 = *(v33 + 40);
              if (v71 > v74)
              {
                break;
              }

              v75 = *(v57 + 48) * v73;
              v71 = v71;
              v76 = v74 - v71 + 1;
              while (v75 >= *(v72 + v71))
              {
                ++v71;
                if (!--v76)
                {
                  goto LABEL_115;
                }
              }

              v77 = *(v72 - 1 + v71);
              if (v75 - v77 >= 4)
              {
                v78 = 0;
                v79 = *(v33 + 72);
                v80 = *(v33 + 41) + 1;
                while (v75 >= *(v79 + v78))
                {
                  if (v80 == ++v78)
                  {
                    goto LABEL_112;
                  }
                }

                v80 = v78;
LABEL_112:
                v77 = *(v79 + v80 - 1);
              }

              *(v57 + 4 * v73++ - 4) = v77;
              if (v73 == v70)
              {
                goto LABEL_119;
              }
            }

LABEL_115:
            *(v57 + (((v73 << 32) - 0x100000000) >> 30)) = *(v57 + 52);
            if (v73 >= 4)
            {
              v81 = 4;
            }

            else
            {
              v81 = v73;
            }

            *(v57 + 24) = v81;
LABEL_119:
            v82 = 0;
            LODWORD(v83) = *(*(v39 + 2872) + 72);
            v84 = (v39 + 4696);
            do
            {
              CDKmemcpy(v84 - 1792, *(*(v39 + 13912) + 8 * (v82 + *(*(v39 + 13864) + 40) - v83 - 2)), (4 * *(*(v39 + 13864) + 44)));
              CDKmemcpy(v84, *(*(v39 + 13920) + 8 * (v82++ + *(*(v39 + 13864) + 40) - *(*(v39 + 2872) + 72) - 2)), (4 * *(*(v39 + 13864) + 44)));
              v83 = *(*(v39 + 2872) + 72);
              v85 = (v83 + 2);
              v84 += 128;
            }

            while (v82 < v85);
            v86 = 0;
            *(v39 + 13928) = 1;
            v87 = v39 + 10072;
            v88 = v83;
            do
            {
              *(__b + v86) = v87 - 3584;
              v184[v86 / 8] = v87;
              v86 += 8;
              v87 += 256;
            }

            while (8 * v83 + 16 != v86);
            v89 = *(v39 + 13864);
            v90 = *(v89 + 40);
            if (v90 < 1)
            {
              if ((v182 & 0x80) == 0)
              {
                goto LABEL_131;
              }
            }

            else
            {
              v91 = *(v39 + 13912);
              v92 = *(v39 + 13920);
              v93 = &v184[v88 + 2];
              v94 = (&__b[1] + v88 * 8);
              v95 = *(v89 + 40);
              do
              {
                v96 = *v91++;
                *v94++ = v96;
                v97 = *v92++;
                *v93++ = v97;
                --v95;
              }

              while (v95);
              if ((v182 & 0x80) == 0)
              {
                v98 = *(v39 + 13896);
                v99 = v85 + v90;
                v100 = *(v39 + 13904);
                v101 = v90;
                do
                {
                  v102 = *v98++;
                  *(__b + v99) = v102;
                  v103 = *v100++;
                  v184[v99++] = v103;
                  --v101;
                }

                while (v101);
LABEL_131:
                if (!*(v39 + 1939))
                {
                  QmfTransposerApply(v89, &__b[1] + 8 * v83, &v184[v83 + 2], __b, v184, 0, v83, 3);
                  v89 = *(v39 + 13864);
                  v83 = *(*(v39 + 2872) + 72);
                  LODWORD(v90) = *(v89 + 40);
                }

                QmfTransposerApply(v89, &__b[1] + 8 * v83 + 8 * v90, &v184[v83 + 2 + v90], __b, v184, *(v39 + 2215), v83, 2);
LABEL_139:
                v66 = *(v39 + 2872);
                if (!*(v39 + 1939))
                {
                  LODWORD(v111) = *(v66 + 72);
                  if (v56 < v111)
                  {
                    v112 = (v39 + (v56 << 8) + 10584);
                    v113 = v56;
                    do
                    {
                      CDKmemcpy(*(*(*(v39 + 13872) + 112) + 8 * v113), v112 - 3584, 0x100uLL);
                      CDKmemcpy(*(*(*(v39 + 13872) + 120) + 8 * v113++), v112, 0x100uLL);
                      v66 = *(v39 + 2872);
                      v111 = *(v66 + 72);
                      v112 += 256;
                    }

                    while (v113 < v111);
                  }

                  if (v56 < v111)
                  {
                    v114 = (4 * v179);
                    v115 = v56;
                    do
                    {
                      CDKmemcpy(*(*(*(v39 + 13872) + 112) + 8 * v115), *(*(v39 + 13912) + 8 * (v115 + *(*(v39 + 13864) + 40) - v111)), v114);
                      CDKmemcpy(*(*(*(v39 + 13872) + 120) + 8 * v115), *(*(v39 + 13920) + 8 * (v115 + *(*(v39 + 13864) + 40) - *(*(v39 + 2872) + 72))), v114);
                      ++v115;
                      v66 = *(v39 + 2872);
                      v111 = *(v66 + 72);
                    }

                    while (v115 < v111);
                  }
                }

LABEL_146:
                v116 = *(v39 + 1939);
                if ((v182 & 4) != 0 && v116 == 1)
                {
                  if (v56 >= *(v66 + 72))
                  {
                    v116 = 1;
                  }

                  else
                  {
                    v117 = 4 * ((v179 - v178) & ~((v179 - v178) >> 31));
                    v118 = (v39 + (v56 << 7) + 4 * v178 + 4952);
                    do
                    {
                      CDKmemcpy((*(v46 + 8 * v56) + 4 * v178), v118 - 1792, v117);
                      CDKmemcpy((*(v45 + 8 * v56++) + 4 * v178), v118, v117);
                      v66 = *(v39 + 2872);
                      v118 += 128;
                    }

                    while (v56 < *(v66 + 72));
                    v116 = *(v39 + 1939);
                  }
                }

                v119 = *(v39 + 13864);
                a1 = v181;
                if (v119)
                {
                  v120 = v119[14];
                }

                else
                {
                  v120 = 0;
                }

                v121 = ResetLimiterBands((v33 + 47), (v33 + 60), *(v33 + 64), *(v33 + 40), v66 + 14, *(v66 + 1), *(v33 + 21), v116, v119, v120);
                *(v39 + 2720) = *(v39 + 1939);
                if (!v121)
                {
                  continue;
                }

                goto LABEL_77;
              }
            }

            if (!*(v39 + 1939))
            {
              v104 = (v90 / 2);
              if (v90 >= 2)
              {
                v105 = *(v39 + 13896);
                v106 = *(v39 + 13904);
                v107 = v90 + v83 + 2;
                v108 = v104;
                do
                {
                  v109 = *v105++;
                  *(__b + v107) = v109;
                  v110 = *v106++;
                  v184[v107++] = v110;
                  --v108;
                }

                while (v108);
              }

              QmfTransposerApply(v89, &__b[1] + 8 * v83 + 8 * v104, &v184[v83 + 2 + v104], __b, v184, *(v39 + 2215), v83, 2);
              copyHarmonicSpectrum(v89, __b, v184, *(*(v39 + 13864) + 40), *(*(v39 + 2872) + 72), 2);
            }

            goto LABEL_139;
          }
        }

LABEL_76:
        a1 = v181;
LABEL_77:
        *v33 = 1;
      }
    }

    LODWORD(v29) = v165;
    if (v164)
    {
      *(v33 + 4) &= ~1u;
    }

LABEL_160:
    v122 = (v173 + 1944 * v29);
    if (*v33 == 3 || *v33 == 2 && !*(v33 + 5))
    {
      if (v177 == 1)
      {
        v123 = v26[1] + 1944;
      }

      else
      {
        v123 = 0;
      }

      v124 = *v26;
      *&v125 = -1;
      *(&v125 + 1) = -1;
      __b[13] = v125;
      __b[12] = v125;
      __b[11] = v125;
      __b[10] = v125;
      __b[9] = v125;
      __b[8] = v125;
      __b[7] = v125;
      __b[6] = v125;
      __b[5] = v125;
      __b[4] = v125;
      __b[3] = v125;
      __b[2] = v125;
      __b[1] = v125;
      __b[0] = v125;
      CDKmemcpy(__b, (v124 + 1944), 0xE0uLL);
      if (*(v33 + 5) || !*(v33 + 37))
      {
        decodeEnvelope(v33, v122, v124 + 1944, v123);
        decodeNoiseFloorlevels(*(v33 + 42), v122, v124 + 1944);
        if (v175)
        {
          v126 = *(v33 + 5);
          decodeEnvelope(v33, v175, v123, v124 + 1944);
          decodeNoiseFloorlevels(*(v33 + 42), v175, v123);
          if (!v126 && *(v33 + 5))
          {
            CDKmemcpy((v124 + 1944), __b, 0xE0uLL);
            decodeEnvelope(v33, v122, v124 + 1944, v123);
          }

          if (v122[16])
          {
            v127 = (v122 + 20);
            v128 = *v122;
            if (v128 >= 1)
            {
              v129 = (v175 + 20);
              do
              {
                v130 = *v129 * 0.0000038147;
                v131 = (*v127 + *v127) / (v130 + 1.0);
                *v129++ = v131;
                *v127++ = v130 * v131;
                --v128;
              }

              while (v128);
            }

            if (*(v122 + 24) * *(v33 + 42))
            {
              v132 = (v122 + 468);
              v133 = (v175 + 468);
              if (*(v122 + 24) * *(v33 + 42) <= 1)
              {
                v134 = 1;
              }

              else
              {
                v134 = *(v122 + 24) * *(v33 + 42);
              }

              do
              {
                v135 = 6.0 - *v132;
                v136 = exp2((*v133 + -12.0));
                v137 = exp2((v135 + 1.0));
                v138 = v137 / (v136 + 1.0);
                *v133++ = v138;
                *v132++ = v138 * v136;
                --v134;
              }

              while (v134);
            }
          }
        }
      }

      else
      {
        if (v175)
        {
          v157 = __cxa_allocate_exception(0x10uLL);
          *v157 = "void decodeSbrData(HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_SBR_PREV_FRAME_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_SBR_PREV_FRAME_DATA)";
          v157[2] = 170;
        }

        decodeNoiseFloorlevels(*(v33 + 42), v122, v124 + 1944);
      }

      *v33 = 3;
      a1 = v181;
    }

    if (v161 * *(v33 + 6) * *(v33 + 8) * *(*(a1 + 496) + 66) > v162)
    {
      return 8;
    }

    MapValue = CDK_chMapDescr_getMapValue(v168, v176, v169);
    if (v170 || v177 == 1)
    {
      v140 = CDK_chMapDescr_getMapValue(v168, (v176 + 1), v169);
      v141 = v174;
      v142 = v140 * v174;
      v183 = v140;
    }

    else
    {
      v142 = 0;
      v183 = 255;
      v141 = v174;
    }

    sbr_dec(*v26 + 2248, v167 + 4 * MapValue * v141, v33, v122, *v26 + 1944, *v33 == 3, *(v181 + 536), *(v181 + 496) + 496, 0);
    if ((*(v181 + 538) & 0x40) != 0 || (*(a11 + 32) & 1) == 0)
    {
      v147 = 0;
      v148 = *(v181 + 496);
      v144 = *(v148 + 66);
      v145 = *(v148 + 72) + *(v148 + 70);
    }

    else
    {
      v143 = *(v181 + 496);
      v144 = *(v143 + 66);
      v145 = *(v143 + 72) + *(v143 + 70);
      if (*(a11 + 34) == 3)
      {
        if (v145)
        {
          v146 = 0;
          do
          {
            memcpy(*(*a11 + v146), *(*(*(*v26 + 13872) + 112) + v146), 4 * v144);
            memcpy(*(*(a11 + 8) + v146), *(*(*(*v26 + 13872) + 120) + v146), 4 * v144);
            v146 += 8;
          }

          while (8 * v145 != v146);
        }

        v147 = 1;
      }

      else
      {
        v147 = 0;
      }
    }

    if (v177 != 1)
    {
      goto LABEL_202;
    }

    sbr_dec(v26[1] + 2248, v167 + 4 * v142, v33, v175, v26[1] + 1944, *v33 == 3, *(v181 + 536), *(v181 + 496) + 496, 1u);
    if (!v147)
    {
      goto LABEL_207;
    }

    if (v145)
    {
      v149 = 0;
      do
      {
        memcpy(*(*(a11 + 16) + v149), *(*(*(v26[1] + 13872) + 112) + v149), 4 * v144);
        memcpy(*(*(a11 + 24) + v149), *(*(*(v26[1] + 13872) + 120) + v149), 4 * v144);
        v149 += 8;
      }

      while (8 * v145 != v149);
LABEL_202:
      if (!v147)
      {
        goto LABEL_207;
      }
    }

    LODWORD(__b[0]) = -1431655766;
    if (MPEG_D::USAC::DynRangeCompressor::ProcessQMFDomain(a11, a11, a11, __b))
    {
      return 5;
    }

    if (v145)
    {
      v150 = 0;
      do
      {
        memcpy(*(*(*(*v26 + 13872) + 112) + v150), *(*a11 + v150), 4 * v144);
        memcpy(*(*(*(*v26 + 13872) + 120) + v150), *(*(a11 + 8) + v150), 4 * v144);
        v150 += 8;
      }

      while (8 * v145 != v150);
    }

LABEL_207:
    sbr_dec2((*v26 + 2248), (v166 + 4 * MapValue), v33, *v26 + 1944, *v33 == 3, *(v181 + 536), (*(v181 + 496) + 496), 0);
    if (v177 == 1)
    {
      if (v145)
      {
        v151 = v147;
      }

      else
      {
        v151 = 0;
      }

      if (v151 == 1)
      {
        v152 = 0;
        v153 = 4 * v144;
        do
        {
          memcpy(*(*(*(v26[1] + 13872) + 112) + v152), *(*(a11 + 16) + v152), v153);
          memcpy(*(*(*(v26[1] + 13872) + 120) + v152), *(*(a11 + 24) + v152), v153);
          v152 += 8;
        }

        while (8 * v145 != v152);
      }

      sbr_dec2((v26[1] + 2248), (v166 + 4 * v183), v33, v26[1] + 1944, *v33 == 3, *(v181 + 536), (*(v181 + 496) + 496), 1u);
    }

    a1 = v181;
    v154 = *(v181 + 536);
    *(v181 + 536) = v154 & 0xFFFFFFBF;
    v176 += v171;
    if (v176 >= v160)
    {
      break;
    }

    v24 = v172 + 1;
  }

  while (v172 + 1 < *(v181 + 508));
  if ((v154 & 4) == 0)
  {
    *v158 = v176;
  }

  result = 0;
  *v159 = *(v181 + 520);
  *a10 = (*(v181 + 536) & 0x40) != 0;
  *(v181 + 536) &= 0xFFFF3FFF;
  return result;
}

uint64_t MPEG_D::USAC::DynRangeCompressor::AdjustForHostInput(MPEG_D::USAC::DynRangeCompressor *this)
{
  v1 = *(this + 8);
  if (v1)
  {
    v3 = *(this + 5);
    if (*(v3 + 12))
    {
      *(v3 + 12) = 0;
      if (*(v3 + 13))
      {
        mpddrc::UniDrc::SetRequestTargetLoudness(v1 + 8, *(v3 + 16));
      }

      else
      {
        v24 = 0xAAAAAAAAAAAAAAAALL;
        *&v4 = 0xAAAAAAAAAAAAAAAALL;
        *(&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *__p = v4;
        v23 = v4;
        *v20 = v4;
        v21 = v4;
        v18[4] = v4;
        *v19 = v4;
        v18[2] = v4;
        v18[3] = v4;
        v18[0] = v4;
        v18[1] = v4;
        v16 = v4;
        v17 = v4;
        v14 = v4;
        v15 = v4;
        v12 = v4;
        v13 = v4;
        v10 = v4;
        *v11 = v4;
        v8 = v4;
        *v9 = v4;
        mpddrc::UniDrcInterface::UniDrcInterface(&v8, v1 + 2064);
        BYTE2(v8) = 1;
        LOBYTE(v13) = 0;
        if (!mpddrc::UniDrcInterface::operator==(&v8, (v1 + 2064), v5))
        {
          *(v1 + 2440) = 1;
          mpddrc::UniDrcInterface::operator=(v1 + 2064, &v8);
        }

        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }

        if (v20[1])
        {
          *&v21 = v20[1];
          operator delete(v20[1]);
        }

        if (v19[0])
        {
          operator delete(v19[0]);
        }

        v25 = v18;
        std::vector<mpddrc::DrcFeatureRequest>::__destroy_vector::operator()[abi:ne200100](&v25);
        if (v11[0])
        {
          v11[1] = v11[0];
          operator delete(v11[0]);
        }

        if (v9[0])
        {
          v9[1] = v9[0];
          operator delete(v9[0]);
        }
      }
    }

    v6 = *(this + 5);
    if (*(v6 + 48))
    {
      *(v6 + 48) = 0;
      if (*(v6 + 49))
      {
        mpddrc::UniDrc::SetRequestFromProfile(*(this + 8) + 8, *(v6 + 52));
        v6 = *(this + 5);
      }
    }

    if (*(v6 + 32))
    {
      *(v6 + 32) = 0;
      mpddrc::UniDrc::SetRequestCompressBoost(*(this + 8) + 8, *(v6 + 24), *(v6 + 28));
      v6 = *(this + 5);
    }

    if (*(v6 + 34))
    {
      *(v6 + 34) = 0;
      result = mpddrc::UniDrc::SetRequestOutputPeakLevelMax(*(this + 8) + 8, *(v6 + 36));
      if (result)
      {
        return result;
      }

      v6 = *(this + 5);
    }

    if (*(v6 + 56))
    {
      *(v6 + 56) = 0;
      mpddrc::UniDrc::SetRequestLoudnessEqSensitivity(*(this + 8) + 8, *(v6 + 60));
      v6 = *(this + 5);
    }

    if (*(v6 + 64))
    {
      *(v6 + 64) = 0;
      mpddrc::UniDrc::SetRequestLoudnessEqPlaybackGain(*(this + 8) + 8, *(v6 + 68));
      v6 = *(this + 5);
    }

    if (*(v6 + 72))
    {
      *(v6 + 72) = 0;
      mpddrc::UniDrc::SetRequestLoudnessEqStrength(*(this + 8) + 8, *(v6 + 76));
      v6 = *(this + 5);
    }

    if (*(v6 + 88))
    {
      *(v6 + 88) = 0;
      mpddrc::UniDrc::SetAlbumMode(*(this + 8) + 8, *(v6 + 90) != 0);
    }
  }

  return 0;
}

uint64_t mpddrc::UniDrc::ProcessPostSubbandSynt(uint64_t a1, const void **a2, const void **a3, int a4, int a5)
{
  LODWORD(v6) = a4;
  v45 = *MEMORY[0x1E69E9840];
  result = mpddrc::UniDrc::UpdateConfig(a1);
  if (!result)
  {
    v11 = a1 + 2472;
    v12 = a1 + 2472 + 2144 * *(a1 + 2456);
    if ((*(v12 + 2020) & 1) == 0 && (*(a1 + 2452) != 3 || (*(v11 + 2144 * *(a1 + 2460) + 2020) & 1) == 0) && *(v12 + 1640) != 1)
    {
      return 0;
    }

    v13 = *(a1 + 44);
    v14 = *(a1 + 352);
    if (*(a1 + 360) != v14)
    {
      v15 = *(a1 + 92);
      if ((v15 & 0x80000000) == 0 && *(v14 + 168 * v15 + 12) == 1)
      {
        v13 = *(v14 + 168 * v15 + 16);
      }
    }

    if (*(a1 + 2444) == 1)
    {
      if (v6)
      {
        v6 = v6;
        do
        {
          v16 = *a3++;
          bzero(v16, 4 * v13);
          --v6;
        }

        while (v6);
      }

      return 0;
    }

    v17 = *(v12 + 2016);
    v44 = v17;
    if (*(a1 + 2452) == 3)
    {
      v41 = &v39;
      v18 = v6;
      v40 = v13;
      v19 = MEMORY[0x1EEE9AC00](v12);
      v22 = &v39 - v21;
      if (v23)
      {
        v19 = memset(&v39 - v21, 255, v20);
      }

      MEMORY[0x1EEE9AC00](v19);
      v25 = (&v39 - ((v24 + 15) & 0xFFFFFFFF0));
      if (v6)
      {
        memset(&v39 - ((v24 + 15) & 0xFFFFFFFF0), 170, v24);
        v26 = 4 * v40;
        v27 = v25;
        v28 = v6;
        do
        {
          *v27++ = v22;
          v22 += v26;
          --v28;
        }

        while (v28);
        v29 = v6;
      }

      else
      {
        v29 = 0;
      }

      result = mpddrc::UniDrcProcessor::ProcessPostSubbandSynt(v11 + 2144 * *(a1 + 2456), a1 + 2408, a1 + 8, 0, a2, v25, v29);
      if (!result)
      {
        result = mpddrc::UniDrcProcessor::ProcessPostSubbandSynt(v11 + 2144 * *(a1 + 2460), a1 + 2408, a1 + 8, a5, a2, a3, v6);
        if (!result)
        {
          v32 = *(v11 + 2144 * *(a1 + 2460) + 2016);
          __A = v32;
          v33 = v44 == 1.0 && v32 == 1.0;
          v34 = v40;
          if (!v33)
          {
            if (v44 == v32)
            {
              if (v6)
              {
                do
                {
                  v35 = *a3++;
                  MEMORY[0x19EAE6090](v35, 1, &v44, v35, 1, v34);
                  --v18;
                }

                while (v18);
              }
            }

            else
            {
              __B = (v44 - v32) / v13;
              MEMORY[0x1EEE9AC00](result);
              v37 = (&v39 - ((v36 + 15) & 0x7FFFFFFF0));
              if (v13)
              {
                memset(&v39 - ((v36 + 15) & 0x7FFFFFFF0), 255, v36);
              }

              vDSP_vramp(&__A, &__B, v37, 1, v34);
              if (v6)
              {
                do
                {
                  v38 = *a3++;
                  MEMORY[0x19EAE5FA0](v38, 1, v37, 1, v38, 1, v34);
                  --v18;
                }

                while (v18);
              }
            }
          }

          return 0;
        }
      }
    }

    else
    {
      result = mpddrc::UniDrcProcessor::ProcessPostSubbandSynt(v12, a1 + 2408, a1 + 8, 0, a2, a3, v6);
      if (!result)
      {
        if (v17 != 1.0 && v6 != 0)
        {
          v6 = v6;
          do
          {
            v31 = *a3++;
            MEMORY[0x19EAE6090](v31, 1, &v44, v31, 1, v13);
            --v6;
          }

          while (v6);
        }

        return 0;
      }
    }
  }

  return result;
}

uint64_t mpddrc::UniDrc::UpdateConfig(uint64_t a1)
{
  v1 = a1;
  v342 = *MEMORY[0x1E69E9840];
  if ((*(a1 + 1674) & 1) == 0 && (*(a1 + 1675) & 1) == 0 && *(a1 + 2432) != 1)
  {
    return 0;
  }

  if (*(a1 + 2432) == 1)
  {
    if (*(a1 + 2061) == 1)
    {
      if (*(a1 + 2240) == 1)
      {
        v2 = *(a1 + 2244);
        v3 = (v2 * -0.0039062) + 1.0;
        if (v2 >= 0xFF)
        {
          v3 = 0.0;
        }

        *(a1 + 2412) = v3;
      }

      if (*(a1 + 2248) == 1)
      {
        v4 = *(a1 + 2252);
        v5 = (v4 * -0.0039062) + 1.0;
        if (v4 >= 0xFF)
        {
          v5 = 0.0;
        }

        *(a1 + 2408) = v5;
      }

      if (*(a1 + 2256) == 1)
      {
        *(a1 + 2416) = *(a1 + 2260);
      }
    }

    if (*(a1 + 2059) == 1 && *(a1 + 2192) == 1)
    {
      *(a1 + 2420) = (*(a1 + 2196) * 0.03125) + -16.0;
    }

    if (*(a1 + 2062) == 1 && *(a1 + 2266) == 1)
    {
      *(a1 + 1632) = *(a1 + 1624);
      std::vector<float>::resize((a1 + 1624), (*(a1 + 2328) - *(a1 + 2320)) >> 1);
      v6 = *(v1 + 2320);
      v7 = *(v1 + 2328) - v6;
      if ((v7 & 0x1FFFFFFFELL) != 0)
      {
        v8 = *(v1 + 1624);
        v9 = (v7 >> 1);
        do
        {
          v10 = *v6++;
          v11 = vcvts_n_f32_u32(v10, 2uLL) + -64.0;
          if (!v10)
          {
            v11 = -10000.0;
          }

          *v8++ = v11;
          --v9;
        }

        while (v9);
      }

      *(v1 + 1656) = *(v1 + 1648);
      std::vector<float>::resize((v1 + 1648), (*(v1 + 2352) - *(v1 + 2344)) >> 1);
      v12 = *(v1 + 2344);
      v13 = *(v1 + 2352) - v12;
      if ((v13 & 0x1FFFFFFFELL) != 0)
      {
        v14 = *(v1 + 1648);
        v15 = (v13 >> 1);
        do
        {
          v16 = *v12++;
          v17 = vcvts_n_f32_u32(v16, 2uLL) + -64.0;
          if (!v16)
          {
            v17 = -10000.0;
          }

          *v14++ = v17;
          --v15;
        }

        while (v15);
      }

      *(v1 + 1618) = *(v1 + 2288);
    }

    if (*(v1 + 2056) != *(v1 + 1728) || *(v1 + 2056) && mpddrc::UniDrcInterfaceSignature::operator!=(v1 + 2064, v1 + 1736) || *(v1 + 2057) != *(v1 + 1729) || *(v1 + 2057) && !mpddrc::SystemInterface::operator==((v1 + 2096), v1 + 1768) || *(v1 + 2058) != *(v1 + 1730) || *(v1 + 2058) && (*(v1 + 2136) != *(v1 + 1808) || *(v1 + 2136) && *(v1 + 2140) != *(v1 + 1812)) || *(v1 + 2060) != *(v1 + 1732) || *(v1 + 2060) && (mpddrc::DynamicRangeControlInterface::operator!=((v1 + 2208), (v1 + 1880)) & 1) != 0 || *(v1 + 2061) != *(v1 + 1733) || *(v1 + 2062) != *(v1 + 1734))
    {
      goto LABEL_71;
    }

    if (*(v1 + 2062))
    {
      if (*(v1 + 2264) != *(v1 + 1936) || *(v1 + 2266) != *(v1 + 1938) || *(v1 + 2266) && !mpddrc::SceneControlInterface::operator==((v1 + 2288), (v1 + 1960)))
      {
        goto LABEL_71;
      }

      v18 = *(v1 + 1945);
      if (*(v1 + 2273) != v18)
      {
        goto LABEL_71;
      }

      if (*(v1 + 2273))
      {
        v19 = 6;
      }

      else
      {
        v19 = 4;
      }

      v20 = v18 == 0;
      if (*(v1 + 1945))
      {
        v21 = 6;
      }

      else
      {
        v21 = 4;
      }

      v22 = *(v1 + v21 + 1940);
      if (v20)
      {
        v22 = 0;
      }

      if (*(v1 + 2273) && *(v1 + v19 + 2268) != v22)
      {
        goto LABEL_71;
      }
    }

    if (*(v1 + 2059) == *(v1 + 1731) && (!*(v1 + 2059) || mpddrc::LoudnessNormalizationParameterInterface::OnlyLoudnessNormalizationGainModificationDbChangedFrom((v1 + 2144), (v1 + 1816))))
    {
      v23 = 0;
    }

    else
    {
LABEL_71:
      v23 = 1;
    }

    mpddrc::UniDrcInterface::operator=(v1 + 1728, v1 + 2056);
    v24 = v1 + 8;
    if (*(v1 + 1674))
    {
      goto LABEL_73;
    }
  }

  else
  {
    v24 = a1 + 8;
    if (*(a1 + 1674))
    {
LABEL_73:
      v25 = *(v1 + 2452);
      v26 = *(v1 + 2456);
      *(v1 + 2460) = v26;
      v27 = 1 - v26;
      *(v1 + 2456) = v27;
      if (v25)
      {
        *(v1 + 2452) = 2;
        *(v1 + 2464) = 1;
        goto LABEL_86;
      }

      v30 = (v1 + 2452);
      goto LABEL_82;
    }

    v23 = 0;
  }

  if ((v23 & 1) == 0 && (*(v1 + 1675) & 1) == 0)
  {
    result = 0;
    goto LABEL_263;
  }

  v29 = *(v1 + 2452);
  if (v29 < 2)
  {
    v30 = (v1 + 2452);
    v31 = *(v1 + 2456);
    *(v1 + 2460) = v31;
    v27 = 1 - v31;
    *(v1 + 2456) = v27;
    if (v29)
    {
      v32 = 2;
LABEL_83:
      *v30 = v32;
      goto LABEL_86;
    }

LABEL_82:
    v32 = 1;
    goto LABEL_83;
  }

  *(v1 + 2452) = 2;
  v27 = *(v1 + 2456);
LABEL_86:
  v33 = v1 + 2472;
  v34 = *(v1 + 2428);
  v35 = v1 + 2472 + 2144 * v27;
  *v35 = *(v1 + 2424);
  *(v35 + 1552) = 0xFFFFFFFF00000000;
  *(v35 + 2016) = 0;
  *(v35 + 2020) = 0;
  *(v35 + 2024) = 0;
  *(v35 + 2029) = 0;
  std::vector<mpddrc::EqCoefficients::FilterBlock>::clear[abi:ne200100]((v35 + 1792));
  result = mpddrc::UniDrcSelection::Process(v35 + 8);
  if (result)
  {
    goto LABEL_263;
  }

  __sz = *(v1 + 44);
  v36 = *(v1 + 352);
  v333 = (v35 + 2024);
  if (*(v1 + 360) != v36)
  {
    v37 = *(v1 + 92);
    if ((v37 & 0x80000000) == 0 && *(v36 + 168 * v37 + 12) == 1)
    {
      __sz = *(v36 + 168 * v37 + 16);
    }
  }

  *(v35 + 1552) = 0;
  v335 = v35;
  v38 = *(v35 + 620);
  v332 = v1;
  if (v38)
  {
    v39 = 0;
    v40 = (v335 + 600);
    do
    {
      LODWORD(buf.__end_) = -1431655766;
      if (*(v40 - 5) >= 1)
      {
        v41 = *v40;
        if (*(v335 + 628))
        {
          v42 = v41 == 0;
        }

        else
        {
          v42 = 1;
        }

        v43 = v42;
        LODWORD(buf.__begin_) = *(v40 - 5);
        HIDWORD(buf.__begin_) = v41;
        LOBYTE(buf.__end_) = v43;
        HIDWORD(buf.__end_) = *(v335 + 560);
        result = mpddrc::UniDrcProcessor::InitSelectedDrcSet(v335, v24, v34, &buf);
        if (result)
        {
          v1 = v332;
          goto LABEL_263;
        }

        v38 = *(v335 + 620);
        v1 = v332;
      }

      ++v39;
      ++v40;
    }

    while (v39 < v38);
  }

  result = mpddrc::UniDrcProcessor::SetConstantDelays(v335, v24, v34);
  if (result)
  {
    goto LABEL_263;
  }

  v320 = v33;
  v321 = v24;
  v45 = *(v1 + 48);
  v322 = v34;
  if (!*(v335 + 1552))
  {
LABEL_115:
    v330 = v45;
    v56 = v335;
    v57 = *(v335 + 628) == 0;
    v58 = *(v335 + 624);
    *(v335 + 1644) = -1;
    v59 = v322;
    if (!v58)
    {
      *(v335 + 1648) = -1;
      *(v335 + 1640) = 0;
      goto LABEL_133;
    }

    v60 = *(v1 + 352);
    v61 = *(v1 + 360);
    v62 = 1022611261 * ((v61 - v60) >> 3);
    if (!v62)
    {
      goto LABEL_121;
    }

    v63 = 0;
    v64 = (v60 + 8);
    while (*v64 != 1 || !*(v64 - 1))
    {
      ++v63;
      v64 += 42;
      if (v62 == v63)
      {
        goto LABEL_121;
      }
    }

    *(v335 + 1644) = v63;
    if ((v63 & 0x80000000) != 0)
    {
LABEL_121:
      if (gDRCScope)
      {
        v65 = *gDRCScope;
        if (!*gDRCScope)
        {
          goto LABEL_133;
        }
      }

      else
      {
        v65 = MEMORY[0x1E69E9C10];
      }

      if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_133;
      }

      LODWORD(buf.__begin_) = 136315394;
      *(&buf.__begin_ + 4) = "MPDDRC.cpp";
      WORD2(buf.__end_) = 1024;
      *(&buf.__end_ + 6) = 698;
      v67 = "%25s:%-5d ERROR: no applicable drcCoefficientsUniDrc found\n";
      goto LABEL_132;
    }

    *(v335 + 1648) = -1;
    v173 = *(v1 + 424);
    v174 = *(v1 + 432);
    v175 = v174 - v173;
    if (v174 == v173)
    {
      goto LABEL_278;
    }

    v176 = 0;
    v177 = 0;
    v178 = 0xEF7BDEF7BDEF7BDFLL * (v175 >> 3);
    while (*(v173 + 248 * v176 + 32) != v58)
    {
      v176 = ++v177;
      if (v178 <= v177)
      {
        goto LABEL_278;
      }
    }

    *(v335 + 1648) = v177;
    if ((v177 & 0x80000000) != 0)
    {
LABEL_278:
      if (gDRCScope)
      {
        v65 = *gDRCScope;
        if (!*gDRCScope)
        {
          goto LABEL_133;
        }
      }

      else
      {
        v65 = MEMORY[0x1E69E9C10];
      }

      if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_133;
      }

      LODWORD(buf.__begin_) = 136315394;
      *(&buf.__begin_ + 4) = "MPDDRC.cpp";
      WORD2(buf.__end_) = 1024;
      *(&buf.__end_ + 6) = 714;
      v67 = "%25s:%-5d ERROR: no applicable loudEqInstructions found\n";
      goto LABEL_132;
    }

    *(v335 + 1640) = 1;
    if (*(v1 + 1734))
    {
      v179 = *(v1 + 1945);
      v180 = 4;
      if (*(v1 + 1945))
      {
        v180 = 6;
      }

      LODWORD(v44) = *(v1 + 1947);
      v181 = vmovl_u8(*&v44);
      v182 = LODWORD(v44);
      v183 = *(v1 + v180 + 1940);
      v184 = 90.0;
      if (v182)
      {
        v184 = (v181.u16[1] + 23);
      }

      *(v335 + 1656) = v184;
      if ((v182 & 0x10000) != 0)
      {
        v185 = -v181.u8[6];
      }

      else
      {
        v185 = -0.0;
      }

      *(v335 + 1660) = v185;
      if (v179)
      {
        v186 = v183;
      }

      else
      {
        v186 = 0;
      }

      *(v335 + 1672) = v186;
    }

    else
    {
      v185 = *(v335 + 1660);
    }

    *(v335 + 1664) = v185;
    v187 = *(v1 + 44);
    if (v61 != v60)
    {
      v188 = *(v1 + 92);
      if ((v188 & 0x80000000) == 0 && *(v60 + 168 * v188 + 12) == 1)
      {
        v187 = *(v60 + 168 * v188 + 16);
      }
    }

    *(v335 + 1688) = v187;
    v189 = v173 + 248 * v177;
    *(v335 + 1673) = *(v189 + 160);
    *(v335 + 1641) = v57;
    v190 = *(v189 + 168);
    v191 = *(v189 + 176) - v190;
    v192 = *(v335 + 1720);
    v193 = *(v335 + 1728) - v192;
    if (v191 <= v193)
    {
      if (v191 < v193)
      {
        *(v335 + 1728) = v192 + v191;
      }
    }

    else
    {
      std::vector<unsigned char>::__append((v335 + 1720), v191 - v193);
      v190 = *(v189 + 168);
      v191 = *(v189 + 176) - v190;
    }

    if (v191)
    {
      v194 = 0;
      v195 = 0;
      do
      {
        *(*(v335 + 1720) + v194) = *(v190 + v194) - 1;
        v190 = *(v189 + 168);
        if (v195 <= *(v190 + v194))
        {
          v195 = *(v190 + v194);
        }

        ++v194;
      }

      while (v194 < (*(v189 + 176) - v190));
    }

    else
    {
      v195 = 0;
    }

    std::vector<mpddrc::EqCoefficients::FilterBlock>::clear[abi:ne200100]((v335 + 1768));
    v317 = v195;
    std::vector<std::vector<int>>::resize((v335 + 1768), v195);
    v197 = *(v335 + 1728);
    v198 = *(v335 + 1720);
    if (v197 != v198)
    {
      v199 = 0;
      do
      {
        if ((*(v198 + v199) & 0x8000000000000000) == 0)
        {
          v200 = *(v335 + 1768) + 24 * *(v198 + v199);
          v202 = *(v200 + 8);
          v201 = *(v200 + 16);
          if (v202 >= v201)
          {
            v204 = *v200;
            v205 = v202 - *v200;
            v206 = v205 >> 1;
            if (v205 >> 1 <= -2)
            {
              std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
            }

            v207 = v201 - v204;
            if (v207 <= v206 + 1)
            {
              v208 = v206 + 1;
            }

            else
            {
              v208 = v207;
            }

            v209 = v207 >= 0x7FFFFFFFFFFFFFFELL;
            v210 = 0x7FFFFFFFFFFFFFFFLL;
            if (!v209)
            {
              v210 = v208;
            }

            if (v210)
            {
              std::allocator<unsigned short>::allocate_at_least[abi:ne200100](v196, v210);
            }

            *(2 * v206) = v199;
            v203 = 2 * v206 + 2;
            memcpy(0, v204, v205);
            v196 = *v200;
            *v200 = 0;
            *(v200 + 8) = v203;
            *(v200 + 16) = 0;
            if (v196)
            {
              operator delete(v196);
            }

            v56 = v335;
          }

          else
          {
            *v202 = v199;
            v203 = (v202 + 1);
          }

          *(v200 + 8) = v203;
          v197 = *(v56 + 1728);
          v198 = *(v56 + 1720);
        }

        ++v199;
      }

      while (v199 < (v197 - v198));
    }

    v211 = *(v189 + 200);
    v212 = *(v189 + 208) - v211;
    v213 = *(v56 + 1744);
    v214 = *(v56 + 1752) - v213;
    if (v212 <= v214)
    {
      if (v212 < v214)
      {
        *(v56 + 1752) = v213 + v212;
      }
    }

    else
    {
      std::vector<unsigned char>::__append((v56 + 1744), v212 - v214);
      v211 = *(v189 + 200);
      v212 = *(v189 + 208) - v211;
    }

    if (v212)
    {
      v215 = 0;
      do
      {
        *(*(v56 + 1744) + v215) = *(v211 + v215) - 1;
        ++v215;
        v211 = *(v189 + 200);
      }

      while (v215 < (*(v189 + 208) - v211));
    }

    v216 = *(v56 + 1696);
    for (i = *(v56 + 1704); i != v216; std::allocator_traits<std::allocator<mpddrc::LoudnessEqSet::ChannelGroupLeq>>::destroy[abi:ne200100]<mpddrc::LoudnessEqSet::ChannelGroupLeq,void,0>(i))
    {
      i -= 16;
    }

    *(v56 + 1704) = v216;
    std::vector<mpddrc::LoudnessEqSet::ChannelGroupLeq>::resize((v56 + 1696), v317);
    if (v317)
    {
      v218 = 0;
      v327 = 12;
      v316 = v189;
      do
      {
        v219 = (*(v56 + 1768) + 24 * v218);
        v221 = *v219;
        v220 = v219[1];
        v325 = *(v56 + 1696);
        v222 = v325 + (v218 << 7);
        v223 = *(v56 + 1644);
        v224 = *(v332 + 352);
        v225 = *(v56 + 1672);
        v226 = *(v56 + 1688);
        v227 = *(v189 + 224);
        v44 = NAN;
        *(v222 + 12) = -1;
        v228 = (v227 + 24 * v218);
        *v222 = v226;
        *(v222 + 4) = 0;
        v229 = *v228;
        v230 = v228[1];
        v231 = v230 - *v228;
        if (v230 == *v228)
        {
          goto LABEL_417;
        }

        v232 = 0;
        v233 = 0;
        v234 = (v220 - v221) >> 1;
        v235 = v224 + 168 * v223;
        v236 = 0xAAAAAAAAAAAAAAABLL * (v231 >> 3);
        while (1)
        {
          v237 = *(v229 + 24 * v232 + 12);
          if (!v237)
          {
            break;
          }

          v232 = ++v233;
          if (v236 <= v233)
          {
            v238 = 0;
            goto LABEL_341;
          }
        }

        *(v222 + 12) = v233;
        *(v222 + 4) = 1;
        v238 = 1;
LABEL_341:
        v239 = 0;
        v240 = 0;
        do
        {
          if (*(v229 + 24 * v239 + 12) == 1)
          {
            if (!v237)
            {
              *(v222 + 12 + 4 * v238++) = v240;
              *(v222 + 4) = v238;
              goto LABEL_348;
            }

            if (gDRCScope)
            {
              v65 = *gDRCScope;
              if (!*gDRCScope)
              {
LABEL_133:
                v68 = v59;
                mpddrc::UniDrcProcessor::AdjustDelays(v56, v321, v59, *&v44);
                std::vector<mpddrc::EqCoefficients::FilterBlock>::clear[abi:ne200100]((v335 + 1816));
                std::vector<std::vector<float>>::resize((v335 + 1816), v330);
                v69 = *(v335 + 1816);
                if (-1431655765 * ((*(v335 + 1824) - v69) >> 3))
                {
                  v70 = 0;
                  v71 = 0;
                  do
                  {
                    std::vector<float>::resize((v69 + v70), __sz);
                    ++v71;
                    v69 = *(v335 + 1816);
                    v70 += 24;
                  }

                  while (v71 < -1431655765 * ((*(v335 + 1824) - v69) >> 3));
                }

                v72 = *(v332 + 48);
                v73 = v335;
                if (*(v335 + 2024) <= *(v335 + 2028))
                {
                  v74 = *(v335 + 2028);
                }

                else
                {
                  v74 = *(v335 + 2024);
                }

                v75 = mpddrc::GainSampleInterval(v59);
                v331 = v72;
                if (v59 == 1)
                {
                  if (*(v335 + 2036) == 1)
                  {
                    v77 = *(v332 + 80);
                    std::vector<mpddrc::EqCoefficients::FilterBlock>::clear[abi:ne200100]((v335 + 1840));
                    if (*(v335 + 2024))
                    {
                      std::vector<std::vector<float>>::resize((v335 + 1840), v72);
                      if (v72)
                      {
                        v79 = 0;
                        v80 = 24 * v72;
                        do
                        {
                          v81 = (*(v335 + 1840) + v79);
                          v81[1] = *v81;
                          v82 = *v333 + __sz;
                          LODWORD(buf.__begin_) = 0;
                          std::vector<float>::resize(v81, v82, &buf, v78);
                          v79 += 24;
                        }

                        while (v80 != v79);
                      }
                    }

                    v73 = v335;
                    std::vector<mpddrc::EqCoefficients::FilterBlock>::clear[abi:ne200100]((v335 + 1864));
                    if (*(v335 + 2028))
                    {
                      std::vector<std::vector<float>>::resize((v335 + 1864), v77);
                      v73 = v335;
                      if (v77)
                      {
                        v83 = 0;
                        do
                        {
                          v84 = (*(v73 + 1864) + v83);
                          v84[1] = *v84;
                          v85 = *(v73 + 2028) + __sz;
                          LODWORD(buf.__begin_) = 0;
                          std::vector<float>::resize(v84, v85, &buf, v76);
                          v83 += 24;
                          v73 = v335;
                        }

                        while (24 * v77 != v83);
                      }
                    }

                    goto LABEL_182;
                  }
                }

                else
                {
                  v86 = v75;
                  v87 = mpddrc::GainSampleInterval(v59);
                  v88 = (v335 + 1888);
                  v89 = *(v335 + 1896);
                  v90 = *(v335 + 1888);
                  while (v89 != v90)
                  {
                    v89 -= 48;
                    std::__destroy_at[abi:ne200100]<mpddrc::QmfComplexBufferPtr,0>(v89);
                  }

                  *(v335 + 1896) = v90;
                  std::vector<mpddrc::QmfComplexBufferPtr>::resize((v335 + 1888), v72);
                  v91 = __sz / v86;
                  if (v72)
                  {
                    v92 = 0;
                    v93 = 48 * v72;
                    do
                    {
                      v94 = (*v88 + v92);
                      v94[1] = *v94;
                      v94[4] = v94[3];
                      std::vector<float *>::resize(v94, v74 / v87 + v91);
                      std::vector<float *>::resize((*v88 + v92 + 24), v74 / v87 + v91);
                      v92 += 48;
                    }

                    while (v93 != v92);
                  }

                  v73 = v335;
                  v72 = v331;
                  if (*(v335 + 2036))
                  {
                    v326 = *(v332 + 80);
                    v323 = mpddrc::NumAudioCodecSubbands(v68);
                    v95 = *(v335 + 1896);
                    v96 = *(v335 + 1888);
                    while (v95 != v96)
                    {
                      v95 -= 48;
                      std::__destroy_at[abi:ne200100]<mpddrc::QmfComplexBufferPtr,0>(v95);
                    }

                    *(v335 + 1896) = v96;
                    std::vector<mpddrc::QmfComplexBufferPtr>::resize(v88, v331);
                    if (v331)
                    {
                      v97 = 0;
                      do
                      {
                        v98 = (*v88 + v97);
                        v98[1] = *v98;
                        v98[4] = v98[3];
                        std::vector<float *>::resize(v98, v74 / v87 + v91);
                        std::vector<float *>::resize((*v88 + v97 + 24), v74 / v87 + v91);
                        v97 += 48;
                      }

                      while (48 * v331 != v97);
                    }

                    v99 = (v335 + 1912);
                    std::vector<mpddrc::QmfComplexBuffer>::__base_destruct_at_end[abi:ne200100](v335 + 1912, *(v335 + 1912));
                    if (*(v335 + 2024))
                    {
                      std::vector<mpddrc::QmfComplexBuffer>::resize(v99, v331);
                      if (v331)
                      {
                        for (j = 0; j != v331; ++j)
                        {
                          std::vector<mpddrc::EqCoefficients::FilterBlock>::clear[abi:ne200100]((*v99 + 48 * j));
                          std::vector<mpddrc::EqCoefficients::FilterBlock>::clear[abi:ne200100]((*v99 + 48 * j + 24));
                          std::vector<std::vector<float>>::resize((*v99 + 48 * j), *v333 / v87 + v91);
                          std::vector<std::vector<float>>::resize((*v99 + 48 * j + 24), *v333 / v87 + v91);
                          if (*v333 / v87 != -v91)
                          {
                            v101 = 0;
                            v102 = 0;
                            do
                            {
                              v103 = (*v99 + 48 * j);
                              v104 = (*v103 + v101);
                              v104->__end_ = v104->__begin_;
                              *(v103[3] + v101 + 8) = *(v103[3] + v101);
                              std::vector<float>::resize(v104, v323);
                              std::vector<float>::resize((*(*v99 + 48 * j + 24) + v101), v323);
                              ++v102;
                              v101 += 24;
                            }

                            while (v102 < *v333 / v87 + v91);
                          }
                        }
                      }
                    }

                    v73 = v335;
                    std::vector<mpddrc::QmfComplexBuffer>::__base_destruct_at_end[abi:ne200100](v335 + 1936, *(v335 + 1936));
                    if (*(v335 + 2028))
                    {
                      std::vector<mpddrc::QmfComplexBuffer>::resize(v335 + 1936, v326);
                      v73 = v335;
                      if (v326)
                      {
                        for (k = 0; k != v326; ++k)
                        {
                          std::vector<mpddrc::EqCoefficients::FilterBlock>::clear[abi:ne200100]((*(v73 + 1936) + 48 * k));
                          std::vector<mpddrc::EqCoefficients::FilterBlock>::clear[abi:ne200100]((*(v73 + 1936) + 48 * k + 24));
                          std::vector<std::vector<float>>::resize((*(v73 + 1936) + 48 * k), *(v73 + 2028) / v87 + v91);
                          std::vector<std::vector<float>>::resize((*(v335 + 1936) + 48 * k + 24), *(v335 + 2028) / v87 + v91);
                          v73 = v335;
                          if (*(v335 + 2028) / v87 != -v91)
                          {
                            v106 = 0;
                            v107 = 0;
                            do
                            {
                              v108 = (*(v73 + 1936) + 48 * k);
                              v109 = (*v108 + v106);
                              v109->__end_ = v109->__begin_;
                              *(v108[3] + v106 + 8) = *(v108[3] + v106);
                              std::vector<float>::resize(v109, v323);
                              std::vector<float>::resize((*(*(v335 + 1936) + 48 * k + 24) + v106), v323);
                              ++v107;
                              v73 = v335;
                              v106 += 24;
                            }

                            while (v107 < *(v335 + 2028) / v87 + v91);
                          }
                        }
                      }
                    }

                    if (*(v73 + 2020) == 1)
                    {
                      if (*(v73 + 2032))
                      {
                        std::vector<std::vector<float>>::resize((v73 + 1960), v326);
                        v73 = v335;
                        if (v326)
                        {
                          v110 = 0;
                          do
                          {
                            v111 = (*(v73 + 1960) + v110);
                            v111[1] = *v111;
                            v112 = *(v73 + 2032) + __sz;
                            LODWORD(buf.__begin_) = 0;
                            std::vector<float>::resize(v111, v112, &buf, v76);
                            v110 += 24;
                            v73 = v335;
                          }

                          while (24 * v326 != v110);
                        }
                      }
                    }

LABEL_182:
                    *(v73 + 2036) = 0;
                    v72 = v331;
                  }
                }

                *(v73 + 1984) = 0;
                v113 = (v73 + 1992);
                *(v73 + 2000) = *(v73 + 1992);
                LODWORD(buf.__begin_) = 1065353216;
                std::vector<float>::resize((v73 + 1992), v72, &buf, v76);
                if (*(v332 + 1672) == 1 && *(v332 + 1432) == 8 && *(v332 + 1552) == 1)
                {
                  v114 = *(v332 + 1568);
                  v115 = -858993459 * ((*(v332 + 1576) - v114) >> 3);
                  if (v115)
                  {
                    v116 = 0;
                    v117 = *(v332 + 1560);
                    v334 = vdupq_n_s64(v331 - 1);
                    v324 = vdupq_n_s64(4uLL);
                    do
                    {
                      v118 = (v114 + 40 * v116);
                      if (*(v118 + 24) == 1 && *(v118 + 32) == 1)
                      {
                        *v119.i32 = __exp10f((v118[9] - v118[7]) * 0.05);
                        if (*v119.i32 != 1.0)
                        {
                          *(v335 + 1984) = 1;
                          if (v117)
                          {
                            if (v331)
                            {
                              v120 = (*v113 + 8);
                              v121 = (v331 + 3) & 0x1FFFFFFFCLL;
                              v122 = xmmword_19B0A5850;
                              v123 = xmmword_19B0A5840;
                              do
                              {
                                v124 = vmovn_s64(vcgeq_u64(v334, v122));
                                if (vuzp1_s16(v124, v119).u8[0])
                                {
                                  *(v120 - 2) = v119.i32[0];
                                }

                                if (vuzp1_s16(v124, v119).i8[2])
                                {
                                  *(v120 - 1) = v119.i32[0];
                                }

                                if (vuzp1_s16(v119, vmovn_s64(vcgeq_u64(v334, *&v123))).i32[1])
                                {
                                  *v120 = v119.i32[0];
                                  v120[1] = v119.i32[0];
                                }

                                v123 = vaddq_s64(v123, v324);
                                v122 = vaddq_s64(v122, v324);
                                v120 += 4;
                                v121 -= 4;
                              }

                              while (v121);
                            }
                          }

                          else
                          {
                            v125 = *v118;
                            v126 = *(v118 + 1) - *v118;
                            if ((v126 & 0x1FFFFFFFELL) != 0)
                            {
                              v127 = 0;
                              v128 = (v126 >> 1);
                              do
                              {
                                v129 = (v125 + 2 * v127);
                                v130 = *v129;
                                v131 = v129[1] + v130;
                                if (v331 >= v131)
                                {
                                  v132 = v131;
                                }

                                else
                                {
                                  v132 = v331;
                                }

                                if (v132 > v130)
                                {
                                  v133 = 0;
                                  v134 = v132 - v130;
                                  v135 = (v132 - v130 + 3) & 0xFFFFFFFFFFFFFFFCLL;
                                  v136 = vdupq_n_s64(v134 - 1);
                                  v137 = (*v113 + 4 * v130 + 8);
                                  do
                                  {
                                    v138 = vdupq_n_s64(v133);
                                    v139 = vmovn_s64(vcgeq_u64(v136, vorrq_s8(v138, xmmword_19B0A5850)));
                                    if (vuzp1_s16(v139, v119).u8[0])
                                    {
                                      *(v137 - 2) = v119.i32[0];
                                    }

                                    if (vuzp1_s16(v139, v119).i8[2])
                                    {
                                      *(v137 - 1) = v119.i32[0];
                                    }

                                    if (vuzp1_s16(v119, vmovn_s64(vcgeq_u64(v136, vorrq_s8(v138, xmmword_19B0A5840)))).i32[1])
                                    {
                                      *v137 = v119.i32[0];
                                      v137[1] = v119.i32[0];
                                    }

                                    v133 += 4;
                                    v137 += 4;
                                  }

                                  while (v135 != v133);
                                }

                                ++v127;
                              }

                              while (v127 != v128);
                            }
                          }
                        }
                      }

                      ++v116;
                    }

                    while (v116 != v115);
                  }
                }

                *(v335 + 2016) = __exp10f((*(v335 + 572) + *(v332 + 2420)) * 0.05);
                v141 = *(v335 + 2056);
                v142 = *(v335 + 2048);
                v143 = (v141 - v142) >> 2;
                if (v331 <= v143)
                {
                  if (v331 < v143)
                  {
                    v149 = v142 + 4 * v331;
                    goto LABEL_237;
                  }
                }

                else
                {
                  v144 = v331 - v143;
                  v145 = *(v335 + 2064);
                  if (v144 > (v145 - v141) >> 2)
                  {
                    v146 = v145 - v142;
                    v147 = v146 >> 1;
                    if (v146 >> 1 <= v331)
                    {
                      v147 = v331;
                    }

                    if (v146 >= 0x7FFFFFFFFFFFFFFCLL)
                    {
                      v148 = 0x3FFFFFFFFFFFFFFFLL;
                    }

                    else
                    {
                      v148 = v147;
                    }

                    std::allocator<float>::allocate_at_least[abi:ne200100](v140, v148);
                  }

                  v150 = (v144 + 0x3FFFFFFFFFFFFFFFLL) & 0x3FFFFFFFFFFFFFFFLL;
                  v151 = vdupq_n_s64(v150);
                  v152 = v150 - ((v144 + 0x3FFFFFFFFFFFFFFFLL) & 3);
                  v153 = (v141 + 8);
                  v154 = -4;
                  do
                  {
                    v155 = vdupq_n_s64(v154 + 4);
                    v156 = vmovn_s64(vcgeq_u64(v151, vorrq_s8(v155, xmmword_19B0A5850)));
                    if (vuzp1_s16(v156, *v151.i8).u8[0])
                    {
                      *(v153 - 2) = 0;
                    }

                    if (vuzp1_s16(v156, *&v151).i8[2])
                    {
                      *(v153 - 1) = 0;
                    }

                    if (vuzp1_s16(*&v151, vmovn_s64(vcgeq_u64(v151, vorrq_s8(v155, xmmword_19B0A5840)))).i32[1])
                    {
                      *v153 = 0;
                      v153[1] = 0;
                    }

                    v154 += 4;
                    v153 += 4;
                  }

                  while (v152 != v154);
                  v149 = v141 + 4 * v144;
LABEL_237:
                  *(v335 + 2056) = v149;
                }

                buf.__begin_ = 0;
                std::vector<float *>::resize((v335 + 2072), v331, &buf);
                buf.__begin_ = 0;
                std::vector<float *>::resize((v335 + 2096), v331, &buf);
                v157 = *(v335 + 2128);
                v158 = *(v335 + 2120);
                v159 = 0xAAAAAAAAAAAAAAABLL * ((v157 - v158) >> 3);
                v160 = v331;
                v161 = v331 - v159;
                if (v331 <= v159)
                {
                  v166 = v335;
                  if (v331 < v159)
                  {
                    v167 = v158 + 24 * v331;
                    if (v157 != v167)
                    {
                      v168 = *(v335 + 2128);
                      do
                      {
                        v170 = *(v168 - 24);
                        v168 -= 24;
                        v169 = v170;
                        if (v170)
                        {
                          *(v157 - 16) = v169;
                          operator delete(v169);
                        }

                        v157 = v168;
                      }

                      while (v168 != v167);
                    }

                    *(v335 + 2128) = v167;
                    v160 = v331;
                  }
                }

                else
                {
                  v162 = *(v335 + 2136);
                  if (0xAAAAAAAAAAAAAAABLL * ((v162 - v157) >> 3) < v161)
                  {
                    v163 = 0xAAAAAAAAAAAAAAABLL * ((v162 - v158) >> 3);
                    v164 = 2 * v163;
                    if (2 * v163 <= v331)
                    {
                      v164 = v331;
                    }

                    if (v163 >= 0x555555555555555)
                    {
                      v165 = 0xAAAAAAAAAAAAAAALL;
                    }

                    else
                    {
                      v165 = v164;
                    }

                    if (v165 <= 0xAAAAAAAAAAAAAAALL)
                    {
                      operator new();
                    }

                    std::__throw_bad_array_new_length[abi:ne200100]();
                  }

                  bzero(*(v335 + 2128), 24 * ((24 * v161 - 24) / 0x18) + 24);
                  *(v335 + 2128) = v157 + 24 * ((24 * v161 - 24) / 0x18) + 24;
                  v166 = v335;
                }

                if (v160)
                {
                  v171 = 0;
                  do
                  {
                    v172 = *(v166 + 2120);
                    buf.__begin_ = 0;
                    std::vector<float *>::resize((v172 + v171), v331, &buf);
                    v171 += 24;
                    v166 = v335;
                  }

                  while (24 * v331 != v171);
                }

                result = 0;
                v1 = v332;
                *(v332 + 2448) = *(v320 + 2144 * *(v332 + 2456) + 2040);
                goto LABEL_263;
              }
            }

            else
            {
              v65 = MEMORY[0x1E69E9C10];
            }

            if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
            {
              goto LABEL_133;
            }

            LODWORD(buf.__begin_) = 136315394;
            *(&buf.__begin_ + 4) = "MPDDRC.cpp";
            WORD2(buf.__end_) = 1024;
            *(&buf.__end_ + 6) = 630;
            v67 = "%25s:%-5d ERROR: loudness EQ parameters for low band are missing.\n";
            goto LABEL_132;
          }

          v239 = ++v240;
        }

        while (v236 > v240);
        if (v237)
        {
LABEL_417:
          if (gDRCScope)
          {
            v65 = *gDRCScope;
            if (!*gDRCScope)
            {
              goto LABEL_133;
            }
          }

          else
          {
            v65 = MEMORY[0x1E69E9C10];
          }

          if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
          {
            goto LABEL_133;
          }

          LODWORD(buf.__begin_) = 136315394;
          *(&buf.__begin_ + 4) = "MPDDRC.cpp";
          WORD2(buf.__end_) = 1024;
          *(&buf.__end_ + 6) = 639;
          v67 = "%25s:%-5d ERROR: applicable loudEqGainParams not found\n";
LABEL_132:
          _os_log_impl(&dword_19AA99000, v65, OS_LOG_TYPE_ERROR, v67, &buf, 0x12u);
          goto LABEL_133;
        }

LABEL_348:
        v318 = v234;
        v319 = v218;
        std::vector<mpddrc::GainMappingTable>::resize((v222 + 24), v238);
        std::vector<mpddrc::GainMappingTable>::resize((v222 + 48), *(v222 + 4));
        std::vector<mpddrc::GainBuffer>::resize((v222 + 96), *(v222 + 4));
        memset(&buf, 0, sizeof(buf));
        std::vector<float>::resize(&buf, *(v222 + 4));
        if (*(v222 + 4))
        {
          v241 = 0;
          v242 = 0;
          begin = buf.__begin_;
          do
          {
            begin[v242] = *(*v228 + 24 * *(v325 + v327 + 4 * v242) + 12);
            std::vector<float>::resize((*(v222 + 24) + v241), 0x100uLL);
            std::vector<float>::resize((*(v222 + 48) + v241), 0x100uLL);
            ++v242;
            v241 += 24;
          }

          while (v242 < *(v222 + 4));
        }

        std::vector<mpddrc::ShapeFilterBlock>::resize((v222 + 72), 1uLL);
        v246 = *(v222 + 72);
        *(v246 + 24) = 0;
        *(v246 + 76) = 0;
        *(v246 + 128) = 0;
        *(v246 + 180) = 0;
        if (v225)
        {
          v247 = buf.__begin_;
          if (buf.__end_ != buf.__begin_)
          {
            v248 = 0;
            v249 = &mpddrc::ShapeFilterSet::kShapeFilterParams_LoudEq + 4 * (v225 - 1);
            v250 = buf.__end_ - buf.__begin_;
            v251 = 1;
            while (1)
            {
              v252 = v247[v248];
              if (v252 == 1)
              {
                break;
              }

              if (!v252)
              {
                v253 = *v249;
                v254 = v249[1];
                *(v246 + 76) = 2;
                v255 = mpddrc::shapeFilterGainOffsetLfTable[3 * v253 + v254];
                *(v246 + 80) = v255;
                v256 = mpddrc::shapeFilterY1BoundLfTable[3 * v253 + v254];
                *(v246 + 84) = v256;
                v257 = mpddrc::shapeFilterRadiusLfTable[v253];
                v258 = 1583.9 / (v255 + 1583.9);
                *(v246 + 88) = v258;
                *(v246 + 92) = (v256 + v257) / v258;
                *(v246 + 112) = -v257;
LABEL_358:
                *v246 = 1;
              }

              v248 = v251;
              v259 = v250 > v251++;
              if (!v259)
              {
                goto LABEL_360;
              }
            }

            mpddrc::ShapeFilterSet::initShapeFilterCoeff(v249[2], v249[3], 4, v246 + 180);
            v246 = *(v222 + 72);
            goto LABEL_358;
          }

LABEL_360:
          v56 = v335;
          v189 = v316;
          if (!mpddrc::UniDRCShapingFilter::create((v246 + 240), v318))
          {
            mpddrc::ShapeFilterSet::resetShapeFilterBlock((v222 + 72), v260);
            v246 = *(v222 + 72);
            v261 = 1;
            goto LABEL_363;
          }
        }

        else
        {
          v261 = 0;
          *v246 = 0;
          v56 = v335;
          v189 = v316;
LABEL_363:
          *(v246 + 1) = v261;
        }

        if (*(v222 + 4))
        {
          v262 = 0;
          v263 = 0;
          while (1)
          {
            v339 = 0;
            v340 = 2863267840;
            v337 = 0;
            v338 = -1431699456;
            v336 = -86;
            v264 = *v228 + 24 * *(v325 + v327 + 4 * v263);
            HIBYTE(v337) = *(v264 + 4);
            if (HIBYTE(v337))
            {
              LOWORD(v338) = *(v264 + 6);
            }

            else
            {
              LOWORD(v340) = *(v264 + 8);
            }

            BYTE6(v337) = 1;
            if (mpddrc::GenerateGainMappingTableForLoudEq(*(v235 + 24), *(v235 + 56), &v337, 1, &v336, (*(v222 + 24) + v262), v44, v244, v245))
            {
              break;
            }

            v267 = mpddrc::GenerateGainMappingTableForLoudEq(*(v235 + 24), *(v235 + 56), &v337, 0, &v336, (*(v222 + 48) + v262), v44, v265, v266);
            v268 = v267 == 0;
            if (v267)
            {
              goto LABEL_375;
            }

            ++v263;
            v262 += 24;
            if (v263 >= *(v222 + 4))
            {
              v268 = 1;
              goto LABEL_375;
            }
          }

          v268 = 0;
LABEL_375:
          v56 = v335;
        }

        else
        {
          v268 = 1;
        }

        v59 = v322;
        if (buf.__begin_)
        {
          operator delete(buf.__begin_);
        }

        if (!v268)
        {
          goto LABEL_133;
        }

        v218 = v319 + 1;
        v327 += 128;
      }

      while (v319 + 1 != v317);
    }

    *(v56 + 1668) = *(v56 + 572);
    *(v56 + 1652) = 1118437376;
    v269 = *(v332 + 1456);
    v270 = *(v332 + 1448);
    v271 = 0xCCCCCCCCCCCCCCCDLL * ((v269 - v270) >> 3);
    if (v269 == v270)
    {
LABEL_391:
      v284 = *(v332 + 1480);
      v285 = *(v332 + 1472);
      v286 = 0xCCCCCCCCCCCCCCCDLL * ((v284 - v285) >> 3);
      if (v284 == v285)
      {
LABEL_402:
        v299 = v59;
        if (v269 == v270)
        {
LABEL_409:
          if (v284 == v285)
          {
            LODWORD(v44) = 1118437376;
            v56 = v335;
            goto LABEL_428;
          }

          v308 = 0;
          v309 = 0;
          v56 = v335;
          while (1)
          {
            v311 = (v285 + 40 * v308 + 16);
            v310 = *v311;
            v312 = v311[1] - *v311;
            if (v312)
            {
              break;
            }

LABEL_415:
            LODWORD(v44) = 1118437376;
            v308 = ++v309;
            v59 = v299;
            if (v286 <= v309)
            {
              goto LABEL_428;
            }
          }

          v313 = 0;
          v314 = v312 >> 4;
          v315 = 1;
          while (1)
          {
            v283 = *(v310 + 16 * v313 + 8);
            if ((v283 & 0xFF0000) == 0x70000)
            {
              break;
            }

            v313 = v315;
            v259 = v314 > v315++;
            if (!v259)
            {
              goto LABEL_415;
            }
          }
        }

        else
        {
          v300 = 0;
          v301 = 0;
          while (1)
          {
            v303 = (v270 + 40 * v300 + 16);
            v302 = *v303;
            v304 = v303[1] - *v303;
            if (v304)
            {
              break;
            }

LABEL_408:
            v300 = ++v301;
            if (v271 <= v301)
            {
              goto LABEL_409;
            }
          }

          v305 = 0;
          v306 = v304 >> 4;
          v307 = 1;
          while (1)
          {
            v283 = *(v302 + 16 * v305 + 8);
            if ((v283 & 0xFF0000) == 0x70000)
            {
              break;
            }

            v305 = v307;
            v259 = v306 > v307++;
            if (!v259)
            {
              goto LABEL_408;
            }
          }
        }

        v56 = v335;
        v59 = v299;
      }

      else
      {
        v287 = 0;
        v288 = 0;
        v289 = *(v56 + 620);
        while (!v289)
        {
LABEL_401:
          v287 = ++v288;
          if (v286 <= v288)
          {
            goto LABEL_402;
          }
        }

        v290 = 0;
        v291 = *(v285 + 40 * v287 + 1);
        v292 = v285 + 40 * v287;
        while (1)
        {
          if (*(v56 + 580 + 4 * v290) == v291)
          {
            v294 = *(v292 + 16);
            v293 = *(v292 + 24);
            v295 = v293 - v294;
            if (v293 != v294)
            {
              break;
            }
          }

LABEL_400:
          if (++v290 == v289)
          {
            goto LABEL_401;
          }
        }

        v296 = 0;
        v297 = v295 >> 4;
        v298 = 1;
        while (1)
        {
          v283 = *(v294 + 16 * v296 + 8);
          if ((v283 & 0xFF0000) == 0x70000)
          {
            break;
          }

          v296 = v298;
          v259 = v297 > v298++;
          if (!v259)
          {
            goto LABEL_400;
          }
        }
      }
    }

    else
    {
      v272 = 0;
      v273 = 0;
      v274 = *(v56 + 620);
      while (!v274)
      {
LABEL_390:
        v272 = ++v273;
        if (v271 <= v273)
        {
          goto LABEL_391;
        }
      }

      v275 = 0;
      v276 = *(v270 + 40 * v272 + 1);
      v277 = v270 + 40 * v272;
      while (1)
      {
        if (*(v56 + 580 + 4 * v275) == v276)
        {
          v278 = *(v277 + 16);
          v279 = *(v277 + 24) - v278;
          if (v279)
          {
            break;
          }
        }

LABEL_389:
        if (++v275 == v274)
        {
          goto LABEL_390;
        }
      }

      v280 = 0;
      v281 = v279 >> 4;
      v282 = 1;
      while (1)
      {
        v283 = *(v278 + 16 * v280 + 8);
        if ((v283 & 0xFF0000) == 0x70000)
        {
          break;
        }

        v280 = v282;
        v259 = v281 > v282++;
        if (!v259)
        {
          goto LABEL_389;
        }
      }
    }

    *&v44 = (BYTE1(v283) + 80);
    *(v56 + 1652) = *&v44;
LABEL_428:
    mpddrc::LoudnessEqSet::BandMixLevelInit((v56 + 1640), 0, *&v44, *&v44);
    goto LABEL_133;
  }

  v46 = 0;
  while (1)
  {
    v47 = (v335 + 952 + 120 * v46);
    v48 = *(v1 + 384) + 424 * *v47;
    v49 = *(v48 + 216);
    if (*(v48 + 224) == v49)
    {
      break;
    }

    v329 = v45;
    v50 = __sz - 1;
    if (*(v49 + 16))
    {
      v50 = __sz - *(v49 + 12) + ((*(v49 + 12) - 1) >> 1);
    }

    std::vector<mpddrc::GainSetParams>::clear[abi:ne200100](v47 + 3);
    std::vector<mpddrc::GainBuffer>::resize(v47 + 3, *(v48 + 264));
    v51 = v47[3];
    if (-1227133513 * ((v47[4] - v51) >> 3))
    {
      v52 = 0;
      v53 = 0;
      do
      {
        v54 = v51 + v52;
        *(v54 + 20) = -1;
        *(v54 + 8) = v50;
        *(v54 + 12) = 1065353216;
        v55 = *(v54 + 24) + 2 * __sz;
        LODWORD(buf.__begin_) = 1065353216;
        std::vector<float>::resize((v54 + 32), v55, &buf, *&v44);
        ++v53;
        v51 = v47[3];
        v52 += 56;
      }

      while (v53 < -1227133513 * ((v47[4] - v51) >> 3));
    }

    v45 = v329;
    if (*(v48 + 268) > v329)
    {
      v45 = *(v48 + 268);
    }

    ++v46;
    v1 = v332;
    if (v46 >= *(v335 + 1552))
    {
      goto LABEL_115;
    }
  }

  if (!gDRCScope)
  {
    v66 = MEMORY[0x1E69E9C10];
LABEL_260:
    if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__begin_) = 136315394;
      *(&buf.__begin_ + 4) = "MPDDRC.cpp";
      WORD2(buf.__end_) = 1024;
      *(&buf.__end_ + 6) = 2255;
      _os_log_impl(&dword_19AA99000, v66, OS_LOG_TYPE_ERROR, "%25s:%-5d ERROR: ChannelGroupInfo has size 0.\n", &buf, 0x12u);
    }

    goto LABEL_262;
  }

  v66 = *gDRCScope;
  if (*gDRCScope)
  {
    goto LABEL_260;
  }

LABEL_262:
  result = 4294967285;
LABEL_263:
  *(v1 + 1674) = 0;
  *(v1 + 2432) = 0;
  return result;
}

void sub_19B079CAC(_Unwind_Exception *exception_object)
{
  v3 = *(v1 - 144);
  if (v3)
  {
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_19B07A498(_Unwind_Exception *a1)
{
  *(v1 - 208) = v1 - 120;
  std::vector<mpddrc::QmfComplexBufferPtr>::__destroy_vector::operator()[abi:ne200100]((v1 - 208));
  _Unwind_Resume(a1);
}

uint64_t mpddrc::UniDrcProcessor::InitSelectedDrcSet(uint64_t a1, uint64_t a2, unsigned int a3, int *a4)
{
  v405 = *MEMORY[0x1E69E9840];
  v4 = *a4;
  v5 = *(a2 + 400);
  if (!v5)
  {
LABEL_5:
    if (gDRCScope)
    {
      v11 = *gDRCScope;
      if (!*gDRCScope)
      {
        return 0xFFFFFFFFLL;
      }
    }

    else
    {
      v11 = MEMORY[0x1E69E9C10];
    }

    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      return 0xFFFFFFFFLL;
    }

    *v400 = 136315650;
    *&v400[4] = "MPDDRC.cpp";
    *&v400[12] = 1024;
    *&v400[14] = 3159;
    *&v400[18] = 1024;
    *&v400[20] = v4;
    v19 = "%25s:%-5d ERROR: no matching DRC instruction with drcSetId %d found\n";
LABEL_22:
    v20 = v11;
    v21 = 24;
LABEL_51:
    _os_log_impl(&dword_19AA99000, v20, OS_LOG_TYPE_ERROR, v19, v400, v21);
    return 0xFFFFFFFFLL;
  }

  v7 = 0;
  v8 = a4[1];
  v9 = *(a2 + 376);
  v10 = (v9 + 40);
  while (*v10 != v4)
  {
    v10 += 106;
    if (v5 == ++v7)
    {
      goto LABEL_5;
    }
  }

  if (!v8 || v8 == 127)
  {
    goto LABEL_10;
  }

  v22 = *(a2 + 256);
  v23 = -1227133513 * ((*(a2 + 264) - v22) >> 3);
  if (!v23)
  {
LABEL_27:
    if (gDRCScope)
    {
      v11 = *gDRCScope;
      if (!*gDRCScope)
      {
        return 0xFFFFFFFFLL;
      }
    }

    else
    {
      v11 = MEMORY[0x1E69E9C10];
    }

    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      return 0xFFFFFFFFLL;
    }

    *v400 = 136315650;
    *&v400[4] = "MPDDRC.cpp";
    *&v400[12] = 1024;
    *&v400[14] = 3179;
    *&v400[18] = 1024;
    *&v400[20] = v8;
    v19 = "%25s:%-5d ERROR: no matching downmix instruction with downmixInstructionId %d found\n";
    goto LABEL_22;
  }

  v24 = (v22 + 8);
  while (1)
  {
    v25 = *v24;
    v24 += 14;
    if (v25 == v8)
    {
      break;
    }

    if (!--v23)
    {
      goto LABEL_27;
    }
  }

LABEL_10:
  v12 = v9 + 424 * v7;
  v13 = *(v12 + 4);
  v14 = *(a2 + 344);
  v15 = 1022611261 * ((*(a2 + 352) - v14) >> 3);
  if (v13)
  {
    if (1022611261 * ((*(a2 + 352) - v14) >> 3))
    {
      v16 = 0;
      v17 = (v14 + 8);
      LODWORD(v18) = -1;
      while (1)
      {
        if (*v17 == 1)
        {
          if (*(v17 - 1))
          {
            LODWORD(v18) = v16;
            goto LABEL_37;
          }

          if (v18 == -1)
          {
            LODWORD(v18) = v16;
          }
        }

        ++v16;
        v17 += 42;
        if (v15 == v16)
        {
          goto LABEL_37;
        }
      }
    }

LABEL_44:
    if (gDRCScope)
    {
      v38 = *gDRCScope;
      if (!*gDRCScope)
      {
        return 0xFFFFFFFFLL;
      }
    }

    else
    {
      v38 = MEMORY[0x1E69E9C10];
    }

    if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      return 0xFFFFFFFFLL;
    }

    *v400 = 136315394;
    *&v400[4] = "MPDDRC.cpp";
    *&v400[12] = 1024;
    *&v400[14] = 3217;
    v19 = "%25s:%-5d ERROR: No matching DrcCoefficients for location 1 present.\n";
LABEL_50:
    v20 = v38;
    v21 = 18;
    goto LABEL_51;
  }

  if (!(1022611261 * ((*(a2 + 352) - v14) >> 3)))
  {
    goto LABEL_44;
  }

  v18 = 0;
  v26 = (v14 + 8);
  while (*(v26 - 1) || *v26 != 1)
  {
    ++v18;
    v26 += 42;
    if (v15 == v18)
    {
      goto LABEL_44;
    }
  }

LABEL_37:
  if ((v18 & 0x80000000) != 0)
  {
    goto LABEL_44;
  }

  v387 = a3;
  v28 = *(a1 + 1552);
  v384 = a1 + 952;
  v29 = a1 + 952 + 120 * v28;
  *v29 = v7;
  *(v29 + 4) = v18;
  *(v29 + 8) = *(a4 + 8);
  v30 = 0x8E38E38E38E38E39 * ((*(v12 + 224) - *(v12 + 216)) >> 2);
  v31 = *(a4 + 3);
  v370 = *(a2 + 1552);
  v32 = (v29 + 72);
  v33 = (v29 + 96);
  v376 = v30;
  v34 = v30;
  std::vector<float>::resize((v29 + 48), v30);
  v392 = v32;
  std::vector<std::vector<int>>::resize(v32, v34);
  v391 = v33;
  std::vector<std::vector<int>>::resize(v33, v34);
  if (v13 == 8)
  {
    v31 = -31.0;
    v37 = a1;
    if (*(v12 + 8) == 1 && *(a2 + 1664) == 1 && *(a2 + 1544) == 1)
    {
      if (0xCCCCCCCCCCCCCCCDLL * ((*(a2 + 1568) - *(a2 + 1560)) >> 3) != v34)
      {
        if (gDRCScope)
        {
          v38 = *gDRCScope;
          if (!*gDRCScope)
          {
            return 0xFFFFFFFFLL;
          }
        }

        else
        {
          v38 = MEMORY[0x1E69E9C10];
        }

        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          return 0xFFFFFFFFLL;
        }

        *v400 = 136315394;
        *&v400[4] = "MPDDRC.cpp";
        *&v400[12] = 1024;
        *&v400[14] = 3263;
        v19 = "%25s:%-5d ERROR: loudnessInfoSource has unexpected size\n";
        goto LABEL_50;
      }

      v389 = 1;
    }

    else
    {
      v389 = 0;
    }
  }

  else
  {
    v389 = 0;
    v37 = a1;
  }

  v41 = v14 + 168 * v18;
  v382 = v37;
  v386 = v34;
  v396 = v12;
  v394 = a2;
  v395 = v41;
  if (!v376)
  {
    v44 = 0;
    v43 = 0;
    v385 = 0;
    v374 = 2;
    goto LABEL_391;
  }

  v42 = 0;
  v385 = 0;
  v43 = 0;
  v44 = 0;
  v371 = (v37 + 928);
  v372 = (v37 + 936);
  v373 = &v400[244];
  v381 = &v401;
  v45 = v387 - 3;
  if (v387 == 2)
  {
    v46 = 32;
  }

  else
  {
    v46 = 1;
  }

  if (v387 == 2)
  {
    v47 = 5;
  }

  else
  {
    v47 = 0;
  }

  v48 = v45 >= 2;
  if (v45 >= 2)
  {
    v49 = v46;
  }

  else
  {
    v49 = 64;
  }

  v368 = v49;
  v369 = v387 != 1;
  v50 = v49;
  if (v48)
  {
    v51 = v47;
  }

  else
  {
    v51 = 6;
  }

  v367 = v51;
  *&v36 = 136315394;
  v377 = v36;
  v52 = 0.001;
  v53 = 0.1;
  v54 = 0.05;
  v55 = -0.05;
  v56 = 0.25;
  v366 = vneg_f32(0x80000000800000);
  v374 = 2;
  do
  {
    v57 = *(v12 + 216);
    v58 = v57 + 36 * v42;
    if (*(v58 + 32) >= -1227133513 * ((*(v41 + 128) - *(v41 + 120)) >> 3))
    {
      if (gDRCScope)
      {
        v38 = *gDRCScope;
        if (!*gDRCScope)
        {
          return 0xFFFFFFFFLL;
        }
      }

      else
      {
        v38 = MEMORY[0x1E69E9C10];
      }

      if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        return 0xFFFFFFFFLL;
      }

      *v400 = v377;
      *&v400[4] = "MPDDRC.cpp";
      *&v400[12] = 1024;
      *&v400[14] = 3272;
      v19 = "%25s:%-5d ERROR: Gain set index invalid.\n";
      goto LABEL_50;
    }

    LODWORD(v393) = v44;
    if (!v389)
    {
      goto LABEL_86;
    }

    v59 = *(v394 + 1584);
    v60 = *(v394 + 1592) - v59;
    v61 = *(v12 + 240);
    if (v60 >> 1 == (*(v12 + 248) - v61) >> 2)
    {
      v62 = *(v394 + 1560);
      if (0x8E38E38E38E38E39 * ((*(v12 + 224) - v57) >> 2) == 0xCCCCCCCCCCCCCCCDLL * ((*(v394 + 1568) - v62) >> 3))
      {
        if ((v60 & 0x1FFFFFFFELL) != 0)
        {
          v63 = 0;
          v64 = (v60 >> 1);
          while (v42 != *(v61 + 4 * v63))
          {
            if (v64 == ++v63)
            {
              goto LABEL_78;
            }
          }

          v65 = *(v59 + 2 * v63);
        }

        else
        {
LABEL_78:
          v65 = 0;
        }

        v192 = (v62 + 40 * v65);
        v31 = -31.0;
        if (*(v192 + 24) != 1)
        {
          goto LABEL_86;
        }

        if (v370)
        {
          v31 = *(v62 + 28);
          goto LABEL_86;
        }

        v209 = *v192;
        v210 = v192[1];
        if (v209 == v210)
        {
          v211 = 0;
        }

        else
        {
          v211 = 0;
          do
          {
            v211 += *(v209 + 1);
            v209 += 2;
          }

          while (v209 != v210);
        }

        if (*(v58 + 20) == v211)
        {
          goto LABEL_332;
        }

        if (gDRCScope)
        {
          v239 = *gDRCScope;
          if (!*gDRCScope)
          {
LABEL_332:
            v31 = *(v62 + 40 * v65 + 28);
            goto LABEL_85;
          }
        }

        else
        {
          v239 = MEMORY[0x1E69E9C10];
        }

        inited = os_log_type_enabled(v239, OS_LOG_TYPE_ERROR);
        if (inited)
        {
          *v400 = v377;
          *&v400[4] = "MPDDRC.cpp";
          *&v400[12] = 1024;
          *&v400[14] = 3301;
          _os_log_impl(&dword_19AA99000, v239, OS_LOG_TYPE_ERROR, "%25s:%-5d WARNING: channel cluster and channel groups not matching\n", v400, 0x12u);
          v62 = *(v394 + 1560);
        }

        goto LABEL_332;
      }
    }

    if (!gDRCScope)
    {
      v66 = MEMORY[0x1E69E9C10];
LABEL_83:
      inited = os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
      v31 = -31.0;
      if (inited)
      {
        *v400 = v377;
        *&v400[4] = "MPDDRC.cpp";
        *&v400[12] = 1024;
        *&v400[14] = 3282;
        _os_log_impl(&dword_19AA99000, v66, OS_LOG_TYPE_ERROR, "%25s:%-5d WARNING: channel cluster and channel groups not matching\n", v400, 0x12u);
      }

      goto LABEL_85;
    }

    v66 = *gDRCScope;
    if (*gDRCScope)
    {
      goto LABEL_83;
    }

    v31 = -31.0;
LABEL_85:
    v41 = v395;
LABEL_86:
    v67 = *(v12 + 216) + 36 * v42;
    v68 = *(v67 + 20);
    if ((*(*(v12 + 280) + ((v42 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v42))
    {
      v69 = *(v394 + 640);
      v70 = 0x86BCA1AF286BCA1BLL * ((*(v394 + 648) - v69) >> 3);
      v71 = 0;
      if (*(v394 + 648) != v69)
      {
        v72 = 1;
        do
        {
          if (*(*(v394 + 616) + 56 * *(*(v12 + 304) + 4 * v42)) == *(v69 + 152 * v71 + 4))
          {
            break;
          }

          v71 = v72;
          v73 = v70 > v72++;
        }

        while (v73);
      }

      if (v70 == v71)
      {
        if (gDRCScope)
        {
          v38 = *gDRCScope;
          if (!*gDRCScope)
          {
            return 0xFFFFFFFFLL;
          }
        }

        else
        {
          v38 = MEMORY[0x1E69E9C10];
        }

        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          return 0xFFFFFFFFLL;
        }

        *v400 = v377;
        *&v400[4] = "MPDDRC.cpp";
        *&v400[12] = 1024;
        *&v400[14] = 3402;
        v19 = "%25s:%-5d ERROR: parametricDrcInstructions expected but not found.\n";
        goto LABEL_50;
      }

      *&v383 = *(v394 + 640);
      v390 = v68;
      v74 = *(v394 + 36);
      v380 = *(v394 + 32);
      v75 = v387;
      inited = mpddrc::GainSampleInterval(v387);
      v76 = *(v12 + 304);
      v388 = v42;
      v77 = *(v76 + 4 * v42);
      v78 = v394;
      if (*(v394 + 588))
      {
        v79 = *(v394 + 596) + 1;
      }

      else
      {
        v79 = 1 << *(v394 + 592);
      }

      *(v37 + 916) = v79;
      *(v37 + 920) = *(v78 + 608);
      v378 = v74;
      *(v37 + 912) = LODWORD(v74) / v79;
      if (v75 != 1)
      {
        v80 = inited;
        if (v79 != inited)
        {
          if (gDRCScope)
          {
            v81 = *gDRCScope;
            v34 = v386;
            v82 = v393;
            v42 = v388;
            if (!*gDRCScope)
            {
LABEL_249:
              v43 = 0;
              *(*(v384 + 120 * *(v37 + 1552) + 48) + 4 * v42) = -1 - 483939977 * ((*(v37 + 936) - *(v37 + 928)) >> 3);
              v41 = v395;
              v12 = v396;
              goto LABEL_250;
            }
          }

          else
          {
            v81 = MEMORY[0x1E69E9C10];
            v34 = v386;
            v82 = v393;
            v42 = v388;
          }

          inited = os_log_type_enabled(v81, OS_LOG_TYPE_ERROR);
          if (inited)
          {
            *v400 = 136315906;
            *&v400[4] = "MPDDRCParametricDRC.cpp";
            *&v400[12] = 1024;
            *&v400[14] = 1290;
            *&v400[18] = 1024;
            *&v400[20] = v79;
            *&v400[24] = 1024;
            *&v400[26] = v80;
            _os_log_impl(&dword_19AA99000, v81, OS_LOG_TYPE_ERROR, "%25s:%-5d ERROR: drcFrameSizeParametricDrc (%d) != AUDIO_CODEC_SUBBAND_DOWNSAMPLING_FACTOR (%d).\n", v400, 0x1Eu);
          }

          goto LABEL_249;
        }
      }

      v379 = v77;
      memcpy(v400, &unk_19B3BB9C8, sizeof(v400));
      v114 = 0;
      v400[0] = 1;
      memset(&v400[8], 0, 24);
      memset(&v400[96], 0, 24);
      memset(&v400[320], 0, 24);
      memset(&v400[64], 0, 28);
      memset(&v400[124], 0, 40);
      memset(&v400[168], 0, 72);
      v115 = v373;
      *(v373 + 16) = 0;
      v115[2] = 0u;
      v115[3] = 0u;
      *v115 = 0u;
      v115[1] = 0u;
      memset(&v400[400], 0, 24);
      memset(&v400[448], 0, 48);
      *&v400[528] = 0;
      v116 = v381;
      v381[1] = 0;
      v116[2] = 0;
      *v116 = 0;
      v42 = v388;
      if (*(v396 + 60) == 1)
      {
        if (*(v396 + 61) != 1 || *(v396 + 72) == *(v396 + 64))
        {
          v114 = *(v396 + 56);
        }

        else
        {
          v114 = 127;
        }
      }

      *&v400[536] = v114;
      v117 = *(v396 + 208);
      memset(&v397, 0, sizeof(v397));
      std::vector<float>::resize(&v397, v117);
      begin = v397.__begin_;
      if (v117)
      {
        v119 = *(v396 + 240);
        v120 = v397.__begin_;
        v121 = v117;
        do
        {
          v122 = *v119++;
          *v120++ = v122 == v42;
          --v121;
        }

        while (v121);
      }

      std::vector<unsigned int>::__assign_with_size[abi:ne200100]<unsigned int *,unsigned int *>(v381, begin, v397.__end_, (v397.__end_ - begin) >> 2);
      v123 = *(v37 + 912);
      v124 = *&v400[16];
      v125 = 0xAAAAAAAAAAAAAAABLL * ((*&v400[16] - *&v400[8]) >> 2);
      v126 = v123 - v125;
      v375 = v117;
      if (v123 <= v125)
      {
        if (v123 < v125)
        {
          *&v400[16] = *&v400[8] + 12 * v123;
        }
      }

      else
      {
        if (0xAAAAAAAAAAAAAAABLL * ((*&v400[24] - *&v400[16]) >> 2) < v126)
        {
          if (0x5555555555555556 * ((*&v400[24] - *&v400[8]) >> 2) > v123)
          {
            v123 = 0x5555555555555556 * ((*&v400[24] - *&v400[8]) >> 2);
          }

          if (0xAAAAAAAAAAAAAAABLL * ((*&v400[24] - *&v400[8]) >> 2) >= 0xAAAAAAAAAAAAAAALL)
          {
            v127 = 0x1555555555555555;
          }

          else
          {
            v127 = v123;
          }

          std::allocator<mpddrc::Node>::allocate_at_least[abi:ne200100](v127);
        }

        bzero(*&v400[16], 12 * ((12 * v126 - 12) / 0xC) + 12);
        v37 = v382;
        *&v400[16] = v124 + 12 * ((12 * v126 - 12) / 0xC) + 12;
      }

      v128 = *(v394 + 616) + 56 * v379;
      *&v129 = 0xAAAAAAAAAAAAAAAALL;
      *(&v129 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *v399 = v129;
      *&v399[16] = v129;
      *&v399[32] = -1431655766;
      *v398 = *v128;
      *&v398[16] = *(v128 + 16);
      memset(&v399[4], 0, 24);
      std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(&v399[4], *(v128 + 24), *(v128 + 32), (*(v128 + 32) - *(v128 + 24)) >> 2);
      v130 = *(v128 + 48);
      *&v399[28] = v130;
      if (v130)
      {
        v131 = (HIDWORD(v130) * v56) + -57.75;
      }

      else
      {
        v132 = *(v394 + 1472);
        v133 = *(v394 + 1464);
        if (v132 == v133)
        {
          goto LABEL_295;
        }

        v134 = 0;
        v135 = 0;
        v131 = 0.0;
        do
        {
          v136 = v133 + 40 * v134;
          if (*&v400[536] == *(v136 + 3) && !*(v136 + 1))
          {
            v138 = v136 + 16;
            v137 = *(v136 + 16);
            v139 = *(v138 + 8) - v137;
            if (v139)
            {
              v140 = 0;
              v141 = v139 >> 4;
              v142 = 1;
              do
              {
                v143 = *(v137 + 16 * v140 + 8);
                if ((v143 & 0xFF0000) == 0x10000)
                {
                  v144 = BYTE1(v143);
                  goto LABEL_188;
                }

                v140 = v142;
                v73 = v141 > v142++;
              }

              while (v73);
              if (v135)
              {
                v135 = 1;
                goto LABEL_178;
              }

              v145 = 0;
              v146 = 1;
              while (1)
              {
                v147 = *(v137 + 16 * v145 + 8);
                if ((v147 & 0xFF0000) == 0x20000)
                {
                  break;
                }

                v145 = v146;
                v73 = v141 > v146++;
                if (!v73)
                {
                  v135 = 0;
                  goto LABEL_178;
                }
              }

              v144 = BYTE1(v147);
LABEL_188:
              v131 = (v144 * v56) + -57.75;
              v135 = 1;
            }

            else
            {
              v135 = v135;
            }
          }

LABEL_178:
          ++v134;
        }

        while (0xCCCCCCCCCCCCCCCDLL * ((v132 - v133) >> 3) > v134);
        if (!v135)
        {
          v193 = v132 - v133;
          if (v132 == v133)
          {
            goto LABEL_295;
          }

          v194 = 0;
          v195 = 0;
          v196 = 0xCCCCCCCCCCCCCCCDLL * (v193 >> 3);
          do
          {
            v197 = v133 + 40 * v194;
            if (!*(v197 + 3) && !*(v197 + 1))
            {
              v199 = v197 + 16;
              v198 = *(v197 + 16);
              v200 = *(v199 + 8) - v198;
              if (v200)
              {
                v201 = 0;
                v202 = v200 >> 4;
                v203 = 1;
                do
                {
                  v204 = *(v198 + 16 * v201 + 8);
                  if ((v204 & 0xFF0000) == 0x10000)
                  {
                    v205 = BYTE1(v204);
                    goto LABEL_271;
                  }

                  v201 = v203;
                  v73 = v202 > v203++;
                }

                while (v73);
                if (v195)
                {
                  v195 = 1;
                  goto LABEL_261;
                }

                v206 = 0;
                v207 = 1;
                while (1)
                {
                  v208 = *(v198 + 16 * v206 + 8);
                  if ((v208 & 0xFF0000) == 0x20000)
                  {
                    break;
                  }

                  v206 = v207;
                  v73 = v202 > v207++;
                  if (!v73)
                  {
                    v195 = 0;
                    goto LABEL_261;
                  }
                }

                v205 = BYTE1(v208);
LABEL_271:
                v131 = (v205 * v56) + -57.75;
                v195 = 1;
              }

              else
              {
                v195 = v195;
              }
            }

LABEL_261:
            ++v194;
          }

          while (v196 > v194);
          if (!v195)
          {
LABEL_295:
            if (gDRCScope)
            {
              v221 = *gDRCScope;
              v34 = v386;
              v82 = v393;
              if (!*gDRCScope)
              {
LABEL_235:
                if (*&v399[4])
                {
                  operator delete(*&v399[4]);
                }

                if (v397.__begin_)
                {
                  operator delete(v397.__begin_);
                }

                if (v401)
                {
                  v402 = v401;
                  operator delete(v401);
                }

                if (*&v400[472])
                {
                  *&v400[480] = *&v400[472];
                  operator delete(*&v400[472]);
                }

                if (*&v400[448])
                {
                  *&v400[456] = *&v400[448];
                  operator delete(*&v400[448]);
                }

                if (*&v400[400])
                {
                  *&v400[408] = *&v400[400];
                  operator delete(*&v400[400]);
                }

                mpddrc::ParametricDrcInstance::DrcTypeFeedForward::~DrcTypeFeedForward(&v400[32]);
                inited = *&v400[8];
                if (*&v400[8])
                {
                  *&v400[16] = *&v400[8];
                  operator delete(*&v400[8]);
                }

                goto LABEL_249;
              }
            }

            else
            {
              v221 = MEMORY[0x1E69E9C10];
              v34 = v386;
              v82 = v393;
            }

            if (os_log_type_enabled(v221, OS_LOG_TYPE_ERROR))
            {
              *buf = v377;
              *&buf[4] = "MPDDRCParametricDRC.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 1389;
              _os_log_impl(&dword_19AA99000, v221, OS_LOG_TYPE_ERROR, "%25s:%-5d ERROR: drcInputLoudness not found in loudnessInfoSet.\n", buf, 0x12u);
            }

            goto LABEL_235;
          }
        }
      }

      v148 = v383 + 152 * v71;
      *(v37 + 924) = v131;
      v149 = *(v37 + 916);
      v150 = *(v148 + 144);
      v400[0] = *(v148 + 144);
      v151 = *(v148 + 16);
      if (v151 == 1)
      {
        v152 = *(v148 + 20);
        *&v400[4] = 0;
        v153 = v375;
        if (v152 == 5)
        {
          v154 = 1;
          *&v400[4] = 1;
          v155 = 5.0;
          goto LABEL_203;
        }

        if (v152 >= 6)
        {
          v150 = 1;
          v400[0] = 1;
        }
      }

      else
      {
        v154 = *(v148 + 24);
        *&v400[4] = v154;
        v155 = 5.0;
        v153 = v375;
        if (v154)
        {
          goto LABEL_203;
        }
      }

      v154 = 0;
      v155 = 10.0;
LABEL_203:
      if (*(v148 + 8))
      {
        v155 = *(v148 + 12);
      }

      if (v150)
      {
        goto LABEL_206;
      }

      v164 = LODWORD(v380);
      v165 = ((v155 * LODWORD(v380)) * v52);
      if (v154 == 1)
      {
        *&v400[388] = v149;
        *&v400[392] = LODWORD(v378) / v149;
        *&v400[384] = v153;
        *&v400[440] = v164;
        v212 = *(v394 + 616) + 56 * v379;
        if (*(v212 + 4) == 1)
        {
          v213 = *(v212 + 16);
          v214 = *(v212 + 32) - *(v212 + 24);
          v215 = (v214 >> 2);
          std::vector<float>::resize(&v400[400], v215);
          if ((v214 & 0x3FFFFFFFCLL) != 0)
          {
            v216 = *(v212 + 24);
            v217 = *&v400[400];
            do
            {
              v219 = *v216++;
              v218 = v219;
              if (v213)
              {
                *v217 = mpddrc::kChannelWeight[v218];
              }

              else if (v218)
              {
                *v217 = 1065353216;
              }

              else
              {
                *v217 = 0;
              }

              ++v217;
              --v215;
            }

            while (v215);
          }
        }

        else
        {
          std::vector<float>::resize(&v400[400], (v402 - v401) >> 2);
          v222 = v401;
          if (v402 != v401)
          {
            v223 = 0;
            v224 = (v402 - v401) >> 2;
            v225 = *&v400[400];
            do
            {
              *(v225 + 4 * v223) = v222[v223];
              ++v223;
            }

            while (v224 > v223);
          }
        }

        v226 = *(v148 + 12);
        if (!*(v148 + 8))
        {
          v226 = 5.0;
        }

        v227 = ((v226 * *&v400[440]) * v52);
        v228 = sqrtf((v227 + 1));
        *&v400[504] = v228;
        v229 = (v227 + 1) / v228;
        if (v229 * v228 >= v227 + 1)
        {
          v230 = (v227 + 1) / v228;
        }

        else
        {
          v230 = v229 + 1;
        }

        *&v400[508] = v230;
        std::vector<float>::resize(&v400[448], v230 * v228);
        std::vector<float>::resize(&v400[472], *&v400[508]);
        *&v400[496] = 0;
        *&v400[512] = 0;
        if (*(v148 + 136))
        {
          v231 = 10 * *(v148 + 140);
        }

        else
        {
          v231 = 50;
        }

        *&v400[424] = v227;
        *&v400[428] = powf(v53, 1.0 / (v227 + 1));
        *&v400[432] = powf(v53, 1.0 / (*&v400[440] * v231 / 0x3E8u + 1));
        v232 = (*(v148 + 132) * -0.125) * v54;
        if (!*(v148 + 128))
        {
          v232 = v55;
        }

        *&v400[436] = __exp10f(v232);
        *&v400[396] = v165;
        *&v400[496] = 0;
        *&v400[512] = 0;
        *&v400[444] = 1065353216;
        *&v400[520] = 0x3FF0000000000000;
        v233 = *&v400[448];
        if (*&v400[456] != *&v400[448])
        {
          v234 = (*&v400[456] - *&v400[448]) >> 2;
          v235 = 1;
          do
          {
            *v233++ = 0;
            v73 = v234 > v235++;
          }

          while (v73);
        }

        v236 = *&v400[472];
        v37 = v382;
        if (*&v400[480] != *&v400[472])
        {
          v237 = (*&v400[480] - *&v400[472]) >> 2;
          v238 = 1;
          do
          {
            *v236++ = 0;
            v73 = v237 > v238++;
          }

          while (v73);
        }

        goto LABEL_206;
      }

      if (v154)
      {
        if (gDRCScope)
        {
          v220 = *gDRCScope;
          if (!*gDRCScope)
          {
            goto LABEL_206;
          }
        }

        else
        {
          v220 = MEMORY[0x1E69E9C10];
        }

        if (os_log_type_enabled(v220, OS_LOG_TYPE_ERROR))
        {
          *buf = 136315650;
          *&buf[4] = "MPDDRCParametricDRC.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 1164;
          *&buf[18] = 1024;
          *&buf[20] = v154;
          _os_log_impl(&dword_19AA99000, v220, OS_LOG_TYPE_ERROR, "%25s:%-5d ERROR: Unknown parametricDrcType = %d.\n", buf, 0x18u);
        }

        goto LABEL_206;
      }

      LODWORD(v383) = ((v155 * LODWORD(v380)) * v52);
      *&v400[120] = 2;
      *&v400[52] = v149;
      if (v151)
      {
        v166 = *(v148 + 20);
      }

      else
      {
        v166 = 0;
      }

      v167 = &mpddrc::kFeedForwardDefaultConstants + 32 * v166;
      v168 = *(v167 + 2);
      v169 = *(v167 + 4);
      *&v400[360] = vcvt_f32_u32(*(v167 + 20));
      v37 = v382;
      if (mpddrc::ParametricDrcInstance::DrcTypeFeedForward::InitializeDrcCurveParameters(&v400[32], v166 + 7))
      {
        goto LABEL_206;
      }

      v170 = v169;
      if (*(v148 + 80) == 1)
      {
        v172 = *(v148 + 84);
        v171 = *(v148 + 88);
        v173 = *(v148 + 92);
        v380 = 10.0;
        if (v173 == 1)
        {
          v174 = *(v148 + 100);
          v380 = (5 * *(v148 + 96));
          v170 = (20 * v174);
          if (*(v148 + 104) == 1)
          {
            *&v400[360] = vbsl_s8(vcgt_u32(*(v148 + 108), 0x1E0000001ELL), v366, vcvt_f32_u32(*(v148 + 108)));
          }
        }

        v175 = 5 * v172;
        v168 = 40 * v171;
        if (*(v148 + 116))
        {
          v378 = *(v148 + 120) * 256.0;
          goto LABEL_335;
        }
      }

      else
      {
        v175 = 100;
        v380 = 10.0;
      }

      v378 = 2560.0;
LABEL_335:
      if ((*(v148 + 16) & 1) == 0)
      {
        if (*(v148 + 44))
        {
          v240 = *(v148 + 64) - *(v148 + 56);
          std::vector<unsigned long long>::resize(&v400[320], (v240 >> 1));
          if ((v240 & 0x1FFFFFFFELL) != 0)
          {
            v241 = 0;
            v242 = *(v148 + 56) + 1;
            v243 = *&v400[320];
            v244 = *&v400[320];
            v245 = v242;
            do
            {
              if (v241)
              {
                *v244 = *(v244 - 2) + (*(v245 - 1) + 1);
              }

              else
              {
                *v243 = (-11 - *(v242 - 1));
              }

              v246 = *v245;
              v245 += 2;
              v244[1] = (v246 - 39);
              ++v241;
              v244 += 2;
            }

            while ((v240 >> 1) != v241);
          }
        }

        else
        {
          v37 = v382;
          if (mpddrc::ParametricDrcInstance::DrcTypeFeedForward::InitializeDrcCurveParameters(&v400[32], *(v148 + 48)))
          {
            goto LABEL_206;
          }
        }
      }

      v364 = v54;
      v365 = v55;
      v363 = v53;
      *&v400[120] = *(v148 + 32);
      v247 = v52;
      if (*(v148 + 36))
      {
        v248 = v149 + v149 * *(v148 + 40);
        *&v400[52] = v248;
      }

      else
      {
        v248 = *&v400[52];
      }

      v249 = v149 / (v164 * -0.001);
      *&v400[344] = 1.0 - expf(v249 / v175);
      *&v400[348] = 1.0 - expf(v249 / v168);
      *&v400[352] = 1.0 - expf(v249 / v380);
      *&v400[356] = 1.0 - expf(v249 / v170);
      *&v400[368] = ((v378 * v164) / (48000 * v149));
      *&v400[36] = v149;
      *&v400[32] = v153;
      *&v400[40] = v387;
      *&v400[56] = 0;
      *&v400[240] = v369;
      *&v400[60] = v248 / v149;
      std::vector<float>::resize(&v400[64], v248 / v149);
      v52 = v247;
      v53 = v363;
      v54 = v364;
      v55 = v365;
      v250 = *(v394 + 616) + 56 * v379;
      if (*(v250 + 4) == 1)
      {
        v251 = *(v250 + 16);
        v252 = *(v250 + 32) - *(v250 + 24);
        v253 = (v252 >> 2);
        std::vector<float>::resize(&v400[96], v253);
        if ((v252 & 0x3FFFFFFFCLL) != 0)
        {
          v254 = *(v250 + 24);
          v255 = *&v400[96];
          do
          {
            v257 = *v254++;
            v256 = v257;
            if (v251)
            {
              *v255 = mpddrc::kChannelWeight[v256];
            }

            else if (v256)
            {
              *v255 = 1065353216;
            }

            else
            {
              *v255 = 0;
            }

            ++v255;
            --v253;
          }

          while (v253);
        }
      }

      else
      {
        std::vector<float>::resize(&v400[96], (v402 - v401) >> 2);
        v258 = v401;
        if (v402 != v401)
        {
          v259 = 0;
          v260 = (v402 - v401) >> 2;
          v261 = *&v400[96];
          do
          {
            *(v261 + 4 * v259) = v258[v259];
            ++v259;
          }

          while (v260 > v259);
        }
      }

      v262 = v164;
      if (*&v400[40] == 1)
      {
        *&v400[44] = v164;
        std::vector<unsigned long long>::resize(&v400[168], v153);
        std::vector<unsigned long long>::resize(&v400[192], v153);
        if (*&v400[120] == 2)
        {
          v263 = v262;
          v264 = 9424.77796 / v262;
          v265 = __sincosf_stret(v264);
          *&v266 = v265.__sinval * 0.5 * 1.41421354;
          v267.i32[0] = 1048875488;
          v268 = (v265.__cosval * -0.25893) + 2.2589;
          *v269.i32 = v268 + (*&v266 * 2.244);
          HIDWORD(v266) = LODWORD(v265.__cosval);
          v270 = vdupq_lane_s32(v267, 0);
          v270.f32[0] = (v265.__cosval * 0.25893) + 2.2589;
          v270.f32[2] = v270.f32[0];
          *&v400[124] = vdivq_f32(vmulq_f32(vmlaq_f32(v270, xmmword_19B0B2CE0, vdupq_lane_s64(v266, 0)), xmmword_19B0B2CF0), vdupq_lane_s32(v269, 0));
          *&v400[140] = (v268 + (*&v266 * -2.244)) / *v269.i32;
          v37 = v382;
        }

        else
        {
          v37 = v382;
          if ((*&v400[120] - 1) > 1)
          {
LABEL_369:
            *&v400[312] = (*(v250 + 52) * 0.25) + -57.75;
            v275 = v368;
            if (v383 - 1 >= v368)
            {
              v275 = ((v383 / v50) + 0.5) << v367;
            }

            *&v400[48] = v275;
            *&v400[56] = 0;
            *&v400[88] = 1;
            v276 = *&v400[64];
            if (*&v400[72] != *&v400[64])
            {
              v277 = (*&v400[72] - *&v400[64]) >> 2;
              v278 = 1;
              do
              {
                *v276++ = 0;
                v73 = v277 > v278++;
              }

              while (v73);
            }

            v279 = *&v400[168];
            if (*&v400[176] != *&v400[168])
            {
              v280 = (*&v400[176] - *&v400[168]) >> 3;
              v281 = 1;
              do
              {
                *v279++ = 0;
                v73 = v280 > v281++;
              }

              while (v73);
            }

            v282 = *&v400[192];
            if (*&v400[200] != *&v400[192])
            {
              v283 = (*&v400[200] - *&v400[192]) >> 3;
              v284 = 1;
              do
              {
                *v282++ = 0;
                v73 = v283 > v284++;
              }

              while (v73);
            }

            v285 = *&v400[264];
            if (*&v400[272] != *&v400[264])
            {
              v286 = (*&v400[272] - *&v400[264]) >> 3;
              v287 = 1;
              do
              {
                *v285++ = 0;
                v73 = v286 > v287++;
              }

              while (v73);
            }

            v288 = *&v400[288];
            if (*&v400[296] != *&v400[288])
            {
              v289 = (*&v400[296] - *&v400[288]) >> 3;
              v290 = 1;
              do
              {
                *v288++ = 0;
                v73 = v289 > v290++;
              }

              while (v73);
            }

            *&v400[372] = 3272015872;
            *&v400[380] = 0;
            goto LABEL_206;
          }

          v263 = v262;
        }

        v271 = 238.761042 / v263;
        v272 = __sincosf_stret(v271);
        *v273.i32 = v272.__sinval + 1.0;
        v274.f32[0] = (v272.__cosval + 1.0) * 0.5;
        v274.f32[1] = -(v272.__cosval + 1.0);
        v274.f32[2] = v274.f32[0];
        v274.f32[3] = v272.__cosval * -2.0;
        *&v400[144] = vdivq_f32(v274, vdupq_lane_s32(v273, 0));
        *&v400[160] = (1.0 - v272.__sinval) / (v272.__sinval + 1.0);
        goto LABEL_369;
      }

      v37 = v382;
      if (!mpddrc::ParametricDrcInstance::DrcTypeFeedForward::initLvlEstFilterSubBand(&v400[32], v164, v153))
      {
        goto LABEL_369;
      }

LABEL_206:
      v156 = *(v37 + 936);
      v157 = *(v37 + 944);
      if (v156 >= v157)
      {
        v158 = v372;
        v160 = 0x193D4BB7E327A977 * ((v156 - *v371) >> 3);
        v161 = v160 + 1;
        v34 = v386;
        if ((v160 + 1) > 0x73615A240E6C2BLL)
        {
          std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
        }

        v162 = 0x193D4BB7E327A977 * ((v157 - *v371) >> 3);
        if (2 * v162 > v161)
        {
          v161 = 2 * v162;
        }

        if (v162 >= 0x39B0AD12073615)
        {
          v163 = 0x73615A240E6C2BLL;
        }

        else
        {
          v163 = v161;
        }

        v404 = v371;
        if (v163)
        {
          if (v163 <= 0x73615A240E6C2BLL)
          {
            operator new();
          }

          std::__throw_bad_array_new_length[abi:ne200100]();
        }

        v56 = 0.25;
        *buf = 0;
        *&buf[8] = 568 * v160;
        *&buf[16] = 568 * v160;
        *&buf[24] = 0;
        mpddrc::ParametricDrcInstance::ParametricDrcInstance(568 * v160, v400);
        *&buf[16] += 568;
        v176 = *v372;
        v177 = *v371;
        v178 = *&buf[8] + *v371 - *v372;
        if (*v371 != *v372)
        {
          v179 = v177 + *&buf[8] - *v372;
          v180 = *v371;
          do
          {
            *v179 = *v180;
            *(v179 + 1) = 0;
            *(v179 + 1) = 0uLL;
            *(v179 + 8) = *(v180 + 1);
            *(v179 + 3) = v180[3];
            v180[3] = 0;
            *(v180 + 1) = 0uLL;
            v181 = *(v180 + 3);
            *(v179 + 2) = *(v180 + 2);
            *(v179 + 3) = v181;
            *(v179 + 72) = 0uLL;
            *(v179 + 8) = 0;
            *(v179 + 4) = *(v180 + 4);
            *(v179 + 10) = v180[10];
            v180[10] = 0;
            *(v180 + 4) = 0uLL;
            *(v179 + 22) = *(v180 + 22);
            *(v179 + 104) = 0uLL;
            *(v179 + 12) = 0;
            *(v179 + 6) = *(v180 + 6);
            *(v179 + 14) = v180[14];
            v180[14] = 0;
            *(v180 + 6) = 0uLL;
            v182 = *(v180 + 15);
            v183 = *(v180 + 17);
            *(v179 + 148) = *(v180 + 148);
            *(v179 + 136) = v183;
            *(v179 + 120) = v182;
            *(v179 + 21) = 0;
            *(v179 + 11) = 0uLL;
            *(v179 + 168) = *(v180 + 21);
            *(v179 + 23) = v180[23];
            v180[23] = 0;
            *(v180 + 21) = 0uLL;
            *(v179 + 26) = 0;
            *(v179 + 12) = 0uLL;
            *(v179 + 12) = *(v180 + 12);
            *(v179 + 26) = v180[26];
            v180[26] = 0;
            *(v180 + 12) = 0uLL;
            *(v179 + 29) = 0;
            *(v179 + 216) = 0uLL;
            *(v179 + 216) = *(v180 + 27);
            *(v179 + 29) = v180[29];
            v180[29] = 0;
            *(v180 + 27) = 0uLL;
            v184 = v180[32];
            *(v179 + 15) = *(v180 + 15);
            *(v179 + 32) = v184;
            *(v179 + 33) = 0;
            *(v179 + 17) = 0uLL;
            *(v179 + 33) = v180[33];
            *(v179 + 17) = *(v180 + 17);
            v180[35] = 0;
            *(v180 + 33) = 0uLL;
            *(v179 + 38) = 0;
            *(v179 + 18) = 0uLL;
            *(v179 + 18) = *(v180 + 18);
            *(v179 + 38) = v180[38];
            v180[38] = 0;
            *(v180 + 18) = 0uLL;
            *(v179 + 78) = *(v180 + 78);
            *(v179 + 328) = 0uLL;
            *(v179 + 40) = 0;
            *(v179 + 20) = *(v180 + 20);
            *(v179 + 42) = v180[42];
            v180[42] = 0;
            *(v180 + 20) = 0uLL;
            v185 = *(v180 + 43);
            v186 = *(v180 + 45);
            *(v179 + 47) = v180[47];
            *(v179 + 344) = v185;
            *(v179 + 360) = v186;
            *(v179 + 24) = *(v180 + 24);
            *(v179 + 408) = 0uLL;
            *(v179 + 50) = 0;
            *(v179 + 25) = *(v180 + 25);
            *(v179 + 52) = v180[52];
            v180[52] = 0;
            *(v180 + 25) = 0uLL;
            v187 = v180[55];
            *(v179 + 424) = *(v180 + 53);
            *(v179 + 55) = v187;
            *(v179 + 56) = 0;
            *(v179 + 456) = 0uLL;
            *(v179 + 28) = *(v180 + 28);
            *(v179 + 58) = v180[58];
            v180[58] = 0;
            *(v180 + 28) = 0uLL;
            *(v179 + 61) = 0;
            *(v179 + 472) = 0uLL;
            *(v179 + 59) = v180[59];
            *(v179 + 30) = *(v180 + 30);
            v180[61] = 0;
            *(v180 + 59) = 0uLL;
            v188 = *(v180 + 32);
            *(v179 + 31) = *(v180 + 31);
            *(v179 + 32) = v188;
            v189 = v180[66];
            *(v179 + 134) = *(v180 + 134);
            *(v179 + 66) = v189;
            *(v179 + 68) = 0;
            *(v179 + 552) = 0uLL;
            *(v179 + 34) = *(v180 + 34);
            *(v179 + 70) = v180[70];
            v180[70] = 0;
            *(v180 + 34) = 0uLL;
            v180 += 71;
            v179 += 568;
          }

          while (v180 != v176);
          do
          {
            std::allocator_traits<std::allocator<mpddrc::ParametricDrcInstance>>::destroy[abi:ne200100]<mpddrc::ParametricDrcInstance,void,0>(v177);
            v177 += 71;
          }

          while (v177 != v176);
        }

        v190 = *(v37 + 928);
        *(v37 + 928) = v178;
        v191 = *(v37 + 944);
        v383 = *&buf[16];
        *v158 = *&buf[16];
        *&buf[16] = v190;
        *&buf[24] = v191;
        *buf = v190;
        *&buf[8] = v190;
        std::__split_buffer<mpddrc::ParametricDrcInstance>::~__split_buffer(buf);
        v159 = v383;
        v82 = v393;
      }

      else
      {
        v158 = v372;
        mpddrc::ParametricDrcInstance::ParametricDrcInstance(*(v37 + 936), v400);
        v34 = v386;
        v82 = v393;
        v159 = v156 + 568;
        *v372 = v156 + 568;
        v56 = 0.25;
      }

      *v158 = v159;
      goto LABEL_235;
    }

    if ((*v67 & 1) == 0 && *(v67 + 4) >= 2u)
    {
      v83 = *(*(v41 + 120) + 56 * *(v67 + 32) + 24);
      if (v374 == v83)
      {
        v84 = v374;
      }

      else
      {
        v84 = 3;
      }

      if (v374 != 2)
      {
        v83 = v84;
      }

      v374 = v83;
      if (*(v37 + 1556) != -1)
      {
        if (gDRCScope)
        {
          v38 = *gDRCScope;
          if (!*gDRCScope)
          {
            return 0xFFFFFFFFLL;
          }
        }

        else
        {
          v38 = MEMORY[0x1E69E9C10];
        }

        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          return 0xFFFFFFFFLL;
        }

        *v400 = v377;
        *&v400[4] = "MPDDRC.cpp";
        *&v400[12] = 1024;
        *&v400[14] = 3325;
        v19 = "%25s:%-5d ERROR: Not more than one DRC can be a multi-band DRC if two DRCs are applied to the time-domain signal.\n";
        goto LABEL_50;
      }

      v43 = 1;
    }

    v85 = *(v12 + 184);
    if (0xCCCCCCCCCCCCCCCDLL * ((*(v12 + 192) - v85) >> 3) <= v42)
    {
      v82 = v393;
      goto LABEL_251;
    }

    v390 = v68;
    v86 = v85 + 40 * v42;
    v87 = *(v86 + 8);
    v88 = *(v86 + 16);
    v89 = (v86 + 8);
    v90 = -858993459 * ((v88 - v87) >> 3);
    v91 = (*v392 + 24 * v42);
    v91->__end_ = v91->__begin_;
    std::vector<int>::resize(v91, v90);
    v92 = (*v391 + 24 * v42);
    v92->__end_ = v92->__begin_;
    std::vector<int>::resize(v92, v90);
    if (!v90)
    {
      goto LABEL_148;
    }

    v94 = 0;
    v95 = 0;
    v96 = 0;
    v97 = 40 * v90;
    do
    {
      v98 = v395;
      if (*(*(v396 + 216) + 36 * v42) == 1)
      {
        if (gDRCScope)
        {
          v38 = *gDRCScope;
          if (!*gDRCScope)
          {
            return 0xFFFFFFFFLL;
          }
        }

        else
        {
          v38 = MEMORY[0x1E69E9C10];
        }

        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          return 0xFFFFFFFFLL;
        }

        *v400 = v377;
        *&v400[4] = "MPDDRC.cpp";
        *&v400[12] = 1024;
        *&v400[14] = 3340;
        v19 = "%25s:%-5d ERROR: unexpected passthrough channel group\n";
        goto LABEL_50;
      }

      buf[0] = -86;
      v99 = *v89 + v94;
      v100 = v31;
      if (*(v99 + 4) == 1)
      {
        LOBYTE(v93) = *(v99 + 5);
        v100 = v31 - v93;
      }

      memset(v400, 0, 24);
      std::vector<float>::resize(v400, 0x100uLL);
      *(*(*v392 + 24 * v42) + v96) = -1;
      *(*(*v391 + 24 * v42) + v96) = -1;
      v103 = *v89;
      v104 = *v89 + v94;
      if (*(v104 + 6) == 1)
      {
        v105 = *(v104 + 8);
        if (v105 > (v98[4] - v98[3]) >> 5)
        {
          if (!gDRCScope)
          {
            v106 = MEMORY[0x1E69E9C10];
LABEL_132:
            if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
            {
              *v398 = v377;
              *&v398[4] = "MPDDRC.cpp";
              *&v398[12] = 1024;
              *&v398[14] = 3355;
              v111 = v106;
              goto LABEL_137;
            }

            goto LABEL_138;
          }

          v106 = *gDRCScope;
          if (*gDRCScope)
          {
            goto LABEL_132;
          }

          goto LABEL_143;
        }

        if (mpddrc::GenerateGainMappingTable(v98, *(v98[15] + 56 * *(*(v396 + 216) + 36 * v42 + 32) + 32) + v95, v105, 1, buf, v400, v100, v101, v102))
        {
          goto LABEL_130;
        }

        v107 = v382;
        v108 = v392;
        if (!buf[0])
        {
          v108 = v391;
        }

        *(*(*v108 + 24 * v42) + v96) = -1431655765 * ((*(v382 + 1800) - *(v382 + 1792)) >> 3);
        std::vector<mpddrc::GainMappingTable>::push_back[abi:ne200100]((v107 + 1792), v400);
        v385 = 0;
        v103 = *v89;
      }

      v109 = v103 + v94;
      if (*(v109 + 12) != 1)
      {
        goto LABEL_142;
      }

      v110 = *(v109 + 16);
      if (v110 <= (v98[8] - v98[7]) >> 5)
      {
        if (mpddrc::GenerateGainMappingTable(v98, *(v98[15] + 56 * *(*(v396 + 216) + 36 * v42 + 32) + 32) + v95, v110, 0, buf, v400, v100, v101, v102))
        {
LABEL_130:
          LOBYTE(v106) = 0;
          v385 = -1;
          goto LABEL_143;
        }

        v112 = v382;
        v113 = v392;
        if (buf[0])
        {
          v113 = v391;
        }

        *(*(*v113 + 24 * v42) + v96) = -1431655765 * ((*(v382 + 1800) - *(v382 + 1792)) >> 3);
        std::vector<mpddrc::GainMappingTable>::push_back[abi:ne200100]((v112 + 1792), v400);
        v385 = 0;
LABEL_142:
        LOBYTE(v106) = 1;
        goto LABEL_143;
      }

      if (!gDRCScope)
      {
        v106 = MEMORY[0x1E69E9C10];
LABEL_135:
        if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
        {
          *v398 = v377;
          *&v398[4] = "MPDDRC.cpp";
          *&v398[12] = 1024;
          *&v398[14] = 3373;
          v111 = v106;
LABEL_137:
          _os_log_impl(&dword_19AA99000, v111, OS_LOG_TYPE_ERROR, "%25s:%-5d ERROR: DRC characteristic missing\n", v398, 0x12u);
        }

LABEL_138:
        LOBYTE(v106) = 0;
        goto LABEL_143;
      }

      v106 = *gDRCScope;
      if (*gDRCScope)
      {
        goto LABEL_135;
      }

LABEL_143:
      inited = *v400;
      if (*v400)
      {
        operator delete(*v400);
      }

      if ((v106 & 1) == 0)
      {
        return 0xFFFFFFFFLL;
      }

      v96 += 4;
      v95 += 24;
      v94 += 40;
    }

    while (v97 != v94);
    v37 = v382;
    v34 = v386;
LABEL_148:
    v41 = v395;
    v12 = v396;
    v82 = v393;
LABEL_250:
    v68 = v390;
LABEL_251:
    v44 = v68 + v82;
    ++v42;
  }

  while (v42 != v34);
LABEL_391:
  if (v387 != 1)
  {
    mpddrc::SubbandOverlap::Initialize((v37 + 1584), v41, v12, v387, v43 & 1);
    goto LABEL_404;
  }

  v291 = *(v394 + 344);
  if (v291 != *(v394 + 352))
  {
    v292 = v291 + 168 * v18;
    if (*(v292 + 80) == 1)
    {
      inited = mpddrc::ShapeFilterSet::initShapeFilterBlock((v37 + 1616), (v292 + 88), v12);
      v39 = inited;
      if (inited)
      {
        return v39;
      }

      v385 = 0;
    }
  }

  if ((v43 & 1) == 0)
  {
LABEL_404:
    v39 = v385;
    goto LABEL_405;
  }

  v293 = (v376 + 1);
  v294 = (3 * v376);
  MEMORY[0x1EEE9AC00](inited);
  v296 = &v362[-v295];
  if (v293 * v294)
  {
    memset(&v362[-v295], 170, v293 * v294);
  }

  memset(v400, 170, 24);
  v398[0] = 0;
  std::vector<unsigned char>::vector[abi:ne200100](v400, v293);
  bzero(v296, v293 * v294);
  if ((v374 & 0xFE) == 2)
  {
    if (gDRCScope)
    {
      v297 = *gDRCScope;
      v39 = v385;
      if (!*gDRCScope)
      {
        goto LABEL_505;
      }
    }

    else
    {
      v297 = MEMORY[0x1E69E9C10];
      v39 = v385;
    }

    if (!os_log_type_enabled(v297, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_505;
    }

    *v398 = 136315394;
    *&v398[4] = "MPDDRC.cpp";
    *&v398[12] = 1024;
    *&v398[14] = 3447;
    v347 = "%25s:%-5d ERROR: multiband DRC info has inconsistent bandType\n";
    goto LABEL_503;
  }

  if (!v374)
  {
    if (gDRCScope)
    {
      v348 = *gDRCScope;
      v39 = v385;
      if (!*gDRCScope)
      {
        goto LABEL_505;
      }
    }

    else
    {
      v348 = MEMORY[0x1E69E9C10];
      v39 = v385;
    }

    if (!os_log_type_enabled(v348, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_505;
    }

    *v398 = 136315650;
    *&v398[4] = "MPDDRC.cpp";
    *&v398[12] = 1024;
    *&v398[14] = 3452;
    *&v398[18] = 1024;
    *v399 = 0;
    v347 = "%25s:%-5d ERROR: subband DRC is currently not supported (bandType==%d)\n";
    v349 = v348;
    v350 = 24;
    goto LABEL_504;
  }

  *(v37 + 1556) = *(v37 + 1552);
  v298 = v395;
  v299 = *(v396 + 208);
  v300 = v299 - v44;
  if (v299 < v44)
  {
    v300 = 0;
  }

  LODWORD(v394) = v300;
  if (v44 >= v299)
  {
    v293 = v376;
  }

  else
  {
    v293 = v293;
  }

  if (v376)
  {
    v301 = 0;
    v302 = *(v396 + 216);
    do
    {
      v303 = v302 + 36 * v301;
      if ((*v303 & 1) == 0 && *(v302 + 36 * v301 + 4) >= 2u)
      {
        v304 = v298[15] + 56 * *(v303 + 32);
        v305 = 1;
        do
        {
          if (v293)
          {
            v306 = 0;
            v307 = *(*(v304 + 32) + 24 * v305 + 20);
            v308 = v296;
            do
            {
              if (v301 != v306)
              {
                v309 = *v400;
                v310 = *(*v400 + v306);
                if (v294 <= v310)
                {
                  if (gDRCScope)
                  {
                    v297 = *gDRCScope;
                    v39 = v385;
                    if (!*gDRCScope)
                    {
                      goto LABEL_505;
                    }
                  }

                  else
                  {
                    v297 = MEMORY[0x1E69E9C10];
                    v39 = v385;
                  }

                  if (!os_log_type_enabled(v297, OS_LOG_TYPE_ERROR))
                  {
                    goto LABEL_505;
                  }

                  *v398 = 136315394;
                  *&v398[4] = "MPDDRC.cpp";
                  *&v398[12] = 1024;
                  *&v398[14] = 3482;
                  v347 = "%25s:%-5d ERROR: array size for crossover frequencies of Linkwitz-Riley filter exceeded\n";
                  goto LABEL_503;
                }

                v308[v310] = v307;
                *(v309 + v306) = v310 + 1;
              }

              ++v306;
              v308 += v294;
            }

            while (v293 != v306);
            v302 = *(v396 + 216);
          }

          ++v305;
        }

        while (v305 < *(v302 + 36 * v301 + 4));
      }

      ++v301;
    }

    while (v301 != v34);
  }

  v311 = *v400;
  v312 = **v400;
  if (**v400)
  {
    v313 = 0;
    do
    {
      if (v293 >= 2)
      {
        v314 = v296[v313];
        v315 = &v296[v294];
        v316 = 1;
        while (1)
        {
          v317 = *(v311 + v316);
          v318 = v315;
          if (!*(v311 + v316))
          {
            break;
          }

          while (1)
          {
            v319 = *v318++;
            if (v319 == v314)
            {
              break;
            }

            if (!--v317)
            {
              goto LABEL_458;
            }
          }

          ++v316;
          v315 += v294;
          if (v316 == v293)
          {
            v320 = 0;
            v321 = v296 + 1;
            v322 = v296;
            do
            {
              v323 = *v400;
              v324 = *(*v400 + v320);
              if (*(*v400 + v320))
              {
                v325 = 0;
                v326 = v324 - 1;
                v327 = v321;
                while (v322[v325] != v314)
                {
                  ++v325;
                  --v326;
                  ++v327;
                  if (v324 == v325)
                  {
                    goto LABEL_456;
                  }
                }

                if (v325 + 1 < v324)
                {
                  do
                  {
                    *(v327 - 1) = *v327;
                    ++v327;
                    --v326;
                  }

                  while (v326);
                }

                *(v323 + v320) = v324 - 1;
              }

LABEL_456:
              ++v320;
              v322 += v294;
              v321 += v294;
            }

            while (v320 != v293);
            v313 = 0;
            v311 = *v400;
            v312 = **v400;
            goto LABEL_459;
          }
        }
      }

LABEL_458:
      ++v313;
LABEL_459:
      ;
    }

    while (v313 < v312);
  }

  v393 = v362;
  v328 = (v37 + 1560);
  std::vector<LinkwitzRileyFilterbank>::resize((v37 + 1560), v293);
  MEMORY[0x1EEE9AC00](v329);
  v331 = &v362[-((v330 + 15) & 0x7FFFFFFF0)];
  *buf = -1;
  *&buf[8] = -1;
  if (!v376)
  {
    goto LABEL_521;
  }

  memset(&v362[-((v330 + 15) & 0x7FFFFFFF0)], 255, v330);
  v332 = 0;
  v333 = 1;
  v334 = v296;
  while (2)
  {
    v335 = *(v396 + 216) + 36 * v332;
    if (*v335)
    {
LABEL_471:
      ++v332;
      v334 += v294;
      v333 = v332 < v386;
      if (v332 == v386)
      {
        goto LABEL_521;
      }

      continue;
    }

    break;
  }

  v336 = *(v335 + 4);
  v337 = *(*v400 + v332);
  if (v336 >= 2)
  {
    v338 = v336 - 1;
    v339 = (*(v395[15] + 56 * *(v335 + 32) + 32) + 44);
    v340 = buf;
    do
    {
      v341 = *v339;
      v339 += 6;
      *v340++ = mpddrc::xOverIndexToFreqTable[v341];
      --v338;
    }

    while (v338);
  }

  if (v337)
  {
    v342 = v334;
    v343 = v331;
    v344 = v337;
    do
    {
      v345 = *v342++;
      *v343++ = mpddrc::xOverIndexToFreqTable[v345];
      --v344;
    }

    while (v344);
  }

  v346 = LinkwitzRileyFilterbank::Initialize((*v328 + 56 * v332), *(v335 + 20), v336, buf, v337, v331);
  if (!v346)
  {
    v385 = 0;
    goto LABEL_471;
  }

  v385 = v346;
  if (gDRCScope)
  {
    v352 = *gDRCScope;
    if (!*gDRCScope)
    {
      goto LABEL_519;
    }
  }

  else
  {
    v352 = MEMORY[0x1E69E9C10];
  }

  if (os_log_type_enabled(v352, OS_LOG_TYPE_ERROR))
  {
    *v398 = 136315394;
    *&v398[4] = "MPDDRC.cpp";
    *&v398[12] = 1024;
    *&v398[14] = 3590;
    _os_log_impl(&dword_19AA99000, v352, OS_LOG_TYPE_ERROR, "%25s:%-5d ERROR: Linkwitz-Riley filter bank initialization failed\n", v398, 0x12u);
  }

LABEL_519:
  if (v333)
  {
    v351 = 0;
    goto LABEL_530;
  }

LABEL_521:
  if (v293 > v376)
  {
    v353 = v386;
    v354 = &v296[v294 * v386];
    v355 = v394;
    while (1)
    {
      v356 = *(*v400 + v353);
      if (*(*v400 + v353))
      {
        v357 = v354;
        v358 = v331;
        v359 = *(*v400 + v353);
        do
        {
          v360 = *v357++;
          *v358++ = mpddrc::xOverIndexToFreqTable[v360];
          --v359;
        }

        while (v359);
      }

      v361 = LinkwitzRileyFilterbank::Initialize((*v328 + 56 * v353), v355, 1u, 0, v356, v331);
      if (v361)
      {
        break;
      }

      ++v353;
      v354 += v294;
      if (v353 == v293)
      {
        v39 = 0;
        v351 = 1;
        v37 = v382;
        goto LABEL_506;
      }
    }

    v39 = v361;
    if (gDRCScope)
    {
      v297 = *gDRCScope;
      v37 = v382;
      if (!*gDRCScope)
      {
LABEL_505:
        v351 = 0;
        goto LABEL_506;
      }
    }

    else
    {
      v297 = MEMORY[0x1E69E9C10];
      v37 = v382;
    }

    if (!os_log_type_enabled(v297, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_505;
    }

    *v398 = 136315394;
    *&v398[4] = "MPDDRC.cpp";
    *&v398[12] = 1024;
    *&v398[14] = 3608;
    v347 = "%25s:%-5d ERROR: Linkwitz-Riley filter bank initialization failed\n";
LABEL_503:
    v349 = v297;
    v350 = 18;
LABEL_504:
    _os_log_impl(&dword_19AA99000, v349, OS_LOG_TYPE_ERROR, v347, v398, v350);
    goto LABEL_505;
  }

  v351 = 1;
LABEL_530:
  v37 = v382;
  v39 = v385;
LABEL_506:
  if (*v400)
  {
    *&v400[8] = *v400;
    operator delete(*v400);
  }

  if (v351)
  {
LABEL_405:
    ++*(v37 + 1552);
    return v39;
  }

  return 0xFFFFFFFFLL;
}

void sub_19B07D0B0(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 368);
  if (v3)
  {
    *(v1 + 376) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t *std::vector<float>::resize(uint64_t *result, unint64_t a2, __int32 *a3, int16x4_t a4)
{
  v5 = *result;
  v4 = result[1];
  v6 = (v4 - *result) >> 2;
  if (a2 <= v6)
  {
    if (a2 >= v6)
    {
      return result;
    }

    v12 = v5 + 4 * a2;
  }

  else
  {
    v7 = a2 - v6;
    v8 = result[2];
    if (v7 > (v8 - v4) >> 2)
    {
      if (!(a2 >> 62))
      {
        v9 = v8 - v5;
        v10 = (v8 - v5) >> 1;
        if (v10 <= a2)
        {
          v10 = a2;
        }

        if (v9 >= 0x7FFFFFFFFFFFFFFCLL)
        {
          v11 = 0x3FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v11 = v10;
        }

        std::allocator<float>::allocate_at_least[abi:ne200100](result, v11);
      }

      std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
    }

    a4.i32[0] = *a3;
    v13 = (v7 + 0x3FFFFFFFFFFFFFFFLL) & 0x3FFFFFFFFFFFFFFFLL;
    v14 = vdupq_n_s64(v13);
    v15 = v13 - ((v7 + 0x3FFFFFFFFFFFFFFFLL) & 3);
    v16 = (v4 + 8);
    v17 = -4;
    do
    {
      v18 = vdupq_n_s64(v17 + 4);
      v19 = vmovn_s64(vcgeq_u64(v14, vorrq_s8(v18, xmmword_19B0A5850)));
      if (vuzp1_s16(v19, a4).u8[0])
      {
        *(v16 - 2) = a4.i32[0];
      }

      if (vuzp1_s16(v19, a4).i8[2])
      {
        *(v16 - 1) = a4.i32[0];
      }

      if (vuzp1_s16(a4, vmovn_s64(vcgeq_u64(v14, vorrq_s8(v18, xmmword_19B0A5840)))).i32[1])
      {
        *v16 = a4.i32[0];
        v16[1] = a4.i32[0];
      }

      v17 += 4;
      v16 += 4;
    }

    while (v15 != v17);
    v12 = v4 + 4 * v7;
  }

  result[1] = v12;
  return result;
}

uint64_t *mpddrc::UniDrcProcessor::AdjustDelays(uint64_t *result, uint64_t a2, int a3, int16x4_t a4)
{
  v4 = result;
  v57 = *MEMORY[0x1E69E9840];
  if (*(result + 388))
  {
    v49[1] = v49;
    MEMORY[0x1EEE9AC00](result);
    v8 = v49 - ((v7 + 15) & 0x7FFFFFFF0);
    result = memset(v8, 170, v7);
    v10 = *(a2 + 36);
    v11 = *(a2 + 344);
    if (*(a2 + 352) != v11)
    {
      v12 = *(a2 + 84);
      if ((v12 & 0x80000000) == 0 && *(v11 + 168 * v12 + 12) == 1)
      {
        v10 = *(v11 + 168 * v12 + 16);
      }
    }

    v13 = *(v4 + 388);
    if (v13)
    {
      v14 = 0;
      v15 = v4 + 119;
      v16 = *(a2 + 376);
      do
      {
        *&v8[4 * v14] = 0;
        v17 = &v15[15 * v14];
        v18 = (v16 + 424 * *v17);
        result = (954437177 * ((v18[28] - v18[27]) >> 2));
        if (result)
        {
          v19 = 0;
          v20 = 0;
          v21 = 0;
          v22 = v18[35];
          do
          {
            if ((*(v22 + ((v21 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v21))
            {
              v23 = *(v18[44] + 4 * v21);
              if (a3 == 1 || *(v18[41] + 4 * v21) != 1)
              {
                if (v19 <= v23)
                {
                  v19 = *(v18[44] + 4 * v21);
                }

                *&v8[4 * v14] = v19;
              }

              else if (v20 <= v23)
              {
                v20 = *(v18[44] + 4 * v21);
              }
            }

            ++v21;
          }

          while (result != v21);
        }

        else
        {
          v20 = 0;
        }

        *(v17 + 4) = v20;
        ++v14;
      }

      while (v14 != v13);
      v50 = v4;
      v51 = v8;
      v24 = 0;
      v55 = (2 * v10);
      v54 = v4 + 119;
      v52 = a2;
      do
      {
        v25 = &v15[15 * v24];
        if (*(v25 + 8) == 1)
        {
          HIDWORD(v55) += *&v8[4 * v24];
          v26 = (*(a2 + 376) + 424 * *v25);
          v27 = v26[27];
          v28 = v26[28];
          if (954437177 * ((v28 - v27) >> 2))
          {
            v53 = v24;
            v29 = 0;
            v30 = 0;
            do
            {
              if ((*(v26[35] + ((v29 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v29))
              {
                v31 = 0;
              }

              else
              {
                v31 = HIDWORD(v55);
              }

              if (*(v27 + 36 * v29 + 4))
              {
                v32 = 0;
                v33 = (v31 + v55);
                do
                {
                  v34 = v25[3] + 56 * (v30 + v32);
                  *(v34 + 24) = v31;
                  *(v34 + 28) = 1;
                  v56 = 1065353216;
                  result = std::vector<float>::resize((v34 + 32), v33, &v56, v9);
                  ++v32;
                  v27 = v26[27];
                }

                while (v32 < *(v27 + 36 * v29 + 4));
                v30 += v32;
                v28 = v26[28];
              }

              ++v29;
            }

            while (v29 < 954437177 * ((v28 - v27) >> 2));
            v8 = v51;
            v13 = *(v50 + 388);
            a2 = v52;
            v24 = v53;
          }

          *(v25 + 3) = HIDWORD(v55);
          v15 = v54;
        }

        ++v24;
      }

      while (v24 < v13);
      v4 = v50;
      v35 = *(v50 + 506);
      if (v13)
      {
        v36 = 0;
        HIDWORD(v55) = *(v50 + 506);
        do
        {
          v37 = &v15[15 * v36];
          if ((v37[1] & 1) == 0)
          {
            HIDWORD(v55) += *&v51[4 * v36];
            v38 = (*(v52 + 376) + 424 * *v37);
            v39 = v38[27];
            v40 = v38[28];
            if (954437177 * ((v40 - v39) >> 2))
            {
              v53 = v36;
              v41 = 0;
              v42 = 0;
              do
              {
                if ((*(v38[35] + ((v41 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v41))
                {
                  v43 = 0;
                }

                else
                {
                  v43 = HIDWORD(v55);
                }

                if (*(v39 + 36 * v41 + 4))
                {
                  v44 = 0;
                  v45 = (v43 + v55);
                  do
                  {
                    v46 = v37[3] + 56 * (v42 + v44);
                    *(v46 + 24) = v43;
                    *(v46 + 28) = 1;
                    v56 = 1065353216;
                    result = std::vector<float>::resize((v46 + 32), v45, &v56, v9);
                    ++v44;
                    v39 = v38[27];
                  }

                  while (v44 < *(v39 + 36 * v41 + 4));
                  v42 += v44;
                  v40 = v38[28];
                }

                ++v41;
              }

              while (v41 < 954437177 * ((v40 - v39) >> 2));
              v4 = v50;
              v35 = *(v50 + 506);
              v13 = *(v50 + 388);
              v36 = v53;
              v15 = v54;
            }

            *(v37 + 3) = HIDWORD(v55) - v35;
          }

          ++v36;
        }

        while (v36 < v13);
      }

      else
      {
        HIDWORD(v55) = *(v50 + 506);
      }
    }

    else
    {
      HIDWORD(v55) = *(v4 + 506);
    }

    if (v4[205])
    {
      v9.i32[0] = 1118437376;
      return mpddrc::LoudnessEqSet::BandMixLevelInit(v4 + 205, SHIDWORD(v55), v9, 85.0);
    }
  }

  else if (*(result + 1640) == 1)
  {
    v47 = *(result + 506);
    a4.i32[0] = 1118437376;
    v48 = result + 205;

    return mpddrc::LoudnessEqSet::BandMixLevelInit(v48, v47, a4, 85.0);
  }

  return result;
}

uint64_t *mpddrc::LoudnessEqSet::BandMixLevelInit(uint64_t *result, int a2, int16x4_t a3, float a4)
{
  v9 = result[7];
  v8 = result[8];
  if (((v8 - v9) & 0x7FFFFFFF80) != 0)
  {
    v27 = v7;
    v28 = v6;
    v29 = v4;
    v30 = v5;
    v12 = a3.i32[0];
    v13 = result;
    v14 = 0;
    do
    {
      v15 = v9 + (v14 << 7);
      v16 = *(v13 + 12);
      v26 = v12;
      v17 = *(v15 + 96);
      if (*(v15 + 104) != v17)
      {
        v18 = 0;
        v19 = (a2 + 2 * v16);
        v20 = 1;
        do
        {
          v21 = 56 * v18;
          v22 = v17 + 56 * v18;
          *(v22 + 24) = a2;
          result = std::vector<float>::resize((v22 + 32), v19, &v26, a3);
          v17 = *(v15 + 96);
          v23 = *(v15 + 104);
          v24 = v17 + v21;
          *(v24 + 28) = 1;
          *v24 = a4;
          v18 = v20;
        }

        while (0x6DB6DB6DB6DB6DB7 * ((v23 - v17) >> 3) > v20++);
        v9 = v13[7];
        v8 = v13[8];
      }

      ++v14;
    }

    while (v14 < ((v8 - v9) >> 7));
  }

  return result;
}

void sub_19B07DBD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_19B07DF68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  v5 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<mpddrc::ShapeFilterBlock>,mpddrc::ShapeFilterBlock*>>::~__exception_guard_exceptions[abi:ne200100](va1);
  std::__split_buffer<mpddrc::ShapeFilterBlock>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

void sub_19B07E410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *a28)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a21)
  {
    operator delete(a21);
  }

  if (a28)
  {
    operator delete(a28);
  }

  _Unwind_Resume(exception_object);
}

void sub_19B07E59C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<std::vector<unsigned char>>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

void sub_19B07F214(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t mpddrc::ParametricDrcInstance::ParametricDrcInstance(uint64_t a1, uint64_t *a2)
{
  v4 = *a2;
  *(a1 + 8) = 0;
  *a1 = v4;
  *(a1 + 16) = 0;
  *(a1 + 24) = 0;
  v6 = a2[1];
  v5 = a2[2];
  if (v5 != v6)
  {
    v7 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v6) >> 2);
    if (v7 < 0x1555555555555556)
    {
      std::allocator<mpddrc::Node>::allocate_at_least[abi:ne200100](v7);
    }

    std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
  }

  v8 = *(a2 + 2);
  v9 = *(a2 + 3);
  *(a1 + 64) = 0;
  *(a1 + 32) = v8;
  *(a1 + 48) = v9;
  *(a1 + 72) = 0;
  *(a1 + 80) = 0;
  std::vector<float>::__init_with_size[abi:ne200100]<float *,float *>(a1 + 64, a2[8], a2[9], (a2[9] - a2[8]) >> 2);
  v10 = *(a2 + 22);
  *(a1 + 96) = 0;
  *(a1 + 88) = v10;
  *(a1 + 104) = 0;
  *(a1 + 112) = 0;
  std::vector<float>::__init_with_size[abi:ne200100]<float *,float *>(a1 + 96, a2[12], a2[13], (a2[13] - a2[12]) >> 2);
  v11 = *(a2 + 15);
  v12 = *(a2 + 17);
  v13 = *(a2 + 148);
  *(a1 + 168) = 0;
  *(a1 + 148) = v13;
  *(a1 + 120) = v11;
  *(a1 + 136) = v12;
  *(a1 + 176) = 0;
  *(a1 + 184) = 0;
  std::vector<mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder>::__init_with_size[abi:ne200100]<mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder*,mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder*>(a1 + 168, a2[21], a2[22], (a2[22] - a2[21]) >> 3);
  *(a1 + 192) = 0;
  *(a1 + 200) = 0;
  *(a1 + 208) = 0;
  std::vector<mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder>::__init_with_size[abi:ne200100]<mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder*,mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder*>(a1 + 192, a2[24], a2[25], (a2[25] - a2[24]) >> 3);
  *(a1 + 216) = 0;
  *(a1 + 224) = 0;
  *(a1 + 232) = 0;
  std::vector<float>::__init_with_size[abi:ne200100]<float *,float *>(a1 + 216, a2[27], a2[28], (a2[28] - a2[27]) >> 2);
  v14 = a2[32];
  *(a1 + 240) = *(a2 + 15);
  *(a1 + 256) = v14;
  *(a1 + 264) = 0;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  std::vector<mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder>::__init_with_size[abi:ne200100]<mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder*,mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder*>(a1 + 264, a2[33], a2[34], (a2[34] - a2[33]) >> 3);
  *(a1 + 288) = 0;
  *(a1 + 296) = 0;
  *(a1 + 304) = 0;
  std::vector<mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder>::__init_with_size[abi:ne200100]<mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder*,mpddrc::ParametricDrcInstance::DrcTypeFeedForward::FilterState2ndOrder*>(a1 + 288, a2[36], a2[37], (a2[37] - a2[36]) >> 3);
  *(a1 + 312) = *(a2 + 78);
  *(a1 + 328) = 0;
  *(a1 + 336) = 0;
  *(a1 + 320) = 0;
  v16 = a2[40];
  v15 = a2[41];
  v17 = v15 - v16;
  if (v15 != v16)
  {
    if (!((v17 >> 3) >> 61))
    {
      std::allocator<apac::drc::ItemRenderer::SelectedChannel>::allocate_at_least[abi:ne200100](v17 >> 3);
    }

    std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
  }

  v18 = *(a2 + 43);
  v19 = *(a2 + 45);
  *(a1 + 376) = a2[47];
  *(a1 + 344) = v18;
  *(a1 + 360) = v19;
  *(a1 + 384) = *(a2 + 24);
  *(a1 + 408) = 0;
  *(a1 + 416) = 0;
  *(a1 + 400) = 0;
  std::vector<float>::__init_with_size[abi:ne200100]<float *,float *>(a1 + 400, a2[50], a2[51], (a2[51] - a2[50]) >> 2);
  v20 = a2[55];
  *(a1 + 424) = *(a2 + 53);
  *(a1 + 440) = v20;
  *(a1 + 448) = 0;
  *(a1 + 456) = 0;
  *(a1 + 464) = 0;
  std::vector<float>::__init_with_size[abi:ne200100]<float *,float *>(a1 + 448, a2[56], a2[57], (a2[57] - a2[56]) >> 2);
  *(a1 + 472) = 0;
  *(a1 + 480) = 0;
  *(a1 + 488) = 0;
  std::vector<float>::__init_with_size[abi:ne200100]<float *,float *>(a1 + 472, a2[59], a2[60], (a2[60] - a2[59]) >> 2);
  v21 = *(a2 + 32);
  *(a1 + 496) = *(a2 + 31);
  *(a1 + 512) = v21;
  v22 = a2[66];
  *(a1 + 536) = *(a2 + 134);
  *(a1 + 528) = v22;
  *(a1 + 544) = 0;
  *(a1 + 560) = 0;
  *(a1 + 552) = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(a1 + 544, a2[68], a2[69], (a2[69] - a2[68]) >> 2);
  return a1;
}

void sub_19B07F840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  mpddrc::ParametricDrcInstance::DrcTypeLimiter::~DrcTypeLimiter((v10 + 384));
  mpddrc::ParametricDrcInstance::DrcTypeFeedForward::~DrcTypeFeedForward((v11 - 32));
  v13 = *a10;
  if (*a10)
  {
    *(v10 + 16) = v13;
    operator delete(v13);
  }

  _Unwind_Resume(a1);
}

void sub_19B07F968()
{
  if (!*v0)
  {
    JUMPOUT(0x19B07F960);
  }

  JUMPOUT(0x19B07F958);
}

void sub_19B07F9F4(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t mpddrc::UniDrc::Process(uint64_t a1, const void **a2, unsigned int a3, const void **a4, unsigned int a5, unsigned int *a6)
{
  v54 = *MEMORY[0x1E69E9840];
  v12 = *(a1 + 44);
  v13 = *(a1 + 352);
  if (*(a1 + 360) != v13)
  {
    v14 = *(a1 + 92);
    if ((v14 & 0x80000000) == 0 && *(v13 + 168 * v14 + 12) == 1)
    {
      v12 = *(v13 + 168 * v14 + 16);
    }
  }

  if (*(a1 + 2444) == 1)
  {
    if (*a6)
    {
      v15 = 0;
      do
      {
        bzero(a4[v15++], 4 * v12);
      }

      while (v15 < *a6);
    }

    return 0;
  }

  result = mpddrc::UniDrc::UpdateConfig(a1);
  if (!result)
  {
    v17 = *(a1 + 2452);
    if (v17 == 3)
    {
      if ((*(a1 + 2464) & 1) == 0)
      {
        v43 = 0;
        v42 = 0;
        *(a1 + 2452) = 1;
LABEL_24:
        v44 = &v41;
        v21 = a3;
        v22 = MEMORY[0x1EEE9AC00](result);
        v25 = &v41 - v24;
        if (v26)
        {
          v22 = memset(&v41 - v24, 255, v23);
        }

        MEMORY[0x1EEE9AC00](v22);
        v28 = (&v41 - ((v27 + 15) & 0xFFFFFFFF0));
        if (a3)
        {
          v41 = v12;
          memset(&v41 - ((v27 + 15) & 0xFFFFFFFF0), 170, v27);
          v29 = 4 * v41;
          v30 = v28;
          do
          {
            *v28++ = v25;
            v25 += v29;
            --v21;
          }

          while (v21);
          v31 = a3;
        }

        else
        {
          v30 = (&v41 - ((v27 + 15) & 0xFFFFFFFF0));
          v31 = 0;
        }

        v32 = v30;
        result = mpddrc::UniDrcProcessor::Process(a1 + 2472 + 2144 * *(a1 + 2456), a1 + 2408, a1 + 8, a1 + 1688, *(a1 + 2428), SHIDWORD(v43), a2, v31, v30, a5, a6, v12);
        if (result)
        {
          return result;
        }

        result = mpddrc::UniDrcProcessor::Process(a1 + 2472 + 2144 * *(a1 + 2460), a1 + 2408, a1 + 8, a1 + 1688, *(a1 + 2428), v42, a2, a3, a4, a5, a6, v12);
        if (!((result != 0) | v43 & 1))
        {
          v33 = *(a1 + 2448);
          v34 = v12 - v33;
          if (v12 > v33)
          {
            MEMORY[0x1EEE9AC00](result);
            v35 = &v41 - ((4 * (v12 - v33) + 15) & 0x7FFFFFFF0);
            v36 = memset(v35, 255, 4 * v34);
            MEMORY[0x1EEE9AC00](v36);
            v37 = &v41 - ((4 * v34 + 15) & 0x7FFFFFFF0);
            memset(v37, 255, 4 * v34);
            __B = 1.0 / (v34 + -1.0);
            v46 = -1082130432;
            __A = 0.0;
            v45 = 1065353216;
            vDSP_vramp(&__A, &__B, v35, 1, v34);
            MEMORY[0x19EAE6060](v35, 1, &v46, &v45, v37, 1, v34);
            if (*a6)
            {
              v38 = 0;
              do
              {
                v39 = v32[v38] + 4 * *(a1 + 2448);
                MEMORY[0x19EAE5FA0](v35, 1, v39, 1, v39, 1, v34);
                MEMORY[0x19EAE5F20](v37, 1, a4[v38] + 4 * *(a1 + 2448), 1, v32[v38] + 4 * *(a1 + 2448), 1, a4[v38] + 4 * *(a1 + 2448), 1, v34);
                ++v38;
              }

              while (v38 < *a6);
            }

            return 0;
          }

          if (gDRCScope)
          {
            v40 = *gDRCScope;
            if (!*gDRCScope)
            {
              return 0;
            }
          }

          else
          {
            v40 = MEMORY[0x1E69E9C10];
          }

          if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
          {
            __B = 4.8152e-34;
            v49 = "MPDDRC.cpp";
            v50 = 1024;
            v51 = 1580;
            v52 = 1024;
            v53 = v33;
            _os_log_impl(&dword_19AA99000, v40, OS_LOG_TYPE_INFO, "%25s:%-5d DRC delay too large for smooth DRC transition %d\n", &__B, 0x18u);
          }

          return 0;
        }

        if (result)
        {
          return result;
        }

        return 0;
      }

      *(a1 + 2464) = 0;
      *(a1 + 2452) = 1;
      v20 = 2;
    }

    else
    {
      if (v17 == 2)
      {
        v18 = *(a1 + 2464);
        if (*(a1 + 2464))
        {
          v19 = 4;
        }

        else
        {
          v19 = 8;
        }

        *(a1 + 2452) = 3;
        v42 = v18;
        LODWORD(v43) = v18 ^ 1;
        HIDWORD(v43) = v19;
        goto LABEL_24;
      }

      v20 = 0;
    }

    result = mpddrc::UniDrcProcessor::Process(a1 + 2144 * *(a1 + 2456) + 2472, a1 + 2408, a1 + 8, a1 + 1688, *(a1 + 2428), v20, a2, a3, a4, a5, a6, v12);
    if (result)
    {
      return result;
    }

    return 0;
  }

  return result;
}

void sub_19B0816D8(_Unwind_Exception *a1)
{
  *(v1 - 208) = v1 - 232;
  std::vector<mpddrc::QmfComplexBufferPtr>::__destroy_vector::operator()[abi:ne200100]((v1 - 208));
  _Unwind_Resume(a1);
}

uint64_t initMpegSurroundDecoder(uint64_t a1)
{
  v2 = *(a1 + 3476);
  v3 = *(a1 + 3453);
  v4 = a1 + 3480;
  v5 = *(a1 + 3480 + 4 * v3);
  v6 = *(a1 + 300);
  if (v6 != 42 && ((*(a1 + 180) - 96001) < 0xFFFEA83F || *(a1 + 192) > 7u || *(a1 + 196) > 2u))
  {
    result = 4294966314;
    goto LABEL_11;
  }

  if (*(a1 + 200) == 1 || *(a1 + 192) != 7 || *(a1 + 3504) != -1 || *(a1 + 3496) || (v8 = *(a1 + 3500), v8 != 1) && (v8 || *(a1 + 3492)) || *(a1 + 3457) == 1 || (*(a1 + 3456) | 2) != 2)
  {
    result = 4294966313;
    goto LABEL_11;
  }

  v9 = a1 + 156 * *(a1 + 3453);
  *(a1 + 3476) = 0;
  v10 = (v5 >> 3) & 0x10 | 0xFFF00;
  if ((v5 & 0x2000) == 0)
  {
    v10 = (v5 >> 3) & 0x10;
  }

  if ((v5 & 1) == 0 && *(v9 + 132) == v6)
  {
    v11 = v10 & 0xFFDFFFFF | (((v5 >> 20) & 1) << 21);
    v12 = (v5 >> 5) & 1;
    if (v12 || *(v9 + 24) != 7 || *(v9 + 12) != *(a1 + 180))
    {
      v11 |= 0x500u;
    }

    v13 = v12 | (v2 != 0);
    if (!v13 && *(v9 + 24) == 7 && *(v9 + 12) == *(a1 + 180))
    {
      if (*(v9 + 40) == *(a1 + 208))
      {
        v14 = v11;
      }

      else
      {
        v14 = v11 | 0x200;
      }

      if (*(v9 + 48) == *(a1 + 216))
      {
LABEL_36:
        if (v2 || *(v9 + 24) != 7)
        {
          v16 = v14 | 0x2000;
        }

        else
        {
          if (*(v9 + 12) == *(a1 + 180))
          {
            v16 = v14;
          }

          else
          {
            v16 = v14 | 0x2000;
          }

          if (*(v9 + 44) == *(a1 + 212))
          {
            goto LABEL_45;
          }
        }

        v16 |= 0x4000u;
LABEL_45:
        if (v13 || *(v9 + 12) != *(a1 + 180) || *(v9 + 16) != *(a1 + 184))
        {
          v16 |= 0x8000u;
        }

        v15 = (v16 << 13) & 0x20000 | v16;
        goto LABEL_50;
      }
    }

    else
    {
      v14 = v11 | 0x200;
    }

    v14 |= 0x800u;
    goto LABEL_36;
  }

  v15 = v10 | 0xFFFF00;
LABEL_50:
  CDKmemcpy((v9 + 8), (a1 + 176), 0x9CuLL);
  NrOfQmfBands = mpegSurroundDecoder_GetNrOfQmfBands(v9 + 8);
  result = SpatialDecInit(*(a1 + 168), v9 + 8, NrOfQmfBands, *(a1 + 3476), a1 + 3456, v15);
  v3 = *(a1 + 3453);
  if (!result)
  {
    v5 = 0;
    *(a1 + 4 * v3 + 3488) = 1;
  }

LABEL_11:
  *(v4 + 4 * v3) = v5;
  return result;
}

uint64_t SpatialDecApplyFrame(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, _DWORD *a7, int a8, double a9, int32x4_t a10, int32x4_t a11, int64x2_t a12, double a13, float32x4_t a14, float32x4_t a15, float32x4_t a16, uint64_t a17, UsacQmf *a18, uint64_t a19)
{
  v842[1] = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "SACDEC_ERROR SpatialDecApplyFrame(spatialDec *, SPATIAL_BS_FRAME *, SPATIALDEC_INPUT_MODE, FLOAT *, FLOAT **, FLOAT **, FLOAT *, UINT, UINT *, int, const CDK_channelMapDescr *const, UsacQmf &, MPEG_D::USAC::DynRangeCompressor &)";
    v771 = 1415;
    goto LABEL_687;
  }

  if (!a7)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "SACDEC_ERROR SpatialDecApplyFrame(spatialDec *, SPATIAL_BS_FRAME *, SPATIALDEC_INPUT_MODE, FLOAT *, FLOAT **, FLOAT **, FLOAT *, UINT, UINT *, int, const CDK_channelMapDescr *const, UsacQmf &, MPEG_D::USAC::DynRangeCompressor &)";
    v771 = 1416;
    goto LABEL_687;
  }

  if (!a5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "SACDEC_ERROR SpatialDecApplyFrame(spatialDec *, SPATIAL_BS_FRAME *, SPATIALDEC_INPUT_MODE, FLOAT *, FLOAT **, FLOAT **, FLOAT *, UINT, UINT *, int, const CDK_channelMapDescr *const, UsacQmf &, MPEG_D::USAC::DynRangeCompressor &)";
    v771 = 1417;
    goto LABEL_687;
  }

  v19 = a8;
  *a1 = 0;
  v21 = *a7;
  if ((**(a1 + 376) & 2) != 0)
  {
    if (*(a1 + 504) > 1u)
    {
      v19 = 1;
    }

    else
    {
      v19 = a8;
    }
  }

  if (v19 != *(a1 + 84))
  {
    if (v19 > *(a1 + 20))
    {
      return 4294966299;
    }

    v21 |= 2u;
  }

  *(a1 + 1208) = a5;
  if (!*(a2 + 1))
  {
    v26 = *(a1 + 168);
    v25 = *(a1 + 172);
    if (a6 / *(a1 + 208) + v25 <= v26 && *(a2 + 2) && *(a2 + 4 + 4 * (*(a2 + 2) - 1)) == v26 - 1 && v25 <= *(a2 + 4 + 4 * *(a1 + 180)))
    {
      v23 = 1;
      if ((v21 & 2) != 0)
      {
        goto LABEL_15;
      }

      goto LABEL_21;
    }

    goto LABEL_20;
  }

  if (!*(a2 + 2))
  {
LABEL_20:
    v23 = 0;
    v21 |= 2u;
    if ((v21 & 2) != 0)
    {
      goto LABEL_15;
    }

    goto LABEL_21;
  }

  v23 = 0;
  if ((v21 & 2) != 0)
  {
LABEL_15:
    v24 = 0;
    goto LABEL_22;
  }

LABEL_21:
  v24 = *(a1 + 1360) + 1;
LABEL_22:
  *(a1 + 1360) = v24;
  v27 = *(a1 + 1352);
  if (v27 <= 2)
  {
    switch(v27)
    {
      case 0:
        if ((v21 & 2) != 0)
        {
          goto LABEL_51;
        }

        v30 = 1;
        goto LABEL_47;
      case 1:
        if ((v21 & 2) == 0)
        {
          goto LABEL_51;
        }

        v30 = 2;
        goto LABEL_47;
      case 2:
        v28 = *(a1 + 1356) + 1;
        *(a1 + 1356) = v28;
        if ((v21 & 2) != 0)
        {
          if (v28 < *(a1 + 1336))
          {
            goto LABEL_51;
          }

          if (!*(a1 + 1340))
          {
LABEL_49:
            v32 = 4;
            goto LABEL_50;
          }

          goto LABEL_46;
        }

        goto LABEL_45;
    }

    goto LABEL_692;
  }

  if (v27 == 3)
  {
    v31 = *(a1 + 1356) + 1;
    *(a1 + 1356) = v31;
    if (!v24)
    {
      if (v31 < *(a1 + 1340))
      {
        goto LABEL_51;
      }

      goto LABEL_49;
    }

    v30 = 5;
LABEL_47:
    *(a1 + 1352) = v30;
    goto LABEL_51;
  }

  if (v27 == 4)
  {
    if (!v24)
    {
      goto LABEL_51;
    }

    if (*(a1 + 1344))
    {
      *(a1 + 1352) = 5;
      *(a1 + 1360) = 0;
      goto LABEL_51;
    }

    goto LABEL_45;
  }

  if (v27 != 5)
  {
LABEL_692:
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void SpatialDecConcealment_UpdateState(SpatialDecConcealmentInfo *, const int)";
    v771 = 229;
LABEL_687:
    exception[2] = v771;
  }

  v29 = v24 + 1;
  *(a1 + 1360) = v29;
  if ((v21 & 2) != 0)
  {
LABEL_46:
    v30 = 3;
    goto LABEL_47;
  }

  if (v29 < *(a1 + 1344))
  {
    goto LABEL_51;
  }

LABEL_45:
  v32 = 1;
LABEL_50:
  *(a1 + 1352) = v32;
LABEL_51:
  v33 = a19;
  v798 = v19;
  if (v23)
  {
LABEL_52:
    v34 = 0;
    goto LABEL_78;
  }

  v35 = a2;
  *(a2 + 1) = 0;
  *(a1 + 172) = 0xFFFFFFFF00000000;
  *(a1 + 180) = 0;
  if ((v21 & 2) != 0)
  {
    if (*(a1 + 24) >= 1)
    {
      v37 = 0;
      do
      {
        v38 = a2 + v37;
        *(v38 + 3010) = 0;
        *(v38 + 2880) = 0;
        ++v37;
      }

      while (v37 < *(a1 + 24));
    }

    *(a2 + 3012) = 0;
    *(a2 + 2) = 1;
    *(a2 + 4) = *(a1 + 168) - 1;
    *(a2 + 2560) = 0;
    v39 = *(a1 + 60);
    if (v39 >= 1)
    {
      v40 = *(a1 + 56);
      if (v40 >= *(a1 + 20) + *(a1 + 68))
      {
        v40 = *(a1 + 20) + *(a1 + 68);
      }

      if (v40)
      {
        v41 = 0;
        v42 = *(a1 + 28);
        do
        {
          if (v42 >= 1)
          {
            v43 = **(*(a1 + 1096) + 8 * v41);
            v44 = **(*(a1 + 1104) + 8 * v41);
            v45 = v42;
            do
            {
              *v43++ = 0;
              *v44++ = 0;
              --v45;
            }

            while (v45);
          }

          ++v41;
        }

        while (v41 != v39);
      }
    }

    v36 = 0;
    v35 = a2;
  }

  else
  {
    v36 = *(a2 + 2) - 1;
  }

  *(a1 + 400) = 0;
  v46 = v35 + 4;
  if (*(v35 + 4 + 4 * v36) != *(a1 + 168) - 1)
  {
    *(a1 + 400) = 1;
  }

  *(a1 + 224) = 0;
  if (!*(a1 + 104))
  {
    v724 = *(a1 + 92);
    if (v724 < 1)
    {
LABEL_624:
      if (*(a1 + 80) == 7 && *(a1 + 512))
      {
        if (!*(a2 + 2872) && *(*(a1 + 376) + 145))
        {
          v730 = 0;
          do
          {
            *(**(a1 + 440) + v730++) = 0;
          }

          while (v730 < *(*(a1 + 376) + 145));
        }

        if (v724 >= 1)
        {
          v731 = 0;
          for (i = 0; i != v724; ++i)
          {
            BYTE4(__len) = 0;
            LODWORD(__len) = *(a1 + 976);
            mapIndexData(*(a2 + 2856) + v731, *(a1 + 520), *(a1 + 448), *(a2 + 2864), 0, i, *(a1 + 440), 2, __len, *(a2 + 2), v46, *(a1 + 400), *(a1 + 104), (a1 + 1332));
            v731 += 48;
          }
        }
      }
    }

    else
    {
      v725 = 0;
      v726 = 0;
      while (1)
      {
        v727 = *(a1 + 376) + v726;
        BYTE4(__len) = *(v727 + 140);
        LODWORD(__len) = *(v727 + 146);
        if (mapIndexData(*(a2 + 2840) + v725, *(a1 + 488), *(a1 + 448), a2 + 40, 0, v726, *(a1 + 424), 0, __len, *(a2 + 2), v46, *(a1 + 400), *(a1 + 104), (a1 + 1332)))
        {
          break;
        }

        ++v726;
        v725 += 48;
        if (v724 == v726)
        {
          v728 = 0;
          v729 = 0;
          while (1)
          {
            BYTE4(__len) = 0;
            LODWORD(__len) = *(*(a1 + 376) + v729 + 146);
            if (mapIndexData(*(a2 + 2848) + v728, *(a1 + 496), *(a1 + 448), a2 + 1300, *(a1 + 472), v729, *(a1 + 432), 1, __len, *(a2 + 2), v46, *(a1 + 400), *(a1 + 104), (a1 + 1332)))
            {
              goto LABEL_71;
            }

            ++v729;
            v728 += 48;
            if (v724 == v729)
            {
              goto LABEL_624;
            }
          }
        }
      }
    }
  }

LABEL_71:
  if (*(a2 + 2) > 9u)
  {
    v47 = -980;
LABEL_75:
    v21 |= 2u;
    if (!*a1)
    {
      *a1 = v47;
    }

    v34 = 1;
    goto LABEL_78;
  }

  v48 = *(a1 + 388);
  if (v48 > 28)
  {
    v47 = -979;
    goto LABEL_75;
  }

  if (*(a2 + 2))
  {
    v779 = v21;
    v739 = 0;
    __b[7].n128_u32[0] = -1431655766;
    v740.n128_u64[0] = 0xAAAAAAAAAAAAAAAALL;
    v740.n128_u64[1] = 0xAAAAAAAAAAAAAAAALL;
    __b[5] = v740;
    __b[6] = v740;
    __b[3] = v740;
    __b[4] = v740;
    v741 = a2 + 2560;
    v742 = a2 + 2569;
    __b[1] = v740;
    __b[2] = v740;
    __b[0] = v740;
    do
    {
      v743 = *(v741 + v739);
      if (v743 > 1)
      {
        if (v743 == 2)
        {
          *(*(a1 + 408) + 4 * v739) = smgTimeTable[*(v742 + v739)];
          if (*(a1 + 388) >= 1)
          {
            v756 = 0;
            do
            {
              *(*(*(a1 + 416) + 8 * v739) + v756++) = 1;
            }

            while (v756 < *(a1 + 388));
          }
        }

        else if (v743 == 3)
        {
          *(*(a1 + 408) + 4 * v739) = smgTimeTable[*(v742 + v739)];
          v748 = pbStrideTable[*(a2 + 2578 + v739)];
          v749 = *(a1 + 388);
          v750 = (v749 - 1) / v748;
          createMapping(__b, v749, v748);
          if ((v750 & 0x80000000) == 0)
          {
            v751 = 0;
            LODWORD(v752) = __b[0].n128_u32[0];
            do
            {
              v753 = v751 + 1;
              v754 = __b[0].n128_i32[v751 + 1];
              if (v752 < v754)
              {
                v752 = v752;
                v755 = *(a2 + 2587 + 28 * v739 + v751);
                do
                {
                  *(*(*(a1 + 416) + 8 * v739) + v752++) = v755;
                }

                while (v754 != v752);
              }

              LODWORD(v752) = v754;
              v751 = v753;
            }

            while (v753 != v750 + 1);
          }
        }
      }

      else if (*(v741 + v739))
      {
        if (v743 == 1)
        {
          if (v739)
          {
            *(*(a1 + 408) + 4 * v739) = *(*(a1 + 408) + 4 * (v739 - 1));
            v744 = *(a1 + 416);
            v745 = *(v744 + 8 * v739);
            v746 = *(v744 + 8 * (v739 - 1));
            v747 = *(a1 + 388);
          }

          else
          {
            v757 = *(a1 + 1288);
            **(a1 + 408) = *(v757 + 4);
            v745 = **(a1 + 416);
            v747 = *(a1 + 388);
            v746 = (v757 + 8);
          }

          CDKmemcpy(v745, v746, v747);
        }
      }

      else
      {
        *(*(a1 + 408) + 4 * v739) = 256;
        bzero(*(*(a1 + 416) + 8 * v739), *(a1 + 388));
      }

      ++v739;
      v758 = *(a2 + 2);
    }

    while (v739 < v758);
    v48 = *(a1 + 388);
    v21 = v779;
    v33 = a19;
  }

  else
  {
    v758 = 0;
  }

  v759 = *(a1 + 1288);
  *(v759 + 4) = *(*(a1 + 408) + 4 * v758 - 4);
  CDKmemcpy((v759 + 8), *(*(a1 + 416) + 8 * v758 - 8), v48);
  if (!*(a1 + 400))
  {
    goto LABEL_52;
  }

  v760 = *(a2 + 2);
  *(*(a1 + 408) + 4 * v760) = *(*(a1 + 408) + 4 * v760 - 4);
  CDKmemcpy(*(*(a1 + 416) + 8 * v760), *(*(a1 + 416) + 8 * v760 - 8), *(a1 + 388));
  if (!*(a1 + 400))
  {
    goto LABEL_52;
  }

  v34 = 0;
  v761 = *(a2 + 2);
  if (v761 >= 8)
  {
    v761 = 8;
  }

  *(a2 + 2) = v761 + 1;
  *(v46 + 4 * v761) = *(a1 + 168) - 1;
LABEL_78:
  v815 = 2;
  v49 = *(a1 + 180);
  v791 = *(a1 + 176);
  memset(v816, 170, sizeof(v816));
  v50 = *(a1 + 172);
  v51 = v50 + a6 / *(a1 + 208) - 1;
  if (v51 >= *(a1 + 168) - 1)
  {
    v51 = *(a1 + 168) - 1;
  }

  v778 = v21;
  if (v50 <= v51)
  {
    v53 = v50;
    v54 = v21 & 1 | v34;
    if (*(a1 + 188) == -1)
    {
      v54 = 1;
    }

    v799 = v54;
    v802 = a1 + 361;
    v781 = (a1 + 528);
    v790 = (a1 + 640);
    v782 = a2 + 3014;
    v814 = (a1 + 240);
    *v55.f32 = vsqrt_f32(-1);
    v777 = v55.i64[0];
    v797 = 312 * v19;
    v52 = 0;
    v780 = (v33 + 8);
    v56 = -6.2832;
    v57 = -1.0;
    v58 = 0.25;
    v59 = v49;
    while (1)
    {
      v60 = a2 + 4;
      v792 = *(a2 + 4 + 4 * v59);
      v795 = v53;
      v787 = v59;
      v801 = v52;
      if (v791 + 1 != v53)
      {
        goto LABEL_126;
      }

      v61 = v59;
      *(a1 + 1320) = 0;
      v62 = a2;
      if ((*(a1 + 188) + 1) > 1 || *(a1 + 80) != 7)
      {
        if (!*a1)
        {
          *a1 = -978;
        }

        v799 = 1;
        goto LABEL_95;
      }

      v55.i64[0] = 0;
      v839 = 0u;
      v840 = 0u;
      v837 = 0u;
      v838 = 0u;
      v835 = 0u;
      v836 = 0u;
      v833 = 0u;
      v834 = 0u;
      v831 = 0u;
      v832 = 0u;
      v829 = 0u;
      v830 = 0u;
      v827 = 0u;
      v828 = 0u;
      v825 = 0u;
      v826 = 0u;
      v823 = 0u;
      v824 = 0u;
      v821 = 0u;
      v822 = 0u;
      v820 = 0u;
      memset(v819, 0, sizeof(v819));
      memset(v818, 0, sizeof(v818));
      memset(v817, 0, sizeof(v817));
      v63 = *(a1 + 512);
      if (v63 == 3)
      {
        param2UMX_Prediction__CDK(a1, &v834, v818, &v827, &v820, v817, v819, v59, *(a1 + 361));
      }

      else if (v63 == 1)
      {
        v64 = *(a2 + 2872);
        if (v64)
        {
          v65 = *(a1 + 976);
        }

        else
        {
          v65 = 0;
        }

        if (*(a1 + 112))
        {
          v774 = __cxa_allocate_exception(0x10uLL);
          *v774 = "void param2UMX_PS_IPD_OPD__CDK(spatialDec *, const SPATIAL_BS_FRAME *, FLOAT *, FLOAT *, FLOAT *, FLOAT *, FLOAT *, FLOAT *, int, int, int)";
          v774[2] = 459;
        }

        if (*(a1 + 361))
        {
          v775 = __cxa_allocate_exception(0x10uLL);
          *v775 = "void param2UMX_PS_Core__CDK(const SCHAR *, const SCHAR *, const int, const int, FLOAT *, FLOAT *, FLOAT *, FLOAT *, FLOAT *, FLOAT *)";
          v775[2] = 289;
        }

        v641 = **(a1 + 392);
        v642 = *(**(a1 + 488) + 8 * v59);
        v643 = *(**(a1 + 496) + 8 * v59);
        if (v641 >= 1)
        {
          v644 = v819;
          v645 = &v827;
          v646 = &v820;
          v647 = &v834;
          v648 = *(**(a1 + 488) + 8 * v61);
          v649 = v643;
          v650 = **(a1 + 392);
          do
          {
            v652 = *v648++;
            v651 = v652;
            v653 = *v649++;
            *v647 = H11_nc[8 * v651 + v653];
            v647 = (v647 + 4);
            *v646 = H11_nc[8 * (30 - v651) + v653];
            v646 = (v646 + 4);
            *v645 = *(&H12_nc + 8 * v651 + v653);
            v645 = (v645 + 4);
            v55.f32[0] = -*(&H12_nc + 8 * (30 - v651) + v653);
            *v644++ = v55.i32[0];
            --v650;
          }

          while (v650);
        }

        v654 = v641;
        v655 = *(a1 + 384);
        if (v641 < v655)
        {
          v656 = 4 * (v655 - v641);
          bzero(v819 + 4 * v641, v656);
          bzero(&v827 + 4 * v641, v656);
          bzero(&v820 + 4 * v641, v656);
          bzero(&v834 + 4 * v641, v656);
        }

        if (v64)
        {
          v55.i64[0] = -1;
          v55.i64[1] = -1;
          __b[12] = v55;
          __b[13] = v55;
          __b[10] = v55;
          __b[11] = v55;
          __b[8] = v55;
          __b[9] = v55;
          __b[6] = v55;
          __b[7] = v55;
          __b[4] = v55;
          __b[5] = v55;
          __b[2] = v55;
          __b[3] = v55;
          __b[0] = v55;
          __b[1] = v55;
          v657 = *(a1 + 976);
          if (v657 >= 1)
          {
            v658 = *(**(a1 + 520) + 8 * v61);
            v659 = &__b[0].n128_f32[1];
            do
            {
              v661 = *v642++;
              v660 = v661;
              v663 = *v658++;
              v662 = v663;
              v664 = dequantIPD__CDK[v663];
              v55.i64[0] = 0;
              if (v663 != 8 || v660 != 15)
              {
                v666 = sqrt_CLD_m[v660];
                v667 = v666 * dequantICC__CDK[*v643];
                v668 = sinIpd_tab[(v662 + 4) & 0xF];
                v669 = sqrt(sqrt((((((v666 * v666) + 1.0) + (v668 * (v667 + v667))) / (((v666 * v666) + 1.0) + (v667 + v667))) + 0.000000001)));
                *v55.i64 = atan2((sinIpd_tab[v662] * v669), ((v668 * v669) + ((2.0 - v669) * v666)));
                v55.f32[0] = *v55.i64;
              }

              *a10.i32 = v55.f32[0] - v664;
              *(v659 - 1) = v55.f32[0];
              *v659 = v55.f32[0] - v664;
              v659 += 2;
              ++v643;
              --v657;
            }

            while (v657);
          }

          if (v65 >= 1)
          {
            v670 = v65;
            v671 = &__b[0].n128_f32[1];
            v672 = (a1 + 640);
            do
            {
              *(v672 - 28) = wrapPhase(*(v671 - 1));
              v55.f32[0] = wrapPhase(*v671);
              *v672++ = v55.f32[0];
              v671 += 2;
              --v670;
            }

            while (v670);
          }
        }

        if (v65 < v654)
        {
          v673 = v654 - v65;
          v674 = &v790[4 * v65];
          do
          {
            *(v674 - 28) = 0;
            *v674++ = 0;
            --v673;
          }

          while (v673);
        }

        v62 = a2;
        LODWORD(v59) = v787;
        LODWORD(v52) = v801;
        v60 = a2 + 4;
      }

      else if (*(a1 + 112))
      {
        param2UMX_Prediction__CDK(a1, &v834, 0, &v827, &v820, 0, v819, v59, *(a1 + 361));
      }

      else
      {
        v708 = **(a1 + 392);
        if (v708 >= 1)
        {
          v709 = *(**(a1 + 488) + 8 * v59);
          v710 = *(**(a1 + 496) + 8 * v59);
          v711 = v819;
          v712 = &v827;
          v713 = &v820;
          v714 = &v834;
          v715 = **(a1 + 392);
          do
          {
            v717 = *v709++;
            v716 = v717;
            v718 = *v710++;
            *v714 = H11_nc[8 * v716 + v718];
            v714 = (v714 + 4);
            *v713 = H11_nc[8 * (30 - v716) + v718];
            v713 = (v713 + 4);
            *v712 = *(&H12_nc + 8 * v716 + v718);
            v712 = (v712 + 4);
            v55.f32[0] = -*(&H12_nc + 8 * (30 - v716) + v718);
            *v711++ = v55.i32[0];
            --v715;
          }

          while (v715);
        }

        v675 = *(a1 + 384);
        if (v708 >= v675)
        {
          goto LABEL_562;
        }

        v719 = 4 * (v675 - v708);
        bzero(v819 + 4 * v708, v719);
        bzero(&v827 + 4 * v708, v719);
        bzero(&v820 + 4 * v708, v719);
        bzero(&v834 + 4 * v708, v719);
      }

      v675 = *(a1 + 384);
LABEL_562:
      if (v675 >= 1)
      {
        v676 = *(a1 + 984);
        v677 = *(v676 + 8);
        v678 = **v676;
        v679 = *(*v676 + 8);
        v680 = v675;
        v681 = v819;
        v682 = *v677;
        v683 = v677[1];
        v684 = &v820;
        v685 = &v827;
        v686 = &v834;
        v687 = v675;
        do
        {
          v688 = *v686++;
          *v678++ = v688;
          v689 = *v685++;
          *v679++ = v689;
          v690 = *v684++;
          *v682++ = v690;
          v691 = *v681++;
          v55.i32[0] = v691;
          *v683++ = v691;
          --v687;
        }

        while (v687);
        if (v63 == 3)
        {
          v692 = *(a1 + 992);
          v693 = *v692;
          v694 = *(v692 + 8);
          v695 = **v692;
          v696 = v693[1];
          v697 = *v694;
          v698 = *(v694 + 8);
          v699 = v817;
          v700 = v818;
          do
          {
            v701 = *v700++;
            *v695++ = v701;
            v702 = *v699++;
            v55.i32[0] = v702;
            *v697++ = v702;
            *v696++ = 0;
            *v698++ = 0;
            --v680;
          }

          while (v680);
        }
      }

      if (*(a1 + 512) == 1)
      {
        v703 = *(a1 + 1288);
        v704 = (v703 + 36);
        v705 = (v703 + 148);
        if (*(v62 + 2876))
        {
          v706 = *(v60 + 4 * v61);
          if (v59)
          {
            v707 = v706 - *(v60 + 4 * v61 - 4);
          }

          else
          {
            v707 = v706 + 1;
          }

          if (v675 >= 1)
          {
            v720 = 0;
            v55.f32[0] = vcvts_n_f32_s32(v707, 7uLL);
            *a10.i32 = 1.0 - v55.f32[0];
            a11.i32[0] = dword_19B0B04F8[*(*(v62 + 2856) + v61 + 9) == 0];
            do
            {
              a14.i32[0] = *&v781[4 * v720];
                ;
              }

              while (a14.f32[0] < (j + -3.1416))
              {
                a14.f32[0] = a14.f32[0] + 6.2832;
              }

              a15.i32[0] = *&v790[4 * v720];
              v722 = *&v705[4 * v720];
              while (a15.f32[0] > (v722 + 3.1416))
              {
                a15.f32[0] = a15.f32[0] + v56;
              }

              while (a15.f32[0] < (v722 + -3.1416))
              {
                a15.f32[0] = a15.f32[0] + 6.2832;
              }

              v723 = (*a10.i32 * j) + (v55.f32[0] * a14.f32[0]);
              *&v704[4 * v720] = v723;
              *&a13 = (*a10.i32 * v722) + (v55.f32[0] * a15.f32[0]);
              *&v705[4 * v720] = LODWORD(a13);
                ;
              }

              while (a16.f32[0] < -3.1416)
              {
                a16.f32[0] = a16.f32[0] + 6.2832;
              }

              if (a16.f32[0] <= 0.0)
              {
                a16.f32[0] = -a16.f32[0];
              }

              if (a16.f32[0] > *a11.i32)
              {
                *&v704[4 * v720] = a14.i32[0];
                *&v705[4 * v720] = a15.i32[0];
                LODWORD(a13) = a15.i32[0];
                v723 = a14.f32[0];
              }

              if (v723 > 6.2832)
              {
                do
                {
                  v723 = v723 + v56;
                }

                while (v723 > 6.2832);
                *&v704[4 * v720] = v723;
              }

              if (v723 < 0.0)
              {
                do
                {
                  v723 = v723 + 6.2832;
                }

                while (v723 < 0.0);
                *&v704[4 * v720] = v723;
              }

              if (*&a13 > 6.2832)
              {
                do
                {
                  *&a13 = *&a13 + v56;
                }

                while (*&a13 > 6.2832);
                *&v705[4 * v720] = LODWORD(a13);
              }

              if (*&a13 < 0.0)
              {
                do
                {
                  *&a13 = *&a13 + 6.2832;
                }

                while (*&a13 < 0.0);
                *&v705[4 * v720] = LODWORD(a13);
              }

              *&v781[4 * v720] = v723;
              a12.i32[0] = *&v705[4 * v720];
              *&v790[4 * v720++] = a12.i32[0];
            }

            while (v720 != v675);
          }
        }

        else
        {
          CDKmemcpy(v704, v781, (4 * v675));
          CDKmemcpy(v705, v790, (4 * *(a1 + 384)));
          LODWORD(v59) = v787;
          LODWORD(v52) = v801;
          v60 = a2 + 4;
        }
      }

LABEL_95:
      if (!v59 && *(a1 + 1328))
      {
        SpatialDecBufferMatrices(a1);
        *(a1 + 1328) = 0;
        LODWORD(v52) = v801;
        v60 = a2 + 4;
      }

      if (*(a1 + 112) && (v66 = *(a1 + 92), v66 >= 1))
      {
        LODWORD(v67) = 0;
        v68 = (a1 + 361);
        do
        {
          v70 = *v68++;
          v69 = v70;
          if (v67 <= v70)
          {
            v67 = v69;
          }

          else
          {
            v67 = v67;
          }

          --v66;
        }

        while (v66);
      }

      else
      {
        v67 = 0;
      }

      v71 = *(v60 + 4 * v61);
      v72 = *(a1 + 1288);
      v73 = v71 - *v72;
      if (v71 <= *v72)
      {
        v73 += *(a1 + 168);
      }

      v74 = *(a1 + 384);
      if (v74 >= 1)
      {
        v75 = 0;
        v55.f32[0] = v73 / *(*(a1 + 408) + 4 * v61);
        *a10.i32 = 1.0 - v55.f32[0];
        v76 = *(*(a1 + 416) + 8 * v61);
        do
        {
          if (*(v76 + v75))
          {
            v77 = v75 >= v67;
          }

          else
          {
            v77 = 0;
          }

          if (v77)
          {
            v78 = *(a1 + 96);
            if (v78 >= 1)
            {
              v79 = 0;
              v80 = *(a1 + 160);
              do
              {
                if (v80 >= 1)
                {
                  v81 = 0;
                  v82 = *(*(a1 + 984) + 8 * v79);
                  v83 = *(*(a1 + 1000) + 8 * v79);
                  v84 = *(a1 + 512);
                  do
                  {
                    v85 = *(v82 + v81);
                    *a12.i32 = *a10.i32 * *(*(v83 + v81) + 4 * v75);
                    *a11.i32 = *a12.i32 + (v55.f32[0] * *(v85 + 4 * v75));
                    *(v85 + 4 * v75) = a11.i32[0];
                    if (v84 == 3)
                    {
                      v86 = *(*(*(a1 + 992) + 8 * v79) + v81);
                      *a12.i32 = *a10.i32 * *(*(*(*(a1 + 1008) + 8 * v79) + v81) + 4 * v75);
                      *a11.i32 = *a12.i32 + (v55.f32[0] * *(v86 + 4 * v75));
                      *(v86 + 4 * v75) = a11.i32[0];
                    }

                    v81 += 8;
                  }

                  while (8 * v80 != v81);
                }

                ++v79;
              }

              while (v79 != v78);
            }
          }

          ++v75;
        }

        while (v75 != v74);
      }

      *v72 = v71;
LABEL_126:
      if (a3 == 1001)
      {
        *(a1 + 200) = 1;
        v87 = *(a1 + 84);
        if (v87 >= 1)
        {
          v88 = 0;
          v89 = *(a1 + 1040);
          v90 = *(a1 + 1048);
          do
          {
            v91 = *(v89 + 8 * v88);
            v92 = *(v90 + 8 * v88);
            v93 = *(a1 + 1216) + (v88 << 7);
            if (*(a1 + 200))
            {
              CDK_QmfDomain_GetSlot(v93 + 80, v52 + 6, 0, 3, *(v89 + 8 * v88), *(v90 + 8 * v88));
              CDK_QmfDomain_GetSlot(*(a1 + 1216) + (v88 << 7) + 80, v801, 3u, *(a1 + 208), v91, v92);
            }

            else
            {
              CDK_QmfDomain_GetSlot(v93 + 80, v52, 0, *(a1 + 208), *(v89 + 8 * v88), *(v90 + 8 * v88));
            }

            v94 = *(a1 + 1216);
            LODWORD(v52) = v801;
            if (*(v94 + 70) - 1 == v801)
            {
              CDK_QmfDomain_SaveOverlap((v94 + (v88 << 7) + 80));
              LODWORD(v52) = v801;
            }

            if (!v799)
            {
              v95 = *(a1 + 208);
              if (v95 >= 1)
              {
                v96 = *(v89 + 8 * v88);
                v97 = *(v90 + 8 * v88);
                do
                {
                  *v96 = (*v96 * *(a1 + 144)) * 0.000030518;
                  ++v96;
                  a10.i32[0] = *(a1 + 144);
                  v55.f32[0] = (*v97 * *a10.i32) * 0.000030518;
                  *v97++ = v55.f32[0];
                  --v95;
                }

                while (v95);
              }
            }

            ++v88;
          }

          while (v88 != v87);
        }

        if (!v799)
        {
          v98 = *(a1 + 88);
          if (v98 >= 1)
          {
            v99 = (v98 + 3) & 0xFFFFFFFC;
            v55 = vdupq_n_s64(v98 - 1);
            a10 = xmmword_19B0A5840;
            a11 = xmmword_19B0A5850;
            v100 = (*(a1 + 1216) + 636);
            do
            {
              v101 = vmovn_s64(vcgeq_u64(v55, a11));
              if (vuzp1_s16(v101, *v55.f32).u8[0])
              {
                *(v100 - 60) = 1191182336;
              }

              if (vuzp1_s16(v101, *&v55).i8[2])
              {
                *(v100 - 40) = 1191182336;
              }

              v102 = vmovn_s64(vcgeq_u64(v55, a10));
              a13 = COERCE_DOUBLE(vuzp1_s16(*v55.f32, v102));
              if (BYTE4(a13))
              {
                *(v100 - 20) = 1191182336;
              }

              if (vuzp1_s16(*&v55, v102).i8[6])
              {
                *v100 = 1191182336;
              }

              a12 = vdupq_n_s64(4uLL);
              a10 = vaddq_s64(a10, a12);
              a11 = vaddq_s64(a11, a12);
              v100 += 80;
              v99 -= 4;
            }

            while (v99);
          }
        }
      }

      else
      {
        *(a1 + 200) = 0;
        v810 = *(a1 + 84);
        if (v810 >= 1)
        {
          v103 = 0;
          v104 = *(a1 + 1040);
          v105 = *(a1 + 1048);
          v106 = *(*(a1 + 1216) + 70) * *(*(a1 + 1216) + 66);
          do
          {
            v107 = *(a1 + 1216);
            v108 = *(v104 + 8 * v103);
            v109 = *(v105 + 8 * v103);
            v110 = v107 + (v103 << 7);
            v111 = (a4 + 4 * (v801 * *(v107 + 64)) + 4 * v106 * v103);
            memset(__b, 170, 0x208uLL);
            qmfAnalysisFilteringSlot(v110 + 88, v108, v109, v111, (__b + (-__b & 7)));
            if (!v799)
            {
              v112 = *(a1 + 208);
              if (v112 >= 1)
              {
                v113 = *(v104 + 8 * v103);
                v114 = *(v105 + 8 * v103);
                do
                {
                  *v113 = (*v113 * *(a1 + 144)) * 0.000030518;
                  ++v113;
                  a10.i32[0] = *(a1 + 144);
                  v55.f32[0] = (*v114 * *a10.i32) * 0.000030518;
                  *v114++ = v55.f32[0];
                  --v112;
                }

                while (v112);
              }
            }

            ++v103;
          }

          while (v103 != v810);
        }
      }

      *(a1 + 1036) = (*(a1 + 1036) + 1) % *(a1 + 1032);
      if ((**(a1 + 376) & 2) != 0)
      {
        if (*(a1 + 112))
        {
          UsacQmf::ProcessAnalysis((*(a1 + 1216) + 768), 0, 1, (a4 + 4 * v795 * *(*(a1 + 1216) + 64) + 4 * *(*(a1 + 1216) + 70) * *(*(a1 + 1216) + 64)), **(a1 + 1096), **(a1 + 1104));
          if (!v799)
          {
            v115 = *(a1 + 208);
            if (v115 >= 1)
            {
              v116 = ***(a1 + 1096);
              v117 = ***(a1 + 1104);
              do
              {
                *v116 = (*v116 * *(a1 + 144)) * 0.000030518;
                ++v116;
                a10.i32[0] = *(a1 + 144);
                v55.f32[0] = (*v117 * *a10.i32) * 0.000030518;
                *v117++ = v55.f32[0];
                --v115;
              }

              while (v115);
            }
          }
        }
      }

      v118 = v798;
      if (v798 >= 1)
      {
        v119 = 0;
        v120 = *(a1 + 1040);
        v121 = *(a1 + 1048);
        v122 = *(a1 + 1056);
        v123 = *(a1 + 1064);
        do
        {
          v124 = *(a1 + 200);
          v125 = *(a1 + 1224) + v119;
          *(v125 + 272) = v124;
          v126 = *(a1 + 504) != 3 || v124 == 0;
          if (!v126)
          {
            v762 = __cxa_allocate_exception(0x10uLL);
            *v762 = "SACDEC_ERROR SpatialDecHybridAnalysis(spatialDec *, FLOAT **, FLOAT **, FLOAT **, FLOAT **, const INT, const INT)";
            v762[2] = 207;
          }

          CDKhybridAnalysisApply(v125, *v120, *v121, *v122, *v123, *v55.i64, *a10.i64, *a11.i64, a12, a13, *a14.i64, a15, a16);
          v119 += 312;
          ++v123;
          ++v122;
          ++v121;
          ++v120;
          v118 = v798;
        }

        while (v797 != v119);
      }

      if ((**(a1 + 376) & 2) != 0 && *(a1 + 112))
      {
        v127 = *(a1 + 1224) + 312 * v118;
        *(v127 + 272) = 0;
        CDKhybridAnalysisApply(v127, ***(a1 + 1096), ***(a1 + 1104), **(a1 + 1112), **(a1 + 1120), *v55.i64, *a10.i64, *a11.i64, a12, a13, *a14.i64, a15, a16);
        v118 = v798;
      }

      v55.f32[0] = (v795 - v791);
      *a10.i32 = (v792 - v791);
      v128 = v55.f32[0] / *a10.i32;
      if (!v799)
      {
        v828 = 0u;
        v829 = 0u;
        v827 = 0u;
        v821 = 0u;
        v822 = 0u;
        v820 = 0u;
        v137 = *(a1 + 84);
        if (v137 >= 1)
        {
          v138 = *(a1 + 1056);
          v139 = *(a1 + 1064);
          v140 = &v820;
          v141 = &v827;
          do
          {
            v142 = *v138++;
            *v141 = v142;
            v141 = (v141 + 8);
            v143 = *v139++;
            *v140 = v143;
            v140 = (v140 + 8);
            --v137;
          }

          while (v137);
        }

        if (*(a1 + 160) != 2)
        {
          v765 = __cxa_allocate_exception(0x10uLL);
          *v765 = "SACDEC_ERROR SpatialDecApplyM1_CreateW_Mode212(spatialDec *, const SPATIAL_BS_FRAME *, FLOAT **, FLOAT **, FLOAT **, FLOAT **)";
          v765[2] = 301;
        }

        if (*(a1 + 148) != 1)
        {
          v766 = __cxa_allocate_exception(0x10uLL);
          *v766 = "SACDEC_ERROR SpatialDecApplyM1_CreateW_Mode212(spatialDec *, const SPATIAL_BS_FRAME *, FLOAT **, FLOAT **, FLOAT **, FLOAT **)";
          v766[2] = 302;
        }

        if (*(a1 + 156) != 1)
        {
          v767 = __cxa_allocate_exception(0x10uLL);
          *v767 = "SACDEC_ERROR SpatialDecApplyM1_CreateW_Mode212(spatialDec *, const SPATIAL_BS_FRAME *, FLOAT **, FLOAT **, FLOAT **, FLOAT **)";
          v767[2] = 303;
        }

        v144 = *(a1 + 1160);
        v145 = *(a1 + 1168);
        v146 = *v144;
        v147 = *v145;
        CDKmemcpy(*v144, v827, (4 * *(a1 + 212)));
        CDKmemcpy(*v145, v820, (4 * *(a1 + 212)));
        v148 = *(a2 + 3012);
        if (*(a2 + 3012))
        {
          v146 = *v144;
          v149 = v144[1];
          v147 = *v145;
          v150 = v145[1];
          if ((*(v782 + *(a1 + 224)) & 0x80000000) == 0)
          {
            v151 = 0;
            v152 = *(a1 + 212);
            do
            {
              *&v149[v151] = *&v146[v151];
              v55.i32[0] = *&v147[v151];
              *&v150[v151] = v55.i32[0];
              v151 += 4;
            }

            while (v151 != 28);
            if (v152 >= 8)
            {
              v153 = 4 * v152;
              v154 = 28;
              do
              {
                *&v149[v154] = 0;
                *&v150[v154] = 0;
                v154 += 4;
              }

              while (v153 != v154);
            }

            v146 = v149;
            v147 = v150;
          }
        }

        else
        {
          v149 = v144[1];
          v150 = v145[1];
        }

        v158 = row2residual[2 * *(a1 + 80) + 1];
        v159 = *(a1 + 1272);
        if (v159)
        {
          v808 = v144;
          v811 = v145;
          *v805 = row2residual[2 * *(a1 + 80) + 1];
          v160 = *(*(a1 + 232) + 4 * *(v802 + v158));
          v161 = *(v159 + 2616);
          v162 = *(v159 + 2352);
          v55.i64[0] = 0;
          v834 = 0u;
          v835 = 0u;
          v836 = 0u;
          v837 = 0u;
          v838 = 0u;
          v839 = 0u;
          v840 = 0u;
          a11.i32[0] = 8.0;
          if (v162 > v160)
          {
            v163 = v162 - v160;
            v164 = &v147[4 * v160];
            v165 = &v146[4 * v160];
            v166 = (*(v159 + 2384) + v160);
            do
            {
              v168 = *v166++;
              v167 = v168;
              v169 = *v165++;
              v170 = v169;
              v171 = *v164++;
              a10.i32[0] = *(&v834 + v167);
              v55.f32[0] = *a10.i32 + (((v171 * v171) + (v170 * v170)) * 8.0);
              *(&v834 + v167) = v55.i32[0];
              --v163;
            }

            while (v163);
          }

          v172 = 0;
          LODWORD(v173) = 0;
          v174 = *(v159 + 40);
          v175 = v159 + 64;
          do
          {
            if (v173 <= v160)
            {
              v176 = v160;
            }

            else
            {
              v176 = v173;
            }

            if (*(v174 + v172) >= v161)
            {
              v173 = v161;
            }

            else
            {
              v173 = *(v174 + v172);
            }

            if (v176 < v173)
            {
              if (*(*(v159 + 32) + 4 * v172) != 2)
              {
                goto LABEL_284;
              }

              v177 = *(*(v159 + 56) + v172);
              v178 = *(*(v159 + 48) + v172);
              v179 = (v159 + 80 + 32 * v176);
              v181 = v179[1];
              v180 = v179[2];
              v182 = *v179;
              v183 = (v181 + 4 * *(v175 + 4 * v172));
              v184 = 2 * v177;
              if (v177 == 2)
              {
                v195 = 0;
                *a11.i8 = *v180;
                v196 = vrev64q_s32(a11);
                v55 = vzip1q_s32(v196, v196);
                *a10.i8 = vdup_lane_s32(*v180, 0);
                v197 = &v150[4 * v176];
                *a11.i8 = vdup_lane_s32(*a11.i8, 1);
                v198 = v173 - v176;
                v199 = &v149[4 * v176];
                v200 = &v147[4 * v176];
                v201 = &v146[4 * v176];
                v202 = 8 * v178;
                do
                {
                  a13 = *v183;
                  v183->i32[0] = *&v201[4 * v195];
                  v183->i32[1] = *&v200[4 * v195];
                  *a12.i8 = vmla_f32(*v182, *a10.i8, *&a13);
                  *&v199[4 * v195] = a12.i32[0];
                  *&v197[4 * v195] = a12.i32[1];
                  *v203.f32 = vmla_f32(*(v182 + 8), *a11.i8, *&a13);
                  a12.i64[1] = a12.i64[0];
                  *&v203.i64[1] = a13;
                  a14 = vmlsq_f32(v203, v55, a12);
                  *v182 = a14;
                  ++v195;
                  v182 += 4 * (2 * v177);
                  v183 = (v183 + v202);
                }

                while (v198 != v195);
              }

              else if (v177 == 3)
              {
                v185 = 0;
                *v55.f32 = vld1_dup_f32(v180);
                v186 = (v180 + 4);
                v187 = &v150[4 * v176];
                a11.i64[0] = *v186;
                v188 = vrev64q_s32(a11);
                a10 = vzip1q_s32(v188, v188);
                a11 = vzip1q_s32(a11, a11);
                v189 = v173 - v176;
                v190 = &v149[4 * v176];
                v191 = &v147[4 * v176];
                v192 = &v146[4 * v176];
                v193 = 8 * v178;
                do
                {
                  v194 = *v183;
                  v183->i32[0] = *&v192[4 * v185];
                  v183->i32[1] = *&v191[4 * v185];
                  *a12.i8 = vmla_f32(*v182, *v55.f32, v194);
                  *&v190[4 * v185] = a12.i32[0];
                  *&v187[4 * v185] = a12.i32[1];
                  *a14.f32 = vneg_f32(*a12.i8);
                  a14.i64[1] = a14.i64[0];
                  *a16.f32 = v194;
                  *&a16.u32[2] = v194;
                  a15 = vmlaq_f32(vmlaq_f32(*(v182 + 8), a11, a16), a10, a14);
                  *v182 = a15;
                  a13 = COERCE_DOUBLE(vmls_f32(v194, *v55.f32, *a12.i8));
                  *(v182 + 16) = a13;
                  ++v185;
                  v182 += 4 * (2 * v177);
                  v183 = (v183 + v193);
                }

                while (v189 != v185);
              }

              else
              {
                v204 = v177;
                v205 = 2 * v178 - 1;
                v206 = v184;
                v207 = v180 + 4 * v177 - 4;
                v208 = v182 + 8;
                v209 = 4 * v184;
                do
                {
                  v210 = v183->f32[0];
                  v183->i32[0] = *&v146[4 * v176];
                  v212 = v183->f32[1];
                  v211 = v183 + 1;
                  v213 = v212;
                  *v211 = *&v147[4 * v176];
                  v214 = *v180->i32;
                  v215 = *v182;
                  v216 = *(v182 + 4);
                  *&v149[4 * v176] = *v182 + (v210 * *v180->i32);
                  v217 = v216 + (v212 * v214);
                  *&v150[4 * v176] = v217;
                  v218 = -(v215 + (v210 * v214));
                  v219 = -v217;
                  if (v204 < 2)
                  {
                    v227 = 1;
                  }

                  else
                  {
                    v220 = v208;
                    v221 = v207;
                    v222 = v180 + 1;
                    v223 = v204 - 1;
                    do
                    {
                      v224 = *v222++;
                      v225 = v224;
                      v226 = *v221--;
                      a16.i32[0] = *(v220 + 4);
                      a15.f32[0] = (*v220 + (v210 * v225)) + (v218 * v226);
                      *(v220 - 8) = a15.i32[0];
                      *(v220 - 4) = (a16.f32[0] + (v213 * v225)) + (v219 * v226);
                      v220 += 8;
                      --v223;
                    }

                    while (v223);
                    v227 = v204;
                  }

                  LODWORD(a13) = v180->i32[v227];
                  a14.i32[0] = v180->i32[v204 - v227];
                  v183 = &v211[v205];
                  *a12.i32 = a14.f32[0] * v218;
                  v55.f32[0] = *a12.i32 + (v210 * *&a13);
                  v228 = v182 + 8 * v227;
                  *a11.i32 = a14.f32[0] * v219;
                  *a10.i32 = *a11.i32 + (v213 * *&a13);
                  *(v228 - 8) = v55.i32[0];
                  *(v228 - 4) = a10.i32[0];
                  v182 += 4 * v206;
                  ++v176;
                  v208 += v209;
                }

                while (v176 != v173);
              }
            }

            ++v172;
          }

          while (v172 != 4);
          v229 = 0;
          v230 = *(v159 + 48);
          do
          {
            v231 = *(v175 + 4 * v229) + 2;
            *(v175 + 4 * v229) = v231;
            if (v231 >= 2 * *(v230 + v229))
            {
              v231 = 0;
            }

            *(v175 + 4 * v229++) = v231;
          }

          while (v229 != 4);
          v232 = *(v159 + 2352);
          v233 = *(v159 + 2384);
          v234 = *(v233 + v160);
          v55.i64[0] = 0;
          memset(__b, 0, 112);
          a11.i32[0] = 8.0;
          v144 = v808;
          v145 = v811;
          if (v232 > v160)
          {
            v235 = v232 - v160;
            v236 = &v150[4 * v160];
            v237 = (v233 + v160);
            v238 = &v149[4 * v160];
            do
            {
              v240 = *v237++;
              v239 = v240;
              v241 = *v238++;
              v242 = v241;
              v243 = *v236++;
              a10.i32[0] = __b[0].n128_i32[v239];
              v55.f32[0] = *a10.i32 + (((v243 * v243) + (v242 * v242)) * 8.0);
              __b[0].n128_u32[v239] = v55.i32[0];
              --v235;
            }

            while (v235);
          }

          v244 = *(v159 + 2356);
          v158 = *v805;
          if (v244 > v234)
          {
            v245 = v159 + 2392;
            v246 = *(v159 + 2368);
            while (1)
            {
              v247 = *(&v834 + v234);
              a10.i32[1] = __b[0].n128_i32[v234];
              *a11.i8 = vdup_n_s32(0x3E4CCCCCu);
              *v55.f32 = vmla_f32(vmul_f32(*(v245 + 8 * v234), vdup_n_s32(0x3F4CCCCDu)), *a11.i8, *a10.i8);
              *(v245 + 8 * v234) = v55.i64[0];
              a12.i32[0] = 1.5;
              *a10.i32 = 1.5 * v55.f32[0];
              v248 = *(v246 + v234) >= v232 ? v232 : *(v246 + v234);
              a11.i32[0] = v55.i32[1];
              if (v55.f32[1] > *a10.i32)
              {
                break;
              }

              *a10.i32 = v55.f32[1] * 1.5;
              if (v55.f32[0] > (v55.f32[1] * 1.5))
              {
                *a11.i32 = v55.f32[0] * v58;
                if (*a10.i32 > (v55.f32[0] * v58))
                {
                  v55.f32[0] = v55.f32[0] / *a10.i32;
                  goto LABEL_256;
                }

                if (v160 < v248)
                {
                  v252 = v248 - v160;
                  v253 = &v150[4 * v160];
                  v254 = &v149[4 * v160];
                  do
                  {
                    *v254 = *v254 + *v254;
                    ++v254;
                    v55.f32[0] = *v253 + *v253;
                    *v253++ = v55.f32[0];
                    --v252;
                  }

                  while (v252);
                  goto LABEL_268;
                }

LABEL_267:
                v248 = v160;
              }

LABEL_268:
              ++v234;
              v160 = v248;
              if (v234 == v244)
              {
                goto LABEL_269;
              }
            }

            v55.f32[0] = *a10.i32 / v55.f32[1];
LABEL_256:
            if (v160 < v248)
            {
              v249 = v248 - v160;
              v250 = &v150[4 * v160];
              v251 = &v149[4 * v160];
              v55.f32[0] = sqrtf(v55.f32[0]);
              do
              {
                *v251 = *v251 * v55.f32[0];
                ++v251;
                *a10.i32 = *v250 * v55.f32[0];
                *v250++ = *a10.i32;
                --v249;
              }

              while (v249);
              goto LABEL_268;
            }

            goto LABEL_267;
          }

LABEL_269:
          v148 = *(a2 + 3012);
        }

        if (v148)
        {
          v255 = *(a1 + 224);
          v256 = *(v782 + v255);
          if ((v256 & 0x8000000000000000) == 0)
          {
            if (v256 > 7)
            {
              v769 = __cxa_allocate_exception(0x10uLL);
              *v769 = "void TsdApply(const int, const TSD_DATA *, int *, const FLOAT *, const FLOAT *, FLOAT *, FLOAT *)";
              v769[2] = 289;
            }

            v257 = *(a1 + 212);
            if (v257 >= 8)
            {
              v258 = (&phiTsd + 8 * v256);
              v55.i32[0] = *v258;
              a10.i32[0] = v258[1];
              v259 = v257 - 7;
              *a11.i32 = -*a10.i32;
              v260 = v145[1] + 28;
              v261 = (v144[1] + 28);
              v262 = (*v145 + 28);
              v263 = (*v144 + 28);
              do
              {
                v264 = *v263++;
                v265 = v264;
                v266 = *v262++;
                a15.i32[0] = *v261;
                a14.f32[0] = *v261 + ((v266 * *a11.i32) + (v265 * v55.f32[0]));
                *v261++ = a14.i32[0];
                LODWORD(a13) = *v260;
                *a12.i32 = *v260 + ((v266 * v55.f32[0]) + (v265 * *a10.i32));
                *v260++ = a12.i32[0];
                --v259;
              }

              while (v259);
            }
          }

          *(a1 + 224) = (v255 + 1) & 0x3F;
        }

        if (*(v802 + v158))
        {
          v267 = *(*(a1 + 232) + 4 * *(v802 + v158));
          if (v267 >= *(a1 + 212))
          {
            v268 = *(a1 + 212);
          }

          else
          {
            v268 = *(*(a1 + 232) + 4 * *(v802 + v158));
          }

          CDKmemcpy(v144[1], *(*(a1 + 1112) + 8 * v158), (4 * v268));
          v269 = *(a1 + 212);
          if (v267 < v269)
          {
            v269 = v267;
          }

          CDKmemcpy(v145[1], *(*(a1 + 1120) + 8 * v158), (4 * v269));
        }

LABEL_284:
        v270 = **(a1 + 376);
        v271 = *(a1 + 128);
        v272 = (v271 - 1) < 2 || (**(a1 + 376) & 6) != 0;
        if ((v270 & 6) != 0 && (v271 - 1) >= 2)
        {
          v388 = *(a1 + 1160);
          v389 = *(a1 + 1168);
          v390 = *(a1 + 1176);
          v391 = *(a1 + 1184);
          if (*(a1 + 512) == 3)
          {
            v813 = *(a1 + 96);
            if (v813 >= 1)
            {
              if ((v270 & 0x20) != 0)
              {
                v772 = __cxa_allocate_exception(0x10uLL);
                *v772 = "SACDEC_ERROR SpatialDecApplyM2_Mode212_ResidualsPlusPhaseCoding(spatialDec *, INT, const FLOAT, FLOAT **, FLOAT **, FLOAT **, FLOAT **)";
                v772[2] = 457;
              }

              v807 = *(a1 + 128);
              if (*(a1 + 244) + *(a1 + 240) < 3)
              {
                v773 = __cxa_allocate_exception(0x10uLL);
                *v773 = "SACDEC_ERROR SpatialDecApplyM2_Mode212_ResidualsPlusPhaseCoding(spatialDec *, INT, const FLOAT, FLOAT **, FLOAT **, FLOAT **, FLOAT **)";
                v773[2] = 458;
              }

              v392 = 0;
              v393 = *(*(a1 + 216) + *(a1 + 212) - 1);
              v809 = *(a1 + 984);
              v394 = *(a1 + 992);
              v395 = *(a1 + 1000);
              v396 = *(a1 + 1008);
              v55.f32[0] = -v128;
              v398 = *v389;
              v397 = *(*(a1 + 1168) + 8);
              v400 = *v388;
              v399 = v388[1];
              do
              {
                v401 = 0;
                v402 = *(v809 + 8 * v392);
                v403 = **(v394 + 8 * v392);
                v404 = *v402;
                v405 = v402[1];
                v406 = *(v395 + 8 * v392);
                v407 = **(v396 + 8 * v392);
                v408 = *(v391 + 8 * v392);
                v409 = *(v390 + 8 * v392);
                v410 = 3;
                v411 = 1;
                v412 = *v406;
                v413 = v406[1];
                v414 = v400;
                v415 = v398;
                v416 = v399;
                v417 = v397;
                do
                {
                  v418 = 0;
                  v419 = v411;
                  *a10.i32 = (*(v412 + 4 * v401) + (v55.f32[0] * *(v412 + 4 * v401))) + (v128 * *(v404 + 4 * v401));
                  *a11.i32 = -((*(v407 + 4 * v401) + (v55.f32[0] * *(v407 + 4 * v401))) + (v128 * *(v403 + 4 * v401)));
                  *a12.i32 = (*(v413 + 4 * v401) + (v55.f32[0] * *(v413 + 4 * v401))) + (v128 * *(v405 + 4 * v401));
                  v420 = v814[v401];
                  do
                  {
                    v421 = *(v414 + v418);
                    v422 = *(v415 + v418);
                    a15.i32[0] = *(v416 + v418);
                    a16.i32[0] = *(v417 + v418);
                    v423 = (v421 * *a10.i32) - (v422 * *a11.i32);
                    v424 = (*a10.i32 * v422) + (v421 * *a11.i32);
                    a14.f32[0] = v423 + (a15.f32[0] * *a12.i32);
                    *(v409 + v418) = a14.i32[0];
                    *(v408 + v418) = v424 + (a16.f32[0] * *a12.i32);
                    *&a13 = -*a11.i32;
                    if (v410 > 0)
                    {
                      *a11.i32 = -*a11.i32;
                    }

                    v410 -= v410 > 0;
                    v418 += 4;
                    --v420;
                  }

                  while (v420);
                  v411 = 0;
                  v414 += v418;
                  v415 += v418;
                  v416 += v418;
                  v417 += v418;
                  v409 += v418;
                  v408 += v418;
                  v401 = 1;
                }

                while ((v419 & 1) != 0);
                if (v393 >= 2)
                {
                  v425 = 2;
                  do
                  {
                    v426 = 0;
                    *a10.i32 = (*(v412 + 4 * v425) + (v55.f32[0] * *(v412 + 4 * v425))) + (v128 * *(v404 + 4 * v425));
                    *a11.i32 = (*(v407 + 4 * v425) + (v55.f32[0] * *(v407 + 4 * v425))) + (v128 * *(v403 + 4 * v425));
                    *a12.i32 = (*(v413 + 4 * v425) + (v55.f32[0] * *(v413 + 4 * v425))) + (v128 * *(v405 + 4 * v425));
                    v427 = v814[v425];
                    do
                    {
                      v428 = *(v414 + v426);
                      v429 = *(v415 + v426);
                      a16.i32[0] = *(v417 + v426);
                      v430 = (v428 * *a10.i32) - (v429 * *a11.i32);
                      a14.f32[0] = *a10.i32 * v429;
                      a15.f32[0] = v430 + (*(v416 + v426) * *a12.i32);
                      *(v409 + v426) = a15.i32[0];
                      *&a13 = (a14.f32[0] + (v428 * *a11.i32)) + (a16.f32[0] * *a12.i32);
                      *(v408 + v426) = LODWORD(a13);
                      v426 += 4;
                      --v427;
                    }

                    while (v427);
                    v414 += v426;
                    v415 += v426;
                    v416 += v426;
                    v417 += v426;
                    v409 += v426;
                    v408 += v426;
                    v126 = v425++ == v393;
                  }

                  while (!v126);
                }

                ++v392;
              }

              while (v392 != v813);
              v387 = a7;
              v271 = v807;
              goto LABEL_389;
            }
          }

          else
          {
            v431 = *(a1 + 88);
            v387 = a7;
            if (v431 >= 1)
            {
              v432 = 0;
              v433 = *(*(a1 + 216) + *(a1 + 212) - 1);
              v434 = *(a1 + 984);
              v435 = *(a1 + 1000);
              v436 = *v388;
              v437 = v388[1];
              v438 = *v389;
              v439 = v389[1];
              v55.f32[0] = -v128;
              do
              {
                if ((v433 & 0x80000000) == 0)
                {
                  v440 = 0;
                  v441 = *(v434 + 8 * v432);
                  v442 = *v441;
                  v443 = v441[1];
                  v444 = *(v435 + 8 * v432);
                  v445 = *(v391 + 8 * v432);
                  v446 = *(v390 + 8 * v432);
                  v447 = *v444;
                  v448 = v444[1];
                  v449 = v436;
                  v450 = v439;
                  v451 = v438;
                  v452 = v437;
                  do
                  {
                    v453 = 0;
                    *a10.i32 = (*(v447 + 4 * v440) + (v55.f32[0] * *(v447 + 4 * v440))) + (v128 * *(v442 + 4 * v440));
                    *a11.i32 = (*(v448 + 4 * v440) + (v55.f32[0] * *(v448 + 4 * v440))) + (v128 * *(v443 + 4 * v440));
                    v454 = v814[v440];
                    do
                    {
                      a14.i32[0] = *(v451 + v453);
                      LODWORD(a13) = *(v450 + v453);
                      *(v446 + v453) = (*a10.i32 * *(v449 + v453)) + (*(v452 + v453) * *a11.i32);
                      *a12.i32 = (*a10.i32 * a14.f32[0]) + (*&a13 * *a11.i32);
                      *(v445 + v453) = a12.i32[0];
                      v453 += 4;
                      --v454;
                    }

                    while (v454);
                    v446 += v453;
                    v445 += v453;
                    v449 += v453;
                    v450 += v453;
                    v451 += v453;
                    v452 += v453;
                    v126 = v440++ == v433;
                  }

                  while (!v126);
                }

                ++v432;
              }

              while (v432 != v431);
              goto LABEL_389;
            }
          }
        }

        else
        {
          v812 = *(a1 + 1160);
          v274 = *(a1 + 1168);
          v275 = *(a1 + 1176);
          v276 = *(a1 + 1184);
          v788 = *(a1 + 1200);
          v789 = *(a1 + 1192);
          memset(__b, 255, 0x21CuLL);
          v277 = *(a1 + 212);
          v806 = *(a1 + 384);
          v793 = v276;
          bzero(*v276, (4 * *(a1 + 24) * *(a1 + 52)));
          v794 = v275;
          bzero(*v275, (4 * *(a1 + 24) * *(a1 + 32)));
          if (v272)
          {
            bzero(*v789, (4 * *(a1 + 24) * *(a1 + 32)));
            bzero(*v788, (4 * *(a1 + 24) * *(a1 + 52)));
          }

          if (*(a1 + 96) >= 1)
          {
            v278 = 0;
            v800 = v272;
            do
            {
              v279 = v794[v278];
              v280 = v793[v278];
              v803 = v280;
              v804 = v279;
              if (v272)
              {
                v803 = v788[v278];
                v804 = v789[v278];
              }

              if (*(a1 + 148) < 1)
              {
                v281 = 0;
              }

              else
              {
                v281 = 0;
                do
                {
                  v282 = *(a1 + 1320);
                  if (!v282 || *(v282 + v281 + 2 * v278))
                  {
                    v283 = *(v812 + 8 * v281);
                    v284 = *(v274 + 8 * v281);
                    M2ParamToKernelMult(__b, *(*(*(a1 + 984) + 8 * v278) + 8 * v281), *(*(*(a1 + 1000) + 8 * v278) + 8 * v281), v814, v128, *(a1 + 384), *a10.i64, a11);
                    if (*(a1 + 512) == 3)
                    {
                      if (v277 >= 1)
                      {
                        v285 = __b;
                        v286 = v283;
                        v287 = v279;
                        v288 = v284;
                        v289 = v280;
                        v290 = v277;
                        do
                        {
                          v291 = *v286++;
                          v292 = v291;
                          v293 = v285->n128_f32[0];
                          v285 = (v285 + 4);
                          *a10.i32 = v293;
                          *v287 = *v287 + (v292 * v293);
                          ++v287;
                          v294 = *v288++;
                          a11.i32[0] = *v289;
                          *v289 = *v289 + (v294 * *a10.i32);
                          ++v289;
                          --v290;
                        }

                        while (v290);
                      }

                      M2ParamToKernelMult(__b, *(*(*(a1 + 992) + 8 * v278) + 8 * v281), *(*(*(a1 + 1008) + 8 * v278) + 8 * v281), v814, v128, v806, *a10.i64, a11);
                      a10.i32[0] = __b[0].n128_u32[0];
                      *v279 = *v279 + (*v284 * __b[0].n128_f32[0]);
                      *v280 = *v280 - (*v283 * *a10.i32);
                      a11.i32[0] = __b[0].n128_i32[2];
                      a12.i32[0] = __b[0].n128_i32[1];
                      v279[2] = v279[2] + (v284[2] * __b[0].n128_f32[2]);
                      *(v280 + 2) = *(v280 + 2) - (v283[2] * *a11.i32);
                      v279[1] = v279[1] - (v284[1] * *a12.i32);
                      a10.i32[0] = *(v280 + 1);
                      v55.f32[0] = *a10.i32 + (v283[1] * *a12.i32);
                      *(v280 + 1) = v55.i32[0];
                      if (v277 >= 4)
                      {
                        v295 = v283 + 3;
                        v296 = v284 + 3;
                        v297 = &__b[0].n128_f32[3];
                        v298 = v279 + 3;
                        v300 = v277 - 3;
                        v299 = (v280 + 12);
                        do
                        {
                          v301 = *v296++;
                          v302 = v301;
                          v303 = *v297++;
                          *a10.i32 = v303;
                          *v298 = *v298 - (v302 * v303);
                          ++v298;
                          v304 = *v295++;
                          a11.i32[0] = *v299;
                          v55.f32[0] = *v299 + (v304 * *a10.i32);
                          *v299++ = v55.i32[0];
                          --v300;
                        }

                        while (v300);
                      }
                    }

                    else if (v277 >= 1)
                    {
                      v305 = __b;
                      v306 = v279;
                      v307 = v280;
                      v308 = v277;
                      do
                      {
                        v309 = *v283++;
                        v310 = v309;
                        v311 = v305->n128_f32[0];
                        v305 = (v305 + 4);
                        *a10.i32 = v311;
                        *v306++ = v310 * v311;
                        v312 = *v284++;
                        v55.f32[0] = *a10.i32 * v312;
                        *v307++ = *a10.i32 * v312;
                        --v308;
                      }

                      while (v308);
                    }
                  }

                  ++v281;
                }

                while (v281 < *(a1 + 148));
                v281 = v281;
              }

              for (; *(a1 + 160) > v281; ++v281)
              {
                v313 = *(a1 + 1320);
                if (!v313 || *(v313 + v281 + 2 * v278))
                {
                  v314 = *(*(a1 + 232) + 4 * *(v802 + row2residual[2 * *(a1 + 80) + v281]));
                  v315 = *(v812 + 8 * v281);
                  v316 = *(v274 + 8 * v281);
                  M2ParamToKernelMult(__b, *(*(*(a1 + 984) + 8 * v278) + 8 * v281), *(*(*(a1 + 1000) + 8 * v278) + 8 * v281), v814, v128, *(a1 + 384), *a10.i64, a11);
                  if (*(a1 + 512) == 3)
                  {
                    if (v314 < 1)
                    {
                      v327 = 0;
                    }

                    else
                    {
                      v317 = __b;
                      v318 = v315;
                      v319 = v279;
                      v320 = v316;
                      v321 = v280;
                      v322 = v314;
                      do
                      {
                        v323 = *v318++;
                        v324 = v323;
                        v325 = v317->n128_f32[0];
                        v317 = (v317 + 4);
                        *a10.i32 = v325;
                        *v319 = *v319 + (v324 * v325);
                        ++v319;
                        v326 = *v320++;
                        a11.i32[0] = *v321;
                        *v321 = *v321 + (v326 * *a10.i32);
                        ++v321;
                        --v322;
                      }

                      while (v322);
                      v327 = v314;
                    }

                    if (v327 < v277)
                    {
                      v338 = v277 - v327;
                      v339 = &v803[v327];
                      v340 = &v316[v327];
                      v341 = &v804[v327];
                      v342 = __b + v327;
                      v343 = (v315 + 4 * v327);
                      do
                      {
                        v344 = *v343++;
                        v345 = v344;
                        v346 = *v342++;
                        *a10.i32 = v346;
                        *v341 = *v341 + (v345 * v346);
                        ++v341;
                        v347 = *v340++;
                        a11.i32[0] = *v339;
                        *v339 = *v339 + (v347 * *a10.i32);
                        ++v339;
                        --v338;
                      }

                      while (v338);
                    }

                    M2ParamToKernelMult(__b, *(*(*(a1 + 992) + 8 * v278) + 8 * v281), *(*(*(a1 + 1008) + 8 * v278) + 8 * v281), v814, v128, v806, *a10.i64, a11);
                    if (v800)
                    {
                      v348 = v804;
                      if (v314)
                      {
                        v349 = v279;
                      }

                      else
                      {
                        v349 = v804;
                      }

                      if (v314)
                      {
                        v350 = v280;
                      }

                      else
                      {
                        v350 = v803;
                      }

                      v351 = __b[0].n128_f32[0];
                      *v349 = *v349 + (*v316 * __b[0].n128_f32[0]);
                      *v350 = *v350 - (*v315 * v351);
                      if (v314 == 1)
                      {
                        v349 = v804;
                        v350 = v803;
                      }

                      v352 = __b[0].n128_f32[1];
                      v349[1] = v349[1] - (v316[1] * __b[0].n128_f32[1]);
                      v350[1] = v350[1] + (*(v315 + 4) * v352);
                      if (v314 == 2)
                      {
                        v353 = v803;
                      }

                      else
                      {
                        v348 = v349;
                        v353 = v350;
                      }

                      v354 = __b[0].n128_f32[2];
                      v348[2] = v348[2] + (v316[2] * __b[0].n128_f32[2]);
                    }

                    else
                    {
                      v355 = __b[0].n128_f32[0];
                      *v279 = *v279 + (*v316 * __b[0].n128_f32[0]);
                      *v280 = *v280 - (*v315 * v355);
                      v356 = __b[0].n128_f32[1];
                      v279[1] = v279[1] - (v316[1] * __b[0].n128_f32[1]);
                      *(v280 + 1) = *(v280 + 1) + (*(v315 + 4) * v356);
                      v354 = __b[0].n128_f32[2];
                      v279[2] = v279[2] + (v316[2] * __b[0].n128_f32[2]);
                      v353 = v280;
                    }

                    a10.i32[0] = *(v315 + 8);
                    a11.i32[0] = v353[2];
                    v55.f32[0] = *a11.i32 - (*a10.i32 * v354);
                    v353[2] = v55.f32[0];
                    if (v314 < 4)
                    {
                      v314 = 3;
                    }

                    else
                    {
                      v357 = v314 - 3;
                      v358 = (v315 + 12);
                      v359 = v316 + 3;
                      v360 = &__b[0].n128_f32[3];
                      v361 = v279 + 3;
                      v362 = (v280 + 12);
                      do
                      {
                        v363 = *v359++;
                        v364 = v363;
                        v365 = *v360++;
                        *a10.i32 = v365;
                        *v361 = *v361 - (v364 * v365);
                        ++v361;
                        v366 = *v358++;
                        a11.i32[0] = *v362;
                        v55.f32[0] = *v362 + (v366 * *a10.i32);
                        *v362++ = v55.i32[0];
                        --v357;
                      }

                      while (v357);
                    }

                    if (v314 < v277)
                    {
                      v367 = v277 - v314;
                      v368 = &v803[v314];
                      v369 = (v315 + 4 * v314);
                      v370 = &v804[v314];
                      v371 = __b + v314;
                      v372 = &v316[v314];
                      do
                      {
                        v373 = *v372++;
                        v374 = v373;
                        v375 = *v371++;
                        *a10.i32 = v375;
                        *v370 = *v370 - (v374 * v375);
                        ++v370;
                        v376 = *v369++;
                        a11.i32[0] = *v368;
                        v55.f32[0] = *v368 + (v376 * *a10.i32);
                        *v368++ = v55.i32[0];
                        --v367;
                      }

                      while (v367);
                    }
                  }

                  else
                  {
                    if (v314 < 1)
                    {
                      v314 = 0;
                    }

                    else
                    {
                      v328 = __b;
                      v329 = v315;
                      v330 = v279;
                      v331 = v316;
                      v332 = v280;
                      v333 = v314;
                      do
                      {
                        v334 = *v329++;
                        v335 = v334;
                        v336 = v328->n128_f32[0];
                        v328 = (v328 + 4);
                        *a10.i32 = v336;
                        *v330 = *v330 + (v335 * v336);
                        ++v330;
                        v337 = *v331++;
                        a11.i32[0] = *v332;
                        v55.f32[0] = *v332 + (v337 * *a10.i32);
                        *v332++ = v55.i32[0];
                        --v333;
                      }

                      while (v333);
                    }

                    if (v314 < v277)
                    {
                      v377 = v277 - v314;
                      v378 = &v803[v314];
                      v379 = &v316[v314];
                      v380 = &v804[v314];
                      v381 = __b + v314;
                      v382 = (v315 + 4 * v314);
                      do
                      {
                        v383 = *v382++;
                        v384 = v383;
                        v385 = *v381++;
                        *a10.i32 = v385;
                        *v380 = *v380 + (v384 * v385);
                        ++v380;
                        v386 = *v379++;
                        a11.i32[0] = *v378;
                        v55.f32[0] = *v378 + (v386 * *a10.i32);
                        *v378++ = v55.i32[0];
                        --v377;
                      }

                      while (v377);
                    }
                  }
                }
              }

              ++v278;
              v272 = v800;
            }

            while (v278 < *(a1 + 96));
          }

          v271 = *(a1 + 128);
          v387 = a7;
LABEL_389:
          if (v271 == 2)
          {
            __b[0].n128_u64[0] = 0;
            *&v834 = 0;
            v455 = *(a1 + 212);
            if (*(a1 + 84) >= 2)
            {
              v456 = 2;
            }

            else
            {
              v456 = *(a1 + 84);
            }

            extractBBEnv(a1, 1, v456, &v834, a2);
            extractBBEnv(a1, 0, *(a1 + 88), __b, a2);
            v457 = *(a1 + 88);
            if (v457 >= 1)
            {
              v458 = 0;
              a10.i32[0] = DWORD1(v834);
              v55.f32[0] = *&v834 + *(&v834 + 1);
              v459 = &row2channelGES[2 * *(a1 + 80)];
              do
              {
                v460 = v459[v458];
                if (v460 != -1 && *(a2 + 2880 + v460))
                {
                  v461 = *(a2 + 2882 + (v460 << 6) + v795);
                  if (v461 >= 5)
                  {
                    v764 = __cxa_allocate_exception(0x10uLL);
                    *v764 = "void SpatialDecReshapeBBEnv(spatialDec *, const SPATIAL_BS_FRAME *, INT)";
                    v764[2] = 268;
                  }

                  v462 = *(a1 + 140);
                  if (v462 >= 2)
                  {
                    v763 = __cxa_allocate_exception(0x10uLL);
                    *v763 = "void SpatialDecReshapeBBEnv(spatialDec *, const SPATIAL_BS_FRAME *, INT)";
                    v763[2] = 269;
                  }

                  v463 = *(a1 + 1304 + v458);
                  v464 = v55.f32[0];
                  if (v463 != 2)
                  {
                    v464 = *(&v834 + v463);
                  }

                  v465 = (*(*(a1 + 1176) + 8 * v458) + 24);
                  v466 = (*(*(a1 + 1184) + 8 * v458) + 24);
                  a12.i64[0] = 0;
                  if (v455 >= 7)
                  {
                    v467 = (*(*(a1 + 1192) + 8 * v458) + 24);
                    v468 = (*(*(a1 + 1200) + 8 * v458) + 24);
                    v469 = 0.0;
                    v470 = (*(*(a1 + 1176) + 8 * v458) + 24);
                    v471 = (*(*(a1 + 1184) + 8 * v458) + 24);
                    v472 = (v455 - 6);
                    a13 = 0.0;
                    do
                    {
                      v473 = *v470++;
                      v474 = v473;
                      v475 = *v471++;
                      *&a13 = *&a13 + ((v475 * v475) + (v474 * v474));
                      v476 = *v467++;
                      v477 = v476;
                      v478 = *v468++;
                      a15.f32[0] = v478 * v478;
                      v469 = v469 + ((v478 * v478) + (v477 * v477));
                      --v472;
                    }

                    while (v472);
                    *a12.i64 = (v469 / (*&a13 + 0.000000001));
                  }

                  LODWORD(a13) = envShapeDataTable__CDK[2 * v461 + v462];
                  a14.i32[0] = __b[0].n128_i32[v458];
                  v479 = (*&a13 * v464) / (a14.f32[0] + 0.000000001);
                  *a11.i64 = sqrt(*a12.i64);
                  *a11.i32 = *a11.i64;
                  *a12.i32 = v479 + v57;
                  *a10.i32 = v479 + (*a11.i32 * (v479 + v57));
                  if (*a10.i32 < v58)
                  {
                    *a10.i32 = v58;
                  }

                  a11.i32[0] = 4.0;
                  if (*a10.i32 > 4.0)
                  {
                    *a10.i32 = 4.0;
                  }

                  if (v455 >= 7)
                  {
                    v480 = (v455 - 6);
                    do
                    {
                      *v465 = *a10.i32 * *v465;
                      ++v465;
                      *a11.i32 = *a10.i32 * *v466;
                      *v466++ = *a11.i32;
                      --v480;
                    }

                    while (v480);
                  }
                }

                ++v458;
              }

              while (v458 != v457);
            }

            v271 = *(a1 + 128);
          }

          if (v271 == 1)
          {
            v481 = *(a1 + 88);
            if (v481 >= 1)
            {
              v482 = 0;
              v483 = *(a1 + 204);
              do
              {
                if (v483 >= 1)
                {
                  v484 = *(*(a1 + 1192) + 8 * v482);
                  v485 = *(*(a1 + 1176) + 8 * v482);
                  v486 = *(*(a1 + 1200) + 8 * v482);
                  v487 = *(*(a1 + 1184) + 8 * v482);
                  v488 = v483;
                  do
                  {
                    v489 = *v484++;
                    *v485 = v489 + *v485;
                    ++v485;
                    v490 = *v486++;
                    *v487 = v490 + *v487;
                    ++v487;
                    --v488;
                  }

                  while (v488);
                }

                ++v482;
              }

              while (v482 != v481);
            }

            __b[0].n128_u64[1] = 0xAAAAAAAAAAAAAAAALL;
            __b[0].n128_u64[0] = 0xAAAAAAAAAAAAAAAALL;
            *(&v834 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *&v834 = 0xAAAAAAAAAAAAAAAALL;
            v819[0] = 0xAAAAAAAAAAAAAAAALL;
            v819[1] = 0xAAAAAAAAAAAAAAAALL;
            v818[0] = 0xAAAAAAAAAAAAAAAALL;
            v818[1] = 0xAAAAAAAAAAAAAAAALL;
            *&v817[0] = -1;
            v842[0] = -1;
            v491 = *(a1 + 1312);
            v492 = *(a1 + 212);
            if (v481 >= 1)
            {
              v493 = *(a1 + 1176);
              v494 = *(a1 + 1192);
              v495 = v818;
              v496 = &v834;
              v497 = *(a1 + 1184);
              v498 = v819;
              v499 = __b;
              v500 = v481;
              v501 = *(a1 + 1200);
              do
              {
                v502 = *v493++;
                v499->n128_u64[0] = v502 + 28;
                v499 = (v499 + 8);
                v503 = *v494++;
                *v498++ = v503 + 28;
                v504 = *v497++;
                *v496 = v504 + 28;
                v496 = (v496 + 8);
                v505 = *v501++;
                *v495++ = v505 + 28;
                --v500;
              }

              while (v500);
            }

            v506 = *(v491 + 48);
            if (v506 == 32)
            {
              *(v491 + 48) = 1;
              v507 = *(a1 + 84);
              v508 = v491;
              if (v507 >= 1)
              {
                do
                {
                  v508[3] = *v508;
                  ++v508;
                  --v507;
                }

                while (v507);
              }

              if (v481 >= 1)
              {
                v509 = (v491 + 16);
                v510 = v481;
                do
                {
                  *v509 = *(v509 - 3);
                  ++v509;
                  --v510;
                }

                while (v510);
              }
            }

            else
            {
              *(v491 + 48) = v506 + 1;
            }

            if (*(a1 + 80) != 7)
            {
              result = 4294966318;
              goto LABEL_642;
            }

            v525 = 0;
            v526 = *(v491 + 40);
            v527 = 0;
            do
            {
              v528 = *(__b[0].n128_u64[0] + 24 + v525) + *(__b[0].n128_u64[1] + 24 + v525);
              a12.i32[0] = *(*(&v834 + 1) + 24 + v525);
              *a10.i32 = ((*(v834 + 24 + v525) + *a12.i32) * (*(v834 + 24 + v525) + *a12.i32)) + (v528 * v528);
              a11.i32[0] = *(v526 + v525);
              *v527.i32 = *v527.i32 + (*a10.i32 * *a11.i32);
              v525 += 4;
            }

            while (v525 != 76);
            v529 = *(a1 + 84);
            if (v529 < 1)
            {
              v527 = 0;
            }

            else
            {
              for (k = 0; k != v529; ++k)
              {
                v531 = k;
                a12.i32[0] = 1064514355;
                *(v491 + 4 * k) = (*v527.i32 * 0.05) + (*(v491 + 4 * k) * 0.95);
              }

              a11.i32[0] = 814313567;
              *a10.i32 = *(v491 + 4 * v531 + 12) + 0.000000001;
              *v527.i32 = *v527.i32 / *a10.i32;
            }

            if (v481 < 1)
            {
              v55.i64[0] = v777;
              *&v817[0] = v777;
            }

            else
            {
              for (m = 0; m != v481; ++m)
              {
                v533 = 0;
                v534 = 0.0;
                do
                {
                  v534 = v534 + (((*(v819[m] + 24 + v533) * *(v819[m] + 24 + v533)) + (*(v818[m] + 24 + v533) * *(v818[m] + 24 + v533))) * *(v526 + v533));
                  v533 += 4;
                }

                while (v533 != 76);
                LODWORD(a13) = 1064514355;
                *(v491 + 4 + 4 * m) = (v534 * 0.05) + (*(v491 + 4 + 4 * m) * 0.95);
                a12.i32[0] = 814313567;
                v842[0].f32[m] = v534 / (*(v491 + 16 + 4 * m) + 0.000000001);
              }

              *a11.i8 = vdup_n_s32(0x3089705Fu);
              *a10.i8 = vadd_f32(v842[0], *a11.i8);
              *v55.f32 = vsqrt_f32(vdiv_f32(vdup_lane_s32(v527, 0), *a10.i8));
              *&v817[0] = v55.i64[0];
              v535 = (v491 + 24);
              v536 = v817;
              v537 = v481;
              do
              {
                *a10.i32 = *v535 * 0.55;
                a11.i32[0] = 1055286886;
                v55.f32[0] = *a10.i32 + (fminf(fmaxf((*v536 * 0.9) + 0.1, 0.35461), 2.82) * 0.45);
                *v536++ = v55.f32[0];
                *v535++ = v55.f32[0];
                --v537;
              }

              while (v537);
              for (n = 0; n != v481; ++n)
              {
                if (*(a2 + 3010 + row2channelSTP[n + 14]))
                {
                  v55.i32[0] = *(v817 + n);
                  v539 = *(a1 + 204);
                  v540 = *(*(a1 + 1176) + 8 * n);
                  v541 = *(*(a1 + 1184) + 8 * n);
                  v542 = *(*(a1 + 1192) + 8 * n);
                  v543 = *(*(a1 + 1200) + 8 * n);
                  if (v539 < 15)
                  {
                    v544 = (v543 + 4 * v539);
                    v545 = (v542 + 4 * v539);
                    v546 = (v541 + 4 * v539);
                    v547 = *(v491 + 32);
                    v548 = 16 - v539;
                    v549 = (v540 + 4 * v539);
                    do
                    {
                      v550 = *v547++;
                      v551 = v55.f32[0] * v550;
                      v552 = *v545++;
                      *v549 = *v549 + (v552 * v551);
                      ++v549;
                      v553 = *v544++;
                      *a11.i32 = v553;
                      a12.i32[0] = *v546;
                      *a10.i32 = *v546 + (v553 * v551);
                      *v546++ = a10.i32[0];
                      --v548;
                    }

                    while (v548 > 1);
                  }

                  if (v492 > 15)
                  {
                    v554 = (v543 + 60);
                    v555 = (v542 + 60);
                    v556 = (v541 + 60);
                    v557 = (v540 + 60);
                    v558 = v492 - 14;
                    do
                    {
                      v559 = *v555++;
                      *v557 = *v557 + (v559 * v55.f32[0]);
                      ++v557;
                      v560 = *v554++;
                      a11.i32[0] = *v556;
                      *a10.i32 = *v556 + (v560 * v55.f32[0]);
                      *v556++ = a10.i32[0];
                      --v558;
                    }

                    while (v558 > 1);
                  }
                }

                else
                {
                  v561 = *(a1 + 204);
                  if (v492 - v561 >= 1)
                  {
                    v562 = (*(*(a1 + 1200) + 8 * n) + 4 * v561);
                    v563 = (*(*(a1 + 1192) + 8 * n) + 4 * v561);
                    v564 = (*(*(a1 + 1184) + 8 * n) + 4 * v561);
                    v565 = (*(*(a1 + 1176) + 8 * n) + 4 * v561);
                    v566 = v492 + 1 - v561;
                    do
                    {
                      v567 = *v563++;
                      *v565 = *v565 + v567;
                      ++v565;
                      v568 = *v562++;
                      a10.i32[0] = *v564;
                      v55.f32[0] = *v564 + v568;
                      *v564++ = v55.i32[0];
                      --v566;
                    }

                    while (v566 > 1);
                  }
                }
              }
            }

            goto LABEL_473;
          }
        }

        if ((v271 - 1) <= 1)
        {
          v511 = *(a1 + 88);
          if (v511 >= 1)
          {
            v512 = 0;
            v513 = *(a1 + 1176);
            v514 = *(a1 + 1184);
            v515 = *(a1 + 1192);
            v516 = *(a1 + 1200);
            v517 = *(a1 + 212);
            do
            {
              if (v517 >= 1)
              {
                v518 = *(v513 + 8 * v512);
                v519 = *(v514 + 8 * v512);
                v520 = *(v515 + 8 * v512);
                v521 = v517;
                v522 = *(v516 + 8 * v512);
                do
                {
                  v523 = *v520++;
                  *v518 = v523 + *v518;
                  ++v518;
                  v524 = *v522++;
                  a10.i32[0] = *v519;
                  v55.f32[0] = v524 + *v519;
                  *v519++ = v55.i32[0];
                  --v521;
                }

                while (v521);
              }

              ++v512;
            }

            while (v512 != v511);
          }
        }

        goto LABEL_473;
      }

      v129 = *(a1 + 1056);
      v130 = *(a1 + 1064);
      v131 = *(a1 + 1176);
      v132 = *(a1 + 1184);
      v133 = *(a1 + 80);
      if (v133 == 7)
      {
        v134 = 1;
      }

      else
      {
        v134 = 0xFFFFFFFFLL;
      }

      if (v118 == 2)
      {
        if (v133 != 7)
        {
          v768 = __cxa_allocate_exception(0x10uLL);
          *v768 = "void SpatialDecApplyBypass(spatialDec *, FLOAT **, FLOAT **, FLOAT **, FLOAT **, const int)";
          v768[2] = 969;
        }

        CDKmemcpy(*v131, *v129, (4 * *(a1 + 212)));
        CDKmemcpy(v131[1], v129[1], (4 * *(a1 + 212)));
        CDKmemcpy(*v132, *v130, (4 * *(a1 + 212)));
        v136 = v132 + 1;
        ++v130;
      }

      else
      {
        if (v118 != 1)
        {
          goto LABEL_203;
        }

        if (v133 == 7)
        {
          v135 = 0;
        }

        else
        {
          v135 = -1;
        }

        CDKmemcpy(v131[v135], *v129, (4 * *(a1 + 212)));
        CDKmemcpy(v131[v134], *v129, (4 * *(a1 + 212)));
        CDKmemcpy(v132[v135], *v130, (4 * *(a1 + 212)));
        v136 = &v132[v134];
      }

      CDKmemcpy(*v136, *v130, (4 * *(a1 + 212)));
LABEL_203:
      v155 = *(a1 + 100);
      if (v155 >= 1)
      {
        v156 = 0;
        if (v133 == 7)
        {
          v157 = 0;
        }

        else
        {
          v157 = 0xFFFFFFFFLL;
        }

        do
        {
          if (v157 != v156 && v134 != v156)
          {
            bzero(v131[v156], (4 * *(a1 + 212)));
            bzero(v132[v156], (4 * *(a1 + 212)));
            v155 = *(a1 + 100);
          }

          ++v156;
        }

        while (v156 < v155);
      }

LABEL_473:
      if (*(a1 + 512) == 1)
      {
        v55.i64[0] = -1;
        v55.i64[1] = -1;
        __b[27] = v55;
        __b[26] = v55;
        __b[25] = v55;
        __b[24] = v55;
        __b[23] = v55;
        __b[21] = v55;
        __b[22] = v55;
        __b[19] = v55;
        __b[20] = v55;
        __b[17] = v55;
        __b[18] = v55;
        __b[15] = v55;
        __b[16] = v55;
        __b[13] = v55;
        __b[14] = v55;
        __b[11] = v55;
        __b[12] = v55;
        __b[9] = v55;
        __b[10] = v55;
        __b[7] = v55;
        __b[8] = v55;
        __b[5] = v55;
        __b[6] = v55;
        __b[3] = v55;
        __b[4] = v55;
        __b[1] = v55;
        __b[2] = v55;
        __b[0] = v55;
        v569 = *(a1 + 384);
        if (v569 >= 1)
        {
          v570 = -v128;
          v571 = &__b[0].n128_f32[2];
          v572 = (a1 + 528);
          do
          {
            v573 = v572[56];
            v574 = *v572;
            if ((*v572 - v573) > 3.1416)
            {
              v574 = *v572 + v56;
            }

            if ((v573 - v574) > 3.1416)
            {
              v573 = v573 + v56;
            }

            v575 = (v573 + (v570 * v573)) + (v128 * v574);
            v576 = v572[84];
            v577 = v572[28];
            if ((v577 - v576) > 3.1416)
            {
              v577 = v577 + v56;
            }

            if ((v576 - v577) > 3.1416)
            {
              v576 = v576 + v56;
            }

            v578 = v575 / 3.1416;
            v579 = vcvts_n_s32_f32(v578, 0xAuLL);
            v580 = (v576 + (v570 * v576)) + (v128 * v577);
            if (v579 >= 0)
            {
              LOWORD(v581) = v579;
            }

            else
            {
              v581 = -v579;
            }

            v582 = v581 & 0x3FF;
            if (v582 > 0x200)
            {
              v582 = 1024 - v582;
            }

            v583 = &SineTable512 + 8 * (512 - v582);
            v584 = (&SineTable512 + 8 * v582);
            v585 = v582 > 0x100;
            if (v582 <= 0x100)
            {
              v586 = v584 + 1;
            }

            else
            {
              v586 = (&SineTable512 + 8 * (512 - v582));
            }

            if (v585)
            {
              v587 = (v583 + 4);
            }

            else
            {
              v587 = v584;
            }

            v588 = *v587;
            v589 = v56;
            v590 = *v586;
            v591 = fmodf(v578, 0.00097656) * 3.1416;
            v592 = -v590;
            if ((v579 & 0x400) == 0)
            {
              v592 = v590;
            }

            v593 = -v588;
            if (((v579 + 512) & 0x400) == 0)
            {
              v593 = v588;
            }

            v594 = vcvts_n_s32_f32(v580 / 3.1416, 0xAuLL);
            *(v571 - 2) = v593 - (v591 * v592);
            *(v571 - 1) = v592 + (v591 * v593);
            if (v594 >= 0)
            {
              LOWORD(v595) = v594;
            }

            else
            {
              v595 = -v594;
            }

            v596 = v595 & 0x3FF;
            if (v596 > 0x200)
            {
              v596 = 1024 - v596;
            }

            v597 = &SineTable512 + 8 * (512 - v596);
            v598 = (&SineTable512 + 8 * v596);
            v599 = v596 > 0x100;
            if (v596 <= 0x100)
            {
              v600 = v598 + 1;
            }

            else
            {
              v600 = (&SineTable512 + 8 * (512 - v596));
            }

            if (v599)
            {
              v601 = (v597 + 4);
            }

            else
            {
              v601 = v598;
            }

            v602 = *v601;
            v603 = *v600;
            v55.f32[0] = fmodf(v580 / 3.1416, 0.00097656) * 3.1416;
            *a10.i32 = -v603;
            if ((v594 & 0x400) == 0)
            {
              *a10.i32 = v603;
            }

            v604 = -v602;
            if (((v594 + 512) & 0x400) == 0)
            {
              v604 = v602;
            }

            v56 = v589;
            *v571 = v604 - (v55.f32[0] * *a10.i32);
            v571[1] = *a10.i32 + (v55.f32[0] * v604);
            v571 += 4;
            ++v572;
            --v569;
          }

          while (v569);
        }

        v605 = 0;
        v606 = *(a1 + 216);
        v607 = *(a1 + 1176);
        v608 = *(a1 + 1184);
        v610 = *v607;
        v609 = v607[1];
        v612 = *v608;
        v611 = v608[1];
        do
        {
          v613 = *v606++;
          v614 = *(v610 + v605);
          v615 = *(v612 + v605);
          v616 = &__b[v613];
          v618 = v616->n128_f32[0];
          v617 = v616->n128_f32[1];
          v619 = v615 * v616->n128_f32[0];
          v620 = (4 * v613) | 2;
          v621 = (4 * v613) | 3;
          if (v605 == 4)
          {
            *(v610 + v605) = (v614 * v618) - (v615 * v617);
            *(v612 + v605) = v619 + (v614 * v617);
            v622 = *(v609 + v605);
            v623 = *(v611 + v605);
            a12.i32[0] = __b[0].n128_i32[v620];
            LODWORD(a13) = __b[0].n128_u32[v621];
            v55.f32[0] = (v622 * *a12.i32) - (v623 * *&a13);
            *a11.i32 = v623 * *a12.i32;
            *a10.i32 = *a11.i32 + (v622 * *&a13);
          }

          else
          {
            *(v610 + v605) = (v615 * v617) + (v614 * v618);
            *(v612 + v605) = v619 - (v614 * v617);
            v624 = *(v609 + v605);
            v625 = *(v611 + v605);
            a12.i32[0] = __b[0].n128_i32[v620];
            LODWORD(a13) = __b[0].n128_u32[v621];
            v55.f32[0] = (v625 * *&a13) + (v624 * *a12.i32);
            *a11.i32 = v625 * *a12.i32;
            *a10.i32 = *a11.i32 - (v624 * *&a13);
          }

          *(v609 + v605) = v55.i32[0];
          *(v611 + v605) = a10.i32[0];
          v605 += 4;
        }

        while (v605 != 12);
        v626 = *(a1 + 212);
        v57 = -1.0;
        v58 = 0.25;
        if (v626 != 3)
        {
          v627 = 0;
          v628 = (v610 + v605);
          v629 = (v612 + v605);
          v630 = (v609 + v605);
          v631 = (v611 + v605);
          v632 = v626 - 3;
          do
          {
            v633 = &__b[v606[v627]];
            v634 = v633->n128_f32[1];
            v635 = (*v629 * v633->n128_f32[0]) + (*v628 * v634);
            *v628 = (*v628 * v633->n128_f32[0]) - (*v629 * v634);
            ++v628;
            *v629++ = v635;
            a11.i32[0] = v633->n128_i32[2];
            a12.i32[0] = v633->n128_i32[3];
            *&a13 = (*v630 * *a11.i32) - (*v631 * *a12.i32);
            *a10.i32 = *v631 * *a11.i32;
            v55.f32[0] = *a10.i32 + (*v630 * *a12.i32);
            *v630++ = *&a13;
            *v631++ = v55.f32[0];
            ++v627;
          }

          while (v632 != v627);
        }
      }

      if (v792 == v795)
      {
        SpatialDecBufferMatrices(a1);
        v59 = (v787 + 1);
        v791 = v795;
        v33 = a19;
      }

      else
      {
        v33 = a19;
        v59 = v787;
      }

      v636 = v801;
      if (*(v33 + 32) == 1 && *(v33 + 34) == 4)
      {
        if (*(a1 + 88) >= 1)
        {
          v637 = 0;
          v638 = v780;
          do
          {
            memcpy(*(*(v638 - 1) + 8 * v801), *(*(a1 + 1176) + 8 * v637), 4 * *(a1 + 212));
            v639 = *v638;
            v638 += 2;
            memcpy(*(v639 + 8 * v801), *(*(a1 + 1184) + 8 * v637++), 4 * *(a1 + 212));
          }

          while (v637 < *(a1 + 88));
        }
      }

      else
      {
        SpatialDecSynthesis(a1, v801, *(a1 + 1176), *(a1 + 1184), *(a1 + 1208), a17, a18);
        v33 = a19;
        v636 = v801;
      }

      v53 = v795 + 1;
      v52 = v636 + 1;
      v640 = *(a1 + 172) + a6 / *(a1 + 208) - 1;
      if (v640 >= *(a1 + 168) - 1)
      {
        v640 = *(a1 + 168) - 1;
      }

      if (v795 >= v640)
      {
        LODWORD(v49) = v59;
        v50 = v795 + 1;
        goto LABEL_613;
      }
    }
  }

  LODWORD(v52) = 0;
LABEL_613:
  if (*(v33 + 32) != 1 || *(v33 + 34) != 4)
  {
LABEL_640:
    result = 0;
    *(a1 + 172) = v50;
    *(a1 + 176) = v791;
    *(a1 + 180) = v49;
    goto LABEL_641;
  }

  if (!MPEG_D::USAC::DynRangeCompressor::ProcessQMFDomain(v33, v33, v33, &v815))
  {
    if (v52)
    {
      v733 = 0;
      do
      {
        v734 = *(a1 + 88);
        if (v734 >= 1)
        {
          v735 = v816;
          v736 = &v816[2];
          v737 = (a19 + 8);
          do
          {
            v738 = *v737;
            *v736++ = *(*(v737 - 1) + 8 * v733);
            *v735++ = *(v738 + 8 * v733);
            v737 += 2;
            --v734;
          }

          while (v734);
        }

        SpatialDecSynthesis(a1, v733++, &v816[2], v816, *(a1 + 1208), a17, a18);
      }

      while (v733 != v52);
    }

    goto LABEL_640;
  }

  result = 4294966314;
LABEL_641:
  v387 = a7;
LABEL_642:
  *v387 = v778;
  return result;
}

uint64_t SpatialDecChannelProperties(uint64_t result, _DWORD *a2, _BYTE *a3, uint64_t a4)
{
  if (result && a2 && a3 && a4)
  {
    v4 = *(result + 100);
    v5 = *(result + 80);
    if (v4 == treePropertyTable[9 * v5 + 1])
    {
      if (v5 == 7)
      {
        *a2 = 1;
        *a3 = 0;
        a2[1] = 1;
        a3[1] = 1;
      }
    }

    else if (v4 >= 1)
    {
      v6 = 0;
      do
      {
        a2[v6] = 1;
        a3[v6] = v6;
        ++v6;
      }

      while (v6 < *(result + 100));
    }
  }

  return result;
}

void *SpatialDecBufferMatrices(uint64_t a1)
{
  v2 = *(a1 + 96);
  v3 = *(a1 + 384);
  if (v2 >= 1)
  {
    v4 = 0;
    v5 = (4 * v3);
    LODWORD(v6) = *(a1 + 160);
    do
    {
      if (v6 >= 1)
      {
        v7 = 0;
        do
        {
          CDKmemcpy(*(*(*(a1 + 1000) + 8 * v4) + 8 * v7), *(*(*(a1 + 984) + 8 * v4) + 8 * v7), (4 * *(a1 + 384)));
          if (*(a1 + 512) == 3)
          {
            CDKmemcpy(*(*(*(a1 + 1008) + 8 * v4) + 8 * v7), *(*(*(a1 + 992) + 8 * v4) + 8 * v7), v5);
          }

          ++v7;
          v6 = *(a1 + 160);
        }

        while (v7 < v6);
        v2 = *(a1 + 96);
      }

      ++v4;
    }

    while (v4 < v2);
    v3 = *(a1 + 384);
  }

  CDKmemcpy((a1 + 752), (a1 + 528), (4 * v3));
  v8 = (4 * *(a1 + 384));

  return CDKmemcpy((a1 + 864), (a1 + 640), v8);
}

void *UsacQmf::ProcessAnalysis(UsacQmf *this, unsigned int a2, uint64_t a3, float *a4, float **a5, float **a6)
{
  v8 = a3;
  v10 = *(*this + 8 * a2);
  result = (*(*v10 + 24))(v10, a4, a3, *(this + 22), *(this + 25));
  if (v8)
  {
    v12 = 0;
    v13 = 24 * v8;
    do
    {
      v14 = *a5++;
      memcpy(v14, *(*(this + 7) + v12), *(*(this + 7) + v12 + 8) - *(*(this + 7) + v12));
      v15 = *a6++;
      result = memcpy(v15, *(*(this + 10) + v12), *(*(this + 10) + v12 + 8) - *(*(this + 10) + v12));
      v12 += 24;
    }

    while (v13 != v12);
  }

  return result;
}

float *SpatialDecSynthesis(float *result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, UsacQmf *a7)
{
  v51 = a3;
  v57 = *MEMORY[0x1E69E9840];
  *&a3 = result[25];
  if (a3 >= 1)
  {
    v7 = result;
    v8 = 0;
    v9 = *(*(result + 152) + 66);
    *&v10 = -1;
    *(&v10 + 1) = -1;
    v56[14] = v10;
    v56[15] = v10;
    v47 = a5 + 4 * a3 * a2 * v9;
    v56[12] = v10;
    v56[13] = v10;
    v56[10] = v10;
    v56[11] = v10;
    v56[8] = v10;
    v56[9] = v10;
    v56[6] = v10;
    v56[7] = v10;
    v56[4] = v10;
    v56[5] = v10;
    v56[2] = v10;
    v56[3] = v10;
    v56[0] = v10;
    v56[1] = v10;
    v55[0] = v10;
    v55[1] = v10;
    v55[2] = v10;
    v55[3] = v10;
    v55[4] = v10;
    v55[5] = v10;
    v55[6] = v10;
    v55[7] = v10;
    v55[8] = v10;
    v55[9] = v10;
    v55[10] = v10;
    v55[11] = v10;
    v45 = (2 * a2) | 1;
    v46 = 2 * a2;
    v55[12] = v10;
    v55[13] = v10;
    v55[14] = v10;
    v55[15] = v10;
    do
    {
      v11 = *(v7 + 154) + 16 * v8;
      v12 = *(v51 + 8 * v8);
      v13 = *(a4 + 8 * v8);
      v14 = *(v11 + 8);
      v15 = *v14;
      if (*v14)
      {
        v16 = 0;
        LODWORD(v17) = 0;
        v18 = v14 + 1;
        do
        {
          v19 = v18[v16];
          if (v18[v16])
          {
            v20 = (v13 + 4 * v17);
            v21 = 0.0;
            v22 = v18[v16];
            v23 = 0.0;
            v24 = (v12 + 4 * v17);
            do
            {
              v25 = *v24++;
              v23 = v23 + v25;
              v26 = *v20++;
              v21 = v21 + v26;
              --v22;
            }

            while (v22);
          }

          else
          {
            v23 = 0.0;
            v21 = 0.0;
          }

          *(v56 + v16) = v23;
          *(v55 + v16) = v21;
          v17 = (v17 + v19);
          ++v16;
        }

        while (v16 != v15);
      }

      else
      {
        v17 = 0;
      }

      if (*v11 > v15)
      {
        CDKmemcpy(v56 + 4 * v15, (v12 + 4 * v17), (4 * (*v11 - v15)));
        CDKmemcpy(v55 + 4 * v15, (v13 + 4 * v17), (4 * (*(v11 + 4) - v15)));
        *&a3 = v7[25];
      }

      if (a3 >= 7)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "SACDEC_ERROR SpatialDecSynthesis(spatialDec *, const INT, FLOAT **, FLOAT **, FLOAT *, const INT, const CDK_channelMapDescr *const, UsacQmf &)";
        exception[2] = 795;
      }

      MapValue = CDK_chMapDescr_getMapValue(a6, mapChannel(spatialDec_struct *,unsigned int)::chanelIdx[v8], a3);
      if (*(v7 + 504) == 3)
      {
        v28 = MapValue;
        v29 = *(v7 + 152) + (MapValue << 7);
        v30 = *(v29 + 161);
        if (!*(v29 + 161))
        {
          v42 = __cxa_allocate_exception(0x10uLL);
          *v42 = "void CDK_QmfDomain_GetWorkBuffer(const HANDLE_CDK_QMF_DOMAIN_IN, const int, FLOAT **, FLOAT **)";
          v42[2] = 530;
        }

        if (*(v29 + 160) <= a2)
        {
          v44 = __cxa_allocate_exception(0x10uLL);
          *v44 = "void CDK_QmfDomain_GetWorkBuffer(const HANDLE_CDK_QMF_DOMAIN_IN, const int, FLOAT **, FLOAT **)";
          v44[2] = 531;
        }

        v31 = *(v29 + 184);
        v32 = *(v29 + 162);
        v33 = *(v29 + 164);
        WorkBuffer = CDK_getWorkBuffer(v31, (v32 + v46 * v30), v33, v30);
        result = CDK_getWorkBuffer(v31, (v32 + v45 * v30), v33, v30);
        v35 = *(v7 + 52);
        if (v35 > *(*(v7 + 152) + (v28 << 7) + 161))
        {
          v43 = __cxa_allocate_exception(0x10uLL);
          *v43 = "SACDEC_ERROR SpatialDecSynthesis(spatialDec *, const INT, FLOAT **, FLOAT **, FLOAT *, const INT, const CDK_channelMapDescr *const, UsacQmf &)";
          v43[2] = 805;
        }

        if (v35 >= 1)
        {
          v36 = v55;
          v37 = v56;
          do
          {
            v38 = *v37++;
            *WorkBuffer++ = v38 * 32768.0;
            v39 = *v36++;
            *result++ = v39 * 32768.0;
            --v35;
          }

          while (v35);
        }
      }

      else
      {
        v53 = v55;
        v54 = v56;
        v40 = *(v7 + 152) + 80 * MapValue;
        result = UsacQmf::ProcessSynthesis(a7, MapValue, *(v40 + 388), *(v40 + 396) * 0.5, (v47 + 4 * MapValue), &v54, &v53);
      }

      ++v8;
      a3 = *(v7 + 25);
    }

    while (v8 < a3);
  }

  return result;
}

uint64_t MPEG_D::USAC::DynRangeCompressor::ProcessQMFDomain(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (!*(a1 + 64))
  {
    return 0;
  }

  result = MPEG_D::USAC::DynRangeCompressor::AdjustForHostInput(a1);
  if (!result)
  {
    if (mpddrc::UniDrc::ProcessQmfDomain(*(a1 + 64) + 8, a2, *(a1 + 48), a3, *(a1 + 52), a4))
    {
      result = 0;
      *(a1 + 32) = 0;
      *(a1 + 34) = 0;
      v10 = *(a1 + 64);
      *(v10 + 2448) = 0;
      *(v10 + 2452) = 0;
      *(v10 + 2460) = 0;
      *(v10 + 2472) = 0;
    }

    else
    {
      v11 = *(a1 + 40);
      v12 = *(a1 + 64);
      v13 = *(v12 + 2456);
      if (*(v11 + 96) != v13 && !*(v11 + 100))
      {
        *(v11 + 96) = v13;
        *(v11 + 101) = 1;
      }

      v14 = (a1 + 72);
      if (*(a1 + 72) || *(v11 + 103))
      {
        if (*(v11 + 102) && !*(v11 + 103) && *(v12 + 2144 * *(v12 + 2464) + 3385) == 1)
        {
          Limiter::Initialize(v14, *(a1 + 60), v9);
        }
      }

      else if (*(v12 + 2144 * *(v12 + 2464) + 3385) == 1)
      {
        Limiter::Initialize(v14, *(a1 + 60), v9);
      }

      return 0;
    }
  }

  return result;
}

uint64_t mpddrc::UniDrc::ProcessQmfDomain(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned int a5, _DWORD *a6)
{
  v91 = *MEMORY[0x1E69E9840];
  v12 = mpddrc::NumAudioCodecSubbands(*(a1 + 2428));
  v13 = *(a1 + 44);
  v14 = *(a1 + 352);
  if (*(a1 + 360) != v14)
  {
    v15 = *(a1 + 92);
    if ((v15 & 0x80000000) == 0 && *(v14 + 168 * v15 + 12) == 1)
    {
      v13 = *(v14 + 168 * v15 + 16);
    }
  }

  if (v13 == 4096)
  {
    v16 = 64;
  }

  else
  {
    v16 = 32;
  }

  if (*(a1 + 2444) == 1)
  {
    if (a5)
    {
      v17 = 0;
      do
      {
        v18 = 0;
        v19 = (a4 + 16 * v17);
        do
        {
          bzero(*(*v19 + 8 * v18), 4 * v12);
          bzero(*(v19[1] + 8 * v18++), 4 * v12);
        }

        while (v16 != v18);
        ++v17;
      }

      while (v17 != a5);
    }

    return 0;
  }

  result = mpddrc::UniDrc::UpdateConfig(a1);
  if (!result)
  {
    v21 = *(a1 + 2452);
    if (v21 == 3)
    {
      if ((*(a1 + 2464) & 1) == 0)
      {
        v77 = 0;
        v78 = a1 + 8;
        v81 = a2;
        LODWORD(v82) = a5;
        v86 = a6;
        v76 = 0;
        *(a1 + 2452) = 1;
LABEL_29:
        v79 = &v75;
        v25 = a3;
        v26 = MEMORY[0x1EEE9AC00](result);
        v27 = &v75 - 2 * a3;
        if (a3)
        {
          v28 = 16 * a3;
          v29 = (&v75 - v28);
          do
          {
            *v29 = 0xAAAAAAAAAAAAAAAALL;
            v29[1] = 0xAAAAAAAAAAAAAAAALL;
            v29 += 2;
            v28 -= 16;
          }

          while (v28);
          v30 = 5;
          if (v13 == 4096)
          {
            v30 = 6;
          }

          v85 = v30;
          v31 = a3 << v30;
          MEMORY[0x1EEE9AC00](v26);
          v32 = (8 * v31 + 15) & 0xFFFFFFFFFFFFFFF0;
          v84 = &v75 - v32;
          v33 = memset(&v75 - v32, 170, 8 * v31);
          MEMORY[0x1EEE9AC00](v33);
          v83 = &v75 - v32;
          v26 = memset(&v75 - v32, 170, 8 * v31);
        }

        else
        {
          v31 = 0;
          if (v13 == 4096)
          {
            v34 = 6;
          }

          else
          {
            v34 = 5;
          }

          v83 = &v90;
          v84 = &v90;
          v85 = v34;
        }

        v87 = a3;
        LODWORD(v80) = v12;
        v35 = v12;
        v36 = 4 * v31 * v12;
        v37 = (v36 + 15) & 0xFFFFFFFFFFFFFFF0;
        MEMORY[0x1EEE9AC00](v26);
        v38 = &v75 - v37;
        if (v39)
        {
          v40 = memset(&v75 - v37, 255, v36);
          MEMORY[0x1EEE9AC00](v40);
          v41 = &v75 - v37;
          memset(&v75 - v37, 255, v36);
        }

        else
        {
          v41 = &v90;
        }

        v43 = v84;
        v42 = v85;
        v44 = v83;
        if (v87)
        {
          v45 = 0;
          v46 = 4 * (v35 << v85);
          v47 = 4 * v35;
          do
          {
            v48 = v38;
            v49 = v41;
            v50 = &v43[8 * (v45 << v42)];
            v51 = &v44[8 * (v45 << v42)];
            v52 = v16;
            do
            {
              *v50 = v48;
              v50 += 8;
              *v51 = v49;
              v51 += 8;
              v49 += v47;
              v48 += v47;
              --v52;
            }

            while (v52);
            v53 = &v27[2 * v45];
            *v53 = &v43[8 * (v45 << v42)];
            v53[1] = &v44[8 * (v45++ << v42)];
            v41 += v46;
            v38 += v46;
          }

          while (v45 != v25);
          v54 = v87;
        }

        else
        {
          v54 = 0;
        }

        v55 = a1 + 2472 + 2144 * *(a1 + 2456);
        v56 = v80;
        v74 = *(a1 + 2428);
        v75 = a1 + 1688;
        v57 = v78;
        v58 = v81;
        v59 = v27;
        v60 = v82;
        v61 = v86;
        result = mpddrc::UniDrcProcessor::ProcessQmfDomain(v55, a1 + 2408, SHIDWORD(v77), v81, v54, v59, v82, v86, v78, a1 + 1688, v74, v80);
        if (result)
        {
          return result;
        }

        result = mpddrc::UniDrcProcessor::ProcessQmfDomain(a1 + 2472 + 2144 * *(a1 + 2460), a1 + 2408, v76, v58, v87, a4, v60, v61, v57, v75, *(a1 + 2428), v56);
        if (!((result != 0) | v77 & 1))
        {
          v82 = a4;
          MEMORY[0x1EEE9AC00](result);
          v63 = (&v75 - v62);
          memset(&v75 - v62, 255, v64);
          LODWORD(v81) = v16 - 1;
          __B = 1.0 / (v16 - 1);
          __A = 0.0;
          vDSP_vramp(&__A, &__B, v63, 1, v16);
          if (*v61)
          {
            v65 = 0;
            v80 = -v16;
            v86 = v61;
            do
            {
              v66 = 0;
              v67 = &v84[8 * (v65 << v85)];
              v68 = &v83[8 * (v65 << v85)];
              v69 = v63;
              v70 = v81;
              v71 = v80;
              v87 = v65;
              v72 = (v82 + 16 * v65);
              do
              {
                MEMORY[0x19EAE6090](*&v67[v66], 1, v69, *&v67[v66], 1, v35);
                MEMORY[0x19EAE6090](*&v68[v66], 1, v69, *&v68[v66], 1, v35);
                MEMORY[0x19EAE6050](*(*v72 + v66), 1, &v63[v70], *&v67[v66], 1, *(*v72 + v66), 1, v35);
                MEMORY[0x19EAE6050](*(v72[1] + v66), 1, &v63[v70], *&v68[v66], 1, *(v72[1] + v66), 1, v35);
                v66 += 8;
                --v70;
                ++v69;
              }

              while (!__CFADD__(v71++, 1));
              v65 = (v87 + 1);
            }

            while (v87 + 1 < *v86);
          }

          return 0;
        }

        if (result)
        {
          return result;
        }

        return 0;
      }

      *(a1 + 2464) = 0;
      *(a1 + 2452) = 1;
      v24 = 2;
    }

    else
    {
      if (v21 == 2)
      {
        v78 = a1 + 8;
        v81 = a2;
        LODWORD(v82) = a5;
        v86 = a6;
        v22 = *(a1 + 2464);
        if (*(a1 + 2464))
        {
          v23 = 4;
        }

        else
        {
          v23 = 8;
        }

        *(a1 + 2452) = 3;
        v76 = v22;
        LODWORD(v77) = v22 ^ 1;
        HIDWORD(v77) = v23;
        goto LABEL_29;
      }

      v24 = 0;
    }

    result = mpddrc::UniDrcProcessor::ProcessQmfDomain(a1 + 2144 * *(a1 + 2456) + 2472, a1 + 2408, v24, a2, a3, a4, a5, a6, a1 + 8, a1 + 1688, *(a1 + 2428), v12);
    if (result)
    {
      return result;
    }

    return 0;
  }

  return result;
}

uint64_t mpddrc::UniDrcProcessor::ProcessQmfDomain(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t *a5, uint64_t a6, unsigned int a7, _DWORD *a8, uint64_t a9, uint64_t a10, unsigned int a11, unsigned int a12)
{
  v17 = a1;
  v126 = *MEMORY[0x1E69E9840];
  v18 = *(a9 + 36);
  v19 = *(a9 + 344);
  v20 = *(a9 + 352);
  v122 = a7;
  v124 = a4;
  if (v20 != v19)
  {
    v21 = *(a9 + 84);
    if ((v21 & 0x80000000) == 0 && *(v19 + 168 * v21 + 12) == 1)
    {
      v18 = *(v19 + 168 * v21 + 16);
    }
  }

  if (v18 == 4096)
  {
    v22 = 64;
  }

  else
  {
    v22 = 32;
  }

  result = mpddrc::UniDrcProcessor::PrepareDrcGains(a1, a2, a9, a10, a11, a3);
  if (result)
  {
    return result;
  }

  v119 = a9;
  v24 = a12;
  if (*(v17 + 644) == 1)
  {
    v25 = *(v17 + 158);
    v26 = *(v17 + 159);
    *a8 = v26;
    result = 0xFFFFFFFFLL;
    if (v26 > 8 || v26 > v25)
    {
      return result;
    }

    v121 = v26;
    v115 = a3;
    v116 = a2;
    v117 = a11;
    v118 = v17;
    v111 = a6;
    v112 = a8;
    v114 = &v110;
    v27 = v18 == 4096 ? 6 : 5;
    v28 = (a5 << v27);
    v29 = MEMORY[0x1EEE9AC00](0xFFFFFFFFLL);
    v32 = &v110 - v31;
    v33 = 4 * v30;
    v123 = v34;
    v120 = a5;
    if (v30)
    {
      v35 = memset(&v110 - v31, 255, 4 * v30);
      MEMORY[0x1EEE9AC00](v35);
      v36 = &v110 - ((v33 + 15) & 0x7FFFFFFF0);
      v37 = memset(v36, 255, v33);
      MEMORY[0x1EEE9AC00](v37);
      v38 = v36;
      v39 = memset(v36, 255, v33);
      MEMORY[0x1EEE9AC00](v39);
      v40 = v36;
      v41 = memset(v36, 255, v33);
    }

    else
    {
      v42 = MEMORY[0x1EEE9AC00](v29);
      v36 = &v110 - ((v33 + 15) & 0x7FFFFFFF0);
      v43 = MEMORY[0x1EEE9AC00](v42);
      v38 = &v110 - v44;
      v41 = MEMORY[0x1EEE9AC00](v43);
      v40 = &v110 - v45;
    }

    v46 = MEMORY[0x1EEE9AC00](v41);
    v48 = &v110 - v47;
    v49 = 8 * v28;
    if (v28)
    {
      v50 = 8 * v28;
      v51 = memset(&v110 - v47, 170, v49);
      MEMORY[0x1EEE9AC00](v51);
      v113 = (v50 + 15) & 0xFFFFFFFF0;
      v52 = &v110 - v113;
      v53 = memset(&v110 - v113, 170, v50);
      MEMORY[0x1EEE9AC00](v53);
      v54 = &v110 - v113;
      v55 = memset(&v110 - v113, 170, v50);
      MEMORY[0x1EEE9AC00](v55);
      v56 = &v110 - v113;
      v58 = memset(&v110 - v113, 170, v57);
    }

    else
    {
      v59 = MEMORY[0x1EEE9AC00](v46);
      v52 = &v110 - ((v60 + 15) & 0xFFFFFFFF0);
      v61 = MEMORY[0x1EEE9AC00](v59);
      v54 = &v110 - v62;
      v58 = MEMORY[0x1EEE9AC00](v61);
      v56 = &v110 - v63;
    }

    v64 = MEMORY[0x1EEE9AC00](v58);
    if (v66)
    {
      v67 = 16 * v65;
      v68 = &v110 - 2 * v65;
      do
      {
        *v68 = 0xAAAAAAAAAAAAAAAALL;
        v68[1] = 0xAAAAAAAAAAAAAAAALL;
        v68 += 2;
        v67 -= 16;
      }

      while (v67);
      MEMORY[0x1EEE9AC00](v64);
      v72 = &v110 - 2 * v71;
      v73 = 0;
      do
      {
        v74 = &v72[v73 / 8];
        *v74 = 0xAAAAAAAAAAAAAAAALL;
        v74[1] = 0xAAAAAAAAAAAAAAAALL;
        v73 += 16;
      }

      while (v70 != v73);
      v75 = 0;
      v76 = 0;
      v77 = 0;
      do
      {
        v78 = v77;
        v79 = v22;
        do
        {
          *&v48[8 * v78] = &v32[4 * v76];
          v80 = &v36[4 * v76];
          v81 = &v38[4 * v76];
          v82 = &v40[4 * v76];
          v76 += v24;
          *&v52[8 * v78] = v80;
          *&v54[8 * v78] = v81;
          *&v56[8 * v78++] = v82;
          --v79;
        }

        while (v79);
        v83 = (v69 + 16 * v75);
        *v83 = &v48[8 * v77];
        v83[1] = &v52[8 * v77];
        v84 = &v72[2 * v75];
        *v84 = &v54[8 * v77];
        v84[1] = &v56[8 * v77];
        v77 += v22;
        ++v75;
      }

      while (v75 != v71);
      v85 = v120;
      v86 = &v110 - 2 * v71;
    }

    else
    {
      MEMORY[0x1EEE9AC00](v64);
      v86 = &v110 - 2 * v87;
      v85 = 0;
    }

    v88 = v69;
    result = mpddrc::UniDrcProcessor::ApplyDrcGainsQmfDomain(v118, v116, v119, v117, v115 & 1, v124, v69, v85, 1u);
    v89 = v123;
    if (result)
    {
      return result;
    }

    v124 = v88;
    if (!v121)
    {
      goto LABEL_63;
    }

    v90 = 0;
    v91 = v118 + 162;
    v120 = v86;
    while (1)
    {
      v92 = 0;
      v93 = 0;
      v94 = &v86[2 * v90];
      v95 = v124;
      do
      {
        v96 = v91[8 * v92 + v90];
        v125 = v96;
        if (v96 == 0.0)
        {
          goto LABEL_58;
        }

        v97 = (v95 + 16 * v92);
        if (v96 == 1.0)
        {
          if ((v93 & 1) == 0)
          {
            for (i = 0; i != v22; ++i)
            {
              memcpy(*(*v94 + 8 * i), *(*v97 + 8 * i), 4 * v24);
              memcpy(*(v94[1] + 8 * i), *(v97[1] + 8 * i), 4 * v24);
            }

            v93 = 1;
            goto LABEL_57;
          }

          for (j = 0; j != v22; ++j)
          {
            v93 = 1;
            MEMORY[0x19EAE5DC0](*(*v97 + 8 * j), 1, *(*v94 + 8 * j), 1, *(*v94 + 8 * j), 1, v24);
            v99 = *(v94[1] + 8 * j);
            MEMORY[0x19EAE5DC0](*(v97[1] + 8 * j), 1, v99, 1, v99, 1, v24);
          }
        }

        else
        {
          if (v93)
          {
            for (k = 0; k != v22; ++k)
            {
              MEMORY[0x19EAE6050](*(*v97 + 8 * k), 1, &v125, *(*v94 + 8 * k), 1, *(*v94 + 8 * k), 1, v24);
              v101 = *(v94[1] + 8 * k);
              MEMORY[0x19EAE6050](*(v97[1] + 8 * k), 1, &v125, v101, 1, v101, 1, v24);
            }
          }

          else
          {
            for (m = 0; m != v22; ++m)
            {
              MEMORY[0x19EAE6090](*(*v97 + 8 * m), 1, &v125, *(*v94 + 8 * m), 1, v24);
              MEMORY[0x19EAE6090](*(v97[1] + 8 * m), 1, &v125, *(v94[1] + 8 * m), 1, v24);
            }
          }

          v93 = 1;
        }

        v89 = v123;
LABEL_57:
        v95 = v124;
LABEL_58:
        ++v92;
      }

      while (v92 != v89);
      if ((v93 & 1) == 0)
      {
        for (n = 0; n != v22; ++n)
        {
          bzero(*(*v94 + 8 * n), 4 * v24);
          bzero(*(v94[1] + 8 * n), 4 * v24);
        }
      }

      ++v90;
      v86 = v120;
      if (v90 == v121)
      {
LABEL_63:
        v17 = v118;
        a6 = v111;
        result = mpddrc::UniDrcProcessor::ApplyDrcGainsQmfDomain(v118, v116, v119, v117, v115 & 1, v86, v111, v122, 0);
        a8 = v112;
        if (!result)
        {
          goto LABEL_64;
        }

        return result;
      }
    }
  }

  *a8 = a5;
  result = mpddrc::UniDrcProcessor::ApplyDrcGainsQmfDomain(v17, a2, v119, a11, a3 & 1, v124, a6, a5, 1u);
  if (!result)
  {
    result = mpddrc::UniDrcProcessor::ApplyDrcGainsQmfDomain(v17, a2, v119, a11, a3 & 1, a6, a6, a5, 0);
    if (!result)
    {
LABEL_64:
      if (v17[505])
      {
        return 0;
      }

      if (v17[504] == 1.0 || *a8 == 0)
      {
        return 0;
      }

      else
      {
        v106 = 0;
        do
        {
          v107 = 0;
          v108 = (a6 + 16 * v106);
          do
          {
            MEMORY[0x19EAE6090](*(*v108 + 8 * v107), 1, v17 + 504, *(*v108 + 8 * v107), 1, v24);
            v109 = *(v108[1] + 8 * v107);
            MEMORY[0x19EAE6090](v109, 1, v17 + 504, v109, 1, v24);
            ++v107;
          }

          while (v22 != v107);
          result = 0;
          ++v106;
        }

        while (v106 < *a8);
      }
    }
  }

  return result;
}

uint64_t CDK_chMapDescr_getMapValue(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!a1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "UCHAR CDK_chMapDescr_getMapValue(const CDK_channelMapDescr *const, const UCHAR, const UINT)";
    exception[2] = 79;
  }

  if (!*(a1 + 12))
  {
    if (*a1)
    {
      if (*(a1 + 8) > a3)
      {
        v4 = *a1 + 16 * a3;
        if (*(v4 + 8) > a2)
        {
          return *(*v4 + a2);
        }
      }
    }
  }

  return a2;
}

uint64_t UsacQmf::ProcessSynthesis(UsacQmf *this, unsigned int a2, unsigned int a3, float a4, float *a5, float **a6, float **a7)
{
  v9 = *(this + 13);
  if (*(this + 14) != v9)
  {
    v12 = 0;
    v13 = a3;
    v14 = 4 * a3;
    v15 = 4 * (((v9[1] - *v9) >> 2) - a3);
    v16 = 1;
    do
    {
      memcpy(v9[3 * v12], a6[v12], v14);
      memcpy(*(*(this + 16) + 24 * v12), a7[v12], v14);
      bzero((*(*(this + 13) + 24 * v12) + 4 * v13), v15);
      bzero((*(*(this + 16) + 24 * v12) + 4 * v13), v15);
      v12 = v16;
      v9 = *(this + 13);
    }

    while (0xAAAAAAAAAAAAAAABLL * ((*(this + 14) - v9) >> 3) > v16++);
  }

  v18 = *(*(this + 3) + 8 * a2);
  (*(*v18 + 24))(v18, *(this + 28), *(this + 31), *(this + 12), *(this + 19), a7);
  v22 = a4;
  return MEMORY[0x19EAE6090](*(this + 19), 1, &v22, a5, *(this + 13), -1431655765 * ((*(this + 14) - *(this + 13)) >> 3) * ((*(*(this + 13) + 8) - **(this + 13)) >> 2));
}

float *CDK_getWorkBuffer(float **a1, unsigned int a2, unsigned int a3, int a4)
{
  if ((a3 & 0x3F) != 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "FLOAT *CDK_getWorkBuffer(FLOAT **, USHORT, USHORT, USHORT)";
    v7 = 315;
    goto LABEL_10;
  }

  if (a2 / a3 >= 5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "FLOAT *CDK_getWorkBuffer(FLOAT **, USHORT, USHORT, USHORT)";
    v7 = 322;
    goto LABEL_10;
  }

  v4 = a1[a2 / a3];
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "FLOAT *CDK_getWorkBuffer(FLOAT **, USHORT, USHORT, USHORT)";
    v7 = 325;
    goto LABEL_10;
  }

  if ((a2 % a3) + a4 > a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "FLOAT *CDK_getWorkBuffer(FLOAT **, USHORT, USHORT, USHORT)";
    v7 = 328;
LABEL_10:
    exception[2] = v7;
  }

  return &v4[(a2 % a3)];
}

uint64_t extractBBEnv(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  v51 = *MEMORY[0x1E69E9840];
  v5 = *(result + 212);
  if (v5 >= 42)
  {
    v6 = 42;
  }

  else
  {
    v6 = *(result + 212);
  }

  if (a3 >= 1)
  {
    v7 = 0;
    v8 = *(result + 1296);
    v9 = *(v8 + 40);
    v10 = *(v8 + 44);
    v11 = 1.0 - v9;
    *&v12 = -1;
    *(&v12 + 1) = -1;
    v49 = v12;
    v50 = v12;
    v47 = v12;
    v48 = v12;
    v45 = v12;
    v46 = v12;
    v43[10] = v12;
    v44 = v12;
    v43[8] = v12;
    v43[9] = v12;
    v43[6] = v12;
    v43[7] = v12;
    v43[4] = v12;
    v43[5] = v12;
    v43[2] = v12;
    v43[3] = v12;
    v43[0] = v12;
    v43[1] = v12;
    v42[8] = v12;
    v42[9] = v12;
    v42[6] = v12;
    v42[7] = v12;
    v13 = a5 + 2880;
    v42[4] = v12;
    v42[5] = v12;
    v14 = v8 + 20;
    v42[2] = v12;
    v42[3] = v12;
    v15 = 1;
    v42[0] = v12;
    v42[1] = v12;
    while (!a2)
    {
      v19 = row2channelGES[2 * *(result + 80) + v7];
      if (v19 != -1)
      {
        v15 = *(v13 + v19) != 0;
        if (v5 < 13)
        {
          v17 = v42;
        }

        else
        {
          v20 = 0;
          v21 = *(*(result + 1200) + 8 * v7) + 48;
          v22 = *(*(result + 1184) + 8 * v7) + 48;
          v23 = *(*(result + 1192) + 8 * v7) + 48;
          v24 = *(*(result + 1176) + 8 * v7) + 48;
          do
          {
            v17 = v42;
            v25 = (v42 + v20);
            v25[12] = *(v24 + v20) + *(v23 + v20);
            v25[54] = *(v22 + v20) + *(v21 + v20);
            v20 += 4;
          }

          while (4 * v6 - 48 != v20);
        }

        v18 = v43 + 2;
        v16 = v7;
LABEL_15:
        *&v44 = (v18[12] * v18[12]) + (v17[12] * v17[12]);
        *(&v44 + 1) = (v18[13] * v18[13]) + (v17[13] * v17[13]);
        *(&v44 + 2) = (v18[14] * v18[14]) + (v17[14] * v17[14]);
        *(&v44 + 3) = (v18[15] * v18[15]) + (v17[15] * v17[15]);
        *&v45 = ((v18[16] * v18[16]) + (v17[16] * v17[16])) + ((v18[17] * v18[17]) + (v17[17] * v17[17]));
        *(&v45 + 1) = (((v18[18] * v18[18]) + (v17[18] * v17[18])) + ((v18[19] * v18[19]) + (v17[19] * v17[19]))) + ((v18[20] * v18[20]) + (v17[20] * v17[20]));
        *(&v45 + 2) = ((((v18[21] * v18[21]) + (v17[21] * v17[21])) + ((v18[22] * v18[22]) + (v17[22] * v17[22]))) + ((v18[23] * v18[23]) + (v17[23] * v17[23]))) + ((v18[24] * v18[24]) + (v17[24] * v17[24]));
        *(&v45 + 3) = (((((v18[25] * v18[25]) + (v17[25] * v17[25])) + ((v18[26] * v18[26]) + (v17[26] * v17[26]))) + ((v18[27] * v18[27]) + (v17[27] * v17[27]))) + ((v18[28] * v18[28]) + (v17[28] * v17[28]))) + ((v18[29] * v18[29]) + (v17[29] * v17[29]));
        v26 = (v18[30] * v18[30]) + (v17[30] * v17[30]);
        if (v5 >= 32)
        {
          v27 = v18 + 31;
          v28 = v17 + 31;
          v29 = v6 - 31;
          do
          {
            v30 = *v27++;
            v31 = v30;
            v32 = *v28++;
            v26 = v26 + ((v31 * v31) + (v32 * v32));
            --v29;
          }

          while (v29);
        }

        v33 = 0;
        v34 = v16;
        v35 = v8 + 48 + 36 * v16;
        *&v46 = v26;
        v36 = 0.0;
        do
        {
          *(v35 + v33) = (v9 * *(v35 + v33)) + (v11 * *(&v44 + v33));
          v36 = v36 + *(&v44 + v33);
          v33 += 4;
        }

        while (v33 != 36);
        v37 = 0;
        v38 = (v9 * *(v14 + 4 * v34)) + (v11 * (v36 / 9.0));
        *(v14 + 4 * v34) = v38;
        v39 = 0.0;
        do
        {
          v39 = v39 + (*(&v44 + v37) / (*(v35 + v37) + 0.000000001));
          v37 += 4;
        }

        while (v37 != 36);
        v40 = v38 * v39;
        v41 = (v10 * *(v8 + 4 * v34)) + ((1.0 - v10) * v40);
        *(v8 + 4 * v34) = v41;
        if (v15)
        {
          v40 = sqrtf(v40 / (v41 + 0.000000001));
        }

        *(a4 + 4 * v7) = v40;
      }

      if (++v7 == a3)
      {
        return result;
      }
    }

    v16 = *(result + 88) + v7;
    v17 = *(*(result + 1056) + 8 * v7);
    v18 = *(*(result + 1064) + 8 * v7);
    goto LABEL_15;
  }

  return result;
}

__n128 *M2ParamToKernelMult(__n128 *result, float *a2, float *a3, int *a4, float a5, int a6, double a7, __n128 a8)
{
  if (a6 >= 1)
  {
    for (i = 0; i != a6; ++i)
    {
      a8.n128_f32[0] = (a3[i] + (-a5 * a3[i])) + (a5 * a2[i]);
      v9 = a4[i];
      if (v9)
      {
        result->n128_u32[0] = a8.n128_u32[0];
        result = (result + 4);
      }

      if ((v9 & 2) != 0)
      {
        result->n128_u32[0] = a8.n128_u32[0];
        result->n128_u32[1] = a8.n128_u32[0];
        result = (result + 8);
      }

      if (v9 >= 4)
      {
        v10 = v9 >> 2;
        a8 = vdupq_lane_s32(a8.n128_u64[0], 0);
        do
        {
          *result++ = a8;
          --v10;
        }

        while (v10);
      }
    }
  }

  return result;
}

void CDKhybridAnalysisApply(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, float32x4_t a9, double a10, double a11, float32x4_t a12, float32x4_t a13)
{
  v14 = a1;
  v152 = *MEMORY[0x1E69E9840];
  v15 = *(a1 + 304);
  v16 = *v15;
  v17 = *(a1 + 256);
  if (v17 + 1 < v15[7])
  {
    v18 = v17 + 1;
  }

  else
  {
    v18 = 0;
  }

  v139 = *v15;
  v140 = v14;
  v136 = v18;
  if (*v15)
  {
    v19 = 0;
    v20 = 0;
    v21 = v14 + 24;
    v22 = (*(v15 + 2) + 4 * v18);
    v137 = a3;
    v138 = a2;
    do
    {
      v23 = *(v14 + 8 * v19);
      *(v23 + 4 * v17) = *(a2 + 4 * v19);
      v24 = *(v21 + 8 * v19);
      *(v24 + 4 * v17) = *(a3 + 4 * v19);
      v25 = v15[v19 + 4];
      HIDWORD(v27) = v25 + 8;
      LODWORD(v27) = v25 + 8;
      v26 = v27 >> 1;
      if (v26 <= 8)
      {
        v28 = (a4 + 4 * v20);
        v29 = 1 << v26;
        v30 = a5 + 4 * v20;
        if ((v29 & 0x28) != 0)
        {
          v103 = (v25 >> 7) & 1;
          v105 = v22[5];
          v104 = v22[6];
          v106 = *(v24 + 4 * v104);
          v107 = *(v23 + 4 * v104);
          v108 = v22[1];
          v109 = v22[11];
          a12.i32[0] = 0.5;
          v110 = v106 * 0.5;
          a13.i32[0] = -1114284786;
          v111 = v22[3];
          v112 = v22[9];
          v113 = v22[7];
          v114 = (((*(v24 + 4 * v109) * 0.018995) + (*(v24 + 4 * v108) * 0.018995)) + ((*(v24 + 4 * v112) * -0.072931) + (*(v24 + 4 * v111) * -0.072931))) + ((*(v24 + 4 * v113) * 0.30597) + (*(v24 + 4 * v105) * 0.30597));
          v115 = v107 * 0.5;
          v116 = (((*(v23 + 4 * v109) * 0.018995) + (*(v23 + 4 * v108) * 0.018995)) + ((*(v23 + 4 * v112) * -0.072931) + (*(v23 + 4 * v111) * -0.072931))) + ((*(v23 + 4 * v113) * 0.30597) + (*(v23 + 4 * v105) * 0.30597));
          v28[v103] = v115 + v116;
          *(v30 + 4 * v103) = v110 + v114;
          v28[(v25 & 0x80) == 0] = v115 - v116;
          *(v30 + 4 * ((v25 & 0x80) == 0)) = v110 - v114;
        }

        else if ((v29 & 0x44) != 0)
        {
          v56 = v22[2];
          v57 = v22[3];
          v58 = *(v23 + 4 * v56);
          v59 = *(v24 + 4 * v56);
          a13.i32[1] = 0x80000000;
          v60 = v22[6];
          v61 = v22[7];
          v62 = *(v23 + 4 * v60);
          v63 = *(v24 + 4 * v60);
          v64 = v22[10];
          v65 = v22[11];
          v66 = *(v23 + 4 * v64);
          v67 = *(v24 + 4 * v64);
          v68 = (((v62 + (v63 * -0.0)) * 0.25) + (((v59 * -0.0) - v58) * 0.0)) + (((v67 * -0.0) - v66) * 0.0);
          v69 = ((v63 + (v62 * 0.0)) * 0.25) + (-(v59 - (v58 * 0.0)) * 0.0);
          v70 = *(v23 + 4 * v57);
          v71 = v69 + (-(v67 - (v66 * 0.0)) * 0.0);
          v72 = *(v24 + 4 * v57) * -0.70711;
          v73 = *(v23 + 4 * v61);
          v74 = *(v24 + 4 * v61) * 0.70711;
          a13.i32[0] = *(v23 + 4 * v65);
          v75 = *(v24 + 4 * v65) * -0.70711;
          v76 = (((v74 + (v73 * 0.70711)) * 0.21228) + ((v72 + (v70 * -0.70711)) * 0.043189)) + ((v75 + (a13.f32[0] * -0.70711)) * -0.0079486);
          v77 = *v22;
          v78 = v22[1];
          v79 = *(v23 + 4 * v77);
          v80 = *(v24 + 4 * v77);
          v81 = v22[4];
          v82 = v22[5];
          v83 = *(v23 + 4 * v81);
          v84 = *(v24 + 4 * v81);
          v85 = v22[8];
          v86 = v22[9];
          v87 = *(v23 + 4 * v85);
          v88 = *(v24 + 4 * v85);
          v89 = v72 + (v70 * 0.70711);
          v90 = v22[12];
          v91 = *(v23 + 4 * v90);
          v92 = *(v24 + 4 * v90);
          v93 = (((v74 + (v73 * -0.70711)) * 0.21228) + (v89 * 0.043189)) + ((v75 + (a13.f32[0] * 0.70711)) * -0.0079486);
          v94 = (((-(v84 - (v83 * 0.0)) * 0.12542) + ((v80 + (v79 * 0.0)) * -0.0030515)) + ((v88 + (v87 * 0.0)) * 0.12542)) + (-(v92 - (v91 * 0.0)) * -0.0030515);
          v95 = *(v23 + 4 * v78);
          v96 = (v80 * 0.0) - v79;
          v97 = *(v23 + 4 * v82);
          v98 = ((((v83 + (v84 * 0.0)) * 0.12542) + (v96 * -0.0030515)) + (((v88 * 0.0) - v87) * 0.12542)) + ((v91 + (v92 * 0.0)) * -0.0030515);
          a13.f32[0] = *(v24 + 4 * v78) * -0.70711;
          v99 = *(v24 + 4 * v82) * 0.70711;
          v100 = *(v23 + 4 * v86);
          v101 = *(v24 + 4 * v86) * -0.70711;
          v102 = ((-(v99 - (v97 * 0.70711)) * 0.21228) + (-(a13.f32[0] - (v95 * -0.70711)) * -0.0079486)) + (-(v101 - (v100 * -0.70711)) * 0.043189);
          a12.f32[0] = (((v99 + (v97 * 0.70711)) * 0.21228) + ((a13.f32[0] + (v95 * -0.70711)) * -0.0079486)) + ((v101 + (v100 * -0.70711)) * 0.043189);
          *v28 = ((v68 + v76) + v94) + v102;
          *v30 = ((v71 + v93) + v98) + a12.f32[0];
          v28[1] = ((v68 + v93) - v94) - a12.f32[0];
          *(v30 + 4) = ((v71 - v76) - v98) + v102;
          v28[2] = ((v68 - v76) + v94) - v102;
          a13.f32[0] = ((v71 - v93) + v98) - a12.f32[0];
          *(v30 + 8) = a13.i32[0];
          v28[3] = ((v68 - v93) - v94) + a12.f32[0];
          *(v30 + 12) = ((v71 + v76) - v98) - v102;
        }

        else if ((v29 & 0x101) != 0)
        {
          v31 = v21;
          v32 = v17;
          v33 = a5;
          v34 = v22[6];
          v35 = v22[7];
          v141 = *(v23 + 4 * v34) * 0.125;
          v142 = *(v24 + 4 * v34) * 0.125;
          v143 = vmla_n_f32(vmul_n_f32(0x3DDF26403D38DCF0, *(v24 + 4 * v35)), 0xBD38DCF03DDF2640, *(v23 + 4 * v35));
          v36 = *v22;
          v37 = v22[1];
          v38 = *(v23 + 4 * v36);
          v39 = *(v24 + 4 * v36) * -0.0052756;
          v40 = v39 + (v38 * -0.0052756);
          v41 = v22[8];
          v42 = v22[9];
          v43 = *(v23 + 4 * v41);
          v44 = v39 + (v38 * 0.0052756);
          v45 = *(v24 + 4 * v41) * 0.069898;
          LODWORD(a11) = -1114691885;
          v144 = v40 + (v45 + (v43 * 0.069898));
          v145 = v44 + (v45 + (v43 * -0.069898));
          v146 = vadd_f32(vmla_n_f32(vmul_n_f32(0xBC0E5A50BCABD5C4, *(v24 + 4 * v37)), 0x3CABD5C4BC0E5A50, *(v23 + 4 * v37)), vmla_n_f32(vmul_n_f32(0x3CE3C9DC3D897B87, *(v24 + 4 * v42)), 0xBD897B873CE3C9DCLL, *(v23 + 4 * v42)));
          v46 = v22[10];
          v47 = v22[11];
          v48 = v22[2];
          v49 = v22[3];
          v147 = (*(v24 + 4 * v48) * -0.045469) + (*(v24 + 4 * v46) * 0.045469);
          v148 = (*(v23 + 4 * v46) * -0.045469) + (*(v23 + 4 * v48) * 0.045469);
          v149 = vadd_f32(vmla_n_f32(vmul_n_f32(0x3CE3C9DCBD897B87, *(v24 + 4 * v49)), 0x3D897B873CE3C9DCLL, *(v23 + 4 * v49)), vmla_n_f32(vmul_n_f32(0xBC0E5A503CABD5C4, *(v24 + 4 * v47)), 0xBCABD5C4BC0E5A50, *(v23 + 4 * v47)));
          v50 = v22[5];
          v51 = vdup_n_s32(0x3D8F26D3u);
          *a9.f32 = vdup_n_s32(0xBBACDEF7);
          v52 = COERCE_DOUBLE(vadd_f32(vmla_n_f32(vmul_n_f32(0x3D8F26D3BD8F26D3, *(v24 + 4 * v22[4])), v51, *(v23 + 4 * v22[4])), vmla_n_f32(vmul_n_f32(0xBBACDEF73BACDEF7, *(v24 + 4 * v22[12])), *a9.f32, *(v23 + 4 * v22[12]))));
          v150 = v52;
          LODWORD(v52) = *(v23 + 4 * v50);
          v151 = COERCE_DOUBLE(vmla_n_f32(vmul_n_f32(0x3DDF2640BD38DCF0, *(v24 + 4 * v50)), 0x3D38DCF03DDF2640, *&v52));
          fft(8, &v141, v52, v151, 8.83312651e-14, a9, *&v51, a11, a12, a13);
          v16 = v139;
          v14 = v140;
          a5 = v33;
          if ((v25 & 0x80000000) != 0)
          {
            v117 = HIDWORD(v151);
            *v28 = *&v151;
            *v30 = v117;
            v118 = v142;
            v28[1] = v141;
            *(v30 + 4) = v118;
            v119 = HIDWORD(v150);
            v28[2] = *&v150;
            *(v30 + 8) = v119;
            v120 = v143.i32[1];
            v28[3] = v143.f32[0];
            *(v30 + 12) = v120;
            v121 = v145;
            v122 = v149.f32[1];
            v28[4] = v144 + v149.f32[0];
            *(v30 + 16) = v121 + v122;
            v123 = v146.f32[1];
            v124 = v148;
            v28[5] = v146.f32[0] + v147;
            *(v30 + 20) = v123 + v124;
            v17 = v32;
            v21 = v31;
          }

          else
          {
            v53 = 0;
            v54 = &v142;
            v17 = v32;
            v21 = v31;
            do
            {
              v55 = *v54;
              v28[v53] = *(v54 - 1);
              *(v30 + v53 * 4) = v55;
              ++v53;
              v54 += 2;
            }

            while (v53 != 8);
          }

          a3 = v137;
          a2 = v138;
        }
      }

      v15 = *(v14 + 304);
      v20 += v15[++v19];
    }

    while (v19 != v16);
  }

  else
  {
    v20 = 0;
  }

  *(v14 + 256) = v136;
  v125 = *(v14 + 264);
  v126 = __OFSUB__(v125, v16);
  v127 = v125 - v16;
  if (!((v127 < 0) ^ v126 | (v127 == 0)))
  {
    if (*(v14 + 272))
    {
      v128 = a5;
      v129 = a3;
      CDKmemcpy((a4 + 4 * v20), (a2 + 4 * v16), (4 * v127));
      CDKmemcpy((v128 + 4 * v20), (v129 + 4 * v139), (4 * (*(v140 + 268) - v139)));
    }

    else
    {
      if (!*(v14 + 300))
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "INT CDKhybridAnalysisApply(HANDLE_CDK_ANA_HYB_FILTER, const FLOAT *const, const FLOAT *const, FLOAT *const, FLOAT *const)";
        exception[2] = 230;
      }

      v130 = a5;
      v131 = a2;
      v132 = a3;
      v133 = v14 + 48;
      CDKmemcpy((a4 + 4 * v20), *(v14 + 48 + 8 * *(v14 + 260)), (4 * v127));
      CDKmemcpy((v130 + 4 * v20), *(v140 + 152 + 8 * *(v140 + 260)), (4 * (*(v140 + 268) - v139)));
      CDKmemcpy(*(v133 + 8 * *(v140 + 260)), (v131 + 4 * v139), (4 * (*(v140 + 264) - v139)));
      CDKmemcpy(*(v140 + 152 + 8 * *(v140 + 260)), (v132 + 4 * v139), (4 * (*(v140 + 268) - v139)));
      if (*(v140 + 260) + 1 < *(*(v140 + 304) + 8))
      {
        v134 = *(v140 + 260) + 1;
      }

      else
      {
        v134 = 0;
      }

      *(v140 + 260) = v134;
    }
  }
}

void fft(int a1, float *a2, double a3, double a4, double a5, float32x4_t a6, double a7, double a8, float32x4_t a9, float32x4_t a10)
{
  v10 = a2;
  v412 = *MEMORY[0x1E69E9840];
  if (a1 > 23)
  {
    if (a1 > 127)
    {
      if (a1 <= 255)
      {
        if (a1 != 128)
        {
          if (a1 != 192)
          {
            goto LABEL_146;
          }

          memset(__b, 170, 0x608uLL);
          v195 = 0;
          v400.i64[0] = 0xAAAAAAAAAAAAAAAALL;
          v196 = -__b & 7;
          v197.i64[0] = 0xAAAAAAAAAAAAAAAALL;
          v197.i64[1] = 0xAAAAAAAAAAAAAAAALL;
          v398 = v197;
          v399 = v197;
          v198 = &__b[v196];
          v396 = v197;
          v397 = v197;
          v394 = v197;
          v395 = v197;
          v199 = v10;
          v200 = &__b[v196];
          do
          {
            v201 = 0;
            v202 = v199;
            do
            {
              v203 = *v202;
              v202 += 24;
              *&v200[v201] = v203;
              v201 += 2;
            }

            while (v201 != 32);
            fft_16(v200);
            v199 += 2;
            v200 += 32;
            ++v195;
          }

          while (v195 != 12);
          v211 = &__b[v196 + 140];
          v212 = &RotVectorReal192;
          v213 = &RotVectorImag192;
          v214 = 16;
          do
          {
            v215 = v211;
            v216 = 15;
            do
            {
              v217 = *(v215 - 1);
              *&v204 = *v215;
              v218 = *v212++;
              LODWORD(v205) = v218;
              v219 = *v213++;
              *&v206 = v219;
              *&v207 = (*v215 * *&v205) - (v217 * v219);
              *(v215 - 1) = (v217 * *&v205) + (*v215 * v219);
              *v215 = *&v207;
              v215 += 2;
              --v216;
            }

            while (v216);
            v211 += 32;
            _CF = v214 >= 0xB0;
            v214 += 16;
          }

          while (!_CF);
          for (i = 0; i != 16; ++i)
          {
            v221 = 0;
            for (j = 0; j != 1536; j += 128)
            {
              v223 = *&v198[j];
              *&v394.i64[v221++] = v223;
            }

            fft12(&v394, v223, v204, v205, v206, v207, v208, v209, v210);
            v224 = 0;
            for (k = 0; k != 384; k += 32)
            {
              *&v10[k] = v394.i64[v224++];
            }

            v198 += 8;
            v10 += 2;
          }

          return;
        }

        v134 = a2;
        v135 = 7;
      }

      else
      {
        switch(a1)
        {
          case 256:
            v134 = a2;
            v135 = 8;
            break;
          case 384:
            memset(__b, 170, sizeof(__b));
            v369 = 0;
            v410 = 0xAAAAAAAAAAAAAAAALL;
            v370 = -__b & 7;
            v371.i64[0] = 0xAAAAAAAAAAAAAAAALL;
            v371.i64[1] = 0xAAAAAAAAAAAAAAAALL;
            v408 = v371;
            v409 = v371;
            v372 = &__b[v370];
            v406 = v371;
            v407 = v371;
            v404 = v371;
            v405 = v371;
            v402 = v371;
            v403 = v371;
            v400 = v371;
            v401 = v371;
            v398 = v371;
            v399 = v371;
            v396 = v371;
            v397 = v371;
            v373 = v10;
            v374 = &__b[v370];
            v394 = v371;
            v395 = v371;
            do
            {
              v375 = 0;
              v376 = v373;
              do
              {
                v377 = *v376;
                v374[v375++] = *v376;
                v376 += 32;
              }

              while (v375 != 12);
              fft12(v374, v377, v362, v363, *v364.i64, v365, v366, *v367.i64, v368);
              v373 += 2;
              v374 += 12;
              ++v369;
            }

            while (v369 != 32);
            v378 = &__b[v370 + 108];
            v379 = &RotVectorReal384;
            v380 = &RotVectorImag384;
            v381 = 12;
            do
            {
              v382 = v378;
              v383 = 11;
              do
              {
                v384 = *(v382 - 1);
                *&v362 = *v382;
                v385 = *v379++;
                LODWORD(v363) = v385;
                v386 = *v380++;
                v364.f32[0] = v386;
                *&v365 = (*v382 * *&v363) - (v384 * v386);
                *(v382 - 1) = (v384 * *&v363) + (*v382 * v386);
                *v382 = *&v365;
                v382 += 2;
                --v383;
              }

              while (v383);
              v378 += 24;
              _CF = v381 >= 0x174;
              v381 += 12;
            }

            while (!_CF);
            for (m = 0; m != 12; ++m)
            {
              v388 = 0;
              for (n = 0; n != 3072; n += 96)
              {
                v390 = *&v372[n];
                *&v394.i64[v388++] = v390;
              }

              fft_32(v394.f32, v390, v362, v363, v364, v365, v366, v367);
              v391 = 0;
              for (ii = 0; ii != 768; ii += 24)
              {
                *&v10[ii] = v394.i64[v391++];
              }

              v372 += 8;
              v10 += 2;
            }

            return;
          case 512:
            v134 = a2;
            v135 = 9;
            break;
          default:
            goto LABEL_146;
        }
      }
    }

    else
    {
      if (a1 <= 47)
      {
        if (a1 == 24)
        {
          v228 = 0;
          *&__b[192] = 0xAAAAAAAAAAAAAAAALL;
          v229.i64[0] = 0xAAAAAAAAAAAAAAAALL;
          v229.i64[1] = 0xAAAAAAAAAAAAAAAALL;
          *&__b[160] = v229;
          *&__b[176] = v229;
          *&__b[128] = v229;
          *&__b[144] = v229;
          *&__b[96] = v229;
          *&__b[112] = v229;
          *&__b[64] = v229;
          *&__b[80] = v229;
          *&__b[32] = v229;
          *&__b[48] = v229;
          *__b = v229;
          *&__b[16] = v229;
          v400.i64[0] = 0xAAAAAAAAAAAAAAAALL;
          v230 = __b;
          v398 = v229;
          v399 = v229;
          v396 = v229;
          v397 = v229;
          v394 = v229;
          v395 = v229;
          do
          {
            v231 = &a2[2 * v228];
            v232.i64[0] = *v231;
            v232.i64[1] = *v231;
            v233.i64[0] = v231[12];
            v233.i64[1] = v233.i64[0];
            *&v234 = vaddq_f32(v232, v233).u64[0];
            *(&v234 + 1) = vsubq_f32(v232, v233).i64[1];
            *&__b[16 * v228++] = v234;
          }

          while (v228 != 12);
          v235 = 0;
          v236 = &__b[28];
          v237 = &RotVectorReal24;
          v238 = &RotVectorImag24;
          do
          {
            v239 = *v237++;
            v240 = v239;
            v241 = *v238++;
            v233.f32[0] = v241;
            LODWORD(v234) = *(v236 - 1);
            a6.i32[0] = *v236;
            *&a7 = (*v236 * v240) - (*&v234 * v241);
            *(v236 - 1) = (*&v234 * v240) + (*v236 * v241);
            *v236 = LODWORD(a7);
            v236 += 4;
            v235 += 2;
          }

          while (v235 < 0x16);
          v242 = 0;
          do
          {
            v243 = 0;
            v244 = 0;
            v245 = v242;
            do
            {
              v246 = *&v230[v244];
              *&v394.i64[v243] = v246;
              v244 += 16;
              ++v243;
            }

            while (v244 != 192);
            fft12(&v394, v246, *v233.i64, *&v234, *a6.i64, a7, a8, *a9.i64, a10);
            v247 = 0;
            for (jj = 0; jj != 48; jj += 4)
            {
              *&v10[jj] = v394.i64[v247++];
            }

            v230 += 8;
            v10 += 2;
            v242 = 1;
          }

          while ((v245 & 1) == 0);
        }

        else
        {
          if (a1 != 32)
          {
            goto LABEL_146;
          }

          fft_32(a2, a3, a4, a5, a6, a7, a8, a9);
        }

        return;
      }

      if (a1 == 48)
      {
        v328 = 0;
        *&__b[384] = 0xAAAAAAAAAAAAAAAALL;
        v329.i64[0] = 0xAAAAAAAAAAAAAAAALL;
        v329.i64[1] = 0xAAAAAAAAAAAAAAAALL;
        *&__b[352] = v329;
        *&__b[368] = v329;
        *&__b[320] = v329;
        *&__b[336] = v329;
        *&__b[288] = v329;
        *&__b[304] = v329;
        *&__b[256] = v329;
        *&__b[272] = v329;
        *&__b[224] = v329;
        *&__b[240] = v329;
        *&__b[192] = v329;
        *&__b[208] = v329;
        *&__b[160] = v329;
        *&__b[176] = v329;
        *&__b[128] = v329;
        *&__b[144] = v329;
        *&__b[96] = v329;
        *&__b[112] = v329;
        *&__b[64] = v329;
        *&__b[80] = v329;
        *&__b[32] = v329;
        *&__b[48] = v329;
        *__b = v329;
        *&__b[16] = v329;
        v330 = __b;
        v398 = v329;
        v399 = v329;
        v396 = v329;
        v397 = v329;
        v394 = v329;
        v395 = v329;
        v331 = a2;
        v400.i64[0] = 0xAAAAAAAAAAAAAAAALL;
        v332 = __b;
        do
        {
          v333 = 0;
          v334 = v331;
          do
          {
            v335 = *v334;
            v334 += 24;
            HIDWORD(v336) = HIDWORD(v335);
            *&v332[v333] = v335;
            v333 += 2;
          }

          while (v333 != 8);
          v337 = v332[4];
          v338 = v332[5];
          v339 = *v332 + v337;
          a10.f32[0] = v332[6];
          v340 = v332[7];
          v341 = v332[2] + a10.f32[0];
          v342 = v332[1] + v338;
          a9.f32[0] = v332[3] + v340;
          *v332 = v339 + v341;
          v332[1] = v342 + a9.f32[0];
          v343 = v339 - (v337 * 2.0);
          v344 = v342 - (v338 * 2.0);
          v332[4] = v339 - v341;
          v332[5] = v342 - a9.f32[0];
          v345 = v341 - (a10.f32[0] * 2.0);
          v346 = a9.f32[0] - (v340 * 2.0);
          *&a8 = v343 + v346;
          v332[2] = v343 + v346;
          v332[3] = v344 - v345;
          v332[6] = v343 - v346;
          v332[7] = v345 + v344;
          v331 += 2;
          v332 += 8;
          ++v328;
        }

        while (v328 != 12);
        v347 = &__b[44];
        v348 = &RotVectorReal48;
        v349 = &RotVectorImag48;
        v350 = 4;
        do
        {
          v351 = v347;
          v352 = 3;
          do
          {
            v353 = *(v351 - 1);
            *&v336 = *v351;
            v354 = *v348++;
            LODWORD(a5) = v354;
            v355 = *v349++;
            a6.f32[0] = v355;
            *&a7 = (*v351 * *&a5) - (v353 * v355);
            *(v351 - 1) = (v353 * *&a5) + (*v351 * v355);
            *v351 = *&a7;
            v351 += 2;
            --v352;
          }

          while (v352);
          v347 += 8;
          _CF = v350 >= 0x2C;
          v350 += 4;
        }

        while (!_CF);
        for (kk = 0; kk != 4; ++kk)
        {
          v357 = 0;
          for (mm = 0; mm != 384; mm += 32)
          {
            v359 = *&v330[mm];
            *&v394.i64[v357++] = v359;
          }

          fft12(&v394, v359, v336, a5, *a6.i64, a7, a8, *a9.i64, a10);
          v360 = 0;
          for (nn = 0; nn != 96; nn += 8)
          {
            *&v10[nn] = v394.i64[v360++];
          }

          v330 += 8;
          v10 += 2;
        }

        return;
      }

      if (a1 != 64)
      {
        if (a1 != 96)
        {
          goto LABEL_146;
        }

        memset(__b, 170, 0x308uLL);
        v40 = 0;
        v410 = 0xAAAAAAAAAAAAAAAALL;
        v41 = -__b & 7;
        v42 = &__b[v41];
        v43.i64[0] = 0xAAAAAAAAAAAAAAAALL;
        v43.i64[1] = 0xAAAAAAAAAAAAAAAALL;
        v408 = v43;
        v409 = v43;
        v406 = v43;
        v407 = v43;
        v404 = v43;
        v405 = v43;
        v402 = v43;
        v403 = v43;
        v400 = v43;
        v401 = v43;
        v398 = v43;
        v399 = v43;
        v396 = v43;
        v397 = v43;
        v394 = v43;
        v395 = v43;
        v44.i64[0] = 0xBF000000BF000000;
        v44.i64[1] = 0xBF000000BF000000;
        v45 = vdup_n_s32(0xBF5DB3D7);
        v46 = &__b[v41];
        do
        {
          v47.i64[0] = *&v10[v40];
          v48 = *&v10[v40 + 64];
          v49 = *&v10[v40 + 128];
          *v50.f32 = vadd_f32(v48, v49);
          v51 = vmul_f32(vsub_f32(v48, v49), v45);
          v52 = COERCE_DOUBLE(vadd_f32(*v47.f32, *v50.f32));
          *v53.f32 = vrev64_s32(v51);
          v50.i64[1] = v50.i64[0];
          v47.i64[1] = v47.i64[0];
          v53.i64[1] = v53.i64[0];
          v54 = vmlaq_f32(v47, v44, v50);
          v55 = vsubq_f32(v54, v53);
          v56 = vaddq_f32(v54, v53);
          v56.i32[0] = v55.i32[0];
          *v46 = v52;
          v56.i32[3] = v55.i32[3];
          *(v46 + 8) = v56;
          v46 += 24;
          v40 += 2;
        }

        while ((v40 * 4) != 256);
        v57 = &__b[v41 + 36];
        v58 = &RotVectorReal96;
        v59 = &RotVectorImag96;
        v60 = 3;
        do
        {
          v61 = v57;
          v62 = 2;
          do
          {
            v63 = *(v61 - 1);
            v45.f32[0] = *v61;
            v64 = *v58++;
            v56.i32[0] = v64;
            v65 = *v59++;
            v53.f32[0] = v65;
            *&v52 = (*v61 * v56.f32[0]) - (v63 * v65);
            *(v61 - 1) = (v63 * v56.f32[0]) + (*v61 * v65);
            *v61 = *&v52;
            v61 += 2;
            --v62;
          }

          while (v62);
          v57 += 6;
          _CF = v60 >= 0x5D;
          v60 += 3;
        }

        while (!_CF);
        for (i1 = 0; i1 != 3; ++i1)
        {
          v68 = 0;
          for (i2 = 0; i2 != 768; i2 += 24)
          {
            v70 = *&v42[i2];
            *&v394.i64[v68++] = v70;
          }

          fft_32(v394.f32, v70, *&v45, *v56.i64, v53, v52, *v55.i64, v39);
          v71 = 0;
          for (i3 = 0; i3 != 192; i3 += 6)
          {
            *&v10[i3] = v394.i64[v71++];
          }

          v42 += 8;
          v10 += 2;
        }

        return;
      }

      v134 = a2;
      v135 = 6;
    }

    dit_fft(v134, v135);
    return;
  }

  if (a1 <= 7)
  {
    if (a1 <= 3)
    {
      if (a1 == 2)
      {
        v226 = vextq_s8(*a2, *a2, 8uLL);
        *&v227 = vaddq_f32(v226, *a2).u64[0];
        *(&v227 + 1) = vsubq_f32(v226, *a2).i64[1];
        *a2 = v227;
        return;
      }

      if (a1 == 3)
      {
        v137 = *(a2 + 2);
        v136 = *(a2 + 4);
        v138.i64[0] = *a2;
        *v139.f32 = vadd_f32(v137, v136);
        *v140.f32 = vrev64_s32(vmul_f32(vsub_f32(v137, v136), vdup_n_s32(0xBF5DB3D7)));
        v140.i64[1] = v140.i64[0];
        v139.i64[1] = v139.i64[0];
        *a2 = vadd_f32(*a2, *v139.f32);
        v138.i64[1] = v138.i64[0];
        v141.i64[0] = 0xBF000000BF000000;
        v141.i64[1] = 0xBF000000BF000000;
        v142 = vmlaq_f32(v138, v141, v139);
        v143 = vsubq_f32(v142, v140);
        v144 = vaddq_f32(v142, v140);
        v144.i32[0] = v143.i32[0];
        v144.i32[3] = v143.i32[3];
        *(a2 + 2) = v144;
        return;
      }
    }

    else
    {
      switch(a1)
      {
        case 4:
          v293 = a2[4];
          v294 = a2[5];
          v295 = *a2 + v293;
          v296 = a2[6];
          v297 = a2[7];
          v298 = a2[2] + v296;
          v299 = a2[1] + v294;
          v300 = a2[3] + v297;
          *a2 = v295 + v298;
          a2[1] = v299 + v300;
          v301 = v295 - (v293 * 2.0);
          v302 = v299 - (v294 * 2.0);
          a2[4] = v295 - v298;
          a2[5] = v299 - v300;
          v303 = v298 - (v296 * 2.0);
          v304 = v300 - (v297 * 2.0);
          a2[2] = v301 + v304;
          a2[3] = v302 - v303;
          a2[6] = v301 - v304;
          a2[7] = v303 + v302;
          return;
        case 5:
          v306 = *(a2 + 6);
          v305 = *(a2 + 8);
          v307 = *(a2 + 2);
          v308 = vadd_f32(v307, v305);
          v309 = *(a2 + 4);
          v310 = vadd_f32(v309, v306);
          v311 = vadd_f32(v308, v310);
          v312 = vadd_f32(*a2, v311);
          v313 = vmul_f32(vsub_f32(v308, v310), vdup_n_s32(0x3F0F1BBDu));
          __asm { FMOV            V6.2S, #-0.625 }

          *v315.f32 = vrev64_s32(vsub_f32(v307, v305));
          v316 = vrev64_s32(vsub_f32(v309, v306));
          *a2 = v312;
          v317 = vmla_f32(v312, 0x4000000040000000, vmul_f32(v311, _D6));
          *v318.f32 = vsub_f32(v317, v313);
          v318.i64[1] = v318.i64[0];
          v315.i64[1] = v315.i64[0];
          *v319.f32 = vmul_f32(vadd_f32(*v315.f32, v316), vdup_n_s32(0x3F737871u));
          v319.i64[1] = v319.i64[0];
          v320.i64[0] = 0x4000000040000000;
          v320.i64[1] = 0x4000000040000000;
          v321 = vadd_f32(v313, v317);
          v322 = vmla_f32(*v319.f32, vdup_n_s32(0xBEB9FEB1), v316);
          v323 = vadd_f32(v321, v322);
          v324 = vsub_f32(v321, v322);
          v325 = vmlaq_f32(v319, v320, vmulq_f32(v315, vdupq_n_s32(0xBF44F8C5)));
          *(a2 + 1) = __PAIR64__(v324.u32[1], v323.u32[0]);
          v324.i32[1] = v323.i32[1];
          *(a2 + 4) = v324;
          v326 = vsubq_f32(v318, v325);
          v327 = vaddq_f32(v318, v325);
          v327.i32[0] = v326.i32[0];
          v327.i32[3] = v326.i32[3];
          *(a2 + 1) = v327;
          return;
        case 6:
          v11 = 0;
          *&__b[48] = 0xAAAAAAAAAAAAAAAALL;
          *&v12 = 0xAAAAAAAAAAAAAAAALL;
          *(&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *&__b[16] = v12;
          *&__b[32] = v12;
          *__b = v12;
          do
          {
            v13 = &a2[2 * v11];
            v14.i64[0] = *v13;
            v14.i64[1] = *v13;
            v15.i64[0] = v13[3];
            v15.i64[1] = v15.i64[0];
            *&v16 = vaddq_f32(v14, v15).u64[0];
            *(&v16 + 1) = vsubq_f32(v14, v15).i64[1];
            *&__b[16 * v11++] = v16;
          }

          while (v11 != 3);
          v17 = 0;
          v18 = &__b[28];
          v19 = &RotVectorReal6;
          v20 = &RotVectorImag6;
          do
          {
            v21 = *v19++;
            v22 = v21;
            v23 = *v20++;
            v24 = *(v18 - 1);
            v25 = (*v18 * v22) - (v24 * v23);
            *(v18 - 1) = (v24 * v22) + (*v18 * v23);
            *v18 = v25;
            v18 += 4;
            v17 += 2;
          }

          while (v17 < 4);
          v26 = 0;
          v27 = vdup_n_s32(0xBF5DB3D7);
          v28.i64[0] = 0xBF000000BF000000;
          v28.i64[1] = 0xBF000000BF000000;
          do
          {
            v29.i64[0] = *&__b[v26];
            v30 = *&__b[v26 + 16];
            v31 = *&__b[v26 + 32];
            *v32.f32 = vadd_f32(v30, v31);
            v33 = &a2[v26 / 4];
            *v34.f32 = vrev64_s32(vmul_f32(vsub_f32(v30, v31), v27));
            v35 = vadd_f32(*v29.f32, *v32.f32);
            v34.i64[1] = v34.i64[0];
            v32.i64[1] = v32.i64[0];
            v29.i64[1] = v29.i64[0];
            v36 = vmlaq_f32(v29, v28, v32);
            v37 = vsubq_f32(v36, v34);
            v38 = vaddq_f32(v36, v34);
            v38.i32[0] = v37.i32[0];
            v38.i32[3] = v37.i32[3];
            *v33 = v35;
            *(v33 + 2) = v38.i64[0];
            *&a2[v26 / 4 + 8] = v38.i64[1];
            v26 += 8;
          }

          while (v26 != 16);
          return;
      }
    }

LABEL_146:
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void fft(int, FLOAT *)";
    exception[2] = 1568;
  }

  if (a1 <= 11)
  {
    if (a1 == 8)
    {
      v249 = a2[8];
      v250 = a2[9];
      v251 = *a2 + v249;
      v252 = a2[12];
      v253 = a2[13];
      v254 = a2[4] + v252;
      v255 = a2[1] + v250;
      v256 = a2[5] + v253;
      v257 = v251 + v254;
      v258 = v251 - v254;
      v259 = v255 + v256;
      v260 = v255 - v256;
      v261 = v251 + (v249 * -2.0);
      v262 = v254 + (v252 * -2.0);
      v263 = v255 + (v250 * -2.0);
      v264 = v256 + (v253 * -2.0);
      v265 = v261 + v264;
      v266 = v261 - v264;
      v267 = v263 - v262;
      v268 = v262 + v263;
      v269 = a2[10];
      v270 = a2[11];
      v271 = a2[2] + v269;
      v272 = a2[14];
      v273 = a2[15];
      v274 = a2[6] + v272;
      v275 = a2[3] + v270;
      v276 = a2[7] + v273;
      v277 = v271 + v274;
      v278 = v271 - v274;
      v279 = v275 + v276;
      v280 = v275 - v276;
      v281 = v271 + (v269 * -2.0);
      v282 = v274 + (v272 * -2.0);
      v283 = v275 + (v270 * -2.0);
      v284 = v276 + (v273 * -2.0);
      v285 = v281 + v284;
      v286 = v281 - v284;
      v287 = v283 - v282;
      v288 = v282 + v283;
      *a2 = v257 + v277;
      a2[1] = v259 + v279;
      a2[8] = v257 - v277;
      a2[9] = v259 - v279;
      a2[4] = v258 + v280;
      a2[5] = v260 - v278;
      a2[12] = v258 - v280;
      a2[13] = v260 + v278;
      v289 = (v285 * -0.70711) + (v287 * 0.70711);
      v290 = (v285 * 0.70711) + (v287 * 0.70711);
      a2[2] = v265 + v290;
      a2[3] = v267 + v289;
      a2[10] = v265 - v290;
      a2[11] = v267 - v289;
      v291 = (v286 * -0.70711) + (v288 * 0.70711);
      v292 = (v286 * 0.70711) + (v288 * 0.70711);
      a2[6] = v266 + v291;
      a2[7] = v268 - v292;
      a2[14] = v266 - v291;
      a2[15] = v268 + v292;
      return;
    }

    if (a1 == 10)
    {
      v145 = *(a2 + 8);
      v146 = *(a2 + 12);
      v147 = *(a2 + 14);
      v148 = vadd_f32(v145, v146);
      v150 = *(a2 + 4);
      v149 = *(a2 + 6);
      v151 = *(a2 + 16);
      v152 = *(a2 + 18);
      v153 = vadd_f32(v150, v151);
      v154 = vdup_n_s32(0x3F0F1BBDu);
      v155 = vmul_f32(vsub_f32(v148, v153), v154);
      v156 = vadd_f32(v148, v153);
      v157 = *(a2 + 2);
      v158 = vadd_f32(*a2, v156);
      __asm { FMOV            V22.2S, #-0.625 }

      v160 = vadd_f32(v157, v152);
      v161 = vadd_f32(v149, v147);
      v162 = vadd_f32(v161, v160);
      v163 = vadd_f32(*(a2 + 10), v162);
      *&v164 = vadd_f32(v158, v163);
      v165 = vsub_f32(v158, v163);
      v166 = vmla_f32(v158, 0x4000000040000000, vmul_f32(v156, _D22));
      v167 = vrev64_s32(vsub_f32(v146, v145));
      v168 = vrev64_s32(vsub_f32(v150, v151));
      v169 = vdup_n_s32(0x3F737871u);
      v170 = vmul_f32(vadd_f32(v167, v168), v169);
      v171 = vadd_f32(v155, v166);
      v172 = vdup_n_s32(0xBEB9FEB1);
      v173 = vmla_f32(v170, v172, v168);
      v174 = vadd_f32(v171, v173);
      v175 = vsub_f32(v171, v173);
      v168.i32[0] = v174.i32[1];
      v176 = vmul_f32(vsub_f32(v160, v161), v154);
      v177 = vmla_f32(v163, 0x4000000040000000, vmul_f32(v162, _D22));
      v178 = vrev64_s32(vsub_f32(v157, v152));
      v179 = vrev64_s32(vsub_f32(v147, v149));
      v180 = vmul_f32(vadd_f32(v179, v178), v169);
      v181 = vadd_f32(v176, v177);
      v182 = vmla_f32(v180, v172, v179);
      v183 = vadd_f32(v181, v182);
      v184 = vsub_f32(v181, v182);
      v179.i32[0] = v183.i32[1];
      v182.i32[0] = vadd_f32(v174, v183).u32[0];
      v174.i32[1] = v175.i32[1];
      a2[4] = v182.f32[0];
      v183.i32[1] = v184.i32[1];
      v185 = vsub_f32(v174, v183);
      v186 = vsub_f32(v166, v155);
      v187 = vdup_n_s32(0xBF44F8C5);
      v188 = vmla_f32(v170, 0x4000000040000000, vmul_f32(v167, v187));
      v189 = vsub_f32(v186, v188);
      v190 = vadd_f32(v186, v188);
      v191 = vsub_f32(v177, v176);
      v192 = vmla_f32(v180, 0x4000000040000000, vmul_f32(v178, v187));
      v193 = vsub_f32(v191, v192);
      v194 = vadd_f32(v191, v192);
      *(a2 + 4) = vadd_f32(__PAIR64__(v190.u32[1], v189.u32[0]), __PAIR64__(v194.u32[1], v193.u32[0]));
      *(a2 + 5) = v165;
      *(a2 + 9) = vsub_f32(__PAIR64__(v190.u32[1], v189.u32[0]), __PAIR64__(v194.u32[1], v193.u32[0]));
      v190.i32[1] = v189.i32[1];
      v194.i32[1] = v193.i32[1];
      *(a2 + 6) = vadd_f32(v190, v194);
      *(a2 + 7) = v185;
      *(&v164 + 1) = vsub_f32(v190, v194);
      *a2 = v164;
      *&v164 = vadd_f32(v175, v184);
      *(a2 + 16) = v164;
      a2[17] = v168.f32[0] + v179.f32[0];
      *(a2 + 5) = vext_s8(*&v164, vsub_f32(v175, v184), 4uLL);
      a2[7] = v168.f32[0] - v179.f32[0];
      return;
    }

    goto LABEL_146;
  }

  switch(a1)
  {
    case 12:

      fft12(a2, a3, a4, a5, *a6.i64, a7, a8, *a9.i64, a10);
      break;
    case 16:

      fft_16(a2);
      break;
    case 20:
      v73 = 0;
      v74.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      v74.i64[1] = 0xAAAAAAAAAAAAAAAALL;
      *&__b[128] = v74;
      *&__b[144] = v74;
      *&__b[96] = v74;
      *&__b[112] = v74;
      *&__b[64] = v74;
      *&__b[80] = v74;
      *&__b[32] = v74;
      *&__b[48] = v74;
      *__b = v74;
      *&__b[16] = v74;
      v75 = __b;
      v395 = v74;
      v396 = v74;
      v394 = v74;
      v76 = a2;
      *&__b[160] = 0xAAAAAAAAAAAAAAAALL;
      v77 = __b;
      do
      {
        v78 = 0;
        v79 = v76;
        do
        {
          v80 = *v79;
          v79 += 10;
          *&v77[v78] = v80;
          v78 += 2;
        }

        while (v78 != 8);
        v81 = v77[4];
        v82 = v77[5];
        v83 = *v77 + v81;
        v84 = v77[6];
        v85 = v77[7];
        v86 = v77[2] + v84;
        v87 = v77[1] + v82;
        v88 = v77[3] + v85;
        *v77 = v83 + v86;
        v77[1] = v87 + v88;
        v89 = v83 - (v81 * 2.0);
        v90 = v87 - (v82 * 2.0);
        v77[4] = v83 - v86;
        v77[5] = v87 - v88;
        v91 = v86 - (v84 * 2.0);
        v92 = v88 - (v85 * 2.0);
        v77[2] = v89 + v92;
        v77[3] = v90 - v91;
        v77[6] = v89 - v92;
        v77[7] = v91 + v90;
        v76 += 2;
        v77 += 8;
        ++v73;
      }

      while (v73 != 5);
      v93 = &__b[44];
      v94 = &RotVectorReal20;
      v95 = &RotVectorImag20;
      v96 = 4;
      do
      {
        v97 = v93;
        v98 = 3;
        do
        {
          v99 = *(v97 - 1);
          v100 = *v94++;
          v101 = v100;
          v102 = *v95++;
          v103 = (*v97 * v101) - (v99 * v102);
          *(v97 - 1) = (v99 * v101) + (*v97 * v102);
          *v97 = v103;
          v97 += 2;
          --v98;
        }

        while (v98);
        v93 += 8;
        _CF = v96 >= 0x10;
        v96 += 4;
      }

      while (!_CF);
      v104 = 0;
      v105 = vdup_n_s32(0x3F0F1BBDu);
      __asm { FMOV            V1.2S, #-0.625 }

      v110 = vdup_n_s32(0x3F737871u);
      v111 = vdupq_n_s32(0xBF44F8C5);
      v112.i64[0] = 0x4000000040000000;
      v112.i64[1] = 0x4000000040000000;
      v113 = vdup_n_s32(0xBEB9FEB1);
      do
      {
        v114 = 0;
        for (i4 = 0; i4 != 160; i4 += 32)
        {
          v394.i64[v114++] = *&v75[i4];
        }

        v116 = 0;
        v117 = 0;
        v118 = vadd_f32(*&v394.u32[2], *v396.f32);
        v119 = vadd_f32(*v395.f32, *&v395.u32[2]);
        v120 = vadd_f32(v118, v119);
        v121 = vmul_f32(vsub_f32(v118, v119), v105);
        *v122.f32 = vrev64_s32(vsub_f32(*&v394.u32[2], *v396.f32));
        v123 = vrev64_s32(vsub_f32(*v395.f32, *&v395.u32[2]));
        *v394.f32 = vadd_f32(*v394.f32, v120);
        v124 = vmla_f32(*v394.f32, 0x4000000040000000, vmul_f32(v120, _D1));
        *v125.f32 = vsub_f32(v124, v121);
        v125.i64[1] = v125.i64[0];
        v122.i64[1] = v122.i64[0];
        *v126.f32 = vmul_f32(vadd_f32(*v122.f32, v123), v110);
        v126.i64[1] = v126.i64[0];
        v127 = vadd_f32(v121, v124);
        v128 = vmla_f32(*v126.f32, v113, v123);
        v129 = vadd_f32(v127, v128);
        v130 = vsub_f32(v127, v128);
        v131 = vmlaq_f32(v126, v112, vmulq_f32(v122, v111));
        v394.i64[1] = __PAIR64__(v130.u32[1], v129.u32[0]);
        v130.i32[1] = v129.i32[1];
        *v396.f32 = v130;
        v132 = vsubq_f32(v125, v131);
        v133 = vaddq_f32(v125, v131);
        v133.i32[0] = v132.i32[0];
        v133.i32[3] = v132.i32[3];
        v395 = v133;
        do
        {
          *&v10[v117] = v394.i64[v116];
          v117 += 8;
          ++v116;
        }

        while (v117 != 40);
        v75 += 8;
        v10 += 2;
        ++v104;
      }

      while (v104 != 4);
      break;
    default:
      goto LABEL_146;
  }
}

float fft_32(float *a1, double a2, double a3, double a4, float32x4_t a5, double a6, double a7, float32x4_t a8)
{
  v8 = 0;
  v9 = a1[32];
  v10 = a1[33];
  v11 = *a1 + v9;
  v12 = a1[1] + v10;
  v13 = a1[48];
  v14 = a1[49];
  v15 = a1[16] + v13;
  v16 = a1[17] + v14;
  *a1 = v11 + v15;
  a1[1] = v12 + v16;
  v17 = a1[36];
  v18 = a1[37];
  v19 = a1[4] + v17;
  v20 = a1[5] + v18;
  a1[4] = v11 - v15;
  a1[5] = v12 - v16;
  v21 = v11 + (v9 * -2.0);
  v22 = v12 + (v10 * -2.0);
  v23 = v15 + (v13 * -2.0);
  v24 = v16 + (v14 * -2.0);
  v25 = a1[34];
  v26 = a1[35];
  v27 = a1[2] + v25;
  v28 = a1[3] + v26;
  a1[2] = v21 + v24;
  a1[3] = v22 - v23;
  v29 = a1[38];
  v30 = a1[39];
  v31 = a1[6] + v29;
  v32 = a1[7] + v30;
  a1[6] = v21 - v24;
  a1[7] = v22 + v23;
  v33 = a1[52];
  v34 = a1[53];
  v35 = a1[20] + v33;
  v36 = a1[21] + v34;
  a1[16] = v19 + v35;
  a1[17] = v20 + v36;
  a1[20] = v19 - v35;
  a1[21] = v20 - v36;
  v37 = v19 + (v17 * -2.0);
  v38 = v20 + (v18 * -2.0);
  v39 = v35 + (v33 * -2.0);
  v40 = v36 + (v34 * -2.0);
  v41 = a1[50];
  v42 = a1[51];
  v43 = a1[18] + v41;
  v44 = a1[19] + v42;
  a1[18] = v37 + v40;
  a1[19] = v38 - v39;
  v45 = v37 - v40;
  v46 = a1[54];
  v47 = a1[55];
  v48 = a1[22] + v46;
  v49 = a1[23] + v47;
  a1[22] = v45;
  a1[23] = v38 + v39;
  a1[32] = v27 + v43;
  a1[33] = v28 + v44;
  a1[36] = v27 - v43;
  a1[37] = v28 - v44;
  v50 = v27 + (v25 * -2.0);
  v51 = v28 + (v26 * -2.0);
  v52 = v43 + (v41 * -2.0);
  v53 = v44 + (v42 * -2.0);
  a1[34] = v50 + v53;
  a1[35] = v51 - v52;
  a1[48] = v31 + v48;
  a1[49] = v32 + v49;
  a1[52] = v31 - v48;
  a1[53] = v32 - v49;
  v54 = v31 + (v29 * -2.0);
  v55 = v32 + (v30 * -2.0);
  a1[38] = v50 - v53;
  a1[39] = v51 + v52;
  v56 = v48 + (v46 * -2.0);
  v57 = v49 + (v47 * -2.0);
  a1[50] = v54 + v57;
  a1[51] = v55 - v56;
  a1[54] = v54 - v57;
  a1[55] = v55 + v56;
  v58 = a1[40];
  v59 = a1[41];
  v60 = a1[8] + v58;
  v61 = a1[9] + v59;
  v62 = a1[56];
  v63 = a1[57];
  v64 = a1[24] + v62;
  v65 = a1[25] + v63;
  a1[8] = v60 + v64;
  a1[9] = v61 + v65;
  v66 = a1[44];
  v67 = a1[45];
  v68 = a1[12] + v66;
  v69 = a1[13] + v67;
  a1[12] = v60 - v64;
  a1[13] = v61 - v65;
  v70 = v60 + (v58 * -2.0);
  v71 = v61 + (v59 * -2.0);
  v72 = v64 + (v62 * -2.0);
  v73 = v65 + (v63 * -2.0);
  v74 = a1[42];
  v75 = a1[43];
  v76 = a1[10] + v74;
  v77 = a1[11] + v75;
  a1[10] = v70 + v73;
  a1[11] = v71 - v72;
  v78 = a1[46];
  v79 = a1[47];
  v80 = a1[14] + v78;
  v81 = a1[15] + v79;
  a1[14] = v70 - v73;
  a1[15] = v71 + v72;
  v82 = a1[60];
  v83 = a1[61];
  v84 = a1[28] + v82;
  v85 = a1[29] + v83;
  a1[24] = v68 + v84;
  a1[25] = v69 + v85;
  a1[28] = v68 - v84;
  a1[29] = v69 - v85;
  v86 = v68 + (v66 * -2.0);
  v87 = v69 + (v67 * -2.0);
  v88 = v84 + (v82 * -2.0);
  v89 = v85 + (v83 * -2.0);
  v90 = a1[58];
  v91 = a1[59];
  v92 = a1[26] + v90;
  v93 = a1[27] + v91;
  a1[26] = v86 + v89;
  a1[27] = v87 - v88;
  v94 = v86 - v89;
  v95 = a1[62];
  v96 = a1[63];
  v97 = a1[30] + v95;
  v98 = a1[31] + v96;
  a1[30] = v94;
  a1[31] = v87 + v88;
  a1[40] = v76 + v92;
  a1[41] = v77 + v93;
  v99 = v76 + (v74 * -2.0);
  a1[44] = v76 - v92;
  a1[45] = v77 - v93;
  v100 = v77 + (v75 * -2.0);
  v101 = v92 + (v90 * -2.0);
  v102 = v93 + (v91 * -2.0);
  a1[42] = v99 + v102;
  a1[43] = v100 - v101;
  a1[56] = v80 + v97;
  a1[57] = v81 + v98;
  a1[60] = v80 - v97;
  a1[61] = v81 - v98;
  v103 = v80 + (v78 * -2.0);
  v104 = v81 + (v79 * -2.0);
  a1[46] = v99 - v102;
  a1[47] = v100 + v101;
  v105 = v97 + (v95 * -2.0);
  v106 = v98 + (v96 * -2.0);
  a1[58] = v103 + v106;
  a1[59] = v104 - v105;
  a1[62] = v103 - v106;
  a1[63] = v104 + v105;
  do
  {
    v107 = &a1[v8];
    v109 = a1[v8 + 12];
    v108 = a1[v8 + 13];
    a5.f32[0] = a1[v8 + 4];
    v110 = a1[v8 + 5];
    v111 = v108 + a5.f32[0];
    a8.f32[0] = v110 - v109;
    v112 = a5.f32[0] - v108;
    v113 = v109 + v110;
    v107[4] = v111;
    v107[5] = a8.f32[0];
    a5.f32[0] = a1[v8 + 10] * 0.70711;
    v114 = a1[v8 + 11] * 0.70711;
    v107[12] = v112;
    v107[13] = v113;
    v115 = *&a1[v8];
    v116.f32[0] = v114 + a5.f32[0];
    v117 = a1[v8 + 14] * 0.70711;
    a5.f32[0] = v114 - a5.f32[0];
    v118 = a1[v8 + 15] * 0.70711;
    a8.f32[0] = v118 - v117;
    v119 = v118 + v117;
    v116.i32[1] = a5.i32[0];
    a5.i64[0] = *&a1[v8 + 6];
    v120.i64[0] = *&a1[v8 + 8];
    LODWORD(v121) = vsub_f32(*a5.f32, *a8.f32).u32[0];
    a8.f32[1] = v119;
    a8.i64[1] = v120.i64[0];
    *&v120.u32[2] = v116;
    *(v107 + 5) = vsub_f32(*&vextq_s8(v115, v115, 8uLL), v116);
    v116.i32[0] = vaddq_f32(a5, a8).u32[0];
    *v107 = vaddq_f32(v115, v120);
    a5.i64[1] = v115.i64[0];
    v122 = vsubq_f32(a5, a8);
    v122.i32[0] = v116.i32[0];
    *(v107 + 6) = v122;
    HIDWORD(v121) = vadd_f32(*&a5, *&a8).i32[1];
    *(v107 + 7) = v121;
    v8 += 16;
  }

  while ((v8 * 4) != 256);
  v123 = a1[16];
  v124 = a1[17];
  v125 = a1[1];
  v268 = v123 + *a1;
  v269 = v124 + v125;
  v272 = *a1 - v123;
  v273 = v125 - v124;
  v126 = a1[24];
  v127 = a1[25];
  v128 = a1[8];
  v129 = a1[9];
  v299 = v127 + v128;
  v300 = v129 - v126;
  v301 = v128 - v127;
  v302 = v126 + v129;
  v130 = a1[48];
  v131 = a1[49];
  v132 = a1[32];
  v133 = a1[33];
  v134 = v130 + v132;
  v135 = v131 + v133;
  v136 = v132 - v130;
  v267 = v133 - v131;
  v137 = a1[56];
  v138 = a1[57];
  v139 = a1[40];
  v140 = a1[41];
  v291 = v140 - v137;
  v292 = v138 + v139;
  v295 = v137 + v140;
  v296 = v139 - v138;
  v141 = a1[18];
  v142 = a1[19];
  v143 = (v141 * -0.38268) + (v142 * 0.92388);
  v144 = (v141 * 0.92388) + (v142 * 0.38268);
  v145 = a1[2];
  v146 = a1[3];
  v265 = v145 + v144;
  v266 = v146 + v143;
  v270 = v145 - v144;
  v271 = v146 - v143;
  v148 = a1[26];
  v147 = a1[27];
  v149 = (v148 * -0.38268) + (v147 * 0.92388);
  v150 = (v148 * 0.92388) + (v147 * 0.38268);
  v151 = a1[10];
  v152 = a1[11];
  v293 = v151 + v149;
  v294 = v152 - v150;
  v297 = v151 - v149;
  v298 = v152 + v150;
  v154 = a1[50];
  v153 = a1[51];
  v155 = (v154 * -0.38268) + (v153 * 0.92388);
  v156 = (v154 * 0.92388) + (v153 * 0.38268);
  v157 = a1[34];
  v158 = a1[35];
  v159 = v157 + v156;
  v160 = v157 - v156;
  v161 = v158 + v155;
  v162 = v158 - v155;
  v164 = a1[58];
  v163 = a1[59];
  v165 = (v164 * -0.38268) + (v163 * 0.92388);
  v166 = (v164 * 0.92388) + (v163 * 0.38268);
  v167 = a1[42];
  v168 = a1[43];
  v283 = v168 - v166;
  v284 = v167 + v165;
  v287 = v168 + v166;
  v288 = v167 - v165;
  v169 = a1[20] * 0.70711;
  v170 = a1[21] * 0.70711;
  v171 = v170 - v169;
  v172 = v169 + v170;
  v173 = a1[4];
  v174 = a1[5];
  v175 = v173 + v172;
  v176 = v174 + v171;
  v263 = v174 - v171;
  v264 = v173 - v172;
  v177 = a1[28] * 0.70711;
  v178 = a1[29] * 0.70711;
  v179 = v178 - v177;
  v180 = v177 + v178;
  v181 = a1[12];
  v182 = a1[13];
  v285 = v182 - v180;
  v286 = v181 + v179;
  v289 = v182 + v180;
  v290 = v181 - v179;
  v183 = a1[52] * 0.70711;
  v184 = a1[53] * 0.70711;
  v185 = v184 - v183;
  v186 = v183 + v184;
  v187 = a1[36];
  v188 = a1[37];
  v189 = v187 + v186;
  v190 = v187 - v186;
  v191 = v188 + v185;
  v192 = v188 - v185;
  v193 = a1[60] * 0.70711;
  v194 = a1[61] * 0.70711;
  v195 = v194 - v193;
  v196 = v193 + v194;
  v197 = a1[44];
  v198 = a1[45];
  v275 = v198 - v196;
  v276 = v197 + v195;
  v279 = v198 + v196;
  v280 = v197 - v195;
  v200 = a1[22];
  v199 = a1[23];
  v201 = (v200 * -0.92388) + (v199 * 0.38268);
  v202 = (v200 * 0.38268) + (v199 * 0.92388);
  v203 = a1[6];
  v204 = a1[7];
  v205 = v203 + v202;
  v206 = v203 - v202;
  v207 = v204 + v201;
  v208 = v204 - v201;
  v210 = a1[30];
  v209 = a1[31];
  v211 = (v210 * -0.92388) + (v209 * 0.38268);
  v212 = (v210 * 0.38268) + (v209 * 0.92388);
  v213 = a1[14];
  v214 = a1[15];
  v277 = v214 - v212;
  v278 = v213 + v211;
  v281 = v214 + v212;
  v282 = v213 - v211;
  v216 = a1[54];
  v215 = a1[55];
  v217 = (v216 * -0.92388) + (v215 * 0.38268);
  v218 = (v216 * 0.38268) + (v215 * 0.92388);
  v220 = a1[38];
  v219 = a1[39];
  v221 = v220 + v218;
  v222 = v220 - v218;
  v223 = v219 + v217;
  v224 = v219 - v217;
  v225 = a1[62];
  v226 = a1[63];
  v227 = (v225 * -0.92388) + (v226 * 0.38268);
  v228 = (v225 * 0.38268) + (v226 * 0.92388);
  v230 = a1[46];
  v229 = a1[47];
  v231 = v230 + v227;
  v232 = v230 - v227;
  v233 = v229 - v228;
  v274 = v229 + v228;
  *a1 = v268 + v134;
  a1[1] = v269 + v135;
  a1[32] = v268 - v134;
  a1[33] = v269 - v135;
  a1[16] = v272 + v267;
  a1[17] = v273 - v136;
  a1[48] = v272 - v267;
  a1[49] = v273 + v136;
  v234 = (v159 * -0.19509) + (v161 * 0.98079);
  v235 = (v159 * 0.98079) + (v161 * 0.19509);
  a1[2] = v265 + v235;
  a1[3] = v266 + v234;
  a1[34] = v265 - v235;
  a1[35] = v266 - v234;
  v236 = (v160 * -0.19509) + (v162 * 0.98079);
  v237 = (v160 * 0.98079) + (v162 * 0.19509);
  a1[18] = v270 + v236;
  a1[19] = v271 - v237;
  a1[50] = v270 - v236;
  a1[51] = v271 + v237;
  v238 = (v189 * -0.38268) + (v191 * 0.92388);
  v239 = (v189 * 0.92388) + (v191 * 0.38268);
  a1[4] = v175 + v239;
  a1[5] = v176 + v238;
  a1[36] = v175 - v239;
  a1[37] = v176 - v238;
  v240 = (v190 * -0.38268) + (v192 * 0.92388);
  v241 = (v190 * 0.92388) + (v192 * 0.38268);
  a1[20] = v264 + v240;
  a1[21] = v263 - v241;
  a1[52] = v264 - v240;
  a1[53] = v263 + v241;
  v242 = (v221 * -0.55557) + (v223 * 0.83147);
  v243 = (v221 * 0.83147) + (v223 * 0.55557);
  a1[6] = v205 + v243;
  a1[7] = v207 + v242;
  a1[38] = v205 - v243;
  a1[39] = v207 - v242;
  v244 = (v222 * -0.55557) + (v224 * 0.83147);
  v245 = (v222 * 0.83147) + (v224 * 0.55557);
  a1[22] = v206 + v244;
  a1[23] = v208 - v245;
  a1[54] = v206 - v244;
  a1[55] = v208 + v245;
  v246 = (v291 * 0.70711) - (v292 * 0.70711);
  v247 = (v292 * 0.70711) + (v291 * 0.70711);
  a1[8] = v299 + v247;
  a1[9] = v300 + v246;
  a1[40] = v299 - v247;
  a1[41] = v300 - v246;
  v248 = (v295 * 0.70711) - (v296 * 0.70711);
  v249 = (v296 * 0.70711) + (v295 * 0.70711);
  a1[24] = v301 + v248;
  a1[25] = v302 - v249;
  a1[56] = v301 - v248;
  a1[57] = v302 + v249;
  v250 = (v284 * -0.83147) + (v283 * 0.55557);
  v251 = (v284 * 0.55557) + (v283 * 0.83147);
  a1[10] = v293 + v251;
  a1[11] = v294 + v250;
  a1[42] = v293 - v251;
  a1[43] = v294 - v250;
  v252 = (v288 * -0.83147) + (v287 * 0.55557);
  v253 = (v288 * 0.55557) + (v287 * 0.83147);
  a1[26] = v297 + v252;
  a1[27] = v298 - v253;
  a1[58] = v297 - v252;
  a1[59] = v298 + v253;
  v254 = (v276 * -0.92388) + (v275 * 0.38268);
  v255 = (v276 * 0.38268) + (v275 * 0.92388);
  a1[12] = v286 + v255;
  a1[13] = v285 + v254;
  a1[44] = v286 - v255;
  a1[45] = v285 - v254;
  v256 = (v280 * -0.92388) + (v279 * 0.38268);
  v257 = (v280 * 0.38268) + (v279 * 0.92388);
  a1[28] = v290 + v256;
  a1[29] = v289 - v257;
  a1[60] = v290 - v256;
  a1[61] = v289 + v257;
  v258 = (v231 * -0.98079) + (v233 * 0.19509);
  v259 = (v231 * 0.19509) + (v233 * 0.98079);
  a1[14] = v278 + v259;
  a1[15] = v277 + v258;
  a1[46] = v278 - v259;
  a1[47] = v277 - v258;
  v260 = (v232 * -0.98079) + (v274 * 0.19509);
  v261 = (v232 * 0.19509) + (v274 * 0.98079);
  a1[30] = v282 + v260;
  a1[31] = v281 - v261;
  result = v282 - v260;
  a1[62] = result;
  a1[63] = v281 + v261;
  return result;
}

float fft_16(float *a1)
{
  v1 = a1[16];
  v2 = a1[17];
  v3 = *a1 + v1;
  v4 = a1[1] + v2;
  v5 = a1[24];
  v6 = a1[25];
  v7 = a1[8] + v5;
  v8 = a1[9] + v6;
  v133 = v3 + v7;
  v137 = v4 + v8;
  v9 = a1[20];
  v10 = a1[21];
  v11 = a1[4] + v9;
  v12 = a1[5] + v10;
  v129 = v3 - v7;
  v130 = v4 - v8;
  v13 = v3 + (v1 * -2.0);
  v14 = v7 + (v5 * -2.0);
  v15 = v4 + (v2 * -2.0);
  v16 = v8 + (v6 * -2.0);
  v17 = a1[18];
  v18 = a1[19];
  v19 = a1[2] + v17;
  v20 = a1[3] + v18;
  v139 = v15 - v14;
  v21 = a1[7];
  v22 = a1[22];
  v23 = a1[23];
  v24 = a1[6] + v22;
  v132 = v13 - v16;
  v135 = v13 + v16;
  v136 = v15 + v14;
  v26 = a1[28];
  v25 = a1[29];
  v27 = a1[12] + v26;
  v28 = a1[13] + v25;
  v29 = v11 + v27;
  v30 = v12 + v28;
  v31 = v11 - v27;
  v32 = v12 - v28;
  v33 = v11 + (v9 * -2.0);
  v34 = v12 + (v10 * -2.0);
  v35 = v27 + (v26 * -2.0);
  v36 = v28 + (v25 * -2.0);
  v37 = a1[26];
  v38 = a1[27];
  v39 = a1[10] + v37;
  v40 = a1[11] + v38;
  v41 = v34 - v35;
  v127 = v33 + v36;
  v128 = v33 - v36;
  v42 = v34 + v35;
  v43 = v19 + v39;
  v44 = v19 + (v17 * -2.0);
  v45 = v19 - v39;
  v46 = v39 + (v37 * -2.0);
  v47 = v20 + v40;
  v48 = v20 + (v18 * -2.0);
  v49 = v20 - v40;
  v50 = v40 + (v38 * -2.0);
  v52 = a1[30];
  v51 = a1[31];
  v53 = a1[14] + v52;
  v54 = v24 + (v22 * -2.0);
  v55 = v24 + v53;
  v56 = v24 - v53;
  v57 = v53 + (v52 * -2.0);
  v58 = v21 + v23;
  v59 = a1[15] + v51;
  v60 = (v21 + v23) + (v23 * -2.0);
  v61 = v59 + (v51 * -2.0);
  v62 = v58 + v59;
  v63 = v58 - v59;
  v64 = v44 + v50;
  v65 = v44 - v50;
  v66 = v48 - v46;
  v67 = v48 + v46;
  v68 = v54 + v61;
  v69 = v54 - v61;
  v70 = v60 - v57;
  v71 = v60 + v57;
  v72 = v133 + v29;
  v73 = v133 - v29;
  v74 = v137 + v30;
  v75 = v137 - v30;
  v76 = v129 + v32;
  v77 = v129 - v32;
  v78 = v130 - v31;
  v79 = v130 + v31;
  v80 = v43 + v55;
  v81 = v43 - v55;
  v82 = v47 + v62;
  v83 = v47 - v62;
  v134 = v45 + v63;
  v138 = v45 - v63;
  v131 = v49 - v56;
  v84 = v49 + v56;
  v85 = v41 * 0.70711;
  v86 = (v41 * 0.70711) - (v127 * 0.70711);
  v87 = v85 + (v127 * 0.70711);
  v88 = v135 + v87;
  v89 = v135 - v87;
  v90 = v139 + v86;
  v91 = v139 - v86;
  v92 = (v42 * 0.70711) - (v128 * 0.70711);
  v93 = (v42 * 0.70711) + (v128 * 0.70711);
  v94 = v132 + v92;
  v95 = v132 - v92;
  v96 = v136 - v93;
  v97 = v136 + v93;
  v98 = v68 * 0.70711;
  v99 = v70 * 0.70711;
  v100 = v99 - v98;
  v101 = v99 + v98;
  v102 = v64 + v101;
  v103 = v64 - v101;
  v104 = v66 + v100;
  v105 = v66 - v100;
  v106 = v69 * 0.70711;
  v107 = v71 * 0.70711;
  v108 = v107 - v106;
  v109 = v107 + v106;
  v110 = v65 + (v107 - v106);
  v111 = v65 - v108;
  v112 = v67 - v109;
  v113 = v67 + v109;
  *a1 = v72 + v80;
  a1[1] = v74 + v82;
  a1[16] = v72 - v80;
  a1[17] = v74 - v82;
  a1[8] = v73 + v83;
  a1[9] = v75 - v81;
  a1[24] = v73 - v83;
  a1[25] = v75 + v81;
  v114 = (v102 * -0.38268) + (v104 * 0.92388);
  v115 = (v102 * 0.92388) + (v104 * 0.38268);
  a1[2] = v88 + v115;
  a1[3] = v90 + v114;
  a1[18] = v88 - v115;
  a1[19] = v90 - v114;
  v116 = (v103 * -0.38268) + (v105 * 0.92388);
  v117 = (v103 * 0.92388) + (v105 * 0.38268);
  a1[10] = v89 + v116;
  a1[11] = v91 - v117;
  a1[26] = v89 - v116;
  a1[27] = v91 + v117;
  v118 = (v131 * 0.70711) - (v134 * 0.70711);
  v119 = (v131 * 0.70711) + (v134 * 0.70711);
  a1[4] = v76 + v119;
  a1[5] = v78 + v118;
  a1[20] = v76 - v119;
  a1[21] = v78 - v118;
  v120 = (v84 * 0.70711) - (v138 * 0.70711);
  v121 = (v84 * 0.70711) + (v138 * 0.70711);
  a1[12] = v77 + v120;
  a1[13] = v79 - v121;
  a1[28] = v77 - v120;
  a1[29] = v79 + v121;
  v122 = (v110 * -0.92388) + (v112 * 0.38268);
  v123 = (v110 * 0.38268) + (v112 * 0.92388);
  a1[6] = v94 + v123;
  a1[7] = v96 + v122;
  a1[22] = v94 - v123;
  a1[23] = v96 - v122;
  v124 = (v111 * -0.92388) + (v113 * 0.38268);
  v125 = (v111 * 0.38268) + (v113 * 0.92388);
  a1[14] = v95 + v124;
  a1[15] = v97 - v125;
  result = v95 - v124;
  a1[30] = result;
  a1[31] = v97 + v125;
  return result;
}

float32x2_t *fft12(float32x2_t *result, double a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9)
{
  v9 = 0;
  v81 = *MEMORY[0x1E69E9840];
  v10 = result[4];
  v11 = result[8];
  *v12.f32 = vadd_f32(v10, v11);
  *v13.f32 = *result;
  v14 = vadd_f32(*result, *v12.f32);
  v12.i64[1] = v12.i64[0];
  *&v13.u32[2] = *result;
  v15.i64[0] = 0xBF000000BF000000;
  v15.i64[1] = 0xBF000000BF000000;
  v16 = vmlaq_f32(v13, v15, v12);
  v12.i64[0] = -1;
  v12.i64[1] = -1;
  v78[1] = v12;
  v79 = v12;
  v77 = v12;
  v78[0] = v12;
  v80 = -1;
  *v17.f32 = vrev64_s32(vmul_f32(vsub_f32(v10, v11), vdup_n_s32(0xBF5DB3D7)));
  v17.i64[1] = v17.i64[0];
  v18 = vsubq_f32(v16, v17);
  v19 = vaddq_f32(v16, v17);
  v19.i32[0] = v18.i32[0];
  v19.i32[3] = v18.i32[3];
  v75 = v14;
  v76 = v19;
  v20 = &RotVectorReal12;
  v21 = &RotVectorImag12;
  v22 = 1;
  v23 = result;
  do
  {
    v24 = v23[1].f32[0];
    ++v23;
    v25 = v23[8].f32[0];
    v26 = v23[8].f32[1];
    v27 = v23[4].f32[0];
    v28 = v23[4].f32[1];
    a9.f32[0] = v27 + v25;
    v29 = (v27 - v25) * -0.86603;
    v30 = v24 + a9.f32[0];
    v31 = v24 - (a9.f32[0] * 0.5);
    a9.f32[0] = v28 + v26;
    v32 = (v28 - v26) * -0.86603;
    v33 = v23->f32[1];
    v34 = v33 - (a9.f32[0] * 0.5);
    v35 = v33 + a9.f32[0];
    a9.f32[0] = v31 - v32;
    v36 = *v20++;
    v37.i64[0] = v36;
    v38 = *v21++;
    v39.i64[0] = v38;
    *&v40 = v29 + v34;
    v41 = v31 + v32;
    v42 = a9;
    a9.f32[1] = v41;
    v42.f32[1] = v41;
    a9.i64[1] = v38;
    v39.i64[1] = v37.i64[0];
    v37.i64[1] = vnegq_f32(v42).u64[0];
    v43 = v22;
    v44 = (&v75 + v9 * 4);
    v45 = &v77.f32[v9 + 2];
    *(&v40 + 1) = v34 - v29;
    v44[6] = v30;
    v44[7] = v35;
    v46 = vmlaq_f32(vmulq_f32(a9, v37), v39, vdupq_lane_s64(v40, 0));
    v37.i64[0] = vextq_s8(v46, v46, 8uLL).u64[0];
    vst2_f32(v45, *(&v37 - 8));
    v9 += 6;
    v22 = 0;
  }

  while ((v43 & 1) != 0);
  v47 = 0;
  v48 = v23[5].f32[0];
  v49 = v23[5].f32[1];
  v50 = v23[9].f32[0];
  v51 = v23[9].f32[1];
  v52 = v23[1].f32[0];
  v53 = v23[1].f32[1];
  v54 = v48 + v50;
  v55 = v48 - v50;
  v56 = v52 + v54;
  v57 = v52 - (v54 * 0.5);
  v58 = (&v75 + v9 * 4);
  v59 = v55 * -0.86603;
  v60 = (v49 - v51) * -0.86603;
  v58[6] = v56;
  v58[7] = v53 + (v49 + v51);
  v61 = v53 - ((v49 + v51) * 0.5);
  v58[8] = v59 + v61;
  v58[9] = v60 - v57;
  v58[10] = -(v57 + v60);
  v58[11] = v59 - v61;
  do
  {
    v62 = &result[v47 / 2];
    v63 = *(v78 + v47 * 4 + 8);
    v64 = *(v78 + v47 * 4 + 12);
    v65 = v75.f32[v47] + v63;
    v66 = v79.f32[v47];
    v67 = v79.f32[v47 + 1];
    v68 = v77.f32[v47] + v66;
    v69 = v75.f32[v47 + 1] + v64;
    v70 = v77.f32[v47 + 1] + v67;
    *v62 = v65 + v68;
    v62[1] = v69 + v70;
    v71 = v65 - (v63 * 2.0);
    v72 = v69 - (v64 * 2.0);
    v62[12] = v65 - v68;
    v62[13] = v69 - v70;
    v73 = v68 - (v66 * 2.0);
    v74 = v70 - (v67 * 2.0);
    v62[6] = v71 + v74;
    v62[7] = v72 - v73;
    v62[18] = v71 - v74;
    v62[19] = v73 + v72;
    v47 += 2;
  }

  while ((v47 * 4) != 24);
  return result;
}

uint64_t dit_fft(uint64_t result, int a2)
{
  v2 = (1 << a2);
  HIDWORD(v4) = v2 - 64;
  LODWORD(v4) = v2 - 64;
  v3 = v4 >> 6;
  if (v3 > 2)
  {
    if (v3 == 3)
    {
      v82 = 0;
      v83 = result + 1024;
      v84 = &scramble(float *,int)::bits;
      v85 = 6;
      v31 = 1980;
      v32 = 1916;
      v33 = 1976;
      v34 = 1912;
      do
      {
        v86 = 0;
        v87 = v85;
        v88 = *v84;
        v89 = 4 * v82;
        do
        {
          if ((v88 & 2) != 0)
          {
            v90 = v89 + v86;
            v91 = *(result + 4 * (v89 + v86 + 2));
            v92 = (scramble(float *,int)::bitreverse[v82 >> 4] & 0xFE) + 16 * scramble(float *,int)::bitreverse[v82 & 0xF];
            *(result + 4 * (v89 + v86 + 2)) = *(v83 + 4 * v92);
            *(v83 + 4 * v92) = v91;
            v93 = v89 + v86 + 3;
            v94 = *(result + 4 * v93);
            v95 = (result + 4 * v92);
            *(result + 4 * v93) = v95[257];
            v95[257] = v94;
            if (v88)
            {
              v96 = *(result + 4 * v90);
              *(result + 4 * v90) = *v95;
              v97 = v90 + 1;
              v98 = *(result + 4 * v97);
              v99 = v92 | 1;
              v100 = *(result + 4 * v99);
              *v95 = v96;
              *(result + 4 * v97) = v100;
              *(result + 4 * v99) = v98;
            }
          }

          v88 >>= 2;
          ++v82;
          v86 += 4;
        }

        while (v86 != 64);
        ++v84;
        v85 = v87 - 1;
      }

      while (v87);
      goto LABEL_45;
    }

    if (v3 == 7)
    {
      v49 = 0;
      v50 = &scramble(float *,int)::bits;
      v51 = result + 2048;
      v52 = 13;
      v31 = 4028;
      v32 = 3836;
      v33 = 4024;
      v34 = 3832;
      v35 = 3900;
      v36 = 3708;
      v37 = 3896;
      v38 = 3704;
      do
      {
        v53 = 0;
        v54 = v52;
        v55 = *v50 | (*v50 << 16);
        v56 = 4 * v49;
        do
        {
          if ((v55 & 2) != 0)
          {
            v57 = v56 + v53;
            v58 = *(result + 4 * (v56 + v53 + 2));
            v59 = 32 * scramble(float *,int)::bitreverse[v49 & 0xF] + 2 * scramble(float *,int)::bitreverse[v49 >> 4];
            *(result + 4 * (v56 + v53 + 2)) = *(v51 + 4 * v59);
            *(v51 + 4 * v59) = v58;
            v60 = v56 + v53 + 3;
            v61 = *(result + 4 * v60);
            v62 = (result + 4 * v59);
            *(result + 4 * v60) = v62[513];
            v62[513] = v61;
            if (v55)
            {
              v63 = *(result + 4 * v57);
              *(result + 4 * v57) = *v62;
              v64 = v57 + 1;
              v65 = *(result + 4 * v64);
              v66 = v59 | 1;
              v67 = *(result + 4 * v66);
              *v62 = v63;
              *(result + 4 * v64) = v67;
              *(result + 4 * v66) = v65;
            }
          }

          v55 >>= 2;
          ++v49;
          v53 += 4;
        }

        while (v53 != 64);
        ++v50;
        v52 = v54 - 1;
      }

      while (v54);
      goto LABEL_26;
    }
  }

  else
  {
    if (!v3)
    {
      v76 = -28;
      v77 = &byte_19B3C6B47;
      do
      {
        v78 = *(v77 - 1);
        v79 = *v77;
        v77 -= 2;
        v80 = *(result + 8 * v78);
        *(result + 8 * v78) = *(result + 8 * v79);
        *(result + 8 * v79) = v80;
      }

      while (!__CFADD__(v76++, 1));
      goto LABEL_46;
    }

    if (v3 == 1)
    {
      v5 = 0;
      v6 = 0;
      v7 = result + 512;
      v8 = 1;
      do
      {
        v9 = 0;
        v10 = v8;
        v11 = scramble(float *,int)::bits[v5];
        v12 = v6;
        v13 = 4 * v6;
        do
        {
          v14 = v13 + v9;
          v15 = *(result + 4 * (v13 + v9 + 2));
          v16 = ((scramble(float *,int)::bitreverse[v6 >> 4] >> 1) & 0x7E) + 8 * scramble(float *,int)::bitreverse[v6 & 0xF];
          *(result + 4 * (v13 + v9 + 2)) = *(v7 + 4 * v16);
          *(v7 + 4 * v16) = v15;
          v17 = v13 + v9 + 3;
          v18 = *(result + 4 * v17);
          v19 = (result + 4 * v16);
          *(result + 4 * v17) = v19[129];
          v19[129] = v18;
          if (v11)
          {
            v20 = *(result + 4 * v14);
            *(result + 4 * v14) = *v19;
            v21 = v14 + 1;
            v22 = *(result + 4 * v21);
            v23 = v16 | 1;
            v24 = *(result + 4 * v23);
            *v19 = v20;
            *(result + 4 * v21) = v24;
            *(result + 4 * v23) = v22;
          }

          v11 >>= 2;
          v9 += 4;
          ++v6;
        }

        while (v9 != 64);
        v8 = 0;
        v5 = 1;
      }

      while ((v10 & 1) != 0);
      v25 = 0;
      v26 = v12 + 16;
      v27 = result + 516;
      v28 = 4 * v12;
      v29 = v12 + 17;
      v30 = -2004309848;
      v31 = 988;
      v32 = 892;
      v33 = 984;
      v34 = 888;
      v35 = 924;
      v36 = 828;
      v37 = 920;
      v38 = 824;
      do
      {
        if ((v30 & 2) != 0)
        {
          v39 = v28 + v25 + 66;
          v40 = *(result + 4 * v39);
          v41 = ((scramble(float *,int)::bitreverse[v26 >> 4] >> 1) & 0x7E) + 8 * scramble(float *,int)::bitreverse[v26 & 0xF];
          *(result + 4 * v39) = *(v7 + 4 * v41);
          *(v7 + 4 * v41) = v40;
          v42 = v28 + v25 + 67;
          v43 = *(result + 4 * v42);
          *(result + 4 * v42) = *(v27 + 4 * v41);
          *(v27 + 4 * v41) = v43;
        }

        if ((v30 & 8) != 0)
        {
          v44 = v28 + v25 + 70;
          v45 = *(result + 4 * v44);
          v46 = ((scramble(float *,int)::bitreverse[v29 >> 4] >> 1) & 0x7E) + 8 * scramble(float *,int)::bitreverse[v29 & 0xF];
          *(result + 4 * v44) = *(v7 + 4 * v46);
          *(v7 + 4 * v46) = v45;
          v47 = v28 + v25 + 71;
          v48 = *(result + 4 * v47);
          *(result + 4 * v47) = *(v27 + 4 * v46);
          *(v27 + 4 * v46) = v48;
        }

        v30 >>= 4;
        v26 += 2;
        v25 += 8;
        v29 += 2;
      }

      while (v25 != 64);
LABEL_26:
      v68 = *(result + v38);
      *(result + v38) = *(result + v37);
      *(result + v37) = v68;
      v69 = *(result + v36);
      *(result + v36) = *(result + v35);
      *(result + v35) = v69;
LABEL_45:
      v101 = *(result + v34);
      *(result + v34) = *(result + v33);
      *(result + v33) = v101;
      v102 = *(result + v32);
      *(result + v32) = *(result + v31);
      *(result + v31) = v102;
      goto LABEL_46;
    }
  }

  v70 = 0;
  v71 = 1;
  do
  {
    v72 = 1 << a2;
    do
    {
      v73 = v70;
      v70 ^= v72 >> 1;
      v72 >>= 1;
    }

    while ((v72 & ~v73) == 0);
    if (v71 < v70)
    {
      v74 = 8 * v70;
      v75 = *(result + 8 * v71);
      *(result + 8 * v71) = *(result + v74);
      *(result + v74) = v75;
    }

    ++v71;
  }

  while (v71 != v2 - 1);
LABEL_46:
  v103 = 0;
  v104 = (result + 16);
  do
  {
    v105 = *(v104 - 2);
    v106 = *(v104 - 1);
    v107 = *(v104 - 4) + v105;
    v108 = v104[2];
    v109 = v104[3];
    v110 = *v104 + v108;
    v111 = *(v104 - 3) + v106;
    v112 = v104[1] + v109;
    *(v104 - 4) = v107 + v110;
    *(v104 - 3) = v111 + v112;
    *v104 = v107 - v110;
    v104[1] = v111 - v112;
    v113 = v107 + (v105 * -2.0);
    v114 = v110 + (v108 * -2.0);
    v115 = v111 + (v106 * -2.0);
    v116 = v112 + (v109 * -2.0);
    *(v104 - 2) = v113 + v116;
    *(v104 - 1) = v115 - v114;
    v104[2] = v113 - v116;
    v104[3] = v114 + v115;
    v103 += 8;
    v104 += 8;
  }

  while (v103 < (2 << a2));
  v117 = 3;
  do
  {
    if (v117 == 12)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "void dit_fft(FLOAT *, const INT, const FLOAT_SPK *, const INT)";
      exception[2] = 84;
    }

    v118 = 0;
    v119 = 0;
    v120 = (1 << v117);
    v121 = v120 >> 1;
    v122 = 2 * v120;
    do
    {
      v123 = v120 + v118 + 1;
      v124 = *(result + 4 * v123);
      v125 = *(result + 4 * (v120 + v118));
      v126 = *(result + 4 * v118);
      v127 = *(result + 4 * (v118 + 1));
      *(result + 4 * v118) = v125 + v126;
      *(result + 4 * (v118 + 1)) = v124 + v127;
      *(result + 4 * (v120 + v118)) = v126 - v125;
      *(result + 4 * v123) = v127 - v124;
      v128 = (result + 4 * ((v120 >> 1) + v120 + v118));
      v130 = *v128;
      v129 = v128[1];
      v131 = (result + 4 * (v121 + v118));
      v132 = *v131;
      v133 = v131[1];
      v134 = v133 - *v128;
      *v131 = v129 + *v131;
      v131[1] = v134;
      *v128 = v132 - v129;
      v128[1] = v130 + v133;
      v119 += v120;
      v118 += v122;
    }

    while (v119 < v2);
    v135 = v121 >> 2;
    if (v121 >= 8)
    {
      v136 = 0;
      if (v121 >> 2 <= 2)
      {
        v137 = 2;
      }

      else
      {
        v137 = v135;
      }

      v138 = (v121 & 0xFFFFFFFE) - 2;
      v139 = v138 + v121;
      v140 = v138 + v121 + v120;
      v141 = (v121 & 0xFFFFFFFE) - 1;
      v142 = v141 + v120;
      v143 = v138 + v120;
      v144 = v121 + 2;
      v145 = v121 + 2 + v120;
      v146 = 1 << v117;
      v147 = 1;
      do
      {
        v148 = 0;
        v149 = 0;
        v150 = (&SineTable512 + 8 * v147 * (0x800u >> v117));
        v151 = *v150;
        v152 = v150[1];
        v153 = -v152;
        do
        {
          v154 = v136 + v148 + 2;
          v155 = v146 + v148 + 3;
          v156 = *(result + 4 * v155);
          v157 = v146 + v148 + 2;
          v158 = *(result + 4 * v157);
          v159 = (v158 * v153) + (v156 * v151);
          v160 = (v158 * v151) + (v156 * v152);
          v161 = *(result + 4 * v154);
          v162 = v136 + v148 + 3;
          v163 = *(result + 4 * v162);
          *(result + 4 * v154) = v161 + v160;
          *(result + 4 * v162) = v163 + v159;
          *(result + 4 * v157) = v161 - v160;
          *(result + 4 * v155) = v163 - v159;
          v164 = (result + 4 * (v145 + v148));
          v165 = v164[1];
          v166 = (*v164 * v153) + (v165 * v151);
          v167 = (*v164 * v151) + (v165 * v152);
          v168 = (result + 4 * (v144 + v148));
          v169 = v168[1];
          v170 = *v168 - v166;
          *v168 = *v168 + v166;
          v168[1] = v169 - v167;
          *v164 = v170;
          v164[1] = v169 + v167;
          v171 = *(result + 4 * (v143 + v148));
          v172 = *(result + 4 * (v142 + v148));
          v173 = (v172 * v153) + (v171 * v151);
          v174 = (v172 * v151) + (v171 * v152);
          v175 = *(result + 4 * (v138 + v148));
          v176 = *(result + 4 * (v141 + v148));
          *(result + 4 * (v138 + v148)) = v175 + v174;
          *(result + 4 * (v141 + v148)) = v176 - v173;
          *(result + 4 * (v143 + v148)) = v175 - v174;
          *(result + 4 * (v142 + v148)) = v176 + v173;
          v177 = (result + 4 * (v140 + v148));
          v178 = v177[1];
          v179 = (v178 * v153) + (*v177 * v151);
          v180 = (v178 * v151) + (*v177 * v152);
          v181 = (result + 4 * (v139 + v148));
          v182 = v181[1];
          v183 = *v181 + v179;
          *v181 = *v181 - v179;
          v181[1] = v182 - v180;
          *v177 = v183;
          v177[1] = v182 + v180;
          v149 += v120;
          v148 += v122;
        }

        while (v149 < v2);
        ++v147;
        v139 -= 2;
        v140 -= 2;
        v141 -= 2;
        v138 -= 2;
        v142 -= 2;
        v143 -= 2;
        v144 += 2;
        v145 += 2;
        v136 += 2;
        v146 += 2;
      }

      while (v147 != v137);
    }

    v184 = 0;
    v185 = 2 * v135;
    v186 = v121 + 2 * v135;
    do
    {
      v187 = v120 + v185 + 1;
      v188 = *(result + 4 * v187);
      v189 = *(result + 4 * (v120 + v185));
      v190 = (v189 * -0.70711) + (v188 * 0.70711);
      v191 = (v189 * 0.70711) + (v188 * 0.70711);
      v192 = *(result + 4 * v185);
      v193 = *(result + 4 * (v185 + 1));
      *(result + 4 * v185) = v192 + v191;
      *(result + 4 * (v185 + 1)) = v193 + v190;
      *(result + 4 * (v120 + v185)) = v192 - v191;
      *(result + 4 * v187) = v193 - v190;
      v194 = (result + 4 * (v120 + v186));
      v195 = v194[1];
      v196 = (*v194 * -0.70711) + (v195 * 0.70711);
      v197 = (*v194 * 0.70711) + (v195 * 0.70711);
      v198 = (result + 4 * v186);
      v199 = *v198;
      v200 = v198[1];
      *v198 = *v198 + v196;
      v198[1] = v200 - v197;
      *v194 = v199 - v196;
      v194[1] = v200 + v197;
      v184 += v120;
      v186 += v122;
      v185 += v122;
    }

    while (v184 < v2);
  }

  while (v117++ != a2);
  return result;
}

void *qmfAnalysisFilteringSlot(uint64_t a1, float *a2, float *a3, float *a4, float *a5)
{
  v6 = a2;
  v8 = *(a1 + 40);
  v9 = *(a1 + 8);
  v10 = 9 * v8;
  if (v8 >= 2)
  {
    v11 = v8 >> 1;
    v12 = &v9[v10];
    do
    {
      *v12 = *a4;
      v12[1] = a4[1];
      v12 += 2;
      a4 += 2;
      --v11;
    }

    while (v11);
  }

  v13 = *(a1 + 64);
  if ((v13 & 2) != 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void qmfAnalysisFilteringSlot(HANDLE_QMF_FILTER_BANK, FLOAT *, FLOAT *, const FLOAT *, const int, FLOAT *)";
    v69 = 222;
    goto LABEL_28;
  }

  v14 = 2 * v8;
  if (v8 >= 1)
  {
    v15 = *a1;
    v16 = &v9[(10 * v8) - 1];
    v17 = 20 * *(a1 + 68);
    v18 = v14;
    v19 = &a5[v14 - 1];
    v20 = 8 * v8 - 8;
    v21 = (32 * (v20 >> 3)) | 0x1C;
    v22 = (4 * v20) ^ 0xFFFFFFFFFFFFFFE4;
    v23 = v8;
    v24 = a5;
    do
    {
      v25 = *v15 * *v16;
      v26 = &v16[-v14];
      v27 = v25 + (v15[1] * *v26);
      v28 = &v26[-v14];
      v29 = v27 + (v15[2] * *v28);
      v30 = &v28[-v14];
      v31 = v29 + (v15[3] * *v30);
      v32 = &v30[-v14];
      *v24++ = v31 + (v15[4] * *v32);
      v15 = (v15 + v17);
      v33 = *v15 * *v9;
      v34 = &v9[v18];
      v35 = v33 + (v15[1] * *v34);
      v36 = &v34[v18];
      v37 = v35 + (v15[2] * *v36);
      v38 = &v36[v18];
      v39 = v37 + (v15[3] * *v38);
      v40 = &v38[v18];
      *v19-- = v39 + (v15[4] * *v40);
      v16 = (v32 + v21);
      v9 = (v40 + v22);
      --v23;
    }

    while (v23);
  }

  if (v13)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void qmfAnalysisFilteringSlot(HANDLE_QMF_FILTER_BANK, FLOAT *, FLOAT *, const FLOAT *, const int, FLOAT *)";
    v69 = 234;
LABEL_28:
    exception[2] = v69;
  }

  if (v8 == 64)
  {
    if ((v13 & 0x14) == 0)
    {
      v41 = 0;
      v43 = *a5;
      v42 = a5[1];
      *a2 = v42 + *a5;
      *a3 = v42 - v43;
      v44 = &a5[v14 - 1];
      do
      {
        v45 = a5[v41 + 2];
        v46 = *v44--;
        a2[v41 + 1] = v45 - v46;
        a3[++v41] = v45 + v46;
      }

      while (v41 != 63);
      goto LABEL_17;
    }
  }

  else if (v8 < 1)
  {
    goto LABEL_17;
  }

  v47 = 0;
  v48 = v14 - 2;
  v49 = a5 + 1;
  v50 = a2 + 1;
  v51 = a3 + 1;
  do
  {
    v52 = *(v49 - 1);
    v53 = *v49;
    v54 = a5[v48 + 1];
    v55 = a5[v48];
    v56 = *v49 - v55;
    *(v50 - 1) = v52 - v54;
    *v50 = v56;
    v47 += 2;
    v49 += 2;
    *(v51 - 1) = v52 + v54;
    *v51 = v53 + v55;
    v50 += 2;
    v48 -= 2;
    v51 += 2;
  }

  while (v47 < v8);
LABEL_17:
  dct_IV(a2, v8);
  dst_IV(a3, v8);
  if (v8 == 64)
  {
    if ((*(a1 + 64) & 0x14) == 0)
    {
      goto LABEL_23;
    }
  }

  else if (v8 < 1)
  {
    goto LABEL_23;
  }

  v57 = *(a1 + 24);
  v58 = *(a1 + 32);
  do
  {
    v59 = *a3;
    v60 = *v6;
    v61 = *v57++;
    v62 = v61;
    v63 = *v58++;
    *a3 = (*a3 * v62) - (*v6 * v63);
    v64 = (v60 * v62) + (v59 * v63);
    *v6 = v64;
    *v6++ = v64 * *(a1 + 56);
    *a3 = *(a1 + 56) * *a3;
    ++a3;
    --v8;
  }

  while (v8);
LABEL_23:
  v65 = *(a1 + 8);
  v66 = &v65[4 * *(a1 + 40)];

  return memmove(v65, v66, (4 * v10));
}

void dct_IV(float *a1, int a2)
{
  v47 = 0;
  v46 = 0xAAAAAAAAAAAAAAAALL;
  if (a2 <= 3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void dct_IV(FLOAT *, int)";
    exception[2] = 278;
  }

  v4 = a2 >> 1;
  v45 = 0xAAAAAAAAAAAAAAAALL;
  dct_getTables(&v46, &v45, &v47, a2);
  v13 = &a1[a2];
  if (v4 < 2)
  {
    v23 = 0;
    v16 = &a1[a2];
    v17 = a1;
  }

  else
  {
    v14 = 0;
    v15 = (v46 + 8);
    v16 = &a1[a2];
    v17 = a1;
    do
    {
      v18 = *(v16 - 2);
      v19 = *(v16 - 1);
      v16 -= 2;
      v20 = v17[1];
      v21 = *(v15 - 2);
      v22 = *(v15 - 1);
      v11.f32[0] = (v19 * v21) - (v22 * *v17);
      *&v6 = (*v17 * v21) + (v19 * v22);
      *&v7 = *v15;
      *&v9 = v15[1];
      v15 += 4;
      *&v10 = -(*&v9 * v20);
      v8.f32[0] = (v20 * *&v7) + (v18 * *&v9);
      *v17 = *&v6;
      v17[1] = v11.f32[0];
      v17 += 2;
      *&v5 = -(*&v10 + (v18 * *&v7));
      *v16 = v8.f32[0];
      v16[1] = *&v5;
      v14 += 2;
    }

    while (v14 < (v4 - 1));
    v23 = v14 & 0xFFFFFFFE;
  }

  v24 = v13 - 2;
  if ((a2 & 2) != 0)
  {
    v25 = *(v16 - 1);
    v26 = (v46 + 8 * v23);
    LODWORD(v7) = *v26;
    v8.i32[0] = v26[1];
    *&v9 = (v25 * *v26) - (v8.f32[0] * *v17);
    *&v6 = *v17 * *v26;
    *&v5 = *&v6 + (v25 * v8.f32[0]);
    *v17 = *&v5;
    v17[1] = *&v9;
  }

  fft(v4, a1, v5, v6, v7, v8, v9, v10, v11, v12);
  v27 = *(v13 - 2);
  v28 = *(v13 - 1);
  *(v13 - 1) = -a1[1];
  if (v4 < 3)
  {
    v32 = v13 - 2;
    if ((a2 & 2) == 0)
    {
LABEL_13:
      v42 = v27 * 0.70711;
      v43 = v28 * 0.70711;
      *v32 = v42 + v43;
      a1[1] = v42 - v43;
    }
  }

  else
  {
    v29 = 8 * v47;
    v30 = (v45 + v29);
    v31 = ((v4 + 1) >> 1) - 1;
    v32 = v13 - 2;
    do
    {
      v33 = *v30;
      v34 = v30[1];
      v35 = (v27 * *v30) - (v34 * v28);
      v36 = (v28 * *v30) + (v27 * v34);
      a1[1] = v35;
      *v24 = v36;
      v37 = a1[2];
      v38 = a1[3];
      a1 += 2;
      v39 = *(v32 - 2);
      v32 -= 2;
      v27 = v39;
      v40 = -(v34 * v37);
      v41 = (v37 * v33) + (v38 * v34);
      v28 = *(v24 - 1);
      *(v24 - 1) = -(v40 + (v38 * v33));
      *a1 = v41;
      v30 = (v30 + v29);
      v24 = v32;
      --v31;
    }

    while (v31);
    if ((a2 & 2) == 0)
    {
      goto LABEL_13;
    }
  }
}

float dst_IV(float *a1, int a2)
{
  v43 = 0;
  v42 = 0xAAAAAAAAAAAAAAAALL;
  if (a2 <= 3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void dst_IV(FLOAT *, int)";
    exception[2] = 377;
  }

  v4 = a2 >> 1;
  v41 = 0xAAAAAAAAAAAAAAAALL;
  dct_getTables(&v42, &v41, &v43, a2);
  v13 = &a1[a2];
  if (v4 < 2)
  {
    v24 = 0;
    v16 = &a1[a2];
    v17 = a1;
  }

  else
  {
    v14 = 0;
    v15 = (v42 + 8);
    v16 = &a1[a2];
    v17 = a1;
    do
    {
      v18 = *(v16 - 2);
      v19 = *(v16 - 1);
      v16 -= 2;
      v20 = v17[1];
      *&v9 = -v18;
      v21 = *(v15 - 2);
      v22 = *(v15 - 1);
      v12.f32[0] = (*v17 * v22) + (v19 * v21);
      v23 = (v19 * v22) - (*v17 * v21);
      *&v7 = *v15;
      *&v10 = v15[1];
      v15 += 4;
      v11.f32[0] = -(*&v10 * v20);
      v8.f32[0] = v20 * *&v7;
      *&v5 = v8.f32[0] - (v18 * *&v10);
      *v17 = v23;
      v17[1] = v12.f32[0];
      v17 += 2;
      *&v6 = -(v11.f32[0] + (*&v9 * *&v7));
      *v16 = *&v5;
      v16[1] = *&v6;
      v14 += 2;
    }

    while (v14 < (v4 - 1));
    v24 = v14 & 0xFFFFFFFE;
  }

  v25 = v13 - 2;
  if ((a2 & 2) != 0)
  {
    v26 = *(v16 - 1);
    v27 = (v42 + 8 * v24);
    LODWORD(v7) = *v27;
    v8.i32[0] = v27[1];
    *&v9 = (*v17 * v8.f32[0]) + (v26 * *v27);
    *&v6 = -(*v17 * *v27);
    *&v5 = (v26 * v8.f32[0]) - (*v17 * *v27);
    *v17 = *&v5;
    v17[1] = *&v9;
  }

  fft(v4, a1, v5, v6, v7, v8, v9, v10, v11, v12);
  result = *(v13 - 2);
  v29 = *(v13 - 1);
  *(v13 - 1) = -*a1;
  *a1 = a1[1];
  if (v4 >= 3)
  {
    v30 = 8 * v43;
    v31 = (v41 + v30);
    v32 = ((v4 + 1) >> 1) - 1;
    do
    {
      v33 = *v31;
      v34 = v31[1];
      v35 = -(v34 * v29);
      v36 = v29 * *v31;
      *v25 = -(v35 + (result * *v31));
      v37 = a1[2];
      a1 += 2;
      *(a1 - 1) = -(v36 + (result * v34));
      v38 = a1[1];
      result = *(v25 - 2);
      v29 = *(v25 - 1);
      v25 -= 2;
      *a1 = (v38 * v33) - (v34 * v37);
      v25[1] = -((v37 * v33) + (v38 * v34));
      v31 = (v31 + v30);
      --v32;
    }

    while (v32);
  }

  if ((a2 & 2) == 0)
  {
    v39 = v29 * 0.70711;
    a1[1] = -(result * 0.70711) - v39;
    result = v39 - (result * 0.70711);
    *v25 = result;
  }

  return result;
}

void *dct_getTables(void *result, void *a2, _DWORD *a3, int a4)
{
  v4 = 0;
  if ((a4 & 0x80000000) == 0)
  {
    v5 = ~a4;
    do
    {
      ++v4;
      v5 *= 2;
    }

    while (v5 < 0);
  }

  v6 = 29 - v4;
  v7 = a4 >> (29 - v4);
  if (v7 == 4)
  {
    v8 = &windowSlopes;
    v9 = -20;
    v10 = &SineTable1024;
  }

  else
  {
    v6 = 30 - v4;
    if (v7 == 5)
    {
      v8 = &unk_1E7531E18;
      v9 = -26;
      v10 = &SineTable20;
    }

    else
    {
      if (v7 != 6)
      {
        *a2 = 0;
        *a3 = 0;
        if (!result)
        {
          goto LABEL_16;
        }

        goto LABEL_17;
      }

      v8 = &unk_1E7531DD0;
      v9 = -22;
      v10 = &SineTable384;
    }
  }

  *a2 = v10;
  v11 = v4 + v9;
  *a3 = 1 << v11;
  if (!result)
  {
    goto LABEL_13;
  }

  v12 = v8[v6];
  if (!v12)
  {
LABEL_17:
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void dct_getTables(const FLOAT_SPK **, const FLOAT_SPK **, int *, int)";
    v14 = 68;
LABEL_18:
    exception[2] = v14;
  }

  *result = v12;
LABEL_13:
  if (v11 == 31)
  {
LABEL_16:
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void dct_getTables(const FLOAT_SPK **, const FLOAT_SPK **, int *, int)";
    v14 = 72;
    goto LABEL_18;
  }

  return result;
}

uint64_t CDK_QmfDomain_GetSlot(uint64_t result, int a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6)
{
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void CDK_QmfDomain_GetSlot(const HANDLE_CDK_QMF_DOMAIN_IN, const int, const int, const int, FLOAT *, FLOAT *)";
    v25 = 486;
    goto LABEL_25;
  }

  if (!a5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void CDK_QmfDomain_GetSlot(const HANDLE_CDK_QMF_DOMAIN_IN, const int, const int, const int, FLOAT *, FLOAT *)";
    v25 = 487;
    goto LABEL_25;
  }

  if (*(*result + 72) + *(*result + 70) <= a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void CDK_QmfDomain_GetSlot(const HANDLE_CDK_QMF_DOMAIN_IN, const int, const int, const int, FLOAT *, FLOAT *)";
    v25 = 497;
    goto LABEL_25;
  }

  if (*(*result + 74) < a4)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void CDK_QmfDomain_GetSlot(const HANDLE_CDK_QMF_DOMAIN_IN, const int, const int, const int, FLOAT *, FLOAT *)";
    v25 = 499;
LABEL_25:
    exception[2] = v25;
  }

  v6 = *(*(result + 112) + 8 * a2);
  v7 = *(*(result + 120) + 8 * a2);
  v9 = *(result + 56);
  v8 = *(result + 60);
  if (v9 >= a4)
  {
    v9 = a4;
  }

  if (v9 > a3)
  {
    v10 = (a6 + 4 * a3);
    v11 = (v7 + 4 * a3);
    v12 = (a5 + 4 * a3);
    v13 = (v6 + 4 * a3);
    do
    {
      v14 = *v13++;
      *v12++ = v14;
      v15 = *v11++;
      *v10++ = v15;
      ++a3;
    }

    while (v9 > a3);
    a3 = v9;
  }

  if (v8 >= a4)
  {
    v8 = a4;
  }

  if (a3 < v8)
  {
    v16 = (a6 + 4 * a3);
    v17 = (v7 + 4 * a3);
    v18 = (a5 + 4 * a3);
    v19 = (v6 + 4 * a3);
    do
    {
      v20 = *v19++;
      *v18++ = v20;
      v21 = *v17++;
      *v16++ = v21;
      ++a3;
    }

    while (v8 > a3);
    a3 = v8;
  }

  if (a3 < a4)
  {
    v22 = (a6 + 4 * a3);
    v23 = (a5 + 4 * a3);
    do
    {
      *v23++ = 0;
      *v22++ = 0;
      ++a3;
    }

    while (a3 < a4);
  }

  return result;
}

void *CDK_QmfDomain_SaveOverlap(void *result)
{
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void CDK_QmfDomain_SaveOverlap(HANDLE_CDK_QMF_DOMAIN_IN, int)";
    exception[2] = 451;
  }

  v1 = *(*result + 72);
  v2 = *(*result + 70);
  v3 = *(*result + 74);
  v4 = result[14];
  v5 = result[15];
  if (v5)
  {
    if (*(*result + 72))
    {
      v6 = (4 * v3);
      do
      {
        CDKmemcpy(*v4, v4[v2], v6);
        result = CDKmemcpy(*v5, v5[v2], v6);
        ++v5;
        ++v4;
        --v1;
      }

      while (v1);
    }
  }

  else if (*(*result + 72))
  {
    v7 = (4 * v3);
    do
    {
      result = CDKmemcpy(*v4, v4[v2], v7);
      ++v4;
      --v1;
    }

    while (v1);
  }

  return result;
}

float wrapPhase(float result)
{
    ;
  }

    ;
  }

  if (result < 0.0 || result >= 6.2832)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "FLOAT wrapPhase(FLOAT)";
    exception[2] = 424;
  }

  return result;
}

uint64_t param2UMX_Prediction__CDK(uint64_t result, uint64_t a2, float *a3, uint64_t a4, uint64_t a5, float *a6, uint64_t a7, int a8, unsigned int a9)
{
  v9 = *(result + 384);
  if (v9 >= 1)
  {
    v10 = 0;
    v11 = *(**(result + 488) + 8 * a8);
    v12 = *(**(result + 496) + 8 * a8);
    v13 = *(**(result + 520) + 8 * a8);
    v14 = *(result + 976);
    result = 1054168405;
    v15 = a3;
    v16 = a6;
    do
    {
      v17 = *(v11 + v10);
      v18 = *(v12 + v10);
      v19 = *(v13 + v10);
      if (a3)
      {
        v20 = v15;
      }

      else
      {
        v20 = 0;
      }

      if (a6)
      {
        v21 = v16;
      }

      else
      {
        v21 = 0;
      }

      if (v17 == 15 && v18 == 0 && v19 == 8 && v10 < v14)
      {
        *(a2 + 4 * v10) = 1054168405;
        if (v10 >= a9)
        {
          v36 = -0.41667;
        }

        else
        {
          v36 = 0.41667;
        }

        *(a5 + 4 * v10) = v36;
        if (v10 >= a9)
        {
          v37 = 0.0;
        }

        else
        {
          v37 = 0.41667;
        }

        if (v10 >= a9)
        {
          v38 = 0.0;
        }

        else
        {
          v38 = -0.41667;
        }

        *(a4 + 4 * v10) = v37;
        *(a7 + 4 * v10) = v38;
        if (v20 && v21)
        {
          *v20 = 0.0;
          *v21 = 0.0;
        }
      }

      else
      {
        v25 = sqrt_CLD_m[v17];
        v26 = (v25 * v25) + 1.0;
        v27 = dequantICC__CDK[v18];
        v28 = (v25 * v27) + (v25 * v27);
        if (v10 >= v14)
        {
          v29 = 0;
        }

        else
        {
          v29 = v19;
        }

        v30 = sinIpd_tab[v29];
        v31 = v26 + (v28 * sinIpd_tab[(v29 + 4) & 0xF]);
        v32 = sqrtf(v26 / v31);
        if (v32 > 1.2)
        {
          v32 = 1.2;
        }

        v33 = 0.5 / v32;
        v34 = (1.0 - (v25 * v25)) / v31;
        *(a2 + 4 * v10) = v33 - (v34 * v33);
        *(a5 + 4 * v10) = v33 + (v34 * v33);
        if (v20 && v21)
        {
          v35 = -(v28 * v30) / v31;
          *v20 = -(v35 * v33);
          *v21 = v35 * v33;
        }

        if (v10 >= a9)
        {
          v33 = (v33 * ((v25 + v25) * sqrtf(1.0 - (v27 * v27)))) / v31;
        }

        *(a4 + 4 * v10) = v33;
        *(a7 + 4 * v10) = -v33;
      }

      ++v10;
      ++v16;
      ++v15;
    }

    while (v10 < v9);
  }

  return result;
}

uint64_t mapIndexData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8, size_t __len, int a10, uint64_t a11, int a12, int a13, _DWORD *a14)
{
  v14 = a10;
  v112 = *MEMORY[0x1E69E9840];
  v111 = -1431655766;
  *&v15 = 0xAAAAAAAAAAAAAAAALL;
  *(&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v110[0] = v15;
  v110[1] = v15;
  v109 = -1431655766;
  v108[0] = v15;
  v108[1] = v15;
  v107 = -1431655766;
  v105 = v15;
  v106 = v15;
  v103 = v15;
  v104 = v15;
  v101 = v15;
  v102 = v15;
  *v100 = v15;
  if (a10 > 9)
  {
    return 4294966316;
  }

  v20 = a1;
  if (a10 >= 1)
  {
    v21 = 0;
    v22 = 0;
    do
    {
      if (*(a1 + v21) == 3)
      {
        *(v110 + v22++) = v21;
      }

      ++v21;
    }

    while (a10 != v21);
  }

  v23 = a6;
  if (a5)
  {
    v24 = *(a5 + 8 * a6);
    if (a14)
    {
      goto LABEL_10;
    }

LABEL_24:
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int SpatialDecConcealment_Apply(SpatialDecConcealmentInfo *, const SCHAR (*)[28], SCHAR **, SCHAR *, SCHAR *, const int, const int, const SCHAR, const int, const int)";
    v30 = 57;
    goto LABEL_133;
  }

  v24 = 0;
  if (!a14)
  {
    goto LABEL_24;
  }

LABEL_10:
  if (!a4)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int SpatialDecConcealment_Apply(SpatialDecConcealmentInfo *, const SCHAR (*)[28], SCHAR **, SCHAR *, SCHAR *, const int, const int, const SCHAR, const int, const int)";
    v30 = 58;
    goto LABEL_133;
  }

  v25 = *(a7 + 8 * a6);
  if (!v25)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int SpatialDecConcealment_Apply(SpatialDecConcealmentInfo *, const SCHAR (*)[28], SCHAR **, SCHAR *, SCHAR *, const int, const int, const SCHAR, const int, const int)";
    v30 = 59;
    goto LABEL_133;
  }

  if (!v20)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int SpatialDecConcealment_Apply(SpatialDecConcealmentInfo *, const SCHAR (*)[28], SCHAR **, SCHAR *, SCHAR *, const int, const int, const SCHAR, const int, const int)";
    v30 = 60;
    goto LABEL_133;
  }

  v26 = BYTE4(__len);
  v27 = a14[5];
  v97 = a5;
  if (v27 > 2)
  {
    switch(v27)
    {
      case 3:
        if (__len >= 1)
        {
          v36 = (a14[6] + 1) / (a14[2] + 1);
          v37 = __len;
          do
          {
            *v25 = (*v25 + (v36 * (SBYTE4(__len) - *v25)));
            ++v25;
            --v37;
          }

          while (v37);
        }

        break;
      case 5:
        if (__len >= 1)
        {
          v31 = (a14[7] + 1) / (a14[3] + 1);
          v32 = (252 * a6 + 28 * a10 + a4 - 28);
          v33 = __len;
          do
          {
            v34 = *v32++;
            *v25++ = (SBYTE4(__len) + (v31 * (v34 - SBYTE4(__len))));
            --v33;
          }

          while (v33);
        }

        break;
      case 4:
        if (__len >= 1)
        {
          v28 = a7;
          memset(v25, SBYTE4(__len), __len);
          a5 = v97;
          a7 = v28;
        }

        break;
      default:
LABEL_134:
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "int SpatialDecConcealment_Apply(SpatialDecConcealmentInfo *, const SCHAR (*)[28], SCHAR **, SCHAR *, SCHAR *, const int, const int, const SCHAR, const int, const int)";
        v30 = 113;
LABEL_133:
        exception[2] = v30;
    }

LABEL_33:
    v35 = 1;
    goto LABEL_34;
  }

  if (v27)
  {
    if (v27 == 1)
    {
      goto LABEL_45;
    }

    if (v27 != 2)
    {
      goto LABEL_134;
    }

    goto LABEL_33;
  }

  v35 = 0;
LABEL_34:
  if (a10 < 1)
  {
    goto LABEL_123;
  }

  v38 = 0;
  if (v24)
  {
    v39 = __len < 1;
  }

  else
  {
    v39 = 1;
  }

  v40 = v39;
  do
  {
    *(v20 + v38) = v35;
    if ((v40 & 1) == 0)
    {
      v41 = 0;
      do
      {
        *(*(v24 + 8 * v38) + v41++) = 0;
      }

      while (__len != v41);
    }

    ++v38;
  }

  while (v38 != a10);
LABEL_45:
  if (a10 >= 1)
  {
    v88 = a8;
    v89 = a2;
    v42 = 0;
    v43 = 0;
    v44 = v20 + 27;
    v91 = v20 + 9;
    v92 = v20 + 18;
    if (a5)
    {
      v45 = __len < 1;
    }

    else
    {
      v45 = 1;
    }

    v46 = v45;
    v95 = v20;
    v93 = v20 + 27;
    v94 = a7;
    v90 = v46;
    do
    {
      v47 = *(v20 + v42);
      if (!*(v20 + v42))
      {
        *(v44 + v42) = 0;
        if (__len >= 1)
        {
          v48 = 0;
          do
          {
            *(*(*(a3 + 8 * v23) + 8 * v42) + v48++) = v26;
          }

          while (__len != v48);
          v49 = 0;
          do
          {
            *(*(a7 + 8 * v23) + v49) = *(*(*(a3 + 8 * v23) + 8 * v42) + v49);
            ++v49;
          }

          while (__len != v49);
        }

        **(v20 + 40) = 0;
        v47 = *(v20 + v42);
      }

      if (v47 == 1)
      {
        if (__len < 1)
        {
          v47 = 1;
        }

        else
        {
          v50 = 0;
          do
          {
            *(*(*(a3 + 8 * v23) + 8 * v42) + v50) = *(*(a7 + 8 * v23) + v50);
            ++v50;
          }

          while (__len != v50);
          v47 = *(v20 + v42);
        }

        *(v44 + v42) = **(v20 + 40);
      }

      if (v47 == 2)
      {
        if (__len < 1)
        {
          v47 = 2;
        }

        else
        {
          v51 = 0;
          do
          {
            *(*(*(a3 + 8 * v23) + 8 * v42) + v51) = *(*(a7 + 8 * v23) + v51);
            ++v51;
          }

          while (__len != v51);
          v47 = *(v20 + v42);
        }

        *(v44 + v42) = **(v20 + 40);
        v52 = 1;
      }

      else
      {
        v52 = 0;
      }

      *(v108 + v42) = v52;
      if (v47 == 3)
      {
        v53 = *(v110 + v43);
        v98 = v43;
        v99 = v43;
        v54 = pbStrideTable[*(v92 + v43)];
        v55 = (__len - 1) / v54;
        createMapping(v100, __len, v54);
        if ((v55 & 0x80000000) == 0)
        {
          v56 = *(*(a3 + 8 * v23) + 8 * v53);
          v57 = (v55 + 1);
          v58 = v100[0];
          v59 = (a4 + 252 * v23 + 28 * v99 + v100[0]);
          v60 = &v100[1];
          do
          {
            v62 = *v60++;
            v61 = v62;
            if (v58 < v62)
            {
              memset((v56 + v58), *v59, (v61 + ~v58) + 1);
            }

            ++v59;
            v58 = v61;
            --v57;
          }

          while (v57);
        }

        v26 = BYTE4(__len);
        a7 = v94;
        a5 = v97;
        v46 = v90;
        if (__len >= 1)
        {
          v63 = 0;
          do
          {
            *(*(v94 + 8 * v23) + v63) = *(*(*(a3 + 8 * v23) + 8 * v53) + v63);
            ++v63;
          }

          while (__len != v63);
        }

        v64 = *(v91 + v99);
        v20 = v95;
        v14 = a10;
        **(v95 + 40) = v64;
        v44 = v93;
        *(v93 + v42) = v64;
        v43 = v98 + 1;
      }

      if ((v46 & 1) == 0)
      {
        v65 = 0;
        do
        {
          v66 = *(*(a3 + 8 * v23) + 8 * v42);
          *(v66 + v65) += *(*(*(a5 + 8 * v23) + 8 * v42) + v65);
          ++v65;
        }

        while (__len != v65);
      }

      ++v42;
    }

    while (v42 != v14);
    v67 = 0;
    a2 = v89;
    a8 = v88;
    do
    {
      if (*(v44 + v67) == 1)
      {
        coarse2fine(*(*(a3 + 8 * v23) + 8 * v67), v88, __len);
        *(v44 + v67) = 0;
      }

      ++v67;
    }

    while (v14 != v67);
    v68 = 0;
    v69 = 0;
    v70 = -1;
    v71 = v108;
    do
    {
      v72 = v71;
      v73 = v70;
      do
      {
        v74 = *v72++;
        ++v73;
      }

      while (v74 == 1);
      if (*(v108 + v68) == 1)
      {
        if (v73 >= v14)
        {
          return 4294966316;
        }

        if (__len >= 1)
        {
          v75 = 0;
          v76 = *(a11 + 4 * v69);
          v77 = *(a11 + 4 * v73);
          v78 = *(a11 + 4 * v68) - v76;
          do
          {
            v79 = *(a3 + 8 * v23);
            v80 = *(*(v79 + 8 * v69) + v75);
            if (v77 != v76)
            {
              v80 += (*(*(v79 + 8 * v73) + v75) - *(*(v79 + 8 * v69) + v75)) * v78 / (v77 - v76);
            }

            *(*(v79 + 8 * v68) + v75++) = v80;
          }

          while (__len != v75);
        }
      }

      else
      {
        v69 = v68;
      }

      ++v68;
      ++v70;
      v71 = (v71 + 4);
    }

    while (v68 != v14);
    if (!v88 && a13)
    {
      return 4294966320;
    }

    v81 = 0;
    do
    {
      if (__len >= 1)
      {
        v82 = 0;
        do
        {
          v83 = *(*(*(a3 + 8 * v23) + 8 * v81) + v82);
          if (v88 == 2)
          {
            LOBYTE(v83) = v83 & 0xF;
          }

          else
          {
            if (v88 == 1)
            {
              v84 = v83 >= 8;
            }

            else
            {
              v83 += 15;
              v84 = v83 >= 0x1F;
            }

            if (v84)
            {
              LOBYTE(v83) = -1;
            }
          }

          *(*(*(v89 + 8 * v23) + 8 * v81) + v82) = v83;
          v85 = *(*(v89 + 8 * v23) + 8 * v81);
          if (*(v85 + v82) == 255)
          {
            *(v85 + v82) = BYTE4(__len);
          }

          ++v82;
        }

        while (__len != v82);
      }

      ++v81;
    }

    while (v81 != v14);
  }

LABEL_123:
  if (a12)
  {
    if (a8 == 2)
    {
      *(v20 + 9 + v14) = *(v20 + 9 + v14 - 1);
    }

    if (__len >= 1)
    {
      v86 = 0;
      do
      {
        v87 = (*(a2 + 8 * v23) + 8 * v14);
        *(*v87 + v86) = *(*(v87 - 1) + v86);
        ++v86;
      }

      while (__len != v86);
    }
  }

  return 0;
}

int *createMapping(int *a1, int a2, int a3)
{
  v21 = *MEMORY[0x1E69E9840];
  v20 = -1431655766;
  *&v3 = 0xAAAAAAAAAAAAAAAALL;
  *(&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[5] = v3;
  v19[6] = v3;
  v19[3] = v3;
  v19[4] = v3;
  v19[1] = v3;
  v19[2] = v3;
  v19[0] = v3;
  v4 = ((a2 - 1) / a3) & ~(((a2 - 1) / a3) >> 31);
  v5 = (v4 + 4) & 0xFFFFFFFC;
  v6 = vdupq_n_s64(v4);
  v7 = xmmword_19B0A5840;
  v8 = xmmword_19B0A5850;
  v9 = v19 + 2;
  v10 = vdupq_n_s64(4uLL);
  do
  {
    v11 = vmovn_s64(vcgeq_u64(v6, v8));
    if (vuzp1_s16(v11, *v6.i8).u8[0])
    {
      *(v9 - 2) = a3;
    }

    if (vuzp1_s16(v11, *&v6).i8[2])
    {
      *(v9 - 1) = a3;
    }

    if (vuzp1_s16(*&v6, vmovn_s64(vcgeq_u64(v6, *&v7))).i32[1])
    {
      *v9 = a3;
      v9[1] = a3;
    }

    v7 = vaddq_s64(v7, v10);
    v8 = vaddq_s64(v8, v10);
    v9 += 4;
    v5 -= 4;
  }

  while (v5);
  v12 = a2 + ~v4 * a3;
  if (v12 > 0)
  {
    v13 = -1;
  }

  else
  {
    v13 = 1;
  }

  if (v12)
  {
    if (v12 <= 0)
    {
      v14 = 0;
    }

    else
    {
      v14 = ((a2 - 1) / a3) & ~(((a2 - 1) / a3) >> 31);
    }

    do
    {
      *(v19 + v14) -= v13;
      v14 += v13;
      v12 += v13;
      if (v12)
      {
        v15 = 0;
      }

      else
      {
        v15 = v14;
      }

      if (v12 > 0)
      {
        v15 = ((a2 - 1) / a3) & ~(((a2 - 1) / a3) >> 31);
      }

      if (v14 > v4)
      {
        v14 = v15;
      }
    }

    while (v12);
  }

  v16 = 0;
  v17 = 0;
  *a1 = 0;
  result = a1 + 1;
  do
  {
    v17 += *(v19 + v16);
    result[v16 / 4] = v17;
    v16 += 4;
  }

  while (4 * (((a2 - 1) / a3) & ~(((a2 - 1) / a3) >> 31)) + 4 != v16);
  return result;
}

char *coarse2fine(char *result, int a2, int a3)
{
  if (a3 >= 1)
  {
    v3 = a3;
    v4 = result;
    v5 = a3;
    do
    {
      *v4++ *= 2;
      --v5;
    }

    while (v5);
    if (!a2)
    {
      while (1)
      {
        v6 = *result;
        if (v6 == 242)
        {
          break;
        }

        if (v6 == 14)
        {
          v7 = 15;
LABEL_9:
          *result = v7;
        }

        ++result;
        if (!--v3)
        {
          return result;
        }
      }

      v7 = -15;
      goto LABEL_9;
    }
  }

  return result;
}

uint64_t mpegSurroundDecoder_GetNrOfQmfBands(uint64_t a1)
{
  if (!a1 || *(a1 + 124) != 42 || *(a1 + 128) != 3)
  {
    return 64;
  }

  v1 = *(a1 + 129);
  if ((v1 - 2) >= 3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int mpegSurroundDecoder_GetNrOfQmfBands(const SPATIAL_SPECIFIC_CONFIG *, UINT)";
    exception[2] = 153;
  }

  return mpegSurroundDecoder_GetNrOfQmfBands(T_SPATIAL_SPECIFIC_CONFIG const*,unsigned int)::mapIdx2QmfBands[v1 - 2];
}

uint64_t SpatialDecInit(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  *(a1 + 196) = 0;
  if (!a5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int isValidConfig(const spatialDec *const, const SPATIAL_DEC_UPMIX_TYPE, const SPATIALDEC_PARAM *const, const AUDIO_OBJECT_TYPE)";
    exception[2] = 416;
  }

  v8 = *(a2 + 124);
  result = 4294966299;
  if (v8 != 23 && v8 != 39 && (a4 - 1) >= 0xFFFFFFFE && !*(a1 + 8))
  {
    if (*(a2 + 16) != 7)
    {
      return 4294966306;
    }

    if (*(a2 + 44) <= *(a1 + 20))
    {
      v10 = 48;
      if (a4 == -1)
      {
        v10 = 44;
      }

      if (*(a2 + v10) <= *(a1 + 24) && *(a2 + 52) <= *(a1 + 68))
      {
        *(a1 + 188) = a4;
        if ((a6 & 0x200000) != 0)
        {
          v24 = *(a5 + 3);
          if (v24 > 1)
          {
            return result;
          }

          *(a1 + 1332) = v24;
          v25 = *(a5 + 4);
          if (v25 < 0)
          {
            return result;
          }

          *(a1 + 1336) = v25;
          v26 = *(a5 + 8);
          if (v26 < 0)
          {
            return result;
          }

          *(a1 + 1340) = v26;
          v27 = *(a5 + 12);
          if (v27 < 0)
          {
            return result;
          }

          *(a1 + 1344) = v27;
          v28 = *(a5 + 16);
          if (v28 < 0)
          {
            return result;
          }

          *(a1 + 1348) = v28;
          if ((a6 & 0x80000) == 0)
          {
            goto LABEL_15;
          }
        }

        else if ((a6 & 0x80000) == 0)
        {
          goto LABEL_15;
        }

        *(a1 + 1352) = 0;
LABEL_15:
        *(a1 + 401) = 1;
        *(a1 + 208) = a3;
        *(a1 + 200) = 0;
        result = SpatialDecDecodeHeader(a1, a2);
        if (!result)
        {
          *(a1 + 504) = *(a2 + 128);
          if ((a6 & 0x100) != 0)
          {
            *(a1 + 1032) = 1;
          }

          v12 = *(a1 + 208);
          if ((a6 & 0x20000) != 0)
          {
            **(a1 + 1288) = 0;
          }

          initBBEnv(a1, (a6 >> 14) & 1);
          v13 = *(a1 + 1216);
          v14 = *(v13 + 60);
          v15 = v14 & 0xFFFFFFE6;
          v16 = v14 | 8;
          if ((a6 & 0x100) != 0)
          {
            v16 = v15;
          }

          *(v13 + 60) = v16 & 0xFFFFFFEE;
          CDK_QmfDomain_Configure(v13);
          v17 = *(a1 + 100);
          if (v17 >= 1)
          {
            v18 = *(a1 + 208);
            v19 = *(a1 + 1232) + 4;
            do
            {
              *(v19 + 4) = &setup_3_10;
              *(v19 - 4) = v18;
              *v19 = v12;
              v19 += 16;
              --v17;
            }

            while (v17);
          }

          LODWORD(v20) = *(a1 + 20);
          if (v20 < 1)
          {
            v23 = 0;
          }

          else
          {
            v21 = 0;
            for (i = 0; i < v20; ++i)
            {
              CDKhybridAnalysisInit(*(a1 + 1224) + v21, *(a1 + 208), v12, (a6 >> 10) & 1);
              v20 = *(a1 + 20);
              v21 += 312;
            }

            v23 = i;
          }

          for (j = 312 * v23; ; j += 312)
          {
            if (*(a1 + 60))
            {
              LODWORD(v20) = *(a1 + 56) + v20;
            }

            if (v23 >= v20)
            {
              break;
            }

            CDKhybridAnalysisInit(*(a1 + 1224) + j, v12, v12, 0);
            ++v23;
            LODWORD(v20) = *(a1 + 20);
          }

          if (*(a1 + 156) < 1)
          {
LABEL_55:
            initM1andM2(a1, (a6 >> 13) & 1, (a6 >> 4) & 1);
            if ((a6 & 0x20000) != 0)
            {
              if (*(a1 + 68) >= 1)
              {
                v33 = 0;
                do
                {
                  for (k = 0; k != 9; ++k)
                  {
                    for (m = 0; m != 28; ++m)
                    {
                      *(*(*(*(a1 + 472) + 8 * v33) + 8 * k) + m) = 0;
                    }
                  }

                  ++v33;
                }

                while (v33 < *(a1 + 68));
              }

              v36 = *(a1 + 1288);
              *(v36 + 4) = 256;
              *(v36 + 16) = 0;
              *(v36 + 24) = 0;
              *(v36 + 8) = 0;
              *(v36 + 32) = 0;
              v37 = *(a1 + 1288);
              *(v37 + 52) = 0u;
              *(v37 + 68) = 0u;
              *(v37 + 84) = 0u;
              *(v37 + 100) = 0u;
              *(v37 + 116) = 0u;
              *(v37 + 132) = 0u;
              *(v37 + 36) = 0u;
              v38 = *(a1 + 1288);
              *(v38 + 244) = 0u;
              *(v38 + 228) = 0u;
              *(v38 + 212) = 0u;
              *(v38 + 196) = 0u;
              *(v38 + 180) = 0u;
              *(v38 + 164) = 0u;
              *(v38 + 148) = 0u;
            }

            *(a1 + 172) = -4294967231;
            *(a1 + 180) = 0;
            v39 = *(a1 + 1312);
            memset_pattern16((v39 + 16), &unk_19B3D5A30, 8uLL);
            result = 0;
            __asm { FMOV            V0.2S, #1.0 }

            *(v39 + 24) = _D0;
            *(v39 + 12) = 1065353216;
            *(v39 + 32) = &BP__CDK;
            *(v39 + 40) = &BP_GF__CDK;
            *(v39 + 48) = 0;
          }

          else
          {
            v30 = 0;
            v31 = 0;
            while (1)
            {
              if ((**(a1 + 376) & 6) != 0)
              {
                if (*(a1 + 80) == 7)
                {
                  v32 = *(a1 + 132) == 1 ? 1 : 2;
                }

                else
                {
                  v32 = 2;
                }
              }

              else
              {
                v32 = 1;
              }

              if (CDKdecorrelateInit(*(a1 + 1272) + v30, *(a1 + 212), v32, *(a1 + 136), v31, (a6 >> 11) & 1))
              {
                return 4294966296;
              }

              ++v31;
              v30 += 2624;
              if (v31 >= *(a1 + 156))
              {
                goto LABEL_55;
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t SpatialDecDecodeHeader(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 8);
  *(a1 + 4) = *(a2 + 4);
  *(a1 + 168) = v2;
  v3 = *(a1 + 208);
  *(a1 + 184) = v3 * v2;
  v4 = *(a2 + 12);
  *(a1 + 388) = v4;
  *(a1 + 212) = v3 + 7;
  *(a1 + 204) = 12;
  *(a1 + 384) = v4;
  v5 = 4294966305;
  if (v4 <= 9)
  {
    switch(v4)
    {
      case 4:
        v6 = &kernels_4_to_71;
        break;
      case 5:
        v6 = &kernels_5_to_71;
        break;
      case 7:
        v6 = &kernels_7_to_71;
        break;
      default:
        return v5;
    }
  }

  else if (v4 > 19)
  {
    if (v4 == 20)
    {
      v6 = &kernels_20_to_71;
    }

    else
    {
      if (v4 != 28)
      {
        return v5;
      }

      v6 = &kernels_28_to_71;
    }
  }

  else if (v4 == 10)
  {
    v6 = &kernels_10_to_71;
  }

  else
  {
    if (v4 != 14)
    {
      return v5;
    }

    v6 = &kernels_14_to_71;
  }

  *(a1 + 216) = v6;
  v7 = *(a1 + 232);
  *(v7 + 112) = 0;
  *(v7 + 80) = 0u;
  *(v7 + 96) = 0u;
  *(v7 + 48) = 0u;
  *(v7 + 64) = 0u;
  *(v7 + 16) = 0u;
  *(v7 + 32) = 0u;
  *v7 = 0u;
  if (*(a1 + 212) <= 0)
  {
    LODWORD(v8) = 0;
    v10 = *(a1 + 216);
    v9 = *(a1 + 232);
  }

  else
  {
    v8 = 0;
    v9 = *(a1 + 232);
    v10 = *(a1 + 216);
    do
    {
      v11 = *(v10 + v8++);
      *(v9 + 4 + 4 * v11) = v8;
    }

    while (v8 < *(a1 + 212));
  }

  v12 = *(v10 + v8 - 1);
  if (v12 <= 26)
  {
    v13 = 0;
    v14 = (30 - v12) & 0xFFFFFFFFFFFFFFFCLL;
    v15 = vdupq_n_s64(26 - v12);
    v16 = (v9 + 4 * v12 + 12);
    do
    {
      v17 = vdupq_n_s64(v13);
      v18 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(v17, xmmword_19B0A5850)));
      if (vuzp1_s16(v18, *v15.i8).u8[0])
      {
        *(v16 - 1) = v8;
      }

      if (vuzp1_s16(v18, *&v15).i8[2])
      {
        *v16 = v8;
      }

      if (vuzp1_s16(*&v15, vmovn_s64(vcgeq_u64(v15, vorrq_s8(v17, xmmword_19B0A5840)))).i32[1])
      {
        v16[1] = v8;
        v16[2] = v8;
      }

      v13 += 4;
      v16 += 4;
    }

    while (v14 != v13);
  }

  v19 = (v9 + 4);
  for (i = 60; i != 88; ++i)
  {
    *(a1 + 4 * i) = *v19 - *(v19 - 1);
    ++v19;
  }

  v22 = *(a2 + 48);
  LODWORD(v21) = *(a2 + 52);
  v23 = *(a2 + 44);
  v24 = *(a2 + 20);
  *(a1 + 80) = *(a2 + 16);
  *(a1 + 84) = v23;
  *(a1 + 88) = v22;
  *(a1 + 92) = v21;
  *(a1 + 104) = v24;
  if (*(a2 + 24))
  {
    return 4294966299;
  }

  v25 = 0;
  *(a1 + 96) = v22;
  *(a1 + 112) = 0;
  v26 = *(a1 + 376);
  if ((*v26 & 2) != 0)
  {
    v25 = *(a2 + 28);
    *(a1 + 112) = v25;
  }

  v27 = *(a2 + 36);
  *(a1 + 144) = clipGainTable__CDK[*(a2 + 32)];
  *(a1 + 128) = v27;
  *(a1 + 136) = *(a2 + 40);
  if (*(a1 + 188) == -1)
  {
    *(a1 + 88) = v23;
    v22 = v23;
  }

  *(a1 + 100) = v22;
  *(a1 + 976) = *(a2 + 145);
  *(a1 + 512) = *(a2 + 133);
  if (v21 >= 1)
  {
    v28 = 0;
    do
    {
      v26[v28 + 146] = *(a1 + 388);
      v26 = *(a1 + 376);
      *(*(a1 + 392) + 4 * v28) = v26[v28 + 146];
      ++v28;
      v21 = *(a1 + 92);
    }

    while (v28 < v21);
    v25 = *(a1 + 112);
  }

  if (v25)
  {
    if (v21 >= 1)
    {
      v29 = (a1 + 366);
      v30 = (a2 + 84);
      v21 = v21;
      do
      {
        v31 = *(v30 - 4);
        *(v29 - 10) = v31;
        if (v31)
        {
          v32 = *v30;
          *(v29 - 5) = *v30;
          v31 = *(*(a1 + 232) + 4 * v32);
          if (v31 <= 10)
          {
            LOBYTE(v31) = 10;
          }

          LOBYTE(v31) = v31 - 7;
        }

        else
        {
          *(v29 - 5) = 0;
        }

        *v29++ = v31;
        v30 += 2;
        --v21;
      }

      while (v21);
    }
  }

  else if (v21 >= 1)
  {
    v33 = (a1 + 361);
    v21 = v21;
    do
    {
      *(v33 - 5) = 0;
      *v33++ = 0;
      --v21;
    }

    while (v21);
  }

  if (*(a1 + 80) != 7)
  {
    return 4294966306;
  }

  *(a1 + 148) = 1;
  *(a1 + 164) = 1;
  *(a1 + 156) = 0x200000001;
  *(a1 + 508) = *(a2 + 130);
  *(a1 + 132) = *(a2 + 131);
  SpatialDecDecodeHelperInfo(a2);
  return 0;
}

double initBBEnv(uint64_t a1, int a2)
{
  v2 = *(a1 + 88);
  if (v2 >= 1)
  {
    v3 = *(a1 + 80);
    v4 = (a1 + 1304);
    v5 = &row2channelGES[2 * v3];
    do
    {
      v7 = *v5++;
      v6 = v7;
      if (v7 != 255 && v3 == 7)
      {
        v6 = 0;
      }

      *v4++ = v6;
      --v2;
    }

    while (v2);
  }

  v9 = *(a1 + 1296);
  if (a2)
  {
    memset_pattern16(*(a1 + 1296), &unk_19B3D5A30, 0x14uLL);
    v10 = xmmword_19B0A5850;
    v11 = (v9 + 24);
    v12 = 6;
    v13 = vdupq_n_s64(5uLL);
    v14 = vdupq_n_s64(2uLL);
    do
    {
      if (vmovn_s64(vcgtq_u64(v13, v10)).u8[0])
      {
        *(v11 - 1) = 0;
      }

      if (vmovn_s64(vcgtq_u64(vdupq_n_s64(5uLL), *&v10)).i32[1])
      {
        *v11 = 0;
      }

      v10 = vaddq_s64(v10, v14);
      v11 += 2;
      v12 -= 2;
    }

    while (v12);
  }

  result = 0.00558557081;
  *(v9 + 40) = 0x3F76E0E53F7F12A9;
  return result;
}

void CDKhybridAnalysisInit(uint64_t a1, int a2, int a3, int a4)
{
  *(a1 + 304) = &setup_3_10;
  if (a4)
  {
    *(a1 + 256) = 12;
  }

  *(a1 + 264) = a2;
  *(a1 + 268) = a3;
  *(a1 + 272) = 0;
  if (*(a1 + 296) >= 0x138u)
  {
    v4 = *(a1 + 300);
    if (!v4 || v4 >= 4 * (6 * (a3 + a2) - 36))
    {
      v5 = *(a1 + 280);
      v6 = 3;
      v7 = a1;
      do
      {
        *v7 = v5;
        v7[3] = v5 + 52;
        ++v7;
        v5 += 104;
        --v6;
      }

      while (v6);
      if (v4)
      {
        v8 = *(a1 + 288);
        v9 = (a1 + 152);
        v10 = 4 * (a2 - 3);
        v11 = 6;
        do
        {
          *(v9 - 13) = v8;
          *v9++ = v8 + v10;
          v8 += 4 * a3 + v10 - 12;
          --v11;
        }

        while (v11);
      }

      if (a4)
      {
        v12 = 3;
        v13 = a1;
        do
        {
          v14 = *v13;
          *(v14 + 48) = 0;
          *(v14 + 16) = 0uLL;
          *(v14 + 32) = 0uLL;
          *v14 = 0uLL;
          v15 = v13[3];
          *(v15 + 48) = 0;
          *(v15 + 16) = 0uLL;
          *(v15 + 32) = 0uLL;
          *v15 = 0uLL;
          ++v13;
          --v12;
        }

        while (v12);
        if (a2 >= 4 && *(a1 + 300))
        {
          v16 = (4 * a2 - 12);
          v17 = (a1 + 152);
          v18 = (4 * a3 - 12);
          v19 = 6;
          do
          {
            bzero(*(v17 - 13), v16);
            v20 = *v17++;
            bzero(v20, v18);
            --v19;
          }

          while (v19);
        }
      }
    }
  }
}

uint64_t CDKdecorrelateInit(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  *(a1 + 2620) = 0;
  *(a1 + 2616) = a2;
  result = 1;
  if (a3 == 2 && !a5)
  {
    v8 = &REV_bandOffset_MPS_HQ + 4 * a4;
    v9 = &REV_filterOrder_USAC;
    *(a1 + 48) = &REV_delay_USAC;
    *(a1 + 56) = &REV_filterOrder_USAC;
    *a1 = 1018;
    v10 = *(a1 + 8);
    *(a1 + 32) = &REV_filtType_MPS;
    *(a1 + 40) = v8;
    *(a1 + 24) = v10 + 4072;
    *(a1 + 16) = 1286;
    if (a6)
    {
      bzero(v10, 0xFE8uLL);
      bzero(*(a1 + 24), (4 * *(a1 + 16)));
      *(a1 + 64) = 0;
      *(a1 + 72) = 0;
      v8 = *(a1 + 40);
      v9 = *(a1 + 56);
    }

    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    do
    {
      v15 = v8[v11];
      if (v12 < v15)
      {
        v16 = *(a1 + 8);
        v17 = *(a1 + 24);
        v18 = v15 - v12;
        v19 = (a1 + 96 + 32 * v12);
        v20 = *(a1 + 48);
        v21 = *(&off_1E75312E8 + v11);
        do
        {
          v22 = *(v20 + v11);
          v23 = v16 + 4 * v14;
          v14 += 2 * v9[v11];
          *(v19 - 2) = v23;
          *(v19 - 1) = v17 + 4 * v13;
          *v19 = v21;
          v13 += 2 * v22;
          v19 += 4;
          --v18;
        }

        while (v18);
        v12 = v15;
      }

      ++v11;
    }

    while (v11 != 4);
    if (v14 <= *a1)
    {
      result = 1;
      if (v13 <= *(a1 + 16))
      {
        *(a1 + 2364) = 1;
        v24 = *(a1 + 2616);
        v25 = *(a1 + 2620);
        *(a1 + 2384) = &kernels_28_to_71;
        *(a1 + 2376) = &kernels_28_to_71_offset;
        *(a1 + 2356) = 28;
        *(a1 + 2368) = &unk_19B3BD6E5;
        *(a1 + 2352) = v24;
        *(a1 + 2360) = v25;
        return 0;
      }
    }

    else
    {
      return 1;
    }
  }

  return result;
}

uint64_t initM1andM2(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    v3 = 1;
  }

  else
  {
    v3 = a3 == 0;
  }

  v4 = !v3;
  *(result + 1328) = v4;
  v5 = *(result + 88);
  *(result + 96) = v5;
  if (a2 && v5 >= 1)
  {
    v6 = 0;
    v7 = *(result + 160);
    do
    {
      if (v7 >= 1)
      {
        v8 = 0;
        v9 = *(*(result + 984) + 8 * v6);
        v10 = *(*(result + 1000) + 8 * v6);
        do
        {
          v11 = 0;
          v12 = *(v9 + 8 * v8);
          v13 = *(v10 + 8 * v8);
          do
          {
            *(v12 + v11) = 0;
            *(v13 + v11) = 0;
            v11 += 4;
          }

          while (v11 != 112);
          ++v8;
        }

        while (v8 != v7);
      }

      ++v6;
    }

    while (v6 != v5);
  }

  return result;
}

void sbr_dec(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  v9 = MEMORY[0x1EEE9AC00](a1);
  v11 = v10;
  v662 = v12;
  v710 = v13;
  v660 = v14;
  v680 = v15;
  v17 = v16;
  v18 = v9;
  v744 = *MEMORY[0x1E69E9840];
  v19 = *(*(v9 + 624) + 72);
  v682 = v20;
  v655 = *(v20 + 8);
  v656 = *(v20 + 6);
  v21 = v655 * v656;
  memset(__b, 170, sizeof(__b));
  memset(v726, 170, sizeof(v726));
  v22 = v18;
  v23 = &__b[v19];
  v24 = &v726[8 * v19];
  v661 = v19;
  *v715 = (v21 + v19);
  if (v21 + v19)
  {
    v25 = v18[1453];
    v26 = *(v25 + 112);
    v27 = *(v25 + 120);
    v28 = v726;
    v29 = __b;
    v30 = (v21 + v19);
    do
    {
      v31 = *v26++;
      *v29++ = v31;
      v32 = *v27++;
      *v28++ = v32;
      --v30;
    }

    while (v30);
  }

  *v681 = v18;
  if ((v662 & 0x100) != 0)
  {
    if (v21)
    {
      v33 = 0;
      v34 = v18[1456];
      v35 = v18[1457];
      do
      {
        __b[v715[0] + v33] = *(v34 + 8 * v33);
        *&v726[8 * v715[0] + 8 * v33] = *(v35 + 8 * v33);
        ++v33;
      }

      while (v21 != v33);
      v23 += v21;
      v24 += v21;
      if ((v662 & 0x200000) == 0)
      {
        for (i = 0; i != v21; ++i)
        {
          CDKmemcpy(__b[v661 + i], *(v22[1456] + 8 * i), 4 * *(v682 + 7));
          CDKmemcpy(*&v726[8 * v661 + 8 * i], *(v18[1457] + 8 * i), 4 * *(v682 + 7));
          v22 = v18;
        }

        goto LABEL_22;
      }

      v683 = v23;
    }

    else
    {
      if ((v662 & 0x200000) == 0)
      {
LABEL_22:
        v683 = v23;
        v678 = v24;
        UsacQmf::ProcessAnalysis(v11, a9, *(v22[1453] + 52), v17, v23, v24);
        goto LABEL_40;
      }

      v683 = &__b[v19];
      v34 = v18[1456];
      v35 = v18[1457];
    }

    v52 = v18[1453];
    if (v52)
    {
      v707 = v35;
      if (v34)
      {
        if (v35)
        {
          v53 = *v52;
          v54 = v52[13];
          v55 = *(v52 + 41);
          v56 = *(v52 + 42);
          WorkBuffer = CDK_getWorkBuffer(v54, v55, v56, *(v52 + 81));
          v58 = *(v52 + 80);
          v678 = v24;
          if (WorkBuffer == *(v52[14] + 8 * *(v53 + 72)))
          {
            v70 = *(v53 + 64);
            if (v70 <= 0x40)
            {
              if (*(v52 + 80))
              {
                v71 = 0;
                v72 = 4 * v70;
                v73 = 8 * v58;
                do
                {
                  *&v74 = -1;
                  *(&v74 + 1) = -1;
                  v742[15] = v74;
                  v742[14] = v74;
                  v742[13] = v74;
                  v742[12] = v74;
                  v742[11] = v74;
                  v742[10] = v74;
                  v742[9] = v74;
                  v742[8] = v74;
                  v742[7] = v74;
                  v742[6] = v74;
                  v742[5] = v74;
                  v742[4] = v74;
                  v75 = v52[14];
                  v76 = *(v53 + 72);
                  v742[3] = v74;
                  v742[2] = v74;
                  v742[1] = v74;
                  v742[0] = v74;
                  CDKmemcpy(v742, *(v75 + 8 * v76 + v71), v72);
                  CDKmemcpy(*(v52[14] + 8 * *(v53 + 72) + v71), *(v34 + v71), v72);
                  CDKmemcpy(*(v34 + v71), v742, v72);
                  CDKmemcpy(v742, *(v52[15] + 8 * *(v53 + 72) + v71), v72);
                  CDKmemcpy(*(v52[15] + 8 * *(v53 + 72) + v71), *(v707 + v71), v72);
                  CDKmemcpy(*(v707 + v71), v742, v72);
                  v71 += 8;
                }

                while (v73 != v71);
              }

LABEL_40:
              v39 = v680;
              v38 = *v681;
              v68 = v710;
              v69 = *v715;
              if (!*(v680 + 1939))
              {
                goto LABEL_45;
              }

              goto LABEL_41;
            }

            exception = __cxa_allocate_exception(0x10uLL);
            *exception = "void CDK_QmfDomain_QmfData2HBE(HANDLE_CDK_QMF_DOMAIN_IN, FLOAT **, FLOAT **)";
            v652 = 582;
          }

          else
          {
            v59 = *(v52 + 81);
            if (v59 == *(v53 + 64))
            {
              if (*(v52 + 80))
              {
                v60 = v52;
                v61 = v53;
                v62 = 0;
                v722 = 8 * v58;
                do
                {
                  CDKmemcpy(*(v60[14] + 8 * *(v61 + 72) + v62), *(v34 + v62), (4 * v59));
                  CDKmemcpy(*(v60[15] + 8 * *(v61 + 72) + v62), *(v707 + v62), (4 * v59));
                  v63 = *(v34 + v62);
                  v64 = CDK_getWorkBuffer(v54, v55, v56, v59);
                  CDKmemcpy(v63, v64, (4 * v59));
                  v65 = v55 + v59;
                  v66 = *(v707 + v62);
                  v67 = CDK_getWorkBuffer(v54, v65, v56, v59);
                  CDKmemcpy(v66, v67, (4 * v59));
                  v55 = v65 + v59;
                  v62 += 8;
                }

                while (v722 != v62);
              }

              goto LABEL_40;
            }

            exception = __cxa_allocate_exception(0x10uLL);
            *exception = "void CDK_QmfDomain_QmfData2HBE(HANDLE_CDK_QMF_DOMAIN_IN, FLOAT **, FLOAT **)";
            v652 = 600;
          }
        }

        else
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "void CDK_QmfDomain_QmfData2HBE(HANDLE_CDK_QMF_DOMAIN_IN, FLOAT **, FLOAT **)";
          v652 = 572;
        }
      }

      else
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "void CDK_QmfDomain_QmfData2HBE(HANDLE_CDK_QMF_DOMAIN_IN, FLOAT **, FLOAT **)";
        v652 = 571;
      }
    }

    else
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "void CDK_QmfDomain_QmfData2HBE(HANDLE_CDK_QMF_DOMAIN_IN, FLOAT **, FLOAT **)";
      v652 = 570;
    }

LABEL_583:
    exception[2] = v652;
  }

  v37 = v18[1453];
  v678 = &v726[8 * v19];
  v683 = &__b[v19];
  if ((v662 & 0x200000) != 0)
  {
    v39 = v680;
    if (!v37)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "void CDK_QmfDomain_WorkBuffer2ProcChannel(const HANDLE_CDK_QMF_DOMAIN_IN)";
      v652 = 540;
      goto LABEL_583;
    }

    v40 = *v37;
    v41 = v37[13];
    v42 = *(v37 + 41);
    v43 = *(v37 + 42);
    if (CDK_getWorkBuffer(v41, v42, v43, *(v37 + 81)) == *(v37[14] + 8 * *(v40 + 72)))
    {
      v38 = v18;
      goto LABEL_35;
    }

    v44 = *(v37 + 80);
    if (*(v37 + 80))
    {
      v45 = 0;
      v46 = *(v37 + 81);
      do
      {
        v47 = *(v37[14] + 8 * (v45 + *(v40 + 72)));
        v48 = CDK_getWorkBuffer(v41, v42, v43, v46);
        CDKmemcpy(v47, v48, (4 * v46));
        v49 = v42 + v46;
        v50 = *(v37[15] + 8 * (v45 + *(v40 + 72)));
        v51 = CDK_getWorkBuffer(v41, v49, v43, v46);
        CDKmemcpy(v50, v51, (4 * v46));
        v42 = v49 + v46;
        ++v45;
      }

      while (v44 != v45);
      v39 = v680;
      v38 = *v681;
      LODWORD(v21) = v655 * v656;
      goto LABEL_35;
    }

    v38 = v18;
  }

  else
  {
    UsacQmf::ProcessAnalysis(v11, a9, *(v37 + 13), v17, v23, &v726[8 * v19]);
    v38 = v18;
  }

  v39 = v680;
LABEL_35:
  v68 = v710;
  v69 = *v715;
LABEL_41:
  if (v21)
  {
    v77 = *(v682 + 7);
    v78 = v661;
    do
    {
      bzero((__b[v78] + 4 * v77), (256 - 4 * v77));
      bzero((*&v726[8 * v78++] + 4 * v77), (256 - 4 * v77));
    }

    while (v78 < v69);
    v38 = *v681;
  }

LABEL_45:
  if (!v68)
  {
    goto LABEL_496;
  }

  v79 = v38 + 1024;
  v669 = (v39 + 6);
  v80 = *(v39 + 6 + *(v39 + 5));
  v81 = *(v682 + 6);
  memcpy(__dst, &unk_19B3BBC18, sizeof(__dst));
  v708 = v79;
  if (*(v682 + 5))
  {
    v82 = 0;
    LODWORD(v83) = *(v682 + 8);
    LOBYTE(v84) = *(v682 + 44);
    LOBYTE(__dst[0]) = 0;
    BYTE2(__dst[0]) = v84;
    BYTE3(__dst[0]) = v83;
    v658 = (v682 + 40);
    v85 = *v681;
    goto LABEL_48;
  }

  v178 = *(v39 + 1937);
  v83 = *(v682 + 8);
  v84 = *(v682 + 44);
  v179 = *(v39 + 28);
  LOBYTE(__dst[0]) = *(v682 + 37);
  v82 = __dst[0];
  BYTE2(__dst[0]) = v84;
  BYTE3(__dst[0]) = v83;
  v85 = *v681;
  if (LOBYTE(__dst[0]) == 1)
  {
    v180 = &g_a_scalingCoef_mode1;
    v181 = &g_a_pvcTab1_dp_mode1;
    v183 = &g_2a_pvcTab2_mode1;
    v184 = 8;
    v182 = 8;
    v185 = &g_3a_pvcTab1_mode1;
  }

  else
  {
    if (LOBYTE(__dst[0]) != 2)
    {
      v706 = 0xAAAAAAAAAAAAAAAALL;
      v184 = 170;
      v178 = 170;
      v179 = 170;
      goto LABEL_511;
    }

    v180 = &g_a_scalingCoef_mode2;
    v181 = &g_a_pvcTab1_dp_mode2;
    v182 = 12;
    v183 = &g_2a_pvcTab2_mode2;
    v184 = 6;
    v185 = &g_3a_pvcTab1_mode2;
  }

  BYTE5(__dst[5]) = v184;
  __dst[8] = v183;
  __dst[9] = v181;
  __dst[6] = v180;
  __dst[7] = v185;
  BYTE1(__dst[0]) = v179;
  v587 = *(v79 + 3219);
  *(v79 + 3219) = v179;
  v706 = v39 + 1921;
  __dst[1] = v39 + 1921;
  BYTE4(__dst[0]) = v178;
  if (v178 > 11)
  {
    if (v178 == 16)
    {
      v588 = &pvc_SC_16;
      goto LABEL_515;
    }

    if (v178 == 12)
    {
      v588 = &pvc_SC_12;
      goto LABEL_515;
    }

LABEL_511:
    v589 = v682;
    v658 = (v682 + 40);
    v590 = -86;
    v588 = 0xAAAAAAAAAAAAAAAALL;
    goto LABEL_522;
  }

  if (v178 == 3)
  {
    v588 = &pvc_SC_3;
    goto LABEL_515;
  }

  if (v178 != 4)
  {
    goto LABEL_511;
  }

  v588 = &pvc_SC_4;
LABEL_515:
  __dst[3] = v588;
  v591 = *(v79 + 3217);
  if (v591)
  {
    v592 = 16 - v587;
    if (*(v79 + 3216) == v84)
    {
      v591 = v592;
    }

    else
    {
      v591 = 0;
    }
  }

  v593 = 0;
  v594 = v182 / v83;
  v590 = v591;
  LOBYTE(__dst[2]) = v591;
  v595 = vrev64_s16(vmla_s16(vdup_n_s16(v84), vdup_n_s16(-(8 / v83)), 0x3000200010000));
  LODWORD(__dst[4]) = vuzp1_s8(v595, v595).u32[0];
  v596 = 36;
  do
  {
    *(__dst + v596) = v593;
    v593 += v594;
    v184 = BYTE5(__dst[5]);
    v597 = v596 - 36;
    ++v596;
  }

  while (v597 < BYTE5(__dst[5]));
  v658 = (v682 + 40);
  v589 = v682;
LABEL_522:
  if (*(v589 + 37) && v179 <= 0xF)
  {
    v668 = v84;
    v671 = v82;
    v673 = v81;
    v675 = v80;
    v677 = v21;
    v692 = v588;
    v724 = v179;
    v598 = *v681 + 11412;
    v696 = __dst[9];
    v599 = __dst[6];
    v686 = __dst[7];
    v689 = __dst[8];
    v600 = *(v79 + 3218);
    v601 = v178;
    v714 = v184;
    v602 = v184;
    v703 = v83;
    v700 = v178;
    v603 = v590;
    while (1)
    {
      v604 = 0;
      v605 = v598 + 12 * v600;
      DWORD2(v742[0]) = 0;
      *&v742[0] = 0;
      if (SLOBYTE(__dst[4]) < 0)
      {
        v604 = 0;
        do
        {
          *(v605 + 4 * v604) = -1054867456;
          v606 = *(&__dst[4] + ++v604);
        }

        while (v606 < 0);
        v604 = v604;
        if (v83)
        {
LABEL_531:
          for (j = 0; j != v83; ++j)
          {
            if (v604 <= 2)
            {
              v608 = __b[v724 * v83 + j];
              v609 = *&v726[8 * v724 * v83 + 8 * j];
              v610 = v604;
              v611 = *(&__dst[4] + v604);
              do
              {
                v612 = v610 + 1;
                v613 = *(&__dst[4] + v610 + 1);
                v614 = 0.0;
                if (v613 > v611)
                {
                  v615 = *(&__dst[4] + v610 + 1) - v611;
                  v616 = (v609 + 4 * v611);
                  v617 = (v608 + 4 * v611);
                  do
                  {
                    v618 = *v617++;
                    v619 = v618;
                    v620 = *v616++;
                    v614 = v614 + ((v620 * v620) + (v619 * v619));
                    --v615;
                  }

                  while (v615);
                  v614 = v614 * 0.125;
                }

                *(v742 + v610) = v614 + *(v742 + v610);
                v611 = v613;
                ++v610;
              }

              while (v612 != 3);
            }
          }
        }
      }

      else if (v83)
      {
        goto LABEL_531;
      }

      v721 = v600;
      if (v604 <= 2)
      {
        v621 = 4 * v604;
        do
        {
          v622 = *(v742 + v621);
          v623 = -10.0;
          if (v622 > 0.0)
          {
            v624 = log(v622) * 0.434294482 * 10.0;
            v623 = fmaxf(v624, -10.0);
          }

          *(v605 + v621) = v623;
          v621 += 4;
        }

        while (v621 != 12);
      }

      if (v178)
      {
        v625 = 0;
        v626 = v721;
        v627 = 0;
        v628 = 0.0;
        v629 = v696;
        do
        {
          v630 = v692[v625];
          v631 = (v598 + 12 * v626);
          v627 = vmla_n_f32(v627, *v631, v630);
          v628 = v628 + (v631[1].f32[0] * v630);
          v632 = v626 - 1;
          if (v626 < 1)
          {
            v632 = 15;
          }

          if (v625 < v603)
          {
            v626 = v632;
          }

          ++v625;
        }

        while (v601 != v625);
      }

      else
      {
        v627 = 0;
        v628 = 0.0;
        v629 = v696;
      }

      *&v742[0] = v627;
      *(v742 + 2) = v628;
      v633 = *(v706 + v724);
      if (v633 >= *v629)
      {
        if (v633 >= v629[1])
        {
          v634 = 6;
        }

        else
        {
          v634 = 3;
        }
      }

      else
      {
        v634 = 0;
      }

      if (v714)
      {
        v635 = 0;
        v636 = (v686 + v634 * v714);
        v637 = (v689 + v714 * v633);
        v638 = *(v599 + 12);
        do
        {
          v639 = 0;
          v640 = v638 * *v637;
          v641 = v636;
          do
          {
            v640 = v640 + ((*(v742 + v639) * *v641) * *(v599 + v639));
            v639 += 4;
            v641 += v602;
          }

          while (v639 != 12);
          ++v637;
          v642 = __exp10((v640 / 10.0));
          *(&__dst[4 * v724 + 10] + v635++) = v642;
          ++v636;
        }

        while (v635 != v602);
      }

      v600 = (v721 + 1) & 0xF;
      v79 = v708;
      *(v708 + 3218) = v600;
      v643 = v603;
      if (v603 >= 0xEu)
      {
        v643 = 14;
      }

      v603 = v643 + 1;
      ++v724;
      v85 = *v681;
      v83 = v703;
      v178 = v700;
      if (v724 == 16)
      {
        LOBYTE(__dst[2]) = v643 + 1;
        v39 = v680;
        LODWORD(v21) = v677;
        v80 = v675;
        v81 = v673;
        v82 = v671;
        LOBYTE(v84) = v668;
        break;
      }
    }
  }

LABEL_48:
  v86 = v85 + 78;
  v87 = v80 - v81;
  *(v79 + 3217) = v82;
  *(v79 + 3216) = v84;
  if ((v662 & 0x100) != 0)
  {
    v88 = *(v39 + 1939) != 0;
    if ((v662 & 0x80) != 0)
    {
      v89 = 0x1FFFFFFFFFFFFFE0;
    }

    else
    {
      v89 = 0;
    }

    if (!*(v79 + 3488) && *(v39 + 1939) == 1)
    {
      v90 = v661 + 2;
      v91 = v85 + 306;
      v92 = 8 * (v21 - v661) - 16;
      do
      {
        v93 = v85;
        CDKmemcpy(v91 - 1792, *(v85[1458] + v92), (4 * *(v85[1452] + 44)));
        CDKmemcpy(v91, *(v93[1459] + v92), (4 * *(v93[1452] + 44)));
        v91 += 128;
        v92 += 8;
        --v90;
        v85 = v93;
      }

      while (v90);
    }

    v94 = v85[1452];
    if (*(v94 + 40) >= 1)
    {
      v95 = 0;
      do
      {
        v96 = v85;
        CDKmemcpy(*(v85[1458] + 8 * v95), __b[v661 + v95], (4 * *(v94 + 44)));
        CDKmemcpy(*(v96[1459] + 8 * v95), *&v726[8 * v661 + 8 * v95], (4 * *(v96[1452] + 44)));
        ++v95;
        v94 = v96[1452];
        v85 = v96;
      }

      while (v95 < *(v94 + 40));
    }

    QmfTransposerApply(v94, &v683[v89], &v678[v89], __b, v726, *(v680 + 1941), v661, v88);
    if ((v662 & 0x80) != 0)
    {
      copyHarmonicSpectrum(*(*v681 + 11616), __b, v726, v21, v661, v88);
    }

    v97 = *v681;
    if (!*(v680 + 1939))
    {
      *(v708 + 853) = 0x10000;
      v186 = *(*v681 + 11616);
      v187 = *(v682 + 8);
      v188 = *(v680 + 6);
      v189 = *(v682 + 61);
      *&v729 = -1;
      *(&__src + 1) = -1;
      *&__src = -1;
      v190 = *(*v681 + 624);
      *&v733 = -1;
      *&v191 = -1;
      *(&v191 + 1) = -1;
      v732 = v191;
      *v731 = v191;
      v192 = (v188 * v187);
      v193 = *v190 + v87 * v187;
      v684 = v189;
      inverseFilteringLevelEmphasis(v86, v189, (v680 + 44), (v660 + 248), &__src);
      v716 = *v190;
      v712 = v190[72];
      if (v192 < v193)
      {
        v194 = &v190[6 * v190[1]];
        v195 = v194[13] + v194[11];
        v196 = v192;
        do
        {
          bzero((__b[v196] + 4 * v195), (256 - 4 * v195));
          bzero((*&v726[8 * v196++] + 4 * v195), (256 - 4 * v195));
        }

        while (v196 < v193);
      }

      v719 = v193;
      v197 = *(v186 + 48);
      v709 = *(v186 + 52);
      v198 = *v681;
      if (v197 < v709)
      {
        v199 = *v190;
        v200 = v190[72];
        v693 = v200 + 2;
        v698 = (v200 + v199);
        v201 = *v681 + 4 * v197 + 4752;
        v202 = 8 * v199 - 16;
        v687 = &v726[v202];
        v690 = (__b + v202);
        v203 = *v681 + 4240 + 4 * v197;
        do
        {
          *&v204 = -1;
          *(&v204 + 1) = -1;
          *(&v742[17] + 8) = v204;
          *(&v742[18] + 8) = v204;
          *(&v742[15] + 8) = v204;
          *(&v742[16] + 8) = v204;
          *(&v742[13] + 8) = v204;
          *(&v742[14] + 8) = v204;
          *(&v742[11] + 8) = v204;
          *(&v742[12] + 8) = v204;
          *(&v742[9] + 8) = v204;
          *(&v742[10] + 8) = v204;
          *(&v742[7] + 8) = v204;
          *(&v742[8] + 8) = v204;
          *(&v742[5] + 8) = v204;
          *(&v742[6] + 8) = v204;
          *(&v742[3] + 8) = v204;
          *(&v742[4] + 8) = v204;
          *(&v742[1] + 8) = v204;
          *(&v742[2] + 8) = v204;
          *(v742 + 8) = v204;
          *(&v743[17] + 8) = v204;
          *(&v743[18] + 8) = v204;
          *(&v743[15] + 8) = v204;
          *(&v743[16] + 8) = v204;
          *(&v743[13] + 8) = v204;
          *(&v743[14] + 8) = v204;
          *(&v743[11] + 8) = v204;
          *(&v743[12] + 8) = v204;
          *(&v743[9] + 8) = v204;
          *(&v743[10] + 8) = v204;
          *(&v743[7] + 8) = v204;
          *(&v743[8] + 8) = v204;
          *(&v743[5] + 8) = v204;
          *(&v743[6] + 8) = v204;
          *(&v743[3] + 8) = v204;
          *(&v743[4] + 8) = v204;
          *(&v743[1] + 8) = v204;
          *(&v743[2] + 8) = v204;
          *(v743 + 8) = v204;
          v205 = (*v681 + 4240 + 4 * v197);
          v206 = (*v681 + 7824 + 4 * v197);
          v207 = *v206;
          v208 = v205[64];
          LODWORD(v742[0]) = *v205;
          DWORD1(v742[0]) = v208;
          LODWORD(v204) = v206[64];
          v209 = v742 + 2;
          v210 = v201;
          v211 = v743 + 2;
          v212 = v192;
          *&v743[0] = __PAIR64__(v204, v207);
          if (v192)
          {
            do
            {
              *v209++ = *v210;
              *v211++ = v210[896];
              v210 += 64;
              --v212;
            }

            while (v212);
          }

          v213 = &__b[v192];
          v214 = v742 + v192 + 2;
          v215 = v743 + v192 + 2;
          v216 = &v726[8 * v192];
          v217 = v698 - v192;
          if (v192 < v698)
          {
            do
            {
              v218 = *v213++;
              *v214++ = *(v218 + 4 * v197);
              v219 = *v216++;
              *v215++ = *(v219 + 4 * v197);
              --v217;
            }

            while (v217);
          }

          v220 = v687;
          v221 = v690;
          v222 = v203;
          v223 = v693;
          do
          {
            v224 = *v221++;
            v225 = *(v224 + 4 * v197);
            v226 = *v220++;
            *v222 = v225;
            v222[896] = *(v226 + 4 * v197);
            v222 += 64;
            --v223;
          }

          while (v223);
          autoCorr2nd_cplx(v731, v742 + 2, v743 + 2, v712 + v716);
          v227 = 0.0;
          v228 = 0.0;
          v229 = 0.0;
          if (*(&v733 + 1) != 0.0)
          {
            v228 = (((*&v731[12] * *(&v732 + 1)) - (*(&v732 + 2) * *&v733)) - (*&v732 * *&v731[4])) / *(&v733 + 1);
            v229 = (((*&v731[12] * *&v733) + (*(&v732 + 2) * *(&v732 + 1))) - (*(&v732 + 3) * *&v731[4])) / *(&v733 + 1);
          }

          v230 = 0.0;
          if (*&v731[4] != 0.0)
          {
            v227 = -((*&v731[12] + (v228 * *(&v732 + 1))) + (v229 * *&v733)) / *&v731[4];
            v230 = -((*(&v732 + 2) + (v229 * *(&v732 + 1))) + (-v228 * *&v733)) / *&v731[4];
          }

          v231 = 0;
          v198 = *v681;
          do
          {
            if (v197 < v190[v231 + 4])
            {
              break;
            }

            ++v231;
          }

          while (v231 != 5);
          v232 = *(&__src + v231);
          v233 = v232 * v232;
          if ((v232 * v232) <= 0.0)
          {
            v250 = v742 + v192 + 2;
            v251 = v743 + v192 + 2;
            v252 = &__b[v192];
            v253 = &v726[8 * v192];
            v254 = v192 - v719;
            if (v192 < v719)
            {
              do
              {
                v255 = *v250++;
                v256 = v255;
                v257 = *v252++;
                *(v257 + 4 * v197) = v256;
                LODWORD(v257) = *v251++;
                v258 = v257;
                v259 = *v253++;
                *(v259 + 4 * v197) = v258;
                _CF = __CFADD__(v254++, 1);
              }

              while (!_CF);
            }
          }

          else if (v192 < v719)
          {
            v234 = v227 * v232;
            v235 = v230 * v232;
            v236 = v228 * v233;
            v237 = v229 * v233;
            v238 = *(v742 + v192);
            v239 = *(v743 + v192);
            v240 = v742 + v192 + 2;
            v241 = v743 + v192 + 2;
            v242 = v192 - v719;
            v243 = &__b[v192];
            v244 = &v726[8 * v192];
            do
            {
              v245 = *(v241 - 1);
              v246 = *(v240 - 1);
              v247 = *v243++;
              *(v247 + 4 * v197) = *v240 + (((v245 * -v235) + (v234 * v246)) + ((v239 * -v237) + (v236 * v238)));
              *&v247 = *v241++;
              v248 = (((v234 * v245) + (v235 * v246)) + ((v236 * v239) + (v237 * v238))) + *&v247;
              v249 = *v244++;
              *(v249 + 4 * v197) = v248;
              ++v240;
              v239 = v245;
              v238 = v246;
              _CF = __CFADD__(v242++, 1);
            }

            while (!_CF);
          }

          ++v197;
          v201 += 4;
          v203 += 4;
        }

        while (v709 != v197);
      }

      if (v684)
      {
        memcpy((v198 + 632), &__src, 4 * v684);
        v198 = *v681;
      }

      v260 = v680;
      goto LABEL_189;
    }

    v98 = 0;
    v99 = (*v681 + 7824);
    do
    {
      v100 = v97;
      CDKmemcpy(v99 - 3584, *(*(v97[1453] + 112) + 8 * (v98 + *(v97[1452] + 40) - 2)), 0x100uLL);
      CDKmemcpy(v99, *(*(v100[1453] + 120) + 8 * (v98++ + *(v100[1452] + 40) - 2)), 0x100uLL);
      v101 = v100[78];
      v102 = v101[72];
      v99 += 256;
      v97 = v100;
    }

    while (v98 < v102 + 2);
    v103 = v682;
    LODWORD(v83) = *(v682 + 8);
    v39 = v680;
    v79 = v708;
  }

  else
  {
    v101 = *v86;
    LODWORD(v102) = *(*v86 + 72);
    v103 = v682;
  }

  *(v79 + 853) = 1;
  v104 = v103[36];
  v105 = v103[172];
  v106 = *v669;
  v107 = v103[61];
  memset(v739, 255, sizeof(v739));
  *&v108 = -1;
  *(&v108 + 1) = -1;
  v738 = v108;
  v737 = v108;
  v736 = v108;
  v735 = v108;
  v734 = v108;
  v733 = v108;
  v109 = *v101;
  v704 = v101 + 14;
  v732 = v108;
  *v731 = v108;
  v730 = -1;
  v729 = v108;
  __src = v108;
  if (v87 * v83 > v102)
  {
    v648 = __cxa_allocate_exception(0x10uLL);
    *v648 = "void lppTransposer(HANDLE_SBR_LPP_TRANS, FLOAT **, FLOAT **, const int, const int, const int, const int, const int, const int, INVF_MODE *, INVF_MODE *)";
    v648[2] = 178;
  }

  v110 = (v106 * v83);
  v111 = (v87 * v83 + v109);
  v685 = v107;
  inverseFilteringLevelEmphasis(v86, v107, (v39 + 44), (v660 + 248), v739);
  v112 = v111;
  v701 = *v101;
  v697 = v101[72];
  v711 = v110;
  v113 = v111 - v110;
  v718 = v111;
  if (v111 > v110)
  {
    v114 = &v704[6 * v101[1]];
    v115 = *(v114 - 1) + *(v114 - 3);
    v116 = v711;
    do
    {
      bzero((__b[v116] + 4 * v115), (256 - 4 * v115));
      bzero((*&v726[8 * v116] + 4 * v115), (256 - 4 * v115));
      v112 = v111;
      ++v116;
    }

    while (v116 < v111);
  }

  memset(v740, 0, sizeof(v740));
  if (v104)
  {
    v117 = v101[72];
    *&v118 = -1;
    *(&v118 + 1) = -1;
    v742[7] = v118;
    v742[6] = v118;
    v742[5] = v118;
    v742[4] = v118;
    v742[3] = v118;
    v742[2] = v118;
    v742[1] = v118;
    v742[0] = v118;
    if (v105)
    {
      v119 = 0;
      v120 = v711;
      v121 = v718;
      v122 = 0.0;
      do
      {
        v123 = 0.0;
        if (v120 < v117)
        {
          v124 = &__b[v711];
          v125 = &v726[8 * v711];
          v126 = v117 - v711;
          do
          {
            v127 = *v124++;
            v128 = *(v127 + 4 * v119);
            v129 = *v125++;
            v123 = v123 + ((*(v129 + 4 * v119) * *(v129 + 4 * v119)) + (v128 * v128));
            --v126;
          }

          while (v126);
        }

        v130 = 0.0;
        v131 = 0.0;
        if (v121 > v117)
        {
          v132 = &__b[v117];
          v133 = &v726[8 * v117];
          v134 = v117 - v718;
          do
          {
            v135 = *v132++;
            v136 = *(v135 + 4 * v119);
            v137 = *v133++;
            v131 = v131 + ((*(v137 + 4 * v119) * *(v137 + 4 * v119)) + (v136 * v136));
            _CF = __CFADD__(v134++, 1);
          }

          while (!_CF);
        }

        v138 = (v123 + v131) / v113;
        if (v138 > 0.0)
        {
          v139 = log((v138 + 1.0));
          v121 = v718;
          v120 = v711;
          *&v139 = v139 * 1.44269504;
          v130 = *&v139 * 3.0103;
        }

        *(v742 + v119) = v130;
        v122 = v122 + (v130 / v105);
        ++v119;
      }

      while (v119 != v105);
      v140 = v742;
      v141 = v105;
      do
      {
        *v140 = v122 - *v140;
        ++v140;
        --v141;
      }

      while (v141);
      if (v105 <= 4)
      {
        v261 = v731;
        v262 = v742;
        do
        {
          v263 = *v262++;
          v264 = exp2((v263 * 0.1661));
          *v261 = v264;
          v261 += 4;
          --v105;
        }

        while (v105);
      }

      else
      {
        if (v105 > 0x20)
        {
          v654 = __cxa_allocate_exception(0x10uLL);
          *v654 = "void polyfit(const int, const FLOAT *const, FLOAT *)";
          v654[2] = 383;
        }

        v142 = 0;
        v143 = 0uLL;
        __asm { FMOV            V1.4S, #1.0 }

        do
        {
          v147 = v142;
          v148.i32[3] = HIDWORD(_Q1);
          v148.f32[0] = (v147 * v147) * v147;
          v148.f32[1] = v147 * v147;
          v148.f32[2] = v142;
          v143 = vmlaq_n_f32(v143, v148, *(v742 + v142++));
        }

        while (v105 != v142);
        v149 = 0;
        v150 = 0;
        v741 = v143;
        v151 = &bsd + 80 * (v105 - 5);
        v152 = vmulq_f32(v143, *(v151 + 24));
        v743[0] = v152;
        v153 = -1;
        v741.i32[0] = v152.i32[0];
        v154 = 1;
        v155 = &v741;
        do
        {
          v156 = *(v743 + v154);
          if (v154 <= 1)
          {
            ++v153;
          }

          else
          {
            v157 = &v151[4 * v150];
            v158 = v155;
            v159 = v154;
            do
            {
              v160 = *v157++;
              v161 = v160;
              v162 = *v158--;
              v156 = v156 - (v161 * v162);
              --v159;
            }

            while (v159 > 1);
            v150 += ++v153;
          }

          v741.f32[v154] = (v156 - v152.f32[0]) * *&v151[4 * v154 + 8];
          ++v154;
          ++v149;
          v155 = (v155 + 4);
        }

        while (v149 != 3);
        v163 = 0;
        v743[0] = vmulq_f32(v741, *(v151 + 4));
        *(&v741 | 0xC) = HIDWORD(v743[0]);
        v164 = 2;
        v165 = 1;
        v166 = 12;
        do
        {
          v167 = *(v743 + v164);
          v168 = v163;
          v169 = v166;
          v170 = (&bsd + 80 * (v105 - 5) + 4 * v163 + 40);
          do
          {
            v171 = *v170++;
            v167 = v167 - (v171 * *(v741.f32 + v169));
            v169 += 4;
          }

          while (v169 != 16);
          v163 = v168 + v165;
          v741.f32[v164--] = v167;
          ++v165;
          v166 -= 4;
        }

        while (v165 != 4);
        v172 = 0;
        v173 = v741.i32[0];
        v174 = v741.i32[3];
        do
        {
          v175 = *&v174;
          if (v172)
          {
            v176 = 1;
            v175 = *&v173;
            do
            {
              v175 = v741.f32[v176++] + (v172 * v175);
            }

            while (v176 != 4);
          }

          v177 = exp2((v175 * 0.1661));
          *&v731[4 * v172++] = v177;
        }

        while (v172 != v105);
      }
    }

    v112 = v718;
  }

  v265 = v101[2];
  v694 = v101[3];
  v198 = *v681;
  if (v265 < v694)
  {
    v266 = v101[72] - v711 + *v101;
    v267 = 4 * v711 + 8;
    v268 = *v681 + 4 * v265;
    v723 = v711 - v112;
    do
    {
      v269 = 0;
      *&v742[19] = -1;
      *&v270 = -1;
      *(&v270 + 1) = -1;
      v742[18] = v270;
      v742[17] = v270;
      v742[16] = v270;
      v742[15] = v270;
      v742[14] = v270;
      v742[13] = v270;
      v742[12] = v270;
      v742[11] = v270;
      v742[10] = v270;
      v742[9] = v270;
      v742[8] = v270;
      v742[7] = v270;
      v742[6] = v270;
      v742[5] = v270;
      v742[4] = v270;
      v742[3] = v270;
      v742[2] = v270;
      v742[1] = v270;
      v742[0] = v270;
      *&v743[19] = -1;
      v743[18] = v270;
      v743[17] = v270;
      v743[16] = v270;
      v743[15] = v270;
      v743[14] = v270;
      v743[13] = v270;
      v743[12] = v270;
      v743[11] = v270;
      v743[10] = v270;
      v743[9] = v270;
      v743[8] = v270;
      v743[7] = v270;
      v743[6] = v270;
      v743[5] = v270;
      v743[4] = v270;
      v743[3] = v270;
      v743[2] = v270;
      *v717 = v268;
      v743[1] = v270;
      v743[0] = v270;
      do
      {
        *(v742 + v269) = *(v268 + 656);
        *(v743 + v269) = *(v268 + 2448);
        v269 += 4;
        v268 += 128;
      }

      while (v267 != v269);
      if (v266 >= 1)
      {
        v271 = 0;
        v272 = v743 + v269;
        v273 = v742 + v269;
        do
        {
          *&v273[4 * v271] = *(__b[v711 + v271] + 4 * v265);
          *&v272[4 * v271] = *(*&v726[8 * v711 + 8 * v271] + 4 * v265);
          ++v271;
        }

        while (v271 < v266);
      }

      autoCorr2nd_cplx(&__src, v742 + 2, v743 + 2, v697 + v701);
      v274 = 0.0;
      v275 = 0.0;
      v276 = 0.0;
      if (*(&v730 + 1) != 0.0)
      {
        v276 = (((*(&__src + 3) * *(&v729 + 1)) - (*(&v729 + 2) * *&v730)) - (*&v729 * *(&__src + 1))) / *(&v730 + 1);
        v275 = (((*(&__src + 3) * *&v730) + (*(&v729 + 2) * *(&v729 + 1))) - (*(&v729 + 3) * *(&__src + 1))) / *(&v730 + 1);
      }

      v277 = 0.0;
      if (*(&__src + 1) != 0.0)
      {
        v277 = -((*(&__src + 3) + (v276 * *(&v729 + 1))) + (v275 * *&v730)) / *(&__src + 1);
        v274 = -((*(&v729 + 2) + (v275 * *(&v729 + 1))) + (-v276 * *&v730)) / *(&__src + 1);
      }

      v278 = ((v274 * v274) + (v277 * v277)) < 16.0 && ((v275 * v275) + (v276 * v276)) < 16.0;
      v198 = *v681;
      if (!v278)
      {
        v275 = 0.0;
        v274 = 0.0;
        v277 = 0.0;
        v276 = 0.0;
      }

      v279 = v101[1];
      if (v101[1])
      {
        v280 = 0;
        do
        {
          v281 = &v704[6 * v280];
          if (v265 >= *v281 && v265 < v281[1])
          {
            v282 = v265 + v281[4];
            if (v282 > 0x3F)
            {
              v646 = __cxa_allocate_exception(0x10uLL);
              *v646 = "void lppTransposer(HANDLE_SBR_LPP_TRANS, FLOAT **, FLOAT **, const int, const int, const int, const int, const int, const int, INVF_MODE *, INVF_MODE *)";
              v646[2] = 290;
            }

            v283 = *(v740 + v280);
            _CF = v283 <= 4 && v282 >= v101[v283 + 4];
            v285 = *(v740 + v280);
            if (_CF)
            {
              do
              {
                v285 = v283 + 1;
                if (v283 > 3)
                {
                  break;
                }

                v286 = v101[v283++ + 5];
              }

              while (v282 >= v286);
              *(v740 + v280) = v285;
            }

            v287 = *(v739 + v285);
            v288 = v287 * v287;
            if ((v287 * v287) <= 0.0)
            {
              v309 = v742 + v711 + 2;
              v310 = (v743 + v267);
              v311 = &__b[v711];
              v312 = &v726[8 * v711];
              v313 = v723;
              if (v718 > v711)
              {
                do
                {
                  v314 = *v309;
                  v315 = *v310;
                  if (v104)
                  {
                    v316 = *&v731[4 * v265];
                    v314 = v314 * v316;
                    v315 = v315 * v316;
                  }

                  v317 = *v311++;
                  *(v317 + 4 * v282) = v314;
                  v318 = *v312++;
                  *(v318 + 4 * v282) = v315;
                  ++v310;
                  ++v309;
                  _CF = __CFADD__(v313++, 1);
                }

                while (!_CF);
              }
            }

            else if (v718 > v711)
            {
              v289 = v277 * v287;
              v290 = v274 * v287;
              v291 = v276 * v288;
              v292 = v275 * v288;
              v293 = *(v742 + v711);
              v294 = *(v743 + v711);
              v295 = v742 + v711 + 2;
              v296 = (v743 + v267);
              v297 = v723;
              v298 = &__b[v711];
              v299 = &v726[8 * v711];
              do
              {
                v300 = v293;
                v301 = v294;
                v294 = *(v296 - 1);
                v293 = *(v295 - 1);
                v302 = (((v294 * -v290) + (v289 * v293)) + (v291 * v300)) + (-v292 * v301);
                v303 = (((v289 * v294) + (v290 * v293)) + (v292 * v300)) + (v291 * v301);
                v304 = *v295 + v302;
                v305 = *v296 + v303;
                if (v104)
                {
                  v306 = *&v731[4 * v265];
                  v304 = v304 * v306;
                  v305 = v305 * v306;
                }

                v307 = *v298++;
                *(v307 + 4 * v282) = v304;
                v308 = *v299++;
                *(v308 + 4 * v282) = v305;
                ++v296;
                ++v295;
                _CF = __CFADD__(v297++, 1);
              }

              while (!_CF);
            }
          }

          ++v280;
        }

        while (v280 != v279);
      }

      ++v265;
      v268 = *v717 + 4;
    }

    while (v265 != v694);
  }

  v260 = v680;
  if (v685)
  {
    memcpy((v198 + 632), v739, 4 * v685);
    v198 = *v681;
  }

LABEL_189:
  v319 = v682;
  v320 = *(v260 + 1939);
  if (*(v198 + 472) != v320)
  {
    v321 = *(v198 + 11616);
    if (((v320 == 0) & (v662 >> 8)) != 0)
    {
      v322 = *(v198 + 11616);
    }

    else
    {
      v322 = 0;
    }

    if (v321)
    {
      LODWORD(v321) = *(v321 + 56);
    }

    ResetLimiterBands((v682 + 47), (v682 + 60), *(v682 + 64), *(v682 + 40), *(v198 + 624) + 14, *(*(v198 + 624) + 1), *(v682 + 21), v320, v322, v321);
    v198 = *v681;
    *(*v681 + 472) = *(v260 + 1939);
  }

  if (*(v682 + 5))
  {
    v713 = 0;
  }

  else
  {
    v713 = *(v660 + 270) == 0;
  }

  v659 = (v260 + 1872);
  v323 = *(v682 + 44);
  v324 = *(v682 + 45);
  v325 = v324 - v323;
  v664 = *(v682 + 42);
  *&v734 = 0xAAAAAAAAAAAAAAAALL;
  *&v326 = 0xAAAAAAAAAAAAAAAALL;
  *(&v326 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v733 = v326;
  v732 = v326;
  *v731 = v326;
  v702 = *(v260 + 1912);
  v327 = *(v682 + 46);
  v688 = v324;
  if (v324 > v327)
  {
    LOBYTE(v327) = v324;
  }

  v657 = v327;
  v676 = LOBYTE(__dst[0]);
  if (LOBYTE(__dst[0]))
  {
    v328 = (v260 + 28);
    v329 = *(v260 + 28);
    if (*(v260 + 25) <= v329)
    {
      v674 = 0;
      v333 = *(v682 + 72);
      v330 = v658;
      v670 = v682 + 166;
      v679 = (v260 + 1872);
    }

    else
    {
      v679 = (v198 + 476);
      v664 = *(v198 + 496);
      v330 = (v198 + 497);
      v323 = *(v198 + 499);
      v331 = *(v198 + 500);
      v325 = v331 - v323;
      v332 = *(v198 + 501);
      v688 = v331;
      if (v331 > v332)
      {
        LOBYTE(v332) = *(v198 + 500);
      }

      v657 = v332;
      v333 = (v198 + 549);
      *(v682 + 64) = v198 + 520;
      *(v682 + 72) = v198 + 549;
      v670 = v198 + 606;
      v329 = *v328;
      v674 = 0xFFFFFFFFLL;
    }

    v338 = v330[1];
    v339 = *(v260 + 1938);
    v340 = *(v260 + 6);
    *&v341 = 0x2020202020202020;
    *(&v341 + 1) = 0x2020202020202020;
    *v731 = v341;
    v732 = v341;
    v733 = v341;
    *&v734 = 0x2020202020202020;
    if (v340 > v329)
    {
      v342 = *v333;
      v343 = v333[v338];
      if (v342 < v343)
      {
        v344 = v731;
        while (1)
        {
          v345 = v342 >> 5;
          if (((1 << v342) & *(v198 + 616 + 4 * v345)) != 0)
          {
            break;
          }

          if ((*(v198 + 460 + 4 * v345) & (1 << v342)) != 0)
          {
            v346 = *(v198 + 612) - 16;
            goto LABEL_215;
          }

LABEL_216:
          ++v342;
          ++v344;
          if (v343 == v342)
          {
            goto LABEL_217;
          }
        }

        v346 = 0;
LABEL_215:
        *v344 = v346;
        goto LABEL_216;
      }
    }

LABEL_217:
    *(v198 + 612) = v339;
    v336 = *(v260 + 5);
    if (v328[v336] != 16)
    {
      v649 = __cxa_allocate_exception(0x10uLL);
      *v649 = "void calculateSbrEnvelope(HANDLE_SBR_CALCULATE_ENVELOPE, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, PVC_DYNAMIC_DATA *, FLOAT **, FLOAT **, const UINT, const int)";
      v649[2] = 547;
    }

    v335 = *(v260 + 28);
    v337 = 16;
  }

  else
  {
    v334 = v324 - v323;
    mapSineFlags(*(v682 + 72), *(v682 + 41), (v260 + 72), (v198 + 460), (v198 + 616), *(v260 + 23), v731);
    v674 = 0;
    v335 = 0;
    v260 = v680;
    LODWORD(v336) = *(v680 + 5);
    v679 = v659;
    v670 = v682 + 166;
    v330 = v658;
    v337 = v336;
    v319 = v682;
    v325 = v334;
  }

  if (v335 >= v337)
  {
    goto LABEL_484;
  }

  v691 = v330;
  v672 = v319 + 64;
  v705 = (v260 + 80);
  v666 = v260 + 25;
  v667 = v260 + 15;
  v663 = v260 + 1913;
  v347 = v335;
  v665 = v337;
  v695 = BYTE5(__dst[5]);
  do
  {
    memset(v742, 255, sizeof(v742));
    v348 = *(v682 + 8);
    if (v676)
    {
      v349 = *(v680 + 15);
      if (v349 != *(*(v680 + 5) + v667 - 1))
      {
        v647 = __cxa_allocate_exception(0x10uLL);
        *v647 = "void calculateSbrEnvelope(HANDLE_SBR_CALCULATE_ENVELOPE, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, PVC_DYNAMIC_DATA *, FLOAT **, FLOAT **, const UINT, const int)";
        v647[2] = 566;
      }

      bzero(v742, 0x460uLL);
      v351 = &__dst[4 * v347 + 10];
      if (v695)
      {
        v352 = 0;
        LODWORD(v353) = 0;
        v354 = *v681;
        do
        {
          v355 = v352 + 1;
          v356 = *(&__dst[4] + v352 + 5);
          if (v353 < v356)
          {
            v353 = v353;
            v357 = *(v351 + v352);
            do
            {
              *(v742 + v353++) = v357;
            }

            while (v356 != v353);
          }

          ++v352;
        }

        while (v355 != v695);
        v358 = v695;
        if (v353 > 55)
        {
          goto LABEL_246;
        }
      }

      else
      {
        LODWORD(v353) = 0;
        v358 = 0;
        v354 = *v681;
      }

      v365 = 0;
      v350.i32[0] = *(v351 + v358 - 1);
      v366 = (59 - v353) & 0xFFFFFFFFFFFFFFFCLL;
      v367 = vdupq_n_s64(55 - v353);
      v368 = v742 + v353 + 2;
      do
      {
        v369 = vdupq_n_s64(v365);
        v370 = vmovn_s64(vcgeq_u64(v367, vorrq_s8(v369, xmmword_19B0A5850)));
        if (vuzp1_s16(v370, v350).u8[0])
        {
          *(v368 - 2) = v350.i32[0];
        }

        if (vuzp1_s16(v370, v350).i8[2])
        {
          *(v368 - 1) = v350.i32[0];
        }

        if (vuzp1_s16(v350, vmovn_s64(vcgeq_u64(v367, vorrq_s8(v369, xmmword_19B0A5840)))).i32[1])
        {
          *v368 = v350.i32[0];
          v368[1] = v350.i32[0];
        }

        v365 += 4;
        v368 += 4;
      }

      while (v366 != v365);
LABEL_246:
      if (v347 == *v669)
      {
        v371 = v325;
        v372 = v354;
        mapSineFlags(*(v682 + 72), v691[1], (v680 + 72), (v354 + 460), (v354 + 616), *(v680 + 1938), v731);
        v354 = v372;
        v325 = v371;
      }

      v360 = v347 + 1;
      v364 = v674;
      if (v347 >= *(v666 + v674 + 1))
      {
        if ((v674 & 0x80000000) != 0)
        {
          v664 = *(v682 + 42);
          v323 = *(v682 + 44);
          v373 = *(v682 + 45);
          v720 = v373 - v323;
          v374 = *(v682 + 46);
          v688 = v373;
          if (v373 > v374)
          {
            LOBYTE(v374) = *(v682 + 45);
          }

          v657 = v374;
          v359 = v347;
          *(v682 + 64) = v319 + 80;
          *(v682 + 72) = v319 + 109;
          v691 = v658;
          v670 = v682 + 166;
          v679 = v659;
        }

        else
        {
          v720 = v325;
          v679 += 4 * v664;
          v359 = v347;
        }

        v364 = v674 + 1;
      }

      else
      {
        v720 = v325;
        v359 = v347;
      }

      goto LABEL_256;
    }

    v720 = v325;
    v359 = v669[v347];
    v360 = v669[v347 + 1];
    v349 = *(v667 + v347);
    bzero(v742, 0x460uLL);
    v361 = v674 + 1;
    v362 = *(v666 + v361);
    v363 = v679;
    if (v359 == v362)
    {
      v363 = &v679[4 * v664];
    }

    v679 = v363;
    if (v359 == v362)
    {
      v364 = v361;
    }

    else
    {
      v364 = v674;
    }

    v354 = *v681;
LABEL_256:
    v375 = v348;
    if (v347 == *(v680 + 23) || v347 == *(v354 + 456))
    {
      v376 = 0;
      v699 = 0;
      v377 = 1;
    }

    else
    {
      v377 = 0;
      v699 = (4 - 4 * *(v682 + 24)) & 0xFC;
      v376 = 1;
    }

    v674 = v364;
    v378 = (v359 * v375);
    v379 = (v360 * v375);
    if (*(v682 + 23))
    {
      if (v323 < v688)
      {
        v380 = v323;
        v381 = &v742[14];
        do
        {
          v382 = 0.0;
          if (v379 > v378)
          {
            v383 = &__b[v378];
            v384 = &v726[8 * v378];
            v385 = v379 - v378;
            do
            {
              v386 = *v383++;
              v387 = v382 + (*(v386 + 4 * v380) * *(v386 + 4 * v380));
              v388 = *v384++;
              v382 = v387 + (*(v388 + 4 * v380) * *(v388 + 4 * v380));
              --v385;
            }

            while (v385);
          }

          *v381++ = v382 / (v379 - v378);
          ++v380;
        }

        while (v688 > v380);
      }
    }

    else
    {
      v389 = v691[v349];
      if (v691[v349])
      {
        v390 = 0;
        v391 = *(v672 + 8 * v349);
        v392 = &v742[14];
        do
        {
          v393 = *(v391 + v390++);
          v394 = *(v391 + v390);
          if (v393 < v394)
          {
            v395 = 0.0;
            v396 = v393;
            do
            {
              v397 = 0.0;
              if (v379 > v378)
              {
                v398 = &__b[v378];
                v399 = &v726[8 * v378];
                v400 = v379 - v378;
                do
                {
                  v401 = *v398++;
                  v402 = v397 + (*(v401 + 4 * v396) * *(v401 + 4 * v396));
                  v403 = *v399++;
                  v397 = v402 + (*(v403 + 4 * v396) * *(v403 + 4 * v396));
                  --v400;
                }

                while (v400);
              }

              v395 = v395 + v397;
              ++v396;
            }

            while (v396 != v394);
            v404 = v394 - v393;
            v405 = (v395 / (v379 - v378)) / v404;
            do
            {
              *v392++ = v405;
              --v404;
            }

            while (v404);
          }
        }

        while (v390 != v389);
      }
    }

    v406 = *(v672 + 8 * v349);
    v407 = (v670 + 1);
    v408 = (v679 + 4);
    v409 = *v679;
    v410 = v691[v349];
    if (!v676)
    {
      if (!v691[v349])
      {
        goto LABEL_319;
      }

      v430 = 0;
      v431 = 0;
      LODWORD(v432) = 0;
      while (1)
      {
        v433 = *(v406 + v430++);
        v434 = *(v406 + v430);
        if (v433 < v434)
        {
          break;
        }

LABEL_318:
        ++v705;
        if (v430 >= v410)
        {
          goto LABEL_319;
        }
      }

      v435 = 0;
      v436 = *v705;
      v432 = v432;
      v437 = v434 - v433;
      do
      {
        v435 |= v347 >= v731[v432++];
        --v437;
      }

      while (v437);
      v438 = v431;
      v439 = v433;
      v440 = v742 + 4 * v431;
      while (1)
      {
        if (v439 >= *v407)
        {
          v441 = *v408++;
          v409 = v441;
          ++v407;
        }

        if (v323 > v433)
        {
          v645 = __cxa_allocate_exception(0x10uLL);
          *v645 = "void calculateSbrEnvelope(HANDLE_SBR_CALCULATE_ENVELOPE, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, PVC_DYNAMIC_DATA *, FLOAT **, FLOAT **, const UINT, const int)";
          v645[2] = 718;
        }

        *(v440 + 224) = 0;
        v442 = v731[v438];
        v443 = (v440 + 448);
        v444 = *(v440 + 56) + 1.0;
        v445 = v409 + 1.0;
        *(v440 + 168) = (v436 * v409) / (v409 + 1.0);
        if (!v435)
        {
          break;
        }

        *v443 = (v436 * v409) / (v445 * v444);
        if (v347 >= v442)
        {
          v443 = &v742[56] + v438;
LABEL_315:
          *v443 = v436 / v445;
        }

        *v440 = v436;
        v440 += 4;
        ++v438;
        if (v434 == ++v439)
        {
          v410 = v691[v349];
          v431 = v438;
          goto LABEL_318;
        }
      }

      v445 = v445 * v444;
      if (!v376)
      {
        v445 = v444;
      }

      goto LABEL_315;
    }

    if (!v691[v349])
    {
      goto LABEL_319;
    }

    v411 = 0;
    v412 = 0;
    LODWORD(v413) = 0;
    do
    {
      v414 = *(v406 + v411++);
      v415 = *(v406 + v411);
      if (v414 >= v415)
      {
        continue;
      }

      v416 = 0;
      v413 = v413;
      v417 = v415 - v414;
      do
      {
        v416 |= v347 >= v731[v413++];
        --v417;
      }

      while (v417);
      v418 = 0;
      v419 = v412;
      v420 = v415 - v414;
      v421 = &v731[v412];
      v422 = v412;
      v423 = &v742[28] + 4 * v412;
      do
      {
        if (v414 + v418 >= *v407)
        {
          v424 = *v408++;
          v409 = v424;
          ++v407;
        }

        if (v323 > v414)
        {
          v644 = __cxa_allocate_exception(0x10uLL);
          *v644 = "void calculateSbrEnvelope(HANDLE_SBR_CALCULATE_ENVELOPE, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, PVC_DYNAMIC_DATA *, FLOAT **, FLOAT **, const UINT, const int)";
          v644[2] = 687;
        }

        v425 = *(v742 + v414 + v418 - v323);
        *(v423 + 112) = 0;
        v426 = v421[v418];
        v427 = *(v423 - 56) + 1.0;
        v428 = v409 + 1.0;
        *(v423 + 56) = (v425 * v409) / (v409 + 1.0);
        if (v416)
        {
          *v423 = (v425 * v409) / ((v409 + 1.0) * v427);
          if (v347 < v426)
          {
            goto LABEL_297;
          }

          v429 = &v742[56] + v422;
        }

        else
        {
          if (v376)
          {
            v428 = (v409 + 1.0) * v427;
          }

          else
          {
            v428 = v427;
          }

          v429 = v423;
        }

        *v429 = v425 / v428;
LABEL_297:
        ++v422;
        ++v418;
        v423 += 4;
      }

      while (v420 != v418);
      v412 = v419 + v418;
      v410 = v691[v349];
    }

    while (v411 < v410);
LABEL_319:
    v446 = *(v682 + 60);
    if (*(v682 + 60))
    {
      v447 = 0;
      v448 = CDK_sbrDecoder_sbr_limGains[*(v682 + 22)];
      v449 = *(v682 + 47);
      do
      {
        ++v447;
        v450 = *(v319 + 47 + v447);
        v451 = 0.0;
        v452 = 0.0;
        if (v449 < v450)
        {
          v453 = v450 - v449;
          v454 = v742 + v449;
          do
          {
            v451 = v451 + *v454;
            v452 = v452 + v454[56];
            ++v454;
            --v453;
          }

          while (v453);
        }

        if (v452 == 0.0)
        {
          v455 = v451;
        }

        else
        {
          v455 = v451 / v452;
        }

        v456 = v455 * v448;
        if (v713)
        {
          if (v456 > 1.0e10)
          {
            v456 = 1.0e10;
          }
        }

        else if (v456 > 1.0)
        {
          v456 = 1.0;
        }

        if (v449 < v450)
        {
          v457 = 4 * v449;
          v458 = (&v742[42] + v457);
          v459 = v450 - v449;
          v460 = v459;
          do
          {
            v461 = *(v458 - 56);
            if (v461 > v456)
            {
              *v458 = (v456 * *v458) / v461;
              *(v458 - 56) = v456;
            }

            ++v458;
            --v460;
          }

          while (v460);
          v462 = (&v742[28] + v457);
          v463 = 0.0;
          v464 = v459;
          v465 = v462;
          do
          {
            v463 = v463 + (*v465 * *(v465 - 56));
            v466 = v465[112];
            if (v466 == 0.0)
            {
              if (v376)
              {
                v463 = v463 + v465[56];
              }
            }

            else
            {
              v463 = v466 + v463;
            }

            ++v465;
            --v464;
          }

          while (v464);
          if (v463 == 0.0)
          {
            v467 = 2.5119;
          }

          else
          {
            v467 = fminf(v451 / v463, 2.5119);
          }

          do
          {
            *v462 = v467 * *v462;
            v462[112] = v467 * v462[112];
            v462[56] = v467 * v462[56];
            ++v462;
            --v459;
          }

          while (v459);
        }

        v449 = v450;
      }

      while (v447 != v446);
    }

    if (v720 >= 1)
    {
      v468 = v720;
      v469 = &v742[28];
      do
      {
        v469[112] = sqrtf(v469[112]);
        *v469 = sqrtf(*v469);
        v469[56] = sqrtf(v469[56]);
        ++v469;
        --v468;
      }

      while (v468);
    }

    v470 = (4 * v720);
    if (*(v354 + 448))
    {
      v471 = v354;
      CDKmemcpy((v354 + 224), &v742[42], (4 * v720));
      CDKmemcpy(v471, &v742[28], v470);
      *(v471 + 448) = 0;
      v354 = v471;
    }

    v472 = (v379 - v378);
    if (v379 > v378)
    {
      v473 = v378;
      while (1)
      {
        v474 = 0.0;
        if (v473 - v378 < v699)
        {
          v474 = *(&CDK_sbrDecoder_sbr_smoothFilter + v473 - v378);
        }

        v475 = (__b[v473] + 4 * v323);
        v476 = (*&v726[8 * v473] + 4 * v323);
        if (v702)
        {
          v477 = *(v354 + 452);
          *(v354 + 452) = (v477 + v720) & 0x1FF;
          if (v474 <= 0.0)
          {
            v504 = &v742[28];
            v505 = v720;
            if (v720 >= 1)
            {
              do
              {
                v506 = *v504 * *v475;
                v507 = *v504 * *v476;
                LOWORD(v477) = v477 + 1;
                v508 = v376 ^ 1;
                if (v504[112] != 0.0)
                {
                  v508 = 1;
                }

                if ((v508 & 1) == 0)
                {
                  v509 = v504[56];
                  v477 &= 0x1FFu;
                  v510 = (&CDK_sbrDecoder_sbr_randomPhase + 8 * v477);
                  v506 = v506 + (v509 * *v510);
                  v507 = v507 + (v509 * v510[1]);
                }

                *v475++ = v506;
                *v476++ = v507;
                ++v504;
                --v505;
              }

              while (v505);
            }
          }

          else if (v720 >= 1)
          {
            v478 = 1.0 - v474;
            v479 = &v742[28];
            v480 = v354;
            v481 = v720;
            do
            {
              v482 = (v478 * *v479) + (v474 * *v480);
              v483 = *v475 * v482;
              v484 = *v476 * v482;
              LOWORD(v477) = v477 + 1;
              if (v479[112] == 0.0)
              {
                v485 = v377;
              }

              else
              {
                v485 = 1;
              }

              if ((v485 & 1) == 0)
              {
                v486 = (v478 * v479[56]) + (v474 * v480[56]);
                v477 &= 0x1FFu;
                v487 = (&CDK_sbrDecoder_sbr_randomPhase + 8 * v477);
                v483 = v483 + (*v487 * v486);
                v484 = v484 + (v487[1] * v486);
              }

              *v475++ = v483;
              *v476++ = v484;
              ++v480;
              ++v479;
              --v481;
            }

            while (v481);
          }

          goto LABEL_415;
        }

        v488 = *(v354 + 452);
        v489 = *(v354 + 468);
        *(v354 + 452) = (v488 + v720) & 0x1FF;
        *(v354 + 468) = (v489 + 1) & 3;
        if (v474 <= 0.0)
        {
          break;
        }

        if (v720 >= 1)
        {
          v490 = 1.0 - v474;
          v491 = v354;
          v492 = &v742[28];
          v493 = v720;
          v494 = v323 & 1;
          while (1)
          {
            v495 = (v490 * *v492) + (v474 * *v491);
            v496 = v495 * *v475;
            v497 = v495 * *v476;
            LOWORD(v488) = v488 + 1;
            v498 = v492[112];
            if (v498 == 0.0)
            {
              if ((v376 & 1) == 0)
              {
                goto LABEL_385;
              }

              v500 = (v490 * v492[56]) + (v474 * v491[56]);
              v488 &= 0x1FFu;
              v501 = (&CDK_sbrDecoder_sbr_randomPhase + 8 * v488);
              v502 = v500 * *v501;
              v503 = v500 * v501[1];
              *v475 = v496 + v502;
              v497 = v497 + v503;
              goto LABEL_386;
            }

            if (v489 <= 1)
            {
              break;
            }

            if (v489 == 2)
            {
              v496 = v496 - v498;
LABEL_385:
              *v475 = v496;
              goto LABEL_386;
            }

            if (v489 == 3)
            {
              *v475 = v496;
              v499 = v497 - v498;
              v497 = v497 + v498;
              goto LABEL_380;
            }

LABEL_387:
            v494 ^= 1u;
            ++v492;
            ++v491;
            if (!--v493)
            {
              goto LABEL_415;
            }
          }

          if (!v489)
          {
            v496 = v496 + v498;
            goto LABEL_385;
          }

          *v475 = v496;
          v499 = v497 + v498;
          v497 = v497 - v498;
LABEL_380:
          if (!v494)
          {
            v497 = v499;
          }

LABEL_386:
          ++v475;
          *v476++ = v497;
          goto LABEL_387;
        }

LABEL_415:
        if (++v473 == v379)
        {
          goto LABEL_416;
        }
      }

      v511 = &v742[28];
      v512 = v720;
      v513 = v323 & 1;
      if (v720 < 1)
      {
        goto LABEL_415;
      }

      while (2)
      {
        v514 = *v511 * *v475;
        v515 = *v511 * *v476;
        LOWORD(v488) = v488 + 1;
        v516 = v511[112];
        if (v516 == 0.0)
        {
          if (v376)
          {
            v520 = v511[56];
            v488 &= 0x1FFu;
            v521 = (&CDK_sbrDecoder_sbr_randomPhase + 8 * v488);
            v514 = v514 + (v520 * *v521);
            v515 = v515 + (v520 * v521[1]);
          }
        }

        else if (v489 > 1)
        {
          if (v489 == 2)
          {
            v514 = v514 - v516;
          }

          else
          {
            v522 = v515 - v516;
            v518 = v515 + v516;
            if (!v513)
            {
              v518 = v522;
            }

            _ZF = v489 == 3;
LABEL_409:
            if (_ZF)
            {
              v515 = v518;
            }
          }
        }

        else
        {
          if (v489)
          {
            v517 = v515 + v516;
            v518 = v515 - v516;
            if (!v513)
            {
              v518 = v517;
            }

            _ZF = v489 == 1;
            goto LABEL_409;
          }

          v514 = v514 + v516;
        }

        *v475++ = v514;
        *v476++ = v515;
        v513 ^= 1u;
        ++v511;
        if (!--v512)
        {
          goto LABEL_415;
        }

        continue;
      }
    }

LABEL_416:
    if (v702)
    {
      if (*(v663 + v347))
      {
        v523 = (1 << (*(v663 + v347) - 1));
      }

      else
      {
        v523 = 0.0;
      }

      if (*(v663 + v347) && v472 >= 1)
      {
        v524 = v323 + v720;
        memset(v743, 255, sizeof(v743));
        v525 = 0;
        v526 = 0.0;
        v527 = 0.0;
        do
        {
          if (v323 <= 0)
          {
            *(v743 + v525) = 0;
            v534 = 0.0;
          }

          else
          {
            v528 = 0;
            v529 = 0;
            v530 = v525 + v378;
            v531 = *&v726[8 * v530];
            do
            {
              while (1)
              {
                if (v531[v528] == 0.0)
                {
                  v532 = __b[v530];
                  if (v532[v528] == 0.0)
                  {
                    break;
                  }
                }

                ++v528;
                v529 = 1;
                if (v528 == v323)
                {
                  v533 = v743 + v525;
                  *v533 = 0.0;
                  v532 = __b[v530];
                  goto LABEL_432;
                }
              }

              ++v528;
            }

            while (v323 != v528);
            v533 = v743 + v525;
            *v533 = 0.0;
            v534 = 0.0;
            if ((v529 & 1) == 0)
            {
              goto LABEL_436;
            }

LABEL_432:
            v534 = 0.0;
            v535 = v323;
            do
            {
              v536 = *v532++;
              v537 = v534 + (v536 * v536);
              v538 = *v531++;
              v534 = v537 + (v538 * v538);
              --v535;
            }

            while (v535);
            *v533 = v534;
          }

LABEL_436:
          if (v720 <= 0)
          {
            *(&v743[19] + v525) = 0;
            v545 = 0.0;
          }

          else
          {
            v539 = 0;
            v540 = v525 + v378;
            v541 = *&v726[8 * v540];
            v542 = v323;
            do
            {
              while (1)
              {
                if (*(v541 + 4 * v542) == 0.0)
                {
                  v543 = __b[v540];
                  if (*(v543 + 4 * v542) == 0.0)
                  {
                    break;
                  }
                }

                ++v542;
                v539 = 1;
                if (v542 >= v524)
                {
                  v544 = &v743[19] + v525;
                  *v544 = 0.0;
                  v543 = __b[v540];
                  goto LABEL_445;
                }
              }

              ++v542;
            }

            while (v542 < v524);
            v544 = &v743[19] + v525;
            *v544 = 0.0;
            v545 = 0.0;
            if ((v539 & 1) == 0)
            {
              goto LABEL_449;
            }

LABEL_445:
            v545 = 0.0;
            v546 = v323;
            do
            {
              v545 = (v545 + (*(v541 + 4 * v546) * *(v541 + 4 * v546))) + (*(v543 + 4 * v546) * *(v543 + 4 * v546));
              ++v546;
            }

            while (v546 < v524);
            *v544 = v545;
          }

LABEL_449:
          v527 = v527 + v534;
          v526 = v526 + v545;
          ++v525;
        }

        while (v525 != v472);
        v547 = v743;
        v548 = (v379 - v378);
        v354 = *v681;
        do
        {
          v549 = *v547 * v472;
          if (v527 == 0.0)
          {
            if (v549 == 0.0)
            {
              *(v547 + 152) = 0;
            }

            else
            {
              *(v547 + 152) = 1065353216;
            }
          }

          else
          {
            *(v547 + 152) = sqrtf(v549 / v527);
          }

          v547 = (v547 + 4);
          --v548;
        }

        while (v548);
        v550 = 0.0;
        v551 = &v743[19];
        v552 = (v379 - v378);
        do
        {
          v553 = fmaxf(((v551[76] + -1.0) * v523) + 1.0, 0.2);
          v551[76] = v553;
          v554 = v553 * (*v551 * v553);
          *v551++ = v554;
          v550 = v550 + v554;
          --v552;
        }

        while (v552);
        v555 = 0.5;
        if (v526 != 0.0 && v550 != 0.0)
        {
          v555 = (v526 / v550);
        }

        v556 = sqrt(v555);
        v557 = &v743[38];
        v558 = (v379 - v378);
        do
        {
          *v557 = *v557 * v556;
          ++v557;
          --v558;
        }

        while (v558);
        for (k = 0; k != v472; ++k)
        {
          if (v720 >= 1)
          {
            v560 = __b[k + v378];
            v561 = *(&v743[38] + k);
            v562 = *&v726[8 * k + 8 * v378];
            v563 = v323;
            do
            {
              *(v560 + 4 * v563) = v561 * *(v560 + 4 * v563);
              *(v562 + 4 * v563) = v561 * *(v562 + 4 * v563);
              ++v563;
            }

            while (v563 < v524);
          }
        }
      }

      if (v379 > v378)
      {
        do
        {
          v564 = __b[v378];
          v565 = *&v726[8 * v378];
          v566 = *(v354 + 468);
          *(v354 + 468) = (v566 + 1) & 3;
          if (v720 >= 1)
          {
            v567 = &v742[56];
            v568 = v720;
            v569 = v323 & 1;
            v570 = (v564 + 4 * v323);
            v571 = (v565 + 4 * v323);
            do
            {
              v572 = *v567;
              if (*v567 != 0.0)
              {
                if ((v566 & 2) != 0)
                {
                  v572 = -v572;
                }

                if (v566)
                {
                  if (v569 == 1)
                  {
                    v572 = -v572;
                  }

                  *v571 = v572 + *v571;
                }

                else
                {
                  *v570 = v572 + *v570;
                }
              }

              v569 ^= 1u;
              ++v570;
              ++v571;
              ++v567;
              --v568;
            }

            while (v568);
          }

          ++v378;
        }

        while (v378 != v379);
      }
    }

    v573 = v354;
    CDKmemcpy(v354, &v742[28], v470);
    CDKmemcpy((v573 + 224), &v742[42], v470);
    ++v347;
    v325 = v720;
  }

  while (v347 != v665);
  v260 = v680;
  v198 = *v681;
  LODWORD(v336) = *(v680 + 5);
  v319 = v682;
  v330 = v691;
LABEL_484:
  if (*(v260 + 23) == v336)
  {
    v574 = 0;
  }

  else
  {
    v574 = -1;
  }

  *(v198 + 456) = v574;
  if (v676)
  {
    v575 = *(v260 + 24);
    if (*(v260 + 25 + v575 - 1) >= 0x10u)
    {
      v650 = __cxa_allocate_exception(0x10uLL);
      *v650 = "void calculateSbrEnvelope(HANDLE_SBR_CALCULATE_ENVELOPE, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, PVC_DYNAMIC_DATA *, FLOAT **, FLOAT **, const UINT, const int)";
      v650[2] = 916;
    }

    if (*(v260 + 25 + v575) >= 0x11u)
    {
      if (v679 != &v659[4 * ((v575 - 1) * v664)])
      {
        v653 = __cxa_allocate_exception(0x10uLL);
        *v653 = "void calculateSbrEnvelope(HANDLE_SBR_CALCULATE_ENVELOPE, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, PVC_DYNAMIC_DATA *, FLOAT **, FLOAT **, const UINT, const int)";
        v653[2] = 918;
      }

      *(v198 + 496) = v664;
      *(v198 + 497) = *v330;
      v576 = v330 + 1;
      *(v198 + 498) = v330[1];
      *(v198 + 499) = v323;
      *(v198 + 500) = v688;
      *(v198 + 501) = v657;
      CDKmemcpy((v198 + 520), *(v319 + 64), *v330 + 1);
      CDKmemcpy((v198 + 549), *(v682 + 72), *v576 + 1);
      CDKmemcpy((v198 + 606), (v682 + 166), 6uLL);
      CDKmemcpy((v198 + 476), v679, 0x14uLL);
      v260 = v680;
      v319 = v682;
    }
  }

  v577 = *(v319 + 61);
  if (*(v319 + 61))
  {
    v578 = (v260 + 44);
    v579 = (v660 + 248);
    do
    {
      v580 = *v578++;
      *v579++ = v580;
      --v577;
    }

    while (v577);
  }

  *(v660 + 244) = *(v260 + 64);
  *(v660 + 269) = v669[*(v260 + 5)];
  *(v660 + 268) = *(v260 + 68);
  *(v660 + 271) = *(v260 + 1941);
  CDKmemcpy((v660 + 272), (v260 + 4), 0x1DuLL);
  v38 = *v681;
LABEL_496:
  if ((v662 & 0x100) == 0)
  {
    v581 = 48;
    if ((v662 & 4) == 0)
    {
      v581 = 56;
    }

    v582 = v661 + 2;
    v583 = (4 * *(v38[1453] + v581));
    v584 = v38 + 306;
    v585 = &v726[8 * v656 * v655 - 16];
    v586 = &__b[v656 * v655 - 2];
    do
    {
      CDKmemcpy(v584 - 1792, *v586, v583);
      CDKmemcpy(v584, *v585, v583);
      v584 += 128;
      ++v585;
      ++v586;
      --v582;
    }

    while (v582);
  }
}

void *sbr_dec2(void *result, float *a2, uint64_t a3, uint64_t a4, int a5, int a6, UsacQmf *this, unsigned int a8)
{
  v11 = result;
  if ((a6 & 0x400000) == 0)
  {
    v12 = result[1454];
    v13 = *(v12 + 52);
    v14 = *(a3 + 46);
    v15 = v13;
    if (v13 < v14)
    {
      if (v14 >= *(v12 + 40))
      {
        v15 = *(v12 + 40);
      }

      else
      {
        v15 = v14;
      }

      *(v12 + 52) = v15;
    }

    UsacQmf::ProcessSynthesis(this, a8, v15, 0.5, a2, *(result[1453] + 112), *(result[1453] + 120));
    *(v11[1454] + 52) = v13;
    *(a3 + 46) = v13;
    result = CDK_QmfDomain_SaveOverlap(v11[1453]);
  }

  *(v11 + 11680) = 0;
  *(a4 + 270) = *(a3 + 5);
  *(v11 + 2921) = a5;
  return result;
}

char *QmfTransposerApply(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, int a8)
{
  v8 = result;
  v436 = *MEMORY[0x1E69E9840];
  v9 = *(result + 10);
  v10 = *(result + 14);
  v434 = 0x80000000ALL;
  v435 = 6;
  v11 = *(result + 672);
  v433[0] = xmmword_19B0B3640;
  v433[1] = xmmword_19B0B3650;
  v430[1] = 0;
  v430[0] = 0;
  v431 = xmmword_19B0B3660;
  v432 = 10;
  v427[0] = xmmword_19B0A5860;
  v427[1] = xmmword_19B0B20C0;
  v428 = 0x900000008;
  v429 = 10;
  v424 = xmmword_19B0B1930;
  v425 = xmmword_19B0B3670;
  v426 = 0xA00000009;
  if (**(result + 30) >= 0.0)
  {
    v12 = -1.0;
  }

  else
  {
    v12 = 1.0;
  }

  v421 = 0u;
  v422 = 0u;
  v423 = 0x100000000;
  HIDWORD(v421) = 1;
  DWORD1(v422) = 1;
  HIDWORD(v422) = 1;
  *(v420 + 12) = 0u;
  v13 = v9 - a7 - 2;
  v354 = v13;
  if (!a8)
  {
    v13 = 0;
  }

  v353 = v13;
  v419 = 0uLL;
  v420[0] = 0uLL;
  if (v9 < 2)
  {
    goto LABEL_155;
  }

  v359 = 0;
  v368 = -&v398 & 7;
  result = &v398 + v368;
  v356 = v9 >> 1;
  v374 = 12 * (v10 + 1);
  v362 = a6 << (v10 == 0);
  v357 = ((v9 >> 1) - ((a7 + 14) >> 1));
  v364 = &v397 + v368 + 4;
  v369 = v12;
  v372 = (&v398 + v368);
  v378 = 2 * v11;
  v373 = (a6 / ((v10 + 1) * 12.0));
  do
  {
    v14 = v8[673];
    if (v14 >= 1)
    {
      v15 = *(v8 + 8);
      v16 = 2 * v14;
      do
      {
        *v15 = v15[v16];
        ++v15;
        --v14;
      }

      while (v14);
    }

    v17 = 0;
    v367 = 2 * v359;
    v18 = 1;
    do
    {
      v19 = v18;
      v20 = v8[673];
      v21 = *(v8 + 11);
      if (v20 >= 1)
      {
        v22 = v8[672];
        v23 = *(v8 + 30);
        v24 = *(v8 + 31);
        v25 = (*(a3 + 8 * (v17 | v367)) + 4 * v22);
        v26 = (*(a2 + 8 * (v17 | v367)) + 4 * v22);
        v27 = *(v8 + 11);
        v28 = v8[673];
        do
        {
          v29 = *v23++;
          v30 = v29;
          v31 = *v26++;
          v32 = (v12 * v30) * v31;
          *v27 = v32;
          v33 = *v24++;
          v34 = v12 * v33;
          v35 = *v25++;
          *v27++ = v32 + (v34 * v35);
          --v28;
        }

        while (v28);
      }

      v418 = 0xAAAAAAAAAAAAAAAALL;
      *&v36 = 0xAAAAAAAAAAAAAAAALL;
      *(&v36 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v416 = v36;
      v417 = v36;
      v414 = v36;
      v415 = v36;
      v412 = v36;
      v413 = v36;
      v410 = v36;
      v411 = v36;
      v408 = v36;
      v409 = v36;
      v406 = v36;
      v407 = v36;
      v404 = v36;
      v405 = v36;
      v402 = v36;
      v403 = v36;
      v400 = v36;
      v401 = v36;
      v398 = v36;
      v399 = v36;
      v37 = *(v8 + 8);
      v38 = v8[58];
      if (v38)
      {
        if ((v38 & 4) != 0)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "void qmfSynthesisFilteringSlot(HANDLE_QMF_FILTER_BANK, const FLOAT *, const FLOAT *, FLOAT *, const int, FLOAT *)";
          exception[2] = 98;
        }

        v54 = v8[52];
        CDKmemcpy(result, v21, (4 * v8[55]));
        bzero(&v372[v8[55]], (4 * (v54 - v8[55])));
        if ((v54 & 3) != 0)
        {
          v351 = __cxa_allocate_exception(0x10uLL);
          *v351 = "void dct_II(FLOAT *, FLOAT *, int)";
          v351[2] = 201;
        }

        v393[0] = 0xAAAAAAAAAAAAAAAALL;
        LODWORD(v397) = -1431655766;
        dct_getTables(0, v393, &v397, v54);
        v63 = v54 >> 1;
        v64 = &v372[v54];
        if (v54 >> 1 >= 1)
        {
          v65 = v54 - 1;
          v66 = (&v398 + v368 + 4);
          v67 = &v372[v54];
          v68 = (v54 >> 1);
          do
          {
            *v67++ = *(v66 - 1);
            v69 = *v66;
            v66 += 2;
            *&v55 = v69;
            v64[v65--] = v69;
            --v68;
          }

          while (v68);
        }

        v70 = v397;
        fft(v54 >> 1, v64, v55, v56, v57, v58, v59, v60, v61, v62);
        v71 = v70 >> 1;
        v72 = (v54 >> 2);
        v73 = v393[0];
        if (v72 <= 1)
        {
          v74 = v63;
          v106 = v72;
        }

        else
        {
          *v387 = v37;
          v74 = v63;
          v75 = &v398 + 4;
          v76 = &v398 + 4 * v63 + 4;
          v77 = &v397 + 4 * v63 + 4;
          v78 = (v393[0] + 8 * (v63 - 1) * v71);
          v79 = &v397 + 4 * v54 + 4;
          v80 = (v393[0] + 8 * v71);
          v81 = &v397 + 8 * v54 + 4;
          v82 = 2;
          v83 = 4 * v71;
          v84 = &v398 + 4 * v54 + 8;
          do
          {
            v86 = *&v81[v368 - 4];
            v85 = *&v81[v368];
            v88 = *&v84[v368];
            v87 = *&v84[v368 + 4];
            v89 = (v73 + 8 * v83);
            v90 = v89[1];
            v91 = ((v86 - v88) * *v89) + ((v87 + v85) * v90);
            v92 = -(((v86 - v88) * -v90) + ((v87 + v85) * *v89));
            v93 = ((v87 + v85) * -v90) + ((v86 - v88) * *v89);
            v94 = ((v87 + v85) * *v89) + ((v86 - v88) * v90);
            if (v82 < v72)
            {
              v95 = 0;
            }

            else
            {
              v95 = 4 * v71;
            }

            if (v82 < v72)
            {
              v96 = v93;
            }

            else
            {
              v94 = v91;
              v96 = v92;
            }

            v97 = v86 + v88;
            v98 = v87 - v85;
            v99 = v80[1];
            v100 = ((v98 + v96) * v99) + ((v97 + v94) * *v80);
            *&v79[v368] = (((v97 + v94) * v99) - ((v98 + v96) * *v80)) * 0.5;
            *&v75[v368] = v100 * 0.5;
            v101 = v97 - v94;
            v102 = v96 - v98;
            v103 = v78[1];
            v104 = (v102 * v103) + (v101 * *v78);
            *&v76[v368] = ((v101 * v103) - (v102 * *v78)) * 0.5;
            *&v77[v368] = v104 * 0.5;
            if (v82 >= (v72 - 1))
            {
              v105 = -v95;
            }

            else
            {
              v105 = 4 * v71;
            }

            v83 += v105;
            v82 += 2;
            v76 += 4;
            v77 -= 4;
            v78 -= 2 * v71;
            v75 += 4;
            v79 -= 4;
            v80 += 2 * v71;
            v81 -= 8;
            v84 += 8;
          }

          while (2 * (v54 >> 2) != v82);
          v106 = (v54 >> 2);
          v37 = *v387;
        }

        v107 = v64[v74];
        v108 = v64[v63 | 1];
        v109 = (v73 + 8 * v71 * v72);
        v110 = v109[1];
        v111 = (v107 * *v109) - (v110 * v108);
        result = &v398 + v368;
        v372[v54 - v72] = (v108 * *v109) + (v107 * v110);
        v372[v106] = v111;
        *v372 = *v64 + v64[1];
        v112 = (*v64 - v64[1]) * *(v73 + 8 * v71 * v63);
        v372[v74] = v112;
        *v64 = v112 * 0.015625;
        v64[v74] = 0.0;
        v113 = *v372 * 0.015625;
        *v372 = v372[v74] * 0.015625;
        v372[v74] = v113;
        if (v63 >= 4)
        {
          v114 = &v398 + 4;
          v115 = &v398 + 4 * v54 + 4;
          if (v72 <= 2)
          {
            v116 = 2;
          }

          else
          {
            v116 = v72;
          }

          v117 = v116 - 1;
          v118 = &v398 + 4 * v74 + 4;
          v119 = 4 * v74 + 4 * v54;
          v120 = &v398 + v119 + 4;
          v121 = &v397 + 4 * v74 + 4;
          v122 = &v397 + v119 + 4;
          v123 = &v397 + 8 * v54 + 4;
          v124 = &v397 + 4 * v54 + 4;
          do
          {
            v125 = *&v124[v368] * 0.015625;
            *&v122[v368] = v125;
            *&v120[v368] = -v125;
            v126 = *&v118[v368] * 0.015625;
            *&v115[v368] = v126;
            *&v123[v368] = -v126;
            *&v118[v368] = *&v114[v368] * 0.015625;
            *&v124[v368] = *&v121[v368] * 0.015625;
            v127 = *&v114[v368];
            *&v114[v368] = *&v121[v368] * 0.015625;
            *&v121[v368] = v127 * 0.015625;
            v114 += 4;
            v115 += 4;
            v118 += 4;
            v120 += 4;
            v121 -= 4;
            v122 -= 4;
            v123 -= 4;
            v124 -= 4;
            --v117;
          }

          while (v117);
        }

        v128 = v72 + v63;
        v129 = v372[v72 + v63] * 0.015625;
        v64[v72] = v129;
        v64[v128] = -v129;
        v130 = v372[v72] * 0.015625;
        v372[v72] = v130;
        v372[v128] = v130;
      }

      else
      {
        v39 = v8[52];
        CDKmemcpy(result, v21, (4 * v8[55]));
        v40 = &v372[v39];
        CDKmemcpy(v40, 0, (4 * v8[55]));
        v389 = v17;
        v41 = v20;
        v42 = v19;
        v43 = v37;
        v44 = v8[55];
        v45 = (4 * (v8[52] - v44));
        bzero(&v372[v44], v45);
        v46 = &v40[v44];
        v37 = v43;
        v19 = v42;
        v20 = v41;
        LODWORD(v17) = v389;
        bzero(v46, v45);
        dct_IV(v372, v39);
        dst_IV(v40, v39);
        v47 = (v39 >> 1);
        result = &v398 + v368;
        if (v47 >= 1)
        {
          v48 = v39 - 1;
          v49 = (&v398 + v368);
          do
          {
            v50 = *v49;
            v51 = v40[v48];
            v52 = v372[v48];
            v53 = v49[v39];
            *v49 = (v53 - *v49) * 0.0078125;
            v40[v48] = (-v53 - v50) * -0.0078125;
            v372[v48] = (v51 - v52) * 0.0078125;
            v49[v39] = (-v51 - v52) * -0.0078125;
            ++v49;
            --v48;
            --v47;
          }

          while (v47);
        }
      }

      if ((v8[58] & 2) != 0)
      {
        v349 = __cxa_allocate_exception(0x10uLL);
        *v349 = "void qmfSynthesisFilteringSlot(HANDLE_QMF_FILTER_BANK, const FLOAT *, const FLOAT *, FLOAT *, const int, FLOAT *)";
        v349[2] = 108;
      }

      v131 = v8[52];
      if (v131 >= 1)
      {
        v132 = 0;
        v133 = *(v8 + 236);
        v134 = *(v8 + 57);
        v135 = *(v8 + 22);
        v136 = v131 + 1;
        v137 = v37 + 4 * (v20 + v20 * v17) + 4 * v131 - 4;
        v138 = &v364[4 * v131];
        v139 = &v364[8 * v131];
        v140 = *(v8 + 21) + 8;
        v141 = 5 * v133;
        v142 = (v140 - 20 * v133 + 4 * (v8[46] / 2));
        v143 = 20 * v133;
        v144 = -20 * v133;
        v145 = (v140 + 4 * v141);
        do
        {
          v146 = *&v139[4 * v132];
          v147 = *&v138[4 * v132];
          v148 = v134 * (*v135 + (*(v142 - 2) * v147));
          *(v137 + 4 * v132) = v148 + v148;
          v149 = v135[2];
          *v135 = v135[1] + (v145[2] * v146);
          v135[1] = v149 + (*(v142 - 1) * v147);
          v150 = v135[4];
          v135[2] = v135[3] + (v145[1] * v146);
          v135[3] = v150 + (*v142 * v147);
          v151 = v135[6];
          v135[4] = v135[5] + (*v145 * v146);
          v135[5] = v151 + (v142[1] * v147);
          v152 = v135[8];
          v135[6] = v135[7] + (*(v145 - 1) * v146);
          v135[7] = v152 + (v142[2] * v147);
          v135[8] = v146 * *(v145 - 2);
          v135 += 9;
          --v132;
          v142 = (v142 + v144);
          v145 = (v145 + v143);
        }

        while ((v136 + v132) > 1);
      }

      v18 = 0;
      v17 = 1;
      v12 = v369;
    }

    while ((v19 & 1) != 0);
    v418 = 0xAAAAAAAAAAAAAAAALL;
    *&v153 = 0xAAAAAAAAAAAAAAAALL;
    *(&v153 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v416 = v153;
    v417 = v153;
    v414 = v153;
    v415 = v153;
    v412 = v153;
    v413 = v153;
    v410 = v153;
    v411 = v153;
    v408 = v153;
    v409 = v153;
    v406 = v153;
    v407 = v153;
    v404 = v153;
    v405 = v153;
    v402 = v153;
    v403 = v153;
    v400 = v153;
    v401 = v153;
    v398 = v153;
    v399 = v153;
    qmfAnalysisFilteringSlot((v8 + 24), *(*(v8 + 9) + 96), *(*(v8 + 10) + 96), (*(v8 + 8) + 4), (&v398 + (-&v398 & 7)));
    if (v359 <= v357 && a8 == 1)
    {
      for (i = 0; i != 96; i += 8)
      {
        CDKmemcpy(*(*(v8 + 9) + i), *(*(v8 + 9) + i + 8), (4 * v8[34]));
        CDKmemcpy(*(*(v8 + 10) + i), *(*(v8 + 10) + i + 8), (4 * v8[34]));
      }

      goto LABEL_154;
    }

    v155 = v8[6];
    v156 = v378;
    if (v155 < 2)
    {
      goto LABEL_137;
    }

    v157 = *v8;
    v371 = 1;
    v158 = 2;
    do
    {
      v380 = v158 - 1;
      LODWORD(v159) = v8[v158 - 1];
      if (v157 >= v159)
      {
        goto LABEL_136;
      }

      v363 = v158 - 2;
      v160 = *(&v434 + v158 - 2);
      v379 = v158 - 2;
      v377 = v160 / 2 + 6;
      v376 = 6 - v160 / 2;
      v161 = v157;
      v370 = v160 / -2 + 6;
      v383 = 2 * (v160 / 2);
      v384 = 48 - 8 * (v160 / 2);
      v381 = &v425 - 4 * (v160 / 2) + 8;
      v382 = &v422 - 4 * (v160 / 2) + 8;
      *v388 = v158;
      do
      {
        v396 = 0;
        v397 = 0;
        v394 = 0;
        v395 = 0;
        v162 = 2 * v161 / v158;
        if (v162 - v156 < 0)
        {
          v348 = __cxa_allocate_exception(0x10uLL);
          *v348 = "void QmfTransposerApply(HANDLE_HBE_TRANSPOSER, FLOAT **, FLOAT **, FLOAT **, FLOAT **, int, int, KEEP_STATES_SYNCED_MODE)";
          v348[2] = 999;
        }

        v163 = v158 == 4;
        v385 = (v162 - v156);
        calculateCenter(*(*(*(v8 + 9) + 48) + 4 * v385), *(*(*(v8 + 10) + 48) + 4 * v385), &v397, &v396, v158, v379);
        if (v163)
        {
          v164 = v385 - 1;
          if (v161)
          {
            v164 = v385 + 1;
          }

          v165 = &v419;
          v166 = v430;
          v167 = 0.66667;
          v158 = *v388;
          goto LABEL_76;
        }

        v158 = *v388;
        if (*v388 == 2)
        {
          v165 = &v419;
          v166 = v427;
          v167 = 0.33333;
LABEL_75:
          v164 = v385;
LABEL_76:
          v171 = 0.0;
          v390.i32[0] = 0;
          if (v376 < v377)
          {
            v195 = v164;
            if (v164 <= 0)
            {
              v196 = -(-v164 & 3);
            }

            else
            {
              v196 = v164 & 3;
            }

            v197 = (&hintReal_F + 12 * v196 + 4);
            v198 = (&hintReal_F + 12 * ((v164 - 1) & 3) + 4);
            v199 = (&hintReal_F + 12 * ((v164 + 1) & 3) + 4);
            v200 = *&v397;
            v201 = *&v396;
            v202 = v383;
            v203 = v370;
            do
            {
              v204 = *(v166 + v203);
              v205 = *(v8 + 9);
              v206 = *(v8 + 10);
              v171 = *(*(v205 + 8 * v204) + 4 * v195);
              v207 = *(*(v206 + 8 * v204) + 4 * v195);
              if (*(v165 + v203) == 1)
              {
                v208 = (v171 * *v197) - (v207 * *v198);
                v209 = 8 * v204 + 8;
                v210 = *(*(v205 + v209) + 4 * v195);
                v211 = (v207 * *v197) + (v171 * *v198);
                v212 = *(*(v206 + v209) + 4 * v195);
                v171 = v208 + ((v210 * *v197) - (v212 * *v199));
                v207 = v211 + ((*v197 * v212) + (v210 * *v199));
              }

              v390.f32[0] = v207;
              addHighBandPart(v171, v207, v167, v200, v201, v158, (*(*(v8 + 332) + 8 * v203) + 4 * v161), (*(*(v8 + 333) + 8 * v203) + 4 * v161));
              ++v203;
              --v202;
              v158 = *v388;
            }

            while (v202);
          }

          goto LABEL_84;
        }

        if (2 * v161 % 3 != 2)
        {
          v165 = &v421;
          v166 = &v424;
          v167 = 0.4714;
          goto LABEL_75;
        }

        v168 = (v385 + 1);
        calculateCenter(*(*(*(v8 + 9) + 48) + 4 * v168), *(*(*(v8 + 10) + 48) + 4 * v168), &v397 + 1, &v396 + 1, v388[0], v379);
        v171 = 0.0;
        v390.i32[0] = 0;
        v158 = *v388;
        if (v376 < v377)
        {
          v172 = 0;
          v173 = v385;
          v174 = v397;
          v175 = v396;
          do
          {
            v176 = *&v381[4 * v172];
            v177 = *(v8 + 9);
            v178 = *(v8 + 10);
            v179 = *(v177 + 8 * v176);
            LODWORD(v180) = *(v179 + 4 * v173);
            v181 = *(v179 + 4 * v168);
            v182 = *(v178 + 8 * v176);
            v170.i32[0] = *(v182 + 4 * v173);
            v170.i32[1] = *(v182 + 4 * v168);
            if (*&v382[4 * v172] == 1)
            {
              v183 = 8 * v176 + 8;
              v184 = *(v177 + v183);
              v185 = *(v178 + v183);
              v186.i64[0] = *(&hintReal_F + 12 * (v385 & 3) + 4);
              v187.i64[0] = *(&hintReal_F + 12 * ((v385 - 1) & 3) + 4);
              v169.i32[0] = *(v185 + 4 * v173);
              v169.i32[1] = *(v185 + 4 * v168);
              v188 = vnegq_f32(v170).u64[0];
              v170.i64[1] = v187.i64[0];
              v189.i64[0] = *(&hintReal_F + 12 * ((v385 + 1) & 3) + 4);
              v187.i64[1] = v186.i64[0];
              v190.i64[0] = v186.i64[0];
              v190.i64[1] = v189.i64[0];
              v189.i64[1] = v186.i64[0];
              v186.i64[1] = v188;
              HIDWORD(v180) = v181;
              v191 = vmlaq_f32(vmulq_f32(v170, v186), v187, vdupq_lane_s64(v180, 0));
              v169.i64[1] = vnegq_f32(v169).u64[0];
              LODWORD(v192) = *(v184 + 4 * v173);
              HIDWORD(v192) = *(v184 + 4 * v168);
              v170 = vaddq_f32(v191, vmlaq_f32(vmulq_f32(v190, v169), v189, vdupq_lane_s64(v192, 0)));
            }

            else
            {
              v170.i64[1] = __PAIR64__(v181, v180);
            }

            v193 = v170.i32[1];
            v390 = v170;
            v194 = v170.i32[3];
            addHighBandPart(v170.f32[3], v170.f32[1], 0.2357, *&v174, *&v175, v158, (*(*(v8 + 332) + v384 + 8 * v172) + 4 * v161), (*(*(v8 + 333) + v384 + 8 * v172) + 4 * v161));
            v171 = v390.f32[2];
            addHighBandPart(v390.f32[2], v390.f32[0], 0.2357, *(&v174 + 1), *(&v175 + 1), v388[0], (*(*(v8 + 332) + v384 + 8 * v172) + 4 * v161), (*(*(v8 + 333) + v384 + 8 * v172) + 4 * v161));
            ++v172;
            v158 = *v388;
            v173 = v385;
          }

          while (v383 != v172);
          HIDWORD(v395) = v194;
          HIDWORD(v394) = v193;
        }

LABEL_84:
        *&v395 = v171;
        LODWORD(v394) = v390.i32[0];
        v156 = v378;
        if (v374 <= a6)
        {
          LODWORD(v213) = 0;
          v214 = 0;
          v215 = 0;
          v217 = *(v8 + 9);
          v216 = *(v8 + 10);
          v218 = v217[6];
          v219 = v216[6];
          v220 = 0.0;
          v221 = 1;
          v222 = v371;
          do
          {
            v223 = *(v433 + v380) * (v161 * 2.0 + 1.0 - v221 * v373);
            v224 = v223 - v378;
            if ((v224 & 0x80000000) == 0)
            {
              v225 = (v223 + v373) - v378;
              if (v225 < 2 * v8[673])
              {
                v226 = *(v218 + 4 * v225);
                v227 = (*(v218 + 4 * v224) * *(v218 + 4 * v224)) + (*(v219 + 4 * v224) * *(v219 + 4 * v224));
                if (v227 >= ((v226 * v226) + (*(v219 + 4 * v225) * *(v219 + 4 * v225))))
                {
                  v227 = (v226 * v226) + (*(v219 + 4 * v225) * *(v219 + 4 * v225));
                }

                if (v227 > v220)
                {
                  v215 = v221;
                  v214 = v224;
                  LODWORD(v213) = v225;
                  v220 = v227;
                }
              }
            }

            ++v221;
            --v222;
          }

          while (v222);
          if (v220 > ((*(v218 + 4 * v385) * *(v218 + 4 * v385)) + (*(v219 + 4 * v385) * *(v219 + 4 * v385))) && v213 < 2 * v8[673])
          {
            v228 = v158 - v215;
            switch(v158)
            {
              case 4:
                v229 = -1.0;
                if (!v8[670])
                {
                  v386 = 6.0;
                  goto LABEL_116;
                }

                if (v215 == 2)
                {
                  v386 = 6.0;
                  *&v397 = *(v218 + 4 * v214) + *(v218 + 4 * v214);
                  v269 = *(v219 + 4 * v214);
                  v270 = v213;
                  *&v396 = v269 + v269;
                  v271 = &v395;
                  v272 = &v394;
                  v273 = 1;
                  v274 = 5;
                  do
                  {
                    v275 = v273;
                    v276 = *(v217[v274] + 4 * v270);
                    *v271 = v276 + v276;
                    v277 = *(v216[v274] + 4 * v270);
                    *v272 = v277 + v277;
                    v272 = &v394 + 1;
                    v271 = &v395 + 1;
                    v274 = 6;
                    v273 = 0;
                  }

                  while ((v275 & 1) != 0);
                  LODWORD(v171) = v395;
                  v390.i32[0] = v394;
                  v254 = 2;
                  v228 = 2;
                }

                else
                {
                  v386 = 6.0;
                  if (v215 == 1)
                  {
                    v255 = *(v219 + 4 * v214);
                    LODWORD(v397) = *(v218 + 4 * v214);
                    LODWORD(v396) = v255;
                    v171 = *(v217[4] + 4 * v213);
                    v256 = *(v216[4] + 4 * v213);
                    v395 = __PAIR64__(*(v218 + 4 * v213), LODWORD(v171));
                    v390.i32[0] = v256;
                    v394 = __PAIR64__(*(v219 + 4 * v213), v256);
                    v254 = v158 - 1;
                    v228 = 1;
                  }

                  else
                  {
                    v278 = *(v219 + 4 * v213);
                    LODWORD(v397) = *(v218 + 4 * v213);
                    LODWORD(v396) = v278;
                    v171 = *(v217[4] + 4 * v214);
                    v279 = *(v216[4] + 4 * v214);
                    v395 = __PAIR64__(*(v218 + 4 * v214), LODWORD(v171));
                    v390.i32[0] = v279;
                    v394 = __PAIR64__(*(v219 + 4 * v214), v279);
                    v229 = 1.0;
                    v254 = v215;
                  }
                }

                break;
              case 3:
                v386 = 5.6568;
                if (!v8[669])
                {
                  v229 = -1.0;
                  goto LABEL_116;
                }

                v232 = v216[4];
                v233 = v214;
                v235 = v217[4];
                v234 = v217[5];
                if (v215 == 1)
                {
                  v236 = *(v235 + 4 * v213);
                  v237 = v213;
                  v238 = *(v232 + 4 * v213);
                  if (v213 <= 0)
                  {
                    v239 = -(-v213 & 3);
                  }

                  else
                  {
                    v239 = v213 & 3;
                  }

                  v240 = factors[v239];
                  v241 = (v213 + 3) & 3;
                  if (v213 + 3 <= 0)
                  {
                    v241 = -(-(v213 + 3) & 3);
                  }

                  v242 = factors[v241];
                  v243 = (v240 * v236) - (v242 * v238);
                  v244 = *(v234 + 4 * v213);
                  v245 = *(v216[5] + 4 * v213);
                  v246 = (v238 * v240) + (v242 * v236);
                  v247 = v213 + 1;
                  v249 = -(v213 + 1);
                  _NF = v249 < 0;
                  v250 = v249 & 3;
                  v251 = v247 & 3;
                  if (!_NF)
                  {
                    v251 = -v250;
                  }

                  v252 = factors[v251];
                  v171 = v243 + ((v240 * v244) - (v252 * v245));
                  v253 = v246 + ((v240 * v245) + (v252 * v244));
                  v229 = -1.0;
                  v213 = v233;
                  v254 = 2;
                  v228 = 1;
                }

                else
                {
                  v257 = *(v235 + 4 * v214);
                  v258 = *(v232 + 4 * v214);
                  v213 = v213;
                  v259 = factors[v214 & 3];
                  v260 = factors[(v214 - 1) & 3];
                  v261 = (v259 * v257) - (v260 * v258);
                  v262 = (v258 * v259) + (v260 * v257);
                  v263 = *(v234 + 4 * v214);
                  v264 = *(v216[5] + 4 * v214);
                  v265 = factors[(v214 + 1) & 3];
                  v171 = v261 + ((v259 * v263) - (v265 * v264));
                  v253 = v262 + ((v259 * v264) + (v265 * v263));
                  v229 = 1.0;
                  v237 = v214;
                  v254 = v215;
                }

                v266 = *(v219 + 4 * v237);
                v267 = *(v218 + 4 * v237);
                v268 = *(v219 + 4 * v213);
                LODWORD(v397) = *(v218 + 4 * v213);
                LODWORD(v396) = v268;
                v395 = __PAIR64__(v267, LODWORD(v171));
                v390.f32[0] = v253;
                v394 = __PAIR64__(v266, LODWORD(v253));
                break;
              case 2:
                v229 = -1.0;
                v386 = 5.0;
                if (v8[668])
                {
                  v230 = *(v219 + 4 * v214);
                  LODWORD(v397) = *(v218 + 4 * v214);
                  LODWORD(v396) = v230;
                  v171 = *(v217[5] + 4 * v213);
                  v231 = *(v216[5] + 4 * v213);
                  v395 = __PAIR64__(*(v218 + 4 * v213), LODWORD(v171));
                  v390.i32[0] = v231;
                  v394 = __PAIR64__(*(v219 + 4 * v213), v231);
                }

LABEL_116:
                v254 = v158 - v215;
                v228 = v215;
                break;
              default:
                v352 = __cxa_allocate_exception(0x10uLL);
                *v352 = "void QmfTransposerApply(HANDLE_HBE_TRANSPOSER, FLOAT **, FLOAT **, FLOAT **, FLOAT **, int, int, KEEP_STATES_SYNCED_MODE)";
                v352[2] = 1300;
            }

            calculateCenter(*&v397, *&v396, &v397, &v396, v158, v254 - 1);
            v280 = v228 - 1;
            calculateCenter(v171, v390.f32[0], &v395, &v394, v388[0], v280);
            calculateCenter(*(&v395 + 1), *(&v394 + 1), &v395 + 1, &v394 + 1, v388[0], v280);
            v281 = 0;
            v282 = *&v397;
            v283 = *&v396;
            v284 = *&v395;
            v285 = -(*&v394 * *&v396);
            v286 = *&v397 * *&v394;
            v392.f32[1] = (*(&v395 + 1) * *&v397) - (*(&v394 + 1) * *&v396);
            v391.f32[1] = (*&v397 * *(&v394 + 1)) + (*(&v395 + 1) * *&v396);
            memset(v393, 255, sizeof(v393));
            v287 = v362;
            do
            {
              v288 = twiddle[(v287 + 24) % 96];
              v289 = &v393[v281];
              *v289 = twiddle[v287 % 96];
              v289[1] = v288;
              ++v281;
              v287 += v362;
            }

            while (v281 != 3);
            v158 = *v388;
            v290 = v285 + (v284 * v282);
            v291 = v286 + (v284 * v283);
            v293 = *v388 == 4 && v215 == 2;
            v294 = &v393[v363 - v293];
            v295 = *v294;
            v296 = v229 * v294[1];
            v392.f32[0] = (v290 * *v294) - (v291 * v296);
            v391.f32[0] = (v290 * v296) + (v291 * v295);
            __asm { FMOV            V1.2S, #3.0 }

            v391 = vdiv_f32(vmul_n_f32(v391, v386), _D1);
            v392 = vdiv_f32(vmul_n_f32(v392, v386), _D1);
            v300 = *(v8 + 332);
            v301 = *(v8 + 333);
            v302 = &v392;
            v303 = &v391;
            v304 = 1;
            v305 = 5;
            do
            {
              v306 = v304;
              *(*(v300 + 8 * v305) + 4 * v161) = v302->f32[0] + *(*(v300 + 8 * v305) + 4 * v161);
              *(*(v301 + 8 * v305) + 4 * v161) = v303->f32[0] + *(*(v301 + 8 * v305) + 4 * v161);
              v303 = (&v391 + 4);
              v302 = (&v392 + 4);
              v305 = 6;
              v304 = 0;
            }

            while ((v306 & 1) != 0);
            v156 = v378;
          }
        }

        ++v161;
        v159 = v8[v380];
      }

      while (v161 < v159);
      v155 = v8[6];
LABEL_136:
      v307 = v158++ < v155;
      ++v371;
      v157 = v159;
    }

    while (v307);
LABEL_137:
    for (j = 0; j != 96; j += 8)
    {
      CDKmemcpy(*(*(v8 + 9) + j), *(*(v8 + 9) + j + 8), (4 * v8[34]));
      CDKmemcpy(*(*(v8 + 10) + j), *(*(v8 + 10) + j + 8), (4 * v8[34]));
    }

    if (a8 != 3 && v367 >= v353)
    {
      if (a8 == 2)
      {
        v309 = 0;
        v310 = v367 - v354;
        v311 = 1;
        do
        {
          v312 = v311;
          CDKmemcpy((*(a4 + 8 * (v309 + v310)) + 4 * *v8), (*(*(v8 + 332) + 8 * v309) + 4 * *v8), (256 - 4 * *v8));
          CDKmemcpy((*(a5 + 8 * (v309 + v310)) + 4 * *v8), (*(*(v8 + 333) + 8 * v309) + 4 * *v8), (256 - 4 * *v8));
          v311 = 0;
          v309 = 1;
        }

        while ((v312 & 1) != 0);
      }

      else
      {
        v314 = 0;
        v315 = v367 + a7;
        v316 = 1;
        do
        {
          v317 = v316;
          CDKmemcpy((*(a4 + 8 * (v315 + v314)) + 4 * *v8), (*(*(v8 + 332) + 8 * v314) + 4 * *v8), (256 - 4 * *v8));
          CDKmemcpy((*(a5 + 8 * (v315 + v314)) + 4 * *v8), (*(*(v8 + 333) + 8 * v314) + 4 * *v8), (256 - 4 * *v8));
          v316 = 0;
          v314 = 1;
        }

        while ((v317 & 1) != 0);
      }
    }

    for (k = 0; k != 72; k += 8)
    {
      CDKmemcpy((*(*(v8 + 332) + k) + 4 * *v8), (*(*(v8 + 332) + k + 16) + 4 * *v8), (256 - 4 * *v8));
      CDKmemcpy((*(*(v8 + 333) + k) + 4 * *v8), (*(*(v8 + 333) + k + 16) + 4 * *v8), (256 - 4 * *v8));
    }

    v319 = 1;
    v320 = 10;
    do
    {
      v321 = v319;
      bzero((*(*(v8 + 332) + 8 * v320) + 4 * *v8), (256 - 4 * *v8));
      bzero((*(*(v8 + 333) + 8 * v320) + 4 * *v8), (256 - 4 * *v8));
      v319 = 0;
      v320 = 9;
    }

    while ((v321 & 1) != 0);
LABEL_154:
    ++v359;
    v12 = v369;
    result = &v398 + v368;
  }

  while (v359 != v356);
LABEL_155:
  if (a8 != 3)
  {
    if (a8 == 2)
    {
      v322 = 0;
      v323 = v8[12];
      v324 = v8[13];
      v325 = 4 * v323;
      do
      {
        if (v323 < v324)
        {
          result = (*(a5 + 8 * v322) + v325);
          v326 = (*(a4 + 8 * v322) + v325);
          v327 = (&cos_F + 4 * v323);
          v328 = 0x3F00000000 - (v323 << 32);
          v329 = v324 - v323;
          do
          {
            v330 = *v326;
            v331 = *result;
            v332 = *v327++;
            v333 = *(&cos_F + (v328 >> 30));
            *v326 = (*result * v333) + (*v326 * v332);
            ++v326;
            *result = (v331 * v332) - (v330 * v333);
            result += 4;
            v328 -= 0x100000000;
            --v329;
          }

          while (v329);
        }

        ++v322;
      }

      while (v322 != a7 + 2);
    }

    else
    {
      v334 = v8[10];
      if (v353 < v334)
      {
        v335 = v8[12];
        v336 = v8[13];
        v337 = v353;
        v338 = 4 * v335;
        result = 0xFFFFFFFF00000000;
        do
        {
          if (v335 < v336)
          {
            v339 = (*(a5 + 8 * (v337 + a7)) + v338);
            v340 = (*(a4 + 8 * (v337 + a7)) + v338);
            v341 = (&cos_F + 4 * v335);
            v342 = 0x3F00000000 - (v335 << 32);
            v343 = v336 - v335;
            do
            {
              v344 = *v340;
              v345 = *v339;
              v346 = *v341++;
              v347 = *(&cos_F + (v342 >> 30));
              *v340 = (*v339 * v347) + (*v340 * v346);
              ++v340;
              *v339++ = (v345 * v346) - (v344 * v347);
              v342 -= 0x100000000;
              --v343;
            }

            while (v343);
          }

          ++v337;
        }

        while (v337 != v334);
      }
    }
  }

  return result;
}

uint64_t copyHarmonicSpectrum(uint64_t result, uint64_t a2, uint64_t a3, int a4, unsigned int a5, int a6)
{
  LODWORD(v6) = 0;
  if (a6 == 2)
  {
    v7 = 0;
  }

  else
  {
    v7 = a5;
  }

  for (i = 4; i != 24; i += 4)
  {
    if (*(result + i))
    {
      v6 = (v6 + 1);
    }

    else
    {
      v6 = v6;
    }
  }

  if (v6 >= 4)
  {
    v9 = a2 + 8 * v7;
    v10 = a3 + 8 * v7;
    if (a6 == 1)
    {
      v11 = a4 - 2 - a5;
    }

    else
    {
      v11 = 0;
    }

    v12 = *(result + 12);
    v13 = v12 - *(result + 8);
    v14 = a5 + 2;
    v15 = 3;
    v16 = v12;
    do
    {
      ++v15;
      v17 = *(result + 4 * v15);
      v18 = v17 - v16;
      if (v17 - v16 >= 1)
      {
        if (v17 >= 64)
        {
          v19 = 64;
        }

        else
        {
          v19 = *(result + 4 * v15);
        }

        do
        {
          v20 = v16 + v13;
          v21 = v17 - v16;
          if (v16 + v13 < v17)
          {
            v21 = v13;
          }

          v22 = v16 + v12 + v21;
          v23 = v21 == v13;
          if (v21 == v13)
          {
            v24 = v12 - 1;
          }

          else
          {
            v24 = v12 - 2;
          }

          v25 = v22 & v23;
          v26 = (v22 & v23) << 31 >> 31;
          v27 = v21 - v25;
          if (v22)
          {
            v28 = v24;
          }

          else
          {
            v28 = v12 - 1;
          }

          if (a6 == 2)
          {
            if (v11 < v14)
            {
              if (v17 < v20)
              {
                v20 = v17;
              }

              v29 = v20 + v26 - v16;
              v30 = v29 + 1;
              v31 = v16 + v29;
              v32 = v11;
              do
              {
                if (v27 >= 1)
                {
                  v33 = 0;
                  v34 = v31;
                  v35 = v30;
                  do
                  {
                    if (v34 <= v19)
                    {
                      v36 = *(v10 + 8 * v32);
                      *(*(v9 + 8 * v32) + 4 * v34 - 4) = *(*(v9 + 8 * v32) + 4 * (v28 - v33));
                      *(v36 + 4 * v34 - 4) = *(v36 + 4 * (v28 - v33++));
                    }

                    --v35;
                    --v34;
                  }

                  while (v35 > 1);
                }

                ++v32;
              }

              while (v32 != v14);
            }
          }

          else if (v11 < a4)
          {
            if (v17 < v20)
            {
              v20 = v17;
            }

            v37 = v20 + v26 - v16;
            v38 = v37 + 1;
            v39 = v16 + v37;
            v40 = v11;
            do
            {
              if (v27 >= 1)
              {
                v41 = 0;
                v42 = v39;
                v43 = v38;
                do
                {
                  if (v42 <= v19)
                  {
                    v44 = *(v10 + 8 * v40);
                    *(*(v9 + 8 * v40) + 4 * v42 - 4) = *(*(v9 + 8 * v40) + 4 * (v28 - v41));
                    *(v44 + 4 * v42 - 4) = *(v44 + 4 * (v28 - v41++));
                  }

                  --v43;
                  --v42;
                }

                while (v43 > 1);
              }

              ++v40;
            }

            while (v40 != a4);
          }

          v16 += v27;
          v45 = __OFSUB__(v18, v27);
          v18 -= v27;
        }

        while (!((v18 < 0) ^ v45 | (v18 == 0)));
      }

      v16 = v17;
    }

    while (v15 != v6);
  }

  return result;
}

uint64_t ResetLimiterBands(_BYTE *a1, _BYTE *a2, unsigned __int8 *a3, int a4, uint64_t a5, int a6, int a7, int a8, int *a9, int a10)
{
  v53 = *MEMORY[0x1E69E9840];
  memset(v50, 170, 28);
  v10 = *a3;
  v11 = a3[a4];
  if (a7)
  {
    if (a8 || (v13 = a9) == 0)
    {
      if (a6 < 1)
      {
        a6 = 0;
        v14 = 0;
      }

      else
      {
        v17 = a6;
        v18 = (a5 + 2);
        v19 = v50;
        do
        {
          v20 = *v18;
          v18 += 6;
          *v19++ = v20 - v10;
          --v17;
        }

        while (v17);
        v14 = a6;
      }
    }

    else
    {
      if (a10 == 1)
      {
        v14 = 0;
        for (i = 1; i != 6; ++i)
        {
          if (a9[i])
          {
            ++v14;
          }
        }
      }

      else
      {
        v14 = 0;
        for (j = 1; j != 4; ++j)
        {
          if (a9[j])
          {
            ++v14;
          }
        }
      }

      if (v14 < 1)
      {
        a6 = 0;
      }

      else
      {
        v22 = v14;
        v23 = v50;
        do
        {
          v24 = *v13++;
          *v23++ = v24 - v10;
          --v22;
        }

        while (v22);
        a6 = v14;
      }
    }

    v25 = 0;
    *&v52[15] = -1431655766;
    *&v26 = 0xAAAAAAAAAAAAAAAALL;
    *(&v26 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __src = v26;
    *v52 = v26;
    *(v50 + a6) = v11 - v10;
    do
    {
      v52[v25 - 16] = a3[v25] - v10;
      ++v25;
    }

    while (a4 + 1 != v25);
    v47 = a2;
    if (v14 >= 2)
    {
      v27 = v14 - 1;
      v28 = &v52[a4 - 15];
      v29 = v50 + 1;
      do
      {
        v30 = *v29++;
        *v28++ = v30;
        --v27;
      }

      while (v27);
    }

    v31 = (v14 + a4);
    v16 = v31 - 1;
    shellsort(&__src, (v14 + a4));
    if (v31 >= 2)
    {
      v49 = v11;
      v32 = 0;
      v33 = CDK_sbrDecoder_sbr_limiterBandsPerOctave[a7];
      v48 = (v14 + 1);
      v34 = 1;
      while (1)
      {
        v35 = &v52[v34 - 16];
        v36 = v52[v34 - 16];
        v37 = v52[v32 - 16];
        v38 = log(((v36 + v10) / (v37 + v10))) * 1.44269504;
        if ((v33 * v38) >= 0.49)
        {
          goto LABEL_43;
        }

        if (v36 != v37)
        {
          break;
        }

LABEL_42:
        *v35 = v49;
        --v16;
LABEL_44:
        if (++v34 == v31)
        {
          goto LABEL_45;
        }
      }

      v39 = v50;
      v40 = v48;
      while (1)
      {
        v41 = *v39++;
        if (v41 == v36)
        {
          break;
        }

        if (!--v40)
        {
          goto LABEL_42;
        }
      }

      v42 = v50;
      v43 = v48;
      while (1)
      {
        v44 = *v42++;
        if (v44 == v37)
        {
          break;
        }

        if (!--v43)
        {
          v35 = &v52[v32 - 16];
          v32 = v34;
          goto LABEL_42;
        }
      }

LABEL_43:
      v32 = v34;
      goto LABEL_44;
    }

LABEL_45:
    shellsort(&__src, v31);
    if ((v16 - 13) < 0xFFFFFFF4)
    {
      return 6;
    }

    memcpy(a1, &__src, (v16 + 1));
    a2 = v47;
  }

  else
  {
    *a1 = 0;
    a1[1] = v11 - v10;
    LOBYTE(v16) = 1;
  }

  result = 0;
  *a2 = v16;
  return result;
}

void *mapSineFlags(unsigned __int8 *a1, int a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, char a6, signed __int8 *a7)
{
  v17[1] = *MEMORY[0x1E69E9840];
  v17[0] = 0;
  *&v7 = 0x2020202020202020;
  *(&v7 + 1) = 0x2020202020202020;
  *a7 = v7;
  *(a7 + 1) = v7;
  *(a7 + 2) = v7;
  *(a7 + 6) = 0x2020202020202020;
  *a5 = 0;
  if (a2 >= 1)
  {
    v8 = a1 + 1;
    v9 = 31;
    v10 = a2;
    do
    {
      if ((*a3 >> v9))
      {
        v11 = *a1;
        v12 = *v8 + *(v8 - 1);
        v13 = v12 >> 1;
        v14 = v12 >> 6;
        *(v17 + v14) |= 1 << v13;
        v15 = ((1 << v13) & a4[v14]) != 0 ? 0 : a6;
        a7[v13 - v11] = v15;
        if (v15 <= 15)
        {
          a5[v14] |= 1 << v13;
        }
      }

      a3 += v9 == 0;
      if (v9)
      {
        --v9;
      }

      else
      {
        v9 = 31;
      }

      ++v8;
      --v10;
    }

    while (v10);
  }

  return CDKmemcpy(a4, v17, 8uLL);
}

uint64_t *inverseFilteringLevelEmphasis(uint64_t *result, unsigned int a2, int *a3, int *a4, float *a5)
{
  if (a2)
  {
    v6 = *result++;
    v5 = v6;
    v7 = a2;
    do
    {
      v9 = *a3++;
      v8 = v9;
      v10 = *a4++;
      v21 = *(v5 + 52);
      v22 = *(v5 + 68);
      v11 = 4 * (v10 == 1);
      if (v10)
      {
        v12 = 8;
      }

      else
      {
        v12 = 4;
      }

      if (v8 != 1)
      {
        v12 = v11;
      }

      if (v8 == 2)
      {
        v12 = 12;
      }

      if (v8 == 3)
      {
        v13 = 16;
      }

      else
      {
        v13 = v12;
      }

      v14 = *result;
      result = (result + 4);
      v15 = *(&v21 + v13);
      v16 = (v14 * 0.25) + (v15 * 0.75);
      v17 = (v14 * 0.09375) + (v15 * 0.90625);
      if (v15 >= v14)
      {
        v18 = v17;
      }

      else
      {
        v18 = v16;
      }

      v19 = fminf(v18, 0.99609);
      if (v18 >= 0.015625)
      {
        v20 = v19;
      }

      else
      {
        v20 = 0.0;
      }

      *a5++ = v20;
      --v7;
    }

    while (v7);
  }

  return result;
}

float autoCorr2nd_cplx(float *a1, float *a2, float *a3, int a4)
{
  v5 = *(a2 - 1);
  v6 = *(a3 - 1);
  v7 = *(a3 - 2);
  v8 = *(a2 - 2);
  v9 = 0.0;
  v10 = ((*a3 * v7) + (*a2 * v8)) + 0.0;
  v11 = ((*a3 * v8) - (*a2 * v7)) + 0.0;
  v12 = a4 - 1;
  if (a4 == 1)
  {
    v24 = 0.0;
    v14.i32[0] = 0;
  }

  else
  {
    v13 = a4 - 1;
    v14.i32[0] = 0;
    v14.i32[2] = 0;
    v14.f32[1] = ((*a3 * v8) - (*a2 * v7)) + 0.0;
    v14.f32[3] = ((*a3 * v7) + (*a2 * v8)) + 0.0;
    v15 = a2;
    v16 = a3;
    v17 = *(a3 - 1);
    v18 = *(a2 - 1);
    do
    {
      v9 = v9 + ((v17 * v17) + (v18 * v18));
      v19 = *v15++;
      v4.i64[0] = v19;
      v20 = *v16;
      v16 = (v16 + 4);
      v21.i64[0] = v20;
      v22.i64[0] = vnegq_f32(v4).u64[0];
      v22.i64[1] = v20;
      v23 = vmulq_n_f32(v22, v17);
      v17 = *&v20;
      v21.i64[1] = v4.i64[0];
      v14 = vaddq_f32(v14, vmlaq_n_f32(v23, v21, v18));
      v18 = v4.f32[0];
      --v13;
    }

    while (v13);
    v10 = v14.f32[3];
    v24 = v14.f32[2];
    v11 = v14.f32[1];
  }

  v25 = ((v7 * v7) + (v8 * v8)) + v9;
  v26 = 4 * a4 - 8;
  v27 = *(a2 + v26);
  v28 = *(a3 + v26);
  v29 = v9 + ((v28 * v28) + (v27 * v27));
  v30 = a2[v12];
  v31 = a3[v12];
  v32 = v24 + ((v7 * v6) + (v5 * v8));
  result = v14.f32[0] + ((v6 * v8) - (v5 * v7));
  *a1 = v29 + (((v31 * v31) + (v30 * v30)) - ((v6 * v6) + (v5 * v5)));
  a1[1] = v29;
  a1[2] = v25;
  a1[3] = v24 + ((v28 * v31) + (v30 * v27));
  a1[4] = v10;
  a1[5] = v32;
  a1[6] = v14.f32[0] + ((v31 * v27) - (v30 * v28));
  a1[7] = v11;
  a1[8] = result;
  a1[9] = -(((result * result) + (v32 * v32)) - (v29 * v25));
  return result;
}

void calculateCenter(float a1, float a2, float *a3, float *a4, int a5, int a6)
{
  if (a1 == 0.0 && a2 == 0.0)
  {
    *a3 = 0.0;
    v11 = 0.0;
LABEL_4:
    *a4 = v11;
    return;
  }

  v12 = (a2 * a2) + (a1 * a1);
  if (a5 == 4)
  {
    v14 = inv3EigthRootNorm2(v12);
  }

  else if (a5 == 3)
  {
    v14 = invCubeRootNorm2(v12);
  }

  else
  {
    v13 = 0.0;
    if (a5 != 2)
    {
      goto LABEL_13;
    }

    v14 = invFourthRootNorm2(v12);
  }

  v13 = v14;
LABEL_13:
  v15 = v13 * a1;
  v11 = v13 * a2;
  switch(a6)
  {
    case 2:
      v16 = ((v15 * v15) - (v11 * v11)) * 0.5;
      *a3 = (v16 * v15) - ((v15 * v11) * v11);
      v11 = (v15 * (v15 * v11)) + (v16 * v11);
      goto LABEL_4;
    case 1:
      *a3 = ((v15 * v15) - (v11 * v11)) * 0.5;
      v11 = v15 * v11;
      goto LABEL_4;
    case 0:
      *a3 = v15;
      goto LABEL_4;
  }
}

void addHighBandPart(float a1, float a2, float a3, float a4, float a5, int a6, float *a7, float *a8)
{
  if (a1 != 0.0 && a2 != 0.0)
  {
    v15 = (a2 * a2) + (a1 * a1);
    if (a6 == 4)
    {
      v17 = inv3EigthRootNorm2(v15);
    }

    else if (a6 == 3)
    {
      v17 = invCubeRootNorm2(v15);
    }

    else
    {
      v16 = 0.0;
      if (a6 != 2)
      {
LABEL_10:
        *a7 = *a7 + (((a1 * a4) - (a2 * a5)) * v16);
        *a8 = *a8 + (((a2 * a4) + (a1 * a5)) * v16);
        return;
      }

      v17 = invFourthRootNorm2(v15);
    }

    v16 = v17 * a3;
    goto LABEL_10;
  }
}

float invFourthRootNorm2(float a1)
{
  if (a1 <= 0.0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "FLOAT invFourthRootNorm2(FLOAT)";
    exception[2] = 345;
  }

  v1 = HIWORD(LODWORD(a1)) & 0x7F;
  v2 = invFourthRootTab[v1 + 1];
  v3 = invFourthRootTab[v1];
  LODWORD(result) = (((((((((v2 - v3) * (LOWORD(a1) << 15)) >> 31) & 0xFFFFFFFFFFFFFFEuLL) + v3) * invFourthRootCorrection[(130 - (LODWORD(a1) >> 23)) & 3]) >> 32) >> 5) & 0x7FFFFF | (((130 - (LODWORD(a1) >> 23)) >> 2) << 23)) + 1056964608;
  return result;
}

float invCubeRootNorm2(float a1)
{
  if (a1 <= 0.0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "FLOAT invCubeRootNorm2(FLOAT)";
    exception[2] = 235;
  }

  v1 = 129 - (LODWORD(a1) >> 23);
  if (v1 >= 0)
  {
    v2 = 129 - (LODWORD(a1) >> 23);
  }

  else
  {
    v2 = (LODWORD(a1) >> 23) - 129;
  }

  v3 = (21846 * v2) >> 16;
  if (HIBYTE(LODWORD(a1)) <= 0x40u)
  {
    v4 = v3;
  }

  else
  {
    v4 = -v3;
  }

  v5 = __OFADD__(-3 * v4, v1);
  v6 = -3 * v4 + v1;
  v7 = v4 + (v6 >> 31);
  if (v6 < 0 != v5)
  {
    v6 += 3;
  }

  LODWORD(result) = ((((invCubeRootCorrection[v6] * (invCubeRootTab[HIWORD(LODWORD(a1)) & 0x7F] + (((LOWORD(a1) << 15) * (2 * (invCubeRootTab[(HIWORD(LODWORD(a1)) & 0x7F) + 1] - invCubeRootTab[HIWORD(LODWORD(a1)) & 0x7F]))) >> 32))) >> 32) >> 5) & 0x7FFFFF | (v7 << 23)) + 1056964608;
  return result;
}

float inv3EigthRootNorm2(float a1)
{
  if (a1 <= 0.0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "FLOAT inv3EigthRootNorm2(FLOAT)";
    exception[2] = 448;
  }

  v1 = HIWORD(LODWORD(a1)) & 0x7F;
  v2 = inv3EigthRootTab[v1 + 1];
  v3 = inv3EigthRootTab[v1];
  v4 = 134 - (LODWORD(a1) >> 23);
  v5 = ((inv3EigthRootCorrection[v4 & 7] * (((((v2 - v3) * (LOWORD(a1) << 15)) >> 31) & 0x3FFFFFFFFFFFFFFELL) + v3)) >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v6 = ((((v5 * v5) >> 31) & 0x3FFFFFFFFFFFFFFELL) * v5) >> 31;
  v7 = v6 & 0xFFFFFFFE;
  if ((v6 & 0x80000000) != 0)
  {
    v9 = -1;
  }

  else
  {
    v8 = ~v7;
    v9 = -1;
    do
    {
      v8 *= 2;
      ++v9;
    }

    while (v8 < 0);
  }

  LODWORD(result) = (((v7 << v9) >> 7) & 0x7FFFFF | ((3 * (v4 >> 3) - v9) << 23)) + 1056964608;
  return result;
}

void decodeNoiseFloorlevels(unsigned __int8 a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a2 + 24);
  v4 = (a2 + 1872);
  if (*(a2 + 41))
  {
    if (a1)
    {
      v5 = (a3 + 224);
      v6 = a1;
      v7 = (a2 + 1872);
      do
      {
        v8 = *v5++;
        *v7 = v8 + *v7;
        ++v7;
        --v6;
      }

      while (v6);
    }
  }

  else if (a1 >= 2u)
  {
    v9 = *(a2 + 1872);
    v10 = a1 - 1;
    v11 = (a2 + 1876);
    do
    {
      v9 = v9 + *v11;
      *v11++ = v9;
      --v10;
    }

    while (v10);
  }

  if (v3 >= 2)
  {
    if (*(a2 + 42))
    {
      if (a1)
      {
        v12 = (a2 + 1872);
        v13 = a1;
        do
        {
          v12[a1] = *v12 + v12[a1];
          ++v12;
          --v13;
        }

        while (v13);
      }
    }

    else if (a1 + 1 < 2 * a1)
    {
      v14 = v4[a1];
      v15 = a1 - 1;
      v16 = (a2 + 4 * a1 + 1876);
      do
      {
        v14 = v14 + *v16;
        *v16++ = v14;
        --v15;
      }

      while (v15);
    }
  }

  v17 = v3 * a1;
  if (v17)
  {
    v18 = (a2 + 1872);
    v19 = v3 * a1;
    do
    {
      *v18 = fmaxf(fminf(*v18, 35.0), 0.0);
      ++v18;
      --v19;
    }

    while (v19);
  }

  if (a1)
  {
    v20 = (v3 - 1) * a1;
    v21 = (a3 + 224);
    v22 = a1;
    v23 = &v4[v20];
    do
    {
      v24 = *v23++;
      *v21++ = v24;
      --v22;
    }

    while (v22);
  }

  if (*(a2 + 64))
  {
    v25 = 1;
  }

  else
  {
    v25 = v17 == 0;
  }

  if (!v25)
  {
    do
    {
      v26 = ldexp(1.0, (6.0 - *v4));
      *v4++ = v26;
      --v17;
    }

    while (v17);
  }
}

void decodeEnvelope(_BYTE *a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  v60 = *MEMORY[0x1E69E9840];
  v7 = a1[5];
  if (v7)
  {
    goto LABEL_41;
  }

  if (*(a3 + 270))
  {
    if (!*(a2 + 33))
    {
      v9 = (*(a3 + 269) - a1[6]) & ~((*(a3 + 269) - a1[6]) >> 31);
      v10 = *(a2 + 7);
      v11 = *(a2 + 6);
      v12 = v10 - v11;
      v13 = v10 - v9;
      v14 = log((v10 - v11));
      if (v13 >= 1)
      {
        v15 = v13;
      }

      else
      {
        v15 = v12;
      }

      if (v13 < 1)
      {
        LOBYTE(v9) = v11;
      }

      v16 = log(v15);
      v17 = ldexp(1.0, 2 - a2[17]);
      *(a2 + 6) = v9;
      *(a2 + 25) = v9;
      v18 = a2[16];
      if (v18 != 2)
      {
        v19 = 40;
        if (*(a2 + 15))
        {
          v19 = 41;
        }

        v20 = a1[v19];
        if (v20)
        {
          v21 = v16 * -1.44269504 + v14 * 1.44269504;
          v22 = v17;
          v23 = v21 * v22;
          v24 = (a2 + 20);
          do
          {
            *v24 = v23 + *v24;
            ++v24;
            --v20;
          }

          while (v20);
        }
      }

      v25 = *(a3 + 244);
      if (v18 != v25 && a1[41])
      {
        v26 = 0;
        while (v25 != 2)
        {
          if (v18 == 2)
          {
            *(a3 + 4 * v26) = 1094713344;
            goto LABEL_24;
          }

          if (v18 == 1)
          {
            v27 = (*(a3 + 4 * v26) + *(a4 + 4 * v26)) * 0.5;
            goto LABEL_23;
          }

LABEL_24:
          if (++v26 >= a1[41])
          {
            goto LABEL_28;
          }
        }

        v27 = *(a4 + 4 * v26);
LABEL_23:
        *(a3 + 4 * v26) = v27;
        goto LABEL_24;
      }

      goto LABEL_28;
    }

    goto LABEL_40;
  }

  if (*(a3 + 269) - a1[6] != *(a2 + 6))
  {
LABEL_40:
    v7 = 1;
LABEL_41:
    v39 = 0;
    v40 = *(a3 + 269);
    v41 = a1[6];
    v42 = *(a2 + 5);
    v43 = *(a3 + 268);
    v44 = *(a3 + 244);
    a2[16] = v44;
    a2[17] = v43;
    do
    {
      a2[v39 + 11] = *(a3 + v39 * 4 + 248);
      ++v39;
    }

    while (v39 != 5);
    v45 = (v40 - v41) & ~((v40 - v41) >> 31);
    *(a2 + 5) = 1;
    *(a2 + 6) = v45;
    *(a2 + 7) = v41;
    *(a2 + 15) = 1;
    *(a2 + 23) = 511;
    *(a2 + 25) = v45;
    *(a2 + 26) = v41;
    v46 = a1[41];
    *a2 = v46;
    *(a2 + 33) = 1;
    v47 = 12.0;
    if (v44 != 2)
    {
      v47 = 0.0;
    }

    v48 = 1.0;
    if (!a1[34])
    {
      v48 = 2.0;
      v47 = v47 + v47;
    }

    if (v46)
    {
      v49 = (a2 + 20);
      v50 = a3;
      do
      {
        v51 = *v50++;
        if (v51 <= v47)
        {
          v52 = v48;
        }

        else
        {
          v52 = -v48;
        }

        *v49++ = v52;
        --v46;
      }

      while (v46);
    }

    *(a2 + 41) = 1;
    if (a1[42] * v42)
    {
      bzero(a2 + 468, 4 * a1[42] * v42);
    }

    *(a2 + 9) = 0;
    deltaToLinearPcmEnvelopeDecoding(a1, a2, a3);
    v29 = a2[17];
    v31 = *a2;
    goto LABEL_56;
  }

LABEL_28:
  *&v28 = -1;
  *(&v28 + 1) = -1;
  v59[12] = v28;
  v59[13] = v28;
  v59[10] = v28;
  v59[11] = v28;
  v59[8] = v28;
  v59[9] = v28;
  v59[6] = v28;
  v59[7] = v28;
  v59[4] = v28;
  v59[5] = v28;
  v59[2] = v28;
  v59[3] = v28;
  v59[0] = v28;
  v59[1] = v28;
  CDKmemcpy(v59, a3, 0xE0uLL);
  deltaToLinearPcmEnvelopeDecoding(a1, a2, a3);
  v29 = a2[17];
  v30 = 70.0;
  if (v29 == 1)
  {
    v30 = 35.0;
  }

  v31 = *a2;
  if (*a2 < 1)
  {
    v38 = 1;
  }

  else
  {
    v32 = 0;
    v33 = (a2 + 20);
    v34 = *a2;
    do
    {
      v35 = *v33++;
      v36 = v35;
      if (v35 > v30 || v36 < 0.0)
      {
        v32 = 1;
      }

      --v34;
    }

    while (v34);
    v38 = v32 == 0;
  }

  if (a1[41])
  {
    v57 = 0;
    do
    {
      v58 = fmaxf(*(a3 + 4 * v57), 0.0);
      if (v58 >= v30)
      {
        v58 = v30;
      }

      *(a3 + 4 * v57++) = v58;
    }

    while (v57 < a1[41]);
  }

  if (!v38)
  {
    a1[5] = 1;
    CDKmemcpy(a3, v59, 0xE0uLL);
    decodeEnvelope(a1, a2, a3, a4);
    return;
  }

  v7 = 0;
LABEL_56:
  if (v31 >= 1)
  {
    v53 = 1.0 / (2.0 - v29);
    v54 = (a2 + 20);
    v55 = v31;
    do
    {
      v56 = exp2(((*v54 * v53) + 6.0));
      *v54++ = v56;
      --v55;
    }

    while (v55);
  }

  a1[5] = v7;
}

uint64_t deltaToLinearPcmEnvelopeDecoding(uint64_t result, uint64_t a2, float *a3)
{
  if (*(a2 + 5))
  {
    v5 = 0;
    v6 = *(result + 40);
    result += 40;
    v7 = *(result + 1);
    v8 = 2 * v6 - v7;
    v9 = (a2 + 80);
    v30 = a2 + 33;
    v31 = result;
    v32 = a2 + 15;
    v10 = v7 - 2 * v6;
    v24 = a3 + 2;
    v25 = a3 + 1;
    v26 = &a3[1 - v8];
    v27 = &a3[v10];
    v28 = v7;
    v29 = 2 * v6;
    while (1)
    {
      v11 = *(v32 + v5);
      if (v11 >= 2)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "void deltaToLinearPcmEnvelopeDecoding(HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_SBR_PREV_FRAME_DATA)";
        v23 = 594;
LABEL_31:
        exception[2] = v23;
      }

      v12 = *(v31 + *(v32 + v5));
      if (v12 >= 0x40)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "void deltaToLinearPcmEnvelopeDecoding(HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_SBR_PREV_FRAME_DATA)";
        v23 = 598;
        goto LABEL_31;
      }

      if (!*(v30 + v5))
      {
        break;
      }

      if (*(v31 + *(v32 + v5)))
      {
        v13 = 0;
        v14 = v10;
        do
        {
          if (v11)
          {
            v15 = v13;
          }

          else if (v8 < 0)
          {
            v15 = 3 * v13;
            if (v13 >= v10)
            {
              v15 = v14;
            }
          }

          else
          {
            v15 = 2 * v13 - v8;
            if (v13 < v8)
            {
              v15 = v13;
            }
          }

          v16 = *v9 + a3[v15];
          *v9++ = v16;
          result = mapLowResEnergyVal(v16, a3, v8, v13++, v11);
          v14 += 2;
        }

        while (v12 != v13);
      }

LABEL_27:
      if (++v5 >= *(a2 + 5))
      {
        return result;
      }
    }

    v17 = *v9;
    v18 = a3;
    if (!*(v32 + v5))
    {
      if (v8 < 0)
      {
        *a3 = v17;
        result = v24;
        v19 = v25;
      }

      else
      {
        result = v26;
        v19 = v27;
        v18 = a3;
        if (v29 != v28)
        {
          goto LABEL_24;
        }
      }

      *v19 = v17;
      v18 = result;
    }

LABEL_24:
    *v18 = v17;
    ++v9;
    if (v12 >= 2)
    {
      for (i = 1; i != v12; ++i)
      {
        v21 = *v9 + *(v9 - 1);
        *v9++ = v21;
        result = mapLowResEnergyVal(v21, a3, v8, i, v11);
      }
    }

    goto LABEL_27;
  }

  return result;
}

uint64_t mapLowResEnergyVal(float a1, uint64_t result, int a3, int a4, int a5)
{
  if (a5)
  {
LABEL_2:
    v5 = (result + 4 * a4);
    goto LABEL_3;
  }

  if ((a3 & 0x80000000) == 0)
  {
    if (a4 >= a3)
    {
      v6 = 2 * a4 - a3;
      *(result + 4 * v6) = a1;
      v5 = (result + 4 * (v6 + 1));
      goto LABEL_3;
    }

    goto LABEL_2;
  }

  if (-a3 <= a4)
  {
    v8 = 2 * a4 - a3;
    *(result + 4 * v8) = a1;
    v5 = (result + 4 * (v8 + 1));
  }

  else
  {
    v7 = (result + 12 * a4);
    *v7 = a1;
    v7[1] = a1;
    v5 = v7 + 2;
  }

LABEL_3:
  *v5 = a1;
  return result;
}

uint64_t qmfInitSynthesisFilterBank(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7)
{
  v7 = a7;
  inited = qmfInitFilterBank(a1, a2, a3, a4, a5, a6, a7, 1);
  if ((v7 & 8) == 0)
  {
    v10 = *(a1 + 8);
    if (v10)
    {
      bzero(v10, (36 * *(a1 + 40)));
    }
  }

  v11 = *(a1 + 40);
  if (v11 < *(a1 + 48))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int qmfInitSynthesisFilterBank(HANDLE_QMF_FILTER_BANK, FLOAT *, int, int, int, int, int)";
    v14 = 590;
    goto LABEL_9;
  }

  if (v11 < *(a1 + 52))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int qmfInitSynthesisFilterBank(HANDLE_QMF_FILTER_BANK, FLOAT *, int, int, int, int, int)";
    v14 = 591;
LABEL_9:
    exception[2] = v14;
  }

  return inited;
}

uint64_t qmfInitAnalysisFilterBank(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7)
{
  v7 = a7;
  inited = qmfInitFilterBank(a1, a2, a3, a4, a5, a6, a7, 0);
  if ((v7 & 8) == 0)
  {
    v10 = *(a1 + 8);
    if (v10)
    {
      bzero(v10, (36 * *(a1 + 40)));
    }
  }

  if (*(a1 + 40) < *(a1 + 48))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int qmfInitAnalysisFilterBank(HANDLE_QMF_FILTER_BANK, FLOAT *, int, int, int, int, int)";
    exception[2] = 560;
  }

  return inited;
}

uint64_t qmfInitFilterBank(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *(a1 + 64) = 0;
  *(a1 + 32) = 0u;
  *(a1 + 48) = 0u;
  *a1 = 0u;
  *(a1 + 16) = 0u;
  if ((a7 & 0x14) != 0)
  {
    return 0xFFFFFFFFLL;
  }

  *(a1 + 56) = 1065353216;
  HIDWORD(v10) = a6 - 8;
  LODWORD(v10) = a6 - 8;
  v9 = v10 >> 2;
  v8 = 0xFFFFFFFFLL;
  if (v9 <= 3)
  {
    if (v9 <= 1)
    {
      if (v9)
      {
        if (v9 != 1)
        {
          return v8;
        }

        *a1 = &qmf_pfilt120;
        *(a1 + 68) = 1;
        v11 = 120;
      }

      else
      {
        *a1 = &qmf_pfilt640;
        *(a1 + 68) = 8;
        v11 = 640;
      }

      *(a1 + 16) = v11;
      v16 = 1090519040;
      goto LABEL_29;
    }

    if (v9 == 2)
    {
      *a1 = &qmf_pfilt640;
      *(a1 + 24) = &qmf_phaseshift_cos16;
      *(a1 + 32) = &qmf_phaseshift_sin16;
      *(a1 + 68) = 4;
      v15 = 640;
    }

    else
    {
      *a1 = &qmf_pfilt200;
      *(a1 + 68) = 1;
      v15 = 200;
    }

    goto LABEL_25;
  }

  if (v9 <= 7)
  {
    if (v9 == 4)
    {
      *a1 = &qmf_pfilt240;
      *(a1 + 24) = &qmf_phaseshift_cos24;
      *(a1 + 32) = &qmf_phaseshift_sin24;
      *(a1 + 68) = 1;
      v15 = 240;
LABEL_25:
      *(a1 + 16) = v15;
      v16 = 1082130432;
LABEL_29:
      *(a1 + 56) = v16;
      goto LABEL_30;
    }

    if (v9 != 6)
    {
      return v8;
    }

    *a1 = &qmf_pfilt640;
    v12 = &qmf_phaseshift_cos32;
    if ((a7 & 0x40) != 0)
    {
      v12 = &qmf_phaseshift_cos_downsamp32;
    }

    v13 = &qmf_phaseshift_sin32;
    if ((a7 & 0x40) != 0)
    {
      v13 = &qmf_phaseshift_sin_downsamp32;
    }

    *(a1 + 24) = v12;
    *(a1 + 32) = v13;
    *(a1 + 68) = 2;
    v14 = 640;
LABEL_28:
    *(a1 + 16) = v14;
    v16 = 0x40000000;
    goto LABEL_29;
  }

  if (v9 != 8)
  {
    if (v9 != 14)
    {
      return v8;
    }

    *a1 = &qmf_pfilt640;
    *(a1 + 24) = &qmf_phaseshift_cos64;
    *(a1 + 32) = &qmf_phaseshift_sin64;
    *(a1 + 68) = 1;
    *(a1 + 16) = 640;
    goto LABEL_30;
  }

  if (!a8)
  {
    *a1 = &qmf_pfilt400;
    *(a1 + 24) = &qmf_phaseshift_cos40;
    *(a1 + 32) = &qmf_phaseshift_sin40;
    *(a1 + 68) = 1;
    v14 = 10 * a6;
    goto LABEL_28;
  }

LABEL_30:
  v8 = 0;
  *(a1 + 40) = a6;
  *(a1 + 44) = a3;
  if (a4 >= a6)
  {
    v17 = a6;
  }

  else
  {
    v17 = a4;
  }

  if (a5 >= a6)
  {
    v18 = a6;
  }

  else
  {
    v18 = a5;
  }

  if (!a8)
  {
    v18 = a5;
  }

  *(a1 + 48) = v17;
  *(a1 + 52) = v18;
  *(a1 + 8) = a2;
  *(a1 + 60) = 1065353216;
  *(a1 + 64) = a7;
  return v8;
}

void UsacQmf::InitAnalysis(UsacQmf *this, int a2, unsigned int a3, unsigned int a4)
{
  v8 = a3;
  std::vector<std::vector<float>>::resize(this + 7, a3);
  std::vector<std::vector<float>>::resize(this + 10, v8);
  std::vector<float *>::resize(this + 22, v8);
  std::vector<float *>::resize(this + 25, v8);
  if (a3)
  {
    v9 = 0;
    v10 = 0;
    v11 = 24 * v8;
    do
    {
      std::vector<float>::resize((*(this + 7) + v10), a4);
      std::vector<float>::resize((*(this + 10) + v10), a4);
      *(*(this + 22) + v9) = *(*(this + 7) + v10);
      *(*(this + 25) + v9) = *(*(this + 10) + v10);
      v10 += 24;
      v9 += 8;
    }

    while (v11 != v10);
  }

  std::vector<std::unique_ptr<AnalysisSBRQMF>>::clear[abi:ne200100](this);
  if (a2)
  {
    HIDWORD(v13) = a4 - 16;
    LODWORD(v13) = a4 - 16;
    v12 = v13 >> 3;
    do
    {
      if (v12 > 1)
      {
        if (v12 == 6)
        {
          operator new();
        }

        if (v12 == 2)
        {
          operator new();
        }
      }

      else
      {
        if (!v12)
        {
          operator new();
        }

        if (v12 == 1)
        {
          operator new();
        }
      }

      v15 = *(this + 1);
      v14 = *(this + 2);
      if (v15 >= v14)
      {
        v17 = *this;
        v18 = v15 - *this;
        v19 = v18 >> 3;
        v20 = (v18 >> 3) + 1;
        if (v20 >> 61)
        {
          std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
        }

        v21 = v14 - v17;
        if (v21 >> 2 > v20)
        {
          v20 = v21 >> 2;
        }

        if (v21 >= 0x7FFFFFFFFFFFFFF8)
        {
          v22 = 0x1FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v22 = v20;
        }

        if (v22)
        {
          if (!(v22 >> 61))
          {
            operator new();
          }

          std::__throw_bad_array_new_length[abi:ne200100]();
        }

        *(8 * v19) = 0;
        v16 = 8 * v19 + 8;
        memcpy(0, v17, v18);
        *this = 0;
        *(this + 1) = v16;
        *(this + 2) = 0;
        if (v17)
        {
          operator delete(v17);
        }
      }

      else
      {
        *v15 = 0;
        v16 = (v15 + 1);
      }

      *(this + 1) = v16;
      --a2;
    }

    while (a2);
  }
}

void sub_19B09334C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  _Unwind_Resume(exception_object);
}

void UsacQmf::InitSynthesis(UsacQmf *this, int a2, unsigned int a3, unsigned int a4)
{
  v6 = a2;
  *(this + 12) = a3;
  *(this + 13) = a2;
  v8 = a3;
  std::vector<std::vector<float>>::resize(this + 13, a3);
  std::vector<std::vector<float>>::resize(this + 16, v8);
  std::vector<float *>::resize(this + 28, v8);
  std::vector<float *>::resize(this + 31, v8);
  if (a3)
  {
    v9 = 0;
    v10 = 0;
    v11 = 24 * v8;
    do
    {
      std::vector<float>::resize((*(this + 13) + v10), a4);
      std::vector<float>::resize((*(this + 16) + v10), a4);
      *(*(this + 28) + v9) = *(*(this + 13) + v10);
      *(*(this + 31) + v9) = *(*(this + 16) + v10);
      v10 += 24;
      v9 += 8;
    }

    while (v11 != v10);
  }

  std::vector<float>::resize((this + 152), a4 * a3);
  std::vector<std::unique_ptr<SynthesisSBRQMF>>::clear[abi:ne200100](this + 3);
  for (; v6; --v6)
  {
    if (a4 == 64)
    {
      operator new();
    }

    v13 = *(this + 4);
    v12 = *(this + 5);
    if (v13 >= v12)
    {
      v15 = *(this + 3);
      v16 = v13 - v15;
      v17 = (v13 - v15) >> 3;
      v18 = v17 + 1;
      if ((v17 + 1) >> 61)
      {
        std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
      }

      v19 = v12 - v15;
      if (v19 >> 2 > v18)
      {
        v18 = v19 >> 2;
      }

      if (v19 >= 0x7FFFFFFFFFFFFFF8)
      {
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v20 = v18;
      }

      if (v20)
      {
        if (!(v20 >> 61))
        {
          operator new();
        }

        std::__throw_bad_array_new_length[abi:ne200100]();
      }

      v21 = (v13 - v15) >> 3;
      v22 = (8 * v17);
      v23 = (8 * v17 - 8 * v21);
      *v22 = 0;
      v14 = v22 + 1;
      memcpy(v23, v15, v16);
      *(this + 3) = v23;
      *(this + 4) = v14;
      *(this + 5) = 0;
      if (v15)
      {
        operator delete(v15);
      }
    }

    else
    {
      *v13 = 0;
      v14 = v13 + 8;
    }

    *(this + 4) = v14;
  }
}

void sub_19B093634(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  _Unwind_Resume(exception_object);
}

void *SynthesisSBRQMFImpl<64u,(SBRQMFType)3,(vDSP_DFT_Direction)1>::SetState(uint64_t a1, const void *a2)
{
  result = memcpy((a1 + 16), a2, 0x1200uLL);
  *(a1 + 5136) = 1152;
  return result;
}

void *SynthesisSBRQMFImpl<64u,(SBRQMFType)3,(vDSP_DFT_Direction)1>::GetState(uint64_t a1, char *__dst)
{
  v3 = *(a1 + 5136);
  v4 = v3 + 128;
  v5 = v3 - 1152;
  if (v4 <= 0x4FF)
  {
    v5 = v4;
  }

  v6 = (a1 + 16);
  v7 = 4 * v5;
  v8 = 1280 - v5;
  memcpy(__dst, (a1 + 16 + v7), 4 * (1280 - v5));

  return memcpy(&__dst[4 * v8], v6, v7);
}

uint64_t SynthesisSBRQMFImpl<64u,(SBRQMFType)3,(vDSP_DFT_Direction)1>::Process(uint64_t a1, uint64_t *a2, uint64_t *a3, unsigned int a4, uint64_t a5)
{
  if (a4)
  {
    v9 = 0;
    v10 = a4 << 6;
    do
    {
      v12 = *a2++;
      v11 = v12;
      v13 = *a3++;
      (*(*a1 + 16))(a1, v11, v13, a5 + 4 * (v9 & 0xFFFFFFC0));
      v9 += 64;
    }

    while (v10 != v9);
  }

  return 0;
}

uint64_t SynthesisSBRQMFImpl<64u,(SBRQMFType)3,(vDSP_DFT_Direction)1>::ProcessSlice(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4)
{
  v6 = 0;
  v86 = *MEMORY[0x1E69E9840];
  *&v7 = -1;
  *(&v7 + 1) = -1;
  v85[14] = v7;
  v85[15] = v7;
  v85[12] = v7;
  v85[13] = v7;
  v85[10] = v7;
  v85[11] = v7;
  v85[8] = v7;
  v85[9] = v7;
  v85[6] = v7;
  v85[7] = v7;
  v85[4] = v7;
  v85[5] = v7;
  v85[2] = v7;
  v85[3] = v7;
  v85[0] = v7;
  v85[1] = v7;
  __Or[14] = v7;
  __Or[15] = v7;
  __Or[12] = v7;
  __Or[13] = v7;
  __Or[10] = v7;
  __Or[11] = v7;
  __Or[8] = v7;
  __Or[9] = v7;
  __Or[6] = v7;
  __Or[7] = v7;
  __Or[4] = v7;
  __Or[5] = v7;
  __Or[2] = v7;
  __Or[3] = v7;
  v8 = -4;
  v9 = 0x1Fu;
  __Or[0] = v7;
  __Or[1] = v7;
  do
  {
    v10 = *(a2 + v6 * 16);
    v11 = *(a3 + v6 * 16);
    v12 = vrev64q_s32(*(a2 + v9 * 16 - 256));
    v13 = vextq_s8(v12, v12, 8uLL);
    v14 = vrev64q_s32(*(a3 + v9 * 16 - 256));
    v15 = vextq_s8(v14, v14, 8uLL);
    v16 = vaddq_f32(v10, v13);
    v17 = vaddq_f32(v11, v15);
    v18 = vsubq_f32(v13, v10);
    v19 = vsubq_f32(v15, v11);
    v20 = vsubq_f32(v19, v16);
    v21 = vsubq_f32(v17, v18);
    v22 = vsubq_f32(vnegq_f32(v16), v19);
    v23 = vaddq_f32(v18, v17);
    v24 = kPreModulation128Real[v6];
    v25 = vrev64q_s32(kPreModulation128Real[v9 - 16]);
    v26 = vextq_s8(v25, v25, 8uLL);
    v27 = &__Or[v6];
    *v27 = vaddq_f32(vmulq_f32(v24, v20), vmulq_f32(v21, v26));
    v27[16] = vsubq_f32(vmulq_f32(v24, v21), vmulq_f32(v20, v26));
    v28 = vsubq_f32(vmulq_f32(v23, v26), vmulq_f32(v24, v22));
    v29 = vaddq_f32(vmulq_f32(v24, v23), vmulq_f32(v22, v26));
    v30 = vrev64q_s32(v28);
    v31 = vrev64q_s32(v29);
    v32 = &__Or[v9];
    v32[-16] = vextq_s8(v31, v31, 8uLL);
    *v32 = vextq_s8(v30, v30, 8uLL);
    v8 += 4;
    ++v6;
    --v9;
  }

  while (v8 < 0x1C);
  v33 = CADeprecated::TSingleton<RadixFFT<64u,(vDSP_DFT_Direction)1>>::instance();
  vDSP_DFT_Execute(*(v33 + 8), __Or, v85, __Or, v85);
  v34 = a1 + 16;
  v35 = (a1 + 16 + 4 * *(a1 + 5136));
  {
    v82 = v35;
    v83 = a1 + 16;
    v35 = v82;
    v34 = v83;
    if (v81)
    {
      SynthesisSBRQMFImpl<64u,(SBRQMFType)3,(vDSP_DFT_Direction)1>::PostModulation(DSPSplitComplex const&,float *)::kScaleFac = vdupq_n_s32(0x3C800000u);
      v35 = v82;
      v34 = v83;
    }
  }

  v36 = 0;
  v37 = v35 + 120;
  v38 = SynthesisSBRQMFImpl<64u,(SBRQMFType)3,(vDSP_DFT_Direction)1>::PostModulation(DSPSplitComplex const&,float *)::kScaleFac;
  v39 = -4;
  v40 = 0x1Fu;
  do
  {
    v41 = __Or[v36];
    v42 = __Or[v36 + 16];
    v43 = vmulq_f32(kAnalysisPostModulation128AlphaPlus1Real[v36], v38);
    v44 = vmulq_f32(kAnalysisPostModulation128AlphaPlus1Imag[v36], v38);
    v45 = vmulq_f32(v41, v43);
    v46 = vmulq_f32(v42, v44);
    v47 = vmulq_f32(v41, v44);
    v48 = vmulq_f32(v42, v43);
    v49 = __Or[v40 - 16];
    v50 = __Or[v40];
    v51 = vmulq_f32(v38, kAnalysisPostModulation128AlphaPlus1Real[v40 - 16]);
    v52 = vmulq_f32(v38, kAnalysisPostModulation128AlphaPlus1Imag[v40 - 16]);
    v88.val[0] = vaddq_f32(v45, v46);
    v53 = vrev64q_s32(vsubq_f32(vmulq_f32(v50, v51), vmulq_f32(v49, v52)));
    v88.val[1] = vextq_s8(v53, v53, 8uLL);
    v54 = vsubq_f32(v48, v47);
    v87.val[0] = vaddq_f32(vmulq_f32(v49, v51), vmulq_f32(v50, v52));
    vst2q_f32(v35, v88);
    v35 += 8;
    v55 = vrev64q_s32(v54);
    v87.val[1] = vextq_s8(v55, v55, 8uLL);
    vst2q_f32(v37, v87);
    v39 += 4;
    v37 -= 8;
    --v40;
    ++v36;
  }

  while (v39 < 0x1C);
  v56 = 0;
  v57 = *(a1 + 5136);
  if (v57 + 192 <= 0x4FF)
  {
    v58 = v57 + 192;
  }

  else
  {
    v58 = v57 - 1088;
  }

  v59 = &unk_19B3C2220;
  v60 = &unk_19B3C2320;
  do
  {
    v61 = (v34 + 4 * v57);
    v62 = *v61;
    v63 = v61[1];
    v64 = (&kSBR_FilterCoefficients640 + 4 * v56);
    v65 = vmulq_f32(v62, *v64);
    v66 = vmulq_f32(v63, v64[1]);
    v67 = v60;
    v68 = 4;
    do
    {
      v69 = v57 + 256;
      v57 -= 1024;
      if (v69 <= 0x4FF)
      {
        v57 = v69;
      }

      v70 = (v34 + 4 * v57);
      v65 = vmlaq_f32(v65, v67[-1], *v70);
      v66 = vmlaq_f32(v66, *v67, v70[1]);
      v67 += 32;
      --v68;
    }

    while (v68);
    v71 = v59;
    v72 = 5;
    do
    {
      v73 = (v34 + 4 * v58);
      v65 = vmlaq_f32(v65, v71[-1], *v73);
      v66 = vmlaq_f32(v66, *v71, v73[1]);
      v74 = v58 + 256;
      v58 -= 1024;
      if (v74 <= 0x4FF)
      {
        v58 = v74;
      }

      v71 += 32;
      --v72;
    }

    while (v72);
    v75 = v57 + 264;
    v57 -= 1016;
    if (v75 <= 0x4FF)
    {
      v57 = v75;
    }

    v58 += 8;
    *a4 = v65;
    a4[1] = v66;
    a4 += 2;
    v60 += 2;
    v59 += 2;
    v76 = v56 >= 0x38;
    v56 += 8;
  }

  while (!v76);
  v77 = *(a1 + 5136);
  v78 = v77 - 128;
  v79 = v77 + 1152;
  if (v78 >= 0)
  {
    v79 = v78;
  }

  *(a1 + 5136) = v79;
  return 0;
}

uint64_t CADeprecated::TSingleton<RadixFFT<24u,(vDSP_DFT_Direction)-1>>::instance()
{
  if (atomic_load_explicit(&CADeprecated::TSingleton<RadixFFT<24u,(vDSP_DFT_Direction)-1>>::sOnce, memory_order_acquire) != -1)
  {
    v5[1] = v0;
    v5[2] = v1;
    v5[0] = &v3;
    v4 = v5;
    std::__call_once(&CADeprecated::TSingleton<RadixFFT<24u,(vDSP_DFT_Direction)-1>>::sOnce, &v4, std::__call_once_proxy[abi:ne200100]<std::tuple<CADeprecated::TSingleton<RadixFFT<24u,(vDSP_DFT_Direction)-1>>::instance(void)::{lambda(void)#1} &&>>);
  }

  return CADeprecated::TSingleton<RadixFFT<24u,(vDSP_DFT_Direction)-1>>::sInstance;
}

void *AnalysisSBRQMFImpl<16u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::SetState(uint64_t a1, const void *a2)
{
  result = memcpy((a1 + 16), a2, 0x240uLL);
  *(a1 + 656) = 144;
  return result;
}

void *AnalysisSBRQMFImpl<16u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::GetState(uint64_t a1, char *__dst)
{
  v3 = *(a1 + 656);
  v4 = v3 + 16;
  v5 = v3 - 144;
  if (v4 <= 0x9F)
  {
    v5 = v4;
  }

  v6 = (a1 + 16);
  v7 = 4 * v5;
  v8 = 160 - v5;
  memcpy(__dst, (a1 + 16 + v7), 4 * (160 - v5));

  return memcpy(&__dst[4 * v8], v6, v7);
}

uint64_t AnalysisSBRQMFImpl<16u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::Process(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, uint64_t *a5)
{
  if (a3)
  {
    v9 = 0;
    v10 = 16 * a3;
    do
    {
      v12 = *a4++;
      v11 = v12;
      v13 = *a5++;
      (*(*a1 + 16))(a1, a2 + 4 * (v9 & 0xFFFFFFF0), v11, v13);
      v9 += 16;
    }

    while (v10 != v9);
  }

  return 0;
}

uint64_t AnalysisSBRQMFImpl<16u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::ProcessSlice(uint64_t a1, uint64_t a2, const float *a3, const float *a4)
{
  v6 = 0;
  v94 = *MEMORY[0x1E69E9840];
  v7 = *(a1 + 656);
  v8 = a2 + 64;
  v9 = a1 + 16;
  LOBYTE(v10) = 1;
  v11 = v7;
  v12 = a3;
  do
  {
    v13 = v10;
    v14 = *(v8 - 32);
    v15 = *(v8 - 16);
    v8 -= 32;
    v16 = vrev64q_s32(v14);
    v17 = vextq_s8(v16, v16, 8uLL);
    v18 = vrev64q_s32(v15);
    v19 = vextq_s8(v18, v18, 8uLL);
    v20 = &kSBR_USAC_FilterCoefficients160[v6];
    v22 = *v20;
    v23 = v20[1];
    v21 = (v20 + 9);
    v24 = vmulq_f32(v19, v22);
    v25 = vmulq_f32(v17, v23);
    v26 = (v9 + 4 * v11);
    *v26 = v19;
    v26[1] = v17;
    v10 = 4;
    do
    {
      v27 = v11 + 32;
      v11 -= 128;
      if (v27 <= 0x9F)
      {
        v11 = v27;
      }

      v28 = (v9 + 4 * v11);
      v24 = vmlaq_f32(v24, v21[-1], *v28);
      v25 = vmlaq_f32(v25, *v21, v28[1]);
      v21 += 8;
      --v10;
    }

    while (v10);
    v11 += 8;
    *v12 = v24;
    v12[1] = v25;
    v12 += 2;
    v6 = 2;
  }

  while ((v13 & 1) != 0);
  v29 = 0;
  v30 = v7 + 16;
  v31 = v7 - 144;
  if (v30 <= 0x9F)
  {
    v31 = v30;
  }

  v32 = 1;
  v33 = a4;
  do
  {
    v34 = v32;
    v35 = (v9 + 4 * v31);
    v36 = *v35;
    v37 = v35[1];
    v38 = &kSBR_USAC_FilterCoefficients160[v29];
    v39 = vmulq_f32(v36, v38[4]);
    v40 = vmulq_f32(v37, v38[5]);
    v41 = v38 + 13;
    v42 = 4;
    do
    {
      v43 = v31 + 32;
      v31 -= 128;
      if (v43 <= 0x9F)
      {
        v31 = v43;
      }

      v44 = (v9 + 4 * v31);
      v39 = vmlaq_f32(v39, v41[-1], *v44);
      v40 = vmlaq_f32(v40, *v41, v44[1]);
      v41 += 8;
      --v42;
    }

    while (v42);
    v32 = 0;
    v31 += 8;
    *v33 = v39;
    v33[1] = v40;
    v33 += 2;
    v29 = 2;
  }

  while ((v34 & 1) != 0);
  v45 = 0;
  v46 = *(a1 + 656);
  v47 = v46 - 16;
  v48 = v46 + 144;
  if (v47 >= 0)
  {
    v48 = v47;
  }

  *(a1 + 656) = v48;
  v49 = 1;
  do
  {
    v50 = v49;
    v51 = v45;
    v52 = *&a3[v45];
    v53 = kPreModulation32Real[v45 / 4];
    v54 = *&a4[v45];
    v55 = kPreModulation32Real[v45 / 0xFFFFFFFFFFFFFFFCLL + 3];
    v56 = vrev64q_s32(v55);
    v57 = vextq_s8(v56, v56, 8uLL);
    v58 = vmulq_f32(v52, v53);
    v59 = vmulq_f32(v52, v57);
    v60 = vsubq_f32(v58, vmulq_f32(v54, v57));
    v61 = vaddq_f32(vmulq_f32(v53, v54), v59);
    v62 = &a3[-v45 + 12];
    v63 = *v62;
    v64 = &a4[-v45 + 12];
    v65 = *v64;
    v66 = vrev64q_s32(v53);
    v67 = vextq_s8(v66, v66, 8uLL);
    *&a3[v51] = v60;
    *&a4[v51] = v61;
    *v62 = vsubq_f32(vmulq_f32(v55, v63), vmulq_f32(v67, v65));
    *v64 = vaddq_f32(vmulq_f32(v67, v63), vmulq_f32(v55, v65));
    v45 = 4;
    v49 = 0;
  }

  while ((v50 & 1) != 0);
  v68 = &v89;
  *&v69 = -1;
  *(&v69 + 1) = -1;
  v92[2] = v69;
  v93 = v69;
  v92[0] = v69;
  v92[1] = v69;
  v90[1] = v69;
  v91 = v69;
  v89 = v69;
  v90[0] = v69;
  v70 = CADeprecated::TSingleton<RadixFFT<16u,(vDSP_DFT_Direction)-1>>::instance();
  vDSP_DFT_Execute(*(v70 + 8), a3, a4, &v89, v92);
  v71 = 0;
  v72 = 1;
  do
  {
    v73 = kAnalysisPostModulation32AlphaMinusDot25Real[v71 / 4];
    v74 = v92[v71 / 4];
    v75 = kAnalysisPostModulation32AlphaMinusDot25Imag[v71 / 4];
    v76 = vmulq_f32(*v68, v73);
    v77 = vmulq_f32(v74, v75);
    v78 = vmulq_f32(*v68, v75);
    v79 = vmulq_f32(v73, v74);
    v80 = v92[v71 / 0xFFFFFFFFFFFFFFFCLL - 1];
    v81 = kAnalysisPostModulation32AlphaMinusDot25Real[v71 / 0xFFFFFFFFFFFFFFFCLL + 3];
    v82 = *(&v93 - 4 * v71);
    v83 = kAnalysisPostModulation32AlphaMinusDot25Imag[v71 / 0xFFFFFFFFFFFFFFFCLL + 3];
    v96.val[0] = vsubq_f32(v76, v77);
    v84 = vrev64q_s32(vsubq_f32(vmulq_f32(v82, v83), vmulq_f32(v80, v81)));
    v96.val[1] = vextq_s8(v84, v84, 8uLL);
    v95.val[0] = vaddq_f32(v79, v78);
    v85 = vrev64q_s32(vaddq_f32(vmulq_f32(v81, v82), vmulq_f32(v80, v83)));
    v86 = &a3[2 * v71];
    vst2q_f32(v86, v96);
    v95.val[1] = vextq_s8(v85, v85, 8uLL);
    v87 = &a4[2 * v71];
    vst2q_f32(v87, v95);
    LOBYTE(v86) = v72;
    v68 = v90;
    v71 = 4;
    v72 = 0;
  }

  while ((v86 & 1) != 0);
  return 0;
}

void RadixFFT<24u,(vDSP_DFT_Direction)-1>::~RadixFFT(void *a1)
{
  RadixFFT<24u,(vDSP_DFT_Direction)-1>::~RadixFFT(a1);

  JUMPOUT(0x19EAE53E0);
}

void *RadixFFT<24u,(vDSP_DFT_Direction)-1>::~RadixFFT(void *a1)
{
  *a1 = &unk_1F0E21D58;
  v2 = a1[1];
  if (v2)
  {
    vDSP_DFT_DestroySetup(v2);
  }

  return a1;
}

void *AnalysisSBRQMFImpl<24u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::SetState(uint64_t a1, const void *a2)
{
  result = memcpy((a1 + 16), a2, 0x360uLL);
  *(a1 + 976) = 216;
  return result;
}

void *AnalysisSBRQMFImpl<24u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::GetState(uint64_t a1, char *__dst)
{
  v3 = *(a1 + 976);
  v4 = v3 + 24;
  v5 = v3 - 216;
  if (v4 <= 0xEF)
  {
    v5 = v4;
  }

  v6 = (a1 + 16);
  v7 = 4 * v5;
  v8 = 240 - v5;
  memcpy(__dst, (a1 + 16 + v7), 4 * (240 - v5));

  return memcpy(&__dst[4 * v8], v6, v7);
}

uint64_t AnalysisSBRQMFImpl<24u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::Process(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, uint64_t *a5)
{
  if (a3)
  {
    v9 = 0;
    v10 = 24 * a3;
    do
    {
      v12 = *a4++;
      v11 = v12;
      v13 = *a5++;
      (*(*a1 + 16))(a1, a2 + 4 * (v9 & 0xFFFFFFF8), v11, v13);
      v9 += 24;
    }

    while (v10 != v9);
  }

  return 0;
}

uint64_t AnalysisSBRQMFImpl<24u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::ProcessSlice(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  v4 = a4;
  v5 = a3;
  v6 = 0;
  v87 = *MEMORY[0x1E69E9840];
  v7 = *(a1 + 976);
  v8 = a2 + 96;
  v9 = a1 + 16;
  v10 = &unk_19B3C2BE0;
  v11 = v7;
  v12 = a3;
  do
  {
    v13 = *(v8 - 32);
    v14 = *(v8 - 16);
    v8 -= 32;
    v15 = vrev64q_s32(v13);
    v16 = vextq_s8(v15, v15, 8uLL);
    v17 = vrev64q_s32(v14);
    v18 = vextq_s8(v17, v17, 8uLL);
    v19 = (&kSBR_USAC_FilterCoefficients240 + 4 * v6);
    v20 = vmulq_f32(v18, *v19);
    v21 = vmulq_f32(v16, v19[1]);
    v22 = (v9 + 4 * v11);
    *v22 = v18;
    v22[1] = v16;
    v23 = v10;
    v24 = 4;
    do
    {
      v25 = v11 + 48;
      v11 -= 192;
      if (v25 <= 0xEF)
      {
        v11 = v25;
      }

      v26 = (v9 + 4 * v11);
      v20 = vmlaq_f32(v20, v23[-1], *v26);
      v21 = vmlaq_f32(v21, *v23, v26[1]);
      v23 += 12;
      --v24;
    }

    while (v24);
    v11 += 8;
    *v12 = v20;
    v12[1] = v21;
    v12 += 2;
    v10 += 2;
    v27 = v6 >= 0x10;
    v6 += 8;
  }

  while (!v27);
  v28 = 0;
  v29 = v7 + 24;
  v30 = v7 - 216;
  if (v29 <= 0xEF)
  {
    v30 = v29;
  }

  v31 = &unk_19B3C2C40;
  v32 = a4;
  do
  {
    v33 = (v9 + 4 * v30);
    v34 = *v33;
    v35 = v33[1];
    v36 = (&kSBR_USAC_FilterCoefficients240 + 4 * v28);
    v37 = vmulq_f32(v34, v36[6]);
    v38 = vmulq_f32(v35, v36[7]);
    v39 = v31;
    v40 = 4;
    do
    {
      v41 = v30 + 48;
      v30 -= 192;
      if (v41 <= 0xEF)
      {
        v30 = v41;
      }

      v42 = (v9 + 4 * v30);
      v37 = vmlaq_f32(v37, v39[-1], *v42);
      v38 = vmlaq_f32(v38, *v39, v42[1]);
      v39 += 12;
      --v40;
    }

    while (v40);
    v30 += 8;
    *v32 = v37;
    v32[1] = v38;
    v32 += 2;
    v31 += 2;
    v27 = v28 >= 0x10;
    v28 += 8;
  }

  while (!v27);
  v43 = 0;
  v44 = *(a1 + 976);
  v45 = v44 - 24;
  v46 = v44 + 216;
  if (v45 >= 0)
  {
    v46 = v45;
  }

  *(a1 + 976) = v46;
  v47 = -4;
  v48 = 0x14u;
  do
  {
    v49 = *&a3[v43 / 4];
    v50 = kPreModulation48Real[v43 / 0x10];
    v51 = *&a4[v43 / 4];
    v52 = kPreModulation48Real[v48 / 4];
    v53 = vrev64q_s32(v52);
    v54 = vextq_s8(v53, v53, 8uLL);
    v55 = vmulq_f32(v49, v50);
    v56 = vmulq_f32(v49, v54);
    v57 = vsubq_f32(v55, vmulq_f32(v51, v54));
    v58 = vaddq_f32(vmulq_f32(v50, v51), v56);
    v59 = *&a3[v48];
    v60 = *&a4[v48];
    v61 = vrev64q_s32(v50);
    v62 = vextq_s8(v61, v61, 8uLL);
    *&a3[v43 / 4] = v57;
    *&a4[v43 / 4] = v58;
    *&a3[v48] = vsubq_f32(vmulq_f32(v52, v59), vmulq_f32(v62, v60));
    *&a4[v48] = vaddq_f32(vmulq_f32(v62, v59), vmulq_f32(v52, v60));
    v47 += 4;
    v48 -= 4;
    v43 += 16;
  }

  while (v47 < 8);
  *&v63 = -1;
  *(&v63 + 1) = -1;
  v85[4] = v63;
  v86 = v63;
  v85[2] = v63;
  v85[3] = v63;
  v85[0] = v63;
  v85[1] = v63;
  v84[4] = v63;
  v84[5] = v63;
  v84[2] = v63;
  v84[3] = v63;
  v64 = &v86;
  v84[0] = v63;
  v84[1] = v63;
  v65 = CADeprecated::TSingleton<RadixFFT<24u,(vDSP_DFT_Direction)-1>>::instance();
  vDSP_DFT_Execute(*(v65 + 8), v5, v4, v84, v85);
  v66 = 0;
  v67 = -4;
  v68 = 5u;
  do
  {
    v69 = kAnalysisPostModulation48AlphaDot375Real[v66];
    v70 = v84[v66];
    v71 = v84[v66 + 6];
    v72 = kAnalysisPostModulation48AlphaDot375Imag[v66];
    v73 = vmulq_f32(v70, v69);
    v74 = vmulq_f32(v71, v72);
    v75 = vmulq_f32(v70, v72);
    v76 = vmulq_f32(v69, v71);
    v77 = v64[-6];
    v78 = kAnalysisPostModulation48AlphaDot375Real[v68];
    v79 = *v64--;
    v80 = kAnalysisPostModulation48AlphaDot375Imag[v68];
    v89.val[0] = vsubq_f32(v73, v74);
    v81 = vrev64q_s32(vsubq_f32(vmulq_f32(v79, v80), vmulq_f32(v77, v78)));
    v89.val[1] = vextq_s8(v81, v81, 8uLL);
    v88.val[0] = vaddq_f32(v76, v75);
    v82 = vrev64q_s32(vaddq_f32(vmulq_f32(v78, v79), vmulq_f32(v77, v80)));
    vst2q_f32(v5, v89);
    v5 += 8;
    v88.val[1] = vextq_s8(v82, v82, 8uLL);
    vst2q_f32(v4, v88);
    v4 += 8;
    v67 += 4;
    --v68;
    ++v66;
  }

  while (v67 < 8);
  return 0;
}

void *AnalysisSBRQMFImpl<64u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::SetState(uint64_t a1, const void *a2)
{
  result = memcpy((a1 + 16), a2, 0x900uLL);
  *(a1 + 2576) = 576;
  return result;
}

void *AnalysisSBRQMFImpl<64u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::GetState(uint64_t a1, char *__dst)
{
  v3 = *(a1 + 2576);
  v4 = v3 + 64;
  v5 = v3 - 576;
  if (v4 <= 0x27F)
  {
    v5 = v4;
  }

  v6 = (a1 + 16);
  v7 = 4 * v5;
  v8 = 640 - v5;
  memcpy(__dst, (a1 + 16 + v7), 4 * (640 - v5));

  return memcpy(&__dst[4 * v8], v6, v7);
}

uint64_t AnalysisSBRQMFImpl<64u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::Process(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, uint64_t *a5)
{
  if (a3)
  {
    v9 = 0;
    v10 = a3 << 6;
    do
    {
      v12 = *a4++;
      v11 = v12;
      v13 = *a5++;
      (*(*a1 + 16))(a1, a2 + 4 * (v9 & 0xFFFFFFC0), v11, v13);
      v9 += 64;
    }

    while (v10 != v9);
  }

  return 0;
}

uint64_t AnalysisSBRQMFImpl<64u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::ProcessSlice(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  v4 = a4;
  v5 = a3;
  v6 = 0;
  v85 = *MEMORY[0x1E69E9840];
  v7 = *(a1 + 2576);
  v8 = a2 + 256;
  v9 = a1 + 16;
  v10 = &unk_19B3C2320;
  v11 = v7;
  v12 = a3;
  do
  {
    v13 = *(v8 - 32);
    v14 = *(v8 - 16);
    v8 -= 32;
    v15 = vrev64q_s32(v13);
    v16 = vextq_s8(v15, v15, 8uLL);
    v17 = vrev64q_s32(v14);
    v18 = vextq_s8(v17, v17, 8uLL);
    v19 = (&kSBR_FilterCoefficients640 + 4 * v6);
    v20 = vmulq_f32(v18, *v19);
    v21 = vmulq_f32(v16, v19[1]);
    v22 = (v9 + 4 * v11);
    *v22 = v18;
    v22[1] = v16;
    v23 = v10;
    v24 = 4;
    do
    {
      v25 = v11 + 128;
      v11 -= 512;
      if (v25 <= 0x27F)
      {
        v11 = v25;
      }

      v26 = (v9 + 4 * v11);
      v20 = vmlaq_f32(v20, v23[-1], *v26);
      v21 = vmlaq_f32(v21, *v23, v26[1]);
      v23 += 32;
      --v24;
    }

    while (v24);
    v11 += 8;
    *v12 = v20;
    v12[1] = v21;
    v12 += 2;
    v10 += 2;
    v27 = v6 >= 0x38;
    v6 += 8;
  }

  while (!v27);
  v28 = 0;
  v29 = v7 + 64;
  v30 = v7 - 576;
  if (v29 <= 0x27F)
  {
    v30 = v29;
  }

  v31 = &unk_19B3C2420;
  v32 = a4;
  do
  {
    v33 = (v9 + 4 * v30);
    v34 = *v33;
    v35 = v33[1];
    v36 = (&kSBR_FilterCoefficients640 + 4 * v28);
    v37 = vmulq_f32(v34, v36[16]);
    v38 = vmulq_f32(v35, v36[17]);
    v39 = v31;
    v40 = 4;
    do
    {
      v41 = v30 + 128;
      v30 -= 512;
      if (v41 <= 0x27F)
      {
        v30 = v41;
      }

      v42 = (v9 + 4 * v30);
      v37 = vmlaq_f32(v37, v39[-1], *v42);
      v38 = vmlaq_f32(v38, *v39, v42[1]);
      v39 += 32;
      --v40;
    }

    while (v40);
    v30 += 8;
    *v32 = v37;
    v32[1] = v38;
    v32 += 2;
    v31 += 2;
    v27 = v28 >= 0x38;
    v28 += 8;
  }

  while (!v27);
  v43 = 0;
  v44 = *(a1 + 2576);
  v45 = v44 - 64;
  v46 = v44 + 576;
  if (v45 >= 0)
  {
    v46 = v45;
  }

  *(a1 + 2576) = v46;
  v47 = -4;
  v48 = 0x3Cu;
  do
  {
    v49 = *&a3[v43 / 4];
    v50 = kPreModulation128Real[v43 / 0x10];
    v51 = *&a4[v43 / 4];
    v52 = kPreModulation128Real[v48 / 4];
    v53 = vrev64q_s32(v52);
    v54 = vextq_s8(v53, v53, 8uLL);
    v55 = vmulq_f32(v49, v50);
    v56 = vmulq_f32(v49, v54);
    v57 = vsubq_f32(v55, vmulq_f32(v51, v54));
    v58 = vaddq_f32(vmulq_f32(v50, v51), v56);
    v59 = *&a3[v48];
    v60 = *&a4[v48];
    v61 = vrev64q_s32(v50);
    v62 = vextq_s8(v61, v61, 8uLL);
    *&a3[v43 / 4] = v57;
    *&a4[v43 / 4] = v58;
    *&a3[v48] = vsubq_f32(vmulq_f32(v52, v59), vmulq_f32(v62, v60));
    *&a4[v48] = vaddq_f32(vmulq_f32(v62, v59), vmulq_f32(v52, v60));
    v47 += 4;
    v48 -= 4;
    v43 += 16;
  }

  while (v47 < 0x1C);
  *&v63 = -1;
  *(&v63 + 1) = -1;
  v84[14] = v63;
  v84[15] = v63;
  v84[12] = v63;
  v84[13] = v63;
  v84[10] = v63;
  v84[11] = v63;
  v84[8] = v63;
  v84[9] = v63;
  v84[6] = v63;
  v84[7] = v63;
  v84[4] = v63;
  v84[5] = v63;
  v84[2] = v63;
  v84[3] = v63;
  v84[0] = v63;
  v84[1] = v63;
  v83[14] = v63;
  v83[15] = v63;
  v83[12] = v63;
  v83[13] = v63;
  v83[10] = v63;
  v83[11] = v63;
  v83[8] = v63;
  v83[9] = v63;
  v83[6] = v63;
  v83[7] = v63;
  v83[4] = v63;
  v83[5] = v63;
  v83[2] = v63;
  v83[3] = v63;
  v83[0] = v63;
  v83[1] = v63;
  v64 = CADeprecated::TSingleton<RadixFFT<64u,(vDSP_DFT_Direction)-1>>::instance();
  vDSP_DFT_Execute(*(v64 + 8), v5, v4, v83, v84);
  v65 = 0;
  v66 = -4;
  v67 = 0x1Fu;
  do
  {
    v68 = v83[v65];
    v69 = kAnalysisPostModulation128AlphaPlus1Real_USAC[v65];
    v70 = v83[v65 + 16];
    v71 = kAnalysisPostModulation128AlphaPlus1Imag_USAC[v65];
    v72 = vmulq_f32(v68, v69);
    v73 = vmulq_f32(v70, v71);
    v74 = vmulq_f32(v68, v71);
    v75 = vmulq_f32(v69, v70);
    v76 = v83[v67 - 16];
    v77 = kAnalysisPostModulation128AlphaPlus1Real_USAC[v67 - 16];
    v78 = v83[v67];
    v79 = kAnalysisPostModulation128AlphaPlus1Imag_USAC[v67 - 16];
    v87.val[0] = vsubq_f32(v72, v73);
    v80 = vrev64q_s32(vsubq_f32(vmulq_f32(v78, v79), vmulq_f32(v76, v77)));
    v87.val[1] = vextq_s8(v80, v80, 8uLL);
    v86.val[0] = vaddq_f32(v75, v74);
    v81 = vrev64q_s32(vaddq_f32(vmulq_f32(v77, v78), vmulq_f32(v76, v79)));
    vst2q_f32(v5, v87);
    v5 += 8;
    v86.val[1] = vextq_s8(v81, v81, 8uLL);
    vst2q_f32(v4, v86);
    v4 += 8;
    v66 += 4;
    --v67;
    ++v65;
  }

  while (v66 < 0x1C);
  return 0;
}

void *AnalysisSBRQMFImpl<32u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::SetState(uint64_t a1, const void *a2)
{
  result = memcpy((a1 + 16), a2, 0x480uLL);
  *(a1 + 1296) = 288;
  return result;
}

void *AnalysisSBRQMFImpl<32u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::GetState(uint64_t a1, char *__dst)
{
  v3 = *(a1 + 1296);
  v4 = v3 + 32;
  v5 = v3 - 288;
  if (v4 <= 0x13F)
  {
    v5 = v4;
  }

  v6 = (a1 + 16);
  v7 = 4 * v5;
  v8 = 320 - v5;
  memcpy(__dst, (a1 + 16 + v7), 4 * (320 - v5));

  return memcpy(&__dst[4 * v8], v6, v7);
}

uint64_t AnalysisSBRQMFImpl<32u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::Process(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, uint64_t *a5)
{
  if (a3)
  {
    v9 = 0;
    v10 = 32 * a3;
    do
    {
      v12 = *a4++;
      v11 = v12;
      v13 = *a5++;
      (*(*a1 + 16))(a1, a2 + 4 * (v9 & 0xFFFFFFE0), v11, v13);
      v9 += 32;
    }

    while (v10 != v9);
  }

  return 0;
}

uint64_t AnalysisSBRQMFImpl<32u,(SBRQMFType)3,(vDSP_DFT_Direction)-1>::ProcessSlice(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  v4 = a4;
  v5 = a3;
  v6 = 0;
  v87 = *MEMORY[0x1E69E9840];
  v7 = *(a1 + 1296);
  v8 = a2 + 128;
  v9 = a1 + 16;
  v10 = &unk_19B3C1D20;
  v11 = v7;
  v12 = a3;
  do
  {
    v13 = *(v8 - 32);
    v14 = *(v8 - 16);
    v8 -= 32;
    v15 = vrev64q_s32(v13);
    v16 = vextq_s8(v15, v15, 8uLL);
    v17 = vrev64q_s32(v14);
    v18 = vextq_s8(v17, v17, 8uLL);
    v19 = (&kSBR_FilterCoefficients320 + 4 * v6);
    v20 = vmulq_f32(v18, *v19);
    v21 = vmulq_f32(v16, v19[1]);
    v22 = (v9 + 4 * v11);
    *v22 = v18;
    v22[1] = v16;
    v23 = v10;
    v24 = 4;
    do
    {
      v25 = v11 + 64;
      v11 -= 256;
      if (v25 <= 0x13F)
      {
        v11 = v25;
      }

      v26 = (v9 + 4 * v11);
      v20 = vmlaq_f32(v20, v23[-1], *v26);
      v21 = vmlaq_f32(v21, *v23, v26[1]);
      v23 += 16;
      --v24;
    }

    while (v24);
    v11 += 8;
    *v12 = v20;
    v12[1] = v21;
    v12 += 2;
    v10 += 2;
    v27 = v6 >= 0x18;
    v6 += 8;
  }

  while (!v27);
  v28 = 0;
  v29 = v7 + 32;
  v30 = v7 - 288;
  if (v29 <= 0x13F)
  {
    v30 = v29;
  }

  v31 = &unk_19B3C1DA0;
  v32 = a4;
  do
  {
    v33 = (v9 + 4 * v30);
    v34 = *v33;
    v35 = v33[1];
    v36 = (&kSBR_FilterCoefficients320 + 4 * v28);
    v37 = vmulq_f32(v34, v36[8]);
    v38 = vmulq_f32(v35, v36[9]);
    v39 = v31;
    v40 = 4;
    do
    {
      v41 = v30 + 64;
      v30 -= 256;
      if (v41 <= 0x13F)
      {
        v30 = v41;
      }

      v42 = (v9 + 4 * v30);
      v37 = vmlaq_f32(v37, v39[-1], *v42);
      v38 = vmlaq_f32(v38, *v39, v42[1]);
      v39 += 16;
      --v40;
    }

    while (v40);
    v30 += 8;
    *v32 = v37;
    v32[1] = v38;
    v32 += 2;
    v31 += 2;
    v27 = v28 >= 0x18;
    v28 += 8;
  }

  while (!v27);
  v43 = 0;
  v44 = *(a1 + 1296);
  v45 = v44 - 32;
  v46 = v44 + 288;
  if (v45 >= 0)
  {
    v46 = v45;
  }

  *(a1 + 1296) = v46;
  v47 = -4;
  v48 = 0x1Cu;
  do
  {
    v49 = *&a3[v43 / 4];
    v50 = kPreModulation64Real[v43 / 0x10];
    v51 = *&a4[v43 / 4];
    v52 = kPreModulation64Real[v48 / 4];
    v53 = vrev64q_s32(v52);
    v54 = vextq_s8(v53, v53, 8uLL);
    v55 = vmulq_f32(v49, v50);
    v56 = vmulq_f32(v49, v54);
    v57 = vsubq_f32(v55, vmulq_f32(v51, v54));
    v58 = vaddq_f32(vmulq_f32(v50, v51), v56);
    v59 = *&a3[v48];
    v60 = *&a4[v48];
    v61 = vrev64q_s32(v50);
    v62 = vextq_s8(v61, v61, 8uLL);
    *&a3[v43 / 4] = v57;
    *&a4[v43 / 4] = v58;
    *&a3[v48] = vsubq_f32(vmulq_f32(v52, v59), vmulq_f32(v62, v60));
    *&a4[v48] = vaddq_f32(vmulq_f32(v62, v59), vmulq_f32(v52, v60));
    v47 += 4;
    v48 -= 4;
    v43 += 16;
  }

  while (v47 < 0xC);
  *&v63 = -1;
  *(&v63 + 1) = -1;
  v85[6] = v63;
  v86 = v63;
  v85[4] = v63;
  v85[5] = v63;
  v85[2] = v63;
  v85[3] = v63;
  v85[0] = v63;
  v85[1] = v63;
  v84[6] = v63;
  v84[7] = v63;
  v84[4] = v63;
  v84[5] = v63;
  v84[2] = v63;
  v84[3] = v63;
  v64 = &v86;
  v84[0] = v63;
  v84[1] = v63;
  v65 = CADeprecated::TSingleton<RadixFFT<32u,(vDSP_DFT_Direction)-1>>::instance();
  vDSP_DFT_Execute(*(v65 + 8), v5, v4, v84, v85);
  v66 = 0;
  v67 = -4;
  v68 = 7u;
  do
  {
    v69 = kAnalysisPostModulation64AlphaMinusDot5Real_USAC[v66];
    v70 = v84[v66];
    v71 = v84[v66 + 8];
    v72 = kAnalysisPostModulation64AlphaMinusDot5Imag_USAC[v66];
    v73 = vmulq_f32(v70, v69);
    v74 = vmulq_f32(v71, v72);
    v75 = vmulq_f32(v70, v72);
    v76 = vmulq_f32(v69, v71);
    v77 = v64[-8];
    v78 = kAnalysisPostModulation64AlphaMinusDot5Real_USAC[v68];
    v79 = *v64--;
    v80 = kAnalysisPostModulation64AlphaMinusDot5Imag_USAC[v68];
    v89.val[0] = vsubq_f32(v73, v74);
    v81 = vrev64q_s32(vsubq_f32(vmulq_f32(v79, v80), vmulq_f32(v77, v78)));
    v89.val[1] = vextq_s8(v81, v81, 8uLL);
    v88.val[0] = vaddq_f32(v76, v75);
    v82 = vrev64q_s32(vaddq_f32(vmulq_f32(v78, v79), vmulq_f32(v77, v80)));
    vst2q_f32(v5, v89);
    v5 += 8;
    v88.val[1] = vextq_s8(v82, v82, 8uLL);
    vst2q_f32(v4, v88);
    v4 += 8;
    v67 += 4;
    --v68;
    ++v66;
  }

  while (v67 < 0xC);
  return 0;
}

uint64_t transportDec_AdjustEndOfAccessUnit(_DWORD *a1)
{
  v1 = a1 + 26;
  v2 = *a1 > 0xAu || ((1 << *a1) & 0x4C0) == 0;
  if (v2 || a1[722])
  {
    return 0;
  }

  v4 = a1[719];
  if (!a1[38])
  {
    v6 = (a1 + 28);
    v9 = a1[27];
    v10 = a1[31] - v9;
    v8 = a1[28] + v9;
    v11 = (a1[37] - 1) & (a1[32] - v9);
    a1[28] = v8;
    a1[31] = v10;
    a1[32] = v11;
    *(a1 + 13) = 0;
LABEL_11:
    v12 = (v8 - v4) & 7;
    v13 = a1[32];
    v14 = a1[31] + v12;
    a1[28] = v8 - v12;
    v15 = (a1[37] - 1) & (v13 + v12);
    a1[31] = v14;
    a1[32] = v15;
    goto LABEL_14;
  }

  v5 = a1[27];
  if (v5)
  {
    v6 = (a1 + 28);
    CDK_put((a1 + 28), a1[26], v5);
    v7 = a1[38];
    *(a1 + 13) = 0;
    v8 = a1[28];
    if (!v7)
    {
      goto LABEL_11;
    }
  }

  else
  {
    v6 = (a1 + 28);
    v8 = a1[28];
    *(a1 + 13) = 0;
  }

  CDK_put(v6, 0, (v4 - v8) & 7);
LABEL_14:
  if (*a1 != 10)
  {
    return 0;
  }

  v16 = a1[48];
  if (!v16)
  {
    return 0;
  }

  v17 = 8 * v16;
  v18 = a1[27];
  if (a1[38])
  {
    if (v18)
    {
      CDK_put(v6, *v1, v18);
    }
  }

  else
  {
    v19 = a1[32];
    v20 = a1[31] - v18;
    a1[28] += v18;
    v21 = (a1[37] - 1) & (v19 - v18);
    a1[31] = v20;
    a1[32] = v21;
  }

  *(a1 + 13) = 0;
  v22 = a1[28];
  v23 = a1[719];
  v24 = v22 + v17 - v23;
  if (v22 + v17 == v23)
  {
    return 0;
  }

  if (v22 + v17 - v23 < 0)
  {
    CDKpushBack(v1, v23 - (v22 + v17));
  }

  else
  {
    v26 = a1[31];
    v27 = a1[38];
    v28 = a1[37] - 1;
    if (v27)
    {
      v29 = -1;
    }

    else
    {
      v29 = a1[37] - 1;
    }

    v30 = a1[32] & v29;
    *(a1 + 13) = 0;
    v31 = v26 + v24;
    if (v27)
    {
      v32 = v24;
    }

    else
    {
      v32 = -v24;
    }

    a1[28] = v22 + v32;
    a1[31] = v31;
    a1[32] = v28 & (v30 + v24);
  }

  return (v24 >> 31) & 0x401;
}

int *CDKpushBack(int *result, int a2)
{
  v2 = result;
  v3 = result[1];
  v4 = v3 + a2;
  v5 = result[12];
  if ((v3 + a2) <= 0x1F && v5 == 0)
  {
    v8 = result[6];
    v9 = result[5] - v4;
    result[2] += v4;
    v10 = (result[11] - 1) & (v8 - v4);
    result[5] = v9;
    result[6] = v10;
    *result = 0;
  }

  else
  {
    if (v5)
    {
      if (v3)
      {
        result = CDK_put((result + 2), *result, v3);
        LOBYTE(v5) = *(v2 + 48);
      }
    }

    else
    {
      v11 = result[6];
      v12 = result[5] - v3;
      result[2] += v3;
      v13 = (result[11] - 1) & (v11 - v3);
      result[5] = v12;
      result[6] = v13;
    }

    *v2 = 0;
    if (v5)
    {
      v14 = -a2;
    }

    else
    {
      v14 = a2;
    }

    v2[2] += v14;
    v15 = (v2[11] - 1) & (v2[6] - a2);
    v2[5] -= a2;
    v2[6] = v15;
  }

  return result;
}

uint64_t transportDec_GetAuBitsRemaining(int *a1)
{
  if (a1[720] && a1[721] >= 1)
  {
    if (a1[38])
    {
      v2 = a1[27];
      if (v2)
      {
        CDK_put((a1 + 28), a1[26], v2);
      }
    }

    else
    {
      v9 = a1[27];
      v10 = a1[32];
      v11 = a1[31] - v9;
      a1[28] += v9;
      v12 = (a1[37] - 1) & (v10 - v9);
      a1[31] = v11;
      a1[32] = v12;
    }

    *(a1 + 13) = 0;
    result = a1[28];
    if ((result & 0x80000000) == 0)
    {
      return (a1[721] + result - a1[720]);
    }
  }

  else
  {
    if (a1[38])
    {
      v3 = a1[27];
      if (v3)
      {
        CDK_put((a1 + 28), a1[26], v3);
      }
    }

    else
    {
      v4 = a1[27];
      v5 = a1[32];
      v6 = a1[31] - v4;
      a1[28] += v4;
      v7 = (a1[37] - 1) & (v5 - v4);
      a1[31] = v6;
      a1[32] = v7;
    }

    *(a1 + 13) = 0;
    return a1[28];
  }

  return result;
}

uint64_t aacDecoder_ParseExplicitMpsAndSbr(uint64_t a1, int *a2, uint64_t a3, unsigned int a4, unsigned int a5, int *a6)
{
  v236[1] = *MEMORY[0x1E69E9840];
  AuBitsRemaining = transportDec_GetAuBitsRemaining(*(a1 + 24));
  v218 = AuBitsRemaining;
  if (AuBitsRemaining < 1)
  {
    return 0;
  }

  v12 = *(a1 + 68);
  if ((v12 & 0x8000) == 0 || (v12 & 0x84110) == 0)
  {
    goto LABEL_24;
  }

  v13 = a6[1] + *a6 + a6[3] + a6[16] + a6[17] + a6[18];
  v14 = (v13 - 1) & (v12 << 23 >> 31);
  if (v14 >= v13)
  {
    *(a1 + 840) = 1;
    goto LABEL_24;
  }

  v15 = a1 + 780;
  v16 = v13 - v14;
  v17 = (a1 + 148 + 4 * v14);
  v18 = 64;
  do
  {
    v19 = *(a1 + 68);
    if ((v19 & 0x100) != 0)
    {
      v21 = *(a1 + 148 + 4 * a5);
      if ((v21 & 0xFFFFFFFE) != 0x10)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "AAC_DECODER_ERROR aacDecoder_ParseExplicitMpsAndSbr(HANDLE_AACDECODER, HANDLE_CDK_BITSTREAM, const MP4_ELEMENT_ID, const int, const int, const int *)";
        v199 = 908;
        goto LABEL_291;
      }

      if (v21 == 17)
      {
        if (*(v15 + a5))
        {
          v20 = *(v15 + a5) == 3;
        }

        else
        {
          v20 = 1;
        }
      }

      else
      {
        v20 = 0;
      }
    }

    else
    {
      v20 = *v17;
    }

    v22 = sbrDecoder_Parse(*(a1 + 832), a2, &v218, -1, v20, v14, v19, a1 + 72);
    if (v22)
    {
      if (v22 != 5)
      {
        v23 = 0;
        goto LABEL_23;
      }

      v24 = v218;
      v25 = a2[1];
      v26 = a2[12];
      if (v25 <= v218)
      {
        if (!v26)
        {
          v53 = a2[6];
          v54 = a2[5] - v25;
          a2[2] += v25;
          v55 = (a2[11] - 1) & (v53 - v25);
          a2[5] = v54;
          a2[6] = v55;
          goto LABEL_64;
        }

        if (!v25)
        {
LABEL_64:
          *a2 = 0;
          if (*(a2 + 48))
          {
            v56 = v24;
          }

          else
          {
            v56 = -v24;
          }

          a2[2] += v56;
          v57 = (a2[11] - 1) & (a2[6] + v24);
          a2[5] += v24;
          a2[6] = v57;
          goto LABEL_68;
        }
      }

      else if (!v26)
      {
        a2[1] = v25 - v218;
LABEL_68:
        v58 = 0;
        v218 = 0;
        return v58;
      }

      CDK_put((a2 + 2), *a2, v25);
      goto LABEL_64;
    }

    ++v14;
    ++v17;
    --v16;
  }

  while (v16);
  v23 = 1;
  v18 = 840;
LABEL_23:
  AuBitsRemaining = v218;
  *(a1 + v18) = v23;
  if (AuBitsRemaining < 1)
  {
    return 0;
  }

LABEL_24:
  v27 = *(a1 + 68);
  if ((v27 & 0x4100) != 0 && ((v27 & 0x40000) != 0 || (*(a1 + 4 * a5 + 72) & 0x10) != 0))
  {
    v28 = *(a1 + 1912);
    if (v28 && a2 && *(v28 + 168))
    {
      v29 = *(v28 + 3452);
      v30 = v28 + 156 * v29 + 8;
      if (a2[12])
      {
        v31 = a2[1];
        v32 = *(v28 + 3452);
        LODWORD(v33) = *(v28 + 3452);
        if (v31)
        {
          CDK_put((a2 + 2), *a2, v31);
          v32 = *(v28 + 3452);
          LODWORD(v33) = *(v28 + 3452);
        }
      }

      else
      {
        v34 = a2[1];
        a2[2] += v34;
        v35 = a2[5] - v34;
        v36 = (a2[11] - 1) & (a2[6] - v34);
        a2[5] = v35;
        a2[6] = v36;
        v32 = v29;
        LODWORD(v33) = v29;
      }

      *a2 = 0;
      v37 = a2[2];
      v215 = (a2 + 2);
      if (*(v28 + 4 * v32 + 3480))
      {
        CDKmemcpy(v30, (v28 + 176), 0x9CuLL);
        v33 = *(v28 + 3452);
        *(v28 + 4 * v33 + 3488) = 1;
      }

      if (v37 < 1)
      {
        v42 = 0;
      }

      else
      {
        v212 = *(v28 + 168);
        v38 = v28 + 336 + 3080 * v33;
        __b = *v30;
        v216 = v38;
        v207 = v28;
        v206 = v37;
        v200 = v28 + 336;
        v201 = treePropertyTable[9 * *(v28 + 156 * v29 + 24) + 1];
        v202 = v29;
        __len = *v30 & 6;
        if (__len && !*(v28 + 156 * v29 + 138))
        {
          v48 = 1;
          *(v38 + 2) = 1;
          v47 = 1;
        }

        else
        {
          v39 = a2[1];
          if (1 - v39 <= 0)
          {
            v41 = 0;
            v43 = *a2;
            v40 = (a2 + 2);
          }

          else
          {
            v40 = (a2 + 2);
            if (v39 == -31)
            {
              v41 = 0;
            }

            else
            {
              v41 = *a2 << (1 - v39);
            }

            v43 = CDK_get32(v215);
            *a2 = v43;
            v39 = a2[1] + 32;
          }

          v44 = v39 - 1;
          a2[1] = v39 - 1;
          v45 = (v43 >> (v39 - 1)) | v41;
          if (4 - v39 < 1)
          {
            v46 = 0;
          }

          else
          {
            if (v39 == -28)
            {
              v46 = 0;
            }

            else
            {
              v46 = v43 << (4 - v39);
            }

            v43 = CDK_get32(v40);
            *a2 = v43;
            v44 = a2[1] + 32;
          }

          a2[1] = v44 - 3;
          v47 = (((v43 >> (v44 - 3)) | v46) & 7) + 1;
          *(v38 + 2) = (((v43 >> (v44 - 3)) | v46) & 7) + 1;
          v48 = (v45 & 1) == 0;
        }

        if (*(v30 + 44) < 1 || *(v30 + 48) < 1)
        {
          goto LABEL_272;
        }

        if (v48)
        {
          v49 = (v38 + 4);
          v50 = v47;
          v51 = 1;
          v52 = v30;
          do
          {
            *v49++ = *(v30 + 8) * v51++ / v47 - 1;
            --v50;
          }

          while (v50);
LABEL_86:
          LOBYTE(v72) = 1;
          v73 = v216;
          if ((v27 & 0x100000) == 0 || !__len)
          {
            v74 = a2[1];
            if (1 - v74 <= 0)
            {
              v75 = 0;
              v76 = *a2;
            }

            else
            {
              if (v74 == -31)
              {
                v75 = 0;
              }

              else
              {
                v75 = *a2 << (1 - v74);
              }

              v76 = CDK_get32(v215);
              *a2 = v76;
              v74 = a2[1] + 32;
            }

            v77 = v74 - 1;
            a2[1] = v77;
            v72 = ((v76 >> v77) | v75) & 1;
          }

          *v216 = v72;
          if (*(v52 + 52) >= 1)
          {
            v78 = 0;
            v79 = 0;
            while (!ecDataDec(v73, __b, a2, *(v73 + 355) + v78, (v73 + 40), v212[57], 0, v79, *(v207 + 156 * v202 + v79 + 154), *(v207 + 156 * v202 + v79 + 148)))
            {
              ++v79;
              v80 = *(v52 + 52);
              v78 += 48;
              v73 = v216;
              if (v79 >= v80)
              {
                if (v80 < 1)
                {
                  goto LABEL_103;
                }

                v81 = 0;
                v82 = 0;
                while (!ecDataDec(v73, __b, a2, *(v73 + 356) + v81, (v73 + 1300), v212[58], 1, v82, *(v52 + 146 + v82), 0))
                {
                  ++v82;
                  v81 += 48;
                  v73 = v216;
                  if (v82 >= *(v52 + 52))
                  {
                    goto LABEL_103;
                  }
                }

                goto LABEL_272;
              }
            }

            goto LABEL_272;
          }

LABEL_103:
          if (*(v52 + 16) == 7 && *(v52 + 133))
          {
            v83 = a2[1];
            if (1 - v83 <= 0)
            {
              v85 = 0;
              v86 = *a2;
              v84 = (a2 + 2);
              v87 = v216;
            }

            else
            {
              v84 = (a2 + 2);
              if (v83 == -31)
              {
                v85 = 0;
              }

              else
              {
                v85 = *a2 << (1 - v83);
              }

              v87 = v216;
              v86 = CDK_get32(v215);
              *a2 = v86;
              v83 = a2[1] + 32;
            }

            v88 = v83 - 1;
            a2[1] = v83 - 1;
            v89 = (v86 >> (v83 - 1)) | v85;
            *(v87 + 718) = v89 & 1;
            if (v89)
            {
              v93 = 2 - v83;
              if (v93 < 1)
              {
                v95 = 0;
              }

              else
              {
                v94 = v86 << v93;
                if (v88 == -31)
                {
                  v95 = 0;
                }

                else
                {
                  v95 = v94;
                }

                v86 = CDK_get32(v84);
                *a2 = v86;
                v88 = a2[1] + 32;
              }

              a2[1] = v88 - 1;
              *(v87 + 719) = ((v86 >> (v88 - 1)) | v95) & 1;
              if (ecDataDec(v87, __b, a2, *(v87 + 357), *(v87 + 358), v212[60], 2, 0, *(v52 + 145), 0))
              {
                goto LABEL_272;
              }
            }

            else
            {
              if (*(v52 + 145))
              {
                v90 = 0;
                do
                {
                  *(*v212[60] + v90) = 0;
                  if (v87[2])
                  {
                    v91 = 0;
                    v92 = v90;
                    do
                    {
                      *(*(v87 + 358) + v92) = 0;
                      ++v91;
                      v92 += 28;
                    }

                    while (v91 < v87[2]);
                  }

                  ++v90;
                }

                while (v90 < *(v52 + 145));
              }

              *(v87 + 719) = 0;
            }
          }

          v209 = v52;
          if ((__b & 2) == 0 || *(v52 + 130))
          {
            v96 = (a2 + 2);
            if (v216[2])
            {
              v97 = 0;
              v213 = v216 + 2560;
              v98 = v216 + 2587;
              do
              {
                v99 = a2[1];
                if (2 - v99 <= 0)
                {
                  v100 = 0;
                  v101 = *a2;
                }

                else
                {
                  if (v99 == -30)
                  {
                    v100 = 0;
                  }

                  else
                  {
                    v100 = *a2 << (2 - v99);
                  }

                  v101 = CDK_get32(v215);
                  *a2 = v101;
                  v99 = a2[1] + 32;
                }

                v102 = v99 - 2;
                a2[1] = v102;
                v103 = (v101 >> v102) | v100;
                v104 = v103 & 3;
                v213[v97] = v103 & 3;
                if ((v103 & 2) != 0)
                {
                  v105 = a2[1];
                  if (2 - v105 <= 0)
                  {
                    LOBYTE(v106) = 0;
                    v107 = *a2;
                  }

                  else
                  {
                    if (v105 == -30)
                    {
                      LOBYTE(v106) = 0;
                    }

                    else
                    {
                      v106 = *a2 << (2 - v105);
                    }

                    v107 = CDK_get32(v215);
                    *a2 = v107;
                    v105 = a2[1] + 32;
                  }

                  v108 = v105 - 2;
                  a2[1] = v108;
                  v216[v97 + 2569] = ((v107 >> v108) | v106) & 3;
                  v104 = v213[v97];
                }

                if (v104 == 3)
                {
                  v109 = a2[1];
                  if (2 - v109 <= 0)
                  {
                    LOBYTE(v110) = 0;
                    v111 = *a2;
                  }

                  else
                  {
                    if (v109 == -30)
                    {
                      LOBYTE(v110) = 0;
                    }

                    else
                    {
                      v110 = *a2 << (2 - v109);
                    }

                    v111 = CDK_get32(v215);
                    *a2 = v111;
                    v109 = a2[1] + 32;
                  }

                  v112 = v109 - 2;
                  a2[1] = v112;
                  v113 = ((v111 >> v112) | v110) & 3;
                  v216[v97 + 2578] = v113;
                  v114 = (v209[3] - 1) / pbStrideTable[v113];
                  if ((v114 & 0x80000000) == 0)
                  {
                    v115 = (v114 + 1);
                    v116 = v98;
                    do
                    {
                      v117 = a2[1];
                      if (1 - v117 <= 0)
                      {
                        LOBYTE(v118) = 0;
                        v119 = *a2;
                      }

                      else
                      {
                        if (v117 == -31)
                        {
                          LOBYTE(v118) = 0;
                        }

                        else
                        {
                          v118 = *a2 << (1 - v117);
                        }

                        v119 = CDK_get32(v215);
                        *a2 = v119;
                        v117 = a2[1] + 32;
                      }

                      v120 = v117 - 1;
                      a2[1] = v120;
                      *v116++ = ((v119 >> v120) | v118) & 1;
                      --v115;
                    }

                    while (v115);
                  }
                }

                ++v97;
                v98 += 28;
              }

              while (v97 < v216[2]);
            }
          }

          else
          {
            v96 = (a2 + 2);
            if (v216[2])
            {
              bzero(v216 + 2560, v216[2]);
            }
          }

          v121 = v209;
          if ((__b & 2) != 0 && v209[9] == 3)
          {
            v122 = v209[2];
            if (v122 == 32)
            {
              __lena = v209[2];
              v123 = 4;
              v124 = "\x05\t\r\x10\x12\x14\x16\x18\x19\x1A\x1B\x1C\x1D\x1D\x1E\x1E\x1E\x1D\x1D\x1C\x1B\x1A\x19\x18\x16\x14\x12\x10\r\t\x05";
            }

            else
            {
              if (v122 != 64)
              {
                goto LABEL_272;
              }

              __lena = v209[2];
              v123 = 5;
              v124 = "\x06\v\x10\x14\x17\x1B\x1E!#&(*,.01345789::;<<<=======<<<;::98754310.,*(&#!\x1E\x1B\x17\x14\x10\v\x06";
              v96 = (a2 + 2);
            }

            v125 = a2[1];
            if (v125)
            {
              v126 = v125 - 1;
              v127 = *a2;
              v128 = (*a2 >> v126) & 1;
            }

            else
            {
              v127 = CDK_get32(v96);
              *a2 = v127;
              v128 = v127 >> 31;
              v126 = 31;
            }

            a2[1] = v126;
            v216[3012] = v128;
            if (v128)
            {
              v216[3013] = __lena;
              v129 = v123 - v126;
              if (v123 - v126 < 1)
              {
                v130 = 0;
              }

              else
              {
                if (v129 == 32)
                {
                  v130 = 0;
                }

                else
                {
                  v130 = v127 << v129;
                }

                v127 = CDK_get32(v215);
                *a2 = v127;
                v126 = a2[1] + 32;
              }

              v131 = v126 - v123;
              a2[1] = v131;
              v132 = ((v127 >> v131) | v130) & BitMask[v123];
              v133 = v124[v132];
              v203 = v132;
              v134 = v132 + 1;
              v236[0] = 0;
              *&v220[1] = 0;
              v219 = -21846;
              __ba = v216 + 3014;
              memset(v216 + 3014, 255, __lena);
              v135 = 0;
              v136 = -48;
              v137 = 6;
              do
              {
                if (v135 + 48 < v133)
                {
                  if ((v133 + v136) >= 0x21)
                  {
                    exception = __cxa_allocate_exception(0x10uLL);
                    *exception = "UINT CDKreadBits(HANDLE_CDK_BITSTREAM, const UINT)";
                    v199 = 143;
                    goto LABEL_291;
                  }

                  v138 = a2[1];
                  if (v136 + v133 - v138 <= 0)
                  {
                    v139 = 0;
                    v140 = *a2;
                  }

                  else
                  {
                    if (v133 - v138 - 80 == v135)
                    {
                      LOWORD(v214) = 0;
                    }

                    else
                    {
                      v214 = *a2 << (v136 + v133 - v138);
                    }

                    v140 = CDK_get32(v215);
                    *a2 = v140;
                    v138 = a2[1] + 32;
                    v139 = v214;
                  }

                  v141 = v135 + v138 - v133 + 48;
                  a2[1] = v141;
                  *(v236 + v137) = ((v140 >> v141) | v139) & LOWORD(BitMask[v133 + v136]);
                  v133 = v135 + 48;
                }

                v137 -= 2;
                v135 -= 16;
                v136 += 16;
              }

              while (v135 != -64);
              v142 = (__lena - 1);
              v220[0] = __lena - v134;
              if (v203 >= 1)
              {
                v143 = 2;
                do
                {
                  v144 = (v143 + __lena - 1 - v134);
                  v145 = v144 * v220[0];
                  v220[0] *= v144;
                  for (i = 1; i != 5; ++i)
                  {
                    v145 = v144 * v220[i] + HIWORD(v145);
                    v220[i] = v145;
                  }

                  longdiv(v220, v143, v220, &v219);
                  if (v219)
                  {
                    exception = __cxa_allocate_exception(0x10uLL);
                    *exception = "int TsdRead(HANDLE_CDK_BITSTREAM, const int, TSD_DATA *)";
                    v199 = 200;
                    goto LABEL_291;
                  }
                }

                while (v143++ != v134);
              }

              v148 = 0;
              while (v142 >= v134)
              {
                v149 = 3;
                while (*(v236 + v149) == v220[v149])
                {
                  v150 = v149-- != 0;
                  if (v149 == 0 || !v150)
                  {
                    v149 = 0;
                    break;
                  }
                }

                if (*(v236 + v149) >= v220[v149])
                {
                  v154 = 0;
                  v155 = 0;
                  do
                  {
                    v156 = v220[v154];
                    v157 = v155 - v156 + *(v236 + v154 * 2);
                    *(v236 + v154 * 2) += v155 - v156;
                    v155 = v157 >> 16;
                    ++v154;
                  }

                  while (v154 != 4);
                  if (v157 >= 0x10000)
                  {
                    exception = __cxa_allocate_exception(0x10uLL);
                    *exception = "void longsub(USHORT *, USHORT *, int, int)";
                    v199 = 113;
LABEL_291:
                    exception[2] = v199;
                  }

                  __ba[v142] = 1;
                  if (v134 == 1)
                  {
                    goto LABEL_220;
                  }

                  v158 = 0;
                  v159 = v134 * v220[0];
                  v220[0] *= v134;
                  do
                  {
                    v159 = v134 * v220[v158 + 1] + HIWORD(v159);
                    v220[++v158] = v159;
                  }

                  while (v158 != 4);
                  --v134;
                }

                else
                {
                  v151 = 0;
                  v152 = (v142 - v134);
                  v153 = v152 * v220[0];
                  v220[0] *= v152;
                  do
                  {
                    v153 = v152 * v220[v151 + 1] + HIWORD(v153);
                    v220[++v151] = v153;
                  }

                  while (v151 != 4);
                }

                longdiv(v220, v142, v220, &v219);
                if (v219)
                {
                  exception = __cxa_allocate_exception(0x10uLL);
                  *exception = "int TsdRead(HANDLE_CDK_BITSTREAM, const int, TSD_DATA *)";
                  v199 = 226;
                  goto LABEL_291;
                }

                ++v148;
                if (v142-- <= 0)
                {
                  goto LABEL_220;
                }
              }

              memset(__ba, 1, (__lena - v148));
LABEL_220:
              v121 = v209;
              v161 = v216 + 3014;
              v162 = __lena;
              do
              {
                if (*v161 == 1)
                {
                  v163 = a2[1];
                  if (3 - v163 <= 0)
                  {
                    LOBYTE(v164) = 0;
                    v165 = *a2;
                  }

                  else
                  {
                    if (v163 == -29)
                    {
                      LOBYTE(v164) = 0;
                    }

                    else
                    {
                      v164 = *a2 << (3 - v163);
                    }

                    v165 = CDK_get32(v215);
                    *a2 = v165;
                    v163 = a2[1] + 32;
                  }

                  v166 = v163 - 3;
                  a2[1] = v166;
                  *v161 = ((v165 >> v166) | v164) & 7;
                }

                ++v161;
                --v162;
              }

              while (v162);
            }
          }

          else
          {
            v216[3012] = 0;
          }

          v167 = v201;
          if (v201 >= 1)
          {
            v168 = v216 + 2880;
            do
            {
              v168[130] = 0;
              *v168++ = 0;
              --v167;
            }

            while (v167);
          }

          if ((v121[9] - 1) <= 1)
          {
            v169 = a2[1];
            if (1 - v169 <= 0)
            {
              v170 = 0;
              v171 = *a2;
            }

            else
            {
              v170 = v169 == -31 ? 0 : *a2 << (1 - v169);
              v171 = CDK_get32(v215);
              *a2 = v171;
              v169 = a2[1] + 32;
            }

            v172 = v169 - 1;
            a2[1] = v172;
            if (((v171 >> v172) | v170))
            {
              v173 = v121[9];
              v174 = tempShapeChanTable[8 * v173 - 8 + v121[4]];
              if (v173 == 2)
              {
                LOWORD(v236[0]) = -21846;
                if (v174)
                {
                  v180 = v121;
                  for (j = 0; j != v174; ++j)
                  {
                    v182 = a2[1];
                    if (1 - v182 <= 0)
                    {
                      LOBYTE(v183) = 0;
                      v184 = *a2;
                    }

                    else
                    {
                      if (v182 == -31)
                      {
                        LOBYTE(v183) = 0;
                      }

                      else
                      {
                        v183 = *a2 << (1 - v182);
                      }

                      v184 = CDK_get32(v215);
                      *a2 = v184;
                      v182 = a2[1] + 32;
                    }

                    v185 = v182 - 1;
                    a2[1] = v185;
                    LOBYTE(v185) = ((v184 >> v185) | v183) & 1;
                    *(v236 + j) = v185;
                    v216[j + 2880] = v185;
                  }

                  v186 = 0;
                  v187 = v216 + 2882;
                  while (1)
                  {
                    if (*(v236 + v186))
                    {
                      *&v188 = 0xAAAAAAAAAAAAAAAALL;
                      *(&v188 + 1) = 0xAAAAAAAAAAAAAAAALL;
                      v234 = v188;
                      v235 = v188;
                      v232 = v188;
                      v233 = v188;
                      v230 = v188;
                      v231 = v188;
                      v228 = v188;
                      v229 = v188;
                      v226 = v188;
                      v227 = v188;
                      v224 = v188;
                      v225 = v188;
                      v222 = v188;
                      v223 = v188;
                      *v220 = v188;
                      v221 = v188;
                      if (huff_dec_reshape(a2, v220, v180[2]))
                      {
                        goto LABEL_272;
                      }

                      if (v180[2] >= 1)
                      {
                        break;
                      }
                    }

LABEL_270:
                    ++v186;
                    v187 += 64;
                    if (v186 == v174)
                    {
                      goto LABEL_241;
                    }
                  }

                  v189 = 0;
                  while (1)
                  {
                    v190 = *&v220[2 * v189];
                    if (v190 < 0)
                    {
                      goto LABEL_272;
                    }

                    v187[v189++] = v190;
                    if (v189 >= v180[2])
                    {
                      goto LABEL_270;
                    }
                  }
                }
              }

              else
              {
                if (v173 != 1)
                {
                  goto LABEL_272;
                }

                if (tempShapeChanTable[8 * v173 - 8 + v121[4]])
                {
                  v175 = v216 + 3010;
                  do
                  {
                    v176 = a2[1];
                    if (1 - v176 <= 0)
                    {
                      LOBYTE(v177) = 0;
                      v178 = *a2;
                    }

                    else
                    {
                      if (v176 == -31)
                      {
                        LOBYTE(v177) = 0;
                      }

                      else
                      {
                        v177 = *a2 << (1 - v176);
                      }

                      v178 = CDK_get32(v215);
                      *a2 = v178;
                      v176 = a2[1] + 32;
                    }

                    v179 = v176 - 1;
                    a2[1] = v179;
                    *v175++ = ((v178 >> v179) | v177) & 1;
                    --v174;
                  }

                  while (v174);
                }
              }
            }
          }

LABEL_241:
          v28 = v207;
          v42 = 1;
          *(v200 + 3080 * *(v207 + 3452) + 1) = 1;
        }

        else
        {
          v59 = *(v30 + 8);
          if (v59 < 2)
          {
            v61 = 0;
          }

          else
          {
            v60 = log(v59);
            v61 = (v60 * 1.44269504) & ~((v60 * 1.44269504) >> 31);
          }

          v208 = v30;
          if (1 << v61 >= v59)
          {
            v62 = v61;
          }

          else
          {
            v62 = v61 + 1;
          }

          if (v62 > 0x20)
          {
            exception = __cxa_allocate_exception(0x10uLL);
            *exception = "int nBitsParamSlot(int)";
            v199 = 579;
            goto LABEL_291;
          }

          v63 = 0;
          v64 = BitMask[v62];
          v65 = -1;
          while (1)
          {
            v66 = a2[1];
            v67 = v62 - v66;
            if ((v62 - v66) <= 0)
            {
              v68 = 0;
              v69 = *a2;
            }

            else
            {
              v68 = v67 == 32 ? 0 : *a2 << v67;
              v69 = CDK_get32(v215);
              *a2 = v69;
              v66 = a2[1] + 32;
            }

            v70 = v66 - v62;
            a2[1] = v70;
            v71 = ((v69 >> v70) | v68) & v64;
            *&v216[4 * v63 + 4] = v71;
            v52 = v208;
            if (v71 <= v65 || v71 >= *(v208 + 8))
            {
              break;
            }

            ++v63;
            v65 = v71;
            if (v63 >= v216[2])
            {
              goto LABEL_86;
            }
          }

LABEL_272:
          v42 = 0;
          v216[2] = 0;
          v28 = v207;
        }

        v37 = v206;
      }

      v191 = a2[1];
      if (a2[12])
      {
        if (v191)
        {
          CDK_put(v215, *a2, v191);
        }
      }

      else
      {
        v192 = a2[6];
        v193 = a2[5] - v191;
        a2[2] += v191;
        v194 = (a2[11] - 1) & (v192 - v191);
        a2[5] = v193;
        a2[6] = v194;
      }

      *a2 = 0;
      v195 = a2[2];
      v196 = v195 - v37;
      if (v195 < 0)
      {
        *(v28 + 3080 * *(v28 + 3452) + 337) = 0;
        AuBitsRemaining = v196 + v218;
        v218 += v196;
      }

      else
      {
        AuBitsRemaining = v196 + v218;
        v218 += v196;
        if (v42)
        {
          goto LABEL_280;
        }
      }
    }

    *(a1 + 64) = 0;
    v58 = 16386;
  }

  else
  {
LABEL_280:
    v58 = 0;
  }

  if ((*(a1 + 68) & 0x84100) == 0 && AuBitsRemaining >= 8)
  {
    while (!CAacDecoder_ExtPayloadParse(a1, a2, &v218, a3, a4, 0))
    {
      if (v218 < 8)
      {
        return 0;
      }
    }

    *(a1 + 64) = 0;
    return 16386;
  }

  return v58;
}

uint64_t CAacDecoder_AncDataParse(uint64_t result, int *a2, int a3)
{
  v5 = 0;
  if (a3 >= 1)
  {
    v6 = result;
    if (*result)
    {
      v7 = *(result + 44);
      v8 = *(result + 12 + 4 * v7);
      if (v8 + a3 <= *(result + 8) && v7 <= 6)
      {
        v10 = a3;
        do
        {
          v11 = a2[1];
          if (8 - v11 <= 0)
          {
            LOBYTE(v12) = 0;
            result = *a2;
          }

          else
          {
            if (v11 == -24)
            {
              LOBYTE(v12) = 0;
            }

            else
            {
              v12 = *a2 << (8 - v11);
            }

            result = CDK_get32((a2 + 2));
            *a2 = result;
            v11 = a2[1] + 32;
          }

          v13 = v11 - 8;
          a2[1] = v13;
          *(*v6 + v8++) = (result >> v13) | v12;
          --v10;
        }

        while (v10);
        v14 = *(v6 + 44);
        *(v6 + 44) = v14 + 1;
        *(v6 + 12 + 4 * (v14 + 1)) = *(v6 + 12 + 4 * v14) + a3;
        v5 = a3;
      }

      else
      {
        v5 = 0;
      }
    }
  }

  v15 = a3 - v5;
  if (v15 >= 1)
  {
    v16 = 8 * v15;
    v17 = a2[1];
    v18 = a2[12];
    if (v17 <= 8 * v15)
    {
      if (!v18)
      {
        v19 = a2[6];
        v20 = a2[5] - v17;
        a2[2] += v17;
        v21 = (a2[11] - 1) & (v19 - v17);
        a2[5] = v20;
        a2[6] = v21;
        goto LABEL_25;
      }

      if (!v17)
      {
LABEL_25:
        *a2 = 0;
        if (*(a2 + 48))
        {
          v22 = v16;
        }

        else
        {
          v22 = -v16;
        }

        a2[2] += v22;
        v23 = (a2[11] - 1) & (a2[6] + v16);
        a2[5] += v16;
        a2[6] = v23;
        return result;
      }
    }

    else if (!v18)
    {
      a2[1] = v17 - v16;
      return result;
    }

    result = CDK_put((a2 + 2), *a2, v17);
    goto LABEL_25;
  }

  return result;
}

int *CDKpushBiDirectional(int *result, unsigned int a2)
{
  v3 = result;
  if ((a2 & 0x80000000) == 0)
  {
    v4 = result[1];
    v5 = result[12];
    if (v4 <= a2)
    {
      if (!v5)
      {
        v12 = result[6];
        v13 = result[5] - v4;
        result[2] += v4;
        v14 = (result[11] - 1) & (v12 - v4);
        result[5] = v13;
        result[6] = v14;
        goto LABEL_15;
      }

      if (!v4)
      {
LABEL_15:
        *v3 = 0;
        if (*(v3 + 48))
        {
          v15 = a2;
        }

        else
        {
          v15 = -a2;
        }

        v3[2] += v15;
        v16 = (v3[11] - 1) & (v3[6] + a2);
        v3[5] += a2;
        v3[6] = v16;
        return result;
      }
    }

    else if (!v5)
    {
      result[1] = v4 - a2;
      return result;
    }

    result = CDK_put((result + 2), *result, v4);
    goto LABEL_15;
  }

  v6 = result[1];
  v7 = v6 - a2;
  v8 = result[12];
  if (v6 - a2 <= 0x1F)
  {
    if (!v8)
    {
      v9 = result[6];
      v10 = result[5] - v7;
      result[2] += v7;
      v11 = (result[11] - 1) & (v9 - v7);
      result[5] = v10;
      result[6] = v11;
      *result = 0;
      return result;
    }

    goto LABEL_12;
  }

  if (v8)
  {
LABEL_12:
    if (v6)
    {
      result = CDK_put((result + 2), *result, v6);
      LOBYTE(v8) = *(v3 + 48);
    }

    goto LABEL_20;
  }

  v17 = result[6];
  v18 = result[5] - v6;
  result[2] += v6;
  v19 = (result[11] - 1) & (v17 - v6);
  result[5] = v18;
  result[6] = v19;
LABEL_20:
  *v3 = 0;
  if (v8)
  {
    v20 = a2;
  }

  else
  {
    v20 = -a2;
  }

  v21 = v3[6];
  v22 = v3[5] + a2;
  v3[2] += v20;
  v23 = (v3[11] - 1) & (v21 + a2);
  v3[5] = v22;
  v3[6] = v23;
  return result;
}

uint64_t CAacDecoder_ExtPayloadParse(uint64_t a1, int *a2, int *a3, uint64_t a4, uint64_t a5, int a6)
{
  v6 = *a3;
  if (*a3 < 4)
  {
    return 16386;
  }

  if (a2[12])
  {
    v14 = a2[1];
    if (v14)
    {
      CDK_put((a2 + 2), *a2, v14);
    }
  }

  else
  {
    v15 = a2[1];
    v16 = a2[6];
    v17 = a2[5] - v15;
    a2[2] += v15;
    v18 = (a2[11] - 1) & (v16 - v15);
    a2[5] = v17;
    a2[6] = v18;
  }

  *a2 = 0;
  if (a2[2] < *a3)
  {
    return 16388;
  }

  v19 = CDK_get32((a2 + 2));
  v20 = a2[1] + 28;
  *a2 = v19;
  a2[1] = v20;
  v21 = (v19 >> v20) & 0xF;
  v22 = *a3;
  v23 = *a3 - 4;
  *a3 = v23;
  if (v21 > 12)
  {
    if ((v21 - 13) > 1)
    {
      goto LABEL_25;
    }

    result = 16386;
    if (a4 <= 0x12 && ((1 << a4) & 0x7000B) != 0)
    {
      CAacDecoder_SyncQmfMode(a1);
      if (sbrDecoder_InitElement(*(a1 + 832), *(a1 + 320), *(a1 + 352), *(a1 + 340), *(a1 + 328), a4, a5, 2, 2, &v58, *(a1 + 826)))
      {
        v28 = 0;
        *(a1 + 840) = 0;
      }

      else
      {
        v35 = sbrDecoder_Parse(*(a1 + 832), a2, a3, *a3, a4, a5, *(a1 + 68), a1 + 72);
        if (v35 != 5 && v35)
        {
          v28 = 0;
        }

        else
        {
          *(a1 + 840) = 1;
          v28 = v35 == 0;
        }
      }

      if (a6)
      {
        CDKpushBiDirectional(a2, *a3);
        *a3 = 0;
      }

      else if (!v28)
      {
        *(a1 + 64) = 0;
      }

      return 0;
    }
  }

  else
  {
    if (v21 == 1)
    {
      v31 = a2[1];
      if (4 - v31 <= 0)
      {
        v32 = 0;
        v36 = *a2;
      }

      else
      {
        if (v31 == -28)
        {
          v32 = 0;
        }

        else
        {
          v32 = *a2 << (4 - v31);
        }

        v36 = CDK_get32((a2 + 2));
        *a2 = v36;
        v31 = a2[1] + 32;
      }

      v45 = v31 - 4;
      a2[1] = v45;
      if ((((v36 >> v45) | v32) & 0xF) == 0)
      {
        v46 = (v6 >> 3) - 1;
        v47 = v46 & (v46 >> 31);
        while (1)
        {
          v48 = __OFSUB__(v46--, 1);
          if (v46 < 0 != v48)
          {
            break;
          }

          if (8 - v45 < 1)
          {
            v49 = 0;
          }

          else
          {
            if (v45 == -24)
            {
              v49 = 0;
            }

            else
            {
              v49 = v36 << (8 - v45);
            }

            v36 = CDK_get32((a2 + 2));
            *a2 = v36;
            v45 = a2[1] + 32;
          }

          v45 -= 8;
          a2[1] = v45;
          if (((v36 >> v45) | v49) != 0xA5)
          {
            result = 16386;
            v47 = v46;
            goto LABEL_86;
          }
        }

        result = 0;
LABEL_86:
        *a3 = 8 * v47;
        if (!a6)
        {
          return result;
        }

        goto LABEL_65;
      }
    }

    else
    {
      if (v21 != 2)
      {
        if (v21 == 3 && !a6 && (*(a1 + 68) & 0x40) != 0)
        {
          v24 = CDKreadBits(a2, 4);
          *a3 -= 4;
          if (v24 == 15)
          {
            v25 = CDKreadBits(a2, 8);
            *a3 -= 8;
            v24 = v25 + 15;
            if (v25 == 255)
            {
              v24 += CDKreadBits(a2, 16);
              *a3 -= 16;
            }
          }

          v26 = 8 * v24;
          v57 = v26;
          if (CDKreadBits(a2, 4) == 3)
          {
            return 16386;
          }

          CDKpushBack(a2);
          result = CAacDecoder_ExtPayloadParse(a1, a2, &v57, a4, a5, 1);
          v27 = v57 - v26 + *a3;
          goto LABEL_77;
        }

LABEL_25:
        v29 = a2[1];
        v30 = a2[12];
        if (v29 <= v23)
        {
          if (!v30)
          {
            v38 = a2[6];
            v39 = a2[5] - v29;
            a2[2] += v29;
            v40 = (a2[11] - 1) & (v38 - v29);
            a2[5] = v39;
            a2[6] = v40;
            goto LABEL_43;
          }

          if (!v29)
          {
LABEL_43:
            *a2 = 0;
            if (*(a2 + 48))
            {
              v41 = v23;
            }

            else
            {
              v41 = 4 - v22;
            }

            v42 = a2[6];
            v43 = a2[5] + v23;
            a2[2] += v41;
            v44 = (a2[11] - 1) & (v42 + v23);
            a2[5] = v43;
            a2[6] = v44;
            goto LABEL_67;
          }
        }

        else if (!v30)
        {
          a2[1] = v29 - v23;
LABEL_67:
          result = 0;
          *a3 = 0;
          return result;
        }

        CDK_put((a2 + 2), *a2, v29);
        goto LABEL_43;
      }

      v33 = a2[1];
      if (4 - v33 <= 0)
      {
        LOBYTE(v34) = 0;
        v37 = *a2;
      }

      else
      {
        if (v33 == -28)
        {
          LOBYTE(v34) = 0;
        }

        else
        {
          v34 = *a2 << (4 - v33);
        }

        v37 = CDK_get32((a2 + 2));
        *a2 = v37;
        v33 = a2[1] + 32;
      }

      v50 = v33 - 4;
      a2[1] = v50;
      *a3 -= 4;
      if ((((v37 >> v50) | v34) & 0xF) == 0)
      {
        v51 = 0;
        do
        {
          v52 = a2[1];
          if (8 - v52 <= 0)
          {
            v53 = 0;
            v54 = *a2;
          }

          else
          {
            if (v52 == -24)
            {
              v53 = 0;
            }

            else
            {
              v53 = *a2 << (8 - v52);
            }

            v54 = CDK_get32((a2 + 2));
            *a2 = v54;
            v52 = a2[1] + 32;
          }

          v55 = v52 - 8;
          a2[1] = v55;
          v56 = (v54 >> v55) | v53;
          *a3 -= 8;
          v51 += v56;
        }

        while (v56 == 255);
        CAacDecoder_AncDataParse(a1 + 1936, a2, v51);
        result = 0;
        v27 = *a3 - 8 * v51;
LABEL_77:
        *a3 = v27;
        return result;
      }
    }

    result = 16386;
  }

  if (!a6)
  {
    return result;
  }

LABEL_65:
  if (result)
  {
    CDKpushBiDirectional(a2, *a3);
    goto LABEL_67;
  }

  return result;
}

uint64_t CDKreadBits(unsigned int *a1, int a2)
{
  v4 = a1[1];
  v5 = a2 - v4;
  if (a2 - v4 <= 0)
  {
    v6 = 0;
    v7 = *a1;
  }

  else
  {
    if (v5 == 32)
    {
      v6 = 0;
    }

    else
    {
      v6 = *a1 << v5;
    }

    v7 = CDK_get32((a1 + 2));
    *a1 = v7;
    v4 = a1[1] + 32;
  }

  v8 = v4 - a2;
  a1[1] = v8;
  return ((v7 >> v8) | v6) & BitMask[a2];
}

int *CDKsyncCache(int *result)
{
  v1 = result;
  if (result[12])
  {
    v2 = result[1];
    if (v2)
    {
      result = CDK_put((result + 2), *result, v2);
    }
  }

  else
  {
    v3 = result[1];
    v4 = result[6];
    v5 = result[5] - v3;
    result[2] += v3;
    v6 = (result[11] - 1) & (v4 - v3);
    result[5] = v5;
    result[6] = v6;
  }

  *v1 = 0;
  return result;
}

float32x4_t lsf_dec::lsfDecoder::Conceal(lsf_dec::lsfDecoder *this, int a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9)
{
  v10 = (this + 128);
  if (a2)
  {
    *v10 = lpd_rom::cdk_dec_lsf_init[0];
    *(this + 9) = unk_19B3D5EF8;
    *(this + 10) = xmmword_19B3D5F08;
    *(this + 11) = unk_19B3D5F18;
    *this = lpd_rom::cdk_dec_lsf_init[0];
    *(this + 1) = unk_19B3D5EF8;
    *(this + 2) = xmmword_19B3D5F08;
    *(this + 3) = unk_19B3D5F18;
  }

  else
  {
    v11 = *(this + 1);
    *v10 = *this;
    *(this + 9) = v11;
    v12 = *(this + 3);
    *(this + 10) = *(this + 2);
    *(this + 11) = v12;
  }

  v13 = 0;
  __asm
  {
    FMOV            V0.4S, #0.75
    FMOV            V1.4S, #0.25
  }

  v20 = vdupq_n_s32(0x3DCCCCCDu);
  v21 = vdupq_n_s32(0x3F666666u);
  do
  {
    *(this + v13 * 16 + 192) = vmlaq_f32(vmulq_f32(vmlaq_f32(vmulq_f32(*(this + v13 * 16 + 64), _Q0), _Q1, lpd_rom::cdk_dec_lsf_init[v13]), v20), v21, *(this + v13 * 16));
    ++v13;
  }

  while (v13 != 4);
  v22 = 2;
  v23 = vdupq_n_s32(0x3DCCCCCDu);
  v24 = vdupq_n_s32(0x3F666666u);
  v25 = this;
  do
  {
    a9.f32[0] = (v22 * 0.1) + 0.25;
    a9 = vdupq_lane_s32(*a9.f32, 0);
    v26 = 16;
    v27 = v25;
    v28 = (this + 64);
    v29 = lpd_rom::cdk_dec_lsf_init;
    do
    {
      v30 = *v29++;
      v31 = v30;
      v32 = *v28++;
      v27[16] = vmlaq_f32(vmulq_f32(vmlaq_f32(vmulq_n_f32(v32, 0.75 - (v22 * 0.1)), v31, a9), v23), v24, v27[12]);
      ++v27;
      v26 -= 4;
    }

    while (v26);
    ++v22;
    v25 = (v25 + 64);
  }

  while (v22 != 5);
  v33 = 0;
  v34 = *(this + 25);
  *this = *(this + 24);
  *(this + 1) = v34;
  v35 = *(this + 27);
  *(this + 2) = *(this + 26);
  *(this + 3) = v35;
  do
  {
    for (i = 0; i != 64; i += 4)
    {
      *(v10 + i) = __cospif (*(v10 + i) * 0.00015625);
    }

    ++v33;
    v10 += 4;
  }

  while (v33 != 5);
  v37 = (this + 528);
  result = vld1q_dup_f32(v37);
  *(this + 32) = result;
  return result;
}

void bpf_dec::bassPostFilter::Configure(bpf_dec::bassPostFilter *this, int a2, int a3)
{
  v4 = a2 + 255;
  if (a2 >= 0)
  {
    v4 = a2;
  }

  if (a3)
  {
    v5 = 2;
  }

  else
  {
    v5 = 4;
  }

  *(this + 142) = v5;
  *(this + 137) = a2 >> a3;
  v6 = v4 >> 8;
  *(this + 138) = v6;
  if (a3)
  {
    v7 = 1;
  }

  else
  {
    v7 = 2;
  }

  v8 = v6 << v7;
  *(this + 139) = v8;
  v8 >>= 1;
  *(this + 143) = v8;
  v9 = this + 364;
  v10 = v8 - 1;
  *(this + 140) = v10;
  *(this + 141) = v10 << 6;
  if (v10 && (memmove(this + 364, this + 4, 4 * v10), v11 = *(this + 140), v11))
  {
    memmove(this + 456, this + 32, 4 * v11);
    v12 = *(this + 140);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(this + 139);
  if (v13 >= 1)
  {
    memset_pattern16(&v9[4 * v12], "@", 4 * v13);
    v14 = *(this + 139);
    if (v14 >= 1)
    {
      v15 = this + 4 * *(this + 140) + 456;

      bzero(v15, 4 * v14);
    }
  }
}

uint64_t CDKgetWindowSlope(int a1, int a2)
{
  v2 = 0;
  if ((a1 & 0x80000000) == 0)
  {
    v3 = ~a1;
    do
    {
      ++v2;
      v3 *= 2;
    }

    while (v3 < 0);
  }

  v4 = a1 >> (28 - v2);
  v5 = 2;
  if (v4 != 12)
  {
    v5 = v4 == 15;
  }

  v6 = v4 == 8;
  if (v4 == 8)
  {
    v7 = 29;
  }

  else
  {
    v7 = 30;
  }

  if (v6)
  {
    v8 = 0;
  }

  else
  {
    v8 = v5;
  }

  v9 = v7 - v2;
  if (a2 == 1)
  {
    v9 -= 4;
  }

  result = *(&windowSlopes + 36 * (a2 & 1) + 9 * v8 + v9);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "const FLOAT_SPK *CDKgetWindowSlope(int, int)";
    exception[2] = 1724;
  }

  return result;
}

uint64_t fac_dec::facDecoder::Acelp2Mdct(_OWORD *a1, uint64_t a2, char *__dst, float *a4, int a5, int a6, int a7, int a8, float a9, uint64_t *a10, int a11, uint64_t a12, DCTWrapper *a13, unsigned __int8 a14, unsigned __int8 a15, char a16, int a17, int a18)
{
  v22 = a14 | a15;
  v23 = a1 + 8 * a18;
  if (v22 == 1 || !*(v23 + 64))
  {
    a1[30] = 0u;
    a1[31] = 0u;
    a1[28] = 0u;
    a1[29] = 0u;
    a1[26] = 0u;
    a1[27] = 0u;
    a1[24] = 0u;
    a1[25] = 0u;
    a1[22] = 0u;
    a1[23] = 0u;
    a1[20] = 0u;
    a1[21] = 0u;
    a1[18] = 0u;
    a1[19] = 0u;
    a1[16] = 0u;
    a1[17] = 0u;
    a1[14] = 0u;
    a1[15] = 0u;
    a1[12] = 0u;
    a1[13] = 0u;
    a1[10] = 0u;
    a1[11] = 0u;
    a1[8] = 0u;
    a1[9] = 0u;
    a1[6] = 0u;
    a1[7] = 0u;
    a1[4] = 0u;
    a1[5] = 0u;
    a1[2] = 0u;
    a1[3] = 0u;
    *a1 = 0u;
    a1[1] = 0u;
    *(a1 + a18 + 64) = a1;
  }

  if (a6 >= 129)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int32_t fac_dec::facDecoder::Acelp2Mdct(mdct_t_fl &, float *const, float *const, const int32_t, const int32_t, const int32_t, const int32_t, const FLOAT_SPK *, const int32_t, const simd_float16 &, acelp_dec::acelpDecoder &, const float, const BOOL, const BOOL, const BOOL, const lpdMode, const int32_t)";
    v109 = 255;
    goto LABEL_96;
  }

  HIDWORD(v25) = a6 - 48;
  LODWORD(v25) = a6 - 48;
  v24 = v25 >> 4;
  if (v24 >= 6 || ((0x2Bu >> v24) & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int32_t fac_dec::facDecoder::Acelp2Mdct(mdct_t_fl &, float *const, float *const, const int32_t, const int32_t, const int32_t, const int32_t, const FLOAT_SPK *, const int32_t, const simd_float16 &, acelp_dec::acelpDecoder &, const float, const BOOL, const BOOL, const BOOL, const lpdMode, const int32_t)";
    v109 = 283;
    goto LABEL_96;
  }

  v26 = *(&off_1E7531308 + v24);
  v27 = *(&off_1E7531338 + v24);
  v28 = *(&off_1E7531368 + v24);
  v29 = a8 - 2 * a6;
  v119 = a7;
  if (a7 < 1)
  {
    v32 = 0;
  }

  else
  {
    v30 = *(a2 + 28);
    if (v30)
    {
      v31 = a1 + 8 * a18;
      memmove(__dst, *a2, 4 * v30);
      v23 = v31;
      a7 = v119;
      v32 = *(a2 + 28);
    }

    else
    {
      v32 = 0;
    }

    *(a2 + 28) = 0;
  }

  v115 = v29;
  v33 = v29 >> 1;
  if (v32 >= a7)
  {
    v35 = *(a2 + 28);
    v34 = (*a2 + 4 * v35);
    v121 = v34;
    if (v35 < a6)
    {
      v34 = &__dst[4 * v32];
    }

    *(a2 + 28) = v33 + a6 + v35;
  }

  else
  {
    v121 = &__dst[4 * v32];
    v34 = v121;
  }

  v122 = v32;
  v36 = v22 ^ 1;
  v37 = *(v23 + 64);
  if (a18)
  {
    v36 = 1;
  }

  if (v36)
  {
    v117 = v34;
    fac_dec::facDecoder::CalcFacSignal(a13, v37, a6, a12, a16);
    v38 = a13;
    v39 = acelp_dec::acelpDecoder::Zir(a13, a6, v37, a17 != 4, *a12, *(a12 + 16), *(a12 + 32), *(a12 + 48));
    if (a6 >= 1)
    {
LABEL_24:
      v40 = (v117 - 4);
      v41 = v38;
      v43 = a8;
      v42 = v121;
      v44 = a6;
      v45 = v119;
      do
      {
        v46 = *v37++;
        v47 = v46;
        v48 = *v28++;
        v49 = v47 * v48;
        v50 = *v40--;
        v51 = v50;
        v52 = *v27++;
        v53 = v49 + (v51 * v52);
        v54 = *v41++;
        *v42++ = v53 + v54;
        --v44;
      }

      while (v44);
      v55 = 1;
      goto LABEL_29;
    }
  }

  else
  {
    if (a6 > 0)
    {
      v117 = v34;
      bzero(a13, 4 * (2 * a6 - 1) + 4);
      v38 = a13;
      v39 = acelp_dec::acelpDecoder::Zir(a13, a6, v37, a17 != 4, *a12, *(a12 + 16), *(a12 + 32), *(a12 + 48));
      v28 = v27;
      v27 = a13;
      goto LABEL_24;
    }

    v38 = a13;
    v39 = acelp_dec::acelpDecoder::Zir(a13, a6, *(v23 + 64), a17 != 4, *a12, *(a12 + 16), *(a12 + 32), *(a12 + 48));
  }

  v55 = 0;
  v43 = a8;
  v45 = v119;
LABEL_29:
  if (v122 >= v45)
  {
    v56 = 0;
  }

  else
  {
    v56 = v33 + a6;
  }

  DCTWrapper::Instance(v39);
  Dct = DCTWrapper::getDct(&DCTWrapper::Instance(void)::instance, v43);
  vDSP_DCT_Execute(Dct, a4, a4);
  v58 = 1.0 / v43;
  if (a9 == 0.0)
  {
    v59 = 1.0;
  }

  else
  {
    v59 = a9;
  }

  v124[0] = v58 * v59;
  v118 = v43;
  v60 = MEMORY[0x19EAE6090](a4, 1, v124, a4, 1);
  v61 = &v121[a6 - 1];
  if (v55)
  {
    v62 = &a4[v43 - a6];
    v63 = a6;
    while (1)
    {
      v64 = *v62++;
      v65 = v64;
      v66 = v61 < *a2 || v61 >= *a2 + 4 * *(a2 + 32);
      if (v66 && (v61 < __dst || v61 >= __dst + 1024))
      {
        break;
      }

      *v61 = *v61 - (v65 * *v26);
      --v61;
      v26 += 2;
      if (!--v63)
      {
        goto LABEL_45;
      }
    }

    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int32_t fac_dec::facDecoder::Acelp2Mdct(mdct_t_fl &, float *const, float *const, const int32_t, const int32_t, const int32_t, const int32_t, const FLOAT_SPK *, const int32_t, const simd_float16 &, acelp_dec::acelpDecoder &, const float, const BOOL, const BOOL, const BOOL, const lpdMode, const int32_t)";
    v109 = 369;
LABEL_96:
    exception[2] = v109;
  }

LABEL_45:
  v67 = (v38 + 4 * a6);
  v68 = v67;
  if (v115 >= 2)
  {
    if (v33 < a6)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "int32_t fac_dec::facDecoder::Acelp2Mdct(mdct_t_fl &, float *const, float *const, const int32_t, const int32_t, const int32_t, const int32_t, const FLOAT_SPK *, const int32_t, const simd_float16 &, acelp_dec::acelpDecoder &, const float, const BOOL, const BOOL, const BOOL, const lpdMode, const int32_t)";
      v109 = 383;
      goto LABEL_96;
    }

    v68 = 0;
  }

  v69 = &v61[a6 + 1];
  *(a2 + 48) = v68;
  if (v33 >= 1)
  {
    v70 = 0;
    v71 = &a4[v43 - a6 - 1];
    do
    {
      v72 = *v71;
      if (v70 >= a6)
      {
        v74 = -v72;
      }

      else
      {
        v73 = *v67++;
        v74 = v73 - v72;
      }

      v75 = v69 < *a2 || v69 >= *a2 + 4 * *(a2 + 32);
      if (v75 && (v69 < __dst || v69 >= __dst + 1024))
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "int32_t fac_dec::facDecoder::Acelp2Mdct(mdct_t_fl &, float *const, float *const, const int32_t, const int32_t, const int32_t, const int32_t, const FLOAT_SPK *, const int32_t, const simd_float16 &, acelp_dec::acelpDecoder &, const float, const BOOL, const BOOL, const BOOL, const lpdMode, const int32_t)";
        v109 = 397;
        goto LABEL_96;
      }

      *v69++ = v74;
      --v71;
      ++v70;
    }

    while (v33 != v70);
  }

  v76 = (v43 - a11) >> 1;
  v123 = v56 + v122;
  *(a2 + 20) = v76;
  *(a2 + 24) = a11;
  *(a2 + 8) = a10;
  *(a2 + 16) = v43;
  v77 = (v43 + (v43 >> 31)) >> 1;
  if (a5 > 1)
  {
    v114 = v76 + a11 / 2;
    v78 = (a11 + (a11 >> 31)) >> 1;
    v112 = v43;
    v113 = 8 * v43 - 4 * (a11 / 2);
    v79 = 1;
    v80 = a4;
    v81 = a8;
    v116 = v76;
    do
    {
      v82 = &v80[v112];
      DCTWrapper::Instance(v60);
      v83 = DCTWrapper::getDct(&DCTWrapper::Instance(void)::instance, v81);
      vDSP_DCT_Execute(v83, v82, v82);
      v124[0] = v58;
      v60 = MEMORY[0x19EAE6090](v82, 1, v124, v82, 1, v118);
      v84 = v123;
      if (v123 >= v119)
      {
        v86 = *(a2 + 28);
        v69 = (*a2 + 4 * v86);
        v85 = *(a2 + 20);
        *(a2 + 28) = v86 + a11 / 2 + v85;
      }

      else
      {
        v85 = *(a2 + 20);
        v84 = v123 + a11 / 2 + v85;
      }

      v87 = &v80[v77 - 1];
      if (v85 >= 1)
      {
        do
        {
          v88 = *v87--;
          *v69++ = -v88;
          --v85;
        }

        while (v85);
      }

      if (v84 >= v119)
      {
        v90 = *(a2 + 28);
        v89 = (*a2 + 4 * v90 + 4 * v78 - 4);
        *(a2 + 28) = v114 + v90;
      }

      else
      {
        v89 = &v69[a11 - 1];
        v84 += v114;
      }

      v91 = v113;
      v92 = a10;
      v93 = (a11 / 2);
      if (a11 >= 2)
      {
        do
        {
          v94 = *(v80 + v91);
          v95 = *v87--;
          v96 = v95;
          v97 = *v92++;
          *v69++ = (v94 * *(&v97 + 1)) - (v96 * *&v97);
          *v89-- = -((v96 * *(&v97 + 1)) + (v94 * *&v97));
          v91 += 4;
          --v93;
        }

        while (v93);
      }

      v98 = *(a2 + 48);
      if (v98)
      {
        if (a11 > 257)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *exception = "int32_t fac_dec::facDecoder::Acelp2Mdct(mdct_t_fl &, float *const, float *const, const int32_t, const int32_t, const int32_t, const int32_t, const FLOAT_SPK *, const int32_t, const simd_float16 &, acelp_dec::acelpDecoder &, const float, const BOOL, const BOOL, const BOOL, const lpdMode, const int32_t)";
          v109 = 467;
          goto LABEL_96;
        }

        if (a11 >= 2)
        {
          v99 = &v69[a11 / -2];
          v100 = (a11 / 2);
          do
          {
            v101 = *v98++;
            *v99 = v101 + *v99;
            ++v99;
            --v100;
          }

          while (v100);
        }

        *(a2 + 48) = 0;
      }

      v123 = v84;
      if (v116 >= 1)
      {
        v102 = v113 - 4;
        v103 = &v89[v78 + 1];
        v104 = v116;
        do
        {
          *v103++ = -*(v80 + v102);
          v102 -= 4;
          --v104;
        }

        while (v104);
      }

      v69 += v78;
      *(a2 + 20) = v116;
      *(a2 + 24) = a11;
      v81 = a8;
      *(a2 + 16) = a8;
      *(a2 + 8) = a10;
      ++v79;
      v80 = (v80 + v112 * 4);
    }

    while (v79 != a5);
  }

  v105 = *(a2 + 32);
  v106 = (*a2 + 4 * v105 - 4 * v77);
  if (v106 < *a2 + 4 * *(a2 + 28))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int32_t fac_dec::facDecoder::Acelp2Mdct(mdct_t_fl &, float *const, float *const, const int32_t, const int32_t, const int32_t, const int32_t, const FLOAT_SPK *, const int32_t, const simd_float16 &, acelp_dec::acelpDecoder &, const float, const BOOL, const BOOL, const BOOL, const lpdMode, const int32_t)";
    v109 = 496;
    goto LABEL_96;
  }

  if (v77 > v105)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int32_t fac_dec::facDecoder::Acelp2Mdct(mdct_t_fl &, float *const, float *const, const int32_t, const int32_t, const int32_t, const int32_t, const FLOAT_SPK *, const int32_t, const simd_float16 &, acelp_dec::acelpDecoder &, const float, const BOOL, const BOOL, const BOOL, const lpdMode, const int32_t)";
    v109 = 497;
    goto LABEL_96;
  }

  if (a8 >= 2)
  {
    memmove(v106, &a4[(a5 - 1) * a8], 4 * (a8 >> 1));
  }

  return v123;
}

uint64_t imlt_block(DCTWrapper *a1, float *a2, float *a3, unsigned int a4, int a5, int a6, uint64_t a7, int a8, float a9, uint64_t a10, int a11)
{
  v16 = a1;
  v63 = a8;
  v62 = (a6 - a8) >> 1;
  if (*(a1 + 6) != a8)
  {
    a1 = imdct_adapt_parameters(a1, &v63, &v62, a7, a5);
  }

  v17 = *v16 + 4 * *(v16 + 32);
  if (a5 < 1)
  {
    v18 = 0;
  }

  else
  {
    v18 = *(v16 + 28);
    if (v18 >= 1)
    {
      for (i = 0; i != v18; ++i)
      {
        *a2++ = *(*v16 + 4 * i);
      }
    }

    *(v16 + 28) = 0;
  }

  v20 = 0;
  v21 = 1.0;
  if (a9 != 0.0)
  {
    v21 = a9;
  }

  v22 = (1.0 / a6) * v21;
  v57 = a4;
  v23 = *(v16 + 24);
  LODWORD(v24) = v63;
  v59 = a4;
  v61 = 4 * a6;
  v25 = a3;
  do
  {
    if (v23 != v24)
    {
      a1 = imdct_adapt_parameters(v16, &v63, &v62, a7, a5);
    }

    v26 = *(v16 + 8);
    v27 = &a3[v20 * a6];
    DCTWrapper::Instance(a1);
    Dct = DCTWrapper::getDct(&DCTWrapper::Instance(void)::instance, a6);
    vDSP_DCT_Execute(Dct, v27, v27);
    if (a6 >= 1)
    {
      v29 = v25;
      v30 = a6;
      do
      {
        *v29 = v22 * *v29;
        ++v29;
        --v30;
      }

      while (v30);
    }

    if (v18 >= a5)
    {
      v33 = *(v16 + 28);
      a2 = (*v16 + 4 * v33);
      LODWORD(v31) = *(v16 + 20);
      v24 = v63;
      v32 = v63 / 2;
      *(v16 + 28) = v31 + v33 + v63 / 2;
    }

    else
    {
      LODWORD(v31) = *(v16 + 20);
      v24 = v63;
      v32 = v63 / 2;
      v18 = (v31 + v18 + v63 / 2);
    }

    v34 = (v17 - 4);
    v35 = *(v16 + 48);
    if (v35 && v31 == v32)
    {
      if (v31 >= 1)
      {
        v31 = v31;
        do
        {
          v36 = *v34--;
          v37 = v36;
          v38 = *v35++;
          *a2++ = v38 - v37;
          --v31;
        }

        while (v31);
      }

      v35 = 0;
      *(v16 + 48) = 0;
    }

    else if (v31 >= 1)
    {
      do
      {
        v39 = *v34--;
        *a2++ = -v39;
        LODWORD(v31) = v31 - 1;
      }

      while (v31);
    }

    if (v18 >= a5)
    {
      v42 = *(v16 + 28);
      v40 = (*v16 + 4 * v42 + 4 * v32 - 4);
      v41 = v62;
      *(v16 + 28) = v62 + v42 + v32;
    }

    else
    {
      v40 = &a2[v24 - 1];
      v41 = v62;
      v18 = (v62 + v18 + v32);
    }

    if (v24 >= 2)
    {
      v43 = v32;
      v44 = v61 - ((2 * v24) & 0x1FFFFFFFCLL);
      do
      {
        v45 = *(v25 + v44);
        v46 = *v34--;
        v47 = v46;
        v48 = *v26++;
        *a2++ = (v45 * *(&v48 + 1)) - (v47 * *&v48);
        *v40-- = -((v47 * *(&v48 + 1)) + (v45 * *&v48));
        v44 += 4;
        --v43;
      }

      while (v43);
    }

    if (v35)
    {
      if (v24 > 257)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "INT imlt_block(H_MDCT_FL, FLOAT *, FLOAT *, const INT, const INT, const INT, const FLOAT_SPK *, INT, const FLOAT_SPK *, const INT, FLOAT, int)";
        exception[2] = 329;
      }

      if (v24 >= 2)
      {
        v49 = &a2[-v32];
        v50 = v32;
        do
        {
          v51 = *v35++;
          *v49 = v51 + *v49;
          ++v49;
          --v50;
        }

        while (v50);
      }

      *(v16 + 48) = 0;
    }

    if (v41 >= 1)
    {
      v52 = &v40[v32 + 1];
      v53 = v61 - 4 - 4 * v32;
      v54 = v41;
      do
      {
        *v52++ = -*(v25 + v53);
        v53 -= 4;
        --v54;
      }

      while (v54);
    }

    a2 += v41 + v32;
    v17 = &v27[(a6 + (a6 >> 31)) >> 1];
    v23 = a11;
    *(v16 + 20) = (a6 - a11) >> 1;
    *(v16 + 24) = a11;
    *(v16 + 16) = a6;
    *(v16 + 8) = a10;
    ++v20;
    v25 = (v25 + v61);
  }

  while (v20 != v59);
  CDKmemcpy((*v16 + 4 * *(v16 + 32) + 4 * (a6 / -2)), &a3[(v57 - 1) * a6], (4 * (a6 / 2)));
  return v18;
}

void *bpf_dec::bassPostFilter::Process(bpf_dec::bassPostFilter *this, const float *a2, int a3, int a4, int a5, float *a6)
{
  v7 = a4;
  v57 = *MEMORY[0x1E69E9840];
  v8 = *(this + 139);
  if (v8 >= 1)
  {
    v9 = a2;
    v10 = (this + 456);
    v11 = 114;
    do
    {
      if (*v10 > 0.0)
      {
        v12 = &v9[-*(v10 - 23)];
        v55 = NAN;
        __C[0] = 0.0;
        vDSP_dotpr(v9, 1, v12, 1, __C, 0x40uLL);
        vDSP_svesq(v12, 1, &v55, 0x40uLL);
        *v10 = __C[0] / (v55 + 0.000001);
        v8 = *(this + 139);
        v7 = a4;
      }

      v13 = v11 - 113;
      ++v11;
      ++v10;
      v9 += 64;
    }

    while (v13 < v8);
  }

  result = memset(__C, 255, sizeof(__C));
  if (v7 >= 1)
  {
    v15 = 0;
    v16 = 0;
    v48 = a2 - 96;
    v17 = a2 - 64;
    v18 = this + 364;
    v47 = a5 + v7;
    v19 = a6;
    do
    {
      v20 = *&v18[4 * v16];
      v21 = *(this + v16 + 114);
      if (v21 > 1.0)
      {
        v21 = 1.0;
      }

      if (v21 < 0.0)
      {
        v21 = 0.0;
      }

      v55 = v21;
      if (v21 <= 0.0)
      {
        memset(&__C[76], 0, 256);
      }

      else
      {
        v54 = 0.0;
        v22 = &a2[v15];
        v53 = 0;
        vDSP_svesq(v22 - 96, 1, &v54, 0xA0uLL);
        vDSP_svesq(&v48[v15 - (v20 >> 1)], 1, &v53, 0xA0uLL);
        vDSP_dotpr(v22 - 96, 1, &v48[v15 - (v20 >> 1)], 1, &v53 + 1, 0xA0uLL);
        *(&v53 + 1) = *(&v53 + 1) + 0.01;
        v54 = v54 + 0.01;
        *&v53 = *&v53 + 0.01;
        v23.i32[1] = -1;
        v23.f32[0] = v54 * *&v53;
        v24 = vrsqrte_f32(v23);
        v25 = vmul_f32(v24, vrsqrts_f32(v23, vmul_f32(v24, v24)));
        if ((*(&v53 + 1) * vmul_f32(v25, vrsqrts_f32(v23, vmul_f32(v25, v25))).f32[0]) > 0.95)
        {
          v20 >>= 1;
        }

        v26 = v47 - (v20 + v15);
        if (v26 >= 64)
        {
          v27 = 64;
        }

        else
        {
          v27 = v47 - (v20 + v15);
        }

        v28 = v27 & ~(v27 >> 31);
        v29 = &a2[v20 + v15];
        if (v26 <= 0)
        {
          v32 = v55;
        }

        else
        {
          vDSP_svesq(v22, 1, &v53, v28);
          vDSP_svesq(v29, 1, &v54, v28);
          v30 = v54 + 0.01;
          v54 = v30;
          v31 = *&v53 + 0.01;
          *&v53 = *&v53 + 0.01;
          if (v30 <= 0.0)
          {
            exception = __cxa_allocate_exception(0x10uLL);
            *exception = "void bpf_dec::bassPostFilter::Process(const float *const, const int32_t, const int32_t, const int32_t, float *const)";
            exception[2] = 208;
          }

          v32 = sqrtf(v31 / v30);
          *&v53 = v32;
          if (v32 >= v55)
          {
            v32 = v55;
          }
        }

        v55 = v32 * 0.5;
        v52 = -1090519040;
        MEMORY[0x19EAE6050](&a2[v15 - v20], 1, &v52, v22, 1, &__C[76], 1, v28);
        MEMORY[0x19EAE6050](v29, 1, &v52, &__C[76], 1, &__C[76], 1, v28);
        if (v26 <= 63)
        {
          MEMORY[0x19EAE6100](&a2[v28 + v15 - v20], 1, &a2[(v28 + v15)], 1, &__C[v28 + 76], 1, (64 - v28));
          LODWORD(v28) = 64;
        }

        MEMORY[0x19EAE6090](&__C[76], 1, &v55, &__C[76], 1, v28);
        v7 = a4;
        v18 = this + 364;
      }

      memcpy(__C, this + 60, 0x130uLL);
      result = memcpy(this + 60, &__C[64], 0x130uLL);
      v33 = 0;
      v34.f32[0] = __C[12];
      v35 = &__C[13];
      do
      {
        v36 = v34.f32[0] * 0.08825;
        v34 = *v35;
        v37 = vrev64q_s32(*(&v35[-2] + 12));
        v38 = vrev64q_s32(*(&v35[-3] + 12));
        v39 = vaddq_f32(v35[1], vextq_s8(v38, v38, 8uLL));
        v40 = vrev64q_s32(*(&v35[-4] + 12));
        v41 = vmulq_f32(vaddq_f32(*v35, vextq_s8(v37, v37, 8uLL)), xmmword_19B0B3680);
        v42 = vmulq_f32(v39, xmmword_19B0B3690);
        *v42.i8 = vadd_f32(*v42.i8, *&vextq_s8(v42, v42, 8uLL));
        v43 = vmulq_f32(vaddq_f32(v35[2], vextq_s8(v40, v40, 8uLL)), xmmword_19B0B36A0);
        *v43.i8 = vadd_f32(*v43.i8, *&vextq_s8(v43, v43, 8uLL));
        *v42.i8 = vadd_f32(vzip1_s32(*v42.i8, *v43.i8), vzip2_s32(*v42.i8, *v43.i8));
        v19[v33] = v17[v33] - (((v36 + vaddv_f32(vadd_f32(*v41.i8, *&vextq_s8(v41, v41, 8uLL)))) + *v42.i32) + *&v42.i32[1]);
        v35 = (v35 + 4);
        ++v33;
      }

      while (v33 != 64);
      v15 += 64;
      ++v16;
      v19 += 64;
      v17 += 64;
    }

    while (v15 < v7);
  }

  if (a3 != v7)
  {
    return memmove(&a6[v7], &a2[v7 - 64], 4 * (a3 - v7));
  }

  return result;
}

uint64_t imdct_adapt_parameters(uint64_t result, int *a2, int *a3, uint64_t a4, int a5)
{
  v5 = *a2;
  v6 = *a3;
  if (*(result + 16))
  {
    v7 = 0;
    v9 = *(result + 20);
    v8 = *(result + 24);
  }

  else
  {
    *(result + 8) = a4;
    v9 = (a5 - v5) >> 1;
    *(result + 16) = a5;
    *(result + 20) = v9;
    *(result + 24) = v5;
    *(result + 28) = 0;
    v7 = 1;
    v8 = v5;
  }

  v10 = v9 + ((v8 - v5) >> 1);
  if (v10 >= 1)
  {
    v11 = 1;
  }

  else
  {
    v11 = v7;
  }

  v12 = v6 - ((v8 - v5) >> 1);
  if (v12 >= 1 && v11 != 0)
  {
    if (v8 > v5)
    {
      goto LABEL_14;
    }

    goto LABEL_13;
  }

  if (v11)
  {
LABEL_13:
    *(result + 20) = v10;
    *(result + 24) = v5;
    v8 = v5;
    v12 = v6;
    *(result + 8) = a4;
  }

LABEL_14:
  *a2 = v8;
  *a3 = v12;
  return result;
}

char *acelp_dec::acelpDecoder::Zir(char *result, int a2, float *__dst, int a4, int32x4_t a5, int32x4_t a6, int32x4_t a7, int32x4_t a8)
{
  v8 = *(result + 108);
  v26[0] = *(result + 107);
  v26[1] = v8;
  v9 = *(result + 110);
  v26[2] = *(result + 109);
  v26[3] = v9;
  memset(v27, 0, sizeof(v27));
  if (a2 < 1)
  {
    if (a4)
    {
      v23 = (result + 1776);
      v24 = *(result + 444);
      goto LABEL_10;
    }
  }

  else
  {
    v10 = v27;
    v11 = vrev64q_s32(a5);
    v12 = vextq_s8(v11, v11, 8uLL);
    v13 = vrev64q_s32(a6);
    v14 = vextq_s8(v13, v13, 8uLL);
    v15 = vrev64q_s32(a7);
    v16 = vextq_s8(v15, v15, 8uLL);
    v17 = vrev64q_s32(a8);
    v18 = vextq_s8(v17, v17, 8uLL);
    v19 = a2;
    v20 = v27;
    v21 = a2;
    do
    {
      v22 = vaddq_f32(vaddq_f32(vmulq_f32(v18, *(v20 - 16)), vmulq_f32(v14, *(v20 - 8))), vaddq_f32(vmulq_f32(v16, *(v20 - 12)), vmulq_f32(v12, *(v20 - 4))));
      *v20 = *v20 - vaddv_f32(vadd_f32(*v22.i8, *&vextq_s8(v22, v22, 8uLL)));
      ++v20;
      --v21;
    }

    while (v21);
    if (a4)
    {
      v23 = (result + 1776);
      v24 = *(result + 444);
      do
      {
        v25 = *v10++;
        v24 = v25 + (v24 * 0.68);
        *__dst++ = v24;
        --v19;
      }

      while (v19);
LABEL_10:
      if (fabsf(v24) < 1.0e-10)
      {
        v24 = 0.0;
      }

      *v23 = v24;
      return result;
    }
  }

  if (a2)
  {
    return memcpy(__dst, v26, 4 * a2);
  }

  return result;
}

void fac_dec::facDecoder::CalcFacSignal(DCTWrapper *a1, float *a2, int a3, float32x4_t *a4, char a5)
{
  DCTWrapper::Instance(a1);
  Dct = DCTWrapper::getDct(&DCTWrapper::Instance(void)::instance, a3);
  vDSP_DCT_Execute(Dct, a2, a2);
  if (a5)
  {
    if (!a3)
    {
      v12 = a4[2];
      v13 = a4[3];
      v15 = *a4;
      v14 = a4[1];
      goto LABEL_8;
    }

    v11 = a3;
    memmove(a1, a2, 4 * a3);
  }

  else
  {
    v43 = 1.0 / a3;
    v11 = a3;
    MEMORY[0x19EAE6090](a2, 1, &v43, a1, 1, a3);
  }

  v12 = a4[2];
  v13 = a4[3];
  v15 = *a4;
  v14 = a4[1];
  if (a3 >= 1)
  {
    v40 = a4[2];
    v41 = a4[3];
    v38 = a4[1];
    v39 = *a4;
    bzero(a1 + 4 * v11, 4 * a3);
    v14 = v38;
    v15 = v39;
    v12 = v40;
    v13 = v41;
  }

LABEL_8:
  v16 = 0;
  v17 = vmulq_f32(v14, xmmword_19B0B3610);
  v18 = vmulq_f32(v15, xmmword_19B0B3620);
  v19 = vmulq_f32(v12, xmmword_19B0B3600);
  v20 = vmulq_f32(v13, xmmword_19B0B35F0);
  v21 = (a1 - 4);
  do
  {
    if (v16)
    {
      v22 = 0;
      v23 = 0.0;
      v24 = v21;
      do
      {
        v42[0] = v18;
        v42[1] = v17;
        v42[2] = v19;
        v42[3] = v20;
        v25 = *(v42 + (v22++ & 0xF));
        v26 = *v24--;
        v23 = v23 - (v25 * v26);
      }

      while (v16 != v22);
    }

    else
    {
      v23 = 0.0;
    }

    *(a1 + v16) = v23 + *(a1 + v16);
    ++v16;
    ++v21;
  }

  while (v16 != 16);
  if (a3 >= 9)
  {
    v27 = vrev64q_s32(v18);
    v28 = vextq_s8(v27, v27, 8uLL);
    v29 = vrev64q_s32(v17);
    v30 = vextq_s8(v29, v29, 8uLL);
    v31 = vrev64q_s32(v19);
    v32 = vextq_s8(v31, v31, 8uLL);
    v33 = vrev64q_s32(v20);
    v34 = vextq_s8(v33, v33, 8uLL);
    v35 = (2 * a3) - 16;
    v36 = (a1 + 64);
    do
    {
      v37 = vaddq_f32(vaddq_f32(vmulq_f32(v34, *(v36 - 16)), vmulq_f32(v30, *(v36 - 8))), vaddq_f32(vmulq_f32(v32, *(v36 - 12)), vmulq_f32(v28, *(v36 - 4))));
      *v36 = *v36 - vaddv_f32(vadd_f32(*v37.i8, *&vextq_s8(v37, v37, 8uLL)));
      ++v36;
      --v35;
    }

    while (v35);
  }
}

uint64_t d4t64_dec::D_ACELP_decode_4p_4N1(uint64_t result, unsigned __int16 a2, _WORD *a3)
{
  v3 = ((result >> 3) & 4) + a2;
  v4 = (result >> 2) & 3;
  v5 = v3 + v4;
  v6 = v3 + (result & 3);
  if ((result & 0x10) != 0)
  {
    v5 += 16;
    v7 = v6 + 16;
  }

  else
  {
    v7 = v6;
  }

  if ((result & 0x10) == 0)
  {
    v6 += 16;
  }

  if ((result & 3u) >= v4)
  {
    v6 = v7;
  }

  *a3 = v5;
  a3[1] = v6;
  v8 = (result >> 9) & 7;
  v9 = v8 + a2;
  v10 = (result >> 6) & 7;
  v11 = v10 + a2;
  if ((result & 0x1000) != 0)
  {
    v9 += 16;
    v12 = v11 + 16;
  }

  else
  {
    v12 = v10 + a2;
  }

  if ((result & 0x1000) == 0)
  {
    v11 += 16;
  }

  if (v10 >= v8)
  {
    v11 = v12;
  }

  a3[2] = v9;
  a3[3] = v11;
  return result;
}

uint64_t CConcealment_ApplyFadeOut(uint64_t result, uint64_t a2, int a3, uint64_t a4, int a5)
{
  v5 = *(a4 + 8);
  if (*(a2 + 52) == 3)
  {
    v6 = 1;
    v7 = a3 >> 2;
    if (a5 == 1)
    {
      v8 = 3;
    }

    else
    {
      v8 = 0;
    }

    if (a5 == 1)
    {
      v9 = 4;
    }

    else
    {
      v7 = a3;
      v9 = 1;
    }

    if (a5 == 2)
    {
      v10 = 1;
    }

    else
    {
      v10 = v8;
    }

    if (a5 == 2)
    {
      v11 = a3 >> 1;
    }

    else
    {
      v11 = v7;
    }

    *(a2 + 60) = 1;
    if (a5 == 2)
    {
      v12 = 2;
    }

    else
    {
      v12 = v9;
    }
  }

  else
  {
    *(a4 + 26) = *(a2 + 53);
    v13 = *(a2 + 56);
    *(a4 + 28) = v13;
    if (v13 == 2)
    {
      v11 = a3 >> 3;
      v6 = *(a2 + 60);
      v12 = 8;
      v10 = 8 - v6;
    }

    else
    {
      v10 = 0;
      v6 = *(a2 + 60);
      v12 = 1;
      v11 = a3;
    }
  }

  v14 = v12 / (v6 + 1);
  if (v14 <= 1)
  {
    v15 = 1;
  }

  else
  {
    v15 = v14;
  }

  if (v11 + v11 * v10 > a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int CConcealment_ApplyFadeOut(int, CConcealmentInfo *, CAacDecoderStaticChannelInfo *, const int, CAacDecoderChannelInfo *, UCHAR)";
    v32 = 1119;
    goto LABEL_61;
  }

  v34 = a2 + 36;
  v16 = *(a2 + 36 + 4 * result) + v10;
  if (v11 + v11 * v16 > 1024)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int CConcealment_ApplyFadeOut(int, CConcealmentInfo *, CAacDecoderStaticChannelInfo *, const int, CAacDecoderChannelInfo *, UCHAR)";
    v32 = 1120;
    goto LABEL_61;
  }

  v17 = 0;
  v33 = a2 + 44;
  v18 = *(a2 + 44 + 4 * result);
  v19 = *(a2 + 32);
  v20 = v11;
  v21 = v12;
  v39 = result;
  v38 = a2;
  v37 = v12;
  v36 = v10;
  v35 = v12;
  do
  {
    if (result == 1)
    {
      v22 = (*(a2 + 8) + 4 * v16 * v11);
      if (v19 > *(*a2 + 260))
      {
        bzero((*(a2 + 8) + 4 * v16 * v11), (4 * v11));
        v21 = v35;
        v20 = v11;
        v12 = v37;
        a2 = v38;
        v10 = v36;
        result = v39;
      }

      v23 = v5;
      v24 = v20;
      if (v11 >= 1)
      {
        do
        {
          v25 = *v22++;
          *v23++ = v25;
          --v24;
        }

        while (v24);
        v26 = *(a2 + 16);
        v27 = AacDec_randomSign[v26 >> 4] >> (v26 & 0xF);
        v28 = v26;
        while ((v28 & 0xF) != 0)
        {
          v27 = v27;
          if (v27)
          {
            goto LABEL_34;
          }

LABEL_35:
          v27 >>= 1;
          v28 = (v28 + 1) & 0x1FF;
          v24 += 4;
          if (4 * v11 == v24)
          {
            goto LABEL_40;
          }
        }

        v27 = AacDec_randomSign[v28 >> 4];
        if ((v27 & 1) == 0)
        {
          goto LABEL_35;
        }

LABEL_34:
        *(v5 + v24) = -*(v5 + v24);
        goto LABEL_35;
      }

      v26 = *(a2 + 16);
LABEL_40:
      *(a2 + 16) = (v26 + 1) & 0x1FF;
    }

    if (v18 + 1 < v15)
    {
      v29 = v19;
    }

    else
    {
      v29 = v19 + 1;
    }

    if (v18 + 1 < v15)
    {
      v30 = v18 + 1;
    }

    else
    {
      v30 = 0;
    }

    if (v16 + 1 < v12)
    {
      ++v16;
    }

    else
    {
      v19 = v29;
      v18 = v30;
      v16 = v10;
    }

    ++v17;
    v5 += v11;
  }

  while (v17 != v21);
  *(v34 + 4 * result) = v16 - v10;
  if ((v16 - v10) >= 8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int CConcealment_ApplyFadeOut(int, CConcealmentInfo *, CAacDecoderStaticChannelInfo *, const int, CAacDecoderChannelInfo *, UCHAR)";
    v32 = 1166;
    goto LABEL_61;
  }

  *(v33 + 4 * result) = v18;
  if (v18 < 0 || v18 >= v15)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "int CConcealment_ApplyFadeOut(int, CConcealmentInfo *, CAacDecoderStaticChannelInfo *, const int, CAacDecoderChannelInfo *, UCHAR)";
    v32 = 1168;
LABEL_61:
    exception[2] = v32;
  }

  if (!result)
  {
    *(a2 + 32) = v19;
  }

  return result;
}

uint64_t findEquiFadeFrame(uint64_t a1, unsigned int a2, int a3)
{
  if (a3)
  {
    if ((a2 & 0x80000000) != 0)
    {
      v3 = 1.0;
    }

    else
    {
      v3 = *(a1 + 4 * a2 + 128) * 0.5;
    }

    v4 = a1;
  }

  else
  {
    if ((a2 & 0x80000000) != 0)
    {
      v3 = 1.0;
    }

    else
    {
      v3 = *(a1 + 4 * a2) * 0.5;
    }

    v4 = a1 + 128;
  }

  v5 = 0;
  v6 = 0;
  v7 = 1.0;
  do
  {
    v8 = (*(v4 + 4 * v5) * 0.5) - v3;
    if (v8 <= 0.0)
    {
      v8 = -v8;
    }

    if (v8 < v7)
    {
      v7 = v8;
      v6 = v5;
    }

    ++v5;
  }

  while (v5 != 32);
  if (a3)
  {
    v10 = v6 < 31 && (*(v4 + 4 * v6) * 0.5) >= v3;
    return (v6 + v10);
  }

  else
  {
    v12 = *(a1 + 264);
    if (v12 <= 1)
    {
      v13 = 1;
    }

    else
    {
      v13 = *(a1 + 264);
    }

    v14 = v13 - 1;
    if (v6 > v12)
    {
      v6 = v14;
    }

    v16 = v6 > 0 && (*(v4 + 4 * v6) * 0.5) <= v3;
    return (v6 - v16);
  }
}

uint64_t sbrDecoder_Parse(uint64_t a1, int *a2, _DWORD *a3, int a4, unsigned int a5, int a6, int a7, uint64_t a8)
{
  v224 = *MEMORY[0x1E69E9840];
  v16 = a2[12];
  if (v16)
  {
    v17 = a2[1];
    if (v17)
    {
      CDK_put((a2 + 2), *a2, v17);
      v16 = a2[12];
    }
  }

  else
  {
    v18 = a2[1];
    v19 = a2[6];
    v20 = a2[5] - v18;
    a2[2] += v18;
    v21 = (a2[11] - 1) & (v19 - v18);
    a2[5] = v20;
    a2[6] = v21;
  }

  memcpy(__dst, &unk_19B3C6378, sizeof(__dst));
  memcpy(v222, &unk_19B3C6378, sizeof(v222));
  *a2 = 0;
  v220 = a2[2];
  if (a1)
  {
    v22 = *(a8 + 4 * a6);
    if (!v16)
    {
      a2[6] &= a2[11] - 1;
    }

    *a2 = 0;
    v219 = a6;
    v23 = *(a1 + 8 * a6);
    if (v23)
    {
      if (*(v23 + 113))
      {
        v24 = *(v23 + 113) - 1;
      }

      else
      {
        v24 = *(a1 + 532);
      }

      v212 = a4;
      v215 = *(v23 + v24 + 114);
      v214 = *(v23 + 113);
      v211 = *v23;
      v27 = (*v23 + 1944 * *(v23 + 113));
      v216 = *(v23 + 26);
      v218 = v27;
      if (v216 == 1)
      {
        v28 = v23[1];
        CDKmemcpy(__dst, v27, 0x798uLL);
        v29 = v28 + 1944 * v214;
        CDKmemcpy(v222, v29, 0x798uLL);
      }

      else
      {
        CDKmemcpy(__dst, v27, 0x798uLL);
        v29 = 0;
      }

      v30 = v218;
      *(a1 + 536) &= ~0x40u;
      if ((*(a1 + 240 * v219 + 20) & 2) != 0)
      {
        *(a1 + 240 * v219 + 20) &= ~2u;
        v217 = 2;
      }

      else
      {
        v217 = 0;
      }

      if (a5 > 1 || *(v23 + 26) != a5)
      {
        goto LABEL_348;
      }

      v31 = a2[1];
      v213 = (a1 + 240 * v219 + 16);
      if (a2[12])
      {
        if (v31)
        {
          CDK_put((a2 + 2), *a2, v31);
        }
      }

      else
      {
        v32 = a2[6];
        v33 = a2[5] - v31;
        a2[2] += v31;
        v34 = (a2[11] - 1) & (v32 - v31);
        a2[5] = v33;
        a2[6] = v34;
      }

      *a2 = 0;
      if (a2[2] < 1)
      {
        goto LABEL_348;
      }

      v35 = *(a1 + 536);
      v210 = v29;
      if ((v35 & 0xC) == 0)
      {
        v44 = CDK_get32((a2 + 2));
        v45 = a1 + 240 * v219 + 16;
        v46 = v44 >> 31;
        *a2 = v44;
        a2[1] = 31;
        goto LABEL_68;
      }

      v36 = v35 & 0xFFFFFBFF | (((v22 >> 2) & 1) << 10);
      if ((a7 & 0x100000) != 0)
      {
        v37 = 0;
        *(a1 + 536) = v36 | 0x10;
      }

      else
      {
        *(a1 + 536) = v36 & 0xFFFFFFEF;
        if (!CDKreadBit(a2))
        {
          v67 = 0;
          v54 = 1;
          goto LABEL_91;
        }

        v37 = CDKreadBit(a2) == 0;
        v38 = a2[1];
        if (v38)
        {
          v39 = v38 - 1;
          v40 = *a2;
          a2[1] = v38 - 1;
          LOBYTE(v221) = (v40 >> (v38 - 1)) & 1;
          v41 = 5 - v38;
          if (v41 <= 0)
          {
            v43 = 0;
          }

          else
          {
            v42 = v40 << v41;
            if (v39 == -28)
            {
              v43 = 0;
            }

            else
            {
              v43 = v42;
            }

            v40 = CDK_get32((a2 + 2));
            *a2 = v40;
            v39 = a2[1] + 32;
          }

          goto LABEL_40;
        }
      }

      v40 = CDK_get32((a2 + 2));
      v43 = 0;
      *a2 = v40;
      LOBYTE(v221) = (v40 & 0x80000000) != 0;
      v39 = 31;
LABEL_40:
      a2[1] = v39 - 4;
      v47 = (v40 >> (v39 - 4)) | v43;
      v48 = v47 & 0xF;
      BYTE1(v221) = v47 & 0xF;
      if (v39 == 4)
      {
        v51 = CDK_get32((a2 + 2));
        *a2 = v51;
        v50 = v51 >> 31;
        v49 = 31;
      }

      else
      {
        v49 = v39 - 5;
        v50 = (v40 >> v49) & 1;
      }

      a2[1] = v49;
      BYTE2(v221) = v50;
      if ((v22 & 8) != 0)
      {
        v53 = CDKreadBits(a2, 2);
        if (v216 == 1)
        {
          v52 = 0;
        }

        else
        {
          v52 = v53;
        }

        HIBYTE(v221) = v52;
        v45 = a1 + 240 * v219 + 16;
        if (v53 > 2u)
        {
          v54 = 0;
          v217 = 1;
          *v213 = 1;
          v29 = v210;
          goto LABEL_70;
        }
      }

      else
      {
        v52 = 0;
        HIBYTE(v221) = 0;
        v45 = a1 + 240 * v219 + 16;
      }

      if (*(v45 + 34) == v221)
      {
        v217 = 2;
        v29 = v210;
      }

      else
      {
        if (*(v45 + 37) == v52)
        {
          if (*(v45 + 35) == v48)
          {
            v55 = 2;
          }

          else
          {
            v55 = 3;
          }
        }

        else
        {
          v55 = 3;
        }

        v217 = v55;
        v29 = v210;
        *(v45 + 34) = v221;
      }

      if (v37)
      {
        goto LABEL_59;
      }

      if (CDKreadBit(a2))
      {
        v45 = a1 + 240 * v219 + 16;
        v56 = *(a1 + 240 * v219 + 32) == *(a1 + 240 * v219 + 41) && *(a1 + 240 * v219 + 40) == *(a1 + 240 * v219 + 49);
        if (!v56 || *v213 != 3)
        {
          v46 = 0;
          *(a1 + 240 * v219 + 32) = *(a1 + 240 * v219 + 41);
          *(a1 + 240 * v219 + 40) = *(a1 + 240 * v219 + 49);
          v217 = 3;
LABEL_68:
          v54 = 1;
          if (!v46)
          {
            goto LABEL_70;
          }

          goto LABEL_69;
        }

LABEL_59:
        v46 = 0;
        goto LABEL_68;
      }

      v54 = 1;
      v67 = 1;
LABEL_91:
      v45 = a1 + 240 * v219 + 16;
      if (!v67)
      {
LABEL_70:
        if (v217 == 3)
        {
          v58 = v45;
          if (resetFreqBandTables(v45, *(a1 + 536)))
          {
            *v58 = 0;
            v217 = 1;
LABEL_348:
            v188 = *(a1 + 8 * v219);
            if (v188)
            {
              *(v188 + *(v188 + 113) + 112) = 1;
            }

            CDKmemcpy(v30, __dst, 0x798uLL);
            if (v216 == 1)
            {
              CDKmemcpy(v29, v222, 0x798uLL);
              v26 = 5;
              goto LABEL_354;
            }

            v26 = 5;
            goto LABEL_353;
          }

          *(v58 + 4) |= 1u;
          *v58 = 2;
          v59 = 1;
          v45 = v58;
          if (!v54)
          {
            goto LABEL_81;
          }
        }

        else
        {
          v59 = *v45 > 1;
          if (!v54)
          {
            goto LABEL_81;
          }
        }

        if (v59)
        {
          v60 = *v23;
          v205 = *(*v23 + 13657);
          v61 = *(a1 + 536);
          v62 = *(*(a1 + 8 * v219) + 88);
          v209 = v61;
          if (v29)
          {
            v63 = a2[1];
            if (1 - v63 <= 0)
            {
              v64 = 0;
              v68 = *a2;
            }

            else
            {
              if (v63 == -31)
              {
                v64 = 0;
              }

              else
              {
                v64 = *a2 << (1 - v63);
              }

              v68 = CDK_get32((a2 + 2));
              *a2 = v68;
              v63 = a2[1] + 32;
              v45 = a1 + 240 * v219 + 16;
            }

            v69 = v63 - 1;
            a2[1] = v69;
            if (((v68 >> v69) | v64))
            {
              v66 = 0;
              *(v218 + 64) = 1;
              *(v29 + 64) = 2;
            }

            else
            {
              *(v218 + 64) = 0;
              *(v29 + 64) = 0;
              v66 = 1;
            }

            LOWORD(v61) = v209;
          }

          else
          {
            *(v218 + 64) = 0;
            v66 = 1;
          }

          if ((v61 & 0xC) == 0)
          {
LABEL_149:
            v81 = (v45 + 37);
            if (*(v45 + 37))
            {
              if (v29)
              {
                exception = __cxa_allocate_exception(0x10uLL);
                *exception = "int sbrGetChannelElement(HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_SBR_PREV_FRAME_DATA, UCHAR, HANDLE_CDK_BITSTREAM, const UINT, const int)";
                exception[2] = 498;
              }

              v73 = a2[1];
              goto LABEL_152;
            }

            goto LABEL_155;
          }

          if ((v61 & 0x100) == 0)
          {
            if (v29)
            {
              *(v29 + 1939) = 1;
              *(v29 + 1941) = 0;
            }

            LOBYTE(v70) = 0;
            *(v218 + 1939) = 1;
            v71 = v218;
            goto LABEL_148;
          }

          v72 = a2[1];
          if (v72)
          {
            v73 = v72 - 1;
            v74 = *a2;
            v75 = *a2 >> (v72 - 1);
            a2[1] = v72 - 1;
            *(v218 + 1939) = v75 & 1;
            if ((v75 & 1) == 0)
            {
              if (v72 == 1)
              {
                v74 = CDK_get32((a2 + 2));
                v45 = a1 + 240 * v219 + 16;
                *a2 = v74;
                *(v218 + 1940) = (v74 & 0x80000000) != 0;
                v76 = 31;
              }

              else
              {
                v76 = v72 - 2;
                a2[1] = v72 - 2;
                *(v218 + 1940) = (v74 >> (v72 - 2)) & 1;
                if (v72 == 2)
                {
                  v74 = CDK_get32((a2 + 2));
                  v45 = a1 + 240 * v219 + 16;
                  *a2 = v74;
                  v70 = v74 >> 31;
                  v73 = 31;
                  goto LABEL_116;
                }
              }

LABEL_115:
              v73 = v76 - 1;
              v70 = (v74 >> v73) & 1;
LABEL_116:
              a2[1] = v73;
              if (v70)
              {
                if (7 - v73 < 1)
                {
                  v77 = 0;
                }

                else
                {
                  if (v73 == -25)
                  {
                    v77 = 0;
                  }

                  else
                  {
                    v77 = v74 << (7 - v73);
                  }

                  v74 = CDK_get32((a2 + 2));
                  v45 = a1 + 240 * v219 + 16;
                  *a2 = v74;
                  v73 = a2[1] + 32;
                }

                v73 -= 7;
                a2[1] = v73;
                LOBYTE(v70) = ((v74 >> v73) | v77) & 0x7F;
                v29 = v210;
              }

LABEL_124:
              *(v218 + 1941) = v70;
              if (!v29)
              {
                v81 = (v45 + 37);
                if (*(v45 + 37))
                {
LABEL_152:
                  v202 = v60;
                  v84 = v62;
                  v85 = v81;
                  if (4 - v73 <= 0)
                  {
                    v86 = 0;
                    v89 = *a2;
                  }

                  else
                  {
                    if (v73 == -28)
                    {
                      v86 = 0;
                    }

                    else
                    {
                      v86 = *a2 << (4 - v73);
                    }

                    v89 = CDK_get32((a2 + 2));
                    *a2 = v89;
                    v73 = a2[1] + 32;
                    v45 = a1 + 240 * v219 + 16;
                  }

                  a2[1] = v73 - 4;
                  v90 = ((v89 >> (v73 - 4)) | v86) & 0xF;
                  if (v73 == 4)
                  {
                    v93 = CDK_get32((a2 + 2));
                    v45 = a1 + 240 * v219 + 16;
                    *a2 = v93;
                    v92 = v93 >> 31;
                    v91 = 31;
                  }

                  else
                  {
                    v91 = v73 - 5;
                    v92 = (v89 >> (v73 - 5)) & 1;
                  }

                  a2[1] = v91;
                  *(v218 + 31) = v90;
                  *(v218 + 23) = 511;
                  *(v218 + 5) = 1;
                  *(v218 + 15) = 0;
                  if (v92)
                  {
                    v94 = a2[1];
                    if (2 - v94 <= 0)
                    {
                      LOBYTE(v95) = 0;
                      v97 = *a2;
                    }

                    else
                    {
                      if (v94 == -30)
                      {
                        LOBYTE(v95) = 0;
                      }

                      else
                      {
                        v95 = *a2 << (2 - v94);
                      }

                      v97 = CDK_get32((a2 + 2));
                      *a2 = v97;
                      v94 = a2[1] + 32;
                      v45 = a1 + 240 * v219 + 16;
                    }

                    v98 = v94 - 2;
                    a2[1] = v98;
                    v99 = ((v97 >> v98) | v95) & 3;
                    v96 = v99 + 1;
                    *(v218 + 32) = v99 + 1;
                    v29 = v210;
                    if (v99 == 3)
                    {
                      *(v218 + 32) = 0;
                      goto LABEL_348;
                    }
                  }

                  else
                  {
                    v96 = 0;
                    *(v218 + 32) = 0;
                  }

                  if (v90)
                  {
                    *(v218 + 5) = 2;
                    *(v218 + 24) = 2;
                    *(v218 + 15) = 0;
                  }

                  v81 = v85;
                  v100 = *v85;
                  v62 = v84;
                  if (v100)
                  {
                    v101 = *(v218 + 5);
                    if (v101 - 1 >= 2)
                    {
                      v198 = __cxa_allocate_exception(0x10uLL);
                      *v198 = "int extractPvcFrameInfo(HANDLE_CDK_BITSTREAM, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_SBR_PREV_FRAME_DATA, UCHAR, const UINT)";
                      v198[2] = 983;
                    }

                    if (*(v202 + 2217))
                    {
                      v102 = (*(v202 + *(v202 + 2217) + 2218) - 16);
                      *(v218 + 6) = *(v202 + *(v202 + 2217) + 2218) - 16;
                      if (v102 >= 4)
                      {
                        v103 = __cxa_allocate_exception(0x10uLL);
                        *v103 = "int extractPvcFrameInfo(HANDLE_CDK_BITSTREAM, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_SBR_PREV_FRAME_DATA, UCHAR, const UINT)";
                        v103[2] = 988;
                      }
                    }

                    else
                    {
                      *(v218 + 6) = 0;
                    }

                    *(v218 + 6 + v101) = v96 | 0x10;
                    if (v101 == 2)
                    {
                      *(v218 + 7) = *(v218 + 31);
                    }

                    if (v205)
                    {
                      v104 = 0;
                    }

                    else
                    {
                      v104 = *(v218 + 6);
                    }

                    *(v218 + 28) = v104;
                    if (v101 == 2)
                    {
                      *(v218 + 29) = *(v218 + 7);
                    }

                    *(v218 + 28 + v101) = 16;
                    v105 = (v218 + 25);
                    v106 = *(v218 + 24) + 1;
                    do
                    {
                      *v105 = *(v105 - 19);
                      ++v105;
                      --v106;
                    }

                    while (v106);
                    *(v218 + 23) = -1;
                  }

                  v87 = *(v45 + 6);
                  v88 = *(v45 + 8);
                  goto LABEL_192;
                }

LABEL_155:
                if (!extractFrameInfo(a2, *(v45 + 6), v218))
                {
                  goto LABEL_347;
                }

                v87 = *(a1 + 240 * v219 + 22);
                v88 = *(a1 + 240 * v219 + 24);
                v30 = v218;
LABEL_192:
                if (!checkFrameInfo(v30 + 4, v87, v62, v88))
                {
                  goto LABEL_348;
                }

                if (v29)
                {
                  if (*(v30 + 64))
                  {
                    CDKmemcpy((v29 + 4), (v30 + 4), 0x1DuLL);
                    v30 = v218;
                    *(v29 + 68) = *(v218 + 68);
                  }

                  else
                  {
                    if (!extractFrameInfo(a2, v87, v29))
                    {
                      goto LABEL_347;
                    }

                    v30 = v218;
                    if (!checkFrameInfo(v29 + 4, *(a1 + 240 * v219 + 22), v62, *(a1 + 240 * v219 + 24)))
                    {
                      goto LABEL_348;
                    }
                  }

                  v206 = v81;
                  sbrGetDirectionControlData(v30, a2, v209, *v81);
                  v107 = v29;
                  v108 = a2;
                  v109 = v209;
                  v110 = 0;
                }

                else
                {
                  v206 = v81;
                  v110 = *v81;
                  v107 = v30;
                  v108 = a2;
                  v109 = v209;
                }

                sbrGetDirectionControlData(v107, v108, v109, v110);
                v111 = a1 + 240 * v219 + 16;
                LODWORD(v112) = *(a1 + 240 * v219 + 77);
                if (*(a1 + 240 * v219 + 77))
                {
                  v113 = 0;
                  v114 = a2[1];
                  do
                  {
                    if (2 - v114 <= 0)
                    {
                      LOBYTE(v115) = 0;
                      v116 = *a2;
                    }

                    else
                    {
                      if (v114 == -30)
                      {
                        LOBYTE(v115) = 0;
                      }

                      else
                      {
                        v115 = *a2 << (2 - v114);
                      }

                      v116 = CDK_get32((a2 + 2));
                      *a2 = v116;
                      v114 = a2[1] + 32;
                      v111 = a1 + 240 * v219 + 16;
                      LODWORD(v112) = *(a1 + 240 * v219 + 77);
                    }

                    v114 -= 2;
                    a2[1] = v114;
                    *(v30 + 44 + 4 * v113++) = ((v116 >> v114) | v115) & 3;
                  }

                  while (v113 < v112);
                }

                v29 = v210;
                if (!v210)
                {
                  v120 = *v206;
                  if (*v206)
                  {
                    v121 = a2[1];
                    if (3 - v121 <= 0)
                    {
                      LOBYTE(v122) = 0;
                      v132 = *a2;
                    }

                    else
                    {
                      if (v121 == -29)
                      {
                        LOBYTE(v122) = 0;
                      }

                      else
                      {
                        v122 = *a2 << (3 - v121);
                      }

                      v132 = CDK_get32((a2 + 2));
                      *a2 = v132;
                      v121 = a2[1] + 32;
                      v111 = a1 + 240 * v219 + 16;
                    }

                    v133 = v121 - 3;
                    a2[1] = v121 - 3;
                    if (v121 == 3)
                    {
                      v136 = CDK_get32((a2 + 2));
                      v111 = a1 + 240 * v219 + 16;
                      *a2 = v136;
                      v135 = v136 >> 31;
                      v134 = 31;
                    }

                    else
                    {
                      v134 = v121 - 4;
                      v135 = (v132 >> v134) & 1;
                      v136 = v132;
                    }

                    a2[1] = v134;
                    if (v120 >= 3)
                    {
                      v199 = __cxa_allocate_exception(0x10uLL);
                      *v199 = "int sbrGetPvcEnvelope(HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_CDK_BITSTREAM, const UINT, const UINT)";
                      v199[2] = 725;
                    }

                    v137 = ((v132 >> v133) | v122) & 7;
                    v138 = (v30 + 1921);
                    *(v30 + 1937) = mapNsMode2ns[2 * v120 - 2 + v135];
                    if (v137 > 3)
                    {
                      v140 = v137 - 4;
                      v141 = 8u >> (v137 - 4);
                      if (v141 << (v137 - 3) != 16)
                      {
                        v200 = __cxa_allocate_exception(0x10uLL);
                        *v200 = "int sbrGetPvcEnvelope(HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_CDK_BITSTREAM, const UINT, const UINT)";
                        v200[2] = 774;
                      }

                      v203 = 8u >> (v137 - 4);
                      if ((v209 & 0x10) != 0 || (!v134 ? (v136 = CDK_get32((a2 + 2)), v111 = a1 + 240 * v219 + 16, *a2 = v136, v142 = v136 >> 31, v134 = 31) : (--v134, v142 = (v136 >> v134) & 1), a2[1] = v134, v142))
                      {
                        if (7 - v134 < 1)
                        {
                          v165 = 0;
                        }

                        else
                        {
                          if (v134 == -25)
                          {
                            v165 = 0;
                          }

                          else
                          {
                            v165 = v136 << (7 - v134);
                          }

                          v136 = CDK_get32((a2 + 2));
                          v111 = a1 + 240 * v219 + 16;
                          *a2 = v136;
                          v134 = a2[1] + 32;
                        }

                        v166 = v134 - 7;
                        a2[1] = v166;
                        v167 = ((v136 >> v166) | v165) & 0x7F;
                        v141 = 8u >> (v137 - 4);
                      }

                      else
                      {
                        LOBYTE(v167) = *(v111 + 232);
                      }

                      *v138 = v167;
                      v208 = v141 - 1;
                      if (v141 == 1)
                      {
                        LODWORD(v169) = 1;
                        v29 = 0;
                      }

                      else
                      {
                        v29 = 0;
                        v168 = (v211 + 1944 * v214 + 1922);
                        LODWORD(v169) = 1;
                        do
                        {
                          *v168++ = v167;
                          LODWORD(v169) = v169 + 1;
                        }

                        while (v141 != v169);
                      }

                      v170 = (2 << v140) - 1;
                      do
                      {
                        v171 = a2[1];
                        if (v171)
                        {
                          v172 = v171 - 1;
                          v173 = *a2;
                          v174 = (*a2 >> v172) & 1;
                        }

                        else
                        {
                          v173 = CDK_get32((a2 + 2));
                          v111 = a1 + 240 * v219 + 16;
                          *a2 = v173;
                          v174 = v173 >> 31;
                          v172 = 31;
                        }

                        a2[1] = v172;
                        if (v174)
                        {
                          if (7 - v172 < 1)
                          {
                            v175 = 0;
                          }

                          else
                          {
                            if (v172 == -25)
                            {
                              v175 = 0;
                            }

                            else
                            {
                              v175 = v173 << (7 - v172);
                            }

                            v173 = CDK_get32((a2 + 2));
                            v111 = a1 + 240 * v219 + 16;
                            *a2 = v173;
                            v172 = a2[1] + 32;
                          }

                          v177 = v172 - 7;
                          a2[1] = v177;
                          v138[v169] = ((v173 >> v177) | v175) & 0x7F;
                          v176 = v208;
                          LODWORD(v169) = v169 + 1;
                          v29 = 0;
                        }

                        else
                        {
                          v176 = v203;
                        }

                        if (v176)
                        {
                          v178 = *(v218 + 1920 + v169);
                          v169 = v169;
                          do
                          {
                            v138[v169++] = v178;
                            --v176;
                          }

                          while (v176);
                        }

                        --v170;
                      }

                      while (v170);
                    }

                    else
                    {
                      if ((v209 & 0x10) != 0 || (!v134 ? (v136 = CDK_get32((a2 + 2)), v111 = a1 + 240 * v219 + 16, *a2 = v136, v139 = v136 >> 31, v134 = 31) : (--v134, v139 = (v136 >> v134) & 1), a2[1] = v134, !v139))
                      {
                        if (7 - v134 < 1)
                        {
                          v144 = 0;
                        }

                        else
                        {
                          if (v134 == -25)
                          {
                            v144 = 0;
                          }

                          else
                          {
                            v144 = v136 << (7 - v134);
                          }

                          v136 = CDK_get32((a2 + 2));
                          v111 = a1 + 240 * v219 + 16;
                          *a2 = v136;
                          v134 = a2[1] + 32;
                        }

                        v145 = v134 - 7;
                        a2[1] = v145;
                        v143 = ((v136 >> v145) | v144) & 0x7F;
                      }

                      else
                      {
                        v143 = *(v111 + 232);
                      }

                      *v138 = v143;
                      if (v137)
                      {
                        v201 = v137;
                        v146 = 0;
                        v147 = 0;
                        v148 = 1;
                        do
                        {
                          if (v146 > 6)
                          {
                            v149 = 3;
                          }

                          else
                          {
                            v149 = 4;
                          }

                          if (v146 > 10)
                          {
                            v149 = 2;
                          }

                          if (v146 <= 12)
                          {
                            v150 = v149;
                          }

                          else
                          {
                            v150 = 1;
                          }

                          v151 = a2[1];
                          v152 = v150 - v151;
                          v207 = v147;
                          if (v150 - v151 <= 0)
                          {
                            v153 = 0;
                            v154 = *a2;
                          }

                          else
                          {
                            if (v152 == 32)
                            {
                              v204 = 0;
                            }

                            else
                            {
                              v204 = *a2 << v152;
                            }

                            v154 = CDK_get32((a2 + 2));
                            *a2 = v154;
                            v151 = a2[1] + 32;
                            v111 = a1 + 240 * v219 + 16;
                            v153 = v204;
                          }

                          v155 = v151 - v150;
                          a2[1] = v155;
                          v156 = ((v154 >> v155) | v153) & BitMask[v150];
                          v146 += v156 + 1;
                          if (v146 > 15)
                          {
                            v29 = 0;
                            goto LABEL_348;
                          }

                          if (v156)
                          {
                            v157 = v148;
                            v158 = *(v30 + 1920 + v148);
                            do
                            {
                              v138[v157++] = v158;
                              --v156;
                            }

                            while (v156);
                            v155 = a2[1];
                          }

                          else
                          {
                            LODWORD(v157) = v148;
                          }

                          if (7 - v155 <= 0)
                          {
                            LOBYTE(v159) = 0;
                            v160 = *a2;
                          }

                          else
                          {
                            if (v155 == -25)
                            {
                              LOBYTE(v159) = 0;
                            }

                            else
                            {
                              v159 = *a2 << (7 - v155);
                            }

                            v160 = CDK_get32((a2 + 2));
                            *a2 = v160;
                            v155 = a2[1] + 32;
                            v111 = a1 + 240 * v219 + 16;
                          }

                          v161 = v155 - 7;
                          a2[1] = v161;
                          v138[v157] = ((v160 >> v161) | v159) & 0x7F;
                          v148 = v157 + 1;
                          v147 = v207 + 1;
                        }

                        while (v207 + 1 != v201);
                        v162 = v157 <= 14;
                        v29 = 0;
                        if (v162)
                        {
                          goto LABEL_296;
                        }
                      }

                      else
                      {
                        v148 = 1;
                        v29 = 0;
LABEL_296:
                        v163 = v148 + 1;
                        v164 = v211 + 1944 * v214 + v148;
                        do
                        {
                          *(v164 + 1921) = *(v164 + 1920);
                          ++v164;
                          v56 = v163++ == 16;
                        }

                        while (!v56);
                      }
                    }

                    v30 = v218;
                    *(v111 + 232) = *(v218 + 1936);
                    *(v218 + 1912) = 0;
                  }

                  else
                  {
                    Envelope = sbrGetEnvelope(v111, v30, a2, v209);
                    v30 = v218;
                    v111 = a1 + 240 * v219 + 16;
                    if (!Envelope)
                    {
                      goto LABEL_348;
                    }
                  }

                  v127 = v111;
                  sbrGetNoiseFloorData(v111, v30, a2);
                  v130 = v30;
                  v129 = v209;
LABEL_334:
                  sbrGetSyntheticCodedData(v127, v130, a2, v129);
                  v179 = a2[12];
                  v180 = a2[1];
                  if (v212 < 1)
                  {
                    if (v179)
                    {
                      if (v180)
                      {
                        CDK_put((a2 + 2), *a2, v180);
                      }
                    }

                    else
                    {
                      v185 = a2[6];
                      v186 = a2[5] - v180;
                      a2[2] += v180;
                      v187 = (a2[11] - 1) & (v185 - v180);
                      a2[5] = v186;
                      a2[6] = v187;
                    }

                    *a2 = 0;
                    v184 = a2[2];
                  }

                  else
                  {
                    if (v179)
                    {
                      if (v180)
                      {
                        CDK_put((a2 + 2), *a2, v180);
                      }
                    }

                    else
                    {
                      v181 = a2[6];
                      v182 = a2[5] - v180;
                      a2[2] += v180;
                      v183 = (a2[11] - 1) & (v181 - v180);
                      a2[5] = v182;
                      a2[6] = v183;
                    }

                    *a2 = 0;
                    v184 = v212 - v220 + a2[2];
                  }

                  if ((v184 & 0x80000000) == 0)
                  {
                    v26 = 0;
                    goto LABEL_83;
                  }

LABEL_347:
                  v30 = v218;
                  goto LABEL_348;
                }

                if (*(v30 + 64))
                {
                  if (v112)
                  {
                    v117 = (v30 + 44);
                    v118 = (v210 + 44);
                    v112 = v112;
                    do
                    {
                      v119 = *v117++;
                      *v118++ = v119;
                      --v112;
                    }

                    while (v112);
                  }
                }

                else
                {
                  if (!v112)
                  {
                    goto LABEL_373;
                  }

                  v123 = 0;
                  v124 = a2[1];
                  do
                  {
                    if (2 - v124 <= 0)
                    {
                      LOBYTE(v125) = 0;
                      v126 = *a2;
                    }

                    else
                    {
                      if (v124 == -30)
                      {
                        LOBYTE(v125) = 0;
                      }

                      else
                      {
                        v125 = *a2 << (2 - v124);
                      }

                      v126 = CDK_get32((a2 + 2));
                      *a2 = v126;
                      v124 = a2[1] + 32;
                      v111 = a1 + 240 * v219 + 16;
                      LODWORD(v112) = *(a1 + 240 * v219 + 77);
                    }

                    v124 -= 2;
                    a2[1] = v124;
                    *(v210 + 44 + 4 * v123++) = ((v126 >> v124) | v125) & 3;
                    v29 = v210;
                  }

                  while (v123 < v112);
                  v30 = v218;
                  if (!*(v218 + 64))
                  {
LABEL_373:
                    if (!sbrGetEnvelope(v111, v30, a2, v209) || !sbrGetEnvelope(v213, v29, a2, v209))
                    {
                      goto LABEL_347;
                    }

                    v30 = v218;
                    sbrGetNoiseFloorData(v213, v218, a2);
LABEL_236:
                    v127 = a1 + 240 * v219 + 16;
                    sbrGetNoiseFloorData(v213, v29, a2);
                    v128 = v30;
                    v129 = v209;
                    sbrGetSyntheticCodedData(v213, v128, a2, v209);
                    v130 = v29;
                    goto LABEL_334;
                  }
                }

                if (!sbrGetEnvelope(v111, v30, a2, v209))
                {
                  goto LABEL_347;
                }

                sbrGetNoiseFloorData(v213, v218, a2);
                v30 = v218;
                if (!sbrGetEnvelope(v213, v29, a2, v209))
                {
                  goto LABEL_348;
                }

                goto LABEL_236;
              }

              if (v66)
              {
                if (v73)
                {
                  v78 = v74 >> (v73 - 1);
                  a2[1] = v73 - 1;
                  *(v29 + 1939) = v78 & 1;
                  if ((v78 & 1) == 0)
                  {
                    if (v73 == 1)
                    {
                      v74 = CDK_get32((a2 + 2));
                      v45 = a1 + 240 * v219 + 16;
                      *a2 = v74;
                      *(v29 + 1940) = (v74 & 0x80000000) != 0;
                      v79 = 31;
                    }

                    else
                    {
                      v79 = v73 - 2;
                      a2[1] = v79;
                      *(v29 + 1940) = (v74 >> v79) & 1;
                      if (!v79)
                      {
                        v74 = CDK_get32((a2 + 2));
                        v45 = a1 + 240 * v219 + 16;
                        *a2 = v74;
                        v70 = v74 >> 31;
                        v80 = 31;
                        goto LABEL_139;
                      }
                    }

LABEL_138:
                    v80 = v79 - 1;
                    v70 = (v74 >> v80) & 1;
LABEL_139:
                    a2[1] = v80;
                    if (v70)
                    {
                      if (7 - v80 < 1)
                      {
                        v82 = 0;
                      }

                      else
                      {
                        if (v80 == -25)
                        {
                          v82 = 0;
                        }

                        else
                        {
                          v82 = v74 << (7 - v80);
                        }

                        v74 = CDK_get32((a2 + 2));
                        v45 = a1 + 240 * v219 + 16;
                        *a2 = v74;
                        v80 = a2[1] + 32;
                      }

                      v83 = v80 - 7;
                      a2[1] = v83;
                      v70 = ((v74 >> v83) | v82) & 0x7F;
                    }

                    goto LABEL_147;
                  }
                }

                else
                {
                  v74 = CDK_get32((a2 + 2));
                  v45 = a1 + 240 * v219 + 16;
                  *a2 = v74;
                  a2[1] = 31;
                  *(v29 + 1939) = (v74 & 0x80000000) != 0;
                  if ((v74 & 0x80000000) == 0)
                  {
                    *(v29 + 1940) = v74 >> 30;
                    v79 = 30;
                    goto LABEL_138;
                  }
                }

                LOBYTE(v70) = 0;
                *(v29 + 1940) = 0;
              }

              else
              {
                *(v29 + 1939) = *(v218 + 1939);
              }

LABEL_147:
              v71 = v29;
LABEL_148:
              *(v71 + 1941) = v70;
              goto LABEL_149;
            }
          }

          else
          {
            v74 = CDK_get32((a2 + 2));
            v73 = 31;
            *a2 = v74;
            a2[1] = 31;
            *(v218 + 1939) = (v74 & 0x80000000) != 0;
            if ((v74 & 0x80000000) == 0)
            {
              *(v218 + 1940) = v74 >> 30;
              v76 = 30;
              v45 = a1 + 240 * v219 + 16;
              goto LABEL_115;
            }

            v45 = a1 + 240 * v219 + 16;
          }

          LOBYTE(v70) = 0;
          *(v218 + 1940) = 0;
          goto LABEL_124;
        }

LABEL_81:
        if (!v54)
        {
          goto LABEL_348;
        }

        v26 = 5;
LABEL_83:
        v65 = *(a1 + 8 * v219);
        if (v65)
        {
          *(v65 + *(v65 + 113) + 112) = 0;
        }

        if (v216 == 1)
        {
LABEL_354:
          v190 = (v26 != 5 || v217 != 3) && v217 >= 2;
          v191 = v215;
          if (v190)
          {
            v191 = 0;
          }

          v192 = *(v23 + 113);
          *(v23 + *(v23 + 113) + 114) = v191;
          *(v23 + 113) = (v192 + 1) % (*(a1 + 532) + 1);
          v25 = a2[1];
          if (!a2[12])
          {
            goto LABEL_364;
          }

          goto LABEL_12;
        }

LABEL_353:
        *(v218 + 64) = 0;
        goto LABEL_354;
      }

LABEL_69:
      HeaderData = sbrGetHeaderData(v45, a2, *(a1 + 536), 1, 0);
      v45 = a1 + 240 * v219 + 16;
      v217 = HeaderData;
      goto LABEL_70;
    }
  }

  v25 = 0;
  v26 = 3;
  if (!v16)
  {
LABEL_364:
    v193 = a2[6];
    v194 = a2[5] - v25;
    a2[2] += v25;
    v195 = (a2[11] - 1) & (v193 - v25);
    a2[5] = v194;
    a2[6] = v195;
    goto LABEL_365;
  }

LABEL_12:
  if (v25)
  {
    CDK_put((a2 + 2), *a2, v25);
  }

LABEL_365:
  *a2 = 0;
  *a3 += a2[2] - v220;
  return v26;
}

int *CDKpushBack(int *result)
{
  v1 = result;
  v2 = result[1];
  v3 = v2 + 4;
  v4 = result[12];
  if ((v2 + 4) > 0x1F)
  {
    if (!v4)
    {
      v8 = result[6];
      v9 = result[5] - v2;
      result[2] += v2;
      v10 = (result[11] - 1) & (v8 - v2);
      result[5] = v9;
      result[6] = v10;
      goto LABEL_9;
    }

    goto LABEL_6;
  }

  if (!v4)
  {
    v5 = result[6];
    v6 = result[5] - v3;
    result[2] += v3;
    v7 = (result[11] - 1) & (v5 - v3);
    result[5] = v6;
    result[6] = v7;
    *result = 0;
    return result;
  }

  if (v2)
  {
LABEL_6:
    result = CDK_put((result + 2), *result, v2);
    LOBYTE(v4) = *(v1 + 48);
  }

LABEL_9:
  if (v4)
  {
    v11 = -4;
  }

  else
  {
    v11 = 4;
  }

  v1[2] += v11;
  v12 = v1[5];
  v13 = (v1[11] - 1) & (v1[6] - 4);
  *v1 = 0;
  v1[5] = v12 - 4;
  v1[6] = v13;
  return result;
}

uint64_t CDKreadBit(unsigned int *a1)
{
  v2 = a1[1];
  if (v2)
  {
    v3 = v2 - 1;
    result = (*a1 >> v3) & 1;
  }

  else
  {
    v5 = CDK_get32((a1 + 2));
    *a1 = v5;
    result = v5 >> 31;
    v3 = 31;
  }

  a1[1] = v3;
  return result;
}

uint64_t checkFrameInfo(uint64_t a1, int a2, unsigned int a3, int a4)
{
  v4 = *(a1 + 1);
  v5 = *(a1 + 20);
  if ((v4 - 9) < 0xFFFFFFF8 || v5 > 2)
  {
    return 0;
  }

  v7 = 0;
  if (a3 > 0xC || (a4 - 5) < 0xFFFFFFFC)
  {
    return v7;
  }

  v9 = *(a1 + 2);
  v10 = *(a1 + 2 + v4);
  v11 = a3 / a4;
  v12 = v10 < a2 || v9 >= v10;
  v13 = !v12 && v11 >= v9;
  if (!v13 || (v11 + a2) < v10)
  {
    return 0;
  }

  v15 = (a1 + 3);
  v16 = *(a1 + 1);
  v17 = *(a1 + 2);
  while (v16)
  {
    v18 = *v15++;
    --v16;
    v12 = v17 >= v18;
    v17 = v18;
    if (v12)
    {
      return 0;
    }
  }

  if (*(a1 + 19) > v4 || v4 == 1 && v5 == 2)
  {
    return 0;
  }

  v7 = 0;
  if (v9 == *(a1 + 21) && v10 == *(a1 + 21 + v5))
  {
    v19 = (a1 + 22);
    v20 = *(a1 + 20);
    while (v20)
    {
      v7 = 0;
      v21 = *v19++;
      --v20;
      v12 = v9 >= v21;
      v9 = v21;
      if (v12)
      {
        return v7;
      }
    }

    if (!*(a1 + 20))
    {
      return 1;
    }

    v22 = 0;
    while (1)
    {
      if (*(a1 + 1))
      {
        v23 = 0;
        while (*(a1 + 2 + v23) != *(a1 + 21 + v22))
        {
          v7 = 0;
          if (v4 == ++v23)
          {
            return v7;
          }
        }
      }

      else
      {
        LODWORD(v23) = 0;
      }

      if (v23 == v4)
      {
        break;
      }

      ++v22;
      v7 = 1;
      if (v22 == v5)
      {
        return v7;
      }
    }

    return 0;
  }

  return v7;
}

uint64_t extractFrameInfo(unsigned int *a1, unsigned __int8 a2, _BYTE *a3)
{
  v6 = a1[1];
  if (2 - v6 <= 0)
  {
    v7 = 0;
    v8 = *a1;
  }

  else
  {
    if (v6 == -30)
    {
      v7 = 0;
    }

    else
    {
      v7 = *a1 << (2 - v6);
    }

    v8 = CDK_get32((a1 + 2));
    *a1 = v8;
    v6 = a1[1] + 32;
  }

  v9 = a2;
  v10 = v6 - 2;
  a1[1] = v6 - 2;
  v11 = ((v8 >> (v6 - 2)) | v7) & 3;
  if ((v11 - 1) >= 2)
  {
    if (v11 == 3)
    {
      v133 = 2;
LABEL_55:
      if (2 - v10 < 1)
      {
        v44 = 0;
      }

      else
      {
        if (v10 == -30)
        {
          v44 = 0;
        }

        else
        {
          v44 = v8 << (2 - v10);
        }

        v8 = CDK_get32((a1 + 2));
        *a1 = v8;
        v10 = a1[1] + 32;
      }

      v45 = v10 - 2;
      a1[1] = v10 - 2;
      v46 = (v8 >> (v10 - 2)) | v44;
      if (4 - v10 < 1)
      {
        v47 = 0;
      }

      else
      {
        if (v10 == -28)
        {
          v47 = 0;
        }

        else
        {
          v47 = v8 << (4 - v10);
        }

        v8 = CDK_get32((a1 + 2));
        *a1 = v8;
        v45 = a1[1] + 32;
      }

      v132 = v46 & 3;
      v48 = v45 - 2;
      a1[1] = v45 - 2;
      v49 = (v8 >> (v45 - 2)) | v47;
      if (4 - v45 < 1)
      {
        v50 = 0;
      }

      else
      {
        if (v45 == -28)
        {
          v50 = 0;
        }

        else
        {
          v50 = v8 << (4 - v45);
        }

        v8 = CDK_get32((a1 + 2));
        *a1 = v8;
        v48 = a1[1] + 32;
      }

      v129 = v11;
      v51 = v48 - 2;
      a1[1] = v48 - 2;
      v52 = (v8 >> (v48 - 2)) | v50;
      if (4 - v48 < 1)
      {
        v53 = 0;
      }

      else
      {
        if (v48 == -28)
        {
          v53 = 0;
        }

        else
        {
          v53 = v8 << (4 - v48);
        }

        v8 = CDK_get32((a1 + 2));
        *a1 = v8;
        v51 = a1[1] + 32;
      }

      v130 = (v49 & 3) + v9;
      a1[1] = v51 - 2;
      v54 = ((v8 >> (v51 - 2)) | v53) & 3;
      v55 = v54 + (v52 & 3u);
      v56 = v55 + 1;
      a3[6] = v132;
      v127 = a3 + 6;
      if ((v52 & 3) != 0)
      {
        v57 = v52 & 3;
        v58 = a3 + 7;
        v59 = v132;
        do
        {
          v60 = a1[1];
          if (2 - v60 <= 0)
          {
            LOBYTE(v61) = 0;
            v62 = *a1;
          }

          else
          {
            if (v60 == -30)
            {
              LOBYTE(v61) = 0;
            }

            else
            {
              v61 = *a1 << (2 - v60);
            }

            v62 = CDK_get32((a1 + 2));
            *a1 = v62;
            v60 = a1[1] + 32;
          }

          v63 = v60 - 2;
          a1[1] = v63;
          v64 = v59 + 2 * (((v62 >> v63) | v61) & 3);
          v59 = v64 + 2;
          *v58++ = v64 + 2;
          --v57;
        }

        while (v57);
      }

      v127[v56] = v130;
      if (v54)
      {
        v65 = &a3[v56 + 5];
        v66 = v130;
        do
        {
          v67 = a1[1];
          if (2 - v67 <= 0)
          {
            LOBYTE(v68) = 0;
            v69 = *a1;
          }

          else
          {
            if (v67 == -30)
            {
              LOBYTE(v68) = 0;
            }

            else
            {
              v68 = *a1 << (2 - v67);
            }

            v69 = CDK_get32((a1 + 2));
            *a1 = v69;
            v67 = a1[1] + 32;
          }

          v70 = v67 - 2;
          a1[1] = v70;
          v71 = v66 - 2 * (((v69 >> v70) | v68) & 3);
          v66 = v71 - 2;
          *v65-- = v71 - 2;
          --v54;
        }

        while (v54);
      }

      v72 = -2 - v55;
      v73 = -1;
      do
      {
        v72 *= 2;
        ++v73;
      }

      while (v72 < 0);
      v74 = 31 - v73;
      if ((31 - v73) < 0x21)
      {
        v75 = a1[1];
        v76 = v74 - v75;
        if (v74 - v75 <= 0)
        {
          v77 = 0;
          v78 = *a1;
        }

        else
        {
          if (v76 == 32)
          {
            v77 = 0;
          }

          else
          {
            v77 = *a1 << v76;
          }

          v78 = CDK_get32((a1 + 2));
          *a1 = v78;
          v75 = a1[1] + 32;
        }

        v79 = v75 - v74;
        a1[1] = v79;
        v80 = ((v78 >> v79) | v77) & BitMask[v74];
        if (v80 <= v56)
        {
          v81 = v55 + 2 - v80;
          if (!v80)
          {
            v81 = -1;
          }

          a3[23] = v81;
          v82 = a3 + 15;
          v83 = v55 + 1;
          do
          {
            v84 = a1[1];
            if (1 - v84 <= 0)
            {
              LOBYTE(v85) = 0;
              v86 = *a1;
            }

            else
            {
              if (v84 == -31)
              {
                LOBYTE(v85) = 0;
              }

              else
              {
                v85 = *a1 << (1 - v84);
              }

              v86 = CDK_get32((a1 + 2));
              *a1 = v86;
              v84 = a1[1] + 32;
            }

            v87 = v84 - 1;
            a1[1] = v87;
            *v82++ = ((v86 >> v87) | v85) & 1;
            --v83;
          }

          while (v83);
          a3[25] = v132;
          if (v55)
          {
            if (v80 > 1)
            {
              v55 = a3[23];
            }

            a3[26] = v127[v55];
            LOBYTE(v11) = v129;
            a3[27] = v130;
            a3[5] = v56;
            v88 = 2;
            v89 = 2;
          }

          else
          {
            LOBYTE(v11) = v129;
            a3[26] = v130;
            v89 = 1;
            a3[5] = 1;
            v88 = 1;
            v56 = 1;
          }

          v90 = v133;
          goto LABEL_200;
        }

        return 0;
      }

LABEL_203:
      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "UINT CDKreadBits(HANDLE_CDK_BITSTREAM, const UINT)";
      v126 = 143;
      goto LABEL_204;
    }

    if (4 - v6 < 1)
    {
      v13 = 0;
    }

    else
    {
      if (v6 == -28)
      {
        v13 = 0;
      }

      else
      {
        v13 = v8 << (4 - v6);
      }

      v8 = CDK_get32((a1 + 2));
      *a1 = v8;
      v10 = a1[1] + 32;
    }

    v90 = v11 - 1;
    v91 = v10 - 2;
    a1[1] = v10 - 2;
    v20 = (1 << (((v8 >> (v10 - 2)) | v13) & 3));
    if (3 - v10 < 1)
    {
      v92 = 0;
    }

    else
    {
      if (v10 == -29)
      {
        v92 = 0;
      }

      else
      {
        v92 = v8 << (3 - v10);
      }

      v8 = CDK_get32((a1 + 2));
      *a1 = v8;
      v91 = a1[1] + 32;
    }

    v93 = v91 - 1;
    a1[1] = v91 - 1;
    if (v20 > 3)
    {
      if (v20 == 4)
      {
        if (a2 == 16)
        {
          v94 = &CDK_sbrDecoder_sbr_frame_info4_16;
          goto LABEL_143;
        }

        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "int extractFrameInfo(HANDLE_CDK_BITSTREAM, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, const UINT, const UINT)";
        v126 = 1087;
      }

      else
      {
        if (v20 != 8)
        {
          goto LABEL_144;
        }

        if (a2 == 16)
        {
          v94 = &CDK_sbrDecoder_sbr_frame_info8_16;
          goto LABEL_143;
        }

        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "int extractFrameInfo(HANDLE_CDK_BITSTREAM, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, const UINT, const UINT)";
        v126 = 1097;
      }
    }

    else if (v20 == 1)
    {
      if (a2 == 16)
      {
        v94 = &CDK_sbrDecoder_sbr_frame_info1_16;
        goto LABEL_143;
      }

      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "int extractFrameInfo(HANDLE_CDK_BITSTREAM, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, const UINT, const UINT)";
      v126 = 1069;
    }

    else
    {
      if (v20 != 2)
      {
        goto LABEL_144;
      }

      if (a2 == 16)
      {
        v94 = &CDK_sbrDecoder_sbr_frame_info2_16;
LABEL_143:
        CDKmemcpy(a3 + 4, v94, 0x1DuLL);
LABEL_144:
        if ((((v8 >> v93) | v92) & 1) == 0)
        {
          bzero(a3 + 15, v20);
        }

        goto LABEL_194;
      }

      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "int extractFrameInfo(HANDLE_CDK_BITSTREAM, HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, const UINT, const UINT)";
      v126 = 1078;
    }

LABEL_204:
    exception[2] = v126;
  }

  if (4 - v6 < 1)
  {
    v12 = 0;
  }

  else
  {
    if (v6 == -28)
    {
      v12 = 0;
    }

    else
    {
      v12 = v8 << (4 - v6);
    }

    v8 = CDK_get32((a1 + 2));
    *a1 = v8;
    v10 = a1[1] + 32;
  }

  v14 = v10 - 2;
  a1[1] = v10 - 2;
  v15 = (v8 >> (v10 - 2)) | v12;
  v133 = v11 - 1;
  if (4 - v10 < 1)
  {
    v16 = 0;
  }

  else
  {
    if (v10 == -28)
    {
      v16 = 0;
    }

    else
    {
      v16 = v8 << (4 - v10);
    }

    v8 = CDK_get32((a1 + 2));
    *a1 = v8;
    v14 = a1[1] + 32;
  }

  v17 = v15 & 3;
  v10 = v14 - 2;
  a1[1] = v14 - 2;
  v18 = (v8 >> (v14 - 2)) | v16;
  v19 = v18 & 3;
  v20 = v19 + 1;
  if (v11 > 1)
  {
    if (v11 == 2)
    {
      a3[6] = v17;
      v131 = a3 + 6;
      if (v19)
      {
        v35 = v18 & 3;
        v36 = a3 + 7;
        do
        {
          v37 = a1[1];
          if (2 - v37 <= 0)
          {
            LOBYTE(v38) = 0;
            v39 = *a1;
          }

          else
          {
            if (v37 == -30)
            {
              LOBYTE(v38) = 0;
            }

            else
            {
              v38 = *a1 << (2 - v37);
            }

            v39 = CDK_get32((a1 + 2));
            *a1 = v39;
            v37 = a1[1] + 32;
          }

          v40 = v37 - 2;
          a1[1] = v40;
          v41 = v17 + 2 * (((v39 >> v40) | v38) & 3);
          v17 = v41 + 2;
          *v36++ = v41 + 2;
          --v35;
        }

        while (v35);
        v42 = &v131[v20];
        v43 = v19 + 1;
        LOBYTE(v11) = 2;
      }

      else
      {
        v42 = a3 + 7;
        v43 = 1;
      }

      *v42 = a2;
      v95 = ~v43;
      v96 = -1;
      do
      {
        v95 *= 2;
        ++v96;
      }

      while (v95 < 0);
      v97 = 31 - v96;
      if ((31 - v96) < 0x21)
      {
        v98 = a1[1];
        v99 = v97 - v98;
        if (v97 - v98 <= 0)
        {
          v100 = 0;
          v102 = *a1;
        }

        else
        {
          if (v99 == 32)
          {
            v100 = 0;
          }

          else
          {
            v100 = *a1 << v99;
          }

          v102 = CDK_get32((a1 + 2));
          *a1 = v102;
          v98 = a1[1] + 32;
        }

        v114 = v98 - v97;
        a1[1] = v114;
        v115 = ((v102 >> v114) | v100) & BitMask[v97];
        if (v115 <= v43)
        {
          v117 = v115 - 1;
          if (v115 < 2)
          {
            v117 = -1;
          }

          a3[23] = v117;
          v118 = a3 + 15;
          v119 = v19 + 1;
          do
          {
            v120 = a1[1];
            if (1 - v120 <= 0)
            {
              LOBYTE(v121) = 0;
              v122 = *a1;
            }

            else
            {
              if (v120 == -31)
              {
                LOBYTE(v121) = 0;
              }

              else
              {
                v121 = *a1 << (1 - v120);
              }

              v122 = CDK_get32((a1 + 2));
              *a1 = v122;
              v120 = a1[1] + 32;
            }

            v123 = v120 - 1;
            a1[1] = v123;
            *v118++ = ((v122 >> v123) | v121) & 1;
            --v119;
          }

          while (v119);
          if (v115 == 1)
          {
            a3[26] = v131[v19];
          }

          else
          {
            if (v115)
            {
              v124 = v131[a3[23]];
            }

            else
            {
              v124 = a3[7];
            }

            a3[26] = v124;
          }

          goto LABEL_193;
        }

        return 0;
      }

      goto LABEL_203;
    }

    goto LABEL_55;
  }

  if (v11)
  {
    v128 = v11;
    a3[6] = 0;
    v21 = a3 + 6;
    v22 = v17 + a2;
    a3[v20 + 6] = v17 + v9;
    if (v19)
    {
      v23 = v18 & 3;
      do
      {
        v24 = a1[1];
        if (2 - v24 <= 0)
        {
          LOBYTE(v25) = 0;
          v26 = *a1;
        }

        else
        {
          if (v24 == -30)
          {
            LOBYTE(v25) = 0;
          }

          else
          {
            v25 = *a1 << (2 - v24);
          }

          v26 = CDK_get32((a1 + 2));
          *a1 = v26;
          v24 = a1[1] + 32;
        }

        v27 = v24 - 2;
        a1[1] = v27;
        v28 = v22 - 2 * (((v26 >> v27) | v25) & 3);
        v22 = v28 - 2;
        v21[v23--] = v28 - 2;
      }

      while (v23);
    }

    v29 = -2 - v19;
    v30 = -1;
    do
    {
      v29 *= 2;
      ++v30;
    }

    while (v29 < 0);
    v31 = 31 - v30;
    if ((31 - v30) < 0x21)
    {
      v32 = a1[1];
      v33 = v31 - v32;
      if (v31 - v32 <= 0)
      {
        v34 = 0;
        v101 = *a1;
      }

      else
      {
        if (v33 == 32)
        {
          v34 = 0;
        }

        else
        {
          v34 = *a1 << v33;
        }

        v101 = CDK_get32((a1 + 2));
        *a1 = v101;
        v32 = a1[1] + 32;
      }

      v103 = v32 - v31;
      a1[1] = v103;
      v104 = ((v101 >> v103) | v34) & BitMask[v31];
      if (v104 <= v20)
      {
        v105 = v19 - v104 + 2;
        if (!v104)
        {
          v105 = -1;
        }

        a3[23] = v105;
        v106 = v19 + 1;
        v107 = &a3[v19 + 15];
        do
        {
          v108 = a1[1];
          if (1 - v108 <= 0)
          {
            LOBYTE(v109) = 0;
            v110 = *a1;
          }

          else
          {
            if (v108 == -31)
            {
              LOBYTE(v109) = 0;
            }

            else
            {
              v109 = *a1 << (1 - v108);
            }

            v110 = CDK_get32((a1 + 2));
            *a1 = v110;
            v108 = a1[1] + 32;
          }

          v111 = v108 - 1;
          a1[1] = v111;
          *v107-- = ((v110 >> v111) | v109) & 1;
        }

        while (v106-- > 1);
        if (v104 > 1)
        {
          v113 = v21[a3[23]];
        }

        else
        {
          v113 = v21[v19];
        }

        a3[26] = v113;
        LOBYTE(v11) = v128;
        goto LABEL_193;
      }

      return 0;
    }

    goto LABEL_203;
  }

LABEL_193:
  v90 = v133;
LABEL_194:
  a3[5] = v20;
  v89 = 2;
  if (v20 == 1)
  {
    v88 = 1;
  }

  else
  {
    v88 = 2;
  }

  if (v20 == 1)
  {
    v89 = 1;
    v56 = 1;
  }

  else
  {
    v56 = v20;
  }

LABEL_200:
  a3[24] = v88;
  a3[4] = v11;
  if (v90 <= 1)
  {
    a3[25] = a3[6];
    a3[v89 + 25] = a3[v56 + 6];
  }

  return 1;
}

uint64_t sbrGetDirectionControlData(uint64_t result, unsigned int *a2, char a3, int a4)
{
  v5 = result;
  v6 = (a3 & 0x10) == 0 || (a3 & 0xC) == 0;
  if (!a4)
  {
    if (v6)
    {
      v7 = 0;
    }

    else
    {
      *(result + 33) = 0;
      v7 = 1;
    }

    v8 = *(result + 5);
    if (v7 < v8)
    {
      v9 = v7;
      do
      {
        v10 = a2[1];
        if (1 - v10 <= 0)
        {
          LOBYTE(v11) = 0;
          result = *a2;
        }

        else
        {
          if (v10 == -31)
          {
            LOBYTE(v11) = 0;
          }

          else
          {
            v11 = *a2 << (1 - v10);
          }

          result = CDK_get32((a2 + 2));
          *a2 = result;
          v10 = a2[1] + 32;
          v8 = v5[5];
        }

        v12 = v10 - 1;
        a2[1] = v12;
        v5[v9++ + 33] = ((result >> v12) | v11) & 1;
      }

      while (v9 < v8);
    }
  }

  if (v6)
  {
    v13 = 0;
  }

  else
  {
    v5[41] = 0;
    v13 = 1;
  }

  v14 = v5[24];
  if (v13 < v14)
  {
    v15 = v13;
    do
    {
      v16 = a2[1];
      if (1 - v16 <= 0)
      {
        LOBYTE(v17) = 0;
        result = *a2;
      }

      else
      {
        if (v16 == -31)
        {
          LOBYTE(v17) = 0;
        }

        else
        {
          v17 = *a2 << (1 - v16);
        }

        result = CDK_get32((a2 + 2));
        *a2 = result;
        v16 = a2[1] + 32;
        v14 = v5[24];
      }

      v18 = v16 - 1;
      a2[1] = v18;
      v5[v15++ + 41] = ((result >> v18) | v17) & 1;
    }

    while (v15 < v14);
  }

  return result;
}

uint64_t sbrGetEnvelope(uint64_t a1, uint64_t a2, unsigned int *a3, __int16 a4)
{
  v59[1] = *MEMORY[0x1E69E9840];
  v59[0] = 0xAAAAAAAAAAAAAAAALL;
  v5 = *(a2 + 64);
  v6 = *(a1 + 34);
  v7 = *(a2 + 5);
  if (*(a2 + 4))
  {
    v8 = 0;
  }

  else
  {
    v8 = v7 == 1;
  }

  *a2 = 0;
  if (v8)
  {
    v6 = 0;
  }

  *(a2 + 68) = v6;
  if (v6 == 1)
  {
    v9 = 6;
  }

  else
  {
    v9 = 7;
  }

  v53 = v9;
  v54 = v5;
  if (v6 == 1)
  {
    v10 = 5;
  }

  else
  {
    v10 = 6;
  }

  v52 = v10;
  if (!v7)
  {
    goto LABEL_17;
  }

  v11 = 0;
  v12 = v59;
  v13 = 15;
  v14 = v7;
  do
  {
    v15 = *(a1 + 40 + *(a2 + v13));
    *v12++ = v15;
    v11 += v15;
    *a2 = v11;
    ++v13;
    --v14;
  }

  while (v14);
  if (v11 > 0x1C0)
  {
    return 0;
  }

  else
  {
LABEL_17:
    v16 = &CDK_sbrDecoder_sbr_huffBook_EnvBalance11T;
    v17 = v6 == 0;
    v18 = &CDK_sbrDecoder_sbr_huffBook_EnvBalance11F;
    if (v17)
    {
      v16 = &CDK_sbrDecoder_sbr_huffBook_EnvBalance10T;
      v18 = &CDK_sbrDecoder_sbr_huffBook_EnvBalance10F;
    }

    v19 = &CDK_sbrDecoder_sbr_huffBook_EnvLevel11T;
    if (v17)
    {
      v19 = &CDK_sbrDecoder_sbr_huffBook_EnvLevel10T;
    }

    v20 = &CDK_sbrDecoder_sbr_huffBook_EnvLevel11F;
    if (v17)
    {
      v20 = &CDK_sbrDecoder_sbr_huffBook_EnvLevel10F;
    }

    v21 = v54 == 2;
    if (v54 == 2)
    {
      v22 = v16;
    }

    else
    {
      v22 = v19;
    }

    if (v54 == 2)
    {
      v23 = v18;
    }

    else
    {
      v23 = v20;
    }

    *(a2 + 1912) = 0;
    v50 = 1;
    if (v7)
    {
      v24 = 0;
      *&v58[8] = 0;
      v25 = a2 + 33;
      v51 = a2 + 80;
      *v58 = a4 & 0x404;
      v55 = a2 + 1913;
      v57 = a2 + 84;
      do
      {
        v26 = *(v25 + v24);
        if (!*(v25 + v24))
        {
          v27 = a3[1];
          if (v54 == 2)
          {
            v28 = v52 - v27;
            if (v52 - v27 <= 0)
            {
              v29 = 0;
              v32 = *a3;
            }

            else
            {
              if (v28 == 32)
              {
                v29 = 0;
              }

              else
              {
                v29 = *a3 << v28;
              }

              v32 = CDK_get32((a3 + 2));
              *a3 = v32;
              v27 = a3[1] + 32;
            }

            v34 = v27 - v52;
            a3[1] = v34;
            v35 = (((v32 >> v34) | v29) & BitMask[v52]) << v21;
          }

          else
          {
            v30 = v53 - v27;
            if (v53 - v27 <= 0)
            {
              v31 = 0;
              v33 = *a3;
            }

            else
            {
              if (v30 == 32)
              {
                v31 = 0;
              }

              else
              {
                v31 = *a3 << v30;
              }

              v33 = CDK_get32((a3 + 2));
              *a3 = v33;
              v27 = a3[1] + 32;
            }

            v36 = v27 - v53;
            a3[1] = v36;
            v35 = ((v33 >> v36) | v31) & BitMask[v53];
          }

          *(v51 + 4 * *&v58[4]) = v35;
          v26 = *(v25 + v24);
        }

        v37 = *(v59 + v24);
        if ((1 - v26) < v37)
        {
          v38 = v37 + v26 - 1;
          v39 = (v57 - 4 * v26 + 4 * *&v58[4]);
          do
          {
            if (*(v25 + v24))
            {
              v40 = v22;
            }

            else
            {
              v40 = v23;
            }

            *v39++ = (DecodeHuffmanCW(v40, a3) << v21);
            --v38;
          }

          while (v38);
        }

        if (*v58 == 1028)
        {
          v41 = a3[1];
          if (v41)
          {
            v42 = v41 - 1;
            v43 = *a3;
            v44 = (*a3 >> v42) & 1;
          }

          else
          {
            v43 = CDK_get32((a3 + 2));
            *a3 = v43;
            v44 = v43 >> 31;
            v42 = 31;
          }

          a3[1] = v42;
          if (v24 >= 8)
          {
            exception = __cxa_allocate_exception(0x10uLL);
            *exception = "int sbrGetEnvelope(HANDLE_SBR_HEADER_DATA, HANDLE_SBR_FRAME_DATA, HANDLE_CDK_BITSTREAM, const UINT)";
            exception[2] = 919;
          }

          *(a2 + 1912) |= v44 << v24;
          if (v44)
          {
            if (2 - v42 < 1)
            {
              LOBYTE(v45) = 0;
            }

            else
            {
              v45 = v43 << (2 - v42);
              v43 = CDK_get32((a3 + 2));
              *a3 = v43;
              v42 = a3[1] + 32;
            }

            v47 = v42 - 2;
            a3[1] = v47;
            v46 = ((v43 >> v47) | v45) & 3;
          }

          else
          {
            v46 = 0;
          }

          *(v55 + v24) = v46;
        }

        *&v58[4] += v37;
        ++v24;
      }

      while (v24 != v7);
      return 1;
    }
  }

  return v50;
}

uint64_t sbrGetNoiseFloorData(uint64_t result, uint64_t a2, unsigned int *a3)
{
  v23 = *(a2 + 64);
  v3 = v23 == 2;
  if (v23 == 2)
  {
    v4 = &CDK_sbrDecoder_sbr_huffBook_EnvBalance11F;
  }

  else
  {
    v4 = &CDK_sbrDecoder_sbr_huffBook_EnvLevel11F;
  }

  if (v23 == 2)
  {
    v5 = &CDK_sbrDecoder_sbr_huffBook_NoiseBalance11T;
  }

  else
  {
    v5 = &CDK_sbrDecoder_sbr_huffBook_NoiseLevel11T;
  }

  if (*(a2 + 24))
  {
    v7 = 0;
    v8 = *(result + 42);
    v9 = (a2 + 1872);
    v24 = 4 * v8;
    v25 = a2 + 41;
    v22 = a2 + 1872;
    v10 = (a2 + 1876);
    do
    {
      if (*(v25 + v7))
      {
        v11 = v9;
        v12 = v8;
        if (v8)
        {
          do
          {
            result = DecodeHuffmanCW(v5, a3);
            *v11++ = (result << v3);
            --v12;
          }

          while (v12);
        }
      }

      else
      {
        v13 = a3[1];
        v14 = 5 - v13;
        if (v23 == 2)
        {
          if (v14 <= 0)
          {
            LOBYTE(v15) = 0;
            result = *a3;
          }

          else
          {
            if (v13 == -27)
            {
              LOBYTE(v15) = 0;
            }

            else
            {
              v15 = *a3 << v14;
            }

            result = CDK_get32((a3 + 2));
            *a3 = result;
            v13 = a3[1] + 32;
          }

          v17 = v13 - 5;
          a3[1] = v17;
          v18 = 2 * (((result >> v17) | v15) & 0x1F);
        }

        else
        {
          if (v14 <= 0)
          {
            LOBYTE(v16) = 0;
            result = *a3;
          }

          else
          {
            if (v13 == -27)
            {
              LOBYTE(v16) = 0;
            }

            else
            {
              v16 = *a3 << v14;
            }

            result = CDK_get32((a3 + 2));
            *a3 = result;
            v13 = a3[1] + 32;
          }

          v19 = v13 - 5;
          a3[1] = v19;
          v18 = ((result >> v19) | v16) & 0x1F;
        }

        *(v22 + 4 * v7 * v8) = v18;
        if (v8 >= 2)
        {
          v20 = v10;
          v21 = v8 - 1;
          do
          {
            result = DecodeHuffmanCW(v4, a3);
            *v20++ = (result << v3);
            --v21;
          }

          while (v21);
        }
      }

      ++v7;
      v9 = (v9 + v24);
      v10 = (v10 + v24);
    }

    while (v7 < *(a2 + 24));
  }

  return result;
}

uint64_t sbrGetSyntheticCodedData(uint64_t a1, uint64_t a2, unsigned int *a3, char a4)
{
  v8 = a3[1];
  if (1 - v8 <= 0)
  {
    v9 = 0;
    result = *a3;
  }

  else
  {
    if (v8 == -31)
    {
      v9 = 0;
    }

    else
    {
      v9 = *a3 << (1 - v8);
    }

    result = CDK_get32((a3 + 2));
    *a3 = result;
    v8 = a3[1] + 32;
  }

  v11 = v8 - 1;
  a3[1] = v11;
  if (((result >> v11) | v9))
  {
    v30 = a4;
    v12 = 0;
    v13 = *(a1 + 41);
    v29 = a2;
    v14 = a2 + 72;
    v15 = 1;
    do
    {
      v16 = v15;
      if (v13 >= 32)
      {
        v17 = 32;
      }

      else
      {
        v17 = v13;
      }

      if (v13 < 1)
      {
        v21 = 0;
      }

      else
      {
        v18 = a3[1];
        v19 = v17 - v18;
        if (v17 - v18 <= 0)
        {
          v20 = 0;
          result = *a3;
        }

        else
        {
          if (v19 == 32)
          {
            v20 = 0;
          }

          else
          {
            v20 = *a3 << v19;
          }

          result = CDK_get32((a3 + 2));
          *a3 = result;
          v18 = a3[1] + 32;
        }

        v22 = v18 - v17;
        a3[1] = v22;
        v21 = (((result >> v22) | v20) & BitMask[v17]) << -v17;
      }

      v15 = 0;
      v13 -= v17;
      *(v14 + 4 * v12) = v21;
      v12 = 1;
    }

    while ((v16 & 1) != 0);
    if ((v30 & 4) != 0 && *(a1 + 37))
    {
      v23 = a3[1];
      if (v23)
      {
        v24 = v23 - 1;
        result = *a3;
        v25 = (result >> v24) & 1;
      }

      else
      {
        result = CDK_get32((a3 + 2));
        *a3 = result;
        v25 = result >> 31;
        v24 = 31;
      }

      a3[1] = v24;
      if (v25)
      {
        if (5 - v24 < 1)
        {
          v26 = 0;
        }

        else
        {
          if (v24 == -27)
          {
            v26 = 0;
          }

          else
          {
            v26 = result << (5 - v24);
          }

          result = CDK_get32((a3 + 2));
          *a3 = result;
          v24 = a3[1] + 32;
        }

        v28 = v24 - 5;
        a3[1] = v28;
        v27 = ((result >> v28) | v26) & 0x1F;
      }

      else
      {
        v27 = 31;
      }

      *(v29 + 1938) = v27;
    }
  }

  else
  {
    *(a2 + 72) = 0;
  }

  return result;
}

uint64_t DecodeHuffmanCW(uint64_t a1, unsigned int *a2)
{
  LOBYTE(v4) = 0;
  v5 = a2[1];
  do
  {
    if (1 - v5 <= 0)
    {
      LOBYTE(v6) = 0;
      v7 = *a2;
    }

    else
    {
      if (v5 == -31)
      {
        LOBYTE(v6) = 0;
      }

      else
      {
        v6 = *a2 << (1 - v5);
      }

      v7 = CDK_get32((a2 + 2));
      *a2 = v7;
      v5 = a2[1] + 32;
    }

    a2[1] = --v5;
    v4 = *(a1 + 2 * v4 + (((v7 >> v5) | v6) & 1));
  }

  while ((v4 & 0x80000000) == 0);
  return (v4 + 64);
}

uint64_t ecDataDec(_BYTE *a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, int a9, char a10)
{
  v224 = *MEMORY[0x1E69E9840];
  v211 = 0;
  memset(v210, 0, sizeof(v210));
  if (a9 < 1)
  {
    return 4294966314;
  }

  v10 = a1;
  if (!a1[2])
  {
    v23 = *(a4 + 40);
    LOBYTE(v24) = *(v23 + 1);
    goto LABEL_296;
  }

  v15 = 0;
  v206 = a4;
  do
  {
    v16 = a3[1];
    if (2 - v16 <= 0)
    {
      LOBYTE(v17) = 0;
      v18 = *a3;
    }

    else
    {
      if (v16 == -30)
      {
        LOBYTE(v17) = 0;
      }

      else
      {
        v17 = *a3 << (2 - v16);
      }

      v18 = CDK_get32((a3 + 2));
      *a3 = v18;
      v16 = a3[1] + 32;
      a4 = v206;
      v10 = a1;
    }

    v19 = v16 - 2;
    a3[1] = v19;
    v20 = ((v18 >> v19) | v17) & 3;
    *(a4 + v15) = v20;
    if (!v15 && *v10 == 1 && (v20 - 1) < 2)
    {
      return 4294966314;
    }

    v21 = v10[2];
    if (v15 >= (v21 - 1) && v20 == 2)
    {
      return 4294966314;
    }

    ++v15;
  }

  while (v15 < v21);
  v193 = a8;
  v23 = *(a4 + 40);
  v24 = *(v23 + 1);
  if (!v10[2])
  {
LABEL_296:
    result = 0;
    *(v23 + 1) = v24;
    return result;
  }

  v25 = 0;
  v26 = 0;
  v201 = 0;
  v204 = a4 + 9;
  v197 = a4 + 18;
  v200 = a7;
  while (1)
  {
    v27 = *(a4 + v25);
    if (!*(a4 + v25))
    {
        ;
      }

      v24 = 0;
      v27 = *(a4 + v25);
    }

    if (v27 != 3)
    {
      goto LABEL_292;
    }

    if (!v26)
    {
      break;
    }

    v26 = 0;
LABEL_292:
    if (++v25 >= v10[2])
    {
      v23 = *(a4 + 40);
      goto LABEL_296;
    }
  }

  v29 = a3[1];
  v198 = v25;
  if (1 - v29 <= 0)
  {
    LOBYTE(v30) = 0;
    v31 = *a3;
  }

  else
  {
    if (v29 == -31)
    {
      LOBYTE(v30) = 0;
    }

    else
    {
      v30 = *a3 << (1 - v29);
    }

    v31 = CDK_get32((a3 + 2));
    *a3 = v31;
    v29 = a3[1] + 32;
  }

  v32 = v29 - 1;
  a3[1] = v29 - 1;
  if (2 - v29 < 1)
  {
    v33 = 0;
    v34 = v31;
    v35 = v29 - 1;
  }

  else
  {
    if (v29 == -30)
    {
      v33 = 0;
    }

    else
    {
      v33 = v31 << (2 - v29);
    }

    v34 = CDK_get32((a3 + 2));
    *a3 = v34;
    v35 = a3[1] + 32;
  }

  v36 = v35 - 1;
  a3[1] = v36;
  v37 = v201;
  *(v204 + v201) = ((v34 >> v36) | v33) & 1;
  v38 = a3[1];
  if (2 - v38 <= 0)
  {
    LOBYTE(v39) = 0;
    v40 = *a3;
    v41 = a1;
  }

  else
  {
    if (v38 == -30)
    {
      LOBYTE(v39) = 0;
    }

    else
    {
      v39 = *a3 << (2 - v38);
    }

    v40 = CDK_get32((a3 + 2));
    *a3 = v40;
    v38 = a3[1] + 32;
    v41 = a1;
    v37 = v201;
  }

  v42 = v38 - 2;
  a3[1] = v42;
  *(v197 + v37) = ((v40 >> v42) | v39) & 3;
  v203 = v37;
  v43 = v200;
  if (v24 != *(v204 + v37))
  {
    v44 = *(a6 + 8 * v193);
    if (v24)
    {
      v43 = v200;
      coarse2fine(v44, v200, a9);
      v37 = v201;
      v41 = a1;
    }

    else
    {
      v45 = a9;
      v43 = v200;
      do
      {
        v46 = *v44;
        v47 = v46 >> 1;
        v48 = ((v46 + (v46 >> 7)) << 24) >> 25;
        if (v200)
        {
          LOBYTE(v48) = v47;
        }

        *v44++ = v48;
        --v45;
      }

      while (v45);
    }
  }

  v49 = 0;
  v205 = ((v31 >> v32) | v30) & 1;
  v50 = pbStrideTable[*(v197 + v203)];
  v51 = (a9 - 1) / v50;
  LODWORD(v210[0]) = 0;
  v52 = vdupq_n_s32(v50);
  v53 = vmull_u16(vmovn_s32(v52), 0x3000200010000);
  v54 = vdupq_n_s32(4 * v50);
  v55 = vdupq_n_s64(v51);
  v56 = v210 + 8;
  v57 = v43;
  do
  {
    v58 = vdupq_n_s64(v49);
    v59 = vmovn_s64(vcgeq_u64(v55, vorrq_s8(v58, xmmword_19B0A5850)));
    v60 = vaddq_s32(v53, v52);
    if (vuzp1_s16(v59, *v52.i8).u8[0])
    {
      *(v56 - 1) = v60.i32[0];
    }

    if (vuzp1_s16(v59, *&v52).i8[2])
    {
      *v56 = v60.i32[1];
    }

    if (vuzp1_s16(*&v52, vmovn_s64(vcgeq_u64(v55, vorrq_s8(v58, xmmword_19B0A5840)))).i32[1])
    {
      *(v56 + 4) = v60.i64[1];
    }

    v49 += 4;
    v53 = vaddq_s32(v53, v54);
    v56 += 16;
  }

  while (((v51 + 4) & 0xFFFFFFFC) != v49);
  v61 = (v51 + 1);
  v62 = *(v210 + v61);
  if (v62 > a9)
  {
    LODWORD(v63) = 0;
    do
    {
      if (v63 > v51)
      {
        v64 = v63;
      }

      else
      {
        v64 = v63 + 1;
      }

      if (v64 <= v61)
      {
        if (v63 > v51)
        {
          v63 = v63;
        }

        else
        {
          v63 = v63 + 1;
        }

        v65 = v63 - 1;
        v66 = v210 + v63;
        do
        {
          --*v66++;
          ++v65;
        }

        while (v65 <= v51);
        v62 = *(v210 + v61);
      }

      LODWORD(v63) = v64;
    }

    while (v62 > a9);
  }

  v67 = 0;
  do
  {
    *(*(a6 + 8 * v193) + v67) = *(*(a6 + 8 * v193) + *(v210 + v67));
    ++v67;
  }

  while (v67 < v61);
  if (v193 > 5)
  {
    return 4294966309;
  }

  if (v205 + v37 <= 9)
  {
    v68 = *(a6 + 8 * v193);
    v69 = *(v204 + v203);
    v70 = *(v204 + v203) == 0;
    if (v198)
    {
      v71 = 1;
    }

    else
    {
      v71 = *v41 == 0;
    }

    v72 = !v71 && v37 <= 0;
    v217 = 0;
    v73 = !v72;
    memset(v216, 0, sizeof(v216));
    v215 = 0;
    memset(v214, 0, sizeof(v214));
    memset(v212, 0, sizeof(v212));
    v213 = 0;
    if (v57 == 2)
    {
      v74 = 0;
      if (v69)
      {
        v75 = 8;
      }

      else
      {
        v75 = 16;
      }
    }

    else if (v57 == 1)
    {
      v70 = 0;
      v74 = 0;
      if (v69)
      {
        v75 = 4;
      }

      else
      {
        v75 = 8;
      }
    }

    else
    {
      v70 = 0;
      if (v69)
      {
        v75 = 15;
      }

      else
      {
        v75 = 31;
      }

      if (v69)
      {
        v74 = 7;
      }

      else
      {
        v74 = 15;
      }
    }

    v208 = v70;
    v209 = v74;
    v76 = a3[1];
    v194 = v205 + v37;
    v190 = v68;
    if (1 - v76 <= 0)
    {
      v77 = 0;
      v78 = *a3;
    }

    else
    {
      if (v76 == -31)
      {
        v77 = 0;
      }

      else
      {
        v77 = *a3 << (1 - v76);
      }

      v78 = CDK_get32((a3 + 2));
      *a3 = v78;
      v76 = a3[1] + 32;
      v37 = v201;
    }

    v191 = a5 + 252 * v193;
    v195 = (v191 + 28 * v203);
    v202 = v37 + 1;
    v79 = v76 - 1;
    a3[1] = v76 - 1;
    if (((v78 >> (v76 - 1)) | v77))
    {
      if (v205)
      {
        v81 = &v216[1] + 12;
      }

      else
      {
        v81 = 0;
      }

      if (pcm_decode(a3, v216, v81, v209, v61 << v205, v75))
      {
        return 0xFFFFFFFFLL;
      }

      goto LABEL_272;
    }

    if (v205 | v73)
    {
      if (2 - v76 < 1)
      {
        v80 = 0;
      }

      else
      {
        if (v76 == -30)
        {
          v80 = 0;
        }

        else
        {
          v80 = v78 << (2 - v76);
        }

        v78 = CDK_get32((a3 + 2));
        *a3 = v78;
        v79 = a3[1] + 32;
      }

      a3[1] = --v79;
      v82 = ((v78 >> v79) | v80) & 1;
    }

    else
    {
      v82 = 0;
    }

    v192 = v82;
    v196 = 0;
    if (v82)
    {
      v83 = v73;
    }

    else
    {
      v83 = 1;
    }

    v189 = v83;
    if (v205 && v83)
    {
      if (1 - v79 < 1)
      {
        v84 = 0;
      }

      else
      {
        if (v79 == -31)
        {
          v84 = 0;
        }

        else
        {
          v84 = v78 << (1 - v79);
        }

        v78 = CDK_get32((a3 + 2));
        *a3 = v78;
        v79 = a3[1] + 32;
      }

      a3[1] = --v79;
      v196 = ((v78 >> v79) | v84) & 1;
    }

    v220 = 0;
    v221 = 0;
    v218 = 0;
    v219 = 0;
    if (1 - v79 < 1)
    {
      v85 = 0;
    }

    else
    {
      if (v79 == -31)
      {
        v85 = 0;
      }

      else
      {
        v85 = v78 << (1 - v79);
      }

      v78 = CDK_get32((a3 + 2));
      *a3 = v78;
      v79 = a3[1] + 32;
    }

    v223 = 0xAAAAAAAAAAAAAAAALL;
    *&v86 = 0xAAAAAAAAAAAAAAAALL;
    *(&v86 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v222[1] = v86;
    v222[2] = v86;
    v222[0] = v86;
    v87 = v79 - 1;
    a3[1] = v79 - 1;
    if ((((v78 >> (v79 - 1)) | v85) & 1) == 0)
    {
      v88 = huff_dec_1D(a3, v200, v192, v214, v51 + 1, v192 ^ 1);
      v89 = v209;
      if (v205 && !v88)
      {
        v88 = huff_dec_1D(a3, v200, v196, &v214[1] + 12, v51 + 1, v196 ^ 1);
      }

      if (v88)
      {
        return 0xFFFFFFFFLL;
      }

      v90 = 0;
      v91 = v192;
LABEL_188:
      if (v205 && v91 | v196)
      {
        if ((v196 | v189 ^ 1))
        {
          v115 = v91 != v196 && v90;
          v116 = v208;
          if (!v189)
          {
            goto LABEL_232;
          }
        }

        else
        {
          v113 = a3[1];
          if (1 - v113 <= 0)
          {
            v114 = 0;
            v141 = *a3;
          }

          else
          {
            if (v113 == -31)
            {
              v114 = 0;
            }

            else
            {
              v114 = *a3 << (1 - v113);
            }

            v141 = CDK_get32((a3 + 2));
            *a3 = v141;
            v113 = a3[1] + 32;
            v91 = v192;
          }

          v142 = v113 - 1;
          a3[1] = v142;
          v143 = (v141 >> v142) | v114;
          v115 = v91 & v90;
          v116 = v208;
          v89 = v209;
          if (v143)
          {
LABEL_232:
            v144 = BYTE12(v214[1]);
            BYTE12(v216[1]) = BYTE12(v214[1]);
            if (v51 < 1)
            {
              if (!v91)
              {
                LOBYTE(v216[0]) = v214[0];
                goto LABEL_248;
              }
            }

            else
            {
              v145 = 0;
              v146 = v61 - 1;
              do
              {
                v144 += *(&v214[1] + v145 + 13);
                *(&v216[1] + v145++ + 13) = v144;
              }

              while (v146 != v145);
              if (!v91)
              {
                v147 = LOBYTE(v214[0]);
                LOBYTE(v216[0]) = v214[0];
                v148 = v216 + 1;
                v149 = v214 + 1;
                do
                {
                  v150 = *v149++;
                  v147 += v150;
                  *v148++ = v147;
                  --v146;
                }

                while (v146);
LABEL_248:
                v156 = 0;
                do
                {
                  v157 = *(v216 + v156);
                  if (v116)
                  {
                    v158 = a3[1];
                    if (1 - v158 <= 0)
                    {
                      LOBYTE(v159) = 0;
                      v161 = *a3;
                    }

                    else
                    {
                      if (v158 == -31)
                      {
                        LOBYTE(v159) = 0;
                      }

                      else
                      {
                        v159 = *a3 << (1 - v158);
                      }

                      v161 = CDK_get32((a3 + 2));
                      *a3 = v161;
                      v158 = a3[1] + 32;
                    }

                    v162 = v158 - 1;
                    a3[1] = v162;
                    LOBYTE(v162) = ((v161 >> v162) | v159) & 1 | (2 * v157);
                    v116 = v208;
                    v89 = v209;
                    v160 = v162 - v209;
                  }

                  else
                  {
                    v160 = v157 - v89;
                  }

                  *(v216 + v156++) = v160;
                }

                while (v61 != v156);
                if (!v205)
                {
                  CDKmemcpy(v195, v216, v61);
LABEL_274:
                  if (v200 == 2)
                  {
                    v171 = 0;
                    v172 = v203;
                    if (*(v204 + v203))
                    {
                      v173 = 7;
                    }

                    else
                    {
                      v173 = 15;
                    }

                    LODWORD(v174) = v210[0];
                    do
                    {
                      v175 = v171 + 1;
                      v176 = *(v210 + v171 + 1);
                      if (v174 < v176)
                      {
                        v174 = v174;
                        do
                        {
                          *(*(a6 + 8 * v193) + v174++) = *(a5 + 252 * v193 + 28 * v194 + v171) & v173;
                        }

                        while (v176 != v174);
                      }

                      LODWORD(v174) = v176;
                      ++v171;
                    }

                    while (v175 < v61);
                  }

                  else
                  {
                    v177 = 0;
                    LODWORD(v178) = v210[0];
                    v172 = v203;
                    do
                    {
                      v179 = v177 + 1;
                      v180 = *(v210 + v177 + 1);
                      if (v178 < v180)
                      {
                        v178 = v178;
                        v181 = *(a5 + 252 * v193 + 28 * v194 + v177);
                        do
                        {
                          *(*(a6 + 8 * v193) + v178++) = v181;
                        }

                        while (v180 != v178);
                      }

                      LODWORD(v178) = v180;
                      v177 = v179;
                    }

                    while (v179 < v61);
                  }

                  v24 = *(v204 + v172);
                  v26 = v205;
                  if (v205)
                  {
                    *(v204 + v202) = v24;
                    *(v197 + v202) = *(v197 + v172);
                  }

                  v201 = v202 + v205;
                  a4 = v206;
                  v10 = a1;
                  v25 = v198;
                  goto LABEL_292;
                }

                v163 = &v216[1] + 12;
                v164 = v61;
                do
                {
                  v165 = *v163;
                  if (v208)
                  {
                    v166 = a3[1];
                    if (1 - v166 <= 0)
                    {
                      LOBYTE(v167) = 0;
                      v169 = *a3;
                    }

                    else
                    {
                      if (v166 == -31)
                      {
                        LOBYTE(v167) = 0;
                      }

                      else
                      {
                        v167 = *a3 << (1 - v166);
                      }

                      v169 = CDK_get32((a3 + 2));
                      *a3 = v169;
                      v166 = a3[1] + 32;
                    }

                    v170 = v166 - 1;
                    a3[1] = v170;
                    v168 = (((v169 >> v170) | v167) & 1 | (2 * v165)) - v209;
                  }

                  else
                  {
                    v168 = v165 - v209;
                  }

                  *v163++ = v168;
                  --v164;
                }

                while (v164);
LABEL_272:
                CDKmemcpy(v195, v216, v61);
                if (v205)
                {
                  CDKmemcpy((v191 + 28 * v202), &v216[1] + 12, v61);
                }

                goto LABEL_274;
              }
            }

            if (v115)
            {
              LOBYTE(v216[0]) = v214[0];
              v151 = 1;
            }

            else
            {
              v151 = 0;
            }

            if (v151 <= v51)
            {
              v152 = v61 - v151;
              v153 = (v216 | v151);
              v154 = (v214 | v151);
              do
              {
                v155 = *v154++;
                *v153 = v153[28] - v155;
                ++v153;
                --v152;
              }

              while (v152);
            }

            goto LABEL_248;
          }
        }
      }

      else
      {
        v115 = v91 != v196 && v90;
        v116 = v208;
      }

      if (v91)
      {
        v117 = 0;
        do
        {
          *(v212 + v117) = (*(v190 + v117) + v89) >> v116;
          ++v117;
        }

        while (v61 != v117);
        if (v115)
        {
          LOBYTE(v216[0]) = v214[0];
          v118 = 1;
        }

        else
        {
          v118 = 0;
        }

        if (v118 <= v51)
        {
          v124 = v61 - v118;
          v125 = (v216 | v118);
          v126 = (v214 | v118);
          v127 = (v212 | v118);
          do
          {
            v129 = *v127++;
            v128 = v129;
            v130 = *v126++;
            *v125++ = v130 + v128;
            --v124;
          }

          while (v124);
        }
      }

      else
      {
        v119 = LOBYTE(v214[0]);
        LOBYTE(v216[0]) = v214[0];
        if (v51 >= 1)
        {
          v120 = v61 - 1;
          v121 = v216 + 1;
          v122 = v214 + 1;
          do
          {
            v123 = *v122++;
            v119 += v123;
            *v121++ = v119;
            --v120;
          }

          while (v120);
        }
      }

      if (v196)
      {
        if (v115)
        {
          BYTE12(v216[1]) = BYTE12(v214[1]);
          v131 = 1;
        }

        else
        {
          v131 = 0;
        }

        if (v131 <= v51)
        {
          v137 = v61 - v131;
          v138 = (v216 | v131);
          v139 = &v214[1] + v131 + 12;
          do
          {
            v140 = *v139++;
            v138[28] = v140 + *v138;
            ++v138;
            --v137;
          }

          while (v137);
        }
      }

      else
      {
        v132 = BYTE12(v214[1]);
        BYTE12(v216[1]) = BYTE12(v214[1]);
        if (v51 >= 1)
        {
          v133 = v61 - 1;
          v134 = &v216[1] + 13;
          v135 = &v214[1] + 13;
          do
          {
            v136 = *v135++;
            v132 += v136;
            *v134++ = v132;
            --v133;
          }

          while (v133);
        }
      }

      goto LABEL_248;
    }

    if (v205)
    {
      if (2 - v79 < 1)
      {
        v93 = 0;
      }

      else
      {
        if (v79 == -30)
        {
          v93 = 0;
        }

        else
        {
          v93 = v78 << (2 - v79);
        }

        v78 = CDK_get32((a3 + 2));
        *a3 = v78;
        v87 = a3[1] + 32;
      }

      v92 = v192;
      a3[1] = v87 - 1;
      v186 = ((v78 >> (v87 - 1)) | v93) & 1;
      if (v186)
      {
        v94 = v196;
        if (v192 && v196)
        {
          v95 = v214;
          v96 = v51 + 1;
          v97 = 28;
        }

        else
        {
          v220 = v214;
          v221 = &v214[1] + 12;
          v94 = v196;
          v96 = v51;
          v95 = v214 + 1;
          v97 = 29;
        }

        v188 = v97;
        v108 = v96;
        if (huff_dec_2D(a3, v200, v192 | v94, 1u, v222, v96, 1u, &v220))
        {
          return 0xFFFFFFFFLL;
        }

        if (v108 < 1)
        {
          v89 = v209;
          v91 = v192;
        }

        else
        {
          v109 = v108;
          v110 = v214 + v188;
          v111 = v222 + 1;
          v91 = v192;
          do
          {
            *v95++ = *(v111 - 1);
            v112 = *v111;
            v111 += 2;
            *v110++ = v112;
            --v109;
          }

          while (v109);
          v89 = v209;
        }

LABEL_187:
        v90 = (v186 & 0xF) == 1;
        goto LABEL_188;
      }
    }

    else
    {
      LOBYTE(v186) = 16;
      v92 = v192;
    }

    if (v92)
    {
      v98 = v214;
      v99 = v51 + 1;
    }

    else
    {
      v220 = v214;
      v221 = 0;
      v99 = v51;
      v98 = v214 + 1;
    }

    if (v205)
    {
      v100 = v51 + 1;
      v184 = &v214[1] + 12;
      if (!v196)
      {
        v218 = 0;
        v219 = &v214[1] + 12;
        v100 = v51;
        v184 = &v214[1] + 13;
      }

      v183 = (v100 & 1) == 0;
      v187 = v100 & 0xFFFFFFFE;
    }

    else
    {
      v184 = 0;
      v183 = 1;
      v187 = v51 + 1;
    }

    v101 = v99;
    v185 = v99 & 0xFFFFFFFE;
    if (huff_dec_2D(a3, v200, v92, 0, v222, v99 & 0xFFFFFFFE, 2u, &v220) || (v101 & 1) != 0 && huff_dec_1D(a3, v200, v192, &v98[v185], 1, 0) || v205 && (huff_dec_2D(a3, v200, v196, 0, v222 + 2, v187, 2u, &v218) || !v183 && huff_dec_1D(a3, v200, v196, &v184[v187], 1, 0)))
    {
      return 0xFFFFFFFFLL;
    }

    if (v185 >= 2)
    {
      v102 = 0;
      v103 = v222 + 1;
      do
      {
        *&v98[v102] = *(v103 - 1);
        v102 += 2;
        v103 += 4;
      }

      while (v102 < (v185 - 1));
    }

    v89 = v209;
    v91 = v192;
    if (v205 && v187 >= 2)
    {
      v104 = 0;
      v105 = v222 + 3;
      do
      {
        v106 = &v184[v104];
        *v106 = *(v105 - 1);
        v107 = *v105;
        v105 += 4;
        v106[1] = v107;
        v104 += 2;
      }

      while (v104 < (v187 - 1));
    }

    goto LABEL_187;
  }

  return 4294966310;
}

uint64_t huff_dec_reshape(unsigned int *a1, uint64_t a2, int a3)
{
  v17 = 0;
  if (a3 < 1)
  {
    return 0;
  }

  v5 = 0;
  v6 = a2 + 8;
  while (1)
  {
    huff_read_2D(a1, &huffReshapeNodes, &v17, &v18);
    v7 = v5 + SHIBYTE(v17) + 1;
    if (v7 > a3)
    {
      break;
    }

    if (v5 < v7)
    {
      v8 = 0;
      v9 = v17;
      v10 = v7 - v5;
      v11 = (v10 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      v12 = vdupq_n_s64(v10 - 1);
      v13 = (v6 + 4 * v5);
      do
      {
        v14 = vdupq_n_s64(v8);
        v15 = vmovn_s64(vcgeq_u64(v12, vorrq_s8(v14, xmmword_19B0A5850)));
        if (vuzp1_s16(v15, *v12.i8).u8[0])
        {
          *(v13 - 2) = v9;
        }

        if (vuzp1_s16(v15, *&v12).i8[2])
        {
          *(v13 - 1) = v9;
        }

        if (vuzp1_s16(*&v12, vmovn_s64(vcgeq_u64(v12, vorrq_s8(v14, xmmword_19B0A5840)))).i32[1])
        {
          *v13 = v9;
          v13[1] = v9;
        }

        v8 += 4;
        v13 += 4;
      }

      while (v11 != v8);
    }

    v5 = v7;
    if (v7 >= a3)
    {
      return 0;
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t huff_read_2D(unsigned int *a1, uint64_t a2, _BYTE *a3, _DWORD *a4)
{
  v8 = 0;
  v9 = a1[1];
  do
  {
    if (1 - v9 <= 0)
    {
      LOBYTE(v10) = 0;
      result = *a1;
    }

    else
    {
      if (v9 == -31)
      {
        LOBYTE(v10) = 0;
      }

      else
      {
        v10 = *a1 << (1 - v9);
      }

      result = CDK_get32((a1 + 2));
      *a1 = result;
      v9 = a1[1] + 32;
    }

    a1[1] = --v9;
    v8 = *(a2 + 4 * v8 + 2 * (((result >> v9) | v10) & 1));
  }

  while (v8 > 0);
  *a4 = v8 == 0;
  v12 = ~v8 >> 4;
  v13 = ~v8 & 0xF;
  if (!v8)
  {
    LOBYTE(v12) = 0;
    v13 = 1;
  }

  *a3 = v12;
  a3[1] = v13;
  return result;
}

uint64_t longdiv(uint64_t result, unsigned int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "void longdiv(USHORT *, USHORT, USHORT *, USHORT *, int)";
    exception[2] = 71;
  }

  v4 = 0;
  for (i = 4; i != -1; --i)
  {
    v6 = *(result + i * 2) | (v4 << 16);
    if (v6)
    {
      v7 = v6 / a2;
      v4 = v6 % a2;
    }

    else
    {
      LOWORD(v7) = 0;
    }

    a3[i] = v7;
  }

  *a4 = v4;
  return result;
}

uint64_t pcm_decode(unsigned int *a1, uint64_t a2, uint64_t a3, char a4, int a5, int a6)
{
  v49 = *MEMORY[0x1E69E9840];
  memset(v47, 0, sizeof(v47));
  v48 = 0;
  result = 0xFFFFFFFFLL;
  if (a6 > 14)
  {
    if (a6 <= 25)
    {
      if ((a6 - 15) >= 2)
      {
        if (a6 != 19)
        {
          if (a6 != 25)
          {
            return result;
          }

          v10 = 3;
          goto LABEL_21;
        }

        goto LABEL_19;
      }

      goto LABEL_20;
    }

    if (a6 != 26 && a6 != 31)
    {
      if (a6 != 51)
      {
        return result;
      }

LABEL_19:
      v10 = 4;
      goto LABEL_21;
    }

LABEL_20:
    v10 = 1;
    goto LABEL_21;
  }

  if (a6 > 7)
  {
    if (a6 == 8)
    {
      goto LABEL_20;
    }

    if (a6 != 11)
    {
      if (a6 != 13)
      {
        return result;
      }

      goto LABEL_19;
    }

    v10 = 2;
  }

  else
  {
    if (a6 != 3)
    {
      if (a6 != 4)
      {
        if (a6 != 7)
        {
          return result;
        }

        v10 = 6;
        goto LABEL_21;
      }

      goto LABEL_20;
    }

    v10 = 5;
  }

LABEL_21:
  v11 = 1;
  v12 = 1;
  do
  {
    v12 *= a6;
    if (v12 >= 2)
    {
      v13 = 0;
      v14 = v12 - 1;
      do
      {
        ++v13;
        v15 = v14 > 1;
        v14 >>= 1;
      }

      while (v15);
    }

    else
    {
      v13 = 0;
    }

    *(v47 + v11++) = v13;
  }

  while (v11 != v10 + 1);
  if (a5 >= 1)
  {
    v16 = 0;
    if (a3)
    {
      v17 = a3;
    }

    else
    {
      v17 = a2;
    }

    if (a2)
    {
      v18 = a3 == 0;
    }

    else
    {
      v18 = 1;
    }

    v19 = a5;
    v42 = -v10;
    v43 = v10;
    v20 = -1;
    v41 = a5;
    v39 = a2;
    v40 = a3;
    v38 = v10;
    do
    {
      v21 = v43;
      if (v19 < v43)
      {
        v21 = v19;
      }

      if (v21 <= 1)
      {
        v22 = 1;
      }

      else
      {
        v22 = v21;
      }

      if (v10 >= v19)
      {
        v23 = v19;
      }

      else
      {
        v23 = v10;
      }

      v24 = a5 - v16;
      if (v10 >= a5 - v16)
      {
        v25 = a5 - v16;
      }

      else
      {
        v25 = v10;
      }

      v26 = *(v47 + v25);
      if (v26 >= 0x21)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = "UINT CDKreadBits(HANDLE_CDK_BITSTREAM, const UINT)";
        exception[2] = 143;
      }

      v27 = a1[1];
      v28 = v26 - v27;
      if (v26 - v27 <= 0)
      {
        v29 = 0;
        v30 = *a1;
      }

      else
      {
        v45 = v23;
        v46 = v20;
        if (v28 == 32)
        {
          v44 = 0;
        }

        else
        {
          v44 = *a1 << v28;
        }

        v30 = CDK_get32((a1 + 2));
        *a1 = v30;
        v27 = a1[1] + 32;
        a5 = v41;
        a2 = v39;
        a3 = v40;
        v10 = v38;
        v23 = v45;
        v20 = v46;
        v29 = v44;
      }

      v31 = v27 - v26;
      a1[1] = v27 - v26;
      if (v24 >= 1)
      {
        v32 = v23 + v20;
        v33 = ((v30 >> v31) | v29) & BitMask[v26];
        do
        {
          v34 = v32;
          v35 = v17;
          if (!v18)
          {
            v34 = v32 >> 1;
            if (v32)
            {
              v34 = v32 / 2;
              v35 = a3;
            }

            else
            {
              v35 = a2;
            }
          }

          v36 = v33 - a4;
          v33 /= a6;
          *(v35 + v34) = v36 - v33 * a6;
          --v32;
          --v22;
        }

        while (v22);
      }

      v16 += v10;
      v19 += v42;
      v20 += v10;
    }

    while (v16 < a5);
  }

  return 0;
}

uint64_t huff_dec_1D(int *a1, int a2, unsigned int a3, _BYTE *a4, int a5, int a6)
{
  if (a2 == 2)
  {
    v10 = &huffIPDNodes + 28 * a3;
    v11 = &unk_19B3C95C0;
    if (a6)
    {
      goto LABEL_6;
    }

    goto LABEL_16;
  }

  if (a2 != 1)
  {
    v10 = *(&huffCLDNodes + a3);
    v11 = &huffPart0Nodes;
    if (a6)
    {
      goto LABEL_6;
    }

LABEL_16:
    v16 = 0;
    goto LABEL_17;
  }

  v10 = *(&huffICCNodes + a3);
  v11 = &unk_19B3C95A4;
  if (!a6)
  {
    goto LABEL_16;
  }

LABEL_6:
  v12 = 0;
  v13 = a1[1];
  do
  {
    if (1 - v13 <= 0)
    {
      LOBYTE(v14) = 0;
      v15 = *a1;
    }

    else
    {
      if (v13 == -31)
      {
        LOBYTE(v14) = 0;
      }

      else
      {
        v14 = *a1 << (1 - v13);
      }

      v15 = CDK_get32((a1 + 2));
      *a1 = v15;
      v13 = a1[1] + 32;
    }

    a1[1] = --v13;
    v12 = v11[2 * v12 + (((v15 >> v13) | v14) & 1)];
  }

  while (v12 > 0);
  *a4 = ~v12;
  v16 = 1;
LABEL_17:
  if (v16 >= a5)
  {
    return 0;
  }

  v17 = v16;
  while (1)
  {
    v18 = a1[1];
    if (a1[12])
    {
      if (v18)
      {
        CDK_put((a1 + 2), *a1, v18);
      }
    }

    else
    {
      v19 = a1[6];
      v20 = a1[5] - v18;
      a1[2] += v18;
      v21 = (a1[11] - 1) & (v19 - v18);
      a1[5] = v20;
      a1[6] = v21;
    }

    *a1 = 0;
    if (a1[2] < 1)
    {
      break;
    }

    v22 = 0;
    v23 = 0;
    v24 = 0;
    do
    {
      if (1 - v23 < 1)
      {
        v25 = 0;
      }

      else
      {
        if (v23 == -31)
        {
          v25 = 0;
        }

        else
        {
          v25 = v22 << (1 - v23);
        }

        v22 = CDK_get32((a1 + 2));
        *a1 = v22;
        v23 = a1[1] + 32;
      }

      a1[1] = --v23;
      v24 = *&v10[4 * v24 + 2 * (((v22 >> v23) | v25) & 1)];
    }

    while (v24 > 0);
    v26 = ~v24;
    if (a2 != 2 && v24 != -1)
    {
      if (a1[12])
      {
        if (v23)
        {
          CDK_put((a1 + 2), v22, v23);
        }
      }

      else
      {
        v27 = a1[6];
        v28 = a1[5] - v23;
        a1[2] += v23;
        v29 = (a1[11] - 1) & (v27 - v23);
        a1[5] = v28;
        a1[6] = v29;
      }

      *a1 = 0;
      if (a1[2] < 1)
      {
        return 0xFFFFFFFFLL;
      }

      v30 = v24 + 1;
      v31 = CDK_get32((a1 + 2));
      v32 = a1[1] + 31;
      *a1 = v31;
      a1[1] = v32;
      if ((v31 >> v32))
      {
        v26 = v30;
      }
    }

    a4[v17++] = v26;
    if (v17 == a5)
    {
      return 0;
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t huff_dec_2D(unsigned int *a1, int a2, unsigned int a3, unsigned int a4, char *a5, int a6, unsigned int a7, _BYTE **a8)
{
  v14 = 0;
  v62 = *MEMORY[0x1E69E9840];
  v58 = 0;
  v61 = 0;
  memset(v60, 0, sizeof(v60));
  memset(v59, 0, sizeof(v59));
  v15 = a1[1];
  do
  {
    if (1 - v15 <= 0)
    {
      LOBYTE(v16) = 0;
      v17 = *a1;
    }

    else
    {
      if (v15 == -31)
      {
        LOBYTE(v16) = 0;
      }

      else
      {
        v16 = *a1 << (1 - v15);
      }

      v17 = CDK_get32((a1 + 2));
      *a1 = v17;
      v15 = a1[1] + 32;
    }

    a1[1] = --v15;
    v14 = huffLavIdxNodes[2 * v14 + (((v17 >> v15) | v16) & 1)];
  }

  while (v14 > 0);
  v18 = ~v14;
  v57 = a2;
  if (a2 == 2)
  {
    v21 = 2 * v18 - 1;
    if (v14 == -1)
    {
      v19 = 7;
    }

    else
    {
      v19 = v21;
    }

    v20 = &unk_19B3C95C0;
  }

  else if (a2 == 1)
  {
    v19 = (2 * v18) | 1;
    v20 = &unk_19B3C95A4;
  }

  else
  {
    v19 = 2 * v18 + 3;
    v20 = &huffPart0Nodes;
  }

  if (*a8)
  {
    v22 = 0;
    do
    {
      if (1 - v15 < 1)
      {
        v23 = 0;
      }

      else
      {
        if (v15 == -31)
        {
          v23 = 0;
        }

        else
        {
          v23 = v17 << (1 - v15);
        }

        v17 = CDK_get32((a1 + 2));
        *a1 = v17;
        v15 = a1[1] + 32;
      }

      a1[1] = --v15;
      v22 = *&v20[4 * v22 + 2 * (((v17 >> v15) | v23) & 1)];
    }

    while (v22 > 0);
    **a8 = ~v22;
  }

  if (a8[1])
  {
    v24 = 0;
    v25 = a1[1];
    do
    {
      if (1 - v25 <= 0)
      {
        LOBYTE(v26) = 0;
        v27 = *a1;
      }

      else
      {
        if (v25 == -31)
        {
          LOBYTE(v26) = 0;
        }

        else
        {
          v26 = *a1 << (1 - v25);
        }

        v27 = CDK_get32((a1 + 2));
        *a1 = v27;
        v25 = a1[1] + 32;
      }

      a1[1] = --v25;
      v24 = *&v20[4 * v24 + 2 * (((v27 >> v25) | v26) & 1)];
    }

    while (v24 > 0);
    *a8[1] = ~v24;
  }

  if (v57 == 2)
  {
    if (v19 > 4)
    {
      if (v19 == 5)
      {
        v20 = &huffIPDNodes + 928 * a3 + 464 * a4 + 156;
      }

      else if (v19 == 7)
      {
        v20 = &huffIPDNodes + 928 * a3 + 464 * a4 + 296;
      }
    }

    else if (v19 == 1)
    {
      v20 = &huffIPDNodes + 928 * a3 + 464 * a4 + 84;
    }

    else if (v19 == 3)
    {
      v20 = &huffIPDNodes + 928 * a3 + 464 * a4 + 96;
    }

    goto LABEL_67;
  }

  if (v57 == 1)
  {
    if (v19 > 4)
    {
      if (v19 == 5)
      {
        v20 = *(&huffICCNodes + 2 * a3 + a4 + 3) + 72;
      }

      else if (v19 == 7)
      {
        v20 = *(&huffICCNodes + 2 * a3 + a4 + 3) + 212;
      }

      goto LABEL_67;
    }

    if (v19 != 1)
    {
      if (v19 == 3)
      {
        v20 = *(&huffICCNodes + 2 * a3 + a4 + 3) + 12;
      }

      goto LABEL_67;
    }

    v28 = &huffICCNodes;
  }

  else
  {
    if (v19 > 6)
    {
      if (v19 == 7)
      {
        v20 = *(&huffCLDNodes + 2 * a3 + a4 + 3) + 200;
      }

      else if (v19 == 9)
      {
        v20 = *(&huffCLDNodes + 2 * a3 + a4 + 3) + 452;
      }

      goto LABEL_67;
    }

    if (v19 != 3)
    {
      if (v19 == 5)
      {
        v20 = *(&huffCLDNodes + 2 * a3 + a4 + 3) + 60;
      }

      goto LABEL_67;
    }

    v28 = &huffCLDNodes;
  }

  v20 = *(&v28[2 * a3 + 3] + a4);
LABEL_67:
  if (a6 < 1)
  {
    return 0;
  }

  v29 = a6;
  v30 = 0;
  v31 = 0;
  v56 = (2 * v19) | 1;
  v32 = a5;
  v33 = v29;
  do
  {
    huff_read_2D(a1, v20, v32, &v58);
    if (v58)
    {
      *(v59 + v31++) = v30;
      goto LABEL_95;
    }

    v37 = *v32;
    v34 = v32[1];
    v35 = v34 + v37;
    v36 = v37 - v34;
    LOBYTE(v37) = v56 - v35;
    if (v35 > v19)
    {
      v36 = -v36;
    }

    else
    {
      LOBYTE(v37) = v35;
    }

    *v32 = v37;
    v32[1] = v36;
    if (v57 == 2)
    {
      if (v36 == v37)
      {
        goto LABEL_95;
      }

LABEL_87:
      v43 = a1[1];
      if (1 - v43 <= 0)
      {
        v44 = 0;
        v45 = *a1;
      }

      else
      {
        if (v43 == -31)
        {
          v44 = 0;
        }

        else
        {
          v44 = *a1 << (1 - v43);
        }

        v45 = CDK_get32((a1 + 2));
        *a1 = v45;
        v43 = a1[1] + 32;
      }

      v46 = v43 - 1;
      a1[1] = v46;
      if (((v45 >> v46) | v44))
      {
        v47 = *v32;
        *v32 = v32[1];
        v32[1] = v47;
      }

      goto LABEL_95;
    }

    if (v36 + v37)
    {
      v38 = a1[1];
      if (1 - v38 <= 0)
      {
        v39 = 0;
        v40 = *a1;
      }

      else
      {
        v39 = v38 == -31 ? 0 : *a1 << (1 - v38);
        v40 = CDK_get32((a1 + 2));
        *a1 = v40;
        v38 = a1[1] + 32;
      }

      v41 = v38 - 1;
      a1[1] = v41;
      v42 = (v40 >> v41) | v39;
      v37 = *v32;
      v36 = v32[1];
      if (v42)
      {
        v37 = -v37;
        *v32 = v37;
        v36 = -v36;
        v32[1] = v36;
      }
    }

    if (v37 != v36)
    {
      goto LABEL_87;
    }

LABEL_95:
    v30 += a7;
    v32 += 2 * a7;
  }

  while (v30 < v33);
  if (v31 >= 1)
  {
    if (pcm_decode(a1, v60, &v60[1] + 12, 0, 2 * v31, v56))
    {
      return 0xFFFFFFFFLL;
    }

    v49 = v31;
    v50 = v60;
    v51 = v59;
    do
    {
      v52 = *v51++;
      v53 = &a5[2 * v52];
      *v53 = *v50 - v19;
      v53[1] = v50[28] - v19;
      ++v50;
      --v49;
    }

    while (v49);
  }

  return 0;
}

uint64_t transportDec_readHeader(int *a1, __int128 *a2, int a3, int *a4, int *a5, int *a6, int *a7, _DWORD *a8, uint64_t a9)
{
  if (a5)
  {
    v67 = *a5;
    if (a6)
    {
      goto LABEL_3;
    }

LABEL_6:
    v69 = 0;
    if (a7)
    {
      goto LABEL_4;
    }

    goto LABEL_7;
  }

  v67 = 0;
  if (!a6)
  {
    goto LABEL_6;
  }

LABEL_3:
  v69 = *a6;
  if (a7)
  {
LABEL_4:
    v16 = *a7;
    goto LABEL_8;
  }

LABEL_7:
  v16 = 0;
LABEL_8:
  v17 = *a4;
  v70 = v16;
  if (*(a2 + 12))
  {
    v18 = *(a2 + 1);
    if (v18)
    {
      CDK_put(a2 + 8, *a2, v18);
    }
  }

  else
  {
    v19 = *(a2 + 1);
    v20 = *(a2 + 6);
    v21 = *(a2 + 5) - v19;
    *(a2 + 2) += v19;
    v22 = (*(a2 + 11) - 1) & (v20 - v19);
    *(a2 + 5) = v21;
    *(a2 + 6) = v22;
  }

  *a2 = 0;
  v68 = *(a2 + 2);
  if ((*a1 - 6) >= 2)
  {
    if (*a1 != 10)
    {
      v27 = 0;
      v69 = 0;
      goto LABEL_75;
    }

    if (a1[722] <= 0)
    {
      v23 = CDK_get32(a2 + 8);
      v24 = *(a2 + 1) + 19;
      *a2 = v23;
      *(a2 + 1) = v24;
      v25 = (v23 >> v24) & 0x1FFF;
      a1[48] = v25;
      v69 = 8 * v25;
    }
  }

  if (a1[722] <= 0)
  {
    v28 = *(a2 + 1);
    if (*(a2 + 12))
    {
      if (!v28)
      {
        *a2 = 0;
        v30 = *(a2 + 2);
        a1[719] = v30;
        v31 = (a1 + 42);
        v32 = *a1;
        v33 = a1 + 2;
        v34 = (a1 + 53);
LABEL_27:
        *a2 = 0;
        if (v30 < 9)
        {
LABEL_28:
          v26 = 0;
          v27 = 257;
          goto LABEL_74;
        }

        v64 = v30;
        if (v32 == 7)
        {
          goto LABEL_46;
        }

        v62 = v33;
        v63 = v34;
        v65 = v31;
        v38 = CDK_get32(a2 + 8);
        v31 = v65;
        v39 = *(a2 + 1) + 31;
        *a2 = v38;
        *(a2 + 1) = v39;
        v40 = v38 >> v39;
        *(a1 + 196) = v40 & 1;
        if (v40)
        {
          goto LABEL_46;
        }

        v41 = a9;
        if (!*(a1 + 207))
        {
          v44 = a2[1];
          v71 = *a2;
          v72 = v44;
          v73 = a2[2];
          v74 = *(a2 + 6);
          *(a1 + 208) = 0;
          v43 = CLatmDemux_ReadStreamMuxConfig(a2, v65, v62, v63, &v70, 1, 0, a9);
          if (v43)
          {
LABEL_44:
            v27 = v43;
            goto LABEL_56;
          }

          v41 = a9;
          if (*(a1 + 245) && *(a1 + 208))
          {
            *(a1 + 207) = 0;
LABEL_45:
            v16 = v70;
            v31 = v65;
LABEL_46:
            if (!v16)
            {
              LODWORD(v27) = 258;
              goto LABEL_50;
            }

            if (*(a1 + 198))
            {
              v70 = 0;
              LODWORD(v27) = 1026;
              goto LABEL_50;
            }

            PayloadLengthInfo = CLatmDemux_ReadPayloadLengthInfo(a2, v31);
            if (!PayloadLengthInfo)
            {
              if (!a3)
              {
                v49 = a1[43];
                if (v49 != 255 && !*(a1 + 205))
                {
                  if (v64 < ((32 * v49 * *(a1 + 1008)) | 0x18u))
                  {
                    goto LABEL_28;
                  }

                  *(a1 + 205) = 1;
                }
              }

              goto LABEL_64;
            }

            v27 = PayloadLengthInfo;
            v70 = 0;
LABEL_56:
            *(a1 + 207) = 1;
            if (v27)
            {
              if (v27 == 257)
              {
                v26 = 0;
                goto LABEL_74;
              }

LABEL_51:
              v26 = 0;
              if ((v27 - 512) >= 6)
              {
                v27 = 258;
              }

              else
              {
                v27 = v27;
              }

              goto LABEL_74;
            }

LABEL_64:
            a1[722] = *(a1 + 200);
            if (*a1 == 10)
            {
              v50 = *(a2 + 1);
              if (*(a2 + 12))
              {
                if (v50)
                {
                  CDK_put(a2 + 8, *a2, v50);
                }
              }

              else
              {
                v51 = *(a2 + 6);
                v52 = *(a2 + 5) - v50;
                *(a2 + 2) += v50;
                v53 = (*(a2 + 11) - 1) & (v51 - v50);
                *(a2 + 5) = v52;
                *(a2 + 6) = v53;
              }

              *a2 = 0;
              v69 = v69 - v68 + *(a2 + 2) + 13;
            }

            goto LABEL_70;
          }

          v61 = v72;
          *a2 = v71;
          a2[1] = v61;
          a2[2] = v73;
          *(a2 + 6) = v74;
          *(a1 + 207) = 1;
          v31 = v65;
        }

        v42 = a2[1];
        v75 = *a2;
        v76 = v42;
        v77 = a2[2];
        v78 = *(a2 + 6);
        v43 = CLatmDemux_ReadStreamMuxConfig(a2, v31, v62, v63, &v70, 1, 0, v41);
        if (v43)
        {
          goto LABEL_44;
        }

        if (*(a1 + 1019) || *(a1 + 1020) || *(a1 + 1021))
        {
          if ((*(a1 + 3))(*(a1 + 4), v63))
          {
            LODWORD(v27) = 1025;
LABEL_50:
            *(a1 + 207) = 1;
            goto LABEL_51;
          }

          v45 = 1;
          v46 = v63;
        }

        else
        {
          v45 = 0;
          v46 = v63;
        }

        v47 = v76;
        *a2 = v75;
        a2[1] = v47;
        a2[2] = v77;
        *(a2 + 6) = v78;
        v43 = CLatmDemux_ReadStreamMuxConfig(a2, v65, v62, v46, &v70, 2, v45, a9);
        if (v43)
        {
          goto LABEL_44;
        }

        goto LABEL_45;
      }

      CDK_put(a2 + 8, *a2, v28);
      v29 = *(a2 + 12);
      *a2 = 0;
      v30 = *(a2 + 2);
      a1[719] = v30;
      v31 = (a1 + 42);
      v32 = *a1;
      v33 = a1 + 2;
      v34 = (a1 + 53);
      if (v29)
      {
        goto LABEL_27;
      }
    }

    else
    {
      v35 = *(a2 + 6);
      v36 = *(a2 + 5) - v28;
      v30 = *(a2 + 2) + v28;
      *(a2 + 2) = v30;
      v37 = (*(a2 + 11) - 1) & (v35 - v28);
      *(a2 + 5) = v36;
      *(a2 + 6) = v37;
      *a2 = 0;
      a1[719] = v30;
      v31 = (a1 + 42);
      v32 = *a1;
      v33 = a1 + 2;
      v34 = (a1 + 53);
    }

    *(a2 + 2) = v30;
    *(a2 + 6) &= *(a2 + 11) - 1;
    goto LABEL_27;
  }

  if (!CLatmDemux_ReadPayloadLengthInfo(a2, (a1 + 42)))
  {
LABEL_70:
    v54 = 0;
    v17 = 0;
    for (i = a1 + 45; *(a1 + 201); i += 4)
    {
      if (v54 >= *(a1 + 202))
      {
        break;
      }

      v17 += *i;
      ++v54;
    }

    v27 = 0;
    v26 = a1[722] - 1;
    goto LABEL_74;
  }

  v26 = 0;
  v27 = 258;
LABEL_74:
  a1[722] = v26;
LABEL_75:
  *a4 = v17;
  if (a8)
  {
    v56 = *(a2 + 1);
    if (*(a2 + 12))
    {
      if (v56)
      {
        CDK_put(a2 + 8, *a2, v56);
      }
    }

    else
    {
      v57 = *(a2 + 6);
      v58 = *(a2 + 5) - v56;
      *(a2 + 2) += v56;
      v59 = (*(a2 + 11) - 1) & (v57 - v56);
      *(a2 + 5) = v58;
      *(a2 + 6) = v59;
    }

    *a2 = 0;
    *a8 += v68 - *(a2 + 2);
  }

  if (v27 && *(a1 + 2872))
  {
    a1[722] = 0;
    a1[717] = 0;
    *(a1 + 2871) = 0;
    (*(a1 + 5))(*(a1 + 6));
  }

  if (a7)
  {
    *a7 = v70;
  }

  if (a5)
  {
    *a5 = v67;
  }

  if (a6)
  {
    *a6 = v69;
  }

  return v27;
}

uint64_t synchronization(int *a1, int *a2, uint64_t a3)
{
  v195 = *MEMORY[0x1E69E9840];
  v192 = 0;
  v191 = 0;
  v5 = a1[729];
  v189 = v5 & 0x20;
  *&v6 = 0xAAAAAAAAAAAAAAAALL;
  *(&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *&v194[12] = v6;
  v193 = v6;
  *v194 = v6;
  if (a1[38])
  {
    v7 = a1[27];
    if (v7)
    {
      CDK_put((a1 + 28), a1[26], v7);
    }
  }

  else
  {
    v8 = a1[27];
    v9 = a1[32];
    v10 = a1[31] - v8;
    a1[28] += v8;
    v11 = (a1[37] - 1) & (v9 - v8);
    a1[31] = v10;
    a1[32] = v11;
  }

  v13 = a1 + 28;
  v12 = a1[28];
  *(a1 + 13) = 0;
  if (v12 < 1)
  {
    v19 = 257;
LABEL_118:
    a1[721] = v192;
    goto LABEL_227;
  }

  v178 = a2;
  v179 = 0;
  v180 = 0;
  v177 = 0;
  v184 = v5 & 0x15;
  v14 = (a1[729] & 0xA) != 0 && (a1[729] & 1) == 0;
  v190 = v14;
  v181 = 0;
  v182 = *a1;
  if (*a1 == 10)
  {
    v15 = 11;
  }

  else
  {
    v15 = 0;
  }

  if (*a1 == 10)
  {
    v16 = 695;
  }

  else
  {
    v16 = 0;
  }

  v185 = -1;
  v17 = v15 + 8;
LABEL_16:
  v18 = 0;
  v19 = 0;
  while (1)
  {
    v186 = v191;
    if (a1[38])
    {
      if (v18)
      {
        CDK_put((a1 + 28), a1[26], v18);
      }
    }

    else
    {
      v20 = a1[32];
      v21 = a1[31] - v18;
      a1[28] += v18;
      v22 = (a1[37] - 1) & (v20 - v18);
      a1[31] = v21;
      a1[32] = v22;
    }

    *(a1 + 13) = 0;
    v23 = a1[28];
    v188 = a1[722];
    if (!v188)
    {
      break;
    }

    v24 = 0;
    v191 = 0;
    v187 = v192;
    if (!v19)
    {
      goto LABEL_41;
    }

LABEL_43:
    if (v19 == 258)
    {
      goto LABEL_47;
    }

    if (v19 == 257)
    {
      goto LABEL_128;
    }

    v31 = 0;
LABEL_76:
    if (v190)
    {
      if ((a1[729] & 0xA) == 8)
      {
        if (v19)
        {
          v56 = v185;
        }

        else
        {
          v56 = v185;
          if (v185 == -1)
          {
            v57 = a1[27];
            if (a1[38])
            {
              if (v57)
              {
                CDK_put((a1 + 28), a1[26], v57);
                v24 = v191;
              }
            }

            else
            {
              v58 = a1[32];
              v59 = a1[31] - v57;
              a1[28] += v57;
              v60 = (a1[37] - 1) & (v58 - v57);
              a1[31] = v59;
              a1[32] = v60;
            }

            *(a1 + 13) = 0;
            v56 = a1[28];
            HIDWORD(v180) = a1[719];
            v181 = a1[722];
            LODWORD(v180) = v192;
            CDKmemcpy(&v193, a1 + 168, 0x2CuLL);
            HIDWORD(v179) = v24;
          }
        }

        v185 = v56;
        if (v56 != -1)
        {
          if (!(v189 | v19))
          {
            v184 = 1;
            if (!v19)
            {
              goto LABEL_97;
            }

LABEL_93:
            if (v190)
            {
              goto LABEL_96;
            }

            goto LABEL_94;
          }

          if (v31)
          {
            v83 = 0;
            v189 = 0;
            goto LABEL_167;
          }

          v84 = v56;
LABEL_131:
          v85 = a1[27];
          if (a1[38])
          {
            if (v85)
            {
              CDK_put((a1 + 28), a1[26], v85);
            }
          }

          else
          {
            v86 = a1[32];
            v87 = a1[31] - v85;
            a1[28] += v85;
            v88 = (a1[37] - 1) & (v86 - v85);
            a1[31] = v87;
            a1[32] = v88;
          }

          *(a1 + 13) = 0;
          v89 = *v13;
          v90 = *v13 - v84;
          if (v90 >= 0)
          {
            v91 = a1[31];
            v92 = a1[38];
            v93 = a1[37] - 1;
            if (v92)
            {
              v94 = -1;
            }

            else
            {
              v94 = a1[37] - 1;
            }

            v95 = a1[32] & v94;
            *(a1 + 13) = 0;
            v96 = v91 + v90;
            if (v92)
            {
              v97 = v90;
            }

            else
            {
              v97 = -v90;
            }

            a1[28] = v89 + v97;
            v98 = v93 & (v95 + v90);
            a1[31] = v96;
LABEL_165:
            a1[32] = v98;
            goto LABEL_166;
          }

          v99 = v84 - *v13;
          v100 = a1[38];
          if (v99 > 0x1F)
          {
            if (!v100)
            {
              v112 = a1[37];
              v111 = (v112 - 1) & a1[32];
              goto LABEL_162;
            }
          }

          else if (!v100)
          {
            v101 = a1[32];
            v102 = a1[31] + v90;
            a1[28] = v84;
            v103 = (a1[37] - 1) & (v101 + v90);
            a1[31] = v102;
            a1[32] = v103;
            *(a1 + 13) = 0;
LABEL_166:
            CDKmemcpy(a1 + 168, &v193, 0x2CuLL);
            v83 = 0;
            v19 = 0;
            a1[722] = v181;
            a1[719] = HIDWORD(v180);
            v191 = HIDWORD(v179);
            LODWORD(v192) = v180;
            goto LABEL_167;
          }

          v111 = a1[32];
          v112 = a1[37];
LABEL_162:
          v113 = a1[31];
          *(a1 + 13) = 0;
          v114 = v113 + v90;
          if (v100)
          {
            v99 = v90;
          }

          a1[28] = v89 + v99;
          v98 = (v112 - 1) & (v111 + v90);
          a1[31] = v114;
          goto LABEL_165;
        }

        v184 = 1;
        v185 = -1;
      }

      if (v19)
      {
        goto LABEL_93;
      }

LABEL_97:
      v61 = v192;
      v62 = a1[27];
      v63 = a1[38];
      v64 = v62 - v192;
      if (v62 > v192)
      {
        if (!v63)
        {
          LODWORD(v179) = v179 + 1;
          v65 = a1[28];
          v66 = a1[31];
          v67 = a1[32];
          v68 = a1[37] - 1;
          goto LABEL_110;
        }

LABEL_102:
        CDK_put((a1 + 28), a1[26], v62);
LABEL_104:
        v63 = a1[38];
        goto LABEL_105;
      }

      if (!v63)
      {
        v69 = a1[32];
        v70 = a1[31] - v62;
        a1[28] += v62;
        v71 = (a1[37] - 1) & (v69 - v62);
        a1[31] = v70;
        a1[32] = v71;
        goto LABEL_104;
      }

      if (v62)
      {
        goto LABEL_102;
      }

LABEL_105:
      *(a1 + 13) = 0;
      if (v63)
      {
        v72 = v61;
      }

      else
      {
        v72 = -v61;
      }

      v65 = a1[28] + v72;
      v73 = a1[32];
      v66 = a1[31] + v61;
      a1[28] = v65;
      v68 = a1[37] - 1;
      v67 = v68 & (v73 + v61);
      a1[31] = v66;
      a1[32] = v67;
      LODWORD(v179) = v179 + 1;
      if (v63)
      {
        goto LABEL_111;
      }

      v64 = 0;
LABEL_110:
      v65 += v64;
      a1[28] = v65;
      a1[31] = v66 - v64;
      a1[32] = v68 & (v67 - v64);
LABEL_111:
      *(a1 + 13) = 0;
      transportDec_AdjustEndOfAccessUnit(a1);
      v74 = a1[27];
      if (a1[38])
      {
        if (v74)
        {
          CDK_put((a1 + 28), a1[26], v74);
        }
      }

      else
      {
        v75 = a1[32];
        v76 = a1[31] - v74;
        a1[28] += v74;
        v77 = (a1[37] - 1) & (v75 - v74);
        a1[31] = v76;
        a1[32] = v77;
      }

      *(a1 + 13) = 0;
      v177 = v65 - *v13;
      if (!v190)
      {
        v19 = 0;
        goto LABEL_129;
      }

      goto LABEL_16;
    }

LABEL_94:
    if (v19 != 258)
    {
      goto LABEL_129;
    }

    if (a1[729])
    {
      v19 = 258;
      goto LABEL_129;
    }

LABEL_96:
    v18 = a1[27];
  }

  if ((v23 & 7) != 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = "TRANSPORTDEC_ERROR synchronization(HANDLE_TRANSPORTDEC, INT *, MPEG_D::USAC::DynRangeCompressor &)";
    exception[2] = 856;
  }

  if (v23 >= v17)
  {
    if (v182 == 10)
    {
      v25 = CDK_get32((a1 + 28));
      a1[26] = v25;
      v26 = a1[27] + 32;
    }

    else
    {
      v25 = 0;
      v26 = 0;
    }

    v27 = v26 - v15;
    a1[27] = v27;
    v28 = (v25 >> v27) & BitMask[v15];
    if ((a1[729] & 1) == 0)
    {
      if (v28 == v16)
      {
        v191 = v15;
        v187 = v192;
        v188 = a1[722];
        goto LABEL_41;
      }

      do
      {
        if (8 - v27 < 1)
        {
          v29 = 0;
        }

        else
        {
          if (v27 == -24)
          {
            v29 = 0;
          }

          else
          {
            v29 = v25 << (8 - v27);
          }

          v25 = CDK_get32((a1 + 28));
          a1[26] = v25;
          v27 = a1[27] + 32;
        }

        v27 -= 8;
        a1[27] = v27;
        v28 = ((v25 >> v27) | v29) | ~(-1 << v15) & (v28 << 8);
        v23 -= 8;
      }

      while (v23 >= v17 && v28 != v16);
    }

    v191 = v15;
    v24 = v15;
    v187 = v192;
    v188 = a1[722];
    if (v28 != v16)
    {
      goto LABEL_47;
    }

LABEL_41:
    v30 = transportDec_readHeader(a1, (a1 + 26), v184, &v192, &v190, &v192 + 1, &v189, &v191, a3);
    v19 = v30;
    v24 = v191;
    if ((v30 - 512) > 5)
    {
      if (v30)
      {
        goto LABEL_43;
      }

      if (HIDWORD(v192) + v191 <= 65529)
      {
        if (v23 - v191 < SHIDWORD(v192))
        {
          goto LABEL_128;
        }

        v31 = 0;
        v19 = 0;
        goto LABEL_76;
      }

LABEL_47:
      a1[722] = 0;
      if (v23 <= 0)
      {
        v32 = -(-v23 & 7);
      }

      else
      {
        v32 = v23 & 7;
      }

      v33 = v32 - v24;
      v34 = v32 - v24 + 8;
      if (v34 >= 0)
      {
        v35 = a1[27];
        v36 = a1[38];
        if (v35 <= v34)
        {
          if (!v36)
          {
            v44 = a1[32];
            v45 = a1[31] - v35;
            a1[28] += v35;
            v46 = (a1[37] - 1) & (v44 - v35);
            a1[31] = v45;
            a1[32] = v46;
            goto LABEL_66;
          }

          if (!v35)
          {
LABEL_66:
            *(a1 + 13) = 0;
            if (*(a1 + 152))
            {
              v47 = v34;
            }

            else
            {
              v47 = -8 - v33;
            }

            v48 = a1[32];
            v49 = a1[31] + v34;
            a1[28] += v47;
            v50 = (a1[37] - 1) & (v48 + v34);
            a1[31] = v49;
            a1[32] = v50;
            goto LABEL_75;
          }
        }

        else if (!v36)
        {
          a1[27] = v35 - v34;
LABEL_75:
          v24 = 0;
          v191 = 0;
          v19 = 258;
          v31 = 1;
          goto LABEL_76;
        }

        CDK_put((a1 + 28), a1[26], v35);
        goto LABEL_66;
      }

      v37 = -8 - v33;
      v38 = a1[27];
      v39 = v38 + -8 - v33;
      v40 = a1[38];
      if (v39 > 0x1F)
      {
        if (!v40)
        {
          v51 = a1[32];
          v52 = a1[31] - v38;
          a1[28] += v38;
          v53 = (a1[37] - 1) & (v51 - v38);
          a1[31] = v52;
          a1[32] = v53;
LABEL_71:
          *(a1 + 13) = 0;
          if (v40)
          {
            v54 = v33 + 8;
          }

          else
          {
            v54 = -8 - v33;
          }

          a1[28] += v54;
          v55 = (a1[37] - 1) & (a1[32] - v37);
          a1[31] -= v37;
          a1[32] = v55;
          goto LABEL_75;
        }
      }

      else if (!v40)
      {
        v41 = a1[32];
        v42 = a1[31] - v39;
        a1[28] += v39;
        v43 = (a1[37] - 1) & (v41 - v39);
        a1[31] = v42;
        a1[32] = v43;
        *(a1 + 13) = 0;
        goto LABEL_75;
      }

      if (v38)
      {
        CDK_put((a1 + 28), a1[26], v38);
        LOBYTE(v40) = *(a1 + 152);
      }

      goto LABEL_71;
    }

    if (v23 <= 0)
    {
      v78 = -(-v23 & 7);
    }

    else
    {
      v78 = v23 & 7;
    }

    v79 = v78 - v191;
    v80 = v78 - v191 + 8;
    if (v80 >= 0)
    {
      v81 = a1[27];
      v82 = a1[38];
      a2 = v178;
      if (v81 <= v80)
      {
        if (!v82)
        {
          v164 = a1[32];
          v165 = a1[31] - v81;
          a1[28] += v81;
          v166 = (a1[37] - 1) & (v164 - v81);
          a1[31] = v165;
          a1[32] = v166;
          goto LABEL_246;
        }

        if (!v81)
        {
LABEL_246:
          *(a1 + 13) = 0;
          if (*(a1 + 152))
          {
            v167 = v80;
          }

          else
          {
            v167 = -8 - v79;
          }

          v168 = a1[32];
          v169 = a1[31] + v80;
          a1[28] += v167;
          v170 = (a1[37] - 1) & (v168 + v80);
          a1[31] = v169;
          a1[32] = v170;
          goto LABEL_118;
        }
      }

      else if (!v82)
      {
        a1[27] = v81 - v80;
        goto LABEL_118;
      }

      CDK_put((a1 + 28), a1[26], v81);
      goto LABEL_246;
    }

    v104 = -8 - v79;
    v105 = a1[27];
    v106 = v105 + -8 - v79;
    v107 = a1[38];
    a2 = v178;
    if (v106 > 0x1F)
    {
      if (!v107)
      {
        v171 = a1[32];
        v172 = a1[31] - v105;
        a1[28] += v105;
        v173 = (a1[37] - 1) & (v171 - v105);
        a1[31] = v172;
        a1[32] = v173;
LABEL_251:
        *(a1 + 13) = 0;
        if (v107)
        {
          v174 = v79 + 8;
        }

        else
        {
          v174 = -8 - v79;
        }

        a1[28] += v174;
        v175 = (a1[37] - 1) & (a1[32] - v104);
        a1[31] -= v104;
        a1[32] = v175;
        goto LABEL_118;
      }
    }

    else if (!v107)
    {
      v108 = a1[32];
      v109 = a1[31] - v106;
      a1[28] += v106;
      v110 = (a1[37] - 1) & (v108 - v106);
      a1[31] = v109;
      a1[32] = v110;
      *(a1 + 13) = 0;
      goto LABEL_118;
    }

    if (v105)
    {
      CDK_put((a1 + 28), a1[26], v105);
      LOBYTE(v107) = *(a1 + 152);
    }

    goto LABEL_251;
  }

  v191 = 0;
  v187 = v192;
  v188 = 0;
LABEL_128:
  a1[722] = 0;
  v19 = 257;
LABEL_129:
  v83 = v179;
  v84 = v185;
  if (v185 != -1)
  {
    if (v189 | v19)
    {
      goto LABEL_131;
    }

    v19 = 0;
  }

LABEL_167:
  if (a1[729] & 0x15 | v19)
  {
    if (v19 == 257)
    {
      v115 = a1[27];
      v116 = v187;
      goto LABEL_191;
    }

LABEL_208:
    a1[728] = 0;
    if (v83 <= 0)
    {
      a1[721] = v192;
      a2 = v178;
      if (v19)
      {
        goto LABEL_227;
      }
    }

    else
    {
LABEL_209:
      v145 = a1[27];
      v132 = a1[38];
      v146 = v19 == 0;
      v116 = v187;
LABEL_210:
      v148 = v177 + v116;
      v149 = v145 + v177 + v116;
      if (v149 > 0x1F)
      {
        if (v132)
        {
          goto LABEL_215;
        }

        v153 = a1[32];
        v154 = a1[31] - v145;
        a1[28] += v145;
        v155 = (a1[37] - 1) & (v153 - v145);
        a1[31] = v154;
        a1[32] = v155;
      }

      else
      {
        if (!v132)
        {
          v150 = a1[32];
          v151 = a1[31] - v149;
          a1[28] += v149;
          v152 = (a1[37] - 1) & (v150 - v149);
          a1[31] = v151;
          a1[32] = v152;
          *(a1 + 13) = 0;
          if (!v146)
          {
            goto LABEL_213;
          }

LABEL_224:
          v116 = v192;
          goto LABEL_225;
        }

LABEL_215:
        if (v145)
        {
          CDK_put((a1 + 28), a1[26], v145);
          LOBYTE(v132) = *(a1 + 152);
        }
      }

      *(a1 + 13) = 0;
      if (v132)
      {
        v156 = -v148;
      }

      else
      {
        v156 = v177 + v116;
      }

      a1[28] += v156;
      v157 = (a1[37] - 1) & (a1[32] - v148);
      a1[31] -= v148;
      a1[32] = v157;
      if (v146)
      {
        goto LABEL_224;
      }

LABEL_213:
      a1[722] = v188;
      v191 = v186;
LABEL_225:
      a2 = v178;
      a1[721] = v116;
    }

    v19 = 0;
    a1[729] |= 1u;
    goto LABEL_227;
  }

  v117 = -1;
  if (*a1 <= 0xA && ((1 << *a1) & 0x4C0) != 0)
  {
    if (a1[43] == 255)
    {
      v117 = -1;
    }

    else
    {
      v117 = a1[43];
    }
  }

  v118 = a1[27];
  if (a1[38])
  {
    if (v118)
    {
      CDK_put((a1 + 28), a1[26], v118);
    }
  }

  else
  {
    v119 = a1[32];
    v120 = a1[31] - v118;
    a1[28] += v118;
    v121 = (a1[37] - 1) & (v119 - v118);
    a1[31] = v120;
    a1[32] = v121;
  }

  *(a1 + 13) = 0;
  v122 = a1[723];
  if (!v122 || (v123 = a1[727]) == 0)
  {
LABEL_207:
    v19 = 0;
    goto LABEL_208;
  }

  v124 = a1[248];
  if (!v124 || (v125 = a1[247]) == 0)
  {
    v127 = a1[728];
    v116 = v187;
    goto LABEL_190;
  }

  v126 = (1000 * v124 + v123 * v125 - 1) / (1000 * v124);
  v127 = a1[728];
  v128 = (v125 + v122 * v124 - 1) / v125;
  v116 = v187;
  if (*a1 <= 0xA && ((1 << *a1) & 0x4C6) != 0)
  {
    v117 += 31;
  }

  v129 = v117 + (v126 + ~v127) * v128;
  if (v129 <= 65529)
  {
    if (v129 <= a1[28] - HIDWORD(v192))
    {
      goto LABEL_207;
    }

LABEL_190:
    v115 = 0;
    a1[728] = v127 + 1;
LABEL_191:
    v130 = v191;
    v131 = v115 + v191;
    v132 = a1[38];
    if ((v115 + v191) > 0x1F)
    {
      if (!v132)
      {
        v139 = a1[32];
        v140 = a1[31] - v115;
        a1[28] += v115;
        v141 = (a1[37] - 1) & (v139 - v115);
        a1[31] = v140;
        a1[32] = v141;
        goto LABEL_199;
      }
    }

    else if (!v132)
    {
      v133 = a1[32];
      v134 = a1[31] - v131;
      v135 = a1[28] + v131;
      a1[28] = v135;
      v136 = v133 - v131;
      v137 = a1[37];
      v138 = (v137 - 1) & v136;
      a1[31] = v134;
      a1[32] = v138;
      *(a1 + 13) = 0;
      v191 = 0;
      if (v83 > 0)
      {
        v132 = 0;
LABEL_203:
        v145 = 0;
        v146 = 0;
        goto LABEL_210;
      }

      LOBYTE(v132) = 0;
      a1[721] = v192;
      v147 = 1;
      goto LABEL_235;
    }

    if (v115)
    {
      CDK_put((a1 + 28), a1[26], v115);
      v132 = a1[38];
    }

LABEL_199:
    *(a1 + 13) = 0;
    v142 = a1[32];
    v134 = a1[31] - v130;
    if (v132)
    {
      v143 = -v130;
    }

    else
    {
      v143 = v130;
    }

    v135 = a1[28] + v143;
    a1[28] = v135;
    v144 = v142 - v130;
    v137 = a1[37];
    v138 = (v137 - 1) & v144;
    a1[31] = v134;
    a1[32] = v138;
    v191 = 0;
    if (v83 > 0)
    {
      goto LABEL_203;
    }

    a1[721] = v192;
    v147 = v132 == 0;
    if (v132)
    {
LABEL_236:
      *(a1 + 13) = 0;
      a2 = v178;
      if (v135 >= 65529 - a1[727] * a1[723] / 0x3E8u)
      {
        v159 = v137 - 1;
        if (v147)
        {
          v160 = v159;
        }

        else
        {
          v160 = -1;
        }

        v161 = v138 & v160;
        *(a1 + 13) = 0;
        v162 = v134 + 8;
        if (v132)
        {
          v163 = 8;
        }

        else
        {
          v163 = -8;
        }

        a1[28] = v135 + v163;
        a1[31] = v162;
        a1[32] = v159 & (v161 + 8);
        v19 = 258;
      }

      else
      {
        v19 = 257;
      }

      goto LABEL_227;
    }

LABEL_235:
    a1[28] = v135;
    v138 &= v137 - 1;
    a1[31] = v134;
    a1[32] = v138;
    goto LABEL_236;
  }

  a1[728] = 0;
  if (v83 > 0)
  {
    LODWORD(v19) = 258;
    goto LABEL_209;
  }

  a1[721] = v192;
  v19 = 258;
  a2 = v178;
LABEL_227:
  if (v189)
  {
    a1[729] |= 0x20u;
  }

  if (a2)
  {
    *a2 = v191;
  }

  if (v19 == 258)
  {
    a1[729] &= ~1u;
  }

  return v19;
}

uint64_t CLatmDemux_ReadPayloadLengthInfo(unsigned int *a1, uint64_t a2)
{
  if (*(a2 + 31) == 1)
  {
    v2 = *(a2 + 33);
    if (v2 > 1)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "TRANSPORTDEC_ERROR CLatmDemux_ReadPayloadLengthInfo(HANDLE_CDK_BITSTREAM, CLatmDemux *)";
      v19 = 507;
      goto LABEL_32;
    }

    if (*(a2 + 33))
    {
      v4 = 0;
      v5 = 0;
      v6 = a2 + 34;
      v7 = 1;
      v20 = a2;
      while (*(v6 + v4) <= 1u)
      {
        if (!*(v6 + v4))
        {
          goto LABEL_19;
        }

        v8 = 0;
        v9 = a2 + 16 * v4;
        do
        {
          v10 = (v9 + 16 * v8);
          if (*v10)
          {
            return 1025;
          }

          v11 = 0;
          v12 = a1[1];
          do
          {
            if (8 - v12 <= 0)
            {
              LOBYTE(v13) = 0;
              v14 = *a1;
            }

            else
            {
              if (v12 == -24)
              {
                LOBYTE(v13) = 0;
              }

              else
              {
                v13 = *a1 << (8 - v12);
              }

              v14 = CDK_get32((a1 + 2));
              *a1 = v14;
              v12 = a1[1] + 32;
            }

            v12 -= 8;
            a1[1] = v12;
            v11 += ((v14 >> v12) | v13);
          }

          while (((v14 >> v12) | v13) == 0xFF);
          v10[3] = 8 * v11;
          v5 += 8 * v11;
          ++v8;
        }

        while (v8 < *(v6 + v4));
        a2 = v20;
        v7 = *(v20 + 33);
LABEL_19:
        if (++v4 >= v7)
        {
          v2 = 0;
          goto LABEL_24;
        }
      }

      exception = __cxa_allocate_exception(0x10uLL);
      *exception = "TRANSPORTDEC_ERROR CLatmDemux_ReadPayloadLengthInfo(HANDLE_CDK_BITSTREAM, CLatmDemux *)";
      v19 = 509;
LABEL_32:
      exception[2] = v19;
    }

    v5 = 0;
  }

  else
  {
    v5 = 0;
    v2 = 1025;
  }

LABEL_24:
  v16 = *(a2 + 24);
  if (v5 <= 8 * v16 || v16 == 0)
  {
    return v2;
  }

  else
  {
    return 1025;
  }
}

NSObject *aacDecoder_GetDrcCapability(NSObject *a1)
{
  v1 = a1;
  v17 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    if (mpddrc::LoudnessInfoSet::HasValidLoudness(&a1[180]))
    {
      isa = v1[45].isa;
      v3 = v1[46].isa;
      if (isa == v3)
      {
        v4 = 1;
      }

      else
      {
        v4 = 3;
      }

      v5 = v1[54].isa;
      v6 = v1[55].isa;
      if (v5 == v6)
      {
        v1 = v4;
      }

      else
      {
        v1 = (v4 | 4);
      }

      if (gDRCScope)
      {
        v7 = *gDRCScope;
        if (!*gDRCScope)
        {
          return v1;
        }
      }

      else
      {
        v7 = MEMORY[0x1E69E9C10];
      }

      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v9 = 136315906;
        v10 = "USACDRCExtension.cpp";
        v12 = 511;
        v11 = 1024;
        v13 = 1024;
        v14 = 1022611261 * ((v3 - isa) >> 3);
        v15 = 1024;
        v16 = -1108378657 * ((v6 - v5) >> 3);
        _os_log_impl(&dword_19AA99000, v7, OS_LOG_TYPE_DEFAULT, "%25s:%-5d DRC Capability based on validity of loudnessInfo, drcCoefficient size %d, loudEQInstructions size %d\n", &v9, 0x1Eu);
      }
    }

    else
    {
      if (gDRCScope)
      {
        v1 = *gDRCScope;
        if (!*gDRCScope)
        {
          return v1;
        }
      }

      else
      {
        v1 = MEMORY[0x1E69E9C10];
      }

      if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
      {
        v9 = 136315394;
        v10 = "USACDRCExtension.cpp";
        v11 = 1024;
        v12 = 515;
        _os_log_impl(&dword_19AA99000, v1, OS_LOG_TYPE_DEFAULT, "%25s:%-5d DRC Capability based on validity of loudnessInfo\n", &v9, 0x12u);
      }

      return 0;
    }
  }

  return v1;
}

void aia_format::ChannelLock::Parse(uint64_t a1, uint64_t a2)
{
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  *a1 = Bit != 0;
  if (Bit)
  {
    v5 = TBitstreamReader<unsigned int>::GetBit(a2);
    *(a1 + 1) = v5 != 0;
    if (v5)
    {
      *(a1 + 4) = apac::obj::readFloat(a2);
    }
  }
}

void aia_format::Distance::Parse(uint64_t a1, uint64_t a2)
{
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  *a1 = Bit != 0;
  if (Bit)
  {
    *(a1 + 4) = apac::obj::readFloat(a2);
  }
}

float aia_format::Gain::Parse(uint64_t a1, uint64_t a2)
{
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  *a1 = Bit != 0;
  if (Bit)
  {
    *(a1 + 1) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
    result = apac::obj::readFloat(a2);
    *(a1 + 4) = result;
    if ((*(a1 + 1) & 1) == 0)
    {
      *(a1 + 1) = 1;
      result = log10f(result) * 20.0;
      *(a1 + 4) = result;
    }
  }

  return result;
}

void aia_format::HeadphoneVirtualize::Parse(uint64_t a1, uint64_t a2)
{
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  *a1 = Bit != 0;
  if (Bit)
  {
    *(a1 + 1) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
    v5 = TBitstreamReader<unsigned int>::GetBit(a2);
    *(a1 + 2) = v5 != 0;
    if (v5)
    {
      *(a1 + 4) = apac::obj::readFloat(a2);
    }
  }
}

uint64_t aia_format::Importance::Parse(BOOL *a1, uint64_t a2)
{
  result = TBitstreamReader<unsigned int>::GetBit(a2);
  *a1 = result != 0;
  if (result)
  {
    v5 = *(a2 + 20);
    v6 = v5 >> 25;
    v7 = *(a2 + 24) - 7;
    *(a2 + 24) = v7;
    if (v7 < 0)
    {
      result = TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      *a2 += 4;
      v10 = *(a2 + 20);
      v9 = *(a2 + 24);
      v6 |= v10 >> v9;
      *(a2 + 24) = v9 + 32;
      if (v9 == -32)
      {
        v8 = 0;
      }

      else
      {
        v8 = v10 << -v9;
      }
    }

    else
    {
      v8 = v5 << 7;
    }

    *(a2 + 20) = v8;
    a1[1] = v6;
  }

  return result;
}

void aia_format::ObjectDivergence::Parse(uint64_t a1, uint64_t a2)
{
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  *a1 = Bit != 0;
  if (Bit)
  {
    *(a1 + 4) = apac::obj::readFloat(a2);
    v5 = TBitstreamReader<unsigned int>::GetBit(a2);
    *(a1 + 8) = v5 != 0;
    if (v5)
    {
      v6 = 12;
    }

    else
    {
      v6 = 16;
    }

    *(a1 + v6) = apac::obj::readFloat(a2);
  }
}

void aia_format::Zone::Parse(uint64_t a1, uint64_t a2)
{
  *a1 = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  *(a1 + 1) = Bit != 0;
  Float = apac::obj::readFloat(a2);
  if (Bit)
  {
    *(a1 + 4) = Float;
    *(a1 + 8) = apac::obj::readFloat(a2);
    *(a1 + 12) = apac::obj::readFloat(a2);
    *(a1 + 16) = apac::obj::readFloat(a2);
    v6 = 24;
    v7 = 20;
  }

  else
  {
    *(a1 + 28) = Float;
    *(a1 + 32) = apac::obj::readFloat(a2);
    *(a1 + 36) = apac::obj::readFloat(a2);
    *(a1 + 40) = apac::obj::readFloat(a2);
    if (*a1)
    {
      return;
    }

    v6 = 48;
    v7 = 44;
  }

  *(a1 + v7) = apac::obj::readFloat(a2);
  *(a1 + v6) = apac::obj::readFloat(a2);
}

void aia_format::ZoneExclusion::Parse(uint64_t a1, uint64_t a2)
{
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  *a1 = Bit != 0;
  if (Bit)
  {
    v5 = *(a2 + 20);
    v6 = v5 >> 28;
    v7 = *(a2 + 24) - 4;
    *(a2 + 24) = v7;
    if (v7 < 0)
    {
      TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      *a2 += 4;
      v10 = *(a2 + 20);
      v9 = *(a2 + 24);
      v6 |= v10 >> v9;
      *(a2 + 24) = v9 + 32;
      v8 = v9 == -32 ? 0 : v10 << -v9;
    }

    else
    {
      v8 = 16 * v5;
    }

    *(a2 + 20) = v8;
    *(a1 + 4) = v6;
    if (v6)
    {
      v11 = 0;
      v12 = (a1 + 88);
      do
      {
        v13 = TBitstreamReader<unsigned int>::GetBit(a2);
        *(a1 + v11 + 12) = v13 != 0;
        if (v13)
        {
          v14 = *(a2 + 20);
          v15 = v14 >> 28;
          v16 = *(a2 + 24) - 4;
          *(a2 + 24) = v16;
          if (v16 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v19 = *(a2 + 20);
            v18 = *(a2 + 24);
            v15 |= v19 >> v18;
            *(a2 + 24) = v18 + 32;
            if (v18 == -32)
            {
              v17 = 0;
            }

            else
            {
              v17 = v19 << -v18;
            }
          }

          else
          {
            v17 = 16 * v14;
          }

          *(a2 + 20) = v17;
          *(a1 + 4 * v11 + 28) = v15;
        }

        else
        {
          *v12 = 1;
          v12[1] = *(a1 + 2);
          aia_format::Zone::Parse(v12, a2);
        }

        ++v11;
        v12 += 52;
      }

      while (v11 < *(a1 + 4));
    }
  }
}

uint64_t aia_format::Position::Parse(uint64_t a1, uint64_t a2)
{
  *a1 = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
  v4 = *(a2 + 20);
  v5 = v4 >> 26;
  v6 = *(a2 + 24) - 6;
  *(a2 + 24) = v6;
  if (v6 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v9 = *(a2 + 20);
    v8 = *(a2 + 24);
    v5 |= v9 >> v8;
    *(a2 + 24) = v8 + 32;
    if (v8 == -32)
    {
      v7 = 0;
    }

    else
    {
      v7 = v9 << -v8;
    }
  }

  else
  {
    v7 = v4 << 6;
  }

  *(a2 + 20) = v7;
  *(a1 + 1) = v5;
  *(a1 + 2) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
  *(a1 + 4) = apac::obj::readFloat(a2);
  v10 = *(a2 + 20);
  v11 = v10 >> 27;
  v12 = *(a2 + 24) - 5;
  *(a2 + 24) = v12;
  if (v12 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    v14 = (*a2 + 4);
    *a2 = v14;
    v16 = *(a2 + 20);
    v15 = *(a2 + 24);
    v11 |= v16 >> v15;
    v12 = v15 + 32;
    if (v15 == -32)
    {
      v17 = 0;
      *(a1 + 8) = v11;
      *(a2 + 20) = 0xFFFFFFFB00000000;
      goto LABEL_14;
    }

    v13 = v16 << -v15;
  }

  else
  {
    v13 = 32 * v10;
  }

  *(a1 + 8) = v11;
  v17 = v13 >> 27;
  v18 = v12 - 5;
  *(a2 + 20) = v13;
  *(a2 + 24) = v18;
  if (v18 >= 0)
  {
    v19 = 32 * v13;
    goto LABEL_17;
  }

  v14 = *a2;
LABEL_14:
  TBitstreamReader<unsigned int>::FillCacheFrom(a2, v14);
  *a2 += 4;
  v21 = *(a2 + 20);
  v20 = *(a2 + 24);
  v17 |= v21 >> v20;
  *(a2 + 24) = v20 + 32;
  if (v20 == -32)
  {
    v19 = 0;
  }

  else
  {
    v19 = v21 << -v20;
  }

LABEL_17:
  *(a2 + 20) = v19;
  *(a1 + 9) = v17;
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  *(a1 + 10) = Bit != 0;
  if (Bit)
  {
    v23 = TBitstreamReader<unsigned int>::GetBit(a2);
    *(a1 + 11) = v23 != 0;
    if (v23)
    {
      v24 = 28;
    }

    else
    {
      v24 = 12;
    }

    if (v23)
    {
      v25 = 32;
    }

    else
    {
      v25 = 16;
    }

    if (v23)
    {
      v26 = 36;
    }

    else
    {
      v26 = 20;
    }

    *(a1 + v24) = apac::obj::readFloat(a2);
    *(a1 + v25) = apac::obj::readFloat(a2);
    *(a1 + v26) = apac::obj::readFloat(a2);
  }

  v27 = TBitstreamReader<unsigned int>::GetBit(a2);
  *(a1 + 24) = v27 != 0;
  if (v27)
  {
    *(a1 + 40) = apac::obj::readFloat(a2);
    *(a1 + 44) = apac::obj::readFloat(a2);
    *(a1 + 48) = apac::obj::readFloat(a2);
    *(a1 + 52) = apac::obj::readFloat(a2);
  }

  result = TBitstreamReader<unsigned int>::GetBit(a2);
  *(a1 + 56) = result != 0;
  return result;
}

void aia_format::SupplementaryProductionMetadata::Parse(uint64_t a1, uint64_t a2)
{
  *a1 = 1;
  v4 = *(a2 + 20);
  v5 = v4 >> 30;
  v6 = *(a2 + 24) - 2;
  *(a2 + 24) = v6;
  if (v6 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    v8 = (*a2 + 4);
    *a2 = v8;
    v10 = *(a2 + 20);
    v9 = *(a2 + 24);
    v5 |= v10 >> v9;
    v6 = v9 + 32;
    if (v9 == -32)
    {
      v11 = 0;
      *(a1 + 1) = v5;
      *(a2 + 20) = 0xFFFFFFFE00000000;
      goto LABEL_9;
    }

    v7 = v10 << -v9;
  }

  else
  {
    v7 = 4 * v4;
  }

  *(a1 + 1) = v5;
  v11 = v7 >> 30;
  v12 = v6 - 2;
  *(a2 + 20) = v7;
  *(a2 + 24) = v12;
  if (v12 >= 0)
  {
    v13 = 4 * v7;
    goto LABEL_11;
  }

  v8 = *a2;
LABEL_9:
  TBitstreamReader<unsigned int>::FillCacheFrom(a2, v8);
  v14 = (*a2 + 4);
  *a2 = v14;
  v16 = *(a2 + 20);
  v15 = *(a2 + 24);
  v11 |= v16 >> v15;
  v12 = v15 + 32;
  if (v15 == -32)
  {
    v17 = 0;
    *(a1 + 2) = v11;
    *(a2 + 20) = 0xFFFFFFFD00000000;
LABEL_15:
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, v14);
    *a2 += 4;
    v21 = *(a2 + 20);
    v20 = *(a2 + 24);
    v17 |= v21 >> v20;
    *(a2 + 24) = v20 + 32;
    if (v20 == -32)
    {
      v19 = 0;
    }

    else
    {
      v19 = v21 << -v20;
    }

    goto LABEL_18;
  }

  v13 = v16 << -v15;
LABEL_11:
  *(a1 + 2) = v11;
  v17 = v13 >> 29;
  v18 = v12 - 3;
  *(a2 + 20) = v13;
  *(a2 + 24) = v18;
  if (v18 < 0)
  {
    v14 = *a2;
    goto LABEL_15;
  }

  v19 = 8 * v13;
LABEL_18:
  v22 = 0;
  *(a2 + 20) = v19;
  *(a1 + 3) = v17;
  v23 = (a1 + 32);
  do
  {
    Bit = TBitstreamReader<unsigned int>::GetBit(a2);
    *(a1 + 4 + v22) = Bit != 0;
    if (!Bit)
    {
      *(v23 - 4) = apac::obj::readFloat(a2);
      *(v23 - 3) = apac::obj::readFloat(a2);
      *(v23 - 2) = apac::obj::readFloat(a2);
      *(v23 - 1) = apac::obj::readFloat(a2);
      *v23 = apac::obj::readFloat(a2);
    }

    ++v22;
    v23 += 5;
  }

  while (v22 != 9);
  v25 = *(a2 + 20);
  v26 = v25 >> 25;
  v27 = *(a2 + 24) - 7;
  *(a2 + 24) = v27;
  if (v27 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v30 = *(a2 + 20);
    v29 = *(a2 + 24);
    v26 |= v30 >> v29;
    *(a2 + 24) = v29 + 32;
    if (v29 == -32)
    {
      v28 = 0;
    }

    else
    {
      v28 = v30 << -v29;
    }
  }

  else
  {
    v28 = v25 << 7;
  }

  *(a2 + 20) = v28;
  v31 = v26 + 1;
  *(a1 + 196) = v31;
  v32 = *(a1 + 208);
  v33 = v31 - v32;
  if (v31 <= v32)
  {
    *(a1 + 208) = v31;
    goto LABEL_61;
  }

  v34 = *(a1 + 216);
  if (v34 << 6 < v33 || v32 > (v34 << 6) - v33)
  {
    if ((v34 << 6) > 0x3FFFFFFFFFFFFFFELL)
    {
      v38 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v36 = v34 << 7;
      v37 = (v31 + 63) & 0x1FFFFFFC0;
      if (v36 <= v37)
      {
        v38 = v37;
      }

      else
      {
        v38 = v36;
      }

      if (!v38)
      {
        *(&v41 + 1) = 0;
        *&v41 = v32 + v33;
        v42 = *(a1 + 200);
        if (v32 < 1)
        {
          LODWORD(v40) = 0;
          v39 = 0;
        }

        else
        {
          v43 = v32 >> 6;
          if (v32 >= 0x40)
          {
            v65 = v41;
            memmove(0, *(a1 + 200), 8 * v43);
            v41 = v65;
          }

          v39 = (8 * v43);
          v40 = v32 & 0x3F;
          if (v40)
          {
            *(8 * v43) = *(8 * v43) & ~(0xFFFFFFFFFFFFFFFFLL >> -v40) | v42[v43] & (0xFFFFFFFFFFFFFFFFLL >> -v40);
          }

          v42 = *(a1 + 200);
        }

        *(a1 + 200) = 0;
        *(a1 + 208) = v41;
        if (v42)
        {
          operator delete(v42);
        }

        goto LABEL_52;
      }

      if (v38 < 0)
      {
        std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
      }
    }

    __dst = 0;
    v67 = 0uLL;
    std::vector<BOOL>::__vallocate[abi:ne200100](&__dst, v38);
  }

  v39 = (*(a1 + 200) + 8 * (v32 >> 6));
  v40 = *(a1 + 208) & 0x3FLL;
  *(a1 + 208) = v31;
LABEL_52:
  if (v40)
  {
    if ((64 - v40) >= v33)
    {
      v44 = v33;
    }

    else
    {
      v44 = (64 - v40);
    }

    *v39++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v40 - v44)) & (-1 << v40));
    v33 -= v44;
  }

  v45 = v33 >> 6;
  if (v33 >= 0x40)
  {
    bzero(v39, 8 * v45);
  }

  if ((v33 & 0x3F) != 0)
  {
    v39[v45] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v33 & 0x3F));
  }

LABEL_61:
  v46 = *(a1 + 224);
  v47 = *(a1 + 196);
  v48 = *(a1 + 232) - v46;
  if (v47 <= v48)
  {
    if (v47 < v48)
    {
      *(a1 + 232) = v46 + v47;
    }
  }

  else
  {
    std::vector<unsigned char>::__append((a1 + 224), v47 - v48);
    LODWORD(v47) = *(a1 + 196);
  }

  if (v47)
  {
    v49 = 0;
    do
    {
      v50 = TBitstreamReader<unsigned int>::GetBit(a2);
      v51 = *(a1 + 200);
      v52 = v49 >> 6;
      v53 = 1 << v49;
      if (v50)
      {
        v54 = *(v51 + 8 * v52) | v53;
      }

      else
      {
        v54 = *(v51 + 8 * v52) & ~v53;
      }

      *(v51 + 8 * v52) = v54;
      v55 = *(a2 + 20);
      v56 = v55 >> 29;
      v57 = *(a2 + 24) - 3;
      *(a2 + 24) = v57;
      if (v57 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        *a2 += 4;
        v60 = *(a2 + 20);
        v59 = *(a2 + 24);
        v56 |= v60 >> v59;
        *(a2 + 24) = v59 + 32;
        if (v59 == -32)
        {
          v58 = 0;
        }

        else
        {
          v58 = v60 << -v59;
        }
      }

      else
      {
        v58 = 8 * v55;
      }

      *(a2 + 20) = v58;
      *(*(a1 + 224) + v49++) = v56;
    }

    while (v49 < *(a1 + 196));
  }

  v61 = *(a2 + 24);
  if ((v61 & 7) != 0)
  {
    v62 = *(a2 + 20);
    *(a2 + 24) = v61 & 0xFFFFFFF8;
    if (v61 < 0)
    {
      TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      v64 = *(a2 + 24);
      *a2 += 4;
      *(a2 + 24) = v64 + 32;
      if (v64 == -32)
      {
        v63 = 0;
      }

      else
      {
        v63 = *(a2 + 20) << -v64;
      }
    }

    else
    {
      v63 = v62 << (v61 & 7);
    }

    *(a2 + 20) = v63;
  }
}

void sub_19B0A0C10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void aia_format::GlobalConfig::Parse(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 20);
  v5 = v4 >> 21;
  v6 = *(a2 + 24) - 11;
  *(a2 + 24) = v6;
  if (v6 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v9 = *(a2 + 20);
    v8 = *(a2 + 24);
    v5 |= v9 >> v8;
    *(a2 + 24) = v8 + 32;
    if (v8 == -32)
    {
      v7 = 0;
    }

    else
    {
      v7 = v9 << -v8;
    }
  }

  else
  {
    v7 = v4 << 11;
  }

  *(a2 + 20) = v7;
  *a1 = v5 > 0;
  *(a1 + 16) = *(a1 + 8);
  if (v5)
  {
    v10 = 0;
    v280 = a1 + 56;
    v281 = (a1 + 544);
    while (2)
    {
      v11 = *(a2 + 20);
      v12 = v11 >> 21;
      v13 = *(a2 + 24) - 11;
      *(a2 + 24) = v13;
      if (v13 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        *a2 += 4;
        v16 = *(a2 + 20);
        v15 = *(a2 + 24);
        v12 |= v16 >> v15;
        *(a2 + 24) = v15 + 32;
        if (v15 == -32)
        {
          v14 = 0;
        }

        else
        {
          v14 = v16 << -v15;
        }
      }

      else
      {
        v14 = v11 << 11;
      }

      *(a2 + 20) = v14;
      v282 = v12;
      std::vector<unsigned short>::push_back[abi:ne200100](a1 + 8, &v282);
      switch(v12)
      {
        case 0:
          *(a1 + 32) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
          goto LABEL_308;
        case 1:
          *(a1 + 33) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
          goto LABEL_308;
        case 2:
          *(a1 + 34) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
          goto LABEL_308;
        case 3:
          v39 = *(a2 + 20);
          v40 = v39 >> 27;
          v41 = *(a2 + 24) - 5;
          *(a2 + 24) = v41;
          if (v41 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v89 = *(a2 + 20);
            v88 = *(a2 + 24);
            v40 |= v89 >> v88;
            *(a2 + 24) = v88 + 32;
            if (v88 == -32)
            {
              v42 = 0;
            }

            else
            {
              v42 = v89 << -v88;
            }
          }

          else
          {
            v42 = 32 * v39;
          }

          *(a2 + 20) = v42;
          *(a1 + 36) = v40;
          goto LABEL_308;
        case 4:
          v21 = *(a2 + 20);
          v22 = v21 >> 29;
          v23 = *(a2 + 24) - 3;
          *(a2 + 24) = v23;
          if (v23 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            v67 = (*a2 + 4);
            *a2 = v67;
            v69 = *(a2 + 20);
            v68 = *(a2 + 24);
            v22 |= v69 >> v68;
            v23 = v68 + 32;
            if (v68 == -32)
            {
              v70 = 0;
              *(a1 + 40) = v22;
              *(a2 + 20) = 0xFFFFFFF800000000;
              goto LABEL_92;
            }

            v24 = v69 << -v68;
          }

          else
          {
            v24 = 8 * v21;
          }

          *(a1 + 40) = v22;
          v70 = HIBYTE(v24);
          v71 = v23 - 8;
          *(a2 + 20) = v24;
          *(a2 + 24) = v71;
          if (v71 >= 0)
          {
            v72 = v24 << 8;
            goto LABEL_94;
          }

          v67 = *a2;
LABEL_92:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v67);
          v104 = (*a2 + 4);
          *a2 = v104;
          v106 = *(a2 + 20);
          v105 = *(a2 + 24);
          v70 |= v106 >> v105;
          v71 = v105 + 32;
          if (v105 == -32)
          {
            v107 = 0;
            *(a1 + 44) = v70;
            *(a2 + 20) = 0xFFFFFFF800000000;
            goto LABEL_98;
          }

          v72 = v106 << -v105;
LABEL_94:
          *(a1 + 44) = v70;
          v107 = HIBYTE(v72);
          v108 = v71 - 8;
          *(a2 + 20) = v72;
          *(a2 + 24) = v108;
          if (v108 >= 0)
          {
            v109 = v72 << 8;
            goto LABEL_100;
          }

          v104 = *a2;
LABEL_98:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v104);
          v110 = (*a2 + 4);
          *a2 = v110;
          v112 = *(a2 + 20);
          v111 = *(a2 + 24);
          v107 |= v112 >> v111;
          v108 = v111 + 32;
          if (v111 == -32)
          {
            v113 = 0;
            *(a1 + 45) = v107;
            *(a2 + 20) = 0xFFFFFFF800000000;
            goto LABEL_104;
          }

          v109 = v112 << -v111;
LABEL_100:
          *(a1 + 45) = v107;
          v113 = HIBYTE(v109);
          v114 = v108 - 8;
          *(a2 + 20) = v109;
          *(a2 + 24) = v114;
          if (v114 >= 0)
          {
            v115 = v109 << 8;
            goto LABEL_106;
          }

          v110 = *a2;
LABEL_104:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v110);
          v116 = (*a2 + 4);
          *a2 = v116;
          v118 = *(a2 + 20);
          v117 = *(a2 + 24);
          v113 |= v118 >> v117;
          v114 = v117 + 32;
          if (v117 == -32)
          {
            v119 = 0;
            *(a1 + 46) = v113;
            *(a2 + 20) = 0xFFFFFFFD00000000;
            goto LABEL_110;
          }

          v115 = v118 << -v117;
LABEL_106:
          *(a1 + 46) = v113;
          v119 = v115 >> 29;
          v120 = v114 - 3;
          *(a2 + 20) = v115;
          *(a2 + 24) = v120;
          if (v120 >= 0)
          {
            v121 = 8 * v115;
            goto LABEL_112;
          }

          v116 = *a2;
LABEL_110:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v116);
          v122 = (*a2 + 4);
          *a2 = v122;
          v124 = *(a2 + 20);
          v123 = *(a2 + 24);
          v119 |= v124 >> v123;
          v120 = v123 + 32;
          if (v123 == -32)
          {
            v125 = 0;
            *(a1 + 48) = v119;
            *(a2 + 20) = 0xFFFFFFF800000000;
            goto LABEL_116;
          }

          v121 = v124 << -v123;
LABEL_112:
          *(a1 + 48) = v119;
          v125 = HIBYTE(v121);
          v126 = v120 - 8;
          *(a2 + 20) = v121;
          *(a2 + 24) = v126;
          if (v126 >= 0)
          {
            v127 = v121 << 8;
            goto LABEL_118;
          }

          v122 = *a2;
LABEL_116:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v122);
          v128 = (*a2 + 4);
          *a2 = v128;
          v130 = *(a2 + 20);
          v129 = *(a2 + 24);
          v125 |= v130 >> v129;
          v126 = v129 + 32;
          if (v129 == -32)
          {
            v131 = 0;
            *(a1 + 52) = v125;
            *(a2 + 20) = 0xFFFFFFF800000000;
            goto LABEL_122;
          }

          v127 = v130 << -v129;
LABEL_118:
          *(a1 + 52) = v125;
          v131 = HIBYTE(v127);
          v132 = v126 - 8;
          *(a2 + 20) = v127;
          *(a2 + 24) = v132;
          if (v132 >= 0)
          {
            v133 = v127 << 8;
            goto LABEL_124;
          }

          v128 = *a2;
LABEL_122:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v128);
          v134 = (*a2 + 4);
          *a2 = v134;
          v136 = *(a2 + 20);
          v135 = *(a2 + 24);
          v131 |= v136 >> v135;
          v132 = v135 + 32;
          if (v135 == -32)
          {
            v137 = 0;
            *(a1 + 53) = v131;
            *(a2 + 20) = 0xFFFFFFF800000000;
LABEL_128:
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, v134);
            *a2 += 4;
            v141 = *(a2 + 20);
            v140 = *(a2 + 24);
            v137 |= v141 >> v140;
            *(a2 + 24) = v140 + 32;
            if (v140 == -32)
            {
              v139 = 0;
            }

            else
            {
              v139 = v141 << -v140;
            }

            goto LABEL_131;
          }

          v133 = v136 << -v135;
LABEL_124:
          *(a1 + 53) = v131;
          v137 = HIBYTE(v133);
          v138 = v132 - 8;
          *(a2 + 20) = v133;
          *(a2 + 24) = v138;
          if (v138 < 0)
          {
            v134 = *a2;
            goto LABEL_128;
          }

          v139 = v133 << 8;
LABEL_131:
          *(a2 + 20) = v139;
          *(a1 + 54) = v137;
LABEL_308:
          if (++v10 == v5)
          {
            return;
          }

          continue;
        case 5:
          *(a1 + 56) = apac::obj::readFloat(a2);
          Bit = TBitstreamReader<unsigned int>::GetBit(a2);
          *(a1 + 60) = Bit != 0;
          if (Bit)
          {
            v49 = 8;
          }

          else
          {
            v49 = 20;
          }

          if (Bit)
          {
            v50 = 12;
          }

          else
          {
            v50 = 24;
          }

          if (Bit)
          {
            v51 = 16;
          }

          else
          {
            v51 = 28;
          }

          if (Bit)
          {
            v52 = 40;
          }

          else
          {
            v52 = 44;
          }

          *(v280 + v49) = apac::obj::readFloat(a2);
          *(v280 + v50) = apac::obj::readFloat(a2);
          *(v280 + v51) = apac::obj::readFloat(a2);
          *(v280 + v52) = apac::obj::readFloat(a2);
          goto LABEL_308;
        case 6:
          aia_format::SupplementaryProductionMetadata::Parse(a1 + 112, a2);
          goto LABEL_308;
        case 7:
          v43 = TBitstreamReader<unsigned int>::GetBit(a2);
          *(a1 + 360) = v43 != 0;
          if (v43)
          {
            *(a1 + 364) = apac::obj::readChannelLayoutTag(a2);
          }

          v44 = *(a2 + 20);
          v45 = v44 >> 29;
          v46 = *(a2 + 24) - 3;
          *(a2 + 24) = v46;
          if (v46 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v91 = *(a2 + 20);
            v90 = *(a2 + 24);
            v45 |= v91 >> v90;
            v46 = v90 + 32;
            *(a2 + 24) = v90 + 32;
            if (v90 == -32)
            {
              v47 = 0;
            }

            else
            {
              v47 = v91 << -v90;
            }
          }

          else
          {
            v47 = 8 * v44;
          }

          *(a2 + 20) = v47;
          *(a1 + 368) = v45;
          if (v45 != 2)
          {
            if (v45 == 1)
            {
              v204 = HIBYTE(v47);
              v205 = v46 - 8;
              *(a2 + 24) = v205;
              if (v205 < 0)
              {
                TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
                *a2 += 4;
                v240 = *(a2 + 20);
                v239 = *(a2 + 24);
                v204 |= v240 >> v239;
                *(a2 + 24) = v239 + 32;
                if (v239 == -32)
                {
                  v206 = 0;
                }

                else
                {
                  v206 = v240 << -v239;
                }
              }

              else
              {
                v206 = v47 << 8;
              }

              *(a2 + 20) = v206;
              *(a1 + 372) = v204;
            }

            goto LABEL_308;
          }

          v207 = v47 >> 30;
          v208 = v46 - 2;
          *(a2 + 24) = v208;
          if (v208 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            v241 = (*a2 + 4);
            *a2 = v241;
            v243 = *(a2 + 20);
            v242 = *(a2 + 24);
            v207 |= v243 >> v242;
            v208 = v242 + 32;
            if (v242 == -32)
            {
              v244 = 0;
              *(a1 + 373) = v207;
              *(a2 + 20) = 0xFFFFFFF800000000;
              goto LABEL_292;
            }

            v209 = v243 << -v242;
          }

          else
          {
            v209 = 4 * v47;
          }

          *(a1 + 373) = v207;
          v244 = HIBYTE(v209);
          v245 = v208 - 8;
          *(a2 + 20) = v209;
          *(a2 + 24) = v245;
          if (v245 >= 0)
          {
            v246 = v209 << 8;
            goto LABEL_294;
          }

          v241 = *a2;
LABEL_292:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v241);
          v266 = (*a2 + 4);
          *a2 = v266;
          v268 = *(a2 + 20);
          v267 = *(a2 + 24);
          v244 |= v268 >> v267;
          v245 = v267 + 32;
          if (v267 == -32)
          {
            v269 = 0;
            *(a1 + 374) = v244;
            *(a2 + 20) = 0xFFFFFFF800000000;
            goto LABEL_298;
          }

          v246 = v268 << -v267;
LABEL_294:
          *(a1 + 374) = v244;
          v269 = HIBYTE(v246);
          v270 = v245 - 8;
          *(a2 + 20) = v246;
          *(a2 + 24) = v270;
          if (v270 >= 0)
          {
            v271 = v246 << 8;
            goto LABEL_300;
          }

          v266 = *a2;
LABEL_298:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v266);
          v272 = (*a2 + 4);
          *a2 = v272;
          v274 = *(a2 + 20);
          v273 = *(a2 + 24);
          v269 |= v274 >> v273;
          v270 = v273 + 32;
          if (v273 == -32)
          {
            v275 = 0;
            *(a1 + 376) = v269;
            *(a2 + 20) = 0xFFFFFFFD00000000;
            goto LABEL_304;
          }

          v271 = v274 << -v273;
LABEL_300:
          *(a1 + 376) = v269;
          v275 = v271 >> 29;
          v276 = v270 - 3;
          *(a2 + 20) = v271;
          *(a2 + 24) = v276;
          if (v276 >= 0)
          {
            v277 = 8 * v271;
LABEL_307:
            *(a2 + 20) = v277;
            *(a1 + 380) = v275;
            goto LABEL_308;
          }

          v272 = *a2;
LABEL_304:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v272);
          *a2 += 4;
          v279 = *(a2 + 20);
          v278 = *(a2 + 24);
          v275 |= v279 >> v278;
          *(a2 + 24) = v278 + 32;
          if (v278 == -32)
          {
            v277 = 0;
          }

          else
          {
            v277 = v279 << -v278;
          }

          goto LABEL_307;
        case 8:
          v61 = *(a2 + 20);
          v62 = v61 >> 30;
          v63 = *(a2 + 24) - 2;
          *(a2 + 24) = v63;
          if (v63 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            v96 = (*a2 + 4);
            *a2 = v96;
            v98 = *(a2 + 20);
            v97 = *(a2 + 24);
            v62 |= v98 >> v97;
            v63 = v97 + 32;
            if (v97 == -32)
            {
              v99 = 0;
              *(a1 + 384) = v62;
              *(a2 + 20) = 0xFFFFFFF800000000;
              goto LABEL_228;
            }

            v64 = v98 << -v97;
          }

          else
          {
            v64 = 4 * v61;
          }

          *(a1 + 384) = v62;
          v99 = HIBYTE(v64);
          v100 = v63 - 8;
          *(a2 + 20) = v64;
          *(a2 + 24) = v100;
          if (v100 >= 0)
          {
            v101 = v64 << 8;
            goto LABEL_230;
          }

          v96 = *a2;
LABEL_228:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v96);
          v216 = (*a2 + 4);
          *a2 = v216;
          v218 = *(a2 + 20);
          v217 = *(a2 + 24);
          v99 |= v218 >> v217;
          v100 = v217 + 32;
          if (v217 == -32)
          {
            v219 = 0;
            *(a1 + 386) = v99;
            *(a2 + 20) = 0xFFFFFFF800000000;
            goto LABEL_234;
          }

          v101 = v218 << -v217;
LABEL_230:
          *(a1 + 386) = v99;
          v219 = HIBYTE(v101);
          v220 = v100 - 8;
          *(a2 + 20) = v101;
          *(a2 + 24) = v220;
          if (v220 >= 0)
          {
            v221 = v101 << 8;
LABEL_237:
            *(a2 + 20) = v221;
            *(a1 + 388) = v219;
            goto LABEL_308;
          }

          v216 = *a2;
LABEL_234:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v216);
          *a2 += 4;
          v223 = *(a2 + 20);
          v222 = *(a2 + 24);
          v219 |= v223 >> v222;
          *(a2 + 24) = v222 + 32;
          if (v222 == -32)
          {
            v221 = 0;
          }

          else
          {
            v221 = v223 << -v222;
          }

          goto LABEL_237;
        case 9:
          v31 = *(a2 + 20);
          v32 = v31 >> 30;
          v33 = *(a2 + 24) - 2;
          *(a2 + 24) = v33;
          if (v33 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            v76 = (*a2 + 4);
            *a2 = v76;
            v78 = *(a2 + 20);
            v77 = *(a2 + 24);
            v32 |= v78 >> v77;
            v33 = v77 + 32;
            if (v77 == -32)
            {
              v79 = 0;
              *(a1 + 392) = v32;
              *(a2 + 20) = 0xFFFFFFF800000000;
              goto LABEL_137;
            }

            v34 = v78 << -v77;
          }

          else
          {
            v34 = 4 * v31;
          }

          *(a1 + 392) = v32;
          v79 = HIBYTE(v34);
          v80 = v33 - 8;
          *(a2 + 20) = v34;
          *(a2 + 24) = v80;
          if (v80 >= 0)
          {
            v81 = v34 << 8;
            goto LABEL_139;
          }

          v76 = *a2;
LABEL_137:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v76);
          v148 = (*a2 + 4);
          *a2 = v148;
          v150 = *(a2 + 20);
          v149 = *(a2 + 24);
          v79 |= v150 >> v149;
          v80 = v149 + 32;
          if (v149 == -32)
          {
            v151 = 0;
            *(a1 + 396) = v79;
            *(a2 + 20) = 0xFFFFFFF800000000;
            goto LABEL_143;
          }

          v81 = v150 << -v149;
LABEL_139:
          *(a1 + 396) = v79;
          v151 = HIBYTE(v81);
          v152 = v80 - 8;
          *(a2 + 20) = v81;
          *(a2 + 24) = v152;
          if (v152 >= 0)
          {
            v153 = v81 << 8;
            goto LABEL_146;
          }

          v148 = *a2;
LABEL_143:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v148);
          *a2 += 4;
          v155 = *(a2 + 20);
          v154 = *(a2 + 24);
          v151 |= v155 >> v154;
          *(a2 + 24) = v154 + 32;
          if (v154 == -32)
          {
            v153 = 0;
          }

          else
          {
            v153 = v155 << -v154;
          }

LABEL_146:
          *(a2 + 20) = v153;
          *(a1 + 400) = v151;
          if (*(a1 + 431) < 0)
          {
            **(a1 + 408) = 0;
            *(a1 + 416) = 0;
          }

          else
          {
            *(a1 + 408) = 0;
            *(a1 + 431) = 0;
          }

          v156 = 7;
          do
          {
            v157 = *(a2 + 20);
            v158 = HIBYTE(v157);
            v159 = *(a2 + 24) - 8;
            *(a2 + 24) = v159;
            if (v159 < 0)
            {
              TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
              *a2 += 4;
              v162 = *(a2 + 20);
              v161 = *(a2 + 24);
              v158 |= v162 >> v161;
              *(a2 + 24) = v161 + 32;
              if (v161 == -32)
              {
                v160 = 0;
              }

              else
              {
                v160 = v162 << -v161;
              }
            }

            else
            {
              v160 = v157 << 8;
            }

            *(a2 + 20) = v160;
            std::string::push_back((a1 + 408), v158);
            if (v158)
            {
              v163 = v156 == 0;
            }

            else
            {
              v163 = 1;
            }

            --v156;
          }

          while (!v163);
          v164 = *(a2 + 20);
          v165 = v164 >> 28;
          v166 = *(a2 + 24) - 4;
          *(a2 + 24) = v166;
          if (v166 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            v168 = (*a2 + 4);
            *a2 = v168;
            v170 = *(a2 + 20);
            v169 = *(a2 + 24);
            v165 |= v170 >> v169;
            v166 = v169 + 32;
            if (v169 == -32)
            {
              v171 = 0;
              *(a1 + 432) = v165;
              *(a2 + 20) = 0xFFFFFFF800000000;
              goto LABEL_168;
            }

            v167 = v170 << -v169;
          }

          else
          {
            v167 = 16 * v164;
          }

          *(a1 + 432) = v165;
          v171 = HIBYTE(v167);
          v172 = v166 - 8;
          *(a2 + 20) = v167;
          *(a2 + 24) = v172;
          if (v172 >= 0)
          {
            v173 = v167 << 8;
            goto LABEL_171;
          }

          v168 = *a2;
LABEL_168:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v168);
          *a2 += 4;
          v175 = *(a2 + 20);
          v174 = *(a2 + 24);
          v171 |= v175 >> v174;
          *(a2 + 24) = v174 + 32;
          if (v174 == -32)
          {
            v173 = 0;
          }

          else
          {
            v173 = v175 << -v174;
          }

LABEL_171:
          *(a2 + 20) = v173;
          v176 = v171;
          *(a1 + 433) = v171;
          v177 = *(a1 + 440);
          v178 = *(a1 + 448);
          v179 = 0x6DB6DB6DB6DB6DB7 * ((v178 - v177) >> 2);
          v180 = v176 - v179;
          if (v176 == v179)
          {
            goto LABEL_241;
          }

          if (v176 <= v179)
          {
            if (v176 >= v179)
            {
LABEL_240:
              LODWORD(v176) = *(a1 + 433);
LABEL_241:
              if (v176)
              {
                v224 = 0;
                v225 = 0;
                v227 = *(a2 + 20);
                v226 = *(a2 + 24);
                do
                {
                  v228 = *(a1 + 440);
                  v229 = v227 >> 28;
                  v230 = v226 - 4;
                  *(a2 + 24) = v230;
                  if (v230 < 0)
                  {
                    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
                    *a2 += 4;
                    v233 = *(a2 + 20);
                    v232 = *(a2 + 24);
                    v229 |= v233 >> v232;
                    *(a2 + 24) = v232 + 32;
                    if (v232 == -32)
                    {
                      v231 = 0;
                    }

                    else
                    {
                      v231 = v233 << -v232;
                    }
                  }

                  else
                  {
                    v231 = 16 * v227;
                  }

                  *(a2 + 20) = v231;
                  v234 = (v228 + v224);
                  *(v228 + v224) = v229;
                  v234[1] = apac::obj::readFloat(a2);
                  v234[2] = apac::obj::readFloat(a2);
                  v234[3] = apac::obj::readFloat(a2);
                  v235 = *(a2 + 20);
                  v236 = v235 >> 29;
                  v226 = *(a2 + 24) - 3;
                  *(a2 + 24) = v226;
                  if (v226 < 0)
                  {
                    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
                    *a2 += 4;
                    v238 = *(a2 + 20);
                    v237 = *(a2 + 24);
                    v236 |= v238 >> v237;
                    v226 = v237 + 32;
                    *(a2 + 24) = v237 + 32;
                    if (v237 == -32)
                    {
                      v227 = 0;
                    }

                    else
                    {
                      v227 = v238 << -v237;
                    }
                  }

                  else
                  {
                    v227 = 8 * v235;
                  }

                  *(a2 + 20) = v227;
                  *(v228 + v224 + 16) = v236;
                  ++v225;
                  v224 += 28;
                }

                while (v225 < *(a1 + 433));
              }

              goto LABEL_308;
            }

            v183 = v177 + 28 * v176;
          }

          else
          {
            v181 = *(a1 + 456);
            if (0x6DB6DB6DB6DB6DB7 * ((v181 - v178) >> 2) < v180)
            {
              v182 = 0x6DB6DB6DB6DB6DB7 * ((v181 - v177) >> 2);
              if (2 * v182 > v176)
              {
                v176 = 2 * v182;
              }

              if (v182 >= 0x492492492492492)
              {
                v176 = 0x924924924924924;
              }

              if (v176 <= 0x924924924924924)
              {
                operator new();
              }

              std::__throw_bad_array_new_length[abi:ne200100]();
            }

            bzero(*(a1 + 448), 28 * ((28 * v180 - 28) / 0x1C) + 28);
            v183 = v178 + 28 * ((28 * v180 - 28) / 0x1C) + 28;
          }

          *(a1 + 448) = v183;
          goto LABEL_240;
        case 10:
          v57 = *(a2 + 20);
          v58 = v57 >> 29;
          v59 = *(a2 + 24) - 3;
          *(a2 + 24) = v59;
          if (v59 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v95 = *(a2 + 20);
            v94 = *(a2 + 24);
            v58 |= v95 >> v94;
            *(a2 + 24) = v94 + 32;
            if (v94 == -32)
            {
              v60 = 0;
            }

            else
            {
              v60 = v95 << -v94;
            }
          }

          else
          {
            v60 = 8 * v57;
          }

          *(a2 + 20) = v60;
          *(a1 + 464) = v58;
          *(a1 + 468) = apac::obj::readFloat(a2);
          *(a1 + 472) = apac::obj::readFloat(a2);
          *(a1 + 476) = apac::obj::readFloat(a2);
          v210 = *(a2 + 20);
          v211 = v210 >> 31;
          v212 = *(a2 + 24) - 1;
          *(a2 + 24) = v212;
          if (v212 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v215 = *(a2 + 20);
            v214 = *(a2 + 24);
            v211 |= v215 >> v214;
            *(a2 + 24) = v214 + 32;
            if (v214 == -32)
            {
              v213 = 0;
            }

            else
            {
              v213 = v215 << -v214;
            }
          }

          else
          {
            v213 = 2 * v210;
          }

          *(a2 + 20) = v213;
          *(a1 + 480) = v211;
          goto LABEL_308;
        case 11:
          aia_format::Position::Parse(a1 + 484, a2);
          goto LABEL_308;
        case 12:
          v25 = TBitstreamReader<unsigned int>::GetBit(a2);
          *v281 = v25 != 0;
          v27 = *(a2 + 20);
          v26 = *(a2 + 24);
          if (v25)
          {
            v28 = v27 >> 21;
            v29 = v26 - 11;
            *(a2 + 24) = v29;
            if (v29 < 0)
            {
              TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
              *a2 += 4;
              v103 = *(a2 + 20);
              v102 = *(a2 + 24);
              v28 |= v103 >> v102;
              *(a2 + 24) = v102 + 32;
              if (v102 == -32)
              {
                v30 = 0;
              }

              else
              {
                v30 = v103 << -v102;
              }
            }

            else
            {
              v30 = v27 << 11;
            }

            v247 = 4;
            goto LABEL_288;
          }

          v73 = v27 >> 30;
          v74 = v26 - 2;
          *(a2 + 24) = v74;
          if (v74 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            v142 = (*a2 + 4);
            *a2 = v142;
            v144 = *(a2 + 20);
            v143 = *(a2 + 24);
            v73 |= v144 >> v143;
            v74 = v143 + 32;
            if (v143 == -32)
            {
              v145 = 0;
              *(a1 + 552) = v73;
              *(a2 + 20) = 0xFFFFFFF800000000;
              goto LABEL_266;
            }

            v75 = v144 << -v143;
          }

          else
          {
            v75 = 4 * v27;
          }

          *(a1 + 552) = v73;
          v145 = HIBYTE(v75);
          v146 = v74 - 8;
          *(a2 + 20) = v75;
          *(a2 + 24) = v146;
          if (v146 >= 0)
          {
            v147 = v75 << 8;
            goto LABEL_268;
          }

          v142 = *a2;
LABEL_266:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v142);
          v248 = (*a2 + 4);
          *a2 = v248;
          v250 = *(a2 + 20);
          v249 = *(a2 + 24);
          v145 |= v250 >> v249;
          v146 = v249 + 32;
          if (v249 == -32)
          {
            v251 = 0;
            *(a1 + 556) = v145;
            *(a2 + 20) = 0xFFFFFFF800000000;
            goto LABEL_272;
          }

          v147 = v250 << -v249;
LABEL_268:
          *(a1 + 556) = v145;
          v251 = HIBYTE(v147);
          v252 = v146 - 8;
          *(a2 + 20) = v147;
          *(a2 + 24) = v252;
          if (v252 >= 0)
          {
            v253 = v147 << 8;
            goto LABEL_274;
          }

          v248 = *a2;
LABEL_272:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v248);
          v254 = (*a2 + 4);
          *a2 = v254;
          v256 = *(a2 + 20);
          v255 = *(a2 + 24);
          v251 |= v256 >> v255;
          v252 = v255 + 32;
          if (v255 == -32)
          {
            v257 = 0;
            *(a1 + 560) = v251;
            *(a2 + 20) = 0xFFFFFFF500000000;
            goto LABEL_278;
          }

          v253 = v256 << -v255;
LABEL_274:
          *(a1 + 560) = v251;
          v257 = v253 >> 21;
          v258 = v252 - 11;
          *(a2 + 20) = v253;
          *(a2 + 24) = v258;
          if (v258 >= 0)
          {
            v259 = v253 << 11;
            goto LABEL_280;
          }

          v254 = *a2;
LABEL_278:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v254);
          v260 = (*a2 + 4);
          *a2 = v260;
          v262 = *(a2 + 20);
          v261 = *(a2 + 24);
          v257 |= v262 >> v261;
          v258 = v261 + 32;
          if (v261 == -32)
          {
            v28 = 0;
            *(a1 + 564) = v257;
            *(a2 + 20) = 0xFFFFFFEF00000000;
            goto LABEL_284;
          }

          v259 = v262 << -v261;
LABEL_280:
          *(a1 + 564) = v257;
          v28 = v259 >> 15;
          v263 = v258 - 17;
          *(a2 + 20) = v259;
          *(a2 + 24) = v263;
          if (v263 >= 0)
          {
            v30 = v259 << 17;
LABEL_287:
            v247 = 24;
LABEL_288:
            *(a2 + 20) = v30;
            *&v281[v247] = v28;
            goto LABEL_308;
          }

          v260 = *a2;
LABEL_284:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v260);
          *a2 += 4;
          v265 = *(a2 + 20);
          v264 = *(a2 + 24);
          v28 |= v265 >> v264;
          *(a2 + 24) = v264 + 32;
          if (v264 == -32)
          {
            v30 = 0;
          }

          else
          {
            v30 = v265 << -v264;
          }

          goto LABEL_287;
        case 13:
          v53 = *(a2 + 20);
          v54 = v53 >> 26;
          v55 = *(a2 + 24) - 6;
          *(a2 + 24) = v55;
          if (v55 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v93 = *(a2 + 20);
            v92 = *(a2 + 24);
            v54 |= v93 >> v92;
            *(a2 + 24) = v92 + 32;
            if (v92 == -32)
            {
              v56 = 0;
            }

            else
            {
              v56 = v93 << -v92;
            }
          }

          else
          {
            v56 = v53 << 6;
          }

          *(a2 + 20) = v56;
          *(a1 + 572) = v54;
          goto LABEL_308;
        case 14:
          v17 = *(a2 + 20);
          v18 = HIBYTE(v17);
          v19 = *(a2 + 24) - 8;
          *(a2 + 24) = v19;
          if (v19 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v66 = *(a2 + 20);
            v65 = *(a2 + 24);
            v18 |= v66 >> v65;
            *(a2 + 24) = v65 + 32;
            if (v65 == -32)
            {
              v20 = 0;
            }

            else
            {
              v20 = v66 << -v65;
            }
          }

          else
          {
            v20 = v17 << 8;
          }

          *(a2 + 20) = v20;
          *(a1 + 576) = v18;
          goto LABEL_308;
        case 15:
          v35 = *(a2 + 20);
          v36 = v35 >> 28;
          v37 = *(a2 + 24) - 4;
          *(a2 + 24) = v37;
          if (v37 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            v82 = (*a2 + 4);
            *a2 = v82;
            v84 = *(a2 + 20);
            v83 = *(a2 + 24);
            v36 |= v84 >> v83;
            v37 = v83 + 32;
            if (v83 == -32)
            {
              v85 = 0;
              *(a1 + 584) = v36 + 1;
              *(a2 + 20) = 0xFFFFFFF800000000;
              goto LABEL_183;
            }

            v38 = v84 << -v83;
          }

          else
          {
            v38 = 16 * v35;
          }

          *(a1 + 584) = v36 + 1;
          v85 = HIBYTE(v38);
          v86 = v37 - 8;
          *(a2 + 20) = v38;
          *(a2 + 24) = v86;
          if (v86 >= 0)
          {
            v87 = v38 << 8;
LABEL_186:
            *(a2 + 20) = v87;
            *(a1 + 585) = v85 + 1;
            if (((v85 + 1) & 0x100) != 0)
            {
              v186 = -8;
            }

            else
            {
              v187 = 0;
              do
              {
                v188 = *(a2 + 20);
                v189 = v188 >> 29;
                v190 = *(a2 + 24) - 3;
                *(a2 + 24) = v190;
                if (v190 < 0)
                {
                  TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
                  *a2 += 4;
                  v193 = *(a2 + 20);
                  v192 = *(a2 + 24);
                  v189 |= v193 >> v192;
                  *(a2 + 24) = v192 + 32;
                  if (v192 == -32)
                  {
                    v191 = 0;
                  }

                  else
                  {
                    v191 = v193 << -v192;
                  }
                }

                else
                {
                  v191 = 8 * v188;
                }

                *(a2 + 20) = v191;
                v194 = *(a1 + 600);
                v195 = *(a1 + 608);
                if (v194 >= v195)
                {
                  v197 = *(a1 + 592);
                  v198 = (v194 - v197);
                  v199 = v194 - v197 + 1;
                  if (v199 < 0)
                  {
                    std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
                  }

                  v200 = v195 - v197;
                  if (2 * v200 > v199)
                  {
                    v199 = 2 * v200;
                  }

                  if (v200 >= 0x3FFFFFFFFFFFFFFFLL)
                  {
                    v201 = 0x7FFFFFFFFFFFFFFFLL;
                  }

                  else
                  {
                    v201 = v199;
                  }

                  if (v201)
                  {
                    operator new();
                  }

                  v202 = v194 - v197;
                  *v198 = v189;
                  v196 = v198 + 1;
                  memcpy(0, v197, v202);
                  *(a1 + 592) = 0;
                  *(a1 + 600) = v198 + 1;
                  *(a1 + 608) = 0;
                  if (v197)
                  {
                    operator delete(v197);
                  }
                }

                else
                {
                  *v194 = v189;
                  v196 = v194 + 1;
                }

                *(a1 + 600) = v196;
                ++v187;
                v203 = *(a1 + 585);
              }

              while (v187 < v203);
              v186 = -3 * v203 - 8;
            }

            TBitstreamReader<unsigned int>::SkipBits(a2, v186 + 8 * *(a1 + 584));
            goto LABEL_308;
          }

          v82 = *a2;
LABEL_183:
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v82);
          *a2 += 4;
          v185 = *(a2 + 20);
          v184 = *(a2 + 24);
          v85 |= v185 >> v184;
          *(a2 + 24) = v184 + 32;
          if (v184 == -32)
          {
            v87 = 0;
          }

          else
          {
            v87 = v185 << -v184;
          }

          goto LABEL_186;
        default:
          goto LABEL_308;
      }
    }
  }
}

void std::vector<unsigned short>::push_back[abi:ne200100](uint64_t a1, _WORD *a2)
{
  v5 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v5 >= v4)
  {
    v7 = *a1;
    v8 = v5 - *a1;
    v9 = v8 >> 1;
    if (v8 >> 1 <= -2)
    {
      std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
    }

    v10 = v4 - v7;
    if (v10 <= v9 + 1)
    {
      v11 = v9 + 1;
    }

    else
    {
      v11 = v10;
    }

    if (v10 >= 0x7FFFFFFFFFFFFFFELL)
    {
      v12 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v12 = v11;
    }

    if (v12)
    {
      std::allocator<short>::allocate_at_least[abi:ne200100](v12);
    }

    v13 = (2 * v9);
    v14 = *a2;
    v15 = &v13[-(v8 >> 1)];
    *v13 = v14;
    v6 = v13 + 1;
    memcpy(v15, v7, v8);
    v16 = *a1;
    *a1 = v15;
    *(a1 + 8) = v6;
    *(a1 + 16) = 0;
    if (v16)
    {
      operator delete(v16);
    }
  }

  else
  {
    *v5 = *a2;
    v6 = v5 + 1;
  }

  *(a1 + 8) = v6;
}

void aia_format::GroupConfig::Parse(uint64_t a1, uint64_t a2, char a3, unint64_t a4)
{
  v8 = *(a2 + 20);
  v9 = v8 >> 21;
  v10 = *(a2 + 24) - 11;
  *(a2 + 24) = v10;
  if (v10 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v13 = *(a2 + 20);
    v12 = *(a2 + 24);
    v9 |= v13 >> v12;
    *(a2 + 24) = v12 + 32;
    if (v12 == -32)
    {
      v11 = 0;
    }

    else
    {
      v11 = v13 << -v12;
    }
  }

  else
  {
    v11 = v8 << 11;
  }

  *(a2 + 20) = v11;
  *a1 = v9;
  Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  *(a1 + 4) = Bit != 0;
  if (Bit)
  {
    return;
  }

  v15 = TBitstreamReader<unsigned int>::GetBit(a2);
  *(a1 + 5) = v15 != 0;
  v16 = *(a2 + 20);
  v17 = v16 >> 21;
  v18 = *(a2 + 24) - 11;
  *(a2 + 24) = v18;
  if (!v15)
  {
    if (v18 < 0)
    {
      TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      *a2 += 4;
      v28 = *(a2 + 20);
      v27 = *(a2 + 24);
      v17 |= v28 >> v27;
      *(a2 + 24) = v27 + 32;
      if (v27 == -32)
      {
        v20 = 0;
      }

      else
      {
        v20 = v28 << -v27;
      }
    }

    else
    {
      v20 = v16 << 11;
    }

    *(a2 + 20) = v20;
    *(a1 + 104) = v17;
    v44 = TBitstreamReader<unsigned int>::GetBit(a2);
    *(a1 + 108) = v44 != 0;
    if (v44)
    {
      v45 = *(a2 + 20);
      v46 = v45 >> 21;
      v47 = *(a2 + 24) - 11;
      *(a2 + 24) = v47;
      if (v47 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        *a2 += 4;
        v58 = *(a2 + 20);
        v57 = *(a2 + 24);
        v46 |= v58 >> v57;
        *(a2 + 24) = v57 + 32;
        if (v57 == -32)
        {
          v48 = 0;
        }

        else
        {
          v48 = v58 << -v57;
        }
      }

      else
      {
        v48 = v45 << 11;
      }

      *(a2 + 20) = v48;
      *(a1 + 112) = v46;
      return;
    }

    v49 = *(a1 + 120);
    v50 = *(a1 + 128);
    v51 = v50 - v49;
    v52 = *(a1 + 104);
    if (v52 == (v50 - v49) >> 1)
    {
      goto LABEL_81;
    }

    v53 = v52 - (v51 >> 1);
    if (v52 <= v51 >> 1)
    {
      if (v52 >= v51 >> 1)
      {
LABEL_80:
        LODWORD(v52) = *(a1 + 104);
LABEL_81:
        if (v52)
        {
          v69 = 0;
          v71 = *(a2 + 20);
          v70 = *(a2 + 24);
          do
          {
            v72 = v71 >> 21;
            v70 -= 11;
            *(a2 + 24) = v70;
            if (v70 < 0)
            {
              TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
              *a2 += 4;
              v74 = *(a2 + 20);
              v73 = *(a2 + 24);
              v72 |= v74 >> v73;
              v70 = v73 + 32;
              *(a2 + 24) = v73 + 32;
              if (v73 == -32)
              {
                v71 = 0;
              }

              else
              {
                v71 = v74 << -v73;
              }
            }

            else
            {
              v71 <<= 11;
            }

            *(a2 + 20) = v71;
            *(*(a1 + 120) + 2 * v69++) = v72;
          }

          while (v69 < *(a1 + 104));
        }

        return;
      }

      v61 = v49 + 2 * v52;
    }

    else
    {
      v54 = *(a1 + 136);
      if (v53 > (v54 - v50) >> 1)
      {
        v55 = v54 - v49;
        if (v55 > v52)
        {
          v52 = v55;
        }

        if (v55 >= 0x7FFFFFFFFFFFFFFELL)
        {
          v56 = 0x7FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v56 = v52;
        }

        std::allocator<short>::allocate_at_least[abi:ne200100](v56);
      }

      bzero(*(a1 + 128), 2 * v53);
      v61 = v50 + 2 * v53;
    }

    *(a1 + 128) = v61;
    goto LABEL_80;
  }

  if (v18 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    v21 = (*a2 + 4);
    *a2 = v21;
    v23 = *(a2 + 20);
    v22 = *(a2 + 24);
    v17 |= v23 >> v22;
    v18 = v22 + 32;
    if (v22 == -32)
    {
      v24 = 0;
      *(a1 + 8) = v17;
      *(a2 + 20) = 0xFFFFFFFD00000000;
      goto LABEL_21;
    }

    v19 = v23 << -v22;
  }

  else
  {
    v19 = v16 << 11;
  }

  *(a1 + 8) = v17;
  v24 = v19 >> 29;
  v25 = v18 - 3;
  *(a2 + 20) = v19;
  *(a2 + 24) = v18 - 3;
  if (v18 - 3 >= 0)
  {
    v26 = 8 * v19;
    goto LABEL_24;
  }

  v21 = *a2;
LABEL_21:
  TBitstreamReader<unsigned int>::FillCacheFrom(a2, v21);
  *a2 += 4;
  v30 = *(a2 + 20);
  v29 = *(a2 + 24);
  v24 |= v30 >> v29;
  v25 = v29 + 32;
  *(a2 + 24) = v29 + 32;
  if (v29 == -32)
  {
    v26 = 0;
  }

  else
  {
    v26 = v30 << -v29;
  }

LABEL_24:
  *(a2 + 20) = v26;
  *(a1 + 12) = v24;
  if (v24 > 1)
  {
    if (v24 == 2)
    {
      v37 = v26 >> 21;
      v38 = v25 - 11;
      *(a2 + 24) = v38;
      if (v38 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        *a2 += 4;
        v60 = *(a2 + 20);
        v59 = *(a2 + 24);
        v37 |= v60 >> v59;
        v38 = v59 + 32;
        *(a2 + 24) = v59 + 32;
        if (v59 == -32)
        {
          v39 = 0;
        }

        else
        {
          v39 = v60 << -v59;
        }
      }

      else
      {
        v39 = v26 << 11;
      }

      *(a2 + 20) = v39;
      *(a1 + 28) = v37;
      if (a3)
      {
        return;
      }

      v75 = v39 >> 28;
      v76 = v38 - 4;
      *(a2 + 24) = v76;
      if (v76 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        *a2 += 4;
        v79 = *(a2 + 20);
        v78 = *(a2 + 24);
        v75 |= v79 >> v78;
        *(a2 + 24) = v78 + 32;
        if (v78 == -32)
        {
          v77 = 0;
        }

        else
        {
          v77 = v79 << -v78;
        }
      }

      else
      {
        v77 = 16 * v39;
      }

      *(a2 + 20) = v77;
      *(a1 + 32) = v75;
      goto LABEL_98;
    }

    if (v24 != 3)
    {
      if (v24 == 4)
      {
        goto LABEL_28;
      }

LABEL_32:
      if (a3)
      {
        return;
      }

      goto LABEL_101;
    }

LABEL_34:
    v34 = v26 >> 21;
    v35 = v25 - 11;
    *(a2 + 24) = v35;
    if (v35 < 0)
    {
      TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      *a2 += 4;
      v41 = *(a2 + 20);
      v40 = *(a2 + 24);
      v34 |= v41 >> v40;
      *(a2 + 24) = v40 + 32;
      if (v40 == -32)
      {
        v36 = 0;
      }

      else
      {
        v36 = v41 << -v40;
      }
    }

    else
    {
      v36 = v26 << 11;
    }

    *(a2 + 20) = v36;
    *(a1 + 36) = v34;
    if (a3)
    {
      return;
    }

    *(a1 + 40) = apac::obj::readChannelLayoutTag(a2);
    goto LABEL_98;
  }

  if (!v24)
  {
    goto LABEL_34;
  }

  if (v24 != 1)
  {
    goto LABEL_32;
  }

LABEL_28:
  v31 = v26 >> 21;
  v32 = v25 - 11;
  *(a2 + 24) = v32;
  if (v32 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v43 = *(a2 + 20);
    v42 = *(a2 + 24);
    v31 |= v43 >> v42;
    *(a2 + 24) = v42 + 32;
    if (v42 == -32)
    {
      v33 = 0;
    }

    else
    {
      v33 = v43 << -v42;
    }
  }

  else
  {
    v33 = v26 << 11;
  }

  *(a2 + 20) = v33;
  *(a1 + 16) = v31;
  if ((a3 & 1) == 0)
  {
    aia_format::Importance::Parse((a1 + 20), a2);
  }

  v62 = TBitstreamReader<unsigned int>::GetBit(a2);
  *(a1 + 22) = v62 != 0;
  if (v62)
  {
    v63 = *(a2 + 20);
    v64 = v63 >> 21;
    v65 = *(a2 + 24) - 11;
    *(a2 + 24) = v65;
    if (v65 < 0)
    {
      TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      *a2 += 4;
      v68 = *(a2 + 20);
      v67 = *(a2 + 24);
      v64 |= v68 >> v67;
      *(a2 + 24) = v67 + 32;
      if (v67 == -32)
      {
        v66 = 0;
      }

      else
      {
        v66 = v68 << -v67;
      }
    }

    else
    {
      v66 = v63 << 11;
    }

    *(a2 + 20) = v66;
    *(a1 + 24) = v64;
  }

  if ((a3 & 1) == 0)
  {
LABEL_98:
    if ((HIDWORD(a4) | (a4 << 32)) > 0x100000003)
    {
      v80 = TBitstreamReader<unsigned int>::GetBit(a2);
      *(a1 + 144) = v80 != 0;
      if (v80)
      {
        *(a1 + 148) = apac::obj::readChannelLayoutTag(a2);
        *(a1 + 152) = apac::obj::readChannelLayoutTag(a2);
      }
    }

LABEL_101:
    v81 = *(a2 + 20);
    v82 = v81 >> 30;
    v83 = *(a2 + 24) - 2;
    *(a2 + 24) = v83;
    if (v83 < 0)
    {
      TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
      *a2 += 4;
      v86 = *(a2 + 20);
      v85 = *(a2 + 24);
      v82 |= v86 >> v85;
      *(a2 + 24) = v85 + 32;
      if (v85 == -32)
      {
        v84 = 0;
      }

      else
      {
        v84 = v86 << -v85;
      }
    }

    else
    {
      v84 = 4 * v81;
    }

    *(a2 + 20) = v84;
    *(a1 + 44) = v82;
    v87 = TBitstreamReader<unsigned int>::GetBit(a2);
    *(a1 + 48) = v87 != 0;
    if (v87)
    {
      memset(&__str, 0, sizeof(__str));
      v88 = 8;
      do
      {
        v89 = *(a2 + 20);
        v90 = HIBYTE(v89);
        v91 = *(a2 + 24) - 8;
        *(a2 + 24) = v91;
        if (v91 < 0)
        {
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
          *a2 += 4;
          v94 = *(a2 + 20);
          v93 = *(a2 + 24);
          v90 |= v94 >> v93;
          *(a2 + 24) = v93 + 32;
          if (v93 == -32)
          {
            v92 = 0;
          }

          else
          {
            v92 = v94 << -v93;
          }
        }

        else
        {
          v92 = v89 << 8;
        }

        *(a2 + 20) = v92;
        if (!v90)
        {
          break;
        }

        std::string::push_back(&__str, v90);
        --v88;
      }

      while (v88);
      std::string::operator=((a1 + 56), &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }

    v95 = TBitstreamReader<unsigned int>::GetBit(a2);
    *(a1 + 80) = v95 != 0;
    if (v95)
    {
      v96 = *(a2 + 20);
      v97 = v96 >> 30;
      v98 = *(a2 + 24) - 2;
      *(a2 + 24) = v98;
      if (v98 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        *a2 += 4;
        v101 = *(a2 + 20);
        v100 = *(a2 + 24);
        v97 |= v101 >> v100;
        v98 = v100 + 32;
        *(a2 + 24) = v100 + 32;
        v99 = v100 == -32 ? 0 : v101 << -v100;
      }

      else
      {
        v99 = 4 * v96;
      }

      *(a2 + 20) = v99;
      *(a1 + 84) = v97;
      if (v97)
      {
        v102 = 0;
        do
        {
          v103 = HIBYTE(v99);
          v98 -= 8;
          *(a2 + 24) = v98;
          if (v98 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v105 = *(a2 + 20);
            v104 = *(a2 + 24);
            v103 |= v105 >> v104;
            v98 = v104 + 32;
            *(a2 + 24) = v104 + 32;
            if (v104 == -32)
            {
              v99 = 0;
            }

            else
            {
              v99 = v105 << -v104;
            }
          }

          else
          {
            v99 <<= 8;
          }

          *(a2 + 20) = v99;
          *(a1 + 88 + 4 * v102++) = v103;
        }

        while (v102 < *(a1 + 84));
      }
    }
  }
}

void sub_19B0A2AF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void aia_format::RendererData::Parse(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 20);
  v5 = v4 >> 21;
  v6 = *(a2 + 24) - 11;
  *(a2 + 24) = v6;
  if (v6 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v9 = *(a2 + 20);
    v8 = *(a2 + 24);
    v5 = (v9 >> v8) | v5;
    *(a2 + 24) = v8 + 32;
    if (v8 == -32)
    {
      v7 = 0;
    }

    else
    {
      v7 = v9 << -v8;
    }
  }

  else
  {
    v7 = v4 << 11;
  }

  *(a2 + 20) = v7;
  *(a1 + 8) = *a1;
  if (v5)
  {
    v10 = 0;
    while (1)
    {
      v11 = *(a2 + 20);
      v12 = v11 >> 21;
      v13 = *(a2 + 24) - 11;
      *(a2 + 24) = v13;
      if (v13 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
        *a2 += 4;
        v16 = *(a2 + 20);
        v15 = *(a2 + 24);
        v12 |= v16 >> v15;
        *(a2 + 24) = v15 + 32;
        if (v15 == -32)
        {
          v14 = 0;
        }

        else
        {
          v14 = v16 << -v15;
        }
      }

      else
      {
        v14 = v11 << 11;
      }

      *(a2 + 20) = v14;
      v134 = v12;
      std::vector<unsigned short>::push_back[abi:ne200100](a1, &v134);
      switch(v12)
      {
        case 0:
          v17 = a1 + 24;
          goto LABEL_44;
        case 1:
          Bit = TBitstreamReader<unsigned int>::GetBit(a2);
          *(a1 + 85) = Bit != 0;
          if (Bit)
          {
            *(a1 + 88) = apac::obj::readFloat(a2);
            *(a1 + 92) = apac::obj::readFloat(a2);
            v35 = TBitstreamReader<unsigned int>::GetBit(a2);
            *(a1 + 100) = v35 != 0;
            if (v35)
            {
              *(a1 + 96) = apac::obj::readFloat(a2);
            }
          }

          else
          {
            *(a1 + 104) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
            *(a1 + 108) = apac::obj::readFloat(a2);
            v70 = *(a2 + 20);
            v71 = v70 >> 27;
            v72 = *(a2 + 24) - 5;
            *(a2 + 24) = v72;
            if (v72 < 0)
            {
              TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
              *a2 += 4;
              v98 = *(a2 + 20);
              v97 = *(a2 + 24);
              v71 |= v98 >> v97;
              *(a2 + 24) = v97 + 32;
              if (v97 == -32)
              {
                v73 = 0;
              }

              else
              {
                v73 = v98 << -v97;
              }
            }

            else
            {
              v73 = 32 * v70;
            }

            *(a2 + 20) = v73;
            *(a1 + 112) = v71;
            *(a1 + 116) = apac::obj::readFloat(a2);
            *(a1 + 120) = apac::obj::readFloat(a2);
            v116 = TBitstreamReader<unsigned int>::GetBit(a2);
            *(a1 + 113) = v116 != 0;
            if (v116)
            {
              *(a1 + 124) = apac::obj::readFloat(a2);
            }
          }

          goto LABEL_170;
        case 2:
          aia_format::Gain::Parse(a1 + 128, a2);
          goto LABEL_170;
        case 3:
          aia_format::Distance::Parse(a1 + 136, a2);
          goto LABEL_170;
        case 4:
          aia_format::ChannelLock::Parse(a1 + 144, a2);
          goto LABEL_170;
        case 5:
          aia_format::ObjectDivergence::Parse(a1 + 152, a2);
          goto LABEL_170;
        case 6:
          *(a1 + 172) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
          goto LABEL_170;
        case 7:
          aia_format::ZoneExclusion::Parse(a1 + 176, a2);
          goto LABEL_170;
        case 8:
          v50 = *(a2 + 20);
          v51 = v50 >> 29;
          v52 = *(a2 + 24) - 3;
          *(a2 + 24) = v52;
          if (v52 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v79 = *(a2 + 20);
            v78 = *(a2 + 24);
            v51 |= v79 >> v78;
            *(a2 + 24) = v78 + 32;
            if (v78 == -32)
            {
              v53 = 0;
            }

            else
            {
              v53 = v79 << -v78;
            }
          }

          else
          {
            v53 = 8 * v50;
          }

          *(a2 + 20) = v53;
          *(a1 + 1044) = v51;
          goto LABEL_170;
        case 9:
          v22 = *(a2 + 20);
          v23 = v22 >> 29;
          v24 = *(a2 + 24) - 3;
          *(a2 + 24) = v24;
          if (v24 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v65 = *(a2 + 20);
            v64 = *(a2 + 24);
            v23 |= v65 >> v64;
            v24 = v64 + 32;
            *(a2 + 24) = v64 + 32;
            if (v64 == -32)
            {
              v25 = 0;
            }

            else
            {
              v25 = v65 << -v64;
            }
          }

          else
          {
            v25 = 8 * v22;
          }

          *(a2 + 20) = v25;
          *(a1 + 1048) = v23;
          if (v23 == 1)
          {
            v91 = v25 >> 22;
            v92 = v24 - 10;
            *(a2 + 24) = v92;
            if (v92 < 0)
            {
              TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
              *a2 += 4;
              v95 = *(a2 + 20);
              v94 = *(a2 + 24);
              v91 |= v95 >> v94;
              *(a2 + 24) = v94 + 32;
              if (v94 == -32)
              {
                v93 = 0;
              }

              else
              {
                v93 = v95 << -v94;
              }
            }

            else
            {
              v93 = v25 << 10;
            }

            *(a2 + 20) = v93;
            *(a1 + 1052) = v91;
            if (TBitstreamReader<unsigned int>::GetBit(a2))
            {
              *(a1 + 1056) = apac::obj::readFloat(a2);
              *(a1 + 1060) = 1;
            }

            if (TBitstreamReader<unsigned int>::GetBit(a2))
            {
              *(a1 + 1064) = apac::obj::readFloat(a2);
              *(a1 + 1068) = 1;
            }

            if (TBitstreamReader<unsigned int>::GetBit(a2))
            {
              *(a1 + 1072) = apac::obj::readFloat(a2);
              *(a1 + 1076) = 1;
            }

            if (TBitstreamReader<unsigned int>::GetBit(a2))
            {
              *(a1 + 1080) = apac::obj::readFloat(a2);
              *(a1 + 1084) = 1;
            }

            if (TBitstreamReader<unsigned int>::GetBit(a2))
            {
              *(a1 + 1088) = apac::obj::readFloat(a2);
              *(a1 + 1092) = 1;
            }

            *(a1 + 1120) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
            if (TBitstreamReader<unsigned int>::GetBit(a2))
            {
              *(a1 + 1096) = apac::obj::readFloat(a2);
              *(a1 + 1100) = 1;
            }

            if (TBitstreamReader<unsigned int>::GetBit(a2))
            {
              *(a1 + 1104) = apac::obj::readFloat(a2);
              *(a1 + 1108) = 1;
            }

            if (TBitstreamReader<unsigned int>::GetBit(a2))
            {
              *(a1 + 1112) = apac::obj::readFloat(a2);
              *(a1 + 1116) = 1;
            }
          }

          goto LABEL_170;
        case 10:
          v46 = *(a2 + 20);
          v47 = v46 >> 29;
          v48 = *(a2 + 24) - 3;
          *(a2 + 24) = v48;
          if (v48 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v77 = *(a2 + 20);
            v76 = *(a2 + 24);
            v47 |= v77 >> v76;
            *(a2 + 24) = v76 + 32;
            if (v76 == -32)
            {
              v49 = 0;
            }

            else
            {
              v49 = v77 << -v76;
            }
          }

          else
          {
            v49 = 8 * v46;
          }

          *(a2 + 20) = v49;
          *(a1 + 1124) = v47;
          if (v47 == 1)
          {
            v99 = TBitstreamReader<unsigned int>::GetBit(a2);
            *(a1 + 1128) = v99 != 0;
            if (v99)
            {
              *(a1 + 1132) = apac::obj::readFloat(a2);
            }
          }

          goto LABEL_170;
        case 11:
          v18 = *(a2 + 20);
          v19 = v18 >> 29;
          v20 = *(a2 + 24) - 3;
          *(a2 + 24) = v20;
          if (v20 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v63 = *(a2 + 20);
            v62 = *(a2 + 24);
            v19 |= v63 >> v62;
            v20 = v62 + 32;
            *(a2 + 24) = v62 + 32;
            if (v62 == -32)
            {
              v21 = 0;
            }

            else
            {
              v21 = v63 << -v62;
            }
          }

          else
          {
            v21 = 8 * v18;
          }

          *(a2 + 20) = v21;
          *(a1 + 1136) = v19;
          if (v19 == 1)
          {
            v86 = v21 >> 22;
            v87 = v20 - 10;
            *(a2 + 24) = v87;
            if (v87 < 0)
            {
              TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
              *a2 += 4;
              v90 = *(a2 + 20);
              v89 = *(a2 + 24);
              v86 |= v90 >> v89;
              *(a2 + 24) = v89 + 32;
              if (v89 == -32)
              {
                v88 = 0;
              }

              else
              {
                v88 = v90 << -v89;
              }
            }

            else
            {
              v88 = v21 << 10;
            }

            *(a2 + 20) = v88;
            *(a1 + 1140) = v86;
          }

          goto LABEL_170;
        case 12:
          aia_format::HeadphoneVirtualize::Parse(a1 + 1144, a2);
          goto LABEL_170;
        case 13:
          *(a1 + 1152) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
          *(a1 + 1153) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
          v42 = *(a2 + 20);
          v43 = v42 >> 29;
          v44 = *(a2 + 24) - 3;
          *(a2 + 24) = v44;
          if (v44 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v75 = *(a2 + 20);
            v74 = *(a2 + 24);
            v43 |= v75 >> v74;
            *(a2 + 24) = v74 + 32;
            if (v74 == -32)
            {
              v45 = 0;
            }

            else
            {
              v45 = v75 << -v74;
            }
          }

          else
          {
            v45 = 8 * v42;
          }

          *(a2 + 20) = v45;
          *(a1 + 1156) = v43;
          goto LABEL_170;
        case 14:
          *(a1 + 1160) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
          goto LABEL_170;
        case 15:
          v30 = *(a2 + 20);
          v31 = v30 >> 29;
          v32 = *(a2 + 24) - 3;
          *(a2 + 24) = v32;
          if (v32 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v69 = *(a2 + 20);
            v68 = *(a2 + 24);
            v31 |= v69 >> v68;
            *(a2 + 24) = v68 + 32;
            if (v68 == -32)
            {
              v33 = 0;
            }

            else
            {
              v33 = v69 << -v68;
            }
          }

          else
          {
            v33 = 8 * v30;
          }

          *(a2 + 20) = v33;
          *(a1 + 1161) = v31;
          goto LABEL_170;
        case 16:
          *(a1 + 1164) = apac::obj::readFloat(a2);
          goto LABEL_170;
        case 17:
          v36 = TBitstreamReader<unsigned int>::GetBit(a2);
          *(a1 + 1168) = v36 != 0;
          if (v36)
          {
            v37 = TBitstreamReader<unsigned int>::GetBit(a2);
            *(a1 + 1169) = v37 != 0;
            if (v37)
            {
              v38 = *(a2 + 20);
              v39 = v38 >> 28;
              v40 = *(a2 + 24) - 4;
              *(a2 + 24) = v40;
              if (v40 < 0)
              {
                TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
                *a2 += 4;
                v85 = *(a2 + 20);
                v84 = *(a2 + 24);
                v39 |= v85 >> v84;
                *(a2 + 24) = v84 + 32;
                if (v84 == -32)
                {
                  v41 = 0;
                }

                else
                {
                  v41 = v85 << -v84;
                }
              }

              else
              {
                v41 = 16 * v38;
              }

              *(a2 + 20) = v41;
              *(a1 + 1171) = v39;
            }

            else
            {
              *(a1 + 1170) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
              *(a1 + 1172) = 0;
              aia_format::Zone::Parse(a1 + 1172, a2);
            }
          }

          goto LABEL_170;
        case 18:
          v17 = a1 + 1224;
          goto LABEL_44;
        case 19:
          *(a1 + 1284) = apac::obj::readFloat(a2);
          goto LABEL_170;
        case 20:
          v17 = a1 + 1288;
LABEL_44:
          aia_format::Position::Parse(v17, a2);
          goto LABEL_170;
        case 21:
          *(a1 + 1348) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;
          goto LABEL_170;
        case 22:
          v54 = *(a2 + 20);
          v55 = v54 >> 30;
          v56 = *(a2 + 24) - 2;
          *(a2 + 24) = v56;
          if (v56 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v81 = *(a2 + 20);
            v80 = *(a2 + 24);
            v55 |= v81 >> v80;
            v56 = v80 + 32;
            *(a2 + 24) = v80 + 32;
            if (v80 == -32)
            {
              v57 = 0;
            }

            else
            {
              v57 = v81 << -v80;
            }
          }

          else
          {
            v57 = 4 * v54;
          }

          *(a2 + 20) = v57;
          *(a1 + 1352) = v55;
          if (v55 == 2)
          {
            goto LABEL_110;
          }

          if (v55 != 1)
          {
            if (v55)
            {
              goto LABEL_170;
            }

LABEL_110:
            v100 = HIBYTE(v57);
            v101 = v56 - 8;
            *(a2 + 24) = v101;
            if (v101 >= 0)
            {
              v102 = v57 << 8;
              goto LABEL_116;
            }

            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            v106 = (*a2 + 4);
            *a2 = v106;
            v108 = *(a2 + 20);
            v107 = *(a2 + 24);
            v100 |= v108 >> v107;
            v101 = v107 + 32;
            if (v107 == -32)
            {
              v109 = 0;
              *(a1 + 1354) = v100;
              *(a2 + 20) = 0xFFFFFFF800000000;
            }

            else
            {
              v102 = v108 << -v107;
LABEL_116:
              *(a1 + 1354) = v100;
              v109 = HIBYTE(v102);
              v110 = v101 - 8;
              *(a2 + 20) = v102;
              *(a2 + 24) = v110;
              if (v110 >= 0)
              {
                v111 = v102 << 8;
LABEL_146:
                *(a2 + 20) = v111;
                *(a1 + 1356) = v109;
                goto LABEL_170;
              }

              v106 = *a2;
            }

            TBitstreamReader<unsigned int>::FillCacheFrom(a2, v106);
            *a2 += 4;
            v115 = *(a2 + 20);
            v114 = *(a2 + 24);
            v109 |= v115 >> v114;
            *(a2 + 24) = v114 + 32;
            if (v114 == -32)
            {
              v111 = 0;
            }

            else
            {
              v111 = v115 << -v114;
            }

            goto LABEL_146;
          }

          v103 = v57 >> 28;
          v104 = v56 - 4;
          *(a2 + 24) = v104;
          if (v104 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v113 = *(a2 + 20);
            v112 = *(a2 + 24);
            v103 |= v113 >> v112;
            *(a2 + 24) = v112 + 32;
            if (v112 == -32)
            {
              v105 = 0;
            }

            else
            {
              v105 = v113 << -v112;
            }
          }

          else
          {
            v105 = 16 * v57;
          }

          *(a2 + 20) = v105;
          *(a1 + 1358) = v103;
          ChannelLayoutTag = apac::obj::readChannelLayoutTag(a2);
          *(a1 + 1360) = ChannelLayoutTag;
          v118 = ChannelLayoutTag;
          v119 = *(a1 + 1384);
          v120 = *(a1 + 1376);
          v121 = &v119[-v120];
          v133 = (*(a1 + 1358) + 1) * (*(a1 + 1358) + 1);
          v122 = v133 * ChannelLayoutTag;
          if (v122 == &v119[-v120] >> 2)
          {
            goto LABEL_166;
          }

          v123 = v122 - (v121 >> 2);
          if (v122 > v121 >> 2)
          {
            v124 = *(a1 + 1392);
            if (v123 > (v124 - v119) >> 2)
            {
              v125 = v124 - v120;
              if (v125 >> 1 > v122)
              {
                v122 = v125 >> 1;
              }

              if (v125 >= 0x7FFFFFFFFFFFFFFCLL)
              {
                v126 = 0x3FFFFFFFFFFFFFFFLL;
              }

              else
              {
                v126 = v122;
              }

              std::allocator<float>::allocate_at_least[abi:ne200100](ChannelLayoutTag, v126);
            }

            bzero(v119, 4 * v123);
            v127 = &v119[4 * v123];
            goto LABEL_165;
          }

          if (v122 < v121 >> 2)
          {
            v127 = (v120 + 4 * v122);
LABEL_165:
            *(a1 + 1384) = v127;
          }

LABEL_166:
          v128 = 0;
          v129 = 0;
          do
          {
            v130 = v5;
            v131 = v128;
            v132 = v118;
            if (v118)
            {
              do
              {
                *(*(a1 + 1376) + v131) = apac::obj::readFloat(a2);
                v131 += 4;
                --v132;
              }

              while (v132);
            }

            ++v129;
            v128 += 4 * v118;
            v5 = v130;
          }

          while (v129 != v133);
LABEL_170:
          if (++v10 == v5)
          {
            return;
          }

          break;
        case 23:
          aia_format::Distance::Parse(a1 + 1424, a2);
          goto LABEL_170;
        case 24:
          v26 = *(a2 + 20);
          v27 = v26 >> 30;
          v28 = *(a2 + 24) - 2;
          *(a2 + 24) = v28;
          if (v28 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v67 = *(a2 + 20);
            v66 = *(a2 + 24);
            v27 |= v67 >> v66;
            *(a2 + 24) = v66 + 32;
            if (v66 == -32)
            {
              v29 = 0;
            }

            else
            {
              v29 = v67 << -v66;
            }
          }

          else
          {
            v29 = 4 * v26;
          }

          *(a2 + 20) = v29;
          *(a1 + 1432) = v27;
          if (v27)
          {
            v96 = TBitstreamReader<unsigned int>::GetBit(a2);
            *(a1 + 1433) = v96 != 0;
            if (v96)
            {
              *(a1 + 1436) = apac::obj::readFloat(a2);
            }
          }

          goto LABEL_170;
        default:
          *(a1 + 8) -= 2;
          v58 = *(a2 + 20);
          v59 = HIBYTE(v58);
          v60 = *(a2 + 24) - 8;
          *(a2 + 24) = v60;
          if (v60 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
            *a2 += 4;
            v83 = *(a2 + 20);
            v82 = *(a2 + 24);
            v59 |= v83 >> v82;
            *(a2 + 24) = v82 + 32;
            if (v82 == -32)
            {
              v61 = 0;
            }

            else
            {
              v61 = v83 << -v82;
            }
          }

          else
          {
            v61 = v58 << 8;
          }

          *(a2 + 20) = v61;
          TBitstreamReader<unsigned int>::SkipBits(a2, 8 * v59);
          goto LABEL_170;
      }
    }
  }
}

uint64_t aia_format::Header::Parse(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 20);
  v5 = HIWORD(v4);
  v6 = *(a2 + 24) - 16;
  *(a2 + 24) = v6;
  if (v6 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v9 = *(a2 + 20);
    v8 = *(a2 + 24);
    v5 |= v9 >> v8;
    v6 = v8 + 32;
    *(a2 + 24) = v8 + 32;
    if (v8 == -32)
    {
      v7 = 0;
    }

    else
    {
      v7 = v9 << -v8;
    }
  }

  else
  {
    v7 = v4 << 16;
  }

  *(a2 + 20) = v7;
  if (v5 != 0xFFFF)
  {
    return 1;
  }

  *a1 = -1;
  v10 = HIWORD(v7);
  v11 = v6 - 16;
  *(a2 + 24) = v11;
  if (v11 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    v14 = (*a2 + 4);
    *a2 = v14;
    v16 = *(a2 + 20);
    v15 = *(a2 + 24);
    v10 |= v16 >> v15;
    v11 = v15 + 32;
    if (v15 == -32)
    {
      v17 = 0;
      *(a1 + 2) = v10;
      *(a2 + 20) = 0xFFFFFFF800000000;
      goto LABEL_16;
    }

    v12 = v16 << -v15;
  }

  else
  {
    v12 = v7 << 16;
  }

  *(a1 + 2) = v10;
  v17 = HIBYTE(v12);
  v18 = v11 - 8;
  *(a2 + 20) = v12;
  *(a2 + 24) = v18;
  if (v18 >= 0)
  {
    v19 = v12 << 8;
    goto LABEL_18;
  }

  v14 = *a2;
LABEL_16:
  TBitstreamReader<unsigned int>::FillCacheFrom(a2, v14);
  v20 = (*a2 + 4);
  *a2 = v20;
  v22 = *(a2 + 20);
  v21 = *(a2 + 24);
  v17 |= v22 >> v21;
  v18 = v21 + 32;
  if (v21 == -32)
  {
    v23 = 0;
    *(a1 + 4) = v17;
    *(a2 + 20) = 0xFFFFFFF800000000;
    goto LABEL_22;
  }

  v19 = v22 << -v21;
LABEL_18:
  *(a1 + 4) = v17;
  v23 = HIBYTE(v19);
  v24 = v18 - 8;
  *(a2 + 20) = v19;
  *(a2 + 24) = v24;
  if (v24 >= 0)
  {
    v25 = v19 << 8;
    goto LABEL_25;
  }

  v20 = *a2;
LABEL_22:
  TBitstreamReader<unsigned int>::FillCacheFrom(a2, v20);
  *a2 += 4;
  v27 = *(a2 + 20);
  v26 = *(a2 + 24);
  v23 |= v27 >> v26;
  v24 = v26 + 32;
  *(a2 + 24) = v26 + 32;
  if (v26 == -32)
  {
    v25 = 0;
  }

  else
  {
    v25 = v27 << -v26;
  }

LABEL_25:
  *(a2 + 20) = v25;
  *(a1 + 8) = v23;
  if ((v23 | (*(a1 + 4) << 32)) < 0x100000003)
  {
    return 4;
  }

  v28 = HIBYTE(v25);
  v29 = v24 - 8;
  *(a2 + 24) = v29;
  if (v29 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v32 = *(a2 + 20);
    v31 = *(a2 + 24);
    v28 |= v32 >> v31;
    *(a2 + 24) = v31 + 32;
    if (v31 == -32)
    {
      v30 = 0;
    }

    else
    {
      v30 = v32 << -v31;
    }
  }

  else
  {
    v30 = v25 << 8;
  }

  result = 0;
  *(a2 + 20) = v30;
  *(a1 + 12) = v28;
  *(a1 + 16) = 0;
  return result;
}

uint64_t aia_format::Header::ParseLive(aia_format::Header *this, uint64_t a2)
{
  v4 = *(a2 + 20);
  v5 = HIWORD(v4);
  v6 = *(a2 + 24) - 16;
  *(a2 + 24) = v6;
  if (v6 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v9 = *(a2 + 20);
    v8 = *(a2 + 24);
    v5 |= v9 >> v8;
    v6 = v8 + 32;
    *(a2 + 24) = v8 + 32;
    if (v8 == -32)
    {
      v7 = 0;
    }

    else
    {
      v7 = v9 << -v8;
    }
  }

  else
  {
    v7 = v4 << 16;
  }

  *(a2 + 20) = v7;
  if (v5 != 43690)
  {
    return 1;
  }

  v10 = HIWORD(v7);
  v11 = v6 - 16;
  *(a2 + 24) = v11;
  if (v11 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v14 = *(a2 + 20);
    v13 = *(a2 + 24);
    v10 |= v14 >> v13;
    v11 = v13 + 32;
    *(a2 + 24) = v13 + 32;
    v12 = v13 == -32 ? 0 : v14 << -v13;
  }

  else
  {
    v12 = v7 << 16;
  }

  *(a2 + 20) = v12;
  if (v10 != 43690)
  {
    return 1;
  }

  v15 = HIWORD(v12);
  v16 = v11 - 16;
  *(a2 + 24) = v16;
  if (v16 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v19 = *(a2 + 20);
    v18 = *(a2 + 24);
    v15 |= v19 >> v18;
    v16 = v18 + 32;
    *(a2 + 24) = v18 + 32;
    v17 = v18 == -32 ? 0 : v19 << -v18;
  }

  else
  {
    v17 = v12 << 16;
  }

  *(a2 + 20) = v17;
  if (v15 != 43690)
  {
    return 1;
  }

  v20 = HIWORD(v17);
  v21 = v16 - 16;
  *(a2 + 24) = v21;
  if (v21 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v24 = *(a2 + 20);
    v23 = *(a2 + 24);
    v20 |= v24 >> v23;
    v21 = v23 + 32;
    *(a2 + 24) = v23 + 32;
    v22 = v23 == -32 ? 0 : v24 << -v23;
  }

  else
  {
    v22 = v17 << 16;
  }

  *(a2 + 20) = v22;
  if (v20 != 0xFFFF)
  {
    return 1;
  }

  v25 = HIWORD(v22);
  v26 = v21 - 16;
  *(a2 + 24) = v26;
  if (v26 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    *a2 += 4;
    v29 = *(a2 + 20);
    v28 = *(a2 + 24);
    v25 |= v29 >> v28;
    v26 = v28 + 32;
    *(a2 + 24) = v28 + 32;
    v27 = v28 == -32 ? 0 : v29 << -v28;
  }

  else
  {
    v27 = v22 << 16;
  }

  *(a2 + 20) = v27;
  *(this + 1) = v25;
  if (!v25)
  {
    return 1;
  }

  v30 = HIBYTE(v27);
  v31 = v26 - 8;
  *(a2 + 24) = v31;
  if (v31 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    v34 = (*a2 + 4);
    *a2 = v34;
    v36 = *(a2 + 20);
    v35 = *(a2 + 24);
    v30 |= v36 >> v35;
    v31 = v35 + 32;
    if (v35 == -32)
    {
      v37 = 0;
      *(this + 1) = v30;
      *(a2 + 20) = 0xFFFFFFF800000000;
      goto LABEL_41;
    }

    v32 = v36 << -v35;
  }

  else
  {
    v32 = v27 << 8;
  }

  *(this + 1) = v30;
  v37 = HIBYTE(v32);
  v38 = v31 - 8;
  *(a2 + 20) = v32;
  *(a2 + 24) = v38;
  if (v38 >= 0)
  {
    v39 = v32 << 8;
    goto LABEL_44;
  }

  v34 = *a2;
LABEL_41:
  TBitstreamReader<unsigned int>::FillCacheFrom(a2, v34);
  *a2 += 4;
  v41 = *(a2 + 20);
  v40 = *(a2 + 24);
  v37 |= v41 >> v40;
  v38 = v40 + 32;
  *(a2 + 24) = v40 + 32;
  if (v40 == -32)
  {
    v39 = 0;
  }

  else
  {
    v39 = v41 << -v40;
  }

LABEL_44:
  *(a2 + 20) = v39;
  *(this + 2) = v37;
  if ((v37 | (*(this + 1) << 32)) < 0x100000003)
  {
    return 4;
  }

  v42 = HIBYTE(v39);
  v43 = v38 - 8;
  *(a2 + 24) = v43;
  if (v43 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *a2);
    v45 = (*a2 + 4);
    *a2 = v45;
    v47 = *(a2 + 20);
    v46 = *(a2 + 24);
    v42 |= v47 >> v46;
    v43 = v46 + 32;
    if (v46 == -32)
    {
      v48 = 0;
      *(this + 12) = v42;
      *(a2 + 20) = 0xFFFFFFF000000000;
LABEL_54:
      TBitstreamReader<unsigned int>::FillCacheFrom(a2, v45);
      *a2 += 4;
      v52 = *(a2 + 20);
      v51 = *(a2 + 24);
      v48 |= v52 >> v51;
      *(a2 + 24) = v51 + 32;
      if (v51 == -32)
      {
        v50 = 0;
      }

      else
      {
        v50 = v52 << -v51;
      }

      goto LABEL_57;
    }

    v44 = v47 << -v46;
  }

  else
  {
    v44 = v39 << 8;
  }

  *(this + 12) = v42;
  v48 = HIWORD(v44);
  v49 = v43 - 16;
  *(a2 + 20) = v44;
  *(a2 + 24) = v49;
  if (v49 < 0)
  {
    v45 = *a2;
    goto LABEL_54;
  }

  v50 = v44 << 16;
LABEL_57:
  *(a2 + 20) = v50;
  *(this + 7) = v48;
  v53 = aia_format::Header::CalculateCrcChecksum(this);
  result = 1;
  if (v53 == v48)
  {
    *(this + 16) = 1;
    return 0;
  }

  return result;
}

uint64_t aia_format::Header::CalculateCrcChecksum(aia_format::Header *this)
{
  v2 = this + 17;
  v8 = -1431655766;
  v6[0] = this + 17;
  v6[1] = this + 17;
  v6[2] = this + 32;
  v6[3] = 0x2000000000;
  v7 = (this + 17) & 3;
  TBitstreamWriter<unsigned int>::PutBits(v6, 43690, 0x10u);
  TBitstreamWriter<unsigned int>::PutBits(v6, 43690, 0x10u);
  TBitstreamWriter<unsigned int>::PutBits(v6, 43690, 0x10u);
  TBitstreamWriter<unsigned int>::PutBits(v6, *this, 0x10u);
  TBitstreamWriter<unsigned int>::PutBits(v6, *(this + 1), 0x10u);
  TBitstreamWriter<unsigned int>::PutBits(v6, *(this + 1), 8u);
  TBitstreamWriter<unsigned int>::PutBits(v6, *(this + 2), 8u);
  TBitstreamWriter<unsigned int>::PutBits(v6, *(this + 12), 8u);
  TBitstreamWriter<unsigned int>::Flush(v6);
  v3 = 0;
  v4 = -1;
  do
  {
    v4 = aia_format::crc16_table[v2[v3++] ^ ((v4 & 0xFF00) >> 8)] ^ (v4 << 8);
  }

  while (v3 != 13);
  return v4;
}

uint64_t aia_format::Header::Pack(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 16) == 1)
  {
    TBitstreamWriter<unsigned int>::PutBits(a2, 43690, 0x10u);
    TBitstreamWriter<unsigned int>::PutBits(a2, 43690, 0x10u);
    TBitstreamWriter<unsigned int>::PutBits(a2, 43690, 0x10u);
    TBitstreamWriter<unsigned int>::PutBits(a2, 0xFFFF, 0x10u);
    TBitstreamWriter<unsigned int>::PutBits(a2, *(a1 + 2), 0x10u);
    TBitstreamWriter<unsigned int>::PutBits(a2, *(a1 + 4), 8u);
    TBitstreamWriter<unsigned int>::PutBits(a2, *(a1 + 8), 8u);
    TBitstreamWriter<unsigned int>::PutBits(a2, *(a1 + 12), 8u);
    v4 = *(a1 + 14);
    v5 = a2;
    v6 = 16;
  }

  else
  {
    TBitstreamWriter<unsigned int>::PutBits(a2, 0xFFFF, 0x10u);
    TBitstreamWriter<unsigned int>::PutBits(a2, *(a1 + 2), 0x10u);
    TBitstreamWriter<unsigned int>::PutBits(a2, 1, 8u);
    TBitstreamWriter<unsigned int>::PutBits(a2, 4, 8u);
    v4 = *(a1 + 12);
    v5 = a2;
    v6 = 8;
  }

  return TBitstreamWriter<unsigned int>::PutBits(v5, v4, v6);
}

void aia_format::BlockFormatBase::ParseBase(uint64_t a1, uint64_t a2)
{
  aia_format::Distance::Parse(a1, a2);
  aia_format::Gain::Parse(a1 + 8, a2);
  aia_format::Importance::Parse((a1 + 16), a2);
  *(a1 + 18) = TBitstreamReader<unsigned int>::GetBit(a2) != 0;

  aia_format::HeadphoneVirtualize::Parse(a1 + 20, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return MEMORY[0x1EEE63B20](this, a2);
}

{
  return MEMORY[0x1EEE63B38](this, a2);
}

uint64_t std::to_chars(std::__1 *this, char *a2, char *a3, double a4)
{
  return MEMORY[0x1EEE64438](this, a2, a3, a4);
}

{
  return MEMORY[0x1EEE64450](this, a2, a3, a4);
}

uint64_t std::to_chars()
{
  return MEMORY[0x1EEE64440]();
}

{
  return MEMORY[0x1EEE64448]();
}

{
  return MEMORY[0x1EEE64458]();
}

{
  return MEMORY[0x1EEE64460]();
}

{
  return MEMORY[0x1EEE64470]();
}

{
  return MEMORY[0x1EEE64478]();
}

void operator delete[]()
{
    ;
  }
}

void operator delete(void *__p)
{
    ;
  }
}

void operator delete()
{
    ;
  }
}

void operator new[]()
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
    ;
  }
}

void operator new()
{
    ;
  }
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x1EEE73570](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x1EEE73578](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}