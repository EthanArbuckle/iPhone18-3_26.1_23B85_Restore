void _SparseCreatePreconditioner_Complex_Float(int a1@<W0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (a1 <= 1)
  {
    if (a1)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_23670BA40();
      }
    }

    else if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_23670BA84();
    }

    _SparseTrap();
  }

  if (a1 == 2)
  {
    v5 = *(a2 + 28);
    v6 = *a2 * v5;
    v7 = *(a2 + 4) * v5;
    if (v6 >= v7)
    {
      v8 = v7;
    }

    else
    {
      v8 = v6;
    }

    *a3 = 2;
    v9 = malloc_type_malloc(8 * v8, 0x100004000313F17uLL);
    v10 = v9;
    a3[1] = v9;
    a3[2] = sub_2367A525C;
    if (v8 >= 1)
    {
      v11 = v9;
      do
      {
        *v11++ = 1065353216;
        --v8;
      }

      while (v8);
    }

    if ((*(a2 + 24) & 0x1C) != 8)
    {
      v12 = *(a2 + 4);
      if (v12 >= 1)
      {
        v13 = 0;
        v14 = 0;
        v15 = *(a2 + 28);
        v16 = v15 * v15;
        v17 = *(a2 + 8);
        v18 = v15;
        do
        {
          v19 = v14;
          v20 = *(v17 + 8 * v14++);
          if (v20 < *(v17 + 8 * v14))
          {
            do
            {
              if (v19 == *(*(a2 + 16) + 4 * v20) && v18)
              {
                v21 = 0;
                v22 = &v10[v13 * v15];
                do
                {
                  v23 = (*(a2 + 32) + 8 * v20 * v16 + 8 * (v21 + v21 * v18));
                  v24 = v23[1];
                  if (*v23 != 0.0 || v24 != 0.0)
                  {
                    v25.f64[0] = sub_23681E17C(1.0, 0.0, *v23, v24);
                    v25.f64[1] = v26;
                    v22[v21] = vcvt_f32_f64(v25);
                    v15 = *(a2 + 28);
                  }

                  ++v21;
                  v18 = v15;
                }

                while (v21 < v15);
                v17 = *(a2 + 8);
                v18 = v15;
              }

              ++v20;
            }

            while (v20 < *(v17 + 8 * v14));
            v12 = *(a2 + 4);
          }

          ++v13;
        }

        while (v14 < v12);
      }
    }
  }

  else
  {

    sub_23679F9A8(a2, a3);
  }
}

void sub_23679F9A8(uint64_t a1@<X0>, void *a2@<X8>)
{
  v2 = a1;
  v209 = *MEMORY[0x277D85DE8];
  v4 = *(a1 + 28);
  v5 = (*(a1 + 4) * v4);
  *a2 = 0;
  *a2 = 3;
  v193 = v5;
  v6 = 8 * v5;
  v7 = malloc_type_malloc(v6, 0x100004000313F17uLL);
  v8 = v7;
  a2[1] = v7;
  a2[2] = sub_2367A525C;
  v197 = (v4 * v4);
  v9 = (*(v2 + 24) >> 2) & 7;
  v206 = v2;
  v208 = v4;
  v196 = v7;
  if (v9 <= 2)
  {
    if ((v9 - 1) >= 2)
    {
      if (*(v2 + 24))
      {
        bzero(v7, v6);
        v96 = *(v2 + 4);
        if (v96 >= 1)
        {
          v97 = 0;
          v98 = *(v2 + 8);
          v99 = 8 * v197;
          v100 = 8 * v4;
          v205.i64[0] = 4;
          v207 = v99;
          do
          {
            v101 = *(v98 + 8 * v97++);
            if (v101 < *(v98 + 8 * v97))
            {
              v102 = v205.i64[0] + v99 * v101;
              do
              {
                v103 = *(*(v2 + 16) + 4 * v101);
                if ((v103 & 0x80000000) == 0 && v103 < *v2 && v4)
                {
                  v104 = 0;
                  v105 = &v196[2 * (v103 * v4)];
                  v106 = (*(v2 + 32) + v102);
                  do
                  {
                    v107 = v4;
                    v108 = v106;
                    v109 = v105;
                    do
                    {
                      v110 = hypotf(*(v108 - 1), *v108);
                      *v109 = *v109 + (v110 * v110);
                      v109 += 2;
                      v108 += 2;
                      --v107;
                    }

                    while (v107);
                    ++v104;
                    v106 = (v106 + v100);
                    v4 = v208;
                  }

                  while (v104 != v208);
                  v2 = v206;
                  v99 = v207;
                  v98 = *(v206 + 8);
                }

                ++v101;
                v102 += v99;
              }

              while (v101 < *(v98 + 8 * v97));
              v96 = *(v2 + 4);
            }
          }

          while (v97 < v96);
        }

        v111 = v193;
        if (v193 >= 1)
        {
          v112 = v196 + 1;
          do
          {
            v113 = hypotf(*(v112 - 1), *v112);
            v114 = 1.0;
            if (v113 >= 0.00000011921)
            {
              v114 = 1.0 / sqrt(v113);
            }

            *(v112 - 1) = v114;
            *v112 = 0.0;
            v112 += 2;
            --v111;
          }

          while (v111);
        }
      }

      else if (*(v2 + 4) >= 1)
      {
        v163 = 0;
        v164 = 4 * v4;
        v207 = 8 * v197;
        v165 = 8 * v4;
        v166 = v7 + 4;
        v200 = 4;
        v201 = (4 * v4 + 15) & 0x7F0;
        v202 = 4 * v4;
        do
        {
          v204 = v166;
          v203.i64[0] = &v189;
          v7 = MEMORY[0x28223BE20](v7);
          v167 = (&v189 - v201);
          if (v4)
          {
            bzero(&v189 - v201, v164);
          }

          v168 = *(v2 + 8);
          v169 = *(v168 + 8 * v163);
          v205.i64[0] = v163 + 1;
          v170 = *(v168 + 8 * (v163 + 1));
          if (v169 < v170)
          {
            v171 = *(v206 + 16);
            v172 = v200 + v207 * v169;
            do
            {
              v173 = *(v171 + 4 * v169);
              if ((v173 & 0x80000000) == 0 && v173 < *v206 && v4)
              {
                v174 = 0;
                v175 = (*(v206 + 32) + v172);
                do
                {
                  v176 = v167[v174];
                  v177 = v4;
                  v178 = v175;
                  do
                  {
                    v179 = hypotf(*(v178 - 1), *v178);
                    v176 = v176 + (v179 * v179);
                    v178 += 2;
                    --v177;
                  }

                  while (v177);
                  v167[v174++] = v176;
                  v175 = (v175 + v165);
                  v4 = v208;
                }

                while (v174 != v208);
              }

              ++v169;
              v172 += v207;
            }

            while (v169 != v170);
          }

          v180 = v4;
          v181 = v204;
          v163 = v205.i64[0];
          v182 = v204;
          v2 = v206;
          v164 = v202;
          if (v4)
          {
            do
            {
              v183 = 1.0;
              if (*v167 >= 0.00000011921)
              {
                v183 = 1.0 / sqrt(*v167);
              }

              *(v182 - 1) = v183;
              *v182 = 0.0;
              v182 += 2;
              ++v167;
              --v180;
            }

            while (v180);
          }

          v166 = (v181 + v165);
        }

        while (v163 < *(v2 + 4));
      }

      goto LABEL_196;
    }

    if (*(v2 + 24))
    {
      bzero(v7, v6);
      v10 = *(v2 + 4);
      if (v10 < 1)
      {
        goto LABEL_48;
      }

      v11 = 0;
      v12 = *(v2 + 8);
      v203.i64[0] = 8 * v197;
      v13 = 8 * v4;
      v14 = v206;
      while (1)
      {
        v15 = *(v12 + 8 * v11);
        v205.i64[0] = v11++;
        if (v15 >= *(v12 + 8 * v11))
        {
          goto LABEL_47;
        }

        v207 = v203.i64[0] * v15;
        v16 = v203.i64[0] * v15 + 4;
        v202 = v11;
        do
        {
          v17 = *(*(v2 + 16) + 4 * v15);
          v18 = *(*(v2 + 16) + 4 * v15);
          v19 = *(v2 + 24);
          if ((v19 & 2) != 0)
          {
            if (v205.i64[0] > v17 || v18 >= *v206)
            {
              goto LABEL_45;
            }

            v30 = *(v206 + 32);
            if (v205.i64[0] != v17)
            {
              v38 = v30 + 8 * v15 * v197;
              if (!v4)
              {
                goto LABEL_45;
              }

LABEL_41:
              v39 = 0;
              v40 = &v196[2 * v18 * v4];
              v41 = (v38 + 4);
              do
              {
                v42 = v4;
                v43 = v41;
                v44 = v40;
                do
                {
                  v45 = hypotf(*(v43 - 1), *v43);
                  *v44 = *v44 + (v45 * v45);
                  v44 += 2;
                  v43 += 2;
                  --v42;
                }

                while (v42);
                ++v39;
                v41 = (v41 + v13);
                v4 = v208;
              }

              while (v39 != v208);
              goto LABEL_45;
            }

            if (v4)
            {
              v31 = 0;
              v32 = &v196[2 * v18 * v4];
              v33 = v30 + v207;
              do
              {
                if ((*(v206 + 24) & 0x1C) == 8)
                {
                  v34 = v31 + 1;
                }

                else
                {
                  v34 = v31;
                }

                if (v34 < v4)
                {
                  v35 = 8 * v34;
                  v36 = v4 - v34;
                  do
                  {
                    v37 = hypotf(*(v33 + v35), *(v33 + v35 + 4));
                    *&v32[v35] = *&v32[v35] + (v37 * v37);
                    v35 += 8;
                    --v36;
                  }

                  while (v36);
                }

                ++v31;
                v33 += v13;
              }

              while (v31 != v4);
            }
          }

          else
          {
            if (v205.i64[0] < v17)
            {
              goto LABEL_45;
            }

            v20 = *(v206 + 32);
            if (v205.i64[0] != v17)
            {
              v38 = v20 + 8 * v15 * v197;
              if (!v4)
              {
                goto LABEL_45;
              }

              goto LABEL_41;
            }

            if (v4)
            {
              v21 = 0;
              v204 = &v196[2 * v17 * v4];
              v22 = (v20 + v16);
              do
              {
                v23 = v21 + 1;
                if ((v19 & 0x1C) != 8 || v21 != 0)
                {
                  v25 = 0;
                  v26 = v22;
                  v27 = v204;
                  do
                  {
                    v28 = hypotf(*(v26 - 1), *v26);
                    *v27 = *v27 + (v28 * v28);
                    v27 += 2;
                    ++v25;
                    v19 = *(v14 + 24);
                    if ((v19 & 0x1C) == 8)
                    {
                      v29 = v21;
                    }

                    else
                    {
                      v29 = v21 + 1;
                    }

                    v26 += 2;
                  }

                  while (v25 < v29);
                  v4 = v208;
                }

                v22 = (v22 + v13);
                ++v21;
              }

              while (v23 != v4);
            }
          }

LABEL_45:
          ++v15;
          v2 = v206;
          v12 = *(v206 + 8);
          v11 = v202;
          v46 = *(v12 + 8 * v202);
          v207 += v203.i64[0];
          v16 += v203.i64[0];
        }

        while (v15 < v46);
        v10 = *(v206 + 4);
LABEL_47:
        if (v11 >= v10)
        {
LABEL_48:
          if ((*(v2 + 24) & 0x1C) == 8)
          {
            v47 = v193;
            v48 = v196;
            if (v193 >= 1)
            {
              do
              {
                v49 = 1.0 / sqrt(*v48 + 1.0);
                *v48 = v49;
                v48[1] = 0.0;
                v48 += 2;
                --v47;
              }

              while (v47);
            }
          }

          else
          {
            v184 = v193;
            if (v193 >= 1)
            {
              v185 = v196 + 1;
              do
              {
                v186 = hypotf(*(v185 - 1), *v185);
                v187 = 1.0;
                if (v186 >= 0.00000011921)
                {
                  v187 = 1.0 / sqrt(v186);
                }

                *(v185 - 1) = v187;
                *v185 = 0.0;
                v185 += 2;
                --v184;
              }

              while (v184);
            }
          }

          goto LABEL_196;
        }
      }
    }

    if (*(v2 + 4) < 1)
    {
      goto LABEL_196;
    }

    v204 = 0;
    v205 = vdupq_n_s64(v4 - 1);
    v191 = (v4 + 3) & 0x1FC;
    v201 = 8 * v197;
    v115 = 8 * v4;
    v190 = xmmword_23681F910;
    v189 = xmmword_23681F920;
    v116 = (v7 + 4);
    v203 = vdupq_n_s64(4uLL);
    v193 = 4 * v4;
    v192 = (4 * v4 + 15) & 0x7F0;
    v198 = 8 * v4;
    while (1)
    {
      v196 = v116;
      v195 = &v189;
      v7 = MEMORY[0x28223BE20](v7);
      v118 = (&v189 - v192);
      if (v4)
      {
        if ((*(v2 + 24) & 0x1C) == 8)
        {
          *v117.i32 = 1.0;
        }

        else
        {
          *v117.i32 = 0.0;
        }

        v119 = v118 + 2;
        v120 = v191;
        v121 = v189;
        v122 = v190;
        do
        {
          v123 = vmovn_s64(vcgeq_u64(v205, v121));
          if (vuzp1_s16(v123, v117).u8[0])
          {
            *(v119 - 2) = v117.i32[0];
          }

          if (vuzp1_s16(v123, v117).i8[2])
          {
            *(v119 - 1) = v117.i32[0];
          }

          if (vuzp1_s16(v117, vmovn_s64(vcgeq_u64(v205, *&v122))).i32[1])
          {
            *v119 = v117.i32[0];
            v119[1] = v117.i32[0];
          }

          v122 = vaddq_s64(v122, v203);
          v121 = vaddq_s64(v121, v203);
          v119 += 4;
          v120 -= 4;
        }

        while (v120);
      }

      v124 = *(v2 + 8);
      v125 = *(v124 + 8 * v204);
      v194 = v204 + 1;
      v202 = *(v124 + 8 * (v204 + 1));
      if (v125 < v202)
      {
        break;
      }

LABEL_165:
      v158 = v4;
      v159 = v196;
      v160 = v196;
      v2 = v206;
      if (v4)
      {
        do
        {
          v161 = 1.0;
          if (*v118 >= 0.00000011921)
          {
            v161 = 1.0 / sqrt(*v118);
          }

          *(v160 - 1) = v161;
          *v160 = 0.0;
          v160 += 2;
          ++v118;
          --v158;
        }

        while (v158);
      }

      v162 = *(v2 + 4);
      v116 = (v159 + v115);
      v204 = v194;
      if (v194 >= v162)
      {
        goto LABEL_196;
      }
    }

    v126 = *(v206 + 16);
    v199 = *(v206 + 24);
    v200 = v126;
    v207 = v199 & 0x1C;
    v127 = v201 * v125;
    v128 = v201 * v125 + 4;
    while (1)
    {
      v129 = *(v200 + 4 * v125);
      if ((v199 & 2) != 0)
      {
        if (v204 <= v129 && *(v200 + 4 * v125) < *v206)
        {
          v137 = *(v206 + 32);
          if (v204 == v129)
          {
            if (v4)
            {
              v138 = 0;
              v139 = v137 + v128;
              v140 = v137 + v127;
              do
              {
                if (v207 == 8)
                {
                  v141 = v138 + 1;
                }

                else
                {
                  v141 = v138;
                }

                if (v141 < v4)
                {
                  v142 = v118[v138];
                  v143 = (v139 + 8 * v141);
                  v144 = v4;
                  v145 = (v140 + 8 * v141);
                  v146 = v144 - v141;
                  do
                  {
                    v147 = *v145;
                    v145 += 2;
                    v148 = v147;
                    v149 = *v143;
                    v143 += 2;
                    v150 = hypotf(v148, v149);
                    v142 = v142 + (v150 * v150);
                    --v146;
                  }

                  while (v146);
                  v118[v138] = v142;
                  v4 = v208;
                  v115 = v198;
                }

                ++v138;
                v139 += v115;
                v140 += v115;
              }

              while (v138 != v4);
            }

            goto LABEL_164;
          }

          v151 = v137 + 8 * v125 * v197;
          if (v4)
          {
            goto LABEL_160;
          }
        }
      }

      else if (v204 >= v129)
      {
        v130 = *(v206 + 32);
        if (v204 == v129)
        {
          if (v4)
          {
            v131 = 0;
            do
            {
              if (v207 == 8)
              {
                v132 = v131;
              }

              else
              {
                v132 = v131 + 1;
              }

              v133 = v132;
              if (v132)
              {
                v134 = v118[v131];
                v135 = v130;
                do
                {
                  v136 = hypotf(*(v135 + v127), *(v135 + v128));
                  v134 = v134 + (v136 * v136);
                  v135 += 8;
                  --v133;
                }

                while (v133);
                v118[v131] = v134;
                v4 = v208;
              }

              ++v131;
              v130 += v115;
            }

            while (v131 != v4);
          }

          goto LABEL_164;
        }

        v151 = v130 + 8 * v125 * v197;
        if (v4)
        {
LABEL_160:
          v152 = 0;
          v153 = (v151 + 4);
          do
          {
            v154 = v118[v152];
            v155 = v4;
            v156 = v153;
            do
            {
              v157 = hypotf(*(v156 - 1), *v156);
              v154 = v154 + (v157 * v157);
              v156 += 2;
              --v155;
            }

            while (v155);
            v118[v152++] = v154;
            v153 = (v153 + v115);
            v4 = v208;
          }

          while (v152 != v208);
        }
      }

LABEL_164:
      ++v125;
      v128 += v201;
      v127 += v201;
      if (v125 == v202)
      {
        goto LABEL_165;
      }
    }
  }

  bzero(v7, v6);
  v50 = *(v2 + 4);
  if (v50 < 1)
  {
    goto LABEL_85;
  }

  v51 = 0;
  v204 = v4 + 1;
  v52 = *(v2 + 8);
  v199 = 8 * v197;
  v207 = 8 * v4;
  v200 = 8 * v4 + 8;
  v195 = (v8 + 8);
  v194 = v4 - 1;
  do
  {
    v53 = v51;
    v54 = *(v52 + 8 * v51++);
    if (v54 >= *(v52 + 8 * v51))
    {
      continue;
    }

    v55 = &v8[8 * v53 * v4];
    v202 = v199 * v54 + 12;
    v203.i64[0] = v199 * v54 + 4;
    v201 = v53;
    v198 = v51;
    do
    {
      v56 = *(*(v2 + 16) + 4 * v54);
      v57 = v56;
      if ((*(v2 + 24) & 2) == 0)
      {
        v58 = v208;
        if (v53 < v56)
        {
          goto LABEL_82;
        }

        LODWORD(v56) = v56 * v208;
        v59 = *(v206 + 32);
        v205.i64[0] = v59 + 8 * v54 * v197;
        if (v201 == v57)
        {
          if (v208)
          {
            v60 = 0;
            v61 = &v196[2 * v56];
            v62 = (v59 + v203.i64[0]);
            do
            {
              if (v60)
              {
                v63 = v60;
                v64 = v61;
                v65 = v62;
                do
                {
                  v66 = hypotf(*(v65 - 1), *v65);
                  *&v55[8 * v60] = *&v55[8 * v60] + (v66 * v66);
                  v67 = hypotf(*(v65 - 1), *v65);
                  *v64 = *v64 + (v67 * v67);
                  v64 += 2;
                  v65 += 2;
                  --v63;
                }

                while (v63);
              }

              v68 = hypotf(*(v205.i64[0] + 8 * v60 * v204), *(v205.i64[0] + 8 * v60 * v204 + 4));
              *&v55[8 * v60] = *&v55[8 * v60] + (v68 * v68);
              ++v60;
              v62 = (v62 + v207);
            }

            while (v60 != v208);
          }

          goto LABEL_82;
        }

        v56 = v56;
LABEL_77:
        if (v58)
        {
          v83 = 0;
          v84 = &v196[2 * v56];
          v85 = v205.i64[0] + 4;
          do
          {
            v86 = v58;
            v87 = v84;
            v88 = v85;
            do
            {
              v89 = hypotf(*(v88 - 1), *v88);
              *&v55[8 * v83] = *&v55[8 * v83] + (v89 * v89);
              v90 = hypotf(*(v88 - 1), *v88);
              *v87 = *v87 + (v90 * v90);
              v87 += 2;
              v88 += 2;
              --v86;
            }

            while (v86);
            ++v83;
            v85 += v207;
          }

          while (v83 != v58);
        }

        goto LABEL_82;
      }

      v58 = v208;
      if (v53 > v56 || v56 >= *v206)
      {
        goto LABEL_82;
      }

      v56 = v56 * v208;
      v69 = *(v206 + 32);
      v205.i64[0] = v69 + 8 * v54 * v197;
      if (v201 != v57)
      {
        goto LABEL_77;
      }

      v70 = v208;
      if (v208)
      {
        v71 = 0;
        v72 = (v69 + v202);
        v73 = v194;
        v74 = v195 + 2 * v56;
        do
        {
          v75 = (v205.i64[0] + 8 * v71 + 8 * (v71 * v70));
          v76 = hypotf(*v75, v75[1]);
          v77 = &v55[8 * v71];
          *v77 = *v77 + (v76 * v76);
          if (++v71 < v70)
          {
            v78 = v73;
            v79 = v74;
            v80 = v72;
            do
            {
              v81 = hypotf(*(v80 - 1), *v80);
              *v77 = *v77 + (v81 * v81);
              v82 = hypotf(*(v80 - 1), *v80);
              *v79 = *v79 + (v82 * v82);
              v79 += 2;
              v80 += 2;
              --v78;
            }

            while (v78);
          }

          v72 = (v72 + v200);
          v74 += 2;
          --v73;
          v70 = v208;
        }

        while (v71 != v208);
      }

LABEL_82:
      ++v54;
      v2 = v206;
      v52 = *(v206 + 8);
      v51 = v198;
      v91 = *(v52 + 8 * v198);
      v202 += v199;
      v203.i64[0] += v199;
      v53 = v201;
    }

    while (v54 < v91);
    v50 = *(v206 + 4);
    v4 = v208;
    v8 = v196;
  }

  while (v51 < v50);
LABEL_85:
  v92 = v193;
  if (v193 >= 1)
  {
    v93 = (v8 + 4);
    do
    {
      v94 = hypotf(*(v93 - 1), *v93);
      v95 = 1.0;
      if (v94 >= 0.00000011921)
      {
        v95 = 1.0 / sqrt(v94);
      }

      *(v93 - 1) = v95;
      *v93 = 0.0;
      v93 += 2;
      --v92;
    }

    while (v92);
  }

LABEL_196:
  v188 = *MEMORY[0x277D85DE8];
}

void _SparseCGIterate_Complex_Float(uint64_t a1, uint64_t a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int *a7, uint64_t a8, uint64_t a9)
{
  v10 = a3;
  v11 = 4;
  if (*(a5 + 12))
  {
    v11 = 0;
  }

  v12 = *(a5 + v11);
  if (!a2)
  {
    goto LABEL_11;
  }

  if (v12 >= 1)
  {
    for (i = 0; i != v12; ++i)
    {
      if (a7[3])
      {
        v14 = i;
      }

      else
      {
        v14 = a7[2] * i;
      }

      *(*(a7 + 2) + 8 * v14) = *&a3[2 * v12 + 2 * i];
    }
  }

  if ((a2 & 0x80000000) == 0)
  {
LABEL_11:
    v15 = *(a5 + 12);
    v16 = 4;
    if (v15)
    {
      v17 = 4;
    }

    else
    {
      v17 = 0;
    }

    v18 = *(a5 + v17);
    v100 = v18;
    if (v15)
    {
      v16 = 0;
    }

    v19 = *(a5 + v16);
    v104 = *(a5 + v17);
    v96 = &a3[2 * v12];
    v95 = v12;
    if (a8)
    {
      if (v15)
      {
        v20 = *(a5 + 8);
      }

      if (a7[3])
      {
        v22 = a7[2];
      }

      v23 = &a3[2 * v19];
      v94 = (v19 * v18);
      v24 = 2 * v94;
      v25 = &v23[2 * v94];
      v26 = *(a8 + 8);
      v27 = *(a8 + 16);
      v93 = &v25[2 * v94];
      if (a2)
      {
        v111 = *a7;
        v112 = *(a7 + 2);
        *&v109 = __PAIR64__(v19, v18);
        *(&v109 + 1) = v18;
        v110 = &v23[2 * v94];
        v27(v26, 0, &v111, &v109);
        v30 = v104;
        if (v19 >= 1)
        {
          v31 = 0;
          v32 = &a3[2 * v19 + 1 + v24];
          v98 = 8 * v100;
          v33 = &a3[4 * v94 + 1 + 2 * v19];
          do
          {
            if ((a7[3] & 1) == 0)
            {
              v34 = a7[2] * v31;
            }

            v35 = *(a7 + 2);
            v36 = &a3[2 * v31];
            v37 = *v36;
            v38 = v36[1];
            cblas_cdotc_sub_NEWLAPACK();
            v28.n128_f32[0] = sub_23681E680(*v36, v36[1], v37, v38);
            v30 = v104;
            if (v104 >= 1)
            {
              v39 = v33;
              v40 = v32;
              v41 = v104;
              do
              {
                v42 = *(v39 - 1);
                v43 = *v40 + ((v29.n128_f32[0] * v42) + (v28.n128_f32[0] * *v39));
                *(v39 - 1) = *(v40 - 1) + ((v28.n128_f32[0] * v42) - (v29.n128_f32[0] * *v39));
                *v39 = v43;
                v40 += 2;
                v39 += 2;
                --v41;
              }

              while (v41);
            }

            ++v31;
            v32 += v98;
            v33 += v98;
          }

          while (v31 != v19);
        }
      }

      else
      {
        v111 = *a7;
        v112 = *(a7 + 2);
        *&v109 = __PAIR64__(v19, v18);
        *(&v109 + 1) = v18;
        v110 = &v23[2 * v94];
        v27(v26, a2, &v111, &v109);
        memcpy(&v25[2 * v94], v25, v24 * 4);
        v30 = v104;
        if (v19 >= 1)
        {
          v44 = 0;
          v45 = a3;
          do
          {
            if ((a7[3] & 1) == 0)
            {
              v46 = a7[2] * v44;
            }

            v47 = *(a7 + 2);
            cblas_cdotc_sub_NEWLAPACK();
            v30 = v104;
            ++v44;
            v45 += 2;
            v25 += 2 * v100;
          }

          while (v19 != v44);
        }
      }

      v48 = *(a9 + 16);
      *&v111 = __PAIR64__(v19, v30);
      *(&v111 + 1) = v30;
      v112 = v93;
      *&v109 = __PAIR64__(v19, v30);
      *(&v109 + 1) = v30;
      v110 = v23;
      v48(a9, 0, 111, &v111, &v109, v28, v29);
      v49 = a4;
      if (v19 >= 1)
      {
        v50 = 0;
        v51 = a3 + 1;
        v52 = 8 * v100;
        v101 = 8 * v100;
        do
        {
          if ((*(v49 + v50) & 1) == 0)
          {
            if (*(a5 + 12))
            {
              v53 = v50;
            }

            else
            {
              v53 = *(a5 + 8) * v50;
            }

            if (a7[3])
            {
              v54 = v50;
            }

            else
            {
              v54 = a7[2] * v50;
            }

            v55 = *(a5 + 16) + 8 * v53;
            v56 = *(a7 + 2) + 8 * v54;
            *&v111 = 0;
            cblas_cdotc_sub_NEWLAPACK();
            LODWORD(v111) = sub_23681E680(*(v51 - 1), *v51, *&v111, *(&v111 + 1));
            DWORD1(v111) = v57;
            cblas_caxpy_NEWLAPACK();
            *&v109 = vneg_f32(*&v111);
            cblas_caxpy_NEWLAPACK();
            v52 = v101;
            v49 = a4;
          }

          ++v50;
          v51 += 2;
          v23 = (v23 + v52);
        }

        while (v19 != v50);
      }
    }

    else
    {
      if (v15)
      {
        v21 = *(a5 + 8);
      }

      if (a7[3])
      {
        v58 = a7[2];
      }

      else
      {
        v58 = 1;
      }

      v103 = v58;
      v59 = &a3[v19];
      LODWORD(v111) = *(a5 + v17);
      DWORD1(v111) = v19;
      v112 = &v59[2 * (v19 * v18)];
      *(&v111 + 1) = v18;
      if (a2)
      {
        if (v19 >= 1)
        {
          v60 = 0;
          v61 = 0;
          v62 = &a3[2 * (v19 * v18) + v19];
          do
          {
            if (a7[3])
            {
              v63 = v61;
            }

            else
            {
              v63 = a7[2] * v61;
            }

            v64 = (*(a7 + 2) + 8 * v63);
            v65 = v10[v61];
            cblas_scnrm2_NEWLAPACK();
            v18 = v104;
            v67 = v66 * v66;
            v10[v61] = v67;
            if (v104 >= 1)
            {
              v68 = &v62[2 * v60];
              v69 = v104;
              v70 = v67 / v65;
              do
              {
                *v68 = vadd_f32(*v64, vmul_n_f32(*v68, v70));
                ++v68;
                v64 += v103;
                --v69;
              }

              while (v69);
            }

            ++v61;
            v60 += v104;
          }

          while (v61 != v19);
        }
      }

      else
      {
        sub_236805D74(a7, &v111);
        v18 = v104;
        if (v19 >= 1)
        {
          for (j = 0; j != v19; ++j)
          {
            if ((a7[3] & 1) == 0)
            {
              v72 = a7[2] * j;
            }

            v73 = *(a7 + 2);
            cblas_scnrm2_NEWLAPACK();
            v18 = v104;
            v10[j] = v74 * v74;
          }
        }
      }

      v75 = *(a9 + 16);
      v109 = v111;
      v110 = v112;
      v105 = __PAIR64__(v19, v18);
      v106 = v18;
      v107 = 0;
      v108 = v59;
      v75(a9, 0, 111, &v109, &v105);
      v76 = a4;
      if (v19 >= 1)
      {
        v77 = 0;
        do
        {
          if ((*(v76 + v77) & 1) == 0)
          {
            if (*(a5 + 12))
            {
              v78 = v77;
            }

            else
            {
              v78 = *(a5 + 8) * v77;
            }

            if (a7[3])
            {
              v79 = v77;
            }

            else
            {
              v79 = a7[2] * v77;
            }

            v80 = *(a5 + 16) + 8 * v78;
            v81 = *(a7 + 2) + 8 * v79;
            *&v109 = 0;
            cblas_cdotc_sub_NEWLAPACK();
            LODWORD(v109) = sub_23681E680(*v10, 0.0, *&v109, *(&v109 + 1));
            DWORD1(v109) = v82;
            cblas_caxpy_NEWLAPACK();
            v105 = vneg_f32(*&v109);
            cblas_caxpy_NEWLAPACK();
            v76 = a4;
          }

          ++v77;
          ++v10;
          v59 += 2 * v100;
          --v19;
        }

        while (v19);
      }
    }

    if (v95 >= 1)
    {
      v83 = 0;
      v84 = 0;
      do
      {
        v85 = v83;
        if ((a7[3] & 1) == 0)
        {
          v85 = a7[2] * v83;
        }

        *&v96[v84] = *(*(a7 + 2) + 8 * v85);
        v86 = a7[2];
        v87 = *(a7 + 2);
        if (a7[3])
        {
          v88 = a7[1];
        }

        else
        {
          v89 = *a7;
        }

        cblas_scnrm2_NEWLAPACK();
        v91 = v83;
        if ((a7[3] & 1) == 0)
        {
          v91 = a7[2] * v83;
        }

        v92 = (*(a7 + 2) + 8 * v91);
        *v92 = v90;
        v92[1] = 0;
        v84 += 2;
        ++v83;
      }

      while (2 * v95 != v84);
    }
  }
}

uint64_t _SparseCGSolve_Complex_Float(void (**a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v55 = *MEMORY[0x277D85DE8];
  v7 = 4;
  if (*(a2 + 12))
  {
    v8 = 4;
  }

  else
  {
    v8 = 0;
  }

  v9 = *(a2 + v8);
  if (*(a2 + 12))
  {
    v7 = 0;
  }

  v10 = *(a2 + v7);
  v11 = v10 * v9;
  if (a5)
  {
    v12 = v11;
  }

  else
  {
    v12 = 0;
  }

  v13 = 8 * ((((2 * v9) | 1) * v10) + (v10 + v11) + v12) + v10 + 24;
  v14 = malloc_type_malloc(v13, 0x100004077774924uLL);
  if (v14)
  {
    v15 = v14;
    v16 = v14 + v13;
    *&v52 = __PAIR64__(v10, v9);
    *(&v52 + 1) = v9;
    v17 = ((&v14[2 * (v10 * v9) + 1] + 3) & 0xFFFFFFFFFFFFFFF8);
    if ((v14 + v13) < v17)
    {
      goto LABEL_58;
    }

    v48 = a1;
    v53 = v14;
    sub_2367A1548(a2, a3, &v52, a4);
    v49 = v17;
    v18 = &v17[2 * v10];
    if (v18 > v16)
    {
      goto LABEL_58;
    }

    if (v10 >= 1)
    {
      v19 = v10;
      v20 = v15;
      v21 = v17;
      do
      {
        cblas_scnrm2_NEWLAPACK();
        *v21++ = v22;
        v20 += 2 * v9;
        --v19;
      }

      while (v19);
    }

    v45 = ((v18 + v10 + 7) & 0xFFFFFFFFFFFFFFF8);
    if (v16 < v45)
    {
LABEL_58:
      __break(1u);
    }

    bzero(&v17[2 * v10], v10);
    v26 = v48;
    v27 = *(v48 + 2);
    if (!v27)
    {
      v27 = 100;
    }

    v46 = v27;
    v28 = *(v48 + 2);
    v25.n128_u64[0] = v48[3];
    v25.n128_f32[0] = v25.n128_f64[0];
    v29 = v25.n128_f32[0] == 0.0;
    if (v25.n128_f32[0] < 0.0)
    {
      v25.n128_f32[0] = 0.0;
    }

    if (v29)
    {
      v30 = 0.00034527;
    }

    else
    {
      v30 = v25.n128_f32[0];
    }

    v31 = v48[4];
    if (v31)
    {
      v23 = (v31)("   Itr   ||r[0]||_2\n", v25);
    }

    if (v46 < 1)
    {
LABEL_41:
      v41 = *v26;
      if (!*v26)
      {
        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_23670BAC8();
        }

        _SparseTrap();
      }

      memset(&__str[35], 0, 221);
      strcpy(__str, "Exceeded maximum iteration limit.\n");
      v41(__str);
      v42 = 1;
    }

    else
    {
      v32 = 0;
      v33 = v28;
      while (1)
      {
        if (v26[4] && (v32 < 0xA || !(v32 % 0xA)))
        {
          if (v32)
          {
            v34 = v15;
          }

          else
          {
            v34 = v17;
          }

          snprintf(__str, 0xC8uLL, "%5d   %10.2e\n", v32, *v34);
          v23 = (v26[4])(__str);
        }

        _SparseCGIterate_Complex_Float(v23, v32, v45, v18, a2, v24, &v52, a5, a4);
        v15 = v53;
        if (v10 < 1)
        {
          break;
        }

        v35 = (v53 + 4);
        v36 = 8 * SDWORD2(v52);
        v37 = 1;
        v38 = v10;
        v39 = v18;
        do
        {
          if ((*v39 & 1) == 0)
          {
            v40 = hypotf(*(v35 - 1), *v35) < (v33 + (v30 * *v17));
            *v39 = v40;
            v37 &= v40;
          }

          v35 = (v35 + v36);
          ++v17;
          ++v39;
          --v38;
        }

        while (v38);
        v26 = v48;
        if (v37)
        {
          goto LABEL_52;
        }

        v32 = (v32 + 1);
        v17 = v49;
        if (v32 == v46)
        {
          goto LABEL_41;
        }
      }

      LODWORD(v32) = 0;
LABEL_52:
      if (!v26[4])
      {
        v42 = 0;
        goto LABEL_55;
      }

      snprintf(__str, 0xC8uLL, "%5d   %10.2e\n", v32 + 1, *v15);
      v26[4](__str);
      v42 = 0;
    }

    v15 = v53;
LABEL_55:
    free(v15);
    goto LABEL_56;
  }

  if (!*a1)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_23670BB0C();
    }

    _SparseTrap();
  }

  memset(__str, 0, 256);
  snprintf(__str, 0x100uLL, "Failed to allocate workspace of size %ld.\n", v13);
  (*a1)(__str);
  v42 = 4294967197;
LABEL_56:
  v43 = *MEMORY[0x277D85DE8];
  return v42;
}

uint64_t sub_2367A1548(__int128 *a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  v6 = 4;
  if (*(a1 + 3))
  {
    v7 = 4;
  }

  else
  {
    v7 = 0;
  }

  v8 = *(a1 + v7);
  if (*(a1 + 3))
  {
    v6 = 0;
  }

  v9 = *(a1 + v6);
  v10 = *(a4 + 16);
  v21 = *a1;
  v22 = *(a1 + 2);
  v19 = *a3;
  v20 = *(a3 + 2);
  result = v10(a4, 0, 111, &v21, &v19);
  if (v9 >= 1)
  {
    for (i = 0; i != v9; ++i)
    {
      if (v8 >= 1)
      {
        for (j = 0; j != v8; ++j)
        {
          if (*(a2 + 12))
          {
            v14 = j;
          }

          else
          {
            v14 = i;
          }

          if (*(a2 + 12))
          {
            v15 = i;
          }

          else
          {
            v15 = j;
          }

          v16 = v15 + *(a2 + 8) * v14;
          if (*(a3 + 3))
          {
            v17 = j;
          }

          else
          {
            v17 = i;
          }

          if (*(a3 + 3))
          {
            v18 = i;
          }

          else
          {
            v18 = j;
          }

          *(*(a3 + 2) + 8 * (v18 + *(a3 + 2) * v17)) = vsub_f32(*(*(a2 + 16) + 8 * v16), *(*(a3 + 2) + 8 * (v18 + *(a3 + 2) * v17)));
        }
      }
    }
  }

  return result;
}

void _SparseGMRESIterate_Complex_Float(uint64_t a1, int a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v10 = *(a1 + 8);
  if ((v10 - 1) >= 2)
  {
    if (!*(a1 + 8))
    {
      v16 = *(a5 + 12);
      v17 = 4;
      if (v16)
      {
        v18 = 4;
      }

      else
      {
        v18 = 0;
      }

      if (v16)
      {
        v17 = 0;
      }

      if (*(a1 + 12))
      {
        v19 = *(a1 + 12);
      }

      else
      {
        v19 = 16;
      }

      if (v16)
      {
        v20 = *(a5 + 8);
      }

      if (*(a7 + 12))
      {
        v40 = *(a7 + 8);
      }

      else
      {
        v40 = 1;
      }

      v253 = v40;
      if (a2 < 0)
      {

        sub_2367A1548(a5, a6, a7, a9);
      }

      else
      {
        v41 = *(a5 + v18);
        v42 = *(a5 + v17);
        v219 = v41;
        v245 = v41;
        v43 = v42 * v41;
        v241 = v42;
        v214 = a3 + 8 * v19 * v43;
        v236 = v19 * v42 * v19;
        v212 = v214 + 8 * v236;
        v232 = 2 * v19 * v42;
        v242 = 8 * v43;
        v44 = v212 + 8 * v232 + v242;
        v239 = v19 * v43;
        __dst = (v44 + 8 * v19 * v43);
        v225 = &__dst[v242];
        v230 = (a2 % v19);
        v259 = v43;
        v45 = a2 % v19 * v43;
        __srca = (v44 + 8 * v45);
        if (!a2 && v42 >= 1)
        {
          v46 = 0;
          v47 = (a3 + 4);
          do
          {
            if ((a4[v46] & 1) == 0)
            {
              v48 = (*(a7 + 12) & 1) != 0 ? v46 : *(a7 + 8) * v46;
              v49 = *(a7 + 16);
              v50 = &v225[8 * v46 * v19];
              cblas_scnrm2_NEWLAPACK();
              *v50 = v51;
              v50[1] = 0.0;
              if (v245 >= 1)
              {
                v52 = (v49 + 8 * v48 + 4);
                v53 = v47;
                v54 = v245;
                do
                {
                  *(v53 - 1) = sub_23681E680(*(v52 - 1), *v52, *v50, v50[1]);
                  *v53 = v55;
                  v53 += 2;
                  v52 += 2 * v253;
                  --v54;
                }

                while (v54);
              }
            }

            ++v46;
            v47 += 2 * v219;
          }

          while (v46 != v241);
        }

        v56 = 8 * v239;
        v57 = 8 * v236;
        v58 = 8 * v232;
        memcpy(__dst, __srca, v242);
        if (a8)
        {
          v59 = *(a8 + 8);
          v60 = *(a8 + 16);
          v264 = __PAIR64__(v241, v245);
          v265 = v245;
          v266 = a3 + 8 * v45;
          v260 = *&v245;
          v261 = *&v241;
          v262 = v245;
          v263 = __srca;
          v60(v59, 0, &v264, &v260);
        }

        else if (v241 >= 1)
        {
          v61 = 8 * v219;
          v62 = a4;
          v63 = (a3 + v57 + 8 * v45 + v56 + v58 + v242);
          v64 = v241;
          do
          {
            v65 = *v62++;
            if ((v65 & 1) == 0)
            {
              memcpy(v63, (a3 + 8 * v45), v61);
            }

            v45 += v245;
            v63 += v61;
            --v64;
          }

          while (v64);
        }

        v66 = *(a9 + 16);
        v264 = __PAIR64__(v241, v245);
        v265 = v245;
        v266 = __srca;
        v260 = *&v245;
        v261 = *&v241;
        v262 = v245;
        v263 = v212 + 8 * v232;
        v66(a9, 0, 111, &v264, &v260);
        if (v241 >= 1)
        {
          v67 = 0;
          v68 = v19 - a2;
          if (v19 <= a2)
          {
            v68 = 1;
          }

          v251 = v19 - v68;
          v70 = v19 < 1 || v19 - v68 < 0;
          v210 = v70;
          v256 = v230 * v19;
          v254 = v68 + v230;
          v71 = v57 + v56 + v58 + a3 + 4;
          v72 = 8 * v219;
          v73 = a3 + 8 * (a2 + 1) % v19 * v259 + 4;
          v223 = (a2 - v19) & ~((a2 - v19) >> 31);
          do
          {
            if ((a4[v67] & 1) == 0)
            {
              v237 = v73;
              v240 = v71;
              v233 = v67 * v19;
              v74 = v214 + 8 * v233 * v19;
              v243 = v67;
              v75 = v245;
              if (!v210)
              {
                v76 = 0;
                do
                {
                  cblas_cdotc_sub_NEWLAPACK();
                  v264 = vneg_f32(*(v74 + 8 * ((v254 + v76) % v19 + v256)));
                  cblas_caxpy_NEWLAPACK();
                  if (v76 + 1 >= v19)
                  {
                    break;
                  }
                }

                while (v76++ < v251);
              }

              cblas_scnrm2_NEWLAPACK();
              v264 = LODWORD(v78);
              if (hypotf(v78, 0.0) == 0.0)
              {
                LODWORD(v264) = 0x800000;
              }

              v79 = v237;
              v80 = v240;
              if (v245 >= 1)
              {
                do
                {
                  *(v79 - 1) = sub_23681E680(*(v80 - 1), *v80, *&v264, *(&v264 + 1));
                  *v79 = v81;
                  v80 += 2;
                  v79 += 2;
                  --v75;
                }

                while (v75);
              }

              v82 = v212 + 8 * v243 * 2 * v19;
              v83 = v74 + 8 * v256;
              v84 = 0.0;
              v85 = 0.0;
              if (a2 > v223)
              {
                v86 = a2 - v223;
                v87 = (a2 - v19) & ~((a2 - v19) >> 31);
                do
                {
                  v88 = v87 % v19;
                  v89 = *(v82 + 8 * (2 * (v87 % v19)));
                  if (v87 % v19 + 1 < v19)
                  {
                    v90 = v88 + 1;
                  }

                  else
                  {
                    v90 = 0;
                  }

                  v91 = (2 * (v88 & 0x3FFFFFFF)) | 1;
                  v92 = *(v82 + 8 * v91);
                  if (v19 == v86)
                  {
                    v93 = *(v83 + 8 * v90);
                    v94 = HIDWORD(*(v82 + 8 * v91));
                    v85 = vmul_f32(v92, v93).f32[0] - vmuls_lane_f32(v92.f32[1], v93, 1);
                    v84 = vmuls_lane_f32(v93.f32[0], v92, 1) + vmuls_lane_f32(v92.f32[0], v93, 1);
                    v95 = vmul_n_f32(v93, v89);
                  }

                  else
                  {
                    v96 = *(v83 + 8 * v90);
                    v97 = *(v83 + 8 * v88);
                    v98 = vrev64_s32(vmul_lane_f32(v92, v96, 1));
                    v99 = vmul_n_f32(v92, v96.f32[0]);
                    v100.i32[0] = vsub_f32(v99, v98).u32[0];
                    v100.i32[1] = vadd_f32(v99, v98).i32[1];
                    *(v83 + 8 * v88) = vadd_f32(vmul_n_f32(v97, v89), v100);
                    v101 = vcvtq_f64_f32(v92);
                    v102.f64[1] = v101.f64[1];
                    v102.f64[0] = -v101.f64[0];
                    v103 = vmulq_n_f64(v101, v97.f32[1]);
                    v95 = vcvt_f32_f64(vaddq_f64(vsubq_f64(vmulq_n_f64(v102, v97.f32[0]), vextq_s8(v103, v103, 8uLL)), vcvtq_f64_f32(vmul_n_f32(v96, v89))));
                  }

                  *(v83 + 8 * v90) = v95;
                  ++v87;
                  --v86;
                }

                while (v86);
              }

              v104 = &v225[8 * v233];
              v105 = (v82 + 8 * (2 * v230));
              v106 = (v82 + 8 * ((2 * (v230 & 0x3FFFFFFF)) | 1));
              v234 = (v74 + 8 * (v230 * v19 + v230));
              cblas_crotg_NEWLAPACK();
              v107 = *v106;
              v108 = v106[1];
              v109 = &v104[8 * v230];
              v110 = *v109;
              v111 = v109[1];
              v112 = -(v107 * v110) - v108 * v111;
              *&v108 = v108 * v110 - v107 * v111;
              v113 = &v104[8 * ((a2 + 1) % v19)];
              *v113 = v112;
              v113[1] = *&v108;
              v114 = *v105 * v109[1];
              *v109 = *v105 * *v109;
              v109[1] = v114;
              v115 = *(a5 + 16);
              if ((*(a5 + 12) & 1) == 0)
              {
                v116 = *(a5 + 8) * v243;
              }

              if (v19 <= a2)
              {
                v260 = -v85;
                v261 = -v84;
                cblas_caxpy_NEWLAPACK();
                cblas_cgemm_NEWLAPACK();
              }

              cblas_cgemm_NEWLAPACK();
              v260 = sub_23681E680(1.0, 0.0, *v234, v234[1]);
              v261 = v117;
              cblas_cscal_NEWLAPACK();
              cblas_caxpy_NEWLAPACK();
              v118 = hypotf(*v113, v113[1]);
              v67 = v243;
              if (*(a7 + 12))
              {
                v119 = v243;
              }

              else
              {
                v119 = *(a7 + 8) * v243;
              }

              v73 = v237;
              v71 = v240;
              v72 = 8 * v219;
              v120 = *(a7 + 16) + 8 * v119;
              *v120 = v118;
              *(v120 + 4) = 0;
            }

            ++v67;
            v71 += v72;
            v73 += v72;
          }

          while (v67 != v241);
        }
      }
    }

    return;
  }

  v11 = 4;
  if (*(a5 + 12))
  {
    v12 = 4;
  }

  else
  {
    v12 = 0;
  }

  v13 = *(a5 + v12);
  if (*(a5 + 12))
  {
    v11 = 0;
  }

  v14 = *(a5 + v11);
  if (*(a7 + 12))
  {
    v15 = *(a7 + 8);
  }

  else
  {
    v15 = 1;
  }

  v231 = v15;
  if (*(a1 + 12))
  {
    v21 = *(a1 + 12);
  }

  else
  {
    v21 = 16;
  }

  v244 = (a2 % v21);
  v211 = v21 + 1;
  v22 = (v21 + 1) * v14;
  v208 = 8 * v22 * v13;
  v258 = v21 * v21;
  v206 = 8 * v21 * v21 * v14;
  v229 = a3 + v208;
  v207 = 16 * v14 * v21;
  v222 = a3 + v208 + v206;
  v255 = v14 * v13;
  v218 = v222 + v207 + 8 * v255;
  v23 = v218 + 8 * v255;
  v235 = v21;
  __src = v14 * v13;
  v24 = 8 * v21 * v14 * v13;
  if (v10 == 2)
  {
    v25 = v218 + 8 * v14 * v13;
  }

  else
  {
    v25 = 0;
  }

  v224 = v25;
  if (v10 != 2)
  {
    v24 = 0;
  }

  v238 = v23 + v24;
  v250 = v14;
  v252 = v23 + v24 + 8 * v22;
  if (a2 < 0 || !v244)
  {
    if (!a2)
    {
LABEL_134:
      if (v14 >= 1)
      {
        v137 = 0;
        v138 = (a3 + 4);
        do
        {
          *(v252 + 4 * v137) = 0;
          if ((a4[v137] & 1) == 0)
          {
            v139 = (*(a7 + 12) & 1) != 0 ? v137 : *(a7 + 8) * v137;
            v140 = *(a7 + 16);
            v141 = (v238 + 8 * v137 * v211);
            cblas_scnrm2_NEWLAPACK();
            *v141 = v142;
            v141[1] = 0.0;
            if (v13 >= 1)
            {
              v143 = (v140 + 8 * v139 + 4);
              v144 = v138;
              v145 = v13;
              do
              {
                *(v144 - 1) = sub_23681E680(*(v143 - 1), *v143, *v141, v141[1]);
                *v144 = v146;
                v144 += 2;
                v143 += 2 * v231;
                --v145;
              }

              while (v145);
            }
          }

          ++v137;
          v138 += 2 * v13;
          v14 = v250;
        }

        while (v137 != v250);
      }

      goto LABEL_144;
    }

    if (v14 < 1)
    {
      if (v10 == 2)
      {
        goto LABEL_133;
      }
    }

    else
    {
      v26 = 0;
      v27 = 8 * v22;
      v205 = v24 + 16 * v255;
      v28 = v205 + v206 + v208 + v207;
      v29 = a3 + v28;
      v213 = v27;
      v30 = (a3 + v27 + v28);
      v31 = v14;
      do
      {
        if (*v30++)
        {
          cblas_ctrsv_NEWLAPACK();
        }

        v29 += 8 * v211;
        v26 += v258;
        --v31;
      }

      while (v31);
      if (v10 == 2)
      {
        v33 = 0;
        v34 = v250;
        do
        {
          if (*(v252 + 4 * v33))
          {
            cblas_cgemv_NEWLAPACK();
            v34 = v250;
            if (v13 >= 1)
            {
              for (i = 0; i != v13; ++i)
              {
                v36 = *(a5 + 8);
                v37 = v33 + v36 * i;
                v38 = i + v33 * v36;
                if (*(a5 + 12))
                {
                  v39 = v37;
                }

                else
                {
                  v39 = v38;
                }

                *(*(a5 + 16) + 8 * v39) = vadd_f32(*(a3 + v206 + v208 + v207 + 8 * i), *(*(a5 + 16) + 8 * v39));
              }
            }
          }

          ++v33;
        }

        while (v33 != v34);
        goto LABEL_133;
      }

      v121 = 0;
      v122 = v206 + v208 + v207;
      v123 = v122 + 8 * __src;
      v124 = 8 * v13;
      v125 = v122 + v205;
      v126 = v122 + v205 + v213;
      v14 = v250;
      v127 = v250;
      v128 = a3;
      do
      {
        if (*(v128 + v126))
        {
          cblas_cgemv_NEWLAPACK();
          v14 = v250;
          v128 = a3;
        }

        v123 += v124;
        v121 += v124;
        v125 += 8 * v211;
        v126 += 4;
        --v127;
      }

      while (v127);
    }

    if (a8)
    {
      v129 = *(a8 + 8);
      v130 = *(a8 + 16);
      v264 = __PAIR64__(v14, v13);
      v265 = v13;
      v266 = v222 + v207 + 8 * v255;
      v260 = *&v13;
      v261 = *&v14;
      v262 = v13;
      v263 = v222 + v207;
      v130(v129, 0, &v264, &v260);
      v14 = v250;
      v131 = v222 + v207;
    }

    else
    {
      v131 = v222 + v207 + 8 * v255;
    }

    if (v14 >= 1)
    {
      v132 = 0;
      for (j = 0; j != v14; ++j)
      {
        if (v13 >= 1 && *(v252 + 4 * j))
        {
          for (k = 0; k != v13; ++k)
          {
            if (*(a5 + 12))
            {
              v135 = k;
            }

            else
            {
              v135 = j;
            }

            if (*(a5 + 12))
            {
              v136 = j;
            }

            else
            {
              v136 = k;
            }

            *(*(a5 + 16) + 8 * (v136 + v135 * *(a5 + 8))) = vadd_f32(*(v131 + 8 * v132 + 8 * k), *(*(a5 + 16) + 8 * (v136 + v135 * *(a5 + 8))));
          }
        }

        v132 += v13;
      }
    }

LABEL_133:
    sub_2367A1548(a5, a6, a7, a9);
    v14 = v250;
    if (a2 < 0)
    {
      return;
    }

    goto LABEL_134;
  }

LABEL_144:
  if (a8)
  {
    v147 = *(a8 + 8);
    v148 = *(a8 + 16);
    if (*(a1 + 8) == 2)
    {
      v149 = v224 + 8 * v244 * __src;
    }

    else
    {
      v149 = v222 + v207 + 8 * v255;
    }

    v264 = __PAIR64__(v14, v13);
    v265 = v13;
    v266 = a3 + 8 * v244 * __src;
    v260 = *&v13;
    v261 = *&v14;
    v262 = v13;
    v263 = v149;
    v150 = v14;
    v148(v147, 0, &v264, &v260);
    v151 = *(a9 + 16);
    v264 = __PAIR64__(v150, v13);
    v265 = v13;
    v266 = v149;
    v260 = *&v13;
    v261 = *&v150;
    v262 = v13;
    v263 = v222 + v207;
    v151(a9, 0, 111, &v264, &v260);
  }

  else
  {
    v152 = *(a9 + 16);
    v264 = __PAIR64__(v14, v13);
    v265 = v13;
    v266 = a3 + 8 * v244 * __src;
    v260 = *&v13;
    v261 = *&v14;
    v262 = v13;
    v263 = v222 + v207;
    v150 = v14;
    v152(a9, 0, 111, &v264, &v260);
  }

  v153 = a3;
  if (v150 >= 1)
  {
    v154 = v150;
    v155 = 0;
    v156 = 0;
    v215 = 2 * v235;
    v157 = 8 * v13;
    v158 = 8 * v255;
    v159 = v206 + v208 + a3;
    v160 = v159 + v207 + 4;
    v161 = a3 + 8 * (v244 + 1) * v255 + 4;
    v162 = (v159 + 12);
    v226 = a3 + v208 + 8 * v235 * v244;
    v163 = 8 * v215;
    while ((a4[v156] & 1) != 0)
    {
LABEL_167:
      ++v156;
      v155 += v258;
      v153 += v157;
      v160 += v157;
      v161 += v157;
      v162 = (v162 + v163);
      if (v156 == v154)
      {
        return;
      }
    }

    v257 = v155;
    v248 = v153;
    ++*(v252 + 4 * v156);
    if ((v244 & 0x80000000) == 0)
    {
      v164 = (v244 + 1);
      v165 = (v226 + 8 * v257);
      v166 = v153;
      do
      {
        cblas_cdotc_sub_NEWLAPACK();
        v167 = *v165++;
        v264 = vneg_f32(v167);
        cblas_caxpy_NEWLAPACK();
        v166 += v158;
        --v164;
      }

      while (v164);
    }

    cblas_scnrm2_NEWLAPACK();
    v264 = LODWORD(v168);
    if (hypotf(v168, 0.0) == 0.0)
    {
      v169 = a7;
      v170 = *(a7 + 16);
      v171 = 0.0;
      v155 = v257;
      if (*(a7 + 12))
      {
LABEL_158:
        v172 = v156;
LABEL_166:
        v153 = v248;
        v154 = v250;
        v163 = 8 * v215;
        v157 = 8 * v13;
        v203 = v170 + 8 * v172;
        *v203 = v171;
        *(v203 + 4) = 0;
        goto LABEL_167;
      }
    }

    else
    {
      v173 = v161;
      v174 = v160;
      v175 = v13;
      if (v13 >= 1)
      {
        do
        {
          *(v173 - 1) = sub_23681E680(*(v174 - 1), *v174, *&v264, *(&v264 + 1));
          *v173 = v176;
          v174 += 2;
          v173 += 2;
          --v175;
        }

        while (v175);
      }

      v155 = v257;
      if (v244 >= 1)
      {
        v177 = (v226 + 12 + 8 * v257);
        v178 = (v229 + 8 * v258 * v156 + 8 * v235 * v244);
        v179 = *v178;
        v180 = v178[1];
        v181 = v162;
        v182 = v244;
        do
        {
          v183 = *(v181 - 3);
          v184 = *(v181 - 1);
          v185 = *v181;
          v186 = *(v177 - 1);
          v187 = *v177;
          v188 = (*v181 * v186) + (v184 * *v177);
          *(v177 - 3) = (v179 * v183) + ((v184 * v186) - (*v181 * *v177));
          *(v177 - 2) = (v180 * v183) + v188;
          v189 = v179;
          v190 = v180;
          v191 = v189 * v185 - v190 * v184;
          v179 = -(v184 * v189) - v190 * v185 + (v183 * v186);
          v180 = v191 + (v183 * v187);
          *(v177 - 1) = v179;
          *v177 = v180;
          v181 += 4;
          v177 += 2;
          --v182;
        }

        while (v182);
      }

      v192 = v222 + 8 * v156 * v215;
      v193 = v238 + 8 * v156 * v211;
      v194 = (v192 + 16 * v244);
      v195 = (v192 + 8 * ((2 * v244) | 1));
      cblas_crotg_NEWLAPACK();
      v196 = *v195;
      v197 = v195[1];
      v198 = (v193 + 8 * v244);
      v199 = *v198;
      v200 = v198[1];
      v201 = -(v196 * v199) - v197 * v200;
      *&v197 = v197 * v199 - v196 * v200;
      v202 = v193 + 8 * (v244 + 1);
      *v202 = v201;
      *(v202 + 4) = LODWORD(v197);
      *&v199 = *v194 * v198[1];
      *v198 = *v194 * *v198;
      v198[1] = *&v199;
      v171 = hypotf(v201, *&v197);
      v169 = a7;
      v170 = *(a7 + 16);
      if (*(a7 + 12))
      {
        goto LABEL_158;
      }
    }

    v172 = *(v169 + 8) * v156;
    goto LABEL_166;
  }
}

void _SparseGMRESSolve_Complex_Float(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v56 = *MEMORY[0x277D85DE8];
  v6 = 4;
  if (*(a2 + 12))
  {
    v7 = 4;
  }

  else
  {
    v7 = 0;
  }

  v8 = *(a2 + v7);
  if (*(a2 + 12))
  {
    v6 = 0;
  }

  v9 = *(a2 + v6);
  v10 = *(a1 + 8);
  if (!a5 && v10 == 2)
  {
    v11 = *a1;
    if (!*a1)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_23670BB88();
      }

      _SparseTrap();
    }

    memset(&__str[100], 0, 156);
    strcpy(__str, "FGMRES requires a preconditioner.\nIf no preconditioner is available, use GMRES or DQGMRES instead.\n");
    v11(__str);
LABEL_71:
    v43 = *MEMORY[0x277D85DE8];
    return;
  }

  if (*(a1 + 12))
  {
    v12 = *(a1 + 12);
  }

  else
  {
    v12 = 16;
  }

  v13 = v10 - 1;
  v14 = v9 * v8;
  if (v10 == 2)
  {
    v15 = v14 * v12;
  }

  else
  {
    v15 = 0;
  }

  v16 = 5 * v9 + 8 * (v15 + v9 + v14 + (v9 + v9 * (v12 + v8) * (v12 + 3)));
  if (v13 > 1)
  {
    v16 = v9 + 8 * ((((v12 + 3) * v12 + (2 * v12 + 2) * v8) * v9) + (v9 + v9 * v8));
  }

  v17 = v16 + 24;
  v18 = malloc_type_malloc(v16 + 24, 0x100004077774924uLL);
  if (!v18)
  {
    if (!*a1)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_23670BB0C();
      }

      _SparseTrap();
    }

    memset(__str, 0, 256);
    snprintf(__str, 0x100uLL, "Failed to allocate workspace of size %ld.\n", v17);
    (*a1)(__str);
    goto LABEL_71;
  }

  v19 = v18 + v17;
  *&v53 = __PAIR64__(v9, v8);
  *(&v53 + 1) = v8;
  v20 = ((&v18[2 * v14 + 1] + 3) & 0xFFFFFFFFFFFFFFF8);
  if (v18 + v17 >= v20)
  {
    v44 = v18;
    v54 = v18;
    sub_2367A1548(a2, a3, &v53, a4);
    v21 = &v20[v9 + 7] & 0xFFFFFFFFFFFFFFF8;
    if (v19 >= v21)
    {
      v47 = v20;
      bzero(v20, v9);
      v49 = &v20[v9 + 7] & 0xFFFFFFFFFFFFFFF8;
      v46 = (v21 + 4 * v9 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v19 >= v46)
      {
        v22 = v8;
        if (v9 >= 1)
        {
          v23 = v9;
          v24 = v44;
          v25 = (&v20[v9 + 7] & 0xFFFFFFFFFFFFFFF8);
          do
          {
            cblas_scnrm2_NEWLAPACK();
            *v25++ = v26;
            v24 += 2 * v8;
            --v23;
          }

          while (v23);
        }

        if (*(a1 + 16))
        {
          v27 = *(a1 + 16);
        }

        else
        {
          v27 = 100;
        }

        v28 = *(a1 + 32);
        v29 = v28 == 0.0;
        if (v28 < 0.0)
        {
          v28 = 0.0;
        }

        if (v29)
        {
          v30 = 0.00034527;
        }

        else
        {
          v30 = v28;
        }

        v45 = v27;
        v31 = v20;
        if (v27 < 1)
        {
LABEL_52:
          v42 = *a1;
          if (!*a1)
          {
            if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
            {
              sub_23670BAC8();
            }

            _SparseTrap();
          }

          memset(&__str[35], 0, 221);
          strcpy(__str, "Exceeded maximum iteration limit.\n");
          v42(__str);
        }

        else
        {
          v32 = 0;
          v33 = *(a1 + 24);
          if (BYTE12(v53))
          {
            v34 = 1;
          }

          else
          {
            v34 = v22;
          }

          v35 = 8 * v34;
          while (1)
          {
            if (*(a1 + 40) && (v32 < v12 || !(v32 % v12)))
            {
              v36 = v44;
              if (!v32)
              {
                v36 = v49;
              }

              snprintf(__str, 0xC8uLL, "%5d   %10.2e\n", v32, *v36);
              (*(a1 + 40))(__str);
            }

            _SparseGMRESIterate_Complex_Float(a1, v32, v46, v31, a2, a3, &v53, a5, a4);
            if (v9 < 1)
            {
              v32 = 0;
              goto LABEL_67;
            }

            v37 = 1;
            v38 = v9;
            v39 = v44 + 1;
            v40 = v49;
            do
            {
              v41 = (*v31 & 1) != 0 || hypotf(*(v39 - 1), *v39) < (v33 + (v30 * *v40));
              *v31++ = v41;
              v37 &= v41;
              ++v40;
              v39 = (v39 + v35);
              --v38;
            }

            while (v38);
            if (v37)
            {
              break;
            }

            ++v32;
            v31 = v47;
            if (v32 == v45)
            {
              goto LABEL_52;
            }
          }

          v31 = v47;
LABEL_67:
          if (*(a1 + 40))
          {
            snprintf(__str, 0xC8uLL, "%5d   %10.2e\n", v32 + 1, *v44);
            (*(a1 + 40))(__str);
          }

          _SparseGMRESIterate_Complex_Float(a1, -1, v46, v31, a2, a3, &v53, a5, a4);
        }

        free(v44);
        goto LABEL_71;
      }
    }
  }

  __break(1u);
}

uint64_t sub_2367A3008(uint64_t a1, int a2, int a3, int a4, int a5)
{
  v5 = *(a1 + 16);
  if (v5 >= a3)
  {
    v5 = a3;
  }

  if (v5 >= a4)
  {
    v5 = a4;
  }

  v6 = 8 * (a3 + (v5 + 3) * a4 + 3) + 140;
  v7 = 16 * a4 * a5 + 104;
  if (!a2)
  {
    v7 = 104;
  }

  return v7 + v6 * a5;
}

void _SparseLSMRIterate_Complex_Float(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v9 = a8;
  v13 = a4;
  v14 = a1;
  v15 = 4;
  v16 = (a6[3] & 1) != 0;
  v17 = a6[v16];
  if (*(a5 + 12))
  {
    v18 = 4;
  }

  else
  {
    v18 = 0;
  }

  v19 = *(a5 + v18);
  if (*(a5 + 12))
  {
    v15 = 0;
  }

  v20 = *(a5 + v15);
  v21 = a9;
  v22 = *(a1 + 16);
  if (v22 >= v17)
  {
    v22 = v17;
  }

  if (v22 >= v19)
  {
    v23 = *(a5 + v18);
  }

  else
  {
    v23 = v22;
  }

  v70[0] = v19;
  v70[1] = v20;
  v70[2] = v19;
  v70[3] = 0;
  v71 = (a3 + 140 * v20 + 7) & 0xFFFFFFFFFFFFFFF8;
  v68[0] = v19;
  v68[1] = v20;
  v68[2] = v19;
  v68[3] = 0;
  v69 = v71 + 8 * (v20 * v19);
  v24 = v69 + 8 * (v20 * v19);
  *&v66 = __PAIR64__(v20, v17);
  *(&v66 + 1) = v17;
  v67 = v24 + 8 * (v20 * v19 * v23);
  *&v64 = __PAIR64__(v20, v19);
  *(&v64 + 1) = v19;
  v65 = v67 + 8 * v20 * v17;
  v25 = (v65 + 8 * (v20 * v19));
  *&v62 = __PAIR64__(v20, v19);
  *(&v62 + 1) = v19;
  v63 = 0;
  *&v60 = __PAIR64__(v20, v19);
  *(&v60 + 1) = v19;
  v61 = 0;
  if (a8)
  {
    v26 = 8 * (v20 * v19);
    v63 = v65 + v26;
    v61 = &v25[v26 / 4];
    if ((a2 & 0x80000000) == 0)
    {
      v25 = (v25 + v26 + v26);
      goto LABEL_18;
    }

    sub_236805D74(a5, &v62);
    v54 = *(v9 + 8);
    v55 = *(v9 + 16);
    v74 = v62;
    v75 = v63;
    v72 = *a5;
    v73 = *(a5 + 16);
    v55(v54, 111, &v74, &v72);
LABEL_47:
    sub_2367A1548(a5, a6, a7, a9);
    return;
  }

  if (a2 < 0)
  {
    goto LABEL_47;
  }

LABEL_18:
  v59 = &v25[v20];
  v58 = &v59[v20];
  if (a2)
  {
    goto LABEL_50;
  }

  v57 = a3;
  v30 = sub_2367A33D4(a1, v17, v19, v20, a4, &v66, &v64, a5, a6, &v62, v70, v68, v24, a8, a9, a3);
  v14 = a1;
  v9 = a8;
  a2 = 0;
  v13 = a4;
  v21 = a9;
  a3 = v57;
  if ((v30 & 1) == 0)
  {
LABEL_50:
    v31 = *(v14 + 8);
    v56 = v9;
    v32 = a3;
    sub_2367A380C(a2, v31, 0.0, v17, v19, v20, v13, &v66, &v64, a5, &v62, &v60, v70, v68, v24, v25, v59, v58, v56, v21, a3);
    if (v20 >= 1)
    {
      v33 = v32;
      v34 = 0;
      v35 = 4;
      if ((*(a7 + 12) & 1) == 0)
      {
        v35 = 0;
      }

      v36 = *(a7 + v35);
      v37 = (v33 + 64);
      do
      {
        if (v36 >= 1)
        {
          v38 = hypotf(*(v37 - 1), *v37);
          v39 = (*(a7 + 12) & 1) != 0 ? v34 : *(a7 + 8) * v34;
          v40 = *(a7 + 16) + 8 * v39;
          *v40 = v38;
          *(v40 + 4) = 0;
          if (v36 != 1)
          {
            v41 = *(a7 + 8);
            v42 = v34 + v41;
            v43 = v41 * v34;
            v44 = (*(a7 + 12) & 1) != 0 ? v42 : v43 + 1;
            v45 = (*(a7 + 16) + 8 * v44);
            *v45 = v25[v34];
            v45[1] = 0;
            if (v36 >= 3)
            {
              v46 = *(a7 + 8);
              v47 = v34 + 2 * v46;
              v48 = v46 * v34 + 2;
              v49 = (*(a7 + 12) & 1) != 0 ? v47 : v48;
              v50 = (*(a7 + 16) + 8 * v49);
              *v50 = v59[v34];
              v50[1] = 0;
              if (v36 != 3)
              {
                if (*(a7 + 12))
                {
                  v51 = 3;
                }

                else
                {
                  v51 = v34;
                }

                if (*(a7 + 12))
                {
                  v52 = v34;
                }

                else
                {
                  v52 = 3;
                }

                v53 = (*(a7 + 16) + 8 * (v52 + *(a7 + 8) * v51));
                *v53 = v58[v34];
                v53[1] = 0;
              }
            }
          }
        }

        ++v34;
        v37 += 35;
      }

      while (v20 != v34);
    }
  }
}

uint64_t sub_2367A33D4(uint64_t a1, int a2, int a3, int a4, uint64_t a5, uint64_t a6, __int128 *a7, int *a8, int *a9, __int128 *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  v20 = *(a1 + 16);
  if (v20 >= a2)
  {
    v20 = a2;
  }

  if (v20 >= a3)
  {
    v20 = a3;
  }

  v44 = v20;
  sub_236805D74(a9, a6);
  sub_2366FD4D0(a8);
  v21 = 1;
  if (a4 >= 1)
  {
    v22 = 0;
    v23 = a16;
    v24 = a4;
    v25 = -a4;
    v26 = 1;
LABEL_7:
    v27 = v23 + 140 * v22++;
    do
    {
      if ((*(a5 + v22 - 1) & 1) == 0)
      {
        *v27 = 0;
        v28 = *(a6 + 16) + 8 * *(a6 + 8) * (v22 - 1);
        *(v27 + 4) = 0;
        cblas_scnrm2_NEWLAPACK();
        *(v27 + 8) = v29;
        if (v29 > 0.0)
        {
          *&v51 = 1.0 / v29;
          DWORD1(v51) = 0;
          cblas_cscal_NEWLAPACK();
          v26 = 0;
          v23 = a16;
          if (v25 + v22)
          {
            goto LABEL_7;
          }

          goto LABEL_17;
        }

        *v27 = 1;
        *(v27 + 60) = 0;
        *(v27 + 64) = 0;
      }

      ++v22;
      v27 += 140;
    }

    while (v25 + v22 != 1);
    v23 = a16;
    if (v26)
    {
      v21 = 1;
      return v21 & 1;
    }

LABEL_17:
    v30 = *(a15 + 16);
    v51 = *a6;
    v52 = *(a6 + 16);
    if (a14)
    {
      v49 = *a10;
      v50 = *(a10 + 2);
      v30();
      v31 = *(a14 + 8);
      v32 = *(a14 + 16);
      v51 = *a10;
      v52 = *(a10 + 2);
      v49 = *a7;
      v50 = *(a7 + 2);
      v32(v31, 113, &v51, &v49);
    }

    else
    {
      v49 = *a7;
      v50 = *(a7 + 2);
      v30();
    }

    v33 = 0;
    v34 = 0;
    __n = 8 * a3;
    v35 = (v23 + 136);
    v21 = 1;
    do
    {
      if ((*(a5 + v34) & 1) == 0 && *(v35 - 32) != 0.0)
      {
        v36 = (*(a7 + 2) + 8 * v34 * *(a7 + 2));
        v37 = *(a11 + 16);
        v38 = *(a11 + 8);
        v45 = *(a12 + 8);
        v46 = *(a12 + 16);
        cblas_scnrm2_NEWLAPACK();
        *(v35 - 33) = v39;
        if (v39 > 0.0)
        {
          *&v51 = 1.0 / v39;
          DWORD1(v51) = 0;
          cblas_cscal_NEWLAPACK();
          v39 = *(v35 - 33);
        }

        v40 = v39 * *(v35 - 32);
        if (v40 == 0.0)
        {
          *(v35 - 136) = 1;
        }

        else
        {
          *(v35 - 68) = v44 > 0;
          *(v35 - 16) = 0.0;
          *(v35 - 15) = v44;
          *(v35 - 67) = 0;
          if (v44 >= 1)
          {
            memcpy((a13 + 8 * v33), v36, __n);
            v39 = *(v35 - 33);
            v40 = v39 * *(v35 - 32);
          }

          *(v35 - 19) = v40;
          *(v35 - 18) = 0.0;
          *(v35 - 31) = v39;
          *(v35 - 22) = 0.0;
          *(v35 - 30) = xmmword_23681FB70;
          *(v35 - 26) = xmmword_23681FE90;
          memcpy((v37 + 8 * v34 * v38), v36, __n);
          bzero((v46 + 8 * v34 * v45), __n);
          v21 = 0;
          v41 = *(v35 - 33);
          *(v35 - 12) = *(v35 - 32);
          *(v35 - 7) = 0;
          *(v35 - 21) = 0;
          *(v35 - 11) = xmmword_23681FEA0;
          *(v35 - 5) = 0;
          *(v35 - 7) = 0;
          *(v35 - 3) = 0.0;
          *v35 = v41 * v41;
          *(v35 - 1) = 0x7F7FFFFF00000000;
        }
      }

      ++v34;
      v35 += 35;
      v33 += a3 * v44;
    }

    while (v24 != v34);
  }

  return v21 & 1;
}

void sub_2367A380C(int a1, float a2, float a3, uint64_t a4, int a5, int a6, _BYTE *a7, __int128 *a8, __int128 *a9, uint64_t a10, __int128 *a11, __int128 *a12, uint64_t a13, uint64_t a14, uint64_t a15, _DWORD *a16, _DWORD *a17, _DWORD *a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
  if (*(a10 + 12))
  {
    v26 = *(a10 + 8);
  }

  v209 = a7;
  if (a6 >= 1)
  {
    v27 = a6;
    v28 = a7;
    v29 = a21;
    v30 = a16;
    v31 = a17;
    v32 = a18;
    do
    {
      v33 = *v28++;
      if ((v33 & 1) == 0 && *v29 == 1)
      {
        *v30 = 0;
        *v31 = 0;
        *v32 = -1082130432;
      }

      ++v32;
      ++v31;
      ++v30;
      v29 += 140;
      --v27;
    }

    while (v27);
    v34 = 0;
    v35 = (a21 + 4);
    do
    {
      if ((a7[v34] & 1) == 0 && (*(v35 - 1) & 1) == 0)
      {
        v36 = *(a8 + 2);
        v37 = (*(a8 + 2) * v34);
        *&v212 = -*v35;
        DWORD1(v212) = 0;
        cblas_cscal_NEWLAPACK();
        a7 = v209;
      }

      ++v34;
      v35 += 35;
    }

    while (a6 != v34);
  }

  if (a19)
  {
    v38 = *(a19 + 8);
    v39 = *(a19 + 16);
    v212 = *a9;
    v213 = *(a9 + 2);
    v210 = *a11;
    v211 = *(a11 + 2);
    v39(v38, 111, &v212, &v210);
    v40 = *(a20 + 16);
    v212 = *a11;
    v41 = *(a11 + 2);
  }

  else
  {
    v40 = *(a20 + 16);
    v212 = *a9;
    v41 = *(a9 + 2);
  }

  v213 = v41;
  v210 = *a8;
  v211 = *(a8 + 2);
  v40();
  v42 = v209;
  if (a6 >= 1)
  {
    v202 = a8;
    v43 = 0;
    v44 = 0;
    v45 = a5;
    v46 = a21 + 76;
    v47 = -a6;
    v205 = a5;
    v178 = a10;
    v179 = a9;
    v180 = a5;
    v177 = a6;
    v181 = a5;
    while (2)
    {
      v196 = v44;
      v48 = v45 * v43;
      v49 = (v46 + 140 * v43);
      v50 = v43++;
      while (1)
      {
        if ((v42[v43 - 1] & 1) == 0 && (*(v49 - 19) & 1) == 0)
        {
          v51 = v47;
          v52 = *(v202 + 2) + 8 * *(v202 + 2) * (v43 - 1);
          v53 = *(v179 + 2);
          v54 = *(v179 + 2);
          v55 = *v49;
          cblas_scnrm2_NEWLAPACK();
          v47 = v51;
          v45 = v205;
          v42 = v209;
          *(v49 - 17) = v56;
          if (v56 > 0.0)
          {
            break;
          }
        }

        v48 += v45;
        ++v43;
        v49 += 35;
        ++v50;
        if (v47 + v43 == 1)
        {
          v63 = a21;
          v67 = v178;
          v66 = v179;
          v65 = v180;
          v64 = v177;
          v62 = v181;
          if ((v196 & 1) == 0)
          {
            goto LABEL_42;
          }

          goto LABEL_34;
        }
      }

      *&v212 = 1.0 / v56;
      DWORD1(v212) = 0;
      cblas_cscal_NEWLAPACK();
      v57 = v180;
      v58 = v181;
      if (*(v49 - 8) == 1)
      {
        v59 = *v49;
        v60 = *(v49 - 1) + 1;
        *(v49 - 1) = v60;
        if (v60 >= SLODWORD(v59))
        {
          *(v49 - 1) = 0.0;
          *(v49 - 7) = 1;
        }

        v57 = v180;
        v58 = v181;
        if (v180 >= 1)
        {
          v61 = 0;
          do
          {
            *(a15 + 8 * v48 * v55 + 8 * (v61 + *(v49 - 1) * v180)) = *(v53 + 8 * v54 * v50 + 8 * v61);
            ++v61;
          }

          while (v181 != v61);
        }
      }

      *&v212 = -*(v49 - 17);
      DWORD1(v212) = 0;
      v44 = 1;
      v62 = v58;
      cblas_cscal_NEWLAPACK();
      v64 = v177;
      v63 = a21;
      v42 = v209;
      v65 = v57;
      v45 = v205;
      v46 = a21 + 76;
      v47 = v51;
      v67 = v178;
      v66 = v179;
      if (v177 != v43)
      {
        continue;
      }

      break;
    }

LABEL_34:
    v68 = *(a20 + 16);
    if (a19)
    {
      v212 = *v202;
      v213 = *(v202 + 2);
      v210 = *a11;
      v211 = *(a11 + 2);
      v68();
      v69 = *(a19 + 8);
      v70 = *(a19 + 16);
      v212 = *a11;
      v213 = *(a11 + 2);
      v210 = *a12;
      v211 = *(a12 + 2);
      v70(v69, 113, &v212, &v210);
      v71 = 0;
      v42 = v209;
      v45 = v205;
      do
      {
        if (v65 >= 1)
        {
          v72 = 0;
          do
          {
            v73 = v72 + *(v66 + 2) * v71;
            *(*(v66 + 2) + 8 * v73) = vadd_f32(*(*(a12 + 2) + 8 * (v72 + *(a12 + 2) * v71)), *(*(v66 + 2) + 8 * v73));
            ++v72;
          }

          while (v62 != v72);
        }

        ++v71;
      }

      while (v71 != v64);
    }

    else
    {
      v212 = *v202;
      v213 = *(v202 + 2);
      v210 = *v66;
      v211 = *(v66 + 2);
      v68();
      v42 = v209;
      v45 = v205;
    }

LABEL_42:
    v74 = 0;
    v75 = 0;
    v76 = a2 != 0.0;
    if (a3 != 0.0)
    {
      v76 = 1;
    }

    v174 = v76;
    v77 = 8 * v45;
    v175 = 8 * v45;
    do
    {
      if ((v42[v75] & 1) == 0)
      {
        v78 = v63 + 140 * v75;
        if ((*v78 & 1) == 0)
        {
          if ((*(v67 + 12) & 1) == 0)
          {
            v79 = *(v67 + 8) * v75;
          }

          v80 = *(v66 + 2);
          v191 = *(v67 + 16);
          v201 = *(a13 + 16);
          v197 = *(v66 + 2);
          v199 = *(a13 + 8);
          v206 = *(a14 + 16);
          v203 = *(a14 + 8);
          if (*(v78 + 8) > 0.0)
          {
            v81 = *(v66 + 2);
            if (*(v78 + 68) == 1)
            {
              v82 = *(v78 + 76);
              if ((*(v78 + 69) & 1) == 0)
              {
                v82 = *(v78 + 72) + 1;
              }

              if (v82 >= 1)
              {
                v83 = v82;
                v84 = a15 + v74 * *(v78 + 76);
                do
                {
                  *&v212 = 0;
                  cblas_cdotc_sub_NEWLAPACK();
                  *&v212 = vneg_f32(*&v212);
                  cblas_caxpy_NEWLAPACK();
                  v84 += v77;
                  --v83;
                }

                while (v83);
              }
            }

            cblas_scnrm2_NEWLAPACK();
            *(v78 + 4) = v85;
            v80 = v81;
            if (v85 > 0.0)
            {
              *&v212 = COERCE_UNSIGNED_INT(1.0 / v85);
              cblas_cscal_NEWLAPACK();
            }
          }

          v86 = *(v78 + 12);
          v87 = *(v78 + 16);
          v88 = sub_23681E680(v86, v87, v86, v87);
          if (v174)
          {
            v90 = *(v78 + 12);
            v91 = *(v78 + 16);
            sub_2367A53BC(v90, v91, a2, a3);
            v86 = v92;
            v87 = 0.0;
            v93 = sub_23681E680(v90, v91, v92, 0.0);
            v184 = v94;
            v185 = v93;
            v192 = sub_23681E680(a2, a3, v86, 0.0);
            v190 = v95;
          }

          else
          {
            v184 = v89;
            v185 = v88;
            v192 = 0.0;
            v190 = 0.0;
          }

          v182 = *(v78 + 40);
          v183 = *(v78 + 36);
          sub_2367A53BC(v86, v87, *(v78 + 8), 0.0);
          *(v78 + 36) = v96;
          *(v78 + 40) = 0;
          v97 = sub_23681E680(v86, v87, v96, 0.0);
          v99 = v98;
          v100 = sub_23681E680(*(v78 + 8), 0.0, *(v78 + 36), *(v78 + 40));
          v102 = v101;
          v103 = *(v78 + 4);
          v186 = v99;
          v187 = v97;
          *(v78 + 12) = v97 * v103;
          *(v78 + 16) = v99 * v103;
          v104 = *(v78 + 40);
          v208 = *(v78 + 44);
          v193 = *(v78 + 56);
          v194 = *(v78 + 52);
          v105 = *(v78 + 28);
          v106 = *(v78 + 32);
          v107 = *(v78 + 36);
          v108 = (v105 * v107) - (v106 * v104);
          v109 = (v106 * v107) + (v105 * v104);
          v110 = *(v78 + 20);
          v111 = *(v78 + 24);
          v112 = (v110 * v107) - (v111 * v104);
          v195 = v112;
          v113 = (v111 * v107) + (v110 * v104);
          v188 = v102;
          v189 = v100;
          v114 = v100 * v103;
          v115 = v102 * v103;
          sub_2367A53BC(v112, v113, v114, v115);
          *(v78 + 44) = v116;
          *(v78 + 48) = 0;
          *(v78 + 20) = sub_23681E680(v112, v113, v116, 0.0);
          *(v78 + 24) = v117;
          v118 = sub_23681E680(v114, v115, *(v78 + 44), *(v78 + 48));
          *(v78 + 28) = v118;
          *(v78 + 32) = v119;
          v120 = *(v78 + 20);
          v121 = *(v78 + 24);
          v122 = *(v78 + 60);
          v123 = *(v78 + 64);
          v124 = v80;
          *(v78 + 52) = (v120 * v122) - (v121 * v123);
          *(v78 + 56) = (v121 * v122) + (v120 * v123);
          *(v78 + 60) = (v119 * v123) - (v118 * v122);
          *(v78 + 64) = -(v119 * v122) - (v118 * v123);
          if (v65 >= 1)
          {
            v125 = (v206 + 8 * v203 * v75 + 4);
            v126 = (v201 + 8 * v199 * v75 + 4);
            v127 = v181;
            do
            {
              v128 = *(v126 - 1);
              v129 = *v126;
              v130 = sub_23681E680((v108 * *(v78 + 36)) - (v109 * *(v78 + 40)), (v109 * *(v78 + 36)) + (v108 * *(v78 + 40)), v183 * v208, v182 * v208);
              v131 = *(v125 - 1);
              v133 = (v132 * v131) + (v130 * *v125);
              *(v125 - 1) = v128 - ((v130 * v131) - (v132 * *v125));
              *v125 = v129 - v133;
              v125 += 2;
              v126 += 2;
              --v127;
            }

            while (v127);
          }

          LODWORD(v212) = sub_23681E680(*(v78 + 52), *(v78 + 56), (*(v78 + 36) * *(v78 + 44)) - (*(v78 + 40) * *(v78 + 48)), (*(v78 + 40) * *(v78 + 44)) + (*(v78 + 36) * *(v78 + 48)));
          DWORD1(v212) = v134;
          cblas_caxpy_NEWLAPACK();
          v67 = v178;
          if (v65 >= 1)
          {
            v135 = (v201 + 8 * v199 * v75 + 4);
            v136 = (v124 + 8 * v197 * v75 + 4);
            v137 = v181;
            do
            {
              v138 = *(v136 - 1);
              v139 = *v136;
              v140 = sub_23681E680(v114, v115, *(v78 + 36), *(v78 + 40));
              v141 = *(v135 - 1);
              v143 = (v142 * v141) + (v140 * *v135);
              *(v135 - 1) = v138 - ((v140 * v141) - (v142 * *v135));
              *v135 = v139 - v143;
              v135 += 2;
              v136 += 2;
              --v137;
            }

            while (v137);
          }

          v144 = *(v78 + 88);
          v145 = *(v78 + 92);
          v146 = (v185 * v144) - (v184 * v145);
          v147 = (v184 * v144) + (v185 * v145);
          v64 = v177;
          v63 = a21;
          v77 = v175;
          v204 = -(v190 * v144) - (v192 * v145);
          v148 = (v187 * v146) - (v186 * v147);
          v149 = (v186 * v146) + (v187 * v147);
          v65 = v180;
          v207 = (v190 * v145) - (v192 * v144);
          *(v78 + 88) = (v188 * v147) - (v189 * v146);
          *(v78 + 92) = -(v188 * v146) - (v189 * v147);
          v198 = *(v78 + 124);
          v200 = *(v78 + 120);
          v150 = *(v78 + 104);
          v151 = *(v78 + 108);
          sub_2367A53BC(v150, v151, v108, v109);
          v153 = v152;
          v154 = sub_23681E680(v150, v151, v152, 0.0);
          v156 = v155;
          v157 = sub_23681E680(v108, v109, v153, 0.0);
          v158 = *(v78 + 44);
          v159 = *(v78 + 48);
          *(v78 + 120) = (v157 * v158) - (v160 * v159);
          *(v78 + 124) = (v160 * v158) + (v157 * v159);
          *(v78 + 104) = (v154 * v158) - (v156 * v159);
          *(v78 + 108) = (v156 * v158) + (v154 * v159);
          v161 = *(v78 + 80);
          v162 = *(v78 + 84);
          *(v78 + 80) = ((v160 * v162) - (v157 * v161)) + ((v148 * v154) - (v149 * v156));
          *(v78 + 84) = (-(v160 * v161) - (v157 * v162)) + ((v149 * v154) + (v148 * v156));
          v163 = sub_23681E680(v194 - ((v200 * *(v78 + 112)) - (v198 * *(v78 + 116))), v193 - ((v198 * *(v78 + 112)) + (v200 * *(v78 + 116))), v153, 0.0);
          *(v78 + 112) = v163;
          *(v78 + 116) = v164;
          v165 = sub_23681E680(*(v78 + 52) - ((v163 * *(v78 + 120)) - (v164 * *(v78 + 124))), *(v78 + 56) - ((v164 * *(v78 + 120)) + (v163 * *(v78 + 124))), *(v78 + 104), *(v78 + 108));
          v166 = *(v78 + 100);
          v42 = v209;
          v167 = *(v78 + 96) + ((v207 * v207) - (v204 * v204));
          *(v78 + 96) = v167;
          *(v78 + 100) = v166 + ((v207 * v204) + (v207 * v204));
          *&a16[v75] = sqrtf((v167 + (((*(v78 + 80) - v165) * (*(v78 + 80) - v165)) - ((*(v78 + 84) - v168) * (*(v78 + 84) - v168)))) + ((*(v78 + 88) * *(v78 + 88)) - (*(v78 + 92) * *(v78 + 92))));
          v169 = *(v78 + 136) + (*(v78 + 8) * *(v78 + 8));
          *(v78 + 136) = v169;
          *&a17[v75] = sqrtf(v169);
          *(v78 + 136) = *(v78 + 136) + (*(v78 + 4) * *(v78 + 4));
          v170 = *(v78 + 128);
          if (v208 > v170)
          {
            *(v78 + 128) = v208;
            v170 = v208;
          }

          v171 = *(v78 + 132);
          if (a1 >= 1 && v208 < v171)
          {
            *(v78 + 132) = v208;
            v171 = v208;
          }

          if (v170 <= v195)
          {
            v170 = v195;
          }

          if (v171 >= v195)
          {
            v171 = v195;
          }

          *&a18[v75] = v170 / v171;
        }
      }

      ++v75;
      v74 += v77;
    }

    while (v75 != v64);
  }
}

uint64_t _SparseLSMRSolve_Complex_Float(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5)
{
  v5 = a5;
  v142 = *MEMORY[0x277D85DE8];
  v9 = 4;
  v10 = (a3[3] & 1) != 0;
  v11 = a3[v10];
  if (*(a2 + 12))
  {
    v12 = 4;
  }

  else
  {
    v12 = 0;
  }

  v13 = *(a2 + v12);
  if (*(a2 + 12))
  {
    v9 = 0;
  }

  v14 = *(a2 + v9);
  v15 = *(a1 + 56);
  if (v15 <= 0)
  {
    v15 = 4 * v13;
  }

  v105 = v15;
  v16 = *(a1 + 16);
  if (v16 >= v11)
  {
    v16 = v11;
  }

  if (v16 >= v13)
  {
    v16 = *(a2 + v12);
  }

  v17 = 8 * (v11 + (v16 + 3) * v13 + 3);
  v18 = 8 * (2 * v13 * v14) + 104;
  if (!a5)
  {
    v18 = 104;
  }

  v19 = v18 + v14 + (v17 + 148) * v14 + 16;
  v20 = malloc_type_malloc(v19, 0xEC5780E5uLL);
  if (v20)
  {
    v21 = v20;
    v22 = v20 + v19;
    v23 = *(a1 + 16);
    if (v23 >= v11)
    {
      v23 = v11;
    }

    if (v23 >= v13)
    {
      v24 = v13;
    }

    else
    {
      v24 = v23;
    }

    v25 = (&v20[35 * v14 + 1] + 3) & 0xFFFFFFFFFFFFFFF8;
    if (v22 >= v25)
    {
      v124[0] = v13;
      v124[1] = v14;
      v124[2] = v13;
      v124[3] = 0;
      v26 = v14 * v13;
      v27 = v25 + 8 * (v14 * v13);
      if (v27 <= v22)
      {
        v28 = v11;
        v125 = (&v20[35 * v14 + 1] + 3) & 0xFFFFFFFFFFFFFFF8;
        v29 = 8 * v26;
        v122[0] = v13;
        v122[1] = v14;
        v122[2] = v13;
        v122[3] = 0;
        v30 = v27 + v29;
        if (v27 + v29 <= v22)
        {
          v123 = v27;
          v31 = (v30 + 8 * (v24 * v26)) & 0xFFFFFFFFFFFFFFF8;
          if (v22 >= v31)
          {
            *&v120 = __PAIR64__(v14, v28);
            *(&v120 + 1) = v28;
            v32 = v31 + 8 * (v14 * v28);
            if (v32 <= v22)
            {
              v121 = v31;
              *&v118 = __PAIR64__(v14, v13);
              v33 = (v32 + v29);
              *(&v118 + 1) = v13;
              if (v32 + v29 <= v22)
              {
                v119 = v31 + 8 * (v14 * v28);
                *&v116 = __PAIR64__(v14, v13);
                *(&v116 + 1) = v13;
                v117 = 0;
                *&v114 = __PAIR64__(v14, v13);
                *(&v114 + 1) = v13;
                v115 = 0;
                if (v5)
                {
                  v34 = &v33[v29] & 0xFFFFFFFFFFFFFFF8;
                  if (v22 < v34)
                  {
                    goto LABEL_107;
                  }

                  v117 = v33;
                  v33 = (v34 + v29);
                  if (v34 + v29 > v22)
                  {
                    goto LABEL_107;
                  }

                  v115 = v34;
                }

                v35 = &v33[v14 + 7] & 0xFFFFFFFFFFFFFFF8;
                if (v22 >= v35)
                {
                  v108 = (&v33[v14 + 7] & 0xFFFFFFFFFFFFFFF8);
                  v36 = (v35 + 4 * v14 + 7) & 0xFFFFFFFFFFFFFFF8;
                  if (v22 >= v36)
                  {
                    v37 = 4 * v14;
                    v109 = v36;
                    v38 = (v36 + v37 + 7) & 0xFFFFFFFFFFFFFFF8;
                    if (v22 >= v38)
                    {
                      v111 = v38;
                      v39 = (v38 + v37 + 7) & 0xFFFFFFFFFFFFFFF8;
                      if (v22 >= v39)
                      {
                        v106 = v28;
                        v110 = v39;
                        if (v22 >= ((v39 + v37 + 7) & 0xFFFFFFFFFFFFFFF8))
                        {
                          bzero(v33, v14);
                          if (sub_2367A33D4(a1, v106, v13, v14, v33, &v120, &v118, a2, a3, &v116, v124, v122, v30, v5, a4, v21))
                          {
                            if (!v5)
                            {
LABEL_42:
                              free(v21);
                              result = 0;
                              goto LABEL_102;
                            }

                            sub_236805D74(a2, &v116);
                            v40 = *(v5 + 8);
                            v41 = *(v5 + 16);
                          }

                          else
                          {
                            v102 = v30;
                            v104 = v21;
                            v43 = *(a1 + 20);
                            if (v43)
                            {
                              v44 = (&v33[v14 + 7] & 0xFFFFFFFFFFFFFFF8);
                              if (v43 == 1 && v14 >= 1)
                              {
                                v45 = (v21 + 2);
                                v46 = v14;
                                do
                                {
                                  v47 = *v45;
                                  v45 += 35;
                                  *v44++ = v47;
                                  --v46;
                                }

                                while (v46);
                              }
                            }

                            else
                            {
                              v48 = (&v33[v14 + 7] & 0xFFFFFFFFFFFFFFF8);
                              if (v14 >= 1)
                              {
                                v49 = v21 + 16;
                                v50 = v14;
                                do
                                {
                                  *v48++ = hypotf(*(v49 - 1), *v49);
                                  v49 += 35;
                                  --v50;
                                }

                                while (v50);
                              }
                            }

                            v51 = *(a1 + 48);
                            v52 = 0.0;
                            if (v51 > 0.0)
                            {
                              v52 = 1.0 / v51;
                            }

                            v53 = *(a1 + 64);
                            v54 = v104;
                            v55 = a4;
                            v56 = v109;
                            if (v53)
                            {
                              v53("\n   Itn       y(1)           norm rbar    Abar'rbar Compatible    LS    norm Abar cond Abar\n");
                              snprintf(__str, 0xC8uLL, "%6d%17.9e+%17.9ei%17.9e%10.2e%10.2e%10.2e\n", 0, **(a2 + 16), *(*(a2 + 16) + 4), v104[2], (v104[2] * v104[1]), 1.0, (v104[1] / v104[2]));
                              (*(a1 + 64))(__str);
                            }

                            v57 = *(a1 + 32);
                            v58 = v57 == 0.0;
                            if (v57 < 0.0)
                            {
                              v57 = 0.0;
                            }

                            if (v58)
                            {
                              v59 = 0.00034527;
                            }

                            else
                            {
                              v59 = v57;
                            }

                            if (v105 < 1)
                            {
LABEL_100:
                              free(v54);
                              result = 1;
                              goto LABEL_102;
                            }

                            v60 = 0;
                            v101 = v5;
                            while (1)
                            {
                              v61 = *(a1 + 8);
                              v100 = v5;
                              v62 = v111;
                              sub_2367A380C(v60, v61, 0.0, v106, v13, v14, v33, &v120, &v118, a2, &v116, &v114, v124, v122, v102, v56, v111, v110, v100, v55, v54);
                              v63 = *(a1 + 20);
                              v103 = v60;
                              if (v63 == 1)
                              {
                                break;
                              }

                              if (v63 || v14 < 1)
                              {
                                goto LABEL_103;
                              }

                              v64 = 1;
                              v65 = v14;
                              v66 = v104 + 16;
                              v67 = v33;
                              v68 = (&v33[v14 + 7] & 0xFFFFFFFFFFFFFFF8);
                              do
                              {
                                v69 = *v67 || *(a1 + 24) + (v59 * *v68) >= hypotf(*(v66 - 1), *v66);
                                *v67++ = v69;
                                v64 &= v69;
                                ++v68;
                                v66 += 35;
                                --v65;
                              }

                              while (v65);
LABEL_94:
                              v62 = v111;
                              v60 = v103;
                              if (v64)
                              {
                                goto LABEL_103;
                              }

                              v54 = v104;
                              v56 = v109;
                              if (*(a1 + 64) && (v103 < 0xA || !(v103 % 0xA)))
                              {
                                v87 = *(a2 + 16);
                                v88 = *v87;
                                v89 = v87[1];
                                v90 = *v109;
                                v91 = *v109;
                                v92 = hypotf(v104[15], v104[16]);
                                snprintf(__str, 0xC8uLL, "%6d%17.9e+%17.9ei%17.9e%10.2e%10.2e%10.2e%10.2e%10.2e\n", v103, v88, v89, v91, v92, (v90 / *v108), (v92 / (v90 * *v111)), *v111, *v110);
                                (*(a1 + 64))(__str);
                              }

                              v60 = v103 + 1;
                              v5 = v101;
                              v55 = a4;
                              if (v103 + 1 == v105)
                              {
                                goto LABEL_100;
                              }
                            }

                            if (*(a2 + 12))
                            {
                              v70 = *(a2 + 8);
                            }

                            if (v14 >= 1)
                            {
                              v71 = 0;
                              v64 = 1;
                              v72 = v104 + 16;
                              while (1)
                              {
                                if ((v33[v71] & 1) == 0)
                                {
                                  v73 = hypotf(*(v72 - 1), *v72);
                                  if ((*(a2 + 12) & 1) == 0)
                                  {
                                    v74 = (*(a2 + 8) * v71);
                                  }

                                  v75 = *(a2 + 16);
                                  cblas_scnrm2_NEWLAPACK();
                                  v77 = 1.0 / v110[v71];
                                  if (v77 + 1.0 <= 1.0 || v77 <= v52)
                                  {
                                    free(v104);
                                    result = 4294967294;
                                    goto LABEL_102;
                                  }

                                  v78 = v109[v71];
                                  v79 = v111[v71];
                                  v80 = (v73 / (v78 * v79));
                                  if (v80 + 1.0 <= 1.0 || (v81 = v108[v71], v82 = v78 / v81, v83 = *(a1 + 24), v84 = *(a1 + 40) + v83 * v79 * v76 / v81, v82 <= v84) || v83 >= v80 || (v85 = v82 / (((v76 * v79) / v81) + 1.0), v85 + 1.0 <= 1.0))
                                  {
                                    v86 = 1;
                                    v33[v71] = 1;
                                  }

                                  else
                                  {
                                    v86 = v33[v71] != 0;
                                  }

                                  v64 &= v86;
                                }

                                ++v71;
                                v72 += 35;
                                if (v14 == v71)
                                {
                                  goto LABEL_94;
                                }
                              }
                            }

LABEL_103:
                            v21 = v104;
                            if (*(a1 + 64))
                            {
                              v94 = *(a2 + 16);
                              v95 = *v94;
                              v96 = v94[1];
                              v97 = *v109;
                              v98 = *v109;
                              v99 = hypotf(v104[15], v104[16]);
                              snprintf(__str, 0xC8uLL, "%6d%17.9e+%17.9ei%17.9e%10.2e%10.2e%10.2e%10.2e%10.2e\n", v60, v95, v96, v98, v99, (v97 / *v108), (v99 / (v97 * *v62)), *v62, *v110);
                              (*(a1 + 64))(__str);
                            }

                            if (!v101)
                            {
                              goto LABEL_42;
                            }

                            sub_236805D74(a2, &v116);
                            v40 = *(v101 + 8);
                            v41 = *(v101 + 16);
                          }

                          *__str = v116;
                          *&v127 = v117;
                          v112 = *a2;
                          v113 = *(a2 + 16);
                          v41(v40, 111, __str, &v112);
                          goto LABEL_42;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

LABEL_107:
    __break(1u);
  }

  if (!*a1)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_23670BBCC();
    }

    _SparseTrap();
  }

  v140 = 0u;
  v141 = 0u;
  v138 = 0u;
  v139 = 0u;
  v136 = 0u;
  v137 = 0u;
  v134 = 0u;
  v135 = 0u;
  v132 = 0u;
  v133 = 0u;
  v130 = 0u;
  v131 = 0u;
  v128 = 0u;
  v129 = 0u;
  *__str = 0u;
  v127 = 0u;
  snprintf(__str, 0x100uLL, "Failed to allocate workspace of size %ld\n", v19);
  (*a1)(__str);
  result = 4294967197;
LABEL_102:
  v93 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t sub_2367A525C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = 4;
  if (*(a3 + 12))
  {
    v4 = 0;
  }

  v5 = *(a3 + v4);
  if (v5 >= 1)
  {
    v6 = 0;
    v7 = 4;
    if ((*(a3 + 12) & 1) == 0)
    {
      v7 = 0;
    }

    v8 = *(a3 + v7);
    do
    {
      if (*(a3 + 12))
      {
        v9 = v6;
      }

      else
      {
        v9 = *(a3 + 8) * v6;
      }

      if (*(a3 + 12))
      {
        v10 = *(a3 + 8);
      }

      else
      {
        v10 = 1;
      }

      v11 = *(a4 + 8) * v6;
      if (*(a4 + 12))
      {
        v11 = v6;
        v12 = *(a4 + 8);
      }

      else
      {
        v12 = 1;
      }

      if (v8 >= 1)
      {
        v13 = *(a3 + 16) + 8 * v9;
        v14 = (*(a4 + 16) + 8 * v11 + 4);
        v15 = 8 * v12;
        v16 = (v13 + 4);
        v17 = 8 * v10;
        v18 = (result + 4);
        v19 = v8;
        do
        {
          v20 = *(v18 - 1);
          v21 = *(v16 - 1);
          v22 = (*v18 * v21) + (v20 * *v16);
          *(v14 - 1) = (v20 * v21) - (*v18 * *v16);
          *v14 = v22;
          v14 = (v14 + v15);
          v18 += 2;
          v16 = (v16 + v17);
          --v19;
        }

        while (v19);
      }

      ++v6;
    }

    while (v6 != v5);
  }

  return result;
}

void sub_2367A53BC(float a1, float a2, float a3, float a4)
{
  v8 = hypotf(a1, a2);
  v9 = v8 + hypotf(a3, a4);
  if (v9 != 0.0)
  {
    hypotf(a1 / v9, a2 / v9);
    hypotf(a3 / v9, a4 / v9);
  }
}

uint64_t sub_2367A5454(int a1, const void *a2, size_t a3, int *a4, uint64_t a5, uint64_t a6)
{
  v8 = *(a4 + 28);
  v35 = (~*(a4 + 12) & 0xC) == 0;
  v9 = a4[1];
  if (a5)
  {
    v10 = *(a5 + 4);
  }

  else
  {
    v10 = 0;
  }

  v11 = *(*(a4 + 1) + 8 * v9);
  v12 = *a4;
  if (a6)
  {
    v13 = *(a6 + 4);
  }

  else
  {
    v13 = 0;
  }

  v36 = v10;
  if (a2)
  {
    v14 = 136;
  }

  else
  {
    v14 = 0;
  }

  if (a2)
  {
    v15 = (a3 + 143) & 0xFFFFFFFFFFFFFFF8;
  }

  else
  {
    v15 = 136;
  }

  v32 = v13;
  v33 = 8 * v9 + 8;
  v16 = v33 + v15;
  v17 = (v33 + v15 + 4 * v11 + 7) & 0xFFFFFFFFFFFFFFF8;
  v34 = v11 * (8 * v8 * v8);
  v18 = 8 * v12 * *(a4 + 28);
  v19 = v18 * v10;
  if (a5)
  {
    v20 = v17 + v34;
  }

  else
  {
    v20 = 0;
  }

  v30 = v20;
  v31 = v14;
  if (!a5)
  {
    v19 = 0;
  }

  v21 = v19 + v17 + v34;
  v22 = v18 * v13;
  if (a6)
  {
    v23 = v19 + v17 + v34;
  }

  else
  {
    v23 = 0;
  }

  v29 = v23;
  if (!a6)
  {
    v22 = 0;
  }

  v24 = v21 + v22;
  if (ftruncate(a1, v21 + v22))
  {
    sub_2366F7F2C(v24);
    return 0xFFFFFFFFLL;
  }

  v25 = mmap(0, v24, 3, 1, a1, 0);
  if (v25 == -1)
  {
    fwrite("Failed to mmap file\n", 0x14uLL, 1uLL, *MEMORY[0x277D85DF8]);
    return 0xFFFFFFFFLL;
  }

  v26 = v25;
  *v25 = 0xF0A30000DAFA2903;
  *(v25 + 1) = v24;
  *(v25 + 2) = 0;
  v25[24] = v35;
  *(v25 + 25) = 0;
  *(v25 + 7) = 0;
  *(v25 + 4) = v12;
  *(v25 + 5) = v9;
  *(v25 + 6) = v11;
  *(v25 + 7) = v8;
  *(v25 + 8) = v31;
  *(v25 + 9) = 0;
  *(v25 + 10) = v15;
  *(v25 + 11) = v16;
  *(v25 + 12) = v17;
  *(v25 + 13) = v36;
  *(v25 + 14) = v32;
  *(v25 + 15) = v30;
  *(v25 + 16) = v29;
  if (a2)
  {
    memcpy(v25 + 136, a2, a3);
  }

  memcpy(&v26[v15], *(a4 + 1), v33);
  memcpy(&v26[v16], *(a4 + 2), 4 * v11);
  memcpy(&v26[v17], *(a4 + 4), v34);
  munmap(v26, v24);
  return 0;
}

double SparseFactor@<D0>(SparseMatrixStructure *a1@<X1>, unsigned int a2@<W0>, uint64_t a3@<X8>)
{
  v3 = *&a1->rowIndices;
  *&v6.rowCount = *&a1->rowCount;
  *&v6.rowIndices = v3;
  v5 = *byte_28499C198;
  return SparseFactor(&v6, &v5, a2, a3);
}

double SparseFactor@<D0>(SparseMatrixStructure *a1@<X1>, SparseSymbolicFactorOptions *a2@<X2>, unsigned int a3@<W0>, uint64_t a4@<X8>)
{
  v14 = *MEMORY[0x277D85DE8];
  columnCount = a1->columnCount;
  if (columnCount <= 0)
  {
    reportError = a2->reportError;
    if (reportError)
    {
      strcpy(v13, ".structure.columnCount must be greater than 0.\n");
      memset(&v13[3], 0, 208);
      (reportError)(v13);
LABEL_25:
      result = 0.0;
      *(a4 + 32) = 0u;
      *(a4 + 48) = 0u;
      *a4 = 0u;
      *(a4 + 16) = 0u;
      *a4 = -4;
      v12 = *MEMORY[0x277D85DE8];
      return result;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBA10();
    }

    goto LABEL_14;
  }

  if (a3 - 80 < 4)
  {
    v6 = *MEMORY[0x277D85DE8];

    _SparseSymbolicFactorLU(a3, &a1->rowCount, a2, a4);
    return result;
  }

  if (a3 - 40 <= 1)
  {
    v9 = *MEMORY[0x277D85DE8];

    _SparseSymbolicFactorQR(a4, a3, a1, a2);
    return result;
  }

  if ((~*&a1->attributes & 0xC) != 0)
  {
    v11 = a2->reportError;
    if (v11)
    {
      memset(&v13[3] + 12, 0, 196);
      strcpy(v13, "Requested symmetric factorization of non-symmetric matrix.\n");
LABEL_24:
      (v11)(v13);
      goto LABEL_25;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBA54();
    }

LABEL_14:
    _SparseTrap();
  }

  if (a1->rowCount != columnCount)
  {
    v11 = a2->reportError;
    if (v11)
    {
      memset(&v13[4] + 11, 0, 181);
      strcpy(v13, "Matrix supposed to be symmetric (Hermitian), but rowCount != columnCount.\n");
      goto LABEL_24;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBA98();
    }

    goto LABEL_14;
  }

  v10 = *MEMORY[0x277D85DE8];

  _SparseSymbolicFactorSymmetric(a4, a3, a1, a2);
  return result;
}

void SparseFactor(unsigned int a1@<W0>, _OWORD *a2@<X1>, uint64_t a3@<X8>)
{
  v3 = a2[1];
  v5[0] = *a2;
  v5[1] = v3;
  v4 = *byte_28499C198;
  SparseFactor(a1, v5, &v4, a3);
}

void SparseFactor(unsigned int a1@<W0>, _OWORD *a2@<X1>, const SparseSymbolicFactorOptions *a3@<X2>, uint64_t a4@<X8>)
{
  v15 = *MEMORY[0x277D85DE8];
  memset(&v13, 0, sizeof(v13));
  v7 = a2[1];
  v14[0] = *a2;
  v14[1] = v7;
  _SparseFromStructureComplex(v14, &v13);
  if (v13.columnCount <= 0)
  {
    reportError = a3->reportError;
    if (reportError)
    {
      strcpy(v14, ".structure.columnCount must be greater than 0.\n");
      memset(&v14[3], 0, 208);
      (reportError)(v14);
LABEL_19:
      *(a4 + 32) = 0u;
      *(a4 + 48) = 0u;
      *a4 = 0u;
      *(a4 + 16) = 0u;
      *a4 = -4;
      goto LABEL_20;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBA10();
    }

    goto LABEL_10;
  }

  if (a1 - 80 >= 4)
  {
    if (a1 - 40 <= 1)
    {
      _SparseSymbolicFactorQR(a4, a1, &v13, a3);
      goto LABEL_20;
    }

    if ((~*&v13.attributes & 0xC) != 0)
    {
      v9 = a3->reportError;
      if (v9)
      {
        memset(&v14[4] + 8, 0, 184);
        v10 = "Requested symmetric factorization of non-symmetric (Hermitian) matrix.\n";
        strcpy(&v14[2], "n of non-symmetric (Hermitian) matrix.\n");
LABEL_18:
        v11 = *(v10 + 1);
        v14[0] = *v10;
        v14[1] = v11;
        (v9)(v14);
        goto LABEL_19;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CBADC();
      }
    }

    else
    {
      if (v13.rowCount == v13.columnCount)
      {
        _SparseSymbolicFactorSymmetric(a4, a1, &v13, a3);
        goto LABEL_20;
      }

      v9 = a3->reportError;
      if (v9)
      {
        memset(&v14[4] + 11, 0, 181);
        v10 = "Matrix supposed to be symmetric (Hermitian), but rowCount != columnCount.\n";
        strcpy(&v14[2], "(Hermitian), but rowCount != columnCount.\n");
        goto LABEL_18;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CBA98();
      }
    }

LABEL_10:
    _SparseTrap();
  }

  _SparseSymbolicFactorLU(a1, &v13.rowCount, a3, a4);
LABEL_20:
  v12 = *MEMORY[0x277D85DE8];
}

__n128 SparseRetain@<Q0>(SparseOpaqueSymbolicFactorization *symbolicFactor@<X0>, uint64_t a2@<X8>)
{
  if (symbolicFactor->status || !symbolicFactor->workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBB20();
    }

    _SparseTrap();
  }

  _SparseRetainSymbolic(symbolicFactor);
  v4 = *&symbolicFactor->factorization;
  *a2 = *&symbolicFactor->status;
  *(a2 + 16) = v4;
  result = *&symbolicFactor->workspaceSize_Double;
  v6 = *&symbolicFactor->factorSize_Double;
  *(a2 + 32) = result;
  *(a2 + 48) = v6;
  return result;
}

double SparseConjugateGradient@<D0>(uint64_t a1@<X8>)
{
  *(a1 + 256) = 0;
  result = 0.0;
  *(a1 + 224) = 0u;
  *(a1 + 240) = 0u;
  *(a1 + 192) = 0u;
  *(a1 + 208) = 0u;
  *(a1 + 160) = 0u;
  *(a1 + 176) = 0u;
  *(a1 + 128) = 0u;
  *(a1 + 144) = 0u;
  *(a1 + 96) = 0u;
  *(a1 + 112) = 0u;
  *(a1 + 64) = 0u;
  *(a1 + 80) = 0u;
  *(a1 + 32) = 0u;
  *(a1 + 48) = 0u;
  *a1 = 0u;
  *(a1 + 16) = 0u;
  return result;
}

__n128 SparseConjugateGradient@<Q0>(SparseCGOptions *a1@<X0>, uint64_t a2@<X8>)
{
  *(a2 + 224) = 0u;
  *(a2 + 240) = 0u;
  *(a2 + 192) = 0u;
  *(a2 + 208) = 0u;
  *(a2 + 160) = 0u;
  *(a2 + 176) = 0u;
  *(a2 + 128) = 0u;
  *(a2 + 144) = 0u;
  *(a2 + 96) = 0u;
  *(a2 + 112) = 0u;
  *(a2 + 64) = 0u;
  *(a2 + 80) = 0u;
  *(a2 + 32) = 0u;
  *(a2 + 48) = 0u;
  *a2 = 0u;
  *(a2 + 16) = 0u;
  result = *&a1->reportError;
  v3 = *&a1->atol;
  *(a2 + 8) = *&a1->reportError;
  *(a2 + 256) = 0;
  *(a2 + 24) = v3;
  *(a2 + 40) = a1->reportStatus;
  return result;
}

double SparseGMRES@<D0>(uint64_t a1@<X8>)
{
  *(a1 + 256) = 0;
  result = 0.0;
  *(a1 + 224) = 0u;
  *(a1 + 240) = 0u;
  *(a1 + 192) = 0u;
  *(a1 + 208) = 0u;
  *(a1 + 160) = 0u;
  *(a1 + 176) = 0u;
  *(a1 + 128) = 0u;
  *(a1 + 144) = 0u;
  *(a1 + 96) = 0u;
  *(a1 + 112) = 0u;
  *(a1 + 64) = 0u;
  *(a1 + 80) = 0u;
  *(a1 + 32) = 0u;
  *(a1 + 48) = 0u;
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *a1 = 1;
  return result;
}

__n128 SparseGMRES@<Q0>(SparseGMRESOptions *a1@<X0>, uint64_t a2@<X8>)
{
  *(a2 + 224) = 0u;
  *(a2 + 240) = 0u;
  *(a2 + 192) = 0u;
  *(a2 + 208) = 0u;
  *(a2 + 160) = 0u;
  *(a2 + 176) = 0u;
  *(a2 + 128) = 0u;
  *(a2 + 144) = 0u;
  *(a2 + 96) = 0u;
  *(a2 + 112) = 0u;
  *(a2 + 64) = 0u;
  *(a2 + 80) = 0u;
  *(a2 + 32) = 0u;
  *(a2 + 48) = 0u;
  *a2 = 0u;
  *(a2 + 16) = 0u;
  v2 = *&a1->maxIterations;
  *(a2 + 8) = *&a1->reportError;
  *(a2 + 256) = 0;
  *a2 = 1;
  *(a2 + 24) = v2;
  result = *&a1->rtol;
  *(a2 + 40) = result;
  return result;
}

double SparseLSMR@<D0>(uint64_t a1@<X8>)
{
  *(a1 + 256) = 0;
  result = 0.0;
  *(a1 + 224) = 0u;
  *(a1 + 240) = 0u;
  *(a1 + 192) = 0u;
  *(a1 + 208) = 0u;
  *(a1 + 160) = 0u;
  *(a1 + 176) = 0u;
  *(a1 + 128) = 0u;
  *(a1 + 144) = 0u;
  *(a1 + 96) = 0u;
  *(a1 + 112) = 0u;
  *(a1 + 64) = 0u;
  *(a1 + 80) = 0u;
  *(a1 + 32) = 0u;
  *(a1 + 48) = 0u;
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *a1 = 2;
  return result;
}

__n128 SparseLSMR@<Q0>(SparseLSMROptions *a1@<X0>, uint64_t a2@<X8>)
{
  *(a2 + 224) = 0u;
  *(a2 + 240) = 0u;
  *(a2 + 192) = 0u;
  *(a2 + 208) = 0u;
  *(a2 + 160) = 0u;
  *(a2 + 176) = 0u;
  *(a2 + 128) = 0u;
  *(a2 + 144) = 0u;
  *(a2 + 96) = 0u;
  *(a2 + 112) = 0u;
  *(a2 + 64) = 0u;
  *(a2 + 80) = 0u;
  *(a2 + 32) = 0u;
  *(a2 + 48) = 0u;
  *a2 = 0u;
  *(a2 + 16) = 0u;
  v2 = *&a1->reportError;
  *(a2 + 24) = *&a1->nvec;
  result = *&a1->rtol;
  v4 = *&a1->conditionLimit;
  *(a2 + 40) = result;
  *(a2 + 56) = v4;
  *(a2 + 256) = 0;
  *a2 = 2;
  *(a2 + 72) = a1->reportStatus;
  *(a2 + 8) = v2;
  return result;
}

void SparseConvertFromCoordinate(SparseAttributes_t a1@<0:W4.2>, const int *a2@<X5>, const int *a3@<X6>, const double *a4@<X7>, unsigned int a5@<W0>, int a6@<W1>, uint64_t a7@<X2>, unsigned int a8@<W3>, uint64_t a9@<X8>)
{
  if ((a5 & 0x80000000) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_23674D34C();
    }

LABEL_21:
    _SparseTrap();
  }

  if (a6 < 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_23674D3C4();
    }

    goto LABEL_21;
  }

  if (a7 < 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBB64();
    }

    goto LABEL_21;
  }

  v17 = a8;
  if (a5 != a6 && (*&a1 & 0xC) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBBDC();
    }

    goto LABEL_21;
  }

  v18 = malloc_type_malloc(4 * a7 + 8 * ((a6 + 1) + a8 * a7 * a8) + 28, 0x100004000313F17uLL);
  if (!v18)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBC98();
    }

    goto LABEL_21;
  }

  storage = v18;
  v20 = malloc_type_malloc(4 * a5, 0x100004052888210uLL);
  if (!v20)
  {
    free(storage);
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBC20();
    }

    goto LABEL_21;
  }

  *(a9 + 32) = 0;
  *a9 = 0u;
  *(a9 + 16) = 0u;
  v21 = a1;
  v22 = v20;
  _SparseConvertFromCoordinate_Double(a9, a5, a6, a7, v17, v21, a2, a3, a4, storage, v20);
  free(v22);
  *(a9 + 24) |= 0x8000u;
}

SparseMatrix_Double *SparseConvertFromCoordinate@<X0>(int m@<W0>, int n@<W1>, uint64_t nBlock@<X2>, SparseAttributes_t attributes@<0:W4.2>, const int *a5@<X5>, const int *a6@<X6>, const double *a7@<X7>, uint8_t a8@<W3>, SparseMatrix_Double *a9@<X8>, char *a10, int *a11)
{
  if (m < 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_23674D34C();
    }

LABEL_14:
    _SparseTrap();
  }

  if (n < 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_23674D3C4();
    }

    goto LABEL_14;
  }

  if (nBlock < 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBB64();
    }

    goto LABEL_14;
  }

  if (m != n && (*&attributes & 0xC) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBBDC();
    }

    goto LABEL_14;
  }

  return _SparseConvertFromCoordinate_Double(a9, m, n, nBlock, a8, attributes, a5, a6, a7, a10, a11);
}

void SparseMultiply(double a1, SparseMatrix_Double *a2, DenseMatrix_Double *a3, DenseMatrix_Double *a4)
{
  v25 = *MEMORY[0x277D85DE8];
  v4 = 4;
  if (*&a2->structure.attributes)
  {
    v5 = 4;
  }

  else
  {
    v5 = 0;
  }

  if (*&a2->structure.attributes)
  {
    v4 = 0;
  }

  rowCount = a4->rowCount;
  if (a4->columnStride < a4->rowCount)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBDE4();
    }

    goto LABEL_35;
  }

  if (a3->columnStride < a3->rowCount)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBD60();
    }

    goto LABEL_35;
  }

  if (*&a4->attributes)
  {
    v7 = 4;
  }

  else
  {
    v7 = 0;
    rowCount = a4->columnCount;
  }

  if (*&a3->attributes)
  {
    v8 = 0;
  }

  else
  {
    v8 = 4;
  }

  v9 = *(&a3->rowCount + v8);
  v10 = *(&a4->rowCount + v7);
  if (*&a3->attributes)
  {
    v11 = 4;
  }

  else
  {
    v11 = 0;
  }

  v12 = *(&a3->rowCount + v11);
  if (rowCount != v9)
  {
    if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      goto LABEL_35;
    }

    A.structure.rowCount = 136316418;
    *&A.structure.columnCount = "Y";
    WORD2(A.structure.columnStarts) = 1024;
    *(&A.structure.columnStarts + 6) = v10;
    WORD1(A.structure.rowIndices) = 1024;
    HIDWORD(A.structure.rowIndices) = rowCount;
    A.structure.attributes = 2080;
    *&A.structure.blockSize = "X";
    WORD1(A.data) = 1024;
    HIDWORD(A.data) = v12;
    v23 = 1024;
    v24 = v9;
    v17 = MEMORY[0x277D86220];
    v18 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
LABEL_34:
    _os_log_error_impl(&dword_2366B9000, v17, OS_LOG_TYPE_ERROR, v18, &A, 0x2Eu);
    goto LABEL_35;
  }

  if (rowCount <= 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBCDC();
    }

LABEL_35:
    _SparseTrap();
  }

  v13 = *(&a2->structure.blockSize + 2);
  v14 = *(&a2->structure.rowCount + v5) * v13;
  v15 = *(&a2->structure.rowCount + v4) * v13;
  if (v10 != v14)
  {
    if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      goto LABEL_35;
    }

    A.structure.rowCount = 136316418;
    *&A.structure.columnCount = "Y";
    WORD2(A.structure.columnStarts) = 1024;
    *(&A.structure.columnStarts + 6) = v10;
    WORD1(A.structure.rowIndices) = 1024;
    HIDWORD(A.structure.rowIndices) = rowCount;
    A.structure.attributes = 2080;
    *&A.structure.blockSize = "matrix A";
    WORD1(A.data) = 1024;
    HIDWORD(A.data) = v15;
    v23 = 1024;
    v24 = v14;
    v17 = MEMORY[0x277D86220];
    v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
    goto LABEL_34;
  }

  if (v12 != v15)
  {
    if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      goto LABEL_35;
    }

    A.structure.rowCount = 136316418;
    *&A.structure.columnCount = "X";
    WORD2(A.structure.columnStarts) = 1024;
    *(&A.structure.columnStarts + 6) = v12;
    WORD1(A.structure.rowIndices) = 1024;
    HIDWORD(A.structure.rowIndices) = rowCount;
    A.structure.attributes = 2080;
    *&A.structure.blockSize = "matrix A";
    WORD1(A.data) = 1024;
    HIDWORD(A.data) = v15;
    v23 = 1024;
    v24 = v14;
    v17 = MEMORY[0x277D86220];
    v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
    goto LABEL_34;
  }

  v16 = *&a2->structure.rowIndices;
  *&A.structure.rowCount = *&a2->structure.rowCount;
  *&A.structure.rowIndices = v16;
  A.data = a2->data;
  x = *a3;
  v20 = *a4;
  _SparseSpMV_Double(a1, &A, &x, 0, &v20);
  v19 = *MEMORY[0x277D85DE8];
}

void SparseMultiply(double a1, SparseMatrix_Double *a2, DenseVector_Double a3, DenseVector_Double a4)
{
  v4 = *(&a2->structure.blockSize + 2);
  v5 = 4;
  if (*&a2->structure.attributes)
  {
    v6 = 4;
  }

  else
  {
    v6 = 0;
  }

  if (*&a2->structure.attributes)
  {
    v5 = 0;
  }

  if (*(&a2->structure.rowCount + v5) * v4 != a3.count)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBE68();
    }

LABEL_13:
    _SparseTrap();
  }

  if (*(&a2->structure.rowCount + v6) * v4 != a4.count)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBED8();
    }

    goto LABEL_13;
  }

  x.rowCount = a3.count;
  x.columnCount = 1;
  *&x.columnStride = a3.count;
  x.data = a3.data;
  y.rowCount = a4.count;
  y.columnCount = 1;
  y.columnStride = a4.count;
  *&y.attributes = 0;
  y.data = a4.data;
  v7 = *&a2->structure.rowIndices;
  *&v8.structure.rowCount = *&a2->structure.rowCount;
  *&v8.structure.rowIndices = v7;
  v8.data = a2->data;
  _SparseSpMV_Double(a1, &v8, &x, 0, &y);
}

void SparseMultiply(SparseMatrix_Double *a1, DenseMatrix_Double *a2, DenseMatrix_Double *a3)
{
  v3 = *&a1->structure.rowIndices;
  *&v6.structure.rowCount = *&a1->structure.rowCount;
  *&v6.structure.rowIndices = v3;
  v6.data = a1->data;
  v5 = *a2;
  v4 = *a3;
  SparseMultiply(1.0, &v6, &v5, &v4);
}

void SparseMultiply(SparseMatrix_Double *a1, DenseVector_Double a2, DenseVector_Double a3)
{
  v3 = *&a1->structure.rowIndices;
  *&v4.structure.rowCount = *&a1->structure.rowCount;
  *&v4.structure.rowIndices = v3;
  v4.data = a1->data;
  SparseMultiply(1.0, &v4, a2, a3);
}

void SparseMultiplyAdd(double a1, SparseMatrix_Double *a2, DenseMatrix_Double *a3, DenseMatrix_Double *a4)
{
  v25 = *MEMORY[0x277D85DE8];
  v4 = 4;
  if (*&a2->structure.attributes)
  {
    v5 = 4;
  }

  else
  {
    v5 = 0;
  }

  if (*&a2->structure.attributes)
  {
    v4 = 0;
  }

  rowCount = a4->rowCount;
  if (a4->columnStride < a4->rowCount)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBDE4();
    }

    goto LABEL_35;
  }

  if (a3->columnStride < a3->rowCount)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBD60();
    }

    goto LABEL_35;
  }

  if (*&a4->attributes)
  {
    v7 = 4;
  }

  else
  {
    v7 = 0;
    rowCount = a4->columnCount;
  }

  if (*&a3->attributes)
  {
    v8 = 0;
  }

  else
  {
    v8 = 4;
  }

  v9 = *(&a3->rowCount + v8);
  v10 = *(&a4->rowCount + v7);
  if (*&a3->attributes)
  {
    v11 = 4;
  }

  else
  {
    v11 = 0;
  }

  v12 = *(&a3->rowCount + v11);
  if (rowCount != v9)
  {
    if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      goto LABEL_35;
    }

    A.structure.rowCount = 136316418;
    *&A.structure.columnCount = "Y";
    WORD2(A.structure.columnStarts) = 1024;
    *(&A.structure.columnStarts + 6) = v10;
    WORD1(A.structure.rowIndices) = 1024;
    HIDWORD(A.structure.rowIndices) = rowCount;
    A.structure.attributes = 2080;
    *&A.structure.blockSize = "X";
    WORD1(A.data) = 1024;
    HIDWORD(A.data) = v12;
    v23 = 1024;
    v24 = v9;
    v17 = MEMORY[0x277D86220];
    v18 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
LABEL_34:
    _os_log_error_impl(&dword_2366B9000, v17, OS_LOG_TYPE_ERROR, v18, &A, 0x2Eu);
    goto LABEL_35;
  }

  if (rowCount <= 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBCDC();
    }

LABEL_35:
    _SparseTrap();
  }

  v13 = *(&a2->structure.blockSize + 2);
  v14 = *(&a2->structure.rowCount + v5) * v13;
  v15 = *(&a2->structure.rowCount + v4) * v13;
  if (v10 != v14)
  {
    if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      goto LABEL_35;
    }

    A.structure.rowCount = 136316418;
    *&A.structure.columnCount = "Y";
    WORD2(A.structure.columnStarts) = 1024;
    *(&A.structure.columnStarts + 6) = v10;
    WORD1(A.structure.rowIndices) = 1024;
    HIDWORD(A.structure.rowIndices) = rowCount;
    A.structure.attributes = 2080;
    *&A.structure.blockSize = "matrix A";
    WORD1(A.data) = 1024;
    HIDWORD(A.data) = v15;
    v23 = 1024;
    v24 = v14;
    v17 = MEMORY[0x277D86220];
    v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
    goto LABEL_34;
  }

  if (v12 != v15)
  {
    if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      goto LABEL_35;
    }

    A.structure.rowCount = 136316418;
    *&A.structure.columnCount = "X";
    WORD2(A.structure.columnStarts) = 1024;
    *(&A.structure.columnStarts + 6) = v12;
    WORD1(A.structure.rowIndices) = 1024;
    HIDWORD(A.structure.rowIndices) = rowCount;
    A.structure.attributes = 2080;
    *&A.structure.blockSize = "matrix A";
    WORD1(A.data) = 1024;
    HIDWORD(A.data) = v15;
    v23 = 1024;
    v24 = v14;
    v17 = MEMORY[0x277D86220];
    v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
    goto LABEL_34;
  }

  v16 = *&a2->structure.rowIndices;
  *&A.structure.rowCount = *&a2->structure.rowCount;
  *&A.structure.rowIndices = v16;
  A.data = a2->data;
  x = *a3;
  v20 = *a4;
  _SparseSpMV_Double(a1, &A, &x, 1, &v20);
  v19 = *MEMORY[0x277D85DE8];
}

void SparseMultiplyAdd(SparseMatrix_Double *a1, DenseMatrix_Double *a2, DenseMatrix_Double *a3)
{
  v3 = *&a1->structure.rowIndices;
  *&v6.structure.rowCount = *&a1->structure.rowCount;
  *&v6.structure.rowIndices = v3;
  v6.data = a1->data;
  v5 = *a2;
  v4 = *a3;
  SparseMultiplyAdd(1.0, &v6, &v5, &v4);
}

void SparseMultiplyAdd(double a1, SparseMatrix_Double *a2, DenseVector_Double a3, DenseVector_Double a4)
{
  v4 = *(&a2->structure.blockSize + 2);
  v5 = 4;
  if (*&a2->structure.attributes)
  {
    v6 = 4;
  }

  else
  {
    v6 = 0;
  }

  if (*&a2->structure.attributes)
  {
    v5 = 0;
  }

  if (*(&a2->structure.rowCount + v5) * v4 != a3.count)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBE68();
    }

LABEL_13:
    _SparseTrap();
  }

  if (*(&a2->structure.rowCount + v6) * v4 != a4.count)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBED8();
    }

    goto LABEL_13;
  }

  x.rowCount = a3.count;
  x.columnCount = 1;
  *&x.columnStride = a3.count;
  x.data = a3.data;
  y.rowCount = a4.count;
  y.columnCount = 1;
  y.columnStride = a4.count;
  *&y.attributes = 0;
  y.data = a4.data;
  v7 = *&a2->structure.rowIndices;
  *&v8.structure.rowCount = *&a2->structure.rowCount;
  *&v8.structure.rowIndices = v7;
  v8.data = a2->data;
  _SparseSpMV_Double(a1, &v8, &x, 1, &y);
}

void SparseMultiplyAdd(SparseMatrix_Double *a1, DenseVector_Double a2, DenseVector_Double a3)
{
  v3 = *&a1->structure.rowIndices;
  *&v4.structure.rowCount = *&a1->structure.rowCount;
  *&v4.structure.rowIndices = v3;
  v4.data = a1->data;
  SparseMultiplyAdd(1.0, &v4, a2, a3);
}

__n128 SparseGetTranspose@<Q0>(SparseMatrix_Double *a1@<X0>, uint64_t a2@<X8>)
{
  a1->structure.attributes = (*&a1->structure.attributes & 0xFFFE | ((*&a1->structure.attributes & 1) == 0));
  *(a2 + 32) = a1->data;
  result = *&a1->structure.rowCount;
  v3 = *&a1->structure.rowIndices;
  *a2 = *&a1->structure.rowCount;
  *(a2 + 16) = v3;
  return result;
}

__n128 SparseGetTranspose@<Q0>(SparseOpaqueFactorization_Double *a1@<X0>, uint64_t a2@<X8>)
{
  a1->attributes = (*&a1->attributes & 0xFFFE | ((*&a1->attributes & 1) == 0));
  _SparseRetainNumeric_Double(a1);
  v4 = *&a1->solveWorkspaceRequiredStatic;
  *(a2 + 64) = *&a1->userFactorStorage;
  *(a2 + 80) = v4;
  *(a2 + 96) = *&a1[1].status;
  v5 = *&a1->symbolicFactorization.columnCount;
  *a2 = *&a1->status;
  *(a2 + 16) = v5;
  result = *&a1->symbolicFactorization.factorSize_Float;
  *(a2 + 32) = *&a1->symbolicFactorization.workspaceSize_Float;
  *(a2 + 48) = result;
  return result;
}

__n128 SparseGetTranspose@<Q0>(SparseOpaqueSubfactor_Double *a1@<X0>, uint64_t a2@<X8>)
{
  a1->attributes = (*&a1->attributes & 0xFFFE | ((*&a1->attributes & 1) == 0));
  _SparseRetainNumeric_Double(&a1->factor);
  v4 = *&a1->factor.numericFactorization;
  *(a2 + 64) = *&a1->factor.symbolicFactorization.factorSize_Double;
  *(a2 + 80) = v4;
  v5 = *&a1->workspaceRequiredPerRHS;
  *(a2 + 96) = *&a1->factor.solveWorkspaceRequiredPerRHS;
  *(a2 + 112) = v5;
  v6 = *&a1->factor.symbolicFactorization.status;
  *a2 = *&a1->attributes;
  *(a2 + 16) = v6;
  result = *&a1->factor.symbolicFactorization.factorization;
  v8 = *&a1->factor.symbolicFactorization.workspaceSize_Double;
  *(a2 + 32) = result;
  *(a2 + 48) = v8;
  return result;
}

SparseOpaqueFactorization_Double *SparseFactor@<X0>(SparseMatrix_Double *a1@<X1>, SparseSymbolicFactorOptions *sfoptions@<X2>, SparseNumericFactorOptions *a3@<X3>, int a4@<W0>, uint64_t a5@<X8>)
{
  v17 = *MEMORY[0x277D85DE8];
  if (a1->structure.rowCount <= 0)
  {
    if (!sfoptions->reportError)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CBF48();
      }

      goto LABEL_34;
    }

    memset(__str, 0, 256);
    snprintf(__str, 0x100uLL, "%s.rowCount must be > 0, but is %d.\n", a3);
LABEL_22:
    reportError = sfoptions->reportError;
LABEL_23:
    result = (reportError)(__str);
    *(a5 + 96) = 0;
    *(a5 + 64) = 0u;
    *(a5 + 80) = 0u;
    *(a5 + 32) = 0u;
    *(a5 + 48) = 0u;
    *a5 = 0u;
    *(a5 + 16) = 0u;
    *a5 = -4;
    *(a5 + 8) = -4;
    v14 = *MEMORY[0x277D85DE8];
    return result;
  }

  columnCount = a1->structure.columnCount;
  if (columnCount <= 0)
  {
    if (!sfoptions->reportError)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CBFCC();
      }

      goto LABEL_34;
    }

    memset(__str, 0, 256);
    snprintf(__str, 0x100uLL, "%s.columnCount must be > 0, but is %d.\n", a3);
    goto LABEL_22;
  }

  if (!*(&a1->structure.blockSize + 2))
  {
    if (!sfoptions->reportError)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC114();
      }

      goto LABEL_34;
    }

    memset(__str, 0, 256);
    snprintf(__str, 0x100uLL, "%s.blockSize must be > 0, but is %d.]n", a3);
    goto LABEL_22;
  }

  v8 = *&a1->structure.attributes & 0xC;
  if (a1->structure.rowCount != columnCount && v8 == 12)
  {
    if (!sfoptions->reportError)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC050();
      }

      goto LABEL_34;
    }

    memset(__str, 0, 256);
    snprintf(__str, 0x100uLL, "%s.attributes.kind=SparseSymmetric, but %s.rowCount (%d) != %s.columnCount (%d).\n", a3);
    goto LABEL_22;
  }

  if ((a4 - 80) < 4)
  {
    v10 = *MEMORY[0x277D85DE8];

    return _SparseFactorLU_Double(a4, &a1->structure.rowCount, sfoptions, a3, a5);
  }

  if ((a4 - 40) <= 1)
  {
    v13 = *MEMORY[0x277D85DE8];

    return _SparseFactorQR_Double(a5, a4, a1, sfoptions, a3);
  }

  if (v8 != 12)
  {
    reportError = sfoptions->reportError;
    if (reportError)
    {
      memset(&__str[72], 0, 184);
      strcpy(__str, "Cannot perform symmetric matrix factorization of non-symmetric matrix.\n");
      goto LABEL_23;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC0D0();
    }

LABEL_34:
    _SparseTrap();
  }

  v15 = *MEMORY[0x277D85DE8];

  return _SparseFactorSymmetric_Double(a5, a4, a1, sfoptions, a3);
}

SparseOpaqueFactorization_Double *SparseFactor@<X0>(SparseMatrix_Double *a1@<X1>, int a2@<W0>, uint64_t a3@<X8>)
{
  v3 = *&a1->structure.rowIndices;
  *&v7.structure.rowCount = *&a1->structure.rowCount;
  *&v7.structure.rowIndices = v3;
  v7.data = a1->data;
  sfoptions = *byte_28499C198;
  v5 = *ymmword_23681FF58;
  return SparseFactor(&v7, &sfoptions, &v5, a2, a3);
}

uint64_t SparseFactor@<X0>(SparseOpaqueSymbolicFactorization *factor@<X0>, SparseMatrix_Double *a2@<X1>, SparseNumericFactorOptions *a3@<X2>, unint64_t a4@<X3>, void *a5@<X4>, uint64_t a6@<X8>)
{
  v39 = *MEMORY[0x277D85DE8];
  if (factor->status || !factor->workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC31C();
    }

    goto LABEL_4;
  }

  _SparseGetOptionsFromSymbolicFactor(&v25, factor);
  reportError = v25.reportError;
  if (*&a2->structure.rowCount != *&factor->rowCount || *(&a2->structure.blockSize + 2) != LOBYTE(factor->factorization) || ((*&factor->attributes ^ *&a2->structure.attributes) & 1) != 0)
  {
    if (v25.reportError)
    {
      v37 = 0u;
      v38 = 0u;
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v26 = 0u;
      memset(&v25, 0, sizeof(v25));
      snprintf(&v25, 0x100uLL, "%s does not match that used for symbolic factorization stored in %s.\n", "Matrix", "symbolicFactor");
      result = (reportError)(&v25);
      *(a6 + 96) = 0;
      *(a6 + 64) = 0u;
      *(a6 + 80) = 0u;
      *(a6 + 32) = 0u;
      *(a6 + 48) = 0u;
      *a6 = 0u;
      *(a6 + 16) = 0u;
      v7 = -4;
LABEL_5:
      *a6 = v7;
      *(a6 + 8) = v7;
      goto LABEL_6;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC19C();
    }

LABEL_4:
    _SparseTrap();
  }

  malloc = v25.malloc;
  free = v25.free;
  v16 = a4;
  if (!a4)
  {
    v16 = (v25.malloc)(*&factor[1].status);
    if (!v16)
    {
      if (reportError)
      {
        v37 = 0u;
        v38 = 0u;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v31 = 0u;
        v32 = 0u;
        v29 = 0u;
        v30 = 0u;
        v27 = 0u;
        v28 = 0u;
        v26 = 0u;
        memset(&v25, 0, sizeof(v25));
        v22 = *&factor[1].status;
        snprintf(&v25, 0x100uLL, "Failed to allocate factor storage of size %ld bytes.");
        goto LABEL_30;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC22C(&factor[1]);
      }

LABEL_41:
      _SparseTrap();
    }
  }

  v17 = a5;
  if (!a5)
  {
    p_factorSize_Float = &factor->factorSize_Float;
    v20 = (malloc)(factor->factorSize_Float);
    if (a4 | v20)
    {
      v17 = v20;
      if (v20)
      {
        goto LABEL_14;
      }
    }

    else
    {
      (free)(v16);
    }

    if (reportError)
    {
      v37 = 0u;
      v38 = 0u;
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v26 = 0u;
      memset(&v25, 0, sizeof(v25));
      v21 = *p_factorSize_Float;
      snprintf(&v25, 0x100uLL, "Failed to allocate workspace of size %ld bytes.");
LABEL_30:
      result = (reportError)(&v25);
      *(a6 + 96) = 0;
      *(a6 + 64) = 0u;
      *(a6 + 80) = 0u;
      *(a6 + 32) = 0u;
      *(a6 + 48) = 0u;
      *a6 = 0u;
      *(a6 + 16) = 0u;
      v7 = -3;
      goto LABEL_5;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC2A4(p_factorSize_Float);
    }

    goto LABEL_41;
  }

LABEL_14:
  *(a6 + 96) = 0;
  *(a6 + 64) = 0u;
  *(a6 + 80) = 0u;
  *(a6 + 32) = 0u;
  *(a6 + 48) = 0u;
  *a6 = 0u;
  *(a6 + 16) = 0u;
  v18 = BYTE1(factor->factorization);
  if ((v18 - 80) >= 4)
  {
    if ((v18 - 40) > 1)
    {
      result = _SparseNumericFactorSymmetric_Double(a6, factor, a2, a3, v16, v17);
    }

    else
    {
      result = _SparseNumericFactorQR_Double(a6, factor, a2, a3, v16, v17);
    }
  }

  else
  {
    result = _SparseNumericFactorLU_Double(factor, a2, a3, v16, v17, a6);
  }

  *(a6 + 72) = a4 != 0;
  if (!a5)
  {
    result = (free)(v17);
  }

  if (!a4 && (*a6 & 0x80000000) != 0)
  {
    result = (free)(v16);
  }

LABEL_6:
  v8 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t SparseFactor@<X0>(SparseOpaqueSymbolicFactorization *a1@<X0>, SparseMatrix_Double *a2@<X1>, uint64_t a3@<X8>)
{
  v3 = *&a1->factorization;
  factor[0] = *&a1->status;
  factor[1] = v3;
  v4 = *&a1->factorSize_Double;
  factor[2] = *&a1->workspaceSize_Double;
  factor[3] = v4;
  v5 = *&a2->structure.rowIndices;
  *&v8.structure.rowCount = *&a2->structure.rowCount;
  *&v8.structure.rowIndices = v5;
  v8.data = a2->data;
  v7 = *ymmword_23681FF58;
  return SparseFactor(factor, &v8, &v7, 0, 0, a3);
}

uint64_t SparseFactor@<X0>(SparseOpaqueSymbolicFactorization *a1@<X0>, SparseMatrix_Double *a2@<X1>, SparseNumericFactorOptions *a3@<X2>, uint64_t a4@<X8>)
{
  v4 = *&a1->factorization;
  factor[0] = *&a1->status;
  factor[1] = v4;
  v5 = *&a1->factorSize_Double;
  factor[2] = *&a1->workspaceSize_Double;
  factor[3] = v5;
  v6 = *&a2->structure.rowIndices;
  *&v10.structure.rowCount = *&a2->structure.rowCount;
  *&v10.structure.rowIndices = v6;
  v10.data = a2->data;
  v7 = *&a3->pivotTolerance;
  *&v9.control = *&a3->control;
  *&v9.pivotTolerance = v7;
  return SparseFactor(factor, &v10, &v9, 0, 0, a4);
}

uint64_t SparseSolve(SparseOpaqueFactorization_Double *factor, DenseMatrix_Double *a2)
{
  v32 = *MEMORY[0x277D85DE8];
  p_symbolicFactorization = &factor->symbolicFactorization;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F73F0();
    }

    goto LABEL_4;
  }

  _SparseGetOptionsFromSymbolicFactor(&v18, &factor->symbolicFactorization);
  reportError = v18.reportError;
  if (p_symbolicFactorization->status == SparseStatusOK && factor->symbolicFactorization.workspaceSize_Float && factor->status == SparseStatusOK && factor->solveWorkspaceRequiredStatic)
  {
    rowCount = a2->rowCount;
    if (a2->columnStride >= a2->rowCount)
    {
      if (*&a2->attributes)
      {
        v9 = 0;
        rowCount = a2->columnCount;
      }

      else
      {
        v9 = 4;
      }

      v10 = *(&a2->rowCount + v9);
      if (v10 <= 0)
      {
        if (v18.reportError)
        {
          v30 = 0u;
          v31 = 0u;
          v28 = 0u;
          v29 = 0u;
          v26 = 0u;
          v27 = 0u;
          v24 = 0u;
          v25 = 0u;
          v22 = 0u;
          v23 = 0u;
          v20 = 0u;
          v21 = 0u;
          v19 = 0u;
          memset(&v18, 0, sizeof(v18));
          snprintf(&v18, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_10;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2366FFDD4();
        }
      }

      else
      {
        factorization_low = LOBYTE(factor->symbolicFactorization.factorization);
        v12 = factor->symbolicFactorization.rowCount * factorization_low;
        v13 = factor->symbolicFactorization.columnCount * factorization_low;
        if (v12 <= v13)
        {
          v14 = v13;
        }

        else
        {
          v14 = v12;
        }

        if (rowCount == v14)
        {
          free = v18.free;
          v16 = (v18.malloc)(factor->solveWorkspaceRequiredPerRHS + *&factor[1].status * v10);
          if (v16)
          {
            v17 = v16;
            _SparseSolveOpaque_Double(factor, 0, a2, v16);
            result = (free)(v17);
            goto LABEL_5;
          }

          if (reportError)
          {
            v30 = 0u;
            v31 = 0u;
            v28 = 0u;
            v29 = 0u;
            v26 = 0u;
            v27 = 0u;
            v24 = 0u;
            v25 = 0u;
            v22 = 0u;
            v23 = 0u;
            v20 = 0u;
            v21 = 0u;
            v19 = 0u;
            memset(&v18, 0, sizeof(v18));
            snprintf(&v18, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
            goto LABEL_10;
          }

          if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
          {
            sub_2367CC3F4();
          }
        }

        else
        {
          if (v18.reportError)
          {
            v30 = 0u;
            v31 = 0u;
            v28 = 0u;
            v29 = 0u;
            v26 = 0u;
            v27 = 0u;
            v24 = 0u;
            v25 = 0u;
            v22 = 0u;
            v23 = 0u;
            v20 = 0u;
            v21 = 0u;
            v19 = 0u;
            memset(&v18, 0, sizeof(v18));
            snprintf(&v18, 0x100uLL, "%s (%dx%d) is not consistent with largest dimension of matrix factorization %s (%d).\n");
            goto LABEL_10;
          }

          if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
          {
            sub_2367CC360();
          }
        }
      }
    }

    else
    {
      if (v18.reportError)
      {
        v30 = 0u;
        v31 = 0u;
        v28 = 0u;
        v29 = 0u;
        v26 = 0u;
        v27 = 0u;
        v24 = 0u;
        v25 = 0u;
        v22 = 0u;
        v23 = 0u;
        v20 = 0u;
        v21 = 0u;
        v19 = 0u;
        memset(&v18, 0, sizeof(v18));
        snprintf(&v18, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
        goto LABEL_10;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC46C();
      }
    }

LABEL_4:
    _SparseTrap();
  }

  if (!v18.reportError)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F736C();
    }

    goto LABEL_4;
  }

  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v19 = 0u;
  memset(&v18, 0, sizeof(v18));
  snprintf(&v18, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_10:
  result = (reportError)(&v18);
LABEL_5:
  v3 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t SparseSolve(SparseOpaqueFactorization_Double *factor, DenseMatrix_Double *a2, DenseMatrix_Double *a3)
{
  v52 = *MEMORY[0x277D85DE8];
  p_symbolicFactorization = &factor->symbolicFactorization;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F73F0();
    }

    goto LABEL_4;
  }

  _SparseGetOptionsFromSymbolicFactor(&v38, &factor->symbolicFactorization);
  reportError = v38.reportError;
  if (p_symbolicFactorization->status == SparseStatusOK && factor->symbolicFactorization.workspaceSize_Float && factor->status == SparseStatusOK && factor->solveWorkspaceRequiredStatic)
  {
    v10 = *&factor->attributes ^ *&factor->symbolicFactorization.attributes;
    factorization_low = LOBYTE(factor->symbolicFactorization.factorization);
    v12 = factor->symbolicFactorization.rowCount * factorization_low;
    v13 = factor->symbolicFactorization.columnCount * factorization_low;
    if (v10)
    {
      v14 = v13;
    }

    else
    {
      v14 = v12;
    }

    if (v10)
    {
      v15 = v12;
    }

    else
    {
      v15 = v13;
    }

    if (BYTE1(factor->symbolicFactorization.factorization) == 40)
    {
      v16 = v14;
    }

    else
    {
      v16 = v15;
    }

    rowCount = a2->rowCount;
    if (a2->columnStride < a2->rowCount)
    {
      if (v38.reportError)
      {
        goto LABEL_30;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC574();
      }

      goto LABEL_4;
    }

    if (a3->columnStride < a3->rowCount)
    {
      if (v38.reportError)
      {
LABEL_30:
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        v46 = 0u;
        v47 = 0u;
        v44 = 0u;
        v45 = 0u;
        v42 = 0u;
        v43 = 0u;
        v40 = 0u;
        v41 = 0u;
        v39 = 0u;
        memset(&v38, 0, sizeof(v38));
        snprintf(&v38, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
        goto LABEL_10;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CBD60();
      }

LABEL_4:
      _SparseTrap();
    }

    attributes = a2->attributes;
    if ((*&attributes & 1) == 0)
    {
      rowCount = a2->columnCount;
    }

    v19 = a3->attributes;
    if (*&attributes)
    {
      v20 = 4;
    }

    else
    {
      v20 = 0;
    }

    v21 = (*&v19 & 1) == 0;
    if (*&v19)
    {
      v22 = 0;
    }

    else
    {
      v22 = 4;
    }

    v23 = *(&a3->rowCount + v22);
    v24 = *(&a2->rowCount + v20);
    if (v21)
    {
      v25 = 0;
    }

    else
    {
      v25 = 4;
    }

    v26 = *(&a3->rowCount + v25);
    if (rowCount == v23)
    {
      if (rowCount <= 0)
      {
        if (v38.reportError)
        {
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v46 = 0u;
          v47 = 0u;
          v44 = 0u;
          v45 = 0u;
          v42 = 0u;
          v43 = 0u;
          v40 = 0u;
          v41 = 0u;
          v39 = 0u;
          memset(&v38, 0, sizeof(v38));
          snprintf(&v38, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_10;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CC4F0();
        }

        goto LABEL_4;
      }

      if (v24 == v16)
      {
        if (v26 == v15)
        {
          free = v38.free;
          v28 = 4;
          if (*&attributes)
          {
            v28 = 0;
          }

          v29 = (v38.malloc)(factor->solveWorkspaceRequiredPerRHS + *&factor[1].status * *(&a2->rowCount + v28));
          if (v29)
          {
            v30 = v29;
            _SparseSolveOpaque_Double(factor, a2, a3, v29);
            result = (free)(v30);
            goto LABEL_5;
          }

          if (reportError)
          {
            v50 = 0u;
            v51 = 0u;
            v48 = 0u;
            v49 = 0u;
            v46 = 0u;
            v47 = 0u;
            v44 = 0u;
            v45 = 0u;
            v42 = 0u;
            v43 = 0u;
            v40 = 0u;
            v41 = 0u;
            v39 = 0u;
            memset(&v38, 0, sizeof(v38));
            snprintf(&v38, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
            goto LABEL_10;
          }

          if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
          {
            sub_2367CC3F4();
          }

          goto LABEL_4;
        }

        if (v38.reportError)
        {
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v46 = 0u;
          v47 = 0u;
          v44 = 0u;
          v45 = 0u;
          v42 = 0u;
          v43 = 0u;
          v40 = 0u;
          v41 = 0u;
          v39 = 0u;
          memset(&v38, 0, sizeof(v38));
          v33 = "X";
          goto LABEL_64;
        }

        v36 = v16;
        v37 = v15;
        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_4;
        }

        v38.control = 136316418;
        *&v38.orderMethod = "X";
        WORD2(v38.order) = 1024;
        *(&v38.order + 6) = v26;
        WORD1(v38.ignoreRowsAndColumns) = 1024;
        HIDWORD(v38.ignoreRowsAndColumns) = rowCount;
        LOWORD(v38.malloc) = 2080;
        *(&v38.malloc + 2) = "matrix factorization Factored";
        WORD1(v38.free) = 1024;
        HIDWORD(v38.free) = v37;
        LOWORD(v38.reportError) = 1024;
        *(&v38.reportError + 2) = v36;
        v31 = MEMORY[0x277D86220];
        v32 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }

      else
      {
        if (v38.reportError)
        {
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v46 = 0u;
          v47 = 0u;
          v44 = 0u;
          v45 = 0u;
          v42 = 0u;
          v43 = 0u;
          v40 = 0u;
          v41 = 0u;
          v39 = 0u;
          memset(&v38, 0, sizeof(v38));
          v33 = "B";
LABEL_64:
          snprintf(&v38, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v33);
          goto LABEL_10;
        }

        v34 = v16;
        v35 = v15;
        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_4;
        }

        v38.control = 136316418;
        *&v38.orderMethod = "B";
        WORD2(v38.order) = 1024;
        *(&v38.order + 6) = v24;
        WORD1(v38.ignoreRowsAndColumns) = 1024;
        HIDWORD(v38.ignoreRowsAndColumns) = rowCount;
        LOWORD(v38.malloc) = 2080;
        *(&v38.malloc + 2) = "matrix factorization Factored";
        WORD1(v38.free) = 1024;
        HIDWORD(v38.free) = v35;
        LOWORD(v38.reportError) = 1024;
        *(&v38.reportError + 2) = v34;
        v31 = MEMORY[0x277D86220];
        v32 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
    }

    else
    {
      if (v38.reportError)
      {
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        v46 = 0u;
        v47 = 0u;
        v44 = 0u;
        v45 = 0u;
        v42 = 0u;
        v43 = 0u;
        v40 = 0u;
        v41 = 0u;
        v39 = 0u;
        memset(&v38, 0, sizeof(v38));
        snprintf(&v38, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
        goto LABEL_10;
      }

      if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        goto LABEL_4;
      }

      v38.control = 136316418;
      *&v38.orderMethod = "B";
      WORD2(v38.order) = 1024;
      *(&v38.order + 6) = v24;
      WORD1(v38.ignoreRowsAndColumns) = 1024;
      HIDWORD(v38.ignoreRowsAndColumns) = rowCount;
      LOWORD(v38.malloc) = 2080;
      *(&v38.malloc + 2) = "X";
      WORD1(v38.free) = 1024;
      HIDWORD(v38.free) = v26;
      LOWORD(v38.reportError) = 1024;
      *(&v38.reportError + 2) = v23;
      v31 = MEMORY[0x277D86220];
      v32 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    }

    _os_log_error_impl(&dword_2366B9000, v31, OS_LOG_TYPE_ERROR, v32, &v38, 0x2Eu);
    goto LABEL_4;
  }

  if (!v38.reportError)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F736C();
    }

    goto LABEL_4;
  }

  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v39 = 0u;
  memset(&v38, 0, sizeof(v38));
  snprintf(&v38, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_10:
  result = (reportError)(&v38);
LABEL_5:
  v4 = *MEMORY[0x277D85DE8];
  return result;
}

void SparseSolve(SparseOpaqueFactorization_Double *factor, DenseMatrix_Double *a2, void *a3)
{
  v29 = *MEMORY[0x277D85DE8];
  p_symbolicFactorization = &factor->symbolicFactorization;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F73F0();
    }

    goto LABEL_4;
  }

  _SparseGetOptionsFromSymbolicFactor(&v15, &factor->symbolicFactorization);
  reportError = v15.reportError;
  if (p_symbolicFactorization->status == SparseStatusOK && factor->symbolicFactorization.workspaceSize_Float && factor->status == SparseStatusOK && factor->solveWorkspaceRequiredStatic)
  {
    rowCount = a2->rowCount;
    if (a2->columnStride >= a2->rowCount)
    {
      if (*&a2->attributes)
      {
        v10 = 0;
        rowCount = a2->columnCount;
      }

      else
      {
        v10 = 4;
      }

      if (*(&a2->rowCount + v10) <= 0)
      {
        if (v15.reportError)
        {
          v27 = 0u;
          v28 = 0u;
          v25 = 0u;
          v26 = 0u;
          v23 = 0u;
          v24 = 0u;
          v21 = 0u;
          v22 = 0u;
          v19 = 0u;
          v20 = 0u;
          v17 = 0u;
          v18 = 0u;
          v16 = 0u;
          memset(&v15, 0, sizeof(v15));
          snprintf(&v15, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_10;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2366FFDD4();
        }
      }

      else
      {
        factorization_low = LOBYTE(factor->symbolicFactorization.factorization);
        v12 = factor->symbolicFactorization.rowCount * factorization_low;
        v13 = factor->symbolicFactorization.columnCount * factorization_low;
        if (v12 <= v13)
        {
          v14 = v13;
        }

        else
        {
          v14 = v12;
        }

        if (rowCount == v14)
        {
          _SparseSolveOpaque_Double(factor, 0, a2, a3);
          goto LABEL_5;
        }

        if (v15.reportError)
        {
          v27 = 0u;
          v28 = 0u;
          v25 = 0u;
          v26 = 0u;
          v23 = 0u;
          v24 = 0u;
          v21 = 0u;
          v22 = 0u;
          v19 = 0u;
          v20 = 0u;
          v17 = 0u;
          v18 = 0u;
          v16 = 0u;
          memset(&v15, 0, sizeof(v15));
          snprintf(&v15, 0x100uLL, "%s (%dx%d) is not consistent with largest dimension of matrix factorization %s (%d).\n");
          goto LABEL_10;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CC360();
        }
      }
    }

    else
    {
      if (v15.reportError)
      {
        v27 = 0u;
        v28 = 0u;
        v25 = 0u;
        v26 = 0u;
        v23 = 0u;
        v24 = 0u;
        v21 = 0u;
        v22 = 0u;
        v19 = 0u;
        v20 = 0u;
        v17 = 0u;
        v18 = 0u;
        v16 = 0u;
        memset(&v15, 0, sizeof(v15));
        snprintf(&v15, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
        goto LABEL_10;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC46C();
      }
    }

LABEL_4:
    _SparseTrap();
  }

  if (!v15.reportError)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F736C();
    }

    goto LABEL_4;
  }

  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v16 = 0u;
  memset(&v15, 0, sizeof(v15));
  snprintf(&v15, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_10:
  (reportError)(&v15);
LABEL_5:
  v4 = *MEMORY[0x277D85DE8];
}

void SparseSolve(SparseOpaqueFactorization_Double *factor, DenseMatrix_Double *a2, DenseMatrix_Double *a3, void *a4)
{
  v46 = *MEMORY[0x277D85DE8];
  p_symbolicFactorization = &factor->symbolicFactorization;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F73F0();
    }

    goto LABEL_4;
  }

  _SparseGetOptionsFromSymbolicFactor(&v32, &factor->symbolicFactorization);
  reportError = v32.reportError;
  if (p_symbolicFactorization->status == SparseStatusOK && factor->symbolicFactorization.workspaceSize_Float && factor->status == SparseStatusOK && factor->solveWorkspaceRequiredStatic)
  {
    v11 = *&factor->attributes ^ *&factor->symbolicFactorization.attributes;
    factorization_low = LOBYTE(factor->symbolicFactorization.factorization);
    v13 = factor->symbolicFactorization.rowCount * factorization_low;
    v14 = factor->symbolicFactorization.columnCount * factorization_low;
    if (v11)
    {
      v15 = v14;
    }

    else
    {
      v15 = v13;
    }

    if (v11)
    {
      v16 = v13;
    }

    else
    {
      v16 = v14;
    }

    if (BYTE1(factor->symbolicFactorization.factorization) == 40)
    {
      v17 = v15;
    }

    else
    {
      v17 = v16;
    }

    rowCount = a2->rowCount;
    if (a2->columnStride < a2->rowCount)
    {
      if (v32.reportError)
      {
        goto LABEL_30;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC574();
      }

      goto LABEL_4;
    }

    if (a3->columnStride < a3->rowCount)
    {
      if (v32.reportError)
      {
LABEL_30:
        v44 = 0u;
        v45 = 0u;
        v42 = 0u;
        v43 = 0u;
        v40 = 0u;
        v41 = 0u;
        v38 = 0u;
        v39 = 0u;
        v36 = 0u;
        v37 = 0u;
        v34 = 0u;
        v35 = 0u;
        v33 = 0u;
        memset(&v32, 0, sizeof(v32));
        snprintf(&v32, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
        goto LABEL_10;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CBD60();
      }

LABEL_4:
      _SparseTrap();
    }

    if (*&a2->attributes)
    {
      v19 = 4;
    }

    else
    {
      v19 = 0;
      rowCount = a2->columnCount;
    }

    if (*&a3->attributes)
    {
      v20 = 0;
    }

    else
    {
      v20 = 4;
    }

    v21 = *(&a3->rowCount + v20);
    v22 = *(&a2->rowCount + v19);
    if (*&a3->attributes)
    {
      v23 = 4;
    }

    else
    {
      v23 = 0;
    }

    v24 = *(&a3->rowCount + v23);
    if (rowCount == v21)
    {
      if (rowCount <= 0)
      {
        if (v32.reportError)
        {
          v44 = 0u;
          v45 = 0u;
          v42 = 0u;
          v43 = 0u;
          v40 = 0u;
          v41 = 0u;
          v38 = 0u;
          v39 = 0u;
          v36 = 0u;
          v37 = 0u;
          v34 = 0u;
          v35 = 0u;
          v33 = 0u;
          memset(&v32, 0, sizeof(v32));
          snprintf(&v32, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_10;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CC4F0();
        }

        goto LABEL_4;
      }

      if (v22 == v17)
      {
        if (v24 == v16)
        {
          _SparseSolveOpaque_Double(factor, a2, a3, a4);
          goto LABEL_5;
        }

        if (v32.reportError)
        {
          v44 = 0u;
          v45 = 0u;
          v42 = 0u;
          v43 = 0u;
          v40 = 0u;
          v41 = 0u;
          v38 = 0u;
          v39 = 0u;
          v36 = 0u;
          v37 = 0u;
          v34 = 0u;
          v35 = 0u;
          v33 = 0u;
          memset(&v32, 0, sizeof(v32));
          v27 = "X";
          goto LABEL_59;
        }

        v30 = v17;
        v31 = v16;
        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_4;
        }

        v32.control = 136316418;
        *&v32.orderMethod = "X";
        WORD2(v32.order) = 1024;
        *(&v32.order + 6) = v24;
        WORD1(v32.ignoreRowsAndColumns) = 1024;
        HIDWORD(v32.ignoreRowsAndColumns) = rowCount;
        LOWORD(v32.malloc) = 2080;
        *(&v32.malloc + 2) = "matrix factorization Factored";
        WORD1(v32.free) = 1024;
        HIDWORD(v32.free) = v31;
        LOWORD(v32.reportError) = 1024;
        *(&v32.reportError + 2) = v30;
        v25 = MEMORY[0x277D86220];
        v26 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }

      else
      {
        if (v32.reportError)
        {
          v44 = 0u;
          v45 = 0u;
          v42 = 0u;
          v43 = 0u;
          v40 = 0u;
          v41 = 0u;
          v38 = 0u;
          v39 = 0u;
          v36 = 0u;
          v37 = 0u;
          v34 = 0u;
          v35 = 0u;
          v33 = 0u;
          memset(&v32, 0, sizeof(v32));
          v27 = "B";
LABEL_59:
          snprintf(&v32, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v27);
          goto LABEL_10;
        }

        v28 = v17;
        v29 = v16;
        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_4;
        }

        v32.control = 136316418;
        *&v32.orderMethod = "B";
        WORD2(v32.order) = 1024;
        *(&v32.order + 6) = v22;
        WORD1(v32.ignoreRowsAndColumns) = 1024;
        HIDWORD(v32.ignoreRowsAndColumns) = rowCount;
        LOWORD(v32.malloc) = 2080;
        *(&v32.malloc + 2) = "matrix factorization Factored";
        WORD1(v32.free) = 1024;
        HIDWORD(v32.free) = v29;
        LOWORD(v32.reportError) = 1024;
        *(&v32.reportError + 2) = v28;
        v25 = MEMORY[0x277D86220];
        v26 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
    }

    else
    {
      if (v32.reportError)
      {
        v44 = 0u;
        v45 = 0u;
        v42 = 0u;
        v43 = 0u;
        v40 = 0u;
        v41 = 0u;
        v38 = 0u;
        v39 = 0u;
        v36 = 0u;
        v37 = 0u;
        v34 = 0u;
        v35 = 0u;
        v33 = 0u;
        memset(&v32, 0, sizeof(v32));
        snprintf(&v32, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
        goto LABEL_10;
      }

      if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        goto LABEL_4;
      }

      v32.control = 136316418;
      *&v32.orderMethod = "B";
      WORD2(v32.order) = 1024;
      *(&v32.order + 6) = v22;
      WORD1(v32.ignoreRowsAndColumns) = 1024;
      HIDWORD(v32.ignoreRowsAndColumns) = rowCount;
      LOWORD(v32.malloc) = 2080;
      *(&v32.malloc + 2) = "X";
      WORD1(v32.free) = 1024;
      HIDWORD(v32.free) = v24;
      LOWORD(v32.reportError) = 1024;
      *(&v32.reportError + 2) = v21;
      v25 = MEMORY[0x277D86220];
      v26 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    }

    _os_log_error_impl(&dword_2366B9000, v25, OS_LOG_TYPE_ERROR, v26, &v32, 0x2Eu);
    goto LABEL_4;
  }

  if (!v32.reportError)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F736C();
    }

    goto LABEL_4;
  }

  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v33 = 0u;
  memset(&v32, 0, sizeof(v32));
  snprintf(&v32, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_10:
  (reportError)(&v32);
LABEL_5:
  v5 = *MEMORY[0x277D85DE8];
}

uint64_t SparseSolve(SparseOpaqueFactorization_Double *factor, DenseVector_Double a2)
{
  v30 = *MEMORY[0x277D85DE8];
  p_symbolicFactorization = &factor->symbolicFactorization;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F73F0();
    }

    goto LABEL_4;
  }

  data = a2.data;
  count = a2.count;
  _SparseGetOptionsFromSymbolicFactor(&v16, &factor->symbolicFactorization);
  reportError = v16.reportError;
  if (p_symbolicFactorization->status || !factor->symbolicFactorization.workspaceSize_Float || factor->status || !factor->solveWorkspaceRequiredStatic)
  {
    if (!v16.reportError)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2366F736C();
      }

      goto LABEL_4;
    }

    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v21 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    memset(&v16, 0, sizeof(v16));
    snprintf(&v16, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
  }

  else
  {
    factorization_low = LOBYTE(factor->symbolicFactorization.factorization);
    v10 = factor->symbolicFactorization.rowCount * factorization_low;
    v11 = factor->symbolicFactorization.columnCount * factorization_low;
    if (v10 > v11)
    {
      v11 = v10;
    }

    if (v11 == count)
    {
      free = v16.free;
      Soln.rowCount = count;
      Soln.columnCount = 1;
      Soln.columnStride = count;
      *&Soln.attributes = 0;
      Soln.data = data;
      v13 = (v16.malloc)(*&factor[1].status + factor->solveWorkspaceRequiredPerRHS);
      if (v13)
      {
        v14 = v13;
        _SparseSolveOpaque_Double(factor, 0, &Soln, v13);
        result = (free)(v14);
        goto LABEL_5;
      }

      if (reportError)
      {
        v28 = 0u;
        v29 = 0u;
        v26 = 0u;
        v27 = 0u;
        v24 = 0u;
        v25 = 0u;
        v22 = 0u;
        v23 = 0u;
        v21 = 0u;
        v19 = 0u;
        v20 = 0u;
        v17 = 0u;
        v18 = 0u;
        memset(&v16, 0, sizeof(v16));
        snprintf(&v16, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
        goto LABEL_10;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC3F4();
      }

LABEL_4:
      _SparseTrap();
    }

    if (!v16.reportError)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC5F8();
      }

      goto LABEL_4;
    }

    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v21 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    memset(&v16, 0, sizeof(v16));
    snprintf(&v16, 0x100uLL, "%s.count (%d) is not equal to largest dimension of matrix factorization %s.\n");
  }

LABEL_10:
  result = (reportError)(&v16);
LABEL_5:
  v3 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t SparseSolve(SparseOpaqueFactorization_Double *factor, DenseVector_Double a2, DenseVector_Double a3)
{
  v40 = *MEMORY[0x277D85DE8];
  p_symbolicFactorization = &factor->symbolicFactorization;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F73F0();
    }

    goto LABEL_4;
  }

  data = a3.data;
  count = a3.count;
  v8 = a2.data;
  v9 = a2.count;
  _SparseGetOptionsFromSymbolicFactor(&v26, &factor->symbolicFactorization);
  reportError = v26.reportError;
  if (p_symbolicFactorization->status || !factor->symbolicFactorization.workspaceSize_Float || factor->status || !factor->solveWorkspaceRequiredStatic)
  {
    if (!v26.reportError)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2366F736C();
      }

      goto LABEL_4;
    }

    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v27 = 0u;
    memset(&v26, 0, sizeof(v26));
    snprintf(&v26, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
  }

  else
  {
    v12 = *&factor->attributes ^ *&factor->symbolicFactorization.attributes;
    factorization_low = LOBYTE(factor->symbolicFactorization.factorization);
    v14 = factor->symbolicFactorization.rowCount * factorization_low;
    v15 = factor->symbolicFactorization.columnCount * factorization_low;
    v16 = (v12 & 1) == 0;
    if (v12)
    {
      v17 = v15;
    }

    else
    {
      v17 = v14;
    }

    if (v16)
    {
      v18 = v15;
    }

    else
    {
      v18 = v14;
    }

    if (BYTE1(factor->symbolicFactorization.factorization) == 40)
    {
      v19 = v17;
    }

    else
    {
      v19 = v18;
    }

    if (v18 == count)
    {
      if (v19 == v9)
      {
        free = v26.free;
        RHS.rowCount = v9;
        RHS.columnCount = 1;
        RHS.columnStride = v9;
        *&RHS.attributes = 0;
        RHS.data = v8;
        Soln.rowCount = count;
        Soln.columnCount = 1;
        Soln.columnStride = count;
        *&Soln.attributes = 0;
        v21 = *&factor[1].status + factor->solveWorkspaceRequiredPerRHS;
        Soln.data = data;
        v22 = (v26.malloc)(v21);
        if (v22)
        {
          v23 = v22;
          _SparseSolveOpaque_Double(factor, &RHS, &Soln, v22);
          result = (free)(v23);
          goto LABEL_5;
        }

        if (reportError)
        {
          v38 = 0u;
          v39 = 0u;
          v36 = 0u;
          v37 = 0u;
          v34 = 0u;
          v35 = 0u;
          v32 = 0u;
          v33 = 0u;
          v30 = 0u;
          v31 = 0u;
          v28 = 0u;
          v29 = 0u;
          v27 = 0u;
          memset(&v26, 0, sizeof(v26));
          snprintf(&v26, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
          goto LABEL_10;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CC3F4();
        }

LABEL_4:
        _SparseTrap();
      }

      if (!v26.reportError)
      {
        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CC71C();
        }

        goto LABEL_4;
      }
    }

    else if (!v26.reportError)
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC68C();
      }

      goto LABEL_4;
    }

    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v27 = 0u;
    memset(&v26, 0, sizeof(v26));
    snprintf(&v26, 0x100uLL, "%s (size %dx1) does not match dimensions of matrix factorization %s (%d x %d).\n");
  }

LABEL_10:
  result = (reportError)(&v26);
LABEL_5:
  v4 = *MEMORY[0x277D85DE8];
  return result;
}

void SparseSolve(SparseOpaqueFactorization_Double *factor, DenseVector_Double a2, void *a3)
{
  v27 = *MEMORY[0x277D85DE8];
  p_symbolicFactorization = &factor->symbolicFactorization;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F73F0();
    }

    goto LABEL_4;
  }

  data = a2.data;
  count = a2.count;
  _SparseGetOptionsFromSymbolicFactor(&v13, &factor->symbolicFactorization);
  reportError = v13.reportError;
  if (p_symbolicFactorization->status == SparseStatusOK && factor->symbolicFactorization.workspaceSize_Float && factor->status == SparseStatusOK && factor->solveWorkspaceRequiredStatic)
  {
    factorization_low = LOBYTE(factor->symbolicFactorization.factorization);
    v11 = factor->symbolicFactorization.rowCount * factorization_low;
    v12 = factor->symbolicFactorization.columnCount * factorization_low;
    if (v11 > v12)
    {
      v12 = v11;
    }

    if (v12 == count)
    {
      v13.control = count;
      *&v13.orderMethod = 1;
      v13.order = count;
      v13.ignoreRowsAndColumns = data;
      _SparseSolveOpaque_Double(factor, 0, &v13, a3);
      goto LABEL_5;
    }

    if (v13.reportError)
    {
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      v14 = 0u;
      memset(&v13, 0, sizeof(v13));
      snprintf(&v13, 0x100uLL, "%s.count (%d) is not equal to largest dimension of matrix factorization %s.\n");
      goto LABEL_10;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC5F8();
    }

LABEL_4:
    _SparseTrap();
  }

  if (!v13.reportError)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F736C();
    }

    goto LABEL_4;
  }

  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v14 = 0u;
  memset(&v13, 0, sizeof(v13));
  snprintf(&v13, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_10:
  (reportError)(&v13);
LABEL_5:
  v4 = *MEMORY[0x277D85DE8];
}

void SparseSolve(SparseOpaqueFactorization_Double *factor, DenseVector_Double a2, DenseVector_Double a3, void *a4)
{
  v36 = *MEMORY[0x277D85DE8];
  p_symbolicFactorization = &factor->symbolicFactorization;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F73F0();
    }

    goto LABEL_4;
  }

  data = a3.data;
  count = a3.count;
  v10 = a2.data;
  v11 = a2.count;
  _SparseGetOptionsFromSymbolicFactor(&v22, &factor->symbolicFactorization);
  reportError = v22.reportError;
  if (p_symbolicFactorization->status == SparseStatusOK && factor->symbolicFactorization.workspaceSize_Float && factor->status == SparseStatusOK && factor->solveWorkspaceRequiredStatic)
  {
    v13 = *&factor->attributes ^ *&factor->symbolicFactorization.attributes;
    factorization_low = LOBYTE(factor->symbolicFactorization.factorization);
    v15 = factor->symbolicFactorization.rowCount * factorization_low;
    v16 = factor->symbolicFactorization.columnCount * factorization_low;
    v17 = (v13 & 1) == 0;
    if (v13)
    {
      v18 = v16;
    }

    else
    {
      v18 = v15;
    }

    if (v17)
    {
      v19 = v16;
    }

    else
    {
      v19 = v15;
    }

    if (BYTE1(factor->symbolicFactorization.factorization) == 40)
    {
      v20 = v18;
    }

    else
    {
      v20 = v19;
    }

    if (v19 == count)
    {
      if (v20 == v11)
      {
        v22.control = v11;
        *&v22.orderMethod = 1;
        v22.order = v11;
        v22.ignoreRowsAndColumns = v10;
        Soln.rowCount = count;
        Soln.columnCount = 1;
        Soln.columnStride = count;
        *&Soln.attributes = 0;
        Soln.data = data;
        _SparseSolveOpaque_Double(factor, &v22, &Soln, a4);
        goto LABEL_5;
      }

      if (v22.reportError)
      {
        goto LABEL_31;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC71C();
      }
    }

    else
    {
      if (v22.reportError)
      {
LABEL_31:
        v34 = 0u;
        v35 = 0u;
        v32 = 0u;
        v33 = 0u;
        v30 = 0u;
        v31 = 0u;
        v28 = 0u;
        v29 = 0u;
        v27 = 0u;
        v25 = 0u;
        v26 = 0u;
        v23 = 0u;
        v24 = 0u;
        memset(&v22, 0, sizeof(v22));
        snprintf(&v22, 0x100uLL, "%s (size %dx1) does not match dimensions of matrix factorization %s (%d x %d).\n");
        goto LABEL_10;
      }

      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CC68C();
      }
    }

LABEL_4:
    _SparseTrap();
  }

  if (!v22.reportError)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F736C();
    }

    goto LABEL_4;
  }

  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v27 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  memset(&v22, 0, sizeof(v22));
  snprintf(&v22, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_10:
  (reportError)(&v22);
LABEL_5:
  v5 = *MEMORY[0x277D85DE8];
}

void SparseRefactor(SparseMatrix_Double *a1, SparseOpaqueFactorization_Double *a2, SparseNumericFactorOptions *a3, void *a4, __n128 a5)
{
  if (a1->structure.rowCount != a2->symbolicFactorization.rowCount || a1->structure.columnCount != a2->symbolicFactorization.columnCount || *(&a1->structure.blockSize + 2) != LOBYTE(a2->symbolicFactorization.factorization) || ((*&a2->symbolicFactorization.attributes ^ *&a1->structure.attributes) & 1) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC7AC();
    }

    _SparseTrap();
  }

  v6 = BYTE1(a2->symbolicFactorization.factorization);
  if ((v6 - 80) >= 4)
  {
    if ((v6 - 40) > 1)
    {

      _SparseRefactorSymmetric_Double(a1, a2, a3, a4);
    }

    else
    {

      _SparseRefactorQR_Double(a1, a2, a3, a4);
    }
  }

  else
  {

    _SparseRefactorLU_Double(a1, a2, a3, a4, a5);
  }
}

uint64_t SparseRefactor(SparseMatrix_Double *a1, SparseOpaqueFactorization_Double *a2, SparseNumericFactorOptions *a3)
{
  v29 = *MEMORY[0x277D85DE8];
  if (a2->symbolicFactorization.status || !a2->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC8B4();
    }

    goto LABEL_4;
  }

  _SparseGetOptionsFromSymbolicFactor(&v15, &a2->symbolicFactorization);
  free = v15.free;
  reportError = v15.reportError;
  v9 = (v15.malloc)(a2->symbolicFactorization.factorSize_Float);
  if (!v9)
  {
    a2->status = SparseInternalError;
    if (reportError)
    {
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      v16 = 0u;
      memset(&v15, 0, sizeof(v15));
      snprintf(&v15, 0x100uLL, "Failed to allocate workspace of size %ld.", a2->symbolicFactorization.factorSize_Float);
      result = (reportError)(&v15);
      goto LABEL_5;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC83C(&a2->symbolicFactorization.factorSize_Float);
    }

LABEL_4:
    _SparseTrap();
  }

  v10 = v9;
  v11 = *&a1->structure.rowIndices;
  *&v15.control = *&a1->structure.rowCount;
  *&v15.ignoreRowsAndColumns = v11;
  v15.free = a1->data;
  v12 = *&a3->pivotTolerance;
  *&v14.control = *&a3->control;
  *&v14.pivotTolerance = v12;
  SparseRefactor(&v15, a2, &v14, v9, *&v14.control);
  result = (free)(v10);
LABEL_5:
  v4 = *MEMORY[0x277D85DE8];
  return result;
}

void SparseRefactor(SparseMatrix_Double *a1, SparseOpaqueFactorization_Double *factor, void *a3)
{
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2366F73F0();
    }

    _SparseTrap();
  }

  memset(&v9, 0, sizeof(v9));
  _SparseGetOptionsFromNumericFactor_Double(&v9, factor);
  v6 = *&a1->structure.rowIndices;
  *&v8.structure.rowCount = *&a1->structure.rowCount;
  *&v8.structure.rowIndices = v6;
  v8.data = a1->data;
  v7 = v9;
  SparseRefactor(&v8, factor, &v7, a3, *&v9.control);
}

uint64_t SparseRefactor(SparseMatrix_Double *a1, SparseOpaqueFactorization_Double *factor)
{
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC8F8();
    }

    _SparseTrap();
  }

  memset(&v8, 0, sizeof(v8));
  _SparseGetOptionsFromNumericFactor_Double(&v8, factor);
  v4 = *&a1->structure.rowIndices;
  *&v7.structure.rowCount = *&a1->structure.rowCount;
  *&v7.structure.rowIndices = v4;
  v7.data = a1->data;
  v6 = v8;
  return SparseRefactor(&v7, factor, &v6);
}

uint64_t SparseUpdateFactor(unsigned __int8 a1, SparseOpaqueFactorization_Double *a2, int a3, const int *a4, SparseMatrix_Double *a5)
{
  if (a5->structure.rowCount != a2->symbolicFactorization.rowCount || a5->structure.columnCount != a2->symbolicFactorization.columnCount || *(&a5->structure.blockSize + 2) != LOBYTE(a2->symbolicFactorization.factorization) || ((*&a2->symbolicFactorization.attributes ^ *&a5->structure.attributes) & 1) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC93C();
    }

LABEL_9:
    _SparseTrap();
  }

  if (BYTE1(a2->symbolicFactorization.factorization) - 81 > 2)
  {
    a2->status = SparseParameterError;
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC9CC();
    }

    goto LABEL_9;
  }

  v5 = *&a5->structure.rowIndices;
  v7[0] = *&a5->structure.rowCount;
  v7[1] = v5;
  data = a5->data;
  return _SparseUpdatePartialRefactorLU_Double(a2, a3, a4, v7);
}

void SparseCreateSubfactor(SparseOpaqueFactorization_Double *a1@<X1>, int a2@<W0>, uint64_t a3@<X8>)
{
  v25 = *MEMORY[0x277D85DE8];
  if (a1->symbolicFactorization.status || !a1->symbolicFactorization.workspaceSize_Float || a1->status || !a1->solveWorkspaceRequiredStatic)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCBA8();
    }

    goto LABEL_4;
  }

  _SparseGetOptionsFromSymbolicFactor(v24, &a1->symbolicFactorization);
  v7 = *&v24[40];
  v8 = BYTE1(a1->symbolicFactorization.factorization);
  if (a2 <= 4)
  {
    if (a2 <= 2)
    {
      if (a2 != 1)
      {
        if (a2 == 2)
        {
          if (v8 - 2 >= 3)
          {
            if (*&v24[40])
            {
              memset(&v24[59], 0, 197);
              strcpy(v24, "Subfactor Type only valid for LDL^T or LU factorizations.\n");
LABEL_46:
              v7(v24);
              *a3 = 0u;
              *(a3 + 16) = 0u;
              *(a3 + 96) = 0u;
              *(a3 + 112) = 0u;
              *(a3 + 64) = 0u;
              *(a3 + 80) = 0u;
              *(a3 + 32) = 0u;
              *(a3 + 48) = 0u;
              *(a3 + 8) = -3;
              *(a3 + 16) = -3;
              goto LABEL_5;
            }

            if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
            {
              sub_2367CCADC();
            }

            goto LABEL_4;
          }

          goto LABEL_36;
        }

LABEL_38:
        if (*&v24[40])
        {
          memset(&v24[24], 0, 232);
          strcpy(v24, "Invalid subfactor type.");
          goto LABEL_46;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CCB64();
        }

        goto LABEL_4;
      }

      goto LABEL_36;
    }

    if (a2 != 3)
    {
      if (v8 - 2 >= 3)
      {
        if (*&v24[40])
        {
          memset(&v24[53], 0, 203);
          strcpy(v24, "Subfactor Type only valid for LDL^T factorizations.\n");
          goto LABEL_46;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CCA98();
        }

        goto LABEL_4;
      }

      goto LABEL_36;
    }

    if (v8 < 5 && ((0x1Du >> v8) & 1) != 0)
    {
      v10 = 6;
      goto LABEL_37;
    }

    if (!*&v24[40])
    {
      if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        goto LABEL_4;
      }

      goto LABEL_42;
    }

LABEL_44:
    memset(&v24[66], 0, 190);
    strcpy(&v24[64], "\n");
    v11 = "Subfactor Type only valid for Cholesky and LDL^T factorizations.\n";
    goto LABEL_45;
  }

  if ((a2 - 7) >= 2)
  {
    if (a2 != 5)
    {
      if (a2 == 6)
      {
        v9 = v8 - 40;
        if (v9 > 0x2B || ((1 << v9) & 0xE0000000001) == 0)
        {
          if (*&v24[40])
          {
            memset(&v24[58], 0, 198);
            strcpy(v24, "SparseSubfactorQ only valid for QR or LU factorizations.\n");
            goto LABEL_46;
          }

          if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
          {
            sub_2367CCA54();
          }

LABEL_4:
          _SparseTrap();
        }

        goto LABEL_36;
      }

      goto LABEL_38;
    }

    if (v8 < 5 && ((0x1Du >> v8) & 1) != 0)
    {
LABEL_36:
      v10 = 2;
      goto LABEL_37;
    }

    if (!*&v24[40])
    {
      if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        goto LABEL_4;
      }

LABEL_42:
      sub_2367CCB20();
      goto LABEL_4;
    }

    goto LABEL_44;
  }

  if ((v8 & 0xFE) != 0x28)
  {
    if (!*&v24[40])
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CCA10();
      }

      goto LABEL_4;
    }

    memset(&v24[66], 0, 190);
    strcpy(&v24[64], "\n");
    v11 = "Subfactor Type only valid for QR and CholeskyAtA factorizations.\n";
LABEL_45:
    v20 = *(v11 + 1);
    *v24 = *v11;
    *&v24[16] = v20;
    v21 = *(v11 + 3);
    *&v24[32] = *(v11 + 2);
    *&v24[48] = v21;
    goto LABEL_46;
  }

  v10 = 4;
LABEL_37:
  _SparseRetainNumeric_Double(a1);
  v22 = 0;
  workStatic = 0;
  v12 = *&a1->solveWorkspaceRequiredStatic;
  *&v24[64] = *&a1->userFactorStorage;
  *&v24[80] = v12;
  *&v24[96] = *&a1[1].status;
  v13 = *&a1->symbolicFactorization.columnCount;
  *v24 = *&a1->status;
  *&v24[16] = v13;
  v14 = *&a1->symbolicFactorization.factorSize_Float;
  *&v24[32] = *&a1->symbolicFactorization.workspaceSize_Float;
  *&v24[48] = v14;
  _SparseGetWorkspaceRequired_Double(a2, v24, &workStatic, &v22);
  v15 = *&a1->symbolicFactorization.workspaceSize_Float;
  *(a3 + 56) = *&a1->symbolicFactorization.factorSize_Float;
  v16 = *&a1->solveWorkspaceRequiredStatic;
  *(a3 + 72) = *&a1->userFactorStorage;
  *(a3 + 88) = v16;
  v17 = *&a1->symbolicFactorization.columnCount;
  *(a3 + 8) = *&a1->status;
  *(a3 + 24) = v17;
  *a3 = v10;
  *(a3 + 2) = 0;
  *(a3 + 4) = a2;
  v18 = *&a1[1].status;
  *(a3 + 40) = v15;
  v19 = workStatic;
  *(a3 + 104) = v18;
  *(a3 + 112) = v19;
  *(a3 + 120) = v22;
LABEL_5:
  v5 = *MEMORY[0x277D85DE8];
}

uint64_t SparseSolve(SparseOpaqueSubfactor_Double *a1, DenseMatrix_Double *a2)
{
  v23 = *MEMORY[0x277D85DE8];
  if (!*(&a1->contents + 2))
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCCA8();
    }

    goto LABEL_25;
  }

  _SparseGetOptionsFromSymbolicFactor(v22, &a1->factor.symbolicFactorization);
  v4 = *&v22[40];
  attributes = a2->attributes;
  v6 = (*&attributes & 1) == 0;
  v7 = 4;
  if (*&attributes)
  {
    v8 = 0;
  }

  else
  {
    v8 = 4;
  }

  v9 = *(&a2->rowCount + v8);
  if (v6)
  {
    v7 = 0;
  }

  if (v9 <= 0)
  {
    if (!*&v22[40])
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CCBEC();
      }

      goto LABEL_25;
    }

    memset(&v22[34], 0, 222);
    strcpy(v22, "XB must have non-zero dimension.\n");
LABEL_34:
    result = v4(v22);
    goto LABEL_35;
  }

  v10 = *(&a2->rowCount + v7);
  factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  v12 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  v13 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v12 >= v13)
  {
    v14 = v13;
  }

  else
  {
    v14 = v12;
  }

  if (v12 > v13)
  {
    v13 = v12;
  }

  if (*(&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40)
  {
    v16 = v13;
  }

  else
  {
    v16 = v14;
  }

  if (v10 != v16)
  {
    if (!*&v22[40])
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CCC30();
      }

      goto LABEL_25;
    }

    memset(v22, 0, sizeof(v22));
    snprintf(v22, 0x100uLL, "XB dimension (%d) must match maximum subfactor dimension (%d).\n");
    goto LABEL_34;
  }

  v17 = *&v22[32];
  v18 = (*&v22[24])(a1->workspaceRequiredPerRHS + *&a1[1].attributes * v9);
  if (!v18)
  {
    if (v4)
    {
      memset(v22, 0, sizeof(v22));
      snprintf(v22, 0x100uLL, "Failed to allocate workspace of size %ld.\n");
      goto LABEL_34;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBC20();
    }

LABEL_25:
    _SparseTrap();
  }

  v19 = v18;
  _SparseSolveSubfactor_Double(a1, 0, a2, v18);
  result = v17(v19);
LABEL_35:
  v21 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t SparseSolve(SparseOpaqueSubfactor_Double *a1, DenseMatrix_Double *a2, DenseMatrix_Double *a3)
{
  v45 = *MEMORY[0x277D85DE8];
  if (!*(&a1->contents + 2))
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCCA8();
    }

    goto LABEL_69;
  }

  _SparseGetOptionsFromSymbolicFactor(&v31, &a1->factor.symbolicFactorization);
  reportError = v31.reportError;
  attributes = a1->attributes;
  factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  v9 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  v10 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v9 >= v10)
  {
    v11 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }

  else
  {
    v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }

  if (v9 <= v10)
  {
    v9 = v10;
  }

  if (*(&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40)
  {
    v13 = v9;
  }

  else
  {
    v13 = v11;
  }

  if (*&attributes)
  {
    v14 = v13;
  }

  else
  {
    v14 = v11;
  }

  if (*&attributes)
  {
    v15 = v11;
  }

  else
  {
    v15 = v13;
  }

  rowCount = a2->rowCount;
  if (a2->columnStride < a2->rowCount)
  {
    if (v31.reportError)
    {
      goto LABEL_26;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC574();
    }

LABEL_69:
    _SparseTrap();
  }

  if (a3->columnStride >= a3->rowCount)
  {
    if (*&a2->attributes)
    {
      v18 = 4;
    }

    else
    {
      v18 = 0;
      rowCount = a2->columnCount;
    }

    if (*&a3->attributes)
    {
      v19 = 0;
    }

    else
    {
      v19 = 4;
    }

    v20 = *(&a3->rowCount + v19);
    v21 = *(&a2->rowCount + v18);
    if (*&a3->attributes)
    {
      v22 = 4;
    }

    else
    {
      v22 = 0;
    }

    v23 = *(&a3->rowCount + v22);
    if (rowCount == v20)
    {
      if (rowCount <= 0)
      {
        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          snprintf(&v31, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_27;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CC4F0();
        }

        goto LABEL_69;
      }

      if (v21 == v15)
      {
        if (v23 == v14)
        {
          free = v31.free;
          v25 = (v31.malloc)(a1->workspaceRequiredPerRHS + *&a1[1].attributes * rowCount);
          if (v25)
          {
            v26 = v25;
            _SparseSolveSubfactor_Double(a1, a2, a3, v25);
            result = (free)(v26);
            goto LABEL_70;
          }

          if (reportError)
          {
            v43 = 0u;
            v44 = 0u;
            v41 = 0u;
            v42 = 0u;
            v39 = 0u;
            v40 = 0u;
            v37 = 0u;
            v38 = 0u;
            v35 = 0u;
            v36 = 0u;
            v33 = 0u;
            v34 = 0u;
            v32 = 0u;
            memset(&v31, 0, sizeof(v31));
            snprintf(&v31, 0x100uLL, "Failed to allocate workspace of size %ld.\n");
            goto LABEL_27;
          }

          if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
          {
            sub_2367CBC20();
          }

          goto LABEL_69;
        }

        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          v29 = "X";
          goto LABEL_57;
        }

        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_69;
        }

        v31.control = 136316418;
        *&v31.orderMethod = "X";
        WORD2(v31.order) = 1024;
        *(&v31.order + 6) = v23;
        WORD1(v31.ignoreRowsAndColumns) = 1024;
        HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
        LOWORD(v31.malloc) = 2080;
        *(&v31.malloc + 2) = "subfactor dimension";
        WORD1(v31.free) = 1024;
        HIDWORD(v31.free) = v14;
        LOWORD(v31.reportError) = 1024;
        *(&v31.reportError + 2) = v15;
        v27 = MEMORY[0x277D86220];
        v28 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }

      else
      {
        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          v29 = "B";
LABEL_57:
          snprintf(&v31, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v29);
          goto LABEL_27;
        }

        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_69;
        }

        v31.control = 136316418;
        *&v31.orderMethod = "B";
        WORD2(v31.order) = 1024;
        *(&v31.order + 6) = v21;
        WORD1(v31.ignoreRowsAndColumns) = 1024;
        HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
        LOWORD(v31.malloc) = 2080;
        *(&v31.malloc + 2) = "subfactor dimension";
        WORD1(v31.free) = 1024;
        HIDWORD(v31.free) = v14;
        LOWORD(v31.reportError) = 1024;
        *(&v31.reportError + 2) = v15;
        v27 = MEMORY[0x277D86220];
        v28 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
    }

    else
    {
      if (v31.reportError)
      {
        v43 = 0u;
        v44 = 0u;
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v32 = 0u;
        memset(&v31, 0, sizeof(v31));
        snprintf(&v31, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
        goto LABEL_27;
      }

      if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        goto LABEL_69;
      }

      v31.control = 136316418;
      *&v31.orderMethod = "B";
      WORD2(v31.order) = 1024;
      *(&v31.order + 6) = v21;
      WORD1(v31.ignoreRowsAndColumns) = 1024;
      HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
      LOWORD(v31.malloc) = 2080;
      *(&v31.malloc + 2) = "X";
      WORD1(v31.free) = 1024;
      HIDWORD(v31.free) = v23;
      LOWORD(v31.reportError) = 1024;
      *(&v31.reportError + 2) = v20;
      v27 = MEMORY[0x277D86220];
      v28 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    }

    _os_log_error_impl(&dword_2366B9000, v27, OS_LOG_TYPE_ERROR, v28, &v31, 0x2Eu);
    goto LABEL_69;
  }

  if (!v31.reportError)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBD60();
    }

    goto LABEL_69;
  }

LABEL_26:
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v32 = 0u;
  memset(&v31, 0, sizeof(v31));
  snprintf(&v31, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
  result = (reportError)(&v31);
LABEL_70:
  v30 = *MEMORY[0x277D85DE8];
  return result;
}

void SparseSolve(SparseOpaqueSubfactor_Double *a1, DenseMatrix_Double *a2, char *a3)
{
  v19 = *MEMORY[0x277D85DE8];
  if (!*(&a1->contents + 2))
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCCEC();
    }

    goto LABEL_23;
  }

  _SparseGetOptionsFromSymbolicFactor(v18, &a1->factor.symbolicFactorization);
  v6 = *&v18[40];
  v7 = 4;
  if (*&a2->attributes)
  {
    v8 = 0;
  }

  else
  {
    v8 = 4;
  }

  v9 = *(&a2->rowCount + v8);
  if ((*&a2->attributes & 1) == 0)
  {
    v7 = 0;
  }

  if (v9 <= 0)
  {
    if (*&v18[40])
    {
      memset(&v18[34], 0, 222);
      strcpy(v18, "XB must have non-zero dimension.\n");
LABEL_28:
      v6(v18);
      goto LABEL_29;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCBEC();
    }

LABEL_23:
    _SparseTrap();
  }

  v10 = *(&a2->rowCount + v7);
  factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  v12 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  v13 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v12 >= v13)
  {
    v14 = v13;
  }

  else
  {
    v14 = v12;
  }

  if (v12 > v13)
  {
    v13 = v12;
  }

  if (*(&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40)
  {
    v16 = v13;
  }

  else
  {
    v16 = v14;
  }

  if (v10 != v16)
  {
    if (*&v18[40])
    {
      memset(v18, 0, sizeof(v18));
      snprintf(v18, 0x100uLL, "XB dimension (%d) must match maximum subfactor dimension (%d).\n", v10, v16);
      goto LABEL_28;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCC30();
    }

    goto LABEL_23;
  }

  _SparseSolveSubfactor_Double(a1, 0, a2, a3);
LABEL_29:
  v17 = *MEMORY[0x277D85DE8];
}

void SparseSolve(SparseOpaqueSubfactor_Double *a1, DenseMatrix_Double *a2, DenseMatrix_Double *a3, char *a4)
{
  v45 = *MEMORY[0x277D85DE8];
  if (!*(&a1->contents + 2))
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCCEC();
    }

    goto LABEL_64;
  }

  _SparseGetOptionsFromSymbolicFactor(&v31, &a1->factor.symbolicFactorization);
  reportError = v31.reportError;
  attributes = a1->attributes;
  factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  v12 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v11 >= v12)
  {
    v13 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }

  else
  {
    v13 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }

  if (v11 <= v12)
  {
    v11 = v12;
  }

  if (*(&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40)
  {
    v15 = v11;
  }

  else
  {
    v15 = v13;
  }

  if (*&attributes)
  {
    v16 = v15;
  }

  else
  {
    v16 = v13;
  }

  if (*&attributes)
  {
    v17 = v13;
  }

  else
  {
    v17 = v15;
  }

  rowCount = a2->rowCount;
  if (a2->columnStride < a2->rowCount)
  {
    if (v31.reportError)
    {
      goto LABEL_26;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CC574();
    }

LABEL_64:
    _SparseTrap();
  }

  if (a3->columnStride >= a3->rowCount)
  {
    if (*&a2->attributes)
    {
      v19 = 4;
    }

    else
    {
      v19 = 0;
      rowCount = a2->columnCount;
    }

    if (*&a3->attributes)
    {
      v20 = 0;
    }

    else
    {
      v20 = 4;
    }

    v21 = *(&a3->rowCount + v20);
    v22 = *(&a2->rowCount + v19);
    if (*&a3->attributes)
    {
      v23 = 4;
    }

    else
    {
      v23 = 0;
    }

    v24 = *(&a3->rowCount + v23);
    if (rowCount == v21)
    {
      if (rowCount <= 0)
      {
        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          snprintf(&v31, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_27;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CC4F0();
        }

        goto LABEL_64;
      }

      if (v22 == v17)
      {
        if (v24 == v16)
        {
          _SparseSolveSubfactor_Double(a1, a2, a3, a4);
          goto LABEL_65;
        }

        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          v28 = "X";
          goto LABEL_56;
        }

        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_64;
        }

        v31.control = 136316418;
        *&v31.orderMethod = "X";
        WORD2(v31.order) = 1024;
        *(&v31.order + 6) = v24;
        WORD1(v31.ignoreRowsAndColumns) = 1024;
        HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
        LOWORD(v31.malloc) = 2080;
        *(&v31.malloc + 2) = "subfactor dimension";
        WORD1(v31.free) = 1024;
        HIDWORD(v31.free) = v16;
        LOWORD(v31.reportError) = 1024;
        *(&v31.reportError + 2) = v17;
        v26 = MEMORY[0x277D86220];
        v27 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }

      else
      {
        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          v28 = "B";
LABEL_56:
          snprintf(&v31, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v28);
          goto LABEL_27;
        }

        v29 = v22;
        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_64;
        }

        v31.control = 136316418;
        *&v31.orderMethod = "B";
        WORD2(v31.order) = 1024;
        *(&v31.order + 6) = v29;
        WORD1(v31.ignoreRowsAndColumns) = 1024;
        HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
        LOWORD(v31.malloc) = 2080;
        *(&v31.malloc + 2) = "subfactor dimension";
        WORD1(v31.free) = 1024;
        HIDWORD(v31.free) = v16;
        LOWORD(v31.reportError) = 1024;
        *(&v31.reportError + 2) = v17;
        v26 = MEMORY[0x277D86220];
        v27 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
    }

    else
    {
      if (v31.reportError)
      {
        v43 = 0u;
        v44 = 0u;
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v32 = 0u;
        memset(&v31, 0, sizeof(v31));
        snprintf(&v31, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
        goto LABEL_27;
      }

      v25 = v22;
      if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        goto LABEL_64;
      }

      v31.control = 136316418;
      *&v31.orderMethod = "B";
      WORD2(v31.order) = 1024;
      *(&v31.order + 6) = v25;
      WORD1(v31.ignoreRowsAndColumns) = 1024;
      HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
      LOWORD(v31.malloc) = 2080;
      *(&v31.malloc + 2) = "X";
      WORD1(v31.free) = 1024;
      HIDWORD(v31.free) = v24;
      LOWORD(v31.reportError) = 1024;
      *(&v31.reportError + 2) = v21;
      v26 = MEMORY[0x277D86220];
      v27 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    }

    _os_log_error_impl(&dword_2366B9000, v26, OS_LOG_TYPE_ERROR, v27, &v31, 0x2Eu);
    goto LABEL_64;
  }

  if (!v31.reportError)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBD60();
    }

    goto LABEL_64;
  }

LABEL_26:
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v32 = 0u;
  memset(&v31, 0, sizeof(v31));
  snprintf(&v31, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
  (reportError)(&v31);
LABEL_65:
  v30 = *MEMORY[0x277D85DE8];
}

uint64_t SparseSolve(SparseOpaqueSubfactor_Double *a1, DenseVector_Double a2)
{
  v2 = *&a1->factor.numericFactorization;
  v8[4] = *&a1->factor.symbolicFactorization.factorSize_Double;
  v8[5] = v2;
  v3 = *&a1->workspaceRequiredPerRHS;
  v8[6] = *&a1->factor.solveWorkspaceRequiredPerRHS;
  v8[7] = v3;
  v4 = *&a1->factor.symbolicFactorization.status;
  v8[0] = *&a1->attributes;
  v8[1] = v4;
  v5 = *&a1->factor.symbolicFactorization.workspaceSize_Double;
  v8[2] = *&a1->factor.symbolicFactorization.factorization;
  v8[3] = v5;
  v7.rowCount = a2.count;
  v7.columnCount = 1;
  v7.columnStride = a2.count;
  *&v7.attributes = 0;
  v7.data = a2.data;
  return SparseSolve(v8, &v7);
}

uint64_t SparseSolve(SparseOpaqueSubfactor_Double *a1, DenseVector_Double a2, DenseVector_Double a3)
{
  v3 = *&a1->factor.numericFactorization;
  v10[4] = *&a1->factor.symbolicFactorization.factorSize_Double;
  v10[5] = v3;
  v4 = *&a1->workspaceRequiredPerRHS;
  v10[6] = *&a1->factor.solveWorkspaceRequiredPerRHS;
  v10[7] = v4;
  v5 = *&a1->factor.symbolicFactorization.status;
  v10[0] = *&a1->attributes;
  v10[1] = v5;
  v6 = *&a1->factor.symbolicFactorization.workspaceSize_Double;
  v10[2] = *&a1->factor.symbolicFactorization.factorization;
  v10[3] = v6;
  v9.rowCount = a2.count;
  v9.columnCount = 1;
  v9.columnStride = a2.count;
  *&v9.attributes = 0;
  v9.data = a2.data;
  v8.rowCount = a3.count;
  v8.columnCount = 1;
  v8.columnStride = a3.count;
  *&v8.attributes = 0;
  v8.data = a3.data;
  return SparseSolve(v10, &v9, &v8);
}

void SparseSolve(SparseOpaqueSubfactor_Double *a1, DenseVector_Double a2, char *a3)
{
  v3 = *&a1->factor.numericFactorization;
  v8[4] = *&a1->factor.symbolicFactorization.factorSize_Double;
  v8[5] = v3;
  v4 = *&a1->workspaceRequiredPerRHS;
  v8[6] = *&a1->factor.solveWorkspaceRequiredPerRHS;
  v8[7] = v4;
  v5 = *&a1->factor.symbolicFactorization.status;
  v8[0] = *&a1->attributes;
  v8[1] = v5;
  v6 = *&a1->factor.symbolicFactorization.workspaceSize_Double;
  v8[2] = *&a1->factor.symbolicFactorization.factorization;
  v8[3] = v6;
  v7.rowCount = a2.count;
  v7.columnCount = 1;
  v7.columnStride = a2.count;
  *&v7.attributes = 0;
  v7.data = a2.data;
  SparseSolve(v8, &v7, a3);
}

void SparseSolve(SparseOpaqueSubfactor_Double *a1, DenseVector_Double a2, DenseVector_Double a3, char *a4)
{
  v4 = *&a1->factor.numericFactorization;
  v10[4] = *&a1->factor.symbolicFactorization.factorSize_Double;
  v10[5] = v4;
  v5 = *&a1->workspaceRequiredPerRHS;
  v10[6] = *&a1->factor.solveWorkspaceRequiredPerRHS;
  v10[7] = v5;
  v6 = *&a1->factor.symbolicFactorization.status;
  v10[0] = *&a1->attributes;
  v10[1] = v6;
  v7 = *&a1->factor.symbolicFactorization.workspaceSize_Double;
  v10[2] = *&a1->factor.symbolicFactorization.factorization;
  v10[3] = v7;
  v9.rowCount = a2.count;
  v9.columnCount = 1;
  v9.columnStride = a2.count;
  *&v9.attributes = 0;
  v9.data = a2.data;
  v8.rowCount = a3.count;
  v8.columnCount = 1;
  v8.columnStride = a3.count;
  *&v8.attributes = 0;
  v8.data = a3.data;
  SparseSolve(v10, &v9, &v8, a4);
}

uint64_t SparseMultiply(SparseOpaqueSubfactor_Double *a1, DenseMatrix_Double *a2)
{
  v23 = *MEMORY[0x277D85DE8];
  if (!*(&a1->contents + 2))
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCCEC();
    }

    goto LABEL_25;
  }

  _SparseGetOptionsFromSymbolicFactor(v22, &a1->factor.symbolicFactorization);
  v4 = *&v22[40];
  attributes = a2->attributes;
  v6 = (*&attributes & 1) == 0;
  v7 = 4;
  if (*&attributes)
  {
    v8 = 0;
  }

  else
  {
    v8 = 4;
  }

  v9 = *(&a2->rowCount + v8);
  if (v6)
  {
    v7 = 0;
  }

  if (v9 <= 0)
  {
    if (!*&v22[40])
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CCD30();
      }

      goto LABEL_25;
    }

    memset(&v22[34], 0, 222);
    strcpy(v22, "XY must have non-zero dimension.\n");
LABEL_34:
    result = v4(v22);
    goto LABEL_35;
  }

  v10 = *(&a2->rowCount + v7);
  factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  v12 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  v13 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v12 >= v13)
  {
    v14 = v13;
  }

  else
  {
    v14 = v12;
  }

  if (v12 > v13)
  {
    v13 = v12;
  }

  if (*(&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40)
  {
    v16 = v13;
  }

  else
  {
    v16 = v14;
  }

  if (v10 != v16)
  {
    if (!*&v22[40])
    {
      if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        sub_2367CCD74();
      }

      goto LABEL_25;
    }

    memset(v22, 0, sizeof(v22));
    snprintf(v22, 0x100uLL, "XY dimension (%d) must match maximum subfactor dimension (%d).\n");
    goto LABEL_34;
  }

  v17 = *&v22[32];
  v18 = (*&v22[24])(a1->workspaceRequiredPerRHS + *&a1[1].attributes * v9);
  if (!v18)
  {
    if (v4)
    {
      memset(v22, 0, sizeof(v22));
      snprintf(v22, 0x100uLL, "Failed to allocate workspace of size %ld.\n");
      goto LABEL_34;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBC20();
    }

LABEL_25:
    _SparseTrap();
  }

  v19 = v18;
  _SparseMultiplySubfactor_Double(a1, 0, a2, v18);
  result = v17(v19);
LABEL_35:
  v21 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t SparseMultiply(SparseOpaqueSubfactor_Double *a1, DenseMatrix_Double *a2, DenseMatrix_Double *a3)
{
  v45 = *MEMORY[0x277D85DE8];
  if (!*(&a1->contents + 2))
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCCEC();
    }

    goto LABEL_69;
  }

  _SparseGetOptionsFromSymbolicFactor(&v31, &a1->factor.symbolicFactorization);
  reportError = v31.reportError;
  attributes = a1->attributes;
  factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  v9 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  v10 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v9 >= v10)
  {
    v11 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }

  else
  {
    v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }

  if (v9 <= v10)
  {
    v9 = v10;
  }

  if (*(&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40)
  {
    v13 = v9;
  }

  else
  {
    v13 = v11;
  }

  if (*&attributes)
  {
    v14 = v13;
  }

  else
  {
    v14 = v11;
  }

  if (*&attributes)
  {
    v15 = v11;
  }

  else
  {
    v15 = v13;
  }

  rowCount = a2->rowCount;
  if (a2->columnStride < a2->rowCount)
  {
    if (v31.reportError)
    {
      goto LABEL_26;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBD60();
    }

LABEL_69:
    _SparseTrap();
  }

  if (a3->columnStride >= a3->rowCount)
  {
    if (*&a2->attributes)
    {
      v18 = 4;
    }

    else
    {
      v18 = 0;
      rowCount = a2->columnCount;
    }

    if (*&a3->attributes)
    {
      v19 = 0;
    }

    else
    {
      v19 = 4;
    }

    v20 = *(&a3->rowCount + v19);
    v21 = *(&a2->rowCount + v18);
    if (*&a3->attributes)
    {
      v22 = 4;
    }

    else
    {
      v22 = 0;
    }

    v23 = *(&a3->rowCount + v22);
    if (rowCount == v20)
    {
      if (rowCount <= 0)
      {
        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          snprintf(&v31, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_27;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CCDEC();
        }

        goto LABEL_69;
      }

      if (v21 == v14)
      {
        if (v23 == v15)
        {
          free = v31.free;
          v25 = (v31.malloc)(a1->workspaceRequiredPerRHS + *&a1[1].attributes * rowCount);
          if (v25)
          {
            v26 = v25;
            _SparseMultiplySubfactor_Double(a1, a2, a3, v25);
            result = (free)(v26);
            goto LABEL_70;
          }

          if (reportError)
          {
            v43 = 0u;
            v44 = 0u;
            v41 = 0u;
            v42 = 0u;
            v39 = 0u;
            v40 = 0u;
            v37 = 0u;
            v38 = 0u;
            v35 = 0u;
            v36 = 0u;
            v33 = 0u;
            v34 = 0u;
            v32 = 0u;
            memset(&v31, 0, sizeof(v31));
            snprintf(&v31, 0x100uLL, "Failed to allocate workspace of size %ld.\n");
            goto LABEL_27;
          }

          if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
          {
            sub_2367CBC20();
          }

          goto LABEL_69;
        }

        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          v29 = "Y";
          goto LABEL_57;
        }

        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_69;
        }

        v31.control = 136316418;
        *&v31.orderMethod = "Y";
        WORD2(v31.order) = 1024;
        *(&v31.order + 6) = v23;
        WORD1(v31.ignoreRowsAndColumns) = 1024;
        HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
        LOWORD(v31.malloc) = 2080;
        *(&v31.malloc + 2) = "subfactor dimension";
        WORD1(v31.free) = 1024;
        HIDWORD(v31.free) = v15;
        LOWORD(v31.reportError) = 1024;
        *(&v31.reportError + 2) = v14;
        v27 = MEMORY[0x277D86220];
        v28 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }

      else
      {
        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          v29 = "X";
LABEL_57:
          snprintf(&v31, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v29);
          goto LABEL_27;
        }

        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_69;
        }

        v31.control = 136316418;
        *&v31.orderMethod = "X";
        WORD2(v31.order) = 1024;
        *(&v31.order + 6) = v21;
        WORD1(v31.ignoreRowsAndColumns) = 1024;
        HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
        LOWORD(v31.malloc) = 2080;
        *(&v31.malloc + 2) = "subfactor dimension";
        WORD1(v31.free) = 1024;
        HIDWORD(v31.free) = v15;
        LOWORD(v31.reportError) = 1024;
        *(&v31.reportError + 2) = v14;
        v27 = MEMORY[0x277D86220];
        v28 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
    }

    else
    {
      if (v31.reportError)
      {
        v43 = 0u;
        v44 = 0u;
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v32 = 0u;
        memset(&v31, 0, sizeof(v31));
        snprintf(&v31, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "X");
        goto LABEL_27;
      }

      if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        goto LABEL_69;
      }

      v31.control = 136316418;
      *&v31.orderMethod = "X";
      WORD2(v31.order) = 1024;
      *(&v31.order + 6) = v21;
      WORD1(v31.ignoreRowsAndColumns) = 1024;
      HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
      LOWORD(v31.malloc) = 2080;
      *(&v31.malloc + 2) = "Y";
      WORD1(v31.free) = 1024;
      HIDWORD(v31.free) = v23;
      LOWORD(v31.reportError) = 1024;
      *(&v31.reportError + 2) = v20;
      v27 = MEMORY[0x277D86220];
      v28 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    }

    _os_log_error_impl(&dword_2366B9000, v27, OS_LOG_TYPE_ERROR, v28, &v31, 0x2Eu);
    goto LABEL_69;
  }

  if (!v31.reportError)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBDE4();
    }

    goto LABEL_69;
  }

LABEL_26:
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v32 = 0u;
  memset(&v31, 0, sizeof(v31));
  snprintf(&v31, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
  result = (reportError)(&v31);
LABEL_70:
  v30 = *MEMORY[0x277D85DE8];
  return result;
}

void SparseMultiply(SparseOpaqueSubfactor_Double *a1, DenseMatrix_Double *a2, char *a3)
{
  v19 = *MEMORY[0x277D85DE8];
  if (!*(&a1->contents + 2))
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCCEC();
    }

    goto LABEL_23;
  }

  _SparseGetOptionsFromSymbolicFactor(v18, &a1->factor.symbolicFactorization);
  v6 = *&v18[40];
  v7 = 4;
  if (*&a2->attributes)
  {
    v8 = 0;
  }

  else
  {
    v8 = 4;
  }

  v9 = *(&a2->rowCount + v8);
  if ((*&a2->attributes & 1) == 0)
  {
    v7 = 0;
  }

  if (v9 <= 0)
  {
    if (*&v18[40])
    {
      memset(&v18[34], 0, 222);
      strcpy(v18, "XY must have non-zero dimension.\n");
LABEL_28:
      v6(v18);
      goto LABEL_29;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCD30();
    }

LABEL_23:
    _SparseTrap();
  }

  v10 = *(&a2->rowCount + v7);
  factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  v12 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  v13 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v12 >= v13)
  {
    v14 = v13;
  }

  else
  {
    v14 = v12;
  }

  if (v12 > v13)
  {
    v13 = v12;
  }

  if (*(&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40)
  {
    v16 = v13;
  }

  else
  {
    v16 = v14;
  }

  if (v10 != v16)
  {
    if (*&v18[40])
    {
      memset(v18, 0, sizeof(v18));
      snprintf(v18, 0x100uLL, "XY dimension (%d) must match maximum subfactor dimension (%d).\n", v10, v16);
      goto LABEL_28;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCD74();
    }

    goto LABEL_23;
  }

  _SparseMultiplySubfactor_Double(a1, 0, a2, a3);
LABEL_29:
  v17 = *MEMORY[0x277D85DE8];
}

void SparseMultiply(SparseOpaqueSubfactor_Double *a1, DenseMatrix_Double *a2, DenseMatrix_Double *a3, char *a4)
{
  v45 = *MEMORY[0x277D85DE8];
  if (!*(&a1->contents + 2))
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CCCEC();
    }

    goto LABEL_64;
  }

  _SparseGetOptionsFromSymbolicFactor(&v31, &a1->factor.symbolicFactorization);
  reportError = v31.reportError;
  attributes = a1->attributes;
  factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  v12 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v11 >= v12)
  {
    v13 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }

  else
  {
    v13 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }

  if (v11 <= v12)
  {
    v11 = v12;
  }

  if (*(&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40)
  {
    v15 = v11;
  }

  else
  {
    v15 = v13;
  }

  if (*&attributes)
  {
    v16 = v15;
  }

  else
  {
    v16 = v13;
  }

  if (*&attributes)
  {
    v17 = v13;
  }

  else
  {
    v17 = v15;
  }

  rowCount = a3->rowCount;
  if (a3->columnStride < a3->rowCount)
  {
    if (v31.reportError)
    {
      goto LABEL_26;
    }

    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBDE4();
    }

LABEL_64:
    _SparseTrap();
  }

  if (a2->columnStride >= a2->rowCount)
  {
    if (*&a3->attributes)
    {
      v19 = 4;
    }

    else
    {
      v19 = 0;
      rowCount = a3->columnCount;
    }

    if (*&a2->attributes)
    {
      v20 = 0;
    }

    else
    {
      v20 = 4;
    }

    v21 = *(&a2->rowCount + v20);
    v22 = *(&a3->rowCount + v19);
    if (*&a2->attributes)
    {
      v23 = 4;
    }

    else
    {
      v23 = 0;
    }

    v24 = *(&a2->rowCount + v23);
    if (rowCount == v21)
    {
      if (rowCount <= 0)
      {
        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          snprintf(&v31, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_27;
        }

        if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          sub_2367CBCDC();
        }

        goto LABEL_64;
      }

      if (v22 == v17)
      {
        if (v24 == v16)
        {
          _SparseMultiplySubfactor_Double(a1, a2, a3, a4);
          goto LABEL_65;
        }

        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          v28 = "X";
          goto LABEL_56;
        }

        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_64;
        }

        v31.control = 136316418;
        *&v31.orderMethod = "X";
        WORD2(v31.order) = 1024;
        *(&v31.order + 6) = v24;
        WORD1(v31.ignoreRowsAndColumns) = 1024;
        HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
        LOWORD(v31.malloc) = 2080;
        *(&v31.malloc + 2) = "subfactor dimension";
        WORD1(v31.free) = 1024;
        HIDWORD(v31.free) = v16;
        LOWORD(v31.reportError) = 1024;
        *(&v31.reportError + 2) = v17;
        v26 = MEMORY[0x277D86220];
        v27 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }

      else
      {
        if (v31.reportError)
        {
          v43 = 0u;
          v44 = 0u;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          v28 = "Y";
LABEL_56:
          snprintf(&v31, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v28);
          goto LABEL_27;
        }

        v29 = v22;
        if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
        {
          goto LABEL_64;
        }

        v31.control = 136316418;
        *&v31.orderMethod = "Y";
        WORD2(v31.order) = 1024;
        *(&v31.order + 6) = v29;
        WORD1(v31.ignoreRowsAndColumns) = 1024;
        HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
        LOWORD(v31.malloc) = 2080;
        *(&v31.malloc + 2) = "subfactor dimension";
        WORD1(v31.free) = 1024;
        HIDWORD(v31.free) = v16;
        LOWORD(v31.reportError) = 1024;
        *(&v31.reportError + 2) = v17;
        v26 = MEMORY[0x277D86220];
        v27 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
    }

    else
    {
      if (v31.reportError)
      {
        v43 = 0u;
        v44 = 0u;
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v32 = 0u;
        memset(&v31, 0, sizeof(v31));
        snprintf(&v31, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "Y");
        goto LABEL_27;
      }

      v25 = v22;
      if (!os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
      {
        goto LABEL_64;
      }

      v31.control = 136316418;
      *&v31.orderMethod = "Y";
      WORD2(v31.order) = 1024;
      *(&v31.order + 6) = v25;
      WORD1(v31.ignoreRowsAndColumns) = 1024;
      HIDWORD(v31.ignoreRowsAndColumns) = rowCount;
      LOWORD(v31.malloc) = 2080;
      *(&v31.malloc + 2) = "X";
      WORD1(v31.free) = 1024;
      HIDWORD(v31.free) = v24;
      LOWORD(v31.reportError) = 1024;
      *(&v31.reportError + 2) = v21;
      v26 = MEMORY[0x277D86220];
      v27 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    }

    _os_log_error_impl(&dword_2366B9000, v26, OS_LOG_TYPE_ERROR, v27, &v31, 0x2Eu);
    goto LABEL_64;
  }

  if (!v31.reportError)
  {
    if (os_log_type_enabled(MEMORY[0x277D86220], OS_LOG_TYPE_ERROR))
    {
      sub_2367CBD60();
    }

    goto LABEL_64;
  }

LABEL_26:
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v32 = 0u;
  memset(&v31, 0, sizeof(v31));
  snprintf(&v31, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
  (reportError)(&v31);
LABEL_65:
  v30 = *MEMORY[0x277D85DE8];
}