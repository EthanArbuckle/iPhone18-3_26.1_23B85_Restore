void sub_1DE70B56C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15)
{
  if (a2)
  {
    applesauce::CF::StringRef::~StringRef(&a15);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1DE70B2B0);
  }

  _Unwind_Resume(exception_object);
}

uint64_t ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_221(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(a1 + 40);
  if (v3)
  {
    v4 = *(v3 + 16);
  }

  else
  {
    v4 = 0;
  }

  return (*(*v2 + 776))(v2, v4, *(a1 + 56), *(a1 + 48), *(a1 + 60));
}

void sub_1DE70B6A4(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_223(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(a1 + 40);
  if (v3)
  {
    v4 = *(v3 + 16);
  }

  else
  {
    v4 = 0;
  }

  return (*(*v2 + 784))(v2, v4, *(a1 + 48));
}

void sub_1DE70B720(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_225(uint64_t a1)
{
  result = (*(**(a1 + 40) + 824))(*(a1 + 40), *(a1 + 56), **(a1 + 48));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE70B7A4(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t __Block_byref_object_copy__227(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

void ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_229(uint64_t a1)
{
  v2 = (*(**(a1 + 40) + 408))(*(a1 + 40));
  v4 = *(*(a1 + 32) + 8);
  v5 = *(v4 + 40);
  *(v4 + 40) = v2;

  HALS_ObjectMap::ReleaseObject(v5, v3);
}

uint64_t ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_2_231(uint64_t a1)
{
  result = HALS_Device::_SetDSPDescription(*(a1 + 40), **(a1 + 48), *(*(a1 + 56) + 4));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE70B8A8(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_3(uint64_t a1)
{
  result = HALS_Device::_SetDSPDescription(*(a1 + 40), **(a1 + 48), *(*(a1 + 56) + 4));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE70B908(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

BOOL HALS_Device::SetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,void const*,unsigned int,void const*,HALS_Client *)::$_0::operator()(uint64_t a1)
{
  v2 = *a1;
  if (!AMCP::Feature_Flags::use_ahal_dsp_hosting_lib(0, 0))
  {
    return 0;
  }

  v3 = **(a1 + 8);
  v4 = v3 ? *(v3 + 16) : 0;
  HALS_Device::DSP_Config_Properties(&v11, v2, v4);
  v5 = v11;
  if (v11 && (*(*v11 + 24))(v11, *(a1 + 16)) && !(*(*v5 + 48))(v5, *(a1 + 16), **(a1 + 24), **(a1 + 32), **(a1 + 40), **(a1 + 48)))
  {
    v7 = 0;
  }

  else
  {
    HALS_Device::DSP_Instance_Properties(&v9, v2, **(a1 + 8), **(a1 + 16), *(*(a1 + 16) + 8) | 0x100000000);
    v6 = v9;
    v7 = !v9 || !(*(*v9 + 24))(v9, *(a1 + 16)) || (*(*v6 + 48))(v6, *(a1 + 16), **(a1 + 24), **(a1 + 32), **(a1 + 40), **(a1 + 48));
    if (v10)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v10);
    }
  }

  if (v12)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v12);
  }

  return !v7;
}

void sub_1DE70BAEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a10);
  }

  if (a12)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a12);
  }

  _Unwind_Resume(exception_object);
}

void ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_234(uint64_t a1, const BOOL *a2)
{
  v3 = *(a1 + 64);
  v4 = *(a1 + 40);
  v5 = *(*(a1 + 48) + 8);
  v6 = *(a1 + 56);
  v7 = *(a1 + 60);
  if (AMCP::Feature_Flags::run_hybrid_hal(a1, a2))
  {
    v13[0] = 0;
    v13[1] = 0;
    HALS_System::GetInstance(&v14, 0, v13);
    v8 = *(v14 + 1744);
    os_unfair_lock_lock(v8 + 4);
    os_unfair_lock_unlock(v8 + 4);
    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v15);
    }

    v9 = 0;
  }

  else
  {
    v10 = (*(*v4 + 408))(v4);
    v12 = v10;
    if (v10)
    {
      LOBYTE(v3) = (*(*v10 + 560))(v10, v3, v5, v6, v7);
    }

    HALS_ObjectMap::ReleaseObject(v12, v11);
    v9 = (v12 != 0) & v3;
  }

  *(*(*(a1 + 32) + 8) + 24) = v9;
}

void sub_1DE70BC60(void *a1, HALS_Object *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22)
{
  HALS_ObjectMap::ReleaseObject(v22, a2);
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_236(uint64_t a1, const BOOL *a2)
{
  v3 = *(a1 + 72);
  v4 = *(a1 + 40);
  v5 = *(*(a1 + 48) + 8);
  v6 = *(a1 + 64);
  v7 = *(a1 + 68);
  v8 = *(a1 + 56);
  if (AMCP::Feature_Flags::run_hybrid_hal(a1, a2))
  {
    v14[0] = 0;
    v14[1] = 0;
    HALS_System::GetInstance(&v15, 0, v14);
    v9 = *(v15 + 1744);
    os_unfair_lock_lock(v9 + 4);
    os_unfair_lock_unlock(v9 + 4);
    if (v16)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v16);
    }

    v10 = 0;
  }

  else
  {
    v11 = (*(*v4 + 408))(v4);
    v13 = v11;
    if (v11)
    {
      LOBYTE(v3) = (*(*v11 + 528))(v11, v3, v5, v6, v7, v8);
    }

    HALS_ObjectMap::ReleaseObject(v13, v12);
    v10 = (v13 != 0) & v3;
  }

  *(*(*(a1 + 32) + 8) + 24) = v10;
}

void sub_1DE70BDF4(void *a1, HALS_Object *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22)
{
  HALS_ObjectMap::ReleaseObject(v22, a2);
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t HALS_Device::GetNumberStreamsExcludingReferenceStreams(HALS_Device *this, char a2)
{
  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v5[0] = MEMORY[0x1E69E9820];
  v5[1] = 0x40000000;
  v5[2] = ___ZNK11HALS_Device41GetNumberStreamsExcludingReferenceStreamsEb_block_invoke;
  v5[3] = &unk_1E8678918;
  v5[4] = &v7;
  v5[5] = this;
  v6 = a2;
  v2 = (*(*this + 64))(this);
  HALB_CommandGate::ExecuteCommand(v2, v5);
  v3 = *(v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v3;
}

void ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_241(uint64_t a1)
{
  v17[1] = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 40);
  v3 = *(a1 + 56);
  v4 = *(a1 + 60);
  if (v3 == 2)
  {
    v7 = *(a1 + 48);
    LODWORD(v17[0]) = 3;
    std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v13, v17, 1);
    v14 = 2;
    std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v12, &v14, 1);
    *(*(*(a1 + 32) + 8) + 24) = HALS_Device::_ConfigureDSPTypesForClient(v2, v4, v7, v13, v12);
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v12[1]);
    v6 = v13[1];
  }

  else
  {
    v5 = *(a1 + 48);
    if (v3 == 1)
    {
      LODWORD(v17[0]) = 2;
      std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v16, v17, 1);
      v14 = 3;
      std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v15, &v14, 1);
      *(*(*(a1 + 32) + 8) + 24) = HALS_Device::_ConfigureDSPTypesForClient(v2, v4, v5, v16, v15);
      std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v15[1]);
      v6 = v16[1];
    }

    else
    {
      v11[0] = 0;
      v11[1] = 0;
      v10 = v11;
      v17[0] = 0x200000003;
      std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v9, v17, 2);
      *(*(*(a1 + 32) + 8) + 24) = HALS_Device::_ConfigureDSPTypesForClient(v2, v4, v5, &v10, v9);
      std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v9[1]);
      v6 = v11[0];
    }
  }

  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v6);
  v8 = *MEMORY[0x1E69E9840];
}

void sub_1DE70C0D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20)
{
  if (a2)
  {
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a17);
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a20);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1DE70C0A8);
  }

  _Unwind_Resume(exception_object);
}

void ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_244(uint64_t a1)
{
  v17[1] = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 40);
  v3 = *(a1 + 56);
  v4 = *(a1 + 60);
  if (v3 == 2)
  {
    v7 = *(a1 + 48);
    LODWORD(v17[0]) = 5;
    std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v13, v17, 1);
    v14 = 4;
    std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v12, &v14, 1);
    *(*(*(a1 + 32) + 8) + 24) = HALS_Device::_ConfigureDSPTypesForClient(v2, v4, v7, v13, v12);
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v12[1]);
    v6 = v13[1];
  }

  else
  {
    v5 = *(a1 + 48);
    if (v3 == 1)
    {
      LODWORD(v17[0]) = 4;
      std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v16, v17, 1);
      v14 = 5;
      std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v15, &v14, 1);
      *(*(*(a1 + 32) + 8) + 24) = HALS_Device::_ConfigureDSPTypesForClient(v2, v4, v5, v16, v15);
      std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v15[1]);
      v6 = v16[1];
    }

    else
    {
      v11[0] = 0;
      v11[1] = 0;
      v10 = v11;
      v17[0] = 0x400000005;
      std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v9, v17, 2);
      *(*(*(a1 + 32) + 8) + 24) = HALS_Device::_ConfigureDSPTypesForClient(v2, v4, v5, &v10, v9);
      std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v9[1]);
      v6 = v11[0];
    }
  }

  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v6);
  v8 = *MEMORY[0x1E69E9840];
}

void sub_1DE70C31C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20)
{
  if (a2)
  {
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a17);
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a20);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1DE70C2ECLL);
  }

  _Unwind_Resume(exception_object);
}

void ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_247(uint64_t a1)
{
  v2 = *(a1 + 60);
  v4 = *(a1 + 40);
  v3 = *(a1 + 48);
  if (*(a1 + 56) == 1)
  {
    v11 = 6;
    std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v12, &v11, 1);
    v10[0] = 0;
    v10[1] = 0;
    v9 = v10;
    *(*(*(a1 + 32) + 8) + 24) = HALS_Device::_ConfigureDSPTypesForClient(v4, v2, v3, v12, &v9);
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v10[0]);
    v5 = v12[1];
  }

  else
  {
    v8[0] = 0;
    v8[1] = 0;
    v7 = v8;
    v11 = 6;
    std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v6, &v11, 1);
    *(*(*(a1 + 32) + 8) + 24) = HALS_Device::_ConfigureDSPTypesForClient(v4, v2, v3, &v7, v6);
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v6[1]);
    v5 = v8[0];
  }

  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v5);
}

void sub_1DE70C4B0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14)
{
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a11);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a14);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE70C49CLL);
}

uint64_t *___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_251(uint64_t *result)
{
  v1 = result;
  v70 = *MEMORY[0x1E69E9840];
  v2 = *(result[5] + 632);
  if (v2)
  {
    if (*(result[6] + 4) != 1768845428)
    {
      v9 = 0;
      LOWORD(v10) = 0;
LABEL_94:
      v8 = v9 | (v10 << 8);
      v7 = *(v1[4] + 8);
      goto LABEL_95;
    }

    v3 = result[7];
    v4 = *result[8];
    if (v3)
    {
      v5 = *(v3 + 16);
      v6 = *&(*v2)[9].__m_.__opaque[48];
      if (v6)
      {
        HALS_Device_HostedDSP::RationalizeDSPOffloadsForClient(&v56, v6, 1, result[7]);
LABEL_12:
        v12 = *v2;
        std::mutex::lock(*v2 + 11);
        v13 = HALS_Device_HostedDSP_ClientInfo::find(v12[10].__m_.__opaque, v3, 1);
        if (!v13)
        {
          goto LABEL_16;
        }

        v14 = v13 + 4;
        v15 = v13[4];
        if (!v15)
        {
          operator new();
        }

        DSP_Host_OffloadDictionary::get_offload_id_list(v61, v15);
        DSP_Host_OffloadDictionary::deep_copy_from(v15, v4);
        v57 = 0;
        v58 = 0;
        v59 = 0;
        std::vector<std::string>::__init_with_size[abi:ne200100]<std::string*,std::string*>(&v57, *v61, *&v61[8], 0xAAAAAAAAAAAAAAABLL * ((*&v61[8] - *v61) >> 3));
        has_same_ids = DSP_Host_OffloadDictionary::has_same_ids(v15, &v57);
        v60 = &v57;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v60);
        v60 = v61;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v60);
        if (!has_same_ids)
        {
          v57 = 0;
          v58 = 0;
          HALS_System::GetInstance(v61, 0, &v57);
          v17 = *(*v61 + 1800);
          if (v17)
          {
            atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
            v18 = HALS_DSPDeveloperPreferences::sInitValues;
            std::__shared_weak_count::__release_shared[abi:ne200100](v17);
          }

          else
          {
            v18 = HALS_DSPDeveloperPreferences::sInitValues;
          }

          v19 = *&v61[8];
          if (*&v61[8])
          {
            std::__shared_weak_count::__release_shared[abi:ne200100](*&v61[8]);
          }

          if (v18 < 0)
          {
            goto LABEL_40;
          }

          v20 = *v14;
          v21 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v21 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v19);
          }

          v23 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v22 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v22)
          {
            atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
            v24 = *v23;
            std::__shared_weak_count::__release_shared[abi:ne200100](v22);
          }

          else
          {
            v24 = *v23;
          }

          if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
LABEL_40:
            v9 = 1;
          }

          else
          {
            v55 = v5;
            v25 = 0;
            v26 = 0;
            v27 = 47;
            do
            {
              v28 = &aLibraryCachesC_39[v25];
              if (v27 == 47)
              {
                v26 = &aLibraryCachesC_39[v25];
              }

              v27 = v28[1];
              if (!v28[1])
              {
                break;
              }
            }

            while (v25++ < 0xFFF);
            if (v26)
            {
              v30 = v26 + 1;
            }

            else
            {
              v30 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device_HostedDSP_ClientInfo.cpp";
            }

            if (v3)
            {
              v31 = *(v3 + 16);
            }

            else
            {
              v31 = 0;
            }

            v32 = *&v12[10].__m_.__opaque[8];
            DSP_Host_OffloadDictionary::get_debug_string(&v57, *v14);
            if (v59 >= 0)
            {
              v33 = &v57;
            }

            else
            {
              v33 = v57;
            }

            *v61 = 136316418;
            *&v61[4] = v30;
            *&v61[12] = 1024;
            *&v61[14] = 218;
            v62 = 1024;
            v63 = v31;
            v64 = 1024;
            v65 = v32;
            v66 = 2048;
            v67 = v20;
            v68 = 2080;
            v69 = v33;
            _os_log_impl(&dword_1DE1F9000, v24, OS_LOG_TYPE_DEFAULT, "%32s:%-5d [hal_dsp][offloads][bypass] (Client ID: %d) (Device ID: %d) (Storage: %p) is bypassing %s", v61, 0x32u);
            if (SHIBYTE(v59) < 0)
            {
              operator delete(v57);
            }

            v9 = 1;
            v5 = v55;
          }
        }

        else
        {
LABEL_16:
          v9 = 0;
        }

        std::mutex::unlock(v12 + 11);
        v34 = *&(*v2)[9].__m_.__opaque[48];
        if (v34)
        {
          HALS_Device_HostedDSP::RationalizeDSPOffloadsForClient(&v60, v34, 1, v3);
          v35 = v60;
        }

        else
        {
          v35 = 0;
          v60 = 0;
        }

        v36 = v56;
        if (v56)
        {
          if (v35)
          {
            v37 = v35[2];
            if (v37)
            {
              if (CFDictionaryGetCount(v37))
              {
                if (!DSP_Host_OffloadDictionary::has_all_id(v35))
                {
                  v38 = *(v36 + 2);
                  if (v38)
                  {
                    if (CFDictionaryGetCount(v38) && !DSP_Host_OffloadDictionary::has_all_id(v36))
                    {
                      has_all_id = DSP_Host_OffloadDictionary::has_same_ids(v35, v36);
LABEL_67:
                      v10 = !has_all_id;
LABEL_69:
                      v57 = 0;
                      v58 = 0;
                      HALS_System::GetInstance(v61, 0, &v57);
                      v42 = *(*v61 + 1800);
                      if (v42)
                      {
                        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
                        v43 = HALS_DSPDeveloperPreferences::sInitValues;
                        std::__shared_weak_count::__release_shared[abi:ne200100](v42);
                      }

                      else
                      {
                        v43 = HALS_DSPDeveloperPreferences::sInitValues;
                      }

                      v44 = *&v61[8];
                      if (*&v61[8])
                      {
                        std::__shared_weak_count::__release_shared[abi:ne200100](*&v61[8]);
                      }

                      if ((v43 & 0x80000000) == 0)
                      {
                        v45 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
                        if ((v45 & 1) == 0)
                        {
                          AMCP::Log::AMCP_Scope_Registry::initialize(v44);
                        }

                        v47 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
                        v46 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
                        if (v46)
                        {
                          atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
                          v48 = *v47;
                          std::__shared_weak_count::__release_shared[abi:ne200100](v46);
                        }

                        else
                        {
                          v48 = *v47;
                        }

                        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                        {
                          v49 = v5;
                          v50 = *&(*v2)->__m_.__opaque[8];
                          if (v10)
                          {
                            v51 = "";
                          }

                          else
                          {
                            v51 = "_NO_";
                          }

                          if (v60)
                          {
                            v52 = v60[2];
                            v53 = "NOPE, NO OFFLOADS";
                            if (v52 && CFDictionaryGetCount(v52))
                            {
                              v53 = "WITH OFFLOADS";
                            }
                          }

                          else
                          {
                            v53 = "NOPE, NO OFFLOADS";
                          }

                          *v61 = 136316418;
                          *&v61[4] = "HALS_Device_HostedDSP.cpp";
                          *&v61[12] = 1024;
                          *&v61[14] = 219;
                          v62 = 1024;
                          v63 = v49;
                          v64 = 1024;
                          v65 = v50;
                          v66 = 2080;
                          v67 = v51;
                          v68 = 2080;
                          v69 = v53;
                          _os_log_impl(&dword_1DE1F9000, v48, OS_LOG_TYPE_DEFAULT, "%32s:%-5d [hal_dsp][offloads][bypass] (Client ID: %d) (Device ID: %d) Bypass change causes %sPROCESSING change = %s", v61, 0x32u);
                        }
                      }

                      if (v10)
                      {
                        HALS_Device_HostedDSP_ClientInfo::get_dsp_types_for_client(v61, (*v2)[10].__m_.__opaque, 1, v3);
                        (*((*v2)->__m_.__sig + 968))(*v2, 1, v3, v61);
                        std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(*&v61[8]);
                      }

                      std::unique_ptr<DSP_Host_OffloadDictionary>::reset[abi:ne200100](&v60, 0);
                      result = std::unique_ptr<DSP_Host_OffloadDictionary>::reset[abi:ne200100](&v56, 0);
                      goto LABEL_94;
                    }
                  }
                }
              }
            }
          }

          else
          {
            v41 = v56[2];
            if (v41 && CFDictionaryGetCount(v41))
            {
              has_all_id = DSP_Host_OffloadDictionary::has_all_id(v36);
              goto LABEL_67;
            }
          }
        }

        else if (v35)
        {
          v40 = v35[2];
          if (v40)
          {
            if (CFDictionaryGetCount(v40))
            {
              has_all_id = DSP_Host_OffloadDictionary::has_all_id(v35);
              goto LABEL_67;
            }
          }
        }

        v10 = 0;
        goto LABEL_69;
      }
    }

    else
    {
      v11 = *&(*v2)[9].__m_.__opaque[48];
      if (v11)
      {
        HALS_Device_HostedDSP::RationalizeDSPOffloadsForClient(&v56, v11, 1, 0);
        v5 = 0;
        goto LABEL_12;
      }

      v5 = 0;
    }

    v56 = 0;
    goto LABEL_12;
  }

  v7 = *(result[4] + 8);
  v8 = *(v7 + 40);
LABEL_95:
  *(v7 + 40) = v8;
  v54 = *MEMORY[0x1E69E9840];
  return result;
}

void ___ZN11HALS_Device15SetPropertyDataEjRK26AudioObjectPropertyAddressjPKvjS4_P11HALS_Client_block_invoke_254(uint64_t a1)
{
  v87 = *MEMORY[0x1E69E9840];
  v2 = *(*(a1 + 40) + 632);
  if (!v2)
  {
    *(*(*(a1 + 32) + 8) + 24) = 0;
    goto LABEL_106;
  }

  v3 = *(a1 + 64);
  v4 = *(a1 + 65);
  v5 = *(a1 + 48);
  v6 = *(a1 + 56);
  std::string::basic_string[abi:ne200100]<0>(&v69, "content creation recording");
  if (!v3)
  {
    goto LABEL_103;
  }

  v7 = *v2;
  v8 = HALS_Device_HostedDSP_ClientInfo::find(*v2 + 648, v5, 1);
  if (!v8)
  {
    goto LABEL_103;
  }

  v9 = v8 + 5;
  v10 = v8[5];
  if (!v10)
  {
    operator new();
  }

  if (v4)
  {
    DSP_Host_OffloadDictionary::get_offload_id_list(buf, v10);
    v72 = 0;
    if (v6)
    {
      v11 = PropertyListDeepImmutableCopy(v6);
      v12 = v11;
      __p = v11;
      if (v11)
      {
        v13 = CFGetTypeID(v11);
        if (v13 != CFDictionaryGetTypeID())
        {
          exception = __cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Could not construct");
          __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
        }
      }
    }

    else
    {
      v21 = CFDictionaryCreate(*MEMORY[0x1E695E478], 0, 0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
      v12 = v21;
      __p = v21;
      if (v21)
      {
        v22 = CFGetTypeID(v21);
        if (v22 != CFDictionaryGetTypeID())
        {
          v66 = __cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v66, "Could not construct");
          __cxa_throw(v66, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
        }
      }
    }

    v72 = v12;
    v23 = *(v10 + 16);
    if (v23)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v23);
      v25 = MutableCopy;
      __p = MutableCopy;
      if ((v71 & 0x80u) == 0)
      {
        v26 = &v69;
      }

      else
      {
        v26 = v69;
      }

      if (v26)
      {
        if ((v71 & 0x80u) == 0)
        {
          v27 = v71;
        }

        else
        {
          v27 = v70;
        }

        v28 = CFStringCreateWithBytes(0, v26, v27, 0x8000100u, 0);
        p_isa = &v28->isa;
        if (!v28)
        {
          v63 = __cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v63, "Could not construct");
          __cxa_throw(v63, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
        }

        mcp_applesauce::CF::Dictionary_Builder::add_value<applesauce::CF::StringRef,applesauce::CF::DictionaryRef>(v25, v28, v12);
        CFRelease(v28);
      }

      else
      {
        p_isa = 0;
        mcp_applesauce::CF::Dictionary_Builder::add_value<applesauce::CF::StringRef,applesauce::CF::DictionaryRef>(MutableCopy, 0, v12);
      }

      mcp_applesauce::CF::Dictionary_Builder::get_dictionary(&cf, v25);
      v37 = cf;
      cf = 0;
      p_isa = v37;
      if (v37)
      {
        v38 = CFGetTypeID(v37);
        if (v38 != CFDictionaryGetTypeID())
        {
          v65 = __cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v65, "Could not construct");
          __cxa_throw(v65, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
        }
      }

      v39 = *(v10 + 16);
      *(v10 + 16) = v37;
      p_isa = v39;
      if (v39)
      {
        CFRelease(v39);
      }

      if (cf)
      {
        CFRelease(cf);
      }

      if (!v25)
      {
        goto LABEL_71;
      }
    }

    else
    {
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
      v25 = Mutable;
      __p = Mutable;
      if ((v71 & 0x80u) == 0)
      {
        v30 = &v69;
      }

      else
      {
        v30 = v69;
      }

      if (v30)
      {
        if ((v71 & 0x80u) == 0)
        {
          v31 = v71;
        }

        else
        {
          v31 = v70;
        }

        v32 = CFStringCreateWithBytes(0, v30, v31, 0x8000100u, 0);
        p_isa = &v32->isa;
        if (!v32)
        {
          v67 = __cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v67, "Could not construct");
          __cxa_throw(v67, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
        }

        mcp_applesauce::CF::Dictionary_Builder::add_value<applesauce::CF::StringRef,applesauce::CF::DictionaryRef>(v25, v32, v12);
        CFRelease(v32);
      }

      else
      {
        p_isa = 0;
        mcp_applesauce::CF::Dictionary_Builder::add_value<applesauce::CF::StringRef,applesauce::CF::DictionaryRef>(Mutable, 0, v12);
      }

      mcp_applesauce::CF::Dictionary_Builder::get_dictionary(&cf, v25);
      v40 = cf;
      cf = 0;
      p_isa = v40;
      if (v40)
      {
        v41 = CFGetTypeID(v40);
        if (v41 != CFDictionaryGetTypeID())
        {
          v68 = __cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v68, "Could not construct");
          __cxa_throw(v68, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
        }
      }

      v42 = *(v10 + 16);
      *(v10 + 16) = v40;
      p_isa = v42;
      if (v42)
      {
        CFRelease(v42);
      }

      if (cf)
      {
        CFRelease(cf);
      }

      if (!v25)
      {
        goto LABEL_71;
      }
    }

    CFRelease(v25);
LABEL_71:
    __p = 0;
    v74 = 0;
    v75 = 0;
    std::vector<std::string>::__init_with_size[abi:ne200100]<std::string*,std::string*>(&__p, *buf, *&buf[8], 0xAAAAAAAAAAAAAAABLL * ((*&buf[8] - *buf) >> 3));
    has_same_ids = DSP_Host_OffloadDictionary::has_same_ids(v10, &__p);
    p_isa = &__p;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&p_isa);
    if (v12)
    {
      CFRelease(v12);
    }

    goto LABEL_73;
  }

  DSP_Host_OffloadDictionary::get_offload_id_list(buf, v10);
  v15 = *(v10 + 16);
  if (v15)
  {
    v16 = CFDictionaryCreateMutableCopy(0, 0, v15);
    v17 = v16;
    __p = v16;
    if ((v71 & 0x80u) == 0)
    {
      v18 = &v69;
    }

    else
    {
      v18 = v69;
    }

    if (v18)
    {
      if ((v71 & 0x80u) == 0)
      {
        v19 = v71;
      }

      else
      {
        v19 = v70;
      }

      v20 = CFStringCreateWithBytes(0, v18, v19, 0x8000100u, 0);
      p_isa = &v20->isa;
      if (!v20)
      {
        v62 = __cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v62, "Could not construct");
        __cxa_throw(v62, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
      }

      mcp_applesauce::CF::Dictionary_Builder::remove_value<applesauce::CF::StringRef>(v17, v20);
      CFRelease(v20);
    }

    else
    {
      p_isa = 0;
      mcp_applesauce::CF::Dictionary_Builder::remove_value<applesauce::CF::StringRef>(v16, 0);
    }

    mcp_applesauce::CF::Dictionary_Builder::get_dictionary(&cf, v17);
    v33 = cf;
    cf = 0;
    p_isa = v33;
    if (v33)
    {
      v34 = CFGetTypeID(v33);
      if (v34 != CFDictionaryGetTypeID())
      {
        v64 = __cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v64, "Could not construct");
        __cxa_throw(v64, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
      }
    }

    v35 = *(v10 + 16);
    *(v10 + 16) = v33;
    p_isa = v35;
    if (v35)
    {
      CFRelease(v35);
    }

    if (cf)
    {
      CFRelease(cf);
    }

    if (v17)
    {
      CFRelease(v17);
    }
  }

  __p = 0;
  v74 = 0;
  v75 = 0;
  std::vector<std::string>::__init_with_size[abi:ne200100]<std::string*,std::string*>(&__p, *buf, *&buf[8], 0xAAAAAAAAAAAAAAABLL * ((*&buf[8] - *buf) >> 3));
  has_same_ids = DSP_Host_OffloadDictionary::has_same_ids(v10, &__p);
  p_isa = &__p;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&p_isa);
LABEL_73:
  p_isa = buf;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&p_isa);
  __p = 0;
  v74 = 0;
  HALS_System::GetInstance(buf, 0, &__p);
  v43 = *(*buf + 1800);
  if (v43)
  {
    atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
    v44 = HALS_DSPDeveloperPreferences::sInitValues;
    std::__shared_weak_count::__release_shared[abi:ne200100](v43);
  }

  else
  {
    v44 = HALS_DSPDeveloperPreferences::sInitValues;
  }

  v45 = *&buf[8];
  if (*&buf[8])
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](*&buf[8]);
  }

  if ((v44 & 0x80000000) == 0)
  {
    v46 = *v9;
    v47 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v47 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v45);
    }

    v49 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v48 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v48)
    {
      atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
      v50 = *v49;
      std::__shared_weak_count::__release_shared[abi:ne200100](v48);
    }

    else
    {
      v50 = *v49;
    }

    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      v51 = 0;
      v52 = 0;
      v53 = 47;
      do
      {
        v54 = &aLibraryCachesC_39[v51];
        if (v53 == 47)
        {
          v52 = &aLibraryCachesC_39[v51];
        }

        v53 = v54[1];
        if (!v54[1])
        {
          break;
        }
      }

      while (v51++ < 0xFFF);
      if (v52)
      {
        v56 = v52 + 1;
      }

      else
      {
        v56 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device_HostedDSP_ClientInfo.cpp";
      }

      if (v5)
      {
        v57 = *(v5 + 16);
      }

      else
      {
        v57 = 0;
      }

      v58 = *(v7 + 656);
      DSP_Host_OffloadDictionary::get_debug_string(&__p, *v9);
      if (v75 >= 0)
      {
        p_p = &__p;
      }

      else
      {
        p_p = __p;
      }

      *buf = 136316418;
      *&buf[4] = v56;
      *&buf[12] = 1024;
      *&buf[14] = 494;
      v79 = 1024;
      v80 = v57;
      v81 = 1024;
      v82 = v58;
      v83 = 2048;
      v84 = v46;
      v85 = 2080;
      v86 = p_p;
      _os_log_impl(&dword_1DE1F9000, v50, OS_LOG_TYPE_DEFAULT, "%32s:%-5d [hal_dsp][content creation][settings] (Client ID: %d) (Device ID: %d) (Storage: %p) settings: %s", buf, 0x32u);
      if (SHIBYTE(v75) < 0)
      {
        operator delete(__p);
      }
    }
  }

  if (has_same_ids)
  {
LABEL_103:
    v60 = 0;
    goto LABEL_104;
  }

  HALS_Device_HostedDSP_ClientInfo::get_dsp_types_for_client(buf, *v2 + 648, 1, v5);
  (*(**v2 + 968))(*v2, 1, v5, buf);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(*&buf[8]);
  v60 = 1;
LABEL_104:
  *(*(*(a1 + 32) + 8) + 24) = v60;
  if (v71 < 0)
  {
    operator delete(v69);
  }

LABEL_106:
  v61 = *MEMORY[0x1E69E9840];
}

void sub_1DE70D5CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16, const void *a17, uint64_t a18, uint64_t a19, const void *a20, char *a21, char a22, uint64_t a23)
{
  if (a2)
  {
    __cxa_free_exception(v23);
    applesauce::CF::ObjectRef<__CFDictionary const*>::~ObjectRef(&a21);
    applesauce::CF::DictionaryRef::~DictionaryRef(&a20);
    mcp_applesauce::CF::Dictionary_Builder::~Dictionary_Builder(&a17);
    applesauce::CF::DictionaryRef::~DictionaryRef(&a16);
    a21 = &a22;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&a21);
    if (a15 < 0)
    {
      operator delete(__p);
    }

    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1DE70D388);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_Device::_ConfigureDSPTypesForClient(std::mutex *a1, const BOOL *a2, uint64_t a3, uint64_t a4, void *a5)
{
  v52 = *MEMORY[0x1E69E9840];
  if ((AMCP::Feature_Flags::force_mock_dsp_type(0, a2) & 1) == 0 && (AMCP::Feature_Flags::allow_adm_dsp_spatial(0, v10) & 1) == 0)
  {
    v11 = std::__tree<DSP_Host_Types::AudioProcessingType>::__erase_unique<DSP_Host_Types::AudioProcessingType>(a4, 4u);
    v12 = std::__tree<DSP_Host_Types::AudioProcessingType>::__erase_unique<DSP_Host_Types::AudioProcessingType>(a4, 5u);
    if ((v12 + v11))
    {
      v13 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v13 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(v12);
      }

      v15 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v14 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        v16 = *v15;
        std::__shared_weak_count::__release_shared[abi:ne200100](v14);
      }

      else
      {
        v16 = *v15;
      }

      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf.mSampleRate) = 136315394;
        *(&buf.mSampleRate + 4) = "HALS_Device.cpp";
        LOWORD(buf.mFormatFlags) = 1024;
        *(&buf.mFormatFlags + 2) = 5938;
        _os_log_impl(&dword_1DE1F9000, v16, OS_LOG_TYPE_INFO, "%32s:%-5d [hal_dsp] Spatial is disabled by feature flag.", &buf, 0x12u);
      }
    }
  }

  if (*(a4 + 16) || a5[2])
  {
    memset(&buf, 0, sizeof(buf));
    v17 = (*(a1->__m_.__sig + 600))(a1, a2, 0, 0);
    if (v17)
    {
      HALS_Stream::GetCurrentVirtualFormat(v17, &buf);
    }

    v49 = 0;
    v50 = 0;
    v48 = &v49;
    std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](&v46, a4);
    std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](&v44, a5);
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v49);
    v49 = 0;
    v50 = 0;
    v48 = &v49;
    std::mutex::lock(a1 + 11);
    v18 = HALS_Device_HostedDSP_ClientInfo::find(a1[10].__m_.__opaque, a3, v47[1] != 0);
    v19 = v18;
    if (!v18)
    {
      goto LABEL_47;
    }

    v20 = 6;
    if (a2)
    {
      v20 = 0;
    }

    v21 = &v18[v20];
    v22 = v46;
    if (v46 == v47)
    {
      v23 = 0;
    }

    else
    {
      v23 = 0;
      do
      {
        v24 = std::__tree<DSP_Host_Types::AudioProcessingType>::__emplace_unique_key_args<DSP_Host_Types::AudioProcessingType,DSP_Host_Types::AudioProcessingType const&>(v21, *(v22 + 7));
        v25 = v22[1];
        if (v25)
        {
          do
          {
            v26 = v25;
            v25 = *v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            v26 = v22[2];
            v27 = *v26 == v22;
            v22 = v26;
          }

          while (!v27);
        }

        v23 |= v24;
        v22 = v26;
      }

      while (v26 != v47);
    }

    v43 = v19;
    v28 = v44;
    if (v44 != v45)
    {
      do
      {
        v29 = std::__tree<DSP_Host_Types::AudioProcessingType>::__erase_unique<DSP_Host_Types::AudioProcessingType>(v21, *(v28 + 7)) != 0;
        v30 = v28[1];
        if (v30)
        {
          do
          {
            v31 = v30;
            v30 = *v30;
          }

          while (v30);
        }

        else
        {
          do
          {
            v31 = v28[2];
            v27 = *v31 == v28;
            v28 = v31;
          }

          while (!v27);
        }

        v23 |= v29;
        v28 = v31;
      }

      while (v31 != v45);
    }

    if (v23)
    {
      v32 = *v21;
      if (*v21 == (v21 + 1))
      {
        v37 = 0;
        v33 = v43;
      }

      else
      {
        v33 = v43;
        while (1)
        {
          v34 = *(v32 + 7) - 2;
          if (v34 < 9 && ((0x14Fu >> v34) & 1) != 0)
          {
            break;
          }

          v35 = v32[1];
          if (v35)
          {
            do
            {
              v36 = v35;
              v35 = *v35;
            }

            while (v35);
          }

          else
          {
            do
            {
              v36 = v32[2];
              v27 = *v36 == v32;
              v32 = v36;
            }

            while (!v27);
          }

          v32 = v36;
          if (v36 == (v21 + 1))
          {
            v37 = 0;
            goto LABEL_51;
          }
        }

        v37 = 1;
      }

LABEL_51:
      if ((AMCP::Feature_Flags::use_ahal_dsp_hosting_lib(0, 0) & 1) == 0)
      {
        if (a2)
        {
          v39 = 24;
        }

        else
        {
          v39 = 72;
        }

        v40 = *(v33 + v39);
        if (v37)
        {
          if (!v40)
          {
            operator new();
          }
        }

        else if (v40)
        {
          HALS_Device_HostedDSP_ClientInfo::PerClientInfo::deactivate_stream(v33, a2);
        }
      }

      if (v21 != &v48)
      {
        std::__tree<DSP_Host_Types::AudioProcessingType>::__assign_multi<std::__tree_const_iterator<DSP_Host_Types::AudioProcessingType,std::__tree_node<DSP_Host_Types::AudioProcessingType,void *> *,long>>(&v48, *v21, v21 + 1);
      }

      v38 = 1;
    }

    else
    {
LABEL_47:
      v38 = 0;
    }

    std::mutex::unlock(a1 + 11);
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v45[0]);
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v47[0]);
    if (v38)
    {
      (*(a1->__m_.__sig + 968))(a1, a2, a3, &v48);
    }

    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v49);
  }

  else
  {
    v38 = 0;
  }

  v41 = *MEMORY[0x1E69E9840];
  return v38;
}

void sub_1DE70DF10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, void *__p, uint64_t a25)
{
  MEMORY[0x1E12C1730](v26, 0x10F1C4094BD800CLL);
  std::mutex::unlock(v25 + 11);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a16);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a19);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a22);
  _Unwind_Resume(a1);
}

void ___ZN11HALS_Device35SetDSPVirtualChannelLayoutForClientEbP11HALS_ClientPK18AudioChannelLayout_block_invoke(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (v1 && (*(a1 + 56) & 1) == 0)
  {
    v3 = *(a1 + 32);
    v2 = *(a1 + 40);
    std::mutex::lock(v3 + 11);
    v4 = HALS_Device_HostedDSP_ClientInfo::find(v3[10].__m_.__opaque, v2, 1);
    v5 = v4;
    if (v4)
    {
      v6 = v1[2];
      if (v6 <= 1)
      {
        v7 = 1;
      }

      else
      {
        v7 = v1[2];
      }

      v8 = 20 * v7 + 12;
      if (*(v4 + 104) == 1)
      {
        v9 = v4[10];
        v10 = v5[11];
        v11 = v8 - (v10 - v9);
        if (v8 <= v10 - v9)
        {
          if (v8 < v10 - v9)
          {
            v5[11] = &v9[v8];
          }
        }

        else
        {
          if (v5[12] - v10 < v11)
          {
            operator new();
          }

          v12 = &v9[v8];
          bzero(v5[11], v11);
          v5[11] = v12;
          v9 = v5[10];
          v6 = v1[2];
        }

        memcpy(v9, v1, 20 * v6 + 12);
      }

      else
      {
        std::vector<char>::vector[abi:ne200100](v4 + 10, 20 * v7 + 12);
        memcpy(v5[10], v1, 20 * v1[2] + 12);
        *(v5 + 104) = 1;
      }
    }

    std::mutex::unlock(v3 + 11);
  }
}

void sub_1DE70E1BC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t ___ZNK11HALS_Device41GetNumberStreamsExcludingReferenceStreamsEb_block_invoke(uint64_t a1)
{
  result = (*(**(a1 + 40) + 584))(*(a1 + 40), *(a1 + 48));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE70E268(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void HALS_Device::DSP_Config_Properties(HALS_Device *this, uint64_t a2, unsigned int a3)
{
  *this = 0;
  *(this + 1) = 0;
  if (AMCP::Feature_Flags::use_ahal_dsp_hosting_lib(0, 0))
  {
    v6 = *(a2 + 624);
    if (v6)
    {
      HALS_DSPHostPerClientConfiguration::configuration_for (&v9, v6, a3);
      v7 = v9;
      *this = v9;
      if (!v7)
      {
        v8 = *(a2 + 16);
        operator new();
      }
    }
  }
}

void sub_1DE70E4CC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  std::mutex::unlock((v3 + 32));
  std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(a1);
}

void HALS_Device::DSP_Instance_Properties(void *a1, HALS_Device *this, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  v43 = *MEMORY[0x1E69E9840];
  *__val = a4;
  v36 = a5;
  *a1 = 0;
  a1[1] = 0;
  if (a3)
  {
    (*(*a3 + 208))(&__p, a3);
  }

  else
  {
    *buf = HALS_Device::GetInternalIOContextID(this);
    v33 = 0;
    v34 = 0;
    __p = 0;
    std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int const*,unsigned int const*>(&__p, buf, &buf[4], 1uLL);
  }

  v8 = __p;
  v9 = v33;
  if (__p != v33)
  {
    v10 = 0;
    v11 = 0;
    while (1)
    {
      v12 = HALS_ObjectMap::CopyObjectByObjectID(*v8);
      v14 = v12;
      if (v12)
      {
        if (!v11)
        {
          v19 = *(this + 4);
          (*(**(v12 + 13) + 784))(buf);
          v11 = *buf;
          v20 = *&buf[8];
          *buf = 0;
          *&buf[8] = 0;
          if (v10)
          {
            std::__shared_weak_count::__release_shared[abi:ne200100](v10);
            if (*&buf[8])
            {
              std::__shared_weak_count::__release_shared[abi:ne200100](*&buf[8]);
            }
          }

          if (BYTE4(v36) == 1 && v11)
          {
            v21 = (*(*v11 + 16))(v11, __val);
            if (v21)
            {
              v22 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v22 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(v21);
              }

              v24 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v23 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v23)
              {
                atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
                v25 = *v24;
                std::__shared_weak_count::__release_shared[abi:ne200100](v23);
              }

              else
              {
                v25 = *v24;
              }

              if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
              {
                if ((v36 & 0x100000000) == 0)
                {
                  *a1 = v11;
                  a1[1] = v20;
                  std::__throw_bad_optional_access[abi:ne200100]();
                }

                v27 = bswap32(__val[0]);
                v41 = v27;
                if ((v27 - 32) > 0x5E || ((v27 >> 8) - 32) > 0x5E || ((v27 << 8 >> 24) - 32) > 0x5E || ((v27 >> 24) - 32) > 0x5E)
                {
                  std::to_string(&v31, __val[0]);
                }

                else
                {
                  v42 = 39;
                  __s = 39;
                  std::string::basic_string[abi:ne200100]<0>(&v31, &__s);
                }

                v28 = &v31;
                if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                {
                  v28 = v31.__r_.__value_.__r.__words[0];
                }

                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 5480;
                v38 = 2080;
                v39[0] = v28;
                _os_log_debug_impl(&dword_1DE1F9000, v25, OS_LOG_TYPE_DEBUG, "%32s:%-5d [ahal_dsp] Found DSP instance property %s.", buf, 0x1Cu);
                if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(v31.__r_.__value_.__l.__data_);
                }
              }
            }

            else
            {
              if (v20)
              {
                std::__shared_weak_count::__release_shared[abi:ne200100](v20);
                v20 = 0;
              }

              v11 = 0;
            }
          }

          goto LABEL_25;
        }

        v15 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v15 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(v12);
        }

        v17 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v16 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          v18 = *v17;
          std::__shared_weak_count::__release_shared[abi:ne200100](v16);
        }

        else
        {
          v18 = *v17;
        }

        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          if (a3)
          {
            v26 = a3[4];
          }

          else
          {
            v26 = 0;
          }

          v29 = *(this + 4);
          *buf = 136315906;
          *&buf[4] = "HALS_Device.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 5487;
          v38 = 1024;
          LODWORD(v39[0]) = v26;
          WORD2(v39[0]) = 1024;
          *(v39 + 6) = v29;
          _os_log_debug_impl(&dword_1DE1F9000, v18, OS_LOG_TYPE_DEBUG, "%32s:%-5d [ahal_dsp] Multiple instances found for this client and device (Client ID: %d) (Device ID: %d).", buf, 0x1Eu);
        }
      }

      v20 = v10;
LABEL_25:
      HALS_ObjectMap::ReleaseObject(v14, v13);
      ++v8;
      v10 = v20;
      if (v8 == v9)
      {
        a1[1] = v20;
        v8 = __p;
        goto LABEL_48;
      }
    }
  }

  v11 = 0;
LABEL_48:
  *a1 = v11;
  if (v8)
  {
    v33 = v8;
    operator delete(v8);
  }

  v30 = *MEMORY[0x1E69E9840];
}

void sub_1DE70E968(_Unwind_Exception *a1, HALS_Object *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  *a14 = v19;
  a14[1] = v21;
  HALS_ObjectMap::ReleaseObject(v20, a2);
  if (__p)
  {
    operator delete(__p);
  }

  if (v21)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v21);
  }

  _Unwind_Resume(a1);
}

void HALS_Device::DSP_Config_Properties(unsigned int)::LocalDeviceListener::dsp_processing_type_change(uint64_t a1)
{
  HALS_DSPHostEventListener_Device::dsp_processing_type_change(a1);
  v4[0] = 0;
  v4[1] = 0;
  HALS_System::GetInstance(&v5, 0, v4);
  v3 = HALS_System::CopyDeviceByObjectID(v5, *(a1 + 8), 0);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v6);
  }

  if (v3)
  {
    (*(*v3 + 944))(v3, *(a1 + 12));
  }

  HALS_ObjectMap::ReleaseObject(v3, v2);
}

void std::__shared_ptr_emplace<HALS_Device::DSP_Config_Properties(unsigned int)::LocalDeviceListener,std::allocator<HALS_Device::DSP_Config_Properties(unsigned int)::LocalDeviceListener>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F598E730;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t HALS_Device::_SetDSPDescription(const __CFDictionary **this, const __CFDictionary *a2, AudioObjectPropertyScope a3)
{
  v24[4] = *MEMORY[0x1E69E9840];
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
  v13 = 257;
  CACFDictionary::operator=(&Mutable, a2);
  v6 = HALS_Device::_SetDSPSettingsFromDescription(this, &Mutable, a3);
  if (v6)
  {
    CACFDictionary::operator=((this + 59), &Mutable);
    *(this + 122) = a3;
  }

  else
  {
    v7 = this[59];
    if (v7)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
      {
        *buf = 136315394;
        *&buf[4] = "HALS_Device.cpp";
        v15 = 1024;
        v16 = 1061;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  Could not set given DSP description, falling back to previous description or disabling DSP.", buf, 0x12u);
        v7 = this[59];
      }

      HALS_DSPSettings::FromDictionary(buf, v7);
      v8 = (*(*this + 50))(this, 0, v23);
      HALS_Device::SetStreamDSP(this, v8, buf);
      HALS_ObjectMap::ReleaseObject(v8, v9);
      OS::CF::UntypedObject::~UntypedObject(v24);
      if (__p)
      {
        v22 = __p;
        operator delete(__p);
      }

      if (cf)
      {
        CFRelease(cf);
      }

      OS::CF::UntypedObject::~UntypedObject(&v19);
      OS::CF::UntypedObject::~UntypedObject(&v18);
      if (v17 < 0)
      {
        operator delete(*buf);
      }
    }
  }

  CACFDictionary::~CACFDictionary(&Mutable);
  v10 = *MEMORY[0x1E69E9840];
  return v6;
}

void sub_1DE70ED8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2)
  {
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t ___ZNK11HALS_Device23ProcessMuteStateChangedEP11HALS_Clientb_block_invoke(uint64_t result)
{
  v1 = *(result + 40);
  if (v1)
  {
    v2 = *(*(result + 32) + 456);
    if (*v2)
    {
      v3 = *(v2 + 8);
      v4 = *(v2 + 16);
      v5 = v3;
      if (v3 != v4)
      {
        v6 = *(v1 + 16);
        v5 = *(v2 + 8);
        while (*(v5 + 8) != v6)
        {
          v5 += 16;
          if (v5 == v4)
          {
            goto LABEL_10;
          }
        }
      }

      if (v5 != v4)
      {
        *(v5 + 13) = *(result + 48);
      }

LABEL_10:
      if (v3 == v4)
      {
        result = HALS_ExternalSecureMuteManager::GetExternalSecureMute(*(v2 + 32));
        if ((result & 1) == 0)
        {
          return result;
        }

        v8 = 0;
      }

      else
      {
        v7 = 0;
        do
        {
          v7 |= *(v3 + 13) ^ 1;
          v3 += 16;
        }

        while (v3 != v4);
        v8 = v7 ^ 1;
        v9 = (v7 ^ 1) & 1;
        result = HALS_ExternalSecureMuteManager::GetExternalSecureMute(*(v2 + 32));
        if (result == v9)
        {
          return result;
        }
      }

      v10 = v8 & 1;
      return (*(**(v2 + 32) + 128))(*(v2 + 32), *(*(v2 + 32) + 16), "msxebolg", 4, &v10, 0, 0, 0);
    }
  }

  return result;
}

uint64_t ___ZNK11HALS_Device31GetTotalNumberChannelsForClientEbP11HALS_Client_block_invoke(uint64_t a1)
{
  result = (*(**(a1 + 40) + 608))(*(a1 + 40), *(a1 + 56), *(a1 + 48));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE70EF6C(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

BOOL HALS_Device::_SetHogModeOwner(HALS_Device *this, uint64_t a2)
{
  v2 = a2;
  v3 = (this + 160);
  v4 = atomic_load(this + 40);
  if (v4 != a2)
  {
    atomic_store(a2, v3);
    (*(*this + 512))(this, a2);
    v6 = atomic_load(v3);
    (*(*this + 528))(this, v6);
  }

  return v4 != v2;
}

void HALS_Device::GetPropertyData(HALS_Device *this, uint64_t a2, AudioObjectPropertyAddress *a3, unsigned int a4, unsigned int *a5, uint64_t *a6, unsigned int a7, int *a8, AudioObjectPropertyAddress *a9)
{
  v312 = *MEMORY[0x1E69E9840];
  v304 = a4;
  v303 = a6;
  v302 = a7;
  v301 = a8;
  v300[0] = this;
  v300[1] = &a9;
  v300[2] = a3;
  v300[3] = &v304;
  v300[4] = a5;
  v300[5] = &v303;
  v300[6] = &v302;
  v300[7] = &v301;
  mSelector = a3->mSelector;
  mScope = a3->mScope;
  v299 = 0;
  if (mSelector <= 1768907635)
  {
    if (mSelector > 1684498540)
    {
      if (mSelector > 1685414762)
      {
        if (mSelector > 1751412336)
        {
          if (mSelector > 1751737453)
          {
            if (mSelector != 1751737454)
            {
              if (mSelector == 1752122448)
              {
                if (a9)
                {
                  v56 = a9[1].mScope;
                }

                else
                {
                  v56 = 0;
                }

                HALS_Device::GetHostedDSPConfiguration(buf, this, v56);
                if (buf[8] == 1)
                {
                  v114 = *buf;
                  *buf = 0;
                }

                else
                {
                  v114 = 0;
                }

                *v303 = v114;
                *a5 = 8;
                std::optional<applesauce::CF::DataRef>::~optional(buf);
                goto LABEL_278;
              }

              goto LABEL_281;
            }
          }

          else if (mSelector != 1751412337)
          {
            if (mSelector != 1751413616)
            {
              goto LABEL_281;
            }

            v299 = 8;
            if (a4 <= 7)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4166;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyDSPDescription", buf, 0x12u);
              }

              exception = __cxa_allocate_exception(0x10uLL);
              *exception = off_1F5991DD8;
              exception[2] = 561211770;
            }

            v280[0] = MEMORY[0x1E69E9820];
            v280[1] = 0x40000000;
            v280[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_177;
            v280[3] = &__block_descriptor_tmp_178_20025;
            v280[4] = this;
            v280[5] = a6;
            v16 = (*(*this + 64))(this);
            HALB_CommandGate::ExecuteCommand(v16, v280);
            goto LABEL_261;
          }

          v14 = 4;
          v299 = 4;
          if (a4 <= 3)
          {
            if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
            {
              *buf = 136315394;
              *&buf[4] = "HALS_Device.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 4045;
              _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyIsHidden", buf, 0x12u);
            }

            v64 = __cxa_allocate_exception(0x10uLL);
            *v64 = off_1F5991DD8;
            v64[2] = 561211770;
          }

          goto LABEL_274;
        }

        if (mSelector != 1685414763)
        {
          if (mSelector != 1735354734 && mSelector != 1735356005)
          {
            goto LABEL_281;
          }

          v14 = 4;
          v299 = 4;
          if (a4 <= 3)
          {
            if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
            {
              *buf = 136315394;
              *&buf[4] = "HALS_Device.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 3765;
              _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyDeviceIsRunning", buf, 0x12u);
            }

            v31 = __cxa_allocate_exception(0x10uLL);
            *v31 = off_1F5991DD8;
            v31[2] = 561211770;
          }

          goto LABEL_274;
        }

        v14 = 16;
        v299 = 16;
        if (a4 <= 0xF)
        {
          if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
          {
            *buf = 136315394;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 4111;
            _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyProcessDuck", buf, 0x12u);
          }

          v224 = __cxa_allocate_exception(0x10uLL);
          *v224 = off_1F5991DD8;
          v224[2] = 561211770;
        }

        a6[1] = 0;
        goto LABEL_276;
      }

      if (mSelector > 1684500593)
      {
        switch(mSelector)
        {
          case 1684500594:
            if (!a8)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4253;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: inQualifierData is nullptr for kAudioDevicePropertyDSPGraphProperty", buf, 0x12u);
              }

              v225 = __cxa_allocate_exception(0x10uLL);
              *v225 = off_1F5991DD8;
              v225[2] = 1852797029;
            }

            if (a7 != 4)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4255;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: incorrect inQualifierDataSize for kAudioDevicePropertyDSPGraphProperty", buf, 0x12u);
              }

              v238 = __cxa_allocate_exception(0x10uLL);
              *v238 = off_1F5991DD8;
              v238[2] = 1852797029;
            }

            if (mScope != 1768845428 && mScope != 1869968496)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4257;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: incorrect inAddress.mScope for kAudioDevicePropertyDSPGraphProperty", buf, 0x12u);
              }

              v244 = __cxa_allocate_exception(0x10uLL);
              *v244 = off_1F5991DD8;
              v244[2] = 1852797029;
            }

            v69 = *a8;
            *buf = 0;
            *&buf[8] = buf;
            *&buf[16] = 0x2000000000;
            buf[24] = 0;
            v271[0] = MEMORY[0x1E69E9820];
            v271[1] = 0x40000000;
            v271[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_183;
            v271[3] = &unk_1E8678E88;
            v271[5] = this;
            v271[4] = buf;
            v273 = mScope == 1768845428;
            v272 = v69;
            v271[6] = a3;
            v271[7] = a5;
            v271[8] = a6;
            v70 = (*(*this + 64))(this);
            HALB_CommandGate::ExecuteCommand(v70, v271);
            if ((*(*&buf[8] + 24) & 1) == 0)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
              {
                *v305 = 136315394;
                *&v305[4] = "HALS_Device.cpp";
                *&v305[12] = 1024;
                *&v305[14] = 4270;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  GetStreamDSPProperty failure", v305, 0x12u);
              }

              v71 = __cxa_allocate_exception(0x10uLL);
              *v71 = off_1F5991DD8;
              v71[2] = 1852797029;
            }

            goto LABEL_271;
          case 1685278561:
            v74 = HALS_Device::GetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,unsigned int &,void *,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v300);
            if (!v74)
            {
              v75 = v303;
              if (!v303)
              {
                v146 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
                if ((v146 & 1) == 0)
                {
                  AMCP::Log::AMCP_Scope_Registry::initialize(v74);
                }

                v148 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
                v147 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
                if (v147)
                {
                  atomic_fetch_add_explicit(&v147->__shared_owners_, 1uLL, memory_order_relaxed);
                  v149 = *v148;
                  std::__shared_weak_count::__release_shared[abi:ne200100](v147);
                }

                else
                {
                  v149 = *v148;
                }

                if (os_log_type_enabled(v149, OS_LOG_TYPE_ERROR))
                {
                  *buf = 136315650;
                  *&buf[4] = "HALS_Device.cpp";
                  *&buf[12] = 1024;
                  *&buf[14] = 4448;
                  *&buf[18] = 2080;
                  *&buf[20] = "outData == nullptr";
                  _os_log_error_impl(&dword_1DE1F9000, v149, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: outData is nullptr for kAudioDevicePropertyDSPOffloadAvailable", buf, 0x1Cu);
                }

                AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
                __cxa_allocate_exception(0x40uLL);
                v265 = off_1F5991DD8;
                v266 = 1852797029;
                *&v305[8] = 1852797029;
                v307 = 0;
                v308 = 0;
                v309 = -1;
                *v305 = &unk_1F598E5D8;
                *&v305[16] = &unk_1F598E600;
                v306 = 0;
                boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
                *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
                *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
                v311 = 4448;
                applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
              }

              if (v304 != 8)
              {
                v166 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
                if ((v166 & 1) == 0)
                {
                  AMCP::Log::AMCP_Scope_Registry::initialize(v74);
                }

                v168 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
                v167 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
                if (v167)
                {
                  atomic_fetch_add_explicit(&v167->__shared_owners_, 1uLL, memory_order_relaxed);
                  v169 = *v168;
                  std::__shared_weak_count::__release_shared[abi:ne200100](v167);
                }

                else
                {
                  v169 = *v168;
                }

                if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
                {
                  *buf = 136315650;
                  *&buf[4] = "HALS_Device.cpp";
                  *&buf[12] = 1024;
                  *&buf[14] = 4449;
                  *&buf[18] = 2080;
                  *&buf[20] = "inDataSize != sizeof(CFDictionaryRef)";
                  _os_log_error_impl(&dword_1DE1F9000, v169, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inDataSize is not CFDictionaryRef for kAudioDevicePropertyDSPOffloadAvailable", buf, 0x1Cu);
                }

                AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
                __cxa_allocate_exception(0x40uLL);
                v265 = off_1F5991DD8;
                v266 = 1852797029;
                *&v305[8] = 1852797029;
                v307 = 0;
                v308 = 0;
                v309 = -1;
                *v305 = &unk_1F598E5D8;
                *&v305[16] = &unk_1F598E600;
                v306 = 0;
                boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
                *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
                *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
                v311 = 4449;
                applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
              }

              *a5 = 0;
              v255[0] = MEMORY[0x1E69E9820];
              v255[1] = 0x40000000;
              v255[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_203;
              v255[3] = &__block_descriptor_tmp_204_20063;
              v255[4] = this;
              v255[5] = a3;
              v255[6] = v75;
              v255[7] = a5;
              v76 = (*(*this + 64))(this);
              HALB_CommandGate::ExecuteCommand(v76, v255);
            }

            break;
          case 1685278562:
            v32 = HALS_Device::GetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,unsigned int &,void *,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v300);
            if (!v32)
            {
              v33 = v303;
              if (!v303)
              {
                v142 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
                if ((v142 & 1) == 0)
                {
                  AMCP::Log::AMCP_Scope_Registry::initialize(v32);
                }

                v144 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
                v143 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
                if (v143)
                {
                  atomic_fetch_add_explicit(&v143->__shared_owners_, 1uLL, memory_order_relaxed);
                  v145 = *v144;
                  std::__shared_weak_count::__release_shared[abi:ne200100](v143);
                }

                else
                {
                  v145 = *v144;
                }

                if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
                {
                  *buf = 136315650;
                  *&buf[4] = "HALS_Device.cpp";
                  *&buf[12] = 1024;
                  *&buf[14] = 4432;
                  *&buf[18] = 2080;
                  *&buf[20] = "outData == nullptr";
                  _os_log_error_impl(&dword_1DE1F9000, v145, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: outData is nullptr for kAudioDevicePropertyDSPOffloadBypass", buf, 0x1Cu);
                }

                AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
                __cxa_allocate_exception(0x40uLL);
                v265 = off_1F5991DD8;
                v266 = 1852797029;
                *&v305[8] = 1852797029;
                v307 = 0;
                v308 = 0;
                v309 = -1;
                *v305 = &unk_1F598E5D8;
                *&v305[16] = &unk_1F598E600;
                v306 = 0;
                boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
                *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
                *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
                v311 = 4432;
                applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
              }

              if (v304 != 8)
              {
                v162 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
                if ((v162 & 1) == 0)
                {
                  AMCP::Log::AMCP_Scope_Registry::initialize(v32);
                }

                v164 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
                v163 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
                if (v163)
                {
                  atomic_fetch_add_explicit(&v163->__shared_owners_, 1uLL, memory_order_relaxed);
                  v165 = *v164;
                  std::__shared_weak_count::__release_shared[abi:ne200100](v163);
                }

                else
                {
                  v165 = *v164;
                }

                if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
                {
                  *buf = 136315650;
                  *&buf[4] = "HALS_Device.cpp";
                  *&buf[12] = 1024;
                  *&buf[14] = 4433;
                  *&buf[18] = 2080;
                  *&buf[20] = "inDataSize != sizeof(CFDictionaryRef)";
                  _os_log_error_impl(&dword_1DE1F9000, v165, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inDataSize is not CFDictionaryRef for kAudioDevicePropertyDSPOffloadBypass", buf, 0x1Cu);
                }

                AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
                __cxa_allocate_exception(0x40uLL);
                v265 = off_1F5991DD8;
                v266 = 1852797029;
                *&v305[8] = 1852797029;
                v307 = 0;
                v308 = 0;
                v309 = -1;
                *v305 = &unk_1F598E5D8;
                *&v305[16] = &unk_1F598E600;
                v306 = 0;
                boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
                *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
                *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
                v311 = 4433;
                applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
              }

              v34 = a9;
              if (!a9 && (*(this + 660) & 1) == 0)
              {
                v214 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
                if ((v214 & 1) == 0)
                {
                  AMCP::Log::AMCP_Scope_Registry::initialize(v32);
                }

                v216 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
                v215 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
                if (v215)
                {
                  atomic_fetch_add_explicit(&v215->__shared_owners_, 1uLL, memory_order_relaxed);
                  v217 = *v216;
                  std::__shared_weak_count::__release_shared[abi:ne200100](v215);
                }

                else
                {
                  v217 = *v216;
                }

                if (os_log_type_enabled(v217, OS_LOG_TYPE_ERROR))
                {
                  *buf = 136315650;
                  *&buf[4] = "HALS_Device.cpp";
                  *&buf[12] = 1024;
                  *&buf[14] = 4434;
                  *&buf[18] = 2080;
                  *&buf[20] = "inClient == nullptr && !mHostedDSPClientInfo.allows_null_client()";
                  _os_log_error_impl(&dword_1DE1F9000, v217, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inClient is null for kAudioDevicePropertyDSPOffloadBypass", buf, 0x1Cu);
                }

                AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
                __cxa_allocate_exception(0x40uLL);
                v265 = off_1F5991DD8;
                v266 = 1852797029;
                *&v305[8] = 1852797029;
                v307 = 0;
                v308 = 0;
                v309 = -1;
                *v305 = &unk_1F598E5D8;
                *&v305[16] = &unk_1F598E600;
                v306 = 0;
                boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
                *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
                *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
                v311 = 4434;
                applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
              }

              *a5 = 0;
              v256[0] = MEMORY[0x1E69E9820];
              v256[1] = 0x40000000;
              v256[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_201;
              v256[3] = &__block_descriptor_tmp_202_20060;
              v256[4] = this;
              v256[5] = a3;
              v256[6] = v34;
              v256[7] = v33;
              v256[8] = a5;
              v35 = (*(*this + 64))(this);
              HALB_CommandGate::ExecuteCommand(v35, v256);
            }

            break;
          default:
            goto LABEL_281;
        }

        goto LABEL_278;
      }

      switch(mSelector)
      {
        case 1684498541:
          if (HALS_Device::GetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,unsigned int &,void *,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v300))
          {
            goto LABEL_278;
          }

          if ((HALS_Device_HostedDSP::HasProperty(*(this + 79), a3, a9, v65) & 0x100) == 0)
          {
            if (!v301)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4229;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: inQualifierData is nullptr for kAudioDevicePropertyDSPGraphParameter", buf, 0x12u);
              }

              v247 = __cxa_allocate_exception(0x10uLL);
              *v247 = off_1F5991DD8;
              v247[2] = 1852797029;
            }

            if (v302 != 4)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4231;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: incorrect inQualifierDataSize for kAudioDevicePropertyDSPGraphParameter", buf, 0x12u);
              }

              v249 = __cxa_allocate_exception(0x10uLL);
              *v249 = off_1F5991DD8;
              v249[2] = 1852797029;
            }

            v66 = a3->mScope;
            if (v66 != 1768845428 && v66 != 1869968496)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4233;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: incorrect inAddress.mScope for kAudioDevicePropertyDSPGraphParameter", buf, 0x12u);
              }

              v251 = __cxa_allocate_exception(0x10uLL);
              *v251 = off_1F5991DD8;
              v251[2] = 1852797029;
            }

            v67 = *v301;
            v274[0] = MEMORY[0x1E69E9820];
            v274[1] = 0x40000000;
            v274[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_181;
            v274[3] = &__block_descriptor_tmp_182_20033;
            v276 = v66 == 1768845428;
            v274[4] = this;
            v274[5] = a3;
            v275 = v67;
            v274[6] = v303;
            v274[7] = a5;
            v68 = (*(*this + 64))(this);
            HALB_CommandGate::ExecuteCommand(v68, v274);
            goto LABEL_278;
          }

          break;
        case 1684498544:
          if (!a8)
          {
            if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
            {
              *buf = 136315394;
              *&buf[4] = "HALS_Device.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 4279;
              _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: inQualifierData is nullptr for kAudioDevicePropertyDSPGraphProperty", buf, 0x12u);
            }

            v226 = __cxa_allocate_exception(0x10uLL);
            *v226 = off_1F5991DD8;
            v226[2] = 1852797029;
          }

          if (a7 != 4)
          {
            if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
            {
              *buf = 136315394;
              *&buf[4] = "HALS_Device.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 4281;
              _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: incorrect inQualifierDataSize for kAudioDevicePropertyDSPGraphProperty", buf, 0x12u);
            }

            v239 = __cxa_allocate_exception(0x10uLL);
            *v239 = off_1F5991DD8;
            v239[2] = 1852797029;
          }

          if (mScope != 1768845428 && mScope != 1869968496)
          {
            if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
            {
              *buf = 136315394;
              *&buf[4] = "HALS_Device.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 4283;
              _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: incorrect inAddress.mScope for kAudioDevicePropertyDSPGraphProperty", buf, 0x12u);
            }

            v245 = __cxa_allocate_exception(0x10uLL);
            *v245 = off_1F5991DD8;
            v245[2] = 1852797029;
          }

          v72 = *a8;
          v268[0] = MEMORY[0x1E69E9820];
          v268[1] = 0x40000000;
          v268[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_185;
          v268[3] = &__block_descriptor_tmp_186;
          v270 = mScope == 1768845428;
          v268[4] = this;
          v268[5] = a3;
          v269 = v72;
          v268[6] = a6;
          v268[7] = a5;
          v73 = (*(*this + 64))(this);
          HALB_CommandGate::ExecuteCommand(v73, v268);
          goto LABEL_278;
        case 1684500589:
          if (HALS_Device::GetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,unsigned int &,void *,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v300))
          {
            goto LABEL_278;
          }

          if ((HALS_Device_HostedDSP::HasProperty(*(this + 79), a3, a9, v23) & 0x100) == 0)
          {
            if (!v301)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4190;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: inQualifierData is nullptr for kAudioDevicePropertyDSPGraphParameter", buf, 0x12u);
              }

              v246 = __cxa_allocate_exception(0x10uLL);
              *v246 = off_1F5991DD8;
              v246[2] = 1852797029;
            }

            if (v302 != 4)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4192;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: incorrect inQualifierDataSize for kAudioDevicePropertyDSPGraphParameter", buf, 0x12u);
              }

              v248 = __cxa_allocate_exception(0x10uLL);
              *v248 = off_1F5991DD8;
              v248[2] = 1852797029;
            }

            v24 = a3->mScope;
            if (v24 != 1768845428 && v24 != 1869968496)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4194;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: incorrect inAddress.mScope for kAudioDevicePropertyDSPGraphParameter", buf, 0x12u);
              }

              v250 = __cxa_allocate_exception(0x10uLL);
              *v250 = off_1F5991DD8;
              v250[2] = 1852797029;
            }

            v25 = *v301;
            *buf = 0;
            *&buf[8] = buf;
            *&buf[16] = 0x2000000000;
            buf[24] = 0;
            *a5 = 4;
            v277[0] = MEMORY[0x1E69E9820];
            v277[1] = 0x40000000;
            v277[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_179;
            v277[3] = &unk_1E8678E40;
            v277[5] = this;
            v277[4] = buf;
            v279 = v24 == 1768845428;
            v278 = v25;
            v277[6] = a3;
            v277[7] = v303;
            v26 = (*(*this + 64))(this);
            HALB_CommandGate::ExecuteCommand(v26, v277);
            if ((*(*&buf[8] + 24) & 1) == 0)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
              {
                *v305 = 136315394;
                *&v305[4] = "HALS_Device.cpp";
                *&v305[12] = 1024;
                *&v305[14] = 4208;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  GetStreamDSPParameter failure", v305, 0x12u);
              }

              v27 = __cxa_allocate_exception(0x10uLL);
              *v27 = off_1F5991DD8;
              v27[2] = 1852797029;
            }

            goto LABEL_271;
          }

          break;
        default:
          goto LABEL_281;
      }

LABEL_26:
      HALS_Device_HostedDSP::GetPropertyData(*(this + 79), a3, v304, a5, v303, v302, v301, a9, v252);
      goto LABEL_278;
    }

    if (mSelector <= 1667523954)
    {
      if (mSelector > 1634758773)
      {
        if (mSelector == 1634758774)
        {
          v299 = 4;
          if (a4 <= 3)
          {
            if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
            {
              *buf = 136315394;
              *&buf[4] = "HALS_Device.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 4090;
              _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyProcessVolumeScalar", buf, 0x12u);
            }

            v230 = __cxa_allocate_exception(0x10uLL);
            *v230 = off_1F5991DD8;
            v230[2] = 561211770;
          }

          v284[0] = MEMORY[0x1E69E9820];
          v284[1] = 0x40000000;
          v284[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_164;
          v284[3] = &__block_descriptor_tmp_165;
          v284[4] = this;
          v284[5] = a6;
          v284[6] = a9;
          v284[7] = a3;
          v89 = (*(*this + 64))(this);
          HALB_CommandGate::ExecuteCommand(v89, v284);
          goto LABEL_261;
        }

        if (mSelector != 1667330160)
        {
          if (mSelector == 1667461733)
          {
            only_ios_high_quality_recording = AMCP::Feature_Flags::va_read_only_ios_high_quality_recording(this);
            if ((only_ios_high_quality_recording & 1) == 0)
            {
              only_ios_high_quality_recording = AMCP::Feature_Flags::dsp_read_only_macos_high_quality_local_recording(only_ios_high_quality_recording);
              if ((only_ios_high_quality_recording & 1) == 0)
              {
                v122 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
                if ((v122 & 1) == 0)
                {
                  AMCP::Log::AMCP_Scope_Registry::initialize(only_ios_high_quality_recording);
                }

                v124 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
                v123 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
                if (v123)
                {
                  atomic_fetch_add_explicit(&v123->__shared_owners_, 1uLL, memory_order_relaxed);
                  v125 = *v124;
                  std::__shared_weak_count::__release_shared[abi:ne200100](v123);
                }

                else
                {
                  v125 = *v124;
                }

                if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
                {
                  *buf = 136315650;
                  *&buf[4] = "HALS_Device.cpp";
                  *&buf[12] = 1024;
                  *&buf[14] = 4467;
                  *&buf[18] = 2080;
                  *&buf[20] = "allowCCR == false";
                  _os_log_error_impl(&dword_1DE1F9000, v125, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: kAudioDevicePropertyContentCreationRecording feature disabled", buf, 0x1Cu);
                }

                AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
                __cxa_allocate_exception(0x40uLL);
                v265 = off_1F5991DD8;
                v266 = 1852797029;
                *&v305[8] = 1852797029;
                v307 = 0;
                v308 = 0;
                v309 = -1;
                *v305 = &unk_1F598E5D8;
                *&v305[16] = &unk_1F598E600;
                v306 = 0;
                boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
                *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
                *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
                v311 = 4467;
                applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
              }
            }

            if (mScope != 1768845428)
            {
              v126 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v126 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(only_ios_high_quality_recording);
              }

              v128 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v127 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v127)
              {
                atomic_fetch_add_explicit(&v127->__shared_owners_, 1uLL, memory_order_relaxed);
                v129 = *v128;
                std::__shared_weak_count::__release_shared[abi:ne200100](v127);
              }

              else
              {
                v129 = *v128;
              }

              if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4468;
                *&buf[18] = 2080;
                *&buf[20] = "isInput == false";
                _os_log_error_impl(&dword_1DE1F9000, v129, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: kAudioDevicePropertyContentCreationRecording is only valid for input scope", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4468;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            if (!v303)
            {
              v130 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v130 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(only_ios_high_quality_recording);
              }

              v132 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v131 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v131)
              {
                atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
                v133 = *v132;
                std::__shared_weak_count::__release_shared[abi:ne200100](v131);
              }

              else
              {
                v133 = *v132;
              }

              if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4469;
                *&buf[18] = 2080;
                *&buf[20] = "outData == nullptr";
                _os_log_error_impl(&dword_1DE1F9000, v133, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: outData is nullptr for kAudioDevicePropertyContentCreationRecording", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4469;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            if (v304 != 4)
            {
              v134 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v134 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(only_ios_high_quality_recording);
              }

              v136 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v135 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v135)
              {
                atomic_fetch_add_explicit(&v135->__shared_owners_, 1uLL, memory_order_relaxed);
                v137 = *v136;
                std::__shared_weak_count::__release_shared[abi:ne200100](v135);
              }

              else
              {
                v137 = *v136;
              }

              if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4470;
                *&buf[18] = 2080;
                *&buf[20] = "inDataSize != sizeof(UInt32)";
                _os_log_error_impl(&dword_1DE1F9000, v137, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inDataSize is not UInt32 for kAudioDevicePropertyContentCreationRecording", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4470;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            if (!a9 && (*(this + 660) & 1) == 0)
            {
              v210 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v210 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(only_ios_high_quality_recording);
              }

              v212 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v211 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v211)
              {
                atomic_fetch_add_explicit(&v211->__shared_owners_, 1uLL, memory_order_relaxed);
                v213 = *v212;
                std::__shared_weak_count::__release_shared[abi:ne200100](v211);
              }

              else
              {
                v213 = *v212;
              }

              if (os_log_type_enabled(v213, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4471;
                *&buf[18] = 2080;
                *&buf[20] = "inClient == nullptr && !mHostedDSPClientInfo.allows_null_client()";
                _os_log_error_impl(&dword_1DE1F9000, v213, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inClient is null for kAudioDevicePropertyContentCreationRecording", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4471;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            v39 = atomic_load(&a9[22].mScope);
            if ((v39 & 1) == 0)
            {
              v138 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v138 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(only_ios_high_quality_recording);
              }

              v140 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v139 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v139)
              {
                atomic_fetch_add_explicit(&v139->__shared_owners_, 1uLL, memory_order_relaxed);
                v141 = *v140;
                std::__shared_weak_count::__release_shared[abi:ne200100](v139);
              }

              else
              {
                v141 = *v140;
              }

              if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4472;
                *&buf[18] = 2080;
                *&buf[20] = "!inClient->SandboxAllowsMicAccess()";
                _os_log_error_impl(&dword_1DE1F9000, v141, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inClient does not have permission to get kAudioDevicePropertyContentCreationRecording", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 560492391;
              *&v305[8] = 560492391;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4472;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            *buf = 0;
            *&buf[8] = buf;
            *&buf[16] = 0x2000000000;
            buf[24] = 0;
            *v305 = 0;
            *&v305[8] = v305;
            *&v305[16] = 0x2000000000;
            v306 = 0;
            v253[0] = MEMORY[0x1E69E9820];
            v253[1] = 0x40000000;
            v253[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_206;
            v253[3] = &unk_1E8678F78;
            v254 = mScope == 1768845428;
            v253[6] = this;
            v253[7] = a9;
            v253[4] = buf;
            v253[5] = v305;
            v40 = (*(*this + 64))(this);
            HALB_CommandGate::ExecuteCommand(v40, v253);
            *v303 = *(*&buf[8] + 24);
            *a5 = 4;
            if (*(*&buf[8] + 24) == 1)
            {
              CFRelease(*(*&v305[8] + 24));
            }

            _Block_object_dispose(v305, 8);
            goto LABEL_271;
          }

          goto LABEL_281;
        }

        v299 = 8;
        if (a4 <= 7)
        {
          if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
          {
            *buf = 136315394;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 3690;
            _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyConfigurationApplication", buf, 0x12u);
          }

          v234 = __cxa_allocate_exception(0x10uLL);
          *v234 = off_1F5991DD8;
          v234[2] = 561211770;
        }

        IOContextDescription = CFRetain(@"com.apple.audio.AudioMIDISetup");
        goto LABEL_260;
      }

      if (mSelector == 1634429294)
      {
        v14 = 4;
        v299 = 4;
        if (a4 <= 3)
        {
          if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
          {
            *buf = 136315394;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 3737;
            _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyRelatedDevices", buf, 0x12u);
          }

          v228 = __cxa_allocate_exception(0x10uLL);
          *v228 = off_1F5991DD8;
          v228[2] = 561211770;
        }

        v41 = *(this + 4);
        goto LABEL_122;
      }

      if (mSelector != 1634755428)
      {
        if (mSelector == 1634758765)
        {
          v299 = 4;
          if (a4 <= 3)
          {
            if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
            {
              *buf = 136315394;
              *&buf[4] = "HALS_Device.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 4099;
              _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyProcessMute", buf, 0x12u);
            }

            v219 = __cxa_allocate_exception(0x10uLL);
            *v219 = off_1F5991DD8;
            v219[2] = 561211770;
          }

          *v305 = 0;
          *&v305[8] = v305;
          *&v305[16] = 0x2000000000;
          LODWORD(v306) = 1065353216;
          v283[0] = MEMORY[0x1E69E9820];
          v283[1] = 0x40000000;
          v283[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_166;
          v283[3] = &unk_1E8678DB0;
          v283[5] = this;
          v283[4] = v305;
          v283[6] = a9;
          v283[7] = a3;
          v17 = (*(*this + 64))(this);
          HALB_CommandGate::ExecuteCommand(v17, v283);
          *v303 = *(*&v305[8] + 24) == 0.0;
          if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
          {
            v18 = *(this + 4);
            v19 = "output";
            if (a3->mScope == 1768845428)
            {
              v19 = "input";
            }

            *buf = 136316162;
            v20 = *(*&v305[8] + 24);
            v21 = "on";
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            if (v20 != 0.0)
            {
              v21 = "off";
            }

            *&buf[14] = 4103;
            *&buf[18] = 1024;
            *&buf[20] = v18;
            *&buf[24] = 2080;
            *&buf[26] = v19;
            *&buf[34] = 2080;
            *&buf[36] = v21;
            _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  HALS_Device::_GetPropertyData: Object ID: %d getting process %s mute: %s", buf, 0x2Cu);
          }

          *a5 = v299;
          v22 = v305;
          goto LABEL_272;
        }

        goto LABEL_281;
      }

      v299 = 8;
      if (a4 <= 7)
      {
        if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
        {
          *buf = 136315394;
          *&buf[4] = "HALS_Device.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 4152;
          _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyClockDevice", buf, 0x12u);
        }

        v233 = __cxa_allocate_exception(0x10uLL);
        *v233 = off_1F5991DD8;
        v233[2] = 561211770;
      }

      v281[0] = MEMORY[0x1E69E9820];
      v281[1] = 0x40000000;
      v281[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_175;
      v281[3] = &__block_descriptor_tmp_176_20023;
      v281[4] = this;
      v281[5] = a9;
      v281[6] = a6;
      v105 = (*(*this + 64))(this);
      HALB_CommandGate::ExecuteCommand(v105, v281);
      goto LABEL_261;
    }

    if (mSelector <= 1684236337)
    {
      if (mSelector == 1667523955)
      {
        v299 = 8;
        if (a4 <= 7)
        {
          if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
          {
            *buf = 136315394;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 4072;
            _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyClientDescription", buf, 0x12u);
          }

          v229 = __cxa_allocate_exception(0x10uLL);
          *v229 = off_1F5991DD8;
          v229[2] = 561211770;
        }

        v285[0] = MEMORY[0x1E69E9820];
        v285[1] = 0x40000000;
        v285[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_162;
        v285[3] = &__block_descriptor_tmp_163_20012;
        v285[4] = this;
        v285[5] = a6;
        v285[6] = a9;
        v88 = (*(*this + 64))(this);
        HALB_CommandGate::ExecuteCommand(v88, v285);
        goto LABEL_261;
      }

      if (mSelector == 1668049764)
      {
        v14 = 4;
        v299 = 4;
        if (a4 <= 3)
        {
          if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
          {
            *buf = 136315394;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 3746;
            _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyClockDomain", buf, 0x12u);
          }

          v106 = __cxa_allocate_exception(0x10uLL);
          *v106 = off_1F5991DD8;
          v106[2] = 561211770;
        }

        goto LABEL_274;
      }

      if (mSelector != 1668575852)
      {
        goto LABEL_281;
      }

      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2000000000;
      *&buf[24] = 0;
      v293[0] = MEMORY[0x1E69E9820];
      v293[1] = 0x40000000;
      v293[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_144;
      v293[3] = &unk_1E8678D00;
      v294 = a4;
      v293[6] = a6;
      v293[5] = this;
      v293[4] = buf;
      v28 = (*(*this + 64))(this);
      HALB_CommandGate::ExecuteCommand(v28, v293);
      goto LABEL_215;
    }

    if (mSelector != 1684236338)
    {
      if (mSelector != 1684301171)
      {
        if (mSelector == 1684434036)
        {
          v14 = 4;
          v299 = 4;
          if (a4 <= 3)
          {
            if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
            {
              *buf = 136315394;
              *&buf[4] = "HALS_Device.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 3783;
              _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyDeviceCanBeDefaultDevice", buf, 0x12u);
            }

            v222 = __cxa_allocate_exception(0x10uLL);
            *v222 = off_1F5991DD8;
            v222[2] = 561211770;
          }

          goto LABEL_121;
        }

        goto LABEL_281;
      }

      v14 = 8;
      v299 = 8;
      if (a4 <= 7)
      {
        if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
        {
          *buf = 136315394;
          *&buf[4] = "HALS_Device.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 4063;
          _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyDeviceDescription", buf, 0x12u);
        }

        v107 = __cxa_allocate_exception(0x10uLL);
        *v107 = off_1F5991DD8;
        v107[2] = 561211770;
      }

      goto LABEL_276;
    }

    v299 = 8;
    if (a4 <= 7)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
      {
        *buf = 136315394;
        *&buf[4] = "HALS_Device.cpp";
        *&buf[12] = 1024;
        *&buf[14] = 3918;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyPreferredChannelsForStereo", buf, 0x12u);
      }

      v231 = __cxa_allocate_exception(0x10uLL);
      *v231 = off_1F5991DD8;
      v231[2] = 561211770;
    }

    v287[1] = 0;
    v287[0] = 0;
    HALS_System::GetInstance(v305, 0, v287);
    Setting = HALS_SettingsManager::ReadSetting(*(*v305 + 1776), *(this + 15));
    *buf = Setting;
    *&buf[8] = 1;
    if (*&v305[8])
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](*&v305[8]);
    }

    v91 = a3->mScope == 1768845428;
    *v305 = 0x200000001;
    TotalNumberChannelsForClient = HALS_Device::GetTotalNumberChannelsForClient(this, v91, a9);
    v93 = a3->mScope;
    if (v93 == 1869968496)
    {
      CACFDictionary::GetUInt32(Setting, @"output.stereo.left", v305);
      v94 = @"output.stereo.right";
    }

    else
    {
      if (v93 != 1768845428)
      {
        v117 = 1;
        goto LABEL_292;
      }

      CACFDictionary::GetUInt32(Setting, @"input.stereo.left", v305);
      v94 = @"input.stereo.right";
    }

    CACFDictionary::GetUInt32(*buf, v94, &v305[4]);
    v117 = *v305;
LABEL_292:
    v118 = v303;
    if (v117 > TotalNumberChannelsForClient)
    {
      v117 = 1;
    }

    *v303 = v117;
    v119 = *&v305[4];
    if (*&v305[4] > TotalNumberChannelsForClient)
    {
      if (TotalNumberChannelsForClient < 2)
      {
        v119 = 1;
      }

      else
      {
        v119 = 2;
      }
    }

    v118[1] = v119;
    *a5 = v299;
    goto LABEL_305;
  }

  if (mSelector > 1934647635)
  {
    if (mSelector > 1937009954)
    {
      if (mSelector > 1983996970)
      {
        if (mSelector <= 1986622323)
        {
          if (mSelector == 1983996971)
          {
            v78 = HALS_Device::GetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,unsigned int &,void *,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v300);
            if (v78)
            {
              goto LABEL_278;
            }

            if (mScope != 1768845428)
            {
              v150 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v150 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(v78);
              }

              v152 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v151 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v151)
              {
                atomic_fetch_add_explicit(&v151->__shared_owners_, 1uLL, memory_order_relaxed);
                v153 = *v152;
                std::__shared_weak_count::__release_shared[abi:ne200100](v151);
              }

              else
              {
                v153 = *v152;
              }

              if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4390;
                *&buf[18] = 2080;
                *&buf[20] = "isInput == false";
                _os_log_error_impl(&dword_1DE1F9000, v153, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: only valid for input scope kAudioDevicePropertyVoiceActivityDetectionEnable", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4390;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            if (!v303)
            {
              v170 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v170 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(v78);
              }

              v172 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v171 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v171)
              {
                atomic_fetch_add_explicit(&v171->__shared_owners_, 1uLL, memory_order_relaxed);
                v173 = *v172;
                std::__shared_weak_count::__release_shared[abi:ne200100](v171);
              }

              else
              {
                v173 = *v172;
              }

              if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4391;
                *&buf[18] = 2080;
                *&buf[20] = "outData == nullptr";
                _os_log_error_impl(&dword_1DE1F9000, v173, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: outData is nullptr for kAudioDevicePropertyVoiceActivityDetectionEnable", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4391;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            if (v304 != 4)
            {
              v182 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v182 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(v78);
              }

              v184 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v183 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v183)
              {
                atomic_fetch_add_explicit(&v183->__shared_owners_, 1uLL, memory_order_relaxed);
                v185 = *v184;
                std::__shared_weak_count::__release_shared[abi:ne200100](v183);
              }

              else
              {
                v185 = *v184;
              }

              if (os_log_type_enabled(v185, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4392;
                *&buf[18] = 2080;
                *&buf[20] = "inDataSize != sizeof(UInt32)";
                _os_log_error_impl(&dword_1DE1F9000, v185, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inDataSize is not UInt32 for kAudioDevicePropertyVoiceActivityDetectionEnable", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4392;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            if (!a9)
            {
              v194 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v194 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(v78);
              }

              v196 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v195 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v195)
              {
                atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
                v197 = *v196;
                std::__shared_weak_count::__release_shared[abi:ne200100](v195);
              }

              else
              {
                v197 = *v196;
              }

              if (os_log_type_enabled(v197, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4393;
                *&buf[18] = 2080;
                *&buf[20] = "inClient == nullptr";
                _os_log_error_impl(&dword_1DE1F9000, v197, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inClient is null for kAudioDevicePropertyVoiceActivityDetectionEnable", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4393;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            v79 = atomic_load(&a9[22].mScope);
            if ((v79 & 1) == 0)
            {
              v202 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v202 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(v78);
              }

              v204 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v203 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v203)
              {
                atomic_fetch_add_explicit(&v203->__shared_owners_, 1uLL, memory_order_relaxed);
                v205 = *v204;
                std::__shared_weak_count::__release_shared[abi:ne200100](v203);
              }

              else
              {
                v205 = *v204;
              }

              if (os_log_type_enabled(v205, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4394;
                *&buf[18] = 2080;
                *&buf[20] = "!inClient->SandboxAllowsMicAccess()";
                _os_log_error_impl(&dword_1DE1F9000, v205, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inClient does not have permission to get kAudioDevicePropertyVoiceActivityDetectionEnable", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 560492391;
              *&v305[8] = 560492391;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4394;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            *buf = 0;
            *&buf[8] = buf;
            *&buf[16] = 0x2000000000;
            *&buf[24] = 0;
            *a5 = 4;
            v257[0] = MEMORY[0x1E69E9820];
            v257[1] = 0x40000000;
            v257[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_197;
            v257[3] = &unk_1E8678F10;
            v258 = mScope == 1768845428;
            v257[4] = buf;
            v257[5] = this;
            v257[6] = a9;
            v257[7] = a5;
            v80 = (*(*this + 64))(this);
            HALB_CommandGate::ExecuteCommand(v80, v257);
            v81 = *(*&buf[8] + 24);
            if (!v81)
            {
              v81 = ((*(***(this + 79) + 472))(**(this + 79)) & 0x1FFFFFFFFLL) == 0x16D746B64;
              *(*&buf[8] + 24) = v81;
            }

            *v303 = v81;
            goto LABEL_271;
          }

          if (mSelector != 1983997011)
          {
            goto LABEL_281;
          }

          if (HALS_Device::GetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,unsigned int &,void *,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v300))
          {
            goto LABEL_278;
          }

          goto LABEL_26;
        }

        if (mSelector == 1986622324)
        {
          if (!HALS_Device::GetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,unsigned int &,void *,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v300))
          {
            NumberStreamsExcludingReferenceStreams = HALS_Device::GetNumberStreamsExcludingReferenceStreams(this, 1);
            if (mScope != 1768845428)
            {
              v158 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v158 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(NumberStreamsExcludingReferenceStreams);
              }

              v160 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v159 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v159)
              {
                atomic_fetch_add_explicit(&v159->__shared_owners_, 1uLL, memory_order_relaxed);
                v161 = *v160;
                std::__shared_weak_count::__release_shared[abi:ne200100](v159);
              }

              else
              {
                v161 = *v160;
              }

              if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4306;
                *&buf[18] = 2080;
                *&buf[20] = "isInput == false";
                _os_log_error_impl(&dword_1DE1F9000, v161, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: only valid for input scope kAudioDevicePropertyVocalIsolationType", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4306;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            if (!v303)
            {
              v178 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v178 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(NumberStreamsExcludingReferenceStreams);
              }

              v180 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v179 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v179)
              {
                atomic_fetch_add_explicit(&v179->__shared_owners_, 1uLL, memory_order_relaxed);
                v181 = *v180;
                std::__shared_weak_count::__release_shared[abi:ne200100](v179);
              }

              else
              {
                v181 = *v180;
              }

              if (os_log_type_enabled(v181, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4307;
                *&buf[18] = 2080;
                *&buf[20] = "outData == nullptr";
                _os_log_error_impl(&dword_1DE1F9000, v181, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: outData is nullptr for kAudioDevicePropertyVocalIsolationType", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4307;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            if (v304 != 4)
            {
              v190 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v190 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(NumberStreamsExcludingReferenceStreams);
              }

              v192 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v191 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v191)
              {
                atomic_fetch_add_explicit(&v191->__shared_owners_, 1uLL, memory_order_relaxed);
                v193 = *v192;
                std::__shared_weak_count::__release_shared[abi:ne200100](v191);
              }

              else
              {
                v193 = *v192;
              }

              if (os_log_type_enabled(v193, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4308;
                *&buf[18] = 2080;
                *&buf[20] = "inDataSize != sizeof(UInt32)";
                _os_log_error_impl(&dword_1DE1F9000, v193, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inDataSize is not UInt32 for kAudioDevicePropertyVocalIsolationType", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4308;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            if (!a9)
            {
              v198 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v198 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(NumberStreamsExcludingReferenceStreams);
              }

              v200 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v199 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v199)
              {
                atomic_fetch_add_explicit(&v199->__shared_owners_, 1uLL, memory_order_relaxed);
                v201 = *v200;
                std::__shared_weak_count::__release_shared[abi:ne200100](v199);
              }

              else
              {
                v201 = *v200;
              }

              if (os_log_type_enabled(v201, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4309;
                *&buf[18] = 2080;
                *&buf[20] = "inClient == nullptr";
                _os_log_error_impl(&dword_1DE1F9000, v201, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inClient is null for kAudioDevicePropertyVocalIsolationType", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 1852797029;
              *&v305[8] = 1852797029;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4309;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            v84 = atomic_load(&a9[22].mScope);
            if ((v84 & 1) == 0)
            {
              v206 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
              if ((v206 & 1) == 0)
              {
                AMCP::Log::AMCP_Scope_Registry::initialize(NumberStreamsExcludingReferenceStreams);
              }

              v208 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
              v207 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
              if (v207)
              {
                atomic_fetch_add_explicit(&v207->__shared_owners_, 1uLL, memory_order_relaxed);
                v209 = *v208;
                std::__shared_weak_count::__release_shared[abi:ne200100](v207);
              }

              else
              {
                v209 = *v208;
              }

              if (os_log_type_enabled(v209, OS_LOG_TYPE_ERROR))
              {
                *buf = 136315650;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4310;
                *&buf[18] = 2080;
                *&buf[20] = "!inClient->SandboxAllowsMicAccess()";
                _os_log_error_impl(&dword_1DE1F9000, v209, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inClient does not have permission to get kAudioDevicePropertyVocalIsolationType", buf, 0x1Cu);
              }

              AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
              __cxa_allocate_exception(0x40uLL);
              v265 = off_1F5991DD8;
              v266 = 560492391;
              *&v305[8] = 560492391;
              v307 = 0;
              v308 = 0;
              v309 = -1;
              *v305 = &unk_1F598E5D8;
              *&v305[16] = &unk_1F598E600;
              v306 = 0;
              boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
              *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
              *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
              v311 = 4310;
              applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
            }

            v261[0] = MEMORY[0x1E69E9820];
            v261[1] = 0x40000000;
            v261[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_192;
            v261[3] = &__block_descriptor_tmp_193;
            v262 = mScope == 1768845428;
            v261[4] = this;
            v261[5] = a9;
            v263 = NumberStreamsExcludingReferenceStreams != 0;
            v261[6] = v303;
            v261[7] = a5;
            v85 = (*(*this + 64))(this);
            HALB_CommandGate::ExecuteCommand(v85, v261);
          }

          goto LABEL_278;
        }

        if (mSelector != 2003136116)
        {
          goto LABEL_281;
        }

        v299 = 4;
        if (a4 <= 3)
        {
          if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
          {
            *buf = 136315394;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 3774;
            _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyDeviceIsRunning", buf, 0x12u);
          }

          v227 = __cxa_allocate_exception(0x10uLL);
          *v227 = off_1F5991DD8;
          v227[2] = 561211770;
        }

        v63 = (*(*this + 504))(this, a9);
        *v303 = v63;
LABEL_261:
        v14 = v299;
        goto LABEL_277;
      }

      if (mSelector != 1937009955)
      {
        if (mSelector == 1953653102)
        {
          v14 = 4;
          v299 = 4;
          if (a4 <= 3)
          {
            if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
            {
              *buf = 136315394;
              *&buf[4] = "HALS_Device.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 3709;
              _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyTransportType", buf, 0x12u);
            }

            v104 = __cxa_allocate_exception(0x10uLL);
            *v104 = off_1F5991DD8;
            v104[2] = 561211770;
          }

          goto LABEL_274;
        }

        if (mSelector != 1969841184)
        {
          goto LABEL_281;
        }

        v299 = 8;
        if (a4 <= 7)
        {
          if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
          {
            *buf = 136315394;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 3699;
            _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyDeviceUID", buf, 0x12u);
          }

          v221 = __cxa_allocate_exception(0x10uLL);
          *v221 = off_1F5991DD8;
          v221[2] = 561211770;
        }

        v37 = (*(*this + 216))(this);
        *buf = v37;
        buf[8] = 1;
        if (v37)
        {
          v37 = PropertyListDeepImmutableCopy(v37);
        }

        *v303 = v37;
        *a5 = v299;
        CACFString::~CACFString(buf);
        goto LABEL_278;
      }

      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2000000000;
      *&buf[24] = 0;
      v291[0] = MEMORY[0x1E69E9820];
      v291[1] = 0x40000000;
      v291[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_146;
      v291[3] = &unk_1E8678D28;
      v292 = a4;
      v291[6] = a3;
      v291[7] = a9;
      v291[8] = a6;
      v291[5] = this;
      v291[4] = buf;
      v86 = (*(*this + 64))(this);
      HALB_CommandGate::ExecuteCommand(v86, v291);
LABEL_215:
      v87 = 4 * *(*&buf[8] + 24);
LABEL_270:
      *a5 = v87;
LABEL_271:
      v22 = buf;
LABEL_272:
      _Block_object_dispose(v22, 8);
      goto LABEL_278;
    }

    if (mSelector <= 1936482680)
    {
      if (mSelector != 1934647636)
      {
        if (mSelector != 1935763060)
        {
          if (mSelector == 1936092276)
          {
            v14 = 4;
            v299 = 4;
            if (a4 <= 3)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 3792;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyDeviceCanBeDefaultSystemDevice", buf, 0x12u);
              }

              v30 = __cxa_allocate_exception(0x10uLL);
              *v30 = off_1F5991DD8;
              v30[2] = 561211770;
            }

            goto LABEL_121;
          }

          goto LABEL_281;
        }

        v14 = 4;
        v299 = 4;
        if (a4 <= 3)
        {
          if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
          {
            *buf = 136315394;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 3908;
            _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertySafetyOffset", buf, 0x12u);
          }

          v236 = __cxa_allocate_exception(0x10uLL);
          *v236 = off_1F5991DD8;
          v236[2] = 561211770;
        }

        goto LABEL_274;
      }

      v96 = HALS_Device::GetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,unsigned int &,void *,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v300);
      if (!v96)
      {
        if (mScope == 1768845428)
        {
          v154 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v154 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v96);
          }

          v156 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v155 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v155)
          {
            atomic_fetch_add_explicit(&v155->__shared_owners_, 1uLL, memory_order_relaxed);
            v157 = *v156;
            std::__shared_weak_count::__release_shared[abi:ne200100](v155);
          }

          else
          {
            v157 = *v156;
          }

          if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
          {
            *buf = 136315650;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 4342;
            *&buf[18] = 2080;
            *&buf[20] = "isInput == true";
            _os_log_error_impl(&dword_1DE1F9000, v157, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: only valid for output scope kAudioDevicePropertySpatializationType", buf, 0x1Cu);
          }

          AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
          __cxa_allocate_exception(0x40uLL);
          v265 = off_1F5991DD8;
          v266 = 1852797029;
          *&v305[8] = 1852797029;
          v307 = 0;
          v308 = 0;
          v309 = -1;
          *v305 = &unk_1F598E5D8;
          *&v305[16] = &unk_1F598E600;
          v306 = 0;
          boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
          *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
          *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
          v311 = 4342;
          applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
        }

        if (!v303)
        {
          v174 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v174 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v96);
          }

          v176 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v175 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v175)
          {
            atomic_fetch_add_explicit(&v175->__shared_owners_, 1uLL, memory_order_relaxed);
            v177 = *v176;
            std::__shared_weak_count::__release_shared[abi:ne200100](v175);
          }

          else
          {
            v177 = *v176;
          }

          if (os_log_type_enabled(v177, OS_LOG_TYPE_ERROR))
          {
            *buf = 136315650;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 4343;
            *&buf[18] = 2080;
            *&buf[20] = "outData == nullptr";
            _os_log_error_impl(&dword_1DE1F9000, v177, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: outData is nullptr for kAudioDevicePropertySpatializationType", buf, 0x1Cu);
          }

          AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
          __cxa_allocate_exception(0x40uLL);
          v265 = off_1F5991DD8;
          v266 = 1852797029;
          *&v305[8] = 1852797029;
          v307 = 0;
          v308 = 0;
          v309 = -1;
          *v305 = &unk_1F598E5D8;
          *&v305[16] = &unk_1F598E600;
          v306 = 0;
          boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
          *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
          *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
          v311 = 4343;
          applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
        }

        if (v304 != 4)
        {
          v186 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v186 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v96);
          }

          v188 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v187 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v187)
          {
            atomic_fetch_add_explicit(&v187->__shared_owners_, 1uLL, memory_order_relaxed);
            v189 = *v188;
            std::__shared_weak_count::__release_shared[abi:ne200100](v187);
          }

          else
          {
            v189 = *v188;
          }

          if (os_log_type_enabled(v189, OS_LOG_TYPE_ERROR))
          {
            *buf = 136315650;
            *&buf[4] = "HALS_Device.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 4344;
            *&buf[18] = 2080;
            *&buf[20] = "inDataSize != sizeof(UInt32)";
            _os_log_error_impl(&dword_1DE1F9000, v189, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s HALS_Device::GetPropertyData: inDataSize is not UInt32 for kAudioDevicePropertySpatializationType", buf, 0x1Cu);
          }

          AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v267);
          __cxa_allocate_exception(0x40uLL);
          v265 = off_1F5991DD8;
          v266 = 1852797029;
          *&v305[8] = 1852797029;
          v307 = 0;
          v308 = 0;
          v309 = -1;
          *v305 = &unk_1F598E5D8;
          *&v305[16] = &unk_1F598E600;
          v306 = 0;
          boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<CAException>>::clone_impl(buf, v305);
          *&buf[32] = "virtual void HALS_Device::GetPropertyData(AudioObjectID, const AudioObjectPropertyAddress &, UInt32, UInt32 &, void *, UInt32, const void *, HALS_Client *) const";
          *&buf[40] = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/Base/HALS_Device.cpp";
          v311 = 4344;
          applesauce::backtrace::snapshot_N<64>::snapshot_N(&v264);
        }

        v259[0] = MEMORY[0x1E69E9820];
        v259[1] = 0x40000000;
        v259[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_195;
        v259[3] = &__block_descriptor_tmp_196_20050;
        v260 = mScope == 1768845428;
        v259[4] = this;
        v259[5] = a9;
        v259[6] = v303;
        v259[7] = a5;
        v97 = (*(*this + 64))(this);
        HALB_CommandGate::ExecuteCommand(v97, v259);
      }

      goto LABEL_278;
    }

    if (mSelector == 1936482681)
    {
      if (mScope == 1768845428)
      {
        v99 = 1;
      }

      else
      {
        v99 = 2 * (mScope != 1869968496);
      }

      v100 = (*(*this + 544))(this, v99 != 0, a9);
      v101 = (16 * v100) | 8;
      v299 = v101;
      if (v304 < v101)
      {
        if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
        {
          *buf = 136315394;
          *&buf[4] = "HALS_Device.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 3879;
          _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyStreamConfiguration", buf, 0x12u);
        }

        v240 = __cxa_allocate_exception(0x10uLL);
        *v240 = off_1F5991DD8;
        v240[2] = 561211770;
      }

      *a5 = v101;
      v288[0] = MEMORY[0x1E69E9820];
      v288[1] = 0x40000000;
      v288[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_148;
      v288[3] = &__block_descriptor_tmp_149;
      v288[4] = this;
      v288[5] = v303;
      v289 = v100;
      v290 = v99;
      v288[6] = a9;
      v102 = (*(*this + 64))(this);
      HALB_CommandGate::ExecuteCommand(v102, v288);
      goto LABEL_278;
    }

    if (mSelector == 1936876644)
    {
      v111 = HALS_Device::GetTotalNumberChannelsForClient(this, mScope == 1768845428, a9);
      v112 = caulk::numeric::exceptional_mul<unsigned int>(v111);
      v299 = caulk::numeric::exceptional_add<unsigned int>(v112);
      if (v304 < v299)
      {
        if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
        {
          *buf = 136315394;
          *&buf[4] = "HALS_Device.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 4020;
          _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyDefaultChannelLayout", buf, 0x12u);
        }

        v242 = __cxa_allocate_exception(0x10uLL);
        *v242 = off_1F5991DD8;
        v242[2] = 561211770;
      }

      (*(*this + 936))(this, a2, a3);
      goto LABEL_278;
    }

    if (mSelector != 1936879204)
    {
      goto LABEL_281;
    }

    v49 = HALS_Device::GetTotalNumberChannelsForClient(this, mScope == 1768845428, a9);
    v50 = caulk::numeric::exceptional_mul<unsigned int>(v49);
    v299 = caulk::numeric::exceptional_add<unsigned int>(v50);
    if (v304 < v299)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
      {
        *buf = 136315394;
        *&buf[4] = "HALS_Device.cpp";
        *&buf[12] = 1024;
        *&buf[14] = 3970;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyPreferredChannelLayout", buf, 0x12u);
      }

      v241 = __cxa_allocate_exception(0x10uLL);
      *v241 = off_1F5991DD8;
      v241[2] = 561211770;
    }

    v51 = v303;
    *v303 = 0;
    v51[2] = v49;
    if (v49)
    {
      v52 = v49;
      v53 = v51 + 4;
      do
      {
        *(v53 - 1) = -1;
        *v53 = 0;
        v53[1] = 0;
        v53 = (v53 + 20);
        --v52;
      }

      while (v52);
    }

    (*(*this + 936))(this, a2, a3);
    v286[1] = 0;
    v286[0] = 0;
    HALS_System::GetInstance(v305, 0, v286);
    *buf = HALS_SettingsManager::ReadSetting(*(*v305 + 1776), *(this + 15));
    *&buf[8] = 1;
    if (*&v305[8])
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](*&v305[8]);
    }

    v54 = a3->mScope;
    *v305 = 0;
    *&v305[8] = 1;
    if (v54 == 1869968496)
    {
      v55 = @"output.surround";
    }

    else
    {
      if (v54 != 1768845428)
      {
LABEL_300:
        HALS_Device::ThrowIfInvalidACL(v51, v304, v49);
        CACFDictionary::~CACFDictionary(v305);
LABEL_305:
        CACFDictionary::~CACFDictionary(buf);
        goto LABEL_278;
      }

      v55 = @"input.surround";
    }

    CACFDictionary::GetCACFDictionary(buf, v55, v305);
    if (*v305)
    {
      HALS_Device::ConstructLayoutFromDictionary(v305, v51, v120);
    }

    goto LABEL_300;
  }

  if (mSelector > 1853059618)
  {
    if (mSelector > 1870098019)
    {
      if (mSelector <= 1919512166)
      {
        if (mSelector != 1870098020)
        {
          if (mSelector == 1886353266)
          {
            v14 = 4;
            v299 = 4;
            if (a4 <= 3)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *buf = 136315394;
                *&buf[4] = "HALS_Device.cpp";
                *&buf[12] = 1024;
                *&buf[14] = 4143;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyPowerIsOn", buf, 0x12u);
              }

              v15 = __cxa_allocate_exception(0x10uLL);
              *v15 = off_1F5991DD8;
              v15[2] = 561211770;
            }

LABEL_121:
            v41 = 1;
LABEL_122:
            *a6 = v41;
LABEL_277:
            *a5 = v14;
            goto LABEL_278;
          }

          goto LABEL_281;
        }

        *buf = 0;
        *&buf[8] = buf;
        *&buf[16] = 0x2000000000;
        *&buf[24] = 0;
        v296[0] = MEMORY[0x1E69E9820];
        v296[1] = 0x40000000;
        v296[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke;
        v296[3] = &unk_1E8678CB0;
        v296[5] = this;
        v296[4] = buf;
        v297 = a4 >> 2;
        v298 = a7 >> 2;
        v296[6] = a9;
        v296[7] = a8;
        v296[8] = a6;
        v77 = (*(*this + 64))(this);
        HALB_CommandGate::ExecuteCommand(v77, v296);
        goto LABEL_215;
      }

      if (mSelector != 1919512167)
      {
        if (mSelector == 1934647619)
        {
          HALS_Device::GetDSPVirtualChannelLayoutForClient(buf, this, (mScope == 1768845428), a9);
          if (buf[24] == 1)
          {
            v57 = *&buf[8] - *buf;
            if (v304 < *&buf[8] - *buf)
            {
              if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
              {
                *v305 = 136315394;
                *&v305[4] = "HALS_Device.cpp";
                *&v305[12] = 1024;
                *&v305[14] = 4371;
                _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertySpatializationVirtualChannelLayout", v305, 0x12u);
              }

              v243 = __cxa_allocate_exception(0x10uLL);
              *v243 = off_1F5991DD8;
              v243[2] = 561211770;
            }

            v58 = v303;
            NumberChannelDescriptions = CA::ChannelLayout::GetNumberChannelDescriptions(*buf, *&buf[8]);
            *v58 = 0;
            *(v58 + 2) = NumberChannelDescriptions;
            if (NumberChannelDescriptions)
            {
              v60 = NumberChannelDescriptions;
              v61 = v58 + 2;
              do
              {
                *(v61 - 1) = -1;
                *v61 = 0;
                v61[1] = 0;
                v61 = (v61 + 20);
                --v60;
              }

              while (v60);
            }

            memcpy(v58, *buf, v57);
            v62 = buf[24];
            *a5 = v57;
            if ((v62 & 1) != 0 && *buf)
            {
              *&buf[8] = *buf;
              operator delete(*buf);
            }

            goto LABEL_278;
          }

LABEL_166:
          *a5 = 0;
          goto LABEL_278;
        }

LABEL_281:
        if (!HALS_Device::GetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,unsigned int &,void *,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v300))
        {
          HALS_Object::GetPropertyData(this, v113, a3, v304, a5, v303);
        }

        goto LABEL_278;
      }

      v14 = 4;
      v299 = 4;
      if (a4 <= 3)
      {
        if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
        {
          *buf = 136315394;
          *&buf[4] = "HALS_Device.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 3821;
          _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyZeroTimeStampPeriod", buf, 0x12u);
        }

        v82 = __cxa_allocate_exception(0x10uLL);
        *v82 = off_1F5991DD8;
        v82[2] = 561211770;
      }

LABEL_274:
      *a6 = 0;
      goto LABEL_277;
    }

    if (mSelector == 1853059619)
    {
      goto LABEL_166;
    }

    if (mSelector != 1853059700)
    {
      if (mSelector != 1869180523)
      {
        goto LABEL_281;
      }

      v299 = 4;
      if (a4 <= 3)
      {
        if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
        {
          *buf = 136315394;
          *&buf[4] = "HALS_Device.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 3801;
          _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyHogMode", buf, 0x12u);
        }

        v220 = __cxa_allocate_exception(0x10uLL);
        *v220 = off_1F5991DD8;
        v220[2] = 561211770;
      }

      v36 = atomic_load(this + 40);
      *v303 = v36;
      goto LABEL_261;
    }

    v14 = 8;
    v299 = 8;
    if (a4 <= 7)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
      {
        *buf = 136315394;
        *&buf[4] = "HALS_Device.cpp";
        *&buf[12] = 1024;
        *&buf[14] = 4029;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyNominalSampleRate", buf, 0x12u);
      }

      v103 = __cxa_allocate_exception(0x10uLL);
      *v103 = off_1F5991DD8;
      v103[2] = 561211770;
    }

LABEL_276:
    *a6 = 0;
    goto LABEL_277;
  }

  if (mSelector <= 1819569762)
  {
    if (mSelector != 1768907636)
    {
      if (mSelector != 1818454126)
      {
        if (mSelector == 1818850926)
        {
          v14 = 4;
          v299 = 4;
          if (a4 <= 3)
          {
            if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
            {
              *buf = 136315394;
              *&buf[4] = "HALS_Device.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 3755;
              _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyDeviceIsAlive", buf, 0x12u);
            }

            v29 = __cxa_allocate_exception(0x10uLL);
            *v29 = off_1F5991DD8;
            v29[2] = 561211770;
          }

          goto LABEL_121;
        }

        goto LABEL_281;
      }

      v299 = 8;
      if (a4 <= 7)
      {
        if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
        {
          *buf = 136315394;
          *&buf[4] = "HALS_Device.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 3672;
          _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioObjectPropertyElementName", buf, 0x12u);
        }

        v235 = __cxa_allocate_exception(0x10uLL);
        *v235 = off_1F5991DD8;
        v235[2] = 561211770;
      }

      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2000000000;
      *&buf[24] = 0;
      v295[0] = MEMORY[0x1E69E9820];
      v295[1] = 0x40000000;
      v295[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_139;
      v295[3] = &unk_1E8678CD8;
      v295[5] = this;
      v295[4] = buf;
      v295[6] = a3;
      v108 = (*(*this + 64))(this);
      HALB_CommandGate::ExecuteCommand(v108, v295);
      v109 = *(*&buf[8] + 24);
      if (!v109)
      {
        v109 = &stru_1F5992518;
      }

      *v303 = v109;
      v87 = v299;
      goto LABEL_270;
    }

    v299 = 8;
    if (a4 <= 7)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
      {
        *buf = 136315394;
        *&buf[4] = "HALS_Device.cpp";
        *&buf[12] = 1024;
        *&buf[14] = 4054;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyIOContextDescription", buf, 0x12u);
      }

      v232 = __cxa_allocate_exception(0x10uLL);
      *v232 = off_1F5991DD8;
      v232[2] = 561211770;
    }

    IOContextDescription = HALS_Device::CreateIOContextDescription(this, a9);
LABEL_260:
    *v303 = IOContextDescription;
    goto LABEL_261;
  }

  if (mSelector == 1819569763)
  {
    v14 = 4;
    v299 = 4;
    if (a4 <= 3)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
      {
        *buf = 136315394;
        *&buf[4] = "HALS_Device.cpp";
        *&buf[12] = 1024;
        *&buf[14] = 3812;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyLatency", buf, 0x12u);
      }

      v98 = __cxa_allocate_exception(0x10uLL);
      *v98 = off_1F5991DD8;
      v98[2] = 561211770;
    }

    goto LABEL_274;
  }

  if (mSelector == 1819634020)
  {
    v14 = 8;
    v299 = 8;
    if (a4 <= 7)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
      {
        *buf = 136315394;
        *&buf[4] = "HALS_Device.cpp";
        *&buf[12] = 1024;
        *&buf[14] = 4081;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyDeviceDescription", buf, 0x12u);
      }

      v237 = __cxa_allocate_exception(0x10uLL);
      *v237 = off_1F5991DD8;
      v237[2] = 561211770;
    }

    goto LABEL_276;
  }

  if (mSelector != 1852793963)
  {
    goto LABEL_281;
  }

  v299 = 4;
  if (a4 <= 3)
  {
    if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
    {
      *buf = 136315394;
      *&buf[4] = "HALS_Device.cpp";
      *&buf[12] = 1024;
      *&buf[14] = 4120;
      _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyData: bad property data size for kAudioDevicePropertyProcessDuckOptOut", buf, 0x12u);
    }

    v223 = __cxa_allocate_exception(0x10uLL);
    *v223 = off_1F5991DD8;
    v223[2] = 561211770;
  }

  v42 = HALS_Device::CopyIOEngineReplacerOwningDevice(this);
  v43 = v42;
  if (v42)
  {
    v44 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v44 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v42);
    }

    v46 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v45 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v45)
    {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      v47 = *v46;
      std::__shared_weak_count::__release_shared[abi:ne200100](v45);
    }

    else
    {
      v47 = *v46;
    }

    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      v121 = (*(*v43 + 224))(v43);
      *buf = 136315906;
      *&buf[4] = "HALS_Device.cpp";
      *&buf[12] = 1024;
      *&buf[14] = 4125;
      *&buf[18] = 2082;
      *&buf[20] = this + 164;
      *&buf[28] = 2082;
      *&buf[30] = v121;
      _os_log_impl(&dword_1DE1F9000, v47, OS_LOG_TYPE_DEFAULT, "%32s:%-5d Device '%{public}s' has a engine replacer '%{public}s', forwarding volume ducking command", buf, 0x26u);
    }

    (*(*v43 + 120))(v43, v43[4], a3, v304, a5, v303, v302, v301, a9);
  }

  else
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2000000000;
    buf[24] = 0;
    v282[0] = MEMORY[0x1E69E9820];
    v282[1] = 0x40000000;
    v282[2] = ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_173;
    v282[3] = &unk_1E8678DD8;
    v282[5] = this;
    v282[4] = buf;
    v282[6] = a9;
    v115 = (*(*this + 64))(this);
    HALB_CommandGate::ExecuteCommand(v115, v282);
    *v303 = *(*&buf[8] + 24);
    *a5 = v299;
    _Block_object_dispose(buf, 8);
  }

  HALS_ObjectMap::ReleaseObject(v43, v116);
LABEL_278:
  v110 = *MEMORY[0x1E69E9840];
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (*(*(*(a1 + 32) + 8) + 24) < *(a1 + 72))
  {
    v3 = 0;
    v4 = 1;
    do
    {
      v5 = (*(*v2 + 392))(v2, v3 & 1);
      v6 = v5;
      v7 = *(*(*(a1 + 32) + 8) + 24);
      v8 = *(a1 + 72);
      if (v7 < v8 && v5 != 0)
      {
        v10 = 1;
        do
        {
          v11 = (*(*v2 + 400))(v2, v3 & 1, v10 - 1);
          v12 = (*(*v2 + 616))(v2, v11, *(a1 + 48));
          if ((v12 & HALS_Object::IsObjectClassInClassIDList(*(a1 + 76), *(a1 + 56), v11, v13)) == 1)
          {
            *(*(a1 + 64) + 4 * (*(*(*(a1 + 32) + 8) + 24))++) = *(v11 + 16);
          }

          HALS_ObjectMap::ReleaseObject(v11, v14);
          v7 = *(*(*(a1 + 32) + 8) + 24);
          v8 = *(a1 + 72);
        }

        while (v7 < v8 && v10++ < v6);
      }

      v16 = (v7 < v8) & v4;
      v3 = 1;
      v4 = 0;
    }

    while ((v16 & 1) != 0);
  }

  v17 = (*(*v2 + 632))(v2);
  v18 = v17;
  if (*(*(*(a1 + 32) + 8) + 24) < *(a1 + 72) && v17 != 0)
  {
    v20 = 1;
    do
    {
      v21 = (*(*v2 + 672))(v2, v20 - 1);
      if (HALS_Object::IsObjectClassInClassIDList(*(a1 + 76), *(a1 + 56), v21, v22))
      {
        *(*(a1 + 64) + 4 * (*(*(*(a1 + 32) + 8) + 24))++) = *(v21 + 16);
      }

      HALS_ObjectMap::ReleaseObject(v21, v23);
    }

    while (*(*(*(a1 + 32) + 8) + 24) < *(a1 + 72) && v20++ < v18);
  }
}

void sub_1DE716490(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_139(void *a1)
{
  v3 = a1[5];
  v2 = a1[6];
  v5 = *(v2 + 4);
  v4 = *(v2 + 8);
  v6 = ((*v3)[16].length)(v3, v5, v4);
  v14[0] = 0;
  v14[1] = 0;
  HALS_System::GetInstance(&theDict, 0, v14);
  Setting = HALS_SettingsManager::ReadSetting(*(theDict + 222), v3[15]);
  v18 = 1;
  if (v16)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v16);
  }

  v7 = 0;
  if (v5 > 1869968495)
  {
    if (v5 == 1869968496)
    {
      v7 = @"output.elementnames";
    }

    else if (v5 == 1886679669)
    {
      v7 = @"through.elementnames";
    }
  }

  else if (v5 == 1735159650)
  {
    v7 = @"global.elementnames";
  }

  else if (v5 == 1768845428)
  {
    v7 = @"input.elementnames";
  }

  theDict = 0;
  LOWORD(v16) = 1;
  CACFDictionary::GetCACFDictionary(&Setting, v7, &theDict);
  if (theDict)
  {
    v8 = CFStringCreateWithFormat(0, 0, @"%lu", v4);
    v12 = v8;
    v13 = 1;
    if (theDict && (Value = CFDictionaryGetValue(theDict, v8), (v10 = Value) != 0) && (v11 = CFGetTypeID(Value), v11 == CFStringGetTypeID()))
    {
      if (v6)
      {
        CFRelease(v6);
      }

      CFRetain(v10);
    }

    else
    {
      v10 = v6;
    }

    CACFString::~CACFString(&v12);
    v6 = v10;
  }

  CACFDictionary::~CACFDictionary(&theDict);
  CACFDictionary::~CACFDictionary(&Setting);
  *(*(a1[4] + 8) + 24) = v6;
}

void sub_1DE7166DC(void *a1)
{
  CACFDictionary::~CACFDictionary(&v2);
  CACFDictionary::~CACFDictionary(&v3);
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_144(uint64_t a1)
{
  v2 = *(a1 + 40);
  v3 = *(a1 + 56) >> 2;
  v4 = (*(*v2 + 664))(v2);
  if (v4 < v3)
  {
    v3 = v4;
  }

  if (v3)
  {
    v5 = 0;
    do
    {
      v6 = (*(*v2 + 672))(v2, v5);
      if (v6)
      {
        *(*(a1 + 48) + 4 * (*(*(*(a1 + 32) + 8) + 24))++) = *(v6 + 4);
      }

      HALS_ObjectMap::ReleaseObject(v6, v7);
      v5 = (v5 + 1);
    }

    while (v3 != v5);
  }
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_146(uint64_t a1)
{
  v2 = *(a1 + 40);
  v3 = *(*(a1 + 48) + 4);
  if (v3 == 1735159650)
  {
    v4 = (*(*v2 + 576))(*(a1 + 40), 1, *(a1 + 56));
    v5 = (*(*v2 + 576))(v2, 0, *(a1 + 56));
    if ((v5 + v4) >= *(a1 + 72) >> 2)
    {
      v6 = *(a1 + 72) >> 2;
    }

    else
    {
      v6 = v5 + v4;
    }

    if (*(*(*(a1 + 32) + 8) + 24) < v6)
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = (*(*v2 + 576))(v2, v7 & 1, *(a1 + 56));
        v10 = v9;
        v11 = *(*(*(a1 + 32) + 8) + 24);
        if (v11 < v6 && v9 != 0)
        {
          v13 = 1;
          do
          {
            v14 = (*(*v2 + 600))(v2, v7 & 1, v13 - 1, *(a1 + 56));
            if (v14)
            {
              *(*(a1 + 64) + 4 * (*(*(*(a1 + 32) + 8) + 24))++) = *(v14 + 4);
            }

            HALS_ObjectMap::ReleaseObject(v14, v15);
            v11 = *(*(*(a1 + 32) + 8) + 24);
          }

          while (v11 < v6 && v13++ < v10);
        }

        v17 = (v11 < v6) & v8;
        v7 = 1;
        v8 = 0;
      }

      while ((v17 & 1) != 0);
    }
  }

  else
  {
    v18 = *(a1 + 72);
    v19 = (*(*v2 + 576))(*(a1 + 40), v3 != 1869968496, *(a1 + 56));
    if (v19 >= v18 >> 2)
    {
      v20 = v18 >> 2;
    }

    else
    {
      v20 = v19;
    }

    if (v20)
    {
      v21 = 0;
      do
      {
        v22 = (*(*v2 + 600))(v2, v3 != 1869968496, v21, *(a1 + 56));
        if (v22)
        {
          *(*(a1 + 64) + 4 * (*(*(*(a1 + 32) + 8) + 24))++) = *(v22 + 4);
        }

        HALS_ObjectMap::ReleaseObject(v22, v23);
        v21 = (v21 + 1);
      }

      while (v20 != v21);
    }
  }
}

void sub_1DE716B04(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_148(uint64_t a1)
{
  v1 = *(a1 + 56);
  v2 = *(a1 + 32);
  **(a1 + 40) = v1;
  if (v1)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = (*(*v2 + 600))(v2, *(a1 + 60) != 0, v5, *(a1 + 48));
      v8 = v6;
      if (v6)
      {
        HALS_Stream::GetCurrentVirtualFormat(v6, &v11);
        v9 = *(a1 + 40) + v4;
        mBytesPerPacket = v11.mBytesPerPacket;
        *(v9 + 8) = v11.mChannelsPerFrame;
        *(v9 + 12) = mBytesPerPacket;
        *(v9 + 16) = 0;
      }

      HALS_ObjectMap::ReleaseObject(v8, v7);
      ++v5;
      v4 += 16;
    }

    while (v5 < *(a1 + 56));
  }
}

void sub_1DE716C28(void *a1, HALS_Object *a2)
{
  HALS_ObjectMap::ReleaseObject(v2, a2);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE716C10);
}

void HALS_Device::ConstructLayoutFromDictionary(HALS_Device *this, const CACFDictionary *a2, AudioChannelLayout *a3)
{
  CACFDictionary::GetUInt32(*this, @"channel layout tag", a2);
  CACFDictionary::GetUInt32(*this, @"channel bitmap", a2 + 1);
  v29 = 0;
  CACFDictionary::GetUInt32(*this, @"number channels", &v29);
  if (!*a2)
  {
    theArray = 0;
    if (CACFDictionary::GetArray(*this, @"channel descriptions", &theArray))
    {
      v26 = theArray;
      v27 = 0;
      if (theArray)
      {
        Count = CFArrayGetCount(theArray);
        v6 = Count;
        if (Count)
        {
          if (*(a2 + 2))
          {
            v7 = 0;
            v8 = a2 + 12;
            v9 = a2 + 20;
            v10 = @"channel label";
            do
            {
              v25 = 0;
              if (CACFArray::GetDictionary(&v26, v7, &v25))
              {
                v23 = v25;
                v24 = 0;
                CACFDictionary::GetUInt32(v25, v10, &v8[20 * v7]);
                CACFDictionary::GetUInt32(v23, @"channel flags", &v8[20 * v7 + 4]);
                v22 = 0;
                if (CACFDictionary::GetArray(v23, @"coordinates", &v22))
                {
                  v11 = v10;
                  v20 = v22;
                  v21 = 0;
                  if (v22)
                  {
                    v12 = CFArrayGetCount(v22);
                    if (v12)
                    {
                      v13 = 0;
                      if (v12 >= 3)
                      {
                        v14 = 3;
                      }

                      else
                      {
                        v14 = v12;
                      }

                      v15 = v9;
                      do
                      {
                        cf = 0;
                        CFType = CACFArray::GetCFType(&v20, v13, &cf);
                        v17 = cf;
                        if (cf)
                        {
                          v18 = CFType;
                        }

                        else
                        {
                          v18 = 0;
                        }

                        if (v18 == 1)
                        {
                          v19 = CFGetTypeID(cf);
                          if (v19 == CFNumberGetTypeID())
                          {
                            CFNumberGetValue(v17, kCFNumberFloat32Type, v15);
                          }
                        }

                        ++v13;
                        v15 += 4;
                      }

                      while (v14 != v13);
                    }
                  }

                  CACFArray::~CACFArray(&v20);
                  v10 = v11;
                  v8 = a2 + 12;
                }

                CACFDictionary::~CACFDictionary(&v23);
              }

              if (++v7 >= v6)
              {
                break;
              }

              v9 += 20;
            }

            while (v7 < *(a2 + 2));
          }
        }
      }

      CACFArray::~CACFArray(&v26);
    }
  }
}

void sub_1DE716E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  CACFArray::~CACFArray(va);
  _Unwind_Resume(a1);
}

uint64_t HALS_Device::ThrowIfInvalidACL(HALS_Device *this, AudioChannelLayout *a2, unsigned int a3)
{
  v17 = *MEMORY[0x1E69E9840];
  if (!this)
  {
    if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
    {
      v13 = 136315394;
      v14 = "HALS_Device.cpp";
      v15 = 1024;
      v16 = 2358;
      _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::ThrowIfInvalidACL: nullptr ACL", &v13, 0x12u);
    }

    exception = __cxa_allocate_exception(0x10uLL);
    *exception = off_1F5991DD8;
    v10 = 2003329396;
LABEL_13:
    exception[2] = v10;
  }

  v4 = a2;
  v6 = caulk::numeric::exceptional_mul<unsigned int>(*(this + 2));
  result = caulk::numeric::exceptional_add<unsigned int>(v6);
  if (result > v4)
  {
    *this = 0;
    *(this + 2) = a3;
    if (a3)
    {
      v11 = a3;
      v12 = (this + 16);
      do
      {
        *(v12 - 1) = -1;
        *v12 = 0;
        v12[1] = 0;
        v12 = (v12 + 20);
        --v11;
      }

      while (v11);
    }

    if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
    {
      v13 = 136315394;
      v14 = "HALS_Device.cpp";
      v15 = 1024;
      v16 = 2369;
      _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::ThrowIfInvalidACL: bad property data size for ACL related property", &v13, 0x12u);
    }

    exception = __cxa_allocate_exception(0x10uLL);
    *exception = off_1F5991DD8;
    v10 = 561211770;
    goto LABEL_13;
  }

  v8 = *MEMORY[0x1E69E9840];
  return result;
}

uint64_t HALS_Device::CreateIOContextDescription(HALS_Device *this, HALS_Client *a2)
{
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  if (AMCP::Feature_Flags::run_hybrid_hal(this, a2))
  {
    IOContextDescription = HALS_Device::_CreateIOContextDescription(this, a2);
    v10[3] = IOContextDescription;
  }

  else
  {
    v8[0] = MEMORY[0x1E69E9820];
    v8[1] = 0x40000000;
    v8[2] = ___ZNK11HALS_Device26CreateIOContextDescriptionEP11HALS_Client_block_invoke;
    v8[3] = &unk_1E8678B10;
    v8[4] = &v9;
    v8[5] = this;
    v8[6] = a2;
    v5 = (*(*this + 64))(this);
    HALB_CommandGate::ExecuteCommand(v5, v8);
  }

  v6 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_1DE7171A4(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE717178);
}

void sub_1DE7171B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_162(uint64_t a1)
{
  result = (*(**(a1 + 32) + 720))(*(a1 + 32), *(a1 + 48));
  **(a1 + 40) = result;
  return result;
}

void sub_1DE717224(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_164(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(a1 + 48);
  if (v3)
  {
    v4 = *(v3 + 16);
  }

  else
  {
    v4 = 0;
  }

  **(a1 + 40) = (*(*v2 + 760))(v2, v4, *(*(a1 + 56) + 4) == 1768845428);
}

void sub_1DE7172C8(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_166(void *a1)
{
  v2 = a1[5];
  v3 = a1[6];
  if (v3)
  {
    v4 = *(v3 + 16);
  }

  else
  {
    v4 = 0;
  }

  *(*(a1[4] + 8) + 24) = (*(*v2 + 760))(v2, v4, *(a1[7] + 4) == 1768845428);
}

void sub_1DE717370(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_173(void *a1)
{
  v2 = a1[5];
  v3 = a1[6];
  if (v3)
  {
    v4 = *(v3 + 16);
  }

  else
  {
    v4 = 0;
  }

  result = (*(*v2 + 792))(v2, v4);
  *(*(a1[4] + 8) + 24) = result;
  return result;
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_175(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(a1 + 40);
  if (v3)
  {
    v4 = *(v3 + 16);
  }

  else
  {
    v4 = 0;
  }

  v5 = (*(*v2 + 816))(v2, v4);
  v6 = v5;
  v7 = 1;
  if (v5)
  {
    v5 = PropertyListDeepImmutableCopy(v5);
  }

  **(a1 + 48) = v5;
  CACFString::~CACFString(&v6);
}

void sub_1DE717490(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CACFString::~CACFString(&a9);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE717480);
}

CFTypeRef ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_177(uint64_t a1)
{
  v2 = *(a1 + 32);
  result = *(v2 + 472);
  if (result)
  {
    result = CFRetain(result);
    v4 = *(v2 + 472);
  }

  else
  {
    v4 = 0;
  }

  **(a1 + 40) = v4;
  return result;
}

void sub_1DE7174F8(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

BOOL HALS_Device::GetPropertyData(unsigned int,AudioObjectPropertyAddress const&,unsigned int,unsigned int &,void *,unsigned int,void const*,HALS_Client *)const::$_0::operator()(uint64_t a1)
{
  v2 = *a1;
  if (!AMCP::Feature_Flags::use_ahal_dsp_hosting_lib(0, 0))
  {
    return 0;
  }

  v3 = **(a1 + 8);
  if (v3)
  {
    v4 = *(v3 + 16);
  }

  else
  {
    v4 = 0;
  }

  HALS_Device::DSP_Config_Properties(&v10, v2, v4);
  v6 = v10;
  v5 = v11;
  if (v10 && (*(*v10 + 16))(v10, *(a1 + 16)))
  {
    (*(*v6 + 40))(v6, *(a1 + 16), **(a1 + 24), *(a1 + 32), **(a1 + 40), **(a1 + 48), **(a1 + 56));
    v7 = 1;
    goto LABEL_11;
  }

  HALS_Device::DSP_Instance_Properties(&v10, v2, **(a1 + 8), **(a1 + 16), *(*(a1 + 16) + 8) | 0x100000000);
  v8 = v11;
  if (v10)
  {
    (*(*v10 + 40))(v10, *(a1 + 16), **(a1 + 24), *(a1 + 32), **(a1 + 40), **(a1 + 48), **(a1 + 56));
    v7 = 1;
    if (!v8)
    {
      goto LABEL_11;
    }

    goto LABEL_10;
  }

  v7 = 0;
  if (v11)
  {
LABEL_10:
    std::__shared_weak_count::__release_shared[abi:ne200100](v8);
  }

LABEL_11:
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v5);
  }

  return v7 != 0;
}

void sub_1DE7176A4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_179(uint64_t a1, const BOOL *a2)
{
  v3 = *(a1 + 68);
  v4 = *(a1 + 40);
  v5 = *(*(a1 + 48) + 8);
  v6 = *(a1 + 64);
  v7 = *(a1 + 56);
  if (AMCP::Feature_Flags::run_hybrid_hal(a1, a2))
  {
    v13[0] = 0;
    v13[1] = 0;
    HALS_System::GetInstance(&v14, 0, v13);
    v8 = *(v14 + 1744);
    os_unfair_lock_lock(v8 + 4);
    os_unfair_lock_unlock(v8 + 4);
    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v15);
    }

    v9 = 0;
  }

  else
  {
    v10 = (*(*v4 + 408))(v4);
    v12 = v10;
    if (v10)
    {
      LOBYTE(v3) = (*(*v10 + 568))(v10, v3, v5, v6, v7);
    }

    HALS_ObjectMap::ReleaseObject(v12, v11);
    v9 = (v12 != 0) & v3;
  }

  *(*(*(a1 + 32) + 8) + 24) = v9;
}

void sub_1DE717808(void *a1, HALS_Object *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  HALS_ObjectMap::ReleaseObject(v20, a2);
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_181(uint64_t a1, const BOOL *a2)
{
  v3 = *(a1 + 68);
  v4 = *(a1 + 32);
  v5 = *(*(a1 + 40) + 8);
  v6 = *(a1 + 64);
  if (AMCP::Feature_Flags::run_hybrid_hal(a1, a2))
  {
    v13[0] = 0;
    v13[1] = 0;
    HALS_System::GetInstance(&v14, 0, v13);
    v7 = *(v14 + 1744);
    os_unfair_lock_lock(v7 + 4);
    os_unfair_lock_unlock(v7 + 4);
    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v15);
    }

    v8 = 0;
  }

  else
  {
    v9 = (*(*v4 + 408))(v4);
    v11 = v9;
    if (v9)
    {
      LOBYTE(v3) = (*(*v9 + 576))(v9, v3, v5, v6);
    }

    HALS_ObjectMap::ReleaseObject(v11, v10);
    v8 = (v11 != 0) & v3;
  }

  v12 = *(a1 + 56);
  **(a1 + 48) = v8;
  *v12 = 4;
}

void sub_1DE717988(void *a1, HALS_Object *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  HALS_ObjectMap::ReleaseObject(v20, a2);
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_183(uint64_t a1, const BOOL *a2)
{
  v3 = *(a1 + 76);
  v4 = *(a1 + 40);
  v5 = *(*(a1 + 48) + 8);
  v6 = *(a1 + 72);
  v7 = *(a1 + 56);
  v8 = *(a1 + 64);
  if (AMCP::Feature_Flags::run_hybrid_hal(a1, a2))
  {
    v14[0] = 0;
    v14[1] = 0;
    HALS_System::GetInstance(&v15, 0, v14);
    v9 = *(v15 + 1744);
    os_unfair_lock_lock(v9 + 4);
    os_unfair_lock_unlock(v9 + 4);
    if (v16)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v16);
    }

    v10 = 0;
  }

  else
  {
    v11 = (*(*v4 + 408))(v4);
    v13 = v11;
    if (v11)
    {
      LOBYTE(v3) = (*(*v11 + 544))(v11, v3, v5, v6, v7, v8);
    }

    HALS_ObjectMap::ReleaseObject(v13, v12);
    v10 = (v13 != 0) & v3;
  }

  *(*(*(a1 + 32) + 8) + 24) = v10;
}

void sub_1DE717B18(void *a1, HALS_Object *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22)
{
  HALS_ObjectMap::ReleaseObject(v22, a2);
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_185(uint64_t a1, const BOOL *a2)
{
  v3 = *(a1 + 68);
  v4 = *(a1 + 32);
  v5 = *(*(a1 + 40) + 8);
  v6 = *(a1 + 64);
  if (AMCP::Feature_Flags::run_hybrid_hal(a1, a2))
  {
    v13[0] = 0;
    v13[1] = 0;
    HALS_System::GetInstance(&v14, 0, v13);
    v7 = *(v14 + 1744);
    os_unfair_lock_lock(v7 + 4);
    os_unfair_lock_unlock(v7 + 4);
    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v15);
    }

    v8 = 0;
  }

  else
  {
    v9 = (*(*v4 + 408))(v4);
    v11 = v9;
    if (v9)
    {
      LOBYTE(v3) = (*(*v9 + 552))(v9, v3, v5, v6);
    }

    HALS_ObjectMap::ReleaseObject(v11, v10);
    v8 = (v11 != 0) & v3;
  }

  v12 = *(a1 + 56);
  **(a1 + 48) = v8;
  *v12 = 4;
}

void sub_1DE717C9C(void *a1, HALS_Object *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  HALS_ObjectMap::ReleaseObject(v20, a2);
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_192(uint64_t a1)
{
  v28 = *MEMORY[0x1E69E9840];
  HALS_Device_HostedDSP_ClientInfo::get_dsp_types_for_client(v22, *(a1 + 32) + 648, *(a1 + 64), *(a1 + 40));
  v3 = v23[0];
  if (!v23[0])
  {
    goto LABEL_20;
  }

  v4 = v23;
  v5 = v23[0];
  do
  {
    v6 = v5;
    v7 = v4;
    v8 = *(v5 + 7);
    if (v8 >= 2)
    {
      v4 = v5;
    }

    v5 = v5[v8 < 2];
  }

  while (v5);
  if (v4 == v23)
  {
    v10 = v23;
    goto LABEL_12;
  }

  if (v8 < 2)
  {
    v6 = v7;
  }

  v9 = *(v6 + 7);
  v10 = v23;
  if (v9 >= 3)
  {
    do
    {
LABEL_12:
      v12 = v3;
      v13 = v10;
      v14 = *(v3 + 7);
      if (v14 >= 3)
      {
        v10 = v3;
      }

      v3 = v3[v14 < 3];
    }

    while (v3);
    if (v10 != v23)
    {
      v15 = v14 >= 3 ? v12 : v13;
      if (*(v15 + 7) < 4u)
      {
LABEL_21:
        v11 = 2 * (v10 != v23);
        if (v10 == v23)
        {
          goto LABEL_31;
        }

        goto LABEL_22;
      }
    }

LABEL_20:
    v10 = v23;
    goto LABEL_21;
  }

  v11 = 1;
LABEL_22:
  if ((*(a1 + 65) & 1) == 0)
  {
    v16 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v16 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v2);
    }

    v18 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v17 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      v19 = *v18;
      std::__shared_weak_count::__release_shared[abi:ne200100](v17);
    }

    else
    {
      v19 = *v18;
    }

    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315394;
      v25 = "HALS_Device.cpp";
      v26 = 1024;
      v27 = 4326;
      _os_log_error_impl(&dword_1DE1F9000, v19, OS_LOG_TYPE_ERROR, "%32s:%-5d HALS_Device::GetPropertyData: Unexpected Vocal Isolation setting on device with no input streams.", buf, 0x12u);
    }

    v11 = 0;
  }

LABEL_31:
  v20 = *(a1 + 56);
  **(a1 + 48) = v11;
  *v20 = 4;
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v23[0]);
  v21 = *MEMORY[0x1E69E9840];
}

void sub_1DE717EDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11)
{
  if (a2)
  {
    std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a11);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1DE717E60);
  }

  _Unwind_Resume(exception_object);
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_195(uint64_t a1)
{
  HALS_Device_HostedDSP_ClientInfo::get_dsp_types_for_client(v17, *(a1 + 32) + 648, *(a1 + 64), *(a1 + 40));
  v2 = v18[0];
  if (!v18[0])
  {
LABEL_19:
    v8 = v18;
LABEL_20:
    v12 = 2 * (v8 != v18);
    goto LABEL_21;
  }

  v3 = v18;
  v4 = v18[0];
  do
  {
    v5 = v4;
    v6 = v3;
    v7 = *(v4 + 7);
    if (v7 >= 4)
    {
      v3 = v4;
    }

    v4 = v4[v7 < 4];
  }

  while (v4);
  v8 = v18;
  v9 = v18[0];
  if (v3 == v18 || (v7 >= 4 ? (v10 = v5) : (v10 = v6), v11 = *(v10 + 7), v8 = v18, v9 = v18[0], v11 >= 5))
  {
    do
    {
      v13 = v9;
      v14 = v8;
      v15 = *(v9 + 28);
      if (v15 >= 5)
      {
        v8 = v9;
      }

      v9 = *(v9 + 8 * (v15 < 5));
    }

    while (v9);
    if (v8 != v18)
    {
      if (v15 < 5)
      {
        v13 = v14;
      }

      if (*(v13 + 7) < 6u)
      {
        goto LABEL_20;
      }
    }

    goto LABEL_19;
  }

  v12 = 1;
LABEL_21:
  v16 = *(a1 + 56);
  **(a1 + 48) = v12;
  *v16 = 4;
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v2);
}

void sub_1DE71801C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE71800CLL);
}

void HALS_Device::GetDSPVirtualChannelLayoutForClient(HALS_Device *this, uint64_t a2, HALS_Client *a3, uint64_t a4)
{
  if (a3 || !a4)
  {
    *this = 0;
    *(this + 24) = 0;
  }

  else
  {
    v8 = 0;
    v9 = &v8;
    v10 = 0x4802000000;
    v11 = __Block_byref_object_copy__304;
    v12 = __Block_byref_object_dispose__305;
    LOBYTE(__p) = 0;
    v15 = 0;
    v6[0] = MEMORY[0x1E69E9820];
    v6[1] = 0x40000000;
    v6[2] = ___ZNK11HALS_Device35GetDSPVirtualChannelLayoutForClientEbP11HALS_Client_block_invoke;
    v6[3] = &unk_1E8679388;
    v6[4] = &v8;
    v6[5] = a2;
    v7 = 0;
    v6[6] = a4;
    v5 = (*(*a2 + 64))(a2);
    HALB_CommandGate::ExecuteCommand(v5, v6);
    std::__optional_copy_base<CA::ChannelLayout,false>::__optional_copy_base[abi:ne200100](this, (v9 + 5));
    _Block_object_dispose(&v8, 8);
    if (v15 == 1)
    {
      if (__p)
      {
        v14 = __p;
        operator delete(__p);
      }
    }
  }
}

void sub_1DE718160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, uint64_t a25, char a26)
{
  _Block_object_dispose(&a18, 8);
  if (a26 == 1)
  {
    if (__p)
    {
      a24 = __p;
      operator delete(__p);
    }
  }

  _Unwind_Resume(a1);
}

unint64_t CA::ChannelLayout::GetNumberChannelDescriptions(CA::ChannelLayout *this, uint64_t a2)
{
  result = *(this + 2);
  if (result > (a2 - this - 12) / 0x14uLL)
  {
    __assert_rtn("GetNumberChannelDescriptions", "CoreAudioBaseTypes.hpp", 2252, "GetAudioChannelLayout().mNumberChannelDescriptions <= (mStorage.size() - kHeaderSize) / sizeof(AudioChannelDescription)");
  }

  return result;
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_197(uint64_t a1)
{
  HALS_Device_HostedDSP_ClientInfo::get_dsp_types_for_client(v9, *(a1 + 40) + 648, *(a1 + 64), *(a1 + 48));
  v2 = v10[0];
  if (v10[0])
  {
    v3 = v10;
    v4 = v10[0];
    do
    {
      v5 = v4;
      v6 = v3;
      v7 = *(v4 + 7);
      if (v7 >= 6)
      {
        v3 = v4;
      }

      v4 = v4[v7 < 6];
    }

    while (v4);
    if (v3 != v10)
    {
      if (v7 >= 6)
      {
        v8 = v5;
      }

      else
      {
        v8 = v6;
      }

      if (*(v8 + 7) <= 6u)
      {
        *(*(*(a1 + 32) + 8) + 24) = 1;
      }
    }
  }

  **(a1 + 56) = 4;
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v2);
}

void sub_1DE7182A4(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE718294);
}

void *___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_201(void *result)
{
  v11 = *MEMORY[0x1E69E9840];
  if (*(result[5] + 4) == 1768845428)
  {
    v1 = result[4];
    v3 = result[6];
    v2 = result[7];
    v4 = result[8];
    std::mutex::lock((v1 + 704));
    if (v3)
    {
      v5 = *(v3 + 16);
    }

    else
    {
      if (*(v1 + 660) != 1)
      {
        goto LABEL_9;
      }

      v5 = 0;
    }

    v6 = std::__hash_table<std::__hash_value_type<unsigned int,HALS_Device_HostedDSP_ClientInfo::PerClientInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,HALS_Device_HostedDSP_ClientInfo::PerClientInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,HALS_Device_HostedDSP_ClientInfo::PerClientInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,HALS_Device_HostedDSP_ClientInfo::PerClientInfo>>>::find<unsigned int>((v1 + 664), v5);
    if (v6)
    {
      v7 = v6[7];
      if (v7)
      {
        DSP_Host_OffloadDictionary::create_into(v7, v2);
      }
    }

LABEL_9:
    memset(buf, 0, sizeof(buf));
    cf = 0;
    DSP_Host_OffloadDictionary::make_empty(buf);
    DSP_Host_OffloadDictionary::create_into(buf, v2);
  }

  v8 = *MEMORY[0x1E69E9840];
  return result;
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_203(uint64_t a1)
{
  v2 = *(a1 + 32);
  memset(v4, 0, sizeof(v4));
  DSP_Host_OffloadDictionary::make_empty(v4);
  v3 = *(v2 + 632);
  if (v3)
  {
    HALS_Device_HostedDSP::GetOffloadsAvailableForDevice(v3, *(*(a1 + 40) + 4) == 1768845428, v4);
  }

  DSP_Host_OffloadDictionary::create_into(v4, *(a1 + 48));
}

void sub_1DE718690(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  DSP_Host_OffloadDictionary::~DSP_Host_OffloadDictionary(va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE71867CLL);
}

void ___ZNK11HALS_Device15GetPropertyDataEjRK26AudioObjectPropertyAddressjRjPvjPKvP11HALS_Client_block_invoke_206(uint64_t a1)
{
  v1 = *(*(a1 + 48) + 632);
  if (v1)
  {
    v3 = *(a1 + 64);
    v4 = *(a1 + 56);
    v5 = *(*(a1 + 40) + 8);
    std::string::basic_string[abi:ne200100]<0>(__p, "content creation recording");
    if (!v3)
    {
      LOBYTE(Value) = 0;
      goto LABEL_30;
    }

    v6 = *v1;
    std::mutex::lock(*v1 + 11);
    v7 = HALS_Device_HostedDSP_ClientInfo::find(v6[10].__m_.__opaque, v4, 1);
    if (v7)
    {
      Value = v7[5];
      if (Value)
      {
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
        v19 = Mutable;
        v10 = Value[2];
        if (v10 && CFDictionaryGetCount(v10))
        {
          v11 = Value[2];
          if (!v11)
          {
            exception = __cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Could not construct");
            __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
          }

          if ((v18 & 0x80u) == 0)
          {
            v12 = __p;
          }

          else
          {
            v12 = __p[0];
          }

          if (v12)
          {
            if ((v18 & 0x80u) == 0)
            {
              v13 = v18;
            }

            else
            {
              v13 = __p[1];
            }

            v12 = CFStringCreateWithBytes(0, v12, v13, 0x8000100u, 0);
            cf = v12;
            if (!v12)
            {
              v14 = __cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v14, "Could not construct");
              __cxa_throw(v14, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
            }
          }

          else
          {
            cf = 0;
          }

          Value = CFDictionaryGetValue(v11, v12);
          if (cf)
          {
            CFRelease(cf);
          }

          if (!Value)
          {
            goto LABEL_27;
          }

          CFRetain(Value);
          v15 = CFGetTypeID(Value);
          if (v15 == CFDictionaryGetTypeID())
          {
            *(v5 + 24) = Value;
            LOBYTE(Value) = 1;
            goto LABEL_27;
          }

          CFRelease(Value);
        }

        LOBYTE(Value) = 0;
LABEL_27:
        if (Mutable)
        {
          CFRelease(Mutable);
        }
      }
    }

    else
    {
      LOBYTE(Value) = 0;
    }

    std::mutex::unlock(v6 + 11);
LABEL_30:
    *(*(*(a1 + 32) + 8) + 24) = Value;
    if (v18 < 0)
    {
      operator delete(__p[0]);
    }
  }
}

void sub_1DE7188D8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, const void *a18)
{
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef(&a18);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE71884CLL);
}

void HALS_Device::GetHostedDSPConfiguration(HALS_Device *this, uint64_t a2, unsigned int a3)
{
  if (AMCP::Feature_Flags::use_ahal_dsp_hosting_lib(0, 0))
  {
    HALS_Device::GetDSPOffloadsRequested(&cf, a2, 1);
    v6 = *(a2 + 624);
    if (cf)
    {
      v7 = v6 == 0;
    }

    else
    {
      v7 = 1;
    }

    if (!v7)
    {
      HALS_Device::GetModelUID(__p, a2);
      HALS_DSPHostPerClientConfiguration::set_offloads_requested(v6, a3, &cf, __p);
      if (v21 == 1 && v20 < 0)
      {
        operator delete(__p[0]);
      }
    }

    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
    if (v6)
    {
      HALS_DSPHostPerClientConfiguration::serialize_to_description(v6, a3, Mutable);
    }

    if (Mutable)
    {
      v9 = CFGetTypeID(Mutable);
      if (v9 != CFDictionaryGetTypeID())
      {
        exception = __cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
      }

      *this = 0;
      *(this + 8) = 0;
      Data = CFPropertyListCreateData(0, Mutable, kCFPropertyListBinaryFormat_v1_0, 0, 0);
      v11 = Data;
      if (Data)
      {
        v23 = Data;
        v12 = CFGetTypeID(Data);
        if (v12 != CFDataGetTypeID())
        {
          v18 = __cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v18, "Could not construct");
          __cxa_throw(v18, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
        }

        *(this + 8) = 1;
        *this = v11;
      }
    }

    else
    {
      *this = 0;
      *(this + 8) = 0;
    }

    if (Mutable)
    {
      CFRelease(Mutable);
    }

    if (cf)
    {
      CFRelease(cf);
    }
  }

  else
  {
    v13 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
    v23 = v13;
    AHAL_DSP::CF::Dictionary_Builder::get_dictionary(&cf, v13);
    v14 = CFPropertyListCreateData(0, cf, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (cf)
    {
      CFRelease(cf);
    }

    cf = v14;
    if (v14)
    {
      v15 = CFGetTypeID(v14);
      if (v15 != CFDataGetTypeID())
      {
        v16 = __cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v16, "Could not construct");
        __cxa_throw(v16, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
      }
    }

    *this = v14;
    *(this + 8) = 1;
    if (v13)
    {
      CFRelease(v13);
    }
  }
}

void sub_1DE718C50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, const void *a19)
{
  __cxa_free_exception(v20);
  applesauce::CF::ObjectRef<__CFData const*>::~ObjectRef((v21 - 40));
  std::optional<applesauce::CF::DataRef>::~optional(v19);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a10);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a19);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__304(uint64_t a1, uint64_t a2)
{
  *(a1 + 40) = 0;
  *(a1 + 64) = 0;
  if (*(a2 + 64) == 1)
  {
    *(a1 + 40) = 0;
    *(a1 + 48) = 0;
    *(a1 + 56) = 0;
    result = *(a2 + 40);
    *(a1 + 40) = result;
    *(a1 + 56) = *(a2 + 56);
    *(a2 + 40) = 0;
    *(a2 + 48) = 0;
    *(a2 + 56) = 0;
    *(a1 + 64) = 1;
  }

  return result;
}

void __Block_byref_object_dispose__305(uint64_t a1)
{
  if (*(a1 + 64) == 1)
  {
    v1 = *(a1 + 40);
    if (v1)
    {
      *(a1 + 48) = v1;
      operator delete(v1);
    }
  }
}

void ___ZNK11HALS_Device35GetDSPVirtualChannelLayoutForClientEbP11HALS_Client_block_invoke(uint64_t a1)
{
  HALS_Device_HostedDSP_ClientInfo::get_virtual_channel_layout_for_client(__p, *(a1 + 40) + 648, *(a1 + 56), *(a1 + 48));
  std::__optional_storage_base<CA::ChannelLayout,false>::__assign_from[abi:ne200100]<std::__optional_copy_assign_base<CA::ChannelLayout,false> const&>(*(*(a1 + 32) + 8) + 40, __p);
  if (v3 == 1)
  {
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
}

void sub_1DE718E0C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
  if (a12 == 1 && __p)
  {
    operator delete(__p);
  }

  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE718DFCLL);
}

uint64_t HALS_Device::_CreateIOContextDescription(HALS_Device *this, HALS_Client *a2)
{
  v43 = *MEMORY[0x1E69E9840];
  if (AMCP::Feature_Flags::run_hybrid_hal(this, a2))
  {
    v29[0] = 0;
    v29[1] = 0;
    HALS_System::GetInstance(&v30, 0, v29);
    v4 = *(v30 + 1744);
    v5 = *(this + 4);
    v6 = (*(*this + 224))(this);
    std::string::basic_string[abi:ne200100]<0>(&v27, v6);
    os_unfair_lock_lock((v4 + 16));
    mcp_object = HALS_IOContext_Manager_Impl::Object_Map::find_mcp_object((v4 + 40), v5);
    os_unfair_lock_unlock((v4 + 16));
    if (HIDWORD(mcp_object))
    {
      os_unfair_lock_lock((v4 + 16));
      AMCP::Core::Broker::fetch_core(&v40, *(v4 + 120), mcp_object);
      if (v40.__r_.__value_.__r.__words[0])
      {
        AMCP::Core::Core::get_simple_required_property<1969841184u>(&cf, v40.__r_.__value_.__l.__data_);
      }

      else
      {
        cf = 0;
      }

      if (v40.__r_.__value_.__l.__size_)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v40.__r_.__value_.__l.__size_);
      }

      os_unfair_lock_unlock((v4 + 16));
      if (a2)
      {
        v11 = *(a2 + 60);
      }

      else
      {
        v11 = 0;
      }

      std::operator+<char>();
      v12 = std::string::append(&v41, "(", 1uLL);
      v13 = *&v12->__r_.__value_.__l.__data_;
      v38.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
      *&v38.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v37, v11);
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v14 = &v37;
      }

      else
      {
        v14 = v37.__r_.__value_.__r.__words[0];
      }

      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = HIBYTE(v37.__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = v37.__r_.__value_.__l.__size_;
      }

      v16 = std::string::append(&v38, v14, size);
      v17 = *&v16->__r_.__value_.__l.__data_;
      valuePtr.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *&valuePtr.__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      v18 = std::string::append(&valuePtr, ":", 1uLL);
      v19 = *&v18->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
      *&v39.__r_.__value_.__l.__data_ = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v36, v5);
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v20 = &v36;
      }

      else
      {
        v20 = v36.__r_.__value_.__r.__words[0];
      }

      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v21 = HIBYTE(v36.__r_.__value_.__r.__words[2]);
      }

      else
      {
        v21 = v36.__r_.__value_.__l.__size_;
      }

      v22 = std::string::append(&v39, v20, v21);
      v23 = *&v22->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
      *&v40.__r_.__value_.__l.__data_ = v23;
      v22->__r_.__value_.__l.__size_ = 0;
      v22->__r_.__value_.__r.__words[2] = 0;
      v22->__r_.__value_.__r.__words[0] = 0;
      v24 = std::string::append(&v40, ")", 1uLL);
      v25 = *&v24->__r_.__value_.__l.__data_;
      v34 = v24->__r_.__value_.__r.__words[2];
      *__p = v25;
      v24->__r_.__value_.__l.__size_ = 0;
      v24->__r_.__value_.__r.__words[2] = 0;
      v24->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v40.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v36.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v39.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(valuePtr.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v37.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v38.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v41.__r_.__value_.__l.__data_);
      }

      os_unfair_lock_lock((v4 + 16));
      HALS_IOContext_Manager_Impl::get_graph_builder();
    }

    v32 = 0;
    if (v28 < 0)
    {
      operator delete(v27);
    }

    if (v31)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v31);
    }

    result = v32;
    v26 = *MEMORY[0x1E69E9840];
  }

  else
  {
    v8 = *(*this + 688);
    v9 = *MEMORY[0x1E69E9840];

    return v8(this, a2);
  }

  return result;
}

void sub_1DE719850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, const void *a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27, const void *a28, void *a29, uint64_t a30, int a31, __int16 a32, char a33, char a34, void *a35, uint64_t a36, int a37, __int16 a38, char a39, char a40, void *a41, uint64_t a42, int a43, __int16 a44, char a45, char a46)
{
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef((v48 - 176));
  applesauce::CF::StringRef::~StringRef((v48 - 144));
  mcp_applesauce::CF::Dictionary_Builder::~Dictionary_Builder(&a29);
  applesauce::CF::StringRef::~StringRef(&a20);
  std::default_delete<HALIO::HALIO_Graph_Builder>::operator()[abi:ne200100](v46);
  os_unfair_lock_unlock(v47 + 4);
  if (a27 < 0)
  {
    operator delete(__p);
  }

  applesauce::CF::StringRef::~StringRef(&a28);
  if (a14 < 0)
  {
    operator delete(a9);
  }

  if (a18)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a18);
  }

  if (a16)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a16);
  }

  _Unwind_Resume(a1);
}

uint64_t ___ZNK11HALS_Device26CreateIOContextDescriptionEP11HALS_Client_block_invoke(uint64_t a1)
{
  result = HALS_Device::_CreateIOContextDescription(*(a1 + 40), *(a1 + 48));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE719BA8(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t HALS_Device::GetPropertyDataSize(HALS_Device_HostedDSP **this, unsigned int a2, AudioObjectPropertyAddress *a3, unsigned int a4, _DWORD *a5, AudioObjectPropertyAddress *a6)
{
  v57 = *MEMORY[0x1E69E9840];
  v50 = a4;
  v48 = a6;
  v49 = a5;
  v47[0] = this;
  v47[1] = &v48;
  v47[2] = a3;
  v47[3] = &v50;
  v47[4] = &v49;
  v46 = 0;
  mSelector = a3->mSelector;
  if (a3->mSelector > 1768124269)
  {
    if (mSelector <= 1934647618)
    {
      if (mSelector <= 1852793962)
      {
        if (mSelector <= 1818850925)
        {
          if (mSelector == 1768124270 || mSelector == 1768777573)
          {
            goto LABEL_81;
          }

          v10 = 1768907636;
        }

        else
        {
          if (mSelector <= 1819634019)
          {
            if (mSelector != 1818850926)
            {
              v9 = 1819569763;
              goto LABEL_89;
            }

LABEL_90:
            v11 = 4;
            goto LABEL_91;
          }

          if (mSelector == 1819634020)
          {
            goto LABEL_81;
          }

          v10 = 1836411236;
        }

LABEL_80:
        if (mSelector == v10)
        {
          goto LABEL_81;
        }

LABEL_124:
        v31 = HALS_Device::GetPropertyDataSize(unsigned int,AudioObjectPropertyAddress const&,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v47, &v46);
        if (v31)
        {
          goto LABEL_92;
        }

        PropertyDataSize = HALS_Object::GetPropertyDataSize(v31, v32, a3);
LABEL_126:
        v46 = PropertyDataSize;
        goto LABEL_92;
      }

      if (mSelector > 1869180522)
      {
        if (mSelector <= 1886353265)
        {
          if (mSelector == 1869180523)
          {
            goto LABEL_90;
          }

          if (mSelector != 1870098020)
          {
            goto LABEL_124;
          }

          *buf = 0;
          *&buf[8] = buf;
          *&buf[16] = 0x2000000000;
          v56 = 0;
          v44[0] = MEMORY[0x1E69E9820];
          v44[1] = 0x40000000;
          v44[2] = ___ZNK11HALS_Device19GetPropertyDataSizeEjRK26AudioObjectPropertyAddressjPKvP11HALS_Client_block_invoke;
          v44[3] = &unk_1E8678C60;
          v45 = a4 >> 2;
          v44[6] = a6;
          v44[7] = a5;
          v44[4] = buf;
          v44[5] = this;
          v12 = (*(*this + 8))(this);
          HALB_CommandGate::ExecuteCommand(v12, v44);
          v46 = 4 * *(*&buf[8] + 24);
          goto LABEL_107;
        }

        if (mSelector == 1886353266)
        {
          goto LABEL_90;
        }

        v9 = 1919512167;
LABEL_89:
        if (mSelector == v9)
        {
          goto LABEL_90;
        }

        goto LABEL_124;
      }

      if (mSelector == 1852793963)
      {
        goto LABEL_90;
      }

      if (mSelector != 1853059619)
      {
        v10 = 1853059700;
        goto LABEL_80;
      }

      goto LABEL_92;
    }

    if (mSelector <= 1937009954)
    {
      if (mSelector > 1936092275)
      {
        if (mSelector > 1936876643)
        {
          if (mSelector == 1936876644 || mSelector == 1936879204)
          {
            TotalNumberChannelsForClient = HALS_Device::GetTotalNumberChannelsForClient(this, a3->mScope == 1768845428, a6);
            v19 = caulk::numeric::exceptional_mul<unsigned int>(TotalNumberChannelsForClient);
            PropertyDataSize = caulk::numeric::exceptional_add<unsigned int>(v19);
            goto LABEL_126;
          }

          goto LABEL_124;
        }

        if (mSelector == 1936092276)
        {
          goto LABEL_90;
        }

        if (mSelector == 1936482681)
        {
          v11 = (16 * (*(*this + 68))(this, a3->mScope == 1768845428, a6)) | 8;
LABEL_91:
          v46 = v11;
          goto LABEL_92;
        }

        goto LABEL_124;
      }

      if (mSelector != 1934647619)
      {
        if (mSelector == 1934647636)
        {
          if (HALS_Device::GetPropertyDataSize(unsigned int,AudioObjectPropertyAddress const&,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v47, &v46))
          {
            goto LABEL_92;
          }

          goto LABEL_90;
        }

        v9 = 1935763060;
        goto LABEL_89;
      }

      if (!HALS_Device::GetPropertyDataSize(unsigned int,AudioObjectPropertyAddress const&,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v47, &v46))
      {
        HALS_Device::GetDSPVirtualChannelLayoutForClient(buf, this, (a3->mScope == 1768845428), v48);
        if (v56)
        {
          v46 = *&buf[8] - *buf;
          if (*buf)
          {
            *&buf[8] = *buf;
            operator delete(*buf);
          }
        }

        else
        {
          v46 = 0;
        }
      }

      goto LABEL_92;
    }

    if (mSelector > 1983996970)
    {
      if (mSelector <= 1986622323)
      {
        if (mSelector != 1983996971)
        {
          if (mSelector != 1983997011)
          {
            goto LABEL_124;
          }

          if (HALS_Device::GetPropertyDataSize(unsigned int,AudioObjectPropertyAddress const&,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v47, &v46))
          {
            goto LABEL_92;
          }

LABEL_39:
          PropertyDataSize = HALS_Device_HostedDSP::GetPropertyDataSize(this[79], a3, v48, v13, v14, v15);
          goto LABEL_126;
        }

        if (HALS_Device::GetPropertyDataSize(unsigned int,AudioObjectPropertyAddress const&,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v47, &v46))
        {
          goto LABEL_92;
        }

        if (!v48)
        {
          goto LABEL_92;
        }

        v24 = atomic_load(&v48[22].mScope);
        if (a3->mScope != 1768845428)
        {
          goto LABEL_92;
        }

LABEL_98:
        if ((v24 & 1) == 0)
        {
          goto LABEL_92;
        }

        goto LABEL_90;
      }

      if (mSelector != 1986622324)
      {
        v9 = 2003136116;
        goto LABEL_89;
      }

LABEL_93:
      v22 = HALS_Device::GetPropertyDataSize(unsigned int,AudioObjectPropertyAddress const&,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v47, &v46);
      if (v48)
      {
        v23 = v22;
      }

      else
      {
        v23 = 1;
      }

      if (v23)
      {
        goto LABEL_92;
      }

      v24 = atomic_load(&v48[22].mScope);
      goto LABEL_98;
    }

    if (mSelector != 1937009955)
    {
      if (mSelector == 1953653102)
      {
        goto LABEL_90;
      }

      v10 = 1969841184;
      goto LABEL_80;
    }

    mScope = a3->mScope;
    if (mScope == 1735159650)
    {
      v30 = (*(*this + 68))(this, 1, a6);
      v11 = 4 * ((*(*this + 68))(this, 0, v48) + v30);
      goto LABEL_91;
    }

    v25 = (*(*this + 68))(this, mScope == 1768845428, a6);
LABEL_128:
    v11 = 4 * v25;
    goto LABEL_91;
  }

  if (mSelector <= 1684498540)
  {
    if (mSelector <= 1667461732)
    {
      if (mSelector > 1634758764)
      {
        if (mSelector == 1634758765 || mSelector == 1634758774)
        {
          goto LABEL_90;
        }

        v10 = 1667330160;
      }

      else
      {
        if (mSelector == 1634429294 || mSelector == 1634496615)
        {
          goto LABEL_90;
        }

        v10 = 1634755428;
      }

      goto LABEL_80;
    }

    if (mSelector <= 1668575851)
    {
      if (mSelector == 1667461733)
      {
        goto LABEL_93;
      }

      if (mSelector != 1667523955)
      {
        v9 = 1668049764;
        goto LABEL_89;
      }
    }

    else
    {
      if (mSelector <= 1684301170)
      {
        if (mSelector != 1668575852)
        {
          v10 = 1684236338;
          goto LABEL_80;
        }

        v25 = (*(*this + 79))(this);
        goto LABEL_128;
      }

      if (mSelector != 1684301171)
      {
        v9 = 1684434036;
        goto LABEL_89;
      }
    }

LABEL_81:
    v11 = 8;
    goto LABEL_91;
  }

  if (mSelector > 1685414762)
  {
    if (mSelector > 1751412336)
    {
      if (mSelector > 1751737453)
      {
        if (mSelector == 1751737454)
        {
          goto LABEL_90;
        }

        v10 = 1752122448;
      }

      else
      {
        if (mSelector == 1751412337)
        {
          goto LABEL_90;
        }

        v10 = 1751413616;
      }

      goto LABEL_80;
    }

    if (mSelector == 1685414763)
    {
      v11 = 16;
      goto LABEL_91;
    }

    if (mSelector == 1735354734)
    {
      goto LABEL_90;
    }

    v9 = 1735356005;
    goto LABEL_89;
  }

  if (mSelector > 1684500593)
  {
    if (mSelector > 1685278560)
    {
      if (mSelector == 1685278561 || mSelector == 1685278562)
      {
        if (HALS_Device::GetPropertyDataSize(unsigned int,AudioObjectPropertyAddress const&,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v47, &v46))
        {
          goto LABEL_92;
        }

        goto LABEL_81;
      }

      goto LABEL_124;
    }

    if (mSelector != 1684500594)
    {
      v10 = 1685089383;
      goto LABEL_80;
    }

    if (!a5)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
      {
        *buf = 136315394;
        *&buf[4] = "HALS_Device.cpp";
        *&buf[12] = 1024;
        *&buf[14] = 3475;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyDataSize: inQualifierData is nullptr for kAudioDevicePropertyDSPGraphProperty", buf, 0x12u);
      }

      exception = __cxa_allocate_exception(0x10uLL);
      *exception = off_1F5991DD8;
      exception[2] = 1852797029;
    }

    if (a4 != 4)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
      {
        *buf = 136315394;
        *&buf[4] = "HALS_Device.cpp";
        *&buf[12] = 1024;
        *&buf[14] = 3477;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyDataSize: incorrect inQualifierDataSize for kAudioDevicePropertyDSPGraphProperty", buf, 0x12u);
      }

      v34 = __cxa_allocate_exception(0x10uLL);
      *v34 = off_1F5991DD8;
      v34[2] = 1852797029;
    }

    v26 = a3->mScope;
    if (v26 != 1768845428 && v26 != 1869968496)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
      {
        *buf = 136315394;
        *&buf[4] = "HALS_Device.cpp";
        *&buf[12] = 1024;
        *&buf[14] = 3479;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_Device::_GetPropertyDataSize: incorrect inAddress.mScope for kAudioDevicePropertyDSPGraphProperty", buf, 0x12u);
      }

      v36 = __cxa_allocate_exception(0x10uLL);
      *v36 = off_1F5991DD8;
      v36[2] = 1852797029;
    }

    v27 = *a5;
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2000000000;
    LOBYTE(v56) = 0;
    v40 = 0;
    v41 = &v40;
    v42 = 0x2000000000;
    v43 = 0;
    v37[0] = MEMORY[0x1E69E9820];
    v37[1] = 0x40000000;
    v37[2] = ___ZNK11HALS_Device19GetPropertyDataSizeEjRK26AudioObjectPropertyAddressjPKvP11HALS_Client_block_invoke_136;
    v37[3] = &unk_1E8678C88;
    v39 = v26 == 1768845428;
    v37[6] = this;
    v37[7] = a3;
    v38 = v27;
    v37[4] = buf;
    v37[5] = &v40;
    v28 = (*(*this + 8))(this);
    HALB_CommandGate::ExecuteCommand(v28, v37);
    v46 = *(v41 + 6);
    if ((*(*&buf[8] + 24) & 1) == 0)
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
      {
        *v51 = 136315394;
        v52 = "HALS_Device.cpp";
        v53 = 1024;
        v54 = 3497;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  GetStreamDSPPropertyInfo failure", v51, 0x12u);
      }

      v35 = __cxa_allocate_exception(0x10uLL);
      *v35 = off_1F5991DD8;
      v35[2] = 1852797029;
    }

    _Block_object_dispose(&v40, 8);
LABEL_107:
    _Block_object_dispose(buf, 8);
    goto LABEL_92;
  }

  if (mSelector == 1684498541 || mSelector == 1684498544)
  {
    goto LABEL_90;
  }

  if (mSelector != 1684500589)
  {
    goto LABEL_124;
  }

  if (!HALS_Device::GetPropertyDataSize(unsigned int,AudioObjectPropertyAddress const&,unsigned int,void const*,HALS_Client *)const::$_0::operator()(v47, &v46))
  {
    if ((HALS_Device_HostedDSP::HasProperty(this[79], a3, v48, v17) & 0x100) == 0)
    {
      goto LABEL_90;
    }

    goto LABEL_39;
  }

LABEL_92:
  result = v46;
  v21 = *MEMORY[0x1E69E9840];
  return result;
}

void ___ZNK11HALS_Device19GetPropertyDataSizeEjRK26AudioObjectPropertyAddressjPKvP11HALS_Client_block_invoke(uint64_t a1)
{
  v2 = 0;
  v3 = *(a1 + 40);
  v4 = 1;
  do
  {
    v5 = v4;
    v6 = (*(*v3 + 392))(v3, v2 & 1);
    if (v6)
    {
      v7 = v6;
      v8 = 0;
      do
      {
        v9 = (*(*v3 + 400))(v3, v2 & 1, v8);
        v10 = (*(*v3 + 616))(v3, v9, *(a1 + 48));
        if ((v10 & HALS_Object::IsObjectClassInClassIDList(*(a1 + 64), *(a1 + 56), v9, v11)) == 1)
        {
          ++*(*(*(a1 + 32) + 8) + 24);
        }

        HALS_ObjectMap::ReleaseObject(v9, v12);
        v8 = (v8 + 1);
      }

      while (v7 != v8);
    }

    v4 = 0;
    v2 = 1;
  }

  while ((v5 & 1) != 0);
  v13 = (*(*v3 + 664))(v3);
  if (v13)
  {
    v14 = v13;
    v15 = 0;
    do
    {
      v16 = (*(*v3 + 672))(v3, v15);
      if (HALS_Object::IsObjectClassInClassIDList(*(a1 + 64), *(a1 + 56), v16, v17))
      {
        ++*(*(*(a1 + 32) + 8) + 24);
      }

      HALS_ObjectMap::ReleaseObject(v16, v18);
      v15 = (v15 + 1);
    }

    while (v14 != v15);
  }
}

BOOL HALS_Device::GetPropertyDataSize(unsigned int,AudioObjectPropertyAddress const&,unsigned int,void const*,HALS_Client *)const::$_0::operator()(uint64_t a1, _DWORD *a2)
{
  v4 = *a1;
  if (!AMCP::Feature_Flags::use_ahal_dsp_hosting_lib(0, 0))
  {
    return 0;
  }

  v5 = **(a1 + 8);
  if (v5)
  {
    v6 = *(v5 + 16);
  }

  else
  {
    v6 = 0;
  }

  HALS_Device::DSP_Config_Properties(&v12, v4, v6);
  v8 = v12;
  v7 = v13;
  if (v12 && (*(*v12 + 16))(v12, *(a1 + 16)))
  {
    *a2 = (*(*v8 + 32))(v8, *(a1 + 16), **(a1 + 24), **(a1 + 32));
    v9 = 1;
    goto LABEL_11;
  }

  HALS_Device::DSP_Instance_Properties(&v12, v4, **(a1 + 8), **(a1 + 16), *(*(a1 + 16) + 8) | 0x100000000);
  v10 = v13;
  if (v12)
  {
    *a2 = (*(*v12 + 32))(v12, *(a1 + 16), **(a1 + 24), **(a1 + 32));
    v9 = 1;
    if (!v10)
    {
      goto LABEL_11;
    }

    goto LABEL_10;
  }

  v9 = 0;
  if (v13)
  {
LABEL_10:
    std::__shared_weak_count::__release_shared[abi:ne200100](v10);
  }

LABEL_11:
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }

  return v9 != 0;
}

void sub_1DE71ACC4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void ___ZNK11HALS_Device19GetPropertyDataSizeEjRK26AudioObjectPropertyAddressjPKvP11HALS_Client_block_invoke_136(uint64_t a1, const BOOL *a2)
{
  v13 = 0;
  v3 = *(a1 + 68);
  v4 = *(a1 + 48);
  v5 = *(*(a1 + 56) + 8);
  v6 = *(a1 + 64);
  v7 = *(*(a1 + 40) + 8);
  if (AMCP::Feature_Flags::run_hybrid_hal(a1, a2))
  {
    v14[0] = 0;
    v14[1] = 0;
    HALS_System::GetInstance(&v15, 0, v14);
    v8 = *(v15 + 1744);
    os_unfair_lock_lock(v8 + 4);
    os_unfair_lock_unlock(v8 + 4);
    if (v16)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v16);
    }

    v9 = 0;
  }

  else
  {
    v10 = (*(*v4 + 408))(v4);
    v12 = v10;
    if (v10)
    {
      LOBYTE(v3) = (*(*v10 + 536))(v10, v3, v5, v6, v7 + 24, &v13);
    }

    HALS_ObjectMap::ReleaseObject(v12, v11);
    v9 = (v12 != 0) & v3;
  }

  *(*(*(a1 + 32) + 8) + 24) = v9;
}

void sub_1DE71AE34(void *a1, HALS_Object *a2)
{
  HALS_ObjectMap::ReleaseObject(v2, a2);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE71AE1CLL);
}

uint64_t HALS_Device::IsPropertySettable(HALS_Device *this, unsigned int a2, AudioObjectPropertyAddress *a3, const AudioObjectPropertyAddress *a4)
{
  v20 = a4;
  v19[0] = this;
  v19[1] = &v20;
  v19[2] = a3;
  v18 = 0;
  mSelector = a3->mSelector;
  if (a3->mSelector <= 1768124269)
  {
    if (mSelector > 1684498540)
    {
      if (mSelector > 1685414762)
      {
        if (mSelector <= 1751412336)
        {
          if (mSelector != 1685414763)
          {
            if (mSelector != 1735354734)
            {
              v7 = 1735356005;
              goto LABEL_89;
            }

            return v18;
          }

          return 1;
        }

        if (mSelector > 1751737453)
        {
          if (mSelector != 1751737454)
          {
            v7 = 1752122448;
            goto LABEL_89;
          }

          return v18;
        }

        if (mSelector == 1751412337)
        {
          return v18;
        }

        v8 = 1751413616;
        goto LABEL_82;
      }

      if (mSelector > 1684500593)
      {
        if (mSelector > 1685278560)
        {
          if (mSelector == 1685278561)
          {
            if (!HALS_Device::IsPropertySettable(unsigned int,AudioObjectPropertyAddress const&,HALS_Client *)const::$_0::operator()(v19, &v18))
            {
              return 0;
            }

            return v18;
          }

          if (mSelector == 1685278562)
          {
            if (!HALS_Device::IsPropertySettable(unsigned int,AudioObjectPropertyAddress const&,HALS_Client *)const::$_0::operator()(v19, &v18))
            {
              if (v20)
              {
                v12 = 1;
              }

              else
              {
                v12 = *(this + 660);
              }

              return v12 & 1;
            }

            return v18;
          }

          goto LABEL_99;
        }

        if (mSelector != 1684500594)
        {
          v7 = 1685089383;
          goto LABEL_89;
        }

        return 1;
      }

      if (mSelector == 1684498541 || mSelector == 1684498544)
      {
        return v18;
      }

      if (mSelector != 1684500589)
      {
        goto LABEL_99;
      }

      if (HALS_Device::IsPropertySettable(unsigned int,AudioObjectPropertyAddress const&,HALS_Client *)const::$_0::operator()(v19, &v18))
      {
        return v18;
      }

      if ((HALS_Device_HostedDSP::HasProperty(*(this + 79), a3, v20, v10) & 0x100) == 0)
      {
        return 1;
      }

      return HALS_Device_HostedDSP::IsPropertySettable(*(this + 79), a3, v20, v9);
    }

    if (mSelector <= 1667461732)
    {
      if (mSelector > 1634758764)
      {
        if (mSelector != 1634758765 && mSelector != 1634758774)
        {
          v7 = 1667330160;
          goto LABEL_89;
        }

        return 1;
      }

      if (mSelector == 1634429294 || mSelector == 1634496615)
      {
        return v18;
      }

      v8 = 1634755428;
      goto LABEL_82;
    }

    if (mSelector > 1668575851)
    {
      if (mSelector > 1684301170)
      {
        if (mSelector != 1684301171)
        {
          v7 = 1684434036;
          goto LABEL_89;
        }

        return v18;
      }

      if (mSelector == 1668575852)
      {
        return v18;
      }

      v8 = 1684236338;
      goto LABEL_82;
    }

    if (mSelector != 1667461733)
    {
      if (mSelector != 1667523955)
      {
        v7 = 1668049764;
        goto LABEL_89;
      }

      return 1;
    }

LABEL_91:
    if (HALS_Device::IsPropertySettable(unsigned int,AudioObjectPropertyAddress const&,HALS_Client *)const::$_0::operator()(v19, &v18))
    {
      return v18;
    }

    v15 = v20;
    if (v20)
    {
      v15 = atomic_load(&v20[22].mScope);
    }

    return (a3->mScope == 1768845428) & v15;
  }

  if (mSelector > 1934647618)
  {
    if (mSelector <= 1937009954)
    {
      if (mSelector <= 1936092275)
      {
        if (mSelector == 1934647619 || mSelector == 1934647636)
        {
          if (HALS_Device::IsPropertySettable(unsigned int,AudioObjectPropertyAddress const&,HALS_Client *)const::$_0::operator()(v19, &v18))
          {
            return v18;
          }

          return a3->mScope == 1869968496;
        }

        v7 = 1935763060;
        goto LABEL_89;
      }

      if (mSelector <= 1936876643)
      {
        if (mSelector != 1936092276)
        {
          v7 = 1936482681;
          goto LABEL_89;
        }

        return v18;
      }

      if (mSelector == 1936876644)
      {
        return v18;
      }

      v8 = 1936879204;
LABEL_82:
      if (mSelector == v8)
      {
        return 1;
      }

LABEL_99:
      v16 = HALS_Device::IsPropertySettable(unsigned int,AudioObjectPropertyAddress const&,HALS_Client *)const::$_0::operator()(v19, &v18);
      if (v16)
      {
        return v18;
      }

      return HALS_Object::IsPropertySettable(v16, v17, a3);
    }

    if (mSelector <= 1983996970)
    {
      if (mSelector != 1937009955 && mSelector != 1953653102)
      {
        v7 = 1969841184;
        goto LABEL_89;
      }

      return v18;
    }

    if (mSelector > 1986622323)
    {
      if (mSelector != 1986622324)
      {
        v7 = 2003136116;
        goto LABEL_89;
      }
    }

    else if (mSelector != 1983996971)
    {
      if (mSelector != 1983997011)
      {
        goto LABEL_99;
      }

      if (HALS_Device::IsPropertySettable(unsigned int,AudioObjectPropertyAddress const&,HALS_Client *)const::$_0::operator()(v19, &v18))
      {
        return v18;
      }

      return HALS_Device_HostedDSP::IsPropertySettable(*(this + 79), a3, v20, v9);
    }

    goto LABEL_91;
  }

  if (mSelector > 1836411235)
  {
    if (mSelector <= 1853059699)
    {
      if (mSelector == 1836411236)
      {
        return v18;
      }

      if (mSelector != 1852793963)
      {
        v7 = 1853059619;
        goto LABEL_89;
      }

      return 1;
    }

    if (mSelector <= 1886353265)
    {
      if (mSelector != 1853059700)
      {
        v8 = 1869180523;
        goto LABEL_82;
      }

      return 1;
    }

    if (mSelector == 1886353266)
    {
      return v18;
    }

    v7 = 1919512167;
LABEL_89:
    if (mSelector == v7)
    {
      return v18;
    }

    goto LABEL_99;
  }

  if (mSelector <= 1818454125)
  {
    if (mSelector != 1768124270 && mSelector != 1768777573)
    {
      v7 = 1768907636;
      goto LABEL_89;
    }
  }

  else
  {
    if (mSelector <= 1819569762)
    {
      if (mSelector != 1818454126)
      {
        v7 = 1818850926;
        goto LABEL_89;
      }

      return 1;
    }

    if (mSelector != 1819569763)
    {
      v7 = 1819634020;
      goto LABEL_89;
    }
  }

  return v18;
}

BOOL HALS_Device::IsPropertySettable(unsigned int,AudioObjectPropertyAddress const&,HALS_Client *)const::$_0::operator()(uint64_t a1, _BYTE *a2)
{
  v4 = *a1;
  if (!AMCP::Feature_Flags::use_ahal_dsp_hosting_lib(0, 0))
  {
    return 0;
  }

  v5 = **(a1 + 8);
  if (v5)
  {
    v6 = *(v5 + 16);
  }

  else
  {
    v6 = 0;
  }

  HALS_Device::DSP_Config_Properties(&v12, v4, v6);
  v8 = v12;
  v7 = v13;
  if (v12 && (*(*v12 + 16))(v12, *(a1 + 16)))
  {
    *a2 = (*(*v8 + 24))(v8, *(a1 + 16));
    v9 = 1;
    goto LABEL_11;
  }

  HALS_Device::DSP_Instance_Properties(&v12, v4, **(a1 + 8), **(a1 + 16), *(*(a1 + 16) + 8) | 0x100000000);
  v10 = v13;
  if (v12)
  {
    *a2 = (*(*v12 + 24))(v12, *(a1 + 16));
    v9 = 1;
    if (!v10)
    {
      goto LABEL_11;
    }

    goto LABEL_10;
  }

  v9 = 0;
  if (v13)
  {
LABEL_10:
    std::__shared_weak_count::__release_shared[abi:ne200100](v10);
  }

LABEL_11:
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }

  return v9 != 0;
}

void sub_1DE71B5C4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

BOOL HALS_Device::HasProperty(unsigned int,AudioObjectPropertyAddress const&,HALS_Client *)const::$_0::operator()(uint64_t a1, _BYTE *a2)
{
  v4 = *a1;
  if (!AMCP::Feature_Flags::use_ahal_dsp_hosting_lib(0, 0))
  {
    return 0;
  }

  v5 = **(a1 + 8);
  if (v5)
  {
    v6 = *(v5 + 16);
  }

  else
  {
    v6 = 0;
  }

  HALS_Device::DSP_Config_Properties(&v13, v4, v6);
  v7 = v14;
  if (v13)
  {
    v8 = (*(*v13 + 16))(v13, *(a1 + 16));
    *a2 = v8;
    if (v8)
    {
      v9 = 1;
      goto LABEL_14;
    }
  }

  HALS_Device::DSP_Instance_Properties(&v13, v4, **(a1 + 8), **(a1 + 16), *(*(a1 + 16) + 8) | 0x100000000);
  v10 = v14;
  if (!v13 || (v11 = (*(*v13 + 16))(v13, *(a1 + 16)), *a2 = v11, (v11 & 1) == 0))
  {
    v9 = 0;
    if (!v10)
    {
      goto LABEL_14;
    }

    goto LABEL_13;
  }

  v9 = 1;
  if (v10)
  {
LABEL_13:
    std::__shared_weak_count::__release_shared[abi:ne200100](v10);
  }

LABEL_14:
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }

  return v9 != 0;
}

void sub_1DE71B730(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_Device::GetMIGDispatchQueue(HALS_Device *this)
{
  return *(this + 12);
}

{
  return *(this + 12);
}

uint64_t HALS_Device::GetCommandGate(HALS_Device *this)
{
  return *(this + 10);
}

{
  return *(this + 10);
}

uint64_t HALS_Device::_Deactivate(HALS_Device *this)
{
  v15 = *MEMORY[0x1E69E9840];
  if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
  {
    v2 = *(this + 4);
    *buf = 136315906;
    *&buf[4] = "HALS_Device.cpp";
    *&buf[12] = 1024;
    *&buf[14] = 262;
    *&buf[18] = 2048;
    *&buf[20] = v2;
    *&buf[28] = 2082;
    *&buf[30] = this + 164;
    _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  HALS_Device::_Deactivate: deactivating device %lu: %{public}s", buf, 0x26u);
  }

  *(this + 2) = 0;
  std::mutex::lock(this + 11);
  for (i = (this + 680); ; HALS_Device_HostedDSP_ClientInfo::PerClientInfo::deactivate_stream((i + 3), 0))
  {
    i = *i;
    if (!i)
    {
      break;
    }

    HALS_Device_HostedDSP_ClientInfo::PerClientInfo::deactivate_stream((i + 3), 1);
  }

  std::mutex::unlock(this + 11);
  if (*(this + 154))
  {
    v9[0] = 0;
    v9[1] = 0;
    HALS_System::GetInstance(&v10, 0, v9);
    v4 = *(this + 154);
    *buf = MEMORY[0x1E69E9820];
    *&buf[8] = 0x40000000;
    *&buf[16] = ___ZN11HALS_System16DestroyIOContextEP11HALS_Clientj_block_invoke;
    *&buf[24] = &__block_descriptor_tmp_146;
    *&buf[32] = v10;
    v13 = 0;
    v14 = v4;
    v5 = (*(*v10 + 64))(v10);
    HALB_CommandGate::ExecuteCommand(v5, buf);
    if (v11)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v11);
    }

    *(this + 154) = 0;
  }

  v6 = *(this + 4);
  result = kdebug_trace();
  v8 = *MEMORY[0x1E69E9840];
  return result;
}

void HALS_Device::Activate(HALS_Device *this)
{
  v45 = *MEMORY[0x1E69E9840];
  TransportType = HALS_IODevice::GetTransportType(this);
  v34[0] = HIBYTE(TransportType);
  v34[1] = BYTE2(TransportType);
  v34[2] = BYTE1(TransportType);
  v34[3] = TransportType;
  v34[4] = 0;
  v3 = (*(*this + 328))(this);
  if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(this + 4);
    *buf = 136316418;
    *&buf[4] = "HALS_Device.cpp";
    *&buf[12] = 1024;
    *&buf[14] = 188;
    v37 = 2048;
    v38 = v4;
    v39 = 2082;
    v40 = this + 164;
    v41 = 2080;
    v42 = v34;
    v43 = 2048;
    v44 = v3;
    _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  HALS_Device::Activate: activating device %lu: %{public}s Transport Type: %s Clock Domain: %lu", buf, 0x3Au);
  }

  v5 = *(this + 4);
  kdebug_trace();
  if (v3)
  {
    v6 = 0;
  }

  else
  {
    v6 = TransportType == 1651274862;
  }

  if (v6 && os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
  {
    *buf = 136315394;
    *&buf[4] = "HALS_Device.cpp";
    *&buf[12] = 1024;
    *&buf[14] = 192;
    _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  HALS_Device::Activate: !!!! It is unusual for a built-in device to have a Clock Domain of zero.", buf, 0x12u);
  }

  v7 = *(this + 4);
  strcpy(buf, "sccabolg");
  buf[9] = 0;
  *&buf[10] = 0;
  if ((*(*this + 96))(this, v7, buf, 0))
  {
    v8 = *(this + 4);
    strcpy(buf, "sccabolg");
    buf[9] = 0;
    *&buf[10] = 0;
    v32 = 0;
    LODWORD(v29) = 0;
    (*(*this + 120))(this, v8, buf, 8, &v29, &v32, 0, 0, 0);
    v9 = v32;
    v10 = *(this + 17);
    if (v10 != v32)
    {
      if (v10 && (*(this + 144) & 1) != 0)
      {
        CFRelease(v10);
      }

      *(this + 17) = v9;
    }

    *(this + 144) = 1;
  }

  v31[0] = 0;
  v31[1] = 0;
  HALS_System::GetInstance(&v32, 0, v31);
  Setting = HALS_SettingsManager::ReadSetting(v32[222], *(this + 15));
  *buf = &unk_1F5991008;
  *&buf[8] = Setting;
  if (v33)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v33);
  }

  if (*&buf[8])
  {
    OS::CF::DictionaryBase<__CFDictionary const*>::GetValueForKey<OS::CF::Number>(&v32, *&buf[8], @"output.stereo.left");
    *(this + 38) = OS::CF::Number::GetValue<unsigned int>(v33, 1);
    OS::CF::UntypedObject::~UntypedObject(&v32);
    OS::CF::DictionaryBase<__CFDictionary const*>::GetValueForKey<OS::CF::Number>(&v32, *&buf[8], @"output.stereo.right");
    *(this + 39) = OS::CF::Number::GetValue<unsigned int>(v33, 2);
    OS::CF::UntypedObject::~UntypedObject(&v32);
    if ((HALS_System::sIsInitialized & 1) == 0)
    {
      OS::CF::DictionaryBase<__CFDictionary const*>::GetValueForKey<OS::CF::Dictionary>(&v32, *&buf[8], @"global.arrival");
      if (v33)
      {
        if (HALS_IODevice::GetTransportType(this) == 1651274862)
        {
          v12 = (*(*this + 648))(this, 1685287523, 1869968496, 0);
          if (v12 || (v12 = (*(*this + 648))(this, 1685287523, 1768845428, 0), pthread_once(&HALS_ObjectMap::sObjectInfoListInitialized, HALS_ObjectMap::Initialize), v12))
          {
            v14 = v12[4];
            v29 = 0x676C6F6273636369;
            LODWORD(v30) = 0;
            v27 = 0;
            v35 = 0;
            (*(*v12 + 120))(v12, v14, &v29, 4, &v35, &v27, 0, 0, 0);
            v15 = v27;
          }

          else
          {
            v15 = 0;
          }

          HALS_ObjectMap::ReleaseObject(v12, v13);
        }

        else
        {
          v15 = 0;
        }

        if (!HALS_Device::IsHidden(this) && v15 != 1768778083 && v15 != 1769173099)
        {
          OS::CF::DictionaryBase<__CFDictionary const*>::GetValueForKey<OS::CF::Number>(&v29, v33, @"seed");
          v16 = OS::CF::Number::GetValue<unsigned long long>(v30);
          OS::CF::DictionaryBase<__CFDictionary const*>::GetValueForKey<OS::CF::Number>(&v27, v33, @"time");
          v17 = OS::CF::Number::GetValue<unsigned long long>(v28);
          OS::CF::UntypedObject::~UntypedObject(&v27);
          OS::CF::UntypedObject::~UntypedObject(&v29);
          v26[0] = 0;
          v26[1] = 0;
          HALS_System::GetInstance(&v29, 0, v26);
          CurrentDeviceArrivalTime = HALS_System::GetCurrentDeviceArrivalTime(v18);
          v21 = v20;
          if (v30)
          {
            std::__shared_weak_count::__release_shared[abi:ne200100](v30);
          }

          if (v16 >= CurrentDeviceArrivalTime && (v16 != CurrentDeviceArrivalTime || v17 >= v21))
          {
            v16 = CurrentDeviceArrivalTime;
            v17 = v21;
          }

          *(this + 53) = v16;
          *(this + 54) = v17;
        }
      }

      OS::CF::UntypedObject::~UntypedObject(&v32);
    }
  }

  if (!*(this + 53) && !*(this + 54))
  {
    HALS_Device::UpdateDeviceArrivalTime(this);
  }

  atomic_store((*(*this + 520))(this), this + 40);
  v22 = *(this + 57);
  v23 = (*(**(v22 + 32) + 96))(*(v22 + 32), *(*(v22 + 32) + 16), "msxebolg", 0);
  *v22 = v23;
  if (v23 && HALS_ExternalSecureMuteManager::GetExternalSecureMute(*(v22 + 32)))
  {
    LODWORD(v32) = 0;
    (*(**(v22 + 32) + 128))(*(v22 + 32), *(*(v22 + 32) + 16), "msxebolg", 4, &v32, 0, 0, 0);
  }

  HALS_Object::Activate(this, v24);
  OS::CF::UntypedObject::~UntypedObject(buf);
  v25 = *MEMORY[0x1E69E9840];
}

void sub_1DE71C04C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, void);
  v14 = va_arg(va1, void);
  v15 = va_arg(va1, void);
  v16 = va_arg(va1, void);
  if (a9)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a9);
  }

  OS::CF::UntypedObject::~UntypedObject(va);
  OS::CF::UntypedObject::~UntypedObject(va1);
  _Unwind_Resume(a1);
}

const __CFNumber *OS::CF::Number::GetValue<unsigned long long>(const __CFNumber *result)
{
  valuePtr = 0;
  if (result)
  {
    CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
    return valuePtr;
  }

  return result;
}

void HALS_Device::BasicControlList::~BasicControlList(HALS_ObjectMap ***this, HALS_Object *a2)
{
  v3 = *this;
  v4 = this[1];
  if (*this != v4)
  {
    do
    {
      HALS_ObjectMap::ReleaseObject(*v3++, a2);
    }

    while (v3 != v4);
    v3 = *this;
  }

  if (v3)
  {
    this[1] = v3;
    operator delete(v3);
  }
}

void HALS_Device::HALS_Device(HALS_Device *this, HALB_Info *a2, uint64_t a3, HALS_Object *a4, const __CFString *a5)
{
  v7 = a2;
  v13 = *MEMORY[0x1E69E9840];
  if (HALB_Info::IsStandardClass(a2))
  {
    v10 = v7;
  }

  else
  {
    v10 = 1633969526;
  }

  HALS_Object::HALS_Object(this, v7, v10, a3, v9);
  *(this + 8) = 0;
  *(this + 7) = 0;
  *(this + 6) = this + 56;
  *(this + 72) = 0;
  *(this + 13) = a4;
  *this = &unk_1F598DF60;
  *(this + 11) = 0;
  *(this + 12) = 0;
  *(this + 10) = 0;
  *(this + 112) = 1;
  v12 = this + 104;
  v11 = CFStringCreateWithFormat(0, 0, @"device.%@", a4);
  *(this + 17) = 0;
  *(this + 15) = v11;
  *(this + 128) = 1;
  *(this + 144) = 1;
  *(this + 19) = 0x200000001;
  *(this + 40) = -1;
  *(this + 53) = 0;
  *(this + 54) = 0;
  *(this + 440) = 0;
  operator new();
}

void sub_1DE71CBAC(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    v3 = __cxa_begin_catch(exception_object);
    v4 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v4 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v3);
    }

    v6 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v5 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v5)
    {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      v7 = *v6;
      std::__shared_weak_count::__release_shared[abi:ne200100](v5);
    }

    else
    {
      v7 = *v6;
    }

    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(v2 + 352) = 136315394;
      *(v2 + 356) = "HALS_Device.cpp";
      *(v2 + 364) = 1024;
      *(v2 + 366) = 5441;
      _os_log_error_impl(&dword_1DE1F9000, v7, OS_LOG_TYPE_ERROR, "%32s:%-5d [ahal_dsp] Failed to allocate the DSP client configuration.", (v2 + 352), 0x12u);
    }

    __cxa_end_catch();
    JUMPOUT(0x1DE71C8F4);
  }

  _Unwind_Resume(exception_object);
}

void std::default_delete<HALS_Device_HostedDSP>::operator()[abi:ne200100](uint64_t a1)
{
  if (*(a1 + 32) == 1 && *(a1 + 31) < 0)
  {
    operator delete(*(a1 + 8));
  }

  JUMPOUT(0x1E12C1730);
}

uint64_t *std::unique_ptr<HALS_DSPHostPerClientConfiguration>::reset[abi:ne200100](uint64_t *result, uint64_t a2)
{
  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::__tree<std::__value_type<unsigned int,HALS_DSPHostPerClientConfiguration::PerClientProperties>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,HALS_DSPHostPerClientConfiguration::PerClientProperties>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,HALS_DSPHostPerClientConfiguration::PerClientProperties>>>::destroy(*(v2 + 104));
    std::mutex::~mutex((v2 + 32));
    v3 = *(v2 + 8);
    if (v3)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v3);
    }

    JUMPOUT(0x1E12C1730);
  }

  return result;
}

uint64_t std::deque<HALS_Device::DuckHistoryItem>::~deque[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  *(a1 + 40) = 0;
  v4 = v3 - v2;
  if (v4 >= 3)
  {
    do
    {
      operator delete(*v2);
      v3 = *(a1 + 16);
      v2 = (*(a1 + 8) + 8);
      *(a1 + 8) = v2;
      v4 = v3 - v2;
    }

    while (v4 > 2);
  }

  if (v4 == 1)
  {
    v5 = 64;
    goto LABEL_7;
  }

  if (v4 == 2)
  {
    v5 = 128;
LABEL_7:
    *(a1 + 32) = v5;
  }

  if (v2 != v3)
  {
    do
    {
      v6 = *v2++;
      operator delete(v6);
    }

    while (v2 != v3);
    v8 = *(a1 + 8);
    v7 = *(a1 + 16);
    if (v7 != v8)
    {
      *(a1 + 16) = v7 + ((v8 - v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::vector<HALS_Device::ClientInfo>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 48;
        CACFDictionary::~CACFDictionary((v4 - 40));
        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

uint64_t *std::unique_ptr<HALS_ExternalSecureMuteManager>::~unique_ptr[abi:ne200100](uint64_t *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(v2 + 8);
    if (v3)
    {
      *(v2 + 16) = v3;
      operator delete(v3);
    }

    MEMORY[0x1E12C1730](v2, 0x1020C404AC45F11);
  }

  return a1;
}

uint64_t *std::unique_ptr<HALS_ReferenceStreamStateManager>::~unique_ptr[abi:ne200100](uint64_t *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::__hash_table<std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>>>::~__hash_table(v2 + 208);
    std::__hash_table<std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>>>::~__hash_table(v2 + 168);
    std::condition_variable::~condition_variable((v2 + 112));
    std::condition_variable::~condition_variable((v2 + 64));
    std::mutex::~mutex(v2);
    MEMORY[0x1E12C1730]();
  }

  return a1;
}

void HALS_Device::~HALS_Device(HALS_Device *this)
{
  *this = &unk_1F598DF60;
  std::unique_ptr<HALS_DSPHostPerClientConfiguration>::reset[abi:ne200100](this + 78, 0);
  v2 = *(this + 11);
  *(this + 10) = 0;
  *(this + 11) = 0;
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  v3 = *(this + 12);
  if (v3)
  {
    AMCP::Utility::Dispatch_Queue::~Dispatch_Queue(v3);
    MEMORY[0x1E12C1730]();
  }

  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue((this + 1120));
  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue((this + 784));
  HALS_ObjectMap::ReleaseObject(*(this + 96), v4);
  HALS_Device_HostedDSP_ClientInfo::~HALS_Device_HostedDSP_ClientInfo((this + 648));
  v5 = *(this + 79);
  *(this + 79) = 0;
  if (v5)
  {
    std::default_delete<HALS_Device_HostedDSP>::operator()[abi:ne200100](v5);
  }

  std::unique_ptr<HALS_DSPHostPerClientConfiguration>::reset[abi:ne200100](this + 78, 0);
  std::deque<HALS_Device::DuckHistoryItem>::~deque[abi:ne200100](this + 568);
  v7 = (this + 544);
  std::vector<HALS_Device::ClientInfo>::__destroy_vector::operator()[abi:ne200100](&v7);
  std::__hash_table<std::__hash_value_type<unsigned int,std::string>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::string>>>::~__hash_table(this + 496);
  CACFDictionary::~CACFDictionary((this + 472));
  std::unique_ptr<HALS_ExternalSecureMuteManager>::~unique_ptr[abi:ne200100](this + 57);
  std::unique_ptr<HALS_ReferenceStreamStateManager>::~unique_ptr[abi:ne200100](this + 56);
  CACFString::~CACFString((this + 136));
  CACFString::~CACFString((this + 120));
  CACFString::~CACFString((this + 104));
  v6 = *(this + 11);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v6);
  }

  *this = &unk_1F598F798;
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(*(this + 7));

  HALS_Object::~HALS_Object(this);
}

void HALS_Device::LogState(uint64_t a1, uint64_t a2)
{
  v200 = *MEMORY[0x1E69E9840];
  v148 = a2;
  v2 = (a2 + 16);
  v3 = 3;
  do
  {
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
    --v3;
  }

  while (v3);
  v4 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Device ", 7);
  v5 = MEMORY[0x1E12C1210](v4, *(a1 + 16));
  std::ios_base::getloc((v5 + *(*v5 - 24)));
  v6 = std::locale::use_facet(&v198, MEMORY[0x1E69E5318]);
  (v6->__vftable[2].~facet_0)(v6, 10);
  std::locale::~locale(&v198);
  std::ostream::put();
  std::ostream::flush();
  v154[0] = &unk_1F5991188;
  v154[1] = HALS_Device::CopyServerLocalizedName(a1);
  OS::CF::String::AsCString(v154, __s, 128);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Name:                  ", 23);
  v7 = strlen(__s);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, __s, v7);
  std::ios_base::getloc((v2 + *(*v2 - 24)));
  v8 = std::locale::use_facet(&v198, MEMORY[0x1E69E5318]);
  (v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v198);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "UID:                   ", 23);
  v9 = strlen((a1 + 164));
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, a1 + 164, v9);
  std::ios_base::getloc((v2 + *(*v2 - 24)));
  v10 = std::locale::use_facet(&v198, MEMORY[0x1E69E5318]);
  (v10->__vftable[2].~facet_0)(v10, 10);
  std::locale::~locale(&v198);
  std::ostream::put();
  std::ostream::flush();
  TransportType = HALS_IODevice::GetTransportType(a1);
  v153[0] = HIBYTE(TransportType);
  v153[1] = BYTE2(TransportType);
  v153[2] = BYTE1(TransportType);
  v153[3] = TransportType;
  v153[4] = 0;
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Transport Type:        ", 23);
  v12 = strlen(v153);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, v153, v12);
  std::ios_base::getloc((v2 + *(*v2 - 24)));
  v13 = std::locale::use_facet(&v198, MEMORY[0x1E69E5318]);
  (v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v198);
  std::ostream::put();
  std::ostream::flush();
  IsHidden = HALS_Device::IsHidden(a1);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Is Hidden:             ", 23);
  if (IsHidden)
  {
    v15 = "yes";
  }

  else
  {
    v15 = "no";
  }

  if (IsHidden)
  {
    v16 = 3;
  }

  else
  {
    v16 = 2;
  }

  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, v15, v16);
  std::ios_base::getloc((v2 + *(*v2 - 24)));
  v17 = std::locale::use_facet(&v198, MEMORY[0x1E69E5318]);
  (v17->__vftable[2].~facet_0)(v17, 10);
  std::locale::~locale(&v198);
  std::ostream::put();
  std::ostream::flush();
  v18 = (*(*a1 + 328))(a1);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Clock Domain:          ", 23);
  v19 = MEMORY[0x1E12C1210](v2, v18);
  std::ios_base::getloc((v19 + *(*v19 - 24)));
  v20 = std::locale::use_facet(&v198, MEMORY[0x1E69E5318]);
  (v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v198);
  std::ostream::put();
  std::ostream::flush();
  v21 = (*(*a1 + 312))(a1, 1);
  v22 = (*(*a1 + 312))(a1, 0);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Latency                In: ", 27);
  v23 = MEMORY[0x1E12C1210](v2, v21);
  v24 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v23, " Out: ", 6);
  v25 = MEMORY[0x1E12C1210](v24, v22);
  std::ios_base::getloc((v25 + *(*v25 - 24)));
  v26 = std::locale::use_facet(&v198, MEMORY[0x1E69E5318]);
  (v26->__vftable[2].~facet_0)(v26, 10);
  std::locale::~locale(&v198);
  std::ostream::put();
  std::ostream::flush();
  v27 = (*(*a1 + 320))(a1, 1);
  v28 = (*(*a1 + 320))(a1, 0);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Safety Offset          In: ", 27);
  v29 = MEMORY[0x1E12C1210](v2, v27);
  v30 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v29, " Out: ", 6);
  v31 = MEMORY[0x1E12C1210](v30, v28);
  std::ios_base::getloc((v31 + *(*v31 - 24)));
  v32 = std::locale::use_facet(&v198, MEMORY[0x1E69E5318]);
  (v32->__vftable[2].~facet_0)(v32, 10);
  std::locale::~locale(&v198);
  std::ostream::put();
  std::ostream::flush();
  v33 = (*(*a1 + 272))(a1);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Nominal Sample Rate:   ", 23);
  v34 = MEMORY[0x1E12C11E0](v2, v33);
  std::ios_base::getloc((v34 + *(*v34 - 24)));
  v35 = std::locale::use_facet(&v198, MEMORY[0x1E69E5318]);
  (v35->__vftable[2].~facet_0)(v35, 10);
  std::locale::~locale(&v198);
  std::ostream::put();
  std::ostream::flush();
  v36 = 0;
  v37 = 1;
  v38 = MEMORY[0x1E69E5318];
  do
  {
    v39 = v37;
    v150.__locale_ = 0;
    v151 = 0;
    v152 = 0;
    HALS_Device::CopyStreamList(a1, v36 & 1, &v150.__locale_);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Number ", 7);
    if (v39)
    {
      v40 = "Output Streams:";
    }

    else
    {
      v40 = "Input Streams: ";
    }

    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, v40, 15);
    v41 = MEMORY[0x1E12C1220](v2, (v151 - v150.__locale_) >> 3);
    std::ios_base::getloc((v41 + *(*v41 - 24)));
    v42 = std::locale::use_facet(&v198, v38);
    (v42->__vftable[2].~facet_0)(v42, 10);
    std::locale::~locale(&v198);
    std::ostream::put();
    std::ostream::flush();
    locale = v150.__locale_;
    v45 = v151;
    while (locale != v45)
    {
      v46 = *locale;
      memset(&__p, 0, sizeof(__p));
      if (*(v46 + 56) == 1)
      {
        goto LABEL_18;
      }

      if (HALS_Stream::IsHardwareReferenceStream(v46))
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          __p.__r_.__value_.__l.__size_ = 9;
          p_p = __p.__r_.__value_.__r.__words[0];
        }

        else
        {
LABEL_18:
          *(&__p.__r_.__value_.__s + 23) = 9;
          p_p = &__p;
        }

        p_p->__r_.__value_.__s.__data_[8] = 101;
        p_p->__r_.__value_.__r.__words[0] = *"reference";
        v48 = &p_p->__r_.__value_.__s.__data_[9];
LABEL_20:
        *v48 = 0;
        goto LABEL_21;
      }

      if (*(v46 + 56) == 2)
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          __p.__r_.__value_.__l.__size_ = 3;
          v70 = __p.__r_.__value_.__r.__words[0];
        }

        else
        {
          *(&__p.__r_.__value_.__s + 23) = 3;
          v70 = &__p;
        }

        v70->__r_.__value_.__s.__data_[2] = 80;
        LOWORD(v70->__r_.__value_.__l.__data_) = 21316;
        v48 = &v70->__r_.__value_.__s.__data_[3];
        goto LABEL_20;
      }

      if (*(v46 + 52))
      {
        v71 = "input";
      }

      else
      {
        v71 = "output";
      }

      std::string::__assign_external(&__p, v71);
LABEL_21:
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Stream ", 7);
      v49 = MEMORY[0x1E12C1210](v2, *(v46 + 16));
      std::ios_base::getloc((v49 + *(*v49 - 24)));
      v50 = std::locale::use_facet(&v162, v38);
      (v50->__vftable[2].~facet_0)(v50, 10);
      std::locale::~locale(&v162);
      std::ostream::put();
      std::ostream::flush();
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Direction:               ", 25);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v51 = &__p;
      }

      else
      {
        v51 = __p.__r_.__value_.__r.__words[0];
      }

      v52 = strlen(v51);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, v51, v52);
      std::ios_base::getloc((v2 + *(*v2 - 24)));
      v53 = std::locale::use_facet(&v163, v38);
      (v53->__vftable[2].~facet_0)(v53, 10);
      std::locale::~locale(&v163);
      std::ostream::put();
      std::ostream::flush();
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Starting Channel:        ", 25);
      v54 = (*(*v46 + 208))(v46);
      v55 = MEMORY[0x1E12C1210](v2, v54);
      std::ios_base::getloc((v55 + *(*v55 - 24)));
      v56 = std::locale::use_facet(&v164, v38);
      (v56->__vftable[2].~facet_0)(v56, 10);
      std::locale::~locale(&v164);
      std::ostream::put();
      std::ostream::flush();
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Is Active:               ", 25);
      IsActive = HALS_Stream::GetStreamIsActive(v46);
      if (IsActive)
      {
        v58 = "yes";
      }

      else
      {
        v58 = "no";
      }

      if (IsActive)
      {
        v59 = 3;
      }

      else
      {
        v59 = 2;
      }

      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, v58, v59);
      std::ios_base::getloc((v2 + *(*v2 - 24)));
      v60 = std::locale::use_facet(&v165, v38);
      (v60->__vftable[2].~facet_0)(v60, 10);
      std::locale::~locale(&v165);
      std::ostream::put();
      std::ostream::flush();
      memset(&v158, 0, sizeof(v158));
      HALS_Stream::GetCurrentVirtualFormat(v46, &v158);
      CAStreamBasicDescription::AsString(&v158, &v198, 0x80uLL, v61, v62);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Current Virtual Format:  ", 25);
      v63 = strlen(&v198);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, &v198, v63);
      std::ios_base::getloc((v2 + *(*v2 - 24)));
      v64 = std::locale::use_facet(&v166, v38);
      (v64->__vftable[2].~facet_0)(v64, 10);
      std::locale::~locale(&v166);
      std::ostream::put();
      std::ostream::flush();
      v157 = 0;
      *&v155[0].__locale_ = 0u;
      v156 = 0u;
      v65 = *(v46 + 16);
      v160 = 0x676C6F6270667420;
      v161 = 0;
      v66 = (*(*v46 + 120))(v46, v65, &v160, 40, &v161 + 4, v155, 0, 0, 0, v148);
      CAStreamBasicDescription::AsString(v155, &v196, 0x80uLL, v66, v67);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Current Physical Format: ", 25);
      v68 = strlen(&v196);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, &v196, v68);
      std::ios_base::getloc((v2 + *(*v2 - 24)));
      v69 = std::locale::use_facet(&v167, v38);
      (v69->__vftable[2].~facet_0)(v69, 10);
      std::locale::~locale(&v167);
      std::ostream::put();
      std::ostream::flush();
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      locale = (locale + 8);
    }

    HALS_ArrayReleaser<HALS_Stream>::~HALS_ArrayReleaser(&v150, v43);
    v37 = 0;
    v36 = 1;
  }

  while ((v39 & 1) != 0);
  memset(&v158, 0, 24);
  (*(*a1 + 624))(a1, &v158);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Number Controls:       ", 23);
  v72 = MEMORY[0x1E12C1220](v2, (*&v158.mFormatID - *&v158.mSampleRate) >> 3);
  std::ios_base::getloc((v72 + *(*v72 - 24)));
  v73 = std::locale::use_facet(&v198, MEMORY[0x1E69E5318]);
  (v73->__vftable[2].~facet_0)(v73, 10);
  std::locale::~locale(&v198);
  std::ostream::put();
  std::ostream::flush();
  mSampleRate = v158.mSampleRate;
  v75 = *&v158.mFormatID;
  if (*&v158.mSampleRate != *&v158.mFormatID)
  {
    v76 = MEMORY[0x1E69E5318];
    do
    {
      v77 = **&mSampleRate;
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Control ", 8);
      v78 = MEMORY[0x1E12C1210](v2, v77[4]);
      std::ios_base::getloc((v78 + *(*v78 - 24)));
      v79 = std::locale::use_facet(&v181, v76);
      (v79->__vftable[2].~facet_0)(v79, 10);
      std::locale::~locale(&v181);
      std::ostream::put();
      std::ostream::flush();
      v80 = v77[5];
      BaseClass = v77[6];
      LOBYTE(v181.__locale_) = HIBYTE(v77[5]);
      BYTE1(v181.__locale_) = BYTE2(v80);
      BYTE2(v181.__locale_) = BYTE1(v80);
      *(&v181.__locale_ + 3) = v80;
      if (BaseClass == v80)
      {
        BaseClass = HALB_Info::GetBaseClass(v80);
      }

      v168[0] = HIBYTE(BaseClass);
      v168[1] = BYTE2(BaseClass);
      v168[2] = BYTE1(BaseClass);
      v168[3] = BaseClass;
      v168[4] = 0;
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Class:                  ", 24);
      v82 = strlen(&v181);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, &v181, v82);
      std::ios_base::getloc((v2 + *(*v2 - 24)));
      v83 = std::locale::use_facet(&v182, v76);
      (v83->__vftable[2].~facet_0)(v83, 10);
      std::locale::~locale(&v182);
      std::ostream::put();
      std::ostream::flush();
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Base Class:             ", 24);
      v84 = strlen(v168);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, v168, v84);
      std::ios_base::getloc((v2 + *(*v2 - 24)));
      v85 = std::locale::use_facet(&v183, v76);
      (v85->__vftable[2].~facet_0)(v85, 10);
      std::locale::~locale(&v183);
      std::ostream::put();
      std::ostream::flush();
      v86.i32[0] = v77[12];
      v87 = vrev64_s16(*&vmovl_u8(v86));
      LODWORD(v183.__locale_) = vuzp1_s8(v87, v87).u32[0];
      BYTE4(v183.__locale_) = 0;
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Scope:                  ", 24);
      v88 = strlen(&v183);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, &v183, v88);
      std::ios_base::getloc((v2 + *(*v2 - 24)));
      v89 = std::locale::use_facet(&v196, v76);
      (v89->__vftable[2].~facet_0)(v89, 10);
      std::locale::~locale(&v196);
      std::ostream::put();
      std::ostream::flush();
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Element:                ", 24);
      v90 = MEMORY[0x1E12C1210](v2, v77[13]);
      std::ios_base::getloc((v90 + *(*v90 - 24)));
      v91 = std::locale::use_facet(&v198, v76);
      (v91->__vftable[2].~facet_0)(v91, 10);
      std::locale::~locale(&v198);
      std::ostream::put();
      std::ostream::flush();
      v93 = v77[5];
      v92 = v77[6];
      if (v93 == v92 || v93 == 1936483442)
      {
        v95 = v93 == v92;
        if (v93 == 1936483442)
        {
          v95 = 0;
        }

        if (!v95)
        {
LABEL_58:
          v96 = v77[4];
          v198.__locale_ = 0x676C6F6273647276;
          LODWORD(v199) = 0;
          v170 = 0;
          v169 = 0;
          (*(*v77 + 120))(v77, v96, &v198, 4, &v169, &v170, 0, 0, 0, v148);
          v97 = v170;
          v196.__locale_ = 0;
          LODWORD(v182.__locale_) = 8;
          v98 = v77[4];
          v198.__locale_ = 0x676C6F6273647272;
          LODWORD(v199) = 0;
          (*(*v77 + 120))(v77, v98, &v198, 8, &v182, &v196, 0, 0, 0);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Value:                  ", 24);
          v99 = MEMORY[0x1E12C1210](v2, v97);
          std::ios_base::getloc((v99 + *(*v99 - 24)));
          v100 = std::locale::use_facet(&v184, v76);
          (v100->__vftable[2].~facet_0)(v100, 10);
          std::locale::~locale(&v184);
          std::ostream::put();
          std::ostream::flush();
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Min Value:              ", 24);
          v101 = MEMORY[0x1E12C1210](v2, LODWORD(v196.__locale_));
          std::ios_base::getloc((v101 + *(*v101 - 24)));
          v102 = std::locale::use_facet(&v185, v76);
          (v102->__vftable[2].~facet_0)(v102, 10);
          std::locale::~locale(&v185);
          std::ostream::put();
          std::ostream::flush();
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Max Value:              ", 24);
          v103 = MEMORY[0x1E12C1210](v2, HIDWORD(v196.__locale_));
          std::ios_base::getloc((v103 + *(*v103 - 24)));
          v104 = std::locale::use_facet(&v186, v76);
          (v104->__vftable[2].~facet_0)(v104, 10);
          std::locale::~locale(&v186);
          std::ostream::put();
          std::ostream::flush();
          goto LABEL_63;
        }
      }

      else if (v92 == 1936483442)
      {
        goto LABEL_58;
      }

      if (v93 <= 1936028006)
      {
        if (v93 == 1818588780)
        {
          goto LABEL_62;
        }

        v94 = 1886544237;
      }

      else
      {
        if (v93 == 1936028007 || v93 == 1937072758)
        {
LABEL_62:
          v105 = v77[4];
          v198.__locale_ = 0x676C6F626C637376;
          LODWORD(v199) = 0;
          v172 = 0;
          v171 = 0;
          (*(*v77 + 120))(v77, v105, &v198, 4, &v171, &v172, 0, 0, 0);
          v106 = v77[4];
          v198.__locale_ = 0x676C6F626C636476;
          LODWORD(v199) = 0;
          v174 = 0;
          v173 = 0;
          (*(*v77 + 120))(v77, v106, &v198, 4, &v173, &v174, 0, 0, 0);
          v199 = 0.0;
          v198.__locale_ = 0;
          v107 = v77[4];
          v196.__locale_ = 0x676C6F626C636476;
          LODWORD(v197) = 0;
          v175 = 0;
          (*(*v77 + 120))(v77, v107, &v196, 16, &v175, &v198, 0, 0, 0);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Scalar Value:           ", 24);
          v108 = std::ostream::operator<<();
          std::ios_base::getloc((v108 + *(*v108 - 24)));
          v109 = std::locale::use_facet(&v187, v76);
          (v109->__vftable[2].~facet_0)(v109, 10);
          std::locale::~locale(&v187);
          std::ostream::put();
          std::ostream::flush();
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "dB Value:               ", 24);
          v110 = std::ostream::operator<<();
          std::ios_base::getloc((v110 + *(*v110 - 24)));
          v111 = std::locale::use_facet(&v188, v76);
          (v111->__vftable[2].~facet_0)(v111, 10);
          std::locale::~locale(&v188);
          std::ostream::put();
          std::ostream::flush();
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Min dB Value:           ", 24);
          v112 = MEMORY[0x1E12C11E0](v2, *&v198.__locale_);
          std::ios_base::getloc((v112 + *(*v112 - 24)));
          v113 = std::locale::use_facet(&v189, v76);
          (v113->__vftable[2].~facet_0)(v113, 10);
          std::locale::~locale(&v189);
          std::ostream::put();
          std::ostream::flush();
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Max dB Value:           ", 24);
          v114 = MEMORY[0x1E12C11E0](v2, v199);
          std::ios_base::getloc((v114 + *(*v114 - 24)));
          v115 = std::locale::use_facet(&v190, v76);
          (v115->__vftable[2].~facet_0)(v115, 10);
          std::locale::~locale(&v190);
          std::ostream::put();
          std::ostream::flush();
          goto LABEL_63;
        }

        v94 = 1986817381;
      }

      if (v93 == v94)
      {
        goto LABEL_62;
      }

      if (v93 == v92)
      {
        if (HALB_Info::IsSubClass(v77[5], 1953458028) || v93 != v92)
        {
          goto LABEL_67;
        }
      }

      else
      {
        if (v92 <= 1936028006)
        {
          if (v92 == 1818588780)
          {
            goto LABEL_62;
          }

          v121 = 1886544237;
        }

        else
        {
          if (v92 == 1936028007 || v92 == 1986817381)
          {
            goto LABEL_62;
          }

          v121 = 1937072758;
        }

        if (v92 == v121)
        {
          goto LABEL_62;
        }

        IsSubClass = HALB_Info::IsSubClass(v77[5], 1953458028);
        if (v93 == v92 || IsSubClass || HALB_Info::IsSubClass(v92, 1953458028))
        {
LABEL_67:
          v116 = v77[4];
          v198.__locale_ = 0x676C6F626263766CLL;
          LODWORD(v199) = 0;
          v176 = 0;
          (*(*v77 + 120))(v77, v116, &v198, 4, &v176, &v176 + 4, 0, 0, 0);
          v117 = HIDWORD(v176);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Value:                  ", 24);
          if (v117)
          {
            v118 = "on";
          }

          else
          {
            v118 = "off";
          }

          if (v117)
          {
            v119 = 2;
          }

          else
          {
            v119 = 3;
          }

          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, v118, v119);
          std::ios_base::getloc((v2 + *(*v2 - 24)));
          v120 = std::locale::use_facet(&v191, v76);
          (v120->__vftable[2].~facet_0)(v120, 10);
          std::locale::~locale(&v191);
          std::ostream::put();
          std::ostream::flush();
          goto LABEL_63;
        }
      }

      if (v93 > 1751740517)
      {
        if (v93 == 1751740518 || v93 == 1852601964)
        {
LABEL_92:
          v124 = v77[4];
          v198.__locale_ = 0x676C6F6273636369;
          LODWORD(v199) = 0;
          v125 = (*(*v77 + 112))(v77, v124, &v198, 0, 0, 0);
          LODWORD(v198.__locale_) = 0;
          std::vector<unsigned int>::vector[abi:ne200100](&v196, v125 >> 2);
          v126 = v77[4];
          v198.__locale_ = 0x676C6F6273636369;
          LODWORD(v199) = 0;
          v177 = 0;
          (*(*v77 + 120))(v77, v126, &v198, v125 & 0xFFFFFFFC, &v177, v196.__locale_, 0, 0, 0);
          v127 = v177;
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Number Selector Values: ", 24);
          v128 = MEMORY[0x1E12C1210](v2, v127 >> 2);
          std::ios_base::getloc((v128 + *(*v128 - 24)));
          v129 = std::locale::use_facet(v155, v76);
          (v129->__vftable[2].~facet_0)(v129, 10);
          std::locale::~locale(v155);
          std::ostream::put();
          std::ostream::flush();
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Selector Value:        ", 23);
          v130 = v196.__locale_;
          v131 = v197;
          while (v130 != v131)
          {
            v132 = v77[4];
            v198.__locale_ = 0x676C6F626E696373;
            LODWORD(v199) = 0;
            v179 = 0;
            v178 = 0;
            (*(*v77 + 120))(v77, v132, &v198, 8, &v178, &v179, 4, v130, 0);
            v155[0].__locale_ = &unk_1F5991188;
            v155[1].__locale_ = v179;
            OS::CF::String::AsCString(v155, &v198, 128);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, " ", 1);
            v133 = MEMORY[0x1E12C1210](v2, *v130);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v133, "->", 2);
            v134 = strlen(&v198);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v133, &v198, v134);
            std::ios_base::getloc((v133 + *(*v133 - 24)));
            v135 = std::locale::use_facet(&v193, v76);
            (v135->__vftable[2].~facet_0)(v135, 10);
            std::locale::~locale(&v193);
            std::ostream::put();
            std::ostream::flush();
            OS::CF::UntypedObject::~UntypedObject(v155);
            v130 = (v130 + 4);
          }

          std::ios_base::getloc((v2 + *(*v2 - 24)));
          v136 = std::locale::use_facet(&v192, v76);
          (v136->__vftable[2].~facet_0)(v136, 10);
          std::locale::~locale(&v192);
          std::ostream::put();
          std::ostream::flush();
          if (v196.__locale_)
          {
            v197 = v196.__locale_;
            operator delete(v196.__locale_);
          }

          goto LABEL_63;
        }

        v123 = 1936483188;
      }

      else
      {
        if (v93 == 1668047723 || v93 == 1684370292)
        {
          goto LABEL_92;
        }

        v123 = 1685287523;
      }

      if (v93 == v123)
      {
        goto LABEL_92;
      }

      if (v93 == v92)
      {
        if (v93 == 1936744814)
        {
          goto LABEL_99;
        }
      }

      else
      {
        if (v92 > 1751740517)
        {
          if (v92 == 1751740518 || v92 == 1936483188)
          {
            goto LABEL_92;
          }

          v145 = 1852601964;
        }

        else
        {
          if (v92 == 1668047723 || v92 == 1684370292)
          {
            goto LABEL_92;
          }

          v145 = 1685287523;
        }

        if (v92 == v145)
        {
          goto LABEL_92;
        }

        if (v93 == v92 || v93 == 1936744814 || v92 == 1936744814)
        {
LABEL_99:
          v137 = v77[4];
          v198.__locale_ = 0x676C6F6273647276;
          LODWORD(v199) = 0;
          v180 = 0;
          (*(*v77 + 120))(v77, v137, &v198, 4, &v180, &v180 + 4, 0, 0, 0);
          v196.__locale_ = 0;
          LODWORD(v182.__locale_) = 8;
          v138 = v77[4];
          v198.__locale_ = 0x676C6F6273647272;
          LODWORD(v199) = 0;
          (*(*v77 + 120))(v77, v138, &v198, 8, &v182, &v196, 0, 0, 0);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Value:                  ", 24);
          v139 = std::ostream::operator<<();
          std::ios_base::getloc((v139 + *(*v139 - 24)));
          v140 = std::locale::use_facet(&v194, v76);
          (v140->__vftable[2].~facet_0)(v140, 10);
          std::locale::~locale(&v194);
          std::ostream::put();
          std::ostream::flush();
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Left Channel:           ", 24);
          v141 = MEMORY[0x1E12C1210](v2, LODWORD(v196.__locale_));
          std::ios_base::getloc((v141 + *(*v141 - 24)));
          v142 = std::locale::use_facet(&v150, v76);
          (v142->__vftable[2].~facet_0)(v142, 10);
          std::locale::~locale(&v150);
          std::ostream::put();
          std::ostream::flush();
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "    ", 4);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, "Right Channel:          ", 24);
          v143 = MEMORY[0x1E12C1210](v2, HIDWORD(v196.__locale_));
          std::ios_base::getloc((v143 + *(*v143 - 24)));
          v144 = std::locale::use_facet(&__p, v76);
          (v144->__vftable[2].~facet_0)(v144, 10);
          std::locale::~locale(&__p);
          std::ostream::put();
          std::ostream::flush();
        }
      }

LABEL_63:
      *&mSampleRate += 8;
    }

    while (*&mSampleRate != v75);
  }

  HALS_Device::DumpDuckHistory(a1, 1, v148, 4);
  HALS_Device::BasicControlList::~BasicControlList(&v158, v146);
  OS::CF::UntypedObject::~UntypedObject(v154);
  v147 = *MEMORY[0x1E69E9840];
}

void sub_1DE720494(_Unwind_Exception *a1, HALS_Object *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, void);
  v13 = va_arg(va1, void);
  v14 = va_arg(va1, void);
  v15 = va_arg(va1, void);
  v16 = va_arg(va1, void);
  v17 = va_arg(va1, void);
  v18 = va_arg(va1, void);
  v19 = va_arg(va1, void);
  HALS_Device::BasicControlList::~BasicControlList(va1, a2);
  OS::CF::UntypedObject::~UntypedObject(va);
  _Unwind_Resume(a1);
}

void HALS_Device::CopyStreamList(uint64_t a1, char a2, void **a3)
{
  v20 = 0;
  v21 = &v20;
  v22 = 0x4002000000;
  v23 = __Block_byref_object_copy__20143;
  v24 = __Block_byref_object_dispose__20144;
  __p = 0;
  v26 = 0;
  v27 = 0;
  v18[0] = MEMORY[0x1E69E9820];
  v18[1] = 0x40000000;
  v18[2] = ___ZNK11HALS_Device14CopyStreamListEbRNSt3__16vectorIP11HALS_StreamNS0_9allocatorIS3_EEEE_block_invoke;
  v18[3] = &unk_1E86789B8;
  v19 = a2;
  v18[4] = &v20;
  v18[5] = a1;
  v4 = (*(*a1 + 64))(a1);
  HALB_CommandGate::ExecuteCommand(v4, v18);
  if (v21 + 5 != a3)
  {
    v5 = v21[5];
    v6 = v21[6];
    v7 = v6 - v5;
    v8 = a3[2];
    v9 = *a3;
    if (v8 - *a3 < (v6 - v5))
    {
      v10 = v7 >> 3;
      if (v9)
      {
        a3[1] = v9;
        operator delete(v9);
        v8 = 0;
        *a3 = 0;
        a3[1] = 0;
        a3[2] = 0;
      }

      if (!(v10 >> 61))
      {
        v11 = v8 >> 2;
        if (v8 >> 2 <= v10)
        {
          v11 = v7 >> 3;
        }

        if (v8 >= 0x7FFFFFFFFFFFFFF8)
        {
          v12 = 0x1FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v12 = v11;
        }

        if (!(v12 >> 61))
        {
          std::allocator<HALS_Device *>::allocate_at_least[abi:ne200100](v12);
        }
      }

      std::vector<void *>::__throw_length_error[abi:ne200100]();
    }

    v13 = a3[1];
    v14 = v13 - v9;
    if (v13 - v9 >= v7)
    {
      if (v6 != v5)
      {
        memmove(v9, v5, v6 - v5);
      }

      v17 = &v9[v7];
    }

    else
    {
      if (v13 != v9)
      {
        memmove(*a3, v5, v13 - v9);
        v13 = a3[1];
      }

      v15 = &v5[v14];
      v16 = v6 - &v5[v14];
      if (v16)
      {
        memmove(v13, v15, v16);
      }

      v17 = &v13[v16];
    }

    a3[1] = v17;
  }

  _Block_object_dispose(&v20, 8);
  if (__p)
  {
    v26 = __p;
    operator delete(__p);
  }
}

void sub_1DE720808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23)
{
  _Block_object_dispose(&a17, 8);
  if (__p)
  {
    a23 = __p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__20143(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(a2 + 40);
  *(a1 + 5) = result;
  a1[7] = *(a2 + 56);
  *(a2 + 40) = 0;
  *(a2 + 48) = 0;
  *(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__20144(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (v2)
  {
    *(a1 + 48) = v2;
    operator delete(v2);
  }
}

void sub_1DE7208C0(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t HALS_Device::GetTotalNumberChannels(HALS_Device *this, char a2)
{
  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v5[0] = MEMORY[0x1E69E9820];
  v5[1] = 0x40000000;
  v5[2] = ___ZNK11HALS_Device22GetTotalNumberChannelsEb_block_invoke;
  v5[3] = &unk_1E8678968;
  v5[4] = &v7;
  v5[5] = this;
  v6 = a2;
  v2 = (*(*this + 64))(this);
  HALB_CommandGate::ExecuteCommand(v2, v5);
  v3 = *(v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t ___ZNK11HALS_Device22GetTotalNumberChannelsEb_block_invoke(uint64_t a1)
{
  result = (*(**(a1 + 40) + 560))(*(a1 + 40), *(a1 + 48));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE720A20(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t HALS_Device::AreAllStreamsMixable(HALS_Device *this, char a2)
{
  v8 = 0;
  v9 = 0;
  v10 = 0;
  HALS_Device::CopyStreamList(this, a2, &v8);
  v3 = v8;
  v4 = v9;
  if (v8 == v9)
  {
LABEL_5:
    v5 = 1;
  }

  else
  {
    while (1)
    {
      HALS_Stream::GetCurrentVirtualFormat(*v3, &v7);
      if (v7.mFormatID != 1819304813 || (v7.mFormatFlags & 0x40) != 0)
      {
        break;
      }

      if (++v3 == v4)
      {
        goto LABEL_5;
      }
    }

    v5 = 0;
  }

  HALS_ArrayReleaser<HALS_Stream>::~HALS_ArrayReleaser(&v8, v2);
  return v5;
}

void sub_1DE720AE4(_Unwind_Exception *a1, HALS_Object *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HALS_ArrayReleaser<HALS_Stream>::~HALS_ArrayReleaser(va, a2);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__66_20170(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 40);
  *(result + 44) = *(a2 + 44);
  *(result + 40) = v2;
  return result;
}

void ___ZNK11HALS_Device39GetClientChannelCountFromDSPDescriptionEv_block_invoke(uint64_t a1)
{
  v2 = *(a1 + 40);
  v3 = *(v2 + 472);
  if (v3 && CFDictionaryContainsKey(v3, @"client channel count"))
  {
    HALS_DSPSettings::FromDictionary(&v5, *(v2 + 472));
    v4 = *(*(a1 + 32) + 8);
    *(v4 + 40) = v10;
    *(v4 + 44) = 1;
    OS::CF::UntypedObject::~UntypedObject(&v13);
    if (__p)
    {
      v12 = __p;
      operator delete(__p);
    }

    if (cf)
    {
      CFRelease(cf);
    }

    OS::CF::UntypedObject::~UntypedObject(&v8);
    OS::CF::UntypedObject::~UntypedObject(&v7);
    if (v6 < 0)
    {
      operator delete(v5);
    }
  }
}

uint64_t HALS_Device::GetStreamDSPLatency(HALS_Device *this, const BOOL *a2)
{
  if (AMCP::Feature_Flags::run_hybrid_hal(this, a2))
  {
    return 0;
  }

  v6 = (*(*this + 408))(this);
  if (v6 && (v7 = (*(*this + 544))(this, a2, 0)) != 0)
  {
    v8 = 0;
    LODWORD(v4) = 0;
    do
    {
      v9 = (*(*v6 + 520))(v6, a2, v8);
      if (v4 <= v9)
      {
        v4 = v9;
      }

      else
      {
        v4 = v4;
      }

      v8 = (v8 + 1);
    }

    while (v7 != v8);
  }

  else
  {
    v4 = 0;
  }

  HALS_ObjectMap::ReleaseObject(v6, v5);
  return v4;
}

uint64_t HALS_Device::GetReferenceStreamIndex(HALS_Device *this)
{
  v9 = 0;
  v10 = 0;
  v11 = 0;
  HALS_Device::CopyStreamList(this, 1, &v9);
  v2 = v9;
  v3 = v10;
  if (v9 == v10)
  {
LABEL_6:
    v5 = 0;
    v6 = 0;
    v7 = 0;
  }

  else
  {
    v4 = 0;
    while (*(*v2 + 14) != 1 && (HALS_Stream::IsHardwareReferenceStream(*v2) & 1) == 0)
    {
      ++v4;
      if (++v2 == v3)
      {
        goto LABEL_6;
      }
    }

    v7 = v4 & 0xFFFFFF00;
    v5 = v4;
    v6 = 0x100000000;
  }

  HALS_ArrayReleaser<HALS_Stream>::~HALS_ArrayReleaser(&v9, v1);
  return v6 | v7 | v5;
}

void sub_1DE720DC4(_Unwind_Exception *a1, HALS_Object *a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HALS_ArrayReleaser<HALS_Stream>::~HALS_ArrayReleaser(va, a2);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(HALS_Client *,BOOL)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t std::__function::__func<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1,std::allocator<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "ZN11HALS_Device32SetReferenceStreamStateForClientEjbE3$_1"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void std::__function::__func<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1,std::allocator<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  v8 = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 8);
  (*(*v2 + 976))(v2, 0, *(a1 + 16));
  v4 = *(a1 + 24);
  if (v4)
  {
    v7[0] = xmmword_1DE7A4CCC;
    *(v7 + 12) = *(&xmmword_1DE7A4CCC + 12);
    v6[0] = *"#mtsbolg";
    v6[1] = *"tpni";
    HALS_NotificationManager::PropertiesChanged(v2[4], *(v4 + 16), 5, v6, v3);
  }

  v5 = *MEMORY[0x1E69E9840];
}

void std::__function::__func<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1,std::allocator<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1>,void ()(void)>::destroy_deallocate(HALS_ObjectMap **a1, HALS_Object *a2)
{
  HALS_ObjectMap::ReleaseObject(a1[3], a2);

  operator delete(a1);
}

void std::__function::__func<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1,std::allocator<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F598E6B0;
  v2 = *(a1 + 8);
  *(a2 + 16) = *(a1 + 16);
  *(a2 + 8) = v2;
  v3 = *(a1 + 24);
  *(a2 + 24) = v3;
  HALS_ObjectMap::RetainObject(v3, a2);
}

void std::__function::__func<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1,std::allocator<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1>,void ()(void)>::~__func(uint64_t a1, HALS_Object *a2)
{
  *a1 = &unk_1F598E6B0;
  HALS_ObjectMap::ReleaseObject(*(a1 + 24), a2);

  JUMPOUT(0x1E12C1730);
}

uint64_t std::__function::__func<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1,std::allocator<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_1>,void ()(void)>::~__func(uint64_t a1, HALS_Object *a2)
{
  *a1 = &unk_1F598E6B0;
  HALS_ObjectMap::ReleaseObject(*(a1 + 24), a2);
  return a1;
}

uint64_t std::__function::__func<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_0,std::allocator<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_0>,void ()(HALS_Client *,BOOL)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "ZN11HALS_Device32SetReferenceStreamStateForClientEjbE3$_0"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__func<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_0,std::allocator<HALS_Device::SetReferenceStreamStateForClient(unsigned int,BOOL)::$_0>,void ()(HALS_Client *,BOOL)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F598E620;
  a2[1] = v2;
  return result;
}

uint64_t ___ZN11HALS_Device10ClientDiedEP11HALS_Client_block_invoke(uint64_t a1)
{
  result = (*(**(a1 + 40) + 832))(*(a1 + 40), *(a1 + 48));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE7212C4(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void HALS_Device::UpdateInternalIOContext(HALS_Device *this)
{
  v2 = (*(*this + 840))(this);
  if (v2)
  {
    if (AMCP::Feature_Flags::run_hybrid_hal(v2, v3))
    {
      v33[0] = 0;
      v33[1] = 0;
      HALS_System::GetInstance(&cf, 0, v33);
      HALS_IOContext_Manager::create_stream_info_for_device(&__p, *(cf + 218), this);
      if (p_cf)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](p_cf);
      }

      v32[0] = 0;
      v32[1] = 0;
      HALS_System::GetInstance(&cf, 0, v32);
      v4 = *(cf + 218);
      v5 = *(this + 4);
      v6 = *(this + 7);
      v7 = (*(*this + 216))(this);
      v31 = v7;
      if (v7)
      {
        v8 = CFGetTypeID(v7);
        if (v8 != CFStringGetTypeID())
        {
          exception = __cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Could not construct");
          __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
        }
      }

      (*(*this + 232))(this);
      HALS_IOContext_Manager::device_arrived(v4, v5, v6, &v31, &__p);
    }

    v9 = *(this + 4);
    __p = 0x676C6F62696F6374;
    LODWORD(p_p) = 0;
    cf = 0;
    LODWORD(v34) = 0;
    (*(*this + 120))(this, v9, &__p, 8, &v34, &cf, 0, 0, 0);
    v10 = cf;
    v29 = cf;
    v30 = 1;
    __p = 0;
    p_p = &__p;
    v27 = 0x2000000000;
    v28 = 0;
    cf = 0;
    p_cf = &cf;
    v23 = 0x2000000000;
    v24 = 0;
    v18[0] = MEMORY[0x1E69E9820];
    v18[1] = 1174405120;
    v18[2] = ___ZN11HALS_Device23UpdateInternalIOContextEv_block_invoke;
    v18[3] = &unk_1F598E390;
    v18[6] = this;
    v19 = v10;
    v20 = 1;
    if (v10)
    {
      CFRetain(v10);
    }

    v18[4] = &cf;
    v18[5] = &__p;
    v11 = (*(*this + 64))(this);
    HALB_CommandGate::ExecuteCommand(v11, v18);
    v12 = *(p_p + 6);
    if (v12 && (p_cf[1].__vftable & 1) == 0)
    {
      v13 = HALS_ObjectMap::CopyObjectByObjectID(v12);
      v15 = v13;
      if (v13)
      {
        v16 = v13[4];
        v34 = 0x676C6F6261636F6DLL;
        v35 = 0;
        v36 = v29;
        (*(*v13 + 128))(v13, v16, &v34, 8, &v36, 0, 0, 0);
      }

      HALS_ObjectMap::ReleaseObject(v15, v14);
    }

    CACFDictionary::~CACFDictionary(&v19);
    _Block_object_dispose(&cf, 8);
    _Block_object_dispose(&__p, 8);
    CACFDictionary::~CACFDictionary(&v29);
  }
}

void sub_1DE721664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, std::__shared_weak_count *a20, uint64_t a21, uint64_t a22, void *__p)
{
  __cxa_free_exception(v23);
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef((v24 - 112));
  if (a20)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a20);
  }

  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void ___ZN11HALS_Device23UpdateInternalIOContextEv_block_invoke(void *a1)
{
  v2 = a1[6];
  v3 = *(v2 + 616);
  if (!v3)
  {
    v19[0] = 0;
    v19[1] = 0;
    HALS_System::GetInstance(&v20, 0, v19);
    v4 = v20;
    v5 = a1[7];
    v23 = 0;
    v24 = &v23;
    v25 = 0x2000000000;
    v26 = 0;
    v22[0] = MEMORY[0x1E69E9820];
    v22[1] = 0x40000000;
    v22[2] = ___ZN11HALS_System15CreateIOContextEP11HALS_ClientPK14__CFDictionary_block_invoke;
    v22[3] = &unk_1E8675D40;
    v22[4] = &v23;
    v22[5] = v20;
    v22[6] = 0;
    v6 = (*(*v20 + 64))(v20);
    HALB_CommandGate::ExecuteCommand(v6, v22);
    v7 = v24[3];
    if (v7)
    {
      v8 = v7[4];
      v28 = 0x676C6F6261636F6DLL;
      LODWORD(v29) = 0;
      v27[0] = v5;
      (*(*v7 + 128))(v7, v8, &v28, 8, v27, 0, 0, 0);
      v9 = v24[3];
      v28 = 0;
      v29 = &v28;
      v30 = 0x4002000000;
      v31 = __Block_byref_object_copy__164;
      v32 = __Block_byref_object_dispose__165;
      memset(v33, 0, sizeof(v33));
      v27[0] = MEMORY[0x1E69E9820];
      v27[1] = 0x40000000;
      v27[2] = ___ZNK11HALS_System23UpdateTapsForNewContextEP14HALS_IOContext_block_invoke;
      v27[3] = &unk_1E8675E90;
      v27[4] = &v28;
      v27[5] = v4;
      v10 = (*(*v4 + 64))(v4);
      HALB_CommandGate::ExecuteCommand(v10, v27);
      v11 = v29[5];
      v12 = v29[6];
      while (1)
      {
        if (v11 == v12)
        {
          _Block_object_dispose(&v28, 8);
          HALS_ArrayReleaser<HALS_Tap>::~HALS_ArrayReleaser(v33, v17);
          v18 = v24[3];
          goto LABEL_20;
        }

        v13 = *v11;
        v14 = *v9[9];
        if (*(*v11 + 89) != 1)
        {
          break;
        }

        v34 = 0;
        v35 = 0;
        v36 = 0;
        std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(&v34, *(v13 + 28), *(v13 + 29), (*(v13 + 29) - *(v13 + 28)) >> 2);
        v15 = v35;
        v16 = v34;
        if (v34 != v35)
        {
          v16 = v34;
          while (*v16 != v14)
          {
            if (++v16 == v35)
            {
              v16 = v35;
              break;
            }
          }
        }

        if (v34)
        {
          operator delete(v34);
        }

        if (v16 != v15)
        {
          goto LABEL_16;
        }

LABEL_17:
        v11 += 8;
      }

      if (!std::__hash_table<std::__hash_value_type<unsigned int,HALS_Device_HostedDSP_ClientInfo::PerClientInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,HALS_Device_HostedDSP_ClientInfo::PerClientInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,HALS_Device_HostedDSP_ClientInfo::PerClientInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,HALS_Device_HostedDSP_ClientInfo::PerClientInfo>>>::find<unsigned int>(v13 + 13, *v9[9]))
      {
        goto LABEL_17;
      }

LABEL_16:
      HALS_Tap::AddTapToContext(v13, v9);
      goto LABEL_17;
    }

    v18 = 0;
LABEL_20:
    _Block_object_dispose(&v23, 8);
    if (v21)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v21);
    }

    v3 = *(v18 + 16);
    *(v18 + 80) = *(v2 + 16);
    *(v2 + 616) = v3;
    *(*(a1[4] + 8) + 24) = 1;
  }

  *(*(a1[5] + 8) + 24) = v3;
}

void sub_1DE721A84(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  v32 = *(v31 + 616);
  JUMPOUT(0x1DE721A54);
}

CFTypeRef __copy_helper_block_e8_56c20_ZTS14CACFDictionary(uint64_t a1, uint64_t a2)
{
  result = *(a2 + 56);
  *(a1 + 56) = result;
  v4 = *(a2 + 64);
  *(a1 + 64) = v4;
  *(a1 + 65) = *(a2 + 65);
  if (v4 == 1 && result != 0)
  {
    return CFRetain(result);
  }

  return result;
}

uint64_t HALS_Device::GetNeighborStartingChannel(HALS_Device *this, const HALS_Stream *a2, HALS_IODevice *a3)
{
  v5 = 1;
  NumberStreams = HALS_IODevice::GetNumberStreams(a2, 1);
  if (NumberStreams >= 2)
  {
    v7 = NumberStreams;
    v8 = 1;
    v9 = HALS_IODevice::CopyStreamByIndex(a2, 1, 0);
    do
    {
      v10 = HALS_IODevice::CopyStreamByIndex(a2, 1, v8);
      v12 = v10;
      if (v10)
      {
        if (v10 == this)
        {
          if (v9)
          {
            v15 = (*(*v9 + 208))(v9);
            v5 = HALS_Stream::GetNumberChannels(v9) + v15;
          }

          v14 = 2;
        }

        else
        {
          HALS_ObjectMap::RetainObject(v10, v11);
          HALS_ObjectMap::ReleaseObject(v9, v13);
          v14 = 0;
          v9 = v12;
        }
      }

      else
      {
        v14 = 4;
      }

      HALS_ObjectMap::ReleaseObject(v12, v11);
      if ((v14 | 4) != 4)
      {
        break;
      }

      ++v8;
    }

    while (v7 != v8);
    HALS_ObjectMap::ReleaseObject(v9, v16);
  }

  return v5;
}

void ___ZN11HALS_Device15ClearAllDuckingEv_block_invoke(uint64_t a1)
{
  v26 = *MEMORY[0x1E69E9840];
  v1 = *(a1 + 32);
  v2 = v1[68];
  v3 = v1[69];
  if (v2 != v3)
  {
    v4 = MEMORY[0x1E69E9C10];
    do
    {
      if (*(v2 + 32) == 1)
      {
        v2[9] = 1065353216;
        v5 = HALS_ObjectMap::CopyObjectByObjectID(*v2);
        v6 = v5;
        if (v5)
        {
          v7 = *(v5 + 240);
        }

        else
        {
          v7 = -1;
        }

        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          v8 = *v2;
          v9 = (*(*v1 + 224))(v1);
          v10 = *(v1 + 4);
          *buf = 136316418;
          v15 = "HALS_Device.cpp";
          v16 = 1024;
          v17 = 5410;
          v18 = 1024;
          v19 = v8;
          v20 = 1024;
          v21 = v7;
          v22 = 2080;
          v23 = v9;
          v24 = 1024;
          v25 = v10;
          _os_log_impl(&dword_1DE1F9000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  HALS_Device::ClearAllDucking: client %u (pid %d) unducking on device %s (%u)", buf, 0x2Eu);
        }

        HALS_Device::DumpDuckHistory(v1, 0, 0, 0);
        v11 = (*(*v1 + 272))(v1) * 0.0500000007;
        (*(*v1 + 800))(v1, 0.0, v11);
        HALS_ObjectMap::ReleaseObject(v6, v12);
      }

      v2 += 12;
    }

    while (v2 != v3);
  }

  v13 = *MEMORY[0x1E69E9840];
}

void sub_1DE721EDC(void *a1, int a2)
{
  if (!a2)
  {
    JUMPOUT(0x1DE721EE8);
  }

  __clang_call_terminate(a1);
}

void HALS_Device::DSP_AllocConfigProperties(HALS_Device *this, unsigned int a2)
{
  HALS_Device::DSP_Config_Properties(&v3, this, a2);
  v2 = v4;
  if (v4)
  {

    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }
}

uint64_t HALS_Device::GetDSPLatencyForClient(HALS_Device *this, char a2, HALS_Client *a3)
{
  v8 = 0;
  v9 = &v8;
  v10 = 0x3002000000;
  v11 = __Block_byref_object_copy__66_20170;
  v12 = __Block_byref_object_dispose__67_20171;
  v13 = 0;
  v14 = 0;
  v6[0] = MEMORY[0x1E69E9820];
  v6[1] = 0x40000000;
  v6[2] = ___ZNK11HALS_Device22GetDSPLatencyForClientEbP11HALS_Client_block_invoke;
  v6[3] = &unk_1E86792C8;
  v6[4] = &v8;
  v6[5] = this;
  v7 = a2;
  v6[6] = a3;
  v3 = (*(*this + 64))(this);
  HALB_CommandGate::ExecuteCommand(v3, v6);
  v4 = v9[5];
  _Block_object_dispose(&v8, 8);
  return v4;
}

void sub_1DE722044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK11HALS_Device22GetDSPLatencyForClientEbP11HALS_Client_block_invoke(uint64_t a1)
{
  result = HALS_Device_HostedDSP_ClientInfo::get_dsp_latency_for_client(*(a1 + 40) + 648, *(a1 + 56), *(a1 + 48));
  v3 = *(*(a1 + 32) + 8);
  *(v3 + 44) = BYTE4(result);
  *(v3 + 40) = result;
  return result;
}

uint64_t *___ZNK11HALS_Device31RationalizeDSPOffloadsForClientEbP11HALS_Client_block_invoke(uint64_t a1)
{
  v2 = *(*(a1 + 40) + 632);
  if (v2)
  {
    HALS_Device_HostedDSP::RationalizeDSPOffloadsForClient(&v5, v2, *(a1 + 56), *(a1 + 48));
    v2 = v5;
  }

  v3 = *(*(a1 + 32) + 8);
  v5 = 0;
  std::unique_ptr<DSP_Host_OffloadDictionary>::reset[abi:ne200100]((v3 + 40), v2);
  return std::unique_ptr<DSP_Host_OffloadDictionary>::reset[abi:ne200100](&v5, 0);
}

void sub_1DE722108(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

void *__Block_byref_object_copy__300(void *result, void *a2)
{
  result[5] = a2[5];
  v2 = a2 + 6;
  v3 = a2[6];
  result[6] = v3;
  v4 = result + 6;
  v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(v3 + 16) = v4;
    a2[5] = v2;
    *v2 = 0;
    a2[7] = 0;
  }

  else
  {
    result[5] = v4;
  }

  return result;
}

void ___ZNK11HALS_Device20GetDSPTypesForClientEbP11HALS_Client_block_invoke(uint64_t a1)
{
  HALS_Device_HostedDSP_ClientInfo::get_dsp_types_for_client(&v6, *(a1 + 40) + 648, *(a1 + 56), *(a1 + 48));
  v2 = *(*(a1 + 32) + 8);
  v3 = v2 + 48;
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(*(v2 + 48));
  v4 = v7;
  *(v2 + 40) = v6;
  *(v2 + 48) = v4;
  v5 = v8;
  *(v2 + 56) = v8;
  if (v5)
  {
    v4[2] = v3;
    v6 = &v7;
    v7 = 0;
    v8 = 0;
    v4 = 0;
  }

  else
  {
    *(v2 + 40) = v3;
  }

  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v4);
}

void sub_1DE722204(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE7221F0);
}

void ___ZN11HALS_Device26MirrorOtherDeviceClientDSPEbPKS__block_invoke(void *a1)
{
  v1 = *(*(a1[4] + 8) + 24);
  v2 = *(*(a1[5] + 8) + 24);
  v3 = a1[7];
  std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](v6, (*(a1[6] + 8) + 40));
  v5[0] = 0;
  v5[1] = 0;
  v4 = v5;
  HALS_Device::_ConfigureDSPTypesForClient(v3, v1, v2, v6, &v4);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v5[0]);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v6[1]);
}

void sub_1DE7222B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13)
{
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a10);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a13);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HALS_Device::MirrorOtherDeviceClientDSP(BOOL,HALS_Device const*)::$_0,std::allocator<HALS_Device::MirrorOtherDeviceClientDSP(BOOL,HALS_Device const*)::$_0>,void ()(unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "ZN11HALS_Device26MirrorOtherDeviceClientDSPEbPKS_E3$_0"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void std::__function::__func<HALS_Device::MirrorOtherDeviceClientDSP(BOOL,HALS_Device const*)::$_0,std::allocator<HALS_Device::MirrorOtherDeviceClientDSP(BOOL,HALS_Device const*)::$_0>,void ()(unsigned int)>::operator()(uint64_t a1, unsigned int *a2)
{
  v3 = *a2;
  v4 = *(a1 + 16);
  HALS_Device::DSP_AllocConfigProperties(v4, *a2);
  v5 = *(v4 + 78);
  v6 = *(a1 + 8);

  HALS_DSPHostPerClientConfiguration::clone_configuration_from(v5, v6, v3);
}

__n128 std::__function::__func<HALS_Device::MirrorOtherDeviceClientDSP(BOOL,HALS_Device const*)::$_0,std::allocator<HALS_Device::MirrorOtherDeviceClientDSP(BOOL,HALS_Device const*)::$_0>,void ()(unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F598E7E8;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

uint64_t __Block_byref_object_copy__314(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 40);
  *(a2 + 40) = 0;
  *(result + 40) = v2;
  v5 = *(a2 + 56);
  v3 = a2 + 56;
  v4 = v5;
  v6 = *(v3 - 8);
  *(result + 56) = v5;
  *(result + 48) = v6;
  *(v3 - 8) = 0;
  v7 = *(v3 + 8);
  *(result + 64) = v7;
  *(result + 72) = *(v3 + 16);
  if (v7)
  {
    v8 = *(v4 + 8);
    v9 = *(result + 48);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
      {
        v8 %= v9;
      }
    }

    else
    {
      v8 &= v9 - 1;
    }

    *(v2 + 8 * v8) = result + 56;
    *v3 = 0;
    *(v3 + 8) = 0;
  }

  return result;
}

void ___ZNK11HALS_Device16CopyClientDSPMapEb_block_invoke(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *(a1 + 48);
  std::mutex::lock((v1 + 704));
  v3 = *(v1 + 680);
  if (v3)
  {
    if (v2)
    {
      v4 = 1;
    }

    else
    {
      v4 = 7;
    }

    do
    {
      v5 = &v3[v4 + 2];
      if (v5[2])
      {
        v11 = *(v3 + 4);
        std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](&v12, v5);
        operator new();
      }

      v3 = *v3;
    }

    while (v3);
  }

  std::mutex::unlock((v1 + 704));
  v6 = *(*(a1 + 32) + 8);
  if (*(v6 + 64))
  {
    std::__hash_table<std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>>>::__deallocate_node(*(v6 + 56));
    *(v6 + 56) = 0;
    v7 = *(v6 + 48);
    if (v7)
    {
      for (i = 0; i != v7; ++i)
      {
        *(*(v6 + 40) + 8 * i) = 0;
      }
    }

    *(v6 + 64) = 0;
  }

  v9 = *(v6 + 40);
  *(v6 + 40) = 0;
  if (v9)
  {
    operator delete(v9);
  }

  *(v6 + 56) = 0;
  *(v6 + 48) = 0;
  *(v6 + 64) = 0;
  *(v6 + 72) = 1065353216;
  std::__hash_table<std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>>>::__deallocate_node(0);
}

void sub_1DE722830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::mutex *a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v19[4]);
  operator delete(v19);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a19);
  std::__hash_table<std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<DSP_Host_Types::AudioProcessingType>>>>::~__hash_table(&a11);
  std::mutex::unlock(a10 + 11);
  _Unwind_Resume(a1);
}

BOOL StreamLessThan(const HALS_Stream *a1, const HALS_Stream *a2)
{
  v2 = 0;
  if (a1 && a2)
  {
    v4 = (*(*a1 + 208))(a1);
    return v4 < (*(*a2 + 208))(a2);
  }

  return v2;
}

void ___ZN11HALS_Device27UpdateAndCopyEngineReplacerEv_block_invoke(uint64_t a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 40);
  *(*(*(a1 + 32) + 8) + 24) = HALS_Device::CopyIOEngineReplacerOwningDevice(v2);
  v4 = *(*(*(a1 + 32) + 8) + 24);
  if (!v4)
  {
    v7 = *(v2 + 96);
    if (!v7)
    {
      goto LABEL_21;
    }

    v5 = 0;
    v6 = (v2 + 768);
LABEL_7:
    v8 = *(v7 + 16);
    if (v5 == v8)
    {
      goto LABEL_21;
    }

    v9 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v9 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v4);
    }

    v11 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v10 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      v12 = *v11;
      std::__shared_weak_count::__release_shared[abi:ne200100](v10);
    }

    else
    {
      v12 = *v11;
    }

    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *v17 = 136316162;
      *&v17[4] = "HALS_Device.cpp";
      *&v17[12] = 1024;
      *&v17[14] = 6206;
      *&v17[18] = 1024;
      *&v17[20] = v5;
      LOWORD(v18) = 2082;
      *(&v18 + 2) = v2 + 164;
      WORD5(v18) = 1024;
      HIDWORD(v18) = v8;
      _os_log_impl(&dword_1DE1F9000, v12, OS_LOG_TYPE_DEFAULT, "%32s:%-5d New replacer device %u, clear the cached replacer device state '%{public}s' %u", v17, 0x28u);
    }

    v13 = *v6;
    *v17 = MEMORY[0x1E69E9820];
    *&v17[8] = 0x40000000;
    *&v17[16] = ___ZN11HALS_Device15ClearAllDuckingEv_block_invoke;
    *&v18 = &__block_descriptor_tmp_279;
    *(&v18 + 1) = v13;
    v14 = (*(*v13 + 64))(v13);
    HALB_CommandGate::ExecuteCommand(v14, v17);
    atomic_store(0, *v6 + 776);
    v4 = *(*(*(a1 + 32) + 8) + 24);
    if (!v4)
    {
      goto LABEL_17;
    }

    goto LABEL_16;
  }

  v5 = *(v4 + 4);
  v6 = (v2 + 768);
  v7 = *(v2 + 96);
  if (v7)
  {
    goto LABEL_7;
  }

  if (!v5)
  {
    goto LABEL_21;
  }

LABEL_16:
  HALS_ObjectMap::RetainObject(v4, v3);
  atomic_store(1u, (*(*(*(a1 + 32) + 8) + 24) + 776));
LABEL_17:
  if (*v6)
  {
    atomic_store(0, *v6 + 776);
    v15 = *v6;
  }

  else
  {
    v15 = 0;
  }

  *v6 = *(*(*(a1 + 32) + 8) + 24);
  HALS_ObjectMap::ReleaseObject(v15, v3);
LABEL_21:
  v16 = *MEMORY[0x1E69E9840];
}

void sub_1DE722B64(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

void sub_1DE722ED4(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(DSP_Host_Types::MutationRequestConfiguration const&)>::__value_func[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

void sub_1DE723050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<void ()(AudioObjectPropertyAddress const&)>::~__value_func[abi:ne200100](va);
  _Unwind_Resume(a1);
}

void DSP_Factory_Bridge::~DSP_Factory_Bridge(id *this)
{

  JUMPOUT(0x1E12C1730);
}

{
}

void DSP_PropertySetWrapper::getHostedDSPProperty(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  v16 = *MEMORY[0x1E69E9840];
  v6 = *(a1 + 16);
  if (v6)
  {
    if (*(a3 + 8) == 1)
    {
      v8 = *a3;
      v6 = *(a1 + 16);
    }

    else
    {
      v8 = 0;
    }

    v15 = v8;
    v9 = [v6 getHostedDSPPropertyAtAddress:*a2 withQualifierData:{*(a2 + 8), v8}];
    v10 = v9;
    if (v9)
    {
      CFRetain(v9);
      *a4 = v10;
      v11 = CFGetTypeID(v10);
      if (v11 != CFDataGetTypeID())
      {
        exception = __cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
      }
    }

    else
    {
      *a4 = 0;
    }

    v13 = *MEMORY[0x1E69E9840];
  }

  else
  {
    *a4 = 0;
    v14 = *MEMORY[0x1E69E9840];
  }
}

uint64_t DSP_PropertySetWrapper::setHostedDSPProperty(DSP_PropertySetWrapper *this, const AudioObjectPropertyAddress *a2, id *a3, id *a4)
{
  v18[4] = *MEMORY[0x1E69E9840];
  v8 = 2003329396;
  v9 = objc_alloc(MEMORY[0x1E696ABC0]);
  if (*(this + 2) && (objc_opt_respondsToSelector() & 1) != 0)
  {
    if (a4)
    {
      a4 = *a4;
    }

    v10 = *(this + 2);
    v11 = *&a2->mSelector;
    mElement = a2->mElement;
    v13 = *a3;
    v18[0] = v9;
    v14 = [v10 setHostedDSPPropertyAtAddress:v11 withData:mElement withQualifier:v13 error:{a4, v18}];
    v15 = v18[0];

    if (v14)
    {
      v8 = 0;
    }

    else
    {
      v8 = 2003329396;
    }

    v9 = v15;
  }

  v16 = *MEMORY[0x1E69E9840];
  return v8;
}

void *DSP_PropertySetWrapper::hasHostedDSPProperty(DSP_PropertySetWrapper *this, const AudioObjectPropertyAddress *a2)
{
  v4 = *MEMORY[0x1E69E9840];
  result = *(this + 2);
  if (result)
  {
    result = [result hasHostedDSPPropertyAtAddress:{*&a2->mSelector, a2->mElement}];
  }

  v3 = *MEMORY[0x1E69E9840];
  return result;
}

void DSP_PropertySetWrapper::getHostedDSPPropertyInfoArray(DSP_PropertySetWrapper *this@<X0>, void *a2@<X8>)
{
  cf[4] = *MEMORY[0x1E69E9840];
  a2[1] = 0;
  a2[2] = 0;
  *a2 = &unk_1F598E988;
  a2[4] = 0;
  a2[5] = 0;
  a2[3] = 0;
  v3 = *(this + 2);
  if (v3)
  {
    v4 = [v3 getHostedDSPPropertyInfoArray];
    applesauce::CF::DictionaryRef::from_get(cf, v4);
    (*(*a2 + 32))(a2, cf);
    if (cf[0])
    {
      CFRelease(cf[0]);
    }
  }

  v5 = *MEMORY[0x1E69E9840];
}

void sub_1DE72381C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

void DSP_PropertySetWrapper::~DSP_PropertySetWrapper(DSP_PropertySetWrapper *this)
{
  DSP_PropertySetWrapper::~DSP_PropertySetWrapper(this);

  JUMPOUT(0x1E12C1730);
}

{
  *this = &unk_1F598E8A8;
  v2 = *(this + 2);
  *(this + 2) = 0;
}

uint64_t DSP_ProcessorWrapper::getProcessorPropertySet@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  v2 = *(this + 48);
  *a2 = *(this + 40);
  a2[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return this;
}

uint64_t DSP_ProcessorWrapper::adaptToConfigurationChange@<X0>(DSP_ProcessorWrapper *this@<X0>, const DSP_Host_Types::AdaptRequest *a2@<X1>, HAL_DSP_IOCallbacks *a3@<X2>, uint64_t a4@<X8>)
{
  v19[3] = *MEMORY[0x1E69E9840];
  DSP_Host_Types::AdaptResponse::AdaptResponse(a4);
  v8 = objc_alloc(MEMORY[0x1E696ABC0]);
  v9 = *(this + 4);
  cf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
  (*(*a2 + 24))(a2, &cf);
  mcp_applesauce::CF::Dictionary_Builder::get_dictionary(v19, cf);
  if (cf)
  {
    CFRelease(cf);
  }

  v10 = v19[0];
  v17 = v8;
  v11 = [v9 adaptToConfigurationChange:v10 withCallbacks:a3 error:&v17];
  v12 = v17;

  if (v19[0])
  {
    CFRelease(v19[0]);
  }

  applesauce::CF::DictionaryRef::from_get(&v16, v11);
  (*(*a4 + 32))(a4, &v16);
  if (v16)
  {
    CFRelease(v16);
  }

  if ((*(a4 + 44) & 1) == 0)
  {
    *(a4 + 40) = 0;
    *(a4 + 44) = 1;
  }

  *(a4 + 72) = [v12 code];

  if (*(a4 + 72))
  {
    v13 = "adaptToConfigurationChange UNSUPPORTED";
  }

  else
  {
    v13 = "adaptToConfigurationChange SUCCEEDED";
  }

  result = DSP_Host_Types::ConfigurationChangeRequest::debug_log_device_summary(a2, v13);
  v15 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1DE723BE0(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

void DSP_ProcessorWrapper::negotiateConfigurationChange(DSP_ProcessorWrapper *this@<X0>, const DSP_Host_Types::NegotiateRequest *a2@<X1>, uint64_t a3@<X8>)
{
  v18[3] = *MEMORY[0x1E69E9840];
  v6 = *(a2 + 65);
  v7 = *(a2 + 64);
  *(a3 + 8) = 0;
  *(a3 + 16) = 0;
  *a3 = &unk_1F598EA30;
  *(a3 + 24) = 0u;
  *(a3 + 40) = 0u;
  *(a3 + 56) = 0u;
  *(a3 + 72) = 0u;
  *(a3 + 88) = 0;
  *(a3 + 96) = -1;
  v8 = objc_alloc(MEMORY[0x1E696ABC0]);
  v9 = *(this + 4);
  cf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
  (*(*a2 + 24))(a2, &cf);
  mcp_applesauce::CF::Dictionary_Builder::get_dictionary(v18, cf);
  if (cf)
  {
    CFRelease(cf);
  }

  v10 = v18[0];
  v16 = v8;
  v11 = [v9 negotiateConfigurationChange:v10 error:&v16];
  v12 = v16;

  if (v18[0])
  {
    CFRelease(v18[0]);
  }

  applesauce::CF::DictionaryRef::from_get(&v15, v11);
  (*(*a3 + 32))(a3, &v15);
  if (v15)
  {
    CFRelease(v15);
  }

  *(a3 + 96) = [v12 code];

  if (*(a3 + 96))
  {
    v13 = "negotiateConfigurationChange UNSUPPORTED";
LABEL_11:
    DSP_Host_Types::ConfigurationChangeRequest::debug_log_device_summary(a2, v13);
    goto LABEL_12;
  }

  if (!(v6 & v7 & 1 | ((*(a2 + 41) & *(a2 + 40) & 1) == 0)))
  {
    v13 = "negotiateConfigurationChange";
    goto LABEL_11;
  }

LABEL_12:
  v14 = *MEMORY[0x1E69E9840];
}

void sub_1DE723F78(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

void DSP_ProcessorWrapper::simulateConfigurationChange(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v15[3] = *MEMORY[0x1E69E9840];
  *(a3 + 8) = 0;
  *(a3 + 16) = 0;
  *a3 = &unk_1F598EA30;
  *(a3 + 24) = 0u;
  *(a3 + 40) = 0u;
  *(a3 + 56) = 0u;
  *(a3 + 72) = 0u;
  *(a3 + 88) = 0;
  *(a3 + 96) = -1;
  v6 = objc_alloc(MEMORY[0x1E696ABC0]);
  v7 = *(a1 + 32);
  cf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
  (*(*a2 + 24))(a2, &cf);
  mcp_applesauce::CF::Dictionary_Builder::get_dictionary(v15, cf);
  if (cf)
  {
    CFRelease(cf);
  }

  v8 = v15[0];
  v13 = v6;
  v9 = [v7 simulateConfigurationChange:v8 error:&v13];
  v10 = v13;

  if (v15[0])
  {
    CFRelease(v15[0]);
  }

  applesauce::CF::DictionaryRef::from_get(&v12, v9);
  (*(*a3 + 32))(a3, &v12);
  if (v12)
  {
    CFRelease(v12);
  }

  *(a3 + 96) = [v10 code];

  v11 = *MEMORY[0x1E69E9840];
}

void sub_1DE7242C0(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

void DSP_ProcessorWrapper::~DSP_ProcessorWrapper(DSP_ProcessorWrapper *this)
{
  DSP_ProcessorWrapper::~DSP_ProcessorWrapper(this);

  JUMPOUT(0x1E12C1730);
}

{
  v13 = *MEMORY[0x1E69E9840];
  *this = &unk_1F598E910;
  v2 = *(this + 3);
  v12 = 0;
  [v2 setMutationRequestListener:v11];
  std::__function::__value_func<void ()(DSP_Host_Types::MutationRequestConfiguration const&)>::~__value_func[abi:ne200100](v11);
  v3 = *(this + 3);
  v10 = 0;
  [v3 setPropertyChangeListener:v9];
  std::__function::__value_func<void ()(AudioObjectPropertyAddress const&)>::~__value_func[abi:ne200100](v9);
  [*(this + 3) setOwner:0];
  v4 = *(this + 6);
  *(this + 5) = 0;
  *(this + 6) = 0;
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  v5 = *(this + 4);
  *(this + 4) = 0;

  v6 = *(this + 6);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v6);
  }

  v7 = *(this + 2);
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }

  v8 = *MEMORY[0x1E69E9840];
}

void sub_1DE724574(_Unwind_Exception *a1, int a2)
{
  if (!a2)
  {
    _Unwind_Resume(a1);
  }

  __clang_call_terminate(a1);
}

void std::__shared_ptr_emplace<DSP_PropertySetWrapper>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F598EC60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t DSP_Dictionariable::SingleKvp<int>::load_from(uint64_t a1, CFDictionaryRef *a2)
{
  v7[0] = &unk_1F598EC08;
  v7[1] = 0;
  v8 = a2;
  if (*(a1 + 20) == 1)
  {
    *(a1 + 20) = 0;
  }

  if (applesauce::CF::details::has_key<__CFString const*&>(*a2, *(a1 + 8)))
  {
    v3 = applesauce::CF::details::at_key<__CFString const*&>(*v8, *(a1 + 8));
    if (!v3)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not find item");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    *(a1 + 16) = applesauce::CF::convert_to<int,0>(v3);
    v4 = 1;
    *(a1 + 20) = 1;
  }

  else
  {
    v4 = 0;
  }

  DSP_Dictionariable::TooledDictionary::~TooledDictionary(v7);
  return v4;
}

uint64_t DSP_Dictionariable::SingleKvp<int>::clear_value(uint64_t result)
{
  if (*(result + 20) == 1)
  {
    *(result + 20) = 0;
  }

  return result;
}

void DSP_Dictionariable::SingleKvp<int>::add_to(uint64_t a1, __CFDictionary **a2)
{
  if (*(a1 + 20) == 1)
  {
    v3 = *(a1 + 8);
    valuePtr = *(a1 + 16);
    v4 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    if (!v4)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    v5 = v4;
    mcp_applesauce::CF::Dictionary_Builder::add_value<__CFString const*,applesauce::CF::NumberRef>(*a2, v3, v4);
    CFRelease(v5);
  }
}

void DSP_Dictionariable::SingleKvp<int>::~SingleKvp(DSP_Dictionariable::DictionariableKvp *a1)
{
  DSP_Dictionariable::DictionariableKvp::~DictionariableKvp(a1);

  JUMPOUT(0x1E12C1730);
}

BOOL DSP_Host::loadBypass(DSP_Host *this)
{
  if (*(this + 2))
  {
    return 0;
  }

  v3 = objc_alloc_init(DSP_HAL_Bypass);
  v4 = v3;
  if (v3)
  {
    [(DSP_HAL_Bypass *)v3 createFactory];
    if (objc_claimAutoreleasedReturnValue())
    {
      operator new();
    }
  }

  DSP_Host::initProperties(this);
  v1 = *(this + 6) == 2;

  return v1;
}

void DSP_Host::initProperties(DSP_Host *this)
{
  v14 = *MEMORY[0x1E69E9840];
  v1 = *(this + 2);
  if (v1)
  {
    v2 = *(v1 + 8);
    if (v2)
    {
      v3 = v2;
      v4 = objc_opt_respondsToSelector();
      if (v4)
      {
        [v3 getFactoryPropertySet];
        objc_claimAutoreleasedReturnValue();
        operator new();
      }

      v5 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v5 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(v4);
      }

      v6 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v7 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        v8 = *v6;
        AMCP::Log::Scope::get_os_log_t(*v6);
        objc_claimAutoreleasedReturnValue();
        std::__shared_weak_count::__release_shared[abi:ne200100](v7);
      }

      else
      {
        v8 = *v6;
        AMCP::Log::Scope::get_os_log_t(*v6);
        objc_claimAutoreleasedReturnValue();
      }

      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v10 = 136315394;
        v11 = "DSP_Host.mm";
        v12 = 1024;
        v13 = 528;
        _os_log_error_impl(&dword_1DE1F9000, v8, OS_LOG_TYPE_ERROR, "%32s:%-5d [hal_dsp] Unable to acquire factory properties interface from the Hosted DSP libary", &v10, 0x12u);
      }
    }
  }

  v9 = *MEMORY[0x1E69E9840];
}

AMCP::Log::AMCP_Scope_Registry *DSP_Host::DSP_Host(DSP_Factory_Bridge *,DSP_Host::DefaultConstruction)::LoadTypeLogging::~LoadTypeLogging(AMCP::Log::AMCP_Scope_Registry *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v2 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
  if ((v2 & 1) == 0)
  {
    AMCP::Log::AMCP_Scope_Registry::initialize(a1);
  }

  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v4 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    v5 = *v3;
    AMCP::Log::Scope::get_os_log_t(*v3);
    objc_claimAutoreleasedReturnValue();
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  else
  {
    v5 = *v3;
    AMCP::Log::Scope::get_os_log_t(*v3);
    objc_claimAutoreleasedReturnValue();
  }

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = **a1;
    if (v6 > 4)
    {
      v7 = "<UNKNOWN>";
    }

    else
    {
      v7 = off_1E8679420[v6];
    }

    v10 = 136315906;
    v11 = "DSP_Host.mm";
    v12 = 1024;
    v13 = 372;
    v14 = 1024;
    v15 = v6;
    v16 = 2080;
    v17 = v7;
    _os_log_impl(&dword_1DE1F9000, v5, OS_LOG_TYPE_DEFAULT, "%32s:%-5d [hal_dsp] DSP_Host constructed type %u (%s)", &v10, 0x22u);
  }

  v8 = *MEMORY[0x1E69E9840];
  return a1;
}

void sub_1DE724E04(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

void DSP_Host::DSP_Host(DSP_Factory_Bridge *,DSP_Host::DefaultConstruction)::FactoryBridgeWithLibary::~FactoryBridgeWithLibary(uint64_t a1)
{
  DSP_Host::DSP_Host(DSP_Factory_Bridge *,DSP_Host::DefaultConstruction)::FactoryBridgeWithLibary::~FactoryBridgeWithLibary(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t DSP_Host::DSP_Host(DSP_Factory_Bridge *,DSP_Host::DefaultConstruction)::FactoryBridgeWithLibary::~FactoryBridgeWithLibary(uint64_t a1)
{
  *a1 = &unk_1F598EC28;
  v2 = *(a1 + 16);
  *(a1 + 16) = 0;

  return a1;
}

uint64_t DSP_Host::DSP_Host(uint64_t a1, const BOOL *a2)
{
  v2 = a2;
  v33 = *MEMORY[0x1E69E9840];
  *(a1 + 24) = 0;
  v4 = (a1 + 24);
  *(a1 + 48) = 850045863;
  *a1 = 0;
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *(a1 + 32) = 0;
  *(a1 + 40) = 0;
  *(a1 + 56) = 0u;
  *(a1 + 72) = 0u;
  *(a1 + 88) = 0u;
  *(a1 + 104) = 0u;
  *(a1 + 120) = 0;
  v26 = a1 + 24;
  if (TestConfig::gTestOverrideDefaultConstruction_ == 1)
  {
    v2 = TestConfig::gTestOverrideDefaultConstruction_;
    v5 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v5 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(a1);
    }

    v6 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v7 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      v8 = *v6;
      AMCP::Log::Scope::get_os_log_t(*v6);
      objc_claimAutoreleasedReturnValue();
      std::__shared_weak_count::__release_shared[abi:ne200100](v7);
    }

    else
    {
      v8 = *v6;
      AMCP::Log::Scope::get_os_log_t(*v6);
      objc_claimAutoreleasedReturnValue();
    }

    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136315650;
      v28 = "DSP_Host.mm";
      v29 = 1024;
      v30 = 381;
      v31 = 1024;
      v32 = v2;
      _os_log_debug_impl(&dword_1DE1F9000, v8, OS_LOG_TYPE_DEBUG, "%32s:%-5d [hal_dsp] Construction option overridden for TEST with %d", buf, 0x18u);
    }
  }

  if ((AMCP::Feature_Flags::force_mock_dsp_type(0, a2) & 1) == 0 && v2 != 2)
  {
    if (v2 != 1)
    {
LABEL_24:
      if (objc_alloc_init(DSP_ADM))
      {
        operator new();
      }

      v15 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v15 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(0);
      }

      v16 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v17 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        v18 = *v16;
        AMCP::Log::Scope::get_os_log_t(*v16);
        objc_claimAutoreleasedReturnValue();
        std::__shared_weak_count::__release_shared[abi:ne200100](v17);
      }

      else
      {
        v18 = *v16;
        AMCP::Log::Scope::get_os_log_t(*v16);
        objc_claimAutoreleasedReturnValue();
      }

      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *buf = 136315394;
        v28 = "DSP_Host.mm";
        v29 = 1024;
        v30 = 435;
        _os_log_error_impl(&dword_1DE1F9000, v18, OS_LOG_TYPE_ERROR, "%32s:%-5d [hal_dsp] ADM library instance could not be allocated.", buf, 0x12u);
      }

      if (!*(a1 + 16))
      {
        v20 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v20 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(v19);
        }

        v21 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v22 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v22)
        {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          v23 = *v21;
          AMCP::Log::Scope::get_os_log_t(*v21);
          objc_claimAutoreleasedReturnValue();
          std::__shared_weak_count::__release_shared[abi:ne200100](v22);
        }

        else
        {
          v23 = *v21;
          AMCP::Log::Scope::get_os_log_t(*v21);
          objc_claimAutoreleasedReturnValue();
        }

        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *buf = 136315394;
          v28 = "DSP_Host.mm";
          v29 = 1024;
          v30 = 441;
          _os_log_error_impl(&dword_1DE1F9000, v23, OS_LOG_TYPE_ERROR, "%32s:%-5d [hal_dsp] ADM library factory object could not be allocated.", buf, 0x12u);
        }

        DSP_Host::loadBypass(a1);
      }

      DSP_Host::initProperties(a1);
      goto LABEL_43;
    }

LABEL_23:
    if (DSP_Host::loadBypass(a1))
    {
      goto LABEL_43;
    }

    goto LABEL_24;
  }

  if (*(a1 + 16))
  {
    goto LABEL_23;
  }

  v9 = TestConfig::gTestOverrideMockType_;
  v10 = TestConfig::gTestOverrideMockType_;
  v11 = objc_alloc_init(DSP_HAL_Mock);
  v12 = v11;
  if (v11)
  {
    if (v9)
    {
      v13 = v10;
    }

    else
    {
      v13 = 97;
    }

    [(DSP_HAL_Mock *)v11 createFactory:v13];
    if (objc_claimAutoreleasedReturnValue())
    {
      operator new();
    }
  }

  DSP_Host::initProperties(a1);
  v14 = *v4 == 3;

  if (!v14)
  {
    goto LABEL_23;
  }

LABEL_43:
  DSP_Host::DSP_Host(DSP_Factory_Bridge *,DSP_Host::DefaultConstruction)::LoadTypeLogging::~LoadTypeLogging(&v26);
  v24 = *MEMORY[0x1E69E9840];
  return a1;
}

void sub_1DE725470(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  DSP_Host::DSP_Host(DSP_Factory_Bridge *,DSP_Host::DefaultConstruction)::LoadTypeLogging::~LoadTypeLogging(va);
  v7 = v2[15];
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }

  std::mutex::~mutex(v3);
  v8 = v2[5];
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v8);
  }

  v9 = v2[2];
  v2[2] = 0;
  if (v9)
  {
    (*(*v9 + 8))(v9);
  }

  v10 = v2[1];
  if (v10)
  {
    std::__shared_weak_count::__release_weak(v10);
  }

  _Unwind_Resume(a1);
}

void *DSP_Host::createProcessor(void *result, uint64_t *a2)
{
  v6 = *MEMORY[0x1E69E9840];
  v2 = a2[2];
  if (v2 && *(v2 + 8))
  {
    v3 = a2[1];
    if (v3)
    {
      v4 = *a2;
      if (std::__shared_weak_count::lock(v3))
      {
        operator new();
      }
    }

    std::__throw_bad_weak_ptr[abi:ne200100]();
  }

  *result = 0;
  result[1] = 0;
  v5 = *MEMORY[0x1E69E9840];
  return result;
}

void std::__shared_ptr_emplace<DSP_ProcessorWrapper>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F598ED08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

void DSP_Host::getConcurrentQueue(void)::TaskQueue::~TaskQueue(void *a1)
{
  *a1 = &unk_1F598EDA8;
  v1 = a1 + 1;
  std::unique_ptr<caulk::concurrent::messenger>::reset[abi:ne200100](a1 + 1, 0);
  std::unique_ptr<caulk::concurrent::messenger>::reset[abi:ne200100](v1, 0);

  JUMPOUT(0x1E12C1730);
}

void *DSP_Host::getConcurrentQueue(void)::TaskQueue::~TaskQueue(void *a1)
{
  *a1 = &unk_1F598EDA8;
  v2 = a1 + 1;
  std::unique_ptr<caulk::concurrent::messenger>::reset[abi:ne200100](a1 + 1, 0);
  std::unique_ptr<caulk::concurrent::messenger>::reset[abi:ne200100](v2, 0);
  return a1;
}

void std::__shared_ptr_emplace<DSP_Host::getConcurrentQueue(void)::TaskQueue,std::allocator<DSP_Host::getConcurrentQueue(void)::TaskQueue>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F598ED58;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

void AMCP::make_string_for_class_id(AMCP *this@<X0>, uint64_t a2@<X8>)
{
  v2 = this;
  AMCP::get_class_traits(&v23, this);
  v27 = v25;
  v28 = v26;
  v26 = 0;
  v25 = 0uLL;
  if (v23.__r_.__value_.__r.__words[2])
  {
    v24 = v23.__r_.__value_.__r.__words[2];
    operator delete(v23.__r_.__value_.__r.__words[2]);
  }

  v4 = SHIBYTE(v28);
  if ((SHIBYTE(v28) & 0x8000000000000000) == 0)
  {
    if (SHIBYTE(v28) == 7)
    {
      v5 = &v27;
      goto LABEL_8;
    }

LABEL_12:
    *a2 = v27;
    *(a2 + 16) = v28;
    return;
  }

  if (*(&v27 + 1) != 7)
  {
    goto LABEL_12;
  }

  v5 = v27;
LABEL_8:
  v6 = *v5;
  v7 = *(v5 + 3);
  if (v6 != 1852534357 || v7 != 1853321070)
  {
    goto LABEL_12;
  }

  if (v28 >= 0)
  {
    v9 = SHIBYTE(v28);
  }

  else
  {
    v9 = *(&v27 + 1);
  }

  v10 = &v22;
  std::string::basic_string[abi:ne200100](&v22, v9 + 3);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    v10 = v22.__r_.__value_.__r.__words[0];
  }

  if (v9)
  {
    if (v4 >= 0)
    {
      v12 = &v27;
    }

    else
    {
      v12 = v27;
    }

    memmove(v10, v12, v9);
  }

  *(&v10->__r_.__value_.__l.__data_ + v9) = 2566176;
  v11.i32[0] = bswap32(v2);
  v13 = vzip1_s8(v11, v11);
  v14.i64[0] = 0x1F0000001FLL;
  v14.i64[1] = 0x1F0000001FLL;
  v15.i64[0] = 0x5F0000005FLL;
  v15.i64[1] = 0x5F0000005FLL;
  v16 = vbsl_s8(vmovn_s32(vcgtq_u32(v15, vsraq_n_s32(v14, vshlq_n_s32(vmovl_u16(v13), 0x18uLL), 0x18uLL))), v13, 0x2E002E002E002ELL);
  v21 = 4;
  LODWORD(__p) = vuzp1_s8(v16, v16).u32[0];
  BYTE4(__p) = 0;
  v17 = std::string::append(&v22, &__p, 4uLL);
  v18 = *&v17->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *&v23.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  v19 = std::string::append(&v23, "')", 2uLL);
  *a2 = *v19;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
  }

  if (v21 < 0)
  {
    operator delete(__p);
  }

  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v22.__r_.__value_.__l.__data_);
    if (v4 < 0)
    {
LABEL_32:
      operator delete(v27);
    }
  }

  else if (v4 < 0)
  {
    goto LABEL_32;
  }
}

uint64_t AMCP::get_stock_class_traits_list(AMCP *this)
{
  {
    AMCP::get_stock_class_traits_list(void)::s_indesctructible_class_traits_list_ptr = 0;
  }

  if (atomic_load_explicit(&AMCP::get_stock_class_traits_list(void)::once, memory_order_acquire) != -1)
  {
    v4 = &v2;
    v3 = &v4;
    std::__call_once(&AMCP::get_stock_class_traits_list(void)::once, &v3, std::__call_once_proxy[abi:ne200100]<std::tuple<AMCP::get_stock_class_traits_list(void)::$_0 &&>>);
  }

  return AMCP::get_stock_class_traits_list(void)::s_indesctructible_class_traits_list_ptr;
}

void std::__call_once_proxy[abi:ne200100]<std::tuple<AMCP::get_stock_class_traits_list(void)::$_0 &&>>()
{
  v46[10] = *MEMORY[0x1E69E9840];
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(v0, 1634689642, 0, &AMCP::Static_Class_Traits<1634689642u>::k_valid_scopes, &AMCP::Static_Class_Traits<1634957683u>::k_valid_scopes, -1, "Object", 1634689642);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v1, 1634957683, 1634689642, &AMCP::Static_Class_Traits<1634957683u>::k_valid_scopes, &AMCP::Static_Class_Traits<1634757735u>::k_valid_scopes, 0, "System", 1634957683);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v2, 1634757735, 1634689642, &AMCP::Static_Class_Traits<1634757735u>::k_valid_scopes, &AMCP::Static_Class_Traits<1853189228u>::k_valid_scopes, 0, "Driver", 1634757735);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v3, 1853189228, 1634757735, &AMCP::Static_Class_Traits<1853189228u>::k_valid_scopes, &AMCP::Static_Class_Traits<1835299446u>::k_valid_scopes, 0, "Null Driver", 1853189228);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v4, 1835299446, 1634757735, &AMCP::Static_Class_Traits<1835299446u>::k_valid_scopes, &AMCP::Static_Class_Traits<1633841016u>::k_valid_scopes, 0, "Meta Driver", 1835299446);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v5, 1633841016, 1634689642, &AMCP::Static_Class_Traits<1633841016u>::k_valid_scopes, &AMCP::Static_Class_Traits<1633905771u>::k_valid_scopes, 0, "Box", 1633841016);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v6, 1633905771, 1634689642, &AMCP::Static_Class_Traits<1633905771u>::k_valid_scopes, &AMCP::Static_Class_Traits<1633969526u>::k_valid_scopes, 0, "Clock", 1633905771);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v7, 1633969526, 1633905771, &AMCP::Static_Class_Traits<1633969526u>::k_valid_scopes, &AMCP::Static_Class_Traits<1633773415u>::k_valid_scopes, 0, "Device", 1633969526);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v8, 1633773415, 1633969526, &AMCP::Static_Class_Traits<1633773415u>::k_valid_scopes, &AMCP::Static_Class_Traits<1634956402u>::k_valid_scopes, 0, "Meta_Device", 1633773415);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v9, 1634956402, 1634689642, &AMCP::Static_Class_Traits<1634956402u>::k_valid_scopes, &AMCP::Static_Class_Traits<1836282994u>::k_valid_scopes, 0, "Stream", 1634956402);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v10, 1836282994, 1634956402, &AMCP::Static_Class_Traits<1836282994u>::k_valid_scopes, &AMCP::Static_Class_Traits<1633907820u>::k_valid_scopes, 0, "Meta_Stream", 1836282994);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v11, 1633907820, 1634689642, &AMCP::Static_Class_Traits<1633907820u>::k_valid_scopes, &AMCP::Static_Class_Traits<1936483442u>::k_valid_scopes, 0, "Control", 1633907820);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v12, 1936483442, 1633907820, &AMCP::Static_Class_Traits<1936483442u>::k_valid_scopes, &AMCP::Static_Class_Traits<1818588780u>::k_valid_scopes, 0, "Slider Control", 1936483442);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v13, 1818588780, 1633907820, &AMCP::Static_Class_Traits<1818588780u>::k_valid_scopes, &AMCP::Static_Class_Traits<1986817381u>::k_valid_scopes, 0, "Level Control", 1818588780);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v14, 1986817381, 1818588780, &AMCP::Static_Class_Traits<1986817381u>::k_valid_scopes, &AMCP::Static_Class_Traits<1937072758u>::k_valid_scopes, 0, "Volume Control", 1986817381);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v15, 1937072758, 1818588780, &AMCP::Static_Class_Traits<1937072758u>::k_valid_scopes, &AMCP::Static_Class_Traits<1936028007u>::k_valid_scopes, 0, "LFE Volume Control", 1937072758);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v16, 1936028007, 1818588780, &AMCP::Static_Class_Traits<1936028007u>::k_valid_scopes, &AMCP::Static_Class_Traits<1953458028u>::k_valid_scopes, 0, "Sidetone EQ Gain Control", 1936028007);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v17, 1953458028, 1633907820, &AMCP::Static_Class_Traits<1953458028u>::k_valid_scopes, &AMCP::Static_Class_Traits<1836414053u>::k_valid_scopes, 0, "Boolean Control", 1953458028);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v18, 1836414053, 1953458028, &AMCP::Static_Class_Traits<1836414053u>::k_valid_scopes, &AMCP::Static_Class_Traits<1936682095u>::k_valid_scopes, 0, "Mute Control", 1836414053);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v19, 1936682095, 1953458028, &AMCP::Static_Class_Traits<1936682095u>::k_valid_scopes, &AMCP::Static_Class_Traits<1784767339u>::k_valid_scopes, 0, "Solo Control", 1936682095);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v20, 1784767339, 1953458028, &AMCP::Static_Class_Traits<1784767339u>::k_valid_scopes, &AMCP::Static_Class_Traits<1937072749u>::k_valid_scopes, 0, "Jack Control", 1784767339);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v21, 1937072749, 1953458028, &AMCP::Static_Class_Traits<1937072749u>::k_valid_scopes, &AMCP::Static_Class_Traits<1702259059u>::k_valid_scopes, 0, "LFE Mute Control", 1937072749);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v22, 1702259059, 1953458028, &AMCP::Static_Class_Traits<1702259059u>::k_valid_scopes, &AMCP::Static_Class_Traits<1885888878u>::k_valid_scopes, 0, "Reference Stream Enable Control", 1702259059);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v23, 1885888878, 1953458028, &AMCP::Static_Class_Traits<1885888878u>::k_valid_scopes, &AMCP::Static_Class_Traits<1885893481u>::k_valid_scopes, 0, "Phantom Power Control", 1885888878);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v24, 1885893481, 1953458028, &AMCP::Static_Class_Traits<1885893481u>::k_valid_scopes, &AMCP::Static_Class_Traits<1668049264u>::k_valid_scopes, 0, "Phase Invert Control", 1885893481);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v25, 1668049264, 1953458028, &AMCP::Static_Class_Traits<1668049264u>::k_valid_scopes, &AMCP::Static_Class_Traits<1952541794u>::k_valid_scopes, 0, "Clip Light Control", 1668049264);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v26, 1952541794, 1953458028, &AMCP::Static_Class_Traits<1952541794u>::k_valid_scopes, &AMCP::Static_Class_Traits<1819504226u>::k_valid_scopes, 0, "Talk Back Control", 1952541794);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v27, 1819504226, 1953458028, &AMCP::Static_Class_Traits<1819504226u>::k_valid_scopes, &AMCP::Static_Class_Traits<1650602615u>::k_valid_scopes, 0, "Listen Back Control", 1819504226);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v28, 1650602615, 1953458028, &AMCP::Static_Class_Traits<1650602615u>::k_valid_scopes, &AMCP::Static_Class_Traits<1999790690u>::k_valid_scopes, 0, "bb2w Control", 1650602615);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v29, 1999790690, 1953458028, &AMCP::Static_Class_Traits<1999790690u>::k_valid_scopes, &AMCP::Static_Class_Traits<1815241314u>::k_valid_scopes, 0, "w2bb Control", 1999790690);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v30, 1815241314, 1953458028, &AMCP::Static_Class_Traits<1815241314u>::k_valid_scopes, &AMCP::Static_Class_Traits<1718432370u>::k_valid_scopes, 0, "l2bb Control", 1815241314);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v31, 1718432370, 1953458028, &AMCP::Static_Class_Traits<1718432370u>::k_valid_scopes, &AMCP::Static_Class_Traits<1684895092u>::k_valid_scopes, 0, "fm2r Control", 1718432370);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v32, 1684895092, 1953458028, &AMCP::Static_Class_Traits<1684895092u>::k_valid_scopes, &AMCP::Static_Class_Traits<1936483188u>::k_valid_scopes, 0, "dmut Control", 1684895092);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v33, 1936483188, 1633907820, &AMCP::Static_Class_Traits<1936483188u>::k_valid_scopes, &AMCP::Static_Class_Traits<1685287523u>::k_valid_scopes, 0, "Selector Control", 1936483188);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v34, 1685287523, 1936483188, &AMCP::Static_Class_Traits<1685287523u>::k_valid_scopes, &AMCP::Static_Class_Traits<1684370292u>::k_valid_scopes, 0, "Data Source Control", 1685287523);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v35, 1684370292, 1936483188, &AMCP::Static_Class_Traits<1684370292u>::k_valid_scopes, &AMCP::Static_Class_Traits<1668047723u>::k_valid_scopes, 0, "Data Destination Control", 1684370292);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v36, 1668047723, 1936483188, &AMCP::Static_Class_Traits<1668047723u>::k_valid_scopes, &AMCP::Static_Class_Traits<1852601964u>::k_valid_scopes, 0, "Clock Source Control", 1668047723);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v37, 1852601964, 1936483188, &AMCP::Static_Class_Traits<1852601964u>::k_valid_scopes, &AMCP::Static_Class_Traits<1751740518u>::k_valid_scopes, 0, "Line Level Control", 1852601964);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v38, 1751740518, 1936483188, &AMCP::Static_Class_Traits<1751740518u>::k_valid_scopes, &AMCP::Static_Class_Traits<1936744814u>::k_valid_scopes, 0, "High Pass Filter Control", 1751740518);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v39, 1936744814, 1633907820, &AMCP::Static_Class_Traits<1936744814u>::k_valid_scopes, &AMCP::Static_Class_Traits<1651273579u>::k_valid_scopes, 0, "Stereo Pan Control", 1936744814);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v40, 1651273579, 1633907820, &AMCP::Static_Class_Traits<1651273579u>::k_valid_scopes, &AMCP::Static_Class_Traits<1936028002u>::k_valid_scopes, 0, "Block Control", 1651273579);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v41, 1936028002, 1651273579, &AMCP::Static_Class_Traits<1936028002u>::k_valid_scopes, &AMCP::Static_Class_Traits<1634627428u>::k_valid_scopes, 0, "Sidetone EQ Control", 1936028002);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v42, 1634627428, 1634689642, &AMCP::Static_Class_Traits<1634627428u>::k_valid_scopes, &AMCP::Static_Class_Traits<1768907630u>::k_valid_scopes, 0, "Node", 0);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v43, 1768907630, 1634627428, &AMCP::Static_Class_Traits<1768907630u>::k_valid_scopes, &AMCP::Static_Class_Traits<1684371054u>::k_valid_scopes, 0, "IOContext Node", 0);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v44, 1684371054, 1634627428, &AMCP::Static_Class_Traits<1684371054u>::k_valid_scopes, &AMCP::Static_Class_Traits<1919247982u>::k_valid_scopes, 0, "Device Node", 0);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(&v45, 1919247982, 1634627428, &AMCP::Static_Class_Traits<1919247982u>::k_valid_scopes, &AMCP::Static_Class_Traits<1685287022u>::k_valid_scopes, 0, "Reflector Node", 0);
  AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(v46, 1685287022, 1634627428, &AMCP::Static_Class_Traits<1685287022u>::k_valid_scopes, "N4AMCP25Clock_Filter_One_Pole_IIRE", 0, "DSP Node", 0);
  operator new();
}

void sub_1DE72713C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  std::vector<AMCP::Live_Class_Traits>::__destroy_vector::operator()[abi:ne200100](&a10);
  MEMORY[0x1E12C1730](v12, 0x20C40960023A9);
  for (i = 3680; i != -80; i -= 80)
  {
    AMCP::Live_Class_Traits::~Live_Class_Traits((&a12 + i));
  }

  _Unwind_Resume(a1);
}

uint64_t AMCP::Live_Class_Traits::Live_Class_Traits<unsigned int const*>(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, char *a7, int a8)
{
  *a1 = a2;
  *(a1 + 4) = a3;
  *(a1 + 8) = 1;
  *(a1 + 24) = 0;
  *(a1 + 32) = 0;
  *(a1 + 16) = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int const*,unsigned int const*>(a1 + 16, a4, a5, (a5 - a4) >> 2);
  *(a1 + 40) = a6;
  std::string::basic_string[abi:ne200100]<0>((a1 + 48), a7);
  *(a1 + 72) = a8;
  return a1;
}

void ***std::unique_ptr<std::vector<AMCP::Live_Class_Traits>>::reset[abi:ne200100](void ***result, void **a2)
{
  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = v2;
    std::vector<AMCP::Live_Class_Traits>::__destroy_vector::operator()[abi:ne200100](&v3);

    JUMPOUT(0x1E12C1730);
  }

  return result;
}

void AMCP::Live_Class_Traits::~Live_Class_Traits(void **this)
{
  if (*(this + 71) < 0)
  {
    operator delete(this[6]);
  }

  v2 = this[2];
  if (v2)
  {
    this[3] = v2;
    operator delete(v2);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,AMCP::Live_Class_Traits *,false>(unint64_t a1, uint64_t *a2, uint64_t a3, char a4)
{
  v251 = *MEMORY[0x1E69E9840];
LABEL_2:
  v196 = a1;
LABEL_3:
  v7 = v196;
  while (1)
  {
    v8 = a2 - v7;
    v9 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - v7) >> 4);
    v10 = v9 - 2;
    if (v9 <= 2)
    {
      if (v9 < 2)
      {
        goto LABEL_260;
      }

      if (v9 == 2)
      {
        v95 = *(a2 - 20);
        v94 = a2 - 10;
        if (v95 < *v7)
        {
          v96 = *MEMORY[0x1E69E9840];
          v97 = v196;
          goto LABEL_256;
        }

LABEL_260:
        v195 = *MEMORY[0x1E69E9840];
        return;
      }

      goto LABEL_11;
    }

    if (v9 == 3)
    {
      v103 = *(v7 + 20);
      v105 = *(a2 - 20);
      v94 = a2 - 10;
      v104 = v105;
      if (v103 >= *v7)
      {
        if (v104 >= v103)
        {
          goto LABEL_260;
        }

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v7 + 10, v94);
        if (*(v7 + 20) >= *v7)
        {
          goto LABEL_260;
        }

        v178 = *MEMORY[0x1E69E9840];
        v97 = v7;
        v101 = v7 + 10;
      }

      else
      {
        if (v104 >= v103)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v7, v7 + 10);
          if (*v94 >= *(v7 + 20))
          {
            goto LABEL_260;
          }

          v194 = *MEMORY[0x1E69E9840];
          v97 = v7 + 10;
        }

        else
        {
          v106 = *MEMORY[0x1E69E9840];
          v97 = v7;
        }

LABEL_256:
        v101 = v94;
      }

      goto LABEL_257;
    }

    if (v9 == 4)
    {
      break;
    }

    if (v9 == 5)
    {
      std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,AMCP::Live_Class_Traits *,0>(v7, v7 + 10, v7 + 20, v7 + 30);
      v99 = *(a2 - 20);
      v98 = a2 - 10;
      if (v99 >= *(v7 + 60))
      {
        goto LABEL_260;
      }

      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v7 + 30, v98);
      if (*(v7 + 60) >= *(v7 + 40))
      {
        goto LABEL_260;
      }

      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v7 + 20, v7 + 30);
      if (*(v7 + 40) >= *(v7 + 20))
      {
        goto LABEL_260;
      }

      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v7 + 10, v7 + 20);
      if (*(v7 + 20) >= *v7)
      {
        goto LABEL_260;
      }

      v100 = *MEMORY[0x1E69E9840];
      v101 = v7 + 10;
      v97 = v7;
LABEL_257:

      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v97, v101);
      return;
    }

LABEL_11:
    v222 = a2;
    v224 = v7;
    if (v8 <= 1919)
    {
      v107 = v7 + 10;
      v109 = v7 == a2 || v107 == a2;
      if (a4)
      {
        if (!v109)
        {
          v110 = 0;
          v111 = v7;
          do
          {
            v112 = v107;
            v113 = *(v111 + 20);
            if (v113 < *v111)
            {
              v234 = *(v107 + 1);
              v240 = *(v107 + 8);
              v114 = v111[12];
              v212 = *(v111 + 13);
              v111[12] = 0;
              v111[13] = 0;
              v111[14] = 0;
              v115 = *(v111 + 30);
              v218 = *(v111 + 128);
              *v246 = *(v111 + 129);
              *&v246[14] = *(v111 + 143);
              v116 = *(v111 + 151);
              v111[16] = 0;
              v111[17] = 0;
              v111[18] = 0;
              v117 = v110;
              v118 = *(v111 + 38);
              while (1)
              {
                v119 = v117;
                v120 = v7 + v117;
                *(v120 + 80) = *(v7 + v117);
                *(v120 + 88) = *(v7 + v117 + 8);
                v121 = *(v7 + v117 + 96);
                if (v121)
                {
                  *(v120 + 104) = v121;
                  operator delete(v121);
                  *(v120 + 112) = 0;
                }

                *(v120 + 96) = *(v120 + 16);
                *(v120 + 112) = *(v120 + 32);
                *(v120 + 16) = 0;
                *(v120 + 24) = 0;
                *(v120 + 32) = 0;
                *(v120 + 120) = *(v120 + 40);
                if (*(v120 + 151) < 0)
                {
                  operator delete(*(v120 + 128));
                }

                v122 = v7 + v119;
                *(v120 + 128) = *(v122 + 48);
                *(v120 + 144) = *(v122 + 64);
                *(v122 + 71) = 0;
                *(v122 + 48) = 0;
                *(v122 + 152) = *(v122 + 72);
                if (!v119)
                {
                  break;
                }

                v123 = *(v122 - 80);
                v117 = v119 - 80;
                v7 = v224;
                if (v113 >= v123)
                {
                  v122 = v224 + v119;
                  v124 = (v224 + v119);
                  goto LABEL_153;
                }
              }

              v124 = v224;
LABEL_153:
              *v124 = v113;
              *(v124 + 1) = v234;
              *(v124 + 8) = v240;
              v125 = *(v122 + 16);
              if (v125)
              {
                v124[3] = v125;
                operator delete(v125);
                *(v122 + 24) = 0;
                *(v122 + 32) = 0;
              }

              *(v122 + 16) = v114;
              *(v124 + 3) = v212;
              *(v124 + 10) = v115;
              if (*(v124 + 71) < 0)
              {
                operator delete(*(v122 + 48));
              }

              *(v122 + 48) = v218;
              *(v122 + 49) = *v246;
              *(v122 + 63) = *&v246[14];
              *(v122 + 71) = v116;
              *(v124 + 18) = v118;
              a2 = v222;
              v7 = v224;
            }

            v107 = v112 + 10;
            v110 += 80;
            v111 = v112;
          }

          while (v112 + 10 != a2);
        }
      }

      else if (!v109)
      {
        v179 = v7 + 19;
        do
        {
          v180 = v107;
          v181 = *(v7 + 20);
          if (v181 < *v7)
          {
            v237 = *(v107 + 1);
            v242 = *(v107 + 8);
            v226 = *(v7 + 6);
            v182 = v7[14];
            v7[12] = 0;
            v7[13] = 0;
            v7[14] = 0;
            v183 = *(v7 + 30);
            v184 = *(v7 + 128);
            *v249 = *(v7 + 129);
            *&v249[14] = *(v7 + 143);
            v185 = *(v7 + 151);
            v7[16] = 0;
            v7[17] = 0;
            v7[18] = 0;
            v186 = v179;
            v187 = *(v7 + 38);
            do
            {
              v188 = v186;
              *(v186 - 9) = *(v186 - 19);
              *(v186 - 64) = *(v186 - 144);
              v189 = *(v186 - 7);
              if (v189)
              {
                *(v186 - 6) = v189;
                operator delete(v189);
                *(v186 - 5) = 0;
              }

              v190 = v186 - 34;
              *(v186 - 14) = *(v186 - 34);
              *(v186 - 5) = *(v186 - 15);
              v190[1] = 0;
              v190[2] = 0;
              *v190 = 0;
              *(v186 - 8) = *(v186 - 28);
              v191 = (v186 - 6);
              if (*(v188 - 1) < 0)
              {
                operator delete(*v191);
              }

              *v191 = *(v188 - 26);
              *(v188 - 1) = *(v188 - 11);
              *(v188 - 81) = 0;
              *(v188 - 104) = 0;
              v186 = v188 - 20;
              *v188 = *(v188 - 20);
            }

            while (v181 < *(v188 - 58));
            v192 = v188 - 38;
            *(v186 - 18) = v181;
            *(v192 + 8) = v242;
            v192[1] = v237;
            v193 = *(v186 - 7);
            if (v193)
            {
              *(v192 + 3) = v193;
              operator delete(v193);
            }

            *(v186 - 14) = v226;
            *(v186 - 5) = v182;
            *(v186 - 8) = v183;
            if (*(v186 - 1) < 0)
            {
              operator delete(*(v186 - 3));
            }

            *(v186 - 24) = v184;
            *(v192 + 63) = *&v249[14];
            *(v192 + 49) = *v249;
            *(v186 - 1) = v185;
            *v186 = v187;
            a2 = v222;
          }

          v107 = v180 + 10;
          v179 += 20;
          v7 = v180;
        }

        while (v180 + 10 != a2);
      }

      goto LABEL_260;
    }

    if (!a3)
    {
      if (v7 != a2)
      {
        v126 = v10 >> 1;
        v127 = v10 >> 1;
        do
        {
          v128 = v127;
          if (v126 >= v127)
          {
            v129 = (2 * v127) | 1;
            v130 = &v224[10 * v129];
            if (2 * v128 + 2 >= v9)
            {
              v131 = *v130;
            }

            else
            {
              v131 = *v130;
              v132 = *(v130 + 20);
              if (*v130 <= v132)
              {
                v131 = *(v130 + 20);
              }

              if (*v130 < v132)
              {
                v130 += 10;
                v129 = 2 * v128 + 2;
              }
            }

            v133 = &v224[10 * v128];
            v134 = *v133;
            if (v131 >= *v133)
            {
              v241 = *(v133 + 8);
              v235 = v133[1];
              v207 = *(v133 + 1);
              v203 = *(v133 + 4);
              *(v133 + 2) = 0;
              *(v133 + 3) = 0;
              *(v133 + 4) = 0;
              v135 = v133[10];
              v219 = *(v133 + 48);
              *v247 = *(v133 + 49);
              *&v247[14] = *(v133 + 63);
              v213 = *(v133 + 71);
              *(v133 + 6) = 0;
              *(v133 + 7) = 0;
              *(v133 + 8) = 0;
              v198 = v135;
              v200 = v133[18];
              do
              {
                v136 = v130;
                v137 = *v130;
                *(v133 + 8) = *(v136 + 8);
                *v133 = v137;
                v138 = *(v133 + 2);
                if (v138)
                {
                  *(v133 + 3) = v138;
                  operator delete(v138);
                  *(v133 + 2) = 0;
                  *(v133 + 3) = 0;
                  *(v133 + 4) = 0;
                }

                *(v133 + 1) = *(v136 + 1);
                *(v133 + 4) = *(v136 + 4);
                *(v136 + 3) = 0;
                *(v136 + 4) = 0;
                *(v136 + 2) = 0;
                v133[10] = v136[10];
                if (*(v133 + 71) < 0)
                {
                  operator delete(*(v133 + 6));
                }

                v139 = *(v136 + 3);
                *(v133 + 8) = *(v136 + 8);
                *(v133 + 3) = v139;
                *(v136 + 71) = 0;
                *(v136 + 48) = 0;
                v133[18] = v136[18];
                if (v126 < v129)
                {
                  break;
                }

                v130 = &v224[10 * ((2 * v129) | 1)];
                if (2 * v129 + 2 >= v9)
                {
                  v140 = *v130;
                  v129 = (2 * v129) | 1;
                }

                else
                {
                  v140 = *v130;
                  v141 = *(v130 + 20);
                  if (*v130 <= v141)
                  {
                    v140 = *(v130 + 20);
                  }

                  if (*v130 >= v141)
                  {
                    v129 = (2 * v129) | 1;
                  }

                  else
                  {
                    v130 += 10;
                    v129 = 2 * v129 + 2;
                  }
                }

                v133 = v136;
              }

              while (v140 >= v134);
              *v136 = v134;
              v136[1] = v235;
              *(v136 + 8) = v241;
              v142 = *(v136 + 2);
              if (v142)
              {
                *(v136 + 3) = v142;
                operator delete(v142);
              }

              *(v136 + 1) = v207;
              *(v136 + 4) = v203;
              v136[10] = v198;
              if (*(v136 + 71) < 0)
              {
                operator delete(*(v136 + 6));
              }

              *(v136 + 48) = v219;
              *(v136 + 49) = *v247;
              *(v136 + 63) = *&v247[14];
              *(v136 + 71) = v213;
              v136[18] = v200;
            }
          }

          v127 = v128 - 1;
        }

        while (v128);
        v143 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 4);
        v145 = v222;
        v144 = v224;
        do
        {
          if (v143 >= 2)
          {
            v223 = v145;
            v146 = 0;
            v228 = *(v144 + 8);
            v227 = *v144;
            v148 = v144[2];
            v147 = v144[3];
            v204 = v144[4];
            v144[2] = 0;
            v144[3] = 0;
            v144[4] = 0;
            v149 = *(v144 + 10);
            v214 = *(v144 + 48);
            *v236 = *(v144 + 49);
            *&v236[14] = *(v144 + 63);
            v220 = *(v144 + 71);
            v144[6] = 0;
            v144[7] = 0;
            v144[8] = 0;
            v150 = v144;
            v208 = *(v144 + 18);
            do
            {
              v151 = &v150[10 * v146];
              v152 = v151 + 10;
              if (2 * v146 + 2 >= v143)
              {
                v146 = (2 * v146) | 1;
              }

              else
              {
                v154 = *(v151 + 40);
                v153 = v151 + 20;
                if (*(v153 - 20) >= v154)
                {
                  v146 = (2 * v146) | 1;
                }

                else
                {
                  v152 = v153;
                  v146 = 2 * v146 + 2;
                }
              }

              v155 = *v152;
              *(v150 + 8) = *(v152 + 8);
              *v150 = v155;
              v156 = v150[2];
              if (v156)
              {
                v150[3] = v156;
                operator delete(v156);
                v150[2] = 0;
                v150[3] = 0;
                v150[4] = 0;
              }

              *(v150 + 1) = *(v152 + 1);
              v150[4] = v152[4];
              v152[3] = 0;
              v152[4] = 0;
              v152[2] = 0;
              *(v150 + 10) = *(v152 + 10);
              if (*(v150 + 71) < 0)
              {
                operator delete(v150[6]);
              }

              v157 = *(v152 + 3);
              v150[8] = v152[8];
              *(v150 + 3) = v157;
              *(v152 + 71) = 0;
              *(v152 + 48) = 0;
              *(v150 + 18) = *(v152 + 18);
              v150 = v152;
            }

            while (v146 <= ((v143 - 2) >> 1));
            v158 = v145 - 10;
            if (v152 == v145 - 10)
            {
              *(v152 + 8) = v228;
              *v152 = v227;
              v176 = v152[2];
              if (v176)
              {
                v152[3] = v176;
                operator delete(v176);
              }

              v152[2] = v148;
              v152[3] = v147;
              v152[4] = v204;
              *(v152 + 10) = v149;
              if (*(v152 + 71) < 0)
              {
                operator delete(v152[6]);
              }

              *(v152 + 48) = v214;
              *(v152 + 49) = *v236;
              *(v152 + 63) = *&v236[14];
              *(v152 + 71) = v220;
              *(v152 + 18) = v208;
            }

            else
            {
              v159 = *v158;
              *(v152 + 8) = *(v145 - 72);
              *v152 = v159;
              v160 = v152[2];
              if (v160)
              {
                v152[3] = v160;
                operator delete(v160);
                v152[2] = 0;
                v152[3] = 0;
                v152[4] = 0;
              }

              v161 = v145 - 8;
              *(v152 + 1) = *(v145 - 4);
              v152[4] = *(v145 - 6);
              v161[1] = 0;
              v161[2] = 0;
              *v161 = 0;
              *(v152 + 10) = *(v145 - 10);
              if (*(v152 + 71) < 0)
              {
                operator delete(v152[6]);
              }

              v162 = *(v145 - 2);
              v152[8] = *(v145 - 2);
              *(v152 + 3) = v162;
              *(v145 - 9) = 0;
              *(v145 - 32) = 0;
              *(v152 + 18) = *(v145 - 2);
              *(v145 - 72) = v228;
              *v158 = v227;
              v163 = *(v145 - 8);
              if (v163)
              {
                *(v145 - 7) = v163;
                operator delete(v163);
              }

              *(v145 - 8) = v148;
              *(v145 - 7) = v147;
              *(v145 - 6) = v204;
              *(v145 - 10) = v149;
              if (*(v145 - 9) < 0)
              {
                operator delete(*(v145 - 4));
              }

              *(v145 - 32) = v214;
              *(v145 - 17) = *&v236[14];
              *(v145 - 31) = *v236;
              *(v145 - 9) = v220;
              *(v145 - 2) = v208;
              v164 = (v152 + 10) - v224;
              if (v164 >= 81)
              {
                v165 = (-2 - 0x3333333333333333 * (v164 >> 4)) >> 1;
                v166 = &v224[10 * v165];
                v167 = *v152;
                if (*v166 < *v152)
                {
                  v229 = *(v152 + 1);
                  v230 = *(v152 + 8);
                  v209 = *(v152 + 1);
                  v168 = v152[4];
                  v152[3] = 0;
                  v152[4] = 0;
                  v152[2] = 0;
                  v169 = *(v152 + 10);
                  v221 = *(v152 + 48);
                  *v248 = *(v152 + 49);
                  *&v248[14] = *(v152 + 63);
                  v215 = *(v152 + 71);
                  v152[6] = 0;
                  v152[7] = 0;
                  v152[8] = 0;
                  v170 = *(v152 + 18);
                  do
                  {
                    v171 = v166;
                    v172 = *v166;
                    *(v152 + 8) = *(v171 + 8);
                    *v152 = v172;
                    v173 = v152[2];
                    if (v173)
                    {
                      v152[3] = v173;
                      operator delete(v173);
                      v152[2] = 0;
                      v152[3] = 0;
                      v152[4] = 0;
                    }

                    *(v152 + 1) = *(v171 + 1);
                    v152[4] = v171[4];
                    v171[3] = 0;
                    v171[4] = 0;
                    v171[2] = 0;
                    *(v152 + 10) = *(v171 + 10);
                    if (*(v152 + 71) < 0)
                    {
                      operator delete(v152[6]);
                    }

                    v174 = *(v171 + 3);
                    v152[8] = v171[8];
                    *(v152 + 3) = v174;
                    *(v171 + 71) = 0;
                    *(v171 + 48) = 0;
                    *(v152 + 18) = *(v171 + 18);
                    if (!v165)
                    {
                      break;
                    }

                    v165 = (v165 - 1) >> 1;
                    v166 = &v224[10 * v165];
                    v152 = v171;
                  }

                  while (*v166 < v167);
                  *v171 = v167;
                  *(v171 + 1) = v229;
                  *(v171 + 8) = v230;
                  v175 = v171[2];
                  if (v175)
                  {
                    v171[3] = v175;
                    operator delete(v175);
                  }

                  *(v171 + 1) = v209;
                  v171[4] = v168;
                  *(v171 + 10) = v169;
                  if (*(v171 + 71) < 0)
                  {
                    operator delete(v171[6]);
                  }

                  *(v171 + 48) = v221;
                  *(v171 + 49) = *v248;
                  *(v171 + 63) = *&v248[14];
                  *(v171 + 71) = v215;
                  *(v171 + 18) = v170;
                  v145 = v223;
                }
              }
            }

            v144 = v224;
          }

          v145 -= 10;
        }

        while (v143-- > 2);
      }

      goto LABEL_260;
    }

    v11 = v9 >> 1;
    v12 = &v7[10 * (v9 >> 1)];
    v14 = a2 - 10;
    v13 = *(a2 - 20);
    if (v8 >= 0x2801)
    {
      v15 = *v12;
      if (*v12 >= *v7)
      {
        if (v13 >= v15 || (std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v12, a2 - 10), *v12 >= *v7))
        {
LABEL_28:
          v21 = v7;
          v24 = *(v7 + 20);
          v23 = v7 + 10;
          v22 = v24;
          v25 = &v21[10 * v11];
          v28 = *(v25 - 20);
          v27 = v25 - 10;
          v26 = v28;
          v29 = *(a2 - 40);
          if (v28 >= v22)
          {
            if (v29 >= v26 || (std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v27, a2 - 20), *v27 >= *v23))
            {
LABEL_41:
              v32 = &v224[10 * v11];
              v35 = *(v32 + 20);
              v34 = v32 + 10;
              v33 = v35;
              v36 = *(a2 - 60);
              if (v35 >= *(v224 + 40))
              {
                if (v36 >= v33 || (std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v34, a2 - 30), *v34 >= *(v224 + 40)))
                {
LABEL_50:
                  v39 = *v12;
                  v40 = *v34;
                  if (*v12 >= *v27)
                  {
                    if (v40 >= v39)
                    {
                      goto LABEL_59;
                    }

                    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v12, v34);
                    if (*v12 >= *v27)
                    {
                      goto LABEL_59;
                    }

                    v41 = v27;
                    v42 = v12;
                  }

                  else
                  {
                    v41 = v27;
                    if (v40 >= v39)
                    {
                      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v27, v12);
                      if (*v34 >= *v12)
                      {
LABEL_59:
                        v250 = *(v224 + 8);
                        v243 = *v224;
                        v43 = v224[4];
                        v44 = *(v224 + 1);
                        v224[3] = 0;
                        v224[4] = 0;
                        v224[2] = 0;
                        v45 = *(v224 + 10);
                        v46 = v224[6];
                        *&v231 = v224[7];
                        *(&v231 + 7) = *(v224 + 63);
                        v47 = *(v224 + 71);
                        v224[7] = 0;
                        v224[8] = 0;
                        v224[6] = 0;
                        v48 = *(v224 + 18);
                        v49 = *(v12 + 8);
                        *v224 = *v12;
                        *(v224 + 8) = v49;
                        v50 = v12[4];
                        v51 = *(v12 + 10);
                        *(v224 + 1) = *(v12 + 1);
                        v224[4] = v50;
                        v12[2] = 0;
                        v12[3] = 0;
                        v12[4] = 0;
                        *(v224 + 10) = v51;
                        LODWORD(v50) = *(v12 + 18);
                        v52 = *(v12 + 3);
                        v224[8] = v12[8];
                        *(v224 + 3) = v52;
                        *(v12 + 71) = 0;
                        *(v12 + 48) = 0;
                        *(v224 + 18) = v50;
                        *(v12 + 8) = v250;
                        *v12 = v243;
                        *(v12 + 1) = v44;
                        v12[4] = v43;
                        *(v12 + 10) = v45;
                        v12[6] = v46;
                        *(v12 + 63) = *(&v231 + 7);
                        v12[7] = v231;
                        *(v12 + 71) = v47;
                        v7 = v196;
                        *(v12 + 18) = v48;
                        goto LABEL_60;
                      }

                      v41 = v12;
                    }

                    v42 = v34;
                  }

                  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v41, v42);
                  goto LABEL_59;
                }

                v37 = v224 + 20;
                v38 = v34;
              }

              else
              {
                v37 = v224 + 20;
                if (v36 >= v33)
                {
                  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v37, v34);
                  if (*(a2 - 60) >= *v34)
                  {
                    goto LABEL_50;
                  }

                  v37 = v34;
                }

                v38 = a2 - 30;
              }

              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v37, v38);
              goto LABEL_50;
            }

            v30 = v23;
            v31 = v27;
          }

          else
          {
            v30 = v23;
            if (v29 >= v26)
            {
              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v23, v27);
              if (*(a2 - 40) >= *v27)
              {
                goto LABEL_41;
              }

              v30 = v27;
            }

            v31 = a2 - 20;
          }

          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v30, v31);
          goto LABEL_41;
        }

        v16 = v7;
        v17 = v12;
      }

      else
      {
        v16 = v7;
        if (v13 >= v15)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v7, v12);
          if (*v14 >= *v12)
          {
            goto LABEL_28;
          }

          v16 = v12;
        }

        v17 = a2 - 10;
      }

      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v16, v17);
      goto LABEL_28;
    }

    v18 = *v7;
    if (*v7 < *v12)
    {
      v19 = v12;
      if (v13 >= v18)
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v12, v7);
        if (*v14 >= *v7)
        {
          goto LABEL_60;
        }

        v19 = v7;
      }

      v20 = a2 - 10;
      goto LABEL_36;
    }

    if (v13 < v18)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v7, a2 - 10);
      if (*v7 < *v12)
      {
        v19 = v12;
        v20 = v7;
LABEL_36:
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v19, v20);
      }
    }

LABEL_60:
    v53 = a3 - 1;
    v54 = v7;
    v225 = v53;
    if (a4)
    {
      v55 = *v7;
    }

    else
    {
      v55 = *v7;
      if (*(v7 - 20) >= *v7)
      {
        v75 = v7 + 2;
        v217 = *(v7 + 1);
        v233 = *(v7 + 1);
        v239 = *(v7 + 8);
        v76 = v7[4];
        v7[2] = 0;
        v7[3] = 0;
        v7[4] = 0;
        v77 = *(v7 + 10);
        v79 = v7 + 6;
        v78 = *(v7 + 48);
        *&v245[14] = *(v7 + 63);
        *v245 = *(v7 + 49);
        v80 = *(v7 + 71);
        v7[6] = 0;
        v7[7] = 0;
        v7[8] = 0;
        if (v55 >= *v14)
        {
          v82 = (v7 + 10);
          do
          {
            a1 = v82;
            if (v82 >= a2)
            {
              break;
            }

            v82 += 80;
          }

          while (v55 >= *a1);
        }

        else
        {
          a1 = v7;
          do
          {
            v81 = *(a1 + 80);
            a1 += 80;
          }

          while (v55 >= v81);
        }

        v83 = v53;
        v84 = a2;
        if (a1 < a2)
        {
          v84 = a2;
          do
          {
            v85 = *(v84 - 20);
            v84 -= 10;
          }

          while (v55 < v85);
        }

        v211 = v80;
        v206 = v77;
        v202 = *(v75 + 14);
        v86 = v76;
        while (a1 < v84)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a1, v84);
          do
          {
            v87 = *(a1 + 80);
            a1 += 80;
          }

          while (v55 >= v87);
          do
          {
            v88 = *(v84 - 20);
            v84 -= 10;
          }

          while (v55 < v88);
        }

        a3 = v83;
        if ((a1 - 80) != v54)
        {
          v89 = *(a1 - 80);
          *(v54 + 8) = *(a1 - 72);
          *v54 = v89;
          v90 = v54[2];
          if (v90)
          {
            v54[3] = v90;
            operator delete(v90);
            *v75 = 0;
            v75[1] = 0;
            v75[2] = 0;
          }

          v91 = (a1 - 64);
          *(v54 + 1) = *(a1 - 64);
          v54[4] = *(a1 - 48);
          v91[1] = 0;
          v91[2] = 0;
          *v91 = 0;
          *(v54 + 10) = *(a1 - 40);
          if (*(v54 + 71) < 0)
          {
            operator delete(*v79);
          }

          v92 = *(a1 - 32);
          v79[2] = *(a1 - 16);
          *v79 = v92;
          *(a1 - 9) = 0;
          *(a1 - 32) = 0;
          *(v54 + 18) = *(a1 - 8);
        }

        *(a1 - 80) = v55;
        *(a1 - 72) = v239;
        *(a1 - 76) = v233;
        v93 = *(a1 - 64);
        if (v93)
        {
          *(a1 - 56) = v93;
          operator delete(v93);
        }

        *(a1 - 64) = v217;
        *(a1 - 48) = v86;
        *(a1 - 40) = v206;
        if (*(a1 - 9) < 0)
        {
          operator delete(*(a1 - 32));
        }

        a4 = 0;
        *(a1 - 32) = v78;
        *(a1 - 17) = *&v245[14];
        *(a1 - 31) = *v245;
        *(a1 - 9) = v211;
        *(a1 - 8) = v202;
        a2 = v222;
        goto LABEL_2;
      }
    }

    v216 = *(v7 + 1);
    v232 = *(v7 + 1);
    v238 = *(v7 + 8);
    v201 = v7[4];
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = 0;
    v199 = *(v7 + 10);
    v57 = v7;
    v56 = v7 + 2;
    v59 = *(v7 + 48);
    v58 = v7 + 6;
    v210 = v59;
    *&v244[14] = *(v56 + 47);
    *v244 = *(v56 + 33);
    v205 = *(v56 + 55);
    *v58 = 0;
    v56[5] = 0;
    v56[6] = 0;
    v60 = *(v56 + 14);
    do
    {
      v61 = v57;
      v62 = *(v57 + 80);
      v57 += 80;
    }

    while (v62 < v55);
    v63 = v222;
    if (v61 == v54)
    {
      v63 = v222;
      do
      {
        if (v57 >= v63)
        {
          break;
        }

        v65 = *(v63 - 20);
        v63 -= 10;
      }

      while (v65 >= v55);
    }

    else
    {
      do
      {
        v64 = *(v63 - 20);
        v63 -= 10;
      }

      while (v64 >= v55);
    }

    if (v57 >= v63)
    {
      a1 = v57;
    }

    else
    {
      v66 = v63;
      a1 = v57;
      do
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a1, v66);
        do
        {
          v67 = *(a1 + 80);
          a1 += 80;
        }

        while (v67 < v55);
        do
        {
          v68 = *(v66 - 20);
          v66 -= 10;
        }

        while (v68 >= v55);
      }

      while (a1 < v66);
    }

    if ((a1 - 80) != v54)
    {
      v69 = *(a1 - 80);
      *(v54 + 8) = *(a1 - 72);
      *v54 = v69;
      v70 = v54[2];
      if (v70)
      {
        v54[3] = v70;
        operator delete(v70);
        *v56 = 0;
        v56[1] = 0;
        v56[2] = 0;
      }

      v71 = (a1 - 64);
      *(v54 + 1) = *(a1 - 64);
      v54[4] = *(a1 - 48);
      v71[1] = 0;
      v71[2] = 0;
      *v71 = 0;
      *(v54 + 10) = *(a1 - 40);
      if (*(v54 + 71) < 0)
      {
        operator delete(*v58);
      }

      v72 = *(a1 - 32);
      v58[2] = *(a1 - 16);
      *v58 = v72;
      *(a1 - 9) = 0;
      *(a1 - 32) = 0;
      *(v54 + 18) = *(a1 - 8);
    }

    *(a1 - 80) = v55;
    *(a1 - 72) = v238;
    *(a1 - 76) = v232;
    v73 = *(a1 - 64);
    if (v73)
    {
      *(a1 - 56) = v73;
      operator delete(v73);
    }

    *(a1 - 64) = v216;
    *(a1 - 48) = v201;
    *(a1 - 40) = v199;
    a2 = v222;
    v7 = v54;
    if (*(a1 - 9) < 0)
    {
      operator delete(*(a1 - 32));
    }

    *(a1 - 32) = v210;
    *(a1 - 17) = *&v244[14];
    *(a1 - 31) = *v244;
    *(a1 - 9) = v205;
    *(a1 - 8) = v60;
    a3 = v225;
    if (v57 < v63)
    {
      goto LABEL_94;
    }

    v74 = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,AMCP::Live_Class_Traits *>(v54, (a1 - 80));
    if (!std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,AMCP::Live_Class_Traits *>(a1, v222))
    {
      v196 = a1;
      if (v74)
      {
        goto LABEL_3;
      }

LABEL_94:
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,AMCP::Live_Class_Traits *,false>(v54, a1 - 80, v225, a4 & 1);
      a4 = 0;
      goto LABEL_2;
    }

    a2 = (a1 - 80);
    if (v74)
    {
      goto LABEL_260;
    }
  }

  v102 = *MEMORY[0x1E69E9840];

  std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,AMCP::Live_Class_Traits *,0>(v7, v7 + 10, v7 + 20, a2 - 10);
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(uint64_t *a1, uint64_t *a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v15 = *a1;
  v16 = *(a1 + 8);
  v14 = *(a1 + 1);
  v4 = a1[4];
  a1[3] = 0;
  a1[4] = 0;
  a1[2] = 0;
  v6 = a1 + 6;
  v5 = a1[6];
  v7 = *(a1 + 10);
  *v17 = a1[7];
  *&v17[7] = *(a1 + 63);
  v8 = *(a1 + 71);
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  v9 = *(a1 + 18);
  v10 = *a2;
  *(a1 + 8) = *(a2 + 8);
  *a1 = v10;
  LODWORD(v10) = *(a2 + 10);
  *(a1 + 1) = *(a2 + 1);
  a1[4] = a2[4];
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  *(a1 + 10) = v10;
  if (*(a1 + 71) < 0)
  {
    operator delete(*v6);
  }

  v11 = *(a2 + 3);
  v6[2] = a2[8];
  *v6 = v11;
  *(a2 + 71) = 0;
  *(a2 + 48) = 0;
  *(a1 + 18) = *(a2 + 18);
  *a2 = v15;
  *(a2 + 8) = v16;
  v12 = a2[2];
  if (v12)
  {
    a2[3] = v12;
    operator delete(v12);
  }

  *(a2 + 1) = v14;
  a2[4] = v4;
  *(a2 + 10) = v7;
  if (*(a2 + 71) < 0)
  {
    operator delete(a2[6]);
  }

  a2[6] = v5;
  a2[7] = *v17;
  *(a2 + 63) = *&v17[7];
  *(a2 + 71) = v8;
  *(a2 + 18) = v9;
  v13 = *MEMORY[0x1E69E9840];
}

void std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,AMCP::Live_Class_Traits *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  v7 = a1;
  v8 = *a2;
  v9 = *a3;
  if (*a2 >= *a1)
  {
    if (v9 < v8)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a2, a3);
      if (*a2 < *v7)
      {
        a1 = v7;
        v10 = a2;
        goto LABEL_9;
      }
    }
  }

  else
  {
    if (v9 < v8)
    {
LABEL_5:
      v10 = a3;
LABEL_9:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a1, v10);
      goto LABEL_10;
    }

    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a1, a2);
    if (*a3 < *a2)
    {
      a1 = a2;
      goto LABEL_5;
    }
  }

LABEL_10:
  if (*a4 < *a3)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a3, a4);
    if (*a3 < *a2)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a2, a3);
      if (*a2 < *v7)
      {

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v7, a2);
      }
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,AMCP::Live_Class_Traits *>(uint64_t *a1, uint64_t *a2)
{
  v3 = a1;
  v41 = *MEMORY[0x1E69E9840];
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 4);
  if (v4 > 2)
  {
    switch(v4)
    {
      case 3:
        v9 = *(a1 + 20);
        v5 = a2 - 10;
        v10 = *(a2 - 20);
        if (v9 >= *a1)
        {
          if (v10 >= v9)
          {
            goto LABEL_52;
          }

          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a1 + 10, v5);
          if (*(v3 + 20) >= *v3)
          {
            goto LABEL_52;
          }

          a1 = v3;
          v8 = v3 + 10;
          goto LABEL_17;
        }

        if (v10 >= v9)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a1, a1 + 10);
          if (*v5 >= *(v3 + 20))
          {
            goto LABEL_52;
          }

          a1 = v3 + 10;
        }

LABEL_16:
        v8 = v5;
LABEL_17:
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a1, v8);
        goto LABEL_52;
      case 4:
        std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,AMCP::Live_Class_Traits *,0>(a1, a1 + 10, a1 + 20, a2 - 10);
        goto LABEL_52;
      case 5:
        std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,AMCP::Live_Class_Traits *,0>(a1, a1 + 10, a1 + 20, a1 + 30);
        v7 = *(a2 - 20);
        v6 = a2 - 10;
        if (v7 >= *(v3 + 60))
        {
          goto LABEL_52;
        }

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v3 + 30, v6);
        if (*(v3 + 60) >= *(v3 + 40))
        {
          goto LABEL_52;
        }

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v3 + 20, v3 + 30);
        if (*(v3 + 40) >= *(v3 + 20))
        {
          goto LABEL_52;
        }

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(v3 + 10, v3 + 20);
        if (*(v3 + 20) >= *v3)
        {
          goto LABEL_52;
        }

        v8 = v3 + 10;
        a1 = v3;
        goto LABEL_17;
    }
  }

  else
  {
    if (v4 < 2)
    {
LABEL_52:
      result = 1;
      goto LABEL_53;
    }

    if (v4 == 2)
    {
      v5 = a2 - 10;
      if (*(a2 - 20) >= *a1)
      {
        goto LABEL_52;
      }

      goto LABEL_16;
    }
  }

  v12 = a1 + 20;
  v11 = *(a1 + 40);
  v13 = *(a1 + 20);
  if (v13 < *a1)
  {
    if (v11 >= v13)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a1, a1 + 10);
      if (*(v3 + 40) >= *(v3 + 20))
      {
        goto LABEL_31;
      }

      a1 = v3 + 10;
    }

    v14 = v3 + 20;
    goto LABEL_30;
  }

  if (v11 < v13)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a1 + 10, a1 + 20);
    if (*(v3 + 20) < *v3)
    {
      a1 = v3;
      v14 = v3 + 10;
LABEL_30:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne200100]<AMCP::Live_Class_Traits *&,AMCP::Live_Class_Traits *&>(a1, v14);
    }
  }

LABEL_31:
  v15 = v3 + 30;
  if (v3 + 30 == a2)
  {
    goto LABEL_52;
  }

  v16 = 0;
  v17 = 0;
  while (1)
  {
    v18 = *v15;
    if (*v15 < *v12)
    {
      v19 = *(v15 + 1);
      v39 = *(v15 + 8);
      v35 = *(v15 + 1);
      v34 = v15[4];
      v15[2] = 0;
      v15[3] = 0;
      v15[4] = 0;
      v33 = *(v15 + 10);
      v37 = *(v15 + 48);
      v38 = v19;
      *v40 = *(v15 + 49);
      *&v40[14] = *(v15 + 63);
      v36 = *(v15 + 71);
      v15[7] = 0;
      v15[8] = 0;
      v15[6] = 0;
      v20 = v16;
      v21 = *(v15 + 18);
      while (1)
      {
        v22 = v20;
        v23 = v3 + v20;
        *(v23 + 30) = *(v3 + v20 + 160);
        v23[248] = *(v3 + v20 + 168);
        v24 = *(v3 + v20 + 256);
        if (v24)
        {
          *(v23 + 33) = v24;
          operator delete(v24);
          *(v23 + 34) = 0;
        }

        *(v23 + 16) = *(v23 + 11);
        *(v23 + 34) = *(v23 + 24);
        *(v23 + 22) = 0;
        *(v23 + 23) = 0;
        *(v23 + 24) = 0;
        *(v23 + 70) = *(v23 + 50);
        if (v23[311] < 0)
        {
          operator delete(*(v23 + 36));
        }

        v25 = v3 + v22;
        *(v23 + 18) = *(v3 + v22 + 208);
        *(v23 + 38) = *(v3 + v22 + 224);
        v25[231] = 0;
        v25[208] = 0;
        *(v25 + 78) = *(v3 + v22 + 232);
        if (v22 == -160)
        {
          break;
        }

        v26 = *(v25 + 20);
        v20 = v22 - 80;
        if (v18 >= v26)
        {
          v27 = v3 + v20 + 240;
          v28 = (v3 + v22 + 176);
          v29 = (v3 + v22 + 208);
          goto LABEL_43;
        }
      }

      v28 = (v25 + 176);
      v29 = (v25 + 208);
      v27 = v3;
LABEL_43:
      *v27 = v18;
      *(v27 + 4) = v38;
      *(v27 + 8) = v39;
      v30 = *v28;
      if (*v28)
      {
        *(v27 + 24) = v30;
        operator delete(v30);
      }

      *v28 = v35;
      *(v27 + 32) = v34;
      *(v27 + 40) = v33;
      if (*(v27 + 71) < 0)
      {
        operator delete(*v29);
      }

      *v29 = v37;
      *(v27 + 49) = *v40;
      *(v27 + 63) = *&v40[14];
      *(v27 + 71) = v36;
      *(v27 + 72) = v21;
      if (++v17 == 8)
      {
        break;
      }
    }

    v12 = v15;
    v16 += 80;
    v15 += 10;
    if (v15 == a2)
    {
      goto LABEL_52;
    }
  }

  result = v15 + 10 == a2;
LABEL_53:
  v32 = *MEMORY[0x1E69E9840];
  return result;
}

void std::vector<AMCP::Live_Class_Traits>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:ne200100]<AMCP::Live_Class_Traits,0>(v4);
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne200100]<AMCP::Live_Class_Traits,0>(uint64_t a1)
{
  if (*(a1 + 71) < 0)
  {
    operator delete(*(a1 + 48));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    *(a1 + 24) = v2;

    operator delete(v2);
  }
}

double AMCP::Clock_Filter_One_Pole_IIR::apply(AMCP::Clock_Filter_One_Pole_IIR *this, double a2)
{
  v2 = *(this + 6);
  v3 = 0.0;
  if (v2 >= 2)
  {
    v3 = 0.25;
    if (v2 >= 5)
    {
      v3 = 0.5;
      if (v2 >= 9)
      {
        v3 = 0.75;
        if (v2 >= 0x11)
        {
          v3 = dbl_1DE757F30[v2 < 0x81];
        }
      }
    }
  }

  *(this + 6) = v2 + 1;
  result = (1.0 - v3) * a2 + v3 * *(this + 2);
  *(this + 2) = result;
  return result;
}

double AMCP::Clock_Filter_One_Pole_IIR::reset(AMCP::Clock_Filter_One_Pole_IIR *this)
{
  result = *(this + 1);
  *(this + 2) = result;
  return result;
}

void AMCP::ASP::Engine::unregister_io_buffer(uint64_t a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  v46 = *MEMORY[0x1E69E9840];
  v8 = *(a1 + 776);
  v9 = *(a1 + 784);
  if (v8 != v9)
  {
    while (**v8 != a5)
    {
      v8 += 16;
      if (v8 == v9)
      {
        goto LABEL_4;
      }
    }
  }

  if (v8 == v9)
  {
LABEL_4:
    v10 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v10 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(a1);
    }

    v12 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v11 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      v13 = *v12;
      std::__shared_weak_count::__release_shared[abi:ne200100](v11);
    }

    else
    {
      v13 = *v12;
    }

    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      v38 = "ASP_Engine.cpp";
      v39 = 1024;
      v40 = 771;
      v41 = 2080;
      v42 = "register_buffer_info_iter == m_register_buffer_info_list.end()";
      _os_log_error_impl(&dword_1DE1F9000, v13, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s Failed to unregister io buffer", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v36);
    __cxa_allocate_exception(0x40uLL);
    std::runtime_error::runtime_error(&v29, "Failed to unregister io buffer");
    std::runtime_error::runtime_error(&v30, &v29);
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = -1;
    v30.__vftable = &unk_1F5992170;
    v31 = &unk_1F5992198;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::clone_impl(buf, &v30);
    v43 = "virtual void AMCP::ASP::Engine::unregister_io_buffer(AMCP::Direction, uint32_t, uint32_t, void *)";
    v44 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/ASP_Engine.cpp";
    v45 = 771;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(&v28);
  }

  if (atomic_fetch_add((*v8 + 8), 0xFFFFFFFF) != 1)
  {
    goto LABEL_25;
  }

  v14 = *(a1 + 784);
  if (v8 + 16 != v14)
  {
    do
    {
      v15 = *(v8 + 16);
      *(v8 + 16) = 0;
      *(v8 + 24) = 0;
      v16 = *(v8 + 8);
      *v8 = v15;
      if (v16)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v16);
      }

      v17 = v8 + 16;
      v18 = v8 + 32;
      v8 += 16;
    }

    while (v18 != v14);
    v14 = *(a1 + 784);
    v8 = v17;
  }

  while (v14 != v8)
  {
    v19 = *(v14 - 8);
    if (v19)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v19);
    }

    v14 -= 16;
  }

  *(a1 + 784) = v8;
  v20 = 72;
  if (!a2)
  {
    v20 = 96;
  }

  v22 = a1 + v20;
  v21 = *(a1 + v20);
  if (0x6DB6DB6DB6DB6DB7 * ((*(v22 + 8) - v21) >> 3) > a3)
  {
    v23 = *(v21 + 56 * a3 + 4);
    v24 = *(a1 + 752);
    v25 = *(**(a1 + 744) + 456);
    v26 = *MEMORY[0x1E69E9840];

    v25();
  }

  else
  {
LABEL_25:
    v27 = *MEMORY[0x1E69E9840];
  }
}

void sub_1DE7293D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, std::runtime_error a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, char a29)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a9)
  {
    operator delete(a9);
  }

  boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::~clone_impl(&a29);
  boost::exception_detail::error_info_injector<std::runtime_error>::~error_info_injector(&a18);
  std::runtime_error::~runtime_error(&a17);
  if (v30)
  {
    __cxa_free_exception(v29);
  }

  AMCP::Utility::With_Realtime_Disabled::~With_Realtime_Disabled(&a28);
  _Unwind_Resume(a1);
}

uint64_t AMCP::ASP::Engine::register_io_buffer(uint64_t a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  v5 = *(a1 + 776);
  v6 = *(a1 + 784);
  if (v5 != v6)
  {
    while (**v5 != a5)
    {
      v5 += 16;
      if (v5 == v6)
      {
        goto LABEL_8;
      }
    }
  }

  if (v5 == v6)
  {
LABEL_8:
    operator new();
  }

  v8 = *v5;
  v7 = *(v5 + 8);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  if (atomic_fetch_add(v8 + 2, 1u))
  {
    v9 = 0;
    if (!v7)
    {
      return v9;
    }

    goto LABEL_18;
  }

  v10 = 72;
  if (!a2)
  {
    v10 = 96;
  }

  v12 = a1 + v10;
  v11 = *(a1 + v10);
  if (0x6DB6DB6DB6DB6DB7 * ((*(v12 + 8) - v11) >> 3) > a3)
  {
    v9 = (*(**(a1 + 744) + 448))(*(a1 + 744), *(a1 + 752), *(v11 + 56 * a3 + 4), 1, a2 == 1, a4, a5);
    if (!v7)
    {
      return v9;
    }

    goto LABEL_18;
  }

  v9 = 561214578;
  if (v7)
  {
LABEL_18:
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }

  return v9;
}

void std::__shared_ptr_emplace<AMCP::ASP::Engine::Register_Buffer_Info>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F598F4A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

double AMCP::ASP::Engine::convert_host_to_sample_time(os_unfair_lock_s *this, unint64_t a2)
{
  os_unfair_lock_lock(this + 164);
  v4 = AMCP::IO_Clock::convert_host_to_sample_time_internal(&this[144], a2);
  os_unfair_lock_unlock(this + 164);
  return v4;
}

double AMCP::ASP::Engine::get_current_host_ticks_per_frame(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this + 164);
  v2 = *&this[160]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(this + 164);
  return v2;
}

double AMCP::ASP::Engine::get_zero_time_stamp@<D0>(AMCP::ASP::Engine *this@<X0>, uint64_t a2@<X8>)
{
  *(a2 + 48) = 0;
  *(a2 + 16) = 0u;
  *(a2 + 32) = 0u;
  *(a2 + 56) = 3;
  (*(**(this + 93) + 96))(&v4, *(this + 93), *(this + 188), 1);
  result = v5;
  *a2 = v5;
  *(a2 + 8) = v6;
  return result;
}

uint64_t AMCP::ASP::Engine::end_writing(os_unfair_lock_s *this, uint64_t a2, unint64_t a3, double a4, uint64_t a5, int a6)
{
  if (HIBYTE(this[192]._os_unfair_lock_opaque) == 1)
  {
    v49 = v11;
    v50 = v10;
    v51 = v9;
    v52 = v8;
    v53 = v6;
    v54 = v7;
    os_unfair_lock_lock(this + 164);
    v18 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    v29 = a2;
    v30 = a6;
    v37 = 0u;
    v38 = 0u;
    v39 = 0u;
    v40 = 0u;
    v47 = v18;
    v48 = v18;
    os_unfair_lock_lock(this + 164);
    v19 = AMCP::IO_Clock::convert_host_to_sample_time_internal(&this[144], a3);
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v20 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v21 = *(*&this[148]._os_unfair_lock_opaque + 40);
    os_unfair_lock_unlock(this + 164);
    v35 = 0u;
    v34 = 0u;
    v31 = v19;
    v32 = a3;
    v33 = v20 / v21;
    v36 = 7;
    v22 = AMCP::IO_Clock::convert_sample_to_host_time(this + 144, a4);
    os_unfair_lock_lock(this + 164);
    v23 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v24 = *(*&this[148]._os_unfair_lock_opaque + 40);
    os_unfair_lock_unlock(this + 164);
    v45 = 0u;
    v44 = 0u;
    v41 = a4;
    v42 = v22;
    v43 = v23 / v24;
    v46 = 7;
    (*(**&this[186]._os_unfair_lock_opaque + 400))(*&this[186]._os_unfair_lock_opaque, this[188]._os_unfair_lock_opaque, 1, a5, &v29, v25, v26, v27);
  }

  return 1;
}

uint64_t AMCP::ASP::Engine::write_data_to_stream(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(a1 + 771) != 1)
  {
    return 1;
  }

  v10 = *(a1 + 96);
  if (0x6DB6DB6DB6DB6DB7 * ((*(a1 + 104) - v10) >> 3) > a4)
  {
    os_unfair_lock_lock((a1 + 656));
    v16 = *(a1 + 640);
    os_unfair_lock_unlock((a1 + 656));
    v26 = a2;
    v27 = a7;
    v34 = 0u;
    v35 = 0u;
    v36 = 0u;
    v37 = 0u;
    v44 = v16;
    v45 = v16;
    os_unfair_lock_lock((a1 + 656));
    v17 = AMCP::IO_Clock::convert_host_to_sample_time_internal((a1 + 576), a3);
    os_unfair_lock_unlock((a1 + 656));
    os_unfair_lock_lock((a1 + 656));
    v18 = *(a1 + 640);
    os_unfair_lock_unlock((a1 + 656));
    os_unfair_lock_lock((a1 + 656));
    v19 = *(*(a1 + 592) + 40);
    os_unfair_lock_unlock((a1 + 656));
    v32 = 0u;
    v31 = 0u;
    v28 = v17;
    v29 = a3;
    v30 = v18 / v19;
    v33 = 7;
    v20 = AMCP::IO_Clock::convert_sample_to_host_time((a1 + 576), a5);
    os_unfair_lock_lock((a1 + 656));
    v21 = *(a1 + 640);
    os_unfair_lock_unlock((a1 + 656));
    os_unfair_lock_lock((a1 + 656));
    v22 = *(*(a1 + 592) + 40);
    os_unfair_lock_unlock((a1 + 656));
    v42 = 0u;
    v41 = 0u;
    v38 = a5;
    v39 = v20;
    v40 = v21 / v22;
    v43 = 7;
    v23 = AMCP::Core::Engine::calculate_safety_violation_write(a1, a5);
    if (v23 < 0.0)
    {
      kdebug_trace();
    }

    kdebug_trace();
    (*(**(a1 + 744) + 392))(*(a1 + 744), *(a1 + 752), *(v10 + 56 * a4 + 4), 1, a7, &v26, a8);
    kdebug_trace();
    v24 = AMCP::Core::Engine::calculate_safety_violation_write(a1, a5);
    if (v24 < 0)
    {
      kdebug_trace();
    }

    return 1;
  }

  return 0;
}

uint64_t AMCP::ASP::Engine::begin_writing(os_unfair_lock_s *this, uint64_t a2, unint64_t a3, double a4, uint64_t a5, int a6)
{
  if (HIBYTE(this[192]._os_unfair_lock_opaque) == 1)
  {
    v49 = v11;
    v50 = v10;
    v51 = v9;
    v52 = v8;
    v53 = v6;
    v54 = v7;
    os_unfair_lock_lock(this + 164);
    v18 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    v29 = a2;
    v30 = a6;
    v37 = 0u;
    v38 = 0u;
    v39 = 0u;
    v40 = 0u;
    v47 = v18;
    v48 = v18;
    os_unfair_lock_lock(this + 164);
    v19 = AMCP::IO_Clock::convert_host_to_sample_time_internal(&this[144], a3);
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v20 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v21 = *(*&this[148]._os_unfair_lock_opaque + 40);
    os_unfair_lock_unlock(this + 164);
    v35 = 0u;
    v34 = 0u;
    v31 = v19;
    v32 = a3;
    v33 = v20 / v21;
    v36 = 7;
    v22 = AMCP::IO_Clock::convert_sample_to_host_time(this + 144, a4);
    os_unfair_lock_lock(this + 164);
    v23 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v24 = *(*&this[148]._os_unfair_lock_opaque + 40);
    os_unfair_lock_unlock(this + 164);
    v45 = 0u;
    v44 = 0u;
    v41 = a4;
    v42 = v22;
    v43 = v23 / v24;
    v46 = 7;
    (*(**&this[186]._os_unfair_lock_opaque + 384))(*&this[186]._os_unfair_lock_opaque, this[188]._os_unfair_lock_opaque, 1, a5, &v29, v25, v26, v27);
  }

  return 1;
}

uint64_t AMCP::ASP::Engine::end_reading(os_unfair_lock_s *this, uint64_t a2, unint64_t a3, double a4, uint64_t a5, int a6)
{
  if (HIBYTE(this[189]._os_unfair_lock_opaque) == 1)
  {
    v46 = v11;
    v47 = v10;
    v48 = v9;
    v49 = v8;
    v50 = v6;
    v51 = v7;
    os_unfair_lock_lock(this + 164);
    v18 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    v26 = a2;
    v27 = a6;
    v40 = 0u;
    v41 = 0u;
    v42 = 0u;
    v43 = 0u;
    v44 = v18;
    v45 = v18;
    os_unfair_lock_lock(this + 164);
    v19 = AMCP::IO_Clock::convert_host_to_sample_time_internal(&this[144], a3);
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v20 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v21 = *(*&this[148]._os_unfair_lock_opaque + 40);
    os_unfair_lock_unlock(this + 164);
    v32 = 0u;
    v31 = 0u;
    v28 = v19;
    v29 = a3;
    v30 = v20 / v21;
    v33 = 7;
    v22 = AMCP::IO_Clock::convert_sample_to_host_time(this + 144, a4);
    os_unfair_lock_lock(this + 164);
    v23 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v24 = *(*&this[148]._os_unfair_lock_opaque + 40);
    os_unfair_lock_unlock(this + 164);
    v38 = 0u;
    v37 = 0u;
    v34 = a4;
    v35 = v22;
    v36 = v23 / v24;
    v39 = 7;
    (*(**&this[186]._os_unfair_lock_opaque + 176))(*&this[186]._os_unfair_lock_opaque, this[188]._os_unfair_lock_opaque, 1, a5, &v26);
  }

  return 1;
}

uint64_t AMCP::ASP::Engine::read_data_from_stream(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int a4, unsigned int a5, int a6, unsigned int **a7, double a8)
{
  if (*(a1 + 759) != 1)
  {
    return 1;
  }

  v9 = *(a1 + 72);
  if (0x6DB6DB6DB6DB6DB7 * ((*(a1 + 80) - v9) >> 3) > a4)
  {
    v15 = v9 + 56 * a4;
    v16 = *(v15 + 40);
    v17 = (a5 / v16) + a8;
    v18 = **a7;
    os_unfair_lock_lock((a1 + 656));
    v19 = *(a1 + 640);
    os_unfair_lock_unlock((a1 + 656));
    v29 = a2;
    v30 = a6;
    v43 = 0u;
    v44 = 0u;
    v45 = 0u;
    v46 = 0u;
    v47 = v19;
    v48 = v19;
    os_unfair_lock_lock((a1 + 656));
    v20 = AMCP::IO_Clock::convert_host_to_sample_time_internal((a1 + 576), a3);
    os_unfair_lock_unlock((a1 + 656));
    os_unfair_lock_lock((a1 + 656));
    v21 = *(a1 + 640);
    os_unfair_lock_unlock((a1 + 656));
    os_unfair_lock_lock((a1 + 656));
    v22 = *(*(a1 + 592) + 40);
    os_unfair_lock_unlock((a1 + 656));
    v35 = 0u;
    v34 = 0u;
    v31 = v20;
    v32 = a3;
    v33 = v21 / v22;
    v36 = 7;
    v23 = AMCP::IO_Clock::convert_sample_to_host_time((a1 + 576), v17);
    os_unfair_lock_lock((a1 + 656));
    v24 = *(a1 + 640);
    os_unfair_lock_unlock((a1 + 656));
    os_unfair_lock_lock((a1 + 656));
    v25 = *(*(a1 + 592) + 40);
    os_unfair_lock_unlock((a1 + 656));
    v41 = 0u;
    v40 = 0u;
    v37 = v17;
    v38 = v23;
    v39 = v24 / v25;
    v42 = 7;
    v26 = AMCP::Core::Engine::calculate_safety_violation_read(a1, a8);
    if (v26 <= -5.0)
    {
      kdebug_trace();
    }

    kdebug_trace();
    (*(**(a1 + 744) + 168))(*(a1 + 744), *(a1 + 752), *(v15 + 4), 1, v18 / v16, &v29, a7);
    kdebug_trace();
    v27 = AMCP::Core::Engine::calculate_safety_violation_read(a1, a8);
    if (v27 <= -5)
    {
      kdebug_trace();
    }

    return 1;
  }

  return 0;
}

uint64_t AMCP::ASP::Engine::begin_reading(os_unfair_lock_s *this, uint64_t a2, unint64_t a3, double a4, uint64_t a5, int a6)
{
  if (HIBYTE(this[189]._os_unfair_lock_opaque) == 1)
  {
    v46 = v11;
    v47 = v10;
    v48 = v9;
    v49 = v8;
    v50 = v6;
    v51 = v7;
    os_unfair_lock_lock(this + 164);
    v18 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    v26 = a2;
    v27 = a6;
    v40 = 0u;
    v41 = 0u;
    v42 = 0u;
    v43 = 0u;
    v44 = v18;
    v45 = v18;
    os_unfair_lock_lock(this + 164);
    v19 = AMCP::IO_Clock::convert_host_to_sample_time_internal(&this[144], a3);
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v20 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v21 = *(*&this[148]._os_unfair_lock_opaque + 40);
    os_unfair_lock_unlock(this + 164);
    v32 = 0u;
    v31 = 0u;
    v28 = v19;
    v29 = a3;
    v30 = v20 / v21;
    v33 = 7;
    v22 = AMCP::IO_Clock::convert_sample_to_host_time(this + 144, a4);
    os_unfair_lock_lock(this + 164);
    v23 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v24 = *(*&this[148]._os_unfair_lock_opaque + 40);
    os_unfair_lock_unlock(this + 164);
    v38 = 0u;
    v37 = 0u;
    v34 = a4;
    v35 = v22;
    v36 = v23 / v24;
    v39 = 7;
    (*(**&this[186]._os_unfair_lock_opaque + 160))(*&this[186]._os_unfair_lock_opaque, this[188]._os_unfair_lock_opaque, 1, a5, &v26);
  }

  return 1;
}

uint64_t AMCP::ASP::Engine::end_io_cycle(os_unfair_lock_s *this, uint64_t a2, unint64_t a3, int a4)
{
  if (BYTE2(this[189]._os_unfair_lock_opaque) == 1)
  {
    v37 = v9;
    v38 = v8;
    v39 = v7;
    v40 = v6;
    v41 = v4;
    v42 = v5;
    os_unfair_lock_lock(this + 164);
    v14 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    v19 = a2;
    v20 = a4;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    v34 = 0u;
    v35 = v14;
    v36 = v14;
    os_unfair_lock_lock(this + 164);
    v15 = AMCP::IO_Clock::convert_host_to_sample_time_internal(&this[144], a3);
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v16 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v17 = *(*&this[148]._os_unfair_lock_opaque + 40);
    os_unfair_lock_unlock(this + 164);
    v25 = 0u;
    v24 = 0u;
    v21 = v15;
    v22 = a3;
    v23 = v16 / v17;
    v26 = 7;
    (*(**&this[186]._os_unfair_lock_opaque + 144))(*&this[186]._os_unfair_lock_opaque, this[188]._os_unfair_lock_opaque, 1, &v19);
  }

  return 1;
}

uint64_t AMCP::ASP::Engine::begin_io_cycle(os_unfair_lock_s *this, uint64_t a2, unint64_t a3, int a4)
{
  if (BYTE2(this[189]._os_unfair_lock_opaque) == 1)
  {
    v37 = v9;
    v38 = v8;
    v39 = v7;
    v40 = v6;
    v41 = v4;
    v42 = v5;
    os_unfair_lock_lock(this + 164);
    v14 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    v19 = a2;
    v20 = a4;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    v34 = 0u;
    v35 = v14;
    v36 = v14;
    os_unfair_lock_lock(this + 164);
    v15 = AMCP::IO_Clock::convert_host_to_sample_time_internal(&this[144], a3);
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v16 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    os_unfair_lock_lock(this + 164);
    v17 = *(*&this[148]._os_unfair_lock_opaque + 40);
    os_unfair_lock_unlock(this + 164);
    v25 = 0u;
    v24 = 0u;
    v21 = v15;
    v22 = a3;
    v23 = v16 / v17;
    v26 = 7;
    (*(**&this[186]._os_unfair_lock_opaque + 136))(*&this[186]._os_unfair_lock_opaque, this[188]._os_unfair_lock_opaque, 1, &v19);
  }

  return 1;
}

uint64_t AMCP::ASP::Engine::end_io_thread(os_unfair_lock_s *this, uint64_t a2, int a3)
{
  if (BYTE1(this[189]._os_unfair_lock_opaque) == 1)
  {
    os_unfair_lock_lock(this + 164);
    v6 = *&this[160]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 164);
    v8 = a2;
    v9 = a3;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v22 = v6;
    v23 = v6;
    (*(**&this[186]._os_unfair_lock_opaque + 120))(*&this[186]._os_unfair_lock_opaque, this[188]._os_unfair_lock_opaque, 1, &v8);
  }

  (*(**&this[186]._os_unfair_lock_opaque + 72))(*&this[186]._os_unfair_lock_opaque, this[188]._os_unfair_lock_opaque, 1);
  return 1;
}

uint64_t AMCP::ASP::Engine::begin_io_thread(AMCP::ASP::Engine *this, uint64_t a2, uint64_t a3)
{
  (*(*this + 24))(this);
  (*(**(this + 93) + 64))(*(this + 93), *(this + 188), 1, a3, 0);
  if (*(this + 757) == 1)
  {
    os_unfair_lock_lock(this + 164);
    v6 = *(this + 80);
    os_unfair_lock_unlock(this + 164);
    v8 = a2;
    v9 = a3;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v22 = v6;
    v23 = v6;
    (*(**(this + 93) + 112))(*(this + 93), *(this + 188), 1, &v8);
  }

  return 1;
}

uint64_t AMCP::ASP::Engine::maximum_past_data(AMCP::ASP::Engine *this)
{
  if (*(this + 756) != 1)
  {
    return 0;
  }

  v9 = v1;
  v10 = v2;
  v6 = 0x676C6F62646D7064;
  v7 = 0;
  v3 = *(this + 93);
  v4 = *(this + 188);
  v8 = 0;
  if ((*(*v3 + 432))(v3, v4, 0, &v6, 0, 0, 4, &v8))
  {
    return 0;
  }

  else
  {
    return v8;
  }
}

uint64_t AMCP::ASP::Engine::available_past_data(AMCP::ASP::Engine *this)
{
  if (*(this + 756) != 1)
  {
    return 0;
  }

  v9 = v1;
  v10 = v2;
  v6 = 0x676C6F6264617064;
  v7 = 0;
  v3 = *(this + 93);
  v4 = *(this + 188);
  v8 = 0;
  if ((*(*v3 + 432))(v3, v4, 0, &v6, 0, 0, 4, &v8))
  {
    return 0;
  }

  else
  {
    return v8;
  }
}

BOOL AMCP::ASP::Engine::set_past_data_enabled(AMCP::ASP::Engine *this, int a2)
{
  if (*(this + 756) != 1)
  {
    return 0;
  }

  v10 = v2;
  v11 = v3;
  v8 = 0x676C6F626470656CLL;
  v9 = 0;
  v4 = *(this + 93);
  v5 = *(this + 188);
  v7 = a2;
  return (*(*v4 + 440))(v4, v5, 0, &v8, 0, 0, 4, &v7) == 0;
}

BOOL AMCP::ASP::Engine::is_past_data_enabled(AMCP::ASP::Engine *this)
{
  if (*(this + 756) != 1)
  {
    return 0;
  }

  v10 = v1;
  v11 = v2;
  v7 = 0x676C6F626470656CLL;
  v8 = 0;
  v3 = *(this + 93);
  v4 = *(this + 188);
  v9 = 0;
  if ((*(*v3 + 432))(v3, v4, 0, &v7, 0, 0, 4, &v9))
  {
    v5 = 1;
  }

  else
  {
    v5 = v9 == 0;
  }

  return !v5;
}

void AMCP::ASP::Engine::set_output_stream_active_list(uint64_t a1, uint64_t a2)
{
  AMCP::Core::Implementation::Simple_Engine_IO_State::get_output_stream_active_list(v5, (a1 + 120));
  AMCP::Core::Implementation::Simple_Engine_IO_State::set_output_stream_active_list(__p, a1 + 120, a2);
  AMCP::ASP::Engine::update_stream_active_state(a1, (a1 + 96), v5, __p);
  if (__p[0])
  {
    operator delete(__p[0]);
  }

  if (v5[0])
  {
    operator delete(v5[0]);
  }
}

void sub_1DE72AD3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t AMCP::ASP::Engine::update_stream_active_state(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  v6 = result;
  v7 = *a4;
  v9 = *a2;
  v8 = a2[1];
  if (*a2 == v8)
  {
    v12 = 0;
  }

  else
  {
    v11 = 0;
    v12 = 0;
    v13 = *a3;
    do
    {
      if (v13 == (*a3 + 8 * (*(a3 + 8) >> 6)) && v11 == (*(a3 + 8) & 0x3F))
      {
        break;
      }

      if (v7 == (*a4 + 8 * (*(a4 + 8) >> 6)) && v12 == (*(a4 + 8) & 0x3F))
      {
        break;
      }

      if (((*v13 >> v11) & 1) != ((*v7 & (1 << v12)) != 0))
      {
        v16 = *(v9 + 4);
        v22 = (*v7 & (1 << v12)) != 0;
        result = (*(**(v6 + 744) + 440))();
        v8 = a2[1];
      }

      v9 += 56;
      v13 += v11 == 63;
      if (v11 == 63)
      {
        v11 = 0;
      }

      else
      {
        ++v11;
      }

      v7 += v12 == 63;
      if (v12 == 63)
      {
        v12 = 0;
      }

      else
      {
        ++v12;
      }
    }

    while (v9 != v8);
  }

  if (v9 != v8 && (v7 != (*a4 + 8 * (*(a4 + 8) >> 6)) || v12 != (*(a4 + 8) & 0x3F)))
  {
    v18 = v9 + 56;
    do
    {
      v9 = v18;
      v19 = *(v18 - 52);
      v23 = (*v7 >> v12) & 1;
      result = (*(**(v6 + 744) + 440))();
      v8 = a2[1];
      if (v9 == v8)
      {
        break;
      }

      v7 += v12 == 63;
      if (v12 == 63)
      {
        v12 = 0;
      }

      else
      {
        ++v12;
      }

      v18 = v9 + 56;
    }

    while (v7 != (*a4 + 8 * (*(a4 + 8) >> 6)) || v12 != (*(a4 + 8) & 0x3F));
  }

  if (v9 != v8)
  {
    do
    {
      v21 = *(v9 + 4);
      result = (*(**(v6 + 744) + 440))();
      v9 += 56;
    }

    while (v9 != a2[1]);
  }

  return result;
}

void AMCP::ASP::Engine::set_input_stream_active_list(uint64_t a1, uint64_t a2)
{
  AMCP::Core::Implementation::Simple_Engine_IO_State::get_input_stream_active_list(v5, (a1 + 120));
  AMCP::Core::Implementation::Simple_Engine_IO_State::set_input_stream_active_list(__p, a1 + 120, a2);
  AMCP::ASP::Engine::update_stream_active_state(a1, (a1 + 72), v5, __p);
  if (__p[0])
  {
    operator delete(__p[0]);
  }

  if (v5[0])
  {
    operator delete(v5[0]);
  }
}

void sub_1DE72B0BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t AMCP::ASP::Engine::set_transport_state(uint64_t a1, signed int a2)
{
  v46 = *MEMORY[0x1E69E9840];
  v4 = atomic_load((a1 + 136));
  v5 = MEMORY[0x1E12C16E0]();
  v27 = v5;
  if (v4)
  {
    v6 = 1;
  }

  else
  {
    v6 = a2 < 1;
  }

  if (v6)
  {
    v7 = v5;
    if (v4 >= 1 && a2 == 0)
    {
      AMCP::ASP::Engine::stop(a1);
    }
  }

  else
  {
    AMCP::Core::Implementation::Simple_Engine_IO_State::take_power_assertions(a1 + 120);
    AMCP::IO_Clock::reset_time((a1 + 576));
    kdebug_trace();
    v9 = (*(**(a1 + 744) + 80))(*(a1 + 744), *(a1 + 752), 1);
    v10 = kdebug_trace();
    if (v9)
    {
      v23 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v23 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(v10);
      }

      v25 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v24 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        v26 = *v25;
        std::__shared_weak_count::__release_shared[abi:ne200100](v24);
      }

      else
      {
        v26 = *v25;
      }

      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *buf = 136315650;
        v38 = "ASP_Engine.cpp";
        v39 = 1024;
        v40 = 670;
        v41 = 2080;
        v42 = "error != 0";
        _os_log_error_impl(&dword_1DE1F9000, v26, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s couldn't start the hardware", buf, 0x1Cu);
      }

      AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v36);
      __cxa_allocate_exception(0x40uLL);
      std::runtime_error::runtime_error(&v29, "couldn't start the hardware");
      std::runtime_error::runtime_error(&v30, &v29);
      v32 = 0;
      v33 = 0;
      v34 = 0;
      v35 = -1;
      v30.__vftable = &unk_1F5992170;
      v31 = &unk_1F5992198;
      boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::clone_impl(buf, &v30);
      v43 = "void AMCP::ASP::Engine::start()";
      v44 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/ASP_Engine.cpp";
      v45 = 670;
      applesauce::backtrace::snapshot_N<64>::snapshot_N(&v28);
    }

    *(a1 + 757) = (*(**(a1 + 744) + 104))(*(a1 + 744), *(a1 + 752), 1) >> 32;
    *(a1 + 758) = (*(**(a1 + 744) + 128))(*(a1 + 744), *(a1 + 752), 1) >> 32;
    *(a1 + 759) = (*(**(a1 + 744) + 152))(*(a1 + 744), *(a1 + 752), 1) >> 32;
    v11 = (*(**(a1 + 744) + 184))(*(a1 + 744), *(a1 + 752), 1);
    *(a1 + 760) = BYTE4(v11);
    *(a1 + 761) = BYTE5(v11);
    v12 = (*(**(a1 + 744) + 216))(*(a1 + 744), *(a1 + 752), 1);
    *(a1 + 762) = BYTE4(v12);
    *(a1 + 763) = BYTE5(v12);
    v13 = (*(**(a1 + 744) + 248))(*(a1 + 744), *(a1 + 752), 1);
    *(a1 + 764) = BYTE4(v13);
    *(a1 + 765) = BYTE5(v13);
    v14 = *(a1 + 752);
    *(a1 + 766) = (*(**(a1 + 744) + 280))() >> 32;
    v15 = *(a1 + 752);
    v16 = (*(**(a1 + 744) + 312))();
    *(a1 + 767) = BYTE4(v16);
    *(a1 + 768) = BYTE5(v16);
    v17 = *(a1 + 752);
    v18 = (*(**(a1 + 744) + 344))();
    *(a1 + 769) = BYTE4(v18);
    *(a1 + 770) = BYTE5(v18);
    v19 = *(a1 + 752);
    *(a1 + 771) = (*(**(a1 + 744) + 376))() >> 32;
    v7 = v27;
  }

  atomic_store(a2, (a1 + 136));
  result = MEMORY[0x1E12C16E0]();
  if (result <= v7)
  {
    v22 = *MEMORY[0x1E69E9840];
  }

  else
  {
    atomic_store(0, (a1 + 136));
    v21 = *MEMORY[0x1E69E9840];

    return AMCP::ASP::Engine::stop(a1);
  }

  return result;
}

void sub_1DE72B6F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, std::runtime_error a19, char a20)
{
  if (a2)
  {
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t applesauce::raii::v1::detail::ScopeGuard<AMCP::ASP::Engine::set_transport_state(AMCP::Transport_State)::$_0,applesauce::raii::v1::detail::StackFailPolicy>::~ScopeGuard(uint64_t a1)
{
  if (MEMORY[0x1E12C16E0]() > *a1)
  {
    v2 = *(a1 + 8);
    atomic_store(0, v2 + 34);
    AMCP::ASP::Engine::stop(v2);
  }

  return a1;
}

uint64_t AMCP::ASP::Engine::stop(AMCP::ASP::Engine *this)
{
  kdebug_trace();
  (*(**(this + 93) + 88))(*(this + 93), *(this + 188), 1);
  kdebug_trace();
  AMCP::IO_Clock::reset_time(this + 144);

  return AMCP::Core::Implementation::Simple_Engine_IO_State::release_power_assertions(this + 120);
}

__n128 AMCP::ASP::Engine::get_stream_format@<Q0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  v4 = 48;
  if (!a2)
  {
    v4 = 72;
  }

  v5 = a1 + v4;
  v6 = *(a1 + v4 + 24);
  v7 = *(v5 + 32);
  while (1)
  {
    if (v6 == v7)
    {
      *(a4 + 32) = 0;
      result.n128_u64[0] = 0;
      *a4 = 0u;
      *(a4 + 16) = 0u;
      return result;
    }

    if (*v6 == a3)
    {
      break;
    }

    v6 += 56;
  }

  result = *(v6 + 16);
  v9 = *(v6 + 32);
  *a4 = result;
  *(a4 + 16) = v9;
  *(a4 + 32) = *(v6 + 48);
  return result;
}

void AMCP::ASP::Engine::~Engine(AMCP::ASP::Engine *this)
{
  AMCP::ASP::Engine::~Engine(this);

  JUMPOUT(0x1E12C1730);
}

{
  *this = &unk_1F598EE30;
  AMCP::ASP::Engine::set_transport_state(this, 0);
  v2 = *(this + 93);
  v3 = *(this + 188);
  v13 = 0x100000001;
  v14 = 1;
  v15 = 0;
  (*(*v2 + 24))(v2, v3, &v13);
  v13 = this + 776;
  std::vector<std::shared_ptr<unsigned long long>>::__destroy_vector::operator()[abi:ne200100](&v13);
  v4 = *(this + 93);
  *(this + 93) = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  AMCP::IO_Clock::~IO_Clock((this + 576));
  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue((this + 240));
  v5 = *(this + 29);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v5);
  }

  v6 = *(this + 27);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v6);
  }

  v7 = *(this + 22);
  if (v7)
  {
    operator delete(v7);
  }

  v8 = *(this + 18);
  if (v8)
  {
    operator delete(v8);
  }

  v9 = *(this + 12);
  if (v9)
  {
    *(this + 13) = v9;
    operator delete(v9);
  }

  v10 = *(this + 9);
  if (v10)
  {
    *(this + 10) = v10;
    operator delete(v10);
  }

  v11 = *(this + 3);
  if (v11)
  {
    CFRelease(v11);
  }

  v12 = *(this + 2);
  if (v12)
  {
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1DE72BB80(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "EndIOOperation (kAudioServerPlugInIOOperationWriteMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72BB70);
}

void sub_1DE72BC1C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "DoIOOperation (kAudioServerPlugInIOOperationWriteMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72BC0CLL);
}

void sub_1DE72BCA8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "BeginIOOperation (kAudioServerPlugInIOOperationWriteMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72BC98);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::WillDo_WriteMix(AMCP::ASP::MCP_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v3 = *(this + 1);
  v7 = 0;
  v6 = 1;
  v4 = (*(**(v3 + 16) + 152))(*(v3 + 16), a2, a3, 1919513701, &v7, &v6);
  return v4 | ((v7 != 0) << 32);
}

void sub_1DE72BD54(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "WillDoIOOperation (kAudioServerPlugInIOOperationWriteMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72BD30);
}

void sub_1DE72BDE0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "EndIOOperation (kAudioServerPlugInIOOperationConvertMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72BDD0);
}

void sub_1DE72BE78(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "DoIOOperation (kAudioServerPlugInIOOperationConvertMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72BE68);
}

void sub_1DE72BF04(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "BeginIOOperation (kAudioServerPlugInIOOperationConvertMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72BEF4);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::WillDo_ConvertMix(AMCP::ASP::MCP_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v3 = *(this + 1);
  v7 = 0;
  v6 = 1;
  v4 = (*(**(v3 + 16) + 152))(*(v3 + 16), a2, a3, 1668114808, &v7, &v6);
  return v4 | ((v7 != 0) << 32) | ((v6 != 0) << 40);
}

void sub_1DE72BFC0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "WillDoIOOperation (kAudioServerPlugInIOOperationConvertMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72BF8CLL);
}

void sub_1DE72C04C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "EndIOOperation (kAudioServerPlugInIOOperationProcessMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C03CLL);
}

void sub_1DE72C0E4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "DoIOOperation (kAudioServerPlugInIOOperationProcessMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C0D4);
}

void sub_1DE72C170(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "BeginIOOperation (kAudioServerPlugInIOOperationProcessMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C160);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::WillDo_ProcessMix(AMCP::ASP::MCP_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v3 = *(this + 1);
  v7 = 0;
  v6 = 1;
  v4 = (*(**(v3 + 16) + 152))(*(v3 + 16), a2, a3, 1886218616, &v7, &v6);
  return v4 | ((v7 != 0) << 32) | ((v6 != 0) << 40);
}

void sub_1DE72C22C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "WillDoIOOperation (kAudioServerPlugInIOOperationProcessMix)");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C1F8);
}

void sub_1DE72C2B8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "EndIOOperation (kAudioServerPlugInIOOperationMixOutput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C2A8);
}

void sub_1DE72C34C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "DoIOOperation (kAudioServerPlugInIOOperationMixOutput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C33CLL);
}

void sub_1DE72C3D8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "BeginIOOperation (kAudioServerPlugInIOOperationMixOutput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C3C8);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::WillDo_MixOutput(AMCP::ASP::MCP_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v3 = *(this + 1);
  v7 = 0;
  v6 = 1;
  v4 = (*(**(v3 + 16) + 152))(*(v3 + 16), a2, a3, 1835628655, &v7, &v6);
  return v4 | ((v7 != 0) << 32);
}

void sub_1DE72C484(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "WillDoIOOperation (kAudioServerPlugInIOOperationMixOutput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C460);
}

void sub_1DE72C510(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "EndIOOperation (kAudioServerPlugInIOOperationProcessOutput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C500);
}

void sub_1DE72C5A8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "DoIOOperation (kAudioServerPlugInIOOperationProcessOutput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C598);
}

void sub_1DE72C634(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "BeginIOOperation (kAudioServerPlugInIOOperationProcessOutput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C624);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::WillDo_ProcessOutput(AMCP::ASP::MCP_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v3 = *(this + 1);
  v7 = 0;
  v6 = 1;
  v4 = (*(**(v3 + 16) + 152))(*(v3 + 16), a2, a3, 1886352756, &v7, &v6);
  return v4 | ((v7 != 0) << 32) | ((v6 != 0) << 40);
}

void sub_1DE72C6F0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "WillDoIOOperation (kAudioServerPlugInIOOperationProcessOutput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C6BCLL);
}

void sub_1DE72C77C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "EndIOOperation (kAudioServerPlugInIOOperationProcessInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C76CLL);
}

void sub_1DE72C814(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "DoIOOperation (kAudioServerPlugInIOOperationProcessInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C804);
}

void sub_1DE72C8A0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "BeginIOOperation (kAudioServerPlugInIOOperationProcessInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C890);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::WillDo_ProcessInput(AMCP::ASP::MCP_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v3 = *(this + 1);
  v7 = 0;
  v6 = 1;
  v4 = (*(**(v3 + 16) + 152))(*(v3 + 16), a2, a3, 1885957744, &v7, &v6);
  return v4 | ((v7 != 0) << 32) | ((v6 != 0) << 40);
}

void sub_1DE72C95C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "WillDoIOOperation (kAudioServerPlugInIOOperationProcessInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C928);
}

void sub_1DE72C9E8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "EndIOOperation (kAudioServerPlugInIOOperationConvertInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72C9D8);
}

void sub_1DE72CA80(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "DoIOOperation (kAudioServerPlugInIOOperationConvertInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72CA70);
}

void sub_1DE72CB0C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "BeginIOOperation (kAudioServerPlugInIOOperationConvertInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72CAFCLL);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::WillDo_ConvertInput(AMCP::ASP::MCP_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v3 = *(this + 1);
  v7 = 0;
  v6 = 1;
  v4 = (*(**(v3 + 16) + 152))(*(v3 + 16), a2, a3, 1667853936, &v7, &v6);
  return v4 | ((v7 != 0) << 32) | ((v6 != 0) << 40);
}

void sub_1DE72CBC8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "WillDoIOOperation (kAudioServerPlugInIOOperationConvertInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72CB94);
}

void sub_1DE72CC54(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "EndIOOperation (kAudioServerPlugInIOOperationReadInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72CC44);
}

void sub_1DE72CCF0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "DoIOOperation (kAudioServerPlugInIOOperationReadInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72CCE0);
}

void sub_1DE72CD7C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "BeginIOOperation (kAudioServerPlugInIOOperationReadInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72CD6CLL);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::WillDo_ReadInput(AMCP::ASP::MCP_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v3 = *(this + 1);
  v7 = 0;
  v6 = 1;
  v4 = (*(**(v3 + 16) + 152))(*(v3 + 16), a2, a3, 1919246692, &v7, &v6);
  return v4 | ((v7 != 0) << 32);
}

void sub_1DE72CE28(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "WillDoIOOperation (kAudioServerPlugInIOOperationReadInput)");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72CE04);
}

void sub_1DE72CEB4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "EndIOOperation (kAudioServerPlugInIOOperationCycle)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72CEA4);
}

void sub_1DE72CF40(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "BeginIOOperation (kAudioServerPlugInIOOperationCycle)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72CF30);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::WillDo_IOCycle(AMCP::ASP::MCP_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v3 = *(this + 1);
  v7 = 0;
  v6 = 1;
  v4 = (*(**(v3 + 16) + 152))(*(v3 + 16), a2, a3, 1668899692, &v7, &v6);
  return v4 | ((v7 != 0) << 32);
}

void sub_1DE72CFEC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "WillDoIOOperation (kAudioServerPlugInIOOperationCycle)");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72CFC8);
}

void sub_1DE72D078(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "EndIOOperation (kAudioServerPlugInIOOperationThread)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D068);
}

void sub_1DE72D104(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "BeginIOOperation (kAudioServerPlugInIOOperationThread)");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D0F4);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::WillDo_IOThread(AMCP::ASP::MCP_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v3 = *(this + 1);
  v7 = 0;
  v6 = 1;
  v4 = (*(**(v3 + 16) + 152))(*(v3 + 16), a2, a3, 1953002084, &v7, &v6);
  return v4 | ((v7 != 0) << 32);
}

void sub_1DE72D1B0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "WillDoIOOperation (kAudioServerPlugInIOOperationThread)");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D18CLL);
}

double AMCP::ASP::MCP_PlugIn_Wrapper::GetZeroTimeStamp@<D0>(AMCP::ASP::MCP_PlugIn_Wrapper *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v5 = *(this + 1);
  v10 = 0.0;
  v8 = 0;
  v9 = 0;
  *a4 = (*(**(v5 + 16) + 144))(*(v5 + 16), a2, a3, &v10, &v9, &v8);
  result = v10;
  *(a4 + 8) = v10;
  v7 = v8;
  *(a4 + 16) = v9;
  *(a4 + 24) = v7;
  return result;
}

void sub_1DE72D258(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "GetZeroTimeStamp");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D234);
}

void sub_1DE72D2D4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "StopIO");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D2C4);
}

void sub_1DE72D350(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "StartIO");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D340);
}

void sub_1DE72D3DC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "DestroyDevice");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D3CCLL);
}

unint64_t AMCP::ASP::MCP_PlugIn_Wrapper::CreateDevice(AMCP::ASP::MCP_PlugIn_Wrapper *this, const __CFDictionary *a2, const AudioServerPlugInClientInfo *a3)
{
  v3 = *(this + 1);
  v6 = 0;
  v4 = (*(**(v3 + 16) + 40))(*(v3 + 16), a2, a3, &v6);
  return v4 | (v6 << 32);
}

void sub_1DE72D46C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "CreateDevice");
  AMCP::ASP::PlugIn::log_plugin_exception(v14, &__p);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D450);
}

void sub_1DE72D4E8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "AbortDeviceConfigurationChange");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D4D8);
}

void sub_1DE72D56C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "RemoveDeviceClient");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D55CLL);
}

void sub_1DE72D5E8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_begin_catch(a1);
  std::string::basic_string[abi:ne200100]<0>(&__p, "AddDeviceClient");
  AMCP::ASP::PlugIn::log_plugin_exception(v15, &__p);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __cxa_end_catch();
  JUMPOUT(0x1DE72D5D8);
}

void AMCP::ASP::MCP_PlugIn_Wrapper::~MCP_PlugIn_Wrapper(AMCP::ASP::MCP_PlugIn_Wrapper *this)
{
  *this = &unk_1F598EFD0;
  v1 = *(this + 2);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  JUMPOUT(0x1E12C1730);
}

{
  *this = &unk_1F598EFD0;
  v1 = *(this + 2);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::ObjectGetPropertyData(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3, const AudioObjectPropertyAddress *a4, uint64_t a5, const void *a6, uint64_t a7, void *a8)
{
  v9 = 0;
  (*(**(this + 1) + 568))(*(this + 1), a2, a3, a4, a5, a6, a7, &v9, a8);
  return v9 << 32;
}

uint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::ObjectIsPropertySettable(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3, const AudioObjectPropertyAddress *a4)
{
  if ((*(**(this + 1) + 552))(*(this + 1), a2, a3, a4))
  {
    return 0x100000000;
  }

  else
  {
    return 0;
  }
}

uint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::Do_WriteMix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  v7 = *(a7 + 4);
  if (*(a1 + 24))
  {
    v8 = a7;
  }

  else
  {
    v8 = *a7;
  }

  if (!*(a1 + 24))
  {
    v7 = 0;
  }

  v10 = v8[1];
  v11 = v7;
  v12 = vmovn_s64(*(a7 + 3));
  return (*(**(a1 + 8) + 528))(*(a1 + 8), a2, a3, a4, a5, a6, &v10);
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::WillDo_WriteMix(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 512))(*(this + 1), a2, a3, &v5);
  return v3 | (v5 << 32);
}

uint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::Do_ConvertMix(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const AudioServerPlugInIOCycleInfo *a6, void *a7, void *a8)
{
  v14 = 0;
  v11 = 0;
  v12 = a7;
  v13 = 0;
  v9 = a8;
  v10 = 0;
  return (*(**(this + 1) + 496))(*(this + 1), a2, a3, a4, a5, a6);
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::WillDo_ConvertMix(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 480))(*(this + 1), a2, a3, &v5 + 1, &v5);
  return v3 | (HIBYTE(v5) << 32) | (v5 << 40);
}

uint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::Do_ProcessMix(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const AudioServerPlugInIOCycleInfo *a6, void *a7, void *a8)
{
  v14 = 0;
  v11 = 0;
  v12 = a7;
  v13 = 0;
  v9 = a8;
  v10 = 0;
  return (*(**(this + 1) + 464))(*(this + 1), a2, a3, a4, a5, a6);
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::WillDo_ProcessMix(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 448))(*(this + 1), a2, a3, &v5 + 1, &v5);
  return v3 | (HIBYTE(v5) << 32) | (v5 << 40);
}

uint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::Do_MixOutput(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const AudioServerPlugInIOCycleInfo *a6, void *a7)
{
  v9 = 0;
  v8[0] = a7;
  v8[1] = 0;
  return (*(**(this + 1) + 432))(*(this + 1), a2, a3, a4, a5, a6, v8);
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::WillDo_MixOutput(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 416))(*(this + 1), a2, a3, &v5);
  return v3 | (v5 << 32);
}

uint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::Do_ProcessOutput(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const AudioServerPlugInIOCycleInfo *a6, void *a7, void *a8)
{
  v14 = 0;
  v11 = 0;
  v12 = a7;
  v13 = 0;
  v9 = a8;
  v10 = 0;
  return (*(**(this + 1) + 400))(*(this + 1), a2, a3, a4, a5, a6);
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::WillDo_ProcessOutput(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 384))(*(this + 1), a2, a3, &v5 + 1, &v5);
  return v3 | (HIBYTE(v5) << 32) | (v5 << 40);
}

uint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::Do_ProcessInput(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const AudioServerPlugInIOCycleInfo *a6, void *a7, void *a8)
{
  v14 = 0;
  v11 = 0;
  v12 = a7;
  v13 = 0;
  v9 = a8;
  v10 = 0;
  return (*(**(this + 1) + 368))(*(this + 1), a2, a3, a4, a5, a6);
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::WillDo_ProcessInput(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 352))(*(this + 1), a2, a3, &v5 + 1, &v5);
  return v3 | (HIBYTE(v5) << 32) | (v5 << 40);
}

uint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::Do_ConvertInput(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const AudioServerPlugInIOCycleInfo *a6, void *a7, void *a8)
{
  v14 = 0;
  v11 = 0;
  v12 = a7;
  v13 = 0;
  v9 = a8;
  v10 = 0;
  return (*(**(this + 1) + 336))(*(this + 1), a2, a3, a4, a5, a6);
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::WillDo_ConvertInput(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 320))(*(this + 1), a2, a3, &v5 + 1, &v5);
  return v3 | (HIBYTE(v5) << 32) | (v5 << 40);
}

uint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::Do_ReadInput(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  v7 = *(a7 + 4);
  if (*(a1 + 24))
  {
    v8 = a7;
  }

  else
  {
    v8 = *a7;
  }

  if (!*(a1 + 24))
  {
    v7 = 0;
  }

  v10 = v8[1];
  v11 = v7;
  v12 = vmovn_s64(*(a7 + 3));
  return (*(**(a1 + 8) + 272))(*(a1 + 8), a2, a3, a4, a5, a6, &v10);
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::WillDo_ReadInput(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 256))(*(this + 1), a2, a3, &v5);
  return v3 | (v5 << 32);
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::WillDo_IOCycle(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 232))(*(this + 1), a2, a3, &v5);
  return v3 | (v5 << 32);
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::WillDo_IOThread(AMCP::ASP::Legacy_PlugIn_Wrapper *this, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 208))(*(this + 1), a2, a3, &v5);
  return v3 | (v5 << 32);
}

double AMCP::ASP::Legacy_PlugIn_Wrapper::GetZeroTimeStamp@<D0>(AMCP::ASP::Legacy_PlugIn_Wrapper *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v8 = 0;
  v9 = 0.0;
  v7 = 0;
  *a4 = (*(**(this + 1) + 200))(*(this + 1), a2, a3, &v9, &v8, &v7);
  result = v9;
  *(a4 + 8) = v9;
  v6 = v7;
  *(a4 + 16) = v8;
  *(a4 + 24) = v6;
  return result;
}

unint64_t AMCP::ASP::Legacy_PlugIn_Wrapper::CreateDevice(AMCP::ASP::Legacy_PlugIn_Wrapper *this, const __CFDictionary *a2, const AudioServerPlugInClientInfo *a3)
{
  v5 = 0;
  v3 = (*(**(this + 1) + 104))(*(this + 1), a2, a3, &v5);
  return v3 | (v5 << 32);
}

void AMCP::ASP::Legacy_PlugIn_Wrapper::~Legacy_PlugIn_Wrapper(AMCP::ASP::Legacy_PlugIn_Wrapper *this)
{
  *this = &unk_1F598F1B0;
  v1 = *(this + 2);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  JUMPOUT(0x1E12C1730);
}

{
  *this = &unk_1F598F1B0;
  v1 = *(this + 2);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }
}

uint64_t std::__function::__func<AMCP::ASP::Engine::Engine(std::shared_ptr<AMCP::ASP::PlugIn>,BOOL,std::shared_ptr<HALS_UCPlugInBase>,unsigned int,applesauce::CF::StringRef,double,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,std::vector<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info> const&,std::vector<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info> const&,AMCP::Utility::Dispatch_Queue const&)::$_0,std::allocator<AMCP::ASP::Engine::Engine(std::shared_ptr<AMCP::ASP::PlugIn>,BOOL,std::shared_ptr<HALS_UCPlugInBase>,unsigned int,applesauce::CF::StringRef,double,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,std::vector<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info> const&,std::vector<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info> const&,AMCP::Utility::Dispatch_Queue const&)::$_0>,CA::TimeStamp ()(void)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "ZN4AMCP3ASP6EngineC1ENSt3__110shared_ptrINS0_6PlugInEEEbNS3_I17HALS_UCPlugInBaseEEjN10applesauce2CF9StringRefEdjjjjjjRKNS2_6vectorINS_4Core14Implementation18Simple_Engine_Data11Stream_InfoENS2_9allocatorISF_EEEESK_RKNS_7Utility14Dispatch_QueueEE3$_0"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__func<AMCP::ASP::Engine::Engine(std::shared_ptr<AMCP::ASP::PlugIn>,BOOL,std::shared_ptr<HALS_UCPlugInBase>,unsigned int,applesauce::CF::StringRef,double,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,std::vector<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info> const&,std::vector<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info> const&,AMCP::Utility::Dispatch_Queue const&)::$_0,std::allocator<AMCP::ASP::Engine::Engine(std::shared_ptr<AMCP::ASP::PlugIn>,BOOL,std::shared_ptr<HALS_UCPlugInBase>,unsigned int,applesauce::CF::StringRef,double,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,std::vector<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info> const&,std::vector<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info> const&,AMCP::Utility::Dispatch_Queue const&)::$_0>,CA::TimeStamp ()(void)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F598F410;
  a2[1] = v2;
  return result;
}

void AMCP::ASP::Engine::Engine(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, CFTypeRef *a7, int a8, int a9, int a10, int a11, int a12, int a13, uint64_t *a14, uint64_t *a15, dispatch_queue_t *a16)
{
  v30 = *MEMORY[0x1E69E9840];
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *a1 = &unk_1F598EE30;
  v21 = *a7;
  if (*a7)
  {
    CFRetain(*a7);
  }

  v28 = 0;
  v29 = v21;
  v27 = 0uLL;
  std::vector<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info>::__init_with_size[abi:ne200100]<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info*,AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info*>(&v27, *a14, a14[1], 0x6DB6DB6DB6DB6DB7 * ((a14[1] - *a14) >> 3));
  v25 = 0uLL;
  v26 = 0;
  std::vector<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info>::__init_with_size[abi:ne200100]<AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info*,AMCP::Core::Implementation::Simple_Engine_Data::Stream_Info*>(&v25, *a15, a15[1], 0x6DB6DB6DB6DB6DB7 * ((a15[1] - *a15) >> 3));
  *(a1 + 24) = v21;
  *(a1 + 32) = a2;
  *(a1 + 40) = a8;
  *(a1 + 44) = a9;
  *(a1 + 48) = 0;
  *(a1 + 52) = a10;
  *(a1 + 56) = a11;
  *(a1 + 60) = a12;
  *(a1 + 64) = a13;
  *(a1 + 72) = v27;
  *(a1 + 88) = v28;
  v27 = 0uLL;
  v28 = 0;
  v29 = 0;
  *(a1 + 96) = v25;
  *(a1 + 112) = v26;
  v22 = 0x6DB6DB6DB6DB6DB7 * ((a14[1] - *a14) >> 3);
  v23 = (a15[1] - *a15) >> 3;
  v25 = 0uLL;
  v26 = 0;
  AMCP::Core::Implementation::Simple_Engine_IO_State::Simple_Engine_IO_State((a1 + 120), a7, v22, 0x6DB6DB6DB6DB6DB7 * v23, 0, a16, v24);
}

void sub_1DE72F058(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, char a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25)
{
  a21 = v25 + 97;
  std::vector<std::shared_ptr<unsigned long long>>::__destroy_vector::operator()[abi:ne200100](&a21);
  v27 = v25[93];
  v25[93] = 0;
  if (v27)
  {
    (*(*v27 + 8))(v27);
  }

  AMCP::IO_Clock::~IO_Clock((v25 + 72));
  AMCP::Core::Implementation::Simple_Engine_IO_State::~Simple_Engine_IO_State((v25 + 15));
  AMCP::Core::Implementation::Simple_Engine_Data::~Simple_Engine_Data((v25 + 3));
  v28 = v25[2];
  if (v28)
  {
    std::__shared_weak_count::__release_weak(v28);
  }

  _Unwind_Resume(a1);
}

double ***AMCP::Graph::Input_Path_Calculator::calculate_minimum_required_input_samples_for_output_samples(AMCP::Graph::Input_Path_Calculator *this, const AMCP::Graph::Manifest_Execution_Context *a2)
{
  v3 = *(this + 1);
  v4 = *(v3 + 32) - *(v3 + 24);
  if (v4)
  {
    v5 = 0;
    v6 = 0xCCCCCCCCCCCCCCCDLL * (v4 >> 3);
    v7 = 0.0;
    do
    {
      nth_connection_list = AMCP::Graph::Manifest_Task::get_nth_connection_list(*(this + 1), v5, 1u);
      v9 = *nth_connection_list;
      v10 = nth_connection_list[1];
      while (v9 != v10)
      {
        v11 = *v9;
        v12 = *(*v9 + 160);
        v34 = *(*v9 + 208);
        v13 = v11[29];
        v35 = v11[28];
        v36 = v13;
        v14 = v11[30];
        v37 = v14;
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        sample_time = AMCP::DAL::DAL_Time::get_sample_time(&v34);
        v16 = *v9;
        v30 = *(*v9 + 168);
        v17 = v16[24];
        v31 = v16[23];
        v32 = v17;
        v18 = v16[25];
        v33 = v18;
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        v19 = AMCP::DAL::DAL_Time::get_sample_time(&v30);
        if (v33)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v33);
        }

        if (v37)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v37);
        }

        if (round(v7) < round(v12 - (sample_time - v19)))
        {
          v7 = v12 - (sample_time - v19);
        }

        v9 += 16;
      }

      ++v5;
    }

    while (v5 != v6);
    v3 = *(this + 1);
  }

  else
  {
    v7 = 0.0;
  }

  result = *(*(v3 + 48) + 472);
  if (result)
  {
    *&v34 = vcvtmd_s64_f64(v7);
    result = ((*result)[6])(result, &v34);
    v7 = result;
    v3 = *(this + 1);
  }

  else
  {
    v27 = *(v3 + 96);
    if (round(v27) != 0.0)
    {
      v28 = floor(v7) / v27;
      v29 = vcvtmd_s64_f64(v27);
      if (v28 == floor(v28))
      {
        v7 = v28 * v29;
      }

      else
      {
        v7 = (v29 + v29 * (vcvtmd_s64_f64(v7) / v29));
      }
    }
  }

  v21 = *(v3 + 8) - *v3;
  if (v21)
  {
    v22 = 0;
    v23 = 0xCCCCCCCCCCCCCCCDLL * (v21 >> 3);
    do
    {
      result = AMCP::Graph::Manifest_Task::get_nth_connection_list(*(this + 1), v22, 0);
      v24 = *result;
      v25 = result[1];
      while (v24 != v25)
      {
        v26 = *v24;
        v24 += 2;
        result = AMCP::Graph::Manifest_Buffer::set_minimum_required_samples(v26, v7);
      }

      ++v22;
    }

    while (v22 != v23);
  }

  return result;
}

void sub_1DE72F358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a19);
  }

  _Unwind_Resume(exception_object);
}

void AMCP::Graph::Input_Path_Calculator::get_number_of_samples_to_read(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a1 + 8);
  if (*(v4 + 32) == *(v4 + 24))
  {
    v6 = *a3;
    v16 = *(*a3 + 208);
    v7 = v6[29];
    v17 = v6[28];
    v18 = v7;
    v8 = v6[30];
    v19 = v8;
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    AMCP::DAL::DAL_Time::get_sample_time(&v16);
    v9 = *a3;
    v12 = *(*a3 + 168);
    v10 = v9[24];
    v13 = v9[23];
    v14 = v10;
    v11 = v9[25];
    v15 = v11;
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    AMCP::DAL::DAL_Time::get_sample_time(&v12);
    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v15);
    }

    if (v19)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v19);
    }
  }

  else if (round(*(v4 + 96)) == 0.0)
  {
    v5 = *(*a3 + 160);
  }
}

void sub_1DE72F470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a13)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a13);
  }

  if (a19)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a19);
  }

  _Unwind_Resume(exception_object);
}

void AMCP::Graph::Input_Path_Calculator::process_all_pending_samples(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  v6 = *(a1 + 8);
  if (*(v6 + 32) == *(v6 + 24))
  {
    v34 = *(a1 + 8);

    AMCP::Graph::Manifest_Task::process_once(v34, a2, a3, a4, a5, a6);
  }

  else
  {
    do
    {
      v7 = *(v6 + 32) - *(v6 + 24);
      if (!v7)
      {
        break;
      }

      v8 = 0;
      v9 = 0;
      v10 = v7 >> 3;
      v11 = 0xCCCCCCCCCCCCCCCDLL * v10;
      v12 = 0xCCCCCCCCCCCCCCCDLL * v10 <= 1 ? 1 : 0xCCCCCCCCCCCCCCCDLL * v10;
      v41 = v12;
      do
      {
        nth_connection_list = AMCP::Graph::Manifest_Task::get_nth_connection_list(v6, v9, 1u);
        v15 = *nth_connection_list;
        v14 = nth_connection_list[1];
        while (v15 != v14)
        {
          v16 = *v15;
          v17 = (*v15)[41];
          if (v17)
          {
            v18 = pthread_self();
            v19 = pthread_mach_thread_np(v18);
            v20 = *v16;
            AMCP::Graph::Manifest_Buffer::get_buffer_id(&v42, v16);
            AMCP::Wire_Identifier_to_string(&v45, &v42.__r_.__value_.__l.__data_);
            AMCP::Graph::Manifest_Log::add_message(v17, 4, "%u\tManifest_Buffer(%zu)::has_minimum_required_samples_after_time:  source: %s", v21, v22, v23, v24, v25, v19);
            if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v45.__r_.__value_.__l.__data_);
            }

            if (v44 < 0)
            {
              operator delete(__p);
            }

            if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v42.__r_.__value_.__l.__data_);
            }
          }

          if (!v16[38])
          {
            goto LABEL_22;
          }

          v26 = v16[41];
          if (v26)
          {
            sample_time = AMCP::DAL::DAL_Time::get_sample_time((v16 + 26));
            v28 = LOBYTE(sample_time);
            AMCP::DAL::DAL_Time::get_sample_time((v16 + 31));
            AMCP::DAL::DAL_Time::get_sample_time((v16 + 21));
            AMCP::Graph::Manifest_Log::add_message(v26, 4, "\t\tproducer write: %0.4f  producer target: %0.4f  consumer read: %0.4f", v29, v30, v31, v32, v33, v28);
          }

          if (AMCP::DAL::DAL_Time::operator<((v16 + 26), (v16 + 31)))
          {
            goto LABEL_22;
          }

          v15 += 2;
        }

        v8 = ++v9 >= v11;
      }

      while (v9 != v41);
LABEL_22:
      if (v8)
      {
        break;
      }

      AMCP::Graph::Manifest_Task::process_once(*(a1 + 8), a2, a3, a4, a5, a6);
      v6 = *(a1 + 8);
    }

    while (round(*(v6 + 96)) != 0.0);
  }
}

void sub_1DE72F710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  if (*(v11 - 105) < 0)
  {
    operator delete(*(v11 - 128));
  }

  AMCP::Wire_Identifier::~Wire_Identifier(va);
  _Unwind_Resume(a1);
}

uint64_t AMCP::Graph::Output_Path_Calculator::calculate_minimum_required_input_samples_for_output_samples(uint64_t this, const AMCP::Graph::Manifest_Execution_Context *a2)
{
  v2 = *(*(this + 8) + 8) - **(this + 8);
  if (v2)
  {
    v3 = this;
    v4 = 0;
    v5 = 0xCCCCCCCCCCCCCCCDLL * (v2 >> 3);
    do
    {
      this = AMCP::Graph::Manifest_Task::get_nth_connection_list(v3[1], v4, 0);
      v6 = *this;
      v7 = *(this + 8);
      while (v6 != v7)
      {
        v8 = *v6;
        v6 += 2;
        AMCP::Graph::Output_Path_Calculator::get_number_of_samples_to_write(v3);
        this = AMCP::Graph::Manifest_Buffer::set_minimum_required_samples(v8, v9);
      }

      ++v4;
    }

    while (v4 != v5);
  }

  return this;
}

AMCP::Log::AMCP_Scope_Registry *AMCP::Graph::Output_Path_Calculator::get_number_of_samples_to_write(AMCP::Log::AMCP_Scope_Registry *a1)
{
  v33 = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 1);
  v3 = *(v2 + 96);
  v4 = round(v3);
  if (v4 == 0.0)
  {
    v3 = AMCP::Graph::Manifest_Task::calculate_samples_to_process_for_output(*v2, *(v2 + 8));
    v4 = round(v3);
  }

  if (v4 < 0.0)
  {
    v7 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v7 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(a1);
    }

    v9 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v8 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      v10 = *v9;
      std::__shared_weak_count::__release_shared[abi:ne200100](v8);
    }

    else
    {
      v10 = *v9;
    }

    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      *&buf[4] = "Data_Flow_Calculator.cpp";
      v26 = 1024;
      v27 = 184;
      v28 = 2080;
      v29 = "not (input_samples >= 0_S)";
      _os_log_error_impl(&dword_1DE1F9000, v10, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v24);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("", &v16);
    std::logic_error::logic_error(&v17, &v16);
    v17.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v18, &v17);
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = -1;
    v18.__vftable = &unk_1F5991430;
    v19 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v18);
    v30 = "virtual DAL::Sample_Time AMCP::Graph::Output_Path_Calculator::get_number_of_samples_to_write(const Manifest_Execution_Context &, const Manifest_Task::Connection &)";
    v31 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/Graph/Data_Flow_Calculator.cpp";
    v32 = 184;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(&v15);
  }

  result = *(*(*(a1 + 1) + 48) + 504);
  if (result)
  {
    v18.__vftable = 0;
    *buf = vcvtmd_s64_f64(v3);
    result = (*(*result + 48))(result, buf, &v18);
    v3 = result;
  }

  if (round(v3) < 0.0)
  {
    v11 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v11 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(result);
    }

    v13 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v12 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      v14 = *v13;
      std::__shared_weak_count::__release_shared[abi:ne200100](v12);
    }

    else
    {
      v14 = *v13;
    }

    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      *&buf[4] = "Data_Flow_Calculator.cpp";
      v26 = 1024;
      v27 = 187;
      v28 = 2080;
      v29 = "not (result >= 0_S)";
      _os_log_error_impl(&dword_1DE1F9000, v14, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v24);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("", &v16);
    std::logic_error::logic_error(&v17, &v16);
    v17.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v18, &v17);
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = -1;
    v18.__vftable = &unk_1F5991430;
    v19 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v18);
    v30 = "virtual DAL::Sample_Time AMCP::Graph::Output_Path_Calculator::get_number_of_samples_to_write(const Manifest_Execution_Context &, const Manifest_Task::Connection &)";
    v31 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/Graph/Data_Flow_Calculator.cpp";
    v32 = 187;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(&v15);
  }

  v6 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1DE72FCF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, char a25, uint64_t a26, char a27)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a12)
  {
    operator delete(a12);
  }

  boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::~clone_impl(v28 - 112);
  boost::exception_detail::error_info_injector<std::domain_error>::~error_info_injector(&a27);
  MEMORY[0x1E12C0F00](&a25);
  if (a24 < 0)
  {
    operator delete(a19);
  }

  if (a11)
  {
    __cxa_free_exception(v27);
  }

  AMCP::Utility::With_Realtime_Disabled::~With_Realtime_Disabled((v28 - 113));
  _Unwind_Resume(a1);
}

double AMCP::Graph::Output_Path_Calculator::get_number_of_samples_to_read(uint64_t a1)
{
  v1 = *(a1 + 8);
  result = *(v1 + 96);
  if (round(result) == 0.0)
  {
    return AMCP::Graph::Manifest_Task::calculate_samples_to_process_for_output(*v1, *(v1 + 8));
  }

  return result;
}

double AMCP::Graph::Output_Path_Calculator::process_all_pending_samples(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  while (1)
  {
    v12 = *(a1 + 8);
    result = round(AMCP::Graph::Manifest_Task::calculate_samples_to_process_for_output(*v12, *(v12 + 8)));
    if (result <= 0.0 || result < round(*(v12 + 96)))
    {
      break;
    }

    AMCP::Graph::Manifest_Task::process_once(*(a1 + 8), a2, a3, a4, a5, a6);
  }

  return result;
}

double ***AMCP::Graph::IO_Proc_Calculator::calculate_minimum_required_input_samples_for_output_samples(double ***this, const AMCP::Graph::Manifest_Execution_Context *a2)
{
  v2 = this[1][1] - *this[1];
  if (v2)
  {
    v4 = this;
    v5 = 0;
    v6 = 0xCCCCCCCCCCCCCCCDLL * (v2 >> 3);
    do
    {
      this = AMCP::Graph::Manifest_Task::get_nth_connection_list(*(v4 + 8), v5, 0);
      v7 = *this;
      v8 = this[1];
      while (v7 != v8)
      {
        if ((*a2 & 2) == 0)
        {
          AMCP::DAL::DAL_Time_Delta::validate(a2);
        }

        v9 = *v7;
        v7 += 2;
        this = AMCP::Graph::Manifest_Buffer::set_minimum_required_samples(v9, *(a2 + 1));
      }

      ++v5;
    }

    while (v5 != v6);
  }

  return this;
}

double AMCP::Graph::IO_Proc_Calculator::get_number_of_samples_to_write(int a1, AMCP::DAL::DAL_Time_Delta *this)
{
  if ((*this & 2) == 0)
  {
    AMCP::DAL::DAL_Time_Delta::validate(this);
  }

  return *(this + 1);
}

double AMCP::Graph::IO_Proc_Calculator::get_number_of_samples_to_read(int a1, AMCP::DAL::DAL_Time_Delta *this)
{
  if ((*this & 2) == 0)
  {
    AMCP::DAL::DAL_Time_Delta::validate(this);
  }

  return *(this + 1);
}

uint64_t std::shared_ptr<AMCP::DAL::DAL_Buffer>::operator=[abi:ne200100]<AMCP::DAL::Mixing_Ring_Buffer,std::default_delete<AMCP::DAL::Mixing_Ring_Buffer>,0>(uint64_t a1, uint64_t *a2)
{
  if (*a2)
  {
    v3 = *a2;
    operator new();
  }

  *a2 = 0;
  v4 = *(a1 + 8);
  *a1 = 0u;
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  return a1;
}

uint64_t std::__shared_ptr_pointer<AMCP::DAL::Mixing_Ring_Buffer  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "NSt3__114default_deleteIN4AMCP3DAL18Mixing_Ring_BufferEEE"))
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__shared_ptr_pointer<AMCP::DAL::Mixing_Ring_Buffer  *>::__on_zero_shared(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void std::__shared_ptr_pointer<AMCP::DAL::Mixing_Ring_Buffer  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t std::__shared_ptr_pointer<AMCP::DAL::Ring_Buffer  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "NSt3__114default_deleteIN4AMCP3DAL11Ring_BufferEEE"))
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__shared_ptr_pointer<AMCP::DAL::Ring_Buffer  *>::__on_zero_shared(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void std::__shared_ptr_pointer<AMCP::DAL::Ring_Buffer  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

void AMCP::Graph::Manifest_Buffer::anchor_time(AMCP::Graph::Manifest_Buffer *this, atomic_ullong **a2, int a3, AMCP::Graph::Manifest_Counter *a4, const AMCP::Graph::Manifest_Execution_Context *a5)
{
  v145 = *MEMORY[0x1E69E9840];
  if (*(this + 37))
  {
    v77 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v77 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(this);
    }

    v79 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v78 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v78)
    {
      atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
      v80 = *v79;
      std::__shared_weak_count::__release_shared[abi:ne200100](v78);
    }

    else
    {
      v80 = *v79;
    }

    if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      *&buf[4] = "Manifest_Buffer.cpp";
      *&buf[12] = 1024;
      *&buf[14] = 149;
      *&buf[18] = 2080;
      *&buf[20] = "not (not is_processing())";
      _os_log_error_impl(&dword_1DE1F9000, v80, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s Don't call anchor_to_timebase_anchor on buffers that are currently processing", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v132);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("Don't call anchor_to_timebase_anchor on buffers that are currently processing", &v125);
    std::logic_error::logic_error(&v135, &v125);
    v135.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v106, &v135);
    v108 = 0;
    v109 = 0;
    *&v110 = 0;
    DWORD2(v110) = -1;
    v106.__vftable = &unk_1F5991430;
    v107 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v106);
    *&buf[32] = "void AMCP::Graph::Manifest_Buffer::anchor_time(const DAL::DAL_Time &, AMCP::Object_ID, Manifest_Counter &, const Manifest_Execution_Context &)";
    v139 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/Graph/Manifest_Buffer.cpp";
    v140 = 149;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(&v121);
  }

  v9 = *(this + 8);
  v137 = v9;
  v93 = v9;
  v10 = v9.n128_u64[1];
  if (v9.n128_u64[1])
  {
    atomic_fetch_add_explicit((v9.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
  }

  AMCP::DAL::DAL_Time_Delta::translate_time_delta(&v135, a5, &v137);
  if ((*a2 & 0xFFFFFFFE) == 2)
  {
    AMCP::DAL::DAL_Time::get_sample_time(a2);
  }

  v12 = a2[3];
  v11 = a2[4];
  if (!v11)
  {
    if (v12 == v93.n128_u64[0])
    {
      goto LABEL_8;
    }

LABEL_18:
    v22 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v22 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v11);
    }

    v24 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v23 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      v25 = *v24;
      std::__shared_weak_count::__release_shared[abi:ne200100](v23);
    }

    else
    {
      v25 = *v24;
    }

    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      *&buf[4] = "Manifest_Buffer.cpp";
      *&buf[12] = 1024;
      *&buf[14] = 155;
      *&buf[18] = 2080;
      *&buf[20] = "not (exact_buffer_time.get_clock() == timebase)";
      _os_log_error_impl(&dword_1DE1F9000, v25, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v128);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("", &v125);
    std::logic_error::logic_error(&v132, &v125);
    v132.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v106, &v132);
    v108 = 0;
    v109 = 0;
    *&v110 = 0;
    DWORD2(v110) = -1;
    v106.__vftable = &unk_1F5991430;
    v107 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v106);
    *&buf[32] = "void AMCP::Graph::Manifest_Buffer::anchor_time(const DAL::DAL_Time &, AMCP::Object_ID, Manifest_Counter &, const Manifest_Execution_Context &)";
    v139 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/Graph/Manifest_Buffer.cpp";
    v140 = 155;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(&v121);
  }

  atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed);
  std::__shared_weak_count::__release_shared[abi:ne200100](v11);
  if (v12 != v93.n128_u64[0])
  {
    goto LABEL_18;
  }

LABEL_8:
  sample_time = AMCP::DAL::DAL_Time::get_sample_time(a2);
  v14 = (*(*v93.n128_u64[0] + 136))(v93.n128_u64[0], v93);
  if ((v15 & 1) != 0 && round(sample_time) < round(*&v14))
  {
    v81 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v81 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v14);
    }

    v83 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v82 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v82)
    {
      atomic_fetch_add_explicit(&v82->__shared_owners_, 1uLL, memory_order_relaxed);
      v84 = *v83;
      std::__shared_weak_count::__release_shared[abi:ne200100](v82);
    }

    else
    {
      v84 = *v83;
    }

    if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      *&buf[4] = "Manifest_Buffer.cpp";
      *&buf[12] = 1024;
      *&buf[14] = 156;
      *&buf[18] = 2080;
      *&buf[20] = "not (exact_buffer_time.get_sample_time() >= timebase->get_anchor_time())";
      _os_log_error_impl(&dword_1DE1F9000, v84, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s Attempt to anchor before the clock's anchor time", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v128);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("Attempt to anchor before the clock's anchor time", &v125);
    std::logic_error::logic_error(&v132, &v125);
    v132.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v106, &v132);
    v108 = 0;
    v109 = 0;
    *&v110 = 0;
    DWORD2(v110) = -1;
    v106.__vftable = &unk_1F5991430;
    v107 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v106);
    *&buf[32] = "void AMCP::Graph::Manifest_Buffer::anchor_time(const DAL::DAL_Time &, AMCP::Object_ID, Manifest_Counter &, const Manifest_Execution_Context &)";
    v139 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/Graph/Manifest_Buffer.cpp";
    v140 = 156;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(&v121);
  }

  v16 = *(this + 80);
  if (v10)
  {
    atomic_fetch_add_explicit((v10 + 8), 1uLL, memory_order_relaxed);
  }

  LODWORD(v132.__vftable) = 2;
  *&v132.__imp_.__imp_ = v16;
  v133 = 0;
  v134 = v93;
  AMCP::DAL::DAL_Time::round(&v128, a2);
  v17 = AMCP::DAL::DAL_Time::operator==(&v128, a2);
  if (!v17)
  {
    v18 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v18 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v17);
    }

    v20 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v19 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      v21 = *v20;
      std::__shared_weak_count::__release_shared[abi:ne200100](v19);
    }

    else
    {
      v21 = *v20;
    }

    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136315394;
      *&buf[4] = "Manifest_Buffer.cpp";
      *&buf[12] = 1024;
      *&buf[14] = 163;
      _os_log_debug_impl(&dword_1DE1F9000, v21, OS_LOG_TYPE_DEBUG, "%32s:%-5d Buffer Time was rounded during anchor_time!", buf, 0x12u);
    }
  }

  v26 = AMCP::DAL::DAL_Time::get_sample_time(&v128);
  if ((v135.__vftable & 2) == 0)
  {
    AMCP::DAL::DAL_Time_Delta::validate(&v135);
  }

  imp = v135.__imp_.__imp_;
  if ((v132.__vftable & 2) == 0)
  {
    AMCP::DAL::DAL_Time_Delta::validate(&v132);
  }

  v28 = v26 + *&imp + *&v132.__imp_.__imp_;
  v29 = v137;
  v30 = v137.n128_u64[1];
  if (v137.n128_u64[1])
  {
    atomic_fetch_add_explicit((v137.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
  }

  *buf = 2;
  *&buf[8] = v28;
  *&buf[16] = 0;
  *&buf[24] = v29;
  AMCP::DAL::DAL_Time_Range::DAL_Time_Range(&v125, &v128, buf);
  if (v30)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v30);
  }

  v31 = *(this + 38);
  if (v31)
  {
    if (*(this + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v118, *(this + 1), *(this + 2));
      v31 = *(this + 38);
    }

    else
    {
      v118 = *(this + 8);
    }

    v32 = *(this + 4);
    v120 = *(this + 10);
    LODWORD(v121.__r_.__value_.__l.__data_) = a3;
    *&v121.__r_.__value_.__r.__words[1] = *&v118.__r_.__value_.__l.__data_;
    v33 = v118.__r_.__value_.__r.__words[2];
    memset(&v118, 0, sizeof(v118));
    v119 = v32;
    v124 = v120;
    v122 = v33;
    v123 = v32;
    (*(*v31 + 96))(v31, &v121, &v125, *(this + 39));
    if ((v132.__vftable & 2) == 0)
    {
      AMCP::DAL::DAL_Time_Delta::validate(&v132);
    }

    if (vcvtmd_s64_f64(*&v132.__imp_.__imp_) >= 1)
    {
      (*(**(this + 38) + 80))(v117);
      v34 = AMCP::DAL::DAL_Time::get_sample_time(&v128);
      v35 = v137;
      v36 = v137.n128_u64[1];
      if (v137.n128_u64[1])
      {
        atomic_fetch_add_explicit((v137.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
      }

      LODWORD(v114.__vftable) = 2;
      *&v114.__imp_.__imp_ = v34;
      v115 = 0;
      v116 = v35;
      v37 = *(this + 80);
      *buf = &unk_1F598F618;
      if (v36)
      {
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      LODWORD(__p.__r_.__value_.__l.__data_) = 2;
      *&__p.__r_.__value_.__r.__words[1] = *&v37;
      v104 = v35;
      boost::operators_impl::operator+(&v106, &v114, &__p);
      AMCP::DAL::DAL_Time_Range::DAL_Time_Range(&buf[8], &v114, &v106);
      if (v109)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v109);
      }

      if (v104.n128_u64[1])
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v104.n128_u64[1]);
      }

      AMCP::DAL::Container::Container(&v143, v117, v37);
      if (v36)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v36);
      }

      AMCP::DAL::Fixed_Buffer::create_readable_range(buf, &v106);
      v38 = *(this + 38);
      v95 = v106;
      v96 = v107;
      v97 = v108;
      v98 = v109;
      if (v109)
      {
        atomic_fetch_add_explicit(&v109->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v99 = v110;
      v100 = v111;
      v101 = v112;
      v102 = v113;
      if (v113)
      {
        atomic_fetch_add_explicit(&v113->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      (*(*v38 + 160))(&__p);
      if (v102)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v102);
      }

      if (v98)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v98);
      }

      AMCP::DAL::Writable_Range::receive_data(&__p, &v121, &v106);
      if (v105)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v105);
      }

      if (v104.n128_u64[1])
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v104.n128_u64[1]);
      }

      if (v113)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v113);
      }

      if (v109)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v109);
      }

      *buf = &unk_1F598F618;
      if (v144)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v144);
      }

      if (v142)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v142);
      }

      if (v139)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v139);
      }
    }

    if (SHIBYTE(v122) < 0)
    {
      operator delete(v121.__r_.__value_.__l.__size_);
    }
  }

  boost::operators_impl::operator+(&v106, a2, &v132);
  AMCP::DAL::DAL_Time::round(buf, &v106);
  *(this + 13) = *buf;
  *(this + 28) = *&buf[16];
  v39 = *(this + 30);
  *(this + 232) = *&buf[24];
  if (v39)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v39);
  }

  if (v109)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v109);
  }

  *(this + 62) = *(this + 52);
  *(this + 16) = *(this + 216);
  v41 = *(this + 29);
  v40 = *(this + 30);
  if (v40)
  {
    atomic_fetch_add_explicit((v40 + 8), 1uLL, memory_order_relaxed);
  }

  v42 = *(this + 35);
  *(this + 34) = v41;
  *(this + 35) = v40;
  if (v42)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v42);
  }

  *(this + 42) = v128;
  v43 = (this + 168);
  *(this + 11) = v129;
  v45 = v130;
  v44 = v131;
  if (v131)
  {
    atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v46 = *(this + 25);
  *(this + 24) = v45;
  *(this + 25) = v44;
  if (v46)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v46);
  }

  v47 = *(this + 41);
  if (v47)
  {
    v48 = *this;
    AMCP::Graph::Manifest_Buffer::get_buffer_id(buf, this);
    AMCP::Wire_Identifier_to_string(&__p, buf);
    AMCP::DAL::DAL_Time::get_host_time(&v128);
    v49 = *(a4 + 3);
    v50 = *(a4 + 4);
    v121.__r_.__value_.__r.__words[0] = v49;
    v121.__r_.__value_.__l.__size_ = v50;
    if (v50)
    {
      atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    AMCP::DAL::DAL_Time::translate_time(&v106, &v128, &v121);
    AMCP::DAL::DAL_Time::get_sample_time(&v106);
    AMCP::Graph::Manifest_Log::add_message(v47, 4, "Manifest_Buffer(%zu) %s  anchor_time - host time: %llu, sample time: %lf", v51, v52, v53, v54, v55, v48);
    if (v109)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v109);
    }

    if (v50)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v50);
    }

    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (v141 < 0)
    {
      operator delete(v139);
    }

    if ((buf[23] & 0x80000000) != 0)
    {
      operator delete(*buf);
    }

    v56 = *(this + 41);
    if (v56)
    {
      v57 = AMCP::DAL::DAL_Time::get_sample_time((this + 208));
      vcvtmd_s64_f64(AMCP::DAL::DAL_Time::get_sample_time((this + 168)));
      AMCP::Graph::Manifest_Log::add_message(v56, 4, "\twrite position: %lld, read position: %lld", v58, v59, v60, v61, v62, vcvtmd_s64_f64(v57));
    }
  }

  if ((*v43 & 0xFFFFFFFE) == 2)
  {
    AMCP::DAL::DAL_Time::get_sample_time((this + 168));
  }

  if ((*(this + 62) & 0xFFFFFFFE) == 2)
  {
    AMCP::DAL::DAL_Time::get_sample_time((this + 248));
  }

  if ((*v43 & 0xFFFFFFFE) == 2)
  {
    AMCP::DAL::DAL_Time::get_sample_time((this + 168));
  }

  v63 = AMCP::DAL::DAL_Time::get_sample_time((this + 168));
  if (AMCP::DAL::DAL_Time::get_sample_time((this + 168)) != floor(v63))
  {
    v85 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v85 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v64);
    }

    v87 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v86 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v86)
    {
      atomic_fetch_add_explicit(&v86->__shared_owners_, 1uLL, memory_order_relaxed);
      v88 = *v87;
      std::__shared_weak_count::__release_shared[abi:ne200100](v86);
    }

    else
    {
      v88 = *v87;
    }

    if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      *&buf[4] = "Manifest_Buffer.cpp";
      *&buf[12] = 1024;
      *&buf[14] = 198;
      *&buf[18] = 2080;
      *&buf[20] = "not (m_consumer_read_position.get_sample_time().floor().get() == m_consumer_read_position.get_sample_time().get_double())";
      _os_log_error_impl(&dword_1DE1F9000, v88, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v94);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("", &v121);
    std::logic_error::logic_error(&v114, &v121);
    v114.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v106, &v114);
    v108 = 0;
    v109 = 0;
    *&v110 = 0;
    DWORD2(v110) = -1;
    v106.__vftable = &unk_1F5991430;
    v107 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v106);
    *&buf[32] = "void AMCP::Graph::Manifest_Buffer::anchor_time(const DAL::DAL_Time &, AMCP::Object_ID, Manifest_Counter &, const Manifest_Execution_Context &)";
    v139 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/Graph/Manifest_Buffer.cpp";
    v140 = 198;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(v117);
  }

  v65 = v130;
  v66 = v131;
  if (v131)
  {
    atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v67 = v137.n128_u64[0];
  v68 = (v65 | v137.n128_u64[0]) == 0;
  if (!v65 || !v137.n128_u64[0])
  {
LABEL_125:
    if (!v66)
    {
      goto LABEL_127;
    }

    goto LABEL_126;
  }

  v69 = (*(*v65 + 16))(v65);
  v65 = (*(*v67 + 16))(v67);
  v70 = *(v69 + 23);
  if (v70 >= 0)
  {
    v71 = *(v69 + 23);
  }

  else
  {
    v71 = *(v69 + 8);
  }

  v72 = *(v65 + 23);
  v73 = v72;
  if ((v72 & 0x80u) != 0)
  {
    v72 = *(v65 + 8);
  }

  if (v71 == v72)
  {
    if (v70 >= 0)
    {
      v74 = v69;
    }

    else
    {
      v74 = *v69;
    }

    if (v73 >= 0)
    {
      v75 = v65;
    }

    else
    {
      v75 = *v65;
    }

    v65 = memcmp(v74, v75, v71);
    v68 = v65 == 0;
    goto LABEL_125;
  }

  v68 = 0;
  if (v66)
  {
LABEL_126:
    std::__shared_weak_count::__release_shared[abi:ne200100](v66);
  }

LABEL_127:
  if (!v68)
  {
    v89 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v89 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v65);
    }

    v91 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v90 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v90)
    {
      atomic_fetch_add_explicit(&v90->__shared_owners_, 1uLL, memory_order_relaxed);
      v92 = *v91;
      std::__shared_weak_count::__release_shared[abi:ne200100](v90);
    }

    else
    {
      v92 = *v91;
    }

    if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      *&buf[4] = "Manifest_Buffer.cpp";
      *&buf[12] = 1024;
      *&buf[14] = 199;
      *&buf[18] = 2080;
      *&buf[20] = "not (is_same_timebase(buffer_time.get_clock(), timebase))";
      _os_log_error_impl(&dword_1DE1F9000, v92, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v94);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("", &v121);
    std::logic_error::logic_error(&v114, &v121);
    v114.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v106, &v114);
    v108 = 0;
    v109 = 0;
    *&v110 = 0;
    DWORD2(v110) = -1;
    v106.__vftable = &unk_1F5991430;
    v107 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v106);
    *&buf[32] = "void AMCP::Graph::Manifest_Buffer::anchor_time(const DAL::DAL_Time &, AMCP::Object_ID, Manifest_Counter &, const Manifest_Execution_Context &)";
    v139 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/Graph/Manifest_Buffer.cpp";
    v140 = 199;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(v117);
  }

  if (v127)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v127);
  }

  if (v126)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v126);
  }

  if (v66)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v66);
  }

  if (v134.n128_u64[1])
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v134.n128_u64[1]);
  }

  if (v136)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v136);
  }

  if (v137.n128_u64[1])
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v137.n128_u64[1]);
  }

  v76 = *MEMORY[0x1E69E9840];
}

void sub_1DE731E08(_Unwind_Exception *a1)
{
  AMCP::DAL::DAL_Time_Range::~DAL_Time_Range(&STACK[0x208]);
  v3 = v1[27];
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  v4 = v1[32];
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  v5 = v1[37];
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v5);
  }

  v6 = v1[39];
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v6);
  }

  _Unwind_Resume(a1);
}

double AMCP::DAL::DAL_Time::round(AMCP::DAL::DAL_Time *this, uint64_t a2)
{
  sample_time = AMCP::DAL::DAL_Time::get_sample_time(a2);
  v5 = *(a2 + 24);
  v6 = *(a2 + 32);
  if (v6)
  {
    atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
  }

  *this = 2;
  result = round(sample_time);
  *(this + 1) = result;
  *(this + 2) = 0;
  *(this + 24) = v5;
  return result;
}

void AMCP::Graph::Manifest_Buffer::get_buffer_id(std::string *this, uint64_t a2)
{
  if (*(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(a2 + 8), *(a2 + 16));
  }

  else
  {
    *this = *(a2 + 8);
  }

  this[1].__r_.__value_.__r.__words[0] = *(a2 + 32);
  LODWORD(this[1].__r_.__value_.__r.__words[1]) = *(a2 + 40);
  if (*(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external((this + 40), *(a2 + 48), *(a2 + 56));
  }

  else
  {
    *&this[1].__r_.__value_.__r.__words[2] = *(a2 + 48);
    this[2].__r_.__value_.__l.__size_ = *(a2 + 64);
  }

  this[2].__r_.__value_.__r.__words[2] = *(a2 + 72);
  LODWORD(this[3].__r_.__value_.__l.__data_) = *(a2 + 80);
}

void sub_1DE7322D4(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

void AMCP::Graph::Manifest_Buffer::advance(AMCP::Graph::Manifest_Buffer *this)
{
  v31 = *MEMORY[0x1E69E9840];
  if (!*(this + 37))
  {
    v9 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v9 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(this);
    }

    v11 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v10 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      v12 = *v11;
      std::__shared_weak_count::__release_shared[abi:ne200100](v10);
    }

    else
    {
      v12 = *v11;
    }

    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      *v27 = "Manifest_Buffer.cpp";
      *&v27[8] = 1024;
      *&v27[10] = 265;
      *&v27[14] = 2080;
      *&v27[16] = "not (is_processing())";
      _os_log_error_impl(&dword_1DE1F9000, v12, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v25);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("", &v17);
    std::logic_error::logic_error(&v18, &v17);
    v18.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v19, &v18);
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = -1;
    v19.__vftable = &unk_1F5991430;
    v20 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v19);
    *&v27[28] = "void AMCP::Graph::Manifest_Buffer::advance()";
    v28 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/Graph/Manifest_Buffer.cpp";
    v29 = 265;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(&v16);
  }

  v2 = *(this + 38);
  if (v2)
  {
    v19 = *(this + 168);
    v3 = *(this + 24);
    v20 = *(this + 23);
    v21 = v3;
    v4 = *(this + 25);
    v22 = v4;
    if (v4)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      v2 = *(this + 38);
    }

    (*(*v2 + 64))(buf);
    AMCP::DAL::DAL_Time::operator-(&v14, &v19, buf);
    if (v30)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v30);
    }

    if (*&v27[28])
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](*&v27[28]);
    }

    v5 = v21;
    v6 = v22;
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      *(&v13 + 1) = v6;
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    else
    {
      *(&v13 + 1) = 0;
    }

    *&v13 = v5;
    *buf = 2;
    *&v27[4] = 0;
    *&v27[12] = 0;
    *&v27[20] = v13;
    v7 = AMCP::DAL::DAL_Time_Delta::operator<(buf, &v14);
    if (*&v27[28])
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](*&v27[28]);
    }

    if (v7)
    {
      (*(**(this + 38) + 120))(*(this + 38), &v14);
      (*(**(this + 38) + 88))(*(this + 38));
    }

    if (v6)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v6);
    }

    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v15);
    }

    if (v6)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v6);
    }
  }

  v8 = *MEMORY[0x1E69E9840];
}

void sub_1DE7326DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, void *a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, char a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35)
{
  if (v35)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v35);
  }

  if (a19)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a19);
  }

  if (v35)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v35);
  }

  _Unwind_Resume(exception_object);
}

double *AMCP::Graph::Manifest_Buffer::set_minimum_required_samples(double *result, double a2)
{
  v26 = *MEMORY[0x1E69E9840];
  if (round(a2) < 0.0)
  {
    v3 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v3 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(result);
    }

    v5 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v4 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v4)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      v6 = *v5;
      std::__shared_weak_count::__release_shared[abi:ne200100](v4);
    }

    else
    {
      v6 = *v5;
    }

    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      v18 = "Manifest_Buffer.cpp";
      v19 = 1024;
      v20 = 430;
      v21 = 2080;
      v22 = "not (s >= 0_S)";
      _os_log_error_impl(&dword_1DE1F9000, v6, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v16);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("", &v8);
    std::logic_error::logic_error(&v9, &v8);
    v9.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v10, &v9);
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = -1;
    v10.__vftable = &unk_1F5991430;
    v11 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v10);
    v23 = "void AMCP::Graph::Manifest_Buffer::set_minimum_required_samples(Sample_Time)";
    v24 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/Graph/Manifest_Buffer.cpp";
    v25 = 430;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(&v7);
  }

  result[20] = a2;
  v2 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1DE732A58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, char a25, uint64_t a26, char a27)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a12)
  {
    operator delete(a12);
  }

  boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::~clone_impl(v28 - 112);
  boost::exception_detail::error_info_injector<std::domain_error>::~error_info_injector(&a27);
  MEMORY[0x1E12C0F00](&a25);
  if (a24 < 0)
  {
    operator delete(a19);
  }

  if (a11)
  {
    __cxa_free_exception(v27);
  }

  AMCP::Utility::With_Realtime_Disabled::~With_Realtime_Disabled((v28 - 113));
  _Unwind_Resume(a1);
}

uint64_t HALS_IODevice::UseClockBoundsCheck(HALS_IODevice *this)
{
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 1;
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK13HALS_IODevice19UseClockBoundsCheckEv_block_invoke;
  v4[3] = &unk_1E86794F0;
  v4[4] = &v5;
  v4[5] = this;
  v1 = (*(*this + 64))(this);
  HALB_CommandGate::ExecuteCommand(v1, v4);
  v2 = *(v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1DE732BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK13HALS_IODevice19UseClockBoundsCheckEv_block_invoke(uint64_t a1)
{
  result = (*(**(a1 + 40) + 384))(*(a1 + 40));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE732C44(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t HALS_IODevice::IsClockStable(HALS_IODevice *this)
{
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK13HALS_IODevice13IsClockStableEv_block_invoke;
  v4[3] = &unk_1E86794C8;
  v4[4] = &v5;
  v4[5] = this;
  v1 = (*(*this + 64))(this);
  HALB_CommandGate::ExecuteCommand(v1, v4);
  v2 = *(v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1DE732D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK13HALS_IODevice13IsClockStableEv_block_invoke(uint64_t a1)
{
  result = (*(**(a1 + 40) + 376))(*(a1 + 40));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE732DA0(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t HALS_IODevice::GetClockAlgorithm(HALS_IODevice *this)
{
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 1768518246;
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK13HALS_IODevice17GetClockAlgorithmEv_block_invoke;
  v4[3] = &unk_1E86794A0;
  v4[4] = &v5;
  v4[5] = this;
  v1 = (*(*this + 64))(this);
  HALB_CommandGate::ExecuteCommand(v1, v4);
  v2 = *(v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1DE732E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK13HALS_IODevice17GetClockAlgorithmEv_block_invoke(uint64_t a1)
{
  result = (*(**(a1 + 40) + 368))(*(a1 + 40));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE732F04(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t HALS_IODevice::GetNumberStreams(HALS_IODevice *this, char a2)
{
  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v5[0] = MEMORY[0x1E69E9820];
  v5[1] = 0x40000000;
  v5[2] = ___ZNK13HALS_IODevice16GetNumberStreamsEb_block_invoke;
  v5[3] = &unk_1E8679450;
  v5[4] = &v7;
  v5[5] = this;
  v6 = a2;
  v2 = (*(*this + 64))(this);
  HALB_CommandGate::ExecuteCommand(v2, v5);
  v3 = *(v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t ___ZNK13HALS_IODevice16GetNumberStreamsEb_block_invoke(uint64_t a1)
{
  result = (*(**(a1 + 40) + 392))(*(a1 + 40), *(a1 + 48));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE733070(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t HALS_IODevice::CopyStreamByIndex(HALS_IODevice *this, char a2, int a3)
{
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v6[0] = MEMORY[0x1E69E9820];
  v6[1] = 0x40000000;
  v6[2] = ___ZNK13HALS_IODevice17CopyStreamByIndexEbj_block_invoke;
  v6[3] = &unk_1E8679478;
  v6[4] = &v9;
  v6[5] = this;
  v8 = a2;
  v7 = a3;
  v3 = (*(*this + 64))(this);
  HALB_CommandGate::ExecuteCommand(v3, v6);
  v4 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v4;
}

uint64_t ___ZNK13HALS_IODevice17CopyStreamByIndexEbj_block_invoke(uint64_t a1)
{
  result = (*(**(a1 + 40) + 400))(*(a1 + 40), *(a1 + 52), *(a1 + 48));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_1DE7331DC(void *a1)
{
  __cxa_begin_catch(a1);

  __cxa_end_catch();
}

uint64_t HALS_IODevice::GetTransportType(HALS_IODevice *this)
{
  v1 = *(this + 4);
  v3 = 0x676C6F627472616ELL;
  v4 = 0;
  v5 = 0;
  (*(*this + 120))(this, v1, &v3, 4, &v5, &v5 + 4, 0, 0, 0);
  return HIDWORD(v5);
}

void sub_1DE733274(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE733268);
}

uint64_t HALS_IODevice::CopyIOEngine(HALS_IODevice *this)
{
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 0x40000000;
  v4[2] = ___ZN13HALS_IODevice12CopyIOEngineEv_block_invoke;
  v4[3] = &unk_1E8679518;
  v4[4] = &v5;
  v4[5] = this;
  v1 = (*(*this + 64))(this);
  HALB_CommandGate::ExecuteCommand(v1, v4);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1DE73334C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN13HALS_IODevice12CopyIOEngineEv_block_invoke(uint64_t a1)
{
  result = (*(**(a1 + 40) + 408))(*(a1 + 40));
  *(*(*(a1 + 32) + 8) + 24) = result;
  return result;
}

void ___ZN13HALS_IODevice22set_paused_io_contextsERKNSt3__13setIjNS0_4lessIjEENS0_9allocatorIjEEEE_block_invoke(AMCP::Log::AMCP_Scope_Registry *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = *(a1 + 4);
  if (*(v1 + 72) == 1)
  {
    v4 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v4 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(a1);
    }

    v6 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v5 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v5)
    {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      v7 = *v6;
      std::__shared_weak_count::__release_shared[abi:ne200100](v5);
    }

    else
    {
      v7 = *v6;
    }

    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v12 = 136315650;
      v13 = "HALS_IODevice.cpp";
      v14 = 1024;
      v15 = 136;
      v16 = 2080;
      v17 = "not mContextsPausedForDevice";
      v11 = "%32s:%-5d Assertion Failed: %s Contexts are already paused for this device!";
LABEL_20:
      _os_log_error_impl(&dword_1DE1F9000, v7, OS_LOG_TYPE_ERROR, v11, &v12, 0x1Cu);
    }

LABEL_21:
    abort();
  }

  if (*(v1 + 64))
  {
    v8 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v8 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(a1);
    }

    v10 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v9 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      v7 = *v10;
      std::__shared_weak_count::__release_shared[abi:ne200100](v9);
    }

    else
    {
      v7 = *v10;
    }

    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v12 = 136315650;
      v13 = "HALS_IODevice.cpp";
      v14 = 1024;
      v15 = 137;
      v16 = 2080;
      v17 = "m_paused_contexts.empty()";
      v11 = "%32s:%-5d Assertion Failed: %s Vector of paused contexts is not empty!";
      goto LABEL_20;
    }

    goto LABEL_21;
  }

  v2 = *(a1 + 5);
  if (v1 + 48 != v2)
  {
    std::__tree<DSP_Host_Types::AudioProcessingType>::__assign_multi<std::__tree_const_iterator<DSP_Host_Types::AudioProcessingType,std::__tree_node<DSP_Host_Types::AudioProcessingType,void *> *,long>>(v1 + 48, *v2, (v2 + 8));
  }

  *(v1 + 72) = 1;
  v3 = *MEMORY[0x1E69E9840];
}

void *__Block_byref_object_copy__20790(void *result, void *a2)
{
  result[5] = a2[5];
  v2 = a2 + 6;
  v3 = a2[6];
  result[6] = v3;
  v4 = result + 6;
  v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(v3 + 16) = v4;
    a2[5] = v2;
    *v2 = 0;
    a2[7] = 0;
  }

  else
  {
    result[5] = v4;
  }

  return result;
}

void ___ZN13HALS_IODevice32get_and_clear_paused_io_contextsEv_block_invoke(AMCP::Log::AMCP_Scope_Registry *a1)
{
  v12 = *MEMORY[0x1E69E9840];
  v1 = *(a1 + 5);
  if ((*(v1 + 72) & 1) == 0)
  {
    v5 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v5 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(a1);
    }

    v7 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v6 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      v8 = *v7;
      std::__shared_weak_count::__release_shared[abi:ne200100](v6);
    }

    else
    {
      v8 = *v7;
    }

    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *v9 = 136315650;
      *&v9[4] = "HALS_IODevice.cpp";
      *&v9[12] = 1024;
      *&v9[14] = 148;
      v10 = 2080;
      v11 = "mContextsPausedForDevice";
      _os_log_error_impl(&dword_1DE1F9000, v8, OS_LOG_TYPE_ERROR, "%32s:%-5d Assertion Failed: %s Contexts not paused for this device right now!", v9, 0x1Cu);
    }

    abort();
  }

  std::set<unsigned int>::set[abi:ne200100](v9, v1 + 48);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(*(v1 + 56));
  *(v1 + 48) = v1 + 56;
  *(v1 + 56) = 0;
  *(v1 + 64) = 0;
  *(v1 + 72) = 0;
  v3 = (*(*(a1 + 4) + 8) + 40);
  if (v3 != v9)
  {
    std::__tree<DSP_Host_Types::AudioProcessingType>::__assign_multi<std::__tree_const_iterator<DSP_Host_Types::AudioProcessingType,std::__tree_node<DSP_Host_Types::AudioProcessingType,void *> *,long>>(v3, *v9, &v9[8]);
  }

  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(*&v9[8]);
  v4 = *MEMORY[0x1E69E9840];
}

void AMCP::Null_Object_Description::create(uint64_t *__return_ptr a1@<X8>, AMCP::Null_Object_Description *this@<X0>)
{
  AMCP::Core::Broker::fetch_core(&v21, *(***(this + 4) + 16), *(this + 2));
  AMCP::Core::Core::make_snapshot(&v19, v21);
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
  v5 = v20;
  if (v20)
  {
    do
    {
      stock_class_id = AMCP::Object::get_stock_class_id(this);
      v7 = v5[4];
      if (v7 <= 1684370978)
      {
        if (v7 <= 1652060013)
        {
          if (v7 <= 1651472418)
          {
            if (v7 == 1650682915)
            {
              goto LABEL_68;
            }

            v12 = 1650751011;
            goto LABEL_37;
          }

          if (v7 != 1651472419)
          {
            v12 = 1652060006;
            goto LABEL_37;
          }

          goto LABEL_39;
        }

        if (v7 > 1668575851)
        {
          if (v7 != 1668575852)
          {
            v12 = 1668577315;
LABEL_37:
            if (v7 != v12)
            {
LABEL_38:
              AMCP::make_description_from_thing(v37, (v5 + 8));
              v10 = v37[0];
              goto LABEL_54;
            }

            goto LABEL_68;
          }

          if (v5[5] == 1735159650)
          {
            v27 = 0;
            v28 = 0;
            __p = 0;
            AMCP::Null_Object_Description::make_object_list_description(v37, this, (v5 + 8), &__p);
            v10 = v37[0];
            if (v37[0])
            {
              CFRetain(v37[0]);
              CFRelease(v10);
            }

            v11 = __p;
            if (!__p)
            {
              goto LABEL_54;
            }

            v27 = __p;
LABEL_53:
            operator delete(v11);
            goto LABEL_54;
          }
        }

        else if (v7 != 1652060014)
        {
          if (v7 != 1668049699)
          {
            goto LABEL_38;
          }

          if (AMCP::is_base_of(0x61706C67, stock_class_id))
          {
            v32 = 1633969526;
            v34 = 0;
            v35 = 0;
            v33 = 0;
            std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int const*,unsigned int const*>(&v33, &v32, &v33, 1uLL);
            AMCP::Null_Object_Description::make_object_list_description(v37, this, (v5 + 8), &v33);
            v10 = v37[0];
            if (v37[0])
            {
              CFRetain(v37[0]);
              CFRelease(v10);
            }

            v11 = v33;
            if (v33)
            {
              v34 = v33;
              goto LABEL_53;
            }

LABEL_54:
            if (v10)
            {
              AMCP::Address::to_string(&v36, v5 + 4, v9);
              if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              {
                v13 = &v36;
              }

              else
              {
                v13 = v36.__r_.__value_.__r.__words[0];
              }

              if (v13)
              {
                if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                {
                  size = HIBYTE(v36.__r_.__value_.__r.__words[2]);
                }

                else
                {
                  size = v36.__r_.__value_.__l.__size_;
                }

                v15 = CFStringCreateWithBytes(0, v13, size, 0x8000100u, 0);
                v33 = v15;
                if (!v15)
                {
                  exception = __cxa_allocate_exception(0x10uLL);
                  std::runtime_error::runtime_error(exception, "Could not construct");
                  __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
                }

                mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::TypeRef>(Mutable, v15, v10);
                CFRelease(v15);
              }

              else
              {
                v33 = 0;
                mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::TypeRef>(Mutable, 0, v10);
              }

              if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v36.__r_.__value_.__l.__data_);
              }

              CFRelease(v10);
            }
          }
        }
      }

      else
      {
        if (v7 <= 1869638758)
        {
          if (v7 > 1852793890)
          {
            if (v7 == 1852793891)
            {
              goto LABEL_68;
            }

            v12 = 1853059619;
            goto LABEL_37;
          }

          if (v7 != 1684370979)
          {
            v12 = 1768189556;
            goto LABEL_37;
          }

LABEL_39:
          if (AMCP::is_base_of(0x61706C67, stock_class_id))
          {
            memset(&v36, 0, sizeof(v36));
            AMCP::Null_Object_Description::make_object_list_description(v37, this, (v5 + 8), &v36);
            v10 = v37[0];
            if (v37[0])
            {
              CFRetain(v37[0]);
              CFRelease(v10);
            }

            v11 = v36.__r_.__value_.__r.__words[0];
            if (!v36.__r_.__value_.__r.__words[0])
            {
              goto LABEL_54;
            }

            v36.__r_.__value_.__l.__size_ = v36.__r_.__value_.__r.__words[0];
            goto LABEL_53;
          }

          goto LABEL_68;
        }

        if (v7 <= 1870098033)
        {
          if (v7 == 1869638759)
          {
            goto LABEL_68;
          }

          v12 = 1870097955;
          goto LABEL_37;
        }

        if (v7 != 1870098034)
        {
          if (v7 == 1886152483)
          {
            v32 = 1853189228;
            v24 = 0;
            v25 = 0;
            v23 = 0;
            std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int const*,unsigned int const*>(&v23, &v32, &v33, 1uLL);
            AMCP::Null_Object_Description::make_object_list_description(v37, this, (v5 + 8), &v23);
            v10 = v37[0];
            if (v37[0])
            {
              CFRetain(v37[0]);
              CFRelease(v10);
            }

            v11 = v23;
            if (!v23)
            {
              goto LABEL_54;
            }

            v24 = v23;
            goto LABEL_53;
          }

          if (v7 != 1937009955)
          {
            goto LABEL_38;
          }

          v8 = v5[5];
          if (v8 == 1869968496 || v8 == 1768845428)
          {
            v30 = 0;
            v31 = 0;
            v29 = 0;
            AMCP::Null_Object_Description::make_object_list_description(v37, this, (v5 + 8), &v29);
            v10 = v37[0];
            if (v37[0])
            {
              CFRetain(v37[0]);
              CFRelease(v10);
            }

            v11 = v29;
            if (v29)
            {
              v30 = v29;
              goto LABEL_53;
            }

            goto LABEL_54;
          }
        }
      }

LABEL_68:
      v5 = *v5;
    }

    while (v5);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a1, Mutable);
  if (Mutable)
  {
    CFRelease(Mutable);
  }

  std::__hash_table<std::__hash_value_type<AMCP::Address,AMCP::Thing>,std::__unordered_map_hasher<AMCP::Address,std::__hash_value_type<AMCP::Address,AMCP::Thing>,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,true>,std::__unordered_map_equal<AMCP::Address,std::__hash_value_type<AMCP::Address,AMCP::Thing>,AMCP::Address::Is_Exact_Match,AMCP::Address::Hash,true>,std::allocator<std::__hash_value_type<AMCP::Address,AMCP::Thing>>>::__deallocate_node(v20);
  v16 = v19;
  v19 = 0;
  if (v16)
  {
    operator delete(v16);
  }

  if (v22)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v22);
  }
}

void AMCP::Null_Object_Description::make_object_list_description(void *a1, uint64_t a2, uint64_t a3, unsigned int **a4)
{
  *a1 = 0;
  if (*(a3 + 32))
  {
    v8 = AMCP::Implementation::get_type_marker<std::vector<unsigned int>>();
    v9 = *(a3 + 32);
    *&v30 = 0;
    if (v9)
    {
      v9(3, a3, 0, &v30);
      v9 = v30;
    }

    if (v9 == v8)
    {
      *&v30 = v8;
      v10 = (*(a3 + 32))(4, a3, 0, &v30);
      v29 = 0;
      v28 = 0uLL;
      if (v10)
      {
        v11 = *v10;
        v12 = v10[1];
        v13 = (v12 - *v10) >> 2;
      }

      else
      {
        v11 = 0;
        v12 = 0;
        v13 = 0;
      }

      std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(&v28, v11, v12, v13);
    }

    else
    {
      *&v28 = AMCP::Implementation::get_type_marker<std::vector<unsigned int>>();
      v30 = 0u;
      *v31 = 0u;
      v32 = 0;
      (*(a3 + 32))(6, a3, &v30, &v28);
      if (v32)
      {
        *&v28 = v8;
        v14 = v32(4, &v30, 0, &v28);
        v29 = 0;
        v28 = 0uLL;
        if (v14)
        {
          v15 = *v14;
          v16 = v14[1];
        }

        else
        {
          v15 = 0;
          v16 = 0;
        }

        std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(&v28, v15, v16, (v16 - v15) >> 2);
      }

      else
      {
        v28 = 0uLL;
        v29 = 0;
        std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(&v28, 0, 0, 0);
      }

      if (v32)
      {
        v32(0, &v30, 0, 0);
      }
    }

    v17 = *(&v28 + 1);
    v18 = v28;
    if (v28 != *(&v28 + 1))
    {
      v26 = a1;
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E695E9C8]);
      v20 = v18;
      do
      {
        AMCP::Object::Object(&v30, *(a2 + 32), *v20);
        if (v31[1])
        {
          if (v31[1]->__shared_owners_ != -1)
          {
            stock_class_id = AMCP::Object::get_stock_class_id(&v30);
            v24 = *a4;
            v23 = a4[1];
            if (*a4 != v23)
            {
              v25 = stock_class_id;
              while ((AMCP::is_base_of(*v24, v25) & 1) == 0)
              {
                if (++v24 == v23)
                {
                  v24 = v23;
                  break;
                }
              }

              v23 = a4[1];
            }

            if (v24 == v23)
            {
              AMCP::Null_Object_Description::create(&cf, &v30, v22);
              if (cf)
              {
                mcp_applesauce::CF::Array_Builder::append_value<applesauce::CF::DictionaryRef>(Mutable, cf);
                if (cf)
                {
                  CFRelease(cf);
                }
              }
            }
          }

          *&v30 = &unk_1F5964268;
          if (v31[1])
          {
            std::__shared_weak_count::__release_weak(v31[1]);
          }
        }

        else
        {
          *&v30 = &unk_1F5964268;
        }

        ++v20;
      }

      while (v20 != v17);
      mcp_applesauce::CF::Array_Builder::copy_array(&v30, Mutable);
      *v26 = v30;
      if (Mutable)
      {
        CFRelease(Mutable);
      }
    }

    if (v18)
    {
      operator delete(v18);
    }
  }
}

void sub_1DE734014(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  AMCP::Thing::~Thing(va);
  __clang_call_terminate(a1);
}

void AMCP::Null_Object_Description::create_clock(const void **this@<X0>, const void **a2@<X1>, const applesauce::CF::StringRef *a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  v6 = a3;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
  v37 = 0x676C6F62636C6173;
  v38 = 0;
  AMCP::Address::to_string(&__p, &v37, 0x676C6F62636C6173);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if (p_p)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = __p.__r_.__value_.__l.__size_;
    }

    v13 = CFStringCreateWithBytes(0, p_p, size, 0x8000100u, 0);
    v40 = v13;
    if (!v13)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v13 = 0;
    v40 = 0;
  }

  valuePtr = 1633905771;
  v15 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v15)
  {
    v32 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v32, "Could not construct");
    __cxa_throw(v32, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(Mutable, v13, v15);
  CFRelease(v15);
  if (v13)
  {
    CFRelease(v13);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v37 = 0x676C6F626C6E616DLL;
  v38 = 0;
  AMCP::Address::to_string(&__p, &v37, 0x676C6F626C6E616DLL);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v16 = &__p;
  }

  else
  {
    v16 = __p.__r_.__value_.__r.__words[0];
  }

  if (v16)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v17 = __p.__r_.__value_.__l.__size_;
    }

    v18 = CFStringCreateWithBytes(0, v16, v17, 0x8000100u, 0);
    v40 = v18;
    if (!v18)
    {
      v35 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v35, "Could not construct");
      __cxa_throw(v35, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::StringRef>(Mutable, v18, *this);
    CFRelease(v18);
  }

  else
  {
    v40 = 0;
    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::StringRef>(Mutable, 0, *this);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v37 = 0x676C6F6275696420;
  v38 = 0;
  AMCP::Address::to_string(&__p, &v37, 0x676C6F6275696420);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v19 = &__p;
  }

  else
  {
    v19 = __p.__r_.__value_.__r.__words[0];
  }

  if (v19)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v20 = __p.__r_.__value_.__l.__size_;
    }

    v21 = CFStringCreateWithBytes(0, v19, v20, 0x8000100u, 0);
    v40 = v21;
    if (!v21)
    {
      v36 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v36, "Could not construct");
      __cxa_throw(v36, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::StringRef>(Mutable, v21, *a2);
    CFRelease(v21);
  }

  else
  {
    v40 = 0;
    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::StringRef>(Mutable, 0, *a2);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v37 = 0x696E70746C746E63;
  v38 = 0;
  AMCP::Address::to_string(&__p, &v37, 0x696E70746C746E63);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v22 = &__p;
  }

  else
  {
    v22 = __p.__r_.__value_.__r.__words[0];
  }

  if (v22)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v23 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v23 = __p.__r_.__value_.__l.__size_;
    }

    v24 = CFStringCreateWithBytes(0, v22, v23, 0x8000100u, 0);
    v40 = v24;
    if (!v24)
    {
      v25 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v25, "Could not construct");
      __cxa_throw(v25, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v24 = 0;
    v40 = 0;
  }

  valuePtr = v6;
  v26 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v26)
  {
    v33 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v33, "Could not construct");
    __cxa_throw(v33, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(Mutable, v24, v26);
  CFRelease(v26);
  if (v24)
  {
    CFRelease(v24);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v37 = 0x6F7574706C746E63;
  v38 = 0;
  AMCP::Address::to_string(&__p, &v37, 0x6F7574706C746E63);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v27 = &__p;
  }

  else
  {
    v27 = __p.__r_.__value_.__r.__words[0];
  }

  if (v27)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v28 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v28 = __p.__r_.__value_.__l.__size_;
    }

    v29 = CFStringCreateWithBytes(0, v27, v28, 0x8000100u, 0);
    v40 = v29;
    if (!v29)
    {
      v30 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v30, "Could not construct");
      __cxa_throw(v30, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v29 = 0;
    v40 = 0;
  }

  valuePtr = a4;
  v31 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v31)
  {
    v34 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v34, "Could not construct");
    __cxa_throw(v34, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(Mutable, v29, v31);
  CFRelease(v31);
  if (v29)
  {
    CFRelease(v29);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a5, Mutable);
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

void sub_1DE734650(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef(va);
  __clang_call_terminate(a1);
}

void AMCP::Null_Object_Description::create_device(const void **this@<X0>, const void **a2@<X1>, const applesauce::CF::StringRef *a3@<X2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, int a7@<W6>, void *a8@<X8>)
{
  AMCP::Null_Object_Description::create_clock(this, a2, a3, a5, &theDict);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict.__r_.__value_.__l.__data_);
  if (theDict.__r_.__value_.__r.__words[0])
  {
    CFRelease(theDict.__r_.__value_.__l.__data_);
  }

  v37 = 0x676C6F62636C6173;
  v38 = 0;
  AMCP::Address::to_string(&theDict, &v37, 0x676C6F62636C6173);
  if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_theDict = &theDict;
  }

  else
  {
    p_theDict = theDict.__r_.__value_.__r.__words[0];
  }

  if (p_theDict)
  {
    if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(theDict.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = theDict.__r_.__value_.__l.__size_;
    }

    v15 = CFStringCreateWithBytes(0, p_theDict, size, 0x8000100u, 0);
    v40 = v15;
    if (!v15)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v15 = 0;
    v40 = 0;
  }

  valuePtr = 1633969526;
  v17 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v17)
  {
    v33 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v33, "Could not construct");
    __cxa_throw(v33, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(MutableCopy, v15, v17);
  CFRelease(v17);
  if (v15)
  {
    CFRelease(v15);
  }

  if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(theDict.__r_.__value_.__l.__data_);
  }

  v37 = 0x696E707473616674;
  v38 = 0;
  AMCP::Address::to_string(&theDict, &v37, 0x696E707473616674);
  if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v18 = &theDict;
  }

  else
  {
    v18 = theDict.__r_.__value_.__r.__words[0];
  }

  if (v18)
  {
    if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v19 = HIBYTE(theDict.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v19 = theDict.__r_.__value_.__l.__size_;
    }

    v20 = CFStringCreateWithBytes(0, v18, v19, 0x8000100u, 0);
    v40 = v20;
    if (!v20)
    {
      v21 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v21, "Could not construct");
      __cxa_throw(v21, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v20 = 0;
    v40 = 0;
  }

  valuePtr = a4;
  v22 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v22)
  {
    v34 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v34, "Could not construct");
    __cxa_throw(v34, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(MutableCopy, v20, v22);
  CFRelease(v22);
  if (v20)
  {
    CFRelease(v20);
  }

  if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(theDict.__r_.__value_.__l.__data_);
  }

  v37 = 0x6F75747073616674;
  v38 = 0;
  AMCP::Address::to_string(&theDict, &v37, 0x6F75747073616674);
  if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v23 = &theDict;
  }

  else
  {
    v23 = theDict.__r_.__value_.__r.__words[0];
  }

  if (v23)
  {
    if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v24 = HIBYTE(theDict.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v24 = theDict.__r_.__value_.__l.__size_;
    }

    v25 = CFStringCreateWithBytes(0, v23, v24, 0x8000100u, 0);
    v40 = v25;
    if (!v25)
    {
      v26 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v26, "Could not construct");
      __cxa_throw(v26, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v25 = 0;
    v40 = 0;
  }

  valuePtr = a6;
  v27 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v27)
  {
    v35 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v35, "Could not construct");
    __cxa_throw(v35, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(MutableCopy, v25, v27);
  CFRelease(v27);
  if (v25)
  {
    CFRelease(v25);
  }

  if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(theDict.__r_.__value_.__l.__data_);
  }

  v37 = 0x676C6F627472616ELL;
  v38 = 0;
  AMCP::Address::to_string(&theDict, &v37, 0x676C6F627472616ELL);
  if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v28 = &theDict;
  }

  else
  {
    v28 = theDict.__r_.__value_.__r.__words[0];
  }

  if (v28)
  {
    if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v29 = HIBYTE(theDict.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v29 = theDict.__r_.__value_.__l.__size_;
    }

    v30 = CFStringCreateWithBytes(0, v28, v29, 0x8000100u, 0);
    v40 = v30;
    if (!v30)
    {
      v31 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v31, "Could not construct");
      __cxa_throw(v31, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v30 = 0;
    v40 = 0;
  }

  valuePtr = a7;
  v32 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v32)
  {
    v36 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v36, "Could not construct");
    __cxa_throw(v36, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(MutableCopy, v30, v32);
  CFRelease(v32);
  if (v30)
  {
    CFRelease(v30);
  }

  if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(theDict.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a8, MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

void sub_1DE734C78(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef(va);
  __clang_call_terminate(a1);
}

void AMCP::Null_Object_Description::create_stream(const void **a1, int a2, int a3, int a4)
{
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
  v45.__r_.__value_.__r.__words[0] = 0x676C6F626C6E616DLL;
  LODWORD(v45.__r_.__value_.__r.__words[1]) = 0;
  AMCP::Address::to_string(__p, &v45, 0x676C6F626C6E616DLL);
  if ((SBYTE7(v40) & 0x80u) == 0)
  {
    v9 = __p;
  }

  else
  {
    v9 = __p[0];
  }

  if (v9)
  {
    if ((SBYTE7(v40) & 0x80u) == 0)
    {
      v10 = BYTE7(v40);
    }

    else
    {
      v10 = __p[1];
    }

    v11 = CFStringCreateWithBytes(0, v9, v10, 0x8000100u, 0);
    v43 = v11;
    if (!v11)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::StringRef>(Mutable, v11, *a1);
    CFRelease(v11);
  }

  else
  {
    v43 = 0;
    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::StringRef>(Mutable, 0, *a1);
  }

  if (SBYTE7(v40) < 0)
  {
    operator delete(__p[0]);
  }

  v45.__r_.__value_.__r.__words[0] = 0x676C6F62636C6173;
  LODWORD(v45.__r_.__value_.__r.__words[1]) = 0;
  AMCP::Address::to_string(__p, &v45, 0x676C6F62636C6173);
  if ((SBYTE7(v40) & 0x80u) == 0)
  {
    v12 = __p;
  }

  else
  {
    v12 = __p[0];
  }

  if (v12)
  {
    if ((SBYTE7(v40) & 0x80u) == 0)
    {
      v13 = BYTE7(v40);
    }

    else
    {
      v13 = __p[1];
    }

    v14 = CFStringCreateWithBytes(0, v12, v13, 0x8000100u, 0);
    v43 = v14;
    if (!v14)
    {
      v15 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v15, "Could not construct");
      __cxa_throw(v15, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v14 = 0;
    v43 = 0;
  }

  LODWORD(valuePtr) = 1634956402;
  v16 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  v46 = v16;
  if (v16)
  {
    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(Mutable, v14, v16);
    CFRelease(v16);
    if (v14)
    {
      CFRelease(v14);
    }

    if (SBYTE7(v40) < 0)
    {
      operator delete(__p[0]);
    }

    v43 = 0x676C6F6273646972;
    v44 = 0;
    AMCP::Address::to_string(&v45, &v43, 0x676C6F6273646972);
    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v17 = &v45;
    }

    else
    {
      v17 = v45.__r_.__value_.__r.__words[0];
    }

    if (v17)
    {
      if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = HIBYTE(v45.__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = v45.__r_.__value_.__l.__size_;
      }

      v19 = CFStringCreateWithBytes(0, v17, size, 0x8000100u, 0);
      v46 = v19;
      if (!v19)
      {
        v20 = __cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v20, "Could not construct");
        __cxa_throw(v20, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
      }
    }

    else
    {
      v19 = 0;
      v46 = 0;
    }

    *__p = 0u;
    v40 = 0u;
    LODWORD(__p[0]) = a2;
    v41 = AMCP::Implementation::In_Place_Storage<AMCP::Direction>::dispatch;
    AMCP::make_description_from_thing(&valuePtr, __p);
    v21 = valuePtr;
    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::TypeRef>(Mutable, v19, valuePtr);
    if (v21)
    {
      CFRelease(v21);
    }

    if (v41)
    {
      v41(0, __p, 0, 0);
    }

    if (v19)
    {
      CFRelease(v19);
    }

    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v45.__r_.__value_.__l.__data_);
    }

    v45.__r_.__value_.__r.__words[0] = 0x676C6F627363686ELL;
    LODWORD(v45.__r_.__value_.__r.__words[1]) = 0;
    AMCP::Address::to_string(__p, &v45, 0x676C6F627363686ELL);
    if ((SBYTE7(v40) & 0x80u) == 0)
    {
      v22 = __p;
    }

    else
    {
      v22 = __p[0];
    }

    if (v22)
    {
      if ((SBYTE7(v40) & 0x80u) == 0)
      {
        v23 = BYTE7(v40);
      }

      else
      {
        v23 = __p[1];
      }

      v24 = CFStringCreateWithBytes(0, v22, v23, 0x8000100u, 0);
      v43 = v24;
      if (!v24)
      {
        v25 = __cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v25, "Could not construct");
        __cxa_throw(v25, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
      }
    }

    else
    {
      v24 = 0;
      v43 = 0;
    }

    LODWORD(valuePtr) = a3;
    v26 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    v46 = v26;
    if (v26)
    {
      mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(Mutable, v24, v26);
      CFRelease(v26);
      if (v24)
      {
        CFRelease(v24);
      }

      if (SBYTE7(v40) < 0)
      {
        operator delete(__p[0]);
      }

      v45.__r_.__value_.__r.__words[0] = 0x676C6F627465726DLL;
      LODWORD(v45.__r_.__value_.__r.__words[1]) = 0;
      AMCP::Address::to_string(__p, &v45, 0x676C6F627465726DLL);
      if ((SBYTE7(v40) & 0x80u) == 0)
      {
        v27 = __p;
      }

      else
      {
        v27 = __p[0];
      }

      if (v27)
      {
        if ((SBYTE7(v40) & 0x80u) == 0)
        {
          v28 = BYTE7(v40);
        }

        else
        {
          v28 = __p[1];
        }

        v29 = CFStringCreateWithBytes(0, v27, v28, 0x8000100u, 0);
        v43 = v29;
        if (!v29)
        {
          v30 = __cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v30, "Could not construct");
          __cxa_throw(v30, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
        }
      }

      else
      {
        v29 = 0;
        v43 = 0;
      }

      LODWORD(valuePtr) = a4;
      v31 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      v46 = v31;
      if (v31)
      {
        mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(Mutable, v29, v31);
        CFRelease(v31);
        if (v29)
        {
          CFRelease(v29);
        }

        if (SBYTE7(v40) < 0)
        {
          operator delete(__p[0]);
        }

        v43 = 0x676C6F62666D6174;
        v44 = 0;
        AMCP::Address::to_string(&v45, &v43, 0x676C6F62666D6174);
        if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v32 = &v45;
        }

        else
        {
          v32 = v45.__r_.__value_.__r.__words[0];
        }

        if (v32)
        {
          if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            v33 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
          }

          else
          {
            v33 = v45.__r_.__value_.__l.__size_;
          }

          v46 = CFStringCreateWithBytes(0, v32, v33, 0x8000100u, 0);
          if (!v46)
          {
            v34 = __cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v34, "Could not construct");
            __cxa_throw(v34, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
          }
        }

        else
        {
          v46 = 0;
        }

        *__p = 0u;
        v40 = 0u;
        v41 = AMCP::Implementation::Outboard_Storage<CA::StreamDescription>::dispatch;
        operator new();
      }

      v37 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v37, "Could not construct");
      __cxa_throw(v37, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    v36 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v36, "Could not construct");
    __cxa_throw(v36, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  v35 = __cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(v35, "Could not construct");
  __cxa_throw(v35, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
}

void sub_1DE735610(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef(va);
  __clang_call_terminate(a1);
}

void AMCP::Null_Object_Description::attach_stream_list(CFDictionaryRef *a1@<X0>, int a2@<W1>, const void **a3@<X2>, void *a4@<X8>)
{
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *a1);
  if (a2 == 1)
  {
    v9 = 1768845428;
  }

  else
  {
    v9 = 1869968496;
  }

  v14[0] = 1937009955;
  v14[1] = v9;
  v14[2] = 0;
  AMCP::Address::to_string(&__p, v14, v8);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if (p_p)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = __p.__r_.__value_.__l.__size_;
    }

    v12 = CFStringCreateWithBytes(0, p_p, size, 0x8000100u, 0);
    v16 = v12;
    if (!v12)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::ArrayRef>(MutableCopy, v12, *a3);
    CFRelease(v12);
  }

  else
  {
    v16 = 0;
    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::ArrayRef>(MutableCopy, 0, *a3);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a4, MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

void sub_1DE735850(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef(va);
  __clang_call_terminate(a1);
}

void AMCP::Null_Object_Description::create_slider_control(int a1@<W0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, std::string::size_type *a5@<X4>, int a6@<W5>, void *a7@<X8>)
{
  AMCP::Null_Object_Description::create_control(&theDict, a1, a2, a3, a4);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict.__r_.__value_.__l.__data_);
  if (theDict.__r_.__value_.__r.__words[0])
  {
    CFRelease(theDict.__r_.__value_.__l.__data_);
  }

  __p.__r_.__value_.__r.__words[0] = 0x676C6F6273647276;
  LODWORD(__p.__r_.__value_.__r.__words[1]) = 0;
  AMCP::Address::to_string(&theDict, &__p, 0x676C6F6273647276);
  if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_theDict = &theDict;
  }

  else
  {
    p_theDict = theDict.__r_.__value_.__r.__words[0];
  }

  if (p_theDict)
  {
    if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(theDict.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = theDict.__r_.__value_.__l.__size_;
    }

    v13 = CFStringCreateWithBytes(0, p_theDict, size, 0x8000100u, 0);
    v26 = v13;
    if (!v13)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v13 = 0;
    v26 = 0;
  }

  LODWORD(valuePtr) = a6;
  v15 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  v29 = v15;
  if (!v15)
  {
    v21 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v21, "Could not construct");
    __cxa_throw(v21, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(MutableCopy, v13, v15);
  CFRelease(v15);
  if (v13)
  {
    CFRelease(v13);
  }

  if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(theDict.__r_.__value_.__l.__data_);
  }

  v26 = 0x676C6F6273647272;
  v27 = 0;
  AMCP::Address::to_string(&__p, &v26, 0x676C6F6273647272);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if (p_p)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v17 = __p.__r_.__value_.__l.__size_;
    }

    v18 = CFStringCreateWithBytes(0, p_p, v17, 0x8000100u, 0);
    v29 = v18;
    if (!v18)
    {
      v19 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v19, "Could not construct");
      __cxa_throw(v19, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v18 = 0;
    v29 = 0;
  }

  v23 = 0;
  theDict.__r_.__value_.__r.__words[0] = *a5;
  *&theDict.__r_.__value_.__r.__words[1] = 0uLL;
  v24 = AMCP::Implementation::In_Place_Storage<std::tuple<unsigned int,unsigned int>>::dispatch;
  AMCP::make_description_from_thing(&valuePtr, &theDict);
  v20 = valuePtr;
  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::TypeRef>(MutableCopy, v18, valuePtr);
  if (v20)
  {
    CFRelease(v20);
  }

  if (v24)
  {
    v24(0, &theDict, 0, 0);
  }

  if (v18)
  {
    CFRelease(v18);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a7, MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

void AMCP::Null_Object_Description::create_control(AMCP::Null_Object_Description *this, int a2, int a3, int a4, int a5)
{
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9E0], MEMORY[0x1E695E9F0]);
  v35 = 0x676C6F62636C6173;
  v36 = 0;
  AMCP::Address::to_string(&__p, &v35, 0x676C6F62636C6173);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if (p_p)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = __p.__r_.__value_.__l.__size_;
    }

    v13 = CFStringCreateWithBytes(0, p_p, size, 0x8000100u, 0);
    v38 = v13;
    if (!v13)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v13 = 0;
    v38 = 0;
  }

  valuePtr = a2;
  v15 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v15)
  {
    v32 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v32, "Could not construct");
    __cxa_throw(v32, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(Mutable, v13, v15);
  CFRelease(v15);
  if (v13)
  {
    CFRelease(v13);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v35 = 0x676C6F6263736370;
  v36 = 0;
  AMCP::Address::to_string(&__p, &v35, 0x676C6F6263736370);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v16 = &__p;
  }

  else
  {
    v16 = __p.__r_.__value_.__r.__words[0];
  }

  if (v16)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v17 = __p.__r_.__value_.__l.__size_;
    }

    v18 = CFStringCreateWithBytes(0, v16, v17, 0x8000100u, 0);
    v38 = v18;
    if (!v18)
    {
      v19 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v19, "Could not construct");
      __cxa_throw(v19, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v18 = 0;
    v38 = 0;
  }

  valuePtr = a3;
  v20 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v20)
  {
    v33 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v33, "Could not construct");
    __cxa_throw(v33, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(Mutable, v18, v20);
  CFRelease(v20);
  if (v18)
  {
    CFRelease(v18);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v35 = 0x676C6F6263656C6DLL;
  v36 = 0;
  AMCP::Address::to_string(&__p, &v35, 0x676C6F6263656C6DLL);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v21 = &__p;
  }

  else
  {
    v21 = __p.__r_.__value_.__r.__words[0];
  }

  if (v21)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v22 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v22 = __p.__r_.__value_.__l.__size_;
    }

    v23 = CFStringCreateWithBytes(0, v21, v22, 0x8000100u, 0);
    v38 = v23;
    if (!v23)
    {
      v24 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v24, "Could not construct");
      __cxa_throw(v24, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v23 = 0;
    v38 = 0;
  }

  valuePtr = a4;
  v25 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v25)
  {
    v34 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v34, "Could not construct");
    __cxa_throw(v34, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(Mutable, v23, v25);
  CFRelease(v25);
  if (v23)
  {
    CFRelease(v23);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v35 = 0x676C6F626372646FLL;
  v36 = 0;
  AMCP::Address::to_string(&__p, &v35, 0x676C6F626372646FLL);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v26 = &__p;
  }

  else
  {
    v26 = __p.__r_.__value_.__r.__words[0];
  }

  if (v26)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v27 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v27 = __p.__r_.__value_.__l.__size_;
    }

    v28 = CFStringCreateWithBytes(0, v26, v27, 0x8000100u, 0);
    v38 = v28;
    if (!v28)
    {
      v29 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v29, "Could not construct");
      __cxa_throw(v29, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v28 = 0;
    v38 = 0;
  }

  v30 = MEMORY[0x1E695E4C8];
  if (!a5)
  {
    v30 = MEMORY[0x1E695E4B8];
  }

  v31 = *v30;
  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::BooleanRef>(Mutable, v28, *v30);
  if (v31)
  {
    CFRelease(v31);
  }

  if (v28)
  {
    CFRelease(v28);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(this, Mutable);
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

void sub_1DE73613C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef(va);
  __clang_call_terminate(a1);
}

void AMCP::Null_Object_Description::create_level_control(int a1@<W0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, double *a5@<X4>, void *a6@<X8>, float a7@<S0>)
{
  AMCP::Null_Object_Description::create_control(&theDict, a1, a2, a3, a4);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict.__r_.__value_.__l.__data_);
  if (theDict.__r_.__value_.__r.__words[0])
  {
    CFRelease(theDict.__r_.__value_.__l.__data_);
  }

  __p.__r_.__value_.__r.__words[0] = 0x676C6F626C637376;
  LODWORD(__p.__r_.__value_.__r.__words[1]) = 0;
  AMCP::Address::to_string(&theDict, &__p, 0x676C6F626C637376);
  if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_theDict = &theDict;
  }

  else
  {
    p_theDict = theDict.__r_.__value_.__r.__words[0];
  }

  if (p_theDict)
  {
    if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(theDict.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = theDict.__r_.__value_.__l.__size_;
    }

    v13 = CFStringCreateWithBytes(0, p_theDict, size, 0x8000100u, 0);
    v34 = v13;
    if (!v13)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v13 = 0;
    v34 = 0;
  }

  v15 = a7 - *a5;
  v16 = a5[1] - *a5;
  *&valuePtr = v15 / v16;
  v17 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  v37 = v17;
  if (!v17)
  {
    v28 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v28, "Could not construct");
    __cxa_throw(v28, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(MutableCopy, v13, v17);
  CFRelease(v17);
  if (v13)
  {
    CFRelease(v13);
  }

  if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(theDict.__r_.__value_.__l.__data_);
  }

  __p.__r_.__value_.__r.__words[0] = 0x676C6F626C636476;
  LODWORD(__p.__r_.__value_.__r.__words[1]) = 0;
  AMCP::Address::to_string(&theDict, &__p, 0x676C6F626C636476);
  if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v18 = &theDict;
  }

  else
  {
    v18 = theDict.__r_.__value_.__r.__words[0];
  }

  if (v18)
  {
    if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v19 = HIBYTE(theDict.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v19 = theDict.__r_.__value_.__l.__size_;
    }

    v20 = CFStringCreateWithBytes(0, v18, v19, 0x8000100u, 0);
    v34 = v20;
    if (!v20)
    {
      v21 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v21, "Could not construct");
      __cxa_throw(v21, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v20 = 0;
    v34 = 0;
  }

  *&valuePtr = a7;
  v22 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  v37 = v22;
  if (!v22)
  {
    v29 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v29, "Could not construct");
    __cxa_throw(v29, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(MutableCopy, v20, v22);
  CFRelease(v22);
  if (v20)
  {
    CFRelease(v20);
  }

  if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(theDict.__r_.__value_.__l.__data_);
  }

  v34 = 0x676C6F626C636472;
  v35 = 0;
  AMCP::Address::to_string(&__p, &v34, 0x676C6F626C636472);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if (p_p)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v24 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v24 = __p.__r_.__value_.__l.__size_;
    }

    v25 = CFStringCreateWithBytes(0, p_p, v24, 0x8000100u, 0);
    v37 = v25;
    if (!v25)
    {
      v26 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v26, "Could not construct");
      __cxa_throw(v26, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v25 = 0;
    v37 = 0;
  }

  theDict.__r_.__value_.__r.__words[2] = 0;
  v31 = 0;
  *&theDict.__r_.__value_.__l.__data_ = *a5;
  v32 = AMCP::Implementation::In_Place_Storage<CA::ValueRange>::dispatch;
  AMCP::make_description_from_thing(&valuePtr, &theDict);
  v27 = valuePtr;
  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::TypeRef>(MutableCopy, v25, valuePtr);
  if (v27)
  {
    CFRelease(v27);
  }

  if (v32)
  {
    v32(0, &theDict, 0, 0);
  }

  if (v25)
  {
    CFRelease(v25);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a6, MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

void AMCP::Null_Object_Description::create_BOOLean_control(AMCP::Null_Object_Description *this@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, void *a6@<X8>)
{
  AMCP::Null_Object_Description::create_control(&theDict, this, a2, a3, a4);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict.__r_.__value_.__l.__data_);
  if (theDict.__r_.__value_.__r.__words[0])
  {
    CFRelease(theDict.__r_.__value_.__l.__data_);
  }

  v15 = 0x676C6F626263766CLL;
  v16 = 0;
  AMCP::Address::to_string(&theDict, &v15, 0x676C6F626263766CLL);
  if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_theDict = &theDict;
  }

  else
  {
    p_theDict = theDict.__r_.__value_.__r.__words[0];
  }

  if (p_theDict)
  {
    if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(theDict.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = theDict.__r_.__value_.__l.__size_;
    }

    v11 = CFStringCreateWithBytes(0, p_theDict, size, 0x8000100u, 0);
    v18 = v11;
    if (!v11)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v11 = 0;
    v18 = 0;
  }

  v13 = MEMORY[0x1E695E4C8];
  if (!a5)
  {
    v13 = MEMORY[0x1E695E4B8];
  }

  v14 = *v13;
  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::BooleanRef>(MutableCopy, v11, *v13);
  if (v14)
  {
    CFRelease(v14);
  }

  if (v11)
  {
    CFRelease(v11);
  }

  if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(theDict.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a6, MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

void sub_1DE73684C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef(va);
  __clang_call_terminate(a1);
}

void AMCP::Null_Object_Description::create_selector_control(int a1@<W0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, uint64_t *a5@<X4>, int a6@<W5>, void *a7@<X8>)
{
  v35[1] = *MEMORY[0x1E69E9840];
  AMCP::Null_Object_Description::create_control(theDict, a1, a2, a3, a4);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict[0]);
  if (theDict[0])
  {
    CFRelease(theDict[0]);
  }

  v31 = 0x676C6F6273636369;
  v32 = 0;
  AMCP::Address::to_string(&__p, &v31, 0x676C6F6273636369);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if (p_p)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = __p.__r_.__value_.__l.__size_;
    }

    v13 = CFStringCreateWithBytes(0, p_p, size, 0x8000100u, 0);
    v34 = v13;
    if (!v13)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v13 = 0;
    v34 = 0;
  }

  LODWORD(theDict[0]) = a6;
  v35[0] = CFNumberCreate(0, kCFNumberIntType, theDict);
  if (!v35[0])
  {
    v27 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v27, "Could not construct");
    __cxa_throw(v27, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  std::vector<void const*>::vector[abi:ne200100](theDict, 1uLL);
  *theDict[0] = v35[0];
  CFArray = applesauce::CF::details::make_CFArrayRef<void const*>(theDict[0], theDict[1]);
  if (theDict[0])
  {
    theDict[1] = theDict[0];
    operator delete(theDict[0]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::ArrayRef>(MutableCopy, v13, CFArray);
  if (CFArray)
  {
    CFRelease(CFArray);
  }

  if (v35[0])
  {
    CFRelease(v35[0]);
  }

  if (v13)
  {
    CFRelease(v13);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  __p.__r_.__value_.__r.__words[0] = 0x676C6F627363636DLL;
  LODWORD(__p.__r_.__value_.__r.__words[1]) = 0;
  AMCP::Address::to_string(theDict, &__p, 0x676C6F627363636DLL);
  if ((SBYTE7(v29) & 0x80u) == 0)
  {
    v16 = theDict;
  }

  else
  {
    v16 = theDict[0];
  }

  if (v16)
  {
    if ((SBYTE7(v29) & 0x80u) == 0)
    {
      v17 = BYTE7(v29);
    }

    else
    {
      v17 = theDict[1];
    }

    v18 = CFStringCreateWithBytes(0, v16, v17, 0x8000100u, 0);
    v31 = v18;
    if (!v18)
    {
      v19 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v19, "Could not construct");
      __cxa_throw(v19, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v18 = 0;
    v31 = 0;
  }

  v20 = *MEMORY[0x1E695E4B8];
  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::BooleanRef>(MutableCopy, v18, *MEMORY[0x1E695E4B8]);
  if (v20)
  {
    CFRelease(v20);
  }

  if (v18)
  {
    CFRelease(v18);
  }

  if (SBYTE7(v29) < 0)
  {
    operator delete(theDict[0]);
  }

  v31 = 0x676C6F6273636169;
  v32 = 0;
  AMCP::Address::to_string(&__p, &v31, 0x676C6F6273636169);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v21 = &__p;
  }

  else
  {
    v21 = __p.__r_.__value_.__r.__words[0];
  }

  if (v21)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v22 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v22 = __p.__r_.__value_.__l.__size_;
    }

    v23 = CFStringCreateWithBytes(0, v21, v22, 0x8000100u, 0);
    v34 = v23;
    if (!v23)
    {
      v24 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v24, "Could not construct");
      __cxa_throw(v24, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v23 = 0;
    v34 = 0;
  }

  v30 = 0;
  *theDict = 0u;
  v29 = 0u;
  std::vector<std::tuple<unsigned int,unsigned int,applesauce::CF::StringRef>>::__init_with_size[abi:ne200100]<std::tuple<unsigned int,unsigned int,applesauce::CF::StringRef>*,std::tuple<unsigned int,unsigned int,applesauce::CF::StringRef>*>(theDict, *a5, a5[1], (a5[1] - *a5) >> 4);
  v30 = AMCP::Implementation::In_Place_Storage<std::vector<std::tuple<unsigned int,unsigned int,applesauce::CF::StringRef>>>::dispatch;
  AMCP::make_description_from_thing(v35, theDict);
  v25 = v35[0];
  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::TypeRef>(MutableCopy, v23, v35[0]);
  if (v25)
  {
    CFRelease(v25);
  }

  if (v30)
  {
    v30(0, theDict, 0, 0);
  }

  if (v23)
  {
    CFRelease(v23);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a7, MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }

  v26 = *MEMORY[0x1E69E9840];
}

void sub_1DE736CF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2)
  {
    applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef((v15 - 72));
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void AMCP::Null_Object_Description::create_multi_selector_control(int a1@<W0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, void *a7@<X8>)
{
  AMCP::Null_Object_Description::create_control(theDict, a1, a2, a3, a4);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict[0]);
  if (theDict[0])
  {
    CFRelease(theDict[0]);
  }

  v30 = 0x676C6F6273636369;
  v31 = 0;
  AMCP::Address::to_string(&__p, &v30, 0x676C6F6273636369);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if (p_p)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = __p.__r_.__value_.__l.__size_;
    }

    v13 = CFStringCreateWithBytes(0, p_p, size, 0x8000100u, 0);
    v33 = v13;
    if (!v13)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v13 = 0;
    v33 = 0;
  }

  v28 = 0;
  *theDict = 0u;
  v27 = 0u;
  std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(theDict, *a6, a6[1], (a6[1] - *a6) >> 2);
  v28 = AMCP::Implementation::In_Place_Storage<std::vector<unsigned int>>::dispatch;
  AMCP::make_description_from_thing(&v29, theDict);
  v15 = v29;
  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::TypeRef>(MutableCopy, v13, v29);
  if (v15)
  {
    CFRelease(v15);
  }

  if (v28)
  {
    (v28)(0, theDict, 0, 0);
  }

  if (v13)
  {
    CFRelease(v13);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  __p.__r_.__value_.__r.__words[0] = 0x676C6F627363636DLL;
  LODWORD(__p.__r_.__value_.__r.__words[1]) = 0;
  AMCP::Address::to_string(theDict, &__p, 0x676C6F627363636DLL);
  if ((SBYTE7(v27) & 0x80u) == 0)
  {
    v16 = theDict;
  }

  else
  {
    v16 = theDict[0];
  }

  if (v16)
  {
    if ((SBYTE7(v27) & 0x80u) == 0)
    {
      v17 = BYTE7(v27);
    }

    else
    {
      v17 = theDict[1];
    }

    v18 = CFStringCreateWithBytes(0, v16, v17, 0x8000100u, 0);
    v30 = v18;
    if (!v18)
    {
      v19 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v19, "Could not construct");
      __cxa_throw(v19, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v18 = 0;
    v30 = 0;
  }

  v20 = *MEMORY[0x1E695E4C8];
  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::BooleanRef>(MutableCopy, v18, *MEMORY[0x1E695E4C8]);
  if (v20)
  {
    CFRelease(v20);
  }

  if (v18)
  {
    CFRelease(v18);
  }

  if (SBYTE7(v27) < 0)
  {
    operator delete(theDict[0]);
  }

  v30 = 0x676C6F6273636169;
  v31 = 0;
  AMCP::Address::to_string(&__p, &v30, 0x676C6F6273636169);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v21 = &__p;
  }

  else
  {
    v21 = __p.__r_.__value_.__r.__words[0];
  }

  if (v21)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v22 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v22 = __p.__r_.__value_.__l.__size_;
    }

    v23 = CFStringCreateWithBytes(0, v21, v22, 0x8000100u, 0);
    v33 = v23;
    if (!v23)
    {
      v24 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v24, "Could not construct");
      __cxa_throw(v24, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v23 = 0;
    v33 = 0;
  }

  v28 = 0;
  *theDict = 0u;
  v27 = 0u;
  std::vector<std::tuple<unsigned int,unsigned int,applesauce::CF::StringRef>>::__init_with_size[abi:ne200100]<std::tuple<unsigned int,unsigned int,applesauce::CF::StringRef>*,std::tuple<unsigned int,unsigned int,applesauce::CF::StringRef>*>(theDict, *a5, a5[1], (a5[1] - *a5) >> 4);
  v28 = AMCP::Implementation::In_Place_Storage<std::vector<std::tuple<unsigned int,unsigned int,applesauce::CF::StringRef>>>::dispatch;
  AMCP::make_description_from_thing(&v29, theDict);
  v25 = v29;
  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::TypeRef>(MutableCopy, v23, v29);
  if (v25)
  {
    CFRelease(v25);
  }

  if (v28)
  {
    (v28)(0, theDict, 0, 0);
  }

  if (v23)
  {
    CFRelease(v23);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a7, MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

void AMCP::Null_Object_Description::create_stereo_pan_control(int a1@<W0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, std::string::size_type *a5@<X4>, void *a6@<X8>, float a7@<S0>)
{
  AMCP::Null_Object_Description::create_control(&theDict, a1, a2, a3, a4);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict.__r_.__value_.__l.__data_);
  if (theDict.__r_.__value_.__r.__words[0])
  {
    CFRelease(theDict.__r_.__value_.__l.__data_);
  }

  __p.__r_.__value_.__r.__words[0] = 0x676C6F6273706376;
  LODWORD(__p.__r_.__value_.__r.__words[1]) = 0;
  AMCP::Address::to_string(&theDict, &__p, 0x676C6F6273706376);
  if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_theDict = &theDict;
  }

  else
  {
    p_theDict = theDict.__r_.__value_.__r.__words[0];
  }

  if (p_theDict)
  {
    if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(theDict.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = theDict.__r_.__value_.__l.__size_;
    }

    v13 = CFStringCreateWithBytes(0, p_theDict, size, 0x8000100u, 0);
    v26 = v13;
    if (!v13)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v13 = 0;
    v26 = 0;
  }

  *&valuePtr = a7;
  v15 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  v29 = v15;
  if (!v15)
  {
    v21 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v21, "Could not construct");
    __cxa_throw(v21, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::NumberRef>(MutableCopy, v13, v15);
  CFRelease(v15);
  if (v13)
  {
    CFRelease(v13);
  }

  if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(theDict.__r_.__value_.__l.__data_);
  }

  v26 = 0x676C6F6273706363;
  v27 = 0;
  AMCP::Address::to_string(&__p, &v26, 0x676C6F6273706363);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if (p_p)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v17 = __p.__r_.__value_.__l.__size_;
    }

    v18 = CFStringCreateWithBytes(0, p_p, v17, 0x8000100u, 0);
    v29 = v18;
    if (!v18)
    {
      v19 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v19, "Could not construct");
      __cxa_throw(v19, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }
  }

  else
  {
    v18 = 0;
    v29 = 0;
  }

  v23 = 0;
  theDict.__r_.__value_.__r.__words[0] = *a5;
  *&theDict.__r_.__value_.__r.__words[1] = 0uLL;
  v24 = AMCP::Implementation::In_Place_Storage<std::tuple<unsigned int,unsigned int>>::dispatch;
  AMCP::make_description_from_thing(&valuePtr, &theDict);
  v20 = valuePtr;
  mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::TypeRef>(MutableCopy, v18, valuePtr);
  if (v20)
  {
    CFRelease(v20);
  }

  if (v24)
  {
    v24(0, &theDict, 0, 0);
  }

  if (v18)
  {
    CFRelease(v18);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a6, MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

void AMCP::Null_Object_Description::attach_control_list(CFDictionaryRef *this@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *this);
  v11 = 0x676C6F626374726CLL;
  v12 = 0;
  AMCP::Address::to_string(&__p, &v11, 0x676C6F626374726CLL);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if (p_p)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = __p.__r_.__value_.__l.__size_;
    }

    v9 = CFStringCreateWithBytes(0, p_p, size, 0x8000100u, 0);
    v14 = v9;
    if (!v9)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::ArrayRef>(MutableCopy, v9, *a2);
    CFRelease(v9);
  }

  else
  {
    v14 = 0;
    mcp_applesauce::CF::Dictionary_Builder::set_value<applesauce::CF::StringRef,applesauce::CF::ArrayRef>(MutableCopy, 0, *a2);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  mcp_applesauce::CF::Dictionary_Builder::copy_dictionary(a3, MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

void sub_1DE737704(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef(va);
  __clang_call_terminate(a1);
}

double AMCP::get_property_traits@<D0>(AMCP *this@<X0>, uint64_t a2@<X8>)
{
  v2 = this;
  AMCP::local_get_property_traits_list(this);
  v4 = std::__hash_table<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>>>::find<unsigned int>(v2);
  if (v4)
  {
    v5 = v4;
    *a2 = *(v4 + 6);
    *(a2 + 3) = *(v4 + 27);
    *(a2 + 16) = 0;
    *(a2 + 24) = 0;
    *(a2 + 8) = 0;
    std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(a2 + 8, v5[4], v5[5], (v5[5] - v5[4]) >> 2);
    *(a2 + 32) = v5[7];
    *(a2 + 40) = *(v5 + 16);
  }

  else
  {
    *a2 = v2;
    *(a2 + 4) = 0;
    *(a2 + 6) = 0;
    result = 0.0;
    *(a2 + 8) = 0u;
    *(a2 + 24) = 0u;
    *(a2 + 40) = 0;
  }

  return result;
}

void AMCP::local_get_property_traits_list(AMCP *this)
{
  {
    AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list = 0u;
    *&qword_1ECDAEBA0 = 0u;
    dword_1ECDAEBB0 = 1065353216;
  }

  if (atomic_load_explicit(&AMCP::local_get_property_traits_list(void)::once, memory_order_acquire) != -1)
  {
    v3 = &v1;
    v2 = &v3;
    std::__call_once(&AMCP::local_get_property_traits_list(void)::once, &v2, std::__call_once_proxy[abi:ne200100]<std::tuple<AMCP::local_get_property_traits_list(void)::$_0 &&>>);
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>>>::find<unsigned int>(unsigned int a1)
{
  if (!*(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 1))
  {
    return 0;
  }

  v1 = vcnt_s8(*(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 8));
  v1.i16[0] = vaddlv_u8(v1);
  if (v1.u32[0] > 1uLL)
  {
    v2 = a1;
    if (*(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 1) <= a1)
    {
      v2 = a1 % DWORD2(AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list);
    }
  }

  else
  {
    v2 = (DWORD2(AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list) - 1) & a1;
  }

  i = *(AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 8 * v2);
  if (i)
  {
    for (i = *i; i; i = *i)
    {
      v4 = i[1];
      if (v4 == a1)
      {
        if (*(i + 4) == a1)
        {
          return i;
        }
      }

      else
      {
        if (v1.u32[0] > 1uLL)
        {
          if (v4 >= *(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 1))
          {
            v4 %= *(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 1);
          }
        }

        else
        {
          v4 &= *(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 1) - 1;
        }

        if (v4 != v2)
        {
          return 0;
        }
      }
    }
  }

  return i;
}

void AMCP::local_get_property_traits_list(void)::$_0::operator()()
{
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1768189556, 1, 1, 0, &AMCP::Property_Traits<1768189556u>::k_valid_scopes, &AMCP::Property_Traits<1650682995u>::k_valid_scopes, 0, 0, 15);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_object_id, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1650682995, 1, 1, 0, &AMCP::Property_Traits<1650682995u>::k_valid_scopes, &AMCP::Property_Traits<1668047219u>::k_valid_scopes, 0, 0, 6);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_stock_class_id, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1668047219, 1, 1, 0, &AMCP::Property_Traits<1668047219u>::k_valid_scopes, &AMCP::Property_Traits<1870098034u>::k_valid_scopes, 0, 0, 6);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_class_id, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1870098034, 1, 1, 0, &AMCP::Property_Traits<1870098034u>::k_valid_scopes, &AMCP::Property_Traits<1869638759u>::k_valid_scopes, 0, 0, 15);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_owner, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1869638759, 1, 1, 0, &AMCP::Property_Traits<1869638759u>::k_valid_scopes, &AMCP::Property_Traits<1870097955u>::k_valid_scopes, 0, 1869638759, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_creator, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1870097955, 1, 0, 0, &AMCP::Property_Traits<1870097955u>::k_valid_scopes, &AMCP::Property_Traits<1819173229u>::k_valid_scopes, 0, 1870098020, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_owned_object_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1819173229, 0, 0, 1, &AMCP::Property_Traits<1819173229u>::k_valid_scopes, &AMCP::Property_Traits<1819111268u>::k_valid_scopes, 0, 1819173229, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_object_name, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1819111268, 0, 0, 0, &AMCP::Property_Traits<1819111268u>::k_valid_scopes, &AMCP::Property_Traits<1819107691u>::k_valid_scopes, 0, 1819111268, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_model_name, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1819107691, 0, 0, 0, &AMCP::Property_Traits<1819107691u>::k_valid_scopes, &AMCP::Property_Traits<1768124270u>::k_valid_scopes, 0, 1819107691, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_manufacturer_name, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1768124270, 0, 0, 0, &AMCP::Property_Traits<1768124270u>::k_valid_scopes, &AMCP::Property_Traits<1667330160u>::k_valid_scopes, 0, 1768124270, 5);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_icon, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1667330160, 0, 0, 0, &AMCP::Property_Traits<1667330160u>::k_valid_scopes, &AMCP::Property_Traits<1936618861u>::k_valid_scopes, 0, 1667330160, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_configuration_app, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1936618861, 0, 0, 0, &AMCP::Property_Traits<1936618861u>::k_valid_scopes, &AMCP::Property_Traits<1719105134u>::k_valid_scopes, 0, 1936618861, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_serial_number, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1719105134, 0, 0, 0, &AMCP::Property_Traits<1719105134u>::k_valid_scopes, AMCP::Property_Traits<1818454126u>::k_valid_scopes, 0, 1719105134, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_firmware_version, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1818454126, 0, 0, 0, AMCP::Property_Traits<1818454126u>::k_valid_scopes, &AMCP::Property_Traits<1818452846u>::k_valid_scopes, -1, 1818454126, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_element_name, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1818452846, 0, 0, 0, &AMCP::Property_Traits<1818452846u>::k_valid_scopes, &AMCP::Property_Traits<1818455662u>::k_valid_scopes, -1, 1818452846, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_element_category_name, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1818455662, 0, 0, 0, &AMCP::Property_Traits<1818455662u>::k_valid_scopes, &AMCP::Property_Traits<1920168547u>::k_valid_scopes, -1, 1818455662, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_element_number_name, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1920168547, 0, 0, 0, &AMCP::Property_Traits<1920168547u>::k_valid_scopes, &AMCP::Property_Traits<1668575852u>::k_valid_scopes, 0, 0, 5);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_resource_bundle_url, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1668575852, 0, 0, 0, &AMCP::Property_Traits<1668575852u>::k_valid_scopes, &AMCP::Property_Traits<1885956452u>::k_valid_scopes, 0, 1668575852, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_object_property_control_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1886152483, 1, 0, 0, &AMCP::Property_Traits<1886152483u>::k_valid_scopes, &AMCP::Property_Traits<1668577315u>::k_valid_scopes, 0, 1886152483, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_system_property_driver_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1651472419, 1, 0, 0, &AMCP::Property_Traits<1651472419u>::k_valid_scopes, &AMCP::Property_Traits<1668049699u>::k_valid_scopes, 0, 1651472419, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_system_property_box_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1668049699, 1, 0, 0, &AMCP::Property_Traits<1668049699u>::k_valid_scopes, &AMCP::Property_Traits<1684370979u>::k_valid_scopes, 0, 1668049699, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_system_property_clock_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1684370979, 1, 0, 0, &AMCP::Property_Traits<1684370979u>::k_valid_scopes, "N14mcp_applesauce2CF15PropertyListRefE", 0, 1684370979, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_system_property_device_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1668577315, 1, 0, 0, &AMCP::Property_Traits<1668577315u>::k_valid_scopes, &AMCP::Property_Traits<1852793891u>::k_valid_scopes, 0, 0, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_system_property_io_context_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1852793891, 1, 0, 0, &AMCP::Property_Traits<1852793891u>::k_valid_scopes, &AMCP::Property_Traits<1651861860u>::k_valid_scopes, 0, 0, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_system_property_node_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1885956452, 1, 1, 0, &AMCP::Property_Traits<1885956452u>::k_valid_scopes, &AMCP::Property_Traits<1651472419u>::k_valid_scopes, 0, 1885956452, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_driver_property_bundle_id, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1651861860, 1, 1, 0, &AMCP::Property_Traits<1651861860u>::k_valid_scopes, &AMCP::Property_Traits<1953653102u>::k_valid_scopes, 0, 1651861860, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_box_property_box_uid, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1953653102, 1, 0, 0, &AMCP::Property_Traits<1953653102u>::k_valid_scopes, &AMCP::Property_Traits<1651007861u>::k_valid_scopes, 0, 1953653102, 23);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_box_property_transport_type, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1651007861, 1, 0, 0, &AMCP::Property_Traits<1651007861u>::k_valid_scopes, &AMCP::Property_Traits<1651013225u>::k_valid_scopes, 0, 1651007861, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_box_property_has_audio, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1651013225, 1, 0, 0, &AMCP::Property_Traits<1651013225u>::k_valid_scopes, &AMCP::Property_Traits<1651010921u>::k_valid_scopes, 0, 1651013225, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_box_property_has_video, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1651010921, 1, 0, 0, &AMCP::Property_Traits<1651010921u>::k_valid_scopes, &AMCP::Property_Traits<1651536495u>::k_valid_scopes, 0, 1651010921, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_box_property_has_midi, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1651536495, 1, 0, 0, &AMCP::Property_Traits<1651536495u>::k_valid_scopes, &AMCP::Property_Traits<1652060014u>::k_valid_scopes, 0, 1651536495, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_box_property_is_protected, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1652060014, 1, 0, 1, &AMCP::Property_Traits<1652060014u>::k_valid_scopes, &AMCP::Property_Traits<1652060006u>::k_valid_scopes, 0, 1652060014, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_box_property_acquired, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1652060006, 1, 0, 0, &AMCP::Property_Traits<1652060006u>::k_valid_scopes, &AMCP::Property_Traits<1650751011u>::k_valid_scopes, 0, 1652060006, 24);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_box_property_acquisition_failed, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1650751011, 1, 0, 0, &AMCP::Property_Traits<1650751011u>::k_valid_scopes, &AMCP::Property_Traits<1650682915u>::k_valid_scopes, 0, 0, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_box_property_device_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1650682915, 1, 0, 0, &AMCP::Property_Traits<1650682915u>::k_valid_scopes, &AMCP::Property_Traits<1969841184u>::k_valid_scopes, 0, 0, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_box_property_clock_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1969841184, 1, 1, 0, &AMCP::Property_Traits<1969841184u>::k_valid_scopes, &AMCP::Property_Traits<1836411236u>::k_valid_scopes, 0, 1668639076, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_clock_property_device_uid, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1836411236, 0, 0, 0, &AMCP::Property_Traits<1836411236u>::k_valid_scopes, &AMCP::Property_Traits<1751737454u>::k_valid_scopes, 0, 1836411236, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_clock_property_model_uid, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1751737454, 1, 0, 0, &AMCP::Property_Traits<1751737454u>::k_valid_scopes, &AMCP::Property_Traits<1668049764u>::k_valid_scopes, 0, 1751737454, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_clock_property_hidden, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1668049764, 1, 0, 0, &AMCP::Property_Traits<1668049764u>::k_valid_scopes, &AMCP::Property_Traits<1819569763u>::k_valid_scopes, 0, 1668049764, 7);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_clock_property_clock_domain, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1819569763, 1, 0, 0, &AMCP::Property_Traits<1819569763u>::k_valid_scopes, &AMCP::Property_Traits<1853059700u>::k_valid_scopes, 0, 1819569763, 24);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_clock_property_latency, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1853059700, 1, 0, 1, &AMCP::Property_Traits<1853059700u>::k_valid_scopes, &AMCP::Property_Traits<1853059619u>::k_valid_scopes, 0, 1853059700, 17);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_clock_property_sample_rate, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1853059619, 1, 0, 0, &AMCP::Property_Traits<1853059619u>::k_valid_scopes, &AMCP::Property_Traits<1935763060u>::k_valid_scopes, 0, 1853059619, 25);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_clock_property_available_sample_rate_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1935763060, 1, 0, 0, &AMCP::Property_Traits<1935763060u>::k_valid_scopes, &AMCP::Property_Traits<1937009955u>::k_valid_scopes, 0, 1935763060, 24);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_device_property_safety_offset, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1937009955, 1, 0, 0, &AMCP::Property_Traits<1937009955u>::k_valid_scopes, &AMCP::Property_Traits<1685222501u>::k_valid_scopes, 0, 1937009955, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_device_property_stream_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1685222501, 0, 0, 0, &AMCP::Property_Traits<1685222501u>::k_valid_scopes, &AMCP::Property_Traits<1936879204u>::k_valid_scopes, 0, 1685222501, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_device_property_wants_display_routing, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1936879204, 0, 0, 0, &AMCP::Property_Traits<1936879204u>::k_valid_scopes, &AMCP::Property_Traits<1684434036u>::k_valid_scopes, 0, 1936876644, 27);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_device_property_channel_layout, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1684434036, 1, 0, 0, &AMCP::Property_Traits<1684434036u>::k_valid_scopes, &AMCP::Property_Traits<1936092276u>::k_valid_scopes, 0, 1684434036, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_device_property_can_be_default_device, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1936092276, 1, 0, 0, &AMCP::Property_Traits<1936092276u>::k_valid_scopes, &AMCP::Property_Traits<1684301171u>::k_valid_scopes, 0, 1936092276, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_device_property_can_be_default_system_device, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1684301171, 0, 0, 0, &AMCP::Property_Traits<1684301171u>::k_valid_scopes, &AMCP::Property_Traits<1667523955u>::k_valid_scopes, 0, 1684301171, 3);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_device_property_device_description, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1667523955, 0, 0, 1, &AMCP::Property_Traits<1667523955u>::k_valid_scopes, &AMCP::Property_Traits<1935960434u>::k_valid_scopes, 0, 1667523955, 3);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_device_property_client_description, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1935960434, 1, 0, 0, &AMCP::Property_Traits<1935960434u>::k_valid_scopes, &AMCP::Property_Traits<1935894638u>::k_valid_scopes, 0, 1935960434, 8);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_stream_property_direction, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1935894638, 1, 0, 0, &AMCP::Property_Traits<1935894638u>::k_valid_scopes, &AMCP::Property_Traits<1952542835u>::k_valid_scopes, 0, 1935894638, 24);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_stream_property_starting_channel, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1952542835, 1, 0, 0, &AMCP::Property_Traits<1952542835u>::k_valid_scopes, &AMCP::Property_Traits<1952805485u>::k_valid_scopes, 0, 1952542835, 24);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_stream_property_is_reference_stream, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1952805485, 1, 0, 0, &AMCP::Property_Traits<1952805485u>::k_valid_scopes, &AMCP::Property_Traits<1936487523u>::k_valid_scopes, 0, 1952805485, 22);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_stream_property_terminal_type, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1936487523, 1, 0, 0, &AMCP::Property_Traits<1936487523u>::k_valid_scopes, &AMCP::Property_Traits<1718444404u>::k_valid_scopes, 0, 1819569763, 12);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_stream_property_latency, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1718444404, 1, 0, 1, &AMCP::Property_Traits<1718444404u>::k_valid_scopes, &AMCP::Property_Traits<1718449187u>::k_valid_scopes, 0, 1885762592, 11);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_stream_property_current_format, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1718449187, 1, 0, 0, &AMCP::Property_Traits<1718449187u>::k_valid_scopes, &AMCP::Property_Traits<1735554416u>::k_valid_scopes, 0, 1885762657, 1);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_stream_property_available_format_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1735554416, 1, 0, 1, &AMCP::Property_Traits<1735554416u>::k_valid_scopes, &AMCP::Property_Traits<1634169456u>::k_valid_scopes, 0, 1735554416, 3);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_meta_device_property_full_subdevice_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1634169456, 1, 0, 0, &AMCP::Property_Traits<1634169456u>::k_valid_scopes, &AMCP::Property_Traits<1633906541u>::k_valid_scopes, 0, 1634169456, 14);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_meta_device_property_active_subdevice_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1633906541, 1, 0, 1, &AMCP::Property_Traits<1633906541u>::k_valid_scopes, &AMCP::Property_Traits<1634562932u>::k_valid_scopes, 0, 1633906541, 3);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_meta_device_property_composition, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1634562932, 1, 0, 1, &AMCP::Property_Traits<1634562932u>::k_valid_scopes, &AMCP::Property_Traits<1634755428u>::k_valid_scopes, 0, 1634562932, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_meta_device_property_master_subdevice, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1634755428, 1, 0, 1, &AMCP::Property_Traits<1634755428u>::k_valid_scopes, &AMCP::Property_Traits<1668445298u>::k_valid_scopes, 0, 1634755428, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_meta_device_property_clock_device, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1668445298, 1, 0, 0, &AMCP::Property_Traits<1668445298u>::k_valid_scopes, &AMCP::Property_Traits<1886549620u>::k_valid_scopes, 0, 1668445298, 12);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_meta_device_property_creator, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1886549620, 1, 0, 0, &AMCP::Property_Traits<1886549620u>::k_valid_scopes, &AMCP::Property_Traits<1668506480u>::k_valid_scopes, 0, 1886549620, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_meta_device_property_is_private, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1668506480, 1, 0, 0, &AMCP::Property_Traits<1668506480u>::k_valid_scopes, &AMCP::Property_Traits<1667591277u>::k_valid_scopes, 0, 1668506480, 18);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_control_property_scope, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1667591277, 1, 0, 0, &AMCP::Property_Traits<1667591277u>::k_valid_scopes, &AMCP::Property_Traits<1668441199u>::k_valid_scopes, 0, 1667591277, 9);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_control_property_element, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1668441199, 1, 0, 0, &AMCP::Property_Traits<1668441199u>::k_valid_scopes, &AMCP::Property_Traits<1935962742u>::k_valid_scopes, 0, 0, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_control_property_is_read_only, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1935962742, 1, 0, 1, &AMCP::Property_Traits<1935962742u>::k_valid_scopes, &AMCP::Property_Traits<1935962738u>::k_valid_scopes, 0, 1935962742, 24);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_slider_control_property_value, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1935962738, 1, 0, 0, &AMCP::Property_Traits<1935962738u>::k_valid_scopes, &AMCP::Property_Traits<1818456950u>::k_valid_scopes, 0, 1935962738, 13);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_slider_control_property_range, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1818456950, 1, 0, 1, &AMCP::Property_Traits<1818456950u>::k_valid_scopes, &AMCP::Property_Traits<1818453110u>::k_valid_scopes, 0, 1818456950, 10);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_level_control_property_scalar_value, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1818453110, 1, 0, 1, &AMCP::Property_Traits<1818453110u>::k_valid_scopes, &AMCP::Property_Traits<1818453106u>::k_valid_scopes, 0, 1818453110, 10);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_level_control_property_decibel_value, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1818453106, 1, 0, 0, &AMCP::Property_Traits<1818453106u>::k_valid_scopes, &AMCP::Property_Traits<1650685548u>::k_valid_scopes, 0, 1818453106, 26);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_level_control_property_decibel_range, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1650685548, 1, 0, 1, &AMCP::Property_Traits<1650685548u>::k_valid_scopes, &AMCP::Property_Traits<1935893353u>::k_valid_scopes, 0, 1650685548, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_BOOLean_control_property_value, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1935893353, 1, 0, 1, &AMCP::Property_Traits<1935893353u>::k_valid_scopes, &AMCP::Property_Traits<1935893357u>::k_valid_scopes, 0, 1935893353, 20);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_selector_control_property_value, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1935893357, 1, 0, 0, &AMCP::Property_Traits<1935893357u>::k_valid_scopes, &AMCP::Property_Traits<1935892841u>::k_valid_scopes, 0, 0, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_selector_control_property_is_multi_value, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1935892841, 1, 0, 0, &AMCP::Property_Traits<1935892841u>::k_valid_scopes, &AMCP::Property_Traits<1936745334u>::k_valid_scopes, 0, 0, 19);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_selector_control_property_item_list, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1936745334, 1, 0, 1, &AMCP::Property_Traits<1936745334u>::k_valid_scopes, &AMCP::Property_Traits<1936745315u>::k_valid_scopes, 0, 1936745334, 10);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_stereo_pan_control_property_value, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1936745315, 1, 0, 0, &AMCP::Property_Traits<1936745315u>::k_valid_scopes, &AMCP::Property_Traits<1853188452u>::k_valid_scopes, 0, 1936745315, 21);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_stereo_pan_control_property_channels, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1853188452, 1, 0, 0, &AMCP::Property_Traits<1853188452u>::k_valid_scopes, &AMCP::Property_Traits<1852073061u>::k_valid_scopes, 0, 0, 4);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_node_property_uid, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1852073061, 1, 0, 0, &AMCP::Property_Traits<1852073061u>::k_valid_scopes, &AMCP::Property_Traits<1852077168u>::k_valid_scopes, 0, 0, 0);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_node_property_description, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1852077168, 1, 0, 0, &AMCP::Property_Traits<1852077168u>::k_valid_scopes, &AMCP::Property_Traits<1852072820u>::k_valid_scopes, 0, 0, 0);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_node_property_type, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1852072820, 1, 0, 0, &AMCP::Property_Traits<1852072820u>::k_valid_scopes, &AMCP::Property_Traits<1852072812u>::k_valid_scopes, 0, 0, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_node_property_connected, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1852072812, 1, 0, 0, &AMCP::Property_Traits<1852072812u>::k_valid_scopes, &AMCP::Property_Traits<1953657716u>::k_valid_scopes, 0, 0, 15);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_node_property_clock, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1953657716, 1, 0, 0, &AMCP::Property_Traits<1953657716u>::k_valid_scopes, &AMCP::Property_Traits<1718839674u>::k_valid_scopes, 0, 0, 0);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_iocontext_property_transport_state, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1718839674, 1, 0, 1, &AMCP::Property_Traits<1718839674u>::k_valid_scopes, &AMCP::Property_Traits<1718843939u>::k_valid_scopes, 0, 0, 24);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_iocontext_property_buffer_frame_size, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1718843939, 1, 0, 0, &AMCP::Property_Traits<1718843939u>::k_valid_scopes, &AMCP::Property_Traits<1852012899u>::k_valid_scopes, 0, 0, 13);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_iocontext_property_buffer_frame_size_range, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1852012899, 1, 0, 1, &AMCP::Property_Traits<1852012899u>::k_valid_scopes, &AMCP::Property_Traits<1634955892u>::k_valid_scopes, 0, 0, 10);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_iocontext_property_io_cycle_usage, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1634955892, 1, 0, 0, &AMCP::Property_Traits<1634955892u>::k_valid_scopes, &AMCP::Property_Traits<2003267184u>::k_valid_scopes, 0, 0, 17);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_iocontext_property_actual_sample_rate, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 2003267184, 1, 0, 1, &AMCP::Property_Traits<2003267184u>::k_valid_scopes, &AMCP::Property_Traits<1752130413u>::k_valid_scopes, 0, 0, 0);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_iocontext_property_work_group_handle, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1752130413, 0, 0, 1, &AMCP::Property_Traits<1752130413u>::k_valid_scopes, &AMCP::Property_Traits<1952608870u>::k_valid_scopes, 0, 0, 2);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_iocontext_property_handle_overload_with_catchup_mode, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }

  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v0, 1952608870, 1, 0, 0, &AMCP::Property_Traits<1952608870u>::k_valid_scopes, "N4AMCP12Clock_FilterE", 0, 0, 0);
  std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(&AMCP::k_iocontext_property_timebases, &v0);
  if (__p)
  {
    v2 = __p;
    operator delete(__p);
  }
}

void sub_1DE7398C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

__n128 std::unordered_map<unsigned int,AMCP::Live_Property_Traits>::insert_or_assign[abi:ne200100]<AMCP::Live_Property_Traits>(unsigned int *a1, int *a2)
{
  v3 = *a1;
  if (!*(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 1))
  {
    goto LABEL_18;
  }

  v4 = vcnt_s8(*(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 8));
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a1;
    if (*(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 1) <= v3)
    {
      v5 = v3 % DWORD2(AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list);
    }
  }

  else
  {
    v5 = (DWORD2(AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list) - 1) & v3;
  }

  v6 = *(AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 8 * v5);
  if (!v6 || (v7 = *v6) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v8 = v7[1];
    if (v8 == v3)
    {
      break;
    }

    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 1))
      {
        v8 %= *(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 1);
      }
    }

    else
    {
      v8 &= *(&AMCP::local_get_property_traits_list(void)::s_indesctructible_property_traits_list + 1) - 1;
    }

    if (v8 != v5)
    {
      goto LABEL_18;
    }

LABEL_17:
    v7 = *v7;
    if (!v7)
    {
      goto LABEL_18;
    }
  }

  if (*(v7 + 4) != v3)
  {
    goto LABEL_17;
  }

  v9 = *a2;
  v10 = v7[4];
  *(v7 + 27) = *(a2 + 3);
  *(v7 + 6) = v9;
  if (v10)
  {
    v7[5] = v10;
    operator delete(v10);
    v7[4] = 0;
    v7[5] = 0;
    v7[6] = 0;
  }

  result = *(a2 + 2);
  *(v7 + 2) = result;
  v7[6] = *(a2 + 3);
  *(a2 + 1) = 0;
  *(a2 + 2) = 0;
  *(a2 + 3) = 0;
  v12 = *(a2 + 4);
  *(v7 + 16) = a2[10];
  v7[7] = v12;
  return result;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,void *>>>::operator()[abi:ne200100](char a1, void *__p)
{
  if (a1)
  {
    v3 = __p[4];
    if (v3)
    {
      __p[5] = v3;
      operator delete(v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

double AMCP::get_property_traits_for_hal_selector@<D0>(AMCP *this@<X0>, uint64_t a2@<X8>)
{
  v2 = this;
  AMCP::local_get_property_traits_list(this);
  v4 = &qword_1ECDAEBA0;
  while (1)
  {
    v4 = *v4;
    if (!v4)
    {
      break;
    }

    if (*(v4 + 15) == v2)
    {
      *a2 = *(v4 + 6);
      *(a2 + 3) = *(v4 + 27);
      *(a2 + 16) = 0;
      *(a2 + 24) = 0;
      *(a2 + 8) = 0;
      std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(a2 + 8, v4[4], v4[5], (v4[5] - v4[4]) >> 2);
      *(a2 + 32) = v4[7];
      *(a2 + 40) = *(v4 + 16);
      return result;
    }
  }

  *(a2 + 40) = 0;
  result = 0.0;
  *(a2 + 24) = 0u;
  *(a2 + 8) = 0u;
  *a2 = 0;
  *(a2 + 3) = 0;
  return result;
}

BOOL AMCP::is_stock_property_selector(AMCP *this)
{
  v1 = this;
  AMCP::local_get_property_traits_list(this);
  return std::__hash_table<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>>>::find<unsigned int>(v1) != 0;
}

uint64_t AMCP::is_required_property_selector(AMCP *this)
{
  v1 = this;
  AMCP::local_get_property_traits_list(this);
  v2 = std::__hash_table<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>>>::find<unsigned int>(v1);
  if (v2)
  {
    v3 = *(v2 + 28);
  }

  else
  {
    v3 = 0;
  }

  return v3 & 1;
}

uint64_t AMCP::is_invariant_property_selector(AMCP *this)
{
  v1 = this;
  AMCP::local_get_property_traits_list(this);
  v2 = std::__hash_table<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>>>::find<unsigned int>(v1);
  if (v2)
  {
    v3 = *(v2 + 29);
  }

  else
  {
    v3 = 0;
  }

  return v3 & 1;
}

uint64_t AMCP::property_selector_may_be_settable(AMCP *this)
{
  v1 = this;
  AMCP::local_get_property_traits_list(this);
  v2 = std::__hash_table<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AMCP::Live_Property_Traits>>>::find<unsigned int>(v1);
  if (v2)
  {
    v3 = *(v2 + 30);
  }

  else
  {
    v3 = 0;
  }

  return v3 & 1;
}

uint64_t AMCP::get_property_traits_for_class(AMCP *this)
{
  v1 = this;
  is_base_of = AMCP::is_base_of(0x61706C67, this);
  if (is_base_of)
  {

    return AMCP::get_driver_property_traits_list(is_base_of);
  }

  else
  {
    v4 = AMCP::is_base_of(0x61626F78, v1);
    if (v4)
    {

      return AMCP::get_box_property_traits_list(v4);
    }

    else if (AMCP::is_base_of(0x61616767, v1))
    {
      {
        AMCP::get_meta_device_property_traits_list(void)::s_indestructible_property_traits_list_ptr = 0;
      }

      if (atomic_load_explicit(&AMCP::get_meta_device_property_traits_list(void)::once, memory_order_acquire) != -1)
      {
        v16 = &v14;
        v15 = &v16;
        std::__call_once(&AMCP::get_meta_device_property_traits_list(void)::once, &v15, std::__call_once_proxy[abi:ne200100]<std::tuple<AMCP::get_meta_device_property_traits_list(void)::$_0 &&>>);
      }

      return AMCP::get_meta_device_property_traits_list(void)::s_indestructible_property_traits_list_ptr;
    }

    else
    {
      v5 = AMCP::is_base_of(0x61646576, v1);
      if (v5)
      {

        return AMCP::get_device_property_traits_list(v5);
      }

      else if (AMCP::is_base_of(0x6D737472, v1))
      {
        {
          AMCP::get_meta_stream_property_traits_list(void)::s_indesctructible_property_traits_list_ptr = 0;
        }

        if (atomic_load_explicit(&AMCP::get_meta_stream_property_traits_list(void)::once, memory_order_acquire) != -1)
        {
          v16 = &v14;
          v15 = &v16;
          std::__call_once(&AMCP::get_meta_stream_property_traits_list(void)::once, &v15, std::__call_once_proxy[abi:ne200100]<std::tuple<AMCP::get_meta_stream_property_traits_list(void)::$_0 &&>>);
        }

        return AMCP::get_meta_stream_property_traits_list(void)::s_indesctructible_property_traits_list_ptr;
      }

      else
      {
        v6 = AMCP::is_base_of(0x61737472, v1);
        if (v6)
        {

          return AMCP::get_stream_property_traits_list(v6);
        }

        else
        {
          v7 = AMCP::is_base_of(0x736C6472, v1);
          if (v7)
          {

            return AMCP::get_slider_control_property_traits_list(v7);
          }

          else
          {
            v8 = AMCP::is_base_of(0x6C65766C, v1);
            if (v8)
            {

              return AMCP::get_level_control_property_traits_list(v8);
            }

            else
            {
              v9 = AMCP::is_base_of(0x746F676C, v1);
              if (v9)
              {

                return AMCP::get_BOOLean_control_property_traits_list(v9);
              }

              else
              {
                v10 = AMCP::is_base_of(0x736C6374, v1);
                if (v10)
                {

                  return AMCP::get_selector_control_property_traits_list(v10);
                }

                else
                {
                  v11 = AMCP::is_base_of(0x7370616E, v1);
                  if (v11)
                  {

                    return AMCP::get_stereo_pan_control_property_traits_list(v11);
                  }

                  else
                  {
                    v12 = AMCP::is_base_of(0x6163746C, v1);
                    if (v12)
                    {

                      return AMCP::get_control_property_traits_list(v12);
                    }

                    else
                    {
                      v13 = AMCP::is_base_of(0x61636C6B, v1);
                      if (v13)
                      {

                        return AMCP::get_clock_property_traits_list(v13);
                      }

                      else
                      {

                        return AMCP::get_object_property_traits_list(v13);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void non-virtual thunk toAMCP::IOAudio1::Driver::~Driver(AMCP::IOAudio1::Driver *this)
{
  AMCP::IOAudio1::Driver::~Driver((this - 24));

  JUMPOUT(0x1E12C1730);
}

{
  AMCP::IOAudio1::Driver::~Driver((this - 24));
}

void AMCP::IOAudio1::Driver::~Driver(AMCP::IOAudio1::Driver *this)
{
  *this = &unk_1F598FAF0;
  *(this + 3) = &unk_1F598FB18;
  v2 = (this + 64);
  if (*(this + 8))
  {
    std::vector<std::shared_ptr<DSP_Host_Types::DeviceConfiguration>>::clear[abi:ne200100](this + 8);
    operator delete(*v2);
  }

  std::unique_ptr<applesauce::iokit::io_service_factory>::reset[abi:ne200100](this + 7, 0);
  *(this + 3) = &unk_1F59748E8;
  v3 = *(this + 5);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  v4 = *(this + 2);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

{
  AMCP::IOAudio1::Driver::~Driver(this);

  JUMPOUT(0x1E12C1730);
}

void AMCP::IOAudio1::Driver::shutdown(AMCP::IOAudio1::Driver *this)
{
  v1 = this;
  v25 = *MEMORY[0x1E69E9840];
  v2 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
  if ((v2 & 1) == 0)
  {
    this = AMCP::Log::AMCP_Scope_Registry::initialize(this);
  }

  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v4 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v5 = *(v3 + 16);
  switch(v5)
  {
    case 3:
      v14 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v14 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(this);
      }

      v16 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v15 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        v17 = *v16;
        std::__shared_weak_count::__release_shared[abi:ne200100](v15);
      }

      else
      {
        v17 = *v16;
      }

      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        v21 = 136315394;
        v22 = "IOAudio1_Driver.cpp";
        v23 = 1024;
        v24 = 49;
        v18 = v17;
        v19 = OS_LOG_TYPE_INFO;
LABEL_29:
        _os_log_impl(&dword_1DE1F9000, v18, v19, "%32s:%-5d Tearing down IOAudio1 Driver", &v21, 0x12u);
      }

      break;
    case 2:
      v10 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v10 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(this);
      }

      v12 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v11 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        v13 = *v12;
        std::__shared_weak_count::__release_shared[abi:ne200100](v11);
      }

      else
      {
        v13 = *v12;
      }

      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v21 = 136315394;
        v22 = "IOAudio1_Driver.cpp";
        v23 = 1024;
        v24 = 49;
        _os_log_debug_impl(&dword_1DE1F9000, v13, OS_LOG_TYPE_DEBUG, "%32s:%-5d Tearing down IOAudio1 Driver", &v21, 0x12u);
      }

      break;
    case 1:
      v6 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v6 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(this);
      }

      v8 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v7 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        v9 = *v8;
        std::__shared_weak_count::__release_shared[abi:ne200100](v7);
      }

      else
      {
        v9 = *v8;
      }

      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v21 = 136315394;
        v22 = "IOAudio1_Driver.cpp";
        v23 = 1024;
        v24 = 49;
        v18 = v9;
        v19 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_29;
      }

      break;
  }

  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  std::unique_ptr<applesauce::iokit::io_service_factory>::reset[abi:ne200100](v1 + 7, 0);
  std::vector<std::shared_ptr<DSP_Host_Types::DeviceConfiguration>>::clear[abi:ne200100](v1 + 8);
  AMCP::Core::Broker::destroy_core(*(*(v1 + 4) + 16), *(v1 + 12));
  v20 = *MEMORY[0x1E69E9840];
}

void sub_1DE73A88C(_Unwind_Exception *a1, int a2)
{
  if (!a2)
  {
    _Unwind_Resume(a1);
  }

  __clang_call_terminate(a1);
}

char **std::dynamic_pointer_cast[abi:ne200100]<AMCP::IOAudio1::Driver,AMCP::Core::Driver>(char ***a1, char ***a2)
{
  result = *a2;
  {
    v6 = v4[1];
    *a1 = result;
    a1[1] = v6;
  }

  else
  {
    v4 = a1;
  }

  *v4 = 0;
  v4[1] = 0;
  return result;
}

uint64_t std::__function::__func<AMCP::IOAudio1::Driver::start(void)::$_0,std::allocator<AMCP::IOAudio1::Driver::start(void)::$_0>,void ()(applesauce::iokit::io_object_holder)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "ZN4AMCP8IOAudio16Driver5startEvE3$_0"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void std::__function::__func<AMCP::IOAudio1::Driver::start(void)::$_0,std::allocator<AMCP::IOAudio1::Driver::start(void)::$_0>,void ()(applesauce::iokit::io_object_holder)>::operator()(uint64_t a1, io_registry_entry_t *a2)
{
  v8 = *a2;
  v2 = v8;
  *a2 = 0;
  v3 = *(a1 + 8);
  if (v2)
  {
    v4 = IOObjectRetain(v2);
    if (v4)
    {
      v5 = v4;
      exception = __cxa_allocate_exception(0x20uLL);
      v7 = std::system_category();
      MEMORY[0x1E12C10C0](exception, v5, v7, "Error on Retain");
      __cxa_throw(exception, MEMORY[0x1E69E53B8], MEMORY[0x1E69E52D0]);
    }

    AMCP::IOAudio1::Driver::handle_device_arrival(v3, &v8);
    IOObjectRelease(v2);
    IOObjectRelease(v2);
  }

  else
  {
    AMCP::IOAudio1::Driver::handle_device_arrival(*(a1 + 8), &v8);
  }
}

void sub_1DE73AA60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, io_object_t a10)
{
  __cxa_free_exception(v10);
  applesauce::iokit::io_object_holder::~io_object_holder(&a10);
  _Unwind_Resume(a1);
}

void AMCP::IOAudio1::Driver::handle_device_arrival(uint64_t a1, io_registry_entry_t *a2)
{
  cf[5] = *MEMORY[0x1E69E9840];
  v3 = *a2;
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "cannot create io_object_proxy from null io_object");
    __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  applesauce::iokit::get_properties(cf, v3);
  if (!cf[0])
  {
    v16 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v16, "Could not construct");
    __cxa_throw(v16, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
  }

  applesauce::CF::details::find_at_key<applesauce::CF::StringRef,__CFString const*>(&v24, cf[0], @"IOAudioEngineGlobalUniqueID");
  v5 = *(a1 + 64);
  v6 = *(a1 + 72);
  if (v5 != v6)
  {
    do
    {
      v7 = *(*v5 + 24);
      if (v7)
      {
        CFRetain(*(*v5 + 24));
        v8 = applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>(v7, &v24);
        CFRelease(v7);
        if (v8 == kCFCompareEqualTo)
        {
          goto LABEL_10;
        }
      }

      else if (applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>(0, &v24) == kCFCompareEqualTo)
      {
        goto LABEL_10;
      }

      v5 += 16;
    }

    while (v5 != v6);
    v5 = v6;
LABEL_10:
    v6 = *(a1 + 72);
  }

  if (v5 == v6)
  {
    v9 = *(*(a1 + 32) + 32);
    v10 = *(a1 + 48);
    std::shared_ptr<AMCP::IO_Core::IOContext_Core>::shared_ptr[abi:ne200100]<AMCP::IO_Core::IOContext_Core,0>(&v20, *(a1 + 8), *(a1 + 16));
    std::dynamic_pointer_cast[abi:ne200100]<AMCP::IOAudio1::Driver,AMCP::Core::Driver>(&v21, &v20);
    v11 = *a2;
    v22 = v11;
    if (!v11 || (v12 = IOObjectRetain(v11), !v12))
    {
      v13 = cf[0];
      if (cf[0])
      {
        CFRetain(cf[0]);
      }

      v23 = v13;
      cf[4] = 0;
      operator new();
    }

    v17 = v12;
    v18 = __cxa_allocate_exception(0x20uLL);
    v19 = std::system_category();
    MEMORY[0x1E12C10C0](v18, v17, v19, "Error on Retain");
    __cxa_throw(v18, MEMORY[0x1E69E53B8], MEMORY[0x1E69E52D0]);
  }

  if (v24)
  {
    CFRelease(v24);
  }

  if (cf[0])
  {
    CFRelease(cf[0]);
  }

  v14 = *MEMORY[0x1E69E9840];
}

void sub_1DE73AD40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, const void *a17, __int16 a18, char a19, char a20)
{
  if (a2)
  {
    __cxa_free_exception(v20);
    if (a12)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](a12);
    }

    if (a10)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](a10);
    }

    applesauce::CF::StringRef::~StringRef(&a16);
    applesauce::CF::DictionaryRef::~DictionaryRef(&a17);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1DE73AC44);
  }

  _Unwind_Resume(exception_object);
}

uint64_t AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1::~$_1(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
  }

  v3 = *(a1 + 16);
  if (v3)
  {
    IOObjectRelease(v3);
  }

  v4 = *(a1 + 8);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  return a1;
}

uint64_t std::__function::__func<AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "ZN4AMCP8IOAudio16Driver21handle_device_arrivalEN10applesauce5iokit16io_object_holderEE3$_1"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1DE73B0D0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  applesauce::CF::DictionaryRef::~DictionaryRef(va);
  std::__shared_weak_count::~__shared_weak_count(v4);
  operator delete(v6);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DE73B0A0);
}

void std::__shared_ptr_emplace<AMCP::IOAudio1::Device>::__on_zero_shared(AMCP::Log::AMCP_Scope_Registry *a1)
{
  v1 = a1;
  v47 = *MEMORY[0x1E69E9840];
  v2 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
  if ((v2 & 1) == 0)
  {
    a1 = AMCP::Log::AMCP_Scope_Registry::initialize(a1);
  }

  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v4 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v5 = *(v3 + 16);
  switch(v5)
  {
    case 3:
      v14 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v14 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(a1);
      }

      v16 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v15 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        v17 = *v16;
        std::__shared_weak_count::__release_shared[abi:ne200100](v15);
      }

      else
      {
        v17 = *v16;
      }

      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        v21 = *(v1 + 6);
        if (v21)
        {
          applesauce::CF::convert_to<std::string,0>(__p, v21);
          if (v39 >= 0)
          {
            v22 = __p;
          }

          else
          {
            v22 = __p[0];
          }

          v23 = *(v1 + 14);
          *buf = 136315906;
          *&buf[4] = "IOAudio1_Device.cpp";
          v41 = 1024;
          v42 = 147;
          v43 = 2080;
          v44 = v22;
          v45 = 1024;
          v46 = v23;
          v24 = v17;
          v25 = OS_LOG_TYPE_INFO;
          goto LABEL_40;
        }

LABEL_60:
        exception = __cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
      }

      break;
    case 2:
      v10 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v10 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(a1);
      }

      v12 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v11 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        v13 = *v12;
        std::__shared_weak_count::__release_shared[abi:ne200100](v11);
      }

      else
      {
        v13 = *v12;
      }

      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v18 = applesauce::CF::StringRef::operator->(v1 + 6);
        applesauce::CF::convert_to<std::string,0>(__p, *v18);
        if (v39 >= 0)
        {
          v19 = __p;
        }

        else
        {
          v19 = __p[0];
        }

        v20 = *(v1 + 14);
        *buf = 136315906;
        *&buf[4] = "IOAudio1_Device.cpp";
        v41 = 1024;
        v42 = 147;
        v43 = 2080;
        v44 = v19;
        v45 = 1024;
        v46 = v20;
        _os_log_debug_impl(&dword_1DE1F9000, v13, OS_LOG_TYPE_DEBUG, "%32s:%-5d Tearing down Device '%s' with object id %u", buf, 0x22u);
LABEL_41:
        if (v39 < 0)
        {
          operator delete(__p[0]);
        }
      }

      break;
    case 1:
      v6 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v6 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(a1);
      }

      v8 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v7 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        v9 = *v8;
        std::__shared_weak_count::__release_shared[abi:ne200100](v7);
      }

      else
      {
        v9 = *v8;
      }

      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v26 = *(v1 + 6);
        if (v26)
        {
          applesauce::CF::convert_to<std::string,0>(__p, v26);
          if (v39 >= 0)
          {
            v27 = __p;
          }

          else
          {
            v27 = __p[0];
          }

          v28 = *(v1 + 14);
          *buf = 136315906;
          *&buf[4] = "IOAudio1_Device.cpp";
          v41 = 1024;
          v42 = 147;
          v43 = 2080;
          v44 = v27;
          v45 = 1024;
          v46 = v28;
          v24 = v9;
          v25 = OS_LOG_TYPE_DEFAULT;
LABEL_40:
          _os_log_impl(&dword_1DE1F9000, v24, v25, "%32s:%-5d Tearing down Device '%s' with object id %u", buf, 0x22u);
          goto LABEL_41;
        }

        goto LABEL_60;
      }

      break;
  }

  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  std::vector<std::unique_ptr<AMCP::IOAudio1::Stream>>::clear[abi:ne200100](v1 + 69);
  std::vector<std::unique_ptr<AMCP::IOAudio1::Stream>>::clear[abi:ne200100](v1 + 66);
  std::vector<std::unique_ptr<AMCP::IOAudio1::Stream>>::clear[abi:ne200100](v1 + 72);
  std::unique_ptr<applesauce::iokit::io_connect_holder>::reset[abi:ne200100](v1 + 52, 0);
  AMCP::Utility::Mach_Port::reset((v1 + 424));
  std::unique_ptr<applesauce::iokit::io_service_notifications>::reset[abi:ne200100](v1 + 51, 0);
  AMCP::Core::Broker::destroy_core(*(*(*(v1 + 5) + 32) + 16), *(v1 + 14));
  v29 = *(v1 + 76);
  if (v29)
  {
    std::__shared_weak_count::__release_weak(v29);
  }

  *buf = v1 + 576;
  std::vector<std::unique_ptr<AMCP::IOAudio1::Stream>>::__destroy_vector::operator()[abi:ne200100](buf);
  *buf = v1 + 552;
  std::vector<std::unique_ptr<AMCP::IOAudio1::Stream>>::__destroy_vector::operator()[abi:ne200100](buf);
  *buf = v1 + 528;
  std::vector<std::unique_ptr<AMCP::IOAudio1::Stream>>::__destroy_vector::operator()[abi:ne200100](buf);
  v30 = *(v1 + 65);
  if (v30)
  {
    CFRelease(v30);
  }

  v31 = *(v1 + 128);
  if (v31)
  {
    IOObjectRelease(v31);
  }

  v32 = *(v1 + 63);
  if (v32)
  {
    CFRelease(v32);
  }

  AMCP::Utility::Mach_Port::~Mach_Port((v1 + 424));
  std::unique_ptr<applesauce::iokit::io_connect_holder>::reset[abi:ne200100](v1 + 52, 0);
  std::unique_ptr<applesauce::iokit::io_service_notifications>::reset[abi:ne200100](v1 + 51, 0);
  v33 = *(v1 + 100);
  if (v33)
  {
    IOObjectRelease(v33);
  }

  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue((v1 + 64));
  v34 = *(v1 + 6);
  if (v34)
  {
    CFRelease(v34);
  }

  v35 = *(v1 + 4);
  if (v35)
  {
    std::__shared_weak_count::__release_weak(v35);
  }

  v36 = *MEMORY[0x1E69E9840];
}

void sub_1DE73B5A0(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_free_exception(v2);
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<AMCP::IOAudio1::Device>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F5990138;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

void std::__function::__func<AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1>,void ()(void)>::destroy_deallocate(void *__p)
{
  v2 = __p[4];
  if (v2)
  {
    CFRelease(v2);
  }

  v3 = *(__p + 6);
  if (v3)
  {
    IOObjectRelease(v3);
  }

  v4 = __p[2];
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  operator delete(__p);
}

void std::__function::__func<AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1>,void ()(void)>::destroy(uint64_t a1)
{
  v2 = *(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
  }

  v3 = *(a1 + 24);
  if (v3)
  {
    IOObjectRelease(v3);
  }

  v4 = *(a1 + 16);
  if (v4)
  {

    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }
}

uint64_t AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1::$_1(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 8);
  *a1 = *a2;
  *(a1 + 8) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
  }

  v5 = *(a2 + 16);
  *(a1 + 16) = v5;
  if (v5)
  {
    v6 = IOObjectRetain(v5);
    if (v6)
    {
      v9 = v6;
      exception = __cxa_allocate_exception(0x20uLL);
      v11 = std::system_category();
      MEMORY[0x1E12C10C0](exception, v9, v11, "Error on Retain");
      __cxa_throw(exception, MEMORY[0x1E69E53B8], MEMORY[0x1E69E52D0]);
    }
  }

  v7 = *(a2 + 24);
  if (v7)
  {
    CFRetain(v7);
  }

  *(a1 + 24) = v7;
  return a1;
}

void sub_1DE73B808(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  v4 = *(v1 + 8);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  _Unwind_Resume(a1);
}

void std::__function::__func<AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  *a1 = &unk_1F59900C8;
  v2 = *(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
  }

  v3 = *(a1 + 24);
  if (v3)
  {
    IOObjectRelease(v3);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  JUMPOUT(0x1E12C1730);
}

uint64_t std::__function::__func<AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_arrival(applesauce::iokit::io_object_holder)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  *a1 = &unk_1F59900C8;
  v2 = *(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
  }

  v3 = *(a1 + 24);
  if (v3)
  {
    IOObjectRelease(v3);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  return a1;
}

void std::__function::__func<AMCP::IOAudio1::Driver::start(void)::$_0,std::allocator<AMCP::IOAudio1::Driver::start(void)::$_0>,void ()(applesauce::iokit::io_object_holder)>::destroy_deallocate(void *__p)
{
  v2 = __p[2];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  operator delete(__p);
}

void std::__function::__func<AMCP::IOAudio1::Driver::start(void)::$_0,std::allocator<AMCP::IOAudio1::Driver::start(void)::$_0>,void ()(applesauce::iokit::io_object_holder)>::destroy(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }
}

uint64_t std::__function::__func<AMCP::IOAudio1::Driver::start(void)::$_0,std::allocator<AMCP::IOAudio1::Driver::start(void)::$_0>,void ()(applesauce::iokit::io_object_holder)>::__clone(uint64_t result, void *a2)
{
  v3 = *(result + 8);
  v2 = *(result + 16);
  *a2 = &unk_1F598FBA8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void std::__function::__func<AMCP::IOAudio1::Driver::start(void)::$_0,std::allocator<AMCP::IOAudio1::Driver::start(void)::$_0>,void ()(applesauce::iokit::io_object_holder)>::~__func(void *a1)
{
  *a1 = &unk_1F598FBA8;
  v1 = a1[2];
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  JUMPOUT(0x1E12C1730);
}

void *std::__function::__func<AMCP::IOAudio1::Driver::start(void)::$_0,std::allocator<AMCP::IOAudio1::Driver::start(void)::$_0>,void ()(applesauce::iokit::io_object_holder)>::~__func(void *a1)
{
  *a1 = &unk_1F598FBA8;
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  return a1;
}

uint64_t std::__function::__func<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "ZN4AMCP8IOAudio16Driver23handle_device_departureEPNS0_6DeviceEE3$_1"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void std::__function::__func<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  v22 = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 40);
  is_valid = AMCP::Utility::Expiration_Check::is_valid((a1 + 8));
  if (!is_valid)
  {
    v12 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v12 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(is_valid);
    }

    v14 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v13 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      v15 = *v14;
      std::__shared_weak_count::__release_shared[abi:ne200100](v13);
    }

    else
    {
      v15 = *v14;
    }

    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v16 = 136315650;
      v17 = "IOAudio1_Driver.cpp";
      v18 = 1024;
      v19 = 147;
      v20 = 2080;
      v21 = "expiration_check.is_valid()";
      _os_log_error_impl(&dword_1DE1F9000, v15, OS_LOG_TYPE_ERROR, "%32s:%-5d Assertion Failed: %s caller has gone out of scope", &v16, 0x1Cu);
    }

    abort();
  }

  v4 = **(a1 + 48);
  v5 = *(v2 + 72);
  if (v4 + 16 != v5)
  {
    do
    {
      v6 = *(v4 + 16);
      *(v4 + 16) = 0;
      *(v4 + 24) = 0;
      v7 = *(v4 + 8);
      *v4 = v6;
      if (v7)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v7);
      }

      v8 = v4 + 16;
      v9 = v4 + 32;
      v4 += 16;
    }

    while (v9 != v5);
    v5 = *(v2 + 72);
    v4 = v8;
  }

  while (v5 != v4)
  {
    v10 = *(v5 - 8);
    if (v10)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v10);
    }

    v5 -= 16;
  }

  *(v2 + 72) = v4;
  v11 = *MEMORY[0x1E69E9840];
}

void std::__function::__func<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1>,void ()(void)>::destroy_deallocate(void *a1)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::shared_ptr<std::byte>,std::weak_ptr<std::byte>>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](a1 + 8);

  operator delete(a1);
}

__n128 std::__function::__func<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F5990198;
  AMCP::Utility::Expiration_Check::Expiration_Check(a2 + 8, (a1 + 8));
  result = *(a1 + 40);
  *(a2 + 40) = result;
  return result;
}

void std::__function::__func<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F5990198;
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::shared_ptr<std::byte>,std::weak_ptr<std::byte>>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100]((a1 + 1));

  JUMPOUT(0x1E12C1730);
}

void *std::__function::__func<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1,std::allocator<AMCP::IOAudio1::Driver::handle_device_departure(AMCP::IOAudio1::Device *)::$_1>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F5990198;
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::shared_ptr<std::byte>,std::weak_ptr<std::byte>>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100]((a1 + 1));
  return a1;
}

void AMCP::Core::Conductor::Conductor_Graph_Manager::get_clock_device_list(AMCP::Core::Conductor::Conductor_Graph_Manager *this@<X0>, void *a2@<X8>)
{
  v36 = *MEMORY[0x1E69E9840];
  v4 = *(this + 54);
  v5 = *(this + 55);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v6 = (*(*v4 + 16))(v4);
  AMCP::Core::Broker::fetch_core(&v25, v6, 1u);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v5);
  }

  if (!v25)
  {
    v11 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v11 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v7);
    }

    v13 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v12 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      v14 = *v13;
      std::__shared_weak_count::__release_shared[abi:ne200100](v12);
    }

    else
    {
      v14 = *v13;
    }

    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      v28 = "Conductor.cpp";
      v29 = 1024;
      v30 = 752;
      v31 = 2080;
      v32 = "not (system_core != nullptr)";
      _os_log_error_impl(&dword_1DE1F9000, v14, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v24);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("", &v16);
    std::logic_error::logic_error(&v17, &v16);
    v17.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v18, &v17);
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = -1;
    v18.__vftable = &unk_1F5991430;
    v19 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v18);
    v33 = "virtual std::vector<Object_ID> AMCP::Core::Conductor::Conductor_Graph_Manager::get_clock_device_list() const";
    v34 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/Core/Conductor.cpp";
    v35 = 752;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(&v15);
  }

  AMCP::Core::Core::get_simple_required_property<1668049699u>(a2, v25);
  v8 = v26;
  if (v26)
  {
    v9 = *MEMORY[0x1E69E9840];

    std::__shared_weak_count::__release_shared[abi:ne200100](v8);
  }

  else
  {
    v10 = *MEMORY[0x1E69E9840];
  }
}

void sub_1DE73C1F8(_Unwind_Exception *a1, int a2)
{
  if (!a2)
  {
    _Unwind_Resume(a1);
  }

  __clang_call_terminate(a1);
}

void AMCP::Core::Conductor::Conductor_Graph_Manager::get_device_list(AMCP::Core::Conductor::Conductor_Graph_Manager *this@<X0>, void *a2@<X8>)
{
  v36 = *MEMORY[0x1E69E9840];
  v4 = *(this + 54);
  v5 = *(this + 55);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v6 = (*(*v4 + 16))(v4);
  AMCP::Core::Broker::fetch_core(&v25, v6, 1u);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v5);
  }

  if (!v25)
  {
    v11 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v11 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v7);
    }

    v13 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v12 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      v14 = *v13;
      std::__shared_weak_count::__release_shared[abi:ne200100](v12);
    }

    else
    {
      v14 = *v13;
    }

    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      v28 = "Conductor.cpp";
      v29 = 1024;
      v30 = 743;
      v31 = 2080;
      v32 = "not (system_core != nullptr)";
      _os_log_error_impl(&dword_1DE1F9000, v14, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
    }

    AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v24);
    __cxa_allocate_exception(0x40uLL);
    caulk::make_string("", &v16);
    std::logic_error::logic_error(&v17, &v16);
    v17.__vftable = (MEMORY[0x1E69E55A8] + 16);
    std::logic_error::logic_error(&v18, &v17);
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = -1;
    v18.__vftable = &unk_1F5991430;
    v19 = &unk_1F5991458;
    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v18);
    v33 = "virtual std::vector<Object_ID> AMCP::Core::Conductor::Conductor_Graph_Manager::get_device_list() const";
    v34 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/Core/Conductor.cpp";
    v35 = 743;
    applesauce::backtrace::snapshot_N<64>::snapshot_N(&v15);
  }

  AMCP::Core::Core::get_simple_required_property<1684370979u>(a2, v25);
  v8 = v26;
  if (v26)
  {
    v9 = *MEMORY[0x1E69E9840];

    std::__shared_weak_count::__release_shared[abi:ne200100](v8);
  }

  else
  {
    v10 = *MEMORY[0x1E69E9840];
  }
}

void sub_1DE73C514(_Unwind_Exception *a1, int a2)
{
  if (!a2)
  {
    _Unwind_Resume(a1);
  }

  __clang_call_terminate(a1);
}

void AMCP::Core::Conductor::Conductor_Graph_Manager::call_external_ioc_graph_update_observers(AMCP::Core::Conductor::Conductor_Graph_Manager *this, unsigned int a2)
{
  v18[4] = *MEMORY[0x1E69E9840];
  v3 = *(this + 53);
  std::__shared_mutex_base::lock_shared((v3 + 1832));
  if (*(v3 + 2000))
  {
    v12 = 0uLL;
    *&v13 = 0;
    if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find( *(v3 + 2008),  *(v3 + 2016),  a2))
    {
      AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> const*>>(&v12, *(v4 + 8), *(v4 + 16));
    }

    v5 = *(v3 + 2040);
    if (v5 != a2
      && AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find( *(v3 + 2008),  *(v3 + 2016),  v5))
    {
      AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> const*>>(&v12, *(v6 + 8), *(v6 + 16));
    }
  }

  else
  {
    v12 = 0u;
    v13 = 0u;
  }

  std::__shared_mutex_base::unlock_shared((v3 + 1832));
  v7 = *(&v12 + 1);
  for (i = v12; i != v7; i += 72)
  {
    v9 = *(i + 32);
    if (!v9)
    {
      std::__throw_bad_function_call[abi:ne200100]();
    }

    (*(*v9 + 48))(v15);
    if (*v15 != *&v15[8])
    {
      AMCP::IO_Core::Graph_Manager::modify_graph_internal(&__p, (v3 + 2696), v15);
    }

    *buf = v18;
    std::vector<AMCP::Wire_Identifier>::__destroy_vector::operator()[abi:ne200100](buf);
    *buf = &v17;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](buf);
    *buf = &v16 + 8;
    std::vector<AMCP::Wire_Description>::__destroy_vector::operator()[abi:ne200100](buf);
    *buf = v15;
    std::vector<AMCP::Node_Description>::__destroy_vector::operator()[abi:ne200100](buf);
  }

  *v15 = &v12;
  std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__destroy_vector::operator()[abi:ne200100](v15);
  v10 = *MEMORY[0x1E69E9840];
}

void sub_1DE73CCEC(void *a1, int a2)
{
  if (!a2)
  {
    JUMPOUT(0x1DE73CCFCLL);
  }

  __clang_call_terminate(a1);
}

void std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v2 = *a1;
  if (*v2)
  {
    std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__base_destruct_at_end[abi:ne200100](v2, *v2);
    v3 = **a1;

    operator delete(v3);
  }
}

void **std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List>::~pair(void **a1)
{
  v2 = a1 + 6;
  v4 = a1 + 9;
  std::vector<AMCP::Wire_Identifier>::__destroy_vector::operator()[abi:ne200100](&v4);
  v4 = v2;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v4);
  v4 = a1 + 3;
  std::vector<AMCP::Wire_Description>::__destroy_vector::operator()[abi:ne200100](&v4);
  v4 = a1;
  std::vector<AMCP::Node_Description>::__destroy_vector::operator()[abi:ne200100](&v4);
  return a1;
}

uint64_t std::function<void ()(AMCP::Graph_Description const&)>::operator()(uint64_t a1)
{
  if (!a1)
  {
    std::__throw_bad_function_call[abi:ne200100]();
  }

  v2 = *(*a1 + 48);

  return v2();
}

uint64_t std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__base_destruct_at_end[abi:ne200100](uint64_t result, uint64_t a2)
{
  v3 = result;
  v4 = *(result + 8);
  if (v4 != a2)
  {
    do
    {
      v5 = v4 - 72;
      v6 = v4 - 64;
      std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::~__value_func[abi:ne200100](v4 - 32);
      result = std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::~__value_func[abi:ne200100](v6);
      v4 = v5;
    }

    while (v5 != a2);
  }

  *(v3 + 8) = a2;
  return result;
}

uint64_t std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> const*>>(uint64_t result, char *a2, char *a3)
{
  if (a2 != a3)
  {
    v4 = a2;
    v5 = result;
    do
    {
      v6 = *v4;
      if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>::find(*v5, v5[1], *v4))
      {
        *v7 = v6;
        v8 = (v7 + 40);
        std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::operator=((v7 + 8), (v4 + 8));
        result = std::function<void ()(AMCP::Graph_Description const&)>::operator=(v8, (v4 + 40));
      }

      else
      {
        result = std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::insert(v5, v7, v4);
      }

      v4 += 72;
    }

    while (v4 != a3);
  }

  return result;
}

BOOL AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>::find(void *a1, void *a2, unint64_t a3)
{
  if (a2 == a1)
  {
    v3 = a2;
  }

  else
  {
    v3 = a1;
    v4 = 0x8E38E38E38E38E39 * (a2 - a1);
    do
    {
      v5 = v4 >> 1;
      v6 = &v3[9 * (v4 >> 1)];
      v8 = *v6;
      v7 = v6 + 9;
      v4 += ~(v4 >> 1);
      if (v8 < a3)
      {
        v3 = v7;
      }

      else
      {
        v4 = v5;
      }
    }

    while (v4);
  }

  return v3 != a2 && *v3 == a3;
}

uint64_t std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::operator=(uint64_t a1, uint64_t a2)
{
  v9[3] = *MEMORY[0x1E69E9840];
  std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::__value_func[abi:ne200100](v7, a2);
  if (v7 != a1)
  {
    v3 = v8;
    v4 = *(a1 + 24);
    if (v8 == v7)
    {
      if (v4 == a1)
      {
        (*(*v8 + 24))();
        (*(*v8 + 32))(v8);
        v8 = 0;
        (*(**(a1 + 24) + 24))(*(a1 + 24), v7);
        (*(**(a1 + 24) + 32))(*(a1 + 24));
        *(a1 + 24) = 0;
        v8 = v7;
        (*(v9[0] + 24))(v9, a1);
        (*(v9[0] + 32))(v9);
      }

      else
      {
        (*(*v8 + 24))();
        (*(*v8 + 32))(v8);
        v8 = *(a1 + 24);
      }

      *(a1 + 24) = a1;
    }

    else if (v4 == a1)
    {
      (*(*v4 + 24))(*(a1 + 24), v7);
      (*(**(a1 + 24) + 32))(*(a1 + 24));
      *(a1 + 24) = v8;
      v8 = v7;
    }

    else
    {
      v8 = *(a1 + 24);
      *(a1 + 24) = v3;
    }
  }

  std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::~__value_func[abi:ne200100](v7);
  v5 = *MEMORY[0x1E69E9840];
  return a1;
}

void sub_1DE73D2FC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(AMCP::Graph_Description const&)>::operator=(uint64_t a1, uint64_t a2)
{
  v9[3] = *MEMORY[0x1E69E9840];
  std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::__value_func[abi:ne200100](v7, a2);
  if (v7 != a1)
  {
    v3 = v8;
    v4 = *(a1 + 24);
    if (v8 == v7)
    {
      if (v4 == a1)
      {
        (*(*v8 + 24))();
        (*(*v8 + 32))(v8);
        v8 = 0;
        (*(**(a1 + 24) + 24))(*(a1 + 24), v7);
        (*(**(a1 + 24) + 32))(*(a1 + 24));
        *(a1 + 24) = 0;
        v8 = v7;
        (*(v9[0] + 24))(v9, a1);
        (*(v9[0] + 32))(v9);
      }

      else
      {
        (*(*v8 + 24))();
        (*(*v8 + 32))(v8);
        v8 = *(a1 + 24);
      }

      *(a1 + 24) = a1;
    }

    else if (v4 == a1)
    {
      (*(*v4 + 24))(*(a1 + 24), v7);
      (*(**(a1 + 24) + 32))(*(a1 + 24));
      *(a1 + 24) = v8;
      v8 = v7;
    }

    else
    {
      v8 = *(a1 + 24);
      *(a1 + 24) = v3;
    }
  }

  std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::~__value_func[abi:ne200100](v7);
  v5 = *MEMORY[0x1E69E9840];
  return a1;
}

void sub_1DE73D588(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

char *std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::insert(void *a1, char *a2, char *a3)
{
  v4 = a2;
  v7 = a1[1];
  v6 = a1[2];
  if (v7 >= v6)
  {
    v16 = *a1;
    v17 = 0x8E38E38E38E38E39 * (&v7[-*a1] >> 3) + 1;
    if (v17 > 0x38E38E38E38E38ELL)
    {
      std::vector<void *>::__throw_length_error[abi:ne200100]();
    }

    v18 = a2 - v16;
    v19 = 0x8E38E38E38E38E39 * ((v6 - v16) >> 3);
    if (2 * v19 > v17)
    {
      v17 = 2 * v19;
    }

    if (v19 >= 0x1C71C71C71C71C7)
    {
      v20 = 0x38E38E38E38E38ELL;
    }

    else
    {
      v20 = v17;
    }

    v33 = a1;
    if (v20)
    {
      std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::allocate_at_least[abi:ne200100](v20);
    }

    v21 = (8 * (v18 >> 3));
    v30 = 0;
    v31 = v21;
    v32 = v21;
    if (!(0x8E38E38E38E38E39 * (v18 >> 3)))
    {
      if (v18 < 1)
      {
        if (v16 == a2)
        {
          v22 = 1;
        }

        else
        {
          v22 = 0x1C71C71C71C71C72 * (v18 >> 3);
        }

        v34 = a1;
        std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::allocate_at_least[abi:ne200100](v22);
      }

      v21 -= 72 * ((1 - 0x71C71C71C71C71C7 * (v18 >> 3)) >> 1);
      v31 = v21;
      *&v32 = v21;
    }

    *v21 = *a3;
    std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>::pair[abi:ne200100]((v21 + 8), (a3 + 8));
    v23 = v31;
    *&v32 = v32 + 72;
    std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*>(a1, v4, a1[1], v32);
    v24 = *a1;
    v25 = v31;
    *&v32 = v32 + a1[1] - v4;
    a1[1] = v4;
    v26 = (v25 + v24 - v4);
    std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*>(a1, v24, v4, v26);
    v27 = *a1;
    *a1 = v26;
    v28 = a1[2];
    *(a1 + 1) = v32;
    *&v32 = v27;
    *(&v32 + 1) = v28;
    v30 = v27;
    v31 = v27;
    std::__split_buffer<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::~__split_buffer(&v30);
    return v23;
  }

  else if (a2 == v7)
  {
    *v7 = *a3;
    std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>::pair[abi:ne200100]((v7 + 8), (a3 + 8));
    a1[1] = v7 + 72;
  }

  else
  {
    v8 = a2 + 72;
    v9 = a1[1];
    if (v7 >= 0x48)
    {
      v10 = 0;
      do
      {
        *&v7[v10] = *&v7[v10 - 72];
        std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::__value_func[abi:ne200100](&v7[v10 + 8], &v7[v10 - 64]);
        std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::__value_func[abi:ne200100](&v7[v10 + 40], &v7[v10 - 32]);
        v10 += 72;
      }

      while (&v7[v10 - 72] < v7);
      v9 = &v7[v10];
    }

    a1[1] = v9;
    if (v7 != v8)
    {
      v11 = 0;
      do
      {
        *&v7[v11 - 72] = *&v7[v11 - 144];
        std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>::operator=[abi:ne200100](&v7[v11 - 64], &v7[v11 - 136]);
        v11 -= 72;
      }

      while (v4 - v7 + 72 != v11);
      v9 = a1[1];
    }

    v12 = v9 <= a3 || v4 > a3;
    v13 = 72;
    if (v12)
    {
      v13 = 0;
    }

    v14 = &a3[v13];
    v15 = (v14 + 40);
    *v4 = *v14;
    std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::operator=((v4 + 8), (v14 + 8));
    std::function<void ()(AMCP::Graph_Description const&)>::operator=((v4 + 40), v15);
  }

  return v4;
}

uint64_t std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>::pair[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v4 = std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::__value_func[abi:ne200100](a1, a2);
  std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::__value_func[abi:ne200100](v4 + 32, a2 + 32);
  return a1;
}

void std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::allocate_at_least[abi:ne200100](unint64_t a1)
{
  if (a1 < 0x38E38E38E38E38FLL)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

uint64_t std::__split_buffer<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 72;
    v4 = i - 64;
    std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::~__value_func[abi:ne200100](i - 32);
    std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::~__value_func[abi:ne200100](v4);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*>(uint64_t a1, void *a2, void *a3, void *a4)
{
  v13 = a4;
  v14 = a4;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a2 == a3)
  {
    v12 = 1;
  }

  else
  {
    v5 = a2;
    v6 = a2;
    v7 = a2;
    do
    {
      v8 = *v7;
      v7 += 9;
      *a4 = v8;
      v9 = (a4 + 5);
      std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::__value_func[abi:ne200100]((a4 + 1), (v6 + 1));
      std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::__value_func[abi:ne200100](v9, (v6 + 5));
      a4 = v14 + 9;
      v14 += 9;
      v6 = v7;
    }

    while (v7 != a3);
    v12 = 1;
    do
    {
      std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::~__value_func[abi:ne200100]((v5 + 5));
      std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::~__value_func[abi:ne200100]((v5 + 1));
      v5 += 9;
    }

    while (v5 != a3);
  }

  return std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*>>::~__exception_guard_exceptions[abi:ne200100](v11);
}

uint64_t std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::__value_func[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

uint64_t std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::__value_func[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*>>::~__exception_guard_exceptions[abi:ne200100](uint64_t a1)
{
  if ((*(a1 + 24) & 1) == 0)
  {
    v2 = **(a1 + 16);
    v3 = **(a1 + 8);
    if (v2 != v3)
    {
      do
      {
        v4 = v2 - 72;
        v5 = v2 - 64;
        std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::~__value_func[abi:ne200100](v2 - 32);
        std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::~__value_func[abi:ne200100](v5);
        v2 = v4;
      }

      while (v4 != v3);
    }
  }

  return a1;
}

uint64_t std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>::operator=[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v5 = (a1 + 24);
  v4 = *(a1 + 24);
  *v5 = 0;
  if (v4 == a1)
  {
    (*(*v4 + 32))(v4);
  }

  else if (v4)
  {
    (*(*v4 + 40))(v4);
  }

  v6 = (a2 + 24);
  v7 = *(a2 + 24);
  if (!v7)
  {
    v6 = v5;
    goto LABEL_9;
  }

  if (v7 != a2)
  {
    *v5 = v7;
LABEL_9:
    *v6 = 0;
    goto LABEL_11;
  }

  *(a1 + 24) = a1;
  (*(**v6 + 24))(*v6, a1);
LABEL_11:
  v9 = (a1 + 56);
  v8 = *(a1 + 56);
  *(a1 + 56) = 0;
  if (v8 == a1 + 32)
  {
    (*(*v8 + 32))(v8);
  }

  else if (v8)
  {
    (*(*v8 + 40))(v8);
  }

  v10 = (a2 + 56);
  v11 = *(a2 + 56);
  if (v11)
  {
    if (v11 == a2 + 32)
    {
      *v9 = a1 + 32;
      (*(**v10 + 24))(*v10, a1 + 32);
      return a1;
    }

    *v9 = v11;
  }

  else
  {
    v10 = (a1 + 56);
  }

  *v10 = 0;
  return a1;
}

void AMCP::Core::Conductor::enqueue_config_change(uint64_t a1, unsigned int a2, unsigned int a3, char a4)
{
  v29 = *MEMORY[0x1E69E9840];
  std::mutex::lock((a1 + 1040));
  if ((a4 & 2) != 0)
  {
    operator new();
  }

  v8 = *(a1 + 1152);
  v9 = *(a1 + 1160);
  if (v9 == v8)
  {
    v8 = *(a1 + 1160);
  }

  else
  {
    v10 = (v9 - v8) >> 4;
    do
    {
      v11 = v10 >> 1;
      v12 = &v8[16 * (v10 >> 1)];
      v14 = *v12;
      v13 = v12 + 16;
      v10 += ~(v10 >> 1);
      if (*(v14 + 160) < a2)
      {
        v8 = v13;
      }

      else
      {
        v10 = v11;
      }
    }

    while (v10);
  }

  if (v9 == v8 || (v15 = *v8, *(*v8 + 160) != a2))
  {
    operator new();
  }

  v16 = *(v8 + 1);
  if (v16)
  {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v26 = v15;
  v27 = v16;
  std::mutex::unlock((a1 + 1040));
  if (v26)
  {
    std::mutex::lock(v26);
    v18 = *(v26 + 168);
    v17 = *(v26 + 176);
    if (v17 == v18)
    {
      v18 = *(v26 + 176);
    }

    else
    {
      v19 = (v17 - v18) >> 4;
      do
      {
        v20 = v19 >> 1;
        v21 = &v18[16 * (v19 >> 1)];
        v23 = *v21;
        v22 = (v21 + 2);
        v19 += ~(v19 >> 1);
        if (*v23 < a3)
        {
          v18 = v22;
        }

        else
        {
          v19 = v20;
        }
      }

      while (v19);
    }

    if (v17 != v18 && **v18 == a3)
    {
      v24 = *(v18 + 1);
      if (v24)
      {
        atomic_fetch_add_explicit(v24 + 1, 1uLL, memory_order_relaxed);
      }

      operator new();
    }

    AMCP::Utility::Dispatch_Queue::Dispatch_Queue(queue, (a1 + 704));
    operator new();
  }

  if (v27)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v27);
  }

  v25 = *MEMORY[0x1E69E9840];
}

void sub_1DE73EC18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  std::__split_buffer<std::shared_ptr<DSP_Host_Types::FormatDescription>>::~__split_buffer(va);
  std::mutex::unlock((v13 + 1040));
  std::__shared_weak_count::__release_shared[abi:ne200100](v14);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<AMCP::Core::Conductor::enqueue_config_change(unsigned int,unsigned int,unsigned int,std::function<void ()(void)> const&)::$_0,std::default_delete<AMCP::Core::Conductor::enqueue_config_change(unsigned int,unsigned int,unsigned int,std::function<void ()(void)> const&)::$_0>>::~unique_ptr[abi:ne200100](uint64_t *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(v2 + 40);
    if (v3)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v3);
    }

    v4 = *(v2 + 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v4);
    }

    MEMORY[0x1E12C1730](v2, 0x1020C4045C5CA15);
  }

  return a1;
}

uint64_t *applesauce::dispatch::v1::async<AMCP::Core::Conductor::enqueue_config_change(unsigned int,unsigned int,unsigned int,std::function<void ()(void)> const&)::$_0>(dispatch_queue_s *,AMCP::Core::Conductor::enqueue_config_change(unsigned int,unsigned int,unsigned int,std::function<void ()(void)> const&)::$_0 &&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  v161 = *MEMORY[0x1E69E9840];
  v121 = a1;
  v2 = *(a1 + 32);
  std::mutex::lock(v2);
  v3 = *(a1 + 32);
  v4 = *(v3 + 168);
  v5 = *(v3 + 176);
  if (v4 == v5)
  {
LABEL_191:
    std::mutex::unlock(v2);
  }

  else
  {
    v6 = 0;
    do
    {
      v7 = *v4;
      v4 += 2;
      v6 += *(v7 + 344) + ((*(v7 + 360) - *(v7 + 352)) >> 4);
    }

    while (v4 != v5);
    std::mutex::unlock(v2);
    if (v6)
    {
      do
      {
        v8 = *a1;
        v118 = *(a1 + 16);
        v120 = *(a1 + 20);
        v9 = *(a1 + 24);
        AMCP::Utility::Dispatch_Queue::Dispatch_Queue(&queue, (*a1 + 32));
        dispatch_assert_queue_V2(queue);
        AMCP::Utility::Dispatch_Queue::~Dispatch_Queue(&queue);
        v11 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v11 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(v10);
        }

        v12 = StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v13 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v14 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        v15 = *(v13 + 16);
        switch(v15)
        {
          case 3:
            v25 = *v12;
            v26 = **v12;
            v18 = v25[1];
            if (v18)
            {
              atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            }

            if (!*MEMORY[0x1E69E3C08])
            {
LABEL_194:
              __break(1u);
            }

            v19 = *(v26 + 8);
            v20 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
            v21 = v20;
            *(v20 + 8) = 0;
            *(v20 + 16) = 0;
            *(v20 + 20) = 1;
            *(v20 + 24) = "Conductor.cpp";
            *(v20 + 32) = 315;
            *(v20 + 36) = v120;
            *(v20 + 40) = v118;
            v22 = &unk_1F5990850;
            break;
          case 2:
            v23 = *v12;
            v24 = **v12;
            v18 = v23[1];
            if (v18)
            {
              atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            }

            if (!*MEMORY[0x1E69E3C08])
            {
              goto LABEL_194;
            }

            v19 = *(v24 + 8);
            v20 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
            v21 = v20;
            *(v20 + 8) = 0;
            *(v20 + 16) = 0;
            *(v20 + 20) = 2;
            *(v20 + 24) = "Conductor.cpp";
            *(v20 + 32) = 315;
            *(v20 + 36) = v120;
            *(v20 + 40) = v118;
            v22 = &unk_1F59907F8;
            break;
          case 1:
            v16 = *v12;
            v17 = **v12;
            v18 = v16[1];
            if (v18)
            {
              atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            }

            if (!*MEMORY[0x1E69E3C08])
            {
              goto LABEL_194;
            }

            v19 = *(v17 + 8);
            v20 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
            v21 = v20;
            *(v20 + 8) = 0;
            *(v20 + 16) = 0;
            *(v20 + 20) = 0;
            *(v20 + 24) = "Conductor.cpp";
            *(v20 + 32) = 315;
            *(v20 + 36) = v120;
            *(v20 + 40) = v118;
            v22 = &unk_1F59907A0;
            break;
          default:
            goto LABEL_26;
        }

        *v20 = v22;
        caulk::concurrent::messenger::enqueue(v19, v21);
        if (v18)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v18);
        }

LABEL_26:
        if (v14)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v14);
        }

        LODWORD(v145) = v120;
        v123 = 0;
        __dst = 0;
        v125 = 0;
        AMCP::Core::Broker::fetch_core(&v130, *(*(v8 + 16) + 16), v120);
        v28 = v130;
        if (!v130)
        {
          v35 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v35 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v27);
          }

          v36 = StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v37 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v38 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v38)
          {
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          v39 = *(v37 + 16);
          switch(v39)
          {
            case 1:
              v64 = *v36;
              v65 = **v36;
              v42 = v64[1];
              if (v42)
              {
                atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
              }

              if (!*MEMORY[0x1E69E3C08])
              {
                goto LABEL_194;
              }

              v43 = *(v65 + 8);
              v66 = v145;
              v45 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
              v46 = v45;
              *(v45 + 8) = 0;
              *(v45 + 16) = 0;
              *(v45 + 20) = 0;
              *(v45 + 24) = "Conductor.cpp";
              *(v45 + 32) = 240;
              *(v45 + 36) = v66;
              *(v45 + 40) = v118;
              v47 = &unk_1F59904A8;
              break;
            case 2:
              v61 = *v36;
              v62 = **v36;
              v42 = v61[1];
              if (v42)
              {
                atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
              }

              if (!*MEMORY[0x1E69E3C08])
              {
                goto LABEL_194;
              }

              v43 = *(v62 + 8);
              v63 = v145;
              v45 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
              v46 = v45;
              *(v45 + 8) = 0;
              *(v45 + 16) = 0;
              *(v45 + 20) = 2;
              *(v45 + 24) = "Conductor.cpp";
              *(v45 + 32) = 240;
              *(v45 + 36) = v63;
              *(v45 + 40) = v118;
              v47 = &unk_1F5990500;
              break;
            case 3:
              v40 = *v36;
              v41 = **v36;
              v42 = v40[1];
              if (v42)
              {
                atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
              }

              if (!*MEMORY[0x1E69E3C08])
              {
                goto LABEL_194;
              }

              v43 = *(v41 + 8);
              v44 = v145;
              v45 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
              v46 = v45;
              *(v45 + 8) = 0;
              *(v45 + 16) = 0;
              *(v45 + 20) = 1;
              *(v45 + 24) = "Conductor.cpp";
              *(v45 + 32) = 240;
              *(v45 + 36) = v44;
              *(v45 + 40) = v118;
              v47 = &unk_1F5990558;
              break;
            default:
LABEL_76:
              if (v38)
              {
                std::__shared_weak_count::__release_shared[abi:ne200100](v38);
              }

LABEL_91:
              v151 = 0;
              v152 = 0;
              v153 = 0;
              v73 = v123;
              std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(&v151, v123, __dst, (__dst - v123) >> 2);
              v34 = -1;
              goto LABEL_95;
          }

          *v45 = v47;
          caulk::concurrent::messenger::enqueue(v43, v46);
          if (v42)
          {
            std::__shared_weak_count::__release_shared[abi:ne200100](v42);
          }

          goto LABEL_76;
        }

        *&queue = 0x676C6F6262636C73;
        DWORD2(queue) = 0;
        v29 = AMCP::Core::Core::get_typed_property_value<unsigned int,std::enable_if<true,void>>(v130, &queue, &AMCP::k_class_id_unknown);
        if (!v29)
        {
          v48 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v48 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v29);
          }

          v49 = StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v50 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v51 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v51)
          {
            atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          v52 = *(v50 + 16);
          switch(v52)
          {
            case 1:
              v70 = *v49;
              v71 = **v49;
              v55 = v70[1];
              if (v55)
              {
                atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
              }

              if (!*MEMORY[0x1E69E3C08])
              {
                goto LABEL_194;
              }

              v56 = *(v71 + 8);
              v72 = v145;
              v58 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
              v59 = v58;
              *(v58 + 8) = 0;
              *(v58 + 16) = 0;
              *(v58 + 20) = 0;
              *(v58 + 24) = "Conductor.cpp";
              *(v58 + 32) = 246;
              *(v58 + 36) = v72;
              *(v58 + 40) = v118;
              v60 = &unk_1F59905B0;
              break;
            case 2:
              v67 = *v49;
              v68 = **v49;
              v55 = v67[1];
              if (v55)
              {
                atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
              }

              if (!*MEMORY[0x1E69E3C08])
              {
                goto LABEL_194;
              }

              v56 = *(v68 + 8);
              v69 = v145;
              v58 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
              v59 = v58;
              *(v58 + 8) = 0;
              *(v58 + 16) = 0;
              *(v58 + 20) = 2;
              *(v58 + 24) = "Conductor.cpp";
              *(v58 + 32) = 246;
              *(v58 + 36) = v69;
              *(v58 + 40) = v118;
              v60 = &unk_1F5990608;
              break;
            case 3:
              v53 = *v49;
              v54 = **v49;
              v55 = v53[1];
              if (v55)
              {
                atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
              }

              if (!*MEMORY[0x1E69E3C08])
              {
                goto LABEL_194;
              }

              v56 = *(v54 + 8);
              v57 = v145;
              v58 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
              v59 = v58;
              *(v58 + 8) = 0;
              *(v58 + 16) = 0;
              *(v58 + 20) = 1;
              *(v58 + 24) = "Conductor.cpp";
              *(v58 + 32) = 246;
              *(v58 + 36) = v57;
              *(v58 + 40) = v118;
              v60 = &unk_1F5990660;
              break;
            default:
LABEL_89:
              if (v51)
              {
                std::__shared_weak_count::__release_shared[abi:ne200100](v51);
              }

              goto LABEL_91;
          }

          *v58 = v60;
          caulk::concurrent::messenger::enqueue(v56, v59);
          if (v55)
          {
            std::__shared_weak_count::__release_shared[abi:ne200100](v55);
          }

          goto LABEL_89;
        }

        v30 = v29;
        *&queue = 0x676C6F626F776E72;
        DWORD2(queue) = 0;
        v31 = AMCP::Core::Core::get_typed_property_value<unsigned int,std::enable_if<true,void>>(v28, &queue, &AMCP::k_object_id_unknown);
        LODWORD(v143) = v31;
        v32 = *(*(v8 + 16) + 16);
        *&queue = &unk_1F59906B8;
        *(&v156 + 1) = &queue;
        first_object_id_if = AMCP::Core::Broker::fetch_first_object_id_if (v32, &queue);
        std::__function::__value_func<BOOL ()(std::shared_ptr<AMCP::Core::Core> const&)>::~__value_func[abi:ne200100](&queue);
        LODWORD(v141) = first_object_id_if;
        if (AMCP::is_base_of(0x61706C67, v30))
        {
          std::vector<unsigned int>::push_back[abi:ne200100](&v123, &v145);
          v34 = 6;
          if (!first_object_id_if || first_object_id_if == v120)
          {
            goto LABEL_94;
          }

LABEL_59:
          std::vector<unsigned int>::push_back[abi:ne200100](&v123, &v141);
          goto LABEL_94;
        }

        if (!AMCP::is_base_of(0x61646576, v30))
        {
          if (v120 == 1 && (v9 & 4) != 0)
          {
            std::vector<unsigned int>::push_back[abi:ne200100](&v123, &v145);
            __p = 0uLL;
            *&v139 = 0;
            v148 = 0x676C6F6263747823;
            LODWORD(v149) = 0;
            AMCP::Core::Core::get_typed_property_value<std::vector<unsigned int>,std::enable_if<true,void>>(&queue, v28, &v148, &__p);
            std::vector<unsigned int>::__insert_with_size[abi:ne200100]<std::__wrap_iter<unsigned int *>,std::__wrap_iter<unsigned int *>>(&v123, __dst, queue, *(&queue + 1), (*(&queue + 1) - queue) >> 2);
            v148 = 0;
            v149 = 0;
            v150 = 0;
            __lk.__m_ = 0x676C6F626E6F6423;
            *&__lk.__owns_ = 0;
            AMCP::Core::Core::get_typed_property_value<std::vector<unsigned int>,std::enable_if<true,void>>(&__p, v28, &__lk, &v148);
            std::vector<unsigned int>::__insert_with_size[abi:ne200100]<std::__wrap_iter<unsigned int *>,std::__wrap_iter<unsigned int *>>(&v123, __dst, __p, *(&__p + 1), (*(&__p + 1) - __p) >> 2);
            if (__p)
            {
              *(&__p + 1) = __p;
              operator delete(__p);
            }

            if (queue)
            {
              *(&queue + 1) = queue;
              operator delete(queue);
            }
          }

          else
          {
            std::vector<unsigned int>::push_back[abi:ne200100](&v123, &v145);
          }

          v34 = 5;
          goto LABEL_94;
        }

        std::vector<unsigned int>::push_back[abi:ne200100](&v123, &v143);
        v34 = 6;
        if (first_object_id_if && first_object_id_if != v31)
        {
          goto LABEL_59;
        }

LABEL_94:
        v151 = 0;
        v152 = 0;
        v153 = 0;
        v73 = v123;
        std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(&v151, v123, __dst, (__dst - v123) >> 2);
LABEL_95:
        v154 = v34;
        if (v131)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v131);
        }

        if (v73)
        {
          operator delete(v73);
        }

        if (v34 != -1)
        {
          AMCP::Core::Broker::make_snapshot(&v148, *(*(v8 + 16) + 16), &v151, v34);
          v158 = 0u;
          v159 = 0u;
          v156 = 0u;
          v157 = 0u;
          queue = 0u;
          v160 = 1065353216;
          AMCP::Core::Conductor::call_external_begin_config_change_observers(v8, 1, v120, v9 & 1, &queue);
          std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>>>::~__hash_table(&v158);
          if (*(&v156 + 1))
          {
            *&v157 = *(&v156 + 1);
            operator delete(*(&v156 + 1));
          }

          if (queue)
          {
            *(&queue + 1) = queue;
            operator delete(queue);
          }

          v158 = 0u;
          v159 = 0u;
          v156 = 0u;
          v157 = 0u;
          queue = 0u;
          v160 = 1065353216;
          LODWORD(v123) = v120;
          LOBYTE(__p) = v9 & 1;
          AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_sync<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&>(v8 + 1184, &v123, &v123, &__p, &queue);
          std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>>>::~__hash_table(&v158);
          if (*(&v156 + 1))
          {
            *&v157 = *(&v156 + 1);
            operator delete(*(&v156 + 1));
          }

          if (queue)
          {
            *(&queue + 1) = queue;
            operator delete(queue);
          }

          v145 = 0;
          v146 = 0;
          v147 = 0;
          v144[0] = 0;
          v144[1] = 0;
          v143 = v144;
          AMCP::Core::Conductor::Conductor_Graph_Manager::get_device_list((v8 + 2696), &v141);
          v139 = 0u;
          v140 = 0u;
          __p = 0u;
          v137[0] = 0;
          v137[1] = 0;
          v136 = v137;
          __lk.__m_ = *(a1 + 32);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          v74 = *(a1 + 32);
          v76 = *(v74 + 168);
          v75 = *(v74 + 176);
          if (v76 != v75)
          {
            v77 = 0;
            v78 = *(v74 + 168);
            do
            {
              v79 = *v78;
              v78 += 2;
              v77 += v79[86] + ((*(v79 + 45) - *(v79 + 44)) >> 4);
            }

            while (v78 != v75);
            if (v77)
            {
              do
              {
                v119 = v75;
                if (v76 != v75)
                {
                  do
                  {
                    v80 = *(*v76 + 44);
                    if (v80 != *(*v76 + 45))
                    {
                      v81 = **v76;
                      if (v81 != v120)
                      {
                        v158 = 0u;
                        v159 = 0u;
                        v156 = 0u;
                        v157 = 0u;
                        queue = 0u;
                        v160 = 1065353216;
                        LODWORD(v130) = v81;
                        LOBYTE(v133) = v9 & 1;
                        AMCP::Core::make_external_diff(&v123, &queue);
                        AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_sync<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>((v8 + 2264), &v130, &v130, &v133);
                        boost::container::vector<boost::container::dtl::pair<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>>,boost::container::new_allocator<boost::container::dtl::pair<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>>>,void>::~vector(v128);
                        if (v126)
                        {
                          v127 = v126;
                          operator delete(v126);
                        }

                        if (v123)
                        {
                          __dst = v123;
                          operator delete(v123);
                        }

                        std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>>>::~__hash_table(&v158);
                        if (*(&v156 + 1))
                        {
                          *&v157 = *(&v156 + 1);
                          operator delete(*(&v156 + 1));
                        }

                        if (queue)
                        {
                          *(&queue + 1) = queue;
                          operator delete(queue);
                        }
                      }

                      v130 = 0;
                      v131 = 0;
                      v132 = 0;
                      std::__tree<DSP_Host_Types::AudioProcessingType>::__emplace_unique_key_args<DSP_Host_Types::AudioProcessingType,DSP_Host_Types::AudioProcessingType>(&v136, **v76);
                      AMCP::IO_Core::Graph_Manager::prepare_graph_for_config_change(&v123, (v8 + 2696), **v80, **v76, &v130, &v143);
                      std::vector<std::shared_ptr<AMCP::Graph::Timebase>>::__insert_with_size[abi:ne200100]<std::__wrap_iter<std::shared_ptr<AMCP::Graph::Timebase>*>,std::__wrap_iter<std::shared_ptr<AMCP::Graph::Timebase>*>>(&v145, v146, v130, v131, (v131 - v130) >> 4);
                      std::vector<unsigned int>::__insert_with_size[abi:ne200100]<std::__wrap_iter<unsigned int *>,std::__wrap_iter<unsigned int *>>(&__p, *(&__p + 1), v123, __dst, (__dst - v123) >> 2);
                      v82 = v126;
                      v83 = v127 - v126;
                      if (v127 - v126 >= 1)
                      {
                        v84 = v140;
                        if (*(&v140 + 1) - v140 >= v83)
                        {
                          *&v140 = std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(&v139 + 8, v126, v127, v140);
                        }

                        else
                        {
                          v85 = 0xAAAAAAAAAAAAAAABLL * ((v140 - *(&v139 + 1)) >> 3) - 0x5555555555555555 * (v83 >> 3);
                          if (v85 > 0xAAAAAAAAAAAAAAALL)
                          {
                            std::vector<void *>::__throw_length_error[abi:ne200100]();
                          }

                          if (0x5555555555555556 * ((*(&v140 + 1) - *(&v139 + 1)) >> 3) > v85)
                          {
                            v85 = 0x5555555555555556 * ((*(&v140 + 1) - *(&v139 + 1)) >> 3);
                          }

                          if (0xAAAAAAAAAAAAAAABLL * ((*(&v140 + 1) - *(&v139 + 1)) >> 3) >= 0x555555555555555)
                          {
                            v86 = 0xAAAAAAAAAAAAAAALL;
                          }

                          else
                          {
                            v86 = v85;
                          }

                          *&v157 = &v139 + 8;
                          if (v86)
                          {
                            std::allocator<std::string>::allocate_at_least[abi:ne200100](v86);
                          }

                          v87 = (8 * ((v140 - *(&v139 + 1)) >> 3));
                          *&queue = 0;
                          *(&queue + 1) = v87;
                          v156 = v87;
                          v88 = v87 + v83;
                          do
                          {
                            if (v82[23] < 0)
                            {
                              std::string::__init_copy_ctor_external(v87, *v82, *(v82 + 1));
                            }

                            else
                            {
                              v89 = *v82;
                              v87->__r_.__value_.__r.__words[2] = *(v82 + 2);
                              *&v87->__r_.__value_.__l.__data_ = v89;
                            }

                            ++v87;
                            v82 += 24;
                            v83 -= 24;
                          }

                          while (v83);
                          *&v156 = v88;
                          memcpy(v88, v84, v140 - v84);
                          *&v156 = v156 + v140 - v84;
                          *&v140 = v84;
                          v90 = (*(&queue + 1) - (v84 - *(&v139 + 1)));
                          memcpy(v90, *(&v139 + 1), v84 - *(&v139 + 1));
                          v91 = *(&v139 + 1);
                          v92 = *(&v140 + 1);
                          *(&v139 + 1) = v90;
                          v140 = v156;
                          *&v156 = v91;
                          *(&v156 + 1) = v92;
                          *(&queue + 1) = v91;
                          *&queue = v91;
                          std::__split_buffer<std::string>::~__split_buffer(&queue);
                        }
                      }

                      v93 = *v76;
                      ++(*v76)[86];
                      std::shared_ptr<AMCP::IO_Core::IOContext_Core>::shared_ptr[abi:ne200100]<AMCP::IO_Core::IOContext_Core,0>(&queue, *v8, *(v8 + 8));
                      v94 = *(a1 + 40);
                      *&v156 = *(a1 + 32);
                      *(&v156 + 1) = v94;
                      if (v94)
                      {
                        atomic_fetch_add_explicit((v94 + 8), 1uLL, memory_order_relaxed);
                      }

                      *&v157 = *v76;
                      v95 = v76[1];
                      *(&v157 + 1) = v95;
                      if (v95)
                      {
                        atomic_fetch_add_explicit(v95 + 1, 1uLL, memory_order_relaxed);
                      }

                      *&v158 = *v80;
                      v96 = *(v80 + 8);
                      *(&v158 + 1) = v96;
                      if (v96)
                      {
                        atomic_fetch_add_explicit((v96 + 8), 1uLL, memory_order_relaxed);
                      }

                      v97 = *(v93 + 1);
                      operator new();
                    }

                    std::vector<std::shared_ptr<DSP_Host_Types::DeviceConfiguration>>::clear[abi:ne200100](*v76 + 44);
                    v76 += 2;
                  }

                  while (v76 != v119);
                  v74 = *(a1 + 32);
                }

                std::condition_variable::wait((v74 + 64), &__lk);
                v74 = *(a1 + 32);
                v76 = *(v74 + 168);
                v75 = *(v74 + 176);
                if (v76 == v75)
                {
                  break;
                }

                v98 = 0;
                v99 = *(v74 + 168);
                do
                {
                  v100 = *v99;
                  v99 += 2;
                  v98 += v100[86] + ((*(v100 + 45) - *(v100 + 44)) >> 4);
                }

                while (v99 != v75);
              }

              while (v98);
            }
          }

          v102 = *(&__p + 1);
          v101 = __p;
          v134 = 0;
          v135 = 0;
          v133 = 0;
          std::vector<unsigned int>::__init_with_size[abi:ne200100]<unsigned int *,unsigned int *>(&v133, v141, v142, (v142 - v141) >> 2);
          if (v101 != v102)
          {
            v103 = v133;
            while (1)
            {
              v104 = v133;
              if (v133 != v134)
              {
                v104 = v133;
                while (*v104 != *v101)
                {
                  if (++v104 == v134)
                  {
                    goto LABEL_163;
                  }
                }
              }

              if (v104 == v134)
              {
                break;
              }

              if (++v101 == v102)
              {
                goto LABEL_175;
              }
            }
          }

LABEL_163:
          if (v101 == v102)
          {
            v103 = v133;
            if (v133)
            {
              goto LABEL_176;
            }
          }

          else
          {
            v105 = v101 + 1;
            v103 = v133;
            if (v101 + 1 != v102)
            {
              v106 = v134;
              do
              {
                v107 = v103;
                if (v103 != v106)
                {
                  v107 = v103;
                  while (*v107 != *v105)
                  {
                    if (++v107 == v106)
                    {
                      goto LABEL_173;
                    }
                  }
                }

                if (v107 != v106)
                {
                  *v101++ = *v105;
                }

LABEL_173:
                ++v105;
              }

              while (v105 != v102);
            }

            v102 = v101;
LABEL_175:
            if (v103)
            {
LABEL_176:
              v134 = v103;
              operator delete(v103);
            }
          }

          if (v102 != *(&__p + 1))
          {
            *(&__p + 1) = v102;
          }

          if (__lk.__owns_)
          {
            std::mutex::unlock(__lk.__m_);
          }

          kdebug_trace();
          v108 = v154;
          AMCP::Core::Broker::make_snapshot(&v130, *(*(v8 + 16) + 16), &v151, v154);
          AMCP::Core::compute_system_differences(&queue, &v148, &v130);
          LODWORD(v123) = v120;
          LOBYTE(__lk.__m_) = v9 & 1;
          AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_sync<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&>(v8 + 1400, &v123, &v123, &__lk, &queue);
          AMCP::Core::Broker::make_snapshot(&__lk, *(*(v8 + 16) + 16), &v151, v108);
          AMCP::Core::compute_system_differences(&v123, &v148, &__lk);
          std::set<unsigned int>::set[abi:ne200100](&v122, &v136);
          AMCP::IO_Core::Graph_Manager::update_graph_after_config_change((v8 + 2696), v120, &v122, 1, &__p);
        }

        if (v151)
        {
          operator delete(v151);
        }

        v2 = *(a1 + 32);
        std::mutex::lock(v2);
        v109 = *(a1 + 32);
        v110 = *(v109 + 168);
        v111 = *(v109 + 176);
        if (v110 == v111)
        {
          goto LABEL_191;
        }

        v112 = 0;
        do
        {
          v113 = *v110;
          v110 += 2;
          v112 += *(v113 + 344) + ((*(v113 + 360) - *(v113 + 352)) >> 4);
        }

        while (v110 != v111);
        std::mutex::unlock(v2);
      }

      while (v112);
    }
  }

  v114 = *(a1 + 32);
  std::mutex::lock(v114);
  v115 = *(a1 + 32);
  *(v115 + 164) = 0;
  std::condition_variable::notify_all((v115 + 112));
  std::mutex::unlock(v114);
  result = std::unique_ptr<AMCP::Core::Conductor::enqueue_config_change(unsigned int,unsigned int,unsigned int,std::function<void ()(void)> const&)::$_0,std::default_delete<AMCP::Core::Conductor::enqueue_config_change(unsigned int,unsigned int,unsigned int,std::function<void ()(void)> const&)::$_0>>::~unique_ptr[abi:ne200100](&v121);
  v117 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1DE740330(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, std::__shared_weak_count *a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, void *__p)
{
  if (a2)
  {
    if (__p)
    {
      operator delete(__p);
    }

    v50 = STACK[0x200];
    if (STACK[0x200])
    {
      STACK[0x208] = v50;
      operator delete(v50);
    }

    if (a39)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](a39);
    }

    if (a22)
    {
      operator delete(a22);
    }

    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

void AMCP::Core::Conductor::call_external_begin_config_change_observers(uint64_t a1, int a2, int a3, char a4, uint64_t *a5)
{
  v17[36] = *MEMORY[0x1E69E9840];
  v13 = a3;
  v12 = a4;
  if (a2 == 1)
  {
    AMCP::Core::make_external_diff(v14, a5);
    AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_sync<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>((a1 + 1616), &v13, &v13, &v12);
    boost::container::vector<boost::container::dtl::pair<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>>,boost::container::new_allocator<boost::container::dtl::pair<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>>>,void>::~vector(v17);
    if (__p)
    {
      v16 = __p;
      operator delete(__p);
    }

    if (v14[0])
    {
      v14[1] = v14[0];
      operator delete(v14[0]);
    }
  }

  else
  {
    AMCP::Utility::Dispatch_Queue::Dispatch_Queue(v14, (a1 + 368));
    AMCP::Core::make_external_diff(v8, a5);
    AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>((a1 + 1616), v14, &v13, &v13, &v12, v8);
    boost::container::vector<boost::container::dtl::pair<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>>,boost::container::new_allocator<boost::container::dtl::pair<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>>>,void>::~vector(v11);
    if (v9)
    {
      v10 = v9;
      operator delete(v9);
    }

    if (v8[0])
    {
      v8[1] = v8[0];
      operator delete(v8[0]);
    }

    AMCP::Utility::Dispatch_Queue::~Dispatch_Queue(v14);
  }

  v7 = *MEMORY[0x1E69E9840];
}

void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_sync<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&>(uint64_t a1, unsigned int *a2, _DWORD *a3, char *a4, uint64_t a5)
{
  std::__shared_mutex_base::lock_shared(a1);
  if (*(a1 + 168))
  {
    v18 = 0uLL;
    *&v19 = 0;
    v10 = *a2;
    if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find( *(a1 + 176),  *(a1 + 184),  *a2))
    {
      AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>> const*>>(&v18, *(v11 + 8), *(v11 + 16));
      v10 = *a2;
    }

    v12 = *(a1 + 208);
    if (v10 != v12
      && AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find( *(a1 + 176),  *(a1 + 184),  v12))
    {
      AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>> const*>>(&v18, *(v13 + 8), *(v13 + 16));
    }
  }

  else
  {
    v18 = 0u;
    v19 = 0u;
  }

  std::__shared_mutex_base::unlock_shared(a1);
  v15 = *(&v18 + 1);
  for (i = v18; i != v15; i += 40)
  {
    v16 = *a4;
    LODWORD(v20) = *a3;
    v21 = v16;
    v17 = *(i + 32);
    if (!v17)
    {
      std::__throw_bad_function_call[abi:ne200100]();
    }

    (*(*v17 + 48))(v17, &v20, &v21, a5);
  }

  v20 = &v18;
  std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&v20);
}

void *std::unique_ptr<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_4,std::default_delete<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_4>>::~unique_ptr[abi:ne200100](void *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = v2[7];
    if (v3)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v3);
    }

    v4 = v2[5];
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v4);
    }

    v5 = v2[3];
    if (v5)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v5);
    }

    v6 = v2[1];
    if (v6)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v6);
    }

    MEMORY[0x1E12C1730](v2, 0x20C400FA965B2);
  }

  return a1;
}

void AMCP::Core::Conductor::call_external_end_config_change_observers(uint64_t a1, int a2, char a3, uint64_t *a4)
{
  v13[42] = *MEMORY[0x1E69E9840];
  v12 = a2;
  v11 = a3;
  AMCP::Utility::Dispatch_Queue::Dispatch_Queue(v13, (a1 + 368));
  AMCP::Core::make_external_diff(v7, a4);
  AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>((a1 + 2048), v13, &v12, &v12, &v11, v7);
  boost::container::vector<boost::container::dtl::pair<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>>,boost::container::new_allocator<boost::container::dtl::pair<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>>>,void>::~vector(v10);
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }

  if (v7[0])
  {
    v7[1] = v7[0];
    operator delete(v7[0]);
  }

  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue(v13);
  v6 = *MEMORY[0x1E69E9840];
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>>::~__hash_table(uint64_t a1)
{
  v2 = *(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = *v2;
      std::__hash_table<std::__hash_value_type<AMCP::Address,AMCP::Thing>,std::__unordered_map_hasher<AMCP::Address,std::__hash_value_type<AMCP::Address,AMCP::Thing>,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,true>,std::__unordered_map_equal<AMCP::Address,std::__hash_value_type<AMCP::Address,AMCP::Thing>,AMCP::Address::Is_Exact_Match,AMCP::Address::Hash,true>,std::allocator<std::__hash_value_type<AMCP::Address,AMCP::Thing>>>::~__hash_table((v2 + 3));
      operator delete(v2);
      v2 = v3;
    }

    while (v3);
  }

  v4 = *a1;
  *a1 = 0;
  if (v4)
  {
    operator delete(v4);
  }

  return a1;
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_7,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <=*=* Done with config change for source object %u, owning object %u", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_7,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_6,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <=*=* Done with config change for source object %u, owning object %u", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_6,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_5,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <=*=* Done with config change for source object %u, owning object %u", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_5,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_sync<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>(std::__shared_mutex_base *this, unsigned int *a2, int *a3, char *a4)
{
  AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::gather_observers(v8, this, a2);
  v6 = v8[0];
  v7 = v8[1];
  while (v6 != v7)
  {
    std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::operator()(*(v6 + 32), *a3, *a4);
    v6 += 40;
  }

  v9 = v8;
  std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&v9);
}

void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>(std::__shared_mutex_base *this, dispatch_queue_t *a2, unsigned int *a3, int *a4, char *a5, __int128 *a6)
{
  AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::gather_observers(&v23, this, a3);
  if (v23 != *(&v23 + 1))
  {
    v13 = v23;
    v23 = 0u;
    v14 = v24;
    v24 = 0;
    v15 = *a4;
    v16 = *a5;
    v17 = *a6;
    *a6 = 0u;
    v10 = a6[1];
    v19 = a6[2];
    v18 = v10;
    a6[2] = 0u;
    *(a6 + 2) = 0;
    *(a6 + 3) = 0;
    v11 = *(a6 + 7);
    v20 = *(a6 + 6);
    v21 = v11;
    v22 = *(a6 + 8);
    *(a6 + 6) = 0;
    *(a6 + 7) = 0;
    *(a6 + 8) = 0;
    queue = *a2;
    operator new();
  }

  *&v13 = &v23;
  std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&v13);
}

void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::gather_observers(void *a1, std::__shared_mutex_base *this, unsigned int *a3)
{
  std::__shared_mutex_base::lock_shared(this);
  if (this[1].__mut_.__m_.__sig)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    v6 = *a3;
    if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find( *this[1].__mut_.__m_.__opaque,  *&this[1].__mut_.__m_.__opaque[8],  *a3))
    {
      AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>> const*>>(a1, *(v7 + 8), *(v7 + 16));
      v6 = *a3;
    }

    v8 = *&this[1].__mut_.__m_.__opaque[32];
    if (v6 != v8
      && AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find( *this[1].__mut_.__m_.__opaque,  *&this[1].__mut_.__m_.__opaque[8],  v8))
    {
      AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>> const*>>(a1, *(v9 + 8), *(v9 + 16));
    }
  }

  else
  {
    *a1 = 0u;
    *(a1 + 1) = 0u;
  }

  std::__shared_mutex_base::unlock_shared(this);
}

uint64_t *std::unique_ptr<void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>(AMCP::Utility::Dispatch_Queue const&,unsigned int const&,unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> &&)::{lambda(void)#1},std::default_delete<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> &&>>::~unique_ptr[abi:ne200100](uint64_t *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    boost::container::vector<boost::container::dtl::pair<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>>,boost::container::new_allocator<boost::container::dtl::pair<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>>>,void>::~vector((v2 + 88));
    v3 = *(v2 + 64);
    if (v3)
    {
      *(v2 + 72) = v3;
      operator delete(v3);
    }

    v4 = *(v2 + 40);
    if (v4)
    {
      *(v2 + 48) = v4;
      operator delete(v4);
    }

    v6 = v2;
    std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&v6);
    MEMORY[0x1E12C1730](v2, 0x1030C4007DBB1FBLL);
  }

  return a1;
}

void std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 40;
        std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::~__value_func[abi:ne200100]((v4 - 32));
        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

uint64_t *applesauce::dispatch::v1::async<void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>(AMCP::Utility::Dispatch_Queue const&,unsigned int const&,unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> &&)::{lambda(void)#1}>(dispatch_queue_s *,void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>(AMCP::Utility::Dispatch_Queue const&,unsigned int const&,unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> &&)::{lambda(void)#1} &&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  v5 = a1;
  v1 = *a1;
  v2 = *(a1 + 8);
  if (*a1 != v2)
  {
    do
    {
      std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::operator()(*(v1 + 32), *(a1 + 32), *(a1 + 36));
      v1 += 40;
    }

    while (v1 != v2);
  }

  return std::unique_ptr<void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>(AMCP::Utility::Dispatch_Queue const&,unsigned int const&,unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> &&)::{lambda(void)#1},std::default_delete<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> &&>>::~unique_ptr[abi:ne200100](&v5);
}

void sub_1DE7410B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>>>(AMCP::Utility::Dispatch_Queue const&,unsigned int const&,unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> &&)::{lambda(void)#1},std::default_delete<unsigned int &,BOOL &,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> &&>>::~unique_ptr[abi:ne200100](va);
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::operator()(uint64_t a1, int a2, char a3)
{
  v5 = a2;
  v4 = a3;
  if (!a1)
  {
    std::__throw_bad_function_call[abi:ne200100]();
  }

  return (*(*a1 + 48))(a1, &v5, &v4);
}

uint64_t AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>> const*>>(uint64_t result, char *a2, char *a3)
{
  if (a2 != a3)
  {
    v4 = a2;
    v5 = result;
    do
    {
      v6 = *v4;
      if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::find(*v5, v5[1], *v4))
      {
        *v7 = v6;
        result = std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::operator=((v7 + 8), (v4 + 8));
      }

      else
      {
        result = std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::insert(v5, v7, v4);
      }

      v4 += 40;
    }

    while (v4 != a3);
  }

  return result;
}

uint64_t std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::operator=(uint64_t a1, uint64_t a2)
{
  v9[3] = *MEMORY[0x1E69E9840];
  std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::__value_func[abi:ne200100](v7, a2);
  if (v7 != a1)
  {
    v3 = v8;
    v4 = *(a1 + 24);
    if (v8 == v7)
    {
      if (v4 == a1)
      {
        (*(*v8 + 24))();
        (*(*v8 + 32))(v8);
        v8 = 0;
        (*(**(a1 + 24) + 24))(*(a1 + 24), v7);
        (*(**(a1 + 24) + 32))(*(a1 + 24));
        *(a1 + 24) = 0;
        v8 = v7;
        (*(v9[0] + 24))(v9, a1);
        (*(v9[0] + 32))(v9);
      }

      else
      {
        (*(*v8 + 24))();
        (*(*v8 + 32))(v8);
        v8 = *(a1 + 24);
      }

      *(a1 + 24) = a1;
    }

    else if (v4 == a1)
    {
      (*(*v4 + 24))(*(a1 + 24), v7);
      (*(**(a1 + 24) + 32))(*(a1 + 24));
      *(a1 + 24) = v8;
      v8 = v7;
    }

    else
    {
      v8 = *(a1 + 24);
      *(a1 + 24) = v3;
    }
  }

  std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::~__value_func[abi:ne200100](v7);
  v5 = *MEMORY[0x1E69E9840];
  return a1;
}

void sub_1DE741420(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

char *std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::insert(uint64_t *a1, char *a2, char *a3)
{
  v4 = a2;
  v7 = a1[1];
  v6 = a1[2];
  if (v7 >= v6)
  {
    v12 = *a1;
    v13 = 0xCCCCCCCCCCCCCCCDLL * (&v7[-*a1] >> 3) + 1;
    if (v13 > 0x666666666666666)
    {
      std::vector<void *>::__throw_length_error[abi:ne200100]();
    }

    v14 = &a2[-v12];
    v15 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - v12) >> 3);
    if (2 * v15 > v13)
    {
      v13 = 2 * v15;
    }

    if (v15 >= 0x333333333333333)
    {
      v16 = 0x666666666666666;
    }

    else
    {
      v16 = v13;
    }

    v33 = a1;
    if (v16)
    {
      std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::allocate_at_least[abi:ne200100](v16);
    }

    v17 = (8 * (v14 >> 3));
    v30 = 0;
    v31 = v17;
    v32 = v17;
    if (!(0xCCCCCCCCCCCCCCCDLL * (v14 >> 3)))
    {
      if (v14 < 1)
      {
        if (v12 == a2)
        {
          v22 = 1;
        }

        else
        {
          v22 = 0x999999999999999ALL * (v14 >> 3);
        }

        v34 = a1;
        std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::allocate_at_least[abi:ne200100](v22);
      }

      v17 -= 5 * ((1 - 0x3333333333333333 * (v14 >> 3)) >> 1);
      v31 = v17;
      *&v32 = v17;
    }

    *v17 = *a3;
    std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::__value_func[abi:ne200100]((v17 + 1), (a3 + 8));
    v23 = v31;
    *&v32 = v32 + 40;
    std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*>(v4, a1[1], v32);
    v24 = *a1;
    v25 = v31;
    *&v32 = v32 + a1[1] - v4;
    a1[1] = v4;
    v26 = v25 + v24 - v4;
    std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*>(v24, v4, v26);
    v27 = *a1;
    *a1 = v26;
    v28 = a1[2];
    *(a1 + 1) = v32;
    *&v32 = v27;
    *(&v32 + 1) = v28;
    v30 = v27;
    v31 = v27;
    std::__split_buffer<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::~__split_buffer(&v30);
    return v23;
  }

  else if (a2 == v7)
  {
    *v7 = *a3;
    std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::__value_func[abi:ne200100]((v7 + 8), (a3 + 8));
    a1[1] = (v7 + 40);
  }

  else
  {
    v8 = a2 + 40;
    v9 = v7 - 40;
    if (v7 < 0x28)
    {
      v11 = a1[1];
    }

    else
    {
      v10 = 0;
      do
      {
        *&v7[v10] = *&v7[v10 - 40];
        std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::__value_func[abi:ne200100](&v7[v10 + 8], &v7[v10 - 32]);
        v10 += 40;
      }

      while (&v7[v10 - 40] < v7);
      v11 = &v7[v10];
    }

    a1[1] = v11;
    if (v7 != v8)
    {
      v18 = v4 - v7 + 40;
      v19 = v7 - 80;
      do
      {
        std::__memberwise_forward_assign[abi:ne200100]<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,0ul,1ul>(v9, v19);
        v9 -= 40;
        v19 -= 40;
        v18 += 40;
      }

      while (v18);
      v11 = a1[1];
    }

    v20 = v11 <= a3 || v4 > a3;
    v21 = 40;
    if (v20)
    {
      v21 = 0;
    }

    *v4 = *&a3[v21];
    std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::operator=((v4 + 8), &a3[v21 + 8]);
  }

  return v4;
}

uint64_t std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::__value_func[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

uint64_t std::__split_buffer<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 40;
    std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::~__value_func[abi:ne200100](i - 32);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*>(uint64_t result, void *a2, uint64_t a3)
{
  if (result != a2)
  {
    v4 = result;
    v5 = a3 + 8;
    v6 = v4;
    v7 = v4;
    do
    {
      v8 = *v7;
      v7 += 5;
      *(v5 - 8) = v8;
      v5 = std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::__value_func[abi:ne200100](v5, (v6 + 1)) + 40;
      v6 = v7;
    }

    while (v7 != a2);
    do
    {
      result = std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::~__value_func[abi:ne200100]((v4 + 1));
      v4 += 5;
    }

    while (v4 != a2);
  }

  return result;
}

uint64_t std::__memberwise_forward_assign[abi:ne200100]<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,0ul,1ul>(void *a1, void *a2)
{
  v3 = a2 + 1;
  *a1 = *a2;
  v4 = a1 + 1;
  v6 = a1 + 4;
  result = a1[4];
  *v6 = 0;
  if (result == v4)
  {
    result = (*(*result + 32))(result);
  }

  else if (result)
  {
    result = (*(*result + 40))(result);
  }

  v9 = a2[4];
  v8 = a2 + 4;
  v7 = v9;
  if (!v9)
  {
    v8 = v6;
    goto LABEL_9;
  }

  if (v7 != v3)
  {
    *v6 = v7;
LABEL_9:
    *v8 = 0;
    return result;
  }

  *v6 = v4;
  return (*(**v8 + 24))(*v8, v4);
}

void *applesauce::dispatch::v1::async<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_4>(dispatch_queue_s *,AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_4 &&)::{lambda(void *)#1}::__invoke(void *a1)
{
  v8 = a1;
  v2 = *(a1[6] + 32);
  if (!v2)
  {
    std::__throw_bad_function_call[abi:ne200100]();
  }

  (*(*v2 + 48))(v2);
  v3 = a1[2];
  std::mutex::lock(v3);
  *(a1[6] + 48) = 1;
  v4 = a1[4];
  v5 = *(v4 + 344);
  v6 = __OFSUB__(v5--, 1);
  *(v4 + 344) = v5;
  if ((v5 < 0) ^ v6 | (v5 == 0))
  {
    std::condition_variable::notify_all((a1[2] + 64));
  }

  std::mutex::unlock(v3);
  return std::unique_ptr<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_4,std::default_delete<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_4>>::~unique_ptr[abi:ne200100](&v8);
}

void std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 40;
        std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::~__value_func[abi:ne200100]((v4 - 32));
        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

uint64_t AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>> const*>>(uint64_t result, char *a2, char *a3)
{
  if (a2 != a3)
  {
    v4 = a2;
    v5 = result;
    do
    {
      v6 = *v4;
      if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::find(*v5, v5[1], *v4))
      {
        *v7 = v6;
        result = std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::operator=((v7 + 8), (v4 + 8));
      }

      else
      {
        result = std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::insert(v5, v7, v4);
      }

      v4 += 40;
    }

    while (v4 != a3);
  }

  return result;
}

BOOL AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::find(void *a1, void *a2, unint64_t a3)
{
  if (a2 == a1)
  {
    v3 = a2;
  }

  else
  {
    v3 = a1;
    v4 = 0xCCCCCCCCCCCCCCCDLL * (a2 - a1);
    do
    {
      v5 = v4 >> 1;
      v6 = &v3[5 * (v4 >> 1)];
      v8 = *v6;
      v7 = v6 + 5;
      v4 += ~(v4 >> 1);
      if (v8 < a3)
      {
        v3 = v7;
      }

      else
      {
        v4 = v5;
      }
    }

    while (v4);
  }

  return v3 != a2 && *v3 == a3;
}

uint64_t std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::operator=(uint64_t a1, uint64_t a2)
{
  v9[3] = *MEMORY[0x1E69E9840];
  std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::__value_func[abi:ne200100](v7, a2);
  if (v7 != a1)
  {
    v3 = v8;
    v4 = *(a1 + 24);
    if (v8 == v7)
    {
      if (v4 == a1)
      {
        (*(*v8 + 24))();
        (*(*v8 + 32))(v8);
        v8 = 0;
        (*(**(a1 + 24) + 24))(*(a1 + 24), v7);
        (*(**(a1 + 24) + 32))(*(a1 + 24));
        *(a1 + 24) = 0;
        v8 = v7;
        (*(v9[0] + 24))(v9, a1);
        (*(v9[0] + 32))(v9);
      }

      else
      {
        (*(*v8 + 24))();
        (*(*v8 + 32))(v8);
        v8 = *(a1 + 24);
      }

      *(a1 + 24) = a1;
    }

    else if (v4 == a1)
    {
      (*(*v4 + 24))(*(a1 + 24), v7);
      (*(**(a1 + 24) + 32))(*(a1 + 24));
      *(a1 + 24) = v8;
      v8 = v7;
    }

    else
    {
      v8 = *(a1 + 24);
      *(a1 + 24) = v3;
    }
  }

  std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::~__value_func[abi:ne200100](v7);
  v5 = *MEMORY[0x1E69E9840];
  return a1;
}

void sub_1DE741EEC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

char *std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::insert(uint64_t *a1, char *a2, char *a3)
{
  v4 = a2;
  v7 = a1[1];
  v6 = a1[2];
  if (v7 >= v6)
  {
    v12 = *a1;
    v13 = 0xCCCCCCCCCCCCCCCDLL * (&v7[-*a1] >> 3) + 1;
    if (v13 > 0x666666666666666)
    {
      std::vector<void *>::__throw_length_error[abi:ne200100]();
    }

    v14 = &a2[-v12];
    v15 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - v12) >> 3);
    if (2 * v15 > v13)
    {
      v13 = 2 * v15;
    }

    if (v15 >= 0x333333333333333)
    {
      v16 = 0x666666666666666;
    }

    else
    {
      v16 = v13;
    }

    v33 = a1;
    if (v16)
    {
      std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::allocate_at_least[abi:ne200100](v16);
    }

    v17 = (8 * (v14 >> 3));
    v30 = 0;
    v31 = v17;
    v32 = v17;
    if (!(0xCCCCCCCCCCCCCCCDLL * (v14 >> 3)))
    {
      if (v14 < 1)
      {
        if (v12 == a2)
        {
          v22 = 1;
        }

        else
        {
          v22 = 0x999999999999999ALL * (v14 >> 3);
        }

        v34 = a1;
        std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::allocate_at_least[abi:ne200100](v22);
      }

      v17 -= 5 * ((1 - 0x3333333333333333 * (v14 >> 3)) >> 1);
      v31 = v17;
      *&v32 = v17;
    }

    *v17 = *a3;
    std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::__value_func[abi:ne200100]((v17 + 1), (a3 + 8));
    v23 = v31;
    *&v32 = v32 + 40;
    std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*>(v4, a1[1], v32);
    v24 = *a1;
    v25 = v31;
    *&v32 = v32 + a1[1] - v4;
    a1[1] = v4;
    v26 = v25 + v24 - v4;
    std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*>(v24, v4, v26);
    v27 = *a1;
    *a1 = v26;
    v28 = a1[2];
    *(a1 + 1) = v32;
    *&v32 = v27;
    *(&v32 + 1) = v28;
    v30 = v27;
    v31 = v27;
    std::__split_buffer<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::~__split_buffer(&v30);
    return v23;
  }

  else if (a2 == v7)
  {
    *v7 = *a3;
    std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::__value_func[abi:ne200100]((v7 + 8), (a3 + 8));
    a1[1] = (v7 + 40);
  }

  else
  {
    v8 = a2 + 40;
    v9 = v7 - 40;
    if (v7 < 0x28)
    {
      v11 = a1[1];
    }

    else
    {
      v10 = 0;
      do
      {
        *&v7[v10] = *&v7[v10 - 40];
        std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::__value_func[abi:ne200100](&v7[v10 + 8], &v7[v10 - 32]);
        v10 += 40;
      }

      while (&v7[v10 - 40] < v7);
      v11 = &v7[v10];
    }

    a1[1] = v11;
    if (v7 != v8)
    {
      v18 = v4 - v7 + 40;
      v19 = v7 - 80;
      do
      {
        std::__memberwise_forward_assign[abi:ne200100]<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,0ul,1ul>(v9, v19);
        v9 -= 40;
        v19 -= 40;
        v18 += 40;
      }

      while (v18);
      v11 = a1[1];
    }

    v20 = v11 <= a3 || v4 > a3;
    v21 = 40;
    if (v20)
    {
      v21 = 0;
    }

    *v4 = *&a3[v21];
    std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::operator=((v4 + 8), &a3[v21 + 8]);
  }

  return v4;
}

uint64_t std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::__value_func[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

void std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::allocate_at_least[abi:ne200100](unint64_t a1)
{
  if (a1 < 0x666666666666667)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

uint64_t std::__split_buffer<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 40;
    std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::~__value_func[abi:ne200100](i - 32);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*>(uint64_t result, void *a2, uint64_t a3)
{
  if (result != a2)
  {
    v4 = result;
    v5 = a3 + 8;
    v6 = v4;
    v7 = v4;
    do
    {
      v8 = *v7;
      v7 += 5;
      *(v5 - 8) = v8;
      v5 = std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::__value_func[abi:ne200100](v5, (v6 + 1)) + 40;
      v6 = v7;
    }

    while (v7 != a2);
    do
    {
      result = std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::~__value_func[abi:ne200100]((v4 + 1));
      v4 += 5;
    }

    while (v4 != a2);
  }

  return result;
}

uint64_t std::__memberwise_forward_assign[abi:ne200100]<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,0ul,1ul>(void *a1, void *a2)
{
  v3 = a2 + 1;
  *a1 = *a2;
  v4 = a1 + 1;
  v6 = a1 + 4;
  result = a1[4];
  *v6 = 0;
  if (result == v4)
  {
    result = (*(*result + 32))(result);
  }

  else if (result)
  {
    result = (*(*result + 40))(result);
  }

  v9 = a2[4];
  v8 = a2 + 4;
  v7 = v9;
  if (!v9)
  {
    v8 = v6;
    goto LABEL_9;
  }

  if (v7 != v3)
  {
    *v6 = v7;
LABEL_9:
    *v8 = 0;
    return result;
  }

  *v6 = v4;
  return (*(**v8 + 24))(*v8, v4);
}

uint64_t std::__function::__func<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_0,std::allocator<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_0>,BOOL ()(std::shared_ptr<AMCP::Core::Core> const&)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "ZN4AMCP4Core9Conductor25calculate_snapshot_paramsEjjbE3$_0"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

BOOL std::__function::__func<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_0,std::allocator<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_0>,BOOL ()(std::shared_ptr<AMCP::Core::Core> const&)>::operator()(uint64_t a1, AMCP::Core::Core **a2)
{
  v3 = *a2;
  v15 = 0x676C6F6262636C73;
  v16 = 0;
  v4 = AMCP::Core::Core::get_typed_property_value<unsigned int,std::enable_if<true,void>>(v3, &v15, &AMCP::k_class_id_unknown);
  v5 = 0;
  if (AMCP::is_base_of(0x61706C67, v4))
  {
    v6 = *a2;
    v7 = CFStringCreateWithBytes(0, "", 0, 0x8000100u, 0);
    v13 = v7;
    if (!v7)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    v8 = v7;
    v15 = 0x676C6F6270696964;
    v16 = 0;
    AMCP::Core::Core::get_typed_property_value<applesauce::CF::StringRef,std::enable_if<true,void>>(&cf, v6, &v15, &v13);
    CFRelease(v8);
    v9 = CFStringCreateWithBytes(0, "com.apple.audio.Meta-Driver", 27, 0x8000100u, 0);
    v15 = v9;
    if (!v9)
    {
      v12 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v12, "Could not construct");
      __cxa_throw(v12, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    v5 = applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>(cf, &v15) == kCFCompareEqualTo;
    CFRelease(v9);
    if (cf)
    {
      CFRelease(cf);
    }
  }

  return v5;
}

void sub_1DE742738(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  applesauce::CF::ObjectRef<__CFString const*>::~ObjectRef(va1);
  applesauce::CF::StringRef::~StringRef(va);
  _Unwind_Resume(a1);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_6,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <=*=* Done with config change for source object %u, owning object %u (unrecognized stock class)", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_6,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_5,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <=*=* Done with config change for source object %u, owning object %u (unrecognized stock class)", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_5,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_4,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <=*=* Done with config change for source object %u, owning object %u (unrecognized stock class)", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_4,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_3,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <=*=* Done with config change for source object %u, owning object %u (no object)", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_3,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_2,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <=*=* Done with config change for source object %u, owning object %u (no object)", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_2,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_1,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <=*=* Done with config change for source object %u, owning object %u (no object)", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::calculate_snapshot_params(unsigned int,unsigned int,BOOL)::$_1,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_3,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d *=*=> Begin config change for source object %u, owning object %u", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_3,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_2,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d *=*=> Begin config change for source object %u, owning object %u", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_2,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_1,std::tuple<char const*,int,unsigned int,unsigned int>>::perform(uint64_t a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v9 = *(a1 + 40);
    v12 = 136315906;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d *=*=> Begin config change for source object %u, owning object %u", &v12, 0x1Eu);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::process_queued_config_change(unsigned int,unsigned int,unsigned int,std::shared_ptr<AMCP::Core::Conductor::Queued_Change_Map_Item> const&)::$_1,std::tuple<char const*,int,unsigned int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

void std::__shared_ptr_emplace<AMCP::Core::Conductor::Queued_Change>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F5990458;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

void std::__shared_ptr_emplace<AMCP::Core::Conductor::Queued_Change_Object>::__on_zero_shared(uint64_t a1)
{
  v2 = (a1 + 376);
  std::vector<std::shared_ptr<DSP_Host_Types::DeviceConfiguration>>::__destroy_vector::operator()[abi:ne200100](&v2);

  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue((a1 + 32));
}

void std::__shared_ptr_emplace<AMCP::Core::Conductor::Queued_Change_Object>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F5990C10;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

void std::__shared_ptr_emplace<AMCP::Core::Conductor::Queued_Change_Map_Item>::__on_zero_shared(uint64_t a1)
{
  v2 = *(a1 + 192);
  if (v2)
  {
    v3 = *(a1 + 200);
    v4 = *(a1 + 192);
    if (v3 != v2)
    {
      do
      {
        v5 = *(v3 - 8);
        if (v5)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v5);
        }

        v3 -= 16;
      }

      while (v3 != v2);
      v4 = *(a1 + 192);
    }

    *(a1 + 200) = v2;
    operator delete(v4);
  }

  std::condition_variable::~condition_variable((a1 + 136));
  std::condition_variable::~condition_variable((a1 + 88));

  std::mutex::~mutex((a1 + 24));
}

void std::__shared_ptr_emplace<AMCP::Core::Conductor::Queued_Change_Map_Item>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F5990BC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t AMCP::Core::Conductor::Conductor_Graph_Manager::get_graph_host@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  v2 = *(this + 440);
  *a2 = *(this + 432);
  a2[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return this;
}

void AMCP::Core::Conductor::Conductor_Graph_Manager::~Conductor_Graph_Manager(AMCP::Core::Conductor::Conductor_Graph_Manager *this)
{
  *this = &unk_1F5990218;
  v2 = *(this + 55);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  AMCP::IO_Core::Graph_Manager::~Graph_Manager(this);

  JUMPOUT(0x1E12C1730);
}

{
  *this = &unk_1F5990218;
  v2 = *(this + 55);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  AMCP::IO_Core::Graph_Manager::~Graph_Manager(this);
}

{
  *this = &unk_1F5990218;
  v2 = *(this + 55);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  AMCP::IO_Core::Graph_Manager::~Graph_Manager(this);
}

void AMCP::Observer::Map<std::function<void ()(unsigned int)>,unsigned int,true,std::less<unsigned int>>::~Map(uint64_t a1)
{
  v2 = (a1 + 176);
  std::vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()>>>>>>::__destroy_vector::operator()[abi:ne200100](&v2);
  std::condition_variable::~condition_variable((a1 + 112));
  std::condition_variable::~condition_variable((a1 + 64));

  std::mutex::~mutex(a1);
}

void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::~Map(uint64_t a1)
{
  v2 = *(a1 + 176);
  if (v2)
  {
    v3 = *(a1 + 184);
    v4 = *(a1 + 176);
    if (v3 != v2)
    {
      do
      {
        v5 = v3 - 40;
        v6 = (v3 - 32);
        std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&v6);
        v3 = v5;
      }

      while (v5 != v2);
      v4 = *(a1 + 176);
    }

    *(a1 + 184) = v2;
    operator delete(v4);
  }

  std::condition_variable::~condition_variable((a1 + 112));
  std::condition_variable::~condition_variable((a1 + 64));

  std::mutex::~mutex(a1);
}

void AMCP::Observer::Map<std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>,unsigned int,true,std::less<unsigned int>>::~Map(uint64_t a1)
{
  v2 = (a1 + 176);
  std::vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>>>::__destroy_vector::operator()[abi:ne200100](&v2);
  std::condition_variable::~condition_variable((a1 + 112));
  std::condition_variable::~condition_variable((a1 + 64));

  std::mutex::~mutex(a1);
}

void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,unsigned int,true,std::less<unsigned int>>::~Map(uint64_t a1)
{
  v2 = *(a1 + 176);
  if (v2)
  {
    v3 = *(a1 + 184);
    v4 = *(a1 + 176);
    if (v3 != v2)
    {
      do
      {
        v5 = v3 - 40;
        v6 = (v3 - 32);
        std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&v6);
        v3 = v5;
      }

      while (v5 != v2);
      v4 = *(a1 + 176);
    }

    *(a1 + 184) = v2;
    operator delete(v4);
  }

  std::condition_variable::~condition_variable((a1 + 112));
  std::condition_variable::~condition_variable((a1 + 64));

  std::mutex::~mutex(a1);
}

void std::vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>>>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 40;
        v7 = (v4 - 32);
        std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__destroy_vector::operator()[abi:ne200100](&v7);
        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void std::vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>>>>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 40;
        v7 = (v4 - 32);
        std::vector<std::tuple<unsigned long long,std::function<void ()>>>::__destroy_vector::operator()[abi:ne200100](&v7);
        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 40;
        std::__function::__value_func<void ()>::~__value_func[abi:ne200100]((v4 - 32));
        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void AMCP::Core::Conductor::flush_work_queues(id *this)
{
  v4 = *MEMORY[0x1E69E9840];
  AMCP::Utility::Dispatch_Queue::Dispatch_Queue(v3, this + 46);
  AMCP::Utility::Dispatch_Queue::flush_all_work(v3);
  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue(v3);
  AMCP::Utility::Dispatch_Queue::Dispatch_Queue(v3, this + 4);
  AMCP::Utility::Dispatch_Queue::flush_all_work(v3);
  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue(v3);
  AMCP::Utility::Dispatch_Queue::Dispatch_Queue(v3, this + 88);
  AMCP::Utility::Dispatch_Queue::flush_all_work(v3);
  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue(v3);
  v2 = *MEMORY[0x1E69E9840];
}

uint64_t *std::unique_ptr<AMCP::Core::Conductor::finish_all_notifications(std::function<void ()(void)> const&)::$_0,std::default_delete<AMCP::Core::Conductor::finish_all_notifications(std::function<void ()(void)> const&)::$_0>>::~unique_ptr[abi:ne200100](uint64_t *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::__variant_detail::__dtor<std::__variant_detail::__traits<std::shared_ptr<std::byte>,std::weak_ptr<std::byte>>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](v2);
    MEMORY[0x1E12C1730](v2, 0x10E2C4061EF8AF9);
  }

  return a1;
}

uint64_t *applesauce::dispatch::v1::async<AMCP::Core::Conductor::finish_all_notifications(std::function<void ()(void)> const&)::$_0>(dispatch_queue_s *,AMCP::Core::Conductor::finish_all_notifications(std::function<void ()(void)> const&)::$_0 &&)::{lambda(void *)#1}::__invoke(AMCP::Utility::Expiration_Check *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v11 = a1;
  v2 = *(a1 + 5);
  is_valid = AMCP::Utility::Expiration_Check::is_valid(a1);
  if (!is_valid)
  {
    v7 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v7 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(is_valid);
    }

    v9 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v8 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      v10 = *v9;
      std::__shared_weak_count::__release_shared[abi:ne200100](v8);
    }

    else
    {
      v10 = *v9;
    }

    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      v13 = "Conductor.cpp";
      v14 = 1024;
      v15 = 217;
      v16 = 2080;
      v17 = "expiration_check.is_valid()";
      _os_log_error_impl(&dword_1DE1F9000, v10, OS_LOG_TYPE_ERROR, "%32s:%-5d Assertion Failed: %s caller has gone out of scope", buf, 0x1Cu);
    }

    abort();
  }

  v4 = *(*(a1 + 4) + 24);
  if (!v4)
  {
    std::__throw_bad_function_call[abi:ne200100]();
  }

  (*(*v4 + 48))(v4);
  std::mutex::lock((v2 + 1040));
  std::condition_variable::notify_all((v2 + 1104));
  std::mutex::unlock((v2 + 1040));
  result = std::unique_ptr<AMCP::Core::Conductor::finish_all_notifications(std::function<void ()(void)> const&)::$_0,std::default_delete<AMCP::Core::Conductor::finish_all_notifications(std::function<void ()(void)> const&)::$_0>>::~unique_ptr[abi:ne200100](&v11);
  v6 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1DE743E40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<AMCP::Core::Conductor::finish_all_notifications(std::function<void ()(void)> const&)::$_0,std::default_delete<AMCP::Core::Conductor::finish_all_notifications(std::function<void ()(void)> const&)::$_0>>::~unique_ptr[abi:ne200100](va);
  _Unwind_Resume(a1);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_5,std::tuple<char const*,int,unsigned int>>::perform(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v11 = 136315650;
    v12 = v6;
    v13 = 1024;
    v14 = v7;
    v15 = 1024;
    v16 = v8;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <+++++ Done handling of properties changed for source object, %u", &v11, 0x18u);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v10 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_5,std::tuple<char const*,int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_4,std::tuple<char const*,int,unsigned int>>::perform(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v11 = 136315650;
    v12 = v6;
    v13 = 1024;
    v14 = v7;
    v15 = 1024;
    v16 = v8;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <+++++ Done handling of properties changed for source object, %u", &v11, 0x18u);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v10 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_4,std::tuple<char const*,int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_3,std::tuple<char const*,int,unsigned int>>::perform(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v11 = 136315650;
    v12 = v6;
    v13 = 1024;
    v14 = v7;
    v15 = 1024;
    v16 = v8;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d <+++++ Done handling of properties changed for source object, %u", &v11, 0x18u);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v10 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_3,std::tuple<char const*,int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_2,std::tuple<char const*,int,unsigned int>>::perform(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v11 = 136315650;
    v12 = v6;
    v13 = 1024;
    v14 = v7;
    v15 = 1024;
    v16 = v8;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d +++++> Beginning handling of properties changed for source object, %u", &v11, 0x18u);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v10 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_2,std::tuple<char const*,int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_1,std::tuple<char const*,int,unsigned int>>::perform(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v11 = 136315650;
    v12 = v6;
    v13 = 1024;
    v14 = v7;
    v15 = 1024;
    v16 = v8;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d +++++> Beginning handling of properties changed for source object, %u", &v11, 0x18u);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v10 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_1,std::tuple<char const*,int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_0,std::tuple<char const*,int,unsigned int>>::perform(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v11 = 136315650;
    v12 = v6;
    v13 = 1024;
    v14 = v7;
    v15 = 1024;
    v16 = v8;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d +++++> Beginning handling of properties changed for source object, %u", &v11, 0x18u);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v10 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<AMCP::Core::Conductor::properties_changed(unsigned int,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>> const&)::$_0,std::tuple<char const*,int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

BOOL AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find(_DWORD *a1, _DWORD *a2, unsigned int a3)
{
  if (a2 == a1)
  {
    v3 = a2;
  }

  else
  {
    v3 = a1;
    v4 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
    do
    {
      v5 = v4 >> 1;
      v6 = &v3[10 * (v4 >> 1)];
      v8 = *v6;
      v7 = v6 + 10;
      v4 += ~(v4 >> 1);
      if (v8 < a3)
      {
        v3 = v7;
      }

      else
      {
        v4 = v5;
      }
    }

    while (v4);
  }

  return v3 != a2 && *v3 == a3;
}

uint64_t std::__memberwise_copy_assign[abi:ne200100]<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul,1ul>(uint64_t result, uint64_t a2)
{
  *result = *a2;
  if (result != a2)
  {
    v2 = result;
    v3 = (result + 8);
    v4 = *(result + 8);
    v6 = *(a2 + 8);
    v5 = *(a2 + 16);
    v7 = v5 - v6;
    v8 = *(result + 24);
    if (v8 - v4 < (v5 - v6))
    {
      v9 = 0xCCCCCCCCCCCCCCCDLL * (v7 >> 3);
      if (v4)
      {
        v10 = *(result + 16);
        v11 = *(result + 8);
        if (v10 != v4)
        {
          do
          {
            v12 = v10 - 5;
            std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::~__value_func[abi:ne200100]((v10 - 4));
            v10 = v12;
          }

          while (v12 != v4);
          v11 = *v3;
        }

        *(v2 + 16) = v4;
        operator delete(v11);
        v8 = 0;
        *v3 = 0;
        v3[1] = 0;
        v3[2] = 0;
      }

      if (v9 <= 0x666666666666666)
      {
        v13 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 3);
        v14 = 2 * v13;
        if (2 * v13 <= v9)
        {
          v14 = v9;
        }

        if (v13 >= 0x333333333333333)
        {
          v15 = 0x666666666666666;
        }

        else
        {
          v15 = v14;
        }

        std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__vallocate[abi:ne200100](v3, v15);
      }

      std::vector<void *>::__throw_length_error[abi:ne200100]();
    }

    v16 = *(result + 16);
    v17 = v16 - v4;
    if (v16 - v4 >= v7)
    {
      if (v6 != v5)
      {
        v21 = *(result + 8);
        v22 = *(a2 + 8);
        do
        {
          v23 = *v22;
          v22 += 5;
          *v21 = v23;
          v21 += 5;
          result = std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::operator=((v4 + 1), v6 + 8);
          v4 = v21;
          v6 = v22;
        }

        while (v22 != v5);
        v16 = *(v2 + 16);
      }

      for (; v16 != v4; v16 -= 40)
      {
        result = std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::~__value_func[abi:ne200100](v16 - 32);
      }

      *(v2 + 16) = v4;
    }

    else
    {
      if (v16 != v4)
      {
        v18 = v6 + v17;
        v19 = (v4 + 1);
        v20 = v6 + 8;
        do
        {
          *(v19 - 8) = *(v20 - 8);
          v19 = std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::operator=(v19, v20) + 40;
          v20 += 40;
          v17 -= 40;
        }

        while (v17);
        v16 = *(v2 + 16);
        v6 = v18;
      }

      result = std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*>(v6, v5, v16);
      *(v2 + 16) = result;
    }
  }

  return result;
}

void std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>::allocate_at_least[abi:ne200100](unint64_t a1)
{
  if (a1 < 0x666666666666667)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

uint64_t std::__split_buffer<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 40;
    v5 = (i - 32);
    std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&v5);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>,std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    v11[3] = v4;
    v11[4] = v5;
    v7 = a2;
    v8 = a2;
    do
    {
      *a4 = *v8;
      *(a4 + 16) = 0;
      *(a4 + 24) = 0;
      *(a4 + 8) = 0;
      *(a4 + 8) = *(v8 + 8);
      *(v8 + 8) = 0;
      v9 = *(a4 + 16);
      *(a4 + 16) = *(v8 + 16);
      *(v8 + 16) = v9;
      v10 = *(a4 + 24);
      *(a4 + 24) = *(v8 + 24);
      *(v8 + 24) = v10;
      v8 += 40;
      a4 += 40;
    }

    while (v8 != a3);
    do
    {
      v11[0] = (v7 + 8);
      std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__destroy_vector::operator()[abi:ne200100](v11);
      v7 += 40;
    }

    while (v7 != a3);
  }
}

uint64_t std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__init_with_size[abi:ne200100]<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1DE744A84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__vallocate[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (a2 < 0x666666666666667)
  {
    std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::allocate_at_least[abi:ne200100](a2);
  }

  std::vector<void *>::__throw_length_error[abi:ne200100]();
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v6 = 0;
    do
    {
      *(a3 + v6) = *(a1 + v6);
      std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>::__value_func[abi:ne200100](a3 + v6 + 8, a1 + v6 + 8);
      v6 += 40;
    }

    while (a1 + v6 != a2);
    a3 += v6;
  }

  return a3;
}

unint64_t AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::register_observer(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  v23 = *MEMORY[0x1E69E9840];
  v17 = a1;
  v18 = 1;
  std::__shared_mutex_base::lock(a1);
  if (*(a1 + 168) == 1)
  {
    add = atomic_fetch_add(&AMCP::Observer::Implementation::get_next_token(void)::s_next_token, 1uLL);
    if (!AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find( *(a1 + 176),  *(a1 + 184),  *a2))
    {
      v19 = add;
      std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::__value_func[abi:ne200100](&v20, a3);
      v15 = 0uLL;
      v16 = 0;
      v21 = &v15;
      v22 = 0;
      operator new();
    }

    v8 = v7;
    v21 = add;
    std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::__value_func[abi:ne200100](&v22, a3);
    v9 = *(v8 + 8);
    v10 = *(v8 + 16);
    v11 = (v8 + 8);
    if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::find(v9, v10, add))
    {
      *v12 = add;
      std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::operator=((v12 + 8), &v22);
    }

    else
    {
      std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::insert(v11, v12, &v21);
    }

    std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::~__value_func[abi:ne200100](&v22);
  }

  else
  {
    add = 0;
  }

  std::__shared_mutex_base::unlock(a1);
  v13 = *MEMORY[0x1E69E9840];
  return add;
}

void sub_1DE7450C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, void **a20)
{
  *(v20 + 184) = v21;
  std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&a20);
  a20 = &a9;
  std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&a20);
  std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::~__value_func[abi:ne200100](v22 + 8);
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne200100](&a18);
  _Unwind_Resume(a1);
}

uint64_t std::__memberwise_copy_assign[abi:ne200100]<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>>>,std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>>>,0ul,1ul>(uint64_t result, uint64_t a2)
{
  *result = *a2;
  if (result != a2)
  {
    v2 = result;
    v3 = (result + 8);
    v4 = *(result + 8);
    v6 = *(a2 + 8);
    v5 = *(a2 + 16);
    v7 = v5 - v6;
    v8 = *(result + 24);
    if (v8 - v4 < (v5 - v6))
    {
      v9 = 0xCCCCCCCCCCCCCCCDLL * (v7 >> 3);
      if (v4)
      {
        v10 = *(result + 16);
        v11 = *(result + 8);
        if (v10 != v4)
        {
          do
          {
            v12 = v10 - 5;
            std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::~__value_func[abi:ne200100]((v10 - 4));
            v10 = v12;
          }

          while (v12 != v4);
          v11 = *v3;
        }

        *(v2 + 16) = v4;
        operator delete(v11);
        v8 = 0;
        *v3 = 0;
        v3[1] = 0;
        v3[2] = 0;
      }

      if (v9 <= 0x666666666666666)
      {
        v13 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 3);
        v14 = 2 * v13;
        if (2 * v13 <= v9)
        {
          v14 = v9;
        }

        if (v13 >= 0x333333333333333)
        {
          v15 = 0x666666666666666;
        }

        else
        {
          v15 = v14;
        }

        std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__vallocate[abi:ne200100](v3, v15);
      }

      std::vector<void *>::__throw_length_error[abi:ne200100]();
    }

    v16 = *(result + 16);
    v17 = v16 - v4;
    if (v16 - v4 >= v7)
    {
      if (v6 != v5)
      {
        v21 = *(result + 8);
        v22 = *(a2 + 8);
        do
        {
          v23 = *v22;
          v22 += 5;
          *v21 = v23;
          v21 += 5;
          result = std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::operator=((v4 + 1), v6 + 8);
          v4 = v21;
          v6 = v22;
        }

        while (v22 != v5);
        v16 = *(v2 + 16);
      }

      for (; v16 != v4; v16 -= 40)
      {
        result = std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::~__value_func[abi:ne200100](v16 - 32);
      }

      *(v2 + 16) = v4;
    }

    else
    {
      if (v16 != v4)
      {
        v18 = v6 + v17;
        v19 = (v4 + 1);
        v20 = v6 + 8;
        do
        {
          *(v19 - 8) = *(v20 - 8);
          v19 = std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::operator=(v19, v20) + 40;
          v20 += 40;
          v17 -= 40;
        }

        while (v17);
        v16 = *(v2 + 16);
        v6 = v18;
      }

      result = std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*>(v6, v5, v16);
      *(v2 + 16) = result;
    }
  }

  return result;
}

uint64_t std::__split_buffer<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>>>>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 40;
    v5 = (i - 32);
    std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&v5);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>>>>,std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>>>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    v11[3] = v4;
    v11[4] = v5;
    v7 = a2;
    v8 = a2;
    do
    {
      *a4 = *v8;
      *(a4 + 16) = 0;
      *(a4 + 24) = 0;
      *(a4 + 8) = 0;
      *(a4 + 8) = *(v8 + 8);
      *(v8 + 8) = 0;
      v9 = *(a4 + 16);
      *(a4 + 16) = *(v8 + 16);
      *(v8 + 16) = v9;
      v10 = *(a4 + 24);
      *(a4 + 24) = *(v8 + 24);
      *(v8 + 24) = v10;
      v8 += 40;
      a4 += 40;
    }

    while (v8 != a3);
    do
    {
      v11[0] = (v7 + 8);
      std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](v11);
      v7 += 40;
    }

    while (v7 != a3);
  }
}

uint64_t std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__init_with_size[abi:ne200100]<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1DE7454AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v6 = 0;
    do
    {
      *(a3 + v6) = *(a1 + v6);
      std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::__value_func[abi:ne200100](a3 + v6 + 8, a1 + v6 + 8);
      v6 += 40;
    }

    while (a1 + v6 != a2);
    a3 += v6;
  }

  return a3;
}

void AMCP::Observer::Map<std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,unsigned int,true,std::less<unsigned int>>::deregister_observer(uint64_t a1, unint64_t a2)
{
  std::__shared_mutex_base::lock(a1);
  if (*(a1 + 168) == 1)
  {
    v4 = *(a1 + 176);
    v5 = *(a1 + 184);
    if (v4 != v5)
    {
      v6 = -v4;
      while (1)
      {
        v7 = *(v4 + 16);
        if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::find(*(v4 + 8), v7, a2))
        {
          break;
        }

        v4 += 40;
        v6 -= 40;
        if (v4 == v5)
        {
          goto LABEL_20;
        }
      }

      v9 = v8;
      if (v8 + 5 != v7)
      {
        do
        {
          v10 = v9 + 5;
          std::__memberwise_forward_assign[abi:ne200100]<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>,unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>,0ul,1ul>(v9, v9 + 5);
          v11 = v9 + 10;
          v9 += 5;
        }

        while (v11 != v7);
        v7 = *(v4 + 16);
        v9 = v10;
      }

      for (; v7 != v9; v7 -= 5)
      {
        std::__function::__value_func<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>::~__value_func[abi:ne200100]((v7 - 4));
      }

      *(v4 + 16) = v9;
      if (*(v4 + 8) == v9)
      {
        v12 = *(a1 + 184);
        if (v4 + 40 != v12)
        {
          v13 = *(a1 + 176);
          v14 = -v13;
          v15 = v13 - v6;
          do
          {
            v16 = v15 + v14;
            *v16 = *(v15 + v14 + 40);
            v17 = *(v15 + v14 + 8);
            *(v16 + 8) = *(v15 + v14 + 48);
            *(v16 + 48) = v17;
            v18 = *(v15 + v14 + 24);
            *(v16 + 24) = *(v15 + v14 + 64);
            *(v16 + 64) = v18;
            v15 += 40;
            v4 = v15 + v14;
          }

          while (v15 + v14 + 40 != v12);
          v12 = *(a1 + 184);
        }

        if (v12 != v4)
        {
          do
          {
            v19 = v12 - 40;
            v20 = (v12 - 32);
            std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,boost::container::flat_map<unsigned int,std::tuple<boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>,boost::container::flat_map<AMCP::Address,AMCP::Thing,AMCP::Address::Is_Exact_Before,void>>,std::less<unsigned int>,void>> const&)>>>::__destroy_vector::operator()[abi:ne200100](&v20);
            v12 = v19;
          }

          while (v19 != v4);
        }

        *(a1 + 184) = v4;
      }
    }
  }

LABEL_20:
  std::__shared_mutex_base::unlock(a1);
}

void *std::__memberwise_copy_assign[abi:ne200100]<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>>,std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>>,0ul,1ul>(void *result, void *a2)
{
  *result = *a2;
  if (result != a2)
  {
    v2 = result;
    v4 = (result + 1);
    v3 = result[1];
    v6 = a2[1];
    v5 = a2[2];
    v7 = v5 - v6;
    v8 = result[3];
    if (v8 - v3 < (v5 - v6))
    {
      v9 = 0x8E38E38E38E38E39 * (v7 >> 3);
      if (v3)
      {
        std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__base_destruct_at_end[abi:ne200100]((result + 1), v3);
        operator delete(*v4);
        v8 = 0;
        *v4 = 0;
        *(v4 + 8) = 0;
        *(v4 + 16) = 0;
      }

      if (v9 <= 0x38E38E38E38E38ELL)
      {
        v10 = 0x8E38E38E38E38E39 * (v8 >> 3);
        v11 = 2 * v10;
        if (2 * v10 <= v9)
        {
          v11 = v9;
        }

        if (v10 >= 0x1C71C71C71C71C7)
        {
          v12 = 0x38E38E38E38E38ELL;
        }

        else
        {
          v12 = v11;
        }

        std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__vallocate[abi:ne200100](v4, v12);
      }

      std::vector<void *>::__throw_length_error[abi:ne200100]();
    }

    v13 = result[2] - v3;
    if (v13 >= v7)
    {
      std::__copy_impl::operator()[abi:ne200100]<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> *,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> *,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> *>(a2[1], a2[2], v3);

      return std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__base_destruct_at_end[abi:ne200100](v4, v15);
    }

    else
    {
      v14 = std::__copy_impl::operator()[abi:ne200100]<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> *,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> *,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> *>(v6, &v6[v13], v3);
      result = std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*>(v4, v14, v5, v2[2]);
      v2[2] = result;
    }
  }

  return result;
}

uint64_t std::__split_buffer<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>>>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 40;
    v5 = (i - 32);
    std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__destroy_vector::operator()[abi:ne200100](&v5);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>>>,std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>>>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    v11[3] = v4;
    v11[4] = v5;
    v7 = a2;
    v8 = a2;
    do
    {
      *a4 = *v8;
      *(a4 + 16) = 0;
      *(a4 + 24) = 0;
      *(a4 + 8) = 0;
      *(a4 + 8) = *(v8 + 8);
      *(v8 + 8) = 0;
      v9 = *(a4 + 16);
      *(a4 + 16) = *(v8 + 16);
      *(v8 + 16) = v9;
      v10 = *(a4 + 24);
      *(a4 + 24) = *(v8 + 24);
      *(v8 + 24) = v10;
      v8 += 40;
      a4 += 40;
    }

    while (v8 != a3);
    do
    {
      v11[0] = (v7 + 8);
      std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__destroy_vector::operator()[abi:ne200100](v11);
      v7 += 40;
    }

    while (v7 != a3);
  }
}

uint64_t std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__init_with_size[abi:ne200100]<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1DE7459F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::__vallocate[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (a2 < 0x38E38E38E38E38FLL)
  {
    std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>::allocate_at_least[abi:ne200100](a2);
  }

  std::vector<void *>::__throw_length_error[abi:ne200100]();
}

void *std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*>(uint64_t a1, void *a2, void *a3, void *a4)
{
  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = *v6;
      std::__function::__value_func<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::__value_func[abi:ne200100]((v4 + 1), (v6 + 1));
      std::__function::__value_func<void ()(AMCP::Graph_Description const&)>::__value_func[abi:ne200100]((v4 + 5), (v6 + 5));
      v6 += 9;
      v4 = v11 + 9;
      v11 += 9;
    }

    while (v6 != a3);
  }

  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>>,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>>*>>::~__exception_guard_exceptions[abi:ne200100](v8);
  return v4;
}

void *std::__copy_impl::operator()[abi:ne200100]<std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> *,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> *,std::tuple<unsigned long long,std::pair<std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>,std::function<void ()(AMCP::Graph_Description const&)>>> *>(void *a1, void *a2, void *a3)
{
  v3 = a3;
  v4 = a1;
  if (a1 != a2)
  {
    v6 = a3;
    v7 = a1;
    do
    {
      v8 = *v7;
      v7 += 9;
      *v6 = v8;
      v6 += 9;
      std::function<std::pair<AMCP::Graph_Description,AMCP::Modify_Graph_Destroy_List> ()(void)>::operator=((v3 + 1), (v4 + 1));
      std::function<void ()(AMCP::Graph_Description const&)>::operator=((v3 + 5), (v4 + 5));
      v3 = v6;
      v4 = v7;
    }

    while (v7 != a2);
    return a2;
  }

  return v4;
}

void AMCP::Core::Conductor::notify_control_value_observers(AMCP::Core::Conductor *this, unsigned int a2)
{
  v13[42] = *MEMORY[0x1E69E9840];
  AMCP::Utility::Dispatch_Queue::Dispatch_Queue(v13, this + 46);
  std::__shared_mutex_base::lock_shared((this + 2480));
  if (*(this + 2648))
  {
    v11 = 0uLL;
    *&v12 = 0;
    if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find( *(this + 332),  *(this + 333),  a2))
    {
      AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()>> const*>>(&v11, *(v4 + 8), *(v4 + 16));
    }

    v5 = *(this + 672);
    if (v5 != a2
      && AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find( *(this + 332),  *(this + 333),  v5))
    {
      AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()>> const*>>(&v11, *(v6 + 8), *(v6 + 16));
    }
  }

  else
  {
    v11 = 0u;
    v12 = 0u;
  }

  std::__shared_mutex_base::unlock_shared((this + 2480));
  if (v11 != *(&v11 + 1))
  {
    v8 = v11;
    v11 = 0uLL;
    v9 = v12;
    *&v12 = 0;
    v10 = a2;
    operator new();
  }

  *&v8 = &v11;
  std::vector<std::tuple<unsigned long long,std::function<void ()>>>::__destroy_vector::operator()[abi:ne200100](&v8);
  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue(v13);
  v7 = *MEMORY[0x1E69E9840];
}

void sub_1DE745D48(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

void ***std::unique_ptr<void AMCP::Observer::Map<std::function<void ()(unsigned int)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &>(AMCP::Utility::Dispatch_Queue const&,unsigned int const&,unsigned int &)::{lambda(void)#1},std::default_delete<std::default_delete>>::~unique_ptr[abi:ne200100](void ***a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v4 = v2;
    std::vector<std::tuple<unsigned long long,std::function<void ()>>>::__destroy_vector::operator()[abi:ne200100](&v4);
    MEMORY[0x1E12C1730](v2, 0x1020C40A4A973E6);
  }

  return a1;
}

void ***applesauce::dispatch::v1::async<void AMCP::Observer::Map<std::function<void ()(unsigned int)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &>(AMCP::Utility::Dispatch_Queue const&,unsigned int const&,unsigned int &)::{lambda(void)#1}>(dispatch_queue_s *,void AMCP::Observer::Map<std::function<void ()(unsigned int)>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &>(AMCP::Utility::Dispatch_Queue const&,unsigned int const&,unsigned int &)::{lambda(void)#1} &&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  v5 = a1;
  v1 = *a1;
  v2 = *(a1 + 8);
  if (*a1 != v2)
  {
    do
    {
      std::function<void ()>::operator()(v1[4], *(a1 + 32));
      v1 += 5;
    }

    while (v1 != v2);
  }

  return std::unique_ptr<void AMCP::Observer::Map<std::function<void ()>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &>(AMCP::Utility::Dispatch_Queue const&,unsigned int const&,unsigned int &)::{lambda(void)#1},std::default_delete<std::default_delete>>::~unique_ptr[abi:ne200100](&v5);
}

void sub_1DE745E1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<void AMCP::Observer::Map<std::function<void ()>,unsigned int,true,std::less<unsigned int>>::call_observers_async<unsigned int &>(AMCP::Utility::Dispatch_Queue const&,unsigned int const&,unsigned int &)::{lambda(void)#1},std::default_delete<std::default_delete>>::~unique_ptr[abi:ne200100](va);
  _Unwind_Resume(a1);
}

uint64_t *AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>>::insert_unique<std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int)>> const*>,std::__wrap_iter<std::tuple<unsigned long long,std::function<void ()(unsigned int)>> const*>>(uint64_t *result, char *a2, char *a3)
{
  if (a2 != a3)
  {
    v4 = a2;
    v5 = result;
    do
    {
      v6 = *v4;
      if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::find(*v5, v5[1], *v4))
      {
        *v7 = v6;
        result = std::function<void ()>::operator=((v7 + 8), (v4 + 8));
      }

      else
      {
        result = std::vector<std::tuple<unsigned long long,std::function<void ()>>>::insert(v5, v7, v4);
      }

      v4 += 40;
    }

    while (v4 != a3);
  }

  return result;
}

char *std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>::insert(uint64_t *a1, char *a2, char *a3)
{
  v4 = a2;
  v7 = a1[1];
  v6 = a1[2];
  if (v7 >= v6)
  {
    v12 = *a1;
    v13 = 0xCCCCCCCCCCCCCCCDLL * (&v7[-*a1] >> 3) + 1;
    if (v13 > 0x666666666666666)
    {
      std::vector<void *>::__throw_length_error[abi:ne200100]();
    }

    v14 = &a2[-v12];
    v15 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - v12) >> 3);
    if (2 * v15 > v13)
    {
      v13 = 2 * v15;
    }

    if (v15 >= 0x333333333333333)
    {
      v16 = 0x666666666666666;
    }

    else
    {
      v16 = v13;
    }

    v33 = a1;
    if (v16)
    {
      std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::allocate_at_least[abi:ne200100](v16);
    }

    v17 = (8 * (v14 >> 3));
    v30 = 0;
    v31 = v17;
    v32 = v17;
    if (!(0xCCCCCCCCCCCCCCCDLL * (v14 >> 3)))
    {
      if (v14 < 1)
      {
        if (v12 == a2)
        {
          v22 = 1;
        }

        else
        {
          v22 = 0x999999999999999ALL * (v14 >> 3);
        }

        v34 = a1;
        std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::allocate_at_least[abi:ne200100](v22);
      }

      v17 -= 5 * ((1 - 0x3333333333333333 * (v14 >> 3)) >> 1);
      v31 = v17;
      *&v32 = v17;
    }

    *v17 = *a3;
    std::__function::__value_func<void ()>::__value_func[abi:ne200100]((v17 + 1), (a3 + 8));
    v23 = v31;
    *&v32 = v32 + 40;
    std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()>>>,std::tuple<unsigned long long,std::function<void ()>>*>(v4, a1[1], v32);
    v24 = *a1;
    v25 = v31;
    *&v32 = v32 + a1[1] - v4;
    a1[1] = v4;
    v26 = v25 + v24 - v4;
    std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()>>>,std::tuple<unsigned long long,std::function<void ()>>*>(v24, v4, v26);
    v27 = *a1;
    *a1 = v26;
    v28 = a1[2];
    *(a1 + 1) = v32;
    *&v32 = v27;
    *(&v32 + 1) = v28;
    v30 = v27;
    v31 = v27;
    std::__split_buffer<std::tuple<unsigned long long,std::function<void ()>>>::~__split_buffer(&v30);
    return v23;
  }

  else if (a2 == v7)
  {
    *v7 = *a3;
    std::__function::__value_func<void ()>::__value_func[abi:ne200100]((v7 + 8), (a3 + 8));
    a1[1] = (v7 + 40);
  }

  else
  {
    v8 = a2 + 40;
    v9 = v7 - 40;
    if (v7 < 0x28)
    {
      v11 = a1[1];
    }

    else
    {
      v10 = 0;
      do
      {
        *&v7[v10] = *&v7[v10 - 40];
        std::__function::__value_func<void ()>::__value_func[abi:ne200100](&v7[v10 + 8], &v7[v10 - 32]);
        v10 += 40;
      }

      while (&v7[v10 - 40] < v7);
      v11 = &v7[v10];
    }

    a1[1] = v11;
    if (v7 != v8)
    {
      v18 = v4 - v7 + 40;
      v19 = v7 - 80;
      do
      {
        std::__memberwise_forward_assign[abi:ne200100]<std::tuple<unsigned long long,std::function<void ()>>,std::tuple<unsigned long long,std::function<void ()>>,unsigned long long,std::function<void ()>,0ul,1ul>(v9, v19);
        v9 -= 40;
        v19 -= 40;
        v18 += 40;
      }

      while (v18);
      v11 = a1[1];
    }

    v20 = v11 <= a3 || v4 > a3;
    v21 = 40;
    if (v20)
    {
      v21 = 0;
    }

    *v4 = *&a3[v21];
    std::function<void ()>::operator=(v4 + 1, &a3[v21 + 8]);
  }

  return v4;
}

uint64_t std::__split_buffer<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 40;
    std::__function::__value_func<void ()>::~__value_func[abi:ne200100](i - 32);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int)>>*>(uint64_t result, void *a2, uint64_t a3)
{
  if (result != a2)
  {
    v4 = result;
    v5 = a3 + 8;
    v6 = v4;
    v7 = v4;
    do
    {
      v8 = *v7;
      v7 += 5;
      *(v5 - 8) = v8;
      v5 = std::__function::__value_func<void ()>::__value_func[abi:ne200100](v5, (v6 + 1)) + 40;
      v6 = v7;
    }

    while (v7 != a2);
    do
    {
      result = std::__function::__value_func<void ()>::~__value_func[abi:ne200100]((v4 + 1));
      v4 += 5;
    }

    while (v4 != a2);
  }

  return result;
}

unint64_t AMCP::Observer::Map<std::function<void ()(unsigned int)>,unsigned int,true,std::less<unsigned int>>::register_observer(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  v23 = *MEMORY[0x1E69E9840];
  v17 = a1;
  v18 = 1;
  std::__shared_mutex_base::lock(a1);
  if (*(a1 + 168) == 1)
  {
    add = atomic_fetch_add(&AMCP::Observer::Implementation::get_next_token(void)::s_next_token, 1uLL);
    if (!AMCP::Utility::Sorted_Vector<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>,0ul>,std::less<unsigned int>,std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>>>>::find( *(a1 + 176),  *(a1 + 184),  *a2))
    {
      v19 = add;
      std::__function::__value_func<void ()>::__value_func[abi:ne200100](&v20, a3);
      v15 = 0uLL;
      v16 = 0;
      v21 = &v15;
      v22 = 0;
      operator new();
    }

    v8 = v7;
    v21 = add;
    std::__function::__value_func<void ()>::__value_func[abi:ne200100](&v22, a3);
    v9 = *(v8 + 8);
    v10 = *(v8 + 16);
    v11 = (v8 + 8);
    if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::find(v9, v10, add))
    {
      *v12 = add;
      std::function<void ()>::operator=((v12 + 8), &v22);
    }

    else
    {
      std::vector<std::tuple<unsigned long long,std::function<void ()>>>::insert(v11, v12, &v21);
    }

    std::__function::__value_func<void ()>::~__value_func[abi:ne200100](&v22);
  }

  else
  {
    add = 0;
  }

  std::__shared_mutex_base::unlock(a1);
  v13 = *MEMORY[0x1E69E9840];
  return add;
}

void sub_1DE746808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, void **a20)
{
  *(v20 + 184) = v21;
  std::vector<std::tuple<unsigned long long,std::function<void ()>>>::__destroy_vector::operator()[abi:ne200100](&a20);
  a20 = &a9;
  std::vector<std::tuple<unsigned long long,std::function<void ()>>>::__destroy_vector::operator()[abi:ne200100](&a20);
  std::__function::__value_func<void ()>::~__value_func[abi:ne200100](v22 + 8);
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne200100](&a18);
  _Unwind_Resume(a1);
}

uint64_t std::__memberwise_copy_assign[abi:ne200100]<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>>>,std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>>>,0ul,1ul>(uint64_t result, uint64_t a2)
{
  *result = *a2;
  if (result != a2)
  {
    v2 = result;
    v3 = (result + 8);
    v4 = *(result + 8);
    v6 = *(a2 + 8);
    v5 = *(a2 + 16);
    v7 = v5 - v6;
    v8 = *(result + 24);
    if (v8 - v4 < (v5 - v6))
    {
      v9 = 0xCCCCCCCCCCCCCCCDLL * (v7 >> 3);
      if (v4)
      {
        v10 = *(result + 16);
        v11 = *(result + 8);
        if (v10 != v4)
        {
          do
          {
            v12 = v10 - 5;
            std::__function::__value_func<void ()>::~__value_func[abi:ne200100]((v10 - 4));
            v10 = v12;
          }

          while (v12 != v4);
          v11 = *v3;
        }

        *(v2 + 16) = v4;
        operator delete(v11);
        v8 = 0;
        *v3 = 0;
        v3[1] = 0;
        v3[2] = 0;
      }

      if (v9 <= 0x666666666666666)
      {
        v13 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 3);
        v14 = 2 * v13;
        if (2 * v13 <= v9)
        {
          v14 = v9;
        }

        if (v13 >= 0x333333333333333)
        {
          v15 = 0x666666666666666;
        }

        else
        {
          v15 = v14;
        }

        std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__vallocate[abi:ne200100](v3, v15);
      }

      std::vector<void *>::__throw_length_error[abi:ne200100]();
    }

    v16 = *(result + 16);
    v17 = v16 - v4;
    if (v16 - v4 >= v7)
    {
      if (v6 != v5)
      {
        v21 = *(result + 8);
        v22 = *(a2 + 8);
        do
        {
          v23 = *v22;
          v22 += 5;
          *v21 = v23;
          v21 += 5;
          result = std::function<void ()>::operator=(v4 + 1, v6 + 8);
          v4 = v21;
          v6 = v22;
        }

        while (v22 != v5);
        v16 = *(v2 + 16);
      }

      for (; v16 != v4; v16 -= 40)
      {
        result = std::__function::__value_func<void ()>::~__value_func[abi:ne200100](v16 - 32);
      }

      *(v2 + 16) = v4;
    }

    else
    {
      if (v16 != v4)
      {
        v18 = v6 + v17;
        v19 = v4 + 1;
        v20 = v6 + 8;
        do
        {
          *(v19 - 1) = *(v20 - 8);
          v19 = std::function<void ()>::operator=(v19, v20) + 5;
          v20 += 40;
          v17 -= 40;
        }

        while (v17);
        v16 = *(v2 + 16);
        v6 = v18;
      }

      result = std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()>>>,std::tuple<unsigned long long,std::function<void ()>>*,std::tuple<unsigned long long,std::function<void ()>>*,std::tuple<unsigned long long,std::function<void ()>>*>(v6, v5, v16);
      *(v2 + 16) = result;
    }
  }

  return result;
}

uint64_t std::__split_buffer<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>>>>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 40;
    v5 = (i - 32);
    std::vector<std::tuple<unsigned long long,std::function<void ()>>>::__destroy_vector::operator()[abi:ne200100](&v5);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>>>>,std::tuple<unsigned int,AMCP::Utility::Sorted_Vector_Map<unsigned long long,std::function<void ()(unsigned int)>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>>>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    v11[3] = v4;
    v11[4] = v5;
    v7 = a2;
    v8 = a2;
    do
    {
      *a4 = *v8;
      *(a4 + 16) = 0;
      *(a4 + 24) = 0;
      *(a4 + 8) = 0;
      *(a4 + 8) = *(v8 + 8);
      *(v8 + 8) = 0;
      v9 = *(a4 + 16);
      *(a4 + 16) = *(v8 + 16);
      *(v8 + 16) = v9;
      v10 = *(a4 + 24);
      *(a4 + 24) = *(v8 + 24);
      *(v8 + 24) = v10;
      v8 += 40;
      a4 += 40;
    }

    while (v8 != a3);
    do
    {
      v11[0] = (v7 + 8);
      std::vector<std::tuple<unsigned long long,std::function<void ()>>>::__destroy_vector::operator()[abi:ne200100](v11);
      v7 += 40;
    }

    while (v7 != a3);
  }
}

uint64_t std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>::__init_with_size[abi:ne200100]<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int)>>*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1DE746BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<std::tuple<unsigned long long,std::function<void ()>>>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int)>>>,std::tuple<unsigned long long,std::function<void ()(unsigned int)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int)>>*,std::tuple<unsigned long long,std::function<void ()(unsigned int)>>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v6 = 0;
    do
    {
      *(a3 + v6) = *(a1 + v6);
      std::__function::__value_func<void ()>::__value_func[abi:ne200100](a3 + v6 + 8, a1 + v6 + 8);
      v6 += 40;
    }

    while (a1 + v6 != a2);
    a3 += v6;
  }

  return a3;
}

void AMCP::Core::Conductor::destroy_control_value_observer(AMCP::Core::Conductor *this, unint64_t a2)
{
  std::__shared_mutex_base::lock((this + 2480));
  if (*(this + 2648) == 1)
  {
    v4 = *(this + 332);
    v5 = *(this + 333);
    if (v4 != v5)
    {
      v6 = -v4;
      while (1)
      {
        v7 = *(v4 + 16);
        if (AMCP::Utility::Sorted_Vector<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,AMCP::Utility::Extract_Key_Get_N<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>,0ul>,std::less<unsigned long long>,std::allocator<std::tuple<unsigned long long,std::function<void ()(unsigned int,BOOL,std::tuple<std::vector<unsigned int>,std::vector<unsigned int>,std::unordered_map<unsigned int,std::tuple<std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>,std::unordered_map<AMCP::Address,AMCP::Thing,AMCP::Address::Hash,AMCP::Address::Is_Exact_Match,std::allocator<std::pair<AMCP::Address const,AMCP::Thing>>>>>> const&)>>>>::find(*(v4 + 8), v7, a2))
        {
          break;
        }

        v4 += 40;
        v6 -= 40;
        if (v4 == v5)
        {
          goto LABEL_20;
        }
      }

      v9 = v8;
      if (v8 + 5 != v7)
      {
        do
        {
          v10 = v9 + 5;
          std::__memberwise_forward_assign[abi:ne200100]<std::tuple<unsigned long long,std::function<void ()>>,std::tuple<unsigned long long,std::function<void ()>>,unsigned long long,std::function<void ()>,0ul,1ul>(v9, v9 + 5);
          v11 = v9 + 10;
          v9 += 5;
        }

        while (v11 != v7);
        v7 = *(v4 + 16);
        v9 = v10;
      }

      for (; v7 != v9; v7 -= 5)
      {
        std::__function::__value_func<void ()>::~__value_func[abi:ne200100]((v7 - 4));
      }

      *(v4 + 16) = v9;
      if (*(v4 + 8) == v9)
      {
        v12 = *(this + 333);
        if (v4 + 40 != v12)
        {
          v13 = *(this + 332);
          v14 = -v13;
          v15 = v13 - v6;
          do
          {
            v16 = v15 + v14;
            *v16 = *(v15 + v14 + 40);
            v17 = *(v15 + v14 + 8);
            *(v16 + 8) = *(v15 + v14 + 48);
            *(v16 + 48) = v17;
            v18 = *(v15 + v14 + 24);
            *(v16 + 24) = *(v15 + v14 + 64);
            *(v16 + 64) = v18;
            v15 += 40;
            v4 = v15 + v14;
          }

          while (v15 + v14 + 40 != v12);
          v12 = *(this + 333);
        }

        if (v12 != v4)
        {
          do
          {
            v19 = v12 - 40;
            v20 = (v12 - 32);
            std::vector<std::tuple<unsigned long long,std::function<void ()>>>::__destroy_vector::operator()[abi:ne200100](&v20);
            v12 = v19;
          }

          while (v19 != v4);
        }

        *(this + 333) = v4;
      }
    }
  }

LABEL_20:
  std::__shared_mutex_base::unlock((this + 2480));
}

uint64_t CACFDictionary::GetBool(uint64_t this, const __CFString *a2, BOOL *a3)
{
  if (this)
  {
    this = CFDictionaryGetValue(this, a2);
    if (this)
    {
      v4 = this;
      v5 = CFGetTypeID(this);
      if (v5 == CFBooleanGetTypeID())
      {
        this = CFBooleanGetValue(v4);
        v6 = this == 0;
      }

      else
      {
        v7 = CFGetTypeID(v4);
        this = CFNumberGetTypeID();
        if (v7 != this)
        {
          return this;
        }

        valuePtr = 0;
        this = CFNumberGetValue(v4, kCFNumberSInt32Type, &valuePtr);
        v6 = valuePtr == 0;
      }

      v8 = !v6;
      *a3 = v8;
    }
  }

  return this;
}

const __CFDictionary *CACFDictionary::GetSInt32(const __CFDictionary *this, const __CFString *a2, int *a3)
{
  if (this)
  {
    this = CFDictionaryGetValue(this, a2);
    if (this)
    {
      v4 = this;
      v5 = CFGetTypeID(this);
      this = CFNumberGetTypeID();
      if (v5 == this)
      {

        return CFNumberGetValue(v4, kCFNumberSInt32Type, a3);
      }
    }
  }

  return this;
}

uint64_t CACFDictionary::GetUInt32(uint64_t this, const __CFString *a2, unsigned int *a3)
{
  if (this)
  {
    this = CFDictionaryGetValue(this, a2);
    if (this)
    {
      v4 = this;
      v5 = CFGetTypeID(this);
      if (v5 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v4, kCFNumberSInt32Type, a3);
        return 1;
      }

      else
      {
        return 0;
      }
    }
  }

  return this;
}

uint64_t CACFDictionary::GetUInt64(uint64_t this, const __CFString *a2, unint64_t *a3)
{
  if (this)
  {
    this = CFDictionaryGetValue(this, a2);
    if (this)
    {
      v4 = this;
      v5 = CFGetTypeID(this);
      if (v5 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v4, kCFNumberSInt64Type, a3);
        return 1;
      }

      else
      {
        return 0;
      }
    }
  }

  return this;
}

double CACFDictionary::GetFixed64(CACFDictionary *this, const __CFString *a2, double *a3)
{
  if (this)
  {
    Value = CFDictionaryGetValue(this, a2);
    if (Value)
    {
      v6 = Value;
      v7 = CFGetTypeID(Value);
      if (v7 == CFNumberGetTypeID())
      {
        valuePtr = 0;
        CFNumberGetValue(v6, kCFNumberSInt64Type, &valuePtr);
        result = vcvtd_n_f64_u64(valuePtr, 0x20uLL) + (valuePtr >> 32);
        *a3 = result;
      }
    }
  }

  return result;
}

uint64_t CACFDictionary::GetArray(uint64_t this, const __CFString *a2, const __CFArray **a3)
{
  if (this)
  {
    this = CFDictionaryGetValue(this, a2);
    if (this)
    {
      v4 = this;
      v5 = CFGetTypeID(this);
      if (v5 == CFArrayGetTypeID())
      {
        *a3 = v4;
        return 1;
      }

      else
      {
        return 0;
      }
    }
  }

  return this;
}

uint64_t CACFDictionary::GetDictionary(uint64_t this, const __CFString *a2, const __CFDictionary **a3)
{
  if (this)
  {
    this = CFDictionaryGetValue(this, a2);
    if (this)
    {
      v4 = this;
      v5 = CFGetTypeID(this);
      if (v5 == CFDictionaryGetTypeID())
      {
        *a3 = v4;
        return 1;
      }

      else
      {
        return 0;
      }
    }
  }

  return this;
}

const __CFDictionary *CACFDictionary::GetCACFString(const __CFDictionary **this, const __CFString *a2, CACFString *a3)
{
  CACFString::operator=(a3, 0);
  result = *this;
  if (*this)
  {
    result = CFDictionaryGetValue(result, a2);
    if (result)
    {
      v7 = result;
      v8 = CFGetTypeID(result);
      result = CFStringGetTypeID();
      if (v8 == result)
      {

        return CACFString::operator=(a3, v7);
      }
    }
  }

  return result;
}

const __CFDictionary *CACFDictionary::GetCACFArray(const __CFDictionary **this, const __CFString *key, CFTypeRef *a3)
{
  if (*(a3 + 8) == 1 && *a3)
  {
    CFRelease(*a3);
  }

  *a3 = 0;
  *(a3 + 9) = 0;
  result = *this;
  if (*this)
  {
    result = CFDictionaryGetValue(result, key);
    if (result)
    {
      v7 = result;
      v8 = CFGetTypeID(result);
      result = CFArrayGetTypeID();
      if (v8 == result)
      {

        return CACFArray::operator=(a3, v7);
      }
    }
  }

  return result;
}

const __CFDictionary *CACFDictionary::GetCACFDictionary(const __CFDictionary **this, const __CFString *key, CFTypeRef *a3)
{
  if (*(a3 + 8) == 1 && *a3)
  {
    CFRelease(*a3);
  }

  *a3 = 0;
  *(a3 + 9) = 0;
  result = *this;
  if (*this)
  {
    result = CFDictionaryGetValue(result, key);
    if (result)
    {
      v7 = result;
      v8 = CFGetTypeID(result);
      result = CFDictionaryGetTypeID();
      if (v8 == result)
      {

        return CACFDictionary::operator=(a3, v7);
      }
    }
  }

  return result;
}

void CACFDictionary::AddUInt32(CFMutableDictionaryRef *this, const __CFString *a2, int a3)
{
  valuePtr = a3;
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v6 = v5;
  v7 = 1;
  if (*(this + 9) == 1 && v5 && *this)
  {
    CFDictionarySetValue(*this, a2, v5);
  }

  CACFNumber::~CACFNumber(&v6);
}

void sub_1DE7473D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CACFNumber::~CACFNumber(va);
  _Unwind_Resume(a1);
}

caulk::rt_safe_memory_resource *AMCP::Utility::AudioBufferList_Create(AMCP::Utility *this)
{
  v1 = this;
  result = *MEMORY[0x1E69E3C08];
  if (*MEMORY[0x1E69E3C08])
  {
    v3 = caulk::rt_safe_memory_resource::rt_allocate(result);
    bzero(v3, (16 * v1) | 8u);
    if (v3)
    {
      *v3 = v1;
    }

    return v3;
  }

  else
  {
    __break(1u);
  }

  return result;
}

BOOL HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::set_state_if (uint64_t a1, int a2, unsigned int a3)
{
  v3 = a2;
  atomic_compare_exchange_strong((a1 + 8), &v3, a3);
  return v3 == a2;
}

void HALS_DSPHostModifier_HostPrivateRefStreamDeviceUID::on_set_requested(HALS_DSPHostModifier_HostPrivateRefStreamDeviceUID *this)
{
  v25 = *MEMORY[0x1E69E9840];
  (*(*this + 56))(&__p);
  if (v21 == 1)
  {
    v19 = __p;
  }

  else
  {
    std::string::basic_string[abi:ne200100]<0>(&v19, "<none>");
    if ((v21 & 1) != 0 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::get_requested(this, &__p);
  if (v21 == 1)
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    v3 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v3 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v2);
    }

    v5 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v4 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v4)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      v6 = *v5;
      std::__shared_weak_count::__release_shared[abi:ne200100](v4);
    }

    else
    {
      v6 = *v5;
    }

    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      v8 = 0;
      v9 = 0;
      v10 = 47;
      do
      {
        v11 = &aLibraryCachesC_233[v8];
        if (v10 == 47)
        {
          v9 = &aLibraryCachesC_233[v8];
        }

        v10 = v11[1];
        if (!v11[1])
        {
          break;
        }
      }

      while (v8++ < 0xFFF);
      if (v9)
      {
        v13 = v9 + 1;
      }

      else
      {
        v13 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/Source/HAL/Core/DSPHosting/HALS_DSPHostModifier_HostPrivateReferenceStreamDeviceUID.cpp";
      }

      v14 = atomic_load(this + 2);
      HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::get_requested(this, &v17);
      if ((v18 & 1) == 0)
      {
        std::__throw_bad_optional_access[abi:ne200100]();
      }

      v15 = &v17;
      if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        v15 = v17.__r_.__value_.__r.__words[0];
      }

      v16 = &v19;
      if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        v16 = v19.__r_.__value_.__r.__words[0];
      }

      LODWORD(__p.__r_.__value_.__l.__data_) = 136316162;
      *(__p.__r_.__value_.__r.__words + 4) = v13;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 1024;
      *(&__p.__r_.__value_.__r.__words[1] + 6) = 22;
      WORD1(__p.__r_.__value_.__r.__words[2]) = 1024;
      HIDWORD(__p.__r_.__value_.__r.__words[2]) = v14;
      v21 = 2080;
      v22 = v15;
      v23 = 2080;
      v24 = v16;
      _os_log_debug_impl(&dword_1DE1F9000, v6, OS_LOG_TYPE_DEBUG, "%32s:%-5d [ahal_dsp] (State: %d) Reference stream requested from %s (currently %s)", &__p, 0x2Cu);
      if (v18 == 1 && SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v17.__r_.__value_.__l.__data_);
      }
    }
  }

  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v19.__r_.__value_.__l.__data_);
  }

  v7 = *MEMORY[0x1E69E9840];
}

void sub_1DE7476D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, char a29)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::get_requested(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  std::mutex::lock((a1 + 72));
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne200100](a2, (a1 + 40));

  std::mutex::unlock((a1 + 72));
}

void HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::get_current(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  v3 = atomic_load((a1 + 8));
  if (v3 == 3)
  {

    HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::get_requested(a1, a2);
  }

  else
  {
    if (*(a1 + 39) < 0)
    {
      std::string::__init_copy_ctor_external(a2, *(a1 + 16), *(a1 + 24));
    }

    else
    {
      *&a2->__r_.__value_.__l.__data_ = *(a1 + 16);
      a2->__r_.__value_.__r.__words[2] = *(a1 + 32);
    }

    a2[1].__r_.__value_.__s.__data_[0] = 1;
  }
}

void HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::clear_requested(uint64_t a1)
{
  std::mutex::lock((a1 + 72));
  atomic_exchange((a1 + 8), 0);
  if (*(a1 + 64) == 1)
  {
    if (*(a1 + 63) < 0)
    {
      operator delete(*(a1 + 40));
    }

    *(a1 + 64) = 0;
  }

  std::mutex::unlock((a1 + 72));
}

void HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::get_unmodified(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(a1 + 16), *(a1 + 24));
  }

  else
  {
    *&a2->__r_.__value_.__l.__data_ = *(a1 + 16);
    a2->__r_.__value_.__r.__words[2] = *(a1 + 32);
  }

  a2[1].__r_.__value_.__s.__data_[0] = 1;
}

void HALS_DSPHostModifier_HostPrivateRefStreamDeviceUID::~HALS_DSPHostModifier_HostPrivateRefStreamDeviceUID(HALS_DSPHostModifier_HostPrivateRefStreamDeviceUID *this)
{
  HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::~HALS_DSPHostModifierStorage(this);

  JUMPOUT(0x1E12C1730);
}

uint64_t HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::~HALS_DSPHostModifierStorage(uint64_t a1)
{
  *a1 = &unk_1F5990D08;
  std::mutex::~mutex((a1 + 72));
  if (*(a1 + 64) == 1 && *(a1 + 63) < 0)
  {
    operator delete(*(a1 + 40));
  }

  if (*(a1 + 39) < 0)
  {
    operator delete(*(a1 + 16));
  }

  return a1;
}

void HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::~HALS_DSPHostModifierStorage(uint64_t a1)
{
  HALS_DSPHostModifierStorage<AHAL_DSP::IHostModifier_HostPrivateReferenceStreamDeviceUID,std::string>::~HALS_DSPHostModifierStorage(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t AMCP::get_driver_property_traits_list(AMCP *this)
{
  {
    AMCP::get_driver_property_traits_list(void)::s_indesctructible_property_traits_list_ptr = 0;
  }

  if (atomic_load_explicit(&AMCP::get_driver_property_traits_list(void)::once, memory_order_acquire) != -1)
  {
    v4 = &v2;
    v3 = &v4;
    std::__call_once(&AMCP::get_driver_property_traits_list(void)::once, &v3, std::__call_once_proxy[abi:ne200100]<std::tuple<AMCP::get_driver_property_traits_list(void)::$_0 &&>>);
  }

  return AMCP::get_driver_property_traits_list(void)::s_indesctructible_property_traits_list_ptr;
}

void std::__call_once_proxy[abi:ne200100]<std::tuple<AMCP::get_driver_property_traits_list(void)::$_0 &&>>()
{
  v21[6] = *MEMORY[0x1E69E9840];
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(v0, 1768189556, 1, 1, 0, &AMCP::Property_Traits<1768189556u>::k_valid_scopes, &AMCP::Property_Traits<1650682995u>::k_valid_scopes, 0, 0, 15);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v1, 1650682995, 1, 1, 0, &AMCP::Property_Traits<1650682995u>::k_valid_scopes, &AMCP::Property_Traits<1668047219u>::k_valid_scopes, 0, 0, 6);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v2, 1668047219, 1, 1, 0, &AMCP::Property_Traits<1668047219u>::k_valid_scopes, &AMCP::Property_Traits<1870098034u>::k_valid_scopes, 0, 0, 6);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v3, 1870098034, 1, 1, 0, &AMCP::Property_Traits<1870098034u>::k_valid_scopes, &AMCP::Property_Traits<1869638759u>::k_valid_scopes, 0, 0, 15);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v4, 1869638759, 1, 1, 0, &AMCP::Property_Traits<1869638759u>::k_valid_scopes, &AMCP::Property_Traits<1870097955u>::k_valid_scopes, 0, 1869638759, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v5, 1870097955, 1, 0, 0, &AMCP::Property_Traits<1870097955u>::k_valid_scopes, &AMCP::Property_Traits<1819173229u>::k_valid_scopes, 0, 1870098020, 14);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v6, 1819173229, 0, 0, 1, &AMCP::Property_Traits<1819173229u>::k_valid_scopes, &AMCP::Property_Traits<1819111268u>::k_valid_scopes, 0, 1819173229, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v7, 1819111268, 0, 0, 0, &AMCP::Property_Traits<1819111268u>::k_valid_scopes, &AMCP::Property_Traits<1819107691u>::k_valid_scopes, 0, 1819111268, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v8, 1819107691, 0, 0, 0, &AMCP::Property_Traits<1819107691u>::k_valid_scopes, &AMCP::Property_Traits<1768124270u>::k_valid_scopes, 0, 1819107691, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v9, 1768124270, 0, 0, 0, &AMCP::Property_Traits<1768124270u>::k_valid_scopes, &AMCP::Property_Traits<1667330160u>::k_valid_scopes, 0, 1768124270, 5);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v10, 1667330160, 0, 0, 0, &AMCP::Property_Traits<1667330160u>::k_valid_scopes, &AMCP::Property_Traits<1936618861u>::k_valid_scopes, 0, 1667330160, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v11, 1936618861, 0, 0, 0, &AMCP::Property_Traits<1936618861u>::k_valid_scopes, &AMCP::Property_Traits<1719105134u>::k_valid_scopes, 0, 1936618861, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v12, 1719105134, 0, 0, 0, &AMCP::Property_Traits<1719105134u>::k_valid_scopes, AMCP::Property_Traits<1818454126u>::k_valid_scopes, 0, 1719105134, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v13, 1818454126, 0, 0, 0, AMCP::Property_Traits<1818454126u>::k_valid_scopes, &AMCP::Property_Traits<1818452846u>::k_valid_scopes, -1, 1818454126, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v14, 1818452846, 0, 0, 0, &AMCP::Property_Traits<1818452846u>::k_valid_scopes, &AMCP::Property_Traits<1818455662u>::k_valid_scopes, -1, 1818452846, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v15, 1818455662, 0, 0, 0, &AMCP::Property_Traits<1818455662u>::k_valid_scopes, &AMCP::Property_Traits<1920168547u>::k_valid_scopes, -1, 1818455662, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v16, 1920168547, 0, 0, 0, &AMCP::Property_Traits<1920168547u>::k_valid_scopes, &AMCP::Property_Traits<1668575852u>::k_valid_scopes, 0, 0, 5);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v17, 1668575852, 0, 0, 0, &AMCP::Property_Traits<1668575852u>::k_valid_scopes, &AMCP::Property_Traits<1885956452u>::k_valid_scopes, 0, 1668575852, 14);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v18, 1885956452, 1, 1, 0, &AMCP::Property_Traits<1885956452u>::k_valid_scopes, &AMCP::Property_Traits<1651472419u>::k_valid_scopes, 0, 1885956452, 4);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v19, 1651472419, 1, 0, 0, &AMCP::Property_Traits<1651472419u>::k_valid_scopes, &AMCP::Property_Traits<1668049699u>::k_valid_scopes, 0, 1651472419, 14);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(&v20, 1668049699, 1, 0, 0, &AMCP::Property_Traits<1668049699u>::k_valid_scopes, &AMCP::Property_Traits<1684370979u>::k_valid_scopes, 0, 1668049699, 14);
  AMCP::Live_Property_Traits::Live_Property_Traits<unsigned int const*>(v21, 1684370979, 1, 0, 0, &AMCP::Property_Traits<1684370979u>::k_valid_scopes, "N14mcp_applesauce2CF15PropertyListRefE", 0, 1684370979, 14);
  operator new();
}

void sub_1DE748064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  v13 = v12;
  MEMORY[0x1E12C1730](v13, 0x20C40960023A9);
  v15 = 1056;
  while (1)
  {
    v16 = *(&a12 + v15 - 40);
    if (v16)
    {
      *(&a12 + v15 - 32) = v16;
      operator delete(v16);
    }

    v15 -= 48;
    if (!v15)
    {
      _Unwind_Resume(a1);
    }
  }
}

void AMCP::DAL::demand_map(AMCP::DAL::DALSupport *a1)
{
  {
    if (a1)
    {
      AMCP::DAL::demand_map(void)::s_map = 0u;
      *&qword_1ECDAEC38 = 0u;
      dword_1ECDAEC48 = 1065353216;
    }
  }

  if ((AMCP::DAL::demand_map(void)::has_been_initialized & 1) == 0)
  {
    AMCP::DAL::demand_map(void)::has_been_initialized = 1;

    AMCP::DAL::DALSupport::initialize_data_handlers(a1);
  }
}

AMCP::DAL::DALSupport *AMCP::DAL::File::File(AMCP::DAL::DALSupport *a1, unsigned int a2, uint64_t a3)
{
  AMCP::DAL::demand_map(a1);
  if (!*(&AMCP::DAL::demand_map(void)::s_map + 1))
  {
    goto LABEL_17;
  }

  v6 = vcnt_s8(*(&AMCP::DAL::demand_map(void)::s_map + 8));
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = a2;
    if (*(&AMCP::DAL::demand_map(void)::s_map + 1) <= a2)
    {
      v7 = a2 % DWORD2(AMCP::DAL::demand_map(void)::s_map);
    }
  }

  else
  {
    v7 = (DWORD2(AMCP::DAL::demand_map(void)::s_map) - 1) & a2;
  }

  v8 = *(AMCP::DAL::demand_map(void)::s_map + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_17:
    *a1 = 0;
    *(a1 + 1) = 0;
    return a1;
  }

  while (1)
  {
    v10 = v9[1];
    if (v10 == a2)
    {
      break;
    }

    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= *(&AMCP::DAL::demand_map(void)::s_map + 1))
      {
        v10 %= *(&AMCP::DAL::demand_map(void)::s_map + 1);
      }
    }

    else
    {
      v10 &= *(&AMCP::DAL::demand_map(void)::s_map + 1) - 1;
    }

    if (v10 != v7)
    {
      goto LABEL_17;
    }

LABEL_16:
    v9 = *v9;
    if (!v9)
    {
      goto LABEL_17;
    }
  }

  if (*(v9 + 4) != a2)
  {
    goto LABEL_16;
  }

  v12 = v9[6];
  if (!v12)
  {
    std::__throw_bad_function_call[abi:ne200100]();
  }

  (*(*v12 + 48))(v12, a3);
  return a1;
}

void AMCP::DAL::File::~File(std::__shared_weak_count **this)
{
  ((*this)->__on_zero_shared_weak)(*this);
  v2 = this[1];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }
}

uint64_t AMCP::DAL::File::set_file_handler_format(AMCP::DAL::DALSupport *a1, uint64_t a2)
{
  v3 = a1;
  v17[3] = *MEMORY[0x1E69E9840];
  AMCP::DAL::demand_map(a1);
  if (!*(&AMCP::DAL::demand_map(void)::s_map + 1))
  {
    goto LABEL_18;
  }

  v4 = vcnt_s8(*(&AMCP::DAL::demand_map(void)::s_map + 8));
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = v3;
    if (*(&AMCP::DAL::demand_map(void)::s_map + 1) <= v3)
    {
      v5 = v3 % DWORD2(AMCP::DAL::demand_map(void)::s_map);
    }
  }

  else
  {
    v5 = (DWORD2(AMCP::DAL::demand_map(void)::s_map) - 1) & v3;
  }

  v6 = *(AMCP::DAL::demand_map(void)::s_map + 8 * v5);
  if (!v6 || (v7 = *v6) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v8 = v7[1];
    if (v8 == v3)
    {
      break;
    }

    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *(&AMCP::DAL::demand_map(void)::s_map + 1))
      {
        v8 %= *(&AMCP::DAL::demand_map(void)::s_map + 1);
      }
    }

    else
    {
      v8 &= *(&AMCP::DAL::demand_map(void)::s_map + 1) - 1;
    }

    if (v8 != v5)
    {
      goto LABEL_18;
    }

LABEL_17:
    v7 = *v7;
    if (!v7)
    {
      goto LABEL_18;
    }
  }

  if (*(v7 + 4) != v3)
  {
    goto LABEL_17;
  }

  v9 = *(a2 + 24);
  if (v9)
  {
    if (v9 == a2)
    {
      v16 = &v15;
      (*(*v9 + 24))(v9, &v15);
    }

    else
    {
      v16 = (*(*v9 + 16))(v9);
    }
  }

  else
  {
    v16 = 0;
  }

  v10 = v7 + 3;
  if (v7 + 3 != &v15)
  {
    v11 = v16;
    v12 = v7[6];
    if (v16 == &v15)
    {
      if (v12 == v10)
      {
        (*(*v16 + 24))();
        (*(*v16 + 32))(v16);
        v16 = 0;
        (*(*v7[6] + 24))(v7[6], &v15);
        (*(*v7[6] + 32))(v7[6]);
        v7[6] = 0;
        v16 = &v15;
        (*(v17[0] + 24))(v17, v7 + 3);
        (*(v17[0] + 32))(v17);
      }

      else
      {
        (*(*v16 + 24))();
        (*(*v16 + 32))(v16);
        v16 = v7[6];
      }

      v7[6] = v10;
    }

    else if (v12 == v10)
    {
      (*(*v12 + 24))(v7[6], &v15);
      (*(*v7[6] + 32))(v7[6]);
      v7[6] = v16;
      v16 = &v15;
    }

    else
    {
      v16 = v7[6];
      v7[6] = v11;
    }
  }

  result = std::__function::__value_func<std::shared_ptr<AMCP::DAL::DAL_File_Handler> ()(AMCP::DAL::DAL_Settings const&)>::~__value_func[abi:ne200100](&v15);
  v14 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1DE7489C8(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,std::function<std::shared_ptr<AMCP::DAL::DAL_File_Handler> ()(AMCP::DAL::DAL_Settings const&)>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::function<std::shared_ptr<AMCP::DAL::DAL_File_Handler> ()(AMCP::DAL::DAL_Settings const&)>>,void *>>>>::~unique_ptr[abi:ne200100](uint64_t a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(a1 + 16) == 1)
    {
      std::__function::__value_func<std::shared_ptr<AMCP::DAL::DAL_File_Handler> ()(AMCP::DAL::DAL_Settings const&)>::~__value_func[abi:ne200100](v2 + 24);
    }

    operator delete(v2);
  }

  return a1;
}

void AMCP::DAL::create_timestamp_data(AMCP::DAL *this, const AMCP::DAL::DAL_Time *a2, const AMCP::DAL::DAL_Timed_Segment *a3, std::__shared_weak_count *a4)
{
  v55 = *MEMORY[0x1E69E9840];
  if (a4)
  {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*a3 + 40))(v18, a3);
  sample_time = AMCP::DAL::DAL_Time::get_sample_time(a2);
  std::string::basic_string[abi:ne200100]<0>(v19, "current sample");
  v22 = 0;
  v23 = 0;
  v20 = vcvtmd_s64_f64(sample_time);
  v21 = 0;
  v24 = AMCP::Implementation::In_Place_Storage<unsigned long long>::dispatch;
  host_time = AMCP::DAL::DAL_Time::get_host_time(a2);
  std::string::basic_string[abi:ne200100]<0>(v25, "current host");
  v28 = 0;
  v29 = 0;
  v26 = host_time;
  v27 = 0;
  v30 = AMCP::Implementation::In_Place_Storage<unsigned long long>::dispatch;
  v10 = (*(*a3 + 160))(a3);
  std::string::basic_string[abi:ne200100]<0>(v31, "IO rate scalar");
  v33 = 0;
  v34 = 0;
  v32 = v10;
  v35 = 0;
  v36 = AMCP::Implementation::In_Place_Storage<double>::dispatch;
  v11 = v18[1];
  std::string::basic_string[abi:ne200100]<0>(v37, "zts host");
  v40 = 0;
  v41 = 0;
  v38 = v11;
  v39 = 0;
  v42 = AMCP::Implementation::In_Place_Storage<unsigned long long>::dispatch;
  v12 = *v18;
  std::string::basic_string[abi:ne200100]<0>(v43, "zts sample");
  v46 = 0;
  v47 = 0;
  v44 = v12;
  v45 = 0;
  v48 = AMCP::Implementation::In_Place_Storage<long long>::dispatch;
  std::string::basic_string[abi:ne200100]<0>(v49, "zts rate scalar");
  v51 = 0;
  v52 = 0;
  v50 = v18[2];
  v53 = 0;
  v54 = AMCP::Implementation::In_Place_Storage<double>::dispatch;
  v17[0] = v19;
  v17[1] = 6;
  AMCP::DAL::DAL_Settings::DAL_Settings(this, v17);
  v13 = 48;
  do
  {
    v14 = &v19[v13 * 8];
    v15 = v18[v13 + 7];
    if (v15)
    {
      v15(0, v14 - 5, 0, 0);
    }

    if (*(v14 - 41) < 0)
    {
      operator delete(*(v14 - 8));
    }

    v13 -= 8;
  }

  while (v13 * 8);
  if (a4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a4);
  }

  v16 = *MEMORY[0x1E69E9840];
}

void sub_1DE748CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, uint64_t a60)
{
  v62 = &a60;
  v63 = -384;
  do
  {
    v62 = (std::pair<std::string,AMCP::Thing>::~pair(v62) - 64);
    v63 += 64;
  }

  while (v63);
  if (v60)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v60);
  }

  _Unwind_Resume(a1);
}

void AMCP::DAL::generate_time_stamp(AMCP::DAL *this)
{
  v3 = time(0);
  v2 = localtime(&v3);
  caulk::make_string("%04d%02d%02d.%02d%02d%02d", this, v2->tm_year, v2->tm_mon, v2->tm_mday, v2->tm_hour, v2->tm_min, v2->tm_sec);
}

float AMCP::DAL::DAL_Volume_Processor::set_ramp(uint64_t a1, float a2, double a3, double a4)
{
  v4 = fmaxf(fminf(a2, 1.0), 0.0);
  *(a1 + 52) = v4;
  *(a1 + 56) = a3;
  if (round(a4) == 0.0)
  {
    v5 = *(a1 + 40);
  }

  else
  {
    v5 = *a1;
    if (a4 < *a1)
    {
      v5 = a4;
    }
  }

  *(a1 + 64) = v5;
  v6 = (v4 - *(a1 + 48)) / v5;
  v7 = ceil(v6 * 1000000.0);
  v8 = floor(v6 * 1000000.0);
  if (v6 <= 0.0)
  {
    v9 = v8;
  }

  else
  {
    v9 = v7;
  }

  result = v9 / 1000000.0;
  *(a1 + 72) = result;
  return result;
}

HALS_IODevice *HALS_IOContextDescription_HostedDSP::LocalEngineStreamInfo::getDeviceFromEngine(HALS_IODevice *this)
{
  if (this)
  {
    this = *(this + 11);
    if (this)
    {
      this = (*(*this + 336))(this);
      if (this)
      {
        v1 = this;
        if (HALS_IODevice::GetNumberStreams(this, 1))
        {
          return v1;
        }

        else
        {
          return 0;
        }
      }
    }
  }

  return this;
}

uint64_t HALS_IOContextDescription_HostedDSP::IsHostingInputDSP(void *a1, uint64_t a2, void *a3)
{
  if (!a2)
  {
    return 0;
  }

  __p = 0;
  p_p = &__p;
  v35 = 0x4002000000;
  v36 = __Block_byref_object_copy__300;
  v39 = 0;
  v40 = 0;
  v37 = __Block_byref_object_dispose__301;
  v38 = &v39;
  v26 = MEMORY[0x1E69E9820];
  v27 = 0x40000000;
  v28 = ___ZNK11HALS_Device20GetDSPTypesForClientEbP11HALS_Client_block_invoke;
  v29 = &unk_1E8679340;
  v30 = &__p;
  v31[0] = a2;
  v32 = 1;
  v31[1] = a3;
  v6 = (*(*a2 + 64))(a2);
  HALB_CommandGate::ExecuteCommand(v6, &v26);
  std::set<DSP_Host_Types::AudioProcessingType>::set[abi:ne200100](&v24, (p_p + 40));
  _Block_object_dispose(&__p, 8);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v39);
  v26 = 0;
  v27 = &v26;
  v28 = 0x3002000000;
  v29 = __Block_byref_object_copy__296;
  v30 = __Block_byref_object_dispose__297;
  v31[0] = 0;
  __p = MEMORY[0x1E69E9820];
  p_p = 0x40000000;
  v35 = ___ZNK11HALS_Device31RationalizeDSPOffloadsForClientEbP11HALS_Client_block_invoke;
  v36 = &unk_1E86792F0;
  v37 = &v26;
  v38 = a2;
  LOBYTE(v40) = 1;
  v39 = a3;
  v7 = (*(*a2 + 64))(a2);
  HALB_CommandGate::ExecuteCommand(v7, &__p);
  v8 = *(v27 + 40);
  *(v27 + 40) = 0;
  _Block_object_dispose(&v26, 8);
  std::unique_ptr<DSP_Host_OffloadDictionary>::reset[abi:ne200100](v31, 0);
  if (v8)
  {
    v9 = *(v8 + 16);
    if (v9)
    {
      if (CFDictionaryGetCount(v9))
      {
        LODWORD(__p) = 8;
        std::__tree<DSP_Host_Types::AudioProcessingType>::__emplace_unique_key_args<DSP_Host_Types::AudioProcessingType,DSP_Host_Types::AudioProcessingType>(&v24, 8u);
      }
    }
  }

  (*(*a2 + 952))(&v26, a2, 1, a3);
  if (v26)
  {
    operator new();
  }

  if (!v25[1] || (v13 = *a1, v12 = a1 + 1, v11 = v13, v13 == v12))
  {
LABEL_26:
    v10 = 0;
  }

  else
  {
    while (1)
    {
      if (v25[0])
      {
        v14 = *(v11 + 7);
        v15 = v25;
        v16 = v25[0];
        do
        {
          v17 = v16;
          v18 = v15;
          v19 = *(v16 + 7);
          if (v19 >= v14)
          {
            v15 = v16;
          }

          v16 = v16[v19 < v14];
        }

        while (v16);
        if (v15 != v25)
        {
          if (v19 < v14)
          {
            v17 = v18;
          }

          if (v14 >= *(v17 + 7))
          {
            break;
          }
        }
      }

      v20 = v11[1];
      if (v20)
      {
        do
        {
          v21 = v20;
          v20 = *v20;
        }

        while (v20);
      }

      else
      {
        do
        {
          v21 = v11[2];
          v22 = *v21 == v11;
          v11 = v21;
        }

        while (!v22);
      }

      v11 = v21;
      if (v21 == v12)
      {
        goto LABEL_26;
      }
    }

    v10 = 1;
  }

  v26 = 0;
  if (v8)
  {
    std::default_delete<DSP_Host_OffloadDictionary>::operator()[abi:ne200100](v8);
  }

  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(v25[0]);
  return v10;
}

void sub_1DE74927C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30)
{
  std::default_delete<DSP_Host_OffloadDictionary>::operator()[abi:ne200100](v30);
  std::__tree<DSP_Host_Types::AudioProcessingType>::destroy(a11);
  _Unwind_Resume(a1);
}

void std::vector<HALS_IOContextDescription_HostedDSP::LocalEngineStreamInfo>::push_back[abi:ne200100](uint64_t a1, _OWORD *a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (v4 >= v3)
  {
    v6 = *a1;
    v7 = v4 - *a1;
    v8 = v7 >> 4;
    v9 = (v7 >> 4) + 1;
    if (v9 >> 60)
    {
      std::vector<void *>::__throw_length_error[abi:ne200100]();
    }

    v10 = v3 - v6;
    if (v10 >> 3 > v9)
    {
      v9 = v10 >> 3;
    }

    if (v10 >= 0x7FFFFFFFFFFFFFF0)
    {
      v11 = 0xFFFFFFFFFFFFFFFLL;
    }

    else
    {
      v11 = v9;
    }

    if (v11)
    {
      if (!(v11 >> 60))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    v12 = (16 * v8);
    *v12 = *a2;
    v5 = 16 * v8 + 16;
    v13 = &v12[-(v7 >> 4)];
    memcpy(v13, v6, v7);
    *a1 = v13;
    *(a1 + 8) = v5;
    *(a1 + 16) = 0;
    if (v6)
    {
      operator delete(v6);
    }
  }

  else
  {
    *v4 = *a2;
    v5 = (v4 + 1);
  }

  *(a1 + 8) = v5;
}

uint64_t *AMCP::DAL::PCM_File_Writer::close_file(AMCP::DAL::PCM_File_Writer *this)
{
  result = *(this + 6);
  if (result)
  {
    result = ExtAudioFileDispose(result);
  }

  if (*(this + 160) == 1)
  {
    result = std::unique_ptr<AMCP::DAL::Timestamp_Writer>::reset[abi:ne200100](this + 21, 0);
  }

  *(this + 6) = 0;
  return result;
}

uint64_t *std::unique_ptr<AMCP::DAL::Timestamp_Writer>::reset[abi:ne200100](uint64_t *result, uint64_t a2)
{
  v5 = *MEMORY[0x1E69E9840];
  v2 = *result;
  *result = a2;
  if (v2)
  {
    if (*(v2 + 24) != *(v2 + 32))
    {
      operator new();
    }

    std::vector<AMCP::DAL::Timestamp_Writer::Timestamp_Data,caulk::rt_allocator<AMCP::DAL::Timestamp_Writer::Timestamp_Data>>::__destroy_vector::operator()[abi:ne200100]((v2 + 24));
    if (*(v2 + 23) < 0)
    {
      operator delete(*v2);
    }

    v4 = *MEMORY[0x1E69E9840];

    JUMPOUT(0x1E12C1730);
  }

  v3 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1DE7498A4(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  __clang_call_terminate(exception_object);
}

caulk::rt_safe_memory_resource *AMCP::DAL::PCM_File_Writer::write_data(uint64_t a1, void *a2, uint64_t a3)
{
  v105 = *MEMORY[0x1E69E9840];
  AMCP::DAL::DAL_Timed_Segment::get_audio_buffer_lists(v87, a3);
  AMCP::DAL::DAL_Timed_Segment::translate_range(&v85, *(a3 + 80), a3);
  v6 = v85;
  if (v86 != v85)
  {
    v7 = 0;
    do
    {
      v8 = &v6[12 * v7 + 2];
      sample_time = AMCP::DAL::DAL_Time::get_sample_time(v8);
      v11 = AMCP::DAL::DAL_Time::get_sample_time((v8 + 40));
      v12 = *(a1 + 80);
      v13 = round(v12);
      v14 = round(sample_time);
      v15 = round(v11);
      if (v13 != 0.0 && v14 < v15 && v13 < v14)
      {
        v18 = sample_time - v12;
        if (round(v18) >= round(*(a1 + 8) * 5.0))
        {
          v19 = *(a1 + 8) * 5.0;
        }

        else
        {
          v19 = v18;
        }

        if (round(v19) <= 0.0)
        {
          v72 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v72 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v10);
          }

          v74 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v73 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v73)
          {
            atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
            v75 = *v74;
            std::__shared_weak_count::__release_shared[abi:ne200100](v73);
          }

          else
          {
            v75 = *v74;
          }

          if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
          {
            *buf = 136315650;
            *&buf[4] = "PCM_File_Writer.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 152;
            *&buf[18] = 2080;
            *&buf[20] = "not (num_samples > 0_S)";
            _os_log_error_impl(&dword_1DE1F9000, v75, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
          }

          AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v88);
          __cxa_allocate_exception(0x40uLL);
          caulk::make_string("", &v92);
          std::logic_error::logic_error(&v91, &v92);
          v91.__r_.__value_.__r.__words[0] = MEMORY[0x1E69E55A8] + 16;
          std::logic_error::logic_error(&v94, &v91);
          v96 = 0;
          v97 = 0;
          v98 = 0;
          v99 = -1;
          v94.__vftable = &unk_1F5991430;
          v95 = &unk_1F5991458;
          boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v94);
          *&buf[32] = "void AMCP::DAL::PCM_File_Writer::write_silence_for_skipped_range(Sample_Time) const";
          v103 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/DAL/PCM_File_Writer.cpp";
          v104 = 152;
          applesauce::backtrace::snapshot_N<64>::snapshot_N(&v93);
        }

        if ((*(a1 + 20) & 0x20) != 0)
        {
          v20 = *(a1 + 36);
        }

        else
        {
          v20 = 1;
        }

        v21 = AMCP::Utility::AudioBufferList_Create(v20);
        *buf = &unk_1F59915B8;
        *&buf[24] = buf;
        v100 = v21;
        std::__function::__value_func<void ()(AudioBufferList *)>::__value_func[abi:ne200100](v101, buf);
        v22 = std::__function::__value_func<void ()(AudioBufferList *)>::~__value_func[abi:ne200100](buf);
        v23 = vcvtmd_s64_f64(v19);
        v24 = *(a1 + 32) * v23;
        if (!v24)
        {
          v76 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v76 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v22);
          }

          v78 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v77 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v77)
          {
            atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
            v79 = *v78;
            std::__shared_weak_count::__release_shared[abi:ne200100](v77);
          }

          else
          {
            v79 = *v78;
          }

          if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
          {
            *buf = 136315650;
            *&buf[4] = "PCM_File_Writer.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 158;
            *&buf[18] = 2080;
            *&buf[20] = "not (data_byte_size > 0)";
            _os_log_error_impl(&dword_1DE1F9000, v79, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s ", buf, 0x1Cu);
          }

          AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v89);
          __cxa_allocate_exception(0x40uLL);
          caulk::make_string("", &v93);
          std::logic_error::logic_error(&v88, &v93);
          v88.__vftable = (MEMORY[0x1E69E55A8] + 16);
          std::logic_error::logic_error(&v94, &v88);
          v96 = 0;
          v97 = 0;
          v98 = 0;
          v99 = -1;
          v94.__vftable = &unk_1F5991430;
          v95 = &unk_1F5991458;
          boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v94);
          *&buf[32] = "void AMCP::DAL::PCM_File_Writer::write_silence_for_skipped_range(Sample_Time) const";
          v103 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/DAL/PCM_File_Writer.cpp";
          v104 = 158;
          applesauce::backtrace::snapshot_N<64>::snapshot_N(&v91);
        }

        if (!*MEMORY[0x1E69E3C08])
        {
          __break(1u);
        }

        v25 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
        v93.__r_.__value_.__r.__words[0] = v25;
        v93.__r_.__value_.__r.__words[2] = v25 + v24;
        bzero(v25, v24);
        v26 = 0;
        v93.__r_.__value_.__l.__size_ = v25 + v24;
        v27 = *(a1 + 20);
        v28 = v100;
        v29 = v100 + 2;
        if ((v27 & 0x20) != 0)
        {
LABEL_21:
          if (v26 < *(a1 + 36))
          {
            v30 = 1;
            goto LABEL_25;
          }
        }

        else
        {
          while (!v26)
          {
            v30 = *(a1 + 36);
LABEL_25:
            *(v29 - 2) = v30;
            *(v29 - 1) = v24;
            ++v26;
            *v29 = v25;
            v29 += 2;
            if ((v27 & 0x20) != 0)
            {
              goto LABEL_21;
            }
          }
        }

        v31 = ExtAudioFileWriteAsync(*(a1 + 48), v23, v28);
        v32 = v31;
        v33 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if (v31)
        {
          if ((v33 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v31);
          }

          v81 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v80 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v80)
          {
            atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
            v82 = *v81;
            std::__shared_weak_count::__release_shared[abi:ne200100](v80);
          }

          else
          {
            v82 = *v81;
          }

          if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
          {
            v83 = (a1 + 88);
            if (*(a1 + 111) < 0)
            {
              v83 = *v83;
            }

            *buf = 136316162;
            *&buf[4] = "PCM_File_Writer.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 170;
            *&buf[18] = 2080;
            *&buf[20] = "not (the_error == 0)";
            *&buf[28] = 2080;
            *&buf[30] = v83;
            *&buf[38] = 2048;
            v103 = v32;
            _os_log_error_impl(&dword_1DE1F9000, v82, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s PCM_File_Writer::Write: couldn't write the data %s: %ld", buf, 0x30u);
          }

          AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v90);
          __cxa_allocate_exception(0x40uLL);
          v84 = (a1 + 88);
          if (*(a1 + 111) < 0)
          {
            v84 = *v84;
          }

          caulk::make_string("PCM_File_Writer::Write: couldn't write the data %s: %ld", &v91, v84, v32);
          std::logic_error::logic_error(&v89, &v91);
          v89.__vftable = (MEMORY[0x1E69E55A8] + 16);
          std::logic_error::logic_error(&v94, &v89);
          v96 = 0;
          v97 = 0;
          v98 = 0;
          v99 = -1;
          v94.__vftable = &unk_1F5991430;
          v95 = &unk_1F5991458;
          boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v94);
          *&buf[32] = "void AMCP::DAL::PCM_File_Writer::write_silence_for_skipped_range(Sample_Time) const";
          v103 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/DAL/PCM_File_Writer.cpp";
          v104 = 170;
          applesauce::backtrace::snapshot_N<64>::snapshot_N(&v88);
        }

        if ((v33 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(v31);
        }

        v35 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v34 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v34)
        {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
          v36 = *v35;
          std::__shared_weak_count::__release_shared[abi:ne200100](v34);
        }

        else
        {
          v36 = *v35;
        }

        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        {
          *buf = 136315650;
          *&buf[4] = "PCM_File_Writer.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 171;
          *&buf[18] = 1024;
          *&buf[20] = v23;
          _os_log_debug_impl(&dword_1DE1F9000, v36, OS_LOG_TYPE_DEBUG, "%32s:%-5d write_silence_for_skipped_range: %ul", buf, 0x18u);
        }

        std::vector<char,caulk::rt_allocator<char>>::__destroy_vector::operator()[abi:ne200100](&v93);
        std::unique_ptr<AudioBufferList,std::function<void ()(AudioBufferList*)>>::reset[abi:ne200100](&v100, 0);
        std::__function::__value_func<void ()(AudioBufferList *)>::~__value_func[abi:ne200100](v101);
      }

      v37 = ExtAudioFileWriteAsync(*(a1 + 48), vcvtmd_s64_f64(v11 - sample_time), *(v87[0] + 40 * v7));
      v38 = v37;
      if (v37)
      {
        v66 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v66 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(v37);
        }

        v68 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v67 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v67)
        {
          atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
          v69 = *v68;
          std::__shared_weak_count::__release_shared[abi:ne200100](v67);
        }

        else
        {
          v69 = *v68;
        }

        if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
        {
          v70 = (a1 + 88);
          if (*(a1 + 111) < 0)
          {
            v70 = *v70;
          }

          *buf = 136316162;
          *&buf[4] = "PCM_File_Writer.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 179;
          *&buf[18] = 2080;
          *&buf[20] = "not (the_error == 0)";
          *&buf[28] = 2080;
          *&buf[30] = v70;
          *&buf[38] = 2048;
          v103 = v38;
          _os_log_error_impl(&dword_1DE1F9000, v69, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s PCM_File_Writer::Write: couldn't write the data %s: %ld", buf, 0x30u);
        }

        AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v88);
        __cxa_allocate_exception(0x40uLL);
        v71 = (a1 + 88);
        if (*(a1 + 111) < 0)
        {
          v71 = *v71;
        }

        caulk::make_string("PCM_File_Writer::Write: couldn't write the data %s: %ld", &v92, v71, v38);
        std::logic_error::logic_error(&v91, &v92);
        v91.__r_.__value_.__r.__words[0] = MEMORY[0x1E69E55A8] + 16;
        std::logic_error::logic_error(&v94, &v91);
        v96 = 0;
        v97 = 0;
        v98 = 0;
        v99 = -1;
        v94.__vftable = &unk_1F5991430;
        v95 = &unk_1F5991458;
        boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::domain_error>>::clone_impl(buf, &v94);
        *&buf[32] = "void AMCP::DAL::PCM_File_Writer::_write_data(uint32_t, const BufferListPtr &) const";
        v103 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/IO/DAL/PCM_File_Writer.cpp";
        v104 = 179;
        applesauce::backtrace::snapshot_N<64>::snapshot_N(&v93);
      }

      ++v7;
      v6 = v85;
    }

    while (v7 < 0xAAAAAAAAAAAAAAABLL * ((v86 - v85) >> 5));
  }

  if (*(a1 + 160))
  {
    v39 = *(a1 + 168);
    AMCP::DAL::DAL_Timed_Segment::translate_range(&v100, *(a3 + 80), a3);
    v40 = v101[0];
    if (v100 != v101[0])
    {
      v41 = v39 + 3;
      v42 = (v100 + 7);
      do
      {
        std::string::basic_string[abi:ne200100]<0>(buf, "current sample");
        v43 = std::__hash_table<std::__hash_value_type<std::string,AMCP::Thing>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AMCP::Thing>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AMCP::Thing>,std::equal_to<std::string>,std::hash<std::string>,true>,std::pmr::polymorphic_allocator<std::__hash_value_type<std::string,AMCP::Thing>>>::find<std::string>(a2, buf);
        v44 = v43;
        if ((buf[23] & 0x80000000) != 0)
        {
          operator delete(*buf);
          if (!v44)
          {
LABEL_48:
            if (v39[3] != v39[4])
            {
              v52 = AMCP::DAL::DAL_Time::get_sample_time((v42 - 40));
              *(v39[4] - 40) += vcvtmd_s64_f64(AMCP::DAL::DAL_Time::get_sample_time(v42) - v52);
            }

            goto LABEL_62;
          }
        }

        else if (!v43)
        {
          goto LABEL_48;
        }

        v45 = AMCP::DAL::DAL_Time::get_sample_time((v42 - 40));
        v46 = AMCP::DAL::DAL_Time::get_sample_time(v42);
        v94 = *(v42 - 40);
        v95 = *(v42 - 3);
        v96 = *(v42 - 2);
        v47 = *(v42 - 1);
        v97 = v47;
        if (v47)
        {
          atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        host_time = AMCP::DAL::DAL_Time::get_host_time(&v94);
        v50 = v39[4];
        v49 = v39[5];
        if (v50 >= v49)
        {
          v53 = 0x8E38E38E38E38E39 * ((v50 - *v41) >> 3);
          v54 = v53 + 1;
          if (v53 + 1 > 0x38E38E38E38E38ELL)
          {
            std::vector<void *>::__throw_length_error[abi:ne200100]();
          }

          v55 = 0x8E38E38E38E38E39 * ((v49 - *v41) >> 3);
          if (2 * v55 > v54)
          {
            v54 = 2 * v55;
          }

          if (v55 >= 0x1C71C71C71C71C7)
          {
            v56 = 0x38E38E38E38E38ELL;
          }

          else
          {
            v56 = v54;
          }

          *&buf[32] = v39 + 3;
          if (v56)
          {
            v56 = std::allocator_traits<caulk::rt_allocator<AMCP::DAL::Timestamp_Writer::Timestamp_Data>>::allocate_at_least[abi:ne200100]<caulk::rt_allocator<AMCP::DAL::Timestamp_Writer::Timestamp_Data>>(v56);
          }

          else
          {
            v57 = 0;
          }

          *buf = v56;
          *&buf[8] = v56 + 72 * v53;
          *&buf[16] = *&buf[8];
          *&buf[24] = v56 + 72 * v57;
          AMCP::DAL::Timestamp_Writer::Timestamp_Data::Timestamp_Data(*&buf[8], host_time, a2, v45, v46);
          v51 = *&buf[16] + 72;
          v58 = v39[3];
          v59 = v39[4] - v58;
          v60 = *&buf[8] - v59;
          memcpy((*&buf[8] - v59), v58, v59);
          v61 = v39[3];
          v39[3] = v60;
          v39[4] = v51;
          v62 = v39[5];
          v39[5] = *&buf[24];
          *&buf[16] = v61;
          *&buf[24] = v62;
          *buf = v61;
          *&buf[8] = v61;
          std::__split_buffer<AMCP::DAL::Timestamp_Writer::Timestamp_Data,caulk::rt_allocator<AMCP::DAL::Timestamp_Writer::Timestamp_Data> &>::~__split_buffer(buf);
        }

        else
        {
          AMCP::DAL::Timestamp_Writer::Timestamp_Data::Timestamp_Data(v39[4], host_time, a2, v45, v46);
          v51 = v50 + 72;
        }

        v39[4] = v51;
        if (v97)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v97);
        }

LABEL_62:
        v63 = v42 + 40;
        v42 = (v42 + 96);
      }

      while (v63 != v40);
    }

    *buf = &v100;
    std::vector<AMCP::DAL::Buffer_Time_Translator::Translation_Range,caulk::rt_allocator<AMCP::DAL::Buffer_Time_Translator::Translation_Range>>::__destroy_vector::operator()[abi:ne200100](buf);
  }

  *buf = &v85;
  std::vector<AMCP::DAL::Buffer_Time_Translator::Translation_Range,caulk::rt_allocator<AMCP::DAL::Buffer_Time_Translator::Translation_Range>>::__destroy_vector::operator()[abi:ne200100](buf);
  *buf = v87;
  result = std::vector<std::unique_ptr<AudioBufferList,std::function<void ()(AudioBufferList*)>>,caulk::rt_allocator<std::unique_ptr<AudioBufferList,std::function<void ()(AudioBufferList*)>>>>::__destroy_vector::operator()[abi:ne200100](buf);
  v65 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1DE74A864(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, void *a37, void *__p, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, int a43, __int16 a44, char a45, char a46, uint64_t a47, char a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1DE749F24);
  }

  _Unwind_Resume(exception_object);
}

void AMCP::DAL::PCM_File_Writer::~PCM_File_Writer(AMCP::DAL::PCM_File_Writer *this)
{
  AMCP::DAL::PCM_File_Writer::~PCM_File_Writer(this);

  JUMPOUT(0x1E12C1730);
}

{
  *this = &unk_1F5991228;
  v2 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
  if ((v2 & 1) == 0)
  {
    AMCP::Log::AMCP_Scope_Registry::initialize(this);
  }

  v4 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v3 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    v5 = *v4;
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  else
  {
    v5 = *v4;
  }

  v6 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
  if ((v6 & 1) == 0)
  {
    AMCP::Log::AMCP_Scope_Registry::initialize(v3);
  }

  v7 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v8 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    v9 = os_signpost_id_make_with_pointer(*v7, this);
    std::__shared_weak_count::__release_shared[abi:ne200100](v8);
  }

  else
  {
    v9 = os_signpost_id_make_with_pointer(*v7, this);
  }

  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    *v10 = 0;
    _os_signpost_emit_with_name_impl(&dword_1DE1F9000, v5, OS_SIGNPOST_INTERVAL_END, v9, "AudioHAL Capture", &unk_1DE836302, v10, 2u);
  }

  AMCP::DAL::PCM_File_Writer::close_file(this);
  std::unique_ptr<AMCP::DAL::Timestamp_Writer>::reset[abi:ne200100](this + 21, 0);
  if (*(this + 159) < 0)
  {
    operator delete(*(this + 17));
  }

  if (*(this + 135) < 0)
  {
    operator delete(*(this + 14));
  }

  if (*(this + 111) < 0)
  {
    operator delete(*(this + 11));
  }

  *this = &unk_1F5991568;
  if (*(this + 79) < 0)
  {
    operator delete(*(this + 7));
  }
}

uint64_t HALS_PlugInEngine::_WriteToStream_Write(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v7 = *(a1 + 1136);
  v8 = *(v7 + 416);
  v9 = *(v7 + 424);
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v10 = (*(*v8 + 528))(v8, *(a1 + 1144), *(a3 + 16), a2, a5, a4, a6);
  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v9);
  }

  return v10;
}

void sub_1DE74ADE0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_WriteToStream_ConvertFromTempBuffer(uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(a1 + 1160) == 1)
  {
    v14 = a4[10];
    v15 = a4[12];
    v16 = a4[13];
    v43 = a4[11];
    v44 = v15;
    v45 = v16;
    v17 = a4[6];
    v18 = a4[8];
    v19 = a4[9];
    v40[7] = a4[7];
    v40[8] = v18;
    v41 = v19;
    v42 = v14;
    v20 = a4[3];
    v40[2] = a4[2];
    v40[3] = v20;
    v21 = a4[5];
    v40[4] = a4[4];
    v40[5] = v21;
    v40[6] = v17;
    v22 = *a4;
    v23 = a4[1];
    if (*a8)
    {
      v24 = (*a8 + *(a8 + 8));
    }

    else
    {
      v24 = 0;
    }

    if (*a5)
    {
      v25 = (*a5 + *(a5 + 8));
    }

    else
    {
      v25 = 0;
    }

    v26 = *a6;
    v27 = (*a6 + *(a6 + 8));
    v40[0] = *a4;
    v40[1] = v23;
    if (v26)
    {
      v28 = v27;
    }

    else
    {
      v28 = 0;
    }

    if (*(a1 + 1161) == 1)
    {
      if (v25)
      {
        v29 = *(a5 + 12);
        memcpy(v24, v25, v29);
        if (!v28)
        {
LABEL_15:
          v30 = *(a1 + 1136);
          v31 = *(v30 + 416);
          v32 = *(v30 + 424);
          if (v32)
          {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          v33 = *(a1 + 1144);
          v34 = *(a3 + 16);
          (*(*v31 + 496))();
LABEL_30:
          if (v32)
          {
            std::__shared_weak_count::__release_shared[abi:ne200100](v32);
          }

          return;
        }
      }

      else
      {
        v29 = 0;
        if (!v28)
        {
          goto LABEL_15;
        }
      }

      memcpy(&v24[v29], v28, *(a6 + 12));
      goto LABEL_15;
    }

    if (v25)
    {
      v35 = *(a1 + 1136);
      v36 = *(v35 + 416);
      v37 = *(v35 + 424);
      if (v37)
      {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      (*(*v36 + 496))(v36, *(a1 + 1144), *(a3 + 16), a2, *(a5 + 16), v40, a5, a8, v22);
      if (v37)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v37);
      }
    }

    if (v28)
    {
      v22.n128_u32[0] = *(a5 + 16);
      v41.n128_f64[0] = v41.n128_f64[0] + v22.n128_u64[0];
      v38 = *(a1 + 1136);
      v39 = *(v38 + 416);
      v32 = *(v38 + 424);
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      (*(*v39 + 496))(v39, *(a1 + 1144), *(a3 + 16), a2, *(a6 + 16), v40, a6, a8);
      goto LABEL_30;
    }
  }

  else
  {

    HALS_IOEngine2::_WriteToStream_ConvertFromTempBuffer(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1DE74B0CC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_WriteToStream_ProcessMix(HALS_PlugInEngine *this, uint64_t a2, HALS_IOEngine2_StreamInfo *a3, const AudioServerPlugInIOCycleInfo *a4, unsigned int a5)
{
  if (*(this + 1158) != 1)
  {
    return;
  }

  v8 = *&a4->mOutputTime.mSMPTETime.mSubframes;
  v48 = *&a4->mOutputTime.mRateScalar;
  v49 = v8;
  v9 = *&a4->mMainHostTicksPerFrame;
  v50 = *&a4->mOutputTime.mSMPTETime.mHours;
  v51 = v9;
  v10 = *&a4->mInputTime.mSMPTETime.mSubframes;
  v46[6] = *&a4->mInputTime.mRateScalar;
  v46[7] = v10;
  v11 = *&a4->mOutputTime.mSampleTime;
  v46[8] = *&a4->mInputTime.mSMPTETime.mHours;
  v47 = v11;
  v12 = *&a4->mCurrentTime.mSMPTETime.mSubframes;
  v46[2] = *&a4->mCurrentTime.mRateScalar;
  v46[3] = v12;
  v13 = *&a4->mInputTime.mSampleTime;
  v46[4] = *&a4->mCurrentTime.mSMPTETime.mHours;
  v46[5] = v13;
  v14 = *&a4->mCurrentTime.mSampleTime;
  v46[0] = *&a4->mIOCycleCounter;
  v46[1] = v14;
  HALS_IOEngine2_StreamInfo::GetPointersForMixBuffer(&v38, a3, *&v47, a5);
  if (v38)
  {
    v16 = (v38 + v39);
  }

  else
  {
    v16 = 0;
  }

  if (v42)
  {
    v17 = (v42 + v43);
  }

  else
  {
    v17 = 0;
  }

  if (*(this + 1159) == 1)
  {
    if (v16)
    {
      v18 = *(this + 142);
      v19 = *(v18 + 416);
      v20 = *(v18 + 424);
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v21 = *(this + 286);
      v22 = *(a3 + 4);
      v36 = 0;
      v37 = 0uLL;
      (*(*v19 + 464))();
      if (v20)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v20);
      }
    }

    if (v17)
    {
      LODWORD(v15) = __n_4;
      *&v47 = *&v47 + v15;
      v23 = *(this + 142);
      v24 = *(v23 + 416);
      v25 = *(v23 + 424);
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v26 = *(this + 286);
      v27 = *(a3 + 4);
      v36 = 0;
      v37 = 0uLL;
      (*(*v24 + 464))();
      if (v25)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v25);
      }
    }

    return;
  }

  v28 = *(this + 102);
  if (v28)
  {
    v29 = *v28;
    v36 = *v28;
    LODWORD(v37) = 0;
    v15 = vmovn_s64(*(v28 + 8));
    *(&v37 + 4) = v15;
    if (!v16)
    {
      goto LABEL_21;
    }
  }

  else
  {
    v29 = 0;
    v36 = 0;
    *&v37 = 0;
    DWORD2(v37) = 0;
    if (!v16)
    {
LABEL_21:
      if (!v17)
      {
        return;
      }

      goto LABEL_29;
    }
  }

  v30 = *(this + 142);
  v31 = *(v30 + 416);
  v32 = *(v30 + 424);
  if (v32)
  {
    atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v31 + 464))(v31, *(this + 286), *(a3 + 4), a2, __n_4, v46, &v38, &v36);
  if (v32)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v32);
  }

  memcpy(v16, v29, __n);
  if (v17)
  {
LABEL_29:
    LODWORD(v15) = __n_4;
    *&v47 = *&v47 + v15;
    v33 = *(this + 142);
    v34 = *(v33 + 416);
    v35 = *(v33 + 424);
    if (v35)
    {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v34 + 464))(v34, *(this + 286), *(a3 + 4), a2, v45, v46, &v42, &v36);
    if (v35)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v35);
    }

    memcpy(v17, v29, v44);
  }
}

void sub_1DE74B440(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_WriteToStream_ProcessClient(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  if (*(a1 + 1155) == 1)
  {
    v10 = *(a1 + 1156);
    v11 = *(a1 + 1136);
    v12 = *(v11 + 416);
    v13 = *(v11 + 424);
    if (v10 == 1)
    {
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v14 = *(a1 + 1144);
      v15 = *(a3 + 16);
      (*(*v12 + 400))();
    }

    else
    {
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      (*(*v12 + 400))(v12, *(a1 + 1144), *(a3 + 16), a2, a5, a4 + 512, a6, a7);
    }

    if (v13)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v13);
    }

    *a8 = *(a1 + 1156);
  }

  *a8 = 1;
}

void sub_1DE74B5AC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_EndWriting(HALS_PlugInEngine *this, uint64_t a2, uint64_t a3, const HALS_IOEngineInfo *a4)
{
  if ((*(this + 1155) & 1) != 0 || (*(this + 1157) & 1) != 0 || (*(this + 1158) & 1) != 0 || (*(this + 1160) & 1) != 0 || *(this + 1162) == 1)
  {
    v4 = *(this + 142);
    v5 = *(v4 + 416);
    v6 = *(v4 + 424);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v5 + 536))(v5, *(this + 286), a2, a3, a4 + 512);
    if (v6)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v6);
    }
  }

  return 0;
}

void sub_1DE74B67C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_WriteToStream(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, void *a6, int a7)
{
  if ((*(a1 + 1155) & 1) != 0 || (*(a1 + 1158) & 1) != 0 || (*(a1 + 1160) & 1) != 0 || *(a1 + 1162) == 1)
  {
    v8 = HALS_IOEngine2::_WriteToStream(a1, a2, a3, a4, a5, a6);
  }

  else if (*(a1 + 1157) == 1)
  {
    v10 = *(*(a1 + 808) + 48);
    v11 = (*(*(a1 + 808) + 56) - v10) >> 3;
    if (v11 <= a3)
    {
      v12 = 0;
    }

    else
    {
      if (v11 <= a3)
      {
        std::vector<std::tuple<unsigned int,void *,unsigned int>>::__throw_out_of_range[abi:ne200100]();
      }

      v12 = *(v10 + 8 * a3);
    }

    v13 = *(a1 + 1136);
    v14 = *(v13 + 416);
    v15 = *(v13 + 424);
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    v8 = (*(*v14 + 432))(v14, *(a1 + 1144), *(v12 + 16), a2, a4, a5 + 512, a6);
    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v15);
    }
  }

  else
  {
    v8 = 0;
  }

  if (a7)
  {
    return 0;
  }

  else
  {
    return v8;
  }
}

void sub_1DE74B7B8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_BeginWriting(HALS_PlugInEngine *this, uint64_t a2, uint64_t a3, const HALS_IOEngineInfo *a4)
{
  if ((*(this + 1155) & 1) != 0 || (*(this + 1157) & 1) != 0 || (*(this + 1158) & 1) != 0 || (*(this + 1160) & 1) != 0 || *(this + 1162) == 1)
  {
    v4 = *(this + 142);
    v5 = *(v4 + 416);
    v6 = *(v4 + 424);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v5 + 520))(v5, *(this + 286), a2, a3, a4 + 512);
    if (v6)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v6);
    }
  }

  return 0;
}

void sub_1DE74B884(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_ReadFromStream_Process(HALS_PlugInEngine *this, uint64_t a2, HALS_IOEngine2_StreamInfo *a3, const AudioServerPlugInIOCycleInfo *a4, unsigned int a5)
{
  if (*(this + 1153) == 1)
  {
    v8 = *&a4->mOutputTime.mSMPTETime.mSubframes;
    v55 = *&a4->mOutputTime.mRateScalar;
    v56 = v8;
    v9 = *&a4->mMainHostTicksPerFrame;
    v57 = *&a4->mOutputTime.mSMPTETime.mHours;
    v58 = v9;
    v10 = *&a4->mInputTime.mSMPTETime.mSubframes;
    v51 = *&a4->mInputTime.mRateScalar;
    v52 = v10;
    v11 = *&a4->mOutputTime.mSampleTime;
    v53 = *&a4->mInputTime.mSMPTETime.mHours;
    v54 = v11;
    v12 = *&a4->mCurrentTime.mSMPTETime.mSubframes;
    v49[2] = *&a4->mCurrentTime.mRateScalar;
    v49[3] = v12;
    v13 = *&a4->mInputTime.mSampleTime;
    v49[4] = *&a4->mCurrentTime.mSMPTETime.mHours;
    v50 = v13;
    v14 = *&a4->mCurrentTime.mSampleTime;
    v49[0] = *&a4->mIOCycleCounter;
    v49[1] = v14;
    HALS_IOEngine2_StreamInfo::GetPointersForMixBuffer(&v41, a3, *&v50, a5);
    v15 = v44;
    if (v41)
    {
      v16 = (v41 + v42);
    }

    else
    {
      v16 = 0;
    }

    v17 = v48;
    if (v45)
    {
      v18 = (v45 + v46);
    }

    else
    {
      v18 = 0;
    }

    if (*(this + 1154) == 1)
    {
      if (v16)
      {
        v19 = *(this + 142);
        v20 = *(v19 + 416);
        v21 = *(v19 + 424);
        if (v21)
        {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        v22 = *(this + 286);
        v23 = *(a3 + 4);
        v39 = 0;
        v40 = 0uLL;
        (*(*v20 + 368))();
        if (v21)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v21);
        }
      }

      if (v18)
      {
        *&v50 = *&v50 + v15;
        v24 = *(this + 142);
        v25 = *(v24 + 416);
        v26 = *(v24 + 424);
        if (v26)
        {
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        v27 = *(this + 286);
        v28 = *(a3 + 4);
        v39 = 0;
        v40 = 0uLL;
        (*(*v25 + 368))();
        if (v26)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v26);
        }
      }
    }

    else
    {
      v29 = *(this + 102);
      if (v29)
      {
        v30 = *v29;
        v39 = *v29;
        LODWORD(v40) = 0;
        *(&v40 + 4) = vmovn_s64(*(v29 + 8));
      }

      else
      {
        v30 = 0;
        v39 = 0;
        *&v40 = 0;
        DWORD2(v40) = 0;
      }

      __n = v47;
      if (v16)
      {
        v31 = v43;
        v32 = *(this + 142);
        v33 = *(v32 + 416);
        v34 = *(v32 + 424);
        if (v34)
        {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        (*(*v33 + 368))(v33, *(this + 286), *(a3 + 4), a2, v15, v49, &v41, &v39, __n);
        if (v34)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v34);
        }

        memcpy(v16, v30, v31);
      }

      if (v18)
      {
        *&v50 = *&v50 + v15;
        v35 = *(this + 142);
        v36 = *(v35 + 416);
        v37 = *(v35 + 424);
        if (v37)
        {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        (*(*v36 + 368))(v36, *(this + 286), *(a3 + 4), a2, v17, v49, &v45, &v39);
        if (v37)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v37);
        }

        memcpy(v18, v30, __n);
      }
    }
  }
}

void sub_1DE74BBF8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_ReadFromStream_ConvertToTempBuffer(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(a1 + 1151) == 1)
  {
    if (*a8)
    {
      v13 = (*a8 + *(a8 + 8));
    }

    else
    {
      v13 = 0;
    }

    if (*a5)
    {
      v14 = (*a5 + *(a5 + 8));
    }

    else
    {
      v14 = 0;
    }

    v15 = *(a5 + 16);
    if (*a6)
    {
      v16 = (*a6 + *(a6 + 8));
    }

    else
    {
      v16 = 0;
    }

    v17 = *(a6 + 16);
    if (*(a1 + 1152) == 1)
    {
      v18 = *(a1 + 1136);
      v19 = *(v18 + 416);
      v20 = *(v18 + 424);
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v21 = *(a1 + 1144);
      v22 = *(a3 + 16);
      v37 = 0uLL;
      *&v38 = 0;
      (*(*v19 + 336))(v19, v21, v22);
      if (v20)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v20);
      }

      if (v14)
      {
        v23 = (*(a3 + 64) * v15);
        memcpy(v14, v13, v23);
        if (!v16)
        {
          return;
        }
      }

      else
      {
        v23 = 0;
        if (!v16)
        {
          return;
        }
      }

      memcpy(v16, &v13[v23], (*(a3 + 64) * v17));
      return;
    }

    v24 = a4[11];
    v47 = a4[10];
    v48 = v24;
    v25 = a4[13];
    v49 = a4[12];
    v50 = v25;
    v26 = a4[7];
    v43 = a4[6];
    v44 = v26;
    v27 = a4[9];
    v45 = a4[8];
    v46 = v27;
    v28 = a4[3];
    v39 = a4[2];
    v40 = v28;
    v29 = a4[5];
    v41 = a4[4];
    v42 = v29;
    v30 = a4[1];
    v37 = *a4;
    v38 = v30;
    if (v14)
    {
      v31 = *(a1 + 1136);
      v32 = *(v31 + 416);
      v33 = *(v31 + 424);
      if (v33)
      {
        atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      (*(*v32 + 336))(v32, *(a1 + 1144), *(a3 + 16), a2, v15, &v37, a5, a8);
      if (v33)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v33);
      }
    }

    if (v16)
    {
      *&v42 = *&v42 + v15;
      v34 = *(a1 + 1136);
      v35 = *(v34 + 416);
      v36 = *(v34 + 424);
      if (v36)
      {
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      (*(*v35 + 336))(v35, *(a1 + 1144), *(a3 + 16), a2, v17, &v37, a6, a8);
      if (v36)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v36);
      }
    }
  }

  else
  {

    HALS_IOEngine2::_ReadFromStream_ConvertToTempBuffer(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1DE74BF18(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_EngineTeardownForIsolatedIO(HALS_PlugInEngine *this, HALS_IOEngine2_StreamInfo *a2, uint64_t a3)
{
  v4 = *(this + 142);
  v5 = *(v4 + 416);
  v6 = *(v4 + 424);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v5 + 296))(v5, *(this + 286), *(a2 + 4), a3);
  if (v6)
  {

    std::__shared_weak_count::__release_shared[abi:ne200100](v6);
  }
}

void sub_1DE74BFDC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_EngineSetupForIsolatedIO(HALS_PlugInEngine *this, HALS_IOEngine2_StreamInfo *a2, uint64_t a3, uint64_t a4)
{
  v5 = *(this + 142);
  v6 = *(v5 + 416);
  v7 = *(v5 + 424);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v6 + 288))(v6, *(this + 286), *(a2 + 4), a3, a4);
  if (v7)
  {

    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }
}

void sub_1DE74C090(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_IsolatedReadFromStream_Read(HALS_PlugInEngine *this, HALS_IOEngine2_StreamInfo *a2, const AudioServerPlugInIOCycleInfo *a3, uint64_t a4, uint64_t a5)
{
  if (*(this + 1150) == 1)
  {
    v6 = *(this + 142);
    v7 = *(v6 + 416);
    v8 = *(v6 + 424);
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v7 + 280))(v7, *(this + 286), *(a2 + 4), a4, a3, a5);
    if (v8)
    {

      std::__shared_weak_count::__release_shared[abi:ne200100](v8);
    }
  }
}

void sub_1DE74C150(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_ReadFromStream_Read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (*(a1 + 1150) == 1)
  {
    v7 = *(a1 + 1136);
    v8 = *(v7 + 416);
    v9 = *(v7 + 424);
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v8 + 272))(v8, *(a1 + 1144), *(a3 + 16), a2, a5, a4, a6);
    if (v9)
    {

      std::__shared_weak_count::__release_shared[abi:ne200100](v9);
    }
  }
}

void sub_1DE74C210(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_EndReading(HALS_PlugInEngine *this, uint64_t a2, uint64_t a3, const HALS_IOEngineInfo *a4)
{
  if ((*(this + 1150) & 1) != 0 || (*(this + 1151) & 1) != 0 || *(this + 1153) == 1)
  {
    v4 = *(this + 142);
    v5 = *(v4 + 416);
    v6 = *(v4 + 424);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v5 + 312))(v5, *(this + 286), a2, a3, a4 + 512);
    if (v6)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v6);
    }
  }

  return 0;
}

void sub_1DE74C2CC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_ReadFromStream(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, HALS_IOClock **a5, uint64_t a6)
{
  if ((*(a1 + 1150) & 1) != 0 || (*(a1 + 1151) & 1) != 0 || *(a1 + 1153) == 1)
  {
    HALS_IOEngine2::_ReadFromStream(a1, a2, a3, a4, a5, a6);
  }

  else
  {
    if (*a6)
    {
      v7 = (*a6 + *(a6 + 8));
    }

    else
    {
      v7 = 0;
    }

    bzero(v7, *(a6 + 12));
  }

  return 0;
}

uint64_t HALS_PlugInEngine::_BeginReading(HALS_PlugInEngine *this, uint64_t a2, uint64_t a3, const HALS_IOEngineInfo *a4)
{
  if ((*(this + 1150) & 1) != 0 || (*(this + 1151) & 1) != 0 || *(this + 1153) == 1)
  {
    v4 = *(this + 142);
    v5 = *(v4 + 416);
    v6 = *(v4 + 424);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v5 + 264))(v5, *(this + 286), a2, a3, a4 + 512);
    if (v6)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v6);
    }
  }

  return 0;
}

void sub_1DE74C3DC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_EndIOCycle(HALS_PlugInEngine *this, uint64_t a2, const HALS_IOEngineInfo *a3)
{
  if (*(this + 1149) == 1)
  {
    v4 = *(this + 142);
    v5 = *(v4 + 416);
    v6 = *(v4 + 424);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v5 + 248))(v5, *(this + 286), a2, a3 + 512);
    if (v6)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v6);
    }
  }

  return 0;
}

void sub_1DE74C47C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_BeginIOCycle(HALS_PlugInEngine *this, uint64_t a2, const HALS_IOEngineInfo *a3)
{
  HALS_IOEngine2::_BeginIOCycle(this, a2, a3);
  if (*(this + 1149) == 1)
  {
    v6 = *(this + 142);
    v7 = *(v6 + 416);
    v8 = *(v6 + 424);
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v7 + 240))(v7, *(this + 286), a2, a3 + 512);
    if (v8)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v8);
    }
  }

  return 0;
}

void sub_1DE74C52C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_FirstIOThreadStarted(HALS_PlugInEngine *this, uint64_t a2, const HALS_IOEngineInfo *a3)
{
  v5 = *(this + 142);
  v6 = *(v5 + 416);
  v7 = *(v5 + 424);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v6 + 208))(v6, *(this + 286), a2, this + 1148);
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }

  v8 = *(this + 142);
  v9 = *(v8 + 416);
  v10 = *(v8 + 424);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v9 + 232))(v9, *(this + 286), a2, this + 1149);
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v10);
  }

  v11 = *(this + 142);
  v12 = *(v11 + 416);
  v13 = *(v11 + 424);
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v12 + 256))(v12, *(this + 286), a2, this + 1150);
  if (v13)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v13);
  }

  v14 = *(this + 142);
  v15 = *(v14 + 416);
  v16 = *(v14 + 424);
  if (v16)
  {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v15 + 320))(v15, *(this + 286), a2, this + 1151, this + 1152);
  if (v16)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v16);
  }

  v17 = *(this + 142);
  v18 = *(v17 + 416);
  v19 = *(v17 + 424);
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v18 + 352))(v18, *(this + 286), a2, this + 1153, this + 1154);
  if (v19)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v19);
  }

  v20 = *(this + 142);
  v21 = *(v20 + 416);
  v22 = *(v20 + 424);
  if (v22)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v21 + 384))(v21, *(this + 286), a2, this + 1155, this + 1156);
  if (v22)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v22);
  }

  v23 = *(this + 142);
  v24 = *(v23 + 416);
  v25 = *(v23 + 424);
  if (v25)
  {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v24 + 416))(v24, *(this + 286), a2, this + 1157);
  if (v25)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v25);
  }

  v26 = *(this + 142);
  v27 = *(v26 + 416);
  v28 = *(v26 + 424);
  if (v28)
  {
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v27 + 448))(v27, *(this + 286), a2, this + 1158, this + 1159);
  if (v28)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v28);
  }

  v29 = *(this + 142);
  v30 = *(v29 + 416);
  v31 = *(v29 + 424);
  if (v31)
  {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v30 + 480))(v30, *(this + 286), a2, this + 1160, this + 1161);
  if (v31)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v31);
  }

  v32 = *(this + 142);
  v33 = *(v32 + 416);
  v34 = *(v32 + 424);
  if (v34)
  {
    atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v33 + 512))(v33, *(this + 286), a2, this + 1162);
  if (v34)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v34);
  }

  return 0;
}

void sub_1DE74C910(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_EndIOThread(HALS_PlugInEngine *this, uint64_t a2, const HALS_IOEngineInfo *a3, const applesauce::CF::DictionaryRef *a4)
{
  v8 = *(this + 208);
  if (v8)
  {
    v9 = v8 - 1;
    *(this + 208) = v9;
    if (!v9)
    {
      (*(*this + 1064))(this, a2, a3);
    }
  }

  v10 = *(this + 142);
  v11 = *(v10 + 416);
  v12 = *(v10 + 424);
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v11 + 304))(v11, *(this + 286), a4);
  if (v12)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v12);
  }

  if (*(this + 1148) == 1)
  {
    v13 = *(this + 142);
    v14 = *(v13 + 416);
    v15 = *(v13 + 424);
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v14 + 224))(v14, *(this + 286), a2, a3 + 512);
    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v15);
    }
  }

  return 0;
}

void sub_1DE74CA90(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_BeginIOThread(HALS_PlugInEngine *this, uint64_t a2, const HALS_IOEngineInfo *a3, const applesauce::CF::DictionaryRef *a4)
{
  HALS_IOEngine2::_BeginIOThread(this, a2, a3, a4);
  if (*(this + 1148) == 1)
  {
    v8 = *(this + 142);
    v9 = *(v8 + 416);
    v10 = *(v8 + 424);
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v9 + 216))(v9, *(this + 286), a2, a3 + 512);
    if (v10)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v10);
    }
  }

  v11 = *(this + 142);
  v12 = *(v11 + 416);
  v13 = *(v11 + 424);
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v12 + 304))(v12, *(this + 286), a4);
  if (v13)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v13);
  }

  return 0;
}

void sub_1DE74CBAC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_TellHardwareToStop(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    v5 = *(a1 + 1136);
    v6 = *(v5 + 416);
    v7 = *(v5 + 424);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v6 + 192))(v6, *(a1 + 1144), *(a2 + 16), 0);
    if (v7)
    {

      std::__shared_weak_count::__release_shared[abi:ne200100](v7);
    }
  }
}

void sub_1DE74CC5C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HALS_PlugInEngine::_TellHardwareToStart(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!a4)
  {
    return 0;
  }

  v5 = *(a1 + 1136);
  v6 = *(v5 + 416);
  v7 = *(v5 + 424);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v8 = (*(*v6 + 184))(v6, *(a1 + 1144), *(a2 + 16), 0);
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }

  return v8;
}

void sub_1DE74CD00(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::_UnregisterIOContext(HALS_PlugInEngine *this, HALS_IOContext *a2)
{
  HALS_IOEngine2::_UnregisterIOContext(this, a2);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  LODWORD(v10) = *(a2 + 4);
  LOBYTE(v11) = 1;
  v4 = HALS_ObjectMap::CopyObjectByObjectID(**(a2 + 9));
  v5 = v4;
  if (v4)
  {
    HIDWORD(v10) = *(v4 + 240);
    LOBYTE(v11) = *(v4 + 266) ^ 1;
    v12 = *(v4 + 248);
  }

  v6 = *(this + 142);
  v7 = *(v6 + 416);
  v8 = *(v6 + 424);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v7 + 80))(v7, *(this + 286), &v10);
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v8);
  }

  HALS_ObjectMap::ReleaseObject(v5, v9);
}

void sub_1DE74CDF4(_Unwind_Exception *a1, HALS_Object *a2)
{
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  HALS_ObjectMap::ReleaseObject(v2, a2);
  _Unwind_Resume(a1);
}

void HALS_PlugInEngine::_RegisterIOContext(HALS_PlugInEngine *this, HALS_IOContext *a2)
{
  HALS_IOEngine2::_RegisterIOContext(this, a2);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  LODWORD(v10) = *(a2 + 4);
  LOBYTE(v11) = 1;
  v4 = HALS_ObjectMap::CopyObjectByObjectID(**(a2 + 9));
  v5 = v4;
  if (v4)
  {
    HIDWORD(v10) = *(v4 + 240);
    LOBYTE(v11) = *(v4 + 266) ^ 1;
    v12 = *(v4 + 248);
  }

  v6 = *(this + 142);
  v7 = *(v6 + 416);
  v8 = *(v6 + 424);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  (*(*v7 + 72))(v7, *(this + 286), &v10);
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v8);
  }

  HALS_ObjectMap::ReleaseObject(v5, v9);
}

void sub_1DE74CEF4(_Unwind_Exception *a1, HALS_Object *a2)
{
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  HALS_ObjectMap::ReleaseObject(v2, a2);
  _Unwind_Resume(a1);
}

uint64_t HALS_PlugInEngine::GetZeroTimeStamp(HALS_PlugInEngine *this, uint64_t a2, double *a3, unint64_t *a4, unint64_t *a5)
{
  v6 = *(this + 142);
  v7 = *(v6 + 416);
  v8 = *(v6 + 424);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v9 = (*(*v7 + 200))(v7, *(this + 286), a2, a3, a4, a5);
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v8);
  }

  return v9;
}

void sub_1DE74CFA0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void HALS_PlugInEngine::~HALS_PlugInEngine(HALS_PlugInEngine *this)
{
  HALS_PlugInEngine::~HALS_PlugInEngine(this);

  JUMPOUT(0x1E12C1730);
}

{
  *this = &unk_1F5991658;
  HALB_Mutex::~HALB_Mutex((this + 1216));
  std::__hash_table<std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>>>::~__hash_table(this + 1176);

  HALS_IOEngine2::~HALS_IOEngine2(this);
}

void sub_1DE74D154(_Unwind_Exception *a1)
{
  HALB_Mutex::~HALB_Mutex((v1 + 1216));
  std::__hash_table<std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,HALS_RemotePlugInEngine *>>>::~__hash_table(v2);
  HALS_IOEngine2::~HALS_IOEngine2(v1);
  _Unwind_Resume(a1);
}

uint64_t HALS_PlugInEngine::GetOwningPlugInDeviceUCID(HALS_PlugInEngine *this, HALS_IODevice *a2)
{
  v3 = *(this + 5);
  v2 = *(this + 6);
  v4 = 1476;
  if (v3 <= 1701078389)
  {
    v5 = v3 == 1633773415;
    v6 = 1633969526;
  }

  else
  {
    v5 = v3 == 1701078390 || v3 == 1701733488;
    v6 = 1919182198;
  }

  if (v5 || v3 == v6)
  {
    return *(this + v4);
  }

  if (v3 != v2)
  {
    v4 = 1476;
    if (v2 <= 1701078389)
    {
      if (v2 == 1633773415)
      {
        return *(this + v4);
      }

      v9 = 1633969526;
    }

    else
    {
      if (v2 == 1701078390 || v2 == 1701733488)
      {
        return *(this + v4);
      }

      v9 = 1919182198;
    }

    if (v2 != v9)
    {
      v4 = 396;
      if (v3 != v2 && v3 != 1633905771 && v2 != 1633905771)
      {
        return 0;
      }
    }

    return *(this + v4);
  }

  v4 = 396;
  if (v3 == 1633905771 || v3 != v2)
  {
    return *(this + v4);
  }

  return 0;
}

void HALHealth::Observer::~Observer(HALHealth::Observer *this)
{
  v2 = *(this + 2);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = *(this + 2);
    *(this + 2) = 0;
    if (v3)
    {
      dispatch_release(v3);
    }
  }

  std::__tree<std::shared_ptr<AHAL_DSP::IAudioStream>>::destroy(*(this + 17));
  HALB_Mutex::~HALB_Mutex((this + 24));
  v4 = *(this + 2);
  if (v4)
  {
    dispatch_release(v4);
  }

  v5 = *(this + 1);
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void ___ZN9HALHealth8Observer20setup_periodic_purgeEv_block_invoke(AMCP::Log::AMCP_Scope_Registry *a1)
{
  v36 = *MEMORY[0x1E69E9840];
  v2 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
  if ((v2 & 1) == 0)
  {
    AMCP::Log::AMCP_Scope_Registry::initialize(a1);
  }

  v4 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v3 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    v5 = *v4;
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  else
  {
    v5 = *v4;
  }

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *buf = 136315394;
    *&buf[4] = "HALHealthObserver.cpp";
    *&buf[12] = 1024;
    *&buf[14] = 91;
    _os_log_debug_impl(&dword_1DE1F9000, v5, OS_LOG_TYPE_DEBUG, "%32s:%-5d HALHealth::Observer purging", buf, 0x12u);
  }

  v6 = *(a1 + 5);
  if (v6)
  {
    v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      v8 = v7;
      v9 = *(a1 + 4);
      if (v9)
      {
        memset(buf, 0, sizeof(buf));
        v33 = (v9 + 24);
        v34 = HALB_Mutex::Lock((v9 + 24));
        v10 = *(v9 + 128);
        if (v10 != (v9 + 136))
        {
          do
          {
            if ((*(*v10[4] + 24))(v10[4]))
            {
              v11 = v10[1];
              if (v11)
              {
                do
                {
                  v12 = v11;
                  v11 = *v11;
                }

                while (v11);
              }

              else
              {
                do
                {
                  v12 = v10[2];
                  v13 = *v12 == v10;
                  v10 = v12;
                }

                while (!v13);
              }
            }

            else
            {
              v14 = *&buf[8];
              if (*&buf[8] >= *&buf[16])
              {
                v17 = (*&buf[8] - *buf) >> 4;
                v18 = v17 + 1;
                if ((v17 + 1) >> 60)
                {
                  std::vector<void *>::__throw_length_error[abi:ne200100]();
                }

                v19 = *&buf[16] - *buf;
                if ((*&buf[16] - *buf) >> 3 > v18)
                {
                  v18 = v19 >> 3;
                }

                if (v19 >= 0x7FFFFFFFFFFFFFF0)
                {
                  v20 = 0xFFFFFFFFFFFFFFFLL;
                }

                else
                {
                  v20 = v18;
                }

                if (v20)
                {
                  if (!(v20 >> 60))
                  {
                    operator new();
                  }

                  std::__throw_bad_array_new_length[abi:ne200100]();
                }

                v21 = 16 * v17;
                v22 = *(v10 + 2);
                *(16 * v17) = v22;
                if (*(&v22 + 1))
                {
                  atomic_fetch_add_explicit((*(&v22 + 1) + 8), 1uLL, memory_order_relaxed);
                }

                v16 = v21 + 16;
                v23 = *buf;
                v24 = (v21 - (*&buf[8] - *buf));
                memcpy(v24, *buf, *&buf[8] - *buf);
                *buf = v24;
                *&buf[8] = v16;
                *&buf[16] = 0;
                if (v23)
                {
                  operator delete(v23);
                }
              }

              else
              {
                **&buf[8] = v10[4];
                v15 = v10[5];
                *(v14 + 8) = v15;
                if (v15)
                {
                  atomic_fetch_add_explicit((v15 + 8), 1uLL, memory_order_relaxed);
                }

                v16 = v14 + 16;
              }

              *&buf[8] = v16;
              v25 = v10[1];
              v26 = v10;
              if (v25)
              {
                do
                {
                  v12 = v25;
                  v25 = *v25;
                }

                while (v25);
              }

              else
              {
                do
                {
                  v12 = v26[2];
                  v13 = *v12 == v26;
                  v26 = v12;
                }

                while (!v13);
              }

              if (*(v9 + 128) == v10)
              {
                *(v9 + 128) = v12;
              }

              v27 = *(v9 + 136);
              --*(v9 + 144);
              std::__tree_remove[abi:ne200100]<std::__tree_node_base<void *> *>(v27, v10);
              v28 = v10[5];
              if (v28)
              {
                std::__shared_weak_count::__release_shared[abi:ne200100](v28);
              }

              operator delete(v10);
            }

            v10 = v12;
          }

          while (v12 != (v9 + 136));
        }

        HALB_Mutex::Locker::~Locker(&v33);
        v29 = *buf;
        for (i = *&buf[8]; i != v29; i -= 16)
        {
          v31 = *(i - 8);
          if (v31)
          {
            std::__shared_weak_count::__release_shared[abi:ne200100](v31);
          }
        }

        *&buf[8] = v29;
        v33 = buf;
        std::vector<std::shared_ptr<unsigned long long>>::__destroy_vector::operator()[abi:ne200100](&v33);
      }

      std::__shared_weak_count::__release_shared[abi:ne200100](v8);
    }
  }

  v32 = *MEMORY[0x1E69E9840];
}

void sub_1DE74D668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, char a11)
{
  a9 = &a11;
  std::vector<std::shared_ptr<unsigned long long>>::__destroy_vector::operator()[abi:ne200100](&a9);
  std::__shared_weak_count::__release_shared[abi:ne200100](v11);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c44_ZTSNSt3__18weak_ptrIN9HALHealth8ObserverEEE(uint64_t a1)
{
  v1 = *(a1 + 40);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_e8_32c44_ZTSNSt3__18weak_ptrIN9HALHealth8ObserverEEE(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 40);
  *(result + 32) = *(a2 + 32);
  *(result + 40) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

HALHealth::Observer **std::unique_ptr<HALHealth::Observer>::~unique_ptr[abi:ne200100](HALHealth::Observer **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    HALHealth::Observer::~Observer(v2);
    MEMORY[0x1E12C1730]();
  }

  return a1;
}

uint64_t std::__shared_ptr_pointer<HALHealth::Observer *,std::shared_ptr<HALHealth::Observer>::__shared_ptr_default_delete<HALHealth::Observer,HALHealth::Observer>,std::allocator<HALHealth::Observer>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "NSt3__110shared_ptrIN9HALHealth8ObserverEE27__shared_ptr_default_deleteIS2_S2_EE"))
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

HALHealth::Observer *std::__shared_ptr_pointer<HALHealth::Observer *,std::shared_ptr<HALHealth::Observer>::__shared_ptr_default_delete<HALHealth::Observer,HALHealth::Observer>,std::allocator<HALHealth::Observer>>::__on_zero_shared(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    HALHealth::Observer::~Observer(result);

    JUMPOUT(0x1E12C1730);
  }

  return result;
}

void std::__shared_ptr_pointer<HALHealth::Observer *,std::shared_ptr<HALHealth::Observer>::__shared_ptr_default_delete<HALHealth::Observer,HALHealth::Observer>,std::allocator<HALHealth::Observer>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12C1730);
}

uint64_t HALS_PowerManager::Teardown(uint64_t this)
{
  if (*(this + 424) == 1)
  {
    v1 = this;
    this = (*(**(this + 8) + 40))(*(this + 8), *(this + 408));
    *(v1 + 424) = 0;
  }

  return this;
}

void HALS_PowerManager::Initialize(uint64_t a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  if (a2 == 1)
  {
LABEL_12:
    v11 = *MEMORY[0x1E69E9840];
    return;
  }

  v14 = 0;
  v3 = (*(**(a1 + 8) + 24))(*(a1 + 8), a1 + 416, &v14);
  (*(*a1 + 32))(a1);
  if (!v3)
  {
LABEL_8:
    v8 = *(a1 + 8);
    v9 = *(a1 + 64);
    v13[0] = MEMORY[0x1E69E9820];
    v13[1] = 0x40000000;
    v13[2] = ___ZN17HALS_PowerManager33InitUserActivityLevelNotificationEv_block_invoke;
    v13[3] = &__block_descriptor_tmp_21445;
    v13[4] = a1;
    v10 = (*(*v8 + 32))(v8, v9, v13);
    *(a1 + 408) = v10;
    if (!v10)
    {
      if (!os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT) || (*buf = 136315394, v16 = "HALS_PowerManager.cpp", v17 = 1024, v18 = 75, _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  [FAIL] IOPMScheduleUserActivityLevelNotification returned 0", buf, 0x12u), !*(a1 + 408)))
      {
        if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR))
        {
          *buf = 136315394;
          v16 = "HALS_PowerManager.cpp";
          v17 = 1024;
          v18 = 76;
          _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_ERROR, "%25s:%-5d  HALS_System::_InitUserActivityLevelNotification: IOPMScheduleUserActivityLevelNotification() failed to return the handle", buf, 0x12u);
        }

        exception = __cxa_allocate_exception(0x10uLL);
        *exception = off_1F5991DD8;
        exception[2] = 2003329396;
      }
    }

    *(a1 + 424) = 1;
    goto LABEL_12;
  }

  v4 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v5 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  if (*MEMORY[0x1E69E3C08])
  {
    v6 = *(v4 + 8);
    v7 = caulk::rt_safe_memory_resource::rt_allocate(*MEMORY[0x1E69E3C08]);
    *(v7 + 16) = 0;
    *(v7 + 20) = 16;
    *(v7 + 24) = "HALS_PowerManager.cpp";
    *(v7 + 32) = (v3 << 32) | 0x3E;
    *v7 = &unk_1F5991E00;
    *(v7 + 8) = 0;
    caulk::concurrent::messenger::enqueue(v6, v7);
    if (v5)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v5);
    }

    goto LABEL_8;
  }

  __break(1u);
}

uint64_t ___ZN17HALS_PowerManager33InitUserActivityLevelNotificationEv_block_invoke(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 32);
  v2[52] = a2;
  return (*(*v2 + 32))();
}

uint64_t caulk::concurrent::details::rt_message_call<HALS_PowerManager::InitUserActivityLevelNotification(void)::$_0,std::tuple<char const*,int,unsigned int>>::perform(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v2 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v4 = *v3;
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  else
  {
    v4 = *v3;
  }

  v5 = *(a1 + 20);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(a1 + 24);
    v7 = *(a1 + 32);
    v8 = *(a1 + 36);
    v11 = 136315650;
    v12 = v6;
    v13 = 1024;
    v14 = v7;
    v15 = 1024;
    v16 = v8;
    _os_log_impl(&dword_1DE1F9000, v4, v5, "%32s:%-5d HALS_PowerManager::InitUserActivityLevelNotification: failed to get the user activity level, Error: 0x%X", &v11, 0x18u);
  }

  caulk::concurrent::message::~message(a1);
  if (!*MEMORY[0x1E69E3C08])
  {
    __break(1u);
  }

  result = caulk::rt_safe_memory_resource::rt_deallocate(*MEMORY[0x1E69E3C08], a1);
  v10 = *MEMORY[0x1E69E9840];
  return result;
}

void caulk::concurrent::details::rt_message_call<HALS_PowerManager::InitUserActivityLevelNotification(void)::$_0,std::tuple<char const*,int,unsigned int>>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x1E12C1730);
}

void HALS_PowerManager::~HALS_PowerManager(HALS_PowerManager *this)
{
  HALS_PowerManager::~HALS_PowerManager(this);

  JUMPOUT(0x1E12C1730);
}

{
  *this = &unk_1F5991C80;
  if (*(this + 424) == 1)
  {
    (*(**(this + 1) + 40))(*(this + 1), *(this + 51));
    *(this + 424) = 0;
  }

  AMCP::Utility::Dispatch_Queue::~Dispatch_Queue((this + 64));
  std::__function::__value_func<void ()(void *,AMCP::Power_State)>::~__value_func[abi:ne200100](this + 32);
  v2 = *(this + 2);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }
}

void HALB_Mutex::~HALB_Mutex(HALB_Mutex *this)
{
  HALB_Mutex::~HALB_Mutex(this);

  JUMPOUT(0x1E12C1730);
}

{
  v11 = *MEMORY[0x1E69E9840];
  *this = &unk_1F5991E58;
  if (!*(this + 22))
  {
    v1 = pthread_mutex_destroy((this + 8));
    if (v1)
    {
      v2 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v2 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(v1);
      }

      v4 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v3 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v3)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        v5 = *v4;
        std::__shared_weak_count::__release_shared[abi:ne200100](v3);
      }

      else
      {
        v5 = *v4;
      }

      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v7 = 136315394;
        v8 = "HALB_Mutex.cpp";
        v9 = 1024;
        v10 = 45;
        _os_log_error_impl(&dword_1DE1F9000, v5, OS_LOG_TYPE_ERROR, "%32s:%-5d HALB_Mutex::~HALB_Mutex: failed to destroy the mutex", &v7, 0x12u);
      }
    }
  }

  v6 = *MEMORY[0x1E69E9840];
}

void sub_1DE74DFB4(_Unwind_Exception *a1, int a2)
{
  if (!a2)
  {
    _Unwind_Resume(a1);
  }

  __clang_call_terminate(a1);
}

void HALB_Guard::~HALB_Guard(HALB_Guard *this)
{
  HALB_Guard::~HALB_Guard(this);

  JUMPOUT(0x1E12C1730);
}

{
  v12 = *MEMORY[0x1E69E9840];
  *this = &unk_1F5991E78;
  if (!*(this + 22))
  {
    v2 = pthread_cond_destroy((this + 104));
    if (v2)
    {
      v3 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v3 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(v2);
      }

      v5 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v4 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v4)
      {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        v6 = *v5;
        std::__shared_weak_count::__release_shared[abi:ne200100](v4);
      }

      else
      {
        v6 = *v5;
      }

      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        v8 = 136315394;
        v9 = "HALB_Mutex.cpp";
        v10 = 1024;
        v11 = 196;
        _os_log_error_impl(&dword_1DE1F9000, v6, OS_LOG_TYPE_ERROR, "%32s:%-5d HALB_Guard::~HALB_Guard: failed to destroy the condition variable", &v8, 0x12u);
      }
    }
  }

  HALB_Mutex::~HALB_Mutex(this);
  v7 = *MEMORY[0x1E69E9840];
}

void sub_1DE74E130(_Unwind_Exception *a1, int a2)
{
  if (!a2)
  {
    _Unwind_Resume(a1);
  }

  __clang_call_terminate(a1);
}

void HALB_Mutex::HALB_Mutex(HALB_Mutex *this)
{
  v12 = *MEMORY[0x1E69E9840];
  *this = &unk_1F5991E58;
  *(this + 12) = 0;
  *(this + 24) = 0u;
  *(this + 40) = 0u;
  *(this + 56) = 0u;
  *(this + 72) = 0u;
  *(this + 22) = 0;
  *(this + 8) = 0u;
  v2 = pthread_mutex_init((this + 8), 0);
  *(this + 22) = v2;
  if (v2)
  {
    v3 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v3 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v2);
    }

    v5 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v4 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v4)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      v6 = *v5;
      std::__shared_weak_count::__release_shared[abi:ne200100](v4);
    }

    else
    {
      v6 = *v5;
    }

    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = 136315394;
      v9 = "HALB_Mutex.cpp";
      v10 = 1024;
      v11 = 37;
      _os_log_error_impl(&dword_1DE1F9000, v6, OS_LOG_TYPE_ERROR, "%32s:%-5d HALB_Mutex::HALB_Mutex: failed to initialize the mutex", &v8, 0x12u);
    }
  }

  v7 = *MEMORY[0x1E69E9840];
}

uint64_t HALB_Mutex::Lock(HALB_Mutex *this)
{
  v17 = *MEMORY[0x1E69E9840];
  v1 = *(this + 22);
  if (v1)
  {
    goto LABEL_2;
  }

  v5 = *(this + 9);
  if (v5 == pthread_self())
  {
    v11 = *(this + 10);
    if (v11 != -1)
    {
      v1 = 0;
      *(this + 10) = v11 + 1;
      goto LABEL_2;
    }

    if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
    {
      v13 = 136315394;
      v14 = "HALB_Mutex.cpp";
      v15 = 1024;
      v16 = 126;
      _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  HALB_Mutex::Lock: lock count at maximum", &v13, 0x12u);
    }

LABEL_21:
    v1 = 34;
    goto LABEL_2;
  }

  v6 = pthread_mutex_lock((this + 8));
  if (!v6)
  {
    v12 = *(this + 10);
    if (v12 != -1)
    {
      *(this + 10) = v12 + 1;
      *(this + 9) = pthread_self();
      v1 = 0;
      atomic_store(std::chrono::steady_clock::now().__d_.__rep_, this + 12);
      goto LABEL_2;
    }

    if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
    {
      v13 = 136315394;
      v14 = "HALB_Mutex.cpp";
      v15 = 1024;
      v16 = 112;
      _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  HALB_Mutex::Lock: lock count at maximum after locking", &v13, 0x12u);
    }

    pthread_mutex_unlock((this + 8));
    goto LABEL_21;
  }

  v1 = v6;
  v7 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
  if ((v7 & 1) == 0)
  {
    AMCP::Log::AMCP_Scope_Registry::initialize(v6);
  }

  v9 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v8 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    v10 = *v9;
    std::__shared_weak_count::__release_shared[abi:ne200100](v8);
  }

  else
  {
    v10 = *v9;
  }

  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    v13 = 136315394;
    v14 = "HALB_Mutex.cpp";
    v15 = 1024;
    v16 = 101;
    _os_log_error_impl(&dword_1DE1F9000, v10, OS_LOG_TYPE_ERROR, "%32s:%-5d HALB_Mutex::Lock: locking failed", &v13, 0x12u);
  }

LABEL_2:
  v2 = *MEMORY[0x1E69E9840];
  return v1;
}

uint64_t HALB_Mutex::Unlock(HALB_Mutex *this)
{
  v17 = *MEMORY[0x1E69E9840];
  v1 = *(this + 22);
  if (!v1)
  {
    v3 = *(this + 9);
    if (v3 == pthread_self())
    {
      v6 = *(this + 10);
      if (v6)
      {
        v7 = v6 - 1;
        *(this + 10) = v7;
        if (v7)
        {
          v1 = 0;
        }

        else
        {
          *(this + 9) = 0;
          atomic_store(0, this + 12);
          v8 = pthread_mutex_unlock((this + 8));
          v1 = v8;
          if (v8)
          {
            v9 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
            if ((v9 & 1) == 0)
            {
              AMCP::Log::AMCP_Scope_Registry::initialize(v8);
            }

            v11 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
            v10 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
            if (v10)
            {
              atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
              v12 = *v11;
              std::__shared_weak_count::__release_shared[abi:ne200100](v10);
            }

            else
            {
              v12 = *v11;
            }

            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              v13 = 136315394;
              v14 = "HALB_Mutex.cpp";
              v15 = 1024;
              v16 = 149;
              _os_log_error_impl(&dword_1DE1F9000, v12, OS_LOG_TYPE_ERROR, "%32s:%-5d HALB_Mutex::Unlock: unlocking failed", &v13, 0x12u);
            }
          }
        }
      }

      else
      {
        if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
        {
          v13 = 136315394;
          v14 = "HALB_Mutex.cpp";
          v15 = 1024;
          v16 = 154;
          _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  HALB_Mutex::Unlock: the lock count is at 0 already", &v13, 0x12u);
        }

        v1 = 34;
      }
    }

    else
    {
      if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
      {
        v13 = 136315394;
        v14 = "HALB_Mutex.cpp";
        v15 = 1024;
        v16 = 160;
        _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  HALB_Mutex::Unlock: can't unlock a mutex the thread hasn't locked", &v13, 0x12u);
      }

      v1 = 1;
    }
  }

  v4 = *MEMORY[0x1E69E9840];
  return v1;
}

void HALB_Guard::HALB_Guard(HALB_Guard *this)
{
  v14 = *MEMORY[0x1E69E9840];
  HALB_Mutex::HALB_Mutex(this);
  *v2 = &unk_1F5991E78;
  *(v2 + 104) = 0u;
  v3 = (v2 + 104);
  *(this + 120) = 0u;
  *(this + 136) = 0u;
  if (!*(this + 22))
  {
    v4 = pthread_cond_init(v3, 0);
    *(this + 22) = v4;
    if (v4)
    {
      v5 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v5 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(v4);
      }

      v7 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v6 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v6)
      {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        v8 = *v7;
        std::__shared_weak_count::__release_shared[abi:ne200100](v6);
      }

      else
      {
        v8 = *v7;
      }

      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v10 = 136315394;
        v11 = "HALB_Mutex.cpp";
        v12 = 1024;
        v13 = 187;
        _os_log_error_impl(&dword_1DE1F9000, v8, OS_LOG_TYPE_ERROR, "%32s:%-5d HALB_Guard::HALB_Guard: failed to initialize the condition variable", &v10, 0x12u);
      }
    }
  }

  v9 = *MEMORY[0x1E69E9840];
}

void HALB_Guard::Wait(HALB_Guard *this)
{
  v15 = *MEMORY[0x1E69E9840];
  if (!*(this + 22))
  {
    v3 = (this + 72);
    v4 = *(this + 9);
    if (v4 == pthread_self())
    {
      v5 = *(this + 10);
      *v3 = 0;
      v3[1] = 0;
      v6 = pthread_cond_wait((this + 104), (this + 8));
      if (v6)
      {
        v7 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v7 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(v6);
        }

        v9 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v8 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v8)
        {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          v10 = *v9;
          std::__shared_weak_count::__release_shared[abi:ne200100](v8);
        }

        else
        {
          v10 = *v9;
        }

        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          v11 = 136315394;
          v12 = "HALB_Mutex.cpp";
          v13 = 1024;
          v14 = 211;
          _os_log_error_impl(&dword_1DE1F9000, v10, OS_LOG_TYPE_ERROR, "%32s:%-5d HALB_Guard::Wait: waiting failed", &v11, 0x12u);
        }
      }

      else
      {
        *(this + 10) = v5;
        *(this + 9) = pthread_self();
      }
    }

    else if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136315394;
      v12 = "HALB_Mutex.cpp";
      v13 = 1024;
      v14 = 220;
      _os_log_impl(&dword_1DE1F9000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  HALB_Mutex::Wait: can't wait with a mutex the thread hasn't locked", &v11, 0x12u);
    }
  }

  v1 = *MEMORY[0x1E69E9840];
}

void HALB_Guard::Notify(HALB_Guard *this)
{
  v11 = *MEMORY[0x1E69E9840];
  if (!*(this + 22))
  {
    v1 = pthread_cond_signal((this + 104));
    if (v1)
    {
      v2 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v2 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(v1);
      }

      v4 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v3 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v3)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        v5 = *v4;
        std::__shared_weak_count::__release_shared[abi:ne200100](v3);
      }

      else
      {
        v5 = *v4;
      }

      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v7 = 136315394;
        v8 = "HALB_Mutex.cpp";
        v9 = 1024;
        v10 = 297;
        _os_log_error_impl(&dword_1DE1F9000, v5, OS_LOG_TYPE_ERROR, "%32s:%-5d HALB_Guard::Notify: signaling failed", &v7, 0x12u);
      }
    }
  }

  v6 = *MEMORY[0x1E69E9840];
}

uint64_t Extrinsic_Driver_Connection_To_Server::register_new_driver(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  v18 = *MEMORY[0x1E69E9840];
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  v8 = *(a1 + 32);
  AMCP::Log::Scope::get_os_log_t(v8);
  objc_claimAutoreleasedReturnValue();
  block[0] = MEMORY[0x1E69E9820];
  block[1] = 3321888768;
  block[2] = ___ZN37Extrinsic_Driver_Connection_To_Server19register_new_driverEPP32AudioServerPlugInDriverInterfacebNSt3__18functionIFvvEEE_block_invoke;
  block[3] = &unk_1F5991EB8;
  block[4] = &v12;
  block[5] = a1;
  block[6] = a2;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100](v17, a4);
  v17[32] = a3;
  dispatch_sync(v8, block);

  v9 = *(v13 + 6);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](v17);
  _Block_object_dispose(&v12, 8);
  v10 = *MEMORY[0x1E69E9840];
  return v9;
}

void sub_1DE74EC30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN37Extrinsic_Driver_Connection_To_Server19register_new_driverEPP32AudioServerPlugInDriverInterfacebNSt3__18functionIFvvEEE_block_invoke(uint64_t a1)
{
  v95 = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 40);
  v3 = *(v2 + 24);
  if (!v3)
  {
    v4 = [objc_alloc(MEMORY[0x1E696B0B8]) initWithMachServiceName:@"com.apple.audio.driver-registrar" options:0];
    v5 = *(v2 + 24);
    *(v2 + 24) = v4;

    v6 = [MEMORY[0x1E696B0D0] interfaceWithProtocol:&unk_1F5999938];
    [*(v2 + 24) setRemoteObjectInterface:v6];

    v7 = *(v2 + 24);
    *aBlock = MEMORY[0x1E69E9820];
    *&aBlock[8] = 3321888768;
    *&aBlock[16] = ___ZZN37Extrinsic_Driver_Connection_To_Server28_create_connection_to_serverEvENK3__0cvU13block_pointerFvvEEv_block_invoke;
    *&aBlock[24] = &__block_descriptor_40_ea8_32c83_ZTSKZN37Extrinsic_Driver_Connection_To_Server28_create_connection_to_serverEvE3__0_e5_v8__0l;
    v88[0].__locale_ = v7;
    v8 = v7;
    v9 = _Block_copy(aBlock);

    [*(v2 + 24) setInterruptionHandler:v9];
    *aBlock = MEMORY[0x1E69E9820];
    *&aBlock[8] = 3321888768;
    *&aBlock[16] = ___ZZN37Extrinsic_Driver_Connection_To_Server28_create_connection_to_serverEvENK3__2cvU13block_pointerFvvEEv_block_invoke;
    *&aBlock[24] = &__block_descriptor_40_ea8_32c83_ZTSKZN37Extrinsic_Driver_Connection_To_Server28_create_connection_to_serverEvE3__2_e5_v8__0l;
    v88[0].__locale_ = v2;
    v10 = _Block_copy(aBlock);
    [*(v2 + 24) setInvalidationHandler:v10];

    [*(v2 + 24) resume];
    v3 = *(v2 + 24);
  }

  v81[0] = MEMORY[0x1E69E9820];
  v81[1] = 3221225472;
  v81[2] = ___ZN37Extrinsic_Driver_Connection_To_Server19register_new_driverEPP32AudioServerPlugInDriverInterfacebNSt3__18functionIFvvEEE_block_invoke_2;
  v81[3] = &unk_1E86795D0;
  v81[4] = *(a1 + 32);
  v80 = [v3 synchronousRemoteObjectProxyWithErrorHandler:v81];
  if (v80)
  {
    v11 = *(a1 + 48);
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100](v84, a1 + 56);
    v12 = [Core_Audio_Driver alloc];
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100](&v91, v84);
    *aBlock = [(Core_Audio_Driver *)v12 init_driver_interface:v11 invalidation_handler:&v91];
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100](&aBlock[8], v84);
    v13 = *(v2 + 8);
    v14 = *(v2 + 16);
    if (v13 >= v14)
    {
      v21 = 0xCCCCCCCCCCCCCCCDLL * ((v13 - *v2) >> 3);
      v22 = v21 + 1;
      if (v21 + 1 > 0x666666666666666)
      {
        std::vector<void *>::__throw_length_error[abi:ne200100]();
      }

      v23 = 0xCCCCCCCCCCCCCCCDLL * ((v14 - *v2) >> 3);
      if (2 * v23 > v22)
      {
        v22 = 2 * v23;
      }

      if (v23 >= 0x333333333333333)
      {
        v24 = 0x666666666666666;
      }

      else
      {
        v24 = v22;
      }

      if (v24)
      {
        if (v24 <= 0x666666666666666)
        {
          operator new();
        }

        std::__throw_bad_array_new_length[abi:ne200100]();
      }

      v25 = 40 * v21;
      v26 = *aBlock;
      *aBlock = 0;
      *(40 * v21) = v26;
      v16 = 40 * v21 + 40;
      std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100](40 * v21 + 8, &aBlock[8]);
      v27 = *v2;
      v28 = *(v2 + 8);
      v29 = v28 - *v2;
      if (v28 != *v2)
      {
        v30 = 40 * v21 - 8 * ((v28 - *v2) >> 3) + 8;
        v31 = *v2;
        do
        {
          v32 = (v31 + 1);
          v33 = *v31;
          *v31 = 0;
          v31 += 5;
          *(v30 - 8) = v33;
          v30 = std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100](v30, v32) + 40;
        }

        while (v31 != v28);
        while (v27 != v28)
        {
          std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100]((v27 + 1));

          v27 += 5;
        }
      }

      v34 = *v2;
      *v2 = v25 - v29;
      *(v2 + 8) = v16;
      if (v34)
      {
        operator delete(v34);
      }
    }

    else
    {
      v15 = *aBlock;
      *aBlock = 0;
      *v13 = v15;
      v16 = (v13 + 5);
      std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100]((v13 + 1), &aBlock[8]);
    }

    *(v2 + 8) = v16;
    std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](&aBlock[8]);

    std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](&v91);
    v35 = *(v2 + 8);
    v85 = *(v35 - 40);
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100](v86, v35 - 32);
    std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](v84);
    v36 = [v85 endpoint];
    v37 = *(a1 + 88);
    v38 = v80;
    v39 = v36;
    v91 = 0;
    v92 = &v91;
    v93 = 0x2020000000;
    v94 = 1937010544;
    v40 = [MEMORY[0x1E696AAE8] mainBundle];
    v41 = [v40 bundleURL];
    v42 = [v40 bundleIdentifier];
    if (!v42)
    {
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne200100](aBlock);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&aBlock[16], "ExtrinsicDriver-", 16);
      v43 = getpid();
      MEMORY[0x1E12C1200](&aBlock[16], v43);
      v44 = MEMORY[0x1E696AEC0];
      std::stringbuf::str[abi:ne200100](__p, &aBlock[24]);
      if (v83 >= 0)
      {
        v45 = __p;
      }

      else
      {
        v45 = __p[0];
      }

      v42 = [v44 stringWithUTF8String:v45];
      if (v83 < 0)
      {
        operator delete(__p[0]);
      }

      *aBlock = *MEMORY[0x1E69E54D8];
      v46 = *(MEMORY[0x1E69E54D8] + 72);
      *&aBlock[*(*aBlock - 24)] = *(MEMORY[0x1E69E54D8] + 64);
      *&aBlock[16] = v46;
      *&aBlock[24] = MEMORY[0x1E69E5548] + 16;
      if (v89 < 0)
      {
        operator delete(v88[7].__locale_);
      }

      *&aBlock[24] = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(v88);
      std::iostream::~basic_iostream();
      MEMORY[0x1E12C15F0](&v90);
      v37 = v37;
    }

    *aBlock = MEMORY[0x1E69E9820];
    *&aBlock[8] = 3221225472;
    *&aBlock[16] = ___ZN37Extrinsic_Driver_Connection_To_Server16_register_driverEPU47objcproto36Core_Audio_Driver_Registrar_Protocol11objc_objectP21NSXPCListenerEndpointb_block_invoke;
    *&aBlock[24] = &unk_1E86795F8;
    v88[0].__locale_ = &v91;
    [v38 register_driver:v39 bundle_url:v41 bundle_id:v42 cpu_type:16777228 is_using_driver_service:v37 reply:aBlock];
    v47 = *(v92 + 6);

    _Block_object_dispose(&v91, 8);
    *(*(*(a1 + 32) + 8) + 24) = v47;

    if (*(*(*(a1 + 32) + 8) + 24))
    {
      v49 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
      if ((v49 & 1) == 0)
      {
        AMCP::Log::AMCP_Scope_Registry::initialize(v48);
      }

      v50 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
      v51 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
      if (v51)
      {
        atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
        v52 = *v50;
        AMCP::Log::Scope::get_os_log_t(*v50);
        objc_claimAutoreleasedReturnValue();
        std::__shared_weak_count::__release_shared[abi:ne200100](v51);
      }

      else
      {
        v52 = *v50;
        AMCP::Log::Scope::get_os_log_t(*v50);
        objc_claimAutoreleasedReturnValue();
      }

      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        v67 = 0;
        v68 = 0;
        v69 = 47;
        do
        {
          v70 = &aLibraryCachesC_239[v67];
          if (v69 == 47)
          {
            v68 = &aLibraryCachesC_239[v67];
          }

          v69 = v70[1];
          if (!v70[1])
          {
            break;
          }

          v71 = v67++ >= 0xFFF;
        }

        while (!v71);
        if (v68)
        {
          v72 = v68 + 1;
        }

        else
        {
          v72 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Registration.mm";
        }

        v73 = *(a1 + 48);
        *aBlock = 136315650;
        *&aBlock[4] = v72;
        *&aBlock[12] = 1024;
        *&aBlock[14] = 95;
        *&aBlock[18] = 2048;
        *&aBlock[20] = v73;
        _os_log_error_impl(&dword_1DE1F9000, v52, OS_LOG_TYPE_ERROR, "%32s:%-5d Extrinsic_Driver_Connection_To_Server: Failed to register remote driver, driver interface %p", aBlock, 0x1Cu);
      }

      if (v85)
      {
        v53 = v85;
        v55 = *v2;
        v54 = *(v2 + 8);
        v56 = v53;
        v57 = v56;
        if (v55 != v54)
        {
          while (*v55 != v56)
          {
            v55 += 5;
            if (v55 == v54)
            {
              v55 = v54;
              break;
            }
          }
        }

        v58 = *(v2 + 8);
        if (v55 != v58)
        {
          v59 = v55 + 5;
          if (v55 + 5 != v58)
          {
            while (1)
            {
              v60 = v55[5];
              v55[5] = 0;
              v61 = *v55;
              *v55 = v60;

              std::__function::__value_func<void ()(void)>::operator=[abi:ne200100]((v55 + 1));
              v62 = v55[9];
              if (v62)
              {
                if (v55 + 6 == v62)
                {
                  v55[4] = v55 + 1;
                  (*(*v62 + 3))(v62, v55 + 1);
                  goto LABEL_59;
                }

                v63 = v59 + 4;
                v55[4] = v62;
              }

              else
              {
                v63 = v55 + 4;
              }

              *v63 = 0;
LABEL_59:
              v59 += 5;
              v64 = (v55 + 5);
              v65 = v55 + 10;
              v55 += 5;
              if (v65 == v58)
              {
                goto LABEL_62;
              }
            }
          }

          v64 = v55;
LABEL_62:
          std::vector<std::pair<Core_Audio_Driver * {__strong},std::function<void ()(void)>>>::__base_destruct_at_end[abi:ne200100](v2, v64);
        }
      }
    }

    std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](v86);
  }

  else
  {
    v17 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v17 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(0);
    }

    v18 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v19 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      v20 = *v18;
      AMCP::Log::Scope::get_os_log_t(*v18);
      objc_claimAutoreleasedReturnValue();
      std::__shared_weak_count::__release_shared[abi:ne200100](v19);
    }

    else
    {
      v20 = *v18;
      AMCP::Log::Scope::get_os_log_t(*v18);
      objc_claimAutoreleasedReturnValue();
    }

    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v74 = 0;
      v75 = 0;
      v76 = 47;
      do
      {
        v77 = &aLibraryCachesC_239[v74];
        if (v76 == 47)
        {
          v75 = &aLibraryCachesC_239[v74];
        }

        v76 = v77[1];
        if (!v77[1])
        {
          break;
        }

        v71 = v74++ >= 0xFFF;
      }

      while (!v71);
      if (v75)
      {
        v78 = v75 + 1;
      }

      else
      {
        v78 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Registration.mm";
      }

      v79 = *(a1 + 48);
      *aBlock = 136315650;
      *&aBlock[4] = v78;
      *&aBlock[12] = 1024;
      *&aBlock[14] = 104;
      *&aBlock[18] = 2048;
      *&aBlock[20] = v79;
      _os_log_error_impl(&dword_1DE1F9000, v20, OS_LOG_TYPE_ERROR, "%32s:%-5d Extrinsic_Driver_Connection_To_Server: failed to get server proxy connection, driver interface %p", aBlock, 0x1Cu);
    }

    *(*(*(a1 + 32) + 8) + 24) = 1937010544;
  }

  v66 = *MEMORY[0x1E69E9840];
}

void sub_1DE74F6E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32)
{
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](&a28);

  _Unwind_Resume(a1);
}

void ___ZN37Extrinsic_Driver_Connection_To_Server19register_new_driverEPP32AudioServerPlugInDriverInterfacebNSt3__18functionIFvvEEE_block_invoke_2(uint64_t a1, void *a2)
{
  v24 = *MEMORY[0x1E69E9840];
  v3 = a2;
  v4 = v3;
  v5 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
  if ((v5 & 1) == 0)
  {
    AMCP::Log::AMCP_Scope_Registry::initialize(v3);
  }

  v6 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v7 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    v8 = *v6;
    AMCP::Log::Scope::get_os_log_t(*v6);
    objc_claimAutoreleasedReturnValue();
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }

  else
  {
    v8 = *v6;
    AMCP::Log::Scope::get_os_log_t(*v6);
    objc_claimAutoreleasedReturnValue();
  }

  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    v14 = 0;
    v15 = 0;
    v16 = 47;
    do
    {
      v17 = &aLibraryCachesC_239[v14];
      if (v16 == 47)
      {
        v15 = &aLibraryCachesC_239[v14];
      }

      v16 = v17[1];
      if (!v17[1])
      {
        break;
      }
    }

    while (v14++ < 0xFFF);
    if (v15)
    {
      v19 = v15 + 1;
    }

    else
    {
      v19 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Registration.mm";
    }

    *buf = 136315394;
    v21 = v19;
    v22 = 1024;
    v23 = 84;
    _os_log_error_impl(&dword_1DE1F9000, v8, OS_LOG_TYPE_ERROR, "%32s:%-5d Extrinsic_Driver_Connection_To_Server: server proxy connection failed.", buf, 0x12u);
  }

  *(*(*(a1 + 32) + 8) + 24) = 1937010544;
  v9 = v4;
  NSLog(&cfstr_AudiohardwareG.isa);
  NSLog(&cfstr_CodeLd.isa, [(AMCP::Log::AMCP_Scope_Registry *)v9 code]);
  v10 = [(AMCP::Log::AMCP_Scope_Registry *)v9 localizedDescription];
  NSLog(&cfstr_Description.isa, v10);

  v11 = [(AMCP::Log::AMCP_Scope_Registry *)v9 localizedFailureReason];
  NSLog(&cfstr_Reason.isa, v11);

  v12 = [(AMCP::Log::AMCP_Scope_Registry *)v9 localizedRecoverySuggestion];
  NSLog(&cfstr_Suggestion.isa, v12);

  v13 = *MEMORY[0x1E69E9840];
}

void std::vector<std::pair<Core_Audio_Driver * {__strong},std::function<void ()(void)>>>::__base_destruct_at_end[abi:ne200100](uint64_t a1, uint64_t a2)
{
  for (i = *(a1 + 8); i != a2; i -= 40)
  {
    std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](i - 32);
    v5 = *(i - 40);
  }

  *(a1 + 8) = a2;
}

uint64_t ___ZZN37Extrinsic_Driver_Connection_To_Server28_create_connection_to_serverEvENK3__0cvU13block_pointerFvvEEv_block_invoke(id *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v2 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
  if ((v2 & 1) == 0)
  {
    AMCP::Log::AMCP_Scope_Registry::initialize(a1);
  }

  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v4 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    v5 = *v3;
    AMCP::Log::Scope::get_os_log_t(*v3);
    objc_claimAutoreleasedReturnValue();
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  else
  {
    v5 = *v3;
    AMCP::Log::Scope::get_os_log_t(*v3);
    objc_claimAutoreleasedReturnValue();
  }

  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    v8 = 0;
    v9 = 0;
    v10 = 47;
    do
    {
      v11 = &aLibraryCachesC_239[v8];
      if (v10 == 47)
      {
        v9 = &aLibraryCachesC_239[v8];
      }

      v10 = v11[1];
      if (!v11[1])
      {
        break;
      }
    }

    while (v8++ < 0xFFF);
    if (v9)
    {
      v13 = v9 + 1;
    }

    else
    {
      v13 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Registration.mm";
    }

    v14 = 136315394;
    v15 = v13;
    v16 = 1024;
    v17 = 119;
    _os_log_error_impl(&dword_1DE1F9000, v5, OS_LOG_TYPE_ERROR, "%32s:%-5d HAL Server Connection Interrupted", &v14, 0x12u);
  }

  result = [a1[4] invalidate];
  v7 = *MEMORY[0x1E69E9840];
  return result;
}

void ___ZZN37Extrinsic_Driver_Connection_To_Server28_create_connection_to_serverEvENK3__2cvU13block_pointerFvvEEv_block_invoke(AMCP::Log::AMCP_Scope_Registry *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v2 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
  if ((v2 & 1) == 0)
  {
    AMCP::Log::AMCP_Scope_Registry::initialize(a1);
  }

  v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
  v4 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    v5 = *v3;
    AMCP::Log::Scope::get_os_log_t(*v3);
    objc_claimAutoreleasedReturnValue();
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  else
  {
    v5 = *v3;
    AMCP::Log::Scope::get_os_log_t(*v3);
    objc_claimAutoreleasedReturnValue();
  }

  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    v10 = 0;
    v11 = 0;
    v12 = 47;
    do
    {
      v13 = &aLibraryCachesC_239[v10];
      if (v12 == 47)
      {
        v11 = &aLibraryCachesC_239[v10];
      }

      v12 = v13[1];
      if (!v13[1])
      {
        break;
      }
    }

    while (v10++ < 0xFFF);
    if (v11)
    {
      v15 = v11 + 1;
    }

    else
    {
      v15 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Registration.mm";
    }

    *v16 = 136315394;
    *&v16[4] = v15;
    *&v16[12] = 1024;
    *&v16[14] = 136;
    _os_log_error_impl(&dword_1DE1F9000, v5, OS_LOG_TYPE_ERROR, "%32s:%-5d HAL Server Connection Invalidated", v16, 0x12u);
  }

  v6 = *(a1 + 4);
  *v16 = MEMORY[0x1E69E9820];
  *&v16[8] = 3221225472;
  *&v16[16] = ___ZZN37Extrinsic_Driver_Connection_To_Server28_create_connection_to_serverEvENK3__1clEv_block_invoke;
  v17 = &__block_descriptor_40_e5_v8__0l;
  v18 = v6;
  v7 = *(v6 + 32);
  v8 = AMCP::Log::Scope::get_os_log_t(v7);
  dispatch_async(v8, v16);

  v9 = *MEMORY[0x1E69E9840];
}

void ___ZZN37Extrinsic_Driver_Connection_To_Server28_create_connection_to_serverEvENK3__1clEv_block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = *v1;
  v3 = v1[1];
  if (*v1 != v3)
  {
    do
    {
      v4 = *(v2 + 32);
      if (!v4)
      {
        std::__throw_bad_function_call[abi:ne200100]();
      }

      (*(*v4 + 48))(v4);
      v2 += 40;
    }

    while (v2 != v3);
    v2 = *v1;
  }

  std::vector<std::pair<Core_Audio_Driver * {__strong},std::function<void ()(void)>>>::__base_destruct_at_end[abi:ne200100](v1, v2);
  v5 = v1[3];
  v1[3] = 0;
}

id __copy_helper_block_ea8_32c83_ZTSKZN37Extrinsic_Driver_Connection_To_Server28_create_connection_to_serverEvE3__0(uint64_t a1, uint64_t a2)
{
  result = *(a2 + 32);
  *(a1 + 32) = result;
  return result;
}

uint64_t AudioServerPlugInRegisterRemote(uint64_t a1, void *a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a2;
  v5 = AMCP::Feature_Flags::access_host_asp_oop(0, v4);
  if (v5)
  {
    {
      if (v5)
      {
        qword_1EE013918 = 0;
        AudioServerPlugInRegisterRemote::connection = 0u;
        unk_1EE013908 = 0u;
        qword_1EE013918 = dispatch_queue_create("Extrinsic connection queue", 0);
      }
    }

    v6 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v6 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(v5);
    }

    v7 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v8 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      v9 = *v7;
      AMCP::Log::Scope::get_os_log_t(*v7);
      objc_claimAutoreleasedReturnValue();
      std::__shared_weak_count::__release_shared[abi:ne200100](v8);
    }

    else
    {
      v9 = *v7;
      AMCP::Log::Scope::get_os_log_t(*v7);
      objc_claimAutoreleasedReturnValue();
    }

    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v11 = 0;
      v12 = 0;
      v13 = 47;
      do
      {
        v14 = &aLibraryCachesC_239[v11];
        if (v13 == 47)
        {
          v12 = &aLibraryCachesC_239[v11];
        }

        v13 = v14[1];
        if (!v14[1])
        {
          break;
        }
      }

      while (v11++ < 0xFFF);
      if (v12)
      {
        v16 = v12 + 1;
      }

      else
      {
        v16 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Registration.mm";
      }

      *buf = 136315650;
      v21 = v16;
      v22 = 1024;
      v23 = 237;
      v24 = 2048;
      v25 = a1;
      _os_log_impl(&dword_1DE1F9000, v9, OS_LOG_TYPE_DEFAULT, "%32s:%-5d Registering new remote driver connection, driver interface %p", buf, 0x1Cu);
    }

    _Block_copy(v3);
    v19[0] = &unk_1F59921D8;
    v19[2] = v19[1] = a1;
    v19[3] = v19;
    v10 = Extrinsic_Driver_Connection_To_Server::register_new_driver(&AudioServerPlugInRegisterRemote::connection, a1, 0, v19);
    std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](v19);
  }

  else
  {
    v10 = 1970171760;
  }

  v17 = *MEMORY[0x1E69E9840];
  return v10;
}

uint64_t std::__function::__func<AudioServerPlugInRegisterRemote::$_0,std::allocator<AudioServerPlugInRegisterRemote::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "Z31AudioServerPlugInRegisterRemoteE3$_0"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void std::__function::__func<AudioServerPlugInRegisterRemote::$_0,std::allocator<AudioServerPlugInRegisterRemote::$_0>,void ()(void)>::operator()(AMCP::Log::AMCP_Scope_Registry *a1)
{
  v21 = *MEMORY[0x1E69E9840];
  if (*(a1 + 2))
  {
    v2 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
    if ((v2 & 1) == 0)
    {
      AMCP::Log::AMCP_Scope_Registry::initialize(a1);
    }

    v3 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
    v4 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
    if (v4)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      v5 = *v3;
      AMCP::Log::Scope::get_os_log_t(*v3);
      objc_claimAutoreleasedReturnValue();
      std::__shared_weak_count::__release_shared[abi:ne200100](v4);
    }

    else
    {
      v5 = *v3;
      AMCP::Log::Scope::get_os_log_t(*v3);
      objc_claimAutoreleasedReturnValue();
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = 0;
      v9 = 0;
      v10 = 47;
      do
      {
        v11 = &aLibraryCachesC_239[v8];
        if (v10 == 47)
        {
          v9 = &aLibraryCachesC_239[v8];
        }

        v10 = v11[1];
        if (!v11[1])
        {
          break;
        }
      }

      while (v8++ < 0xFFF);
      if (v9)
      {
        v13 = v9 + 1;
      }

      else
      {
        v13 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Registration.mm";
      }

      v14 = *(a1 + 1);
      v15 = 136315650;
      v16 = v13;
      v17 = 1024;
      v18 = 242;
      v19 = 2048;
      v20 = v14;
      _os_log_error_impl(&dword_1DE1F9000, v5, OS_LOG_TYPE_ERROR, "%32s:%-5d Calling the remote driver registration interruption handler, driver interface %p", &v15, 0x1Cu);
    }

    (*(*(a1 + 2) + 16))();
    v6 = *(a1 + 2);
  }

  else
  {
    v6 = 0;
  }

  _Block_release(v6);
  v7 = *MEMORY[0x1E69E9840];
}

void std::__function::__func<AudioServerPlugInRegisterRemote::$_0,std::allocator<AudioServerPlugInRegisterRemote::$_0>,void ()(void)>::destroy_deallocate(id *a1)
{

  operator delete(a1);
}

void *std::__function::__func<AudioServerPlugInRegisterRemote::$_0,std::allocator<AudioServerPlugInRegisterRemote::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  *a2 = &unk_1F59921D8;
  a2[1] = v4;
  result = _Block_copy(v3);
  a2[2] = result;
  return result;
}

void std::__function::__func<AudioServerPlugInRegisterRemote::$_0,std::allocator<AudioServerPlugInRegisterRemote::$_0>,void ()(void)>::~__func(uint64_t a1)
{

  JUMPOUT(0x1E12C1730);
}

uint64_t AudioServerPlugInMain(uint64_t a1, const BOOL *a2)
{
  v139 = *MEMORY[0x1E69E9840];
  if (AMCP::Feature_Flags::access_host_asp_oop(0, a2))
  {
    v119 = 0;
    MainBundle = CFBundleGetMainBundle();
    v3 = MainBundle;
    if (MainBundle)
    {
      CFRetain(MainBundle);
    }

    mcp_applesauce::CF::BasicRef<mcp_applesauce::CF::BundleRef_Traits>::BasicRef(&v118, v3);
    mcp_applesauce::CF::BundleRef_proxy::get_info_dictionary(&v117, v118);
    mcp_applesauce::CF::BundleRef_proxy::get_bundle_id(&cf, v118);
    v4 = cf;
    if (cf)
    {
      CFRetain(cf);
    }

    v115[1] = v4;
    memset(&v124, 0, sizeof(v124));
    Sandbox_Extensions::cache_iokit_registry_token(&v124, "IOUserUserClient");
    if (v4)
    {
      CFRetain(v4);
    }

    v123 = v4;
    if (!v117)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    *buf = 0;
    applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const*>(theArray, v117, @"AudioServerPlugIn_IOKitUserClients", buf);
    if (*buf)
    {
      CFRelease(*buf);
    }

    v5 = theArray[0];
    if (theArray[0])
    {
      Count = CFArrayGetCount(theArray[0]);
      v7 = CFArrayGetCount(v5);
      if (!Count)
      {
        goto LABEL_43;
      }

      v8 = v7;
      for (i = 0; i != Count; ++i)
      {
        if (v8 == i)
        {
          break;
        }

        v10 = applesauce::CF::details::at_to<applesauce::CF::StringRef>(&v113, v5, i);
        if (v113.__vftable)
        {
          v11 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v11 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v10);
          }

          v13 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v12 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v12)
          {
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
            v14 = *v13;
            std::__shared_weak_count::__release_shared[abi:ne200100](v12);
          }

          else
          {
            v14 = *v13;
          }

          if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
          {
            if (!v123)
            {
              v96 = __cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v96, "Could not construct");
              __cxa_throw(v96, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
            }

            applesauce::CF::convert_to<std::string,0>(&v127, v123);
            if (SHIBYTE(v128) >= 0)
            {
              v15 = &v127;
            }

            else
            {
              v15 = v127.__vftable;
            }

            if (!v113.__vftable)
            {
              v95 = __cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v95, "Could not construct");
              __cxa_throw(v95, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
            }

            applesauce::CF::convert_to<std::string,0>(__p, v113.__vftable);
            v16 = __p;
            if (v126 < 0)
            {
              v16 = __p[0];
            }

            *buf = 136315906;
            *&buf[4] = "Audio_Server_PlugIn_Utilities.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 111;
            v135 = 2080;
            *v136 = v15;
            *&v136[8] = 2080;
            *&v136[10] = v16;
            _os_log_impl(&dword_1DE1F9000, v14, OS_LOG_TYPE_INFO, "%32s:%-5d The plug-in named %s requires extending the sandbox for the IOKit user-client class %s.", buf, 0x26u);
            if (v126 < 0)
            {
              operator delete(__p[0]);
            }

            if (SHIBYTE(v128) < 0)
            {
              operator delete(v127.__vftable);
            }
          }

          if (!v113.__vftable)
          {
            v93 = __cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v93, "Could not construct");
            __cxa_throw(v93, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
          }

          applesauce::CF::convert_to<std::string,0>(buf, v113.__vftable);
          if (v136[3] >= 0)
          {
            v17 = buf;
          }

          else
          {
            v17 = *buf;
          }

          Sandbox_Extensions::cache_iokit_registry_token(&v124, v17);
          if ((v136[3] & 0x80000000) != 0)
          {
            operator delete(*buf);
          }

          if (v113.__vftable)
          {
            CFRelease(v113.__vftable);
          }
        }
      }

      v5 = theArray[0];
      if (theArray[0])
      {
LABEL_43:
        CFRelease(v5);
      }
    }

    if (v123)
    {
      CFRelease(v123);
    }

    if (v4)
    {
      CFRetain(v4);
    }

    v122 = v4;
    if (!v117)
    {
      v100 = __cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v100, "Could not construct");
      __cxa_throw(v100, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
    }

    *buf = 0;
    applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const*>(theArray, v117, @"AudioServerPlugIn_MachServices", buf);
    if (*buf)
    {
      CFRelease(*buf);
    }

    v18 = theArray[0];
    if (theArray[0])
    {
      v19 = CFArrayGetCount(theArray[0]);
      v20 = CFArrayGetCount(v18);
      if (!v19)
      {
        goto LABEL_91;
      }

      v21 = v20;
      for (j = 0; j != v19; ++j)
      {
        if (v21 == j)
        {
          break;
        }

        v23 = applesauce::CF::details::at_to<applesauce::CF::StringRef>(&v113, v18, j);
        if (v113.__vftable)
        {
          v24 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v24 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v23);
          }

          v26 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v25 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v25)
          {
            atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
            v27 = *v26;
            std::__shared_weak_count::__release_shared[abi:ne200100](v25);
          }

          else
          {
            v27 = *v26;
          }

          if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
          {
            if (!v122)
            {
              v98 = __cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v98, "Could not construct");
              __cxa_throw(v98, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
            }

            applesauce::CF::convert_to<std::string,0>(&v127, v122);
            if (SHIBYTE(v128) >= 0)
            {
              v28 = &v127;
            }

            else
            {
              v28 = v127.__vftable;
            }

            if (!v113.__vftable)
            {
              v97 = __cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v97, "Could not construct");
              __cxa_throw(v97, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
            }

            applesauce::CF::convert_to<std::string,0>(__p, v113.__vftable);
            v29 = __p;
            if (v126 < 0)
            {
              v29 = __p[0];
            }

            *buf = 136315906;
            *&buf[4] = "Audio_Server_PlugIn_Utilities.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 124;
            v135 = 2080;
            *v136 = v28;
            *&v136[8] = 2080;
            *&v136[10] = v29;
            _os_log_impl(&dword_1DE1F9000, v27, OS_LOG_TYPE_INFO, "%32s:%-5d The plug-in named %s requires extending the sandbox for the mach service named %s.", buf, 0x26u);
            if (v126 < 0)
            {
              operator delete(__p[0]);
            }

            if (SHIBYTE(v128) < 0)
            {
              operator delete(v127.__vftable);
            }
          }

          if (!v113.__vftable)
          {
            v94 = __cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v94, "Could not construct");
            __cxa_throw(v94, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
          }

          applesauce::CF::convert_to<std::string,0>(buf, v113.__vftable);
          v30 = sandbox_extension_issue_mach();
          v31 = v30;
          if ((v136[3] & 0x80000000) != 0)
          {
            operator delete(*buf);
          }

          v127.__vftable = v31;
          if (v31)
          {
            std::vector<char *>::push_back[abi:ne200100](&v124, &v127);
          }

          else
          {
            v32 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
            if ((v32 & 1) == 0)
            {
              AMCP::Log::AMCP_Scope_Registry::initialize(v30);
            }

            v34 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
            v33 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
            if (v33)
            {
              atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
              v35 = *v34;
              std::__shared_weak_count::__release_shared[abi:ne200100](v33);
            }

            else
            {
              v35 = *v34;
            }

            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
            {
              *buf = 136315394;
              *&buf[4] = "Audio_Server_PlugIn_Utilities.cpp";
              *&buf[12] = 1024;
              *&buf[14] = 132;
              _os_log_debug_impl(&dword_1DE1F9000, v35, OS_LOG_TYPE_DEBUG, "%32s:%-5d sandbox_extension_issue_mach not granted.", buf, 0x12u);
            }
          }

          if (v113.__vftable)
          {
            CFRelease(v113.__vftable);
          }
        }
      }

      v18 = theArray[0];
      if (theArray[0])
      {
LABEL_91:
        CFRelease(v18);
      }
    }

    if (v122)
    {
      CFRelease(v122);
    }

    *buf = 0;
    v37 = sandbox_init("com.apple.audio.coreaudiod", 1uLL, buf);
    if (v37 == -1)
    {
      fprintf(*MEMORY[0x1E69E9848], "sandbox_init: %s\n", *buf);
      sandbox_free_error(*buf);
    }

    else
    {
      size = v124.__r_.__value_.__l.__size_;
      for (k = v124.__r_.__value_.__r.__words[0]; k != size; ++k)
      {
        v40 = *k;
        if (sandbox_extension_consume() == -1)
        {
          v41 = __error();
          v42 = *v41;
          v43 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
          if ((v43 & 1) == 0)
          {
            AMCP::Log::AMCP_Scope_Registry::initialize(v41);
          }

          v45 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
          v44 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
          if (v44)
          {
            atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
            v46 = *v45;
            std::__shared_weak_count::__release_shared[abi:ne200100](v44);
          }

          else
          {
            v46 = *v45;
          }

          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
            *buf = 136315650;
            *&buf[4] = "Audio_Server_PlugIn_Utilities.cpp";
            *&buf[12] = 1024;
            *&buf[14] = 146;
            v135 = 1024;
            *v136 = v42;
            _os_log_debug_impl(&dword_1DE1F9000, v46, OS_LOG_TYPE_DEBUG, "%32s:%-5d sandbox_extension_consume failed with errno = %d", buf, 0x18u);
          }
        }

        free(v40);
      }
    }

    if (v124.__r_.__value_.__r.__words[0])
    {
      operator delete(v124.__r_.__value_.__l.__data_);
    }

    if (v4)
    {
      CFRelease(v4);
    }

    if (v37 == -1)
    {
      if (cf)
      {
        CFRelease(cf);
      }

      if (v117)
      {
        CFRelease(v117);
      }

      if (v118)
      {
        CFRelease(v118);
      }

      result = 1;
    }

    else
    {
      mcp_applesauce::CF::BundleRef_proxy::get_bundle_url(v115, v118);
      v47 = v115[0];
      if (v115[0])
      {
        CFRetain(v115[0]);
      }

      v114 = v47;
      v48 = CFPlugInCreate(0, v47);
      v49 = mcp_applesauce::CF::BasicRef<mcp_applesauce::CF::PlugInRef_Traits>::BasicRef(&v113, v48);
      if (!v113.__vftable)
      {
        v69 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v69 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(v49);
        }

        v71 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v70 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v70)
        {
          atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
          v72 = *v71;
          std::__shared_weak_count::__release_shared[abi:ne200100](v70);
        }

        else
        {
          v72 = *v71;
        }

        if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
        {
          *buf = 136315650;
          *&buf[4] = "Audio_Server_PlugIn_Utilities.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 47;
          v135 = 2080;
          *v136 = "!plugin.is_valid()";
          _os_log_error_impl(&dword_1DE1F9000, v72, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s No plug-in", buf, 0x1Cu);
        }

        AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v123);
        __cxa_allocate_exception(0x40uLL);
        std::runtime_error::runtime_error(theArray, "No plug-in");
        std::runtime_error::runtime_error(&v127, theArray);
        v129 = 0;
        v130 = 0;
        v131 = 0;
        v132 = -1;
        v127.__vftable = &unk_1F5992170;
        v128 = &unk_1F5992198;
        boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::clone_impl(buf, &v127);
        *&v136[12] = "AudioServerPlugInDriverRef get_asp_interface(AMCP::CF::URL)";
        v137 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Utilities.cpp";
        v138 = 47;
        applesauce::backtrace::snapshot_N<64>::snapshot_N(&v124);
      }

      v50 = CFUUIDGetConstantUUIDWithBytes(0, 0x44u, 0x3Au, 0xBAu, 0xB8u, 0xE7u, 0xB3u, 0x49u, 0x1Au, 0xB9u, 0x85u, 0xBEu, 0xB9u, 0x18u, 0x70u, 0x30u, 0xDBu);
      mcp_applesauce::CF::PlugInRef_proxy::find_factories_for_type(&v123, v113.__vftable, v50);
      if (!v123)
      {
        v73 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v73 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(0);
        }

        v75 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v74 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v74)
        {
          atomic_fetch_add_explicit(&v74->__shared_owners_, 1uLL, memory_order_relaxed);
          v76 = *v75;
          std::__shared_weak_count::__release_shared[abi:ne200100](v74);
        }

        else
        {
          v76 = *v75;
        }

        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        {
          *buf = 136315650;
          *&buf[4] = "Audio_Server_PlugIn_Utilities.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 49;
          v135 = 2080;
          *v136 = "!factory_array.is_valid()";
          _os_log_error_impl(&dword_1DE1F9000, v76, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s No factories array", buf, 0x1Cu);
        }

        AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v122);
        __cxa_allocate_exception(0x40uLL);
        std::runtime_error::runtime_error(theArray, "No factories array");
        std::runtime_error::runtime_error(&v127, theArray);
        v129 = 0;
        v130 = 0;
        v131 = 0;
        v132 = -1;
        v127.__vftable = &unk_1F5992170;
        v128 = &unk_1F5992198;
        boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::clone_impl(buf, &v127);
        *&v136[12] = "AudioServerPlugInDriverRef get_asp_interface(AMCP::CF::URL)";
        v137 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Utilities.cpp";
        v138 = 49;
        applesauce::backtrace::snapshot_N<64>::snapshot_N(&v124);
      }

      if (!CFArrayGetCount(v123))
      {
        v77 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v77 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(0);
        }

        v79 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v78 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v78)
        {
          atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
          v80 = *v79;
          std::__shared_weak_count::__release_shared[abi:ne200100](v78);
        }

        else
        {
          v80 = *v79;
        }

        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
        {
          *buf = 136315650;
          *&buf[4] = "Audio_Server_PlugIn_Utilities.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 50;
          v135 = 2080;
          *v136 = "factory_array->get_size() == 0";
          _os_log_error_impl(&dword_1DE1F9000, v80, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s No factories", buf, 0x1Cu);
        }

        AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v122);
        __cxa_allocate_exception(0x40uLL);
        std::runtime_error::runtime_error(theArray, "No factories");
        std::runtime_error::runtime_error(&v127, theArray);
        v129 = 0;
        v130 = 0;
        v131 = 0;
        v132 = -1;
        v127.__vftable = &unk_1F5992170;
        v128 = &unk_1F5992198;
        boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::clone_impl(buf, &v127);
        *&v136[12] = "AudioServerPlugInDriverRef get_asp_interface(AMCP::CF::URL)";
        v137 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Utilities.cpp";
        v138 = 50;
        applesauce::backtrace::snapshot_N<64>::snapshot_N(&v124);
      }

      if (!v123)
      {
        v101 = __cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v101, "Could not construct");
        __cxa_throw(v101, MEMORY[0x1E69E5408], MEMORY[0x1E69E5288]);
      }

      v51 = applesauce::CF::details::at_to<applesauce::CF::TypeRef>(&v122, v123, 0);
      v52 = v122;
      if (!v122)
      {
        v81 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v81 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(v51);
        }

        v83 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v82 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v82)
        {
          atomic_fetch_add_explicit(&v82->__shared_owners_, 1uLL, memory_order_relaxed);
          v84 = *v83;
          std::__shared_weak_count::__release_shared[abi:ne200100](v82);
        }

        else
        {
          v84 = *v83;
        }

        if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
        {
          *buf = 136315650;
          *&buf[4] = "Audio_Server_PlugIn_Utilities.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 53;
          v135 = 2080;
          *v136 = "!factory_uuid.is_valid()";
          _os_log_error_impl(&dword_1DE1F9000, v84, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s Couldn't get the factory uuid", buf, 0x1Cu);
        }

        AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v121);
        __cxa_allocate_exception(0x40uLL);
        std::runtime_error::runtime_error(theArray, "Couldn't find the factory uuid");
        std::runtime_error::runtime_error(&v127, theArray);
        v129 = 0;
        v130 = 0;
        v131 = 0;
        v132 = -1;
        v127.__vftable = &unk_1F5992170;
        v128 = &unk_1F5992198;
        boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::clone_impl(buf, &v127);
        *&v136[12] = "AudioServerPlugInDriverRef get_asp_interface(AMCP::CF::URL)";
        v137 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Utilities.cpp";
        v138 = 53;
        applesauce::backtrace::snapshot_N<64>::snapshot_N(&v124);
      }

      v53 = CFUUIDGetConstantUUIDWithBytes(0, 0x44u, 0x3Au, 0xBAu, 0xB8u, 0xE7u, 0xB3u, 0x49u, 0x1Au, 0xB9u, 0x85u, 0xBEu, 0xB9u, 0x18u, 0x70u, 0x30u, 0xDBu);
      v54 = CFPlugInInstanceCreate(0, v52, v53);
      v55 = v54;
      if (!v54)
      {
        v85 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v85 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(0);
        }

        v87 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v86 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v86)
        {
          atomic_fetch_add_explicit(&v86->__shared_owners_, 1uLL, memory_order_relaxed);
          v88 = *v87;
          std::__shared_weak_count::__release_shared[abi:ne200100](v86);
        }

        else
        {
          v88 = *v87;
        }

        if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
        {
          *buf = 136315650;
          *&buf[4] = "Audio_Server_PlugIn_Utilities.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 56;
          v135 = 2080;
          *v136 = "(iunknown_interface) == nullptr";
          _os_log_error_impl(&dword_1DE1F9000, v88, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s Couldn't create the IUnknown interface", buf, 0x1Cu);
        }

        AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v121);
        __cxa_allocate_exception(0x40uLL);
        std::runtime_error::runtime_error(theArray, "Couldn't create the IUnknown interface");
        std::runtime_error::runtime_error(&v127, theArray);
        v129 = 0;
        v130 = 0;
        v131 = 0;
        v132 = -1;
        v127.__vftable = &unk_1F5992170;
        v128 = &unk_1F5992198;
        boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::clone_impl(buf, &v127);
        *&v136[12] = "AudioServerPlugInDriverRef get_asp_interface(AMCP::CF::URL)";
        v137 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Utilities.cpp";
        v138 = 56;
        applesauce::backtrace::snapshot_N<64>::snapshot_N(&v124);
      }

      v121 = 0;
      v56 = *(*v54 + 8);
      v57 = CFUUIDGetConstantUUIDWithBytes(0, 0xEEu, 0xA5u, 0x77u, 0x3Du, 0xCCu, 0x43u, 0x49u, 0xF1u, 0x8Eu, 0, 0x8Fu, 0x96u, 0xE7u, 0xD2u, 0x3Bu, 0x17u);
      v58 = CFUUIDGetUUIDBytes(v57);
      v59 = v56(v55, *&v58.byte0, *&v58.byte8, &v121);
      v60 = v121;
      if (!v121)
      {
        v89 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v89 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(v59);
        }

        v91 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v90 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v90)
        {
          atomic_fetch_add_explicit(&v90->__shared_owners_, 1uLL, memory_order_relaxed);
          v92 = *v91;
          std::__shared_weak_count::__release_shared[abi:ne200100](v90);
        }

        else
        {
          v92 = *v91;
        }

        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
        {
          *buf = 136315650;
          *&buf[4] = "Audio_Server_PlugIn_Utilities.cpp";
          *&buf[12] = 1024;
          *&buf[14] = 61;
          v135 = 2080;
          *v136 = "(asp_interface) == nullptr";
          _os_log_error_impl(&dword_1DE1F9000, v92, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s Couldn't find the driver interface", buf, 0x1Cu);
        }

        AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v120);
        __cxa_allocate_exception(0x40uLL);
        std::runtime_error::runtime_error(theArray, "Couldn't find the driver interface");
        std::runtime_error::runtime_error(&v127, theArray);
        v129 = 0;
        v130 = 0;
        v131 = 0;
        v132 = -1;
        v127.__vftable = &unk_1F5992170;
        v128 = &unk_1F5992198;
        boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::clone_impl(buf, &v127);
        *&v136[12] = "AudioServerPlugInDriverRef get_asp_interface(AMCP::CF::URL)";
        v137 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Utilities.cpp";
        v138 = 61;
        applesauce::backtrace::snapshot_N<64>::snapshot_N(&v124);
      }

      (*(*v55 + 24))(v55);
      CFRelease(v52);
      if (v123)
      {
        CFRelease(v123);
      }

      if (v113.__vftable)
      {
        CFRelease(v113.__vftable);
      }

      if (v47)
      {
        CFRelease(v47);
      }

      v62 = AMCP::Feature_Flags::access_host_asp_oop(0, v61);
      if ((v62 & 1) == 0)
      {
        goto LABEL_207;
      }

      {
        qword_1ECDAF008 = 0;
        AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::connection = 0u;
        unk_1ECDAEFF8 = 0u;
        qword_1ECDAF008 = dispatch_queue_create("Extrinsic connection queue", 0);
      }

      v63 = _Block_copy(&__block_literal_global_21586);
      *buf = &unk_1F5992008;
      *&buf[8] = v63;
      *&v136[4] = buf;
      v64 = Extrinsic_Driver_Connection_To_Server::register_new_driver(&AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::connection, v60, 1, buf);
      v62 = std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](buf);
      if (v64)
      {
LABEL_207:
        v102 = atomic_load(StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics_initialized);
        if ((v102 & 1) == 0)
        {
          AMCP::Log::AMCP_Scope_Registry::initialize(v62);
        }

        v103 = **StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics;
        v104 = *(*StaticContainer<AMCP::Log::AMCP_Scope_Registry_Statics>::s_statics + 8);
        if (v104)
        {
          atomic_fetch_add_explicit(&v104->__shared_owners_, 1uLL, memory_order_relaxed);
          v105 = *v103;
          AMCP::Log::Scope::get_os_log_t(*v103);
          objc_claimAutoreleasedReturnValue();
          std::__shared_weak_count::__release_shared[abi:ne200100](v104);
        }

        else
        {
          v105 = *v103;
          AMCP::Log::Scope::get_os_log_t(*v103);
          objc_claimAutoreleasedReturnValue();
        }

        if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
        {
          v106 = 0;
          v107 = 0;
          v108 = 47;
          do
          {
            v109 = &aLibraryCachesC_239[v106];
            if (v108 == 47)
            {
              v107 = &aLibraryCachesC_239[v106];
            }

            v108 = v109[1];
            if (!v109[1])
            {
              break;
            }
          }

          while (v106++ < 0xFFF);
          if (v107)
          {
            v111 = v107 + 1;
          }

          else
          {
            v111 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Registration.mm";
          }

          *buf = 136315650;
          *&buf[4] = v111;
          *&buf[12] = 1024;
          *&buf[14] = 302;
          v135 = 2080;
          *v136 = "(status) != 0";
          _os_log_error_impl(&dword_1DE1F9000, v105, OS_LOG_TYPE_ERROR, "%32s:%-5d Throwing Exception: %s Error registering remote", buf, 0x1Cu);
        }

        AMCP::Utility::With_Realtime_Disabled::With_Realtime_Disabled(&v123);
        __cxa_allocate_exception(0x40uLL);
        caulk::make_string("Error registering remote", &v124);
        std::runtime_error::runtime_error(&v113, &v124);
        std::runtime_error::runtime_error(&v127, &v113);
        v129 = 0;
        v130 = 0;
        v131 = 0;
        v132 = -1;
        v127.__vftable = &unk_1F5992170;
        v128 = &unk_1F5992198;
        boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::clone_impl(buf, &v127);
        *&v136[12] = "int AudioServerPlugInMain(int, char ** _Nullable)";
        v137 = "/Library/Caches/com.apple.xbs/Sources/AudioHAL/MCP/AMCP/ASP/Portal/Audio_Server_PlugIn_Registration.mm";
        v138 = 302;
        applesauce::backtrace::snapshot_N<64>::snapshot_N(theArray);
      }

      get_signal_port();
      v65 = MEMORY[0x1E69E96A0];
      v66 = MEMORY[0x1E69E96A0];
      v133[0] = &unk_1F59923E8;
      v133[1] = &v119;
      v133[3] = v133;
      *buf = v65;
      AMCP::Utility::Mach_Port::set_receive_handler(&get_signal_port(void)::s_signal_port, buf, v133);
      std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](v133);

      *buf = signal_handler;
      *&buf[8] = 0x200000000;
      sigaction(13, buf, 0);
      sigaction(15, buf, 0);
      v67 = *MEMORY[0x1E695E8D8];
      while ((v119 & 1) == 0)
      {
        CFRunLoopRunInMode(v67, 1.0e10, 0);
      }

      if (v115[0])
      {
        CFRelease(v115[0]);
      }

      if (cf)
      {
        CFRelease(cf);
      }

      if (v117)
      {
        CFRelease(v117);
      }

      if (v118)
      {
        CFRelease(v118);
      }

      result = 0;
    }
  }

  else
  {
    result = 1970171760;
  }

  v68 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1DE751F94(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, std::runtime_error a19, uint64_t a20, const void *a21, uint64_t a22, const void *a23, const void *a24, const void *a25, uint64_t a26, uint64_t a27, uint64_t a28, __int16 a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, void *__p, uint64_t a38, uint64_t a39, void *a40)
{
  if (a2)
  {
    if (__p)
    {
      a38 = __p;
      operator delete(__p);
    }

    if (a15)
    {
      operator delete(a15);
    }

    boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error>>::~clone_impl(v42 - 192);
    boost::exception_detail::error_info_injector<std::runtime_error>::~error_info_injector(&a40);
    std::runtime_error::~runtime_error(&a19);
    if (a35 < 0)
    {
      operator delete(a30);
    }

    if (v41)
    {
      __cxa_free_exception(v40);
    }

    AMCP::Utility::With_Realtime_Disabled::~With_Realtime_Disabled(&a29);
    applesauce::CF::URLRef::~URLRef(&a21);
    applesauce::CF::StringRef::~StringRef(&a23);
    applesauce::CF::DictionaryRef::~DictionaryRef(&a24);
    mcp_applesauce::CF::BasicRef<mcp_applesauce::CF::BundleRef_Traits>::~BasicRef(&a25);
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1DE750F08);
  }

  _Unwind_Resume(a1);
}

void get_signal_port(void)
{
  {
    if (v0)
    {
      get_signal_port(void)::s_signal_port = AMCP::Utility::Mach_Port::create_port(v0);
      word_1ECDAF01C = 257;
      qword_1ECDAF020 = 850045863;
      xmmword_1ECDAF028 = 0u;
      unk_1ECDAF038 = 0u;
      xmmword_1ECDAF048 = 0u;
      unk_1ECDAF058 = 0u;
    }
  }
}

void signal_handler(mach_msg_id_t a1)
{
  get_signal_port();
  msg.msgh_id = a1;
  if (get_signal_port(void)::s_signal_port)
  {
    *&msg.msgh_bits = 0x1800000013;
    msg.msgh_local_port = 0;
    msg.msgh_voucher_port = 0;
    msg.msgh_remote_port = get_signal_port(void)::s_signal_port;
    if (mach_msg(&msg, 1, 0x18u, 0, 0, 0, 0))
    {
      if ((msg.msgh_bits & 0x1F) != 0x13)
      {
        mach_port_deallocate(*MEMORY[0x1E69E9A60], msg.msgh_remote_port);
      }
    }
  }
}

uint64_t std::__function::__func<AudioServerPlugInMain::$_0,std::allocator<AudioServerPlugInMain::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "Z21AudioServerPlugInMainE3$_0"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void std::__function::__func<AudioServerPlugInMain::$_0,std::allocator<AudioServerPlugInMain::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  get_signal_port();
  if (!AMCP::Utility::Mach_Port::receive_message(get_signal_port(void)::s_signal_port, 0x20u, &v3, 0) && (v3.msgh_id | 2) == 0xF)
  {
    **(a1 + 8) = 1;
    Main = CFRunLoopGetMain();
    CFRunLoopStop(Main);
  }
}

uint64_t std::__function::__func<AudioServerPlugInMain::$_0,std::allocator<AudioServerPlugInMain::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F59923E8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::$_0,std::allocator<AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "ZL49AudioServerPlugInRegisterRemoteUsingDriverServicePP32AudioServerPlugInDriverInterfaceU13block_pointerFvvEE3$_0"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void std::__function::__func<AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::$_0,std::allocator<AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  v2 = *(a1 + 8);
  if (v2)
  {
    v2[2]();
    v2 = *(a1 + 8);
  }

  _Block_release(v2);
}

void std::__function::__func<AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::$_0,std::allocator<AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::$_0>,void ()(void)>::destroy_deallocate(id *a1)
{

  operator delete(a1);
}

void *std::__function::__func<AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::$_0,std::allocator<AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F5992008;
  result = _Block_copy(*(a1 + 8));
  a2[1] = result;
  return result;
}

void std::__function::__func<AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::$_0,std::allocator<AudioServerPlugInRegisterRemoteUsingDriverService(AudioServerPlugInDriverInterface **,void({block_pointer})(void))::$_0>,void ()(void)>::~__func(uint64_t a1)
{

  JUMPOUT(0x1E12C1730);
}

CFGregorianDate CFAbsoluteTimeGetGregorianDate(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  v2 = MEMORY[0x1EEDB65B0](tz, at);
  result.second = v3;
  result.year = v2;
  result.month = BYTE4(v2);
  result.day = BYTE5(v2);
  result.hour = BYTE6(v2);
  result.minute = HIBYTE(v2);
  return result;
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  v1 = MEMORY[0x1EEDB7E78](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

uint64_t applesauce::xpc::dyn_cast_or_default(applesauce::xpc *this, const object *a2)
{
  return MEMORY[0x1EEDEE358](this, a2);
}

{
  return MEMORY[0x1EEDEE360](this, a2);
}

uint64_t caulk::ipc::synchronous_messenger::eventlink_receiver::start()
{
  return MEMORY[0x1EEE5FB20]();
}

{
  return MEMORY[0x1EEE5FB28]();
}

uint64_t caulk::ipc::synchronous_messenger::semaphore_receiver::start()
{
  return MEMORY[0x1EEE5FB40]();
}

{
  return MEMORY[0x1EEE5FB48]();
}

uint64_t caulk::mach::os_workgroup_interval_managed::make_with_workload_id()
{
  return MEMORY[0x1EEE5FBB0]();
}

{
  return MEMORY[0x1EEE5FBB8]();
}

void std::domain_error::~domain_error(std::domain_error *this)
{
  MEMORY[0x1EEE63AD0](this);
}

{
  MEMORY[0x1EEE63AD8](this);
}

void std::out_of_range::~out_of_range(std::out_of_range *this)
{
  MEMORY[0x1EEE63AF0](this);
}

{
  MEMORY[0x1EEE63AF8](this);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return MEMORY[0x1EEE63B20](this, a2);
}

{
  return MEMORY[0x1EEE63B38](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::string *a2)
{
  return MEMORY[0x1EEE63B28](this, a2);
}

{
  return MEMORY[0x1EEE63B40](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
  MEMORY[0x1EEE63B50](this);
}

{
  MEMORY[0x1EEE63B58](this);
}

void std::system_error::~system_error(std::system_error *this)
{
  MEMORY[0x1EEE63D60](this);
}

{
  MEMORY[0x1EEE63D68](this);
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1EEE63EA0]();
}

{
  return MEMORY[0x1EEE63EB0]();
}

{
  return MEMORY[0x1EEE63EB8]();
}

{
  return MEMORY[0x1EEE63EC8]();
}

{
  return MEMORY[0x1EEE63ED0]();
}

{
  return MEMORY[0x1EEE63ED8]();
}

{
  return MEMORY[0x1EEE63EE8]();
}

uint64_t std::to_chars(std::__1 *this, char *a2, char *a3, double a4)
{
  return MEMORY[0x1EEE64438](this, a2, a3, a4);
}

{
  return MEMORY[0x1EEE64450](this, a2, a3, a4);
}

uint64_t std::to_chars()
{
  return MEMORY[0x1EEE64440]();
}

{
  return MEMORY[0x1EEE64448]();
}

{
  return MEMORY[0x1EEE64458]();
}

{
  return MEMORY[0x1EEE64460]();
}

{
  return MEMORY[0x1EEE64470]();
}

{
  return MEMORY[0x1EEE64478]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, uint64_t __val)
{
  return MEMORY[0x1EEE644C0](retstr, __val);
}

{
  return MEMORY[0x1EEE644D0](retstr, __val);
}

std::bad_cast *__cdecl std::bad_cast::bad_cast(std::bad_cast *this)
{
  return MEMORY[0x1EEE644E8](this);
}

{
  return MEMORY[0x1EEE644F0](this);
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x1EEE64520](this);
}

{
  MEMORY[0x1EEE64528](this);
}

void operator delete[]()
{
    ;
  }
}

void operator delete(void *__p)
{
    ;
  }
}

void operator delete(void *__p, std::align_val_t a2)
{
    ;
  }
}

void operator delete()
{
    ;
  }
}

void operator new[]()
{
    ;
  }
}

void *__cdecl operator new(size_t __sz)
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, std::align_val_t a2)
{
    ;
  }
}

void operator new()
{
    ;
  }
}

uint64_t CADSPErrorCreate_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED00]();
}

uint64_t CADSPErrorGetCode_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED08]();
}

uint64_t CADSPGraphCalculateExpectedNumberOfOutputPCMFramesWithFlags_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED10]();
}

uint64_t CADSPGraphCreateRemoteProcessingBlockHost_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED18]();
}

uint64_t CADSPGraphCreateWithModel_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED20]();
}

uint64_t CADSPGraphGetLatency_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED28]();
}

uint64_t CADSPGraphGetParameter_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED38]();
}

uint64_t CADSPGraphGetProperty_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED40]();
}

uint64_t CADSPGraphGetPropertyInfo_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED48]();
}

uint64_t CADSPGraphHasParameter_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED58]();
}

uint64_t CADSPGraphHasProperty_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED60]();
}

uint64_t CADSPGraphInitialize_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED68]();
}

uint64_t CADSPGraphIsInitialized_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED70]();
}

uint64_t CADSPGraphLoadStrip_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEED78]();
}

uint64_t CADSPGraphModelCreateMutable_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEDA0]();
}

uint64_t CADSPGraphModelSetSliceDuration_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEDB8]();
}

uint64_t CADSPGraphModelSetSliceDurationCanVary_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEDC0]();
}

uint64_t CADSPGraphProcessPCMData_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEDC8]();
}

uint64_t CADSPGraphReset_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEDD0]();
}

uint64_t CADSPGraphSetParameter_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEDD8]();
}

uint64_t CADSPGraphSetProperty_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEDE0]();
}

uint64_t CADSPLanguageV1InterpreterCreate_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEDE8]();
}

uint64_t CADSPLanguageV1InterpreterInterpretUTF8String_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEDF8]();
}

uint64_t CADSPLanguageV1InterpreterSetPreprocessorMacroDefinitions_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEE00]();
}

uint64_t CADSPRealTimeErrorCreateWithRealTimeSafeAllocator_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEE10]();
}

uint64_t CADSPRealTimeErrorGetCode_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEE18]();
}

uint64_t CADSPRealTimeErrorRelease_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AudioDSPGraph))
  {
    dlopenHelper_AudioDSPGraph(a1);
  }

  return MEMORY[0x1EEDEEE28]();
}

uint64_t RPBServerAddHost_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_RemoteProcessingBlock))
  {
    dlopenHelper_RemoteProcessingBlock(a1);
  }

  return MEMORY[0x1EEE320F8]();
}

uint64_t RPBServerGetSharedInstance_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_RemoteProcessingBlock))
  {
    dlopenHelper_RemoteProcessingBlock(a1);
  }

  return MEMORY[0x1EEE32100]();
}

uint64_t RPBServerRemoveHost_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_RemoteProcessingBlock))
  {
    dlopenHelper_RemoteProcessingBlock(a1);
  }

  return MEMORY[0x1EEE32108]();
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_AudioDSPGraph(double a1)
{
  dlopen("/System/Library/PrivateFrameworks/AudioDSPGraph.framework/AudioDSPGraph", 0);
  atomic_store(1u, &dlopenHelperFlag_AudioDSPGraph);
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_RemoteProcessingBlock(double a1)
{
  dlopen("/System/Library/PrivateFrameworks/RemoteProcessingBlock.framework/RemoteProcessingBlock", 0);
  atomic_store(1u, &dlopenHelperFlag_RemoteProcessingBlock);
  return a1;
}