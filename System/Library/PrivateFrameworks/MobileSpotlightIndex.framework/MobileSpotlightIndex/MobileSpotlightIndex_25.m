uint64_t ZSTD_btGetAllMatches_dictMatchState_4(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, char *a5, _DWORD *a6, unsigned int a7, int a8)
{
  v8 = *(a2 + 8);
  v9 = *(a2 + 44);
  if (v8 + v9 > a4)
  {
    return 0;
  }

  v18 = a4 - v8;
  v19 = a4 - v8;
  if (v9 < a4 - v8)
  {
    do
    {
      LODWORD(v9) = ZSTD_insertBt1(a2, (v8 + v9), a5, v18, 4, 0) + v9;
    }

    while (v9 < v18);
    v8 = *(a2 + 8);
    v19 = a4 - v8;
  }

  *(a2 + 44) = v18;
  if (*(a2 + 260) >= 0xFFFu)
  {
    v20 = 4095;
  }

  else
  {
    v20 = *(a2 + 260);
  }

  v21 = *a4;
  v150 = *(a2 + 252);
  v152 = *(a2 + 96);
  v151 = (-1640531535 * *a4) >> -*(a2 + 248);
  v22 = *(v152 + 4 * v151);
  v167 = *(a2 + 112);
  v149 = -1 << (*(a2 + 244) - 1);
  v23 = *(a2 + 24);
  v156 = (v8 + v23);
  v24 = v19 + v149 + 1;
  if (v19 < ~v149)
  {
    v24 = 0;
  }

  v164 = v24;
  v25 = 1 << *(a2 + 240);
  if (v19 - *(a2 + 28) > v25 && *(a2 + 40) == 0)
  {
    v27 = v19 - v25;
  }

  else
  {
    v27 = *(a2 + 28);
  }

  if (v27 <= 1)
  {
    v28 = 1;
  }

  else
  {
    v28 = v27;
  }

  v165 = v28;
  v169[0] = 0;
  v29 = *(a2 + 232);
  v31 = *v29;
  v30 = *(v29 + 8);
  v32 = *v29 - v30;
  v33 = *(v29 + 28);
  v34 = v27 - v32;
  v146 = *(v29 + 248);
  v147 = v29;
  v35 = ~(-1 << (*(v29 + 244) - 1));
  v162 = v35;
  v145 = v32;
  v36 = v32 + (-1 << (*(v29 + 244) - 1)) + 1;
  if (v32 - v33 <= v35)
  {
    v36 = v33;
  }

  v163 = v36;
  v37 = (a8 - 1);
  v160 = v30;
  v161 = v33;
  v158 = v23;
  v157 = v34;
  result = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    v38 = v19 - v23;
    v39 = v30 - v34;
    v40 = v19 - v33 - v34;
    v41 = (a4 + 1);
    v42 = a5 - 7;
    v154 = a5 - 1;
    v155 = a5 - 3;
    v148 = a4 + 3;
    v143 = v23 + v8 + 8;
    v144 = v39 + 12;
    v43 = a7;
    v153 = v39;
    do
    {
      if (v43 == 3)
      {
        v44 = *a6 - 1;
      }

      else
      {
        v44 = a6[v43];
      }

      v45 = v19 - v44;
      if (v44 - 1 >= v38)
      {
        if (v44 - 1 < v40 && (v45 - v23) <= 0xFFFFFFFC)
        {
          v58 = (v39 + v45);
          if (v21 == *v58)
          {
            v59 = (v58 + 1);
            v60 = &v41[v31 - v59];
            if (v60 >= a5)
            {
              v60 = a5;
            }

            if (v60 - 7 <= v41)
            {
              v63 = v59;
              v64 = (a4 + 1);
              goto LABEL_69;
            }

            if (*v59 == *v41)
            {
              v61 = a1;
              v62 = 0;
              v63 = (v144 + v45);
              v64 = (a4 + 3);
              while (v64 < (v60 - 7))
              {
                v66 = *v63;
                v63 += 8;
                v65 = v66;
                v68 = *v64;
                v64 += 4;
                v67 = v68;
                v62 += 8;
                if (v65 != v68)
                {
                  v69 = v62 + (__clz(__rbit64(v67 ^ v65)) >> 3);
                  a1 = v61;
                  v23 = v158;
                  v39 = v153;
                  goto LABEL_79;
                }
              }

              a1 = v61;
LABEL_69:
              v23 = v158;
              if (v64 < (v60 - 3) && *v63 == *v64)
              {
                v63 += 4;
                v64 += 2;
              }

              if (v64 < (v60 - 1) && *v63 == *v64)
              {
                v63 += 2;
                ++v64;
              }

              if (v64 < v60 && *v63 == *v64)
              {
                v64 = (v64 + 1);
              }

              v39 = v153;
              v69 = v64 - v41;
            }

            else
            {
              v69 = __clz(__rbit64(*v41 ^ *v59)) >> 3;
              v23 = v158;
            }

LABEL_79:
            if (&v59[v69] == v31)
            {
              v71 = &v41[v69];
              if (v42 <= &v41[v69])
              {
                v75 = v156;
                v74 = &v41[v69];
                goto LABEL_89;
              }

              if (*v156 == *v71)
              {
                v72 = a1;
                v73 = 0;
                v74 = (v148 + v69);
                v75 = v143;
                while (v74 < v42)
                {
                  v77 = *v75;
                  v75 += 4;
                  v76 = v77;
                  v79 = *v74;
                  v74 += 4;
                  v78 = v79;
                  v73 += 8;
                  if (v76 != v79)
                  {
                    v74 = (v73 + (__clz(__rbit64(v78 ^ v76)) >> 3));
                    a1 = v72;
                    goto LABEL_99;
                  }
                }

                a1 = v72;
LABEL_89:
                if (v74 < v155 && *v75 == *v74)
                {
                  v75 += 2;
                  v74 += 2;
                }

                if (v74 < v154 && *v75 == *v74)
                {
                  ++v75;
                  ++v74;
                }

                if (v74 < a5 && *v75 == *v74)
                {
                  LODWORD(v74) = v74 + 1;
                }

                LODWORD(v74) = v74 - v71;
              }

              else
              {
                v74 = (__clz(__rbit64(*v71 ^ *v156)) >> 3);
              }

LABEL_99:
              LODWORD(v69) = v74 + v69;
              v39 = v153;
            }

            v70 = v69 + 4;
            goto LABEL_101;
          }
        }
      }

      else if (v45 >= v27 && v21 == *(a4 - v44))
      {
        v47 = -v44;
        v48 = &v41[-v44];
        if (v42 > v41)
        {
          v49 = *v48;
          if (v49 == *v41)
          {
            v50 = 0;
            v48 = v148 + v47;
            v51 = (a4 + 3);
            while (v51 < v42)
            {
              v53 = *v48;
              v48 += 8;
              v52 = v53;
              v55 = *v51;
              v51 += 4;
              v54 = v55;
              v50 += 8;
              if (v52 != v55)
              {
                v56 = v50 + (__clz(__rbit64(v54 ^ v52)) >> 3);
                goto LABEL_65;
              }
            }

LABEL_54:
            if (v51 < v155 && *v48 == *v51)
            {
              v48 += 4;
              v51 += 2;
            }

            if (v51 < v154 && *v48 == *v51)
            {
              v48 += 2;
              ++v51;
            }

            if (v51 < a5 && *v48 == *v51)
            {
              LODWORD(v51) = v51 + 1;
            }

            LODWORD(v56) = v51 - v41;
          }

          else
          {
            v56 = __clz(__rbit64(*v41 ^ v49)) >> 3;
          }

LABEL_65:
          v70 = v56 + 4;
          goto LABEL_101;
        }

        v51 = (a4 + 1);
        goto LABEL_54;
      }

      v70 = 0;
LABEL_101:
      if (v37 < v70)
      {
        v80 = (a1 + 8 * result);
        *v80 = v43 - a7;
        v80[1] = v70;
        result = (result + 1);
        if (v70 > v20)
        {
          return result;
        }

        v37 = v70;
        if (a4 + v70 == a5)
        {
          return result;
        }
      }

      ++v43;
    }

    while (v43 != a7 + 3);
  }

  v81 = (v167 + 8 * (v19 & ~v149));
  v82 = v19 + 9;
  v83 = 1 << v150;
  *(v152 + 4 * v151) = v19;
  if (v22 < v165)
  {
    *v81 = 0;
    v84 = v160;
    v85 = v161;
    goto LABEL_150;
  }

  v86 = 0;
  v87 = 0;
  v88 = v81 + 1;
  v89 = a5 - 7;
  while (1)
  {
    v90 = v86 >= v87 ? v87 : v86;
    v91 = v8 + v22;
    v92 = a4 + v90;
    v93 = (v91 + v90);
    if (v89 <= a4 + v90)
    {
      v96 = (a4 + v90);
    }

    else
    {
      v94 = *v93;
      if (v94 != *v92)
      {
        v101 = __clz(__rbit64(*v92 ^ v94)) >> 3;
        goto LABEL_130;
      }

      v95 = 0;
      v93 = (v8 + 8 + v90 + v22);
      v96 = (a4 + v90 + 8);
      while (v96 < v89)
      {
        v98 = *v93;
        v93 += 4;
        v97 = v98;
        v100 = *v96;
        v96 += 4;
        v99 = v100;
        v95 += 8;
        if (v97 != v100)
        {
          v101 = v95 + (__clz(__rbit64(v99 ^ v97)) >> 3);
          v23 = v158;
          goto LABEL_130;
        }
      }

      v23 = v158;
    }

    if (v96 < (a5 - 3) && *v93 == *v96)
    {
      v93 += 2;
      v96 += 2;
    }

    if (v96 < (a5 - 1) && *v93 == *v96)
    {
      ++v93;
      ++v96;
    }

    if (v96 < a5 && *v93 == *v96)
    {
      v96 = (v96 + 1);
    }

    v101 = v96 - v92;
LABEL_130:
    v102 = v101 + v90;
    if (v102 > v37)
    {
      if (v102 > v82 - v22)
      {
        v82 = v22 + v102;
      }

      v103 = (a1 + 8 * result);
      *v103 = v19 + 2 - v22;
      v103[1] = v102;
      result = (result + 1);
      if (v102 > 0x1000 || a4 + v102 == a5)
      {
        *v88 = 0;
        *v81 = 0;
        goto LABEL_213;
      }

      v37 = v102;
    }

    v105 = (v167 + 8 * (v22 & ~v149));
    if (*(v91 + v102) < *(a4 + v102))
    {
      break;
    }

    *v88 = v22;
    if (v22 <= v164)
    {
      v88 = v169;
      goto LABEL_149;
    }

    v88 = (v167 + 8 * (v22 & ~v149));
    v87 = v102;
LABEL_143:
    if (--v83)
    {
      v22 = *v105;
      if (*v105 >= v165)
      {
        continue;
      }
    }

    goto LABEL_149;
  }

  *v81 = v22;
  if (v22 > v164)
  {
    v81 = v105 + 1;
    v86 = v102;
    ++v105;
    goto LABEL_143;
  }

  v81 = v169;
LABEL_149:
  *v88 = 0;
  *v81 = 0;
  v84 = v160;
  v85 = v161;
  if (v83)
  {
LABEL_150:
    v106 = *(*(v147 + 96) + 4 * ((-1640531535 * *a4) >> -v146));
    if (v106 > v85)
    {
      v107 = 0;
      v108 = 0;
      v109 = *(v147 + 112);
      v110 = a5 - 7;
      v111 = v19 + 2;
      v166 = v84 + 8;
      v168 = a4 + 2;
      v159 = v23 + v8 + 8;
      v112 = v8 + v157;
      while (1)
      {
        if (v107 >= v108)
        {
          v113 = v108;
        }

        else
        {
          v113 = v107;
        }

        v114 = v84 + v106;
        v115 = a4 + v113;
        v116 = (v114 + v113);
        v117 = &v31[a4 - v114];
        if (v117 >= a5)
        {
          v117 = a5;
        }

        if (v117 - 7 <= v115)
        {
          v120 = (v114 + v113);
          v121 = (a4 + v113);
        }

        else
        {
          if (*v116 != *v115)
          {
            v126 = __clz(__rbit64(*v115 ^ *v116)) >> 3;
            v84 = v160;
            goto LABEL_177;
          }

          v118 = a1;
          v119 = 0;
          v120 = (v166 + v113 + v106);
          v121 = (v168 + v113);
          while (v121 < (v117 - 7))
          {
            v123 = *v120;
            v120 += 4;
            v122 = v123;
            v125 = *v121;
            v121 += 4;
            v124 = v125;
            v119 += 8;
            if (v122 != v125)
            {
              v126 = v119 + (__clz(__rbit64(v124 ^ v122)) >> 3);
              a1 = v118;
              v84 = v160;
              goto LABEL_176;
            }
          }

          a1 = v118;
          v84 = v160;
        }

        if (v121 < (v117 - 3) && *v120 == *v121)
        {
          v120 += 2;
          v121 += 2;
        }

        if (v121 < (v117 - 1) && *v120 == *v121)
        {
          ++v120;
          ++v121;
        }

        if (v121 < v117 && *v120 == *v121)
        {
          v121 = (v121 + 1);
        }

        v126 = v121 - v115;
LABEL_176:
        v85 = v161;
LABEL_177:
        if (v116 + v126 == v31)
        {
          v127 = &v115[v126];
          if (v110 > v127)
          {
            if (*v156 == *v127)
            {
              v128 = 0;
              v129 = (v168 + v126 + v113);
              v130 = v159;
              while (v129 < v110)
              {
                v132 = *v130;
                v130 += 4;
                v131 = v132;
                v134 = *v129;
                v129 += 4;
                v133 = v134;
                v128 += 8;
                if (v131 != v134)
                {
                  v135 = v128 + (__clz(__rbit64(v133 ^ v131)) >> 3);
                  v84 = v160;
                  goto LABEL_197;
                }
              }

              v84 = v160;
LABEL_187:
              if (v129 < (a5 - 3) && *v130 == *v129)
              {
                v130 += 2;
                v129 += 2;
              }

              if (v129 < (a5 - 1) && *v130 == *v129)
              {
                ++v130;
                ++v129;
              }

              if (v129 < a5 && *v130 == *v129)
              {
                v129 = (v129 + 1);
              }

              v135 = v129 - v127;
            }

            else
            {
              v135 = __clz(__rbit64(*v127 ^ *v156)) >> 3;
            }

LABEL_197:
            v126 += v135;
            goto LABEL_198;
          }

          v130 = v156;
          v129 = v127;
          goto LABEL_187;
        }

LABEL_198:
        v136 = v126 + v113;
        v137 = v112 + v106;
        if (v136 + v106 < v145)
        {
          v137 = v114;
        }

        if (v136 <= v37)
        {
          goto LABEL_216;
        }

        if (v136 > v82 - (v106 + v157))
        {
          v82 = v106 + v157 + v136;
        }

        v138 = (a1 + 8 * result);
        *v138 = v111 - (v106 + v157);
        v138[1] = v136;
        result = (result + 1);
        if (v136 <= 0x1000)
        {
          v37 = v136;
          if (a4 + v136 != a5)
          {
LABEL_216:
            if (v106 > v163)
            {
              v139 = *(v137 + v136);
              v140 = *(a4 + v136);
              v141 = v139 >= v140;
              v142 = v139 < v140;
              if (v141)
              {
                v108 = v136;
              }

              if (!v141)
              {
                v107 = v136;
              }

              if (--v83)
              {
                v106 = *(v109 + 8 * (v106 & v162) + 4 * v142);
                if (v106 > v85)
                {
                  continue;
                }
              }
            }
          }
        }

        break;
      }
    }
  }

LABEL_213:
  *(a2 + 44) = v82 - 8;
  return result;
}

uint64_t ZSTD_btGetAllMatches_dictMatchState_5(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, char *a5, _DWORD *a6, unsigned int a7, int a8)
{
  v8 = *(a2 + 8);
  v9 = *(a2 + 44);
  if (v8 + v9 > a4)
  {
    return 0;
  }

  v18 = a4 - v8;
  v19 = a4 - v8;
  if (v9 < a4 - v8)
  {
    do
    {
      LODWORD(v9) = ZSTD_insertBt1(a2, (v8 + v9), a5, v18, 5, 0) + v9;
    }

    while (v9 < v18);
    v8 = *(a2 + 8);
    v19 = a4 - v8;
  }

  *(a2 + 44) = v18;
  v20 = *(a2 + 260);
  if (v20 >= 0xFFF)
  {
    v21 = 4095;
  }

  else
  {
    v21 = v20;
  }

  v155 = 0xCF1BBCDCBB000000 * *a4;
  v161 = *(a2 + 96);
  v159 = *(a2 + 252);
  v160 = v155 >> -*(a2 + 248);
  v22 = *(v161 + 4 * v160);
  v23 = *(a2 + 112);
  v158 = -1 << (*(a2 + 244) - 1);
  v24 = *(a2 + 24);
  v166 = (v8 + v24);
  v25 = v19 + v158 + 1;
  if (v19 < ~v158)
  {
    v25 = 0;
  }

  v171 = v25;
  v26 = 1 << *(a2 + 240);
  v27 = v19 - v26;
  if (v19 - *(a2 + 28) <= v26 || *(a2 + 40) != 0)
  {
    v27 = *(a2 + 28);
  }

  if (v27 <= 1)
  {
    v29 = 1;
  }

  else
  {
    v29 = v27;
  }

  v173 = v29;
  v175[0] = 0;
  v30 = *(a2 + 232);
  v32 = *v30;
  v31 = *(v30 + 8);
  v33 = *v30 - v31;
  v34 = *(v30 + 28);
  v35 = v27 - v33;
  v153 = *(v30 + 248);
  v154 = v30;
  v36 = ~(-1 << (*(v30 + 244) - 1));
  v168 = v36;
  v152 = v33;
  v37 = v33 + (-1 << (*(v30 + 244) - 1)) + 1;
  if (v33 - v34 <= v36)
  {
    v37 = v34;
  }

  v169 = v37;
  v38 = (a8 - 1);
  v164 = v24;
  v170 = v31;
  v156 = v34;
  v167 = v27 - v33;
  result = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    v39 = v19 - v24;
    v40 = v31 - v35;
    v41 = v19 - v34 - v35;
    v42 = a4 + 4;
    v43 = a5 - 7;
    v162 = a5 - 1;
    v163 = a5 - 3;
    v151 = v40 + 12;
    v157 = a4 + 12;
    v149 = v24 + v8 + 8;
    for (i = a7; i != a7 + 3; ++i)
    {
      if (i == 3)
      {
        v45 = *a6 - 1;
      }

      else
      {
        v45 = a6[i];
      }

      v46 = v19 - v45;
      if (v45 - 1 >= v39)
      {
        if (v45 - 1 < v41 && (v46 - v24) <= 0xFFFFFFFC)
        {
          v59 = (v40 + v46);
          if (*a4 == *v59)
          {
            v60 = (v59 + 1);
            v61 = a4 + v32 - v59;
            if (v61 >= a5)
            {
              v61 = a5;
            }

            if (v61 - 7 <= v42)
            {
              v74 = v24;
              v62 = a1;
              v63 = v41;
              v64 = v32;
              v65 = v40;
              v67 = v60;
              v68 = a4 + 2;
              goto LABEL_67;
            }

            if (*v60 == *v42)
            {
              v62 = a1;
              v63 = v41;
              v64 = v32;
              v65 = v40;
              v150 = v23;
              v66 = 0;
              v67 = (v151 + v46);
              v68 = a4 + 6;
              while (v68 < (v61 - 7))
              {
                v70 = *v67;
                v67 += 4;
                v69 = v70;
                v72 = *v68;
                v68 += 4;
                v71 = v72;
                v66 += 8;
                if (v69 != v72)
                {
                  v57 = v66 + (__clz(__rbit64(v71 ^ v69)) >> 3);
                  v23 = v150;
                  v40 = v65;
                  v32 = v64;
                  v41 = v63;
                  a1 = v62;
                  v24 = v164;
                  goto LABEL_77;
                }
              }

              v23 = v150;
              v74 = v164;
LABEL_67:
              if (v68 < (v61 - 3) && *v67 == *v68)
              {
                v67 += 2;
                v68 += 2;
              }

              if (v68 < (v61 - 1) && *v67 == *v68)
              {
                ++v67;
                ++v68;
              }

              if (v68 < v61 && *v67 == *v68)
              {
                v68 = (v68 + 1);
              }

              v40 = v65;
              v57 = v68 - v42;
              v32 = v64;
              v41 = v63;
              a1 = v62;
              v24 = v74;
            }

            else
            {
              v57 = __clz(__rbit64(*v42 ^ *v60)) >> 3;
            }

LABEL_77:
            if (v60 + v57 == v32)
            {
              v75 = &v42[v57];
              if (v43 <= &v42[v57])
              {
                v83 = v166;
                v82 = &v42[v57];
                goto LABEL_87;
              }

              if (*v166 == *v75)
              {
                v76 = a1;
                v77 = v41;
                v78 = v21;
                v79 = v32;
                v80 = v40;
                v81 = 0;
                v82 = &v157[v57];
                v83 = v149;
                while (v82 < v43)
                {
                  v85 = *v83;
                  v83 += 4;
                  v84 = v85;
                  v87 = *v82;
                  v82 += 4;
                  v86 = v87;
                  v81 += 8;
                  if (v84 != v87)
                  {
                    v82 = (v81 + (__clz(__rbit64(v86 ^ v84)) >> 3));
                    v40 = v80;
                    v32 = v79;
                    v21 = v78;
                    v41 = v77;
                    a1 = v76;
                    v24 = v164;
                    goto LABEL_97;
                  }
                }

                v40 = v80;
                v32 = v79;
                v21 = v78;
                v41 = v77;
                a1 = v76;
                v24 = v164;
LABEL_87:
                if (v82 < v163 && *v83 == *v82)
                {
                  v83 += 2;
                  v82 += 2;
                }

                if (v82 < v162 && *v83 == *v82)
                {
                  ++v83;
                  ++v82;
                }

                if (v82 < a5 && *v83 == *v82)
                {
                  LODWORD(v82) = v82 + 1;
                }

                LODWORD(v82) = v82 - v75;
              }

              else
              {
                v82 = (__clz(__rbit64(*v75 ^ *v166)) >> 3);
              }

LABEL_97:
              LODWORD(v57) = v82 + v57;
            }

LABEL_98:
            v73 = v57 + 4;
            goto LABEL_99;
          }
        }
      }

      else if (v46 >= v27 && *a4 == *(a4 - v45))
      {
        v48 = -v45;
        v49 = &v42[-v45];
        if (v43 <= v42)
        {
          v52 = a4 + 2;
        }

        else
        {
          v50 = *v49;
          if (v50 != *v42)
          {
            v57 = __clz(__rbit64(*v42 ^ v50)) >> 3;
            goto LABEL_98;
          }

          v51 = 0;
          v49 = &v157[v48];
          v52 = a4 + 6;
          while (v52 < v43)
          {
            v54 = *v49;
            v49 += 8;
            v53 = v54;
            v56 = *v52;
            v52 += 4;
            v55 = v56;
            v51 += 8;
            if (v53 != v56)
            {
              v57 = v51 + (__clz(__rbit64(v55 ^ v53)) >> 3);
              goto LABEL_98;
            }
          }
        }

        if (v52 < v163 && *v49 == *v52)
        {
          v49 += 4;
          v52 += 2;
        }

        if (v52 < v162 && *v49 == *v52)
        {
          v49 += 2;
          ++v52;
        }

        if (v52 < a5 && *v49 == *v52)
        {
          LODWORD(v52) = v52 + 1;
        }

        LODWORD(v57) = v52 - v42;
        goto LABEL_98;
      }

      v73 = 0;
LABEL_99:
      if (v38 < v73)
      {
        v88 = (a1 + 8 * result);
        *v88 = i - a7;
        v88[1] = v73;
        result = (result + 1);
        if (v73 > v21)
        {
          return result;
        }

        v38 = v73;
        if (a4 + v73 == a5)
        {
          return result;
        }
      }
    }
  }

  v89 = (v23 + 8 * (v19 & ~v158));
  v90 = v19 + 9;
  v91 = 1 << v159;
  *(v161 + 4 * v160) = v19;
  if (v22 < v173)
  {
    v174 = a1;
    *v89 = 0;
    goto LABEL_148;
  }

  v92 = 0;
  v93 = 0;
  v94 = v89 + 1;
  v95 = a5 - 7;
  while (1)
  {
    v96 = v92 >= v93 ? v93 : v92;
    v97 = v8 + v22;
    v98 = a4 + v96;
    v99 = (v97 + v96);
    if (v95 <= a4 + v96)
    {
      v103 = (a4 + v96);
    }

    else
    {
      v100 = *v99;
      if (v100 != *v98)
      {
        v108 = __clz(__rbit64(*v98 ^ v100)) >> 3;
        goto LABEL_128;
      }

      v101 = v23;
      v102 = 0;
      v99 = (v8 + 8 + v96 + v22);
      v103 = (a4 + v96 + 8);
      while (v103 < v95)
      {
        v105 = *v99;
        v99 += 4;
        v104 = v105;
        v107 = *v103;
        v103 += 4;
        v106 = v107;
        v102 += 8;
        if (v104 != v107)
        {
          v108 = v102 + (__clz(__rbit64(v106 ^ v104)) >> 3);
          v23 = v101;
          v24 = v164;
          goto LABEL_128;
        }
      }

      v23 = v101;
      v24 = v164;
    }

    if (v103 < (a5 - 3) && *v99 == *v103)
    {
      v99 += 2;
      v103 += 2;
    }

    if (v103 < (a5 - 1) && *v99 == *v103)
    {
      ++v99;
      ++v103;
    }

    if (v103 < a5 && *v99 == *v103)
    {
      v103 = (v103 + 1);
    }

    v108 = v103 - v98;
LABEL_128:
    v109 = v108 + v96;
    if (v109 > v38)
    {
      if (v109 > v90 - v22)
      {
        v90 = v22 + v109;
      }

      v110 = (a1 + 8 * result);
      *v110 = v19 + 2 - v22;
      v110[1] = v109;
      result = (result + 1);
      if (v109 > 0x1000 || a4 + v109 == a5)
      {
        *v94 = 0;
        *v89 = 0;
        goto LABEL_209;
      }

      v38 = v109;
    }

    v112 = (v23 + 8 * (v22 & ~v158));
    if (*(v97 + v109) < *(a4 + v109))
    {
      break;
    }

    *v94 = v22;
    if (v22 <= v171)
    {
      v94 = v175;
      goto LABEL_147;
    }

    v94 = (v23 + 8 * (v22 & ~v158));
    v93 = v109;
LABEL_141:
    if (--v91)
    {
      v22 = *v112;
      if (*v112 >= v173)
      {
        continue;
      }
    }

    goto LABEL_147;
  }

  *v89 = v22;
  if (v22 > v171)
  {
    v89 = v112 + 1;
    v92 = v109;
    ++v112;
    goto LABEL_141;
  }

  v89 = v175;
LABEL_147:
  v174 = a1;
  *v94 = 0;
  *v89 = 0;
  if (v91)
  {
LABEL_148:
    v113 = *(*(v154 + 96) + 4 * (v155 >> -v153));
    if (v113 > v156)
    {
      v114 = 0;
      v115 = 0;
      v116 = *(v154 + 112);
      v117 = a5 - 7;
      v118 = v19 + 2;
      v172 = a4 + 1;
      v165 = v24 + v8 + 8;
      v119 = v8 + v167;
      while (1)
      {
        if (v114 >= v115)
        {
          v120 = v115;
        }

        else
        {
          v120 = v114;
        }

        v121 = v170 + v113;
        v122 = a4 + v120;
        v123 = (v121 + v120);
        v124 = &v32[a4 - v121];
        if (v124 >= a5)
        {
          v124 = a5;
        }

        if (v124 - 7 <= v122)
        {
          v126 = (v121 + v120);
          v127 = (a4 + v120);
        }

        else
        {
          if (*v123 != *v122)
          {
            v132 = __clz(__rbit64(*v122 ^ *v123)) >> 3;
            goto LABEL_173;
          }

          v125 = 0;
          v126 = (v170 + 8 + v120 + v113);
          v127 = (v172 + v120);
          while (v127 < (v124 - 7))
          {
            v129 = *v126;
            v126 += 4;
            v128 = v129;
            v131 = *v127;
            v127 += 4;
            v130 = v131;
            v125 += 8;
            if (v128 != v131)
            {
              v132 = v125 + (__clz(__rbit64(v130 ^ v128)) >> 3);
              goto LABEL_173;
            }
          }
        }

        if (v127 < (v124 - 3) && *v126 == *v127)
        {
          v126 += 2;
          v127 += 2;
        }

        if (v127 < (v124 - 1) && *v126 == *v127)
        {
          ++v126;
          ++v127;
        }

        if (v127 < v124 && *v126 == *v127)
        {
          v127 = (v127 + 1);
        }

        v132 = v127 - v122;
LABEL_173:
        if (v123 + v132 == v32)
        {
          v133 = &v122[v132];
          if (v117 > v133)
          {
            if (*v166 == *v133)
            {
              v134 = 0;
              v135 = (v172 + v132 + v120);
              v136 = v165;
              while (v135 < v117)
              {
                v138 = *v136;
                v136 += 4;
                v137 = v138;
                v140 = *v135;
                v135 += 4;
                v139 = v140;
                v134 += 8;
                if (v137 != v140)
                {
                  v141 = v134 + (__clz(__rbit64(v139 ^ v137)) >> 3);
                  goto LABEL_192;
                }
              }

LABEL_181:
              if (v135 < (a5 - 3) && *v136 == *v135)
              {
                v136 += 2;
                v135 += 2;
              }

              if (v135 < (a5 - 1) && *v136 == *v135)
              {
                ++v136;
                ++v135;
              }

              if (v135 < a5 && *v136 == *v135)
              {
                v135 = (v135 + 1);
              }

              v141 = v135 - v133;
            }

            else
            {
              v141 = __clz(__rbit64(*v133 ^ *v166)) >> 3;
            }

LABEL_192:
            v132 += v141;
            goto LABEL_193;
          }

          v136 = v166;
          v135 = v133;
          goto LABEL_181;
        }

LABEL_193:
        v142 = v132 + v120;
        if (v142 + v113 >= v152)
        {
          v143 = v119 + v113;
        }

        else
        {
          v143 = v170 + v113;
        }

        if (v142 <= v38)
        {
          goto LABEL_212;
        }

        if (v142 > v90 - (v113 + v167))
        {
          v90 = v113 + v167 + v142;
        }

        v144 = (v174 + 8 * result);
        *v144 = v118 - (v113 + v167);
        v144[1] = v142;
        result = (result + 1);
        if (v142 <= 0x1000)
        {
          v38 = v142;
          if (a4 + v142 != a5)
          {
LABEL_212:
            if (v113 > v169)
            {
              v145 = *(v143 + v142);
              v146 = *(a4 + v142);
              v147 = v145 >= v146;
              v148 = v145 < v146;
              if (v147)
              {
                v115 = v142;
              }

              if (!v147)
              {
                v114 = v142;
              }

              if (--v91)
              {
                v113 = *(v116 + 8 * (v113 & v168) + 4 * v148);
                if (v113 > v156)
                {
                  continue;
                }
              }
            }
          }
        }

        break;
      }
    }
  }

LABEL_209:
  *(a2 + 44) = v90 - 8;
  return result;
}

uint64_t ZSTD_btGetAllMatches_dictMatchState_6(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, char *a5, _DWORD *a6, unsigned int a7, int a8)
{
  v8 = *(a2 + 8);
  v9 = *(a2 + 44);
  if (v8 + v9 > a4)
  {
    return 0;
  }

  v18 = a4 - v8;
  v19 = a4 - v8;
  if (v9 < a4 - v8)
  {
    do
    {
      LODWORD(v9) = ZSTD_insertBt1(a2, (v8 + v9), a5, v18, 6, 0) + v9;
    }

    while (v9 < v18);
    v8 = *(a2 + 8);
    v19 = a4 - v8;
  }

  *(a2 + 44) = v18;
  v20 = *(a2 + 260);
  if (v20 >= 0xFFF)
  {
    v21 = 4095;
  }

  else
  {
    v21 = v20;
  }

  v155 = 0xCF1BBCDCBF9B0000 * *a4;
  v161 = *(a2 + 96);
  v159 = *(a2 + 252);
  v160 = v155 >> -*(a2 + 248);
  v22 = *(v161 + 4 * v160);
  v23 = *(a2 + 112);
  v158 = -1 << (*(a2 + 244) - 1);
  v24 = *(a2 + 24);
  v166 = (v8 + v24);
  v25 = v19 + v158 + 1;
  if (v19 < ~v158)
  {
    v25 = 0;
  }

  v171 = v25;
  v26 = 1 << *(a2 + 240);
  v27 = v19 - v26;
  if (v19 - *(a2 + 28) <= v26 || *(a2 + 40) != 0)
  {
    v27 = *(a2 + 28);
  }

  if (v27 <= 1)
  {
    v29 = 1;
  }

  else
  {
    v29 = v27;
  }

  v173 = v29;
  v175[0] = 0;
  v30 = *(a2 + 232);
  v32 = *v30;
  v31 = *(v30 + 8);
  v33 = *v30 - v31;
  v34 = *(v30 + 28);
  v35 = v27 - v33;
  v153 = *(v30 + 248);
  v154 = v30;
  v36 = ~(-1 << (*(v30 + 244) - 1));
  v168 = v36;
  v152 = v33;
  v37 = v33 + (-1 << (*(v30 + 244) - 1)) + 1;
  if (v33 - v34 <= v36)
  {
    v37 = v34;
  }

  v169 = v37;
  v38 = (a8 - 1);
  v164 = v24;
  v170 = v31;
  v156 = v34;
  v167 = v27 - v33;
  result = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    v39 = v19 - v24;
    v40 = v31 - v35;
    v41 = v19 - v34 - v35;
    v42 = a4 + 4;
    v43 = a5 - 7;
    v162 = a5 - 1;
    v163 = a5 - 3;
    v151 = v40 + 12;
    v157 = a4 + 12;
    v149 = v24 + v8 + 8;
    for (i = a7; i != a7 + 3; ++i)
    {
      if (i == 3)
      {
        v45 = *a6 - 1;
      }

      else
      {
        v45 = a6[i];
      }

      v46 = v19 - v45;
      if (v45 - 1 >= v39)
      {
        if (v45 - 1 < v41 && (v46 - v24) <= 0xFFFFFFFC)
        {
          v59 = (v40 + v46);
          if (*a4 == *v59)
          {
            v60 = (v59 + 1);
            v61 = a4 + v32 - v59;
            if (v61 >= a5)
            {
              v61 = a5;
            }

            if (v61 - 7 <= v42)
            {
              v74 = v24;
              v62 = a1;
              v63 = v41;
              v64 = v32;
              v65 = v40;
              v67 = v60;
              v68 = a4 + 2;
              goto LABEL_67;
            }

            if (*v60 == *v42)
            {
              v62 = a1;
              v63 = v41;
              v64 = v32;
              v65 = v40;
              v150 = v23;
              v66 = 0;
              v67 = (v151 + v46);
              v68 = a4 + 6;
              while (v68 < (v61 - 7))
              {
                v70 = *v67;
                v67 += 4;
                v69 = v70;
                v72 = *v68;
                v68 += 4;
                v71 = v72;
                v66 += 8;
                if (v69 != v72)
                {
                  v57 = v66 + (__clz(__rbit64(v71 ^ v69)) >> 3);
                  v23 = v150;
                  v40 = v65;
                  v32 = v64;
                  v41 = v63;
                  a1 = v62;
                  v24 = v164;
                  goto LABEL_77;
                }
              }

              v23 = v150;
              v74 = v164;
LABEL_67:
              if (v68 < (v61 - 3) && *v67 == *v68)
              {
                v67 += 2;
                v68 += 2;
              }

              if (v68 < (v61 - 1) && *v67 == *v68)
              {
                ++v67;
                ++v68;
              }

              if (v68 < v61 && *v67 == *v68)
              {
                v68 = (v68 + 1);
              }

              v40 = v65;
              v57 = v68 - v42;
              v32 = v64;
              v41 = v63;
              a1 = v62;
              v24 = v74;
            }

            else
            {
              v57 = __clz(__rbit64(*v42 ^ *v60)) >> 3;
            }

LABEL_77:
            if (v60 + v57 == v32)
            {
              v75 = &v42[v57];
              if (v43 <= &v42[v57])
              {
                v83 = v166;
                v82 = &v42[v57];
                goto LABEL_87;
              }

              if (*v166 == *v75)
              {
                v76 = a1;
                v77 = v41;
                v78 = v21;
                v79 = v32;
                v80 = v40;
                v81 = 0;
                v82 = &v157[v57];
                v83 = v149;
                while (v82 < v43)
                {
                  v85 = *v83;
                  v83 += 4;
                  v84 = v85;
                  v87 = *v82;
                  v82 += 4;
                  v86 = v87;
                  v81 += 8;
                  if (v84 != v87)
                  {
                    v82 = (v81 + (__clz(__rbit64(v86 ^ v84)) >> 3));
                    v40 = v80;
                    v32 = v79;
                    v21 = v78;
                    v41 = v77;
                    a1 = v76;
                    v24 = v164;
                    goto LABEL_97;
                  }
                }

                v40 = v80;
                v32 = v79;
                v21 = v78;
                v41 = v77;
                a1 = v76;
                v24 = v164;
LABEL_87:
                if (v82 < v163 && *v83 == *v82)
                {
                  v83 += 2;
                  v82 += 2;
                }

                if (v82 < v162 && *v83 == *v82)
                {
                  ++v83;
                  ++v82;
                }

                if (v82 < a5 && *v83 == *v82)
                {
                  LODWORD(v82) = v82 + 1;
                }

                LODWORD(v82) = v82 - v75;
              }

              else
              {
                v82 = (__clz(__rbit64(*v75 ^ *v166)) >> 3);
              }

LABEL_97:
              LODWORD(v57) = v82 + v57;
            }

LABEL_98:
            v73 = v57 + 4;
            goto LABEL_99;
          }
        }
      }

      else if (v46 >= v27 && *a4 == *(a4 - v45))
      {
        v48 = -v45;
        v49 = &v42[-v45];
        if (v43 <= v42)
        {
          v52 = a4 + 2;
        }

        else
        {
          v50 = *v49;
          if (v50 != *v42)
          {
            v57 = __clz(__rbit64(*v42 ^ v50)) >> 3;
            goto LABEL_98;
          }

          v51 = 0;
          v49 = &v157[v48];
          v52 = a4 + 6;
          while (v52 < v43)
          {
            v54 = *v49;
            v49 += 8;
            v53 = v54;
            v56 = *v52;
            v52 += 4;
            v55 = v56;
            v51 += 8;
            if (v53 != v56)
            {
              v57 = v51 + (__clz(__rbit64(v55 ^ v53)) >> 3);
              goto LABEL_98;
            }
          }
        }

        if (v52 < v163 && *v49 == *v52)
        {
          v49 += 4;
          v52 += 2;
        }

        if (v52 < v162 && *v49 == *v52)
        {
          v49 += 2;
          ++v52;
        }

        if (v52 < a5 && *v49 == *v52)
        {
          LODWORD(v52) = v52 + 1;
        }

        LODWORD(v57) = v52 - v42;
        goto LABEL_98;
      }

      v73 = 0;
LABEL_99:
      if (v38 < v73)
      {
        v88 = (a1 + 8 * result);
        *v88 = i - a7;
        v88[1] = v73;
        result = (result + 1);
        if (v73 > v21)
        {
          return result;
        }

        v38 = v73;
        if (a4 + v73 == a5)
        {
          return result;
        }
      }
    }
  }

  v89 = (v23 + 8 * (v19 & ~v158));
  v90 = v19 + 9;
  v91 = 1 << v159;
  *(v161 + 4 * v160) = v19;
  if (v22 < v173)
  {
    v174 = a1;
    *v89 = 0;
    goto LABEL_148;
  }

  v92 = 0;
  v93 = 0;
  v94 = v89 + 1;
  v95 = a5 - 7;
  while (1)
  {
    v96 = v92 >= v93 ? v93 : v92;
    v97 = v8 + v22;
    v98 = a4 + v96;
    v99 = (v97 + v96);
    if (v95 <= a4 + v96)
    {
      v103 = (a4 + v96);
    }

    else
    {
      v100 = *v99;
      if (v100 != *v98)
      {
        v108 = __clz(__rbit64(*v98 ^ v100)) >> 3;
        goto LABEL_128;
      }

      v101 = v23;
      v102 = 0;
      v99 = (v8 + 8 + v96 + v22);
      v103 = (a4 + v96 + 8);
      while (v103 < v95)
      {
        v105 = *v99;
        v99 += 4;
        v104 = v105;
        v107 = *v103;
        v103 += 4;
        v106 = v107;
        v102 += 8;
        if (v104 != v107)
        {
          v108 = v102 + (__clz(__rbit64(v106 ^ v104)) >> 3);
          v23 = v101;
          v24 = v164;
          goto LABEL_128;
        }
      }

      v23 = v101;
      v24 = v164;
    }

    if (v103 < (a5 - 3) && *v99 == *v103)
    {
      v99 += 2;
      v103 += 2;
    }

    if (v103 < (a5 - 1) && *v99 == *v103)
    {
      ++v99;
      ++v103;
    }

    if (v103 < a5 && *v99 == *v103)
    {
      v103 = (v103 + 1);
    }

    v108 = v103 - v98;
LABEL_128:
    v109 = v108 + v96;
    if (v109 > v38)
    {
      if (v109 > v90 - v22)
      {
        v90 = v22 + v109;
      }

      v110 = (a1 + 8 * result);
      *v110 = v19 + 2 - v22;
      v110[1] = v109;
      result = (result + 1);
      if (v109 > 0x1000 || a4 + v109 == a5)
      {
        *v94 = 0;
        *v89 = 0;
        goto LABEL_209;
      }

      v38 = v109;
    }

    v112 = (v23 + 8 * (v22 & ~v158));
    if (*(v97 + v109) < *(a4 + v109))
    {
      break;
    }

    *v94 = v22;
    if (v22 <= v171)
    {
      v94 = v175;
      goto LABEL_147;
    }

    v94 = (v23 + 8 * (v22 & ~v158));
    v93 = v109;
LABEL_141:
    if (--v91)
    {
      v22 = *v112;
      if (*v112 >= v173)
      {
        continue;
      }
    }

    goto LABEL_147;
  }

  *v89 = v22;
  if (v22 > v171)
  {
    v89 = v112 + 1;
    v92 = v109;
    ++v112;
    goto LABEL_141;
  }

  v89 = v175;
LABEL_147:
  v174 = a1;
  *v94 = 0;
  *v89 = 0;
  if (v91)
  {
LABEL_148:
    v113 = *(*(v154 + 96) + 4 * (v155 >> -v153));
    if (v113 > v156)
    {
      v114 = 0;
      v115 = 0;
      v116 = *(v154 + 112);
      v117 = a5 - 7;
      v118 = v19 + 2;
      v172 = a4 + 1;
      v165 = v24 + v8 + 8;
      v119 = v8 + v167;
      while (1)
      {
        if (v114 >= v115)
        {
          v120 = v115;
        }

        else
        {
          v120 = v114;
        }

        v121 = v170 + v113;
        v122 = a4 + v120;
        v123 = (v121 + v120);
        v124 = &v32[a4 - v121];
        if (v124 >= a5)
        {
          v124 = a5;
        }

        if (v124 - 7 <= v122)
        {
          v126 = (v121 + v120);
          v127 = (a4 + v120);
        }

        else
        {
          if (*v123 != *v122)
          {
            v132 = __clz(__rbit64(*v122 ^ *v123)) >> 3;
            goto LABEL_173;
          }

          v125 = 0;
          v126 = (v170 + 8 + v120 + v113);
          v127 = (v172 + v120);
          while (v127 < (v124 - 7))
          {
            v129 = *v126;
            v126 += 4;
            v128 = v129;
            v131 = *v127;
            v127 += 4;
            v130 = v131;
            v125 += 8;
            if (v128 != v131)
            {
              v132 = v125 + (__clz(__rbit64(v130 ^ v128)) >> 3);
              goto LABEL_173;
            }
          }
        }

        if (v127 < (v124 - 3) && *v126 == *v127)
        {
          v126 += 2;
          v127 += 2;
        }

        if (v127 < (v124 - 1) && *v126 == *v127)
        {
          ++v126;
          ++v127;
        }

        if (v127 < v124 && *v126 == *v127)
        {
          v127 = (v127 + 1);
        }

        v132 = v127 - v122;
LABEL_173:
        if (v123 + v132 == v32)
        {
          v133 = &v122[v132];
          if (v117 > v133)
          {
            if (*v166 == *v133)
            {
              v134 = 0;
              v135 = (v172 + v132 + v120);
              v136 = v165;
              while (v135 < v117)
              {
                v138 = *v136;
                v136 += 4;
                v137 = v138;
                v140 = *v135;
                v135 += 4;
                v139 = v140;
                v134 += 8;
                if (v137 != v140)
                {
                  v141 = v134 + (__clz(__rbit64(v139 ^ v137)) >> 3);
                  goto LABEL_192;
                }
              }

LABEL_181:
              if (v135 < (a5 - 3) && *v136 == *v135)
              {
                v136 += 2;
                v135 += 2;
              }

              if (v135 < (a5 - 1) && *v136 == *v135)
              {
                ++v136;
                ++v135;
              }

              if (v135 < a5 && *v136 == *v135)
              {
                v135 = (v135 + 1);
              }

              v141 = v135 - v133;
            }

            else
            {
              v141 = __clz(__rbit64(*v133 ^ *v166)) >> 3;
            }

LABEL_192:
            v132 += v141;
            goto LABEL_193;
          }

          v136 = v166;
          v135 = v133;
          goto LABEL_181;
        }

LABEL_193:
        v142 = v132 + v120;
        if (v142 + v113 >= v152)
        {
          v143 = v119 + v113;
        }

        else
        {
          v143 = v170 + v113;
        }

        if (v142 <= v38)
        {
          goto LABEL_212;
        }

        if (v142 > v90 - (v113 + v167))
        {
          v90 = v113 + v167 + v142;
        }

        v144 = (v174 + 8 * result);
        *v144 = v118 - (v113 + v167);
        v144[1] = v142;
        result = (result + 1);
        if (v142 <= 0x1000)
        {
          v38 = v142;
          if (a4 + v142 != a5)
          {
LABEL_212:
            if (v113 > v169)
            {
              v145 = *(v143 + v142);
              v146 = *(a4 + v142);
              v147 = v145 >= v146;
              v148 = v145 < v146;
              if (v147)
              {
                v115 = v142;
              }

              if (!v147)
              {
                v114 = v142;
              }

              if (--v91)
              {
                v113 = *(v116 + 8 * (v113 & v168) + 4 * v148);
                if (v113 > v156)
                {
                  continue;
                }
              }
            }
          }
        }

        break;
      }
    }
  }

LABEL_209:
  *(a2 + 44) = v90 - 8;
  return result;
}

uint64_t ZSTD_insertAndFindFirstIndexHash3(uint64_t a1, unsigned int *a2, int *a3)
{
  v3 = *(a1 + 104);
  v4 = *(a1 + 8);
  v5 = *a2;
  v6 = a3 - v4;
  v7 = *a3;
  v8 = 32 - *(a1 + 48);
  if (v5 < a3 - v4)
  {
    do
    {
      *(v3 + 4 * ((900185344 * *(v4 + v5)) >> v8)) = v5;
      ++v5;
    }

    while (v5 < v6);
  }

  *a2 = v6;
  return *(v3 + 4 * ((900185344 * v7) >> v8));
}

size_t ZSTD_noCompressLiterals(_DWORD *a1, size_t a2, void *__src, size_t __n)
{
  if (__n <= 0x1F)
  {
    LODWORD(v4) = 1;
  }

  else
  {
    LODWORD(v4) = 2;
  }

  if (__n <= 0xFFF)
  {
    v4 = v4;
  }

  else
  {
    v4 = (v4 + 1);
  }

  v5 = v4 + __n;
  if (v4 + __n > a2)
  {
    return -70;
  }

  if (v4 == 3)
  {
    *a1 = (16 * __n) | 0xC;
  }

  else if (v4 == 2)
  {
    *a1 = (16 * __n) | 4;
  }

  else
  {
    *a1 = 8 * __n;
  }

  memcpy(a1 + v4, __src, __n);
  return v5;
}

uint64_t ZSTD_compressRleLiteralsBlock(_DWORD *a1, uint64_t a2, _BYTE *a3, unint64_t a4)
{
  if (a4 <= 0x1F)
  {
    v4 = 1;
  }

  else
  {
    v4 = 2;
  }

  if (a4 > 0xFFF)
  {
    ++v4;
  }

  if (v4 == 3)
  {
    *a1 = (16 * a4) | 0xD;
  }

  else if (v4 == 2)
  {
    *a1 = (16 * a4) | 5;
  }

  else
  {
    *a1 = (8 * a4) | 1;
  }

  *(a1 + v4) = *a3;
  return (v4 + 1);
}

uint64_t ZSTD_compressLiterals(void *__src, void *__dst, unsigned int a3, int a4, _DWORD *a5, size_t a6, void *a7, size_t a8, uint64_t a9, unint64_t a10, int a11, int a12)
{
  if (a3 <= 7)
  {
    v20 = 6;
  }

  else
  {
    v20 = a3 - 1;
  }

  v21 = 3;
  if (a8 > 0x3FF)
  {
    v21 = 4;
  }

  if ((a8 & 0xFFFFFFFFFFFFC000) != 0)
  {
    v22 = v21 + 1;
  }

  else
  {
    v22 = v21;
  }

  memcpy(__dst, __src, 0x810uLL);
  if (a4)
  {
    v23 = a5;
    v24 = a6;
    v25 = a7;
LABEL_33:

    return ZSTD_noCompressLiterals(v23, v24, v25, a8);
  }

  v25 = a7;
  v23 = a5;
  v26 = *(__src + 514);
  v27 = 63;
  if (v26 == 2)
  {
    v27 = 6;
  }

  if (v27 >= a8)
  {
    v24 = a6;
    goto LABEL_33;
  }

  v28 = a6 - v22;
  if (a6 <= v22)
  {
    return -70;
  }

  v29 = v22;
  v30 = a6;
  v32 = a3 < 4 && a8 < 0x401;
  v45 = *(__src + 514);
  v35 = v26 == 2 && v22 == 3 || a8 < 0x100;
  v36 = v23;
  v37 = v23 + v22;
  v38 = v25;
  if (v35)
  {
    v39 = HUF_compress1X_repeat(v37, v28, v25, a8, 0xFFu, 0xBu, a9, a10, __dst, &v45, v32, a11, a12);
  }

  else
  {
    v39 = HUF_compress4X_repeat(v37, v28, v25, a8, 0xFFu, 0xBu, a9, a10, __dst, &v45, v32, a11, a12);
  }

  if (v45)
  {
    v41 = 3;
  }

  else
  {
    v41 = 2;
  }

  if (v39 - 1 > 0xFFFFFFFFFFFFFF87 || v39 >= a8 - (a8 >> v20) - 2)
  {
    memcpy(__dst, __src, 0x810uLL);
    return ZSTD_noCompressLiterals(v36, v30, v38, a8);
  }

  else if (v39 == 1)
  {
    memcpy(__dst, __src, 0x810uLL);
    return ZSTD_compressRleLiteralsBlock(v36, v42, v38, a8);
  }

  else
  {
    if (!v45)
    {
      *(__dst + 514) = 1;
    }

    if (v29 == 5)
    {
      *v36 = ((v39 << 22) + 16 * a8) | v41 | 0xC;
      *(v36 + 4) = v39 >> 10;
    }

    else if (v29 == 4)
    {
      *v36 = ((v39 << 18) + 16 * a8) | v41 | 8;
    }

    else
    {
      if (v35)
      {
        v43 = 4;
      }

      else
      {
        v43 = 0;
      }

      v44 = ((v41 | v43 | (16 * a8)) ^ 4) + (v39 << 14);
      *v36 = v44;
      *(v36 + 2) = BYTE2(v44);
    }

    return v39 + v29;
  }
}

void *std::vector<long long>::reserve(void *result, unint64_t a2)
{
  if (a2 > (result[2] - *result) >> 3)
  {
    if (!(a2 >> 61))
    {
      v2 = result[1] - *result;
      std::__allocate_at_least[abi:nn200100]<std::allocator<long long>>(a2);
    }

    std::vector<long long>::__throw_length_error[abi:nn200100]();
  }

  return result;
}

void *std::vector<unsigned long>::reserve(void *result)
{
  if ((result[2] - *result) >> 4 <= 0x804uLL)
  {
    v1 = result[1] - *result;
    operator new();
  }

  return result;
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<long long>>(unint64_t a1)
{
  if (!(a1 >> 61))
  {
    operator new();
  }

  std::vector<long long>::__throw_length_error[abi:nn200100]();
}

uint64_t CachingHotShard::Bind(CachingHotShard *this, int a2)
{
  if (*this != -1)
  {
    *(this + 2) = *(this + 1);
    *(this + 5) = *(this + 4);
    *(this + 8) = *(this + 7);
  }

  *this = a2;
  v4 = hot_shard_for_each_region(a2);
  if (v4 || (file_size = get_file_size(a2), *(this + 10) = file_size, file_size < 0))
  {
    *(this + 2) = *(this + 1);
    *(this + 5) = *(this + 4);
    *(this + 8) = *(this + 7);
    *this = -1;
  }

  return v4;
}

void CachingHotShard::cache_put(CachingHotShard *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21 = a4;
  v22 = a3;
  v7 = *(this + 1);
  v8 = *(this + 2);
  v9 = v8 - v7;
  v10 = (v8 - v7) >> 3;
  if (v10 < 1)
  {
LABEL_5:
    v12 = *(this + 3);
    if (v8 >= v12)
    {
      v14 = v10 + 1;
      if ((v10 + 1) >> 61)
      {
        std::vector<long long>::__throw_length_error[abi:nn200100]();
      }

      v15 = v12 - v7;
      if (v15 >> 2 > v14)
      {
        v14 = v15 >> 2;
      }

      if (v15 >= 0x7FFFFFFFFFFFFFF8)
      {
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v16 = v14;
      }

      if (v16)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<long long>>(v16);
      }

      v17 = (v8 - v7) >> 3;
      v18 = (8 * v10);
      v19 = (8 * v10 - 8 * v17);
      *v18 = a2;
      v13 = v18 + 1;
      memcpy(v19, v7, v9);
      v20 = *(this + 1);
      *(this + 1) = v19;
      *(this + 2) = v13;
      *(this + 3) = 0;
      if (v20)
      {
        operator delete(v20);
      }
    }

    else
    {
      *v8 = a2;
      v13 = v8 + 8;
    }

    *(this + 2) = v13;
    std::vector<unsigned long>::push_back[abi:nn200100](this + 32, &v22);
    std::vector<unsigned long>::push_back[abi:nn200100](this + 56, &v21);
  }

  else
  {
    v11 = 0;
    while (*&v7[8 * v11] != a2)
    {
      if (((v9 >> 3) & 0x7FFFFFFF) == ++v11)
      {
        goto LABEL_5;
      }
    }

    *(*(this + 4) + 8 * v11) = a3;
    *(*(this + 7) + 8 * v11) = a4;
  }
}

void std::vector<unsigned long>::push_back[abi:nn200100](uint64_t a1, void *a2)
{
  v5 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v5 >= v4)
  {
    v7 = *a1;
    v8 = v5 - *a1;
    v9 = (v8 >> 3) + 1;
    if (v9 >> 61)
    {
      std::vector<long long>::__throw_length_error[abi:nn200100]();
    }

    v10 = v4 - v7;
    if (v10 >> 2 > v9)
    {
      v9 = v10 >> 2;
    }

    if (v10 >= 0x7FFFFFFFFFFFFFF8)
    {
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v11 = v9;
    }

    if (v11)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<long long>>(v11);
    }

    v12 = (8 * (v8 >> 3));
    *v12 = *a2;
    v6 = v12 + 1;
    memcpy(0, v7, v8);
    v13 = *a1;
    *a1 = 0;
    *(a1 + 8) = v6;
    *(a1 + 16) = 0;
    if (v13)
    {
      operator delete(v13);
    }
  }

  else
  {
    *v5 = *a2;
    v6 = v5 + 1;
  }

  *(a1 + 8) = v6;
}

uint64_t CachingHotShard::WriteDocs(CachingHotShard *this, int a2, const uint64_t *a3, const char *a4, const char **a5, const unint64_t *a6)
{
  v6 = MEMORY[0x1EEE9AC00](this);
  v62 = *MEMORY[0x1E69E9840];
  if (*v6 == -1)
  {
    v22 = 4294967287;
  }

  else
  {
    v11 = v10;
    v12 = v9;
    v13 = v8;
    v14 = v7;
    v15 = v6;
    v16 = *v6;
    v17 = lseek(*v6, 0, 2);
    if (v17 < 0)
    {
      v23 = __error();
      v24 = 0;
      v22 = -*v23;
      if (*v23)
      {
        goto LABEL_42;
      }
    }

    else
    {
      v18 = v17;
      bzero(__buf, 0x1000uLL);
      v43 = __buf;
      v44.iov_base = __buf;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      v19 = *v14;
      v20 = *v13;
      if (*v14 >= 0x80)
      {
        if (v19 >= 0x4000)
        {
          v21 = 3;
          v25 = 4;
          v26 = 5;
          v27 = 6;
          v28 = 7;
          v29 = 8;
          if (HIBYTE(v19))
          {
            v29 = 9;
          }

          if (v19 >> 49)
          {
            v28 = v29;
          }

          if (v19 >> 42)
          {
            v27 = v28;
          }

          if (v19 >> 35)
          {
            v26 = v27;
          }

          if (v19 >> 28)
          {
            v25 = v26;
          }

          if (v19 >= 0x200000)
          {
            v21 = v25;
          }
        }

        else
        {
          v21 = 2;
        }
      }

      else
      {
        v21 = 1;
      }

      v2_writeVInt64(&v43, *v11 + v21 + 1);
      v2_writeVInt64(&v43, v19);
      v30 = v43;
      *v43 = v20;
      v31 = (v30 - __buf + 1);
      v24 = v18 + v31;
      v32 = *v12;
      v44.iov_len = v31;
      v45 = v32;
      v46 = *v11;
      if (v46 >= 0x1FF9D)
      {
        ftruncate(v16, v18);
        v22 = 4294967256;
        goto LABEL_42;
      }

      v22 = writevall(v16, &v44, 2);
      if (v22)
      {
        ftruncate(v16, v18);
        goto LABEL_42;
      }

      hot_shard_update_logical_size(v16);
    }

    v33 = *v14;
    v34 = *(v15 + 1);
    v35 = *(v15 + 2) - v34;
    if ((v35 >> 3) >= 1)
    {
      v36 = 0;
      v37 = (v35 >> 3) & 0x7FFFFFFF;
      while (*(v34 + 8 * v36) != v33)
      {
        if (v37 == ++v36)
        {
          goto LABEL_41;
        }
      }

      v38 = *(*(v15 + 4) + 8 * v36);
      v39 = *(*(v15 + 7) + 8 * v36);
      memset(__buf, 0, 256);
      if (v39)
      {
        do
        {
          if (v39 >= 0x100)
          {
            v40 = 256;
          }

          else
          {
            v40 = v39;
          }

          if (!pwrite(*v15, __buf, v40, v38) || *__error() != 4)
          {
            v39 -= v40;
            v38 += v40;
          }
        }

        while (v39);
        v33 = *v14;
      }
    }

LABEL_41:
    CachingHotShard::cache_put(v15, v33, v24, *v11);
    v22 = 0;
  }

LABEL_42:
  v41 = *MEMORY[0x1E69E9840];
  return v22;
}

void *TokenMatchNew(uint64_t a1)
{
  v2 = MEMORY[0x1C691E420](a1, 48, 0x60040C5953071, 0);
  *v2 = a1;
  v2[1] = a1;
  v2[3] = 0;
  v2[4] = 0;
  v2[2] = 0;
  v2[5] = a1;
  v10[4] = v2 + 5;
  v3 = MEMORY[0x1C691E420](a1, 448, 0x1070040FF779111, 0);
  v4 = v2[2];
  v5 = v2[3];
  v6 = v3 + v4 - v5;
  std::__uninitialized_allocator_relocate[abi:nn200100]<CFBridgeAllocator<TokenMatch::entry>,TokenMatch::entry*>(v4, v5, v6);
  v7 = v2[2];
  v2[2] = v6;
  v2[3] = v3;
  v8 = v2[4];
  v2[4] = v3 + 448;
  v10[2] = v7;
  v10[3] = v8;
  v10[0] = v7;
  v10[1] = v7;
  std::__split_buffer<TokenMatch::entry,CFBridgeAllocator<TokenMatch::entry> &>::~__split_buffer(v10);
  return v2;
}

void std::__uninitialized_allocator_relocate[abi:nn200100]<CFBridgeAllocator<TokenMatch::entry>,TokenMatch::entry*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v4 = a1;
    v5 = a1;
    do
    {
      v6 = *(v5 + 16);
      *a3 = *v5;
      *(a3 + 16) = v6;
      *(a3 + 24) = 0;
      *(a3 + 32) = 0;
      *(a3 + 40) = 0;
      *(a3 + 48) = *(v5 + 48);
      *(a3 + 24) = *(v5 + 24);
      *(a3 + 40) = *(v5 + 40);
      *(v5 + 24) = 0;
      *(v5 + 32) = 0;
      *(v5 + 40) = 0;
      v5 += 56;
      a3 += 56;
    }

    while (v5 != a2);
    do
    {
      v7 = *(v4 + 24);
      if (v7)
      {
        *(v4 + 32) = v7;
        CFAllocatorDeallocate(*(v4 + 48), v7);
      }

      v4 += 56;
    }

    while (v4 != a2);
  }
}

uint64_t std::__split_buffer<TokenMatch::entry,CFBridgeAllocator<TokenMatch::entry> &>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  v2 = *(a1 + 16);
  while (v2 != v3)
  {
    *(a1 + 16) = v2 - 56;
    v4 = *(v2 - 32);
    if (v4)
    {
      *(v2 - 24) = v4;
      CFAllocatorDeallocate(*(v2 - 8), v4);
      v2 = *(a1 + 16);
    }

    else
    {
      v2 -= 56;
    }
  }

  if (*a1)
  {
    CFAllocatorDeallocate(**(a1 + 32), *a1);
  }

  return a1;
}

void TokenMatchTrack(void *a1, char *__s, const char *a3, char a4, char a5, char a6)
{
  if (__s && a3)
  {
    v12 = strlen(__s);
    v13 = strlen(a3);
    v14 = a1[2];
    v15 = a1[3];
    while (v14 != v15)
    {
      if (*(v14 + 16) == v12 && !memcmp(*(v14 + 8), __s, v12))
      {
        *&v34 = a3;
        *(&v34 + 1) = v13;
        LOBYTE(v35) = a4;
        BYTE1(v35) = a5;
        BYTE2(v35) = a6;
        std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::push_back[abi:nn200100]((v14 + 24), &v34);
        return;
      }

      v14 += 56;
    }

    *&v34 = *a1;
    *allocator = 0u;
    v41 = &allocator[1];
    ptr[0] = MEMORY[0x1C691E420](0, 96, 0x1050040F0E7367ALL, 0);
    ptr[1] = ptr[0];
    allocator[0] = (ptr[0] + 96);
    v39 = 0;
    v40 = 0;
    v38 = 0uLL;
    std::__split_buffer<SnippetTerm,CFBridgeAllocator<SnippetTerm> &>::~__split_buffer(&v38);
    *(&v34 + 1) = __s;
    v35 = v12;
    *&v38 = a3;
    *(&v38 + 1) = v13;
    LOBYTE(v39) = a4;
    BYTE1(v39) = a5;
    BYTE2(v39) = a6;
    std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::push_back[abi:nn200100](ptr, &v38);
    v17 = a1[3];
    v16 = a1[4];
    if (v17 >= v16)
    {
      v20 = a1[2];
      v21 = 0x6DB6DB6DB6DB6DB7 * ((v17 - v20) >> 3);
      if ((v21 + 1) > 0x492492492492492)
      {
        std::vector<long long>::__throw_length_error[abi:nn200100]();
      }

      v22 = 0x6DB6DB6DB6DB6DB7 * ((v16 - v20) >> 3);
      v23 = 2 * v22;
      if (2 * v22 <= v21 + 1)
      {
        v23 = v21 + 1;
      }

      if (v22 >= 0x249249249249249)
      {
        v24 = 0x492492492492492;
      }

      else
      {
        v24 = v23;
      }

      v41 = (a1 + 5);
      if (v24)
      {
        v25 = MEMORY[0x1C691E420](a1[5], 56 * v24, 0x1070040FF779111, 0);
      }

      else
      {
        v25 = 0;
      }

      v26 = v25 + 56 * v21;
      v27 = v34;
      v28 = v25 + 56 * v24;
      *(v26 + 16) = v35;
      *v26 = v27;
      std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::vector[abi:nn200100]((v26 + 24), ptr);
      v19 = v26 + 56;
      v29 = a1[2];
      v30 = a1[3];
      v31 = v26 + v29 - v30;
      std::__uninitialized_allocator_relocate[abi:nn200100]<CFBridgeAllocator<TokenMatch::entry>,TokenMatch::entry*>(v29, v30, v31);
      v32 = a1[2];
      a1[2] = v31;
      a1[3] = v19;
      v33 = a1[4];
      a1[4] = v28;
      v39 = v32;
      v40 = v33;
      *&v38 = v32;
      *(&v38 + 1) = v32;
      std::__split_buffer<TokenMatch::entry,CFBridgeAllocator<TokenMatch::entry> &>::~__split_buffer(&v38);
    }

    else
    {
      v18 = v34;
      *(v17 + 16) = v35;
      *v17 = v18;
      std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::vector[abi:nn200100]((v17 + 24), ptr);
      v19 = v17 + 56;
    }

    a1[3] = v19;
    if (ptr[0])
    {
      ptr[1] = ptr[0];
      CFAllocatorDeallocate(allocator[1], ptr[0]);
    }
  }
}

const void **std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::push_back[abi:nn200100](const void **result, __int128 *a2)
{
  v3 = result;
  v5 = result[1];
  v4 = result[2];
  if (v5 >= v4)
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *result) >> 3);
    v9 = v8 + 1;
    if (v8 + 1 > 0xAAAAAAAAAAAAAAALL)
    {
      std::vector<long long>::__throw_length_error[abi:nn200100]();
    }

    v10 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *result) >> 3);
    if (2 * v10 > v9)
    {
      v9 = 2 * v10;
    }

    if (v10 >= 0x555555555555555)
    {
      v11 = 0xAAAAAAAAAAAAAAALL;
    }

    else
    {
      v11 = v9;
    }

    v20[4] = result + 3;
    if (v11)
    {
      v12 = MEMORY[0x1C691E420](result[3], 24 * v11, 0x1050040F0E7367ALL, 0);
    }

    else
    {
      v12 = 0;
    }

    v13 = v12 + 24 * v8;
    v14 = v12 + 24 * v11;
    v15 = *a2;
    *(v13 + 16) = *(a2 + 2);
    *v13 = v15;
    v7 = v13 + 24;
    v16 = v3[1] - *v3;
    v17 = v13 - v16;
    memcpy((v13 - v16), *v3, v16);
    v18 = *v3;
    *v3 = v17;
    v3[1] = v7;
    v19 = v3[2];
    v3[2] = v14;
    v20[2] = v18;
    v20[3] = v19;
    v20[0] = v18;
    v20[1] = v18;
    result = std::__split_buffer<SnippetTerm,CFBridgeAllocator<SnippetTerm> &>::~__split_buffer(v20);
  }

  else
  {
    v6 = *a2;
    *(v5 + 16) = *(a2 + 2);
    *v5 = v6;
    v7 = v5 + 24;
  }

  v3[1] = v7;
  return result;
}

void *std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::vector[abi:nn200100](void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = *(a2 + 24);
  v4 = *a2;
  v3 = *(a2 + 8);
  v5 = v3 - *a2;
  if (v3 != *a2)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v5 >> 3) >= 0xAAAAAAAAAAAAAABLL)
    {
      std::vector<long long>::__throw_length_error[abi:nn200100]();
    }

    v6 = MEMORY[0x1C691E420]();
    *a1 = v6;
    a1[1] = v6;
    v7 = &v6[v5];
    a1[2] = &v6[v5];
    memmove(v6, v4, v5 - 5);
    a1[1] = v7;
  }

  return a1;
}

uint64_t std::__split_buffer<SnippetTerm,CFBridgeAllocator<SnippetTerm> &>::~__split_buffer(uint64_t a1)
{
  v2 = *(a1 + 16);
  if (v2 != *(a1 + 8))
  {
    *(a1 + 16) = (v2 - *(a1 + 8) - 24) % 0x18uLL + *(a1 + 8);
  }

  if (*a1)
  {
    CFAllocatorDeallocate(**(a1 + 32), *a1);
  }

  return a1;
}

void TokenMatchFree(void *ptr)
{
  v2 = *(ptr + 2);
  if (v2)
  {
    v3 = *(ptr + 3);
    v4 = *(ptr + 2);
    if (v3 != v2)
    {
      do
      {
        v5 = *(v3 - 32);
        if (v5)
        {
          *(v3 - 24) = v5;
          CFAllocatorDeallocate(*(v3 - 8), v5);
        }

        v3 -= 56;
      }

      while (v3 != v2);
      v4 = *(ptr + 2);
    }

    *(ptr + 3) = v2;
    CFAllocatorDeallocate(*(ptr + 5), v4);
  }

  v6 = *ptr;

  CFAllocatorDeallocate(v6, ptr);
}

void TokenMatchConvertToSnippetHints(uint64_t a1)
{
  v2 = *(a1 + 16);
  v3 = *(a1 + 24);
  v4 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (v3 - v2));
  if (v3 == v2)
  {
    v5 = 0;
  }

  else
  {
    v5 = v4;
  }

  std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,false>(v2, v3, v5, 1);
  v7 = *(a1 + 16);
  for (i = *(a1 + 24); v7 != i; v7 += 56)
  {
    v8 = *(v7 + 24);
    v9 = *(v7 + 32);
    v10 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((v9 - v8) >> 3));
    if (v9 == v8)
    {
      v11 = 0;
    }

    else
    {
      v11 = v10;
    }

    std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,false>(v8, v9, v11, 1);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
LABEL_1:
  v8 = a1;
  while (1)
  {
    v9 = a2 - v8;
    v10 = 0x6DB6DB6DB6DB6DB7 * ((a2 - v8) >> 3);
    v11 = v10 - 2;
    if (v10 > 2)
    {
      switch(v10)
      {
        case 3:

          std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(v8, v8 + 56, (a2 - 7));
          return;
        case 4:
          std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(v8, v8 + 56, v8 + 112);
          if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a2 - 6), *(a2 - 5), v8 + 112))
          {
            return;
          }

          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>((v8 + 112), a2 - 7);
          if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v8 + 120), *(v8 + 128), v8 + 56))
          {
            return;
          }

          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>((v8 + 56), (v8 + 112));
          if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v8 + 64), *(v8 + 72), v8))
          {
            return;
          }

          v38 = (v8 + 56);
          goto LABEL_75;
        case 5:

          std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(v8, v8 + 56, v8 + 112, v8 + 168, (a2 - 7));
          return;
      }
    }

    else
    {
      if (v10 < 2)
      {
        return;
      }

      if (v10 == 2)
      {
        if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a2 - 6), *(a2 - 5), v8))
        {
          return;
        }

        v38 = a2 - 7;
LABEL_75:

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(v8, v38);
        return;
      }
    }

    v101 = a2;
    if (v9 <= 1343)
    {
      break;
    }

    if (!a3)
    {
      if (v8 != a2)
      {
        v55 = v11 >> 1;
        v56 = v11 >> 1;
        do
        {
          v57 = v56;
          if (v55 >= v56)
          {
            v58 = (2 * v56) | 1;
            v59 = v8 + 56 * v58;
            if (2 * v56 + 2 < v10 && TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v59 + 8), *(v59 + 16), v59 + 56))
            {
              v59 += 56;
              v58 = 2 * v57 + 2;
            }

            v60 = v8 + 56 * v57;
            a2 = v101;
            if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v59 + 8), *(v59 + 16), v60))
            {
              v61 = *v60;
              *&v104[16] = *(v60 + 16);
              *v104 = v61;
              v107 = *(v60 + 48);
              v105 = *(v60 + 24);
              v106 = *(v60 + 40);
              *(v60 + 24) = 0;
              *(v60 + 32) = 0;
              *(v60 + 40) = 0;
              do
              {
                v62 = v59;
                *v60 = *v59;
                *(v60 + 8) = *(v59 + 8);
                std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v60 + 24, (v59 + 24));
                if (v55 < v58)
                {
                  break;
                }

                v63 = (2 * v58) | 1;
                v59 = v8 + 56 * v63;
                v64 = 2 * v58 + 2;
                if (v64 < v10 && TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v59 + 8), *(v59 + 16), v59 + 56))
                {
                  v59 += 56;
                  v63 = v64;
                }

                v60 = v62;
                v58 = v63;
              }

              while (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v59 + 8), *(v59 + 16), v104));
              *v62 = *v104;
              *(v62 + 8) = *&v104[8];
              v65 = *(v62 + 24);
              if (v65)
              {
                *(v62 + 32) = v65;
                CFAllocatorDeallocate(*(v62 + 48), v65);
                *(v62 + 24) = 0;
                *(v62 + 32) = 0;
                *(v62 + 40) = 0;
              }

              *(v62 + 24) = v105;
              *(v62 + 40) = v106;
              a2 = v101;
            }
          }

          v56 = v57 - 1;
        }

        while (v57);
        v66 = 0x6DB6DB6DB6DB6DB7 * (v9 >> 3);
        do
        {
          if (v66 >= 2)
          {
            v102 = a2;
            v67 = 0;
            v68 = *v8;
            v103 = *(v8 + 8);
            v95 = *(v8 + 24);
            v99 = *(v8 + 40);
            *(v8 + 32) = 0;
            *(v8 + 40) = 0;
            *(v8 + 24) = 0;
            v69 = v8;
            do
            {
              v70 = v69 + 56 * v67;
              v71 = v70 + 56;
              v72 = (2 * v67) | 1;
              v73 = 2 * v67 + 2;
              if (v73 >= v66)
              {
                v67 = (2 * v67) | 1;
              }

              else
              {
                v74 = v70 + 112;
                if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v70 + 64), *(v70 + 72), v70 + 112))
                {
                  v71 = v74;
                  v67 = v73;
                }

                else
                {
                  v67 = v72;
                }
              }

              *v69 = *v71;
              *(v69 + 8) = *(v71 + 8);
              std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v69 + 24, (v71 + 24));
              v69 = v71;
            }

            while (v67 <= ((v66 - 2) >> 1));
            if (v71 == v102 - 7)
            {
              *v71 = v68;
              *(v71 + 8) = v103;
              v82 = *(v71 + 24);
              if (v82)
              {
                *(v71 + 32) = v82;
                CFAllocatorDeallocate(*(v71 + 48), v82);
              }

              *(v71 + 24) = v95;
              *(v71 + 40) = v99;
            }

            else
            {
              *v71 = *(v102 - 7);
              v75 = v71 + 56;
              *(v71 + 8) = *(v102 - 3);
              std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v71 + 24, v102 - 2);
              *(v102 - 7) = v68;
              *(v102 - 3) = v103;
              v76 = *(v102 - 4);
              if (v76)
              {
                *(v102 - 3) = v76;
                CFAllocatorDeallocate(*(v102 - 1), v76);
              }

              *(v102 - 2) = v95;
              *(v102 - 2) = v99;
              if (v75 - v8 >= 57)
              {
                v77 = (0x6DB6DB6DB6DB6DB7 * ((v75 - v8) >> 3) - 2) >> 1;
                v78 = v8 + 56 * v77;
                if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v78 + 8), *(v78 + 16), v71))
                {
                  v79 = *v71;
                  *&v104[16] = *(v71 + 16);
                  *v104 = v79;
                  v107 = *(v71 + 48);
                  v105 = *(v71 + 24);
                  v106 = *(v71 + 40);
                  *(v71 + 24) = 0;
                  *(v71 + 32) = 0;
                  *(v71 + 40) = 0;
                  do
                  {
                    v80 = v78;
                    *v71 = *v78;
                    *(v71 + 8) = *(v78 + 8);
                    std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v71 + 24, (v78 + 24));
                    if (!v77)
                    {
                      break;
                    }

                    v77 = (v77 - 1) >> 1;
                    v78 = v8 + 56 * v77;
                    v71 = v80;
                  }

                  while (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v78 + 8), *(v78 + 16), v104));
                  *v80 = *v104;
                  *(v80 + 8) = *&v104[8];
                  v81 = *(v80 + 24);
                  if (v81)
                  {
                    *(v80 + 32) = v81;
                    CFAllocatorDeallocate(*(v80 + 48), v81);
                    *(v80 + 24) = 0;
                    *(v80 + 32) = 0;
                    *(v80 + 40) = 0;
                  }

                  *(v80 + 24) = v105;
                  *(v80 + 40) = v106;
                }
              }
            }

            a2 = v102;
          }

          a2 -= 7;
        }

        while (v66-- > 2);
      }

      return;
    }

    v12 = v8 + 56 * (v10 >> 1);
    if (v9 < 0x1C01)
    {
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(v12, v8, (a2 - 7));
    }

    else
    {
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(v8, v12, (a2 - 7));
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>((v8 + 56), v12 - 56, (a2 - 14));
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>((v8 + 112), v12 + 56, (a2 - 21));
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>((v12 - 56), v12, v12 + 56);
      v13 = *v8;
      *v104 = *(v8 + 8);
      v96 = *(v8 + 24);
      v14 = *(v8 + 40);
      *(v8 + 32) = 0;
      *(v8 + 40) = 0;
      *(v8 + 24) = 0;
      *v8 = *v12;
      *(v8 + 8) = *(v12 + 8);
      std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v8 + 24, (v12 + 24));
      *v12 = v13;
      *(v12 + 8) = *v104;
      v15 = *(v12 + 24);
      if (v15)
      {
        *(v12 + 32) = v15;
        CFAllocatorDeallocate(*(v12 + 48), v15);
      }

      *(v12 + 24) = v96;
      *(v12 + 40) = v14;
    }

    --a3;
    if ((a4 & 1) == 0 && !TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v8 - 48), *(v8 - 40), v8))
    {
      v32 = *(v8 + 8);
      v94 = *v8;
      v33 = *(v8 + 16);
      v97 = *(v8 + 24);
      v34 = *(v8 + 40);
      *(v8 + 24) = 0;
      *(v8 + 32) = 0;
      *(v8 + 40) = 0;
      if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v32, v33, (a2 - 7)))
      {
        a1 = v8;
        do
        {
          a1 += 7;
        }

        while (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v32, v33, a1));
      }

      else
      {
        v35 = v8 + 56;
        do
        {
          a1 = v35;
          if (v35 >= a2)
          {
            break;
          }

          v36 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v32, v33, v35);
          v35 = (a1 + 7);
        }

        while (!v36);
      }

      if (a1 < a2)
      {
        do
        {
          a2 -= 7;
        }

        while (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v32, v33, a2));
      }

      while (a1 < a2)
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, a2);
        do
        {
          a1 += 7;
        }

        while (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v32, v33, a1));
        do
        {
          a2 -= 7;
        }

        while (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v32, v33, a2));
      }

      if (a1 - 7 != v8)
      {
        *v8 = *(a1 - 7);
        *(v8 + 8) = *(a1 - 3);
        std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v8 + 24, a1 - 2);
      }

      *(a1 - 7) = v94;
      *(a1 - 6) = v32;
      *(a1 - 5) = v33;
      v37 = *(a1 - 4);
      a2 = v101;
      if (v37)
      {
        *(a1 - 3) = v37;
        CFAllocatorDeallocate(*(a1 - 1), v37);
      }

      a4 = 0;
      *(a1 - 2) = v97;
      *(a1 - 2) = v34;
      goto LABEL_1;
    }

    v16 = *v8;
    *&v104[16] = *(v8 + 16);
    *v104 = v16;
    v107 = *(v8 + 48);
    v105 = *(v8 + 24);
    v106 = *(v8 + 40);
    *(v8 + 24) = 0;
    *(v8 + 32) = 0;
    *(v8 + 40) = 0;
    v17 = v8;
    do
    {
      v18 = v17;
      v17 += 7;
    }

    while (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v18[8], v18[9], v104));
    v19 = a2;
    if (v18 == v8)
    {
      v22 = a2;
      while (v17 < v22)
      {
        v20 = v22 - 7;
        v23 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v22 - 6), *(v22 - 5), v104);
        v22 = v20;
        if (v23)
        {
          goto LABEL_28;
        }
      }

      v20 = v22;
    }

    else
    {
      do
      {
        v20 = v19 - 7;
        v21 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v19 - 6), *(v19 - 5), v104);
        v19 = v20;
      }

      while (!v21);
    }

LABEL_28:
    if (v17 >= v20)
    {
      a1 = v17;
    }

    else
    {
      v24 = v20;
      a1 = v17;
      do
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, v24);
        do
        {
          v25 = a1[8];
          v26 = a1[9];
          a1 += 7;
        }

        while (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v25, v26, v104));
        do
        {
          v27 = *(v24 - 6);
          v28 = *(v24 - 5);
          v24 -= 7;
        }

        while (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v27, v28, v104));
      }

      while (a1 < v24);
    }

    if (a1 - 7 != v8)
    {
      *v8 = *(a1 - 7);
      *(v8 + 8) = *(a1 - 3);
      std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v8 + 24, a1 - 2);
    }

    v29 = *(a1 - 4);
    *(a1 - 7) = *v104;
    *(a1 - 3) = *&v104[8];
    if (v29)
    {
      *(a1 - 3) = v29;
      CFAllocatorDeallocate(*(a1 - 1), v29);
      *(a1 - 4) = 0;
      *(a1 - 3) = 0;
      *(a1 - 2) = 0;
    }

    *(a1 - 2) = v105;
    *(a1 - 2) = v106;
    v30 = v17 >= v20;
    a2 = v101;
    if (!v30)
    {
      goto LABEL_46;
    }

    v31 = std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(v8, (a1 - 7));
    if (!std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(a1, v101))
    {
      if (v31)
      {
        goto LABEL_1;
      }

LABEL_46:
      std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,false>(v8, a1 - 7, a3, a4 & 1);
      a4 = 0;
      goto LABEL_1;
    }

    a2 = a1 - 7;
    if (v31)
    {
      return;
    }
  }

  v40 = (v8 + 56);
  v42 = v8 == a2 || v40 == a2;
  if (a4)
  {
    if (!v42)
    {
      v43 = 0;
      v44 = v8;
      do
      {
        v45 = v40;
        if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v40[1], v40[2], v44))
        {
          v47 = *v45;
          v46 = v45[1];
          v48 = v45[2];
          v98 = *(v44 + 80);
          v49 = *(v44 + 96);
          *(v44 + 80) = 0;
          *(v44 + 88) = 0;
          v50 = v43;
          *(v44 + 96) = 0;
          while (1)
          {
            v51 = v50;
            v52 = v8 + v50;
            *(v52 + 56) = *(v8 + v50);
            *(v52 + 64) = *(v8 + v50 + 8);
            std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v8 + v50 + 80, (v8 + v50 + 24));
            if (!v50)
            {
              break;
            }

            v50 -= 56;
            if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v46, v48, v51 - 56 + v8))
            {
              v52 = v8 + v51;
              v53 = (v8 + v51);
              goto LABEL_96;
            }
          }

          v53 = v8;
LABEL_96:
          *v53 = v47;
          *(v52 + 8) = v46;
          *(v52 + 16) = v48;
          v54 = *(v52 + 24);
          if (v54)
          {
            *(v52 + 32) = v54;
            CFAllocatorDeallocate(*(v52 + 48), v54);
          }

          *(v52 + 24) = v98;
          *(v52 + 40) = v49;
          a2 = v101;
        }

        v40 = v45 + 7;
        v43 += 56;
        v44 = v45;
      }

      while (v45 + 7 != a2);
    }
  }

  else if (!v42)
  {
    v84 = v8 + 80;
    do
    {
      v85 = v40;
      if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v40[1], v40[2], v8))
      {
        v86 = *v85;
        v87 = v85[1];
        v88 = v85[2];
        v100 = *(v8 + 80);
        v89 = *(v8 + 96);
        *(v8 + 80) = 0;
        *(v8 + 88) = 0;
        v90 = v84;
        *(v8 + 96) = 0;
        do
        {
          *(v90 - 24) = *(v90 - 80);
          *(v90 - 16) = *(v90 - 72);
          std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v90, (v90 - 56));
          v92 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v87, v88, v90 - 136);
          v91 = v90 - 56;
          v90 -= 56;
        }

        while (v92);
        *(v91 - 24) = v86;
        *(v91 - 16) = v87;
        *(v91 - 8) = v88;
        v93 = *v91;
        if (*v91)
        {
          *(v91 + 8) = v93;
          CFAllocatorDeallocate(*(v91 + 24), v93);
        }

        *v91 = v100;
        *(v91 + 16) = v89;
        a2 = v101;
      }

      v40 = v85 + 7;
      v84 += 56;
      v8 = v85;
    }

    while (v85 + 7 != a2);
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  v7 = result;
LABEL_2:
  v8 = (a2 - 24);
  v9 = v7;
  while (1)
  {
    v7 = v9;
    v10 = a2 - v9;
    v11 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v9) >> 3);
    if (v11 > 2)
    {
      switch(v11)
      {
        case 3:

          return std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(v9, (v9 + 24), (a2 - 24));
        case 4:

          return std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(v9, (v9 + 24), (v9 + 48), (a2 - 24));
        case 5:

          return std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(v9, v9 + 24, v9 + 48, v9 + 72, a2 - 24);
      }
    }

    else
    {
      if (v11 < 2)
      {
        return result;
      }

      if (v11 == 2)
      {
        v117 = *(a2 - 8);
        v118 = *(v9 + 16);
        v119 = v117 > v118;
        if (v117 == v118 && (v120 = *(a2 - 7), v121 = *(v9 + 17), v119 = v120 > v121, v120 == v121) && (v122 = *(a2 - 6), v123 = *(v9 + 18), v119 = v122 > v123, v122 == v123))
        {
          v124 = *(a2 - 16);
          v125 = *(v9 + 8);
          if (v124)
          {
            v126 = *(*(a2 - 24) + v124 - 1) != 42;
          }

          else
          {
            v126 = -1;
          }

          if (v125)
          {
            v273 = *(*v9 + v125 - 1) != 42;
          }

          else
          {
            v273 = -1;
          }

          if (v126 <= v273)
          {
            return result;
          }
        }

        else if (!v119)
        {
          return result;
        }

        *&v277[16] = *(v9 + 16);
        *v277 = *v9;
        v205 = *v8;
        *(v9 + 15) = *(a2 - 9);
        *v9 = v205;
        *(a2 - 9) = *&v277[15];
        *v8 = *v277;
        return result;
      }
    }

    if (v10 <= 575)
    {
      break;
    }

    if (!a3)
    {
      if (v9 == a2)
      {
        return result;
      }

      v154 = (v11 - 2) >> 1;
      v155 = v154;
      while (1)
      {
        v156 = v155;
        if (v154 < v155)
        {
          goto LABEL_306;
        }

        v157 = (2 * v155) | 1;
        v158 = v9 + 24 * v157;
        if (2 * v156 + 2 < v11)
        {
          v159 = *(v158 + 16);
          v160 = *(v158 + 40);
          v161 = v159 > v160;
          if (v159 != v160 || (v162 = *(v158 + 17), v163 = *(v158 + 41), v161 = v162 > v163, v162 != v163) || (v164 = *(v158 + 18), v165 = *(v158 + 42), v161 = v164 > v165, v164 != v165))
          {
            if (!v161)
            {
              goto LABEL_268;
            }

LABEL_267:
            v158 += 24;
            v157 = 2 * v156 + 2;
            goto LABEL_268;
          }

          v166 = *(v158 + 8);
          if (v166)
          {
            v167 = *(*v158 + v166 - 1) != 42;
          }

          else
          {
            v167 = -1;
          }

          v203 = *(v158 + 32);
          if (v203)
          {
            v204 = *(*(v158 + 24) + v203 - 1) != 42;
          }

          else
          {
            v204 = -1;
          }

          if (v167 > v204)
          {
            goto LABEL_267;
          }
        }

LABEL_268:
        v168 = v9 + 24 * v156;
        v169 = *(v158 + 16);
        v170 = *v168;
        v171 = *(v168 + 8);
        v172 = *(v168 + 16);
        result = *(v168 + 17);
        v173 = *(v168 + 18);
        v174 = v169 > v172;
        if (v169 == v172)
        {
          v175 = *(v158 + 17);
          v174 = v175 > result;
          if (v175 == result)
          {
            v176 = *(v158 + 18);
            v174 = v176 > v173;
            if (v176 == v173)
            {
              v177 = *(v158 + 8);
              if (v177)
              {
                v178 = *(*v158 + v177 - 1) != 42;
                if (v171)
                {
                  goto LABEL_273;
                }

LABEL_309:
                v179 = -1;
              }

              else
              {
                v178 = -1;
                if (!v171)
                {
                  goto LABEL_309;
                }

LABEL_273:
                v179 = *(v170 + v171 - 1) != 42;
              }

              if (v178 > v179)
              {
                goto LABEL_306;
              }

              goto LABEL_275;
            }
          }
        }

        if (v174)
        {
          goto LABEL_306;
        }

LABEL_275:
        v180 = *v158;
        *(v168 + 15) = *(v158 + 15);
        *v168 = v180;
        if (v154 < v157)
        {
          goto LABEL_305;
        }

        while (1)
        {
          v181 = v158;
          v182 = 2 * v157;
          v157 = (2 * v157) | 1;
          v158 = v9 + 24 * v157;
          v183 = v182 + 2;
          if (v183 < v11)
          {
            v184 = *(v158 + 16);
            v185 = *(v158 + 40);
            v186 = v184 > v185;
            if (v184 != v185 || (v187 = *(v158 + 17), v188 = *(v158 + 41), v186 = v187 > v188, v187 != v188) || (v189 = *(v158 + 18), v190 = *(v158 + 42), v186 = v189 > v190, v189 != v190))
            {
              if (!v186)
              {
                goto LABEL_285;
              }

LABEL_284:
              v158 += 24;
              v157 = v183;
              goto LABEL_285;
            }

            v191 = *(v158 + 8);
            if (v191)
            {
              v192 = *(*v158 + v191 - 1) != 42;
            }

            else
            {
              v192 = -1;
            }

            v201 = *(v158 + 32);
            if (v201)
            {
              v202 = *(*(v158 + 24) + v201 - 1) != 42;
            }

            else
            {
              v202 = -1;
            }

            if (v192 > v202)
            {
              goto LABEL_284;
            }
          }

LABEL_285:
          v193 = *(v158 + 16);
          v194 = v193 > v172;
          if (v193 != v172 || (v195 = *(v158 + 17), v194 = v195 > result, v195 != result) || (v196 = *(v158 + 18), v194 = v196 > v173, v196 != v173))
          {
            if (v194)
            {
              break;
            }

            goto LABEL_292;
          }

          v197 = *(v158 + 8);
          if (v197)
          {
            v198 = *(*v158 + v197 - 1) != 42;
            if (v171)
            {
              goto LABEL_290;
            }
          }

          else
          {
            v198 = -1;
            if (v171)
            {
LABEL_290:
              v199 = *(v170 + v171 - 1) != 42;
              goto LABEL_296;
            }
          }

          v199 = -1;
LABEL_296:
          if (v198 > v199)
          {
            break;
          }

LABEL_292:
          v200 = *v158;
          *(v181 + 15) = *(v158 + 15);
          *v181 = v200;
          if (v154 < v157)
          {
            goto LABEL_305;
          }
        }

        v158 = v181;
LABEL_305:
        *v158 = v170;
        *(v158 + 8) = v171;
        *(v158 + 16) = v172;
        *(v158 + 17) = result;
        *(v158 + 18) = v173;
LABEL_306:
        v155 = v156 - 1;
        if (!v156)
        {
          v206 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3);
          while (1)
          {
            v207 = 0;
            *&v278[16] = *(v9 + 16);
            *v278 = *v9;
            v208 = v9;
            do
            {
              v209 = v208;
              v210 = v208 + 24 * v207;
              v208 = v210 + 24;
              v211 = 2 * v207;
              v207 = (2 * v207) | 1;
              v212 = v211 + 2;
              if (v212 >= v206)
              {
                goto LABEL_331;
              }

              v215 = *(v210 + 48);
              v213 = v210 + 48;
              v214 = v215;
              result = *(v213 - 8);
              v216 = *(v213 + 16);
              v217 = result > v216;
              if (result == v216 && (result = *(v213 - 7), v218 = *(v213 + 17), v217 = result > v218, result == v218) && (result = *(v213 - 6), v219 = *(v213 + 18), v217 = result > v219, result == v219))
              {
                v220 = *(v213 - 16);
                if (v220)
                {
                  result = *(*(v213 - 24) + v220 - 1) != 42;
                }

                else
                {
                  result = 0xFFFFFFFFLL;
                }

                v222 = *(v213 + 8);
                if (v222)
                {
                  v223 = *(v214 + v222 - 1) != 42;
                }

                else
                {
                  v223 = -1;
                }

                if (result > v223)
                {
LABEL_330:
                  v208 = v213;
                  v207 = v212;
                }
              }

              else if (v217)
              {
                goto LABEL_330;
              }

LABEL_331:
              v221 = *v208;
              *(v209 + 15) = *(v208 + 15);
              *v209 = v221;
            }

            while (v207 <= (v206 - 2) / 2);
            a2 -= 24;
            if (v208 == a2)
            {
              *(v208 + 15) = *&v278[15];
              *v208 = *v278;
              goto LABEL_353;
            }

            v224 = *a2;
            *(v208 + 15) = *(a2 + 15);
            *v208 = v224;
            *(a2 + 15) = *&v278[15];
            *a2 = *v278;
            v225 = v208 - v9 + 24;
            if (v225 < 25)
            {
              goto LABEL_353;
            }

            v226 = 0xAAAAAAAAAAAAAAABLL * (v225 >> 3) - 2;
            result = v226 >> 1;
            v227 = v9 + 24 * (v226 >> 1);
            v228 = *(v227 + 16);
            v229 = *v208;
            v230 = *(v208 + 8);
            v231 = *(v208 + 16);
            v232 = *(v208 + 17);
            v233 = *(v208 + 18);
            v234 = v228 > v231;
            if (v228 != v231 || (v235 = *(v227 + 17), v234 = v235 > v232, v235 != v232) || (v236 = *(v227 + 18), v234 = v236 > v233, v236 != v233))
            {
              if (!v234)
              {
                goto LABEL_353;
              }

LABEL_350:
              v240 = *v227;
              *(v208 + 15) = *(v227 + 15);
              *v208 = v240;
              if (v226 < 2)
              {
LABEL_351:
                v241 = v227;
LABEL_352:
                *v241 = v229;
                *(v241 + 8) = v230;
                *(v241 + 16) = v231;
                *(v241 + 17) = v232;
                *(v241 + 18) = v233;
                goto LABEL_353;
              }

              while (2)
              {
                v242 = result - 1;
                result = (result - 1) >> 1;
                v241 = v9 + 24 * result;
                v243 = *(v241 + 16);
                v244 = v243 > v231;
                if (v243 == v231 && (v245 = *(v241 + 17), v244 = v245 > v232, v245 == v232) && (v246 = *(v241 + 18), v244 = v246 > v233, v246 == v233))
                {
                  v247 = *(v241 + 8);
                  if (v247)
                  {
                    v248 = *(*v241 + v247 - 1) != 42;
                    if (v230)
                    {
                      goto LABEL_361;
                    }

LABEL_367:
                    v249 = -1;
                  }

                  else
                  {
                    v248 = -1;
                    if (!v230)
                    {
                      goto LABEL_367;
                    }

LABEL_361:
                    v249 = *(v229 + v230 - 1) != 42;
                  }

                  if (v248 <= v249)
                  {
                    goto LABEL_351;
                  }
                }

                else if (!v244)
                {
                  goto LABEL_351;
                }

                v250 = *v241;
                *(v227 + 15) = *(v241 + 15);
                *v227 = v250;
                v227 = v9 + 24 * result;
                if (v242 <= 1)
                {
                  goto LABEL_352;
                }

                continue;
              }
            }

            v237 = *(v227 + 8);
            if (v237)
            {
              v238 = *(*v227 + v237 - 1) != 42;
              if (v230)
              {
                goto LABEL_346;
              }

LABEL_371:
              v239 = -1;
            }

            else
            {
              v238 = -1;
              if (!v230)
              {
                goto LABEL_371;
              }

LABEL_346:
              v239 = *(v229 + v230 - 1) != 42;
            }

            if (v238 > v239)
            {
              goto LABEL_350;
            }

LABEL_353:
            v32 = v206-- <= 2;
            if (v32)
            {
              return result;
            }
          }
        }
      }
    }

    v12 = v11 >> 1;
    v13 = v9 + 24 * (v11 >> 1);
    if (v10 < 0xC01)
    {
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>((v7 + 24 * v12), v7, (a2 - 24));
    }

    else
    {
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(v7, (v7 + 24 * v12), (a2 - 24));
      v14 = 3 * v12;
      v15 = (v7 + 24 * v12 - 24);
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>((v7 + 24), v15, (a2 - 48));
      v16 = (v7 + 24 + 8 * v14);
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>((v7 + 48), v16, (a2 - 72));
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(v15, v13, v16);
      *&v274[16] = *(v7 + 16);
      *v274 = *v7;
      v17 = *(v13 + 15);
      *v7 = *v13;
      *(v7 + 15) = v17;
      *(v13 + 15) = *&v274[15];
      *v13 = *v274;
    }

    --a3;
    v18 = *v7;
    if (a4)
    {
      v19 = *(v7 + 8);
      v20 = *(v7 + 16);
      v21 = *(v7 + 17);
      v22 = *(v7 + 18);
LABEL_35:
      v29 = v18 + v19;
      for (i = v7 + 24; ; i += 24)
      {
        v31 = *(i + 16);
        v32 = v31 > v20;
        if (v31 == v20)
        {
          v33 = *(i + 17);
          v32 = v33 > v21;
          if (v33 == v21)
          {
            v34 = *(i + 18);
            v32 = v34 > v22;
            if (v34 == v22)
            {
              break;
            }
          }
        }

        if (!v32)
        {
          goto LABEL_48;
        }

LABEL_44:
        ;
      }

      v35 = *(i + 8);
      if (v35)
      {
        v36 = *(*i + v35 - 1) != 42;
        if (v19)
        {
          goto LABEL_41;
        }
      }

      else
      {
        v36 = -1;
        if (v19)
        {
LABEL_41:
          v37 = *(v29 - 1) != 42;
          goto LABEL_47;
        }
      }

      v37 = -1;
LABEL_47:
      if (v36 > v37)
      {
        goto LABEL_44;
      }

LABEL_48:
      v38 = a2 - 24;
      if (i - 24 != v7)
      {
        while (2)
        {
          v39 = *(v38 + 16);
          v40 = v39 > v20;
          if (v39 == v20 && (v41 = *(v38 + 17), v40 = v41 > v21, v41 == v21) && (v42 = *(v38 + 18), v40 = v42 > v22, v42 == v22))
          {
            v43 = *(v38 + 8);
            if (v43)
            {
              v44 = *(*v38 + v43 - 1) != 42;
              if (v19)
              {
                goto LABEL_54;
              }

LABEL_58:
              v45 = -1;
            }

            else
            {
              v44 = -1;
              if (!v19)
              {
                goto LABEL_58;
              }

LABEL_54:
              v45 = *(v29 - 1) != 42;
            }

            if (v44 > v45)
            {
              goto LABEL_78;
            }
          }

          else if (v40)
          {
            goto LABEL_78;
          }

          v38 -= 24;
          continue;
        }
      }

      v38 = a2;
      if (i < a2)
      {
        v38 = a2 - 24;
        while (2)
        {
          v46 = *(v38 + 16);
          v47 = v46 > v20;
          if (v46 == v20 && (v48 = *(v38 + 17), v47 = v48 > v21, v48 == v21) && (v49 = *(v38 + 18), v47 = v49 > v22, v49 == v22))
          {
            v50 = *(v38 + 8);
            if (v50)
            {
              v51 = *(*v38 + v50 - 1) != 42;
              if (v19)
              {
                goto LABEL_68;
              }

LABEL_75:
              v52 = -1;
            }

            else
            {
              v51 = -1;
              if (!v19)
              {
                goto LABEL_75;
              }

LABEL_68:
              v52 = *(v29 - 1) != 42;
            }

            if (v51 > v52 || i >= v38)
            {
              break;
            }
          }

          else if (v47 || i >= v38)
          {
            break;
          }

          v38 -= 24;
          continue;
        }
      }

LABEL_78:
      v9 = i;
      if (i >= v38)
      {
        goto LABEL_105;
      }

      v9 = i;
      v54 = v38;
      while (2)
      {
        *&v275[16] = *(v9 + 16);
        *v275 = *v9;
        v55 = *v54;
        *(v9 + 15) = *(v54 + 15);
        *v9 = v55;
        *(v54 + 15) = *&v275[15];
        *v54 = *v275;
        v56 = v9 + 24;
        while (2)
        {
          while (1)
          {
            v9 = v56;
            v57 = *(v56 + 16);
            v56 += 24;
            v58 = v57 > v20;
            if (v57 == v20)
            {
              v59 = *(v9 + 17);
              v58 = v59 > v21;
              if (v59 == v21)
              {
                v60 = *(v9 + 18);
                v58 = v60 > v22;
                if (v60 == v22)
                {
                  break;
                }
              }
            }

            if (!v58)
            {
              goto LABEL_92;
            }
          }

          v61 = *(v9 + 8);
          if (v61)
          {
            v62 = *(*v9 + v61 - 1) != 42;
            if (v19)
            {
              goto LABEL_86;
            }

LABEL_90:
            v63 = -1;
          }

          else
          {
            v62 = -1;
            if (!v19)
            {
              goto LABEL_90;
            }

LABEL_86:
            v63 = *(v29 - 1) != 42;
          }

          if (v62 > v63)
          {
            continue;
          }

          break;
        }

LABEL_92:
        while (2)
        {
          while (1)
          {
            v54 -= 24;
            v64 = *(v54 + 16);
            v65 = v64 > v20;
            if (v64 == v20)
            {
              v66 = *(v54 + 17);
              v65 = v66 > v21;
              if (v66 == v21)
              {
                v67 = *(v54 + 18);
                v65 = v67 > v22;
                if (v67 == v22)
                {
                  break;
                }
              }
            }

            if (v65)
            {
              goto LABEL_104;
            }
          }

          v68 = *(v54 + 8);
          if (v68)
          {
            v69 = *(*v54 + v68 - 1) != 42;
            if (v19)
            {
              goto LABEL_97;
            }

LABEL_102:
            v70 = -1;
          }

          else
          {
            v69 = -1;
            if (!v19)
            {
              goto LABEL_102;
            }

LABEL_97:
            v70 = *(v29 - 1) != 42;
          }

          if (v69 <= v70)
          {
            continue;
          }

          break;
        }

LABEL_104:
        if (v9 < v54)
        {
          continue;
        }

        break;
      }

LABEL_105:
      if (v9 - 24 != v7)
      {
        v71 = *(v9 - 24);
        *(v7 + 15) = *(v9 - 9);
        *v7 = v71;
      }

      *(v9 - 24) = v18;
      *(v9 - 16) = v19;
      *(v9 - 8) = v20;
      *(v9 - 7) = v21;
      *(v9 - 6) = v22;
      if (i < v38)
      {
LABEL_110:
        result = std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,false>(v7, v9 - 24, a3, a4 & 1);
        a4 = 0;
      }

      else
      {
        v72 = std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(v7, v9 - 24);
        result = std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(v9, a2);
        if (result)
        {
          a2 = v9 - 24;
          if (v72)
          {
            return result;
          }

          goto LABEL_2;
        }

        if (!v72)
        {
          goto LABEL_110;
        }
      }
    }

    else
    {
      v23 = *(v7 - 8);
      v19 = *(v7 + 8);
      v20 = *(v7 + 16);
      v21 = *(v7 + 17);
      v22 = *(v7 + 18);
      if (v23 == v20)
      {
        v24 = *(v7 - 7);
        if (v24 != v21)
        {
          if (v24 > v21)
          {
            goto LABEL_34;
          }

          goto LABEL_111;
        }

        v25 = *(v7 - 6);
        if (v25 != v22)
        {
          if (v25 > v22)
          {
            goto LABEL_33;
          }

          goto LABEL_111;
        }

        v26 = *(v7 - 16);
        if (v26)
        {
          v27 = *(*(v7 - 24) + v26 - 1) != 42;
          if (v19)
          {
LABEL_22:
            v28 = *(v18 + v19 - 1) != 42;
            goto LABEL_31;
          }
        }

        else
        {
          v27 = -1;
          if (v19)
          {
            goto LABEL_22;
          }
        }

        v28 = -1;
LABEL_31:
        if (v27 > v28)
        {
          v22 = *(v7 - 6);
LABEL_33:
          v21 = *(v7 - 7);
LABEL_34:
          v20 = *(v7 - 8);
          goto LABEL_35;
        }

        goto LABEL_111;
      }

      if (v23 > v20)
      {
        goto LABEL_35;
      }

LABEL_111:
      v73 = *(a2 - 24);
      v74 = *(a2 - 16);
      result = *(a2 - 8);
      v75 = *(a2 - 7);
      v76 = *(a2 - 6);
      v77 = v20 > result;
      if (v20 == result && (v77 = v21 > v75, v21 == v75) && (v77 = v22 > v76, v22 == v76))
      {
        if (v19)
        {
          v78 = *(v18 + v19 - 1) != 42;
        }

        else
        {
          v78 = -1;
        }

        if (v74)
        {
          v87 = *(v73 + v74 - 1) != 42;
        }

        else
        {
          v87 = -1;
        }

        if (v78 <= v87)
        {
LABEL_138:
          v9 = v7 + 24;
          if (v7 + 24 < a2)
          {
            while (1)
            {
              v88 = *(v9 + 16);
              v89 = v20 > v88;
              if (v20 == v88 && (v90 = *(v9 + 17), v89 = v21 > v90, v21 == v90) && (v91 = *(v9 + 18), v89 = v22 > v91, v22 == v91))
              {
                if (v19)
                {
                  v92 = *(v18 + v19 - 1) != 42;
                }

                else
                {
                  v92 = -1;
                }

                v93 = *(v9 + 8);
                if (v93)
                {
                  v94 = *(*v9 + v93 - 1) != 42;
                }

                else
                {
                  v94 = -1;
                }

                if (v92 > v94)
                {
                  goto LABEL_152;
                }
              }

              else if (v89)
              {
                goto LABEL_152;
              }

              v9 += 24;
              if (v9 >= a2)
              {
                goto LABEL_152;
              }
            }
          }

          goto LABEL_152;
        }
      }

      else if (!v77)
      {
        goto LABEL_138;
      }

      v79 = v7 + 24;
      do
      {
        while (1)
        {
          v9 = v79;
          v80 = *(v79 + 16);
          v79 += 24;
          v81 = v20 > v80;
          if (v20 == v80)
          {
            v82 = *(v9 + 17);
            v81 = v21 > v82;
            if (v21 == v82)
            {
              v83 = *(v9 + 18);
              v81 = v22 > v83;
              if (v22 == v83)
              {
                break;
              }
            }
          }

          if (v81)
          {
            goto LABEL_152;
          }
        }

        if (v19)
        {
          v84 = *(v18 + v19 - 1) != 42;
        }

        else
        {
          v84 = -1;
        }

        v85 = *(v9 + 8);
        if (v85)
        {
          v86 = *(*v9 + v85 - 1) != 42;
        }

        else
        {
          v86 = -1;
        }
      }

      while (v84 <= v86);
LABEL_152:
      v95 = a2;
      if (v9 < a2)
      {
        v95 = a2 - 24;
        while (2)
        {
          v96 = v20 > result;
          if (v20 == result && (v96 = v21 > v75, v21 == v75) && (v96 = v22 > v76, v22 == v76))
          {
            if (v19)
            {
              v97 = *(v18 + v19 - 1) != 42;
              if (v74)
              {
                goto LABEL_159;
              }

LABEL_164:
              v98 = -1;
            }

            else
            {
              v97 = -1;
              if (!v74)
              {
                goto LABEL_164;
              }

LABEL_159:
              v98 = *(v73 + v74 - 1) != 42;
            }

            if (v97 <= v98)
            {
              break;
            }
          }

          else if (!v96)
          {
            break;
          }

          v73 = *(v95 - 24);
          v74 = *(v95 - 16);
          v95 -= 24;
          result = *(v95 + 16);
          v75 = *(v95 + 17);
          v76 = *(v95 + 18);
          continue;
        }
      }

      if (v9 < v95)
      {
        v99 = v18 + v19;
        do
        {
          *&v276[16] = *(v9 + 16);
          *v276 = *v9;
          v100 = *v95;
          *(v9 + 15) = *(v95 + 15);
          *v9 = v100;
          *(v95 + 15) = *&v276[15];
          *v95 = *v276;
          v101 = v9 + 24;
          do
          {
            while (1)
            {
              v9 = v101;
              v102 = *(v101 + 16);
              v101 += 24;
              v103 = v20 > v102;
              if (v20 == v102)
              {
                v104 = *(v9 + 17);
                v103 = v21 > v104;
                if (v21 == v104)
                {
                  v105 = *(v9 + 18);
                  v103 = v22 > v105;
                  if (v22 == v105)
                  {
                    break;
                  }
                }
              }

              if (v103)
              {
                goto LABEL_182;
              }
            }

            if (v19)
            {
              v106 = *(v99 - 1) != 42;
            }

            else
            {
              v106 = -1;
            }

            v107 = *(v9 + 8);
            if (v107)
            {
              result = *v9;
              v108 = *(*v9 + v107 - 1) != 42;
            }

            else
            {
              v108 = -1;
            }
          }

          while (v106 <= v108);
          do
          {
LABEL_182:
            while (1)
            {
              v95 -= 24;
              v109 = *(v95 + 16);
              v110 = v20 > v109;
              if (v20 == v109)
              {
                v111 = *(v95 + 17);
                v110 = v21 > v111;
                if (v21 == v111)
                {
                  v112 = *(v95 + 18);
                  v110 = v22 > v112;
                  if (v22 == v112)
                  {
                    break;
                  }
                }
              }

              if (!v110)
              {
                goto LABEL_194;
              }
            }

            if (v19)
            {
              v113 = *(v99 - 1) != 42;
            }

            else
            {
              v113 = -1;
            }

            v114 = *(v95 + 8);
            if (v114)
            {
              v115 = *(*v95 + v114 - 1) != 42;
            }

            else
            {
              v115 = -1;
            }
          }

          while (v113 > v115);
LABEL_194:
          ;
        }

        while (v9 < v95);
      }

      if (v9 - 24 != v7)
      {
        v116 = *(v9 - 24);
        *(v7 + 15) = *(v9 - 9);
        *v7 = v116;
      }

      a4 = 0;
      *(v9 - 24) = v18;
      *(v9 - 16) = v19;
      *(v9 - 8) = v20;
      *(v9 - 7) = v21;
      *(v9 - 6) = v22;
    }
  }

  v127 = v9 + 24;
  v129 = v9 == a2 || v127 == a2;
  if ((a4 & 1) == 0)
  {
    if (v129)
    {
      return result;
    }

    while (1)
    {
      v251 = v7;
      v7 = v127;
      v252 = *(v251 + 24);
      v253 = *(v251 + 32);
      v254 = *(v251 + 40);
      v255 = *(v251 + 41);
      v256 = *(v251 + 42);
      v257 = *(v251 + 16);
      v258 = v254 > v257;
      if (v254 == v257 && (v259 = *(v251 + 17), v258 = v255 > v259, v255 == v259) && (v260 = *(v251 + 18), v258 = v256 > v260, v256 == v260))
      {
        if (v253)
        {
          v261 = *(v252 + v253 - 1) != 42;
        }

        else
        {
          v261 = -1;
        }

        v271 = *(v251 + 8);
        if (v271)
        {
          v272 = *(*v251 + v271 - 1) != 42;
        }

        else
        {
          v272 = -1;
        }

        if (v261 <= v272)
        {
          goto LABEL_397;
        }
      }

      else if (!v258)
      {
        goto LABEL_397;
      }

      for (j = v7; ; j -= 24)
      {
        *j = *(j - 24);
        *(j + 15) = *(j - 9);
        v263 = *(j - 32);
        v264 = v254 > v263;
        if (v254 == v263)
        {
          v265 = *(j - 31);
          v264 = v255 > v265;
          if (v255 == v265)
          {
            v266 = *(j - 30);
            v264 = v256 > v266;
            if (v256 == v266)
            {
              break;
            }
          }
        }

        if (!v264)
        {
          goto LABEL_396;
        }

LABEL_390:
        ;
      }

      if (v253)
      {
        v267 = *(v252 + v253 - 1) != 42;
      }

      else
      {
        v267 = -1;
      }

      v268 = *(j - 40);
      if (v268)
      {
        v269 = *(*(j - 48) + v268 - 1) != 42;
      }

      else
      {
        v269 = -1;
      }

      if (v267 > v269)
      {
        goto LABEL_390;
      }

LABEL_396:
      v270 = j - 24;
      *(j - 24) = v252;
      *(v270 + 8) = v253;
      *(v270 + 16) = v254;
      *(v270 + 17) = v255;
      *(v270 + 18) = v256;
LABEL_397:
      v127 = v7 + 24;
      if (v7 + 24 == a2)
      {
        return result;
      }
    }
  }

  if (v129)
  {
    return result;
  }

  v130 = 0;
  v131 = v9;
  while (2)
  {
    v132 = v131;
    v131 = v127;
    v133 = *(v132 + 24);
    v134 = *(v132 + 32);
    v135 = *(v132 + 40);
    v136 = *(v132 + 41);
    v137 = *(v132 + 42);
    v138 = *(v132 + 16);
    v139 = v135 > v138;
    if (v135 == v138 && (v140 = *(v132 + 17), v139 = v136 > v140, v136 == v140) && (v141 = *(v132 + 18), v139 = v137 > v141, v137 == v141))
    {
      if (v134)
      {
        v142 = *(v133 + v134 - 1) != 42;
      }

      else
      {
        v142 = -1;
      }

      v152 = *(v132 + 8);
      if (v152)
      {
        result = *v132;
        v153 = *(*v132 + v152 - 1) != 42;
      }

      else
      {
        v153 = -1;
      }

      if (v142 <= v153)
      {
        goto LABEL_248;
      }
    }

    else if (!v139)
    {
      goto LABEL_248;
    }

    *v131 = *v132;
    *(v131 + 15) = *(v132 + 15);
    v143 = v9;
    if (v132 == v9)
    {
      goto LABEL_247;
    }

    v144 = v130;
    while (2)
    {
      result = v9 + v144;
      v145 = *(v9 + v144 - 8);
      v146 = v135 > v145;
      if (v135 != v145 || (v147 = *(result - 7), v146 = v136 > v147, v136 != v147) || (v148 = *(result - 6), v146 = v137 > v148, v137 != v148))
      {
        if (!v146)
        {
          v143 = v132;
          goto LABEL_247;
        }

LABEL_239:
        v132 -= 24;
        *result = *(v9 + v144 - 24);
        *(result + 15) = *(v9 + v144 - 9);
        v144 -= 24;
        if (!v144)
        {
          v143 = v9;
          goto LABEL_247;
        }

        continue;
      }

      break;
    }

    if (v134)
    {
      v149 = *(v133 + v134 - 1) != 42;
    }

    else
    {
      v149 = -1;
    }

    v150 = *(result - 16);
    if (v150)
    {
      v151 = *(*(v9 + v144 - 24) + v150 - 1) != 42;
    }

    else
    {
      v151 = -1;
    }

    if (v149 > v151)
    {
      goto LABEL_239;
    }

    v143 = v9 + v144;
LABEL_247:
    *v143 = v133;
    *(v143 + 8) = v134;
    *(v143 + 16) = v135;
    *(v143 + 17) = v136;
    *(v143 + 18) = v137;
LABEL_248:
    v127 = v131 + 24;
    v130 += 24;
    if (v131 + 24 != a2)
    {
      continue;
    }

    return result;
  }
}

__int128 *std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(__int128 *result, uint64_t *a2, __int128 *a3)
{
  v3 = *a2;
  v4 = a2[1];
  v5 = *(a2 + 16);
  v6 = *(a2 + 17);
  v7 = *(a2 + 18);
  v8 = *(result + 16);
  v9 = v5 > v8;
  if (v5 != v8 || (v10 = *(result + 17), v9 = v6 > v10, v6 != v10) || (v11 = *(result + 18), v9 = v7 > v11, v7 != v11))
  {
    if (!v9)
    {
      goto LABEL_21;
    }

    goto LABEL_9;
  }

  v12 = *(result + 1);
  if (v4)
  {
    v13 = *(v3 + v4 - 1) != 42;
    if (v12)
    {
LABEL_6:
      v14 = *(*result + v12 - 1) != 42;
      goto LABEL_20;
    }
  }

  else
  {
    v13 = -1;
    if (v12)
    {
      goto LABEL_6;
    }
  }

  v14 = -1;
LABEL_20:
  if (v13 <= v14)
  {
LABEL_21:
    v24 = *(a3 + 16);
    v25 = v24 > v5;
    if (v24 != v5 || (v26 = *(a3 + 17), v25 = v26 > v6, v26 != v6) || (v27 = *(a3 + 18), v25 = v27 > v7, v27 != v7))
    {
      if (!v25)
      {
        return result;
      }

      goto LABEL_29;
    }

    v28 = *(a3 + 1);
    if (v28)
    {
      v29 = *(*a3 + v28 - 1) != 42;
      if (v4)
      {
LABEL_26:
        v30 = *(v3 + v4 - 1) != 42;
        goto LABEL_51;
      }
    }

    else
    {
      v29 = -1;
      if (v4)
      {
        goto LABEL_26;
      }
    }

    v30 = -1;
LABEL_51:
    if (v29 <= v30)
    {
      return result;
    }

LABEL_29:
    *v61 = *a2;
    v31 = *a2;
    *&v61[16] = a2[2];
    v32 = *(a3 + 15);
    *a2 = *a3;
    *(a2 + 15) = v32;
    *a3 = v31;
    *(a3 + 15) = *&v61[15];
    v33 = *(a2 + 16);
    v34 = *(result + 16);
    v35 = v33 > v34;
    if (v33 == v34 && (v36 = *(a2 + 17), v37 = *(result + 17), v35 = v36 > v37, v36 == v37) && (v38 = *(a2 + 18), v39 = *(result + 18), v35 = v38 > v39, v38 == v39))
    {
      v40 = a2[1];
      v41 = *(result + 1);
      if (v40)
      {
        v42 = *(*a2 + v40 - 1) != 42;
      }

      else
      {
        v42 = -1;
      }

      if (v41)
      {
        v58 = *(*result + v41 - 1) != 42;
      }

      else
      {
        v58 = -1;
      }

      if (v42 <= v58)
      {
        return result;
      }
    }

    else if (!v35)
    {
      return result;
    }

    *v62 = *result;
    v43 = *result;
    *&v62[16] = *(result + 2);
    v44 = *(a2 + 15);
    *result = *a2;
    *(result + 15) = v44;
    *a2 = v43;
    *(a2 + 15) = *&v62[15];
    return result;
  }

LABEL_9:
  v15 = *(a3 + 16);
  v16 = v15 > v5;
  if (v15 != v5 || (v17 = *(a3 + 17), v16 = v17 > v6, v17 != v6) || (v18 = *(a3 + 18), v16 = v18 > v7, v18 != v7))
  {
    if (!v16)
    {
      goto LABEL_40;
    }

LABEL_17:
    v22 = *result;
    *v60 = *result;
    *&v60[16] = *(result + 2);
    v23 = *(a3 + 15);
    *result = *a3;
    *(result + 15) = v23;
LABEL_48:
    *a3 = v22;
    *(a3 + 15) = *&v60[15];
    return result;
  }

  v19 = *(a3 + 1);
  if (v19)
  {
    v20 = *(*a3 + v19 - 1) != 42;
    if (v4)
    {
LABEL_14:
      v21 = *(v3 + v4 - 1) != 42;
      goto LABEL_39;
    }
  }

  else
  {
    v20 = -1;
    if (v4)
    {
      goto LABEL_14;
    }
  }

  v21 = -1;
LABEL_39:
  if (v20 > v21)
  {
    goto LABEL_17;
  }

LABEL_40:
  *v63 = *result;
  v45 = *result;
  *&v63[16] = *(result + 2);
  v46 = *(a2 + 15);
  *result = *a2;
  *(result + 15) = v46;
  *a2 = v45;
  *(a2 + 15) = *&v63[15];
  v47 = *(a3 + 16);
  v48 = *(a2 + 16);
  v49 = v47 > v48;
  if (v47 != v48 || (v50 = *(a3 + 17), v51 = *(a2 + 17), v49 = v50 > v51, v50 != v51) || (v52 = *(a3 + 18), v53 = *(a2 + 18), v49 = v52 > v53, v52 != v53))
  {
    if (!v49)
    {
      return result;
    }

    goto LABEL_47;
  }

  v54 = *(a3 + 1);
  v55 = a2[1];
  if (v54)
  {
    v56 = *(*a3 + v54 - 1) != 42;
  }

  else
  {
    v56 = -1;
  }

  if (v55)
  {
    v59 = *(*a2 + v55 - 1) != 42;
  }

  else
  {
    v59 = -1;
  }

  if (v56 > v59)
  {
LABEL_47:
    v22 = *a2;
    *v60 = *a2;
    *&v60[16] = a2[2];
    v57 = *(a3 + 15);
    *a2 = *a3;
    *(a2 + 15) = v57;
    goto LABEL_48;
  }

  return result;
}

__int128 *std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(uint64_t a1, __int128 *a2, __int128 *a3, __int128 *a4)
{
  result = std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(a1, a2, a3);
  v9 = *(a4 + 16);
  v10 = *(a3 + 16);
  v11 = v9 > v10;
  if (v9 != v10 || (v12 = *(a4 + 17), v13 = *(a3 + 17), v11 = v12 > v13, v12 != v13) || (v14 = *(a4 + 18), v15 = *(a3 + 18), v11 = v14 > v15, v14 != v15))
  {
    if (!v11)
    {
      return result;
    }

    goto LABEL_9;
  }

  v16 = *(a4 + 1);
  v17 = *(a3 + 1);
  if (v16)
  {
    v18 = *(*a4 + v16 - 1) != 42;
    if (v17)
    {
LABEL_6:
      v19 = *(*a3 + v17 - 1) != 42;
      goto LABEL_27;
    }
  }

  else
  {
    v18 = -1;
    if (v17)
    {
      goto LABEL_6;
    }
  }

  v19 = -1;
LABEL_27:
  if (v18 <= v19)
  {
    return result;
  }

LABEL_9:
  *v48 = *a3;
  v20 = *a3;
  *&v48[16] = *(a3 + 2);
  v21 = *(a4 + 15);
  *a3 = *a4;
  *(a3 + 15) = v21;
  *a4 = v20;
  *(a4 + 15) = *&v48[15];
  v22 = *(a3 + 16);
  v23 = *(a2 + 16);
  v24 = v22 > v23;
  if (v22 != v23 || (v25 = *(a3 + 17), v26 = *(a2 + 17), v24 = v25 > v26, v25 != v26) || (v27 = *(a3 + 18), v28 = *(a2 + 18), v24 = v27 > v28, v27 != v28))
  {
    if (!v24)
    {
      return result;
    }

    goto LABEL_17;
  }

  v29 = *(a3 + 1);
  v30 = *(a2 + 1);
  if (v29)
  {
    v31 = *(*a3 + v29 - 1) != 42;
    if (v30)
    {
LABEL_14:
      v32 = *(*a2 + v30 - 1) != 42;
      goto LABEL_31;
    }
  }

  else
  {
    v31 = -1;
    if (v30)
    {
      goto LABEL_14;
    }
  }

  v32 = -1;
LABEL_31:
  if (v31 <= v32)
  {
    return result;
  }

LABEL_17:
  *v49 = *a2;
  v33 = *a2;
  *&v49[16] = *(a2 + 2);
  v34 = *(a3 + 15);
  *a2 = *a3;
  *(a2 + 15) = v34;
  *a3 = v33;
  *(a3 + 15) = *&v49[15];
  v35 = *(a2 + 16);
  v36 = *(a1 + 16);
  v37 = v35 > v36;
  if (v35 != v36 || (v38 = *(a2 + 17), v39 = *(a1 + 17), v37 = v38 > v39, v38 != v39) || (v40 = *(a2 + 18), v41 = *(a1 + 18), v37 = v40 > v41, v40 != v41))
  {
    if (!v37)
    {
      return result;
    }

LABEL_24:
    *v50 = *a1;
    v45 = *a1;
    *&v50[16] = *(a1 + 16);
    v46 = *(a2 + 15);
    *a1 = *a2;
    *(a1 + 15) = v46;
    *a2 = v45;
    *(a2 + 15) = *&v50[15];
    return result;
  }

  v42 = *(a2 + 1);
  v43 = *(a1 + 8);
  if (v42)
  {
    v44 = *(*a2 + v42 - 1) != 42;
  }

  else
  {
    v44 = -1;
  }

  if (v43)
  {
    v47 = *(*a1 + v43 - 1) != 42;
  }

  else
  {
    v47 = -1;
  }

  if (v44 > v47)
  {
    goto LABEL_24;
  }

  return result;
}

__int128 *std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  result = std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(a1, a2, a3, a4);
  v11 = *(a5 + 16);
  v12 = *(a4 + 16);
  v13 = v11 > v12;
  if (v11 != v12 || (v14 = *(a5 + 17), v15 = *(a4 + 17), v13 = v14 > v15, v14 != v15) || (v16 = *(a5 + 18), v17 = *(a4 + 18), v13 = v16 > v17, v16 != v17))
  {
    if (!v13)
    {
      return result;
    }

    goto LABEL_9;
  }

  v18 = *(a5 + 8);
  v19 = *(a4 + 8);
  if (v18)
  {
    v20 = *(*a5 + v18 - 1) != 42;
    if (v19)
    {
LABEL_6:
      v21 = *(*a4 + v19 - 1) != 42;
      goto LABEL_34;
    }
  }

  else
  {
    v20 = -1;
    if (v19)
    {
      goto LABEL_6;
    }
  }

  v21 = -1;
LABEL_34:
  if (v20 <= v21)
  {
    return result;
  }

LABEL_9:
  *v63 = *a4;
  v22 = *a4;
  *&v63[16] = *(a4 + 16);
  v23 = *(a5 + 15);
  *a4 = *a5;
  *(a4 + 15) = v23;
  *a5 = v22;
  *(a5 + 15) = *&v63[15];
  v24 = *(a4 + 16);
  v25 = *(a3 + 16);
  v26 = v24 > v25;
  if (v24 != v25 || (v27 = *(a4 + 17), v28 = *(a3 + 17), v26 = v27 > v28, v27 != v28) || (v29 = *(a4 + 18), v30 = *(a3 + 18), v26 = v29 > v30, v29 != v30))
  {
    if (!v26)
    {
      return result;
    }

    goto LABEL_17;
  }

  v31 = *(a4 + 8);
  v32 = *(a3 + 8);
  if (v31)
  {
    v33 = *(*a4 + v31 - 1) != 42;
    if (v32)
    {
LABEL_14:
      v34 = *(*a3 + v32 - 1) != 42;
      goto LABEL_38;
    }
  }

  else
  {
    v33 = -1;
    if (v32)
    {
      goto LABEL_14;
    }
  }

  v34 = -1;
LABEL_38:
  if (v33 <= v34)
  {
    return result;
  }

LABEL_17:
  *v64 = *a3;
  v35 = *a3;
  *&v64[16] = *(a3 + 16);
  v36 = *(a4 + 15);
  *a3 = *a4;
  *(a3 + 15) = v36;
  *a4 = v35;
  *(a4 + 15) = *&v64[15];
  v37 = *(a3 + 16);
  v38 = *(a2 + 16);
  v39 = v37 > v38;
  if (v37 != v38 || (v40 = *(a3 + 17), v41 = *(a2 + 17), v39 = v40 > v41, v40 != v41) || (v42 = *(a3 + 18), v43 = *(a2 + 18), v39 = v42 > v43, v42 != v43))
  {
    if (!v39)
    {
      return result;
    }

LABEL_24:
    *v65 = *a2;
    v47 = *a2;
    *&v65[16] = *(a2 + 16);
    v48 = *(a3 + 15);
    *a2 = *a3;
    *(a2 + 15) = v48;
    *a3 = v47;
    *(a3 + 15) = *&v65[15];
    v49 = *(a2 + 16);
    v50 = *(a1 + 16);
    v51 = v49 > v50;
    if (v49 == v50 && (v52 = *(a2 + 17), v53 = *(a1 + 17), v51 = v52 > v53, v52 == v53) && (v54 = *(a2 + 18), v55 = *(a1 + 18), v51 = v54 > v55, v54 == v55))
    {
      v56 = *(a2 + 8);
      v57 = *(a1 + 8);
      if (v56)
      {
        v58 = *(*a2 + v56 - 1) != 42;
      }

      else
      {
        v58 = -1;
      }

      if (v57)
      {
        v62 = *(*a1 + v57 - 1) != 42;
      }

      else
      {
        v62 = -1;
      }

      if (v58 <= v62)
      {
        return result;
      }
    }

    else if (!v51)
    {
      return result;
    }

    *v66 = *a1;
    v59 = *a1;
    *&v66[16] = *(a1 + 16);
    v60 = *(a2 + 15);
    *a1 = *a2;
    *(a1 + 15) = v60;
    *a2 = v59;
    *(a2 + 15) = *&v66[15];
    return result;
  }

  v44 = *(a3 + 8);
  v45 = *(a2 + 8);
  if (v44)
  {
    v46 = *(*a3 + v44 - 1) != 42;
  }

  else
  {
    v46 = -1;
  }

  if (v45)
  {
    v61 = *(*a2 + v45 - 1) != 42;
  }

  else
  {
    v61 = -1;
  }

  if (v46 > v61)
  {
    goto LABEL_24;
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(uint64_t a1, uint64_t a2)
{
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  if (v4 > 2)
  {
    switch(v4)
    {
      case 3:
        std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(a1, (a1 + 24), (a2 - 24));
        return 1;
      case 4:
        std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(a1, (a1 + 24), (a1 + 48), (a2 - 24));
        return 1;
      case 5:
        std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(a1, a1 + 24, a1 + 48, a1 + 72, a2 - 24);
        return 1;
    }
  }

  else
  {
    if (v4 < 2)
    {
      return 1;
    }

    if (v4 == 2)
    {
      v5 = (a2 - 24);
      v6 = *(a2 - 8);
      v7 = *(a1 + 16);
      v8 = v6 > v7;
      if (v6 == v7 && (v9 = *(a2 - 7), v10 = *(a1 + 17), v8 = v9 > v10, v9 == v10) && (v11 = *(a2 - 6), v12 = *(a1 + 18), v8 = v11 > v12, v11 == v12))
      {
        v13 = *(a2 - 16);
        v14 = *(a1 + 8);
        if (v13)
        {
          v15 = *(*(a2 - 24) + v13 - 1) != 42;
        }

        else
        {
          v15 = -1;
        }

        if (v14)
        {
          v43 = *(*a1 + v14 - 1) != 42;
        }

        else
        {
          v43 = -1;
        }

        if (v15 <= v43)
        {
          return 1;
        }
      }

      else if (!v8)
      {
        return 1;
      }

      *v44 = *a1;
      v40 = *a1;
      *&v44[16] = *(a1 + 16);
      v41 = *(a2 - 9);
      *a1 = *v5;
      *(a1 + 15) = v41;
      *v5 = v40;
      *(a2 - 9) = *&v44[15];
      return 1;
    }
  }

  v16 = a1 + 48;
  std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,0>(a1, (a1 + 24), (a1 + 48));
  v17 = a1 + 72;
  if (a1 + 72 == a2)
  {
    return 1;
  }

  v18 = 0;
  v19 = 0;
  while (2)
  {
    v21 = *v17;
    v20 = *(v17 + 8);
    v22 = *(v17 + 16);
    v23 = *(v17 + 17);
    v24 = *(v17 + 18);
    v25 = *(v16 + 16);
    v26 = v22 > v25;
    if (v22 == v25 && (v27 = *(v16 + 17), v26 = v23 > v27, v23 == v27) && (v28 = *(v16 + 18), v26 = v24 > v28, v24 == v28))
    {
      if (v20)
      {
        v29 = *(v21 + v20 - 1) != 42;
      }

      else
      {
        v29 = -1;
      }

      v38 = *(v16 + 8);
      if (v38)
      {
        v39 = *(*v16 + v38 - 1) != 42;
      }

      else
      {
        v39 = -1;
      }

      if (v29 <= v39)
      {
        goto LABEL_41;
      }
    }

    else if (!v26)
    {
      goto LABEL_41;
    }

    *v17 = *v16;
    *(v17 + 15) = *(v16 + 15);
    v30 = v18;
    while (1)
    {
      v31 = *(a1 + v30 + 40);
      v32 = v22 > v31;
      if (v22 != v31 || (v33 = *(a1 + v30 + 41), v32 = v23 > v33, v23 != v33))
      {
        if (!v32)
        {
          goto LABEL_40;
        }

        goto LABEL_31;
      }

      v34 = *(a1 + v30 + 42);
      if (v24 == v34)
      {
        if (v20)
        {
          v35 = *(v21 + v20 - 1) != 42;
        }

        else
        {
          v35 = -1;
        }

        v36 = *(a1 + v30 + 32);
        if (v36)
        {
          v37 = *(*(a1 + v30 + 24) + v36 - 1) != 42;
        }

        else
        {
          v37 = -1;
        }

        if (v35 <= v37)
        {
          goto LABEL_40;
        }

        goto LABEL_31;
      }

      if (v24 <= v34)
      {
        break;
      }

LABEL_31:
      v16 -= 24;
      *(a1 + v30 + 48) = *(a1 + v30 + 24);
      *(a1 + v30 + 63) = *(a1 + v30 + 39);
      v30 -= 24;
      if (v30 == -48)
      {
        v16 = a1;
        goto LABEL_40;
      }
    }

    v16 = a1 + v30 + 48;
LABEL_40:
    *v16 = v21;
    *(v16 + 8) = v20;
    *(v16 + 16) = v22;
    *(v16 + 17) = v23;
    ++v19;
    *(v16 + 18) = v24;
    if (v19 != 8)
    {
LABEL_41:
      v16 = v17;
      v18 += 24;
      v17 += 24;
      if (v17 == a2)
      {
        return 1;
      }

      continue;
    }

    return v17 + 24 == a2;
  }
}

BOOL TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  v5 = 0;
  validAttributeForSnippet(a1, a2, &v5 + 1);
  validAttributeForSnippet(*(a3 + 8), *(a3 + 16), &v5);
  return *(&v5 + 1) > *&v5;
}

__n128 std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(uint64_t *a1, uint64_t *a2)
{
  v3 = *a1;
  v7 = *(a1 + 3);
  v8 = *(a1 + 1);
  v4 = a1[5];
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  *a1 = *a2;
  *(a1 + 1) = *(a2 + 1);
  std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign((a1 + 3), (a2 + 3));
  *a2 = v3;
  *(a2 + 1) = v8;
  v5 = a2[3];
  if (v5)
  {
    a2[4] = v5;
    CFAllocatorDeallocate(a2[6], v5);
  }

  result = v7;
  *(a2 + 3) = v7;
  a2[5] = v4;
  return result;
}

double std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v6 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a2 + 8), *(a2 + 16), a1);
  v7 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a3 + 8), *(a3 + 16), a2);
  if (v6)
  {
    if (v7)
    {
      v9 = a1;
    }

    else
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, a2);
      if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a3 + 8), *(a3 + 16), a2))
      {
        return result;
      }

      v9 = a2;
    }

    v10 = a3;
  }

  else
  {
    if (!v7)
    {
      return result;
    }

    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a2, a3);
    if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a2 + 8), *(a2 + 16), a1))
    {
      return result;
    }

    v9 = a1;
    v10 = a2;
  }

  *&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(v9, v10).n128_u64[0];
  return result;
}

double std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(a1, a2, a3);
  if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a4 + 8), *(a4 + 16), a3))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a3, a4);
    if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a3 + 8), *(a3 + 16), a2))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a2, a3);
      if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a2 + 8), *(a2 + 16), a1))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, a2);
      }
    }
  }

  if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a5 + 8), *(a5 + 16), a4))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a4, a5);
    if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a4 + 8), *(a4 + 16), a3))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a3, a4);
      if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a3 + 8), *(a3 + 16), a2))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a2, a3);
        if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a2 + 8), *(a2 + 16), a1))
        {

          *&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, a2).n128_u64[0];
        }
      }
    }
  }

  return result;
}

__n128 std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(uint64_t a1, __n128 *a2)
{
  v4 = *a1;
  if (*a1)
  {
    *(a1 + 8) = v4;
    CFAllocatorDeallocate(*(a1 + 24), v4);
    *a1 = 0;
    *(a1 + 8) = 0;
    *(a1 + 16) = 0;
  }

  result = *a2;
  *a1 = *a2;
  *(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(uint64_t a1, uint64_t a2)
{
  v4 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 3);
  if (v4 > 2)
  {
    switch(v4)
    {
      case 3:
        std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(a1, a1 + 56, a2 - 56);
        return 1;
      case 4:
        std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(a1, a1 + 56, a1 + 112);
        if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a2 - 48), *(a2 - 40), a1 + 112))
        {
          return 1;
        }

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>((a1 + 112), (a2 - 56));
        if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a1 + 120), *(a1 + 128), a1 + 56))
        {
          return 1;
        }

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>((a1 + 56), (a1 + 112));
        if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a1 + 64), *(a1 + 72), a1))
        {
          return 1;
        }

        v5 = (a1 + 56);
        goto LABEL_6;
      case 5:
        std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(a1, a1 + 56, a1 + 112, a1 + 168, a2 - 56);
        return 1;
    }
  }

  else
  {
    if (v4 < 2)
    {
      return 1;
    }

    if (v4 == 2)
    {
      if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(a2 - 48), *(a2 - 40), a1))
      {
        v5 = (a2 - 56);
LABEL_6:
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, v5);
      }

      return 1;
    }
  }

  v6 = a1 + 112;
  std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,0>(a1, a1 + 56, a1 + 112);
  v7 = a1 + 168;
  if (a1 + 168 == a2)
  {
    return 1;
  }

  v8 = 0;
  v9 = 0;
  while (1)
  {
    if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(v7 + 8), *(v7 + 16), v6))
    {
      v10 = *(v7 + 8);
      v11 = *(v7 + 16);
      v25 = *(v7 + 24);
      v23 = *v7;
      v24 = *(v7 + 40);
      *(v7 + 32) = 0;
      *(v7 + 40) = 0;
      v12 = v8;
      *(v7 + 24) = 0;
      while (1)
      {
        v13 = v12;
        v14 = a1 + v12;
        *(v14 + 168) = *(a1 + v12 + 112);
        *(v14 + 176) = *(a1 + v12 + 120);
        v15 = (a1 + v12 + 136);
        std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(a1 + v12 + 192, v15);
        if (v13 == -112)
        {
          break;
        }

        v16 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v10, v11, v14 + 56);
        v12 = v13 - 56;
        if (!v16)
        {
          v17 = a1 + v13;
          v18 = a1 + v13 + 112;
          v19 = a1 + v12 + 168;
          v15 = (v17 + 136);
          v20 = (v17 + 120);
          goto LABEL_20;
        }
      }

      v18 = v14 + 112;
      v20 = (v14 + 120);
      v19 = a1;
LABEL_20:
      *v19 = v23;
      *v20 = v10;
      *(v18 + 16) = v11;
      v21 = v15->n128_u64[0];
      if (v15->n128_u64[0])
      {
        *(v19 + 32) = v21;
        CFAllocatorDeallocate(*(v19 + 48), v21);
        *(v18 + 40) = 0;
      }

      *v15 = v25;
      *(v19 + 40) = v24;
      if (++v9 == 8)
      {
        return v7 + 56 == a2;
      }
    }

    v6 = v7;
    v8 += 56;
    v7 += 56;
    if (v7 == a2)
    {
      return 1;
    }
  }
}

float validAttributeForSnippet(uint64_t *a1, unint64_t a2, _DWORD *a3)
{
  {
    attributeImportance(void)::attributeImportanceScores = 0u;
    *&qword_1EDD788C0 = 0u;
    dword_1EDD788D0 = 1065353216;
    v15 = &off_1E81909F0;
    v16 = 336;
    do
    {
      std::__hash_table<std::__hash_value_type<std::string_view,float>,std::__unordered_map_hasher<std::string_view,std::__hash_value_type<std::string_view,float>,std::hash<std::string_view>,std::equal_to<std::string_view>,true>,std::__unordered_map_equal<std::string_view,std::__hash_value_type<std::string_view,float>,std::equal_to<std::string_view>,std::hash<std::string_view>,true>,std::allocator<std::__hash_value_type<std::string_view,float>>>::__emplace_unique_key_args<std::string_view,std::pair<std::string_view const,float> const&>(*v15, v15[1]);
      v15 += 3;
      v16 -= 24;
    }

    while (v16);
  }

  v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](a1, a2);
  v8 = *(&attributeImportance(void)::attributeImportanceScores + 1);
  if (*(&attributeImportance(void)::attributeImportanceScores + 1))
  {
    v9 = v6;
    v7 = vcnt_s8(*(&attributeImportance(void)::attributeImportanceScores + 8));
    v7.i16[0] = vaddlv_u8(v7);
    v10 = v7.u32[0];
    if (v7.u32[0] > 1uLL)
    {
      v11 = v6;
      if (v6 >= *(&attributeImportance(void)::attributeImportanceScores + 1))
      {
        v11 = v6 % *(&attributeImportance(void)::attributeImportanceScores + 1);
      }
    }

    else
    {
      v11 = (*(&attributeImportance(void)::attributeImportanceScores + 1) - 1) & v6;
    }

    v12 = *(attributeImportance(void)::attributeImportanceScores + 8 * v11);
    if (v12)
    {
      for (i = *v12; i; i = *i)
      {
        v14 = i[1];
        if (v9 == v14)
        {
          if (i[3] == a2 && !memcmp(i[2], a1, a2))
          {
            v7.i32[0] = *(i + 8);
            *a3 = v7.i32[0];
            return *v7.i32;
          }
        }

        else
        {
          if (v10 > 1)
          {
            if (v14 >= v8)
            {
              v14 %= v8;
            }
          }

          else
          {
            v14 &= v8 - 1;
          }

          if (v14 != v11)
          {
            return *v7.i32;
          }
        }
      }
    }
  }

  return *v7.i32;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string_view,float>,std::__unordered_map_hasher<std::string_view,std::__hash_value_type<std::string_view,float>,std::hash<std::string_view>,std::equal_to<std::string_view>,true>,std::__unordered_map_equal<std::string_view,std::__hash_value_type<std::string_view,float>,std::equal_to<std::string_view>,std::hash<std::string_view>,true>,std::allocator<std::__hash_value_type<std::string_view,float>>>::__emplace_unique_key_args<std::string_view,std::pair<std::string_view const,float> const&>(uint64_t *a1, unint64_t a2)
{
  v4 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](a1, a2);
  v5 = v4;
  v6 = *(&attributeImportance(void)::attributeImportanceScores + 1);
  if (!*(&attributeImportance(void)::attributeImportanceScores + 1))
  {
    goto LABEL_19;
  }

  v7 = vcnt_s8(*(&attributeImportance(void)::attributeImportanceScores + 8));
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(&attributeImportance(void)::attributeImportanceScores + 1))
    {
      v9 = v4 % *(&attributeImportance(void)::attributeImportanceScores + 1);
    }
  }

  else
  {
    v9 = (*(&attributeImportance(void)::attributeImportanceScores + 1) - 1) & v4;
  }

  v10 = *(attributeImportance(void)::attributeImportanceScores + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_19:
    operator new();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= v6)
      {
        v12 %= v6;
      }
    }

    else
    {
      v12 &= v6 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_19;
    }

LABEL_18:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_19;
    }
  }

  if (v11[3] != a2)
  {
    goto LABEL_18;
  }

  result = memcmp(v11[2], a1, a2);
  if (result)
  {
    goto LABEL_18;
  }

  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](uint64_t *a1, unint64_t a2)
{
  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      v5 = *(a1 + a2 - 16);
      v6 = *a1 - 0x3C5A37A36834CED9 * (v5 + a2);
      v8 = a1[2];
      v7 = a1[3];
      v9 = __ROR8__(v6 + v7, 52);
      v10 = v6 + a1[1];
      v11 = __ROR8__(v10, 7);
      v12 = v10 + v8;
      v13 = *(a1 + a2 - 32) + v8;
      v14 = *(a1 + a2 - 8) + v7;
      v15 = __ROR8__(v14 + v13, 52);
      v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v5 + a2), 37) + v9;
      v17 = __ROR8__(v13, 37);
      v18 = *(a1 + a2 - 24) + v13;
      v19 = __ROR8__(v18, 7);
      v20 = v16 + __ROR8__(v12, 31);
      v21 = v18 + v5;
      v22 = v21 + v14;
      v23 = 0x9AE16A3B2F90404FLL;
      v24 = 0xC3A5C85C97CB3127 * (v22 + v20) - 0x651E95C4D06FBFB1 * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      v25 = v20 - 0x3C5A37A36834CED9 * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }

    v4 = 0x9DDFEA08EB382D69;
    v32 = *(a1 + a2 - 48);
    v33 = *(a1 + a2 - 40);
    v34 = *(a1 + a2 - 24);
    v35 = *(a1 + a2 - 56);
    v36 = *(a1 + a2 - 16);
    v37 = *(a1 + a2 - 8);
    v38 = v35 + v36;
    v39 = 0x9DDFEA08EB382D69 * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))));
    v40 = 0x9DDFEA08EB382D69 * (v39 ^ (v39 >> 47));
    v41 = *(a1 + a2 - 64) + a2;
    v42 = v41 + v35 + v32;
    v43 = __ROR8__(v42, 44) + v41;
    v44 = __ROR8__(v33 + v41 + v40, 21);
    v45 = v42 + v33;
    v46 = v43 + v44;
    v47 = v38 + *(a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    v48 = v47 + v34 + v36;
    v49 = v48 + v37;
    v50 = __ROR8__(v48, 44) + v47 + __ROR8__(v47 + v33 + v37, 21);
    v52 = *a1;
    v51 = a1 + 4;
    v53 = v52 - 0x4B6D499041670D8DLL * v33;
    v54 = -((a2 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      v55 = *(v51 - 3);
      v56 = v53 + v45 + v38 + v55;
      v57 = v51[2];
      v58 = v51[3];
      v59 = v51[1];
      v38 = v59 + v45 - 0x4B6D499041670D8DLL * __ROR8__(v38 + v46 + v57, 42);
      v60 = v40 + v49;
      v61 = *(v51 - 2);
      v62 = *(v51 - 1);
      v63 = *(v51 - 4) - 0x4B6D499041670D8DLL * v46;
      v64 = v63 + v49 + v62;
      v65 = v63 + v55 + v61;
      v45 = v65 + v62;
      v66 = __ROR8__(v65, 44) + v63;
      v67 = (0xB492B66FBE98F273 * __ROR8__(v56, 37)) ^ v50;
      v53 = 0xB492B66FBE98F273 * __ROR8__(v60, 33);
      v46 = v66 + __ROR8__(v64 + v67, 21);
      v68 = v53 + v50 + *v51;
      v49 = v68 + v59 + v57 + v58;
      v50 = __ROR8__(v68 + v59 + v57, 44) + v68 + __ROR8__(v38 + v61 + v68 + v58, 21);
      v51 += 8;
      v40 = v67;
      v54 += 64;
    }

    while (v54);
    v69 = v67 - 0x4B6D499041670D8DLL * (v38 ^ (v38 >> 47)) - 0x622015F714C7D297 * ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v45)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v45)))) ^ ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v45)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v45)))) >> 47));
    v70 = v53 - 0x622015F714C7D297 * ((0x9DDFEA08EB382D69 * (v50 ^ ((0x9DDFEA08EB382D69 * (v50 ^ v46)) >> 47) ^ (0x9DDFEA08EB382D69 * (v50 ^ v46)))) ^ ((0x9DDFEA08EB382D69 * (v50 ^ ((0x9DDFEA08EB382D69 * (v50 ^ v46)) >> 47) ^ (0x9DDFEA08EB382D69 * (v50 ^ v46)))) >> 47));
    v71 = 0x9DDFEA08EB382D69 * (v70 ^ ((0x9DDFEA08EB382D69 * (v70 ^ v69)) >> 47) ^ (0x9DDFEA08EB382D69 * (v70 ^ v69)));
    goto LABEL_13;
  }

  if (a2 > 0x10)
  {
    v26 = a1[1];
    v27 = 0xB492B66FBE98F273 * *a1;
    v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(a1 + a2 - 8);
    v23 = 0x9DDFEA08EB382D69;
    v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v28 - 0x3C5A37A36834CED9 * *(a1 + a2 - 16)));
    v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    v25 = 0x9DDFEA08EB382D69 * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }

  if (a2 < 9)
  {
    if (a2 >= 4)
    {
      v73 = *(a1 + a2 - 4);
      v23 = 0x9DDFEA08EB382D69;
      v74 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v73);
      v31 = v73 ^ (v74 >> 47) ^ v74;
      goto LABEL_8;
    }

    v4 = 0x9AE16A3B2F90404FLL;
    if (!a2)
    {
      return v4;
    }

    v71 = (0xC949D7C7509E6557 * (a2 | (4 * *(a1 + a2 - 1)))) ^ (0x9AE16A3B2F90404FLL * (*a1 | (*(a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v4 *= v71 ^ (v71 >> 47);
    return v4;
  }

  v2 = *(a1 + a2 - 8);
  v3 = __ROR8__(v2 + a2, a2);
  return (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) >> 47))) ^ v2;
}

uint64_t keycompare(uint64_t a1, int a2, const char *a3, int a4, const char *a5)
{
  v5 = *a3;
  v6 = *a5;
  if (a2 == 4)
  {
    v7 = v5 - v6;
    if (v7)
    {
      v8 = v7;
    }

    else
    {
      v8 = -1;
    }

    if (a4 == 4)
    {
      return v7;
    }

    else
    {
      return v8;
    }
  }

  else if (a4 == 4)
  {
    v10 = v5 - v6;
    if (v10)
    {
      return v10;
    }

    else
    {
      return 1;
    }
  }

  else
  {
    result = (v5 - v6);
    if (v5 == v6)
    {
      return strcmp(a3 + 10, a5 + 10);
    }
  }

  return result;
}

void release_persistent_id_store(uint64_t a1)
{
  v16 = *MEMORY[0x1E69E9840];
  v2 = (a1 + 32);
  if (*(a1 + 32) > 0x63u)
  {
    if (!_sqlite_insert(a1, &master_fid_rec, master_fid_rec_size, (a1 + 32), 4, 0))
    {
      goto LABEL_7;
    }

    v3 = *__error();
    v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v9 = *v2;
      v10 = 136315650;
      v11 = "release_persistent_id_store";
      v12 = 1024;
      v13 = 298;
      v14 = 1024;
      v15 = v9;
      v6 = "%s:%d: psid-release: Failed to update the master fid! (0x%x)\n";
      goto LABEL_13;
    }
  }

  else
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *v2;
      v10 = 136315650;
      v11 = "release_persistent_id_store";
      v12 = 1024;
      v13 = 285;
      v14 = 1024;
      v15 = v5;
      v6 = "%s:%d: release_psid_store: danger! master_fid %d looks bad.\n";
LABEL_13:
      _os_log_error_impl(&dword_1C278D000, v4, OS_LOG_TYPE_ERROR, v6, &v10, 0x18u);
    }
  }

  *__error() = v3;
LABEL_7:
  v7 = *(a1 + 16);
  if (v7)
  {
    sqlite3BtreeCloseCursor(v7);
  }

  if (*a1)
  {
    sqlite3BtreeClose(*a1);
  }

  free(a1);
  v8 = *MEMORY[0x1E69E9840];
}

uint64_t _sqlite_insert(uint64_t *a1, char *a2, unint64_t a3, char *a4, int a5, char a6)
{
  v28 = *MEMORY[0x1E69E9840];
  if ((a6 & 1) != 0 || (v12 = _sqlite_bulkBegin(a1), !v12))
  {
    v12 = sqlite3BtreeInsert(a1[2], a2, a3, a4, a5);
    if (v12)
    {
      v13 = *__error();
      v14 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v22 = 136315650;
        v23 = "_sqlite_insert";
        v24 = 1024;
        v25 = 1061;
        v26 = 1024;
        v27 = v12;
        _os_log_error_impl(&dword_1C278D000, v14, OS_LOG_TYPE_ERROR, "%s:%d: sqlite3BtreeInsert failed; rc = %d\n", &v22, 0x18u);
      }

      *__error() = v13;
    }

    if ((a6 & 1) == 0)
    {
      v15 = _sqlite_bulkEnd(a1);
      if (!v12)
      {
        v16 = v15;
        if (v15)
        {
          v17 = *__error();
          v18 = _SILogForLogForCategory(4);
          v19 = 2 * (dword_1EBF46ADC < 4);
          if (os_log_type_enabled(v18, v19))
          {
            v22 = 67109120;
            LODWORD(v23) = v16;
            _os_log_impl(&dword_1C278D000, v18, v19, "sqlite3BtreeInsert failed in _sqlite_bulkEnd; rc = %d\n", &v22, 8u);
          }

          *__error() = v17;
          v12 = v16;
        }
      }
    }
  }

  v20 = *MEMORY[0x1E69E9840];
  return v12;
}

uint64_t _sqlite_bulkBegin(uint64_t a1)
{
  v2 = (a1 + 16);
  if (*(a1 + 16) || (v3 = sqlite3BtreeCursor(*a1, *(a1 + 8), 1, *(a1 + 24), v2), !v3))
  {
    v3 = sqlite3BtreeBeginTrans(*a1);
    if (v3)
    {
      sqlite3BtreeCloseCursor(*v2);
      *v2 = 0;
    }
  }

  return v3;
}

uint64_t _sqlite_bulkEnd(uint64_t *a1)
{
  v12 = *MEMORY[0x1E69E9840];
  if (a1[2])
  {
    v1 = sqlite3BtreeCommit(*a1);
    if (v1)
    {
      v2 = *__error();
      v3 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        v6 = 136315650;
        v7 = "_sqlite_bulkEnd";
        v8 = 1024;
        v9 = 1153;
        v10 = 1024;
        v11 = v1;
        _os_log_error_impl(&dword_1C278D000, v3, OS_LOG_TYPE_ERROR, "%s:%d: sqlite3BtreeCommit failed; rc = %d\n", &v6, 0x18u);
      }

      *__error() = v2;
    }
  }

  else
  {
    v1 = 0;
  }

  v4 = *MEMORY[0x1E69E9840];
  return v1;
}

uint64_t get_id_for_path(uint64_t a1, _BYTE *a2, int *a3, _DWORD *a4, char a5)
{
  v8 = a2;
  v29 = *MEMORY[0x1E69E9840];
  v24 = 0;
  v26 = 0;
  memset(&v25[1], 0, 256);
  v25[0] = 2;
  *a3 = 0;
  if (a4)
  {
    *a4 = 2;
  }

  v10 = *a2;
  if (*a2)
  {
    v11 = 2;
    do
    {
      while (v10 == 47)
      {
        v12 = *++v8;
        v10 = v12;
      }

      v13 = v8;
      if (!v10)
      {
        break;
      }

      do
      {
        if (v10 == 47)
        {
          break;
        }

        v14 = *++v13;
        v10 = v14;
      }

      while (v14);
      v15 = v13 - v8;
      if (((v13 - v8) & 0xFF00) != 0)
      {
        v15 = 255;
      }

      LOWORD(v25[2]) = v15;
      __strncpy_chk();
      v16 = LOWORD(v25[2]);
      ++LOWORD(v25[2]);
      *(&v25[2] + v16 + 2) = 0;
      v25[1] = 0;
      if (*v13 == 47)
      {
        v8 = v13 + 1;
      }

      else
      {
        v8 = v13;
      }

      if (psid_lookup(a1, v25, &v24))
      {
        if ((a5 & 1) == 0)
        {
          result = 2;
          goto LABEL_26;
        }

        v17 = *(a1 + 32);
        if (v17 != 2 && v17 <= 0x63)
        {
          v20 = *__error();
          v21 = _SILogForLogForCategory(4);
          v22 = 2 * (dword_1EBF46ADC < 4);
          if (os_log_type_enabled(v21, v22))
          {
            v23 = *(a1 + 32);
            *buf = 67109120;
            v28 = v23;
            _os_log_impl(&dword_1C278D000, v21, v22, "psid_insert: master fid corrupted (%d)\n", buf, 8u);
          }

          *__error() = v20;
          result = 22;
          goto LABEL_26;
        }

        v24 = *(a1 + 32);
        *(a1 + 32) = v17 + 1;
        result = _psid_insert(a1, v25, &v24);
        if (result)
        {
          goto LABEL_26;
        }
      }

      if (a4)
      {
        *a4 = v25[0];
      }

      v11 = v24;
      v25[0] = v24;
      v10 = *v8;
    }

    while (*v8);
  }

  else
  {
    v11 = 2;
  }

  result = 0;
  *a3 = v11;
LABEL_26:
  v19 = *MEMORY[0x1E69E9840];
  return result;
}

uint64_t psid_lookup(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  v4 = *(a2 + 8);
  v7 = 0;
  v6 = 4;
  result = _sqlite_get_psid(a1, a2, v4 + 12, &v7, &v6);
  if (result)
  {
    return 2;
  }

  *a3 = v7;
  return result;
}

uint64_t _psid_insert(uint64_t a1, uint64_t a2, char *a3)
{
  v28 = *MEMORY[0x1E69E9840];
  if (_sqlite_bulkBegin(a1))
  {
    result = 22;
    goto LABEL_17;
  }

  v7 = *(a2 + 8);
  if (_sqlite_insert(a1, a2, v7 + 12, a3, 4, 1))
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = *(a1 + 32);
      *buf = 136315906;
      *v25 = "_psid_insert_locked";
      *&v25[8] = 1024;
      *&v25[10] = 413;
      v26 = 1024;
      *v27 = v10;
      *&v27[4] = 2080;
      *&v27[6] = a2 + 10;
      v11 = "%s:%d: psid-insert: failed to store fid 0x%x for path %s\n";
LABEL_21:
      _os_log_error_impl(&dword_1C278D000, v9, OS_LOG_TYPE_ERROR, v11, buf, 0x22u);
      goto LABEL_9;
    }

    goto LABEL_9;
  }

  v12 = 0x1EBF46000uLL;
  if (dword_1EBF46ADC >= 5)
  {
    v23 = v7;
    v18 = *__error();
    v19 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = *(a1 + 32);
      *buf = 67109378;
      *v25 = v20;
      *&v25[4] = 2080;
      *&v25[6] = a2 + 10;
      _os_log_impl(&dword_1C278D000, v19, OS_LOG_TYPE_DEFAULT, "psid-insert: fid 0x%x for path %s\n", buf, 0x12u);
    }

    *__error() = v18;
    LODWORD(v7) = v23;
    v12 = 0x1EBF46000;
  }

  if (_sqlite_insert(a1, a3, 4uLL, a2, v7 + 12, 1))
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v17 = *(a1 + 32);
      *buf = 136315906;
      *v25 = "_psid_insert_locked";
      *&v25[8] = 1024;
      *&v25[10] = 419;
      v26 = 2080;
      *v27 = a2 + 10;
      *&v27[8] = 1024;
      *&v27[10] = v17;
      v11 = "%s:%d: psid-insert: failed to store path %s for fid 0x%x\n";
      goto LABEL_21;
    }

LABEL_9:
    v13 = 22;
    goto LABEL_10;
  }

  if (*(v12 + 2780) < 5)
  {
    v13 = 0;
    goto LABEL_11;
  }

  v8 = *__error();
  v21 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    v22 = *(a1 + 32);
    *buf = 136315394;
    *v25 = a2 + 10;
    *&v25[8] = 1024;
    *&v25[10] = v22;
    _os_log_impl(&dword_1C278D000, v21, OS_LOG_TYPE_DEFAULT, "psid-insert: store path %s for fid 0x%x\n", buf, 0x12u);
  }

  v13 = 0;
LABEL_10:
  *__error() = v8;
LABEL_11:
  v14 = _sqlite_bulkEnd(a1);
  if (v13)
  {
    v15 = v13;
  }

  else
  {
    v15 = 22;
  }

  if (v14)
  {
    result = v15;
  }

  else
  {
    result = v13;
  }

LABEL_17:
  v16 = *MEMORY[0x1E69E9840];
  return result;
}

uint64_t _sqlite_get_psid(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int *a5)
{
  v11 = (a1 + 16);
  v10 = *(a1 + 16);
  if (!v10)
  {
    LODWORD(result) = sqlite3BtreeCursor(*a1, *(a1 + 8), 1, *(a1 + 24), v11);
    if (result)
    {
      goto LABEL_5;
    }

    v10 = *v11;
  }

  v14 = 0;
  LODWORD(result) = sqlite3BtreeMoveto(v10, a2, a3, &v14);
  if (!(result | v14))
  {
    LODWORD(result) = getPayload(*v11, *a5, a4, 1);
    v13 = result == 0;
    goto LABEL_6;
  }

LABEL_5:
  v13 = 0;
LABEL_6:
  if (result)
  {
    v13 = 1;
  }

  if (v13)
  {
    return result;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t _sqlite_get(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t *a5)
{
  v11 = (a1 + 16);
  v10 = *(a1 + 16);
  if (!v10)
  {
    LODWORD(result) = sqlite3BtreeCursor(*a1, *(a1 + 8), 1, *(a1 + 24), v11);
    if (result)
    {
      goto LABEL_13;
    }

    v10 = *v11;
  }

  v20 = 0;
  LODWORD(result) = sqlite3BtreeMoveto(v10, a2, a3, &v20);
  if (result | v20)
  {
LABEL_13:
    v14 = 0;
    goto LABEL_14;
  }

  v13 = *v11;
  v14 = *(*v11 + 97);
  if (!*(*v11 + 97))
  {
    LODWORD(result) = 0;
    goto LABEL_14;
  }

  getCellInfo(*v11);
  v15 = *(v13 + 20);
  if (!v15)
  {
    LODWORD(result) = 0;
    goto LABEL_13;
  }

  if (*a5 >= v15)
  {
    *a5 = v15;
  }

  else
  {
    v16 = *__error();
    v17 = _SILogForLogForCategory(4);
    v18 = 2 * (dword_1EBF46ADC < 4);
    if (os_log_type_enabled(v17, v18))
    {
      *v19 = 0;
      _os_log_impl(&dword_1C278D000, v17, v18, "_sqlite_get: buffer is too small\n", v19, 2u);
    }

    *__error() = v16;
    LODWORD(v15) = *a5;
  }

  LODWORD(result) = getPayload(*v11, v15, a4, 1);
  v14 = result == 0;
LABEL_14:
  if (result)
  {
    v14 = 1;
  }

  if (v14)
  {
    return result;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t get_path_for_id(uint64_t a1, int a2, void *a3, uint64_t a4, int a5)
{
  v38 = *MEMORY[0x1E69E9840];
  v30 = a2;
  v7 = a5;
  *(a4 + a5 - 1) = 0;
  if (a2 == 2)
  {
    v8 = 1;
  }

  else
  {
    v8 = 1;
    memset(v37, 0, 268);
    while (1)
    {
      v29 = 268;
      if (_sqlite_get(a1, &v30, 4, v37, &v29))
      {
        result = 2;
        goto LABEL_24;
      }

      v11 = WORD4(v37[0]);
      if (WORD4(v37[0]) >= a5)
      {
        v15 = *__error();
        v16 = _SILogForLogForCategory(4);
        v17 = 2 * (dword_1EBF46ADC < 4);
        if (os_log_type_enabled(v16, v17))
        {
          *buf = 67109890;
          v32 = WORD4(v37[0]);
          v33 = 1024;
          v34 = v37[0];
          v35 = 1024;
          *v36 = DWORD1(v37[0]);
          *&v36[4] = 2080;
          *&v36[6] = v37 | 0xA;
          v18 = "get_path_for_id: bogus part len %d (%d/%d/%s)\n";
          v19 = v16;
          v20 = v17;
          v21 = 30;
          goto LABEL_22;
        }

LABEL_23:
        *__error() = v15;
        result = 22;
        goto LABEL_24;
      }

      if (LODWORD(v37[0]) != 2 && LODWORD(v37[0]) <= 0x63)
      {
        v12 = *__error();
        v13 = _SILogForLogForCategory(4);
        v14 = 2 * (dword_1EBF46ADC < 4);
        if (os_log_type_enabled(v13, v14))
        {
          *buf = 67109634;
          v32 = v30;
          v33 = 1024;
          v34 = v37[0];
          v35 = 2080;
          *v36 = v37 | 0xA;
          _os_log_impl(&dword_1C278D000, v13, v14, "get_path_for_id: bogus looking part fid (cur fid %d, part fid %d name %s)\n", buf, 0x18u);
        }

        *__error() = v12;
        v11 = WORD4(v37[0]);
      }

      if (v8 + v11 + 1 >= a5)
      {
        *(a4 + v8) = 0;
        v15 = *__error();
        v22 = _SILogForLogForCategory(4);
        v23 = 2 * (dword_1EBF46ADC < 4);
        if (os_log_type_enabled(v22, v23))
        {
          *buf = 67109634;
          v32 = v8;
          v33 = 1024;
          v34 = WORD4(v37[0]);
          v35 = 2080;
          *v36 = a4;
          v18 = "get_path_for_id: path index too large! (%d %d : %s)\n";
          v19 = v22;
          v20 = v23;
          v21 = 24;
LABEL_22:
          _os_log_impl(&dword_1C278D000, v19, v20, v18, buf, v21);
        }

        goto LABEL_23;
      }

      strncpy((a4 + 1 + a5 - (v8 + v11)), (v37 | 0xA), v11 - 1);
      v8 += v11;
      *(a4 + v7 - v8) = 47;
      if (v30 == 100 && LODWORD(v37[0]) != 2)
      {
        break;
      }

      v30 = v37[0];
      if (LODWORD(v37[0]) == 2)
      {
        goto LABEL_3;
      }
    }

    v25 = *__error();
    v26 = _SILogForLogForCategory(4);
    v27 = 2 * (dword_1EBF46ADC < 4);
    if (os_log_type_enabled(v26, v27))
    {
      *buf = 67109376;
      v32 = v30;
      v33 = 1024;
      v34 = v37[0];
      _os_log_impl(&dword_1C278D000, v26, v27, "get_path_for_id: cur fid %d should have parent fid 2 but part->fid == %d\n", buf, 0xEu);
    }

    *__error() = v25;
  }

LABEL_3:
  result = 0;
  *a3 = a4 + v7 - v8;
LABEL_24:
  v24 = *MEMORY[0x1E69E9840];
  return result;
}

uint64_t remove_path(uint64_t *a1, char *a2)
{
  v18 = *MEMORY[0x1E69E9840];
  result = _sqlite_bulkBegin(a1);
  if (!result)
  {
    memset(v17, 0, 268);
    v10 = 0;
    if (!get_id_for_path(a1, a2, v17, &v10, 0))
    {
      if (_sqlite_delete(a1, v17, 4))
      {
        v5 = *__error();
        v6 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *buf = 136315650;
          v12 = "remove_path_locked";
          v13 = 1024;
          v14 = 747;
          v15 = 1024;
          v16 = v17[0];
          _os_log_error_impl(&dword_1C278D000, v6, OS_LOG_TYPE_ERROR, "%s:%d: psid-remove: Could not delete the file-fid record for fid %d\n", buf, 0x18u);
        }

        *__error() = v5;
      }

      memset(v17 + 4, 0, 264);
      LODWORD(v17[0]) = v10;
      v7 = strrchr(a2, 47);
      v8 = a2 - 1;
      if (v7)
      {
        v8 = v7;
      }

      strncpy((v17 | 0xA), v8 + 1, 0x100uLL);
      BYTE9(v17[16]) = 0;
      WORD4(v17[0]) = strlen((v17 | 0xA)) + 1;
      _sqlite_delete(a1, v17, WORD4(v17[0]) + 12);
    }

    result = _sqlite_bulkEnd(a1);
  }

  v9 = *MEMORY[0x1E69E9840];
  return result;
}

uint64_t _sqlite_delete(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v38 = *MEMORY[0x1E69E9840];
  v27 = 0;
  v4 = sqlite3BtreeMoveto(*(a1 + 16), a2, a3, &v27);
  if (v4 | v27)
  {
    goto LABEL_21;
  }

  v5 = *(a1 + 16);
  v6 = *v5;
  if (*(*v5 + 24) != 2)
  {
    if (*(v6 + 26))
    {
      v4 = 8;
    }

    else
    {
      v4 = 1;
    }

    goto LABEL_18;
  }

  v7 = *(v5 + 48);
  if (*(v5 + 56) >= *(v7 + 20))
  {
    v4 = 1;
    goto LABEL_18;
  }

  if (!*(v5 + 96))
  {
    v4 = 3;
    goto LABEL_18;
  }

  if (!checkReadLocks(*(v6 + 8), *(v5 + 40), v5))
  {
    inserted = sqlite3pager_write(*(v7 + 112));
    if (inserted || ((v9 = *(v7 + 112), v10 = __rev16(*(v9 + *(v7 + 14) + 2 * *(v5 + 56))), !*(v7 + 4)) ? (v11 = bswap32(*(v9 + v10))) : (v11 = 0), inserted = clearCell(v7, v9 + v10), inserted))
    {
LABEL_17:
      v4 = inserted;
      goto LABEL_18;
    }

    if (*(v7 + 4))
    {
      v17 = *(v5 + 56);
      *buf = 0u;
      v32 = 0u;
      parseCellPtr(v7, v9 + v10, buf);
      dropCell(v7, v17, WORD5(v32));
      v4 = balance(v7, 0);
    }

    else
    {
      *buf = *v5;
      v32 = *(v5 + 16);
      v34 = *(v5 + 48);
      v35 = *(v5 + 64);
      v36 = *(v5 + 80);
      v37 = *(v5 + 96);
      v33 = *(v5 + 32);
      *&buf[8] = 0;
      *&v32 = 0;
      if (v34)
      {
        v18 = *(v34 + 112);
        if (*(v18 - 10))
        {
          ++*(v18 - 10);
        }

        else
        {
          _page_ref((v18 - 88));
        }
      }

      v19 = sqlite3BtreeNext(buf, &v28);
      if (v19)
      {
        if (v19 == 7)
        {
          v4 = 7;
        }

        else
        {
          v4 = 11;
        }

        goto LABEL_18;
      }

      v20 = v34;
      inserted = sqlite3pager_write(*(v34 + 112));
      if (inserted)
      {
        goto LABEL_17;
      }

      v21 = *(v5 + 56);
      v29 = 0u;
      v30 = 0u;
      parseCellPtr(v7, v9 + v10, &v29);
      dropCell(v7, v21, WORD5(v30));
      v22 = DWORD2(v34);
      v23 = *(v20 + 112) + __rev16(*(*(v20 + 112) + *(v20 + 14) + 2 * SDWORD2(v34)));
      v29 = 0u;
      v30 = 0u;
      parseCellPtr(v20, v23, &v29);
      v24 = WORD5(v30);
      v25 = sqlite3MallocRaw(*(v6 + 32) - 8);
      if (!v25)
      {
        v4 = 7;
        goto LABEL_18;
      }

      v26 = v25;
      inserted = insertCell(v7, *(v5 + 56), v23 - 4, v24 + 4, v25, 0);
      if (inserted)
      {
        goto LABEL_17;
      }

      *findOverflowCell(v7, *(v5 + 56)) = bswap32(v11);
      v4 = balance(v7, 0);
      free(v26);
      if (v4)
      {
        goto LABEL_18;
      }

      dropCell(v20, v22, v24);
      v4 = balance(v20, 0);
      sqlite3pager_unref(*(v20 + 112));
    }

    moveToRoot(v5);
    if (!v4)
    {
      goto LABEL_21;
    }

    goto LABEL_18;
  }

  v4 = 6;
LABEL_18:
  v12 = *__error();
  v13 = _SILogForLogForCategory(4);
  v14 = 2 * (dword_1EBF46ADC < 4);
  if (os_log_type_enabled(v13, v14))
  {
    *buf = 67109120;
    *&buf[4] = v4;
    _os_log_impl(&dword_1C278D000, v13, v14, "sqlite3BtreeDelete failed; rc = %d\n", buf, 8u);
  }

  *__error() = v12;
LABEL_21:
  v15 = *MEMORY[0x1E69E9840];
  return v4;
}

uint64_t *std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(void *a1, int a2)
{
  v2 = a1[1];
  if (!v2)
  {
    return 0;
  }

  v3 = vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
    {
      v4 = a2 % v2;
    }
  }

  else
  {
    v4 = (v2 - 1) & a2;
  }

  v5 = *(*a1 + 8 * v4);
  if (!v5)
  {
    return 0;
  }

  for (result = *v5; result; result = *result)
  {
    v7 = result[1];
    if (v7 == a2)
    {
      if (*(result + 4) == a2)
      {
        return result;
      }
    }

    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2)
        {
          v7 %= v2;
        }
      }

      else
      {
        v7 &= v2 - 1;
      }

      if (v7 != v4)
      {
        return 0;
      }
    }
  }

  return result;
}

uint64_t *___ZL23llmEntityBoostingArgIdsv_block_invoke()
{
  if (!*(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1) || ((v0 = vcnt_s8(*(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 8)), v0.i16[0] = vaddlv_u8(v0), v0.u32[0] > 1uLL) ? (v1 = ~(0xFFFFFFFFFFFFFFFFLL / *(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1) * *(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1))) : (v1 = *(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1) - 1), (v2 = *(llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 8 * v1)) == 0 || (v3 = *v2) == 0))
  {
LABEL_16:
    operator new();
  }

  while (1)
  {
    v4 = v3[1];
    if (v4 == -1)
    {
      break;
    }

    if (v0.u32[0] > 1uLL)
    {
      if (v4 >= *(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1))
      {
        v4 %= *(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1);
      }
    }

    else
    {
      v4 &= *(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1) - 1;
    }

    if (v4 != v1)
    {
      goto LABEL_16;
    }

LABEL_15:
    v3 = *v3;
    if (!v3)
    {
      goto LABEL_16;
    }
  }

  if (*(v3 + 4) != -1)
  {
    goto LABEL_15;
  }

  *(v3 + 5) = 0;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 1) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 158) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 159) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 160) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 161) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 162) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 163) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 164) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 165) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 166) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 167) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 168) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 169) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 170) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 171) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 172) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 173) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 174) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 175) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 176) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 177) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 178) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 179) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 180) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 181) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 182) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 183) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 15) + 5) = 1062006161;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 16) + 5) = 1041865114;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 81) + 5) = 1041865114;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 8) + 5) = 1067668472;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 9) + 5) = 1067668472;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 10) + 5) = 1067668472;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 11) + 5) = 1067668472;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 12) + 5) = 1067668472;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 13) + 5) = 1067668472;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 104) + 5) = 1036831949;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 64) + 5) = 1068010727;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 65) + 5) = 1068010727;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 66) + 5) = 1068010727;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 5) + 5) = 1064653606;
  *(std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 6) + 5) = 1064653606;
  result = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 7);
  *(result + 5) = 1064653606;
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(void *a1, int a2)
{
  v2 = a1[1];
  if (!v2)
  {
    goto LABEL_18;
  }

  v3 = vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
    {
      v4 = a2 % v2;
    }
  }

  else
  {
    v4 = (v2 - 1) & a2;
  }

  v5 = *(*a1 + 8 * v4);
  if (!v5 || (v6 = *v5) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v7 = v6[1];
    if (v7 == a2)
    {
      break;
    }

    if (v3.u32[0] > 1uLL)
    {
      if (v7 >= v2)
      {
        v7 %= v2;
      }
    }

    else
    {
      v7 &= v2 - 1;
    }

    if (v7 != v4)
    {
      goto LABEL_18;
    }

LABEL_17:
    v6 = *v6;
    if (!v6)
    {
      goto LABEL_18;
    }
  }

  if (*(v6 + 4) != a2)
  {
    goto LABEL_17;
  }

  return v6;
}

void std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    prime = 2;
  }

  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
    {
      prime = std::__next_prime(__n);
    }
  }

  v4 = *(a1 + 8);
  if (prime > *&v4)
  {
LABEL_6:
    if (!(prime >> 61))
    {
      operator new();
    }

    std::vector<long long>::__throw_length_error[abi:nn200100]();
  }

  if (prime < *&v4)
  {
    v5 = vcvtps_u32_f32(*(a1 + 24) / *(a1 + 32));
    if (*&v4 < 3uLL || (v6 = vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }

    else
    {
      v7 = 1 << -__clz(v5 - 1);
      if (v5 >= 2)
      {
        v5 = v7;
      }
    }

    if (prime <= v5)
    {
      prime = v5;
    }

    if (prime < *&v4)
    {
      if (prime)
      {
        goto LABEL_6;
      }

      v8 = *a1;
      *a1 = 0;
      if (v8)
      {
        operator delete(v8);
      }

      *(a1 + 8) = 0;
    }
  }
}

void llmDateAttributes(void)
{
  {
    llmDateAttributes(void)::_dateAttributes = 0u;
    *algn_1EBF61368 = 0u;
    dword_1EBF61378 = 1065353216;
  }

  if (llmDateAttributes(void)::onceToken != -1)
  {

    dispatch_once(&llmDateAttributes(void)::onceToken, &__block_literal_global);
  }
}

void ___Z17llmDateAttributesv_block_invoke()
{
  v10.__r_.__value_.__r.__words[0] = *MEMORY[0x1E69E9840];
  std::string::basic_string[abi:nn200100]<0>(&__str, "com_apple_mail_dateReceived");
  std::string::basic_string[abi:nn200100]<0>(v3, "com_apple_mail_dateSent");
  std::string::basic_string[abi:nn200100]<0>(v4, "kMDItemContentCreationDate");
  std::string::basic_string[abi:nn200100]<0>(v5, "kMDItemContentModificationDate");
  std::string::basic_string[abi:nn200100]<0>(v6, "kMDItemDueDate");
  std::string::basic_string[abi:nn200100]<0>(v7, "kMDItemEndDate");
  std::string::basic_string[abi:nn200100]<0>(v8, "kMDItemStartDate");
  std::string::basic_string[abi:nn200100]<0>(v9, "kMDItemUserSharedReceivedDate");
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>(&llmDateAttributes(void)::_dateAttributes, &__str, &v10);
  for (i = 0; i != -192; i -= 24)
  {
    if (v9[i + 23] < 0)
    {
      operator delete(*&v9[i]);
    }
  }

  v1 = *MEMORY[0x1E69E9840];
}

void sub_1C28C255C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  v12 = (v10 + 191);
  v13 = -192;
  v14 = v12;
  while (1)
  {
    v15 = *v14;
    v14 -= 24;
    if (v15 < 0)
    {
      operator delete(*(v12 - 23));
    }

    v12 = v14;
    v13 += 24;
    if (!v13)
    {
      _Unwind_Resume(exception_object);
    }
  }
}

_BYTE *std::string::basic_string[abi:nn200100]<0>(_BYTE *a1, char *__s)
{
  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
  {
    std::vector<long long>::__throw_length_error[abi:nn200100]();
  }

  v5 = v4;
  if (v4 >= 0x17)
  {
    operator new();
  }

  a1[23] = v4;
  if (v4)
  {
    memmove(a1, __s, v4);
  }

  a1[v5] = 0;
  return a1;
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>(uint64_t a1, std::string *__str, std::string *a3)
{
  v3 = a3;
  v4 = __str;
  v6 = *(a1 + 8);
  if (!v6)
  {
    goto LABEL_60;
  }

  for (i = 0; i != v6; ++i)
  {
    *(*a1 + 8 * i) = 0;
  }

  v8 = *(a1 + 16);
  *(a1 + 16) = 0;
  *(a1 + 24) = 0;
  v33 = (a1 + 16);
  if (v8)
  {
    v9 = __str == a3;
  }

  else
  {
    v9 = 1;
  }

  if (v9)
  {
    v10 = v8;
    goto LABEL_58;
  }

  while (1)
  {
    std::string::operator=((v8 + 2), v4);
    __p = *v8;
    v11 = *(v8 + 39);
    if (v11 >= 0)
    {
      v12 = (v8 + 2);
    }

    else
    {
      v12 = v8[2];
    }

    if (v11 >= 0)
    {
      v13 = *(v8 + 39);
    }

    else
    {
      v13 = v8[3];
    }

    v14 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](v12, v13);
    v15 = v14;
    v8[1] = v14;
    v16 = *(a1 + 8);
    if (v16)
    {
      v17 = vcnt_s8(v16);
      v17.i16[0] = vaddlv_u8(v17);
      v18 = v17.u32[0];
      if (v17.u32[0] > 1uLL)
      {
        v19 = v14;
        if (v16 <= v14)
        {
          v19 = v14 % v16;
        }
      }

      else
      {
        v19 = (v16 - 1) & v14;
      }

      v20 = *(*a1 + 8 * v19);
      if (v20)
      {
        v21 = *v20;
        if (*v20)
        {
          do
          {
            v22 = v21[1];
            if (v22 == v15)
            {
              if (std::equal_to<std::string>::operator()[abi:nn200100](v21 + 2, v8 + 2))
              {
                goto LABEL_54;
              }
            }

            else
            {
              if (v18 > 1)
              {
                if (v22 >= v16)
                {
                  v22 %= v16;
                }
              }

              else
              {
                v22 &= v16 - 1;
              }

              if (v22 != v19)
              {
                break;
              }
            }

            v21 = *v21;
          }

          while (v21);
        }
      }
    }

    v23 = (*(a1 + 24) + 1);
    v24 = *(a1 + 32);
    if (!v16 || (v24 * v16) < v23)
    {
      v25 = (v16 & (v16 - 1)) != 0;
      if (v16 < 3)
      {
        v25 = 1;
      }

      v26 = v25 | (2 * v16);
      v27 = vcvtps_u32_f32(v23 / v24);
      if (v26 <= v27)
      {
        v28 = v27;
      }

      else
      {
        v28 = v26;
      }

      std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(a1, v28);
      v16 = *(a1 + 8);
      v15 = v8[1];
    }

    v29 = vcnt_s8(v16);
    v29.i16[0] = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      if (v15 >= v16)
      {
        v15 %= v16;
      }
    }

    else
    {
      v15 &= v16 - 1;
    }

    v30 = *a1;
    v31 = *(*a1 + 8 * v15);
    if (v31)
    {
      *v8 = *v31;
LABEL_52:
      *v31 = v8;
      goto LABEL_53;
    }

    *v8 = *v33;
    *v33 = v8;
    *(v30 + 8 * v15) = v33;
    if (*v8)
    {
      v32 = *(*v8 + 1);
      if (v29.u32[0] > 1uLL)
      {
        if (v32 >= v16)
        {
          v32 %= v16;
        }
      }

      else
      {
        v32 &= v16 - 1;
      }

      v31 = (*a1 + 8 * v32);
      goto LABEL_52;
    }

LABEL_53:
    ++*(a1 + 24);
LABEL_54:
    ++v4;
    v10 = __p;
    if (!__p)
    {
      break;
    }

    v8 = __p;
    v3 = a3;
    if (v4 == a3)
    {
      goto LABEL_58;
    }
  }

  v3 = a3;
LABEL_58:
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(v10);
LABEL_60:
  while (v4 != v3)
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a1, v4++);
  }
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(void **__p)
{
  if (__p)
  {
    v1 = __p;
    do
    {
      v2 = *v1;
      if (*(v1 + 39) < 0)
      {
        operator delete(v1[2]);
      }

      operator delete(v1);
      v1 = v2;
    }

    while (v2);
  }
}

BOOL std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(void *a1, uint64_t a2)
{
  v4 = *(a2 + 23);
  if (v4 >= 0)
  {
    v5 = a2;
  }

  else
  {
    v5 = *a2;
  }

  if (v4 >= 0)
  {
    v6 = *(a2 + 23);
  }

  else
  {
    v6 = *(a2 + 8);
  }

  v7 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](v5, v6);
  v8 = v7;
  v9 = a1[1];
  if (!*&v9)
  {
    goto LABEL_24;
  }

  v10 = vcnt_s8(v9);
  v10.i16[0] = vaddlv_u8(v10);
  v11 = v10.u32[0];
  if (v10.u32[0] > 1uLL)
  {
    v12 = v7;
    if (v7 >= *&v9)
    {
      v12 = v7 % *&v9;
    }
  }

  else
  {
    v12 = (*&v9 - 1) & v7;
  }

  v13 = *(*a1 + 8 * v12);
  if (!v13 || (v14 = *v13) == 0)
  {
LABEL_24:
    operator new();
  }

  while (1)
  {
    v15 = v14[1];
    if (v15 == v8)
    {
      break;
    }

    if (v11 > 1)
    {
      if (v15 >= *&v9)
      {
        v15 %= *&v9;
      }
    }

    else
    {
      v15 &= *&v9 - 1;
    }

    if (v15 != v12)
    {
      goto LABEL_24;
    }

LABEL_23:
    v14 = *v14;
    if (!v14)
    {
      goto LABEL_24;
    }
  }

  result = std::equal_to<std::string>::operator()[abi:nn200100](v14 + 2, a2);
  if (!result)
  {
    goto LABEL_23;
  }

  return result;
}

BOOL std::equal_to<std::string>::operator()[abi:nn200100](void *a1, void *a2)
{
  v2 = *(a1 + 23);
  if (v2 >= 0)
  {
    v3 = *(a1 + 23);
  }

  else
  {
    v3 = a1[1];
  }

  v4 = *(a2 + 23);
  v5 = v4;
  if ((v4 & 0x80u) != 0)
  {
    v4 = a2[1];
  }

  if (v3 != v4)
  {
    return 0;
  }

  if (v2 < 0)
  {
    a1 = *a1;
  }

  v6 = *a2;
  if (v5 < 0)
  {
    a2 = *a2;
  }

  return memcmp(a1, a2, v3) == 0;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn200100](char a1, void **__p)
{
  if (a1)
  {
    if (*(__p + 39) < 0)
    {
      operator delete(__p[2]);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  if (__sz > 0x16)
  {
    if (__sz < 0x7FFFFFFFFFFFFFF8)
    {
      operator new();
    }

    std::vector<long long>::__throw_length_error[abi:nn200100]();
  }

  *(&this->__r_.__value_.__s + 23) = __sz;
  v3 = __sz + 1;

  memmove(this, __s, v3);
}

void ___ZL13llmDateArgIdsv_block_invoke()
{
  v3 = *MEMORY[0x1E69E9840];
  v1 = xmmword_1C2BF9E70;
  v2 = 0xD0000000CLL;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>(&llmDateArgIds(void)::_dateArgIds, &v1, &v3);
  v0 = *MEMORY[0x1E69E9840];
}

void std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>(uint64_t a1, int *a2, int *a3)
{
  v4 = a2;
  v6 = *(a1 + 8);
  if (v6)
  {
    for (i = 0; i != v6; ++i)
    {
      *(*a1 + 8 * i) = 0;
    }

    v8 = (a1 + 16);
    v9 = *(a1 + 16);
    *(a1 + 16) = 0;
    *(a1 + 24) = 0;
    if (v9)
    {
      v10 = a2 == a3;
    }

    else
    {
      v10 = 1;
    }

    if (!v10)
    {
      while (1)
      {
        v12 = *v4;
        *(v9 + 4) = v12;
        v11 = *v9;
        v9[1] = v12;
        if (v6)
        {
          v13 = vcnt_s8(v6);
          v13.i16[0] = vaddlv_u8(v13);
          if (v13.u32[0] > 1uLL)
          {
            v14 = v12;
            if (v6 <= v12)
            {
              v14 = v12 % v6;
            }
          }

          else
          {
            v14 = (v6 - 1) & v12;
          }

          v15 = *(*a1 + 8 * v14);
          if (v15)
          {
            for (j = *v15; j; j = *j)
            {
              v17 = j[1];
              if (v17 == v12)
              {
                if (*(j + 4) == v12)
                {
                  goto LABEL_49;
                }
              }

              else
              {
                if (v13.u32[0] > 1uLL)
                {
                  if (v17 >= v6)
                  {
                    v17 %= v6;
                  }
                }

                else
                {
                  v17 &= v6 - 1;
                }

                if (v17 != v14)
                {
                  break;
                }
              }
            }
          }
        }

        v18 = (*(a1 + 24) + 1);
        v19 = *(a1 + 32);
        if (!v6 || (v19 * v6) < v18)
        {
          v20 = 2 * v6;
          v21 = v6 < 3 || (v6 & (v6 - 1)) != 0;
          v22 = v21 | v20;
          v23 = vcvtps_u32_f32(v18 / v19);
          if (v22 <= v23)
          {
            v24 = v23;
          }

          else
          {
            v24 = v22;
          }

          std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(a1, v24);
          v6 = *(a1 + 8);
          v12 = v9[1];
        }

        v25 = vcnt_s8(v6);
        v25.i16[0] = vaddlv_u8(v25);
        if (v25.u32[0] > 1uLL)
        {
          if (v12 >= v6)
          {
            v12 %= v6;
          }
        }

        else
        {
          v12 &= v6 - 1;
        }

        v26 = *a1;
        v27 = *(*a1 + 8 * v12);
        if (v27)
        {
          *v9 = *v27;
        }

        else
        {
          *v9 = *v8;
          *v8 = v9;
          *(v26 + 8 * v12) = v8;
          if (!*v9)
          {
            goto LABEL_48;
          }

          v28 = *(*v9 + 8);
          if (v25.u32[0] > 1uLL)
          {
            if (v28 >= v6)
            {
              v28 %= v6;
            }
          }

          else
          {
            v28 &= v6 - 1;
          }

          v27 = (*a1 + 8 * v28);
        }

        *v27 = v9;
LABEL_48:
        ++*(a1 + 24);
LABEL_49:
        ++v4;
        if (v11)
        {
          v9 = v11;
          if (v4 != a3)
          {
            continue;
          }
        }

        goto LABEL_51;
      }
    }

    v11 = v9;
LABEL_51:
    if (v11)
    {
      do
      {
        v29 = *v11;
        operator delete(v11);
        v11 = v29;
      }

      while (v29);
    }
  }

  if (v4 != a3)
  {
    v30 = v4;
    do
    {
      v31 = *v30++;
      std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(a1, v31);
    }

    while (v30 != a3);
  }
}

void *std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(void *result, int a2)
{
  v2 = result[1];
  if (!v2)
  {
    goto LABEL_18;
  }

  v3 = vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
    {
      v4 = a2 % v2;
    }
  }

  else
  {
    v4 = (v2 - 1) & a2;
  }

  v5 = *(*result + 8 * v4);
  if (!v5 || (v6 = *v5) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v7 = v6[1];
    if (v7 == a2)
    {
      break;
    }

    if (v3.u32[0] > 1uLL)
    {
      if (v7 >= v2)
      {
        v7 %= v2;
      }
    }

    else
    {
      v7 &= v2 - 1;
    }

    if (v7 != v4)
    {
      goto LABEL_18;
    }

LABEL_17:
    v6 = *v6;
    if (!v6)
    {
      goto LABEL_18;
    }
  }

  if (*(v6 + 4) != a2)
  {
    goto LABEL_17;
  }

  return result;
}

void ___ZL29llmDenseRetrievalFilterArgIdsv_block_invoke()
{
  v3 = *MEMORY[0x1E69E9840];
  v1[0] = xmmword_1C2BF9E80;
  v1[1] = xmmword_1C2BF9E90;
  v1[2] = xmmword_1C2BF9EA0;
  v1[3] = xmmword_1C2BF9EB0;
  v1[4] = xmmword_1C2BF9EC0;
  v1[5] = xmmword_1C2BF9ED0;
  v1[6] = xmmword_1C2BF9EE0;
  v1[7] = xmmword_1C2BF9EF0;
  v1[8] = xmmword_1C2BF9F00;
  v1[9] = xmmword_1C2BF9F10;
  v1[10] = xmmword_1C2BF9F20;
  v1[11] = xmmword_1C2BF9F30;
  v1[12] = xmmword_1C2BF9F40;
  v1[13] = xmmword_1C2BF9F50;
  v1[14] = xmmword_1C2BF9F60;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>(&llmDenseRetrievalFilterArgIds(void)::_denseRetrievalFilterArgIds, v1, &v2);
  v0 = *MEMORY[0x1E69E9840];
}

uint64_t *std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::find<int>(uint64_t a1, unint64_t a2, int a3)
{
  if (!a2)
  {
    return 0;
  }

  v3 = vcnt_s8(a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a3;
    if (a3 >= a2)
    {
      v4 = a3 % a2;
    }
  }

  else
  {
    v4 = (a2 - 1) & a3;
  }

  v5 = *(a1 + 8 * v4);
  if (!v5)
  {
    return 0;
  }

  for (result = *v5; result; result = *result)
  {
    v7 = result[1];
    if (v7 == a3)
    {
      if (*(result + 4) == a3)
      {
        return result;
      }
    }

    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2)
        {
          v7 %= a2;
        }
      }

      else
      {
        v7 &= a2 - 1;
      }

      if (v7 != v4)
      {
        return 0;
      }
    }
  }

  return result;
}

void ___ZL45llmDenseRetrievalBundleSpecificFilterArgIdMapv_block_invoke()
{
  v20.__r_.__value_.__r.__words[0] = *MEMORY[0x1E69E9840];
  LODWORD(v17) = -1;
  __p.__r_.__value_.__r.__words[0] = &v17;
  v0 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, -1);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v0 + 3), 0, 0);
  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.spotlight.events");
  std::string::basic_string[abi:nn200100]<0>(&v19, "com.apple.mobilecal");
  v17 = &QUPP_ARG_TIME;
  v1 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 8);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v1 + 3), &__p, &v20);
  for (i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v19.__r_.__value_.__r.__words[i + 2]) < 0)
    {
      operator delete(*(&__p + i * 8 + 24));
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  std::string::basic_string[abi:nn200100]<0>(&v19, "com.apple.MobileSMS");
  v17 = &QUPP_ARG_PERSON_SENDER;
  v3 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 65);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v3 + 3), &__p, &v20);
  for (j = 0; j != -6; j -= 3)
  {
    if (SHIBYTE(v19.__r_.__value_.__r.__words[j + 2]) < 0)
    {
      operator delete(*(&__p + j * 8 + 24));
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  std::string::basic_string[abi:nn200100]<0>(&v19, "com.apple.MobileSMS");
  v17 = &QUPP_ARG_PERSON_RECEIVER;
  v5 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 66);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v5 + 3), &__p, &v20);
  for (k = 0; k != -6; k -= 3)
  {
    if (SHIBYTE(v19.__r_.__value_.__r.__words[k + 2]) < 0)
    {
      operator delete(*(&__p + k * 8 + 24));
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  std::string::basic_string[abi:nn200100]<0>(&v19, "com.apple.MobileSMS");
  v17 = &QUPP_ARG_CONVERSATION_FILTER_TIME;
  v7 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 193);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v7 + 3), &__p, &v20);
  for (m = 0; m != -6; m -= 3)
  {
    if (SHIBYTE(v19.__r_.__value_.__r.__words[m + 2]) < 0)
    {
      operator delete(*(&__p + m * 8 + 24));
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  std::string::basic_string[abi:nn200100]<0>(&v19, "com.apple.reminders");
  v17 = &QUPP_ARG_APP_ENTITY_STATUS_FLAGGED;
  v9 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 43);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v9 + 3), &__p, &v20);
  for (n = 0; n != -6; n -= 3)
  {
    if (SHIBYTE(v19.__r_.__value_.__r.__words[n + 2]) < 0)
    {
      operator delete(*(&__p + n * 8 + 24));
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  v17 = &QUPP_ARG_APP_ENTITY_STATUS_READ;
  v11 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 47);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v11 + 3), &__p, &v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  v17 = &QUPP_ARG_APP_ENTITY_STATUS_UNREAD;
  v12 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 55);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v12 + 3), &__p, &v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  v17 = &QUPP_ARG_APP_ENTITY_STATUS_DRAFT;
  v13 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 39);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v13 + 3), &__p, &v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (isWalletDocumentUnderstandingEnabled_onceToken != -1)
  {
    dispatch_once(&isWalletDocumentUnderstandingEnabled_onceToken, &__block_literal_global_18_11151);
  }

  if (isWalletDocumentUnderstandingEnabled_ffStatus == 1)
  {
    std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.Passbook");
    v17 = &QUPP_ARG_LOCATION_DEPARTURE;
    v14 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 6);
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v14 + 3), &__p, &v19);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.Passbook");
    v17 = &QUPP_ARG_LOCATION_ARRIVAL;
    v15 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmDenseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 7);
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v15 + 3), &__p, &v19);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  v16 = *MEMORY[0x1E69E9840];
}

uint64_t *std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(void *a1, int a2)
{
  v2 = a1[1];
  if (!v2)
  {
    goto LABEL_18;
  }

  v3 = vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
    {
      v4 = a2 % v2;
    }
  }

  else
  {
    v4 = (v2 - 1) & a2;
  }

  v5 = *(*a1 + 8 * v4);
  if (!v5 || (v6 = *v5) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v7 = v6[1];
    if (v7 == a2)
    {
      break;
    }

    if (v3.u32[0] > 1uLL)
    {
      if (v7 >= v2)
      {
        v7 %= v2;
      }
    }

    else
    {
      v7 &= v2 - 1;
    }

    if (v7 != v4)
    {
      goto LABEL_18;
    }

LABEL_17:
    v6 = *v6;
    if (!v6)
    {
      goto LABEL_18;
    }
  }

  if (*(v6 + 4) != a2)
  {
    goto LABEL_17;
  }

  return v6;
}

void sub_1C28C3CF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_set<std::string>>,void *>>>>::~unique_ptr[abi:nn200100](va);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(void *a1, int a2)
{
  v2 = a1[1];
  if (!v2)
  {
    goto LABEL_18;
  }

  v3 = vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
    {
      v4 = a2 % v2;
    }
  }

  else
  {
    v4 = (v2 - 1) & a2;
  }

  v5 = *(*a1 + 8 * v4);
  if (!v5 || (v6 = *v5) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v7 = v6[1];
    if (v7 == a2)
    {
      break;
    }

    if (v3.u32[0] > 1uLL)
    {
      if (v7 >= v2)
      {
        v7 %= v2;
      }
    }

    else
    {
      v7 &= v2 - 1;
    }

    if (v7 != v4)
    {
      goto LABEL_18;
    }

LABEL_17:
    v6 = *v6;
    if (!v6)
    {
      goto LABEL_18;
    }
  }

  if (*(v6 + 4) != a2)
  {
    goto LABEL_17;
  }

  return v6;
}

void sub_1C28C3F60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_set<std::string>>,void *>>>>::~unique_ptr[abi:nn200100](va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_set<std::string>>,void *>>>>::~unique_ptr[abi:nn200100](uint64_t a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(a1 + 16) == 1)
    {
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v2 + 24);
    }

    operator delete(v2);
  }

  return a1;
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(*(a1 + 16));
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    operator delete(v2);
  }

  return a1;
}

BOOL isLLMRetrievalFilterArgId(int a1)
{
  {
    llmRetrievalFilterArgIds(void)::_retrievalFilterArgIds = 0u;
    unk_1EBF61480 = 0u;
    dword_1EBF61490 = 1065353216;
  }

  if (llmRetrievalFilterArgIds(void)::onceToken != -1)
  {
    dispatch_once(&llmRetrievalFilterArgIds(void)::onceToken, &__block_literal_global_29);
  }

  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmRetrievalFilterArgIds(void)::_retrievalFilterArgIds, a1) != 0;
}

void ___ZL24llmRetrievalFilterArgIdsv_block_invoke()
{
  v4 = *MEMORY[0x1E69E9840];
  v1[0] = xmmword_1C2BF9F70;
  v1[1] = xmmword_1C2BF9F80;
  v1[2] = xmmword_1C2BF9F90;
  v1[3] = xmmword_1C2BF9FA0;
  v1[4] = xmmword_1C2BF9FB0;
  v1[5] = xmmword_1C2BF9FC0;
  v1[6] = xmmword_1C2BF9FD0;
  v1[7] = xmmword_1C2BF9FE0;
  v1[8] = xmmword_1C2BF9FF0;
  v1[9] = xmmword_1C2BFA000;
  v1[10] = xmmword_1C2BFA010;
  v1[11] = xmmword_1C2BFA020;
  v2 = 208;
  v1[12] = xmmword_1C2BFA030;
  v1[13] = xmmword_1C2BFA040;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>(&llmRetrievalFilterArgIds(void)::_retrievalFilterArgIds, v1, &v3);
  v0 = *MEMORY[0x1E69E9840];
}

void std::vector<std::string>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::clear[abi:nn200100](v2);
    v3 = **a1;

    operator delete(v3);
  }
}

void std::vector<std::string>::clear[abi:nn200100](void ***a1)
{
  v2 = *a1;
  v3 = a1[1];
  while (v3 != v2)
  {
    v4 = *(v3 - 1);
    v3 -= 3;
    if (v4 < 0)
    {
      operator delete(*v3);
    }
  }

  a1[1] = v2;
}

void std::vector<std::string>::__vdeallocate(std::vector<std::string> *this)
{
  if (this->__begin_)
  {
    std::vector<std::string>::clear[abi:nn200100](this);
    operator delete(this->__begin_);
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
  }
}

void std::vector<std::string>::__vallocate[abi:nn200100](uint64_t a1, unint64_t a2)
{
  if (a2 < 0xAAAAAAAAAAAAAABLL)
  {
    std::__allocate_at_least[abi:nn200100]<std::allocator<std::string>>(a2);
  }

  std::vector<long long>::__throw_length_error[abi:nn200100]();
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<std::string>>(unint64_t a1)
{
  if (a1 < 0xAAAAAAAAAAAAAABLL)
  {
    operator new();
  }

  std::vector<long long>::__throw_length_error[abi:nn200100]();
}

void ___ZL46llmSparseRetrievalBundleSpecificFilterArgIdMapv_block_invoke()
{
  v10.__r_.__value_.__r.__words[0] = *MEMORY[0x1E69E9840];
  LODWORD(v7) = -1;
  __p.__r_.__value_.__r.__words[0] = &v7;
  v0 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&llmSparseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, -1);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v0 + 3), 0, 0);
  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  std::string::basic_string[abi:nn200100]<0>(&v9, "com.apple.reminders");
  v7 = &QUPP_ARG_APP_ENTITY_STATUS_FLAGGED;
  v1 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmSparseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 43);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v1 + 3), &__p, &v10);
  for (i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v9.__r_.__value_.__r.__words[i + 2]) < 0)
    {
      operator delete(*(&__p + i * 8 + 24));
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  v7 = &QUPP_ARG_APP_ENTITY_STATUS_READ;
  v3 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmSparseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 47);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v3 + 3), &__p, &v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  v7 = &QUPP_ARG_APP_ENTITY_STATUS_UNREAD;
  v4 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmSparseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 55);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v4 + 3), &__p, &v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "com.apple.mobilemail");
  v7 = &QUPP_ARG_APP_ENTITY_STATUS_DRAFT;
  v5 = std::__hash_table<std::__hash_value_type<int,std::unordered_set<std::string>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<std::string>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<std::string>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&llmSparseRetrievalBundleSpecificFilterArgIdMap(void)::_retrievalBundleSpecificFilterArgIdMap, 39);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((v5 + 3), &__p, &v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v6 = *MEMORY[0x1E69E9840];
}

BOOL isLLMPersonArgId(int a1)
{
  {
    llmPersonArgIds(void)::_personArgIds = 0u;
    *algn_1EBF614F0 = 0u;
    dword_1EBF61500 = 1065353216;
  }

  if (llmPersonArgIds(void)::onceToken != -1)
  {
    dispatch_once(&llmPersonArgIds(void)::onceToken, &__block_literal_global_37);
  }

  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmPersonArgIds(void)::_personArgIds, a1) != 0;
}

void ___ZL15llmPersonArgIdsv_block_invoke()
{
  v4 = *MEMORY[0x1E69E9840];
  v1 = 0x4100000040;
  v2 = 66;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>(&llmPersonArgIds(void)::_personArgIds, &v1, &v3);
  v0 = *MEMORY[0x1E69E9840];
}

BOOL isLLMLocationArgId(int a1)
{
  {
    llmLocationArgIds(void)::_locationArgIds = 0u;
    unk_1EBF61528 = 0u;
    dword_1EBF61538 = 1065353216;
  }

  if (llmLocationArgIds(void)::onceToken != -1)
  {
    dispatch_once(&llmLocationArgIds(void)::onceToken, &__block_literal_global_39);
  }

  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmLocationArgIds(void)::_locationArgIds, a1) != 0;
}

void ___ZL17llmLocationArgIdsv_block_invoke()
{
  v4 = *MEMORY[0x1E69E9840];
  v1 = 0x600000005;
  v2 = 7;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>(&llmLocationArgIds(void)::_locationArgIds, &v1, &v3);
  v0 = *MEMORY[0x1E69E9840];
}

BOOL isLLMOptionalArgId(int a1)
{
  {
    llmOptionalArgIds(void)::_optionalArgIds = 0u;
    unk_1EBF61560 = 0u;
    dword_1EBF61570 = 1065353216;
  }

  if (llmOptionalArgIds(void)::onceToken != -1)
  {
    dispatch_once(&llmOptionalArgIds(void)::onceToken, &__block_literal_global_41);
  }

  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmOptionalArgIds(void)::_optionalArgIds, a1) != 0;
}

void ___ZL17llmOptionalArgIdsv_block_invoke()
{
  v3 = *MEMORY[0x1E69E9840];
  v1[0] = xmmword_1C2BFA050;
  v1[1] = xmmword_1C2BFA060;
  v1[2] = xmmword_1C2BFA070;
  v1[3] = xmmword_1C2BFA080;
  v2 = 0x68000000D3;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>(&llmOptionalArgIds(void)::_optionalArgIds, v1, &v3);
  v0 = *MEMORY[0x1E69E9840];
}

BOOL isLLMOptionalizationArgId(int a1)
{
  {
    llmOptionalizationArgIds(void)::_optionalizationArgIds = 0u;
    unk_1EBF61598 = 0u;
    dword_1EBF615A8 = 1065353216;
  }

  if (llmOptionalizationArgIds(void)::onceToken != -1)
  {
    dispatch_once(&llmOptionalizationArgIds(void)::onceToken, &__block_literal_global_43);
  }

  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmOptionalizationArgIds(void)::_optionalizationArgIds, a1) != 0;
}

void ___ZL24llmOptionalizationArgIdsv_block_invoke()
{
  v4 = *MEMORY[0x1E69E9840];
  v1[0] = xmmword_1C2BFA090;
  v1[1] = xmmword_1C2BFA0A0;
  v1[2] = xmmword_1C2BFA0B0;
  v2 = 211;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>(&llmOptionalizationArgIds(void)::_optionalizationArgIds, v1, &v3);
  v0 = *MEMORY[0x1E69E9840];
}

uint64_t isOptionalSearchTerm(int a1, const void **a2, CFArrayRef theArray, CFIndex a4, int a5, int a6, int a7)
{
  result = 0;
  if (!theArray || a1 != 1)
  {
    return result;
  }

  if (CFArrayGetCount(theArray) <= a4)
  {
    return 0;
  }

  if (a6)
  {
    {
      llmSearchTermPhotosSuffixesToRemove(void)::_searchTermPhotosSuffixesToRemove = 0u;
      *algn_1EBF615D0 = 0u;
      dword_1EBF615E0 = 1065353216;
    }

    if (llmSearchTermPhotosSuffixesToRemove(void)::onceToken != -1)
    {
      dispatch_once(&llmSearchTermPhotosSuffixesToRemove(void)::onceToken, &__block_literal_global_48);
    }

    v15 = &llmSearchTermPhotosSuffixesToRemove(void)::_searchTermPhotosSuffixesToRemove;
LABEL_25:

    return isOptionalSearchTermSuffixToRemove(a2, theArray, a4, v15);
  }

  if (!a5)
  {
    {
      llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove = 0u;
      unk_1EBF61678 = 0u;
      dword_1EBF61688 = 1065353216;
    }

    if (llmSearchTermSuffixesToRemove(void)::onceToken != -1)
    {
      dispatch_once(&llmSearchTermSuffixesToRemove(void)::onceToken, &__block_literal_global_125);
    }

    v15 = &llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove;
    goto LABEL_25;
  }

  if (!a7)
  {
    {
      llmSearchTermCalendarSuffixesToRemove(void)::_searchTermCalendarSuffixesToRemove = 0u;
      unk_1EBF61640 = 0u;
      dword_1EBF61650 = 1065353216;
    }

    if (llmSearchTermCalendarSuffixesToRemove(void)::onceToken != -1)
    {
      dispatch_once(&llmSearchTermCalendarSuffixesToRemove(void)::onceToken, &__block_literal_global_117);
    }

    v15 = &llmSearchTermCalendarSuffixesToRemove(void)::_searchTermCalendarSuffixesToRemove;
    goto LABEL_25;
  }

  {
    llmSearchTermCalendarOneOnOneToRemove(void)::_searchTermCalendarOneOnOneToRemove = 0u;
    *&qword_1EBF61608 = 0u;
    dword_1EBF61618 = 1065353216;
  }

  if (llmSearchTermCalendarOneOnOneToRemove(void)::onceToken != -1)
  {
    dispatch_once(&llmSearchTermCalendarOneOnOneToRemove(void)::onceToken, &__block_literal_global_52);
  }

  return std::__find[abi:nn200100]<std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::string,std::__identity>(qword_1EBF61608, a2) != 0;
}