uint64_t ___ZN12_GLOBAL__N_112_GLOBAL__N_114HeapUsageTable5applyERNS0_16BufferUsageTableES3_S3_S3_RNS0_17TextureUsageTableES5_S5_S5__block_invoke_7(uint64_t result, unsigned int *a2, int a3)
{
  if (a3)
  {
    v3 = a3;
    v5 = result;
    do
    {
      v6 = *a2;
      if (v6)
      {
        v7 = *(*(v5 + 40) + 16);
        if ((v7 & 4) != 0)
        {
          LOBYTE(v8) = v7 & 2 | 1;
        }

        else
        {
          v8 = *(*(v5 + 40) + 16);
        }

        result = [**(v5 + 32) contents];
        *(result + (v6 >> 2)) |= v8 << (2 * (v6 & 3));
      }

      ++a2;
      --v3;
    }

    while (v3);
  }

  return result;
}

uint64_t ___ZN12_GLOBAL__N_112_GLOBAL__N_114HeapUsageTable5applyERNS0_16BufferUsageTableES3_S3_S3_RNS0_17TextureUsageTableES5_S5_S5__block_invoke_8(uint64_t result, unsigned int *a2, int a3)
{
  if (a3)
  {
    v3 = a3;
    v5 = result;
    do
    {
      v6 = *a2;
      if (v6)
      {
        v7 = *(*(v5 + 40) + 16);
        if ((v7 & 4) != 0)
        {
          LOBYTE(v8) = v7 & 2 | 1;
        }

        else
        {
          v8 = *(*(v5 + 40) + 16);
        }

        result = [**(v5 + 32) contents];
        *(result + (v6 >> 2)) |= v8 << (2 * (v6 & 3));
      }

      ++a2;
      --v3;
    }

    while (v3);
  }

  return result;
}

uint64_t ___ZN12_GLOBAL__N_112_GLOBAL__N_114HeapUsageTable5applyERNS0_16BufferUsageTableES3_S3_S3_RNS0_17TextureUsageTableES5_S5_S5__block_invoke_9(uint64_t result, unsigned int *a2, int a3)
{
  if (a3)
  {
    v3 = a3;
    v5 = result;
    do
    {
      v6 = *a2;
      if (v6)
      {
        v7 = *(*(v5 + 40) + 16);
        if ((v7 & 4) != 0)
        {
          LOBYTE(v8) = v7 & 2 | 1;
        }

        else
        {
          v8 = *(*(v5 + 40) + 16);
        }

        result = [**(v5 + 32) contents];
        *(result + (v6 >> 2)) |= v8 << (2 * (v6 & 3));
      }

      ++a2;
      --v3;
    }

    while (v3);
  }

  return result;
}

uint64_t ___ZN12_GLOBAL__N_112_GLOBAL__N_114HeapUsageTable5applyERNS0_16BufferUsageTableES3_S3_S3_RNS0_17TextureUsageTableES5_S5_S5__block_invoke_10(uint64_t result, unsigned int *a2, int a3)
{
  if (a3)
  {
    v3 = a3;
    v5 = result;
    do
    {
      v6 = *a2;
      if (v6)
      {
        v7 = *(*(v5 + 40) + 16);
        if ((v7 & 4) != 0)
        {
          LOBYTE(v8) = v7 & 2 | 1;
        }

        else
        {
          v8 = *(*(v5 + 40) + 16);
        }

        result = [**(v5 + 32) contents];
        *(result + (v6 >> 2)) |= v8 << (2 * (v6 & 3));
      }

      ++a2;
      --v3;
    }

    while (v3);
  }

  return result;
}

uint64_t ___ZN12_GLOBAL__N_112_GLOBAL__N_114HeapUsageTable5applyERNS0_16BufferUsageTableES3_S3_S3_RNS0_17TextureUsageTableES5_S5_S5__block_invoke_11(uint64_t result, unsigned int *a2, int a3)
{
  if (a3)
  {
    v3 = a3;
    v5 = result;
    do
    {
      v6 = *a2;
      if (v6)
      {
        v7 = *(*(v5 + 40) + 16);
        if ((v7 & 4) != 0)
        {
          LOBYTE(v8) = v7 & 2 | 1;
        }

        else
        {
          v8 = *(*(v5 + 40) + 16);
        }

        result = [**(v5 + 32) contents];
        *(result + (v6 >> 2)) |= v8 << (2 * (v6 & 3));
      }

      ++a2;
      --v3;
    }

    while (v3);
  }

  return result;
}

uint64_t ___ZN12_GLOBAL__N_112_GLOBAL__N_114HeapUsageTable5applyERNS0_16BufferUsageTableES3_S3_S3_RNS0_17TextureUsageTableES5_S5_S5__block_invoke_12(uint64_t result, unsigned int *a2, int a3)
{
  if (a3)
  {
    v3 = a3;
    v5 = result;
    do
    {
      v6 = *a2;
      if (v6)
      {
        v7 = *(*(v5 + 40) + 16);
        if ((v7 & 4) != 0)
        {
          LOBYTE(v8) = v7 & 2 | 1;
        }

        else
        {
          v8 = *(*(v5 + 40) + 16);
        }

        result = [**(v5 + 32) contents];
        *(result + (v6 >> 2)) |= v8 << (2 * (v6 & 3));
      }

      ++a2;
      --v3;
    }

    while (v3);
  }

  return result;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,anonymous namespace::EncoderResourceUsage>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,anonymous namespace::EncoderResourceUsage>,void *>>>>::~unique_ptr[abi:ne200100](uint64_t a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(a1 + 16) == 1)
    {
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v2 + 24);
    }

    operator delete(v2);
  }

  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>>>::__hash_table(uint64_t result, uint64_t *a2)
{
  v2 = *a2;
  *a2 = 0;
  *result = v2;
  v5 = a2[2];
  v3 = a2 + 2;
  v4 = v5;
  v6 = *(v3 - 1);
  *(result + 16) = v5;
  *(result + 8) = v6;
  *(v3 - 1) = 0;
  v7 = v3[1];
  *(result + 24) = v7;
  *(result + 32) = *(v3 + 4);
  if (v7)
  {
    v8 = *(v4 + 8);
    v9 = *(result + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
      {
        v8 %= v9;
      }
    }

    else
    {
      v8 &= v9 - 1;
    }

    *(v2 + 8 * v8) = result + 16;
    *v3 = 0;
    v3[1] = 0;
  }

  return result;
}

void std::__throw_out_of_range[abi:ne200100](const char *a1)
{
  exception = __cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne200100](exception, a1);
  __cxa_throw(exception, off_2787B3758, MEMORY[0x277D825F8]);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne200100](std::logic_error *a1, const char *a2)
{
  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (MEMORY[0x277D828E8] + 16);
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>>>::find<unsigned long long>(void *a1, unint64_t *a2)
{
  v2 = a1[1];
  if (!*&v2)
  {
    return 0;
  }

  v3 = *a2;
  v4 = vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v3 >= *&v2)
    {
      v5 = v3 % *&v2;
    }
  }

  else
  {
    v5 = (*&v2 - 1) & v3;
  }

  v6 = *(*a1 + 8 * v5);
  if (!v6)
  {
    return 0;
  }

  result = *v6;
  if (*v6)
  {
    do
    {
      v8 = result[1];
      if (v3 == v8)
      {
        if (result[2] == v3)
        {
          return result;
        }
      }

      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *&v2)
          {
            v8 %= *&v2;
          }
        }

        else
        {
          v8 &= *&v2 - 1;
        }

        if (v8 != v5)
        {
          return 0;
        }
      }

      result = *result;
    }

    while (result);
  }

  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>>>::__node_insert_unique(uint64_t *a1, void *a2)
{
  v2 = a2;
  v5 = a2 + 2;
  v4 = a2[2];
  *(v5 - 1) = v4;
  v6 = std::__hash_table<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>>>::__node_insert_unique_prepare[abi:ne200100](a1, v4, v5);
  if (v6)
  {
    return v6;
  }

  std::__hash_table<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>>>::__node_insert_unique_perform[abi:ne200100](a1, v2);
  return v2;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>>>::__node_insert_unique_prepare[abi:ne200100](uint64_t a1, unint64_t a2, void *a3)
{
  v3 = *(a1 + 8);
  if (v3)
  {
    v4 = vcnt_s8(v3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      v5 = v3 <= a2 ? a2 % v3 : a2;
    }

    else
    {
      v5 = (v3 - 1) & a2;
    }

    v6 = *(*a1 + 8 * v5);
    if (v6)
    {
      for (i = *v6; i; i = *i)
      {
        v8 = i[1];
        if (v8 == a2)
        {
          if (i[2] == *a3)
          {
            return i;
          }
        }

        else
        {
          if (v4.u32[0] > 1uLL)
          {
            if (v8 >= v3)
            {
              v8 %= v3;
            }
          }

          else
          {
            v8 &= v3 - 1;
          }

          if (v8 != v5)
          {
            break;
          }
        }
      }
    }
  }

  v9 = (*(a1 + 24) + 1);
  v10 = *(a1 + 32);
  if (!v3 || (v10 * v3) < v9)
  {
    v11 = 2 * v3;
    v12 = v3 < 3 || (v3 & (v3 - 1)) != 0;
    v13 = v12 | v11;
    v14 = vcvtps_u32_f32(v9 / v10);
    if (v13 <= v14)
    {
      v15 = v14;
    }

    else
    {
      v15 = v13;
    }

    std::__hash_table<std::__hash_value_type<unsigned int,NSString *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,NSString *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,NSString *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,NSString *>>>::__rehash<true>(a1, v15);
  }

  return 0;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MTLLegacySVResidencySet *>>>::__node_insert_unique_perform[abi:ne200100](uint64_t *result, void *a2)
{
  v2 = result[1];
  v3 = a2[1];
  v4 = vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *&v2)
    {
      v3 %= *&v2;
    }
  }

  else
  {
    v3 &= *&v2 - 1;
  }

  v5 = *result;
  v6 = *(*result + 8 * v3);
  if (v6)
  {
    *a2 = *v6;
LABEL_13:
    *v6 = a2;
    goto LABEL_14;
  }

  *a2 = result[2];
  result[2] = a2;
  *(v5 + 8 * v3) = result + 2;
  if (*a2)
  {
    v7 = *(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v7 >= *&v2)
      {
        v7 %= *&v2;
      }
    }

    else
    {
      v7 &= *&v2 - 1;
    }

    v6 = (*result + 8 * v7);
    goto LABEL_13;
  }

LABEL_14:
  ++result[3];
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned long,MTLLegacySVResidencySet *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,MTLLegacySVResidencySet *>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,MTLLegacySVResidencySet *>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,MTLLegacySVResidencySet *>>>::__emplace_unique_key_args<unsigned long,unsigned long,MTLLegacySVResidencySet *>(void *a1, unint64_t *a2)
{
  v2 = *a2;
  v3 = a1[1];
  if (!*&v3)
  {
    goto LABEL_18;
  }

  v4 = vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v2 >= *&v3)
    {
      v5 = v2 % *&v3;
    }
  }

  else
  {
    v5 = (*&v3 - 1) & v2;
  }

  v6 = *(*a1 + 8 * v5);
  if (!v6 || (v7 = *v6) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v8 = v7[1];
    if (v8 == v2)
    {
      break;
    }

    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *&v3)
      {
        v8 %= *&v3;
      }
    }

    else
    {
      v8 &= *&v3 - 1;
    }

    if (v8 != v5)
    {
      goto LABEL_18;
    }

LABEL_17:
    v7 = *v7;
    if (!v7)
    {
      goto LABEL_18;
    }
  }

  if (v7[2] != v2)
  {
    goto LABEL_17;
  }

  return v7;
}

void *std::__hash_table<std::__hash_value_type<unsigned long,MTLLegacySVResidencySet *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,MTLLegacySVResidencySet *>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,MTLLegacySVResidencySet *>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,MTLLegacySVResidencySet *>>>::__emplace_unique_key_args<unsigned long,unsigned long,MTLLegacySVResidencySet *&>(void *a1, unint64_t *a2)
{
  v2 = *a2;
  v3 = a1[1];
  if (!*&v3)
  {
    goto LABEL_18;
  }

  v4 = vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v2 >= *&v3)
    {
      v5 = v2 % *&v3;
    }
  }

  else
  {
    v5 = (*&v3 - 1) & v2;
  }

  v6 = *(*a1 + 8 * v5);
  if (!v6 || (v7 = *v6) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v8 = v7[1];
    if (v8 == v2)
    {
      break;
    }

    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *&v3)
      {
        v8 %= *&v3;
      }
    }

    else
    {
      v8 &= *&v3 - 1;
    }

    if (v8 != v5)
    {
      goto LABEL_18;
    }

LABEL_17:
    v7 = *v7;
    if (!v7)
    {
      goto LABEL_18;
    }
  }

  if (v7[2] != v2)
  {
    goto LABEL_17;
  }

  return v7;
}

void *std::__hash_table<_MTLResource *,std::hash<_MTLResource *>,std::equal_to<_MTLResource *>,std::allocator<_MTLResource *>>::__emplace_unique_key_args<_MTLResource *,_MTLResource *>(void *a1, void *a2)
{
  v2 = 0x9DDFEA08EB382D69 * ((8 * (*a2 & 0x1FFFFFFFLL) + 8) ^ HIDWORD(*a2));
  v3 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v2 >> 47) ^ v2);
  v4 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
  v5 = a1[1];
  if (!*&v5)
  {
    goto LABEL_18;
  }

  v6 = vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
    if (v4 >= *&v5)
    {
      v7 = v4 % *&v5;
    }
  }

  else
  {
    v7 = v4 & (*&v5 - 1);
  }

  v8 = *(*a1 + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v10 = v9[1];
    if (v10 == v4)
    {
      break;
    }

    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= *&v5)
      {
        v10 %= *&v5;
      }
    }

    else
    {
      v10 &= *&v5 - 1;
    }

    if (v10 != v7)
    {
      goto LABEL_18;
    }

LABEL_17:
    v9 = *v9;
    if (!v9)
    {
      goto LABEL_18;
    }
  }

  if (v9[2] != *a2)
  {
    goto LABEL_17;
  }

  return v9;
}

void *std::__hash_table<_MTLHeap *,std::hash<_MTLHeap *>,std::equal_to<_MTLHeap *>,std::allocator<_MTLHeap *>>::__emplace_unique_key_args<_MTLHeap *,_MTLHeap *>(void *a1, void *a2)
{
  v2 = 0x9DDFEA08EB382D69 * ((8 * (*a2 & 0x1FFFFFFFLL) + 8) ^ HIDWORD(*a2));
  v3 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v2 >> 47) ^ v2);
  v4 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
  v5 = a1[1];
  if (!*&v5)
  {
    goto LABEL_18;
  }

  v6 = vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
    if (v4 >= *&v5)
    {
      v7 = v4 % *&v5;
    }
  }

  else
  {
    v7 = v4 & (*&v5 - 1);
  }

  v8 = *(*a1 + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v10 = v9[1];
    if (v10 == v4)
    {
      break;
    }

    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= *&v5)
      {
        v10 %= *&v5;
      }
    }

    else
    {
      v10 &= *&v5 - 1;
    }

    if (v10 != v7)
    {
      goto LABEL_18;
    }

LABEL_17:
    v9 = *v9;
    if (!v9)
    {
      goto LABEL_18;
    }
  }

  if (v9[2] != *a2)
  {
    goto LABEL_17;
  }

  return v9;
}

void emitTextureDistribution(void *a1, uint64_t a2)
{
  v166 = *MEMORY[0x277D85DE8];
  for (i = *(a2 + 16); i; i = *(v61 - 104))
  {
    v78 = i;
    v79 = 0;
    v3 = i + 104;
    v61 = i + 104;
    do
    {
      v4 = MTLTextureType1D;
      v62 = v3;
      do
      {
        v5 = *(i + 16);
        Name = MTLPixelFormatGetName();
        v7 = *(v3 - 80);
        if (!v7)
        {
          goto LABEL_40;
        }

        v8 = Name;
        if (*MEMORY[0x277CD7168])
        {
          if (*MEMORY[0x277CD7168] != 1)
          {
            goto LABEL_40;
          }

          v75 = off_2787B3F40[v79];
          v73 = MTLTelemetryStringifyTextureType(v4);
          v9 = *(v3 - 40);
          v10 = *(v3 - 48);
          v11 = 0.0;
          v12 = 0.0;
          if (v9)
          {
            v12 = (v10 / v9);
          }

          v13 = *(v3 - 16);
          v14 = *(v3 - 24);
          if (v13)
          {
            v11 = (v14 / v13);
          }

          v15 = *(v3 + 8);
          v16 = 0.0;
          v17 = 0.0;
          v18 = *v3;
          if (v15)
          {
            v17 = (v18 / v15);
          }

          v19 = *(v3 + 32);
          v20 = *(v3 + 24);
          if (v19)
          {
            v16 = (v20 / v19);
          }

          v21 = *(v3 + 56);
          v22 = 0.0;
          v23 = 0.0;
          v24 = *(v3 + 48);
          if (v21)
          {
            v23 = (v24 / v21);
          }

          v25 = *(v3 + 80);
          v26 = *(v3 + 72);
          if (v25)
          {
            v22 = (v26 / v25);
          }

          v27 = *(v3 + 104);
          v28 = *(v3 + 96);
          if (v27)
          {
            v29 = (v28 / v27);
          }

          else
          {
            v29 = 0.0;
          }

          printf("\n\nTexture, category=%s, format=%s, type=%s, total=%u, minWidth=%u, maxWidth=%u, avgWidth=%f, totalWidth=%llu, countWidth=%u, minHeight=%u, maxHeight=%u, avgHeight=%f, totalHeight=%llu, countHeight=%u, minDepth=%u, maxDepth=%u, avgDepth=%f, totalDepth=%llu, countDepth=%u, minMipLevels=%u, maxMipLevels=%u, avgMipLevels=%f, totalMipLevels=%llu, countMipLevels=%u, minSamples=%u, maxSamples=%u, avgSamples=%f, totalSamples=%llu, countSamples=%u, minArrayLength=%u, maxArrayLength=%u, avgArrayLength=%f, totalArrayLength=%llu, countArrayLength=%u, minBytesPerRow=%u, maxBytesPerRow=%u, avgBytesPerRow=%f, totalBytesPerRow=%llu, countBytesPerRow=%u, frameBufferCount=%u, renderTargetCount=%u, shaderWriteCount=%u, linearAlignLess64Count=%u", v75, v8, v73, v7, *(v3 - 56), *(v3 - 52), v12, v10, v9, *(v3 - 32), *(v3 - 28), v11, v14, v13, *(v3 - 8), *(v3 - 4), v17, v18, v15, *(v3 + 16), *(v3 + 20), v16, v20, v19, *(v3 + 40), *(v3 + 44), v23, v24, v21, *(v3 + 64), *(v3 + 68), v22, v26, v25, *(v3 + 88), *(v3 + 92), v29, v28, v27, *(v3 - 76), *(v3 - 68), *(v3 - 72), *(v3 - 64));
          i = v78;
        }

        v30 = [a1 telemetryLog];
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          v76 = off_2787B3F40[v79];
          v74 = MTLTelemetryStringifyTextureType(v4);
          v31 = *(v3 - 40);
          v32 = *(v3 - 48);
          v33 = 0.0;
          v34 = 0.0;
          if (v31)
          {
            v34 = (v32 / v31);
          }

          v66 = *(v3 - 80);
          v67 = *(v3 - 56);
          v68 = *(v3 - 52);
          v71 = *(v3 - 32);
          v72 = *(v3 - 28);
          v35 = *(v3 - 16);
          v36 = *(v3 - 24);
          if (v35)
          {
            v33 = (v36 / v35);
          }

          v69 = *(v3 - 8);
          v70 = *(v3 - 4);
          v37 = *(v3 + 8);
          v38 = 0.0;
          v39 = 0.0;
          v40 = *v3;
          if (v37)
          {
            v39 = (v40 / v37);
          }

          v64 = *(v3 + 16);
          v65 = *(v3 + 20);
          v41 = *(v3 + 32);
          v42 = *(v3 + 24);
          if (v41)
          {
            v38 = (v42 / v41);
          }

          v43 = *(v3 + 40);
          v63 = *(v3 + 44);
          v44 = *(v3 + 56);
          v45 = 0.0;
          v46 = 0.0;
          v47 = *(v3 + 48);
          if (v44)
          {
            v46 = (v47 / v44);
          }

          v48 = *(v3 + 64);
          v49 = *(v3 + 80);
          v50 = *(v3 + 72);
          if (v49)
          {
            v45 = (v50 / v49);
          }

          v51 = *(v3 + 88);
          v52 = *(v3 + 92);
          v53 = *(v3 + 104);
          v54 = *(v3 + 96);
          if (v53)
          {
            v55 = (v54 / v53);
          }

          else
          {
            v55 = 0.0;
          }

          v57 = *(v3 - 76);
          v56 = *(v3 - 72);
          v59 = *(v3 - 68);
          v58 = *(v3 - 64);
          v167 = *(v3 + 68);
          v81 = v76;
          v83 = v8;
          v85 = v74;
          v87 = v66;
          v89 = v67;
          v91 = v68;
          v95 = v32;
          v97 = v31;
          v99 = v71;
          v101 = v72;
          v105 = v36;
          v107 = v35;
          v109 = v69;
          v111 = v70;
          v115 = v40;
          v117 = v37;
          v119 = v64;
          v121 = v65;
          v125 = v42;
          v127 = v41;
          v129 = v43;
          v131 = v63;
          v135 = v47;
          v137 = v44;
          v139 = v48;
          v141 = v167;
          v145 = v50;
          v147 = v49;
          v149 = v51;
          v151 = v52;
          v155 = v54;
          v157 = v53;
          v159 = v57;
          v161 = v59;
          v163 = v56;
          v165 = v58;
          *buf = 136325890;
          v82 = 2080;
          v84 = 2080;
          v86 = 1024;
          v88 = 1024;
          v90 = 1024;
          v92 = 2048;
          v93 = v34;
          v94 = 2048;
          v96 = 1024;
          v98 = 1024;
          v100 = 1024;
          v102 = 2048;
          v103 = v33;
          v104 = 2048;
          v106 = 1024;
          v108 = 1024;
          v110 = 1024;
          v112 = 2048;
          v113 = v39;
          v114 = 2048;
          v116 = 1024;
          v118 = 1024;
          v120 = 1024;
          v122 = 2048;
          v123 = v38;
          v124 = 2048;
          v126 = 1024;
          v128 = 1024;
          v130 = 1024;
          v132 = 2048;
          v133 = v46;
          v134 = 2048;
          v136 = 1024;
          v138 = 1024;
          v140 = 1024;
          v142 = 2048;
          v143 = v45;
          v144 = 2048;
          v146 = 1024;
          v148 = 1024;
          v150 = 1024;
          v152 = 2048;
          v153 = v55;
          v154 = 2048;
          v156 = 1024;
          v158 = 1024;
          v160 = 1024;
          v162 = 1024;
          v164 = 1024;
          _os_log_impl(&dword_22E0FF000, v30, OS_LOG_TYPE_DEFAULT, "Texture, category=%s, format=%s, type=%s, total=%u, minWidth=%u, maxWidth=%u, avgWidth=%f, totalWidth=%llu, countWidth=%u, minHeight=%u, maxHeight=%u, avgHeight=%f, totalHeight=%llu, countHeight=%u, minDepth=%u, maxDepth=%u, avgDepth=%f, totalDepth=%llu, countDepth=%u, minMipLevels=%u, maxMipLevels=%u, avgMipLevels=%f, totalMipLevels=%llu, countMipLevels=%u, minSamples=%u, maxSamples=%u, avgSamples=%f, totalSamples=%llu, countSamples=%u, minArrayLength=%u, maxArrayLength=%u, avgArrayLength=%f, totalArrayLength=%llu, countArrayLength=%u, minBytesPerRow=%u, maxBytesPerRow=%u, avgBytesPerRow=%f, totalBytesPerRow=%llu, countBytesPerRow=%u, frameBufferCount=%u, renderTargetCount=%u, shaderWriteCount=%u, linearAlignLess64Count=%u", buf, 0x148u);
          i = v78;
        }

LABEL_40:
        ++v4;
        v3 += 192;
      }

      while (v4 != MTLTextureType2DMultisampleArray);
      v3 = v62 + 1536;
      ++v79;
    }

    while (v79 != 4);
  }

  v60 = *MEMORY[0x277D85DE8];
}

void *std::__hash_table<std::__hash_value_type<MTLPixelFormat,MTLTelemetryTextureDistribution>,std::__unordered_map_hasher<MTLPixelFormat,std::__hash_value_type<MTLPixelFormat,MTLTelemetryTextureDistribution>,std::hash<unsigned long long>,std::equal_to<MTLPixelFormat>,true>,std::__unordered_map_equal<MTLPixelFormat,std::__hash_value_type<MTLPixelFormat,MTLTelemetryTextureDistribution>,std::equal_to<MTLPixelFormat>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<MTLPixelFormat,MTLTelemetryTextureDistribution>>>::__emplace_unique_key_args<MTLPixelFormat,std::piecewise_construct_t const&,std::tuple<MTLPixelFormat const&>,std::tuple<>>(void *a1, unint64_t *a2)
{
  v2 = *a2;
  v3 = a1[1];
  if (!*&v3)
  {
    goto LABEL_18;
  }

  v4 = vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v2 >= *&v3)
    {
      v5 = v2 % *&v3;
    }
  }

  else
  {
    v5 = (*&v3 - 1) & v2;
  }

  v6 = *(*a1 + 8 * v5);
  if (!v6 || (v7 = *v6) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v8 = v7[1];
    if (v8 == v2)
    {
      break;
    }

    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *&v3)
      {
        v8 %= *&v3;
      }
    }

    else
    {
      v8 &= *&v3 - 1;
    }

    if (v8 != v5)
    {
      goto LABEL_18;
    }

LABEL_17:
    v7 = *v7;
    if (!v7)
    {
      goto LABEL_18;
    }
  }

  if (v7[2] != v2)
  {
    goto LABEL_17;
  }

  return v7;
}

void *BinaryBuffer::Append<NSString *>(AppendBuffer *a1, char a2, id *a3)
{
  v31 = *MEMORY[0x277D85DE8];
  v24 = a2;
  v30 = &v29;
  v27[0] = 1;
  v27[1] = a2;
  v29 = v28;
  v5 = *a3;
  v6 = [*a3 lengthOfBytesUsingEncoding:4];
  v7 = v6;
  v8 = v29;
  v9 = (v29 + 1);
  v10 = v30;
  if (v29 + 1 <= v30)
  {
    *v29 = 116;
    v10 = v30;
  }

  v11 = v8 + 9;
  if (v11 <= v10)
  {
    *v9 = v6;
  }

  v29 = v11;
  v12 = [v5 UTF8String];
  v13 = &v29[v7];
  v14 = v30;
  if (&v29[v7] <= v30)
  {
    memcpy(v29, v12, v7);
    v14 = v30;
  }

  v15 = v13 + 1;
  if ((v13 + 1) <= v14)
  {
    *v13 = 16;
    v14 = v30;
  }

  v29 = v13 + 1;
  if (v15 <= v14)
  {
    v21 = v15 - v27;
    p_stream = &a1->stream;
    p_src = v27;
    v20 = a1;
  }

  else
  {
    LOBYTE(__src) = 1;
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &v24, 1uLL);
    v16 = *a3;
    __src = [v16 lengthOfBytesUsingEncoding:4];
    v26 = 116;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v26, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    v17 = [v16 UTF8String];
    AppendBuffer::WriteBytes(a1, &a1->stream, v17, __src);
    LOBYTE(__src) = 16;
    p_stream = &a1->stream;
    p_src = &__src;
    v20 = a1;
    v21 = 1;
  }

  result = AppendBuffer::WriteBytes(v20, p_stream, p_src, v21);
  v23 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long,unsigned long,MTLSize,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11)
{
  v51[2] = *MEMORY[0x277D85DE8];
  v51[1] = v51;
  __src[0] = 1;
  __src[1] = a2;
  v11 = *a3;
  __src[2] = 109;
  v24 = v11;
  v12 = *a4;
  v25 = 100;
  v26 = v12;
  v13 = *a5;
  v27 = 100;
  v28 = v13;
  v14 = *a6;
  v29 = 100;
  v30 = v14;
  v31 = 25664;
  v15 = a7[1];
  v32 = *a7;
  v33 = 100;
  v34 = v15;
  v16 = a7[2];
  v35 = 100;
  v36 = v16;
  v37 = 27984;
  v38 = *a8;
  v17 = *a9;
  v39 = 100;
  v40 = v17;
  v18 = *a10;
  v41 = 100;
  v42 = v18;
  v43 = 25664;
  v19 = a11[1];
  v44 = *a11;
  v45 = 100;
  v46 = v19;
  v20 = a11[2];
  v47 = 100;
  v48 = v20;
  v49 = 4176;
  v51[0] = &v50;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x7CuLL);
  v22 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long,unsigned long,MTLSize,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,unsigned long>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12)
{
  v45 = *MEMORY[0x277D85DE8];
  v31 = a2;
  v44 = &v43;
  v34[0] = 1;
  v34[1] = a2;
  v17 = *a3;
  v34[2] = 109;
  v35 = v17;
  v18 = *a4;
  v36 = 100;
  v37 = v18;
  v19 = *a5;
  v38 = 100;
  v39 = v19;
  v20 = *a6;
  v40 = 100;
  v41 = v20;
  v43 = &v42;
  BinaryBuffer::WriteArguments<BinaryBuffer::ScratchBuffer,MTLSize,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,unsigned long>(a1, v34, a7, a8, a9, a10, a11, a12);
  v21 = (v43 + 1);
  v22 = v44;
  if (v43 + 1 <= v44)
  {
    *v43 = 16;
    v22 = v44;
  }

  v43 = v21;
  if (v21 <= v22)
  {
    v26 = v21 - v34;
    p_stream = &a1->stream;
    p_src = v34;
    v25 = a1;
  }

  else
  {
    LOBYTE(__src) = 1;
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &v31, 1uLL);
    __src = *a3;
    v33 = 109;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v33, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = *a4;
    v33 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v33, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = *a5;
    v33 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v33, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = *a6;
    v33 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v33, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,MTLSize,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,unsigned long>(a1, &a1->stream, a7, a8, a9, a10, a11, a12);
    LOBYTE(__src) = 16;
    p_stream = &a1->stream;
    p_src = &__src;
    v25 = a1;
    v26 = 1;
  }

  result = AppendBuffer::WriteBytes(v25, p_stream, p_src, v26);
  v28 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,MTLSize,objc_object  {objcproto10MTLTexture},unsigned long,unsigned long,objc_object  {objcproto10MTLTexture}*>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11)
{
  v56[2] = *MEMORY[0x277D85DE8];
  v56[1] = v56;
  __src[0] = 1;
  __src[1] = a2;
  v11 = *a3;
  __src[2] = 109;
  v25 = v11;
  v12 = *a4;
  v26 = 100;
  v27 = v12;
  v13 = *a5;
  v28 = 100;
  v29 = v13;
  v30 = 25664;
  v14 = a6[1];
  v31 = *a6;
  v32 = 100;
  v33 = v14;
  v15 = a6[2];
  v34 = 100;
  v35 = v15;
  qmemcpy(v36, "P@d", sizeof(v36));
  v16 = a7[1];
  v37 = *a7;
  v38 = 100;
  v39 = v16;
  v17 = a7[2];
  v40 = 100;
  v41 = v17;
  v42 = 27984;
  v43 = *a8;
  v18 = *a9;
  v44 = 100;
  v45 = v18;
  v19 = *a10;
  v46 = 100;
  v47 = v19;
  v48 = 25664;
  v20 = a11[1];
  v49 = *a11;
  v50 = 100;
  v51 = v20;
  v21 = a11[2];
  v52 = 100;
  v53 = v21;
  v54 = 4176;
  v56[0] = &v55;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x90uLL);
  v23 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,MTLSize,objc_object  {objcproto10MTLTexture},unsigned long,unsigned long,objc_object  {objcproto10MTLTexture}*,unsigned long>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12)
{
  v49 = *MEMORY[0x277D85DE8];
  v30 = a2;
  v48 = &v47;
  v33[0] = 1;
  v33[1] = a2;
  v17 = *a3;
  v33[2] = 109;
  v34 = v17;
  v36 = *a4;
  v38 = *a5;
  v39 = 25664;
  v18 = a6[1];
  v40 = *a6;
  v35 = 100;
  v37 = 100;
  v41 = 100;
  v42 = v18;
  v19 = a6[2];
  v43 = 100;
  v44 = v19;
  v45 = 80;
  v47 = v46;
  BinaryBuffer::WriteArguments<BinaryBuffer::ScratchBuffer,MTLSize,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,unsigned long>(a1, v33, a7, a8, a9, a10, a11, a12);
  v20 = v47 + 1;
  v21 = v48;
  if (v47 + 1 <= v48)
  {
    *v47 = 16;
    v21 = v48;
  }

  v47 = v20;
  if (v20 <= v21)
  {
    v25 = v20 - v33;
    p_stream = &a1->stream;
    p_src = v33;
    v24 = a1;
  }

  else
  {
    LOBYTE(__src) = 1;
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &v30, 1uLL);
    __src = *a3;
    v32 = 109;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v32, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = *a4;
    v32 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v32, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = *a5;
    v32 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v32, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    LOBYTE(__src) = 64;
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 1uLL);
    __src = *a6;
    v32 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v32, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = a6[1];
    v32 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v32, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = a6[2];
    v32 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v32, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    LOBYTE(__src) = 80;
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 1uLL);
    BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,MTLSize,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,unsigned long>(a1, &a1->stream, a7, a8, a9, a10, a11, a12);
    LOBYTE(__src) = 16;
    p_stream = &a1->stream;
    p_src = &__src;
    v24 = a1;
    v25 = 1;
  }

  result = AppendBuffer::WriteBytes(v24, p_stream, p_src, v25);
  v27 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,MTLSize,objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long,unsigned long>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11)
{
  v33 = *MEMORY[0x277D85DE8];
  v26 = a2;
  v32 = &v31;
  v29[0] = 1;
  v29[1] = a2;
  v31 = v30;
  BinaryBuffer::WriteArguments<BinaryBuffer::ScratchBuffer,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,MTLSize,objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long,unsigned long>(a1, v29, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  v18 = v31 + 1;
  v19 = v32;
  if (v31 + 1 <= v32)
  {
    *v31 = 16;
    v19 = v32;
  }

  v31 = v18;
  if (v18 <= v19)
  {
    v23 = v18 - v29;
    p_stream = &a1->stream;
    p_src = v29;
    v22 = a1;
  }

  else
  {
    LOBYTE(__src) = 1;
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &v26, 1uLL);
    __src = *a3;
    v28 = 109;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = *a4;
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = *a5;
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    LOBYTE(__src) = 64;
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 1uLL);
    __src = *a6;
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = a6[1];
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = a6[2];
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    LOBYTE(__src) = 80;
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 1uLL);
    LOBYTE(__src) = 64;
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 1uLL);
    __src = *a7;
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = a7[1];
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = a7[2];
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    LOBYTE(__src) = 80;
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 1uLL);
    __src = *a8;
    v28 = 109;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = *a9;
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = *a10;
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    __src = *a11;
    v28 = 100;
    AppendBuffer::WriteBytes(a1, &a1->stream, &v28, 1uLL);
    AppendBuffer::WriteBytes(a1, &a1->stream, &__src, 8uLL);
    LOBYTE(__src) = 16;
    p_stream = &a1->stream;
    p_src = &__src;
    v22 = a1;
    v23 = 1;
  }

  result = AppendBuffer::WriteBytes(v22, p_stream, p_src, v23);
  v25 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,MTLSize,objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long,unsigned long,unsigned long>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12)
{
  v55[2] = *MEMORY[0x277D85DE8];
  v55[1] = v55;
  __src[0] = 1;
  __src[1] = a2;
  v12 = *a3;
  __src[2] = 109;
  v26 = v12;
  v13 = *a4;
  v27 = 100;
  v28 = v13;
  v14 = *a5;
  v29 = 100;
  v30 = v14;
  v31 = 25664;
  v15 = a6[1];
  v32 = *a6;
  v33 = 100;
  v34 = v15;
  v16 = a6[2];
  v35 = 100;
  v36 = v16;
  qmemcpy(v37, "P@d", sizeof(v37));
  v17 = a7[1];
  v38 = *a7;
  v39 = 100;
  v40 = v17;
  v18 = a7[2];
  v41 = 100;
  v42 = v18;
  v43 = 27984;
  v44 = *a8;
  v19 = *a9;
  v45 = 100;
  v46 = v19;
  v20 = *a10;
  v47 = 100;
  v48 = v20;
  v21 = *a11;
  v49 = 100;
  v50 = v21;
  v22 = *a12;
  v51 = 100;
  v52 = v22;
  v53 = 16;
  v55[0] = v54;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x85uLL);
  v24 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto9MTLBuffer}*,_NSRange,unsigned char>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, char *a5)
{
  v19[2] = *MEMORY[0x277D85DE8];
  v19[1] = v19;
  __src[0] = 1;
  __src[1] = a2;
  v5 = *a3;
  __src[2] = 109;
  v10 = v5;
  v11 = 25664;
  v6 = a4[1];
  v12 = *a4;
  v13 = 100;
  v14 = v6;
  v15 = 24912;
  v16 = *a5;
  v17 = 16;
  v19[0] = v18;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x22uLL);
  v8 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto9MTLBuffer}*,_NSRange,unsigned int>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, int *a5)
{
  v19[2] = *MEMORY[0x277D85DE8];
  v19[1] = v19;
  __src[0] = 1;
  __src[1] = a2;
  v5 = *a3;
  __src[2] = 109;
  v10 = v5;
  v11 = 25664;
  v6 = a4[1];
  v12 = *a4;
  v13 = 100;
  v14 = v6;
  v15 = 25424;
  v16 = *a5;
  v17 = 16;
  v19[0] = v18;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x25uLL);
  v8 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLRegion,void const*,unsigned long>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  v41[2] = *MEMORY[0x277D85DE8];
  v41[1] = v41;
  __src[0] = 1;
  __src[1] = a2;
  v8 = *a3;
  __src[2] = 109;
  v18 = v8;
  v9 = *a4;
  v19 = 100;
  v20 = v9;
  v10 = *a5;
  v21 = 100;
  v22 = v10;
  qmemcpy(v23, "@@d", sizeof(v23));
  v11 = a6[1];
  v24 = *a6;
  v25 = 100;
  v26 = v11;
  v27 = 100;
  v12 = a6[3];
  v28 = a6[2];
  qmemcpy(v29, "P@d", sizeof(v29));
  v30 = v12;
  v31 = 100;
  v13 = a6[5];
  v32 = a6[4];
  v33 = 100;
  v34 = v13;
  qmemcpy(v35, "PPm", sizeof(v35));
  v36 = *a7;
  v14 = *a8;
  v37 = 100;
  v38 = v14;
  v39 = 16;
  v41[0] = &v40;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x6CuLL);
  v16 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLRegion,MTLClearColor>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v45[2] = *MEMORY[0x277D85DE8];
  v45[1] = v45;
  __src[0] = 1;
  __src[1] = a2;
  v7 = *a3;
  __src[2] = 109;
  v18 = v7;
  v8 = *a4;
  v19 = 100;
  v20 = v8;
  v9 = *a5;
  v21 = 100;
  v22 = v9;
  qmemcpy(v23, "@@d", sizeof(v23));
  v10 = a6[1];
  v24 = *a6;
  v25 = 100;
  v26 = v10;
  v27 = 100;
  v11 = a6[3];
  v28 = a6[2];
  qmemcpy(v29, "P@d", sizeof(v29));
  v30 = v11;
  v31 = 100;
  v12 = a6[5];
  v32 = a6[4];
  v33 = 100;
  v34 = v12;
  v35 = 1799376976;
  v13 = a7[1];
  v36 = *a7;
  v37 = 107;
  v38 = v13;
  v39 = 107;
  v14 = a7[3];
  v40 = a7[2];
  v41 = 107;
  v42 = v14;
  v43 = 4176;
  v45[0] = &v44;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x80uLL);
  v16 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLRegion,MTLClearColor,MTLPixelFormat>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  v48[2] = *MEMORY[0x277D85DE8];
  v48[1] = v48;
  __src[0] = 1;
  __src[1] = a2;
  v8 = *a3;
  __src[2] = 109;
  v19 = v8;
  v9 = *a4;
  v20 = 100;
  v21 = v9;
  v10 = *a5;
  v22 = 100;
  v23 = v10;
  qmemcpy(v24, "@@d", sizeof(v24));
  v11 = a6[1];
  v25 = *a6;
  v26 = 100;
  v27 = v11;
  v28 = 100;
  v12 = a6[3];
  v29 = a6[2];
  qmemcpy(v30, "P@d", sizeof(v30));
  v31 = v12;
  v32 = 100;
  v13 = a6[5];
  v33 = a6[4];
  v34 = 100;
  v35 = v13;
  v36 = 1799376976;
  v14 = a7[1];
  v37 = *a7;
  v38 = 107;
  v39 = v14;
  v40 = 107;
  v15 = a7[3];
  v41 = a7[2];
  v42 = 107;
  v43 = v15;
  v44 = 25680;
  v45 = *a8;
  v46 = 16;
  v48[0] = v47;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x89uLL);
  v17 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,objc_object  {objcproto10MTLTexture},unsigned long,unsigned long,unsigned long,unsigned long>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10)
{
  v38[2] = *MEMORY[0x277D85DE8];
  v38[1] = v38;
  __src[0] = 1;
  __src[1] = a2;
  v10 = *a3;
  __src[2] = 109;
  v21 = v10;
  v11 = *a4;
  v22 = 100;
  v23 = v11;
  v12 = *a5;
  v24 = 100;
  v25 = v12;
  v13 = *a6;
  v26 = 109;
  v27 = v13;
  v14 = *a7;
  v28 = 100;
  v29 = v14;
  v15 = *a8;
  v30 = 100;
  v31 = v15;
  v16 = *a9;
  v32 = 100;
  v33 = v16;
  v17 = *a10;
  v34 = 100;
  v35 = v17;
  v36 = 16;
  v38[0] = v37;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x4BuLL);
  v19 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLRegion,unsigned long,unsigned long,BOOL,objc_object  {objcproto9MTLBuffer}*,unsigned long>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, _BYTE *a6, uint64_t *a7, uint64_t *a8)
{
  v41[2] = *MEMORY[0x277D85DE8];
  v41[1] = v41;
  __src[0] = 1;
  __src[1] = a2;
  qmemcpy(v17, "@@d", sizeof(v17));
  v8 = a3[1];
  v18 = *a3;
  v20 = v8;
  v9 = a3[3];
  v22 = a3[2];
  qmemcpy(v23, "P@d", sizeof(v23));
  v19 = 100;
  v21 = 100;
  v24 = v9;
  v25 = 100;
  v10 = a3[5];
  v26 = a3[4];
  v27 = 100;
  v28 = v10;
  qmemcpy(v29, "PPd", sizeof(v29));
  v30 = *a4;
  v11 = *a5;
  v31 = 100;
  v32 = v11;
  LOBYTE(v11) = *a6;
  v33 = 97;
  v34 = v11;
  v12 = *a7;
  v35 = 109;
  v36 = v12;
  v13 = *a8;
  v37 = 100;
  v38 = v13;
  v39 = 16;
  v41[0] = v40;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x65uLL);
  v15 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLSize,MTLSize>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  v28[2] = *MEMORY[0x277D85DE8];
  v28[1] = v28;
  __src[0] = 1;
  __src[1] = a2;
  v12 = 25664;
  v5 = a4[1];
  v13 = *a4;
  v14 = 100;
  v15 = v5;
  v6 = a4[2];
  v16 = 100;
  v17 = v6;
  qmemcpy(v18, "P@d", sizeof(v18));
  v7 = a5[1];
  v19 = *a5;
  v20 = 100;
  v21 = v7;
  v8 = a5[2];
  v22 = 100;
  v23 = v8;
  v24 = -27568;
  v25 = *(a1 + 32) * a3 / *(a1 + 36);
  v26 = 16;
  v28[0] = &v27;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x46uLL);
  v10 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto9MTLBuffer}*,unsigned long,MTLSize>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v29[2] = *MEMORY[0x277D85DE8];
  v29[1] = v29;
  __src[0] = 1;
  __src[1] = a2;
  v6 = *a4;
  __src[2] = 109;
  v15 = v6;
  v7 = *a5;
  v16 = 100;
  v17 = v7;
  v18 = 25664;
  v8 = a6[1];
  v19 = *a6;
  v20 = 100;
  v21 = v8;
  v9 = a6[2];
  v22 = 100;
  v23 = v9;
  v24 = 80;
  v10 = *(a1 + 32);
  v11 = *(a1 + 36);
  v25 = -108;
  v26 = v10 * a3 / v11;
  v27 = 16;
  v29[0] = v28;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x3BuLL);
  v13 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto9MTLBuffer}*,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  v19[2] = *MEMORY[0x277D85DE8];
  v19[1] = v19;
  __src[0] = 1;
  __src[1] = a2;
  v5 = *a4;
  __src[2] = 109;
  v12 = v5;
  v6 = *a5;
  v13 = 100;
  v14 = v6;
  v7 = *(a1 + 32);
  v8 = *(a1 + 36);
  v15 = -108;
  v16 = v7 * a3 / v8;
  v17 = 16;
  v19[0] = &v18;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x1EuLL);
  v10 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[2] = *MEMORY[0x277D85DE8];
  v23[1] = v23;
  __src[0] = 1;
  __src[1] = a2;
  v6 = *a4;
  __src[2] = 109;
  v14 = v6;
  v7 = *a5;
  v15 = 100;
  v16 = v7;
  v8 = *a6;
  v17 = 100;
  v18 = v8;
  v9 = *(a1 + 32);
  v10 = *(a1 + 36);
  v19 = -108;
  v20 = v9 * a3 / v10;
  v21 = 16;
  v23[0] = &v22;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x27uLL);
  v12 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<unsigned long,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  v19[2] = *MEMORY[0x277D85DE8];
  v19[1] = v19;
  __src[0] = 1;
  __src[1] = a2;
  v5 = *a4;
  __src[2] = 100;
  v12 = v5;
  v6 = *a5;
  v13 = 100;
  v14 = v6;
  v7 = *(a1 + 32);
  v8 = *(a1 + 36);
  v15 = -108;
  v16 = v7 * a3 / v8;
  v17 = 16;
  v19[0] = &v18;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x1EuLL);
  v10 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<BinaryBuffer::Array<objc_object  {objcproto9MTLBuffer}* const>,BinaryBuffer::Array<unsigned long const>,_NSRange>(AppendBuffer *this, char a2, uint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  v10 = this;
  v50 = *MEMORY[0x277D85DE8];
  v42 = a2;
  v11 = &v48;
  v49 = &v48;
  v45[0] = 1;
  v45[1] = a2;
  v12 = v46;
  v45[2] = 32;
  v48 = v46;
  v13 = *(a4 + 8);
  if (v13)
  {
    v14 = *a4;
    v15 = &v47;
    do
    {
      v16 = *v14;
      v17 = v49;
      if (v15 - 2 <= v49)
      {
        *(v15 - 9) = 109;
        v17 = v49;
      }

      if (v15 <= v17)
      {
        *(v15 - 1) = v16;
      }

      v48 = v15;
      v15 = (v15 + 9);
      ++v14;
      --v13;
    }

    while (v13);
    v11 = v49;
    v12 = v15 - 9;
  }

  if (v12 + 1 <= v11)
  {
    *v12 = 48;
    v11 = v49;
  }

  v48 = (v12 + 1);
  v18 = v12 + 2;
  if (v12 + 2 <= v11)
  {
    v12[1] = 32;
  }

  if (a5[1])
  {
    v19 = 0;
    v20 = (v12 + 11);
    do
    {
      v21 = *(*a5 + 8 * v19);
      v22 = v49;
      if (v20 - 2 <= v49)
      {
        *(v20 - 9) = 100;
        v22 = v49;
      }

      if (v20 <= v22)
      {
        *(v20 - 1) = v21;
      }

      ++v19;
      v20 = (v20 + 9);
    }

    while (a5[1] > v19);
    v18 = v20 - 9;
  }

  v23 = v49;
  if (v18 + 1 <= v49)
  {
    *v18 = 48;
    v23 = v49;
  }

  if ((v18 + 2) <= v23)
  {
    v18[1] = 64;
    v23 = v49;
  }

  v24 = *a6;
  if ((v18 + 3) <= v23)
  {
    v18[2] = 100;
    v23 = v49;
  }

  if ((v18 + 11) <= v23)
  {
    *(v18 + 3) = v24;
    v23 = v49;
  }

  v25 = a6[1];
  if ((v18 + 12) <= v23)
  {
    v18[11] = 100;
    v23 = v49;
  }

  if ((v18 + 20) <= v23)
  {
    *(v18 + 12) = v25;
    v23 = v49;
  }

  if ((v18 + 21) <= v23)
  {
    v18[20] = 80;
    v23 = v49;
  }

  v27 = LODWORD(this[1]._vptr$AppendBuffer);
  v26 = HIDWORD(this[1]._vptr$AppendBuffer);
  if ((v18 + 22) <= v23)
  {
    v18[21] = -108;
    v23 = v49;
  }

  v28 = v18 + 30;
  if ((v18 + 30) <= v23)
  {
    *(v18 + 22) = v27 * a3 / v26;
    v23 = v49;
  }

  v29 = (v18 + 31);
  if (v29 <= v23)
  {
    *v28 = 16;
    v23 = v49;
  }

  v48 = v29;
  if (v29 <= v23)
  {
    v39 = v29 - v45;
    p_stream = &this->stream;
    p_src = v45;
  }

  else
  {
    LOBYTE(__src) = 1;
    AppendBuffer::WriteBytes(this, &this->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(v10, &v10->stream, &v42, 1uLL);
    LOBYTE(__src) = 32;
    AppendBuffer::WriteBytes(v10, &v10->stream, &__src, 1uLL);
    if (*(a4 + 8))
    {
      v30 = 0;
      do
      {
        __src = *(*a4 + 8 * v30);
        v44 = 109;
        AppendBuffer::WriteBytes(v10, &v10->stream, &v44, 1uLL);
        AppendBuffer::WriteBytes(v10, &v10->stream, &__src, 8uLL);
        ++v30;
      }

      while (*(a4 + 8) > v30);
    }

    LOBYTE(__src) = 48;
    AppendBuffer::WriteBytes(v10, &v10->stream, &__src, 1uLL);
    BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<unsigned long const>,_NSRange>(v10, &v10->stream, a5, a6);
    v32 = LODWORD(v10[1]._vptr$AppendBuffer);
    v31 = HIDWORD(v10[1]._vptr$AppendBuffer);
    v33 = v48;
    v34 = (v48 + 1);
    v35 = v49;
    if ((v48 + 1) <= v49)
    {
      *v48 = -108;
      v35 = v49;
    }

    v36 = (v33 + 9);
    if (v36 <= v35)
    {
      *v34 = v32 * a3 / v31;
    }

    v48 = v36;
    LOBYTE(__src) = 16;
    p_stream = &v10->stream;
    p_src = &__src;
    this = v10;
    v39 = 1;
  }

  result = AppendBuffer::WriteBytes(this, p_stream, p_src, v39);
  v41 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto15MTLSamplerState}*,float,float,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, int *a5, int *a6, uint64_t *a7)
{
  v27[2] = *MEMORY[0x277D85DE8];
  v27[1] = v27;
  __src[0] = 1;
  __src[1] = a2;
  v7 = *a4;
  __src[2] = 109;
  v16 = v7;
  v8 = *a5;
  v17 = 106;
  v18 = v8;
  v9 = *a6;
  v19 = 106;
  v20 = v9;
  v10 = *a7;
  v21 = 100;
  v22 = v10;
  v11 = *(a1 + 32);
  v12 = *(a1 + 36);
  v23 = -108;
  v24 = v11 * a3 / v12;
  v25 = 16;
  v27[0] = &v26;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x28uLL);
  v14 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<BinaryBuffer::Array<objc_object  {objcproto15MTLSamplerState}* const>,_NSRange>(AppendBuffer *this, char a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  v8 = this;
  v42 = *MEMORY[0x277D85DE8];
  v34 = a2;
  v9 = &v40;
  v41 = &v40;
  v37[0] = 1;
  v37[1] = a2;
  v10 = v38;
  v37[2] = 32;
  v40 = v38;
  v11 = *(a4 + 8);
  if (v11)
  {
    v12 = *a4;
    v13 = &v39;
    do
    {
      v14 = *v12;
      v15 = v41;
      if (v13 - 2 <= v41)
      {
        *(v13 - 9) = 109;
        v15 = v41;
      }

      if (v13 <= v15)
      {
        *(v13 - 1) = v14;
      }

      v40 = v13;
      v13 = (v13 + 9);
      ++v12;
      --v11;
    }

    while (v11);
    v9 = v41;
    v10 = v13 - 9;
  }

  if (v10 + 1 <= v9)
  {
    *v10 = 48;
    v9 = v41;
  }

  if (v10 + 2 <= v9)
  {
    v10[1] = 64;
    v9 = v41;
  }

  v16 = *a5;
  if (v10 + 3 <= v9)
  {
    v10[2] = 100;
    v9 = v41;
  }

  if (v10 + 11 <= v9)
  {
    *(v10 + 3) = v16;
    v9 = v41;
  }

  v17 = a5[1];
  if (v10 + 12 <= v9)
  {
    v10[11] = 100;
    v9 = v41;
  }

  if (v10 + 20 <= v9)
  {
    *(v10 + 12) = v17;
    v9 = v41;
  }

  if (v10 + 21 <= v9)
  {
    v10[20] = 80;
    v9 = v41;
  }

  v19 = LODWORD(this[1]._vptr$AppendBuffer);
  v18 = HIDWORD(this[1]._vptr$AppendBuffer);
  if (v10 + 22 <= v9)
  {
    v10[21] = -108;
    v9 = v41;
  }

  v20 = v10 + 30;
  if (v10 + 30 <= v9)
  {
    *(v10 + 22) = v19 * a3 / v18;
    v9 = v41;
  }

  v21 = (v10 + 31);
  if (v21 <= v9)
  {
    *v20 = 16;
    v9 = v41;
  }

  v40 = v21;
  if (v21 <= v9)
  {
    v31 = v21 - v37;
    p_stream = &this->stream;
    p_src = v37;
  }

  else
  {
    LOBYTE(__src) = 1;
    AppendBuffer::WriteBytes(this, &this->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(v8, &v8->stream, &v34, 1uLL);
    LOBYTE(__src) = 32;
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 1uLL);
    if (*(a4 + 8))
    {
      v22 = 0;
      do
      {
        __src = *(*a4 + 8 * v22);
        v36 = 109;
        AppendBuffer::WriteBytes(v8, &v8->stream, &v36, 1uLL);
        AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 8uLL);
        ++v22;
      }

      while (*(a4 + 8) > v22);
    }

    LOBYTE(__src) = 48;
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 1uLL);
    LOBYTE(__src) = 64;
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 1uLL);
    __src = *a5;
    v36 = 100;
    AppendBuffer::WriteBytes(v8, &v8->stream, &v36, 1uLL);
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 8uLL);
    __src = a5[1];
    v36 = 100;
    AppendBuffer::WriteBytes(v8, &v8->stream, &v36, 1uLL);
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 8uLL);
    LOBYTE(__src) = 80;
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 1uLL);
    v24 = LODWORD(v8[1]._vptr$AppendBuffer);
    v23 = HIDWORD(v8[1]._vptr$AppendBuffer);
    v25 = v40;
    v26 = (v40 + 1);
    v27 = v41;
    if ((v40 + 1) <= v41)
    {
      *v40 = -108;
      v27 = v41;
    }

    v28 = (v25 + 9);
    if (v28 <= v27)
    {
      *v26 = v24 * a3 / v23;
    }

    v40 = v28;
    LOBYTE(__src) = 16;
    p_stream = &v8->stream;
    p_src = &__src;
    this = v8;
    v31 = 1;
  }

  result = AppendBuffer::WriteBytes(this, p_stream, p_src, v31);
  v33 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<BinaryBuffer::Array<objc_object  {objcproto15MTLSamplerState}* const>,float const*,float const,_NSRange>(AppendBuffer *this, char a2, uint64_t a3, uint64_t **a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v12 = this;
  v46 = *MEMORY[0x277D85DE8];
  v39 = a2;
  v13 = &v44;
  v45 = &v44;
  v41[0] = 1;
  v41[1] = a2;
  v14 = v42;
  v41[2] = 32;
  v44 = v42;
  v15 = a4[1];
  if (v15)
  {
    v16 = *a4;
    v17 = &v43;
    do
    {
      v18 = *v16;
      v19 = v45;
      if (v17 - 2 <= v45)
      {
        *(v17 - 9) = 109;
        v19 = v45;
      }

      if (v17 <= v19)
      {
        *(v17 - 1) = v18;
      }

      v44 = v17;
      v17 = (v17 + 9);
      ++v16;
      v15 = (v15 - 1);
    }

    while (v15);
    v13 = v45;
    v14 = v17 - 9;
  }

  if (v14 + 1 <= v13)
  {
    *v14 = 48;
    v13 = v45;
  }

  v20 = *a5;
  if (v14 + 2 <= v13)
  {
    v14[1] = 109;
    v13 = v45;
  }

  if (v14 + 10 <= v13)
  {
    *(v14 + 2) = v20;
    v13 = v45;
  }

  v44 = (v14 + 10);
  v21 = *a6;
  if (v14 + 11 <= v13)
  {
    v14[10] = 109;
    v13 = v45;
  }

  if (v14 + 19 <= v13)
  {
    *(v14 + 11) = v21;
    v13 = v45;
  }

  if (v14 + 20 <= v13)
  {
    v14[19] = 64;
    v13 = v45;
  }

  v22 = *a7;
  if (v14 + 21 <= v13)
  {
    v14[20] = 100;
    v13 = v45;
  }

  if (v14 + 29 <= v13)
  {
    *(v14 + 21) = v22;
    v13 = v45;
  }

  v23 = a7[1];
  if (v14 + 30 <= v13)
  {
    v14[29] = 100;
    v13 = v45;
  }

  if (v14 + 38 <= v13)
  {
    *(v14 + 30) = v23;
    v13 = v45;
  }

  if (v14 + 39 <= v13)
  {
    v14[38] = 80;
    v13 = v45;
  }

  v25 = LODWORD(this[1]._vptr$AppendBuffer);
  v24 = HIDWORD(this[1]._vptr$AppendBuffer);
  if (v14 + 40 <= v13)
  {
    v14[39] = -108;
    v13 = v45;
  }

  v26 = v14 + 48;
  if (v14 + 48 <= v13)
  {
    *(v14 + 5) = v25 * a3 / v24;
    v13 = v45;
  }

  v27 = (v14 + 49);
  if (v27 <= v13)
  {
    *v26 = 16;
    v13 = v45;
  }

  v44 = v27;
  if (v27 <= v13)
  {
    v36 = v27 - v41;
    p_stream = &this->stream;
    p_src = v41;
  }

  else
  {
    __src = 1;
    AppendBuffer::WriteBytes(this, &this->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(v12, &v12->stream, &v39, 1uLL);
    BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<objc_object  {objcproto15MTLSamplerState}* const>,float const*,float const,_NSRange>(v12, &v12->stream, a4, a5, a6, a7);
    v29 = LODWORD(v12[1]._vptr$AppendBuffer);
    v28 = HIDWORD(v12[1]._vptr$AppendBuffer);
    v30 = v44;
    v31 = (v44 + 1);
    v32 = v45;
    if ((v44 + 1) <= v45)
    {
      *v44 = -108;
      v32 = v45;
    }

    v33 = (v30 + 9);
    if (v33 <= v32)
    {
      *v31 = v29 * a3 / v28;
    }

    v44 = v33;
    __src = 16;
    p_stream = &v12->stream;
    p_src = &__src;
    this = v12;
    v36 = 1;
  }

  result = AppendBuffer::WriteBytes(this, p_stream, p_src, v36);
  v38 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLRegion>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4)
{
  v29[2] = *MEMORY[0x277D85DE8];
  v29[1] = v29;
  __src[0] = 1;
  __src[1] = a2;
  qmemcpy(v12, "@@d", sizeof(v12));
  v4 = a4[1];
  v13 = *a4;
  v15 = v4;
  v5 = a4[3];
  v17 = a4[2];
  qmemcpy(v18, "P@d", sizeof(v18));
  v14 = 100;
  v16 = 100;
  v19 = v5;
  v20 = 100;
  v6 = a4[5];
  v21 = a4[4];
  v22 = 100;
  v23 = v6;
  v24 = 20560;
  v7 = *(a1 + 32);
  v8 = *(a1 + 36);
  v25 = -108;
  v26 = v7 * a3 / v8;
  v27 = 16;
  v29[0] = &v28;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x48uLL);
  v10 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<BinaryBuffer::Array<objc_object  {objcproto7MTLHeap}* const>,unsigned long>(AppendBuffer *this, char a2, uint64_t a3, uint64_t **a4, uint64_t *a5)
{
  v8 = this;
  v39 = *MEMORY[0x277D85DE8];
  v32 = a2;
  v9 = &v37;
  v38 = &v37;
  v34[0] = 1;
  v34[1] = a2;
  v10 = v35;
  v34[2] = 32;
  v37 = v35;
  v11 = a4[1];
  if (v11)
  {
    v12 = *a4;
    v13 = &v36;
    do
    {
      v14 = *v12;
      v15 = v38;
      if (v13 - 2 <= v38)
      {
        *(v13 - 9) = 109;
        v15 = v38;
      }

      if (v13 <= v15)
      {
        *(v13 - 1) = v14;
      }

      v37 = v13;
      v13 = (v13 + 9);
      ++v12;
      v11 = (v11 - 1);
    }

    while (v11);
    v9 = v38;
    v10 = v13 - 9;
  }

  if (v10 + 1 <= v9)
  {
    *v10 = 48;
    v9 = v38;
  }

  v16 = *a5;
  if (v10 + 2 <= v9)
  {
    v10[1] = 100;
    v9 = v38;
  }

  if (v10 + 10 <= v9)
  {
    *(v10 + 2) = v16;
    v9 = v38;
  }

  v18 = LODWORD(this[1]._vptr$AppendBuffer);
  v17 = HIDWORD(this[1]._vptr$AppendBuffer);
  if (v10 + 11 <= v9)
  {
    v10[10] = -108;
    v9 = v38;
  }

  v19 = v10 + 19;
  if (v10 + 19 <= v9)
  {
    *(v10 + 11) = v18 * a3 / v17;
    v9 = v38;
  }

  v20 = (v10 + 20);
  if (v20 <= v9)
  {
    *v19 = 16;
    v9 = v38;
  }

  v37 = v20;
  if (v20 <= v9)
  {
    v29 = v20 - v34;
    p_stream = &this->stream;
    p_src = v34;
  }

  else
  {
    __src = 1;
    AppendBuffer::WriteBytes(this, &this->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(v8, &v8->stream, &v32, 1uLL);
    BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<objc_object  {objcproto7MTLHeap}* const>,unsigned long>(v8, &v8->stream, a4, a5);
    v22 = LODWORD(v8[1]._vptr$AppendBuffer);
    v21 = HIDWORD(v8[1]._vptr$AppendBuffer);
    v23 = v37;
    v24 = (v37 + 1);
    v25 = v38;
    if ((v37 + 1) <= v38)
    {
      *v37 = -108;
      v25 = v38;
    }

    v26 = (v23 + 9);
    if (v26 <= v25)
    {
      *v24 = v22 * a3 / v21;
    }

    v37 = v26;
    __src = 16;
    p_stream = &v8->stream;
    p_src = &__src;
    this = v8;
    v29 = 1;
  }

  result = AppendBuffer::WriteBytes(this, p_stream, p_src, v29);
  v31 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<BinaryBuffer::Array<objc_object  {objcproto11MTLResource}* const>,unsigned long,unsigned long>(AppendBuffer *this, char a2, uint64_t a3, uint64_t **a4, uint64_t *a5, uint64_t *a6)
{
  v10 = this;
  v42 = *MEMORY[0x277D85DE8];
  v35 = a2;
  v11 = &v40;
  v41 = &v40;
  v37[0] = 1;
  v37[1] = a2;
  v12 = v38;
  v37[2] = 32;
  v40 = v38;
  v13 = a4[1];
  if (v13)
  {
    v14 = *a4;
    v15 = &v39;
    do
    {
      v16 = *v14;
      v17 = v41;
      if (v15 - 2 <= v41)
      {
        *(v15 - 9) = 109;
        v17 = v41;
      }

      if (v15 <= v17)
      {
        *(v15 - 1) = v16;
      }

      v40 = v15;
      v15 = (v15 + 9);
      ++v14;
      v13 = (v13 - 1);
    }

    while (v13);
    v11 = v41;
    v12 = v15 - 9;
  }

  if (v12 + 1 <= v11)
  {
    *v12 = 48;
    v11 = v41;
  }

  v18 = *a5;
  if (v12 + 2 <= v11)
  {
    v12[1] = 100;
    v11 = v41;
  }

  if (v12 + 10 <= v11)
  {
    *(v12 + 2) = v18;
    v11 = v41;
  }

  v19 = *a6;
  if (v12 + 11 <= v11)
  {
    v12[10] = 100;
    v11 = v41;
  }

  if (v12 + 19 <= v11)
  {
    *(v12 + 11) = v19;
    v11 = v41;
  }

  v21 = LODWORD(this[1]._vptr$AppendBuffer);
  v20 = HIDWORD(this[1]._vptr$AppendBuffer);
  if (v12 + 20 <= v11)
  {
    v12[19] = -108;
    v11 = v41;
  }

  v22 = v12 + 28;
  if (v12 + 28 <= v11)
  {
    *(v12 + 20) = v21 * a3 / v20;
    v11 = v41;
  }

  v23 = (v12 + 29);
  if (v23 <= v11)
  {
    *v22 = 16;
    v11 = v41;
  }

  v40 = v23;
  if (v23 <= v11)
  {
    v32 = v23 - v37;
    p_stream = &this->stream;
    p_src = v37;
  }

  else
  {
    __src = 1;
    AppendBuffer::WriteBytes(this, &this->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(v10, &v10->stream, &v35, 1uLL);
    BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<objc_object  {objcproto11MTLResource}* const>,unsigned long,unsigned long>(v10, &v10->stream, a4, a5, a6);
    v25 = LODWORD(v10[1]._vptr$AppendBuffer);
    v24 = HIDWORD(v10[1]._vptr$AppendBuffer);
    v26 = v40;
    v27 = (v40 + 1);
    v28 = v41;
    if ((v40 + 1) <= v41)
    {
      *v40 = -108;
      v28 = v41;
    }

    v29 = (v26 + 9);
    if (v29 <= v28)
    {
      *v27 = v25 * a3 / v24;
    }

    v40 = v29;
    __src = 16;
    p_stream = &v10->stream;
    p_src = &__src;
    this = v10;
    v32 = 1;
  }

  result = AppendBuffer::WriteBytes(this, p_stream, p_src, v32);
  v34 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLPrimitiveType,unsigned long,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[2] = *MEMORY[0x277D85DE8];
  v23[1] = v23;
  __src[0] = 1;
  __src[1] = a2;
  v6 = *a4;
  __src[2] = 100;
  v14 = v6;
  v7 = *a5;
  v15 = 100;
  v16 = v7;
  v8 = *a6;
  v17 = 100;
  v18 = v8;
  v9 = *(a1 + 32);
  v10 = *(a1 + 36);
  v19 = -108;
  v20 = v9 * a3 / v10;
  v21 = 16;
  v23[0] = &v22;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x27uLL);
  v12 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLPrimitiveType,unsigned long,unsigned long,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v27[2] = *MEMORY[0x277D85DE8];
  v27[1] = v27;
  __src[0] = 1;
  __src[1] = a2;
  v7 = *a4;
  __src[2] = 100;
  v16 = v7;
  v8 = *a5;
  v17 = 100;
  v18 = v8;
  v9 = *a6;
  v19 = 100;
  v20 = v9;
  v10 = *a7;
  v21 = 100;
  v22 = v10;
  v11 = *(a1 + 32);
  v12 = *(a1 + 36);
  v23 = -108;
  v24 = v11 * a3 / v12;
  v25 = 16;
  v27[0] = &v26;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x30uLL);
  v14 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLPrimitiveType,unsigned long,unsigned long,unsigned long,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  v31[2] = *MEMORY[0x277D85DE8];
  v31[1] = v31;
  __src[0] = 1;
  __src[1] = a2;
  v8 = *a4;
  __src[2] = 100;
  v18 = v8;
  v9 = *a5;
  v19 = 100;
  v20 = v9;
  v10 = *a6;
  v21 = 100;
  v22 = v10;
  v11 = *a7;
  v23 = 100;
  v24 = v11;
  v12 = *a8;
  v25 = 100;
  v26 = v12;
  v13 = *(a1 + 32);
  v14 = *(a1 + 36);
  v27 = -108;
  v28 = v13 * a3 / v14;
  v29 = 16;
  v31[0] = v30;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x39uLL);
  v16 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLPrimitiveType,objc_object  {objcproto9MTLBuffer}*,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[2] = *MEMORY[0x277D85DE8];
  v23[1] = v23;
  __src[0] = 1;
  __src[1] = a2;
  v6 = *a4;
  __src[2] = 100;
  v14 = v6;
  v7 = *a5;
  v15 = 109;
  v16 = v7;
  v8 = *a6;
  v17 = 100;
  v18 = v8;
  v9 = *(a1 + 32);
  v10 = *(a1 + 36);
  v19 = -108;
  v20 = v9 * a3 / v10;
  v21 = 16;
  v23[0] = &v22;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x27uLL);
  v12 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLPrimitiveType,unsigned long,MTLIndexType,objc_object  {objcproto9MTLBuffer}*,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  v31[2] = *MEMORY[0x277D85DE8];
  v31[1] = v31;
  __src[0] = 1;
  __src[1] = a2;
  v8 = *a4;
  __src[2] = 100;
  v18 = v8;
  v9 = *a5;
  v19 = 100;
  v20 = v9;
  v10 = *a6;
  v21 = 100;
  v22 = v10;
  v11 = *a7;
  v23 = 109;
  v24 = v11;
  v12 = *a8;
  v25 = 100;
  v26 = v12;
  v13 = *(a1 + 32);
  v14 = *(a1 + 36);
  v27 = -108;
  v28 = v13 * a3 / v14;
  v29 = 16;
  v31[0] = v30;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x39uLL);
  v16 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLPrimitiveType,unsigned long,MTLIndexType,objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9)
{
  v35[2] = *MEMORY[0x277D85DE8];
  v35[1] = v35;
  __src[0] = 1;
  __src[1] = a2;
  v9 = *a4;
  __src[2] = 100;
  v20 = v9;
  v10 = *a5;
  v21 = 100;
  v22 = v10;
  v11 = *a6;
  v23 = 100;
  v24 = v11;
  v12 = *a7;
  v25 = 109;
  v26 = v12;
  v13 = *a8;
  v27 = 100;
  v28 = v13;
  v14 = *a9;
  v29 = 100;
  v30 = v14;
  v15 = *(a1 + 32);
  v16 = *(a1 + 36);
  v31 = -108;
  v32 = v15 * a3 / v16;
  v33 = 16;
  v35[0] = v34;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x42uLL);
  v18 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLPrimitiveType,unsigned long,MTLIndexType,objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long,unsigned long,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11)
{
  v43[2] = *MEMORY[0x277D85DE8];
  v43[1] = v43;
  __src[0] = 1;
  __src[1] = a2;
  v11 = *a4;
  __src[2] = 100;
  v24 = v11;
  v12 = *a5;
  v25 = 100;
  v26 = v12;
  v13 = *a6;
  v27 = 100;
  v28 = v13;
  v14 = *a7;
  v29 = 109;
  v30 = v14;
  v15 = *a8;
  v31 = 100;
  v32 = v15;
  v16 = *a9;
  v33 = 100;
  v34 = v16;
  v17 = *a10;
  v35 = 100;
  v36 = v17;
  v18 = *a11;
  v37 = 100;
  v38 = v18;
  v19 = *(a1 + 32);
  v20 = *(a1 + 36);
  v39 = -108;
  v40 = v19 * a3 / v20;
  v41 = 16;
  v43[0] = &v42;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x54uLL);
  v22 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLPrimitiveType,MTLIndexType,objc_object  {objcproto9MTLBuffer}*,unsigned long,objc_object  {objcproto9MTLBuffer},unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9)
{
  v35[2] = *MEMORY[0x277D85DE8];
  v35[1] = v35;
  __src[0] = 1;
  __src[1] = a2;
  v9 = *a4;
  __src[2] = 100;
  v20 = v9;
  v10 = *a5;
  v21 = 100;
  v22 = v10;
  v11 = *a6;
  v23 = 109;
  v24 = v11;
  v12 = *a7;
  v25 = 100;
  v26 = v12;
  v13 = *a8;
  v27 = 109;
  v28 = v13;
  v14 = *a9;
  v29 = 100;
  v30 = v14;
  v15 = *(a1 + 32);
  v16 = *(a1 + 36);
  v31 = -108;
  v32 = v15 * a3 / v16;
  v33 = 16;
  v35[0] = v34;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x42uLL);
  v18 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<unsigned long,unsigned long,unsigned long,objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10)
{
  v39[2] = *MEMORY[0x277D85DE8];
  v39[1] = v39;
  __src[0] = 1;
  __src[1] = a2;
  v10 = *a4;
  __src[2] = 100;
  v22 = v10;
  v11 = *a5;
  v23 = 100;
  v24 = v11;
  v12 = *a6;
  v25 = 100;
  v26 = v12;
  v13 = *a7;
  v27 = 109;
  v28 = v13;
  v14 = *a8;
  v29 = 100;
  v30 = v14;
  v15 = *a9;
  v31 = 100;
  v32 = v15;
  v16 = *a10;
  v33 = 100;
  v34 = v16;
  v17 = *(a1 + 32);
  v18 = *(a1 + 36);
  v35 = -108;
  v36 = v17 * a3 / v18;
  v37 = 16;
  v39[0] = v38;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x4BuLL);
  v20 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<unsigned long,unsigned long,unsigned long,objc_object  {objcproto9MTLBuffer}*,unsigned long,objc_object  {objcproto9MTLBuffer},unsigned long,unsigned long,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12)
{
  v47[2] = *MEMORY[0x277D85DE8];
  v47[1] = v47;
  __src[0] = 1;
  __src[1] = a2;
  v12 = *a4;
  __src[2] = 100;
  v26 = v12;
  v13 = *a5;
  v27 = 100;
  v28 = v13;
  v14 = *a6;
  v29 = 100;
  v30 = v14;
  v15 = *a7;
  v31 = 109;
  v32 = v15;
  v16 = *a8;
  v33 = 100;
  v34 = v16;
  v17 = *a9;
  v35 = 109;
  v36 = v17;
  v18 = *a10;
  v37 = 100;
  v38 = v18;
  v19 = *a11;
  v39 = 100;
  v40 = v19;
  v20 = *a12;
  v41 = 100;
  v42 = v20;
  v21 = *(a1 + 32);
  v22 = *(a1 + 36);
  v43 = -108;
  v44 = v21 * a3 / v22;
  v45 = 16;
  v47[0] = v46;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x5DuLL);
  v24 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<unsigned long,objc_object  {objcproto9MTLBuffer}*,unsigned long,objc_object  {objcproto9MTLBuffer},unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  v31[2] = *MEMORY[0x277D85DE8];
  v31[1] = v31;
  __src[0] = 1;
  __src[1] = a2;
  v8 = *a4;
  __src[2] = 100;
  v18 = v8;
  v9 = *a5;
  v19 = 109;
  v20 = v9;
  v10 = *a6;
  v21 = 100;
  v22 = v10;
  v11 = *a7;
  v23 = 109;
  v24 = v11;
  v12 = *a8;
  v25 = 100;
  v26 = v12;
  v13 = *(a1 + 32);
  v14 = *(a1 + 36);
  v27 = -108;
  v28 = v13 * a3 / v14;
  v29 = 16;
  v31[0] = v30;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x39uLL);
  v16 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<unsigned long,objc_object  {objcproto9MTLBuffer}*,unsigned long,objc_object  {objcproto9MTLBuffer},unsigned long,objc_object  {objcproto9MTLBuffer},unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10)
{
  v39[2] = *MEMORY[0x277D85DE8];
  v39[1] = v39;
  __src[0] = 1;
  __src[1] = a2;
  v10 = *a4;
  __src[2] = 100;
  v22 = v10;
  v11 = *a5;
  v23 = 109;
  v24 = v11;
  v12 = *a6;
  v25 = 100;
  v26 = v12;
  v13 = *a7;
  v27 = 109;
  v28 = v13;
  v14 = *a8;
  v29 = 100;
  v30 = v14;
  v15 = *a9;
  v31 = 109;
  v32 = v15;
  v16 = *a10;
  v33 = 100;
  v34 = v16;
  v17 = *(a1 + 32);
  v18 = *(a1 + 36);
  v35 = -108;
  v36 = v17 * a3 / v18;
  v37 = 16;
  v39[0] = v38;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x4BuLL);
  v20 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<float,float,float,float>(uint64_t a1, char a2, uint64_t a3, int *a4, int *a5, int *a6, int *a7)
{
  v27[2] = *MEMORY[0x277D85DE8];
  v27[1] = v27;
  __src[0] = 1;
  __src[1] = a2;
  v7 = *a4;
  __src[2] = 106;
  v16 = v7;
  v8 = *a5;
  v17 = 106;
  v18 = v8;
  v9 = *a6;
  v19 = 106;
  v20 = v9;
  v10 = *a7;
  v21 = 106;
  v22 = v10;
  v11 = *(a1 + 32);
  v12 = *(a1 + 36);
  v23 = -108;
  v24 = v11 * a3 / v12;
  v25 = 16;
  v27[0] = &v26;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x20uLL);
  v14 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<float,float,float>(uint64_t a1, char a2, uint64_t a3, int *a4, int *a5, int *a6)
{
  v23[2] = *MEMORY[0x277D85DE8];
  v23[1] = v23;
  __src[0] = 1;
  __src[1] = a2;
  v6 = *a4;
  __src[2] = 106;
  v14 = v6;
  v7 = *a5;
  v15 = 106;
  v16 = v7;
  v8 = *a6;
  v17 = 106;
  v18 = v8;
  v9 = *(a1 + 32);
  v10 = *(a1 + 36);
  v19 = -108;
  v20 = v9 * a3 / v10;
  v21 = 16;
  v23[0] = v22;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x1BuLL);
  v12 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLScissorRect>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4)
{
  v24[2] = *MEMORY[0x277D85DE8];
  v24[1] = v24;
  __src[0] = 1;
  __src[1] = a2;
  v11 = 25664;
  v4 = a4[1];
  v12 = *a4;
  v13 = 100;
  v14 = v4;
  v15 = 100;
  v5 = a4[3];
  v16 = a4[2];
  v17 = 100;
  v18 = v5;
  v19 = 80;
  v6 = *(a1 + 32);
  v7 = *(a1 + 36);
  v20 = -108;
  v21 = v6 * a3 / v7;
  v22 = 16;
  v24[0] = v23;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x32uLL);
  v9 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<unsigned int,unsigned int>(uint64_t a1, char a2, uint64_t a3, int *a4, int *a5)
{
  v19[2] = *MEMORY[0x277D85DE8];
  v19[1] = v19;
  __src[0] = 1;
  __src[1] = a2;
  v5 = *a4;
  __src[2] = 99;
  v12 = v5;
  v6 = *a5;
  v13 = 99;
  v14 = v6;
  v7 = *(a1 + 32);
  v8 = *(a1 + 36);
  v15 = -108;
  v16 = v7 * a3 / v8;
  v17 = 16;
  v19[0] = &v18;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x16uLL);
  v10 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLViewport>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4)
{
  v26[2] = *MEMORY[0x277D85DE8];
  v4 = a4[1];
  v11 = *a4;
  v13 = v4;
  v5 = a4[3];
  v15 = a4[2];
  v17 = v5;
  v6 = a4[5];
  v19 = a4[4];
  v26[1] = v26;
  __src[0] = 1;
  __src[1] = a2;
  v10 = 27456;
  v12 = 107;
  v14 = 107;
  v16 = 107;
  v18 = 107;
  v20 = 107;
  v21 = v6;
  v22 = -27568;
  v23 = *(a1 + 32) * a3 / *(a1 + 36);
  v24 = 16;
  v26[0] = &v25;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x44uLL);
  v8 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<BinaryBuffer::Array<MTLViewport const>,unsigned long>(AppendBuffer *this, char a2, uint64_t a3, void *a4, uint64_t *a5)
{
  v8 = this;
  v48 = *MEMORY[0x277D85DE8];
  v40 = a2;
  v9 = &v46;
  v47 = &v46;
  v43[0] = 1;
  v43[1] = a2;
  v10 = v44;
  v43[2] = 32;
  v46 = v44;
  v11 = a4[1];
  if (v11)
  {
    v12 = 0;
    v13 = (*a4 + 24);
    v14 = &v45;
    do
    {
      v15 = v47;
      if (v14 - 27 <= v47)
      {
        *(v14 - 28) = 64;
        v15 = v47;
      }

      v16 = *(v13 - 3);
      if ((v14 - 26) <= v15)
      {
        *(v14 - 27) = 107;
        v15 = v47;
      }

      if ((v14 - 18) <= v15)
      {
        *(v14 - 26) = v16;
        v15 = v47;
      }

      v17 = *(v13 - 2);
      if ((v14 - 17) <= v15)
      {
        *(v14 - 18) = 107;
        v15 = v47;
      }

      if ((v14 - 9) <= v15)
      {
        *(v14 - 17) = v17;
        v15 = v47;
      }

      v18 = *(v13 - 1);
      if ((v14 - 8) <= v15)
      {
        *(v14 - 9) = 107;
        v15 = v47;
      }

      if (v14 <= v15)
      {
        *(v14 - 1) = v18;
        v15 = v47;
      }

      v46 = v14;
      v19 = *v13;
      if ((v14 + 1) <= v15)
      {
        *v14 = 107;
        v15 = v47;
      }

      if ((v14 + 9) <= v15)
      {
        *(v14 + 1) = v19;
        v15 = v47;
      }

      v20 = v13[1];
      if ((v14 + 10) <= v15)
      {
        v14[9] = 107;
        v15 = v47;
      }

      if ((v14 + 18) <= v15)
      {
        *(v14 + 10) = v20;
        v15 = v47;
      }

      v21 = v13[2];
      if ((v14 + 19) <= v15)
      {
        v14[18] = 107;
        v15 = v47;
      }

      if ((v14 + 27) <= v15)
      {
        *(v14 + 19) = v21;
        v15 = v47;
      }

      if ((v14 + 28) <= v15)
      {
        v14[27] = 80;
      }

      v46 = v14 + 28;
      ++v12;
      v13 += 6;
      v14 += 56;
    }

    while (v11 > v12);
    v9 = v47;
    v10 = v14 - 28;
  }

  if (v10 + 1 <= v9)
  {
    *v10 = 48;
    v9 = v47;
  }

  v22 = *a5;
  if (v10 + 2 <= v9)
  {
    v10[1] = 100;
    v9 = v47;
  }

  if (v10 + 10 <= v9)
  {
    *(v10 + 2) = v22;
    v9 = v47;
  }

  v24 = LODWORD(this[1]._vptr$AppendBuffer);
  v23 = HIDWORD(this[1]._vptr$AppendBuffer);
  if (v10 + 11 <= v9)
  {
    v10[10] = -108;
    v9 = v47;
  }

  v25 = v10 + 19;
  if (v10 + 19 <= v9)
  {
    *(v10 + 11) = v24 * a3 / v23;
    v9 = v47;
  }

  v26 = v10 + 20;
  if (v26 <= v9)
  {
    *v25 = 16;
    v9 = v47;
  }

  v46 = v26;
  if (v26 <= v9)
  {
    v37 = v26 - v43;
    p_stream = &this->stream;
    p_src = v43;
  }

  else
  {
    LOBYTE(__src) = 1;
    AppendBuffer::WriteBytes(this, &this->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(v8, &v8->stream, &v40, 1uLL);
    LOBYTE(__src) = 32;
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 1uLL);
    if (a4[1])
    {
      v27 = 0;
      v28 = 0;
      do
      {
        BinaryBuffer::WriteValue<AppendBuffer::StreamBuffer>(v8, &v8->stream, (*a4 + v27));
        ++v28;
        v27 += 48;
      }

      while (a4[1] > v28);
    }

    LOBYTE(__src) = 48;
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 1uLL);
    __src = *a5;
    v42 = 100;
    AppendBuffer::WriteBytes(v8, &v8->stream, &v42, 1uLL);
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 8uLL);
    v30 = LODWORD(v8[1]._vptr$AppendBuffer);
    v29 = HIDWORD(v8[1]._vptr$AppendBuffer);
    v31 = v46;
    v32 = (v46 + 1);
    v33 = v47;
    if (v46 + 1 <= v47)
    {
      *v46 = -108;
      v33 = v47;
    }

    v34 = v31 + 9;
    if (v34 <= v33)
    {
      *v32 = v30 * a3 / v29;
    }

    v46 = v34;
    LOBYTE(__src) = 16;
    p_stream = &v8->stream;
    p_src = &__src;
    this = v8;
    v37 = 1;
  }

  result = AppendBuffer::WriteBytes(this, p_stream, p_src, v37);
  v39 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<BinaryBuffer::Array<MTLScissorRect const>,unsigned long>(AppendBuffer *this, char a2, uint64_t a3, void *a4, uint64_t *a5)
{
  v8 = this;
  v45 = *MEMORY[0x277D85DE8];
  v37 = a2;
  v9 = &v43;
  v44 = &v43;
  v40[0] = 1;
  v40[1] = a2;
  v40[2] = 32;
  v10 = a4[1];
  if (v10)
  {
    v11 = v42;
    v12 = (*a4 + 16);
    do
    {
      v13 = v44;
      if (v11 - 37 <= v44)
      {
        *(v11 - 38) = 64;
        v13 = v44;
      }

      v14 = *(v12 - 2);
      if ((v11 - 36) <= v13)
      {
        *(v11 - 37) = 100;
        v13 = v44;
      }

      if ((v11 - 28) <= v13)
      {
        *(v11 - 36) = v14;
        v13 = v44;
      }

      v43 = v11 - 28;
      v15 = *(v12 - 1);
      if ((v11 - 27) <= v13)
      {
        *(v11 - 28) = 100;
        v13 = v44;
      }

      if ((v11 - 19) <= v13)
      {
        *(v11 - 27) = v15;
        v13 = v44;
      }

      v16 = *v12;
      if ((v11 - 18) <= v13)
      {
        *(v11 - 19) = 100;
        v13 = v44;
      }

      if ((v11 - 10) <= v13)
      {
        *(v11 - 18) = v16;
        v13 = v44;
      }

      v17 = v12[1];
      if ((v11 - 9) <= v13)
      {
        *(v11 - 10) = 100;
        v13 = v44;
      }

      if ((v11 - 1) <= v13)
      {
        *(v11 - 9) = v17;
        v13 = v44;
      }

      if (v11 <= v13)
      {
        *(v11 - 1) = 80;
      }

      v43 = v11;
      v11 += 38;
      v12 += 4;
      --v10;
    }

    while (v10);
    v9 = v44;
    v18 = v11 - 38;
  }

  else
  {
    v18 = v41;
  }

  if (v18 + 1 <= v9)
  {
    *v18 = 48;
    v9 = v44;
  }

  v19 = *a5;
  if (v18 + 2 <= v9)
  {
    v18[1] = 100;
    v9 = v44;
  }

  if (v18 + 10 <= v9)
  {
    *(v18 + 2) = v19;
    v9 = v44;
  }

  v21 = LODWORD(this[1]._vptr$AppendBuffer);
  v20 = HIDWORD(this[1]._vptr$AppendBuffer);
  if (v18 + 11 <= v9)
  {
    v18[10] = -108;
    v9 = v44;
  }

  v22 = v18 + 19;
  if (v18 + 19 <= v9)
  {
    *(v18 + 11) = v21 * a3 / v20;
    v9 = v44;
  }

  v23 = v18 + 20;
  if (v23 <= v9)
  {
    *v22 = 16;
    v9 = v44;
  }

  v43 = v23;
  if (v23 <= v9)
  {
    v34 = v23 - v40;
    p_stream = &this->stream;
    p_src = v40;
  }

  else
  {
    LOBYTE(__src) = 1;
    AppendBuffer::WriteBytes(this, &this->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(v8, &v8->stream, &v37, 1uLL);
    LOBYTE(__src) = 32;
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 1uLL);
    if (a4[1])
    {
      v24 = 0;
      v25 = 0;
      do
      {
        BinaryBuffer::WriteValue<AppendBuffer::StreamBuffer>(v8, &v8->stream, (*a4 + v24));
        ++v25;
        v24 += 32;
      }

      while (a4[1] > v25);
    }

    LOBYTE(__src) = 48;
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 1uLL);
    __src = *a5;
    v39 = 100;
    AppendBuffer::WriteBytes(v8, &v8->stream, &v39, 1uLL);
    AppendBuffer::WriteBytes(v8, &v8->stream, &__src, 8uLL);
    v27 = LODWORD(v8[1]._vptr$AppendBuffer);
    v26 = HIDWORD(v8[1]._vptr$AppendBuffer);
    v28 = v43;
    v29 = (v43 + 1);
    v30 = v44;
    if (v43 + 1 <= v44)
    {
      *v43 = -108;
      v30 = v44;
    }

    v31 = v28 + 9;
    if (v31 <= v30)
    {
      *v29 = v27 * a3 / v26;
    }

    v43 = v31;
    LOBYTE(__src) = 16;
    p_stream = &v8->stream;
    p_src = &__src;
    this = v8;
    v34 = 1;
  }

  result = AppendBuffer::WriteBytes(this, p_stream, p_src, v34);
  v36 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<BinaryBuffer::Array<objc_object  {objcproto11MTLResource}* const>,unsigned long,unsigned long,unsigned long>(AppendBuffer *this, char a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v12 = this;
  v47 = *MEMORY[0x277D85DE8];
  v39 = a2;
  v13 = &v45;
  v46 = &v45;
  v42[0] = 1;
  v42[1] = a2;
  v14 = v43;
  v42[2] = 32;
  v45 = v43;
  v15 = *(a4 + 8);
  if (v15)
  {
    v16 = *a4;
    v17 = &v44;
    do
    {
      v18 = *v16;
      v19 = v46;
      if (v17 - 2 <= v46)
      {
        *(v17 - 9) = 109;
        v19 = v46;
      }

      if (v17 <= v19)
      {
        *(v17 - 1) = v18;
      }

      v45 = v17;
      v17 = (v17 + 9);
      ++v16;
      --v15;
    }

    while (v15);
    v13 = v46;
    v14 = v17 - 9;
  }

  if (v14 + 1 <= v13)
  {
    *v14 = 48;
    v13 = v46;
  }

  v20 = *a5;
  if (v14 + 2 <= v13)
  {
    v14[1] = 100;
    v13 = v46;
  }

  if (v14 + 10 <= v13)
  {
    *(v14 + 2) = v20;
    v13 = v46;
  }

  v21 = *a6;
  if (v14 + 11 <= v13)
  {
    v14[10] = 100;
    v13 = v46;
  }

  if (v14 + 19 <= v13)
  {
    *(v14 + 11) = v21;
    v13 = v46;
  }

  v22 = *a7;
  if (v14 + 20 <= v13)
  {
    v14[19] = 100;
    v13 = v46;
  }

  if (v14 + 28 <= v13)
  {
    *(v14 + 20) = v22;
    v13 = v46;
  }

  v24 = LODWORD(this[1]._vptr$AppendBuffer);
  v23 = HIDWORD(this[1]._vptr$AppendBuffer);
  if (v14 + 29 <= v13)
  {
    v14[28] = -108;
    v13 = v46;
  }

  v25 = v14 + 37;
  if (v14 + 37 <= v13)
  {
    *(v14 + 29) = v24 * a3 / v23;
    v13 = v46;
  }

  v26 = (v14 + 38);
  if (v26 <= v13)
  {
    *v25 = 16;
    v13 = v46;
  }

  v45 = v26;
  if (v26 <= v13)
  {
    v36 = v26 - v42;
    p_stream = &this->stream;
    p_src = v42;
  }

  else
  {
    LOBYTE(__src) = 1;
    AppendBuffer::WriteBytes(this, &this->stream, &__src, 1uLL);
    AppendBuffer::WriteBytes(v12, &v12->stream, &v39, 1uLL);
    LOBYTE(__src) = 32;
    AppendBuffer::WriteBytes(v12, &v12->stream, &__src, 1uLL);
    if (*(a4 + 8))
    {
      v27 = 0;
      do
      {
        __src = *(*a4 + 8 * v27);
        v41 = 109;
        AppendBuffer::WriteBytes(v12, &v12->stream, &v41, 1uLL);
        AppendBuffer::WriteBytes(v12, &v12->stream, &__src, 8uLL);
        ++v27;
      }

      while (*(a4 + 8) > v27);
    }

    LOBYTE(__src) = 48;
    AppendBuffer::WriteBytes(v12, &v12->stream, &__src, 1uLL);
    __src = *a5;
    v41 = 100;
    AppendBuffer::WriteBytes(v12, &v12->stream, &v41, 1uLL);
    AppendBuffer::WriteBytes(v12, &v12->stream, &__src, 8uLL);
    __src = *a6;
    v41 = 100;
    AppendBuffer::WriteBytes(v12, &v12->stream, &v41, 1uLL);
    AppendBuffer::WriteBytes(v12, &v12->stream, &__src, 8uLL);
    __src = *a7;
    v41 = 100;
    AppendBuffer::WriteBytes(v12, &v12->stream, &v41, 1uLL);
    AppendBuffer::WriteBytes(v12, &v12->stream, &__src, 8uLL);
    v29 = LODWORD(v12[1]._vptr$AppendBuffer);
    v28 = HIDWORD(v12[1]._vptr$AppendBuffer);
    v30 = v45;
    v31 = (v45 + 1);
    v32 = v46;
    if ((v45 + 1) <= v46)
    {
      *v45 = -108;
      v32 = v46;
    }

    v33 = (v30 + 9);
    if (v33 <= v32)
    {
      *v31 = v29 * a3 / v28;
    }

    v45 = v33;
    LOBYTE(__src) = 16;
    p_stream = &v12->stream;
    p_src = &__src;
    this = v12;
    v36 = 1;
  }

  result = AppendBuffer::WriteBytes(this, p_stream, p_src, v36);
  v38 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long,unsigned long>(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v27[2] = *MEMORY[0x277D85DE8];
  v27[1] = v27;
  __src[0] = 1;
  __src[1] = a2;
  v7 = *a4;
  __src[2] = 109;
  v16 = v7;
  v8 = *a5;
  v17 = 100;
  v18 = v8;
  v9 = *a6;
  v19 = 100;
  v20 = v9;
  v10 = *a7;
  v21 = 100;
  v22 = v10;
  v11 = *(a1 + 32);
  v12 = *(a1 + 36);
  v23 = -108;
  v24 = v11 * a3 / v12;
  v25 = 16;
  v27[0] = &v26;
  result = AppendBuffer::WriteBytes(a1, (a1 + 8), __src, 0x30uLL);
  v14 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<BinaryBuffer::Array<objc_object  {objcproto9MTLBuffer}* const>,BinaryBuffer::Array<unsigned long const>,unsigned long const,_NSRange>(uint64_t a1, char a2, uint64_t a3, void *a4, void *a5, void *a6, uint64_t *a7)
{
  v37 = *MEMORY[0x277D85DE8];
  v31 = a2;
  v36 = &v35;
  v33[0] = 1;
  v33[1] = a2;
  v35 = v34;
  BinaryBuffer::WriteArguments<BinaryBuffer::ScratchBuffer,BinaryBuffer::Array<objc_object  {objcproto9MTLBuffer}* const>,BinaryBuffer::Array<unsigned long const>,unsigned long const,_NSRange>(a1, v33, a4, a5, a6, a7);
  v14 = *(a1 + 32);
  v13 = *(a1 + 36);
  v15 = v35;
  v16 = v36;
  if (v35 + 1 <= v36)
  {
    *v35 = -108;
    v16 = v36;
  }

  v17 = v15 + 9;
  if ((v15 + 9) <= v16)
  {
    *(v15 + 1) = v14 * a3 / v13;
    v16 = v36;
  }

  v18 = v15 + 10;
  if (v18 <= v16)
  {
    *v17 = 16;
    v16 = v36;
  }

  v35 = v18;
  if (v18 <= v16)
  {
    v28 = v18 - v33;
    v25 = (a1 + 8);
    p_src = v33;
    v27 = a1;
  }

  else
  {
    __src = 1;
    AppendBuffer::WriteBytes(a1, (a1 + 8), &__src, 1uLL);
    AppendBuffer::WriteBytes(a1, (a1 + 8), &v31, 1uLL);
    BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<objc_object  {objcproto9MTLBuffer}* const>,BinaryBuffer::Array<unsigned long const>,unsigned long const,_NSRange>(a1, (a1 + 8), a4, a5, a6, a7);
    v20 = *(a1 + 32);
    v19 = *(a1 + 36);
    v21 = v35;
    v22 = (v35 + 1);
    v23 = v36;
    if (v35 + 1 <= v36)
    {
      *v35 = -108;
      v23 = v36;
    }

    v24 = v21 + 9;
    if (v24 <= v23)
    {
      *v22 = v20 * a3 / v19;
    }

    v35 = v24;
    __src = 16;
    v25 = (a1 + 8);
    p_src = &__src;
    v27 = a1;
    v28 = 1;
  }

  result = AppendBuffer::WriteBytes(v27, v25, p_src, v28);
  v30 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<BinaryBuffer::Array<objc_object  {objcproto15MTLSamplerState}* const>,BinaryBuffer::Array<float const>,float const,_NSRange>(uint64_t a1, char a2, uint64_t a3, void *a4, void *a5, void *a6, uint64_t *a7)
{
  v39 = *MEMORY[0x277D85DE8];
  v32 = a2;
  v38 = &v37;
  v35[0] = 1;
  v35[1] = a2;
  v37 = v36;
  BinaryBuffer::WriteArguments<BinaryBuffer::ScratchBuffer,BinaryBuffer::Array<objc_object  {objcproto15MTLSamplerState}* const>,BinaryBuffer::Array<float const>,float const,_NSRange>(a1, v35, a4, a5, a6, a7);
  v14 = *(a1 + 32);
  v13 = *(a1 + 36);
  v15 = v37;
  v16 = v38;
  if (v37 + 1 <= v38)
  {
    *v37 = -108;
    v16 = v38;
  }

  v17 = v15 + 9;
  if ((v15 + 9) <= v16)
  {
    *(v15 + 1) = v14 * a3 / v13;
    v16 = v38;
  }

  v18 = v15 + 10;
  if (v18 <= v16)
  {
    *v17 = 16;
    v16 = v38;
  }

  v37 = v18;
  if (v18 <= v16)
  {
    v29 = v18 - v35;
    v26 = (a1 + 8);
    p_src = v35;
    v28 = a1;
  }

  else
  {
    LOBYTE(__src) = 1;
    AppendBuffer::WriteBytes(a1, (a1 + 8), &__src, 1uLL);
    AppendBuffer::WriteBytes(a1, (a1 + 8), &v32, 1uLL);
    LOBYTE(__src) = 32;
    AppendBuffer::WriteBytes(a1, (a1 + 8), &__src, 1uLL);
    if (a4[1])
    {
      v19 = 0;
      do
      {
        __src = *(*a4 + 8 * v19);
        v34 = 109;
        AppendBuffer::WriteBytes(a1, (a1 + 8), &v34, 1uLL);
        AppendBuffer::WriteBytes(a1, (a1 + 8), &__src, 8uLL);
        ++v19;
      }

      while (a4[1] > v19);
    }

    LOBYTE(__src) = 48;
    AppendBuffer::WriteBytes(a1, (a1 + 8), &__src, 1uLL);
    BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<float const>,BinaryBuffer::Array<float const>,_NSRange>(a1, (a1 + 8), a5, a6, a7);
    v21 = *(a1 + 32);
    v20 = *(a1 + 36);
    v22 = v37;
    v23 = (v37 + 1);
    v24 = v38;
    if (v37 + 1 <= v38)
    {
      *v37 = -108;
      v24 = v38;
    }

    v25 = v22 + 9;
    if (v25 <= v24)
    {
      *v23 = v21 * a3 / v20;
    }

    v37 = v25;
    LOBYTE(__src) = 16;
    v26 = (a1 + 8);
    p_src = &__src;
    v28 = a1;
    v29 = 1;
  }

  result = AppendBuffer::WriteBytes(v28, v26, p_src, v29);
  v31 = *MEMORY[0x277D85DE8];
  return result;
}

void *BinaryBuffer::Append<MTLSparseTextureMappingMode,MTLRegion,unsigned long,unsigned long>(AppendBuffer *a1, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v33[2] = *MEMORY[0x277D85DE8];
  v33[1] = v33;
  __src[0] = 1;
  __src[1] = a2;
  v6 = *a3;
  __src[2] = 100;
  v14 = v6;
  qmemcpy(v15, "@@d", sizeof(v15));
  v7 = a4[1];
  v16 = *a4;
  v17 = 100;
  v18 = v7;
  v19 = 100;
  v8 = a4[3];
  v20 = a4[2];
  qmemcpy(v21, "P@d", sizeof(v21));
  v22 = v8;
  v23 = 100;
  v9 = a4[5];
  v24 = a4[4];
  v25 = 100;
  v26 = v9;
  qmemcpy(v27, "PPd", sizeof(v27));
  v28 = *a5;
  v10 = *a6;
  v29 = 100;
  v30 = v10;
  v31 = 16;
  v33[0] = v32;
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __src, 0x5AuLL);
  v12 = *MEMORY[0x277D85DE8];
  return result;
}

void *StringBuffer::Append<char [10],unsigned long long>(AppendBuffer *a1, char *__s, void *a3)
{
  v11 = *MEMORY[0x277D85DE8];
  v6 = strlen(__s);
  AppendBuffer::WriteBytes(a1, &a1->stream, __s, v6);
  v7 = snprintf(__str, 0x20uLL, "%llu", *a3);
  result = AppendBuffer::WriteBytes(a1, &a1->stream, __str, v7);
  v9 = *MEMORY[0x277D85DE8];
  return result;
}

void *StringBuffer::Append<char [14],NSData *,char [2]>(AppendBuffer *a1, char *__s, id *a3, const char *a4)
{
  v8 = strlen(__s);
  AppendBuffer::WriteBytes(a1, &a1->stream, __s, v8);
  AppendBuffer::WriteBytes(a1, &a1->stream, [*a3 bytes], objc_msgSend(*a3, "length"));
  v9 = strlen(a4);

  return AppendBuffer::WriteBytes(a1, &a1->stream, a4, v9);
}

uint64_t AppendBuffer::Flush(AppendBuffer *this)
{
  result = [MEMORY[0x277CBEA90] dataWithBytesNoCopy:this->stream.bytes length:this->stream.pWrite - this->stream.bytes freeWhenDone:1];
  this->stream.pWrite = 0;
  this->stream.pEnd = 0;
  this->stream.bytes = 0;
  return result;
}

uint64_t AppendBuffer::FlushToBase64(AppendBuffer *this, BOOL *a2, unint64_t *a3)
{
  v5 = (*(this->_vptr$AppendBuffer + 2))(this);
  v6 = [MEMORY[0x277CBEB28] dataWithLength:{objc_msgSend(v5, "length")}];
  v7 = compression_encode_buffer([v6 bytes], objc_msgSend(v6, "length"), objc_msgSend(v5, "bytes"), objc_msgSend(v5, "length"), 0, COMPRESSION_LZ4_RAW);
  [v6 setLength:v7];
  v8 = v7 == 0;
  v9 = v7 != 0;
  if (v8)
  {
    v10 = v5;
  }

  else
  {
    v10 = v6;
  }

  v11 = [v10 base64EncodedDataWithOptions:0];
  *a2 = v9;
  *a3 = [v5 length];
  return v11;
}

void *AppendBuffer::WriteBytes(AppendBuffer *this, StreamBuffer *a2, const void *__src, size_t __n)
{
  pWrite = a2->pWrite;
  pEnd = a2->pEnd;
  bytes = a2->bytes;
  if (a2->bytes)
  {
    v10 = &pWrite[__n] > pEnd;
  }

  else
  {
    v10 = 1;
  }

  if (v10)
  {
    v11 = pWrite - bytes;
    v12 = pEnd - bytes;
    if (v12 <= __n)
    {
      v12 = __n;
    }

    v13 = (*MEMORY[0x277D85FA0] + 2 * v12 - 1) & -*MEMORY[0x277D85FA0];
    v14 = malloc_type_realloc(bytes, v13, 0x100004077774924uLL);
    a2->bytes = v14;
    pWrite = &v14[v11];
    a2->pEnd = &v14[v13];
  }

  result = memcpy(pWrite, __src, __n);
  a2->pWrite = &pWrite[__n];
  return result;
}

void BinaryBuffer::WriteArguments<BinaryBuffer::ScratchBuffer,MTLSize,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,unsigned long>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  v8 = *(a2 + 1024);
  v9 = (v8 + 1);
  v10 = *(a2 + 1032);
  if (v8 + 1 <= v10)
  {
    *v8 = 64;
    v10 = *(a2 + 1032);
  }

  *(a2 + 1024) = v9;
  v11 = *a3;
  if (v8 + 2 <= v10)
  {
    *v9 = 100;
    v10 = *(a2 + 1032);
  }

  if (v8 + 10 <= v10)
  {
    *(v8 + 2) = v11;
    v10 = *(a2 + 1032);
  }

  v12 = a3[1];
  if (v8 + 11 <= v10)
  {
    *(v8 + 10) = 100;
    v10 = *(a2 + 1032);
  }

  if (v8 + 19 <= v10)
  {
    *(v8 + 11) = v12;
    v10 = *(a2 + 1032);
  }

  v13 = a3[2];
  if (v8 + 20 <= v10)
  {
    *(v8 + 19) = 100;
    v10 = *(a2 + 1032);
  }

  if (v8 + 28 <= v10)
  {
    *(v8 + 20) = v13;
    v10 = *(a2 + 1032);
  }

  v14 = (v8 + 29);
  if (v8 + 29 <= v10)
  {
    *(v8 + 28) = 80;
    v10 = *(a2 + 1032);
  }

  *(a2 + 1024) = v14;
  v15 = *a4;
  if (v8 + 30 <= v10)
  {
    *v14 = 109;
    v10 = *(a2 + 1032);
  }

  if (v8 + 38 <= v10)
  {
    *(v8 + 30) = v15;
    v10 = *(a2 + 1032);
  }

  v16 = *a5;
  if (v8 + 39 <= v10)
  {
    *(v8 + 38) = 100;
    v10 = *(a2 + 1032);
  }

  if (v8 + 47 <= v10)
  {
    *(v8 + 39) = v16;
    v10 = *(a2 + 1032);
  }

  v17 = *a6;
  if (v8 + 48 <= v10)
  {
    *(v8 + 47) = 100;
    v10 = *(a2 + 1032);
  }

  if (v8 + 56 <= v10)
  {
    *(v8 + 48) = v17;
    v10 = *(a2 + 1032);
  }

  v18 = (v8 + 57);
  if (v8 + 57 <= v10)
  {
    *(v8 + 56) = 64;
    v10 = *(a2 + 1032);
  }

  *(a2 + 1024) = v18;
  v19 = *a7;
  if (v8 + 58 <= v10)
  {
    *v18 = 100;
    v10 = *(a2 + 1032);
  }

  if (v8 + 66 <= v10)
  {
    *(v8 + 58) = v19;
    v10 = *(a2 + 1032);
  }

  v20 = a7[1];
  if (v8 + 67 <= v10)
  {
    *(v8 + 66) = 100;
    v10 = *(a2 + 1032);
  }

  if (v8 + 75 <= v10)
  {
    *(v8 + 67) = v20;
    v10 = *(a2 + 1032);
  }

  v21 = a7[2];
  if (v8 + 76 <= v10)
  {
    *(v8 + 75) = 100;
    v10 = *(a2 + 1032);
  }

  if (v8 + 84 <= v10)
  {
    *(v8 + 76) = v21;
    v10 = *(a2 + 1032);
  }

  if (v8 + 85 <= v10)
  {
    *(v8 + 84) = 80;
    v10 = *(a2 + 1032);
  }

  v22 = *a8;
  v23 = (v8 + 86);
  if (v8 + 86 <= v10)
  {
    *(v8 + 85) = 100;
    v10 = *(a2 + 1032);
  }

  v24 = v8 + 94;
  if (v24 <= v10)
  {
    *v23 = v22;
  }

  *(a2 + 1024) = v24;
}

void *BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,MTLSize,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,unsigned long>(AppendBuffer *a1, StreamBuffer *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  LOBYTE(v17) = 64;
  AppendBuffer::WriteBytes(a1, a2, &v17, 1uLL);
  v17 = *a3;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v17, 8uLL);
  v17 = a3[1];
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v17, 8uLL);
  v17 = a3[2];
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v17, 8uLL);
  LOBYTE(v17) = 80;
  AppendBuffer::WriteBytes(a1, a2, &v17, 1uLL);
  return BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,unsigned long>(a1, a2, a4, a5, a6, a7, a8);
}

void *BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,unsigned long>(AppendBuffer *a1, StreamBuffer *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v14 = *a3;
  __src = 109;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
  v14 = *a4;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
  v14 = *a5;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
  LOBYTE(v14) = 64;
  AppendBuffer::WriteBytes(a1, a2, &v14, 1uLL);
  v14 = *a6;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
  v14 = a6[1];
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
  v14 = a6[2];
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
  LOBYTE(v14) = 80;
  AppendBuffer::WriteBytes(a1, a2, &v14, 1uLL);
  v14 = *a7;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  return AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
}

void BinaryBuffer::WriteArguments<BinaryBuffer::ScratchBuffer,objc_object  {objcproto10MTLTexture}*,unsigned long,unsigned long,MTLOrigin,MTLSize,objc_object  {objcproto9MTLBuffer}*,unsigned long,unsigned long,unsigned long>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11)
{
  v11 = *a3;
  v12 = *(a2 + 1024);
  v13 = *(a2 + 1032);
  if (v12 + 1 <= v13)
  {
    *v12 = 109;
    v13 = *(a2 + 1032);
  }

  if (v12 + 9 <= v13)
  {
    *(v12 + 1) = v11;
    v13 = *(a2 + 1032);
  }

  v14 = *a4;
  if (v12 + 10 <= v13)
  {
    *(v12 + 9) = 100;
    v13 = *(a2 + 1032);
  }

  if (v12 + 18 <= v13)
  {
    *(v12 + 10) = v14;
    v13 = *(a2 + 1032);
  }

  v15 = *a5;
  if (v12 + 19 <= v13)
  {
    *(v12 + 18) = 100;
    v13 = *(a2 + 1032);
  }

  if (v12 + 27 <= v13)
  {
    *(v12 + 19) = v15;
    v13 = *(a2 + 1032);
  }

  v16 = (v12 + 28);
  if (v12 + 28 <= v13)
  {
    *(v12 + 27) = 64;
    v13 = *(a2 + 1032);
  }

  *(a2 + 1024) = v16;
  v17 = *a6;
  if (v12 + 29 <= v13)
  {
    *v16 = 100;
    v13 = *(a2 + 1032);
  }

  if (v12 + 37 <= v13)
  {
    *(v12 + 29) = v17;
    v13 = *(a2 + 1032);
  }

  v18 = a6[1];
  if (v12 + 38 <= v13)
  {
    *(v12 + 37) = 100;
    v13 = *(a2 + 1032);
  }

  if (v12 + 46 <= v13)
  {
    *(v12 + 38) = v18;
    v13 = *(a2 + 1032);
  }

  v19 = a6[2];
  if (v12 + 47 <= v13)
  {
    *(v12 + 46) = 100;
    v13 = *(a2 + 1032);
  }

  if (v12 + 55 <= v13)
  {
    *(v12 + 47) = v19;
    v13 = *(a2 + 1032);
  }

  if (v12 + 56 <= v13)
  {
    *(v12 + 55) = 80;
    v13 = *(a2 + 1032);
  }

  v20 = (v12 + 57);
  if (v12 + 57 <= v13)
  {
    *(v12 + 56) = 64;
    v13 = *(a2 + 1032);
  }

  *(a2 + 1024) = v20;
  v21 = *a7;
  if (v12 + 58 <= v13)
  {
    *v20 = 100;
    v13 = *(a2 + 1032);
  }

  if (v12 + 66 <= v13)
  {
    *(v12 + 58) = v21;
    v13 = *(a2 + 1032);
  }

  v22 = a7[1];
  if (v12 + 67 <= v13)
  {
    *(v12 + 66) = 100;
    v13 = *(a2 + 1032);
  }

  if (v12 + 75 <= v13)
  {
    *(v12 + 67) = v22;
    v13 = *(a2 + 1032);
  }

  v23 = a7[2];
  if (v12 + 76 <= v13)
  {
    *(v12 + 75) = 100;
    v13 = *(a2 + 1032);
  }

  if (v12 + 84 <= v13)
  {
    *(v12 + 76) = v23;
    v13 = *(a2 + 1032);
  }

  v24 = (v12 + 85);
  if (v12 + 85 <= v13)
  {
    *(v12 + 84) = 80;
    v13 = *(a2 + 1032);
  }

  *(a2 + 1024) = v24;
  v25 = *a8;
  if (v12 + 86 <= v13)
  {
    *v24 = 109;
    v13 = *(a2 + 1032);
  }

  if (v12 + 94 <= v13)
  {
    *(v12 + 86) = v25;
    v13 = *(a2 + 1032);
  }

  v26 = *a9;
  if (v12 + 95 <= v13)
  {
    *(v12 + 94) = 100;
    v13 = *(a2 + 1032);
  }

  if (v12 + 103 <= v13)
  {
    *(v12 + 95) = v26;
    v13 = *(a2 + 1032);
  }

  v27 = *a10;
  if (v12 + 104 <= v13)
  {
    *(v12 + 103) = 100;
    v13 = *(a2 + 1032);
  }

  if (v12 + 112 <= v13)
  {
    *(v12 + 104) = v27;
    v13 = *(a2 + 1032);
  }

  v28 = *a11;
  v29 = (v12 + 113);
  if (v12 + 113 <= v13)
  {
    *(v12 + 112) = 100;
    v13 = *(a2 + 1032);
  }

  v30 = v12 + 121;
  if (v30 <= v13)
  {
    *v29 = v28;
  }

  *(a2 + 1024) = v30;
}

void *BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<unsigned long const>,_NSRange>(AppendBuffer *a1, StreamBuffer *a2, void *a3, uint64_t *a4)
{
  LOBYTE(v10) = 32;
  AppendBuffer::WriteBytes(a1, a2, &v10, 1uLL);
  if (a3[1])
  {
    v8 = 0;
    do
    {
      v10 = *(*a3 + 8 * v8);
      __src = 100;
      AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
      AppendBuffer::WriteBytes(a1, a2, &v10, 8uLL);
      ++v8;
    }

    while (a3[1] > v8);
  }

  LOBYTE(v10) = 48;
  AppendBuffer::WriteBytes(a1, a2, &v10, 1uLL);
  LOBYTE(v10) = 64;
  AppendBuffer::WriteBytes(a1, a2, &v10, 1uLL);
  v10 = *a4;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v10, 8uLL);
  v10 = a4[1];
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v10, 8uLL);
  LOBYTE(v10) = 80;
  return AppendBuffer::WriteBytes(a1, a2, &v10, 1uLL);
}

void *BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<objc_object  {objcproto15MTLSamplerState}* const>,float const*,float const,_NSRange>(AppendBuffer *a1, StreamBuffer *a2, void *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  LOBYTE(v14) = 32;
  AppendBuffer::WriteBytes(a1, a2, &v14, 1uLL);
  if (a3[1])
  {
    v12 = 0;
    do
    {
      v14 = *(*a3 + 8 * v12);
      __src = 109;
      AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
      AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
      ++v12;
    }

    while (a3[1] > v12);
  }

  LOBYTE(v14) = 48;
  AppendBuffer::WriteBytes(a1, a2, &v14, 1uLL);
  v14 = *a4;
  __src = 109;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
  v14 = *a5;
  __src = 109;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
  LOBYTE(v14) = 64;
  AppendBuffer::WriteBytes(a1, a2, &v14, 1uLL);
  v14 = *a6;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
  v14 = a6[1];
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v14, 8uLL);
  LOBYTE(v14) = 80;
  return AppendBuffer::WriteBytes(a1, a2, &v14, 1uLL);
}

void *BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<objc_object  {objcproto7MTLHeap}* const>,unsigned long>(AppendBuffer *a1, StreamBuffer *a2, void *a3, uint64_t *a4)
{
  LOBYTE(v10) = 32;
  AppendBuffer::WriteBytes(a1, a2, &v10, 1uLL);
  if (a3[1])
  {
    v8 = 0;
    do
    {
      v10 = *(*a3 + 8 * v8);
      __src = 109;
      AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
      AppendBuffer::WriteBytes(a1, a2, &v10, 8uLL);
      ++v8;
    }

    while (a3[1] > v8);
  }

  LOBYTE(v10) = 48;
  AppendBuffer::WriteBytes(a1, a2, &v10, 1uLL);
  v10 = *a4;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  return AppendBuffer::WriteBytes(a1, a2, &v10, 8uLL);
}

void *BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<objc_object  {objcproto11MTLResource}* const>,unsigned long,unsigned long>(AppendBuffer *a1, StreamBuffer *a2, void *a3, uint64_t *a4, uint64_t *a5)
{
  LOBYTE(v12) = 32;
  AppendBuffer::WriteBytes(a1, a2, &v12, 1uLL);
  if (a3[1])
  {
    v10 = 0;
    do
    {
      v12 = *(*a3 + 8 * v10);
      __src = 109;
      AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
      AppendBuffer::WriteBytes(a1, a2, &v12, 8uLL);
      ++v10;
    }

    while (a3[1] > v10);
  }

  LOBYTE(v12) = 48;
  AppendBuffer::WriteBytes(a1, a2, &v12, 1uLL);
  v12 = *a4;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v12, 8uLL);
  v12 = *a5;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  return AppendBuffer::WriteBytes(a1, a2, &v12, 8uLL);
}

void *BinaryBuffer::WriteValue<AppendBuffer::StreamBuffer>(AppendBuffer *a1, StreamBuffer *a2, uint64_t *a3)
{
  LOBYTE(v7) = 64;
  AppendBuffer::WriteBytes(a1, a2, &v7, 1uLL);
  v7 = *a3;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v7, 8uLL);
  v7 = a3[1];
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v7, 8uLL);
  v7 = a3[2];
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v7, 8uLL);
  v7 = a3[3];
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v7, 8uLL);
  LOBYTE(v7) = 80;
  return AppendBuffer::WriteBytes(a1, a2, &v7, 1uLL);
}

{
  LOBYTE(v7) = 64;
  AppendBuffer::WriteBytes(a1, a2, &v7, 1uLL);
  v7 = *a3;
  __src = 107;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v7, 8uLL);
  v7 = a3[1];
  __src = 107;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v7, 8uLL);
  v7 = a3[2];
  __src = 107;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v7, 8uLL);
  v7 = a3[3];
  __src = 107;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v7, 8uLL);
  v7 = a3[4];
  __src = 107;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v7, 8uLL);
  v7 = a3[5];
  __src = 107;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v7, 8uLL);
  LOBYTE(v7) = 80;
  return AppendBuffer::WriteBytes(a1, a2, &v7, 1uLL);
}

void BinaryBuffer::WriteArguments<BinaryBuffer::ScratchBuffer,BinaryBuffer::Array<objc_object  {objcproto9MTLBuffer}* const>,BinaryBuffer::Array<unsigned long const>,unsigned long const,_NSRange>(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t *a6)
{
  v6 = *(a2 + 1024);
  v7 = v6 + 1;
  if ((v6 + 1) <= *(a2 + 1032))
  {
    *v6 = 32;
  }

  *(a2 + 1024) = v7;
  if (a3[1])
  {
    v8 = 0;
    v9 = v6 + 10;
    do
    {
      v10 = *(*a3 + 8 * v8);
      v11 = *(a2 + 1032);
      if ((v9 - 8) <= v11)
      {
        *(v9 - 9) = 109;
        v11 = *(a2 + 1032);
      }

      if (v9 <= v11)
      {
        *(v9 - 1) = v10;
      }

      *(a2 + 1024) = v9;
      ++v8;
      v9 += 9;
    }

    while (a3[1] > v8);
    v7 = v9 - 9;
  }

  v12 = *(a2 + 1032);
  if ((v7 + 1) <= v12)
  {
    *v7 = 48;
    v12 = *(a2 + 1032);
  }

  v13 = v7 + 2;
  if ((v7 + 2) <= v12)
  {
    v7[1] = 32;
  }

  if (a4[1])
  {
    v14 = 0;
    v15 = v7 + 11;
    do
    {
      v16 = *(*a4 + 8 * v14);
      v17 = *(a2 + 1032);
      if ((v15 - 8) <= v17)
      {
        *(v15 - 9) = 100;
        v17 = *(a2 + 1032);
      }

      if (v15 <= v17)
      {
        *(v15 - 1) = v16;
      }

      ++v14;
      v15 += 9;
    }

    while (a4[1] > v14);
    v13 = v15 - 9;
  }

  v18 = v13 + 1;
  v19 = *(a2 + 1032);
  if ((v13 + 1) <= v19)
  {
    *v13 = 48;
    v19 = *(a2 + 1032);
  }

  *(a2 + 1024) = v18;
  v20 = v13 + 2;
  if ((v13 + 2) <= v19)
  {
    *v18 = 32;
  }

  if (a5[1])
  {
    v21 = 0;
    v22 = v13 + 11;
    do
    {
      v23 = *(*a5 + 8 * v21);
      v24 = *(a2 + 1032);
      if ((v22 - 8) <= v24)
      {
        *(v22 - 9) = 100;
        v24 = *(a2 + 1032);
      }

      if (v22 <= v24)
      {
        *(v22 - 1) = v23;
      }

      ++v21;
      v22 += 9;
    }

    while (a5[1] > v21);
    v20 = v22 - 9;
  }

  v25 = *(a2 + 1032);
  if ((v20 + 1) <= v25)
  {
    *v20 = 48;
    v25 = *(a2 + 1032);
  }

  if ((v20 + 2) <= v25)
  {
    v20[1] = 64;
    v25 = *(a2 + 1032);
  }

  v26 = *a6;
  if ((v20 + 3) <= v25)
  {
    v20[2] = 100;
    v25 = *(a2 + 1032);
  }

  if ((v20 + 11) <= v25)
  {
    *(v20 + 3) = v26;
    v25 = *(a2 + 1032);
  }

  v27 = a6[1];
  if ((v20 + 12) <= v25)
  {
    v20[11] = 100;
    v25 = *(a2 + 1032);
  }

  v28 = v20 + 20;
  if ((v20 + 20) <= v25)
  {
    *(v20 + 12) = v27;
    v25 = *(a2 + 1032);
  }

  v29 = (v20 + 21);
  if (v29 <= v25)
  {
    *v28 = 80;
  }

  *(a2 + 1024) = v29;
}

void *BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<objc_object  {objcproto9MTLBuffer}* const>,BinaryBuffer::Array<unsigned long const>,unsigned long const,_NSRange>(AppendBuffer *a1, StreamBuffer *a2, void *a3, void *a4, void *a5, uint64_t *a6)
{
  LOBYTE(v15) = 32;
  AppendBuffer::WriteBytes(a1, a2, &v15, 1uLL);
  if (a3[1])
  {
    v12 = 0;
    do
    {
      v15 = *(*a3 + 8 * v12);
      __src = 109;
      AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
      AppendBuffer::WriteBytes(a1, a2, &v15, 8uLL);
      ++v12;
    }

    while (a3[1] > v12);
  }

  LOBYTE(v15) = 48;
  AppendBuffer::WriteBytes(a1, a2, &v15, 1uLL);
  LOBYTE(v15) = 32;
  AppendBuffer::WriteBytes(a1, a2, &v15, 1uLL);
  if (a4[1])
  {
    v13 = 0;
    do
    {
      v15 = *(*a4 + 8 * v13);
      __src = 100;
      AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
      AppendBuffer::WriteBytes(a1, a2, &v15, 8uLL);
      ++v13;
    }

    while (a4[1] > v13);
  }

  LOBYTE(v15) = 48;
  AppendBuffer::WriteBytes(a1, a2, &v15, 1uLL);
  return BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<unsigned long const>,_NSRange>(a1, a2, a5, a6);
}

void BinaryBuffer::WriteArguments<BinaryBuffer::ScratchBuffer,BinaryBuffer::Array<objc_object  {objcproto15MTLSamplerState}* const>,BinaryBuffer::Array<float const>,float const,_NSRange>(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t *a6)
{
  v6 = *(a2 + 1024);
  v7 = v6 + 1;
  if ((v6 + 1) <= *(a2 + 1032))
  {
    *v6 = 32;
  }

  *(a2 + 1024) = v7;
  if (a3[1])
  {
    v8 = 0;
    v9 = v6 + 10;
    do
    {
      v10 = *(*a3 + 8 * v8);
      v11 = *(a2 + 1032);
      if ((v9 - 8) <= v11)
      {
        *(v9 - 9) = 109;
        v11 = *(a2 + 1032);
      }

      if (v9 <= v11)
      {
        *(v9 - 1) = v10;
      }

      *(a2 + 1024) = v9;
      ++v8;
      v9 += 9;
    }

    while (a3[1] > v8);
    v7 = v9 - 9;
  }

  v12 = *(a2 + 1032);
  if ((v7 + 1) <= v12)
  {
    *v7 = 48;
    v12 = *(a2 + 1032);
  }

  v13 = v7 + 2;
  if ((v7 + 2) <= v12)
  {
    v7[1] = 32;
  }

  if (a4[1])
  {
    v14 = 0;
    v15 = v7 + 3;
    do
    {
      v16 = *(*a4 + 4 * v14);
      v17 = *(a2 + 1032);
      if (v15 <= v17)
      {
        *(v15 - 1) = 106;
        v17 = *(a2 + 1032);
      }

      if ((v15 + 1) <= v17)
      {
        *v15 = v16;
      }

      ++v14;
      v15 = (v15 + 5);
    }

    while (a4[1] > v14);
    v13 = v15 - 1;
  }

  v18 = v13 + 1;
  v19 = *(a2 + 1032);
  if ((v13 + 1) <= v19)
  {
    *v13 = 48;
    v19 = *(a2 + 1032);
  }

  *(a2 + 1024) = v18;
  v20 = v13 + 2;
  if ((v13 + 2) <= v19)
  {
    *v18 = 32;
  }

  if (a5[1])
  {
    v21 = 0;
    v22 = v13 + 3;
    do
    {
      v23 = *(*a5 + 4 * v21);
      v24 = *(a2 + 1032);
      if (v22 <= v24)
      {
        *(v22 - 1) = 106;
        v24 = *(a2 + 1032);
      }

      if ((v22 + 1) <= v24)
      {
        *v22 = v23;
      }

      ++v21;
      v22 = (v22 + 5);
    }

    while (a5[1] > v21);
    v20 = v22 - 1;
  }

  v25 = *(a2 + 1032);
  if ((v20 + 1) <= v25)
  {
    *v20 = 48;
    v25 = *(a2 + 1032);
  }

  if ((v20 + 2) <= v25)
  {
    v20[1] = 64;
    v25 = *(a2 + 1032);
  }

  v26 = *a6;
  if ((v20 + 3) <= v25)
  {
    v20[2] = 100;
    v25 = *(a2 + 1032);
  }

  if ((v20 + 11) <= v25)
  {
    *(v20 + 3) = v26;
    v25 = *(a2 + 1032);
  }

  v27 = a6[1];
  if ((v20 + 12) <= v25)
  {
    v20[11] = 100;
    v25 = *(a2 + 1032);
  }

  v28 = v20 + 20;
  if ((v20 + 20) <= v25)
  {
    *(v20 + 12) = v27;
    v25 = *(a2 + 1032);
  }

  v29 = (v20 + 21);
  if (v29 <= v25)
  {
    *v28 = 80;
  }

  *(a2 + 1024) = v29;
}

void *BinaryBuffer::WriteArguments<AppendBuffer::StreamBuffer,BinaryBuffer::Array<float const>,BinaryBuffer::Array<float const>,_NSRange>(AppendBuffer *a1, StreamBuffer *a2, void *a3, void *a4, uint64_t *a5)
{
  LOBYTE(v13) = 32;
  AppendBuffer::WriteBytes(a1, a2, &v13, 1uLL);
  if (a3[1])
  {
    v10 = 0;
    do
    {
      LODWORD(v13) = *(*a3 + 4 * v10);
      __src = 106;
      AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
      AppendBuffer::WriteBytes(a1, a2, &v13, 4uLL);
      ++v10;
    }

    while (a3[1] > v10);
  }

  LOBYTE(v13) = 48;
  AppendBuffer::WriteBytes(a1, a2, &v13, 1uLL);
  LOBYTE(v13) = 32;
  AppendBuffer::WriteBytes(a1, a2, &v13, 1uLL);
  if (a4[1])
  {
    v11 = 0;
    do
    {
      LODWORD(v13) = *(*a4 + 4 * v11);
      __src = 106;
      AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
      AppendBuffer::WriteBytes(a1, a2, &v13, 4uLL);
      ++v11;
    }

    while (a4[1] > v11);
  }

  LOBYTE(v13) = 48;
  AppendBuffer::WriteBytes(a1, a2, &v13, 1uLL);
  LOBYTE(v13) = 64;
  AppendBuffer::WriteBytes(a1, a2, &v13, 1uLL);
  v13 = *a5;
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v13, 8uLL);
  v13 = a5[1];
  __src = 100;
  AppendBuffer::WriteBytes(a1, a2, &__src, 1uLL);
  AppendBuffer::WriteBytes(a1, a2, &v13, 8uLL);
  LOBYTE(v13) = 80;
  return AppendBuffer::WriteBytes(a1, a2, &v13, 1uLL);
}

void sub_22E183EC8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    os_unfair_lock_unlock(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_22E184070(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    os_unfair_lock_unlock(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_22E1841C8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    os_unfair_lock_unlock(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_22E184400(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_22E1855E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,NSString *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,NSString *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,NSString *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,NSString *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(void *a1, unsigned int *a2)
{
  v2 = *a2;
  v3 = a1[1];
  if (!*&v3)
  {
    goto LABEL_18;
  }

  v4 = vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*&v3 <= v2)
    {
      v5 = v2 % v3.i32[0];
    }
  }

  else
  {
    v5 = (v3.i32[0] - 1) & v2;
  }

  v6 = *(*a1 + 8 * v5);
  if (!v6 || (v7 = *v6) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v8 = v7[1];
    if (v8 == v2)
    {
      break;
    }

    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *&v3)
      {
        v8 %= *&v3;
      }
    }

    else
    {
      v8 &= *&v3 - 1;
    }

    if (v8 != v5)
    {
      goto LABEL_18;
    }

LABEL_17:
    v7 = *v7;
    if (!v7)
    {
      goto LABEL_18;
    }
  }

  if (*(v7 + 4) != v2)
  {
    goto LABEL_17;
  }

  return v7;
}

void *std::__hash_table<std::__hash_value_type<unsigned long,MTLGPUDebugResidencySet *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,MTLGPUDebugResidencySet *>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,MTLGPUDebugResidencySet *>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,MTLGPUDebugResidencySet *>>>::__emplace_unique_key_args<unsigned long,unsigned long,MTLGPUDebugResidencySet *>(void *a1, unint64_t *a2)
{
  v2 = *a2;
  v3 = a1[1];
  if (!*&v3)
  {
    goto LABEL_18;
  }

  v4 = vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v2 >= *&v3)
    {
      v5 = v2 % *&v3;
    }
  }

  else
  {
    v5 = (*&v3 - 1) & v2;
  }

  v6 = *(*a1 + 8 * v5);
  if (!v6 || (v7 = *v6) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v8 = v7[1];
    if (v8 == v2)
    {
      break;
    }

    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *&v3)
      {
        v8 %= *&v3;
      }
    }

    else
    {
      v8 &= *&v3 - 1;
    }

    if (v8 != v5)
    {
      goto LABEL_18;
    }

LABEL_17:
    v7 = *v7;
    if (!v7)
    {
      goto LABEL_18;
    }
  }

  if (v7[2] != v2)
  {
    goto LABEL_17;
  }

  return v7;
}

void *std::__hash_table<std::__hash_value_type<unsigned long,MTLGPUDebugResidencySet *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,MTLGPUDebugResidencySet *>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,MTLGPUDebugResidencySet *>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,MTLGPUDebugResidencySet *>>>::__emplace_unique_key_args<unsigned long,unsigned long,MTLGPUDebugResidencySet *&>(void *a1, unint64_t *a2)
{
  v2 = *a2;
  v3 = a1[1];
  if (!*&v3)
  {
    goto LABEL_18;
  }

  v4 = vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v2 >= *&v3)
    {
      v5 = v2 % *&v3;
    }
  }

  else
  {
    v5 = (*&v3 - 1) & v2;
  }

  v6 = *(*a1 + 8 * v5);
  if (!v6 || (v7 = *v6) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v8 = v7[1];
    if (v8 == v2)
    {
      break;
    }

    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *&v3)
      {
        v8 %= *&v3;
      }
    }

    else
    {
      v8 &= *&v3 - 1;
    }

    if (v8 != v5)
    {
      goto LABEL_18;
    }

LABEL_17:
    v7 = *v7;
    if (!v7)
    {
      goto LABEL_18;
    }
  }

  if (v7[2] != v2)
  {
    goto LABEL_17;
  }

  return v7;
}

uint64_t MTLLegacySVLog(void)
{
  if (MTLLegacySVLog(void)::onceToken != -1)
  {
    MTLLegacySVLog();
  }

  return MTLLegacySVLog(void)::logObject;
}

os_log_t ___Z14MTLLegacySVLogv_block_invoke()
{
  result = os_log_create("com.apple.Metal", "GPUDebug");
  MTLLegacySVLog(void)::logObject = result;
  return result;
}

void LegacySVMetalBuffer::LegacySVMetalBuffer(LegacySVMetalBuffer *this, LegacySVMetalBufferHeap *a2, unsigned int a3)
{
  this->heap = a2;
  this->index = a3;
}

{
  this->heap = a2;
  this->index = a3;
}

void LegacySVMetalBufferHeap::freeBuffer(uint64_t a1, uint64_t a2)
{
  std::mutex::lock(a1);
  v4 = *(a2 + 8);
  v5 = *(a1 + 112) + 1;
  *(a1 + 112) = v5;
  *(*(a1 + 88) + 4 * v5) = v4;
  *(a1 + 128) -= *(a1 + 136);
  *a2 = 0;

  std::mutex::unlock(a1);
}

uint64_t LegacySVMetalBufferHeap::init(uint64_t this, MTLLegacySVDevice *a2, uint64_t a3)
{
  *(this + 136) = a3;
  *(this + 144) = a2;
  return this;
}

void LegacySVMetalBufferHeap::grow(LegacySVMetalBufferHeap *this, unsigned int a2)
{
  *&v13[5] = *MEMORY[0x277D85DE8];
  v4 = *(this + 8);
  v5 = *(this + 9);
  v3 = (this + 64);
  v6 = v5 - v4;
  v7 = (v5 - v4) >> 3;
  if (v7 != a2)
  {
    v8 = a2;
    std::vector<MTLGPUDebugBuffer *>::resize(v3, a2);
    std::vector<unsigned int>::resize((this + 88), v8);
    if (v6 < *(this + 9) - *(this + 8))
    {
      do
      {
        *(*(this + 8) + 8 * v7) = [*(this + 18) newInternalBufferWithLength:*(this + 17) options:256];
        *(this + 15) += *(this + 17);
        if (MTLLegacySVLog(void)::onceToken != -1)
        {
          LegacySVMetalBufferHeap::grow();
        }

        v9 = MTLLegacySVLog(void)::logObject;
        if (os_log_type_enabled(MTLLegacySVLog(void)::logObject, OS_LOG_TYPE_DEBUG))
        {
          LegacySVMetalBufferHeap::grow(v12, this + 15, v13, v9);
        }

        v10 = *(this + 28) + 1;
        *(this + 28) = v10;
        *(*(this + 11) + 4 * v10) = v7++;
      }

      while (v7 < (*(this + 9) - *(this + 8)) >> 3);
    }
  }

  v11 = *MEMORY[0x277D85DE8];
}

void std::vector<unsigned int>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz)
{
  v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2)
    {
      this->__end_ = &this->__begin_[__sz];
    }
  }

  else
  {
    std::vector<unsigned int>::__append(this, __sz - v2);
  }
}

std::mutex *LegacySVMetalBufferHeap::allocBuffer(std::mutex *this)
{
  std::mutex::lock(this);
  if ((*&this[1].__m_.__opaque[40] & 0x80000000) != 0)
  {
    LegacySVMetalBufferHeap::grow(this, ((*this[1].__m_.__opaque - this[1].__m_.__sig) >> 3) + 1);
  }

  this[2].__m_.__sig += *this[2].__m_.__opaque;
  if (MTLLegacySVLog(void)::onceToken != -1)
  {
    MTLLegacySVLog();
  }

  v2 = MTLLegacySVLog(void)::logObject;
  if (os_log_type_enabled(MTLLegacySVLog(void)::logObject, OS_LOG_TYPE_DEBUG))
  {
    LegacySVMetalBufferHeap::allocBuffer(&this[2], this, v2);
  }

  v3 = *&this[1].__m_.__opaque[40];
  *&this[1].__m_.__opaque[40] = v3 - 1;
  v4 = *(*&this[1].__m_.__opaque[16] + 4 * v3);
  std::mutex::unlock(this);
  return this;
}

void LegacySVMetalBufferHeap::~LegacySVMetalBufferHeap(std::mutex *this)
{
  sig = this[1].__m_.__sig;
  v3 = *this[1].__m_.__opaque;
  while (sig != v3)
  {
  }

  v4 = *&this[1].__m_.__opaque[16];
  if (v4)
  {
    *&this[1].__m_.__opaque[24] = v4;
    operator delete(v4);
  }

  v5 = this[1].__m_.__sig;
  if (v5)
  {
    *this[1].__m_.__opaque = v5;
    operator delete(v5);
  }

  std::mutex::~mutex(this);
}

void LegacySVBufferDescriptorHeap::init(LegacySVBufferDescriptorHeap *this, MTLLegacySVBuffer **a2, unsigned int a3)
{
  v6 = objc_alloc_init(MEMORY[0x277CD6C70]);
  v7 = objc_alloc_init(MEMORY[0x277CBEB18]);
  v8 = objc_autoreleasePoolPush();
  [v6 setIndex:0];
  [v6 setAccess:1];
  [v6 setArrayLength:1];
  [v6 setDataType:60];
  [v7 addObject:{objc_msgSend(v6, "copy")}];
  [v6 setIndex:1];
  [v6 setAccess:0];
  [v6 setArrayLength:1];
  [v6 setDataType:33];
  [v7 addObject:{objc_msgSend(v6, "copy")}];
  objc_autoreleasePoolPop(v8);
  v9 = objc_autoreleasePoolPush();
  *(this + 15) = [objc_msgSend(a2 "baseObject")];
  objc_autoreleasePoolPop(v9);

  *(this + 16) = [a2 newInternalBufferWithLength:objc_msgSend(*(this + 15) options:{"encodedLength") * a3, 256}];
  if (MTLLegacySVLog(void)::onceToken != -1)
  {
    MTLLegacySVLog();
  }

  if (os_log_type_enabled(MTLLegacySVLog(void)::logObject, OS_LOG_TYPE_DEBUG))
  {
    GPUDebugBufferDescriptorHeap::init(this + 16);
  }

  *(this + 14) = 1;
  [*(this + 15) setArgumentBuffer:*(this + 16) offset:0];
  Handle = LegacySVBufferDescriptorHeap::createHandle(this, a2[81]);
  std::mutex::lock(this);
  [*(this + 15) setArgumentBuffer:*(this + 16) offset:{objc_msgSend(*(this + 15), "encodedLength") * Handle}];
  v11 = *(this + 15);
  [v11 setBuffer:a2[81] offset:0 atIndex:0];
  *[v11 constantDataAtIndex:1] = -1;
  std::mutex::unlock(this);
}

unint64_t LegacySVBufferDescriptorHeap::createHandle(std::mutex *this, MTLLegacySVBuffer *a2)
{
  std::mutex::lock(this);
  v4 = *this[1].__m_.__opaque;
  if (this[1].__m_.__sig == v4)
  {
    v5 = *&this[1].__m_.__opaque[40];
    *&this[1].__m_.__opaque[40] = v5 + 1;
    if (MTLLegacySVLog(void)::onceToken != -1)
    {
      MTLLegacySVLog();
    }

    if (os_log_type_enabled(MTLLegacySVLog(void)::logObject, OS_LOG_TYPE_DEBUG))
    {
      GPUDebugBufferDescriptorHeap::createHandle();
    }

    v6 = *&this[1].__m_.__opaque[16];
    if (v5 >= (*&this[1].__m_.__opaque[24] - v6) >> 3)
    {
      std::vector<MTLGPUDebugBuffer *>::resize(&this[1].__m_.__opaque[16], v5 + 1);
      v6 = *&this[1].__m_.__opaque[16];
    }

    *(v6 + 8 * v5) = a2;
  }

  else
  {
    v5 = *(v4 - 4);
    *(*&this[1].__m_.__opaque[16] + 8 * v5) = a2;
    *this[1].__m_.__opaque -= 4;
  }

  std::mutex::unlock(this);
  return v5;
}

void LegacySVBufferDescriptorHeap::freeBufferHandle(std::mutex *this, uint64_t a2)
{
  std::mutex::lock(this);
  *(*&this[1].__m_.__opaque[16] + 8 * a2) = 0;
  v5 = *this[1].__m_.__opaque;
  v4 = *&this[1].__m_.__opaque[8];
  if (v5 >= v4)
  {
    sig = this[1].__m_.__sig;
    v8 = v5 - sig;
    v9 = (v5 - sig) >> 2;
    v10 = v9 + 1;
    if ((v9 + 1) >> 62)
    {
      std::vector<std::pair<char const*,MTLShaderValidationState>>::__throw_length_error[abi:ne200100]();
    }

    v11 = v4 - sig;
    if (v11 >> 1 > v10)
    {
      v10 = v11 >> 1;
    }

    v12 = v11 >= 0x7FFFFFFFFFFFFFFCLL;
    v13 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v12)
    {
      v13 = v10;
    }

    if (v13)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<unsigned int>>(&this[1], v13);
    }

    v14 = (v5 - sig) >> 2;
    v15 = (4 * v9);
    v16 = (4 * v9 - 4 * v14);
    *v15 = a2;
    v6 = v15 + 1;
    memcpy(v16, sig, v8);
    v17 = this[1].__m_.__sig;
    this[1].__m_.__sig = v16;
    *this[1].__m_.__opaque = v6;
    *&this[1].__m_.__opaque[8] = 0;
    if (v17)
    {
      operator delete(v17);
    }
  }

  else
  {
    *v5 = a2;
    v6 = v5 + 4;
  }

  *this[1].__m_.__opaque = v6;

  std::mutex::unlock(this);
}

void LegacySVConstantBufferCache::getOrCreateBuffer(LegacySVConstantBufferCache *this@<X0>, NSData *a2@<X1>, uint64_t a3@<X8>)
{
  std::mutex::lock((this + 8));
  *this += [(NSData *)a2 length];
  if (MTLLegacySVLog(void)::onceToken != -1)
  {
    MTLLegacySVLog();
  }

  if (os_log_type_enabled(MTLLegacySVLog(void)::logObject, OS_LOG_TYPE_DEBUG))
  {
    GPUDebugConstantBufferCache::getOrCreateBuffer(this);
  }

  v6 = *(this + 14);
  if ((v6[286] & 0x80) != 0)
  {
    v7 = [v6 newBufferWithLength:-[NSData length](a2 options:{"length"), 0}];
  }

  else
  {
    v7 = [v6 newInternalBufferWithLength:-[NSData length](a2 options:{"length"), 0}];
  }

  v8 = v7;
  v9[0] = MEMORY[0x277D85DD0];
  v9[1] = 3221225472;
  v9[2] = ___ZN27LegacySVConstantBufferCache17getOrCreateBufferEP6NSData_block_invoke;
  v9[3] = &unk_2787B3AB8;
  v9[4] = v7;
  [(NSData *)a2 enumerateByteRangesUsingBlock:v9];
  *(a3 + 32) = 0;
  *(a3 + 40) = v8;
  std::mutex::unlock((this + 8));
}

void *___ZN27LegacySVConstantBufferCache17getOrCreateBufferEP6NSData_block_invoke(uint64_t a1, const void *a2, uint64_t a3, size_t a4)
{
  v6 = ([*(a1 + 32) contents] + a3);

  return memcpy(v6, a2, a4);
}

void LegacySVConstantBufferCache::releaseBuffer(LegacySVConstantBufferCache *this, KeyBufferPair *a2)
{
  if (a2->buffer)
  {
    std::mutex::lock((this + 8));
    *this -= [(MTLBuffer *)a2->buffer length];

    a2->buffer = 0;

    std::mutex::unlock((this + 8));
  }
}

void LegacySVGlobalResidentBufferList::useBuffers(LegacySVGlobalResidentBufferList *this, MTLLegacySVRenderCommandEncoder *a2)
{
  if (*&a2->_tileStageActive != *this)
  {
    std::mutex::lock((this + 8));
    for (i = *(this + 10); i != (this + 72); i = *(i + 8))
    {
      v5 = *(i + 16);
      [(MTLLegacySVRenderCommandEncoder *)a2 useResource:v5 usage:1];
      [(MTLToolsCommandEncoder *)a2 addRetainedObject:v5];
    }

    *&a2->_tileStageActive = *this;

    std::mutex::unlock((this + 8));
  }
}

void LegacySVGlobalResidentBufferList::useBuffers(LegacySVGlobalResidentBufferList *this, MTLLegacySVComputeCommandEncoder *a2)
{
  if (*&a2->_enableUseResourceValidation != *this)
  {
    std::mutex::lock((this + 8));
    for (i = *(this + 10); i != (this + 72); i = *(i + 8))
    {
      v5 = *(i + 16);
      [(MTLLegacySVComputeCommandEncoder *)a2 useResource:v5 usage:1];
      [(MTLToolsCommandEncoder *)a2 addRetainedObject:v5];
    }

    *&a2->_enableUseResourceValidation = *this;

    std::mutex::unlock((this + 8));
  }
}

void LegacySVGlobalResidentBufferList::addBuffer(uint64_t a1)
{
  std::mutex::lock((a1 + 8));
  ++*a1;
  operator new();
}

void LegacySVGlobalResidentBufferList::removeBuffer(uint64_t a1, uint64_t a2)
{
  v3 = a2;
  std::mutex::lock((a1 + 8));
  std::list<objc_object  {objcproto9MTLBuffer}*>::remove(a1 + 72, &v3);
  std::mutex::unlock((a1 + 8));
}

void sub_22E1882A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void instrumentationHeapInit(MTLLegacySVDevice *a1)
{
  v2 = (a1 + 688);
  v3 = a1;
  if (atomic_load_explicit(v2, memory_order_acquire) != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(v2, &v4, std::__call_once_proxy[abi:ne200100]<std::tuple<instrumentationHeapInit(MTLLegacySVDevice *)::$_0 &&>>);
  }
}

void indirectCommandBufferPipelineInit(MTLLegacySVDevice *a1)
{
  v3 = a1;
  v1 = (a1 + 696);
  v2 = &v3;
  if (atomic_load_explicit(v1, memory_order_acquire) != -1)
  {
    v5 = &v2;
    v4 = &v5;
    std::__call_once(v1, &v4, std::__call_once_proxy[abi:ne200100]<std::tuple<indirectCommandBufferPipelineInit(MTLLegacySVDevice *)::$_0 &&>>);
  }
}

void LogInstrumentationFailures(MTLLegacySVImageData *a1, MTLDebugInstrumentationData *a2)
{
  v23 = *MEMORY[0x277D85DE8];
  if (a1 && a2)
  {
    [(MTLLegacySVImageData *)a1 functionType];
    v4 = [MTLFunctionTypeString() UTF8String];
    if ([(MTLDebugInstrumentationData *)a2 hasArgumentLimitsInstrumentationFailures])
    {
      if (MTLLegacySVLog(void)::onceToken != -1)
      {
        MTLLegacySVLog();
      }

      v5 = MTLLegacySVLog(void)::logObject;
      if (os_log_type_enabled(MTLLegacySVLog(void)::logObject, OS_LOG_TYPE_INFO))
      {
        v15 = 136315394;
        v16 = v4;
        v17 = 2080;
        v18 = [(NSString *)[(MTLLegacySVImageData *)a1 loadedImageName] UTF8String];
        v6 = "Fatal failure when instrumenting %s %s:\n\tFunction is not instrumented and faults will not be detected.";
        v7 = v5;
        v8 = 22;
LABEL_19:
        _os_log_impl(&dword_22E0FF000, v7, OS_LOG_TYPE_INFO, v6, &v15, v8);
      }
    }

    else if (([(MTLDebugInstrumentationData *)a2 hasArgumentBufferInstrumentationFailures]& 1) != 0 || [(MTLDebugInstrumentationData *)a2 hasGlobalConstantsInstrumentationFailures])
    {
      if (MTLLegacySVLog(void)::onceToken != -1)
      {
        MTLLegacySVLog();
      }

      v9 = MTLLegacySVLog(void)::logObject;
      if (os_log_type_enabled(MTLLegacySVLog(void)::logObject, OS_LOG_TYPE_INFO))
      {
        v10 = [(NSString *)[(MTLLegacySVImageData *)a1 loadedImageName] UTF8String];
        if ([(MTLDebugInstrumentationData *)a2 hasArgumentBufferInstrumentationFailures])
        {
          v11 = "\n\tFaults from argument buffers will not be detected.";
        }

        else
        {
          v11 = "";
        }

        v12 = [(MTLDebugInstrumentationData *)a2 hasGlobalConstantsInstrumentationFailures];
        v15 = 136315906;
        v13 = "\n\tFaults from reading global constant variables will not be detected.";
        v16 = v4;
        if (!v12)
        {
          v13 = "";
        }

        v17 = 2080;
        v18 = v10;
        v19 = 2080;
        v20 = v11;
        v21 = 2080;
        v22 = v13;
        v6 = "Partial failure when instrumenting %s %s:%s%s";
        v7 = v9;
        v8 = 42;
        goto LABEL_19;
      }
    }
  }

  v14 = *MEMORY[0x277D85DE8];
}

void MTLLegacySVSetValidationChecksOptions(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7)
{
  v42 = *MEMORY[0x277D85DE8];
  v36 = 1;
  *c.count = "all";
  *c.hash = 1;
  *&c.hash[2] = "none";
  *&c.hash[4] = 2;
  *&v41 = 0;
  md = 0uLL;
  std::vector<std::pair<char const*,MTLLegacySVValidationState>>::__init_with_size[abi:ne200100]<std::pair<char const*,MTLLegacySVValidationState> const*,std::pair<char const*,MTLLegacySVValidationState> const*>(&md, &c, &c.hash[6], 2uLL);
  v11 = MTLGetEnvCase<MTLShaderValidationState>("MTL_SHADER_VALIDATION_DEFAULT_STATE", &v36, &md);
  if (md)
  {
    *(&md + 1) = md;
    operator delete(md);
  }

  if ((v11 & 1) == 0)
  {
    v36 = 1;
  }

  v12 = objc_opt_new();
  [v12 appendString:@"[METAL SHADER VALIDATION] Processing new pipeline"];
  if (MTLGetEnvDefault())
  {
    v13 = [a2 baseObject];
    v14 = [v13 bitCodeHash];
    data = [v13 bitcodeType];
    CC_SHA256_Init(&c);
    CC_SHA256_Update(&c, v14, 8u);
    CC_SHA256_Update(&c, [objc_msgSend(v13 "name")], objc_msgSend(objc_msgSend(v13, "name"), "length"));
    CC_SHA256_Update(&c, &data, 1u);
    if (a3)
    {
      v15 = [a3 baseObject];
      v16 = [v15 bitCodeHash];
      LOBYTE(md) = [v15 bitcodeType];
      CC_SHA256_Update(&c, v16, 8u);
      CC_SHA256_Update(&c, [objc_msgSend(v15 "name")], objc_msgSend(objc_msgSend(v15, "name"), "length"));
      CC_SHA256_Update(&c, &md, 1u);
    }

    if (a4)
    {
      v17 = [a4 baseObject];
      v18 = [v17 bitCodeHash];
      LOBYTE(md) = [v17 bitcodeType];
      CC_SHA256_Update(&c, v18, 8u);
      CC_SHA256_Update(&c, [objc_msgSend(v17 "name")], objc_msgSend(objc_msgSend(v17, "name"), "length"));
      CC_SHA256_Update(&c, &md, 1u);
    }

    CC_SHA256_Final(&md, &c);
    v37 = md;
    v38 = v41;
    v19 = _MTLRequestHashToString();
    if (a5)
    {
      [v12 appendString:{objc_msgSend(MEMORY[0x277CCACA8], "stringWithFormat:", @"\npipeline label: %@", a5)}];
    }

    [v12 appendString:{objc_msgSend(MEMORY[0x277CCACA8], "stringWithFormat:", @"\n\t{ function1: %@ - label: %@ }", objc_msgSend(a2, "name"), objc_msgSend(a2, "label"))}];
    if (a3)
    {
      [v12 appendString:{objc_msgSend(MEMORY[0x277CCACA8], "stringWithFormat:", @"\n\t{ function2: %@ - label: %@ }", objc_msgSend(a3, "name"), objc_msgSend(a3, "label"))}];
    }

    if (a4)
    {
      [v12 appendString:{objc_msgSend(MEMORY[0x277CCACA8], "stringWithFormat:", @"\n\t{ function3: %@ - label: %@ }", objc_msgSend(a4, "name"), objc_msgSend(a4, "label"))}];
    }

    [v12 appendString:{objc_msgSend(MEMORY[0x277CCACA8], "stringWithFormat:", @"\n\t{ Shader Validation UID: %@ }", v19)}];
  }

  else
  {
    v19 = 0;
  }

  v30 = v12;
  v31[0] = MEMORY[0x277D85DD0];
  v31[1] = 3221225472;
  v32 = ___ZL37MTLLegacySVSetValidationChecksOptionsP17MTLLegacySVDevicePU22objcproto11MTLFunction11objc_objectS2_S2_P8NSString19MTLShaderValidationS5_Rm_block_invoke_2;
  v33 = &unk_2787B3BF8;
  v34 = v12;
  v27[0] = MEMORY[0x277D85DD0];
  v27[1] = 3221225472;
  v28 = ___ZL37MTLLegacySVSetValidationChecksOptionsP17MTLLegacySVDevicePU22objcproto11MTLFunction11objc_objectS2_S2_P8NSString19MTLShaderValidationS5_Rm_block_invoke_3;
  v29 = &unk_2787B3BF8;
  v20 = *(a1 + 656);
  if (v20)
  {
    if (a5 && ([*(a1 + 656) containsObject:a5] & 1) != 0)
    {
      LODWORD(v20) = 1;
    }

    else if (v19)
    {
      LODWORD(v20) = [v20 containsObject:v19];
    }

    else
    {
      LODWORD(v20) = 0;
    }
  }

  v21 = *(a1 + 664);
  if (!v21)
  {
    goto LABEL_35;
  }

  if (!a5 || ([*(a1 + 664) containsObject:a5] & 1) == 0)
  {
    if (v19)
    {
      v22 = [v21 containsObject:v19];
      goto LABEL_31;
    }

LABEL_35:
    if (v20)
    {
      goto LABEL_42;
    }

    goto LABEL_36;
  }

  v22 = 1;
LABEL_31:
  if ((v20 & v22) == 1)
  {
    [v12 appendString:@"\nWarning: Pipeline requested to have shader validation checks both enabled and disabled."];
    if (v36 != 2)
    {
      if (v36 == 1)
      {
        goto LABEL_58;
      }

LABEL_59:
      *a7 |= 0x800000000uLL;
      goto LABEL_61;
    }

    goto LABEL_60;
  }

  if (v20)
  {
LABEL_42:
    if (a6 == 2)
    {
      [v12 appendString:@"\nWarning: Pipeline requested to have shader validation checks both enabled and disabled."];
    }

    if (v36 == 1)
    {
    }

    goto LABEL_58;
  }

  if (v22)
  {
    if (a6 == 1)
    {
      [v12 appendString:@"\nWarning: Pipeline requested to have shader validation checks both enabled and disabled."];
    }

    if (v36 == 2)
    {
    }

    goto LABEL_60;
  }

LABEL_36:
  if (a6 == 2)
  {
    if (v36 == 2)
    {
    }
  }

  else
  {
    if (a6 == 1)
    {
      if (v36 == 1)
      {
      }

      goto LABEL_58;
    }

    if (v36 != 2)
    {
      if (v36 == 1)
      {
LABEL_58:
        v32(v31, a7);
        goto LABEL_61;
      }

      goto LABEL_59;
    }
  }

LABEL_60:
  v28(v27, a7);
LABEL_61:
  if (MTLLegacySVLog(void)::onceToken != -1)
  {
    LegacySVMetalBufferHeap::grow();
  }

  if (os_log_type_enabled(MTLLegacySVLog(void)::logObject, OS_LOG_TYPE_DEBUG))
  {
    MTLLegacySVSetValidationChecksOptions(v12);
  }

  v23 = *MEMORY[0x277D85DE8];
}

void sub_22E189E5C(_Unwind_Exception *exception_object)
{
  v3 = *(v1 - 136);
  if (v3)
  {
    *(v1 - 128) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *DebugCompileOptions(MTLLegacySVDevice *a1, MTLCompileOptions *a2)
{
  if (a2)
  {
    v2 = [(MTLToolsDevice *)a1 unwrapMTLCompileOptions:a2];
  }

  else
  {
    v2 = objc_alloc_init(MEMORY[0x277CD6D08]);
  }

  v3 = v2;
  if ([v2 additionalCompilerArguments])
  {
    v4 = [MEMORY[0x277CCACA8] stringWithFormat:@"%@ -debug-info-kind=line-tables-only", objc_msgSend(v3, "additionalCompilerArguments")];
  }

  else
  {
    v4 = @"-debug-info-kind=line-tables-only";
  }

  [v3 setAdditionalCompilerArguments:v4];
  return v3;
}

uint64_t MTLLegacySVParsePerPSOList(const std::string *a1)
{
  v24 = *MEMORY[0x277D85DE8];
  v2 = objc_alloc_init(MEMORY[0x277CBEB58]);
  if ((a1->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v3 = a1;
  }

  else
  {
    v3 = a1->__r_.__value_.__r.__words[0];
  }

  [MEMORY[0x277CCACA8] stringWithUTF8String:v3];
  if (MTLLegacySVLog(void)::onceToken != -1)
  {
    MTLLegacySVLog();
  }

  v4 = MTLLegacySVLog(void)::logObject;
  if (os_log_type_enabled(MTLLegacySVLog(void)::logObject, OS_LOG_TYPE_DEBUG))
  {
    MTLGPUDebugParsePerPSOList();
  }

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne200100](v17, a1, 24);
  if (!*(&v19[0].__locale_ + *(v17[0] - 24)))
  {
    *&v5 = 138412290;
    v13 = v5;
    while (1)
    {
      v14 = 0;
      v15 = 0;
      v16 = 0;
      std::getline[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(v17, &v14, 0x2Cu);
      if (SHIBYTE(v16) < 0)
      {
        break;
      }

      if (HIBYTE(v16))
      {
        v10 = &v14;
LABEL_18:
        v11 = [MEMORY[0x277CCACA8] stringWithUTF8String:{v10, v13}];
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          *buf = v13;
          v23 = v11;
          _os_log_debug_impl(&dword_22E0FF000, v4, OS_LOG_TYPE_DEBUG, "[METAL SHADER VALIDATION] Storing PSO: %@", buf, 0xCu);
        }

        if (v16 >= 0)
        {
          v12 = &v14;
        }

        else
        {
          v12 = v14;
        }

        [v2 addObject:{objc_msgSend(MEMORY[0x277CCACA8], "stringWithUTF8String:", v12)}];
        if ((SHIBYTE(v16) & 0x80000000) == 0)
        {
          goto LABEL_25;
        }

        goto LABEL_24;
      }

LABEL_25:
      if (*(&v19[0].__locale_ + *(v17[0] - 24)))
      {
        goto LABEL_9;
      }
    }

    if (v15)
    {
      v10 = v14;
      goto LABEL_18;
    }

LABEL_24:
    operator delete(v14);
    goto LABEL_25;
  }

LABEL_9:
  v6 = [v2 copy];
  v17[0] = *MEMORY[0x277D82818];
  v7 = *(MEMORY[0x277D82818] + 72);
  *(v17 + *(v17[0] - 24)) = *(MEMORY[0x277D82818] + 64);
  v17[2] = v7;
  v18 = MEMORY[0x277D82878] + 16;
  if (v20 < 0)
  {
    operator delete(v19[7].__locale_);
  }

  v18 = MEMORY[0x277D82868] + 16;
  std::locale::~locale(v19);
  std::iostream::~basic_iostream();
  MEMORY[0x2318E4900](&v21);
  v8 = *MEMORY[0x277D85DE8];
  return v6;
}

void sub_22E18DEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *__p, uint64_t a5, int a6, __int16 a7, char a8, char a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, ...)
{
  va_start(va, a25);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(&a10, MEMORY[0x277D82818]);
  MEMORY[0x2318E4900](va);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne200100]<std::tuple<instrumentationHeapInit(MTLLegacySVDevice *)::$_0 &&>>(uint64_t ***a1)
{
  v1 = **a1;
  v2 = *v1;
  v3 = *v1 + 112;
  *(v3 + 136) = 0x200000;
  *(v3 + 144) = v2;
  if ((*(v2 + 286) & 0x80) != 0)
  {
    LegacySVBufferDescriptorHeap::init((v2 + 296), v2, 0xFFFFFu);
    v2 = *v1;
  }

  *(v2 + 544) = v2;
}

void std::__call_once_proxy[abi:ne200100]<std::tuple<indirectCommandBufferPipelineInit(MTLLegacySVDevice *)::$_0 &&>>(id ****a1)
{
  v1 = **a1;
  v2 = [**v1 baseObject];
  v3 = [v2 newLibraryWithURL:objc_msgSend(objc_msgSend(MEMORY[0x277CCA8D8] error:{"bundleWithIdentifier:", @"com.apple.gpusw.MetalTools", "URLForResource:withExtension:", @"MTLLegacySVICBSupport", @"metallib", 0}];
  v12 = [v3 newFunctionWithName:@"ICB_Inherit_PSO_Vertex"];
  v11 = [v3 newFunctionWithName:@"ICB_Inherit_None_Vertex"];
  v4 = [v3 newFunctionWithName:@"ICB_Inherit_Buffers_Vertex"];
  v5 = objc_alloc_init(MEMORY[0x277CD6F78]);
  [v5 setRasterizationEnabled:0];
  [v5 setSupportIndirectCommandBuffers:1];
  [v5 setVertexFunction:v12];
  *(**v1 + 88) = [v2 newRenderPipelineStateWithDescriptor:v5 error:0];
  [v5 setVertexFunction:v11];
  *(**v1 + 89) = [v2 newRenderPipelineStateWithDescriptor:v5 error:0];
  [v5 setVertexFunction:v4];
  *(**v1 + 90) = [v2 newRenderPipelineStateWithDescriptor:v5 error:0];
  v6 = [v3 newFunctionWithName:@"ICB_Inherit_PSO_Kernel"];
  v7 = [v3 newFunctionWithName:@"ICB_Inherit_None_Kernel"];
  v8 = [v3 newFunctionWithName:@"ICB_Inherit_Buffers_Kernel"];
  v9 = [v3 newFunctionWithName:@"ICB_Inherit_Both_Kernel"];
  v10 = objc_alloc_init(MEMORY[0x277CD6D30]);
  [v10 setSupportIndirectCommandBuffers:1];
  [v10 setComputeFunction:v6];
  *(**v1 + 92) = [v2 newComputePipelineStateWithDescriptor:v10 options:0 reflection:0 error:0];
  [v10 setComputeFunction:v7];
  *(**v1 + 93) = [v2 newComputePipelineStateWithDescriptor:v10 options:0 reflection:0 error:0];
  [v10 setComputeFunction:v8];
  *(**v1 + 94) = [v2 newComputePipelineStateWithDescriptor:v10 options:0 reflection:0 error:0];
  [v10 setComputeFunction:v9];
  *(**v1 + 95) = [v2 newComputePipelineStateWithDescriptor:v10 options:0 reflection:0 error:0];

  v13 = objc_alloc_init(MEMORY[0x277CD6D60]);
  [v13 setDepthWriteEnabled:0];
  [v13 setDepthCompareFunction:7];
  [objc_msgSend(v13 "frontFaceStencil")];
  [objc_msgSend(v13 "frontFaceStencil")];
  [objc_msgSend(v13 "backFaceStencil")];
  [objc_msgSend(v13 "backFaceStencil")];
  *(**v1 + 91) = [v2 newDepthStencilStateWithDescriptor:v13];
}

uint64_t std::vector<std::pair<char const*,MTLLegacySVValidationState>>::__init_with_size[abi:ne200100]<std::pair<char const*,MTLLegacySVValidationState> const*,std::pair<char const*,MTLLegacySVValidationState> const*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<std::pair<char const*,MTLShaderValidationState>>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_22E18E3B0(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<unsigned int>::__append(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  end = this->__end_;
  value = this->__end_cap_.__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(this->__end_, 4 * __n);
      end += __n;
    }

    this->__end_ = end;
  }

  else
  {
    begin = this->__begin_;
    v7 = end - this->__begin_;
    v8 = __n + (v7 >> 2);
    if (v8 >> 62)
    {
      std::vector<std::pair<char const*,MTLShaderValidationState>>::__throw_length_error[abi:ne200100]();
    }

    v9 = value - begin;
    if (v9 >> 1 > v8)
    {
      v8 = v9 >> 1;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v10 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<unsigned int>>(this, v10);
    }

    v11 = (4 * (v7 >> 2));
    bzero(v11, 4 * __n);
    memcpy(0, begin, v7);
    v12 = this->__begin_;
    this->__begin_ = 0;
    this->__end_ = &v11[4 * __n];
    this->__end_cap_.__value_ = 0;
    if (v12)
    {

      operator delete(v12);
    }
  }
}

uint64_t ___ZZL18WrapDynamicLibraryIZ60__MTLLegacySVDevice_newDynamicLibraryWithURL_options_error__E4__13EP25MTLLegacySVDynamicLibraryP17MTLLegacySVDeviceT_ENKUlS5_E_clIPU28objcproto17MTLDynamicLibrary11objc_objectEEDaS5__block_invoke(uint64_t a1)
{
  v2 = [MTLLegacySVDynamicLibrary alloc];
  v3 = *(a1 + 32);
  v4 = **(a1 + 40);

  return [(MTLLegacySVDynamicLibrary *)v2 initWithDynamicLibrary:v3 device:v4];
}

uint64_t ___ZZL18WrapDynamicLibraryIZ45__MTLLegacySVDevice_newDynamicLibrary_error__E4__14EP25MTLLegacySVDynamicLibraryP17MTLLegacySVDeviceT_ENKUlS5_E_clIPU28objcproto17MTLDynamicLibrary11objc_objectEEDaS5__block_invoke(uint64_t a1)
{
  v2 = [MTLLegacySVDynamicLibrary alloc];
  v3 = *(a1 + 32);
  v4 = **(a1 + 40);

  return [(MTLLegacySVDynamicLibrary *)v2 initWithDynamicLibrary:v3 device:v4];
}

uint64_t ___ZZL18WrapDynamicLibraryIZ63__MTLLegacySVDevice_newDynamicLibrary_computeDescriptor_error__E4__15EP25MTLLegacySVDynamicLibraryP17MTLLegacySVDeviceT_ENKUlS5_E_clIPU28objcproto17MTLDynamicLibrary11objc_objectEEDaS5__block_invoke(uint64_t a1)
{
  v2 = [MTLLegacySVDynamicLibrary alloc];
  v3 = *(a1 + 32);
  v4 = **(a1 + 40);

  return [(MTLLegacySVDynamicLibrary *)v2 initWithDynamicLibrary:v3 device:v4];
}

uint64_t ___ZZL18WrapDynamicLibraryIZ83__MTLLegacySVDevice_loadDynamicLibrariesForFunction_insertLibraries_options_error__E4__16EP25MTLLegacySVDynamicLibraryP17MTLLegacySVDeviceT_ENKUlS5_E_clIPU28objcproto17MTLDynamicLibrary11objc_objectEEDaS5__block_invoke(uint64_t a1)
{
  v2 = [MTLLegacySVDynamicLibrary alloc];
  v3 = *(a1 + 32);
  v4 = **(a1 + 40);

  return [(MTLLegacySVDynamicLibrary *)v2 initWithDynamicLibrary:v3 device:v4];
}

void emitParallellRenderEncoderDistribution(MTLTelemetryDevice *a1, MTLTelemetryStatisticUIRec *a2)
{
  v23 = *MEMORY[0x277D85DE8];
  if (*MEMORY[0x277CD7168])
  {
    if (*MEMORY[0x277CD7168] != 1)
    {
      goto LABEL_12;
    }

    count = a2->count;
    if (count)
    {
      v5 = (a2->total / count);
    }

    else
    {
      v5 = 0.0;
    }

    printf("\n\nParallellRenderEncoder, minEncodersPerParallellRender=%u, maxEncodersPerParallellRender=%u, avgEncodersPerParallellRender=%f, totalEncodersPerParallellRender=%llu, countEncodersPerParallellRender=%u", a2->min, a2->max, v5, a2->total, count);
  }

  v6 = [(MTLTelemetryDevice *)a1 telemetryLog];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    min = a2->min;
    max = a2->max;
    v9 = a2->count;
    total = a2->total;
    if (v9)
    {
      v11 = (total / v9);
    }

    else
    {
      v11 = 0.0;
    }

    *buf = 67110144;
    v14 = min;
    v15 = 1024;
    v16 = max;
    v17 = 2048;
    v18 = v11;
    v19 = 2048;
    v20 = total;
    v21 = 1024;
    v22 = v9;
    _os_log_impl(&dword_22E0FF000, v6, OS_LOG_TYPE_DEFAULT, "ParallellRenderEncoder, minEncodersPerParallellRender=%u, maxEncodersPerParallellRender=%u, avgEncodersPerParallellRender=%f, totalEncodersPerParallellRender=%llu, countEncodersPerParallellRender=%u", buf, 0x28u);
  }

LABEL_12:
  v12 = *MEMORY[0x277D85DE8];
}

unint64_t _MTLDebugValidateBlitOption(unint64_t result)
{
  if ((result > 4 || result == 3) && result != 0x20000000)
  {
    return _MTLMessageContextPush_();
  }

  return result;
}

__CFString *_MTLDebugBlitOptionString(uint64_t a1)
{
  if (!a1)
  {
    return @"MTLBlitOptionNone";
  }

  v1 = a1;
  v2 = [MEMORY[0x277CCAB68] string];
  v3 = v2;
  if (v1)
  {
    [v2 appendString:@"MTLBlitOptionDepthFromDepthStencil"];
    if ((v1 & 2) == 0)
    {
LABEL_4:
      if ((v1 & 4) == 0)
      {
        return v3;
      }

      goto LABEL_9;
    }
  }

  else if ((v1 & 2) == 0)
  {
    goto LABEL_4;
  }

  [v3 appendString:@"MTLBlitOptionStencilFromDepthStencil"];
  if ((v1 & 4) != 0)
  {
LABEL_9:
    [v3 appendString:@"MTLBlitOptionRowLinearPVRTC"];
  }

  return v3;
}

id validateResourceAliasing(uint64_t a1, uint64_t a2, int a3)
{
  result = [*a1 heap];
  if (result)
  {
    v7 = result;
    result = [*a2 heap];
    if (v7 == result)
    {
      result = *a1;
      if (*a1 != *a2)
      {
        result = [result doesAliasResource:?];
        if (result)
        {
          if ([v7 type] != 1)
          {
            return MTLReportFailure();
          }

          if (!a3)
          {
            return MTLReportFailure();
          }

          if (*(a1 + 8) != *(a2 + 8))
          {
            return MTLReportFailure();
          }

          if (*(a1 + 12) != *(a2 + 12))
          {
            return MTLReportFailure();
          }

          if (*(a1 + 20) != *(a2 + 20))
          {
            return MTLReportFailure();
          }

          if (*(a1 + 16) != *(a2 + 16))
          {
            return MTLReportFailure();
          }

          v8 = *a1;
          v9 = *a2;
          v10 = [v8 width];
          if (v10 != [v9 width])
          {
            return MTLReportFailure();
          }

          v11 = [v8 height];
          if (v11 != [v9 height])
          {
            return MTLReportFailure();
          }

          v12 = [v8 depth];
          result = [v9 depth];
          if (v12 != result)
          {
            return MTLReportFailure();
          }
        }
      }
    }
  }

  return result;
}

uint64_t _MTLDebugFindMaxTextureWidth(void *a1, void *a2)
{
  v3 = [a2 textureType];
  if (v3 <= 4)
  {
    if ((v3 - 2) >= 3)
    {
      if (v3 < 2)
      {

        return [a1 maxTextureWidth1D];
      }

LABEL_24:
      abort();
    }

    goto LABEL_17;
  }

  if (v3 > 7)
  {
    if (v3 == 8)
    {
LABEL_17:

      return [a1 maxTextureWidth2D];
    }

    if (v3 != 9)
    {
      goto LABEL_24;
    }

    return [a1 maxTextureBufferWidth];
  }

  else if ((v3 - 5) >= 2)
  {
    if (v3 != 7)
    {
      goto LABEL_24;
    }

    return [a1 maxTextureWidth3D];
  }

  else
  {

    return [a1 maxTextureDimensionCube];
  }
}

void *std::deque<objc_object *>::push_back(void *result, void *a2)
{
  v3 = result;
  v4 = *(result + 1);
  v5 = result[2];
  v6 = result[1];
  v7 = ((v5 - v6) << 6) - 1;
  if (v5 == v6)
  {
    v7 = 0;
  }

  v8 = result[5] + result[4];
  if (v7 == v8)
  {
    result = std::deque<objc_object *>::__add_back_capacity(result);
    v6 = v3[1];
    v8 = v3[5] + v3[4];
  }

  *(*(v6 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  ++v3[5];
  return result;
}

void sub_22E194730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a18)
  {
    operator delete(a18);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<unsigned long long>::push_back[abi:ne200100](const void **a1, void *a2)
{
  v5 = a1[1];
  v4 = a1[2];
  if (v5 >= v4)
  {
    v7 = *a1;
    v8 = v5 - *a1;
    v9 = (v8 >> 3) + 1;
    if (v9 >> 61)
    {
      std::vector<std::pair<char const*,MTLShaderValidationState>>::__throw_length_error[abi:ne200100]();
    }

    v10 = v4 - v7;
    if (v10 >> 2 > v9)
    {
      v9 = v10 >> 2;
    }

    v11 = v10 >= 0x7FFFFFFFFFFFFFF8;
    v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11)
    {
      v12 = v9;
    }

    if (v12)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<unsigned long>>(a1, v12);
    }

    v13 = (8 * (v8 >> 3));
    *v13 = *a2;
    v6 = v13 + 1;
    memcpy(0, v7, v8);
    v14 = *a1;
    *a1 = 0;
    a1[1] = v6;
    a1[2] = 0;
    if (v14)
    {
      operator delete(v14);
    }
  }

  else
  {
    *v5 = *a2;
    v6 = v5 + 1;
  }

  a1[1] = v6;
}

uint64_t validateTextureRegion@<X0>(void *a1@<X0>, void *a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, __int128 *a5@<X4>, __int128 *a6@<X8>)
{
  _MTLMessageContextBegin_();
  if (!a2)
  {
    _MTLMessageContextPush_();
  }

  if (([a2 conformsToProtocol:&unk_28423C818] & 1) == 0)
  {
    _MTLMessageContextPush_();
  }

  if ([a2 device] != a1)
  {
    _MTLMessageContextPush_();
  }

  if ([a2 mipmapLevelCount] <= a3)
  {
    v14 = a3;
    v18 = [a2 mipmapLevelCount];
    _MTLMessageContextPush_();
  }

  v12 = [a2 numFaces];
  if ([a2 arrayLength] * v12 <= a4)
  {
    [MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:slice:level:];
  }

  if (!(*(a5 + 4) * *(a5 + 3) * *(a5 + 5)))
  {
    v19 = *(a5 + 4);
    _MTLMessageContextPush_();
  }

  _MTLMessageContextEnd();
  *(a6 + 6) = 0;
  a6[1] = 0u;
  a6[2] = 0u;
  *a6 = 0u;
  [a1 baseObject];
  [a2 pixelFormat];
  MTLPixelFormatGetInfoForDevice();
  [a2 pixelFormat];
  [a2 width];
  [a2 height];
  [a2 depth];
  [a2 sampleCount];
  MTLGetTextureLevelInfoForDeviceWithOptions();
  v32 = *a5;
  v33 = *(a5 + 2);
  v30 = *(a5 + 24);
  v31 = *(a5 + 5);
  v26 = *a6;
  v27 = a6[1];
  v28 = a6[2];
  v29 = *(a6 + 6);
  _MTLAdjustMTLSize();
  _MTLMessageContextBegin_();
  if (*a5)
  {
    v15 = *a5;
    _MTLMessageContextPush_();
  }

  if (*(a5 + 1))
  {
    v16 = *(a5 + 1);
    _MTLMessageContextPush_();
  }

  if (*(a5 + 2))
  {
    v17 = *(a5 + 2);
    _MTLMessageContextPush_();
  }

  if ((*(a6 + 9) & 4) != 0)
  {
    if (*a5 % *(a6 + 4))
    {
      v20 = *a6;
      _MTLMessageContextPush_();
    }

    if (*(a5 + 1) % *(a6 + 5))
    {
      v21 = *a6;
      _MTLMessageContextPush_();
    }

    if (*(a5 + 2) % *(a6 + 6))
    {
      v22 = *a6;
      _MTLMessageContextPush_();
    }

    if (0uLL % *(a6 + 4))
    {
      v23 = *a6;
      _MTLMessageContextPush_();
    }

    if (0uLL % *(a6 + 5))
    {
      v24 = *a6;
      _MTLMessageContextPush_();
    }

    if (0uLL % *(a6 + 6))
    {
      v25 = *a6;
      _MTLMessageContextPush_();
    }
  }

  return _MTLMessageContextEnd();
}

uint64_t validateBlitProtectionOptions(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (([a2 protectionOptions] & ~a1) != 0)
  {
    v10 = [a2 protectionOptions];
    v11 = a1;
    v9 = a4;
    _MTLMessageContextPush_();
  }

  result = [a3 protectionOptions];
  if ((a1 & ~result) != 0)
  {
    [a3 protectionOptions];
    return _MTLMessageContextPush_();
  }

  return result;
}

void *ResourceIdentity::UnwindTexture(void *a1, MTLTextureType a2, int a3, char a4, int a5, _DWORD *a6, int *a7)
{
  v13 = a1;
  v14 = [a1 textureType];
  v15 = [v13 parentTexture];
  if (v15)
  {
    do
    {
      v16 = v15;
      a4 += [v13 parentRelativeLevel];
      a2 += [v13 parentRelativeSlice];
      v15 = [v16 parentTexture];
      v13 = v16;
    }

    while (v15);
  }

  else
  {
    v16 = v13;
  }

  *a6 = ResourceIdentity::PackViewInformation(v14, a2, a3, a4, a5, 0);
  v17 = [v16 textureType];
  v18 = [v16 arrayLength];
  v19 = [v16 mipmapLevelCount];
  if (v17 <= 6 && ((1 << v17) & 0x4A) != 0)
  {
    v20 = 0x80000000;
  }

  else
  {
    v20 = (v17 == 8) << 31;
  }

  if (v17 - 5 >= 2)
  {
    v21 = 1;
  }

  else
  {
    v21 = 6;
  }

  *a7 = (v19 - 1) & 0xF | ((v17 - 5 < 2) << 30) | v20 | (((v18 * v21) << 8) + 524032) & 0x7FF00;
  return v16;
}

unint64_t ResourceIdentity::PackViewInformation(ResourceIdentity *this, MTLTextureType a2, int a3, char a4, int a5, int a6)
{
  if (this <= 6 && ((1 << this) & 0x4A) != 0)
  {
    v6 = 0x80000000;
  }

  else
  {
    v6 = (this == 8) << 31;
  }

  v7 = this - 5 < 2;
  v8 = v7 << 30;
  if ((v7 & a6) != 0)
  {
    v9 = 6;
  }

  else
  {
    v9 = 1;
  }

  return v8 & 0xC007FF00 | ((a2 & 0x7FF) << 19) | (16 * (a4 & 0xFu)) | (a5 - 1) & 0xF | v6 | (((a3 * v9) << 8) + 524032) & 0x7FF00;
}

void *std::deque<objc_object *>::__add_back_capacity(void *a1)
{
  v1 = a1[4];
  v2 = v1 >= 0x200;
  v3 = v1 - 512;
  if (!v2)
  {
    v6 = a1[2];
    v7 = a1[3];
    v8 = v7 - *a1;
    if (v6 - a1[1] < v8)
    {
      if (v7 != v6)
      {
        operator new();
      }

      operator new();
    }

    if (v7 == *a1)
    {
      v9 = 1;
    }

    else
    {
      v9 = v8 >> 2;
    }

    v11 = a1;
    std::__allocate_at_least[abi:ne200100]<std::allocator<objc_object  {objcproto19MTLGPUDebugViewable}*>>(a1, v9);
  }

  a1[4] = v3;
  v4 = a1[1];
  *&v10 = *v4;
  a1[1] = v4 + 1;
  return std::__split_buffer<objc_object **>::emplace_back<objc_object **&>(a1, &v10);
}

void sub_22E197070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void *std::__split_buffer<objc_object **>::emplace_back<objc_object **&>(void *result, void *a2)
{
  v3 = result;
  v4 = result[2];
  if (v4 == result[3])
  {
    v5 = result[1];
    v6 = &v5[-*result];
    if (v5 <= *result)
    {
      if (v4 == *result)
      {
        v11 = 1;
      }

      else
      {
        v11 = &v4[-*result] >> 2;
      }

      std::__allocate_at_least[abi:ne200100]<std::allocator<objc_object  {objcproto19MTLGPUDebugViewable}*>>(result, v11);
    }

    v7 = ((v6 >> 3) + 1) / -2;
    v8 = ((v6 >> 3) + 1) / 2;
    v9 = &v5[-8 * v8];
    v10 = v4 - v5;
    if (v4 != v5)
    {
      result = memmove(&v5[-8 * v8], v5, v4 - v5);
      v5 = v3[1];
    }

    v4 = &v9[v10];
    v3[1] = &v5[8 * v7];
    v3[2] = &v9[v10];
  }

  *v4 = *a2;
  v3[2] += 8;
  return result;
}

const void **std::__split_buffer<objc_object **>::emplace_front<objc_object **>(const void **result, void *a2)
{
  v3 = result;
  v4 = result[1];
  if (v4 == *result)
  {
    v6 = result[2];
    v7 = result[3];
    if (v6 >= v7)
    {
      if (v7 == v4)
      {
        v9 = 1;
      }

      else
      {
        v9 = (v7 - v4) >> 2;
      }

      std::__allocate_at_least[abi:ne200100]<std::allocator<objc_object  {objcproto19MTLGPUDebugViewable}*>>(result, v9);
    }

    v8 = (((v7 - v6) >> 3) + 1) / 2;
    v5 = &v4[8 * v8];
    if (v6 != v4)
    {
      result = memmove(&v4[8 * v8], v4, v6 - v4);
      v6 = v3[2];
    }

    v3[1] = v5;
    v3[2] = &v6[8 * v8];
  }

  else
  {
    v5 = result[1];
  }

  *(v5 - 1) = *a2;
  v3[1] = v3[1] - 8;
  return result;
}

void *std::__split_buffer<objc_object **>::emplace_back<objc_object **>(void *result, void *a2)
{
  v3 = result;
  v4 = result[2];
  if (v4 == result[3])
  {
    v5 = result[1];
    v6 = &v5[-*result];
    if (v5 <= *result)
    {
      if (v4 == *result)
      {
        v11 = 1;
      }

      else
      {
        v11 = &v4[-*result] >> 2;
      }

      std::__allocate_at_least[abi:ne200100]<std::allocator<objc_object  {objcproto19MTLGPUDebugViewable}*>>(result[4], v11);
    }

    v7 = ((v6 >> 3) + 1) / -2;
    v8 = ((v6 >> 3) + 1) / 2;
    v9 = &v5[-8 * v8];
    v10 = v4 - v5;
    if (v4 != v5)
    {
      result = memmove(&v5[-8 * v8], v5, v4 - v5);
      v5 = v3[1];
    }

    v4 = &v9[v10];
    v3[1] = &v5[8 * v7];
    v3[2] = &v9[v10];
  }

  *v4 = *a2;
  v3[2] += 8;
  return result;
}

const void **std::__split_buffer<objc_object **>::emplace_front<objc_object **&>(const void **result, void *a2)
{
  v3 = result;
  v4 = result[1];
  if (v4 == *result)
  {
    v6 = result[2];
    v7 = result[3];
    if (v6 >= v7)
    {
      if (v7 == v4)
      {
        v9 = 1;
      }

      else
      {
        v9 = (v7 - v4) >> 2;
      }

      std::__allocate_at_least[abi:ne200100]<std::allocator<objc_object  {objcproto19MTLGPUDebugViewable}*>>(result[4], v9);
    }

    v8 = (((v7 - v6) >> 3) + 1) / 2;
    v5 = &v4[8 * v8];
    if (v6 != v4)
    {
      result = memmove(&v4[8 * v8], v4, v6 - v4);
      v6 = v3[2];
    }

    v3[1] = v5;
    v3[2] = &v6[8 * v8];
  }

  else
  {
    v5 = result[1];
  }

  *(v5 - 1) = *a2;
  v3[1] = v3[1] - 8;
  return result;
}

void std::__allocate_at_least[abi:ne200100]<std::allocator<_NSRange>>(uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 60))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

uint64_t std::deque<objc_object *>::~deque[abi:ne200100](void *a1)
{
  v2 = a1[1];
  v3 = a1[2];
  a1[5] = 0;
  v4 = v3 - v2;
  if (v4 >= 3)
  {
    do
    {
      operator delete(*v2);
      v3 = a1[2];
      v2 = (a1[1] + 8);
      a1[1] = v2;
      v4 = v3 - v2;
    }

    while (v4 > 2);
  }

  if (v4 == 1)
  {
    v5 = 256;
  }

  else
  {
    if (v4 != 2)
    {
      goto LABEL_9;
    }

    v5 = 512;
  }

  a1[4] = v5;
LABEL_9:
  while (v2 != v3)
  {
    v6 = *v2++;
    operator delete(v6);
  }

  return std::__split_buffer<objc_object **>::~__split_buffer(a1);
}

uint64_t std::__split_buffer<objc_object **>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  v2 = *(a1 + 16);
  if (v2 != v3)
  {
    *(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }

  v4 = *a1;
  if (*a1)
  {
    operator delete(v4);
  }

  return a1;
}

uint64_t OUTLINED_FUNCTION_4_0()
{

  return _MTLMessageContextPush_();
}

uint64_t OUTLINED_FUNCTION_5_0()
{

  return [v0 arrayLength];
}

uint64_t validateNewTexture(MTLDebugBuffer *a1, MTLTextureDescriptor *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v12 = [(MTLToolsObject *)a1 device];
  if (a2)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      validateNewTexture();
    }

    if (![(MTLTextureDescriptor *)a2 usage]&& +[MTLDebugDevice complainAboutSloppyTextureUsage])
    {
      validateNewTexture();
    }

    if ([(MTLTextureDescriptor *)a2 storageMode]== MTLStorageModeMemoryless)
    {
      validateNewTexture();
    }

    if ([(MTLTextureDescriptor *)a2 storageMode]== MTLStorageModeShared)
    {
      [(MTLDevice *)v12 originalObject];
      MTLValidateFeatureSupport();
    }
  }

  else
  {
    validateNewTexture();
  }

  [(MTLTextureDescriptor *)a2 pixelFormat];
  MTLPixelFormatGetInfoForDevice();
  [(MTLTextureDescriptor *)a2 width];
  if (!a4)
  {
    validateNewTexture();
  }

  if ([(MTLTextureDescriptor *)a2 textureType:v16]!= MTLTextureType2D && [(MTLTextureDescriptor *)a2 textureType]!= MTLTextureType2DArray && [(MTLTextureDescriptor *)a2 textureType]!= MTLTextureTypeTextureBuffer)
  {
    validateNewTexture(a2);
  }

  v13 = [(MTLTextureDescriptor *)a2 height]* a4;
  v14 = a3 - a4 + v13 * [(MTLTextureDescriptor *)a2 arrayLength];
  if (v14 > [(MTLDebugBuffer *)a1 length])
  {
    validateNewTexture(a2, a4, a3 - a4, a1);
  }

  if (((a5 - 1) & a3) != 0)
  {
    v19 = a5;
    v20 = a3;
    v17 = 0;
    MTLReportFailure();
  }

  if (((a6 - 1) & a4) != 0 && [(MTLTextureDescriptor *)a2 textureType]!= MTLTextureTypeTextureBuffer)
  {
    v19 = a6;
    v20 = a4;
    v17 = 0;
    MTLReportFailure();
  }

  result = [(MTLTextureDescriptor *)a2 usage:v17];
  if ((result & 0x20) != 0)
  {
    if (([(MTLTextureDescriptor *)a2 usage]& 3) == 0)
    {
      validateNewTexture();
    }

    result = [(MTLTextureDescriptor *)a2 pixelFormat];
    if (result != 53)
    {
      result = [(MTLTextureDescriptor *)a2 pixelFormat];
      if (result != 54)
      {
        result = [(MTLTextureDescriptor *)a2 pixelFormat];
        if (result != 103)
        {
          return validateNewTexture();
        }
      }
    }
  }

  return result;
}

void emitBufferDistribution(MTLTelemetryDevice *a1, MTLTelemetryBufferDistributionRec *a2)
{
  v22 = *MEMORY[0x277D85DE8];
  count = a2->var0.var0.count;
  if (count)
  {
    if (*MEMORY[0x277CD7168])
    {
      if (*MEMORY[0x277CD7168] != 1)
      {
        goto LABEL_10;
      }

      printf("\n\nBuffer, minLength=%u, maxLength=%u, avgLength=%f, totalLength=%llu, countLength=%u", a2->var0.var0.min, a2->var0.var0.max, (a2->var0.var0.total / count), a2->var0.var0.total, count);
    }

    v5 = [(MTLTelemetryDevice *)a1 telemetryLog];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      min = a2->var0.var0.min;
      max = a2->var0.var0.max;
      v8 = a2->var0.var0.count;
      total = a2->var0.var0.total;
      if (v8)
      {
        v10 = (total / v8);
      }

      else
      {
        v10 = 0.0;
      }

      *buf = 67110144;
      v13 = min;
      v14 = 1024;
      v15 = max;
      v16 = 2048;
      v17 = v10;
      v18 = 2048;
      v19 = total;
      v20 = 1024;
      v21 = v8;
      _os_log_impl(&dword_22E0FF000, v5, OS_LOG_TYPE_DEFAULT, "Buffer, minLength=%u, maxLength=%u, avgLength=%f, totalLength=%llu, countLength=%u", buf, 0x28u);
    }
  }

LABEL_10:
  v11 = *MEMORY[0x277D85DE8];
}

uint64_t _MTLValidateResolveTexture(void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, uint64_t *a9, char a10)
{
  if (a3 >= 0xA)
  {
    _MTLValidateResolveTexture_cold_1();
  }

  if ([a2 device] != a1)
  {
    _MTLValidateResolveTexture_cold_2();
  }

  if (![a2 textureType])
  {
    _MTLValidateResolveTexture_cold_3();
  }

  if ([a2 textureType] == 1)
  {
    _MTLValidateResolveTexture_cold_4();
  }

  if ([a2 textureType] == 4)
  {
    _MTLValidateResolveTexture_cold_5();
  }

  if ([a2 textureType] == 9)
  {
    _MTLValidateResolveTexture_cold_6();
  }

  if ([a2 storageMode] == 3)
  {
    _MTLValidateResolveTexture_cold_7();
  }

  _MTLGetAttachmentSize();
  if (a4 || a5)
  {
    _MTLValidateResolveTexture_cold_8();
  }

  v16 = [a2 pixelFormat];
  v17 = [a9 pixelFormat];
  if ((*(a2 + 80) & 0x80) != 0 || v16 == 253)
  {
    if (a10)
    {
      goto LABEL_22;
    }
  }

  else
  {
    _MTLValidateResolveTexture_cold_9((a2 + 72));
    if (a10)
    {
      goto LABEL_22;
    }
  }

  if (v17 != v16)
  {
    _MTLValidateResolveTexture_cold_10(a9 + 9, (a2 + 72));
  }

LABEL_22:
  v18 = [a2 numFaces];
  v19 = [a2 arrayLength];
  if (v19 * v18 <= a6)
  {
    v21 = a6;
    v22 = v19 * v18;
    MTLReportFailure();
  }

  if ([a2 mipmapLevelCount] <= a8)
  {
    _MTLValidateResolveTexture_cold_11(a2);
  }

  [a2 pixelFormat];
  [a2 width];
  [a2 height];
  [a2 depth];
  [a2 sampleCount];
  MTLGetTextureLevelInfoForDeviceWithOptions();
  MTLReportFailure();
  if ([a2 sampleCount] != 1)
  {
    _MTLValidateResolveTexture_cold_12(a2);
  }

  result = [a1 supportsRenderToLinearTextures];
  if ((result & 1) == 0)
  {
    result = [a2 buffer];
    if (result)
    {
      return _MTLValidateResolveTexture_cold_13();
    }
  }

  return result;
}

uint64_t _MTLValidateResolveTextureWithContext(void *a1, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, void *a9, char a10)
{
  if (a3 >= 0xA)
  {
    _MTLMessageContextPush_();
  }

  if ([a2 device] != a1)
  {
    _MTLMessageContextPush_();
  }

  if (![a2 textureType])
  {
    _MTLMessageContextPush_();
  }

  if ([a2 textureType] == 1)
  {
    _MTLMessageContextPush_();
  }

  if ([a2 textureType] == 4)
  {
    _MTLMessageContextPush_();
  }

  if ([a2 textureType] == 9)
  {
    _MTLMessageContextPush_();
  }

  if ([a2 storageMode] == 3)
  {
    _MTLMessageContextPush_();
  }

  _MTLGetAttachmentSize();
  if (a4 || a5)
  {
    _MTLMessageContextPush_();
  }

  v16 = [a2 pixelFormat];
  v17 = [a9 pixelFormat];
  v18 = a2 + 9;
  if ((a2[10] & 0x80) != 0 || v16 == 253)
  {
    if (a10)
    {
      goto LABEL_22;
    }
  }

  else
  {
    v22 = *v18;
    _MTLMessageContextPush_();
    if (a10)
    {
      goto LABEL_22;
    }
  }

  if (v17 != v16)
  {
    v22 = a9[9];
    v25 = *v18;
    _MTLMessageContextPush_();
  }

LABEL_22:
  v19 = [a2 numFaces];
  v20 = [a2 arrayLength];
  if (v20 * v19 <= a6)
  {
    v23 = a6;
    v26 = v20 * v19;
    _MTLMessageContextPush_();
  }

  if ([a2 mipmapLevelCount] <= a8)
  {
    v24 = a8;
    v27 = [a2 mipmapLevelCount];
    _MTLMessageContextPush_();
  }

  [a2 pixelFormat];
  [a2 width];
  [a2 height];
  [a2 depth];
  [a2 sampleCount];
  MTLGetTextureLevelInfoForDeviceWithOptions();
  _MTLMessageContextPush_();
  if ([a2 sampleCount] != 1)
  {
    _MTLValidateResolveTextureWithContext_cold_1(a2);
  }

  result = [a1 supportsRenderToLinearTextures];
  if ((result & 1) == 0)
  {
    result = [a2 buffer];
    if (result)
    {
      return _MTLMessageContextPush_();
    }
  }

  return result;
}

unint64_t _MTLValidateDepthStencilStoreState(unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  v6 = result;
  if (a4 && (result == 4 || a2 == 4))
  {
    return result;
  }

  if (!result || !a2)
  {
    goto LABEL_14;
  }

  v7 = 0;
  for (i = &qword_22E27C200; *(i - 1) != result; i += 2)
  {
    if (v7 >= 4)
    {
      goto LABEL_18;
    }

LABEL_12:
    ++v7;
  }

  v9 = *i;
  if (v7 <= 3 && v9 != a2)
  {
    goto LABEL_12;
  }

  if (v9 == a2)
  {
    goto LABEL_14;
  }

LABEL_18:
  result = _MTLValidateDepthStencilStoreState_cold_1(a4, result, a2);
LABEL_14:
  if ((v6 & 0xFFFFFFFFFFFFFFFELL) != 2 && a3 == 1)
  {
    return _MTLValidateDepthStencilStoreState_cold_2(a4, v6);
  }

  return result;
}

unint64_t _MTLValidateDepthStencilStoreStateWithContext(unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  v5 = result;
  if (a4 && (result == 4 || a2 == 4))
  {
    return result;
  }

  if (!result || !a2)
  {
    goto LABEL_14;
  }

  v6 = 0;
  for (i = &qword_22E27C200; *(i - 1) != result; i += 2)
  {
    if (v6 >= 4)
    {
      goto LABEL_17;
    }

LABEL_12:
    ++v6;
  }

  v8 = *i;
  if (v6 <= 3 && v8 != a2)
  {
    goto LABEL_12;
  }

  if (v8 == a2)
  {
    goto LABEL_14;
  }

LABEL_17:
  result = _MTLValidateDepthStencilStoreStateWithContext_cold_1(a4, result, a2);
LABEL_14:
  if ((v5 & 0xFFFFFFFFFFFFFFFELL) != 2 && a3 == 1)
  {
    if (v5 <= 4)
    {
      v9 = off_2787B4970[v5];
    }

    return _MTLMessageContextPush_();
  }

  return result;
}

unint64_t validateComputePassDescriptor(void *a1, void *a2)
{
  for (i = 0; i != 4; ++i)
  {
    v5 = [objc_msgSend(a1 sampleBufferAttachments];
    result = [v5 sampleBuffer];
    if (!result)
    {
      continue;
    }

    if ([a2 supportsCounterSampling:0])
    {
      v7 = [objc_msgSend(v5 "sampleBuffer")];
      if ([v5 startOfEncoderSampleIndex] != -1 && objc_msgSend(v5, "startOfEncoderSampleIndex") >= v7)
      {
        v8 = [v5 startOfEncoderSampleIndex];
        v9 = v7;
        _MTLMessageContextPush_();
      }

      result = [v5 endOfEncoderSampleIndex];
      if (result != -1)
      {
        result = [v5 endOfEncoderSampleIndex];
        if (result >= v7)
        {
          v8 = [v5 endOfEncoderSampleIndex];
          v9 = v7;
LABEL_15:
          result = _MTLMessageContextPush_();
          continue;
        }
      }
    }

    else
    {
      if ([v5 startOfEncoderSampleIndex] != -1)
      {
        _MTLMessageContextPush_();
      }

      result = [v5 endOfEncoderSampleIndex];
      if (result != -1)
      {
        goto LABEL_15;
      }
    }
  }

  return result;
}

const char *initLifetimeOptions(void)::$_0::__invoke()
{
  result = getenv("MTL_DEBUG_LAYER_VALIDATE_UNRETAINED_RESOURCES");
  if (result)
  {
    result = atoi(result);
    checkLifetimeOfExternallyReferencedObjects = result & 1;
    checkLifetimeOfInternallyReferencedObjects = (result & 2) != 0;
    checkLifetimeBeforeCommit = (result & 4) != 0;
  }

  return result;
}

void *std::__hash_table<objc_object  {objcproto25MTLDebugResourcePurgeable}*,std::hash<objc_object  {objcproto25MTLDebugResourcePurgeable}>,std::equal_to<objc_object  {objcproto25MTLDebugResourcePurgeable}>,std::allocator<objc_object  {objcproto25MTLDebugResourcePurgeable}>>::__emplace_unique_key_args<objc_object  {objcproto25MTLDebugResourcePurgeable},objc_object  {objcproto25MTLDebugResourcePurgeable}>(void *a1, void *a2)
{
  v2 = 0x9DDFEA08EB382D69 * ((8 * (*a2 & 0x1FFFFFFFLL) + 8) ^ HIDWORD(*a2));
  v3 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v2 >> 47) ^ v2);
  v4 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
  v5 = a1[1];
  if (!*&v5)
  {
    goto LABEL_18;
  }

  v6 = vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
    if (v4 >= *&v5)
    {
      v7 = v4 % *&v5;
    }
  }

  else
  {
    v7 = v4 & (*&v5 - 1);
  }

  v8 = *(*a1 + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v10 = v9[1];
    if (v10 == v4)
    {
      break;
    }

    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= *&v5)
      {
        v10 %= *&v5;
      }
    }

    else
    {
      v10 &= *&v5 - 1;
    }

    if (v10 != v7)
    {
      goto LABEL_18;
    }

LABEL_17:
    v9 = *v9;
    if (!v9)
    {
      goto LABEL_18;
    }
  }

  if (v9[2] != *a2)
  {
    goto LABEL_17;
  }

  return v9;
}

void *std::__hash_table<MTLToolsObject *,std::hash<MTLToolsObject *>,std::equal_to<MTLToolsObject *>,std::allocator<MTLToolsObject *>>::__emplace_unique_key_args<MTLToolsObject *,MTLToolsObject * const&>(void *a1, void *a2)
{
  v2 = 0x9DDFEA08EB382D69 * ((8 * (*a2 & 0x1FFFFFFFLL) + 8) ^ HIDWORD(*a2));
  v3 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v2 >> 47) ^ v2);
  v4 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
  v5 = a1[1];
  if (!*&v5)
  {
    goto LABEL_18;
  }

  v6 = vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
    if (v4 >= *&v5)
    {
      v7 = v4 % *&v5;
    }
  }

  else
  {
    v7 = v4 & (*&v5 - 1);
  }

  v8 = *(*a1 + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v10 = v9[1];
    if (v10 == v4)
    {
      break;
    }

    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= *&v5)
      {
        v10 %= *&v5;
      }
    }

    else
    {
      v10 &= *&v5 - 1;
    }

    if (v10 != v7)
    {
      goto LABEL_18;
    }

LABEL_17:
    v9 = *v9;
    if (!v9)
    {
      goto LABEL_18;
    }
  }

  if (v9[2] != *a2)
  {
    goto LABEL_17;
  }

  return v9;
}

void std::__hash_table<MTLToolsObject *,std::hash<MTLToolsObject *>,std::equal_to<MTLToolsObject *>,std::allocator<MTLToolsObject *>>::swap(uint64_t a1, uint64_t a2)
{
  v4 = *a1;
  *a1 = 0;
  v5 = *a2;
  *a2 = 0;
  v6 = *a1;
  *a1 = v5;
  if (v6)
  {
    operator delete(v6);
  }

  v7 = *a2;
  *a2 = v4;
  if (v7)
  {
    operator delete(v7);
  }

  v8 = *(a1 + 16);
  v9 = *(a1 + 8);
  v10 = *(a2 + 16);
  *(a1 + 8) = *(a2 + 8);
  *(a1 + 16) = v10;
  *(a2 + 8) = v9;
  *(a2 + 16) = v8;
  v11 = *(a1 + 24);
  *(a1 + 24) = *(a2 + 24);
  *(a2 + 24) = v11;
  v12 = *(a1 + 32);
  *(a1 + 32) = *(a2 + 32);
  *(a2 + 32) = v12;
  if (*(a1 + 24))
  {
    v13 = *(a1 + 8);
    v14 = *(*(a1 + 16) + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v14 >= v13)
      {
        v14 %= v13;
      }
    }

    else
    {
      v14 &= v13 - 1;
    }

    *(*a1 + 8 * v14) = a1 + 16;
  }

  if (v11)
  {
    v15 = *(a2 + 8);
    v16 = *(*(a2 + 16) + 8);
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v16 >= v15)
      {
        v16 %= v15;
      }
    }

    else
    {
      v16 &= v15 - 1;
    }

    *(*a2 + 8 * v16) = a2 + 16;
  }
}

uint64_t *std::__hash_table<MTLToolsObject *,std::hash<MTLToolsObject *>,std::equal_to<MTLToolsObject *>,std::allocator<MTLToolsObject *>>::__erase_unique<MTLToolsObject *>(void *a1, void *a2)
{
  if (result)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(a1, result);
    return 1;
  }

  return result;
}

void *validateBeginCommandBufferWithAllocatorCommon(uint64_t a1, void *a2, void *a3)
{
  if ([a2 currentState] == 1)
  {
    _MTLMessageContextPush_();
    if (a3)
    {
      goto LABEL_3;
    }
  }

  else if (a3)
  {
LABEL_3:
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      _MTLMessageContextPush_();
    }

    result = [a3 currentCommandBuffer];
    if (result)
    {
      return validateBeginCommandBufferWithAllocatorCommon(a2, a3, result);
    }

    return result;
  }

  return _MTLMessageContextPush_();
}

void AttachmentDescriptorSimple::AttachmentDescriptorSimple(AttachmentDescriptorSimple *this)
{
  this->sliceRange = 0u;
  this->depthPlaneRange = 0u;
  *&this->texture = 0u;
  this->storeAction = 4;
}

void AttachmentDescriptorSimple::AttachmentDescriptorSimple(AttachmentDescriptorSimple *this, const MTLRenderPassAttachmentDescriptorPrivate *a2, unint64_t a3, unint64_t a4)
{
  var1 = a2->var1;
  var2 = a2->var2;
  var0 = a2->var0;
  v11 = [a2->var0 parentTexture];
  if (v11)
  {
    do
    {
      v12 = v11;
      var1 += [var0 parentRelativeLevel];
      var2 += [var0 parentRelativeSlice];
      v11 = [v12 parentTexture];
      var0 = v12;
    }

    while (v11);
  }

  else
  {
    v12 = var0;
  }

  this->storeAction = a3;
  this->texture = v12;
  this->level = var1;
  if (a4 <= 1)
  {
    v13 = 1;
  }

  else
  {
    v13 = a4;
  }

  this->sliceRange.location = var2;
  this->sliceRange.length = v13;
  this->depthPlaneRange.location = a2->var3;
  this->depthPlaneRange.length = v13;
}

BOOL AttachmentDescriptorSimple::equal_t::operator()(uint64_t a1, NSRange *a2, NSRange *a3)
{
  if (a2->location != a3->location || a2->length != a3->length)
  {
    return 0;
  }

  v9.location = a3[1].location;
  v9.length = a3[1].length;
  length = NSIntersectionRange(a2[16], v9).length;
  v6 = NSIntersectionRange(a2[2], a3[2]);
  if (length)
  {
    v7 = v6.length == 0;
  }

  else
  {
    v7 = 1;
  }

  return !v7;
}

__CFString *_MTLStoreActionString(unint64_t a1)
{
  if (a1 > 4)
  {
    return @"Unknown";
  }

  else
  {
    return off_2787B49B0[a1];
  }
}

__CFString *_MTLLoadActionString(unint64_t a1)
{
  if (a1 > 2)
  {
    return @"Unknown";
  }

  else
  {
    return off_2787B4998[a1];
  }
}

__CFString *_MTLMultisampleDepthResolveFilterString(unint64_t a1)
{
  if (a1 > 2)
  {
    return @"Unknown";
  }

  else
  {
    return off_2787B49D8[a1];
  }
}

MTLRenderPassAttachmentDescriptorPrivate *_MTLDebugValidateStoreLoadTransitionAndTrackAttachments(void *a1, uint64_t a2, int a3, int a4, int a5, unint64_t a6)
{
  result = [a1 _descriptorPrivate];
  if (result)
  {

    validateStoreLoadTransition(a5, a2, result, a3, a4, a6);
  }

  return result;
}

void validateStoreLoadTransition(int a1, uint64_t a2, MTLRenderPassAttachmentDescriptorPrivate *a3, int a4, int a5, unint64_t a6)
{
  AttachmentDescriptorSimple::AttachmentDescriptorSimple(&v13, a3, a3->var5, a6);
  v8 = std::__hash_table<AttachmentDescriptorSimple,AttachmentDescriptorSimple::hash_t,AttachmentDescriptorSimple::equal_t,std::allocator<AttachmentDescriptorSimple>>::__equal_range_multi<AttachmentDescriptorSimple>(a2, &v13);
  if (v8 != v9)
  {
    v10 = v8;
    v11 = v9;
    do
    {
      if (v10[8])
      {
        v12 = 0;
      }

      else
      {
        v12 = a3->var4 == 1;
      }

      if (v12)
      {
        validateStoreLoadTransition(&a3->var0);
      }

      v10 = *v10;
    }

    while (v10 != v11);
  }

  std::__hash_table<AttachmentDescriptorSimple,AttachmentDescriptorSimple::hash_t,AttachmentDescriptorSimple::equal_t,std::allocator<AttachmentDescriptorSimple>>::__emplace_multi<AttachmentDescriptorSimple const&>();
}

uint64_t _MTLDebugValidateRenderPassDescriptorAndTrackAttachments(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  v128 = *MEMORY[0x277D85DE8];
  if (MTLReportFailureTypeEnabled())
  {
    memcpy(a4, a5, 0x1C0uLL);
    v7 = 0;
    memset(__src, 0, 448);
    do
    {
      v8 = &__src[v7];
      *(v8 + 1) = 0uLL;
      *(v8 + 2) = 0uLL;
      *v8 = 0uLL;
      *(v8 + 6) = 4;
      v7 += 56;
    }

    while (v7 != 448);
    memcpy(a5, __src, 0x1C0uLL);
  }

  v124 = 0;
  v122 = 0u;
  v123 = 0u;
  v121 = 0u;
  _MTLMessageContextBegin_();
  v9 = 0;
  v10 = 0;
  v119 = 0;
  v120 = 0;
  v11 = *(a1 + 48);
  v111 = -1;
  v113 = 0;
  v118 = 0;
  v117 = 1;
  memset(v115, 0, sizeof(v115));
  v116 = 1065353216;
  v12 = -1;
  do
  {
    v13 = [*a1 _descriptorAtIndex:v9];
    if (v13)
    {
      v14 = [v13 _descriptorPrivate];
      if (*v14)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          _MTLMessageContextPush_();
        }

        v15 = *v14;
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v16 = *v14;
          if (([*v14 requireUsage:4] & 1) == 0)
          {
            [v16 usage];
            v102 = 4;
            _MTLMessageContextPush_();
          }

          if (!*(a1 + 160) && (*(v14 + 48) & 1) != 0)
          {
            _MTLMessageContextPush_();
          }

          v96 = &v121;
          validateAttachmentOnDevice(a2, v14, v9, &v120, v11, &v118 + 1, &v118, *(a1 + 43), &v117);
          if (MTLReportFailureTypeEnabled())
          {
            validateStoreLoadTransition(v9, a3, v14, a4, a5, v11);
          }

          AttachmentDescriptorSimple::AttachmentDescriptorSimple(&v114, v14, *(v14 + 40), v11);
          v17 = std::__hash_table<AttachmentDescriptorSimple,AttachmentDescriptorSimple::hash_t,AttachmentDescriptorSimple::equal_t,std::allocator<AttachmentDescriptorSimple>>::find<AttachmentDescriptorSimple>(v115, &v114);
          if (v17)
          {
            length_low = LODWORD(v17[4].length);
            v96 = v9;
            _MTLMessageContextPush_();
          }

          v125 = &v114;
          LODWORD(std::__hash_table<std::__hash_value_type<AttachmentDescriptorSimple,unsigned int>,std::__unordered_map_hasher<AttachmentDescriptorSimple,std::__hash_value_type<AttachmentDescriptorSimple,unsigned int>,AttachmentDescriptorSimple::hash_t,AttachmentDescriptorSimple::equal_t,true>,std::__unordered_map_equal<AttachmentDescriptorSimple,std::__hash_value_type<AttachmentDescriptorSimple,unsigned int>,AttachmentDescriptorSimple::equal_t,AttachmentDescriptorSimple::hash_t,true>,std::allocator<std::__hash_value_type<AttachmentDescriptorSimple,unsigned int>>>::__emplace_unique_key_args<AttachmentDescriptorSimple,std::piecewise_construct_t const&,std::tuple<AttachmentDescriptorSimple const&>,std::tuple<>>(v115, &v114)[4].length) = v9;
          v126[v10] = [*v14 pixelFormat];
          v18 = &__src[56 * v10];
          v19 = *(v16 + 72);
          v20 = *(v16 + 88);
          v21 = *(v16 + 104);
          *(v18 + 6) = *(v16 + 15);
          *(v18 + 1) = v20;
          *(v18 + 2) = v21;
          *v18 = v19;
          [*v14 sampleCount];
          if (v111 >= [v16 width] >> *(v14 + 8))
          {
            v111 = [v16 width] >> *(v14 + 8);
          }

          ++v113;
          ++v10;
          if (v12 >= [v16 height] >> *(v14 + 8))
          {
            v12 = [v16 height] >> *(v14 + 8);
          }
        }
      }
    }

    ++v9;
  }

  while (v9 != 8);
  if (!v117)
  {
    _MTLMessageContextPush_();
  }

  if (HIBYTE(v118) == 1 && v118)
  {
    _MTLMessageContextPush_();
  }

  _MTLMessageContextEnd();
  v22 = [a2 maxFramebufferStorageBits];
  v23 = MTLPixelFormatComputeTotalSizeUsed();
  v24 = [a2 isLargeMRTSupported];
  if (8 * v23 <= v22)
  {
    v25 = 1;
  }

  else
  {
    v25 = v24;
  }

  if ((v25 & 1) == 0)
  {
    v86 = v23 & 0x1FFFFFFFFFFFFFFFLL;
    v95 = v22 >> 3;
    MTLReportFailure();
  }

  if (([a2 supportsSeparateVisibilityAndShadingRate] & 1) == 0)
  {
    v119 = v120;
  }

  v124 = 0;
  v122 = 0u;
  v123 = 0u;
  v121 = 0u;
  _MTLMessageContextBegin_();
  v26 = [*a1 _descriptorAtIndex:8];
  v27 = v26;
  if (v26)
  {
    v28 = [v26 _descriptorPrivate];
    v29 = *v28;
    if (*v28)
    {
      __dsta = *(v29 + 20);
      if (([v29 requireUsage:4] & 1) == 0)
      {
        [v29 usage];
        _MTLMessageContextPush_();
      }

      if (!*(a1 + 160) && (*(v28 + 48) & 1) != 0)
      {
        _MTLMessageContextPush_();
      }

      v97 = &v121;
      validateAttachmentOnDevice(a2, v28, 8uLL, &v119, v11, &v118 + 1, &v118, *(a1 + 43), &v117);
      if (v111 >= [v29 width] >> *(v28 + 8))
      {
        v111 = [v29 width] >> *(v28 + 8);
      }

      ++v113;
      if (v12 >= [v29 height] >> *(v28 + 8))
      {
        v12 = [v29 height] >> *(v28 + 8);
      }
    }

    else
    {
      __dsta = 0;
    }

    [v27 clearDepth];
    if (v30 < 0.0 || ([v27 clearDepth], v31 > 1.0))
    {
      [v27 clearDepth];
      v88 = v85;
      _MTLMessageContextPush_();
    }
  }

  else
  {
    v29 = 0;
    v28 = 0;
    __dsta = 0;
  }

  v32 = [*a1 _descriptorAtIndex:{9, v88, v97}];
  if (!v32)
  {
    v35 = 0;
    v34 = 0;
    goto LABEL_62;
  }

  v33 = [v32 _descriptorPrivate];
  v34 = v33;
  v35 = *v33;
  if (!*v33)
  {
LABEL_62:
    v108 = 0;
    goto LABEL_63;
  }

  v36 = v35[20];
  if (([*v33 requireUsage:4] & 1) == 0)
  {
    [v35 usage];
    _MTLMessageContextPush_();
  }

  texture = &v121;
  validateAttachmentOnDevice(a2, v34, 9uLL, &v119, v11, &v118 + 1, &v118, *(a1 + 43), &v117);
  if (v111 >= [v35 width] >> v34[1])
  {
    v111 = [v35 width] >> v34[1];
  }

  if (v12 >= [v35 height] >> v34[1])
  {
    v12 = [v35 height] >> v34[1];
  }

  ++v113;
  v108 = (v36 >> 5) & 1;
LABEL_63:
  if ((v117 & 1) == 0)
  {
    _MTLMessageContextPush_();
  }

  if (HIBYTE(v118) == 1 && v118)
  {
    _MTLMessageContextPush_();
  }

  _MTLMessageContextEnd();
  v37 = v111;
  if (v111 <= 1)
  {
    v37 = 1;
  }

  v105 = v37;
  if (v12 <= 1)
  {
    v38 = 1;
  }

  else
  {
    v38 = v12;
  }

  v112 = v38;
  v39 = *(a1 + 16);
  v40 = *(a1 + 24);
  v121 = 0u;
  v122 = 0u;
  v123 = 0u;
  v124 = 0;
  _MTLMessageContextBegin_();
  v41 = *(a1 + 168);
  if (v41)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      _MTLMessageContextPush_();
    }

    if (!v121)
    {
      if ([v41 device] != a2)
      {
        _MTLMessageContextPush_();
      }

      [v41 screenSize];
      if (v39 > v114.texture)
      {
        [v41 screenSize];
        v89 = v39;
        texture = v114.texture;
        _MTLMessageContextPush_();
      }

      [v41 screenSize];
      if (v40 > v114.level)
      {
        [v41 screenSize];
        v90 = v40;
        level = v114.level;
        _MTLMessageContextPush_();
      }

      if (v11 > [v41 layerCount])
      {
        v89 = v11;
        texture = [v41 layerCount];
        _MTLMessageContextPush_();
      }

      if (!v121)
      {
        memset(&v114, 0, 24);
        [v41 screenSize];
        v42 = v39 ? v39 : v114.texture;
        v43 = v40 ? v40 : v114.level;
        v104 = v43;
        if ([v41 mutability] != 1)
        {
          v44 = v42;
          v45 = 0;
          v46 = v44;
          v47 = 0.0;
          v48 = 0.0;
          while (v45 < [v41 layerCount])
          {
            *&v49 = v46;
            *&v50 = v104;
            [v41 mapScreenToPhysicalCoordinates:v45 forLayer:{v49, v50}];
            if (v47 <= v51)
            {
              v47 = v51;
            }

            if (v48 <= v52)
            {
              v48 = v52;
            }

            ++v45;
          }

          if (v113)
          {
            v83 = vcvtas_u32_f32(v47);
            if (v105 < v83)
            {
              v89 = v83;
              texture = v105;
              _MTLMessageContextPush_();
            }
          }

          if (v113)
          {
            v84 = vcvtas_u32_f32(v48);
            if (v112 < v84)
            {
              v89 = v84;
              texture = v112;
              _MTLMessageContextPush_();
            }
          }
        }
      }
    }
  }

  else
  {
    if (v39 > v105)
    {
      v89 = v39;
      texture = v105;
      _MTLMessageContextPush_();
    }

    if (v40 > v112)
    {
      v89 = v40;
      texture = v112;
      _MTLMessageContextPush_();
    }
  }

  v53 = [a2 supportsRenderPassWithoutRenderTarget];
  if ((v53 & 1) == 0)
  {
    if (v113)
    {
      goto LABEL_110;
    }

    goto LABEL_247;
  }

  if (!v113 && (!v40 || !v39))
  {
LABEL_247:
    _MTLMessageContextPush_();
  }

LABEL_110:
  if ([a2 supportsSparseDepthAttachments])
  {
    goto LABEL_125;
  }

  if ([a2 supportsMTL4PlacementSparse])
  {
    if (v29 && [v29 isSparse] && objc_msgSend(v29, "sparseTextureTier") <= 0)
    {
      _MTLMessageContextPush_();
    }

    if (v35)
    {
      if ([v35 isSparse] && objc_msgSend(v35, "sparseTextureTier") < 1)
      {
        goto LABEL_251;
      }

      goto LABEL_125;
    }

LABEL_238:
    v54 = 0;
    if (!v28)
    {
      goto LABEL_134;
    }

    goto LABEL_132;
  }

  if (v29 && [v29 isSparse])
  {
    _MTLMessageContextPush_();
  }

  if (!v35)
  {
    goto LABEL_238;
  }

  if ([v35 isSparse])
  {
LABEL_251:
    _MTLMessageContextPush_();
  }

LABEL_125:
  v54 = 0;
  if (v29 && v35)
  {
    if (([a2 supportsSeparateDepthStencil] & 1) == 0 && (v108 & ((__dsta & 0x40) >> 6) & 1) == 0)
    {
      _MTLMessageContextPush_();
    }

    v54 = 1;
  }

  if (v28)
  {
LABEL_132:
    if (v34)
    {
      _MTLValidateDepthStencilStoreStateWithContext(*(v28 + 40), v34[5], v34[13], 1);
    }
  }

LABEL_134:
  if ((v108 | (__dsta >> 6)))
  {
    if (v54)
    {
      if (v29 != v35)
      {
        _MTLMessageContextPush_();
      }

      if (*(v28 + 8) != v34[1] || *(v28 + 16) != v34[2])
      {
        _MTLMessageContextPush_();
      }

      v55 = *(v28 + 112);
      if (v55)
      {
        v56 = v34[14];
        if (v56)
        {
          if (v55 != v56)
          {
            _MTLMessageContextPush_();
          }
        }
      }
    }
  }

  else if (v54)
  {
    v57 = *(v28 + 8);
    v58 = v34[1];
    v59 = [v29 width];
    if (v59 >> v57 <= 1)
    {
      v60 = 1;
    }

    else
    {
      v60 = v59 >> v57;
    }

    v61 = [v29 height];
    if (v61 >> v57 <= 1)
    {
      v62 = 1;
    }

    else
    {
      v62 = v61 >> v57;
    }

    v63 = [v35 width];
    if (v63 >> v58 <= 1)
    {
      v64 = 1;
    }

    else
    {
      v64 = v63 >> v58;
    }

    v65 = [v35 height] >> v58;
    if (v65 <= 1)
    {
      v65 = 1;
    }

    if (v60 != v64 || v62 != v65)
    {
      v102 = v64;
      v103 = v65;
      v91 = v60;
      v100 = v62;
      _MTLMessageContextPush_();
    }
  }

  v66 = v120;
  if (v119)
  {
    v67 = v119;
  }

  else
  {
    v67 = v120;
  }

  v68 = [a2 supportsSeparateVisibilityAndShadingRate];
  v69 = *(a1 + 32);
  if (v68)
  {
    v70 = *(a1 + 72);
    v71 = v121;
    if (v69 && ([a2 supportsTextureSampleCount:*(a1 + 32)] & 1) == 0)
    {
      v92 = v69;
      _MTLMessageContextPush_();
    }

    if (v70 && ([a2 supportsTextureSampleCount:v70] & 1) == 0)
    {
      v92 = v70;
      _MTLMessageContextPush_();
    }

    if (v71 == v121)
    {
      if (v69)
      {
        v72 = v69;
      }

      else
      {
        v72 = v70;
      }

      if (!v66)
      {
        v66 = v72;
      }

      if (!v67)
      {
        v67 = v70;
      }

      if (v66 | v67)
      {
        if (v66 && v67 && v67 < v66)
        {
          _MTLMessageContextPush_();
        }

        goto LABEL_191;
      }

LABEL_249:
      _MTLMessageContextPush_();
      v66 = 0;
      v67 = 0;
    }
  }

  else
  {
    if (v69)
    {
      _MTLMessageContextPush_();
    }

    if (v113)
    {
      v73 = 0;
    }

    else
    {
      v73 = v53;
    }

    if (v73 == 1)
    {
      v66 = *(a1 + 72);
      if (!v66)
      {
        goto LABEL_249;
      }

      if (([a2 supportsTextureSampleCount:*(a1 + 72)] & 1) == 0)
      {
        v92 = v66;
        _MTLMessageContextPush_();
      }

      v67 = v66;
    }
  }

LABEL_191:
  if ((v53 & 1) == 0 && *(a1 + 72))
  {
    _MTLMessageContextPush_();
  }

  _MTLMessageContextEnd();
  v124 = 0;
  v122 = 0u;
  v123 = 0u;
  v121 = 0u;
  _MTLMessageContextBegin_();
  {
    _MTLDebugValidateRenderPassDescriptorAndTrackAttachments::is_dyld_program_sdk_at_least_fall_2025_os_versions = dyld_program_sdk_at_least();
  }

  if ((_MTLDebugValidateRenderPassDescriptorAndTrackAttachments::is_dyld_program_sdk_at_least_fall_2025_os_versions & 1) == 0)
  {
    _MTLValidateRenderPassDescriptorTileProperties();
  }

  if (v66 == 4 && *(a1 + 56) == 32 && *(a1 + 64) == 32)
  {
    _MTLMessageContextPush_();
  }

  v74 = *(a1 + 56);
  v75 = (v74 | 0x10) == 0x10 && v74 == *(a1 + 64);
  if (v66 == 8 && !v75)
  {
    _MTLMessageContextPush_();
  }

  v76 = *(a1 + 8);
  if (v76 && [v76 device] != a2)
  {
    _MTLMessageContextPush_();
  }

  v77 = *(a1 + 160);
  if (v77 && v77 != v67)
  {
    v92 = *(a1 + 160);
    v101 = v67;
    _MTLMessageContextPush_();
  }

  for (i = 0; i != 4; ++i)
  {
    v79 = [*(a1 + 176) objectAtIndexedSubscript:{i, v92, v101}];
    if ([v79 sampleBuffer])
    {
      if ([a2 supportsCounterSampling:0])
      {
        v80 = [objc_msgSend(v79 "sampleBuffer")];
        if ([v79 startOfVertexSampleIndex] != -1 && objc_msgSend(v79, "startOfVertexSampleIndex") >= v80)
        {
          v92 = [v79 startOfVertexSampleIndex];
          v101 = v80;
          _MTLMessageContextPush_();
        }

        if ([v79 endOfVertexSampleIndex] != -1 && objc_msgSend(v79, "endOfVertexSampleIndex") >= v80)
        {
          v93 = [v79 endOfVertexSampleIndex];
          v101 = v80;
          _MTLMessageContextPush_();
        }

        if ([v79 startOfFragmentSampleIndex] != -1 && objc_msgSend(v79, "startOfFragmentSampleIndex") >= v80)
        {
          v94 = [v79 startOfFragmentSampleIndex];
          v101 = v80;
          _MTLMessageContextPush_();
        }

        if ([v79 endOfFragmentSampleIndex] != -1 && objc_msgSend(v79, "endOfFragmentSampleIndex") >= v80)
        {
          v92 = [v79 endOfFragmentSampleIndex];
          v101 = v80;
          _MTLMessageContextPush_();
        }
      }

      else
      {
        if ([v79 startOfVertexSampleIndex] != -1)
        {
          _MTLMessageContextPush_();
        }

        if ([v79 endOfVertexSampleIndex] != -1)
        {
          _MTLMessageContextPush_();
        }

        if ([v79 startOfFragmentSampleIndex] != -1)
        {
          _MTLMessageContextPush_();
        }

        if ([v79 endOfFragmentSampleIndex] != -1)
        {
          _MTLMessageContextPush_();
        }
      }
    }
  }

  _MTLMessageContextEnd();
  result = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v115);
  v82 = *MEMORY[0x277D85DE8];
  return result;
}

void sub_22E1A52BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(&a27);
  _Unwind_Resume(a1);
}

void validateAttachmentOnDevice(void *a1, void **a2, unint64_t a3, uint64_t *a4, uint64_t a5, _BYTE *a6, _BYTE *a7, char a8, _BYTE *a9)
{
  if ([*a2 device] != a1)
  {
    _MTLMessageContextPush_();
  }

  [*a2 pixelFormat];
  MTLPixelFormatGetInfoForDevice();
  if ([*a2 storageMode] == 3)
  {
    if ([*a2 textureType] != 2 && objc_msgSend(*a2, "textureType") != 4 && objc_msgSend(*a2, "textureType") != 3 && objc_msgSend(*a2, "textureType") != 8)
    {
      _MTLMessageContextPush_();
    }

    if ((a2[4] & 0xFFFFFFFFFFFFFFFDLL) != 0)
    {
      _MTLMessageContextPush_();
    }

    v13 = a2[5];
    if (v13 > 4 || ((1 << v13) & 0x15) == 0)
    {
      _MTLMessageContextPush_();
    }
  }

  if (a3 <= 7)
  {
    v33 = a3;
  }

  _MTLMessageContextPush_();
  if (![*a2 textureType])
  {
    _MTLMessageContextPush_();
  }

  if ([*a2 textureType] == 1)
  {
    _MTLMessageContextPush_();
  }

  if ([*a2 textureType] == 9)
  {
    _MTLMessageContextPush_();
  }

  v14 = [*a2 numFaces];
  v15 = [*a2 arrayLength];
  v16 = v15 * v14;
  if (a2[2] >= v15 * v14)
  {
    v34 = a3;
    v37 = v15 * v14;
    v29 = a2[2];
    _MTLMessageContextPush_();
  }

  v17 = a2[1];
  if (v17 >= [*a2 mipmapLevelCount])
  {
    v28 = a2[1];
    v35 = a3;
    v38 = [*a2 mipmapLevelCount];
    v30 = v28;
    _MTLMessageContextPush_();
  }

  [*a2 pixelFormat];
  [*a2 width];
  [*a2 height];
  [*a2 depth];
  [*a2 sampleCount];
  v18 = a2[1];
  MTLGetTextureLevelInfoForDeviceWithOptions();
  v36 = 0;
  v39 = a2[1];
  v31 = a2[3];
  _MTLMessageContextPush_();
  if (a5)
  {
    if ([*a2 textureType] == 7)
    {
      if ((a2[3] + a5))
      {
        v36 = 0;
        v39 = a2[1];
        v31 = a2[3] + a5;
        _MTLMessageContextPush_();
      }

      v19 = a6;
    }

    else
    {
      if (a2[2] + a5 > v16)
      {
        v31 = a2[2] + a5;
        v36 = v16;
        _MTLMessageContextPush_();
      }

      v19 = a7;
    }

    *v19 = 1;
  }

  v20 = (a2 + 5);
  if ((a2[5] & 0xFFFFFFFFFFFFFFFELL) == 2)
  {
    if (a3 == 9)
    {
      if ([a1 supportsMSAAStencilResolve])
      {
        goto LABEL_43;
      }

      v21 = *v20;
      if (*v20 <= 4)
      {
LABEL_41:
        v22 = off_2787B49B0[v21];
LABEL_89:
        v31 = [(__CFString *)v22 UTF8String:v31];
        _MTLMessageContextPush_();
        goto LABEL_43;
      }
    }

    else
    {
      if (a3 != 8 || ([a1 supportsMSAADepthResolve] & 1) != 0)
      {
LABEL_43:
        if (!a2[14])
        {
          validateAttachmentOnDevice(a2 + 5);
        }

        goto LABEL_45;
      }

      v21 = *v20;
      if (*v20 < 5)
      {
        goto LABEL_41;
      }
    }

    v22 = @"Unknown";
    goto LABEL_89;
  }

LABEL_45:
  if (a3 == 8)
  {
    if (a2[18] && ([a1 supportsMSAADepthResolveFilter] & 1) == 0)
    {
      validateAttachmentOnDevice(a2 + 18);
    }
  }

  else if (a3 == 9 && a2[13] == 1 && ([a1 supportsMSAAStencilResolveFilter] & 1) == 0)
  {
    _MTLMessageContextPush_();
  }

  v23 = *a2;
  v24 = a2[1];
  _MTLGetAttachmentSize();
  v25 = [*a2 sampleCount];
  if (!*a4 || v25 == *a4)
  {
    *a4 = v25;
  }

  else
  {
    *a9 = 0;
  }

  if (([a1 supportsRenderToLinearTextures] & 1) == 0 && objc_msgSend(*a2, "buffer"))
  {
    v32 = a3;
    _MTLMessageContextPush_();
  }

  if (a2[14])
  {
    if ((*v20 - 2) >= 3)
    {
      _MTLMessageContextPush_();
    }

    if ([*a2 textureType] != 4 && objc_msgSend(*a2, "textureType") != 8)
    {
      _MTLMessageContextPush_();
    }

    if ([*a2 sampleCount] <= 1)
    {
      validateAttachmentOnDevice(a2);
    }

    _MTLValidateResolveTextureWithContext(a1, a2[14], a3, 0, 0, a2[16], a2[17], a2[15], *a2, a8);
  }

  if (a2[6])
  {
    if (a3 == 8)
    {
      v26 = @"the depth attachment";
    }

    else
    {
      v26 = @"the stencil attachment";
    }

    if ((a3 & 0xFFFFFFFFFFFFFFFELL) != 8)
    {
      v26 = [objc_alloc(MEMORY[0x277CCACA8]) initWithFormat:@"color attachment %lu", a3];
    }

    if (([a1 areProgrammableSamplePositionsSupported] & 1) == 0)
    {
      _MTLMessageContextPush_();
    }

    v27 = *v20;
    if (*v20 > 2)
    {
      if ((v27 - 3) >= 2)
      {
LABEL_81:
        _MTLMessageContextPush_();
      }
    }

    else if (v27 != 1)
    {
      goto LABEL_81;
    }
  }
}

uint64_t std::__hash_table<AttachmentDescriptorSimple,AttachmentDescriptorSimple::hash_t,AttachmentDescriptorSimple::equal_t,std::allocator<AttachmentDescriptorSimple>>::__equal_range_multi<AttachmentDescriptorSimple>(uint64_t a1, NSRange *a2)
{
  v3 = std::__hash_table<AttachmentDescriptorSimple,AttachmentDescriptorSimple::hash_t,AttachmentDescriptorSimple::equal_t,std::allocator<AttachmentDescriptorSimple>>::find<AttachmentDescriptorSimple>(a1, a2);
  v4 = v3;
  if (v3)
  {
    v5 = v3;
    do
    {
      v5 = v5->location;
      if (!v5)
      {
        break;
      }

      LOBYTE(v3) = AttachmentDescriptorSimple::equal_t::operator()(v3, v5 + 1, a2);
    }

    while ((v3 & 1) != 0);
  }

  return v4;
}

NSRange *std::__hash_table<AttachmentDescriptorSimple,AttachmentDescriptorSimple::hash_t,AttachmentDescriptorSimple::equal_t,std::allocator<AttachmentDescriptorSimple>>::find<AttachmentDescriptorSimple>(uint64_t a1, NSRange *a2)
{
  v2 = *(a1 + 8);
  if (!*&v2)
  {
    return 0;
  }

  v4 = a2->length ^ a2->location;
  v5 = vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  v6 = v5.u32[0];
  if (v5.u32[0] > 1uLL)
  {
    v7 = a2->length ^ a2->location;
    if (v4 >= *&v2)
    {
      v7 = v4 % *&v2;
    }
  }

  else
  {
    v7 = (*&v2 - 1) & v4;
  }

  v8 = *(*a1 + 8 * v7);
  if (!v8)
  {
    return 0;
  }

  for (i = *v8; i; i = i->location)
  {
    length = i->length;
    if (length == v4)
    {
      LOBYTE(a1) = AttachmentDescriptorSimple::equal_t::operator()(a1, i + 1, a2);
      if (a1)
      {
        return i;
      }
    }

    else
    {
      if (v6 > 1)
      {
        if (length >= *&v2)
        {
          length %= *&v2;
        }
      }

      else
      {
        length &= *&v2 - 1;
      }

      if (length != v7)
      {
        return 0;
      }
    }
  }

  return i;
}

NSRange *std::__hash_table<AttachmentDescriptorSimple,AttachmentDescriptorSimple::hash_t,AttachmentDescriptorSimple::equal_t,std::allocator<AttachmentDescriptorSimple>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, NSRange *a3)
{
  v5 = a1;
  v6 = *(a1 + 8);
  v7 = (*(a1 + 24) + 1);
  v8 = *(a1 + 32);
  if (!v6 || (v8 * v6) < v7)
  {
    v9 = 1;
    if (v6 >= 3)
    {
      v9 = (v6 & (v6 - 1)) != 0;
    }

    v10 = v9 | (2 * v6);
    v11 = vcvtps_u32_f32(v7 / v8);
    if (v10 <= v11)
    {
      v12 = v11;
    }

    else
    {
      v12 = v10;
    }

    std::__hash_table<AttachmentDescriptorSimple,AttachmentDescriptorSimple::hash_t,AttachmentDescriptorSimple::equal_t,std::allocator<AttachmentDescriptorSimple>>::__rehash<false>(a1, v12);
    v6 = v5[1];
  }

  v13 = vcnt_s8(v6);
  v13.i16[0] = vaddlv_u8(v13);
  v14 = v13.u32[0];
  if (v13.u32[0] > 1uLL)
  {
    v15 = a2;
    if (v6 <= a2)
    {
      v15 = a2 % v6;
    }
  }

  else
  {
    v15 = (v6 - 1) & a2;
  }

  v16 = *(*v5 + 8 * v15);
  if (v16)
  {
    location = v16->location;
    if (v16->location)
    {
      v18 = 0;
      do
      {
        length = location->length;
        if (v14 > 1)
        {
          v20 = location->length;
          if (length >= v6)
          {
            v20 = length % v6;
          }
        }

        else
        {
          v20 = length & (v6 - 1);
        }

        if (v20 != v15)
        {
          break;
        }

        if (length == a2)
        {
          LODWORD(a1) = AttachmentDescriptorSimple::equal_t::operator()(a1, location + 1, a3);
        }

        else
        {
          a1 = 0;
        }

        if ((v18 & (a1 != (v18 & 1))) != 0)
        {
          break;
        }

        v18 |= a1 != (v18 & 1);
        v16 = v16->location;
        location = v16->location;
      }

      while (v16->location);
    }
  }

  return v16;
}