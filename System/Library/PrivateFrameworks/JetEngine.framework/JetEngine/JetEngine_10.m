uint64_t BrotliCompressFragmentTwoPassImpl12(uint64_t result, char *__src, unint64_t a3, unsigned __int8 *a4, unsigned __int8 *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  v86 = result;
  if (!a3)
  {
    return result;
  }

  v9 = __dst;
  v92 = __src + 4;
  v11 = __src;
  do
  {
    if (a3 >= 0x20000)
    {
      v12 = 0x20000;
    }

    else
    {
      v12 = a3;
    }

    v13 = &v11[v12];
    v14 = a4;
    v15 = v9;
    v16 = v11;
    v89 = a3;
    v17 = a3 - 16;
    v91 = &v11[v12];
    if (a3 < 0x10)
    {
      goto LABEL_86;
    }

    v88 = v12;
    if (v12 - 4 < v17)
    {
      v17 = v12 - 4;
    }

    v16 = v11;
    v18 = &v11[v17];
    v19 = v13 - 4;
    v20 = -1;
    v14 = a4;
    v15 = v9;
    v87 = v16;
    v93 = v13 - 4;
    do
    {
LABEL_10:
      v22 = v16 + 1;
      v21 = *(v16 + 1);
      for (i = 32; ; ++i)
      {
        v24 = v22 + (i >> 5);
        if (v24 > v18)
        {
          goto LABEL_84;
        }

        v25 = (0x1E35A7BD00000000 * v21) >> 52;
        v21 = *v24;
        v26 = v22 - v20;
        if (*v22 != *v26 || v20 < 1)
        {
          v26 = &__src[*(a6 + 4 * v25)];
          *(a6 + 4 * v25) = v22 - __src;
          if (*v22 != *v26)
          {
            goto LABEL_19;
          }
        }

        else
        {
          *(a6 + 4 * v25) = v22 - __src;
        }

        v28 = v22 - v26;
        if (v22 - v26 <= 262128)
        {
          break;
        }

LABEL_19:
        v22 = v24;
      }

      v29 = (v26 + 4);
      v30 = (v22 + 1);
      v31 = v19 - v22;
      if ((v19 - v22) < 8)
      {
        v35 = (v26 + 4);
        if (v31)
        {
LABEL_27:
          v36 = &v35[v31];
          while (*v35 == *v30)
          {
            ++v30;
            ++v35;
            if (!--v31)
            {
              v35 = v36;
              break;
            }
          }
        }
      }

      else
      {
        v32 = 0;
        do
        {
          v33 = *&v30[v32];
          v34 = *&v29[v32];
          if (v33 != v34)
          {
            v37 = (v32 + (__clz(__rbit64(v34 ^ v33)) >> 3));
            goto LABEL_33;
          }

          v31 -= 8;
          v32 += 8;
        }

        while (v31 > 7);
        v35 = &v29[v32];
        v30 += v32;
        if (v31)
        {
          goto LABEL_27;
        }
      }

      v37 = (v35 - v29);
LABEL_33:
      v38 = v22 - v16;
      v94 = v37;
      if ((v22 - v16) >= 6)
      {
        if (v38 > 0x81)
        {
          if (v38 > 0x841)
          {
            if (v38 >> 1 > 0xC20)
            {
              if (v38 > 0x5841)
              {
                v42 = -5784041;
              }

              else
              {
                v42 = -1589738;
              }

              v39 = (v38 << 8) + v42;
            }

            else
            {
              v39 = (v38 << 8) - 541163;
            }
          }

          else
          {
            v41 = __clz(v38 - 66) ^ 0x1F;
            v39 = (v41 | (((-1 << v41) + v38 - 66) << 8)) + 10;
          }
        }

        else
        {
          v40 = (__clz(v38 - 2) ^ 0x1F) - 1;
          v39 = (((v38 - 2) >> v40) + 2 * v40 + 2) | ((v38 - 2 - ((v38 - 2) >> v40 << v40)) << 8);
        }
      }

      else
      {
        v39 = v22 - v16;
      }

      *v14 = v39;
      v43 = v15;
      memcpy(v15, v16, v38);
      if (v20 == v28)
      {
        v44 = 64;
      }

      else
      {
        v45 = __clz(v28 + 3) ^ 0x1F;
        v44 = (((v28 + 3 - ((((v28 + 3) >> (v45 - 1)) & 1 | 2) << (v45 - 1))) << 8) | (2 * v45) | ((v28 + 3) >> (v45 - 1)) & 1) + 76;
        v20 = v28;
      }

      v46 = (v94 + 4);
      v14[1] = v44;
      if ((v94 + 4) > 0xB)
      {
        if (v46 > 0x47)
        {
          if (v46 > 0x87)
          {
            if (v46 > 0x847)
            {
              v49 = (v46 << 8) - 542657;
            }

            else
            {
              v50 = __clz(v94 - 68) ^ 0x1F;
              v49 = (v50 | (((-1 << v50) + v94 - 68) << 8)) + 52;
            }
          }

          else
          {
            v49 = (((v94 - 4) >> 5) + 54) | (((v94 - 4) & 0x1F) << 8);
          }

          v14[2] = v49;
          v14[3] = 64;
          v47 = 16;
        }

        else
        {
          v48 = (__clz(v94 - 4) ^ 0x1F) - 1;
          v14[2] = (((v94 - 4) >> v48) + 2 * v48 + 28) | ((v94 - 4 - ((v94 - 4) >> v48 << v48)) << 8);
          v47 = 12;
        }
      }

      else
      {
        v14[2] = v94 + 24;
        v47 = 12;
      }

      v16 = v22 + v46;
      v15 = &v43[v38];
      v14 = (v14 + v47);
      if (v22 + v46 >= v18)
      {
LABEL_84:
        v9 = __dst;
        goto LABEL_85;
      }

      v51 = *(v16 - 3);
      *(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 50) & 0x3FFC)) = v16 - __src - 2;
      *(a6 + (((0x1E35A7BD00000000 * v51) >> 50) & 0x3FFC)) = v16 - __src - 1;
      v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 50) & 0x3FFC;
      v53 = *(a6 + v52);
      *(a6 + v52) = v16 - __src;
      v54 = v16 - &__src[v53];
      v19 = v93;
    }

    while (v54 >= 262129 || *v16 != *&__src[v53]);
    while (1)
    {
      v55 = &v92[v53];
      v56 = (v16 + 4);
      v57 = v93 - v16;
      if ((v93 - v16) < 8)
      {
        v61 = v55;
        if (v57)
        {
LABEL_68:
          v62 = &v61[v57];
          while (*v61 == *v56)
          {
            ++v56;
            ++v61;
            if (!--v57)
            {
              v61 = v62;
              break;
            }
          }
        }
      }

      else
      {
        v58 = 0;
        do
        {
          v59 = *&v56[v58];
          v60 = *&v55[v58];
          if (v59 != v60)
          {
            v63 = (v58 + (__clz(__rbit64(v60 ^ v59)) >> 3));
            goto LABEL_74;
          }

          v57 -= 8;
          v58 += 8;
        }

        while (v57 > 7);
        v61 = &v55[v58];
        v56 += v58;
        if (v57)
        {
          goto LABEL_68;
        }
      }

      v63 = (v61 - v55);
LABEL_74:
      v64 = (v63 + 4);
      if ((v63 + 4) > 9)
      {
        v66 = (v64 << 8) - 542145;
        v67 = __clz(v63 - 66) ^ 0x1F;
        if (v64 <= 0x845)
        {
          v66 = (v67 | (((-1 << v67) + v63 - 66) << 8)) + 52;
        }

        v68 = v63 - 2;
        v69 = (__clz(v68) ^ 0x1F) - 1;
        v65 = ((v68 >> v69) + 2 * v69 + 44) | ((v68 - (v68 >> v69 << v69)) << 8);
        if (v64 > 0x85)
        {
          v65 = v66;
        }
      }

      else
      {
        v65 = v63 + 42;
      }

      v16 += v64;
      v20 = v54;
      v70 = v54 + 3;
      v71 = __clz(v70);
      *v14 = v65;
      v14[1] = (((v70 - (((v70 >> ((v71 ^ 0x1F) - 1)) & 1 | 2) << ((v71 ^ 0x1F) - 1))) << 8) | (2 * (v71 ^ 0x1F)) | (v70 >> ((v71 ^ 0x1F) - 1)) & 1) + 76;
      v14 += 2;
      if (v16 >= v18)
      {
        break;
      }

      v72 = *(v16 - 3);
      *(a6 + (((0x1E35A7BD00000000 * v72) >> 50) & 0x3FFC)) = v16 - __src - 3;
      *(a6 + (((506832829 * ((v72 << 24) & 0xFFFFFFFF00000000)) >> 50) & 0x3FFC)) = v16 - __src - 2;
      *(a6 + (((506832829 * ((v72 << 16) & 0xFFFFFFFF00000000)) >> 50) & 0x3FFC)) = v16 - __src - 1;
      v73 = ((506832829 * ((v72 << 8) & 0xFFFFFFFF00000000)) >> 50) & 0x3FFC;
      v53 = *(a6 + v73);
      *(a6 + v73) = v16 - __src;
      v54 = v16 - &__src[v53];
      if (v54 >= 262129 || *v16 != *&__src[v53])
      {
        goto LABEL_10;
      }
    }

    v9 = __dst;
LABEL_85:
    v11 = v87;
    v12 = v88;
    v13 = v91;
LABEL_86:
    if (v16 >= v13)
    {
      v76 = v86;
    }

    else
    {
      v74 = v13 - v16;
      if ((v13 - v16) >= 6)
      {
        v77 = (v74 << 8) - 1589738;
        if (v74 > 0x5841)
        {
          v77 = (v74 << 8) - 5784041;
        }

        if (v74 >> 1 <= 0xC20)
        {
          v75 = (v74 << 8) - 541163;
        }

        else
        {
          v75 = v77;
        }

        v78 = __clz(v74 - 66) ^ 0x1F;
        if (v74 <= 0x841)
        {
          v75 = (v78 | (((-1 << v78) + v74 - 66) << 8)) + 10;
        }

        v79 = (__clz(v74 - 2) ^ 0x1F) - 1;
        if (v74 <= 0x81)
        {
          v75 = (((v74 - 2) >> v79) + 2 * v79 + 2) | ((v74 - 2 - ((v74 - 2) >> v79 << v79)) << 8);
        }
      }

      else
      {
        v75 = v13 - v16;
      }

      *v14++ = v75;
      v80 = v15;
      memcpy(v15, v16, v74);
      v15 = &v80[v74];
      v9 = __dst;
      v76 = v86;
    }

    v81 = v15 - v9;
    if (ShouldCompress(v76, v11, v12, v15 - v9))
    {
      BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
      v82 = *a7;
      *(a8 + (*a7 >> 3)) = *(a8 + (*a7 >> 3));
      *a7 = v82 + 13;
      result = StoreCommands(v86, v9, v81, a4, (v14 - a4) >> 2, a7, a8);
    }

    else
    {
      result = EmitUncompressedMetaBlock(v11, v12, a7, a8);
    }

    v11 = v91;
    a3 = v89 - v12;
  }

  while (v89 != v12);
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl13(uint64_t result, char *__src, unint64_t a3, unsigned __int8 *a4, unsigned __int8 *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  v86 = result;
  if (!a3)
  {
    return result;
  }

  v9 = __dst;
  v92 = __src + 4;
  v11 = __src;
  do
  {
    if (a3 >= 0x20000)
    {
      v12 = 0x20000;
    }

    else
    {
      v12 = a3;
    }

    v13 = &v11[v12];
    v14 = a4;
    v15 = v9;
    v16 = v11;
    v89 = a3;
    v17 = a3 - 16;
    v91 = &v11[v12];
    if (a3 < 0x10)
    {
      goto LABEL_86;
    }

    v88 = v12;
    if (v12 - 4 < v17)
    {
      v17 = v12 - 4;
    }

    v16 = v11;
    v18 = &v11[v17];
    v19 = v13 - 4;
    v20 = -1;
    v14 = a4;
    v15 = v9;
    v87 = v16;
    v93 = v13 - 4;
    do
    {
LABEL_10:
      v22 = v16 + 1;
      v21 = *(v16 + 1);
      for (i = 32; ; ++i)
      {
        v24 = v22 + (i >> 5);
        if (v24 > v18)
        {
          goto LABEL_84;
        }

        v25 = (0x1E35A7BD00000000 * v21) >> 51;
        v21 = *v24;
        v26 = v22 - v20;
        if (*v22 != *v26 || v20 < 1)
        {
          v26 = &__src[*(a6 + 4 * v25)];
          *(a6 + 4 * v25) = v22 - __src;
          if (*v22 != *v26)
          {
            goto LABEL_19;
          }
        }

        else
        {
          *(a6 + 4 * v25) = v22 - __src;
        }

        v28 = v22 - v26;
        if (v22 - v26 <= 262128)
        {
          break;
        }

LABEL_19:
        v22 = v24;
      }

      v29 = (v26 + 4);
      v30 = (v22 + 1);
      v31 = v19 - v22;
      if ((v19 - v22) < 8)
      {
        v35 = (v26 + 4);
        if (v31)
        {
LABEL_27:
          v36 = &v35[v31];
          while (*v35 == *v30)
          {
            ++v30;
            ++v35;
            if (!--v31)
            {
              v35 = v36;
              break;
            }
          }
        }
      }

      else
      {
        v32 = 0;
        do
        {
          v33 = *&v30[v32];
          v34 = *&v29[v32];
          if (v33 != v34)
          {
            v37 = (v32 + (__clz(__rbit64(v34 ^ v33)) >> 3));
            goto LABEL_33;
          }

          v31 -= 8;
          v32 += 8;
        }

        while (v31 > 7);
        v35 = &v29[v32];
        v30 += v32;
        if (v31)
        {
          goto LABEL_27;
        }
      }

      v37 = (v35 - v29);
LABEL_33:
      v38 = v22 - v16;
      v94 = v37;
      if ((v22 - v16) >= 6)
      {
        if (v38 > 0x81)
        {
          if (v38 > 0x841)
          {
            if (v38 >> 1 > 0xC20)
            {
              if (v38 > 0x5841)
              {
                v42 = -5784041;
              }

              else
              {
                v42 = -1589738;
              }

              v39 = (v38 << 8) + v42;
            }

            else
            {
              v39 = (v38 << 8) - 541163;
            }
          }

          else
          {
            v41 = __clz(v38 - 66) ^ 0x1F;
            v39 = (v41 | (((-1 << v41) + v38 - 66) << 8)) + 10;
          }
        }

        else
        {
          v40 = (__clz(v38 - 2) ^ 0x1F) - 1;
          v39 = (((v38 - 2) >> v40) + 2 * v40 + 2) | ((v38 - 2 - ((v38 - 2) >> v40 << v40)) << 8);
        }
      }

      else
      {
        v39 = v22 - v16;
      }

      *v14 = v39;
      v43 = v15;
      memcpy(v15, v16, v38);
      if (v20 == v28)
      {
        v44 = 64;
      }

      else
      {
        v45 = __clz(v28 + 3) ^ 0x1F;
        v44 = (((v28 + 3 - ((((v28 + 3) >> (v45 - 1)) & 1 | 2) << (v45 - 1))) << 8) | (2 * v45) | ((v28 + 3) >> (v45 - 1)) & 1) + 76;
        v20 = v28;
      }

      v46 = (v94 + 4);
      v14[1] = v44;
      if ((v94 + 4) > 0xB)
      {
        if (v46 > 0x47)
        {
          if (v46 > 0x87)
          {
            if (v46 > 0x847)
            {
              v49 = (v46 << 8) - 542657;
            }

            else
            {
              v50 = __clz(v94 - 68) ^ 0x1F;
              v49 = (v50 | (((-1 << v50) + v94 - 68) << 8)) + 52;
            }
          }

          else
          {
            v49 = (((v94 - 4) >> 5) + 54) | (((v94 - 4) & 0x1F) << 8);
          }

          v14[2] = v49;
          v14[3] = 64;
          v47 = 16;
        }

        else
        {
          v48 = (__clz(v94 - 4) ^ 0x1F) - 1;
          v14[2] = (((v94 - 4) >> v48) + 2 * v48 + 28) | ((v94 - 4 - ((v94 - 4) >> v48 << v48)) << 8);
          v47 = 12;
        }
      }

      else
      {
        v14[2] = v94 + 24;
        v47 = 12;
      }

      v16 = v22 + v46;
      v15 = &v43[v38];
      v14 = (v14 + v47);
      if (v22 + v46 >= v18)
      {
LABEL_84:
        v9 = __dst;
        goto LABEL_85;
      }

      v51 = *(v16 - 3);
      *(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 49) & 0x7FFC)) = v16 - __src - 2;
      *(a6 + (((0x1E35A7BD00000000 * v51) >> 49) & 0x7FFC)) = v16 - __src - 1;
      v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 49) & 0x7FFC;
      v53 = *(a6 + v52);
      *(a6 + v52) = v16 - __src;
      v54 = v16 - &__src[v53];
      v19 = v93;
    }

    while (v54 >= 262129 || *v16 != *&__src[v53]);
    while (1)
    {
      v55 = &v92[v53];
      v56 = (v16 + 4);
      v57 = v93 - v16;
      if ((v93 - v16) < 8)
      {
        v61 = v55;
        if (v57)
        {
LABEL_68:
          v62 = &v61[v57];
          while (*v61 == *v56)
          {
            ++v56;
            ++v61;
            if (!--v57)
            {
              v61 = v62;
              break;
            }
          }
        }
      }

      else
      {
        v58 = 0;
        do
        {
          v59 = *&v56[v58];
          v60 = *&v55[v58];
          if (v59 != v60)
          {
            v63 = (v58 + (__clz(__rbit64(v60 ^ v59)) >> 3));
            goto LABEL_74;
          }

          v57 -= 8;
          v58 += 8;
        }

        while (v57 > 7);
        v61 = &v55[v58];
        v56 += v58;
        if (v57)
        {
          goto LABEL_68;
        }
      }

      v63 = (v61 - v55);
LABEL_74:
      v64 = (v63 + 4);
      if ((v63 + 4) > 9)
      {
        v66 = (v64 << 8) - 542145;
        v67 = __clz(v63 - 66) ^ 0x1F;
        if (v64 <= 0x845)
        {
          v66 = (v67 | (((-1 << v67) + v63 - 66) << 8)) + 52;
        }

        v68 = v63 - 2;
        v69 = (__clz(v68) ^ 0x1F) - 1;
        v65 = ((v68 >> v69) + 2 * v69 + 44) | ((v68 - (v68 >> v69 << v69)) << 8);
        if (v64 > 0x85)
        {
          v65 = v66;
        }
      }

      else
      {
        v65 = v63 + 42;
      }

      v16 += v64;
      v20 = v54;
      v70 = v54 + 3;
      v71 = __clz(v70);
      *v14 = v65;
      v14[1] = (((v70 - (((v70 >> ((v71 ^ 0x1F) - 1)) & 1 | 2) << ((v71 ^ 0x1F) - 1))) << 8) | (2 * (v71 ^ 0x1F)) | (v70 >> ((v71 ^ 0x1F) - 1)) & 1) + 76;
      v14 += 2;
      if (v16 >= v18)
      {
        break;
      }

      v72 = *(v16 - 3);
      *(a6 + (((0x1E35A7BD00000000 * v72) >> 49) & 0x7FFC)) = v16 - __src - 3;
      *(a6 + (((506832829 * ((v72 << 24) & 0xFFFFFFFF00000000)) >> 49) & 0x7FFC)) = v16 - __src - 2;
      *(a6 + (((506832829 * ((v72 << 16) & 0xFFFFFFFF00000000)) >> 49) & 0x7FFC)) = v16 - __src - 1;
      v73 = ((506832829 * ((v72 << 8) & 0xFFFFFFFF00000000)) >> 49) & 0x7FFC;
      v53 = *(a6 + v73);
      *(a6 + v73) = v16 - __src;
      v54 = v16 - &__src[v53];
      if (v54 >= 262129 || *v16 != *&__src[v53])
      {
        goto LABEL_10;
      }
    }

    v9 = __dst;
LABEL_85:
    v11 = v87;
    v12 = v88;
    v13 = v91;
LABEL_86:
    if (v16 >= v13)
    {
      v76 = v86;
    }

    else
    {
      v74 = v13 - v16;
      if ((v13 - v16) >= 6)
      {
        v77 = (v74 << 8) - 1589738;
        if (v74 > 0x5841)
        {
          v77 = (v74 << 8) - 5784041;
        }

        if (v74 >> 1 <= 0xC20)
        {
          v75 = (v74 << 8) - 541163;
        }

        else
        {
          v75 = v77;
        }

        v78 = __clz(v74 - 66) ^ 0x1F;
        if (v74 <= 0x841)
        {
          v75 = (v78 | (((-1 << v78) + v74 - 66) << 8)) + 10;
        }

        v79 = (__clz(v74 - 2) ^ 0x1F) - 1;
        if (v74 <= 0x81)
        {
          v75 = (((v74 - 2) >> v79) + 2 * v79 + 2) | ((v74 - 2 - ((v74 - 2) >> v79 << v79)) << 8);
        }
      }

      else
      {
        v75 = v13 - v16;
      }

      *v14++ = v75;
      v80 = v15;
      memcpy(v15, v16, v74);
      v15 = &v80[v74];
      v9 = __dst;
      v76 = v86;
    }

    v81 = v15 - v9;
    if (ShouldCompress(v76, v11, v12, v15 - v9))
    {
      BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
      v82 = *a7;
      *(a8 + (*a7 >> 3)) = *(a8 + (*a7 >> 3));
      *a7 = v82 + 13;
      result = StoreCommands(v86, v9, v81, a4, (v14 - a4) >> 2, a7, a8);
    }

    else
    {
      result = EmitUncompressedMetaBlock(v11, v12, a7, a8);
    }

    v11 = v91;
    a3 = v89 - v12;
  }

  while (v89 != v12);
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl14(uint64_t result, char *__src, unint64_t a3, unsigned __int8 *a4, unsigned __int8 *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  v86 = result;
  if (!a3)
  {
    return result;
  }

  v9 = __dst;
  v92 = __src + 4;
  v11 = __src;
  do
  {
    if (a3 >= 0x20000)
    {
      v12 = 0x20000;
    }

    else
    {
      v12 = a3;
    }

    v13 = &v11[v12];
    v14 = a4;
    v15 = v9;
    v16 = v11;
    v89 = a3;
    v17 = a3 - 16;
    v91 = &v11[v12];
    if (a3 < 0x10)
    {
      goto LABEL_86;
    }

    v88 = v12;
    if (v12 - 4 < v17)
    {
      v17 = v12 - 4;
    }

    v16 = v11;
    v18 = &v11[v17];
    v19 = v13 - 4;
    v20 = -1;
    v14 = a4;
    v15 = v9;
    v87 = v16;
    v93 = v13 - 4;
    do
    {
LABEL_10:
      v22 = v16 + 1;
      v21 = *(v16 + 1);
      for (i = 32; ; ++i)
      {
        v24 = v22 + (i >> 5);
        if (v24 > v18)
        {
          goto LABEL_84;
        }

        v25 = (0x1E35A7BD00000000 * v21) >> 50;
        v21 = *v24;
        v26 = v22 - v20;
        if (*v22 != *v26 || v20 < 1)
        {
          v26 = &__src[*(a6 + 4 * v25)];
          *(a6 + 4 * v25) = v22 - __src;
          if (*v22 != *v26)
          {
            goto LABEL_19;
          }
        }

        else
        {
          *(a6 + 4 * v25) = v22 - __src;
        }

        v28 = v22 - v26;
        if (v22 - v26 <= 262128)
        {
          break;
        }

LABEL_19:
        v22 = v24;
      }

      v29 = (v26 + 4);
      v30 = (v22 + 1);
      v31 = v19 - v22;
      if ((v19 - v22) < 8)
      {
        v35 = (v26 + 4);
        if (v31)
        {
LABEL_27:
          v36 = &v35[v31];
          while (*v35 == *v30)
          {
            ++v30;
            ++v35;
            if (!--v31)
            {
              v35 = v36;
              break;
            }
          }
        }
      }

      else
      {
        v32 = 0;
        do
        {
          v33 = *&v30[v32];
          v34 = *&v29[v32];
          if (v33 != v34)
          {
            v37 = (v32 + (__clz(__rbit64(v34 ^ v33)) >> 3));
            goto LABEL_33;
          }

          v31 -= 8;
          v32 += 8;
        }

        while (v31 > 7);
        v35 = &v29[v32];
        v30 += v32;
        if (v31)
        {
          goto LABEL_27;
        }
      }

      v37 = (v35 - v29);
LABEL_33:
      v38 = v22 - v16;
      v94 = v37;
      if ((v22 - v16) >= 6)
      {
        if (v38 > 0x81)
        {
          if (v38 > 0x841)
          {
            if (v38 >> 1 > 0xC20)
            {
              if (v38 > 0x5841)
              {
                v42 = -5784041;
              }

              else
              {
                v42 = -1589738;
              }

              v39 = (v38 << 8) + v42;
            }

            else
            {
              v39 = (v38 << 8) - 541163;
            }
          }

          else
          {
            v41 = __clz(v38 - 66) ^ 0x1F;
            v39 = (v41 | (((-1 << v41) + v38 - 66) << 8)) + 10;
          }
        }

        else
        {
          v40 = (__clz(v38 - 2) ^ 0x1F) - 1;
          v39 = (((v38 - 2) >> v40) + 2 * v40 + 2) | ((v38 - 2 - ((v38 - 2) >> v40 << v40)) << 8);
        }
      }

      else
      {
        v39 = v22 - v16;
      }

      *v14 = v39;
      v43 = v15;
      memcpy(v15, v16, v38);
      if (v20 == v28)
      {
        v44 = 64;
      }

      else
      {
        v45 = __clz(v28 + 3) ^ 0x1F;
        v44 = (((v28 + 3 - ((((v28 + 3) >> (v45 - 1)) & 1 | 2) << (v45 - 1))) << 8) | (2 * v45) | ((v28 + 3) >> (v45 - 1)) & 1) + 76;
        v20 = v28;
      }

      v46 = (v94 + 4);
      v14[1] = v44;
      if ((v94 + 4) > 0xB)
      {
        if (v46 > 0x47)
        {
          if (v46 > 0x87)
          {
            if (v46 > 0x847)
            {
              v49 = (v46 << 8) - 542657;
            }

            else
            {
              v50 = __clz(v94 - 68) ^ 0x1F;
              v49 = (v50 | (((-1 << v50) + v94 - 68) << 8)) + 52;
            }
          }

          else
          {
            v49 = (((v94 - 4) >> 5) + 54) | (((v94 - 4) & 0x1F) << 8);
          }

          v14[2] = v49;
          v14[3] = 64;
          v47 = 16;
        }

        else
        {
          v48 = (__clz(v94 - 4) ^ 0x1F) - 1;
          v14[2] = (((v94 - 4) >> v48) + 2 * v48 + 28) | ((v94 - 4 - ((v94 - 4) >> v48 << v48)) << 8);
          v47 = 12;
        }
      }

      else
      {
        v14[2] = v94 + 24;
        v47 = 12;
      }

      v16 = v22 + v46;
      v15 = &v43[v38];
      v14 = (v14 + v47);
      if (v22 + v46 >= v18)
      {
LABEL_84:
        v9 = __dst;
        goto LABEL_85;
      }

      v51 = *(v16 - 3);
      *(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 48) & 0xFFFC)) = v16 - __src - 2;
      *(a6 + (((0x1E35A7BD00000000 * v51) >> 48) & 0xFFFC)) = v16 - __src - 1;
      v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 48) & 0xFFFC;
      v53 = *(a6 + v52);
      *(a6 + v52) = v16 - __src;
      v54 = v16 - &__src[v53];
      v19 = v93;
    }

    while (v54 >= 262129 || *v16 != *&__src[v53]);
    while (1)
    {
      v55 = &v92[v53];
      v56 = (v16 + 4);
      v57 = v93 - v16;
      if ((v93 - v16) < 8)
      {
        v61 = v55;
        if (v57)
        {
LABEL_68:
          v62 = &v61[v57];
          while (*v61 == *v56)
          {
            ++v56;
            ++v61;
            if (!--v57)
            {
              v61 = v62;
              break;
            }
          }
        }
      }

      else
      {
        v58 = 0;
        do
        {
          v59 = *&v56[v58];
          v60 = *&v55[v58];
          if (v59 != v60)
          {
            v63 = (v58 + (__clz(__rbit64(v60 ^ v59)) >> 3));
            goto LABEL_74;
          }

          v57 -= 8;
          v58 += 8;
        }

        while (v57 > 7);
        v61 = &v55[v58];
        v56 += v58;
        if (v57)
        {
          goto LABEL_68;
        }
      }

      v63 = (v61 - v55);
LABEL_74:
      v64 = (v63 + 4);
      if ((v63 + 4) > 9)
      {
        v66 = (v64 << 8) - 542145;
        v67 = __clz(v63 - 66) ^ 0x1F;
        if (v64 <= 0x845)
        {
          v66 = (v67 | (((-1 << v67) + v63 - 66) << 8)) + 52;
        }

        v68 = v63 - 2;
        v69 = (__clz(v68) ^ 0x1F) - 1;
        v65 = ((v68 >> v69) + 2 * v69 + 44) | ((v68 - (v68 >> v69 << v69)) << 8);
        if (v64 > 0x85)
        {
          v65 = v66;
        }
      }

      else
      {
        v65 = v63 + 42;
      }

      v16 += v64;
      v20 = v54;
      v70 = v54 + 3;
      v71 = __clz(v70);
      *v14 = v65;
      v14[1] = (((v70 - (((v70 >> ((v71 ^ 0x1F) - 1)) & 1 | 2) << ((v71 ^ 0x1F) - 1))) << 8) | (2 * (v71 ^ 0x1F)) | (v70 >> ((v71 ^ 0x1F) - 1)) & 1) + 76;
      v14 += 2;
      if (v16 >= v18)
      {
        break;
      }

      v72 = *(v16 - 3);
      *(a6 + (((0x1E35A7BD00000000 * v72) >> 48) & 0xFFFC)) = v16 - __src - 3;
      *(a6 + (((506832829 * ((v72 << 24) & 0xFFFFFFFF00000000)) >> 48) & 0xFFFC)) = v16 - __src - 2;
      *(a6 + (((506832829 * ((v72 << 16) & 0xFFFFFFFF00000000)) >> 48) & 0xFFFC)) = v16 - __src - 1;
      v73 = ((506832829 * ((v72 << 8) & 0xFFFFFFFF00000000)) >> 48) & 0xFFFC;
      v53 = *(a6 + v73);
      *(a6 + v73) = v16 - __src;
      v54 = v16 - &__src[v53];
      if (v54 >= 262129 || *v16 != *&__src[v53])
      {
        goto LABEL_10;
      }
    }

    v9 = __dst;
LABEL_85:
    v11 = v87;
    v12 = v88;
    v13 = v91;
LABEL_86:
    if (v16 >= v13)
    {
      v76 = v86;
    }

    else
    {
      v74 = v13 - v16;
      if ((v13 - v16) >= 6)
      {
        v77 = (v74 << 8) - 1589738;
        if (v74 > 0x5841)
        {
          v77 = (v74 << 8) - 5784041;
        }

        if (v74 >> 1 <= 0xC20)
        {
          v75 = (v74 << 8) - 541163;
        }

        else
        {
          v75 = v77;
        }

        v78 = __clz(v74 - 66) ^ 0x1F;
        if (v74 <= 0x841)
        {
          v75 = (v78 | (((-1 << v78) + v74 - 66) << 8)) + 10;
        }

        v79 = (__clz(v74 - 2) ^ 0x1F) - 1;
        if (v74 <= 0x81)
        {
          v75 = (((v74 - 2) >> v79) + 2 * v79 + 2) | ((v74 - 2 - ((v74 - 2) >> v79 << v79)) << 8);
        }
      }

      else
      {
        v75 = v13 - v16;
      }

      *v14++ = v75;
      v80 = v15;
      memcpy(v15, v16, v74);
      v15 = &v80[v74];
      v9 = __dst;
      v76 = v86;
    }

    v81 = v15 - v9;
    if (ShouldCompress(v76, v11, v12, v15 - v9))
    {
      BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
      v82 = *a7;
      *(a8 + (*a7 >> 3)) = *(a8 + (*a7 >> 3));
      *a7 = v82 + 13;
      result = StoreCommands(v86, v9, v81, a4, (v14 - a4) >> 2, a7, a8);
    }

    else
    {
      result = EmitUncompressedMetaBlock(v11, v12, a7, a8);
    }

    v11 = v91;
    a3 = v89 - v12;
  }

  while (v89 != v12);
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl15(uint64_t result, char *__src, unint64_t a3, unsigned __int8 *a4, unsigned __int8 *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  v86 = result;
  if (!a3)
  {
    return result;
  }

  v9 = __dst;
  v92 = __src + 4;
  v11 = __src;
  do
  {
    if (a3 >= 0x20000)
    {
      v12 = 0x20000;
    }

    else
    {
      v12 = a3;
    }

    v13 = &v11[v12];
    v14 = a4;
    v15 = v9;
    v16 = v11;
    v89 = a3;
    v17 = a3 - 16;
    v91 = &v11[v12];
    if (a3 < 0x10)
    {
      goto LABEL_86;
    }

    v88 = v12;
    if (v12 - 4 < v17)
    {
      v17 = v12 - 4;
    }

    v16 = v11;
    v18 = &v11[v17];
    v19 = v13 - 4;
    v20 = -1;
    v14 = a4;
    v15 = v9;
    v87 = v16;
    v93 = v13 - 4;
    do
    {
LABEL_10:
      v22 = v16 + 1;
      v21 = *(v16 + 1);
      for (i = 32; ; ++i)
      {
        v24 = v22 + (i >> 5);
        if (v24 > v18)
        {
          goto LABEL_84;
        }

        v25 = (0x1E35A7BD00000000 * v21) >> 49;
        v21 = *v24;
        v26 = v22 - v20;
        if (*v22 != *v26 || v20 < 1)
        {
          v26 = &__src[*(a6 + 4 * v25)];
          *(a6 + 4 * v25) = v22 - __src;
          if (*v22 != *v26)
          {
            goto LABEL_19;
          }
        }

        else
        {
          *(a6 + 4 * v25) = v22 - __src;
        }

        v28 = v22 - v26;
        if (v22 - v26 <= 262128)
        {
          break;
        }

LABEL_19:
        v22 = v24;
      }

      v29 = (v26 + 4);
      v30 = (v22 + 1);
      v31 = v19 - v22;
      if ((v19 - v22) < 8)
      {
        v35 = (v26 + 4);
        if (v31)
        {
LABEL_27:
          v36 = &v35[v31];
          while (*v35 == *v30)
          {
            ++v30;
            ++v35;
            if (!--v31)
            {
              v35 = v36;
              break;
            }
          }
        }
      }

      else
      {
        v32 = 0;
        do
        {
          v33 = *&v30[v32];
          v34 = *&v29[v32];
          if (v33 != v34)
          {
            v37 = (v32 + (__clz(__rbit64(v34 ^ v33)) >> 3));
            goto LABEL_33;
          }

          v31 -= 8;
          v32 += 8;
        }

        while (v31 > 7);
        v35 = &v29[v32];
        v30 += v32;
        if (v31)
        {
          goto LABEL_27;
        }
      }

      v37 = (v35 - v29);
LABEL_33:
      v38 = v22 - v16;
      v94 = v37;
      if ((v22 - v16) >= 6)
      {
        if (v38 > 0x81)
        {
          if (v38 > 0x841)
          {
            if (v38 >> 1 > 0xC20)
            {
              if (v38 > 0x5841)
              {
                v42 = -5784041;
              }

              else
              {
                v42 = -1589738;
              }

              v39 = (v38 << 8) + v42;
            }

            else
            {
              v39 = (v38 << 8) - 541163;
            }
          }

          else
          {
            v41 = __clz(v38 - 66) ^ 0x1F;
            v39 = (v41 | (((-1 << v41) + v38 - 66) << 8)) + 10;
          }
        }

        else
        {
          v40 = (__clz(v38 - 2) ^ 0x1F) - 1;
          v39 = (((v38 - 2) >> v40) + 2 * v40 + 2) | ((v38 - 2 - ((v38 - 2) >> v40 << v40)) << 8);
        }
      }

      else
      {
        v39 = v22 - v16;
      }

      *v14 = v39;
      v43 = v15;
      memcpy(v15, v16, v38);
      if (v20 == v28)
      {
        v44 = 64;
      }

      else
      {
        v45 = __clz(v28 + 3) ^ 0x1F;
        v44 = (((v28 + 3 - ((((v28 + 3) >> (v45 - 1)) & 1 | 2) << (v45 - 1))) << 8) | (2 * v45) | ((v28 + 3) >> (v45 - 1)) & 1) + 76;
        v20 = v28;
      }

      v46 = (v94 + 4);
      v14[1] = v44;
      if ((v94 + 4) > 0xB)
      {
        if (v46 > 0x47)
        {
          if (v46 > 0x87)
          {
            if (v46 > 0x847)
            {
              v49 = (v46 << 8) - 542657;
            }

            else
            {
              v50 = __clz(v94 - 68) ^ 0x1F;
              v49 = (v50 | (((-1 << v50) + v94 - 68) << 8)) + 52;
            }
          }

          else
          {
            v49 = (((v94 - 4) >> 5) + 54) | (((v94 - 4) & 0x1F) << 8);
          }

          v14[2] = v49;
          v14[3] = 64;
          v47 = 16;
        }

        else
        {
          v48 = (__clz(v94 - 4) ^ 0x1F) - 1;
          v14[2] = (((v94 - 4) >> v48) + 2 * v48 + 28) | ((v94 - 4 - ((v94 - 4) >> v48 << v48)) << 8);
          v47 = 12;
        }
      }

      else
      {
        v14[2] = v94 + 24;
        v47 = 12;
      }

      v16 = v22 + v46;
      v15 = &v43[v38];
      v14 = (v14 + v47);
      if (v22 + v46 >= v18)
      {
LABEL_84:
        v9 = __dst;
        goto LABEL_85;
      }

      v51 = *(v16 - 3);
      *(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 47) & 0x1FFFC)) = v16 - __src - 2;
      *(a6 + (((0x1E35A7BD00000000 * v51) >> 47) & 0x1FFFC)) = v16 - __src - 1;
      v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 47) & 0x1FFFC;
      v53 = *(a6 + v52);
      *(a6 + v52) = v16 - __src;
      v54 = v16 - &__src[v53];
      v19 = v93;
    }

    while (v54 >= 262129 || *v16 != *&__src[v53]);
    while (1)
    {
      v55 = &v92[v53];
      v56 = (v16 + 4);
      v57 = v93 - v16;
      if ((v93 - v16) < 8)
      {
        v61 = v55;
        if (v57)
        {
LABEL_68:
          v62 = &v61[v57];
          while (*v61 == *v56)
          {
            ++v56;
            ++v61;
            if (!--v57)
            {
              v61 = v62;
              break;
            }
          }
        }
      }

      else
      {
        v58 = 0;
        do
        {
          v59 = *&v56[v58];
          v60 = *&v55[v58];
          if (v59 != v60)
          {
            v63 = (v58 + (__clz(__rbit64(v60 ^ v59)) >> 3));
            goto LABEL_74;
          }

          v57 -= 8;
          v58 += 8;
        }

        while (v57 > 7);
        v61 = &v55[v58];
        v56 += v58;
        if (v57)
        {
          goto LABEL_68;
        }
      }

      v63 = (v61 - v55);
LABEL_74:
      v64 = (v63 + 4);
      if ((v63 + 4) > 9)
      {
        v66 = (v64 << 8) - 542145;
        v67 = __clz(v63 - 66) ^ 0x1F;
        if (v64 <= 0x845)
        {
          v66 = (v67 | (((-1 << v67) + v63 - 66) << 8)) + 52;
        }

        v68 = v63 - 2;
        v69 = (__clz(v68) ^ 0x1F) - 1;
        v65 = ((v68 >> v69) + 2 * v69 + 44) | ((v68 - (v68 >> v69 << v69)) << 8);
        if (v64 > 0x85)
        {
          v65 = v66;
        }
      }

      else
      {
        v65 = v63 + 42;
      }

      v16 += v64;
      v20 = v54;
      v70 = v54 + 3;
      v71 = __clz(v70);
      *v14 = v65;
      v14[1] = (((v70 - (((v70 >> ((v71 ^ 0x1F) - 1)) & 1 | 2) << ((v71 ^ 0x1F) - 1))) << 8) | (2 * (v71 ^ 0x1F)) | (v70 >> ((v71 ^ 0x1F) - 1)) & 1) + 76;
      v14 += 2;
      if (v16 >= v18)
      {
        break;
      }

      v72 = *(v16 - 3);
      *(a6 + (((0x1E35A7BD00000000 * v72) >> 47) & 0x1FFFC)) = v16 - __src - 3;
      *(a6 + (((506832829 * ((v72 << 24) & 0xFFFFFFFF00000000)) >> 47) & 0x1FFFC)) = v16 - __src - 2;
      *(a6 + (((506832829 * ((v72 << 16) & 0xFFFFFFFF00000000)) >> 47) & 0x1FFFC)) = v16 - __src - 1;
      v73 = ((506832829 * ((v72 << 8) & 0xFFFFFFFF00000000)) >> 47) & 0x1FFFC;
      v53 = *(a6 + v73);
      *(a6 + v73) = v16 - __src;
      v54 = v16 - &__src[v53];
      if (v54 >= 262129 || *v16 != *&__src[v53])
      {
        goto LABEL_10;
      }
    }

    v9 = __dst;
LABEL_85:
    v11 = v87;
    v12 = v88;
    v13 = v91;
LABEL_86:
    if (v16 >= v13)
    {
      v76 = v86;
    }

    else
    {
      v74 = v13 - v16;
      if ((v13 - v16) >= 6)
      {
        v77 = (v74 << 8) - 1589738;
        if (v74 > 0x5841)
        {
          v77 = (v74 << 8) - 5784041;
        }

        if (v74 >> 1 <= 0xC20)
        {
          v75 = (v74 << 8) - 541163;
        }

        else
        {
          v75 = v77;
        }

        v78 = __clz(v74 - 66) ^ 0x1F;
        if (v74 <= 0x841)
        {
          v75 = (v78 | (((-1 << v78) + v74 - 66) << 8)) + 10;
        }

        v79 = (__clz(v74 - 2) ^ 0x1F) - 1;
        if (v74 <= 0x81)
        {
          v75 = (((v74 - 2) >> v79) + 2 * v79 + 2) | ((v74 - 2 - ((v74 - 2) >> v79 << v79)) << 8);
        }
      }

      else
      {
        v75 = v13 - v16;
      }

      *v14++ = v75;
      v80 = v15;
      memcpy(v15, v16, v74);
      v15 = &v80[v74];
      v9 = __dst;
      v76 = v86;
    }

    v81 = v15 - v9;
    if (ShouldCompress(v76, v11, v12, v15 - v9))
    {
      BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
      v82 = *a7;
      *(a8 + (*a7 >> 3)) = *(a8 + (*a7 >> 3));
      *a7 = v82 + 13;
      result = StoreCommands(v86, v9, v81, a4, (v14 - a4) >> 2, a7, a8);
    }

    else
    {
      result = EmitUncompressedMetaBlock(v11, v12, a7, a8);
    }

    v11 = v91;
    a3 = v89 - v12;
  }

  while (v89 != v12);
  return result;
}

char *BrotliCompressFragmentTwoPassImpl16(char *result, char *__src, unint64_t a3, unsigned __int8 *a4, unsigned __int8 *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  v89 = result;
  if (a3)
  {
    v9 = __dst;
    v11 = __src;
    do
    {
      if (a3 >= 0x20000)
      {
        v12 = 0x20000;
      }

      else
      {
        v12 = a3;
      }

      v13 = &v11[v12];
      v14 = a4;
      v15 = v9;
      v16 = v11;
      v91 = a3;
      v17 = a3 - 16;
      v94 = &v11[v12];
      if (a3 >= 0x10)
      {
        v90 = v12;
        if (v12 - 6 < v17)
        {
          v17 = v12 - 6;
        }

        v15 = v9;
        v18 = &v11[v17];
        v19 = v13 - 6;
        v20 = -1;
        v14 = a4;
        v93 = v11;
        v16 = v11;
        v95 = v13 - 6;
LABEL_10:
        v21 = v16 + 1;
        v22 = (0x1E35A7BD0000 * *(v16 + 1)) >> 48;
        v23 = 32;
        while (1)
        {
          v24 = &v21[v23 >> 5];
          if (v24 > v18)
          {
            break;
          }

          ++v23;
          while (1)
          {
            v25 = v21;
            v26 = v22;
            v21 = v24;
            v22 = (0x1E35A7BD0000 * *v24) >> 48;
            v27 = &v25[-v20];
            if (*v25 == *v27 && v25[4] == v27[4] && v25[5] == v27[5] && v20 >= 1)
            {
              break;
            }

            v27 = &__src[*(a6 + 4 * v26)];
            *(a6 + 4 * v26) = v25 - __src;
            if (*v25 == *v27 && v25[4] == v27[4] && v25[5] == v27[5])
            {
              goto LABEL_25;
            }

            v24 = &v21[v23++ >> 5];
            if (v24 > v18)
            {
              goto LABEL_93;
            }
          }

          *(a6 + 4 * v26) = v25 - __src;
LABEL_25:
          v29 = v25 - v27;
          if (v25 - v27 <= 262128)
          {
            v30 = v27 + 6;
            v31 = (v25 + 6);
            v32 = v19 - v25;
            if ((v19 - v25) < 8)
            {
              v36 = (v27 + 6);
              if (v32)
              {
LABEL_33:
                v37 = &v36[v32];
                while (*v36 == *v31)
                {
                  ++v31;
                  ++v36;
                  if (!--v32)
                  {
                    v36 = v37;
                    break;
                  }
                }
              }
            }

            else
            {
              v33 = 0;
              do
              {
                v34 = *&v31[v33];
                v35 = *&v30[v33];
                if (v34 != v35)
                {
                  v38 = (v33 + (__clz(__rbit64(v35 ^ v34)) >> 3));
                  goto LABEL_39;
                }

                v32 -= 8;
                v33 += 8;
              }

              while (v32 > 7);
              v36 = &v30[v33];
              v31 += v33;
              if (v32)
              {
                goto LABEL_33;
              }
            }

            v38 = (v36 - v30);
LABEL_39:
            v39 = v25 - v16;
            v96 = v38;
            if ((v25 - v16) >= 6)
            {
              if (v39 > 0x81)
              {
                if (v39 > 0x841)
                {
                  if (v39 >> 1 > 0xC20)
                  {
                    if (v39 > 0x5841)
                    {
                      v43 = -5784041;
                    }

                    else
                    {
                      v43 = -1589738;
                    }

                    v40 = (v39 << 8) + v43;
                  }

                  else
                  {
                    v40 = (v39 << 8) - 541163;
                  }
                }

                else
                {
                  v42 = __clz(v39 - 66) ^ 0x1F;
                  v40 = (v42 | (((-1 << v42) + v39 - 66) << 8)) + 10;
                }
              }

              else
              {
                v41 = (__clz(v39 - 2) ^ 0x1F) - 1;
                v40 = (((v39 - 2) >> v41) + 2 * v41 + 2) | ((v39 - 2 - ((v39 - 2) >> v41 << v41)) << 8);
              }
            }

            else
            {
              v40 = v25 - v16;
            }

            *v14 = v40;
            v44 = v15;
            memcpy(v15, v16, v39);
            if (v20 == v29)
            {
              v45 = 64;
            }

            else
            {
              v46 = __clz(v29 + 3) ^ 0x1F;
              v45 = (((v29 + 3 - ((((v29 + 3) >> (v46 - 1)) & 1 | 2) << (v46 - 1))) << 8) | (2 * v46) | ((v29 + 3) >> (v46 - 1)) & 1) + 76;
              v20 = v29;
            }

            v47 = (v96 + 6);
            v14[1] = v45;
            if ((v96 + 6) > 0xB)
            {
              if (v47 > 0x47)
              {
                if (v47 > 0x87)
                {
                  if (v47 > 0x847)
                  {
                    v50 = (v47 << 8) - 542657;
                  }

                  else
                  {
                    v51 = __clz(v96 - 66) ^ 0x1F;
                    v50 = (v51 | (((-1 << v51) + v96 - 66) << 8)) + 52;
                  }
                }

                else
                {
                  v50 = (((v96 - 2) >> 5) + 54) | (((v96 - 2) & 0x1F) << 8);
                }

                v14[2] = v50;
                v14[3] = 64;
                v48 = 16;
              }

              else
              {
                v49 = (__clz(v96 - 2) ^ 0x1F) - 1;
                v14[2] = (((v96 - 2) >> v49) + 2 * v49 + 28) | ((v96 - 2 - ((v96 - 2) >> v49 << v49)) << 8);
                v48 = 12;
              }
            }

            else
            {
              v14[2] = v96 + 26;
              v48 = 12;
            }

            v16 = &v25[v47];
            v15 = &v44[v39];
            v14 = (v14 + v48);
            if (&v25[v47] < v18)
            {
              v52 = *(v16 - 5);
              *(a6 + (((0x1E35A7BD0000 * v52) >> 46) & 0x3FFFC)) = v16 - __src - 5;
              *(a6 + (((506832829 * ((v52 << 8) & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16 - __src - 4;
              *(a6 + (((506832829 * (v52 & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16 - __src - 3;
              v53 = *(v16 - 2);
              *(a6 + (((0x1E35A7BD0000 * v53) >> 46) & 0x3FFFC)) = v16 - __src - 2;
              *(a6 + (((506832829 * ((v53 << 8) & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16 - __src - 1;
              v54 = ((506832829 * (v53 & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC;
              v55 = *(a6 + v54);
              *(a6 + v54) = v16 - __src;
              v56 = &__src[v55];
              LODWORD(v57) = v16 - v56;
              v19 = v95;
              if (v16 - v56 < 262129 && *v16 == *v56)
              {
                v11 = v93;
                while (1)
                {
                  v58 = v57;
                  if (v16[4] != v56[4] || v16[5] != v56[5])
                  {
                    break;
                  }

                  v59 = v56 + 6;
                  v60 = (v16 + 6);
                  v61 = v95 - v16;
                  if ((v95 - v16) < 8)
                  {
                    v65 = v59;
                    if (v61)
                    {
LABEL_77:
                      v66 = &v65[v61];
                      while (*v65 == *v60)
                      {
                        ++v60;
                        ++v65;
                        if (!--v61)
                        {
                          v65 = v66;
                          break;
                        }
                      }
                    }
                  }

                  else
                  {
                    v62 = 0;
                    do
                    {
                      v63 = *&v60[v62];
                      v64 = *&v59[v62];
                      if (v63 != v64)
                      {
                        v67 = v62 + (__clz(__rbit64(v64 ^ v63)) >> 3);
                        goto LABEL_83;
                      }

                      v61 -= 8;
                      v62 += 8;
                    }

                    while (v61 > 7);
                    v65 = &v59[v62];
                    v60 += v62;
                    if (v61)
                    {
                      goto LABEL_77;
                    }
                  }

                  v67 = v65 - v59;
LABEL_83:
                  v68 = v67 + 6;
                  if (v67 + 6 > 9)
                  {
                    if (v68 > 0x85)
                    {
                      v71 = v67 - 64;
                      v72 = __clz(v71) ^ 0x1F;
                      v69 = (v72 | (((-1 << v72) + v71) << 8)) + 52;
                      if (v68 > 0x845)
                      {
                        v69 = (v68 << 8) - 542145;
                      }
                    }

                    else
                    {
                      v70 = (__clz(v67) ^ 0x1F) - 1;
                      v69 = ((v67 >> v70) + 2 * v70 + 44) | ((v67 - (v67 >> v70 << v70)) << 8);
                    }
                  }

                  else
                  {
                    v69 = v67 + 44;
                  }

                  v16 += v68;
                  v73 = __clz(v58 + 3);
                  *v14 = v69;
                  v14[1] = (((v58 + 3 - ((((v58 + 3) >> ((v73 ^ 0x1F) - 1)) & 1 | 2) << ((v73 ^ 0x1F) - 1))) << 8) | (2 * (v73 ^ 0x1F)) | ((v58 + 3) >> ((v73 ^ 0x1F) - 1)) & 1) + 76;
                  v14 += 2;
                  if (v16 >= v18)
                  {
                    v9 = __dst;
                    v12 = v90;
                    v13 = v94;
                    goto LABEL_94;
                  }

                  v74 = *(v16 - 5);
                  *(a6 + (((0x1E35A7BD0000 * v74) >> 46) & 0x3FFFC)) = v16 - __src - 5;
                  *(a6 + (((506832829 * ((v74 << 8) & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16 - __src - 4;
                  *(a6 + (((506832829 * (v74 & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16 - __src - 3;
                  v75 = *(v16 - 2);
                  *(a6 + (((0x1E35A7BD0000 * v75) >> 46) & 0x3FFFC)) = v16 - __src - 2;
                  *(a6 + (((506832829 * ((v75 << 8) & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16 - __src - 1;
                  v76 = ((506832829 * (v75 & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC;
                  v77 = *(a6 + v76);
                  *(a6 + v76) = v16 - __src;
                  v56 = &__src[v77];
                  v57 = v16 - &__src[v77];
                  if (v57 < 262129)
                  {
                    v20 = v58;
                    if (*v16 == *v56)
                    {
                      continue;
                    }
                  }

                  v20 = v58;
                  goto LABEL_10;
                }
              }

              goto LABEL_10;
            }

            break;
          }
        }

LABEL_93:
        v9 = __dst;
        v12 = v90;
        v11 = v93;
        v13 = v94;
      }

LABEL_94:
      if (v16 < v13)
      {
        v78 = v13 - v16;
        if ((v13 - v16) >= 6)
        {
          v80 = (v78 << 8) - 1589738;
          if (v78 > 0x5841)
          {
            v80 = (v78 << 8) - 5784041;
          }

          if (v78 >> 1 <= 0xC20)
          {
            v79 = (v78 << 8) - 541163;
          }

          else
          {
            v79 = v80;
          }

          v81 = __clz(v78 - 66) ^ 0x1F;
          if (v78 <= 0x841)
          {
            v79 = (v81 | (((-1 << v81) + v78 - 66) << 8)) + 10;
          }

          v82 = (__clz(v78 - 2) ^ 0x1F) - 1;
          if (v78 <= 0x81)
          {
            v79 = (((v78 - 2) >> v82) + 2 * v82 + 2) | ((v78 - 2 - ((v78 - 2) >> v82 << v82)) << 8);
          }
        }

        else
        {
          v79 = v13 - v16;
        }

        *v14++ = v79;
        v83 = v15;
        memcpy(v15, v16, v78);
        v15 = &v83[v78];
      }

      v84 = v15 - v9;
      if (ShouldCompress(v89, v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        v85 = *a7;
        *(a8 + (*a7 >> 3)) = *(a8 + (*a7 >> 3));
        *a7 = v85 + 13;
        result = StoreCommands(v89, v9, v84, a4, (v14 - a4) >> 2, a7, a8);
      }

      else
      {
        result = EmitUncompressedMetaBlock(v11, v12, a7, a8);
      }

      v11 = v94;
      a3 = v91 - v12;
    }

    while (v91 != v12);
  }

  return result;
}

char *BrotliCompressFragmentTwoPassImpl17(char *result, char *__src, unint64_t a3, unsigned __int8 *a4, unsigned __int8 *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  v89 = result;
  if (a3)
  {
    v9 = __dst;
    v11 = __src;
    do
    {
      if (a3 >= 0x20000)
      {
        v12 = 0x20000;
      }

      else
      {
        v12 = a3;
      }

      v13 = &v11[v12];
      v14 = a4;
      v15 = v9;
      v16 = v11;
      v91 = a3;
      v17 = a3 - 16;
      v94 = &v11[v12];
      if (a3 >= 0x10)
      {
        v90 = v12;
        if (v12 - 6 < v17)
        {
          v17 = v12 - 6;
        }

        v15 = v9;
        v18 = &v11[v17];
        v19 = v13 - 6;
        v20 = -1;
        v14 = a4;
        v93 = v11;
        v16 = v11;
        v95 = v13 - 6;
LABEL_10:
        v21 = v16 + 1;
        v22 = (0x1E35A7BD0000 * *(v16 + 1)) >> 47;
        v23 = 32;
        while (1)
        {
          v24 = &v21[v23 >> 5];
          if (v24 > v18)
          {
            break;
          }

          ++v23;
          while (1)
          {
            v25 = v21;
            v26 = v22;
            v21 = v24;
            v22 = (0x1E35A7BD0000 * *v24) >> 47;
            v27 = &v25[-v20];
            if (*v25 == *v27 && v25[4] == v27[4] && v25[5] == v27[5] && v20 >= 1)
            {
              break;
            }

            v27 = &__src[*(a6 + 4 * v26)];
            *(a6 + 4 * v26) = v25 - __src;
            if (*v25 == *v27 && v25[4] == v27[4] && v25[5] == v27[5])
            {
              goto LABEL_25;
            }

            v24 = &v21[v23++ >> 5];
            if (v24 > v18)
            {
              goto LABEL_93;
            }
          }

          *(a6 + 4 * v26) = v25 - __src;
LABEL_25:
          v29 = v25 - v27;
          if (v25 - v27 <= 262128)
          {
            v30 = v27 + 6;
            v31 = (v25 + 6);
            v32 = v19 - v25;
            if ((v19 - v25) < 8)
            {
              v36 = (v27 + 6);
              if (v32)
              {
LABEL_33:
                v37 = &v36[v32];
                while (*v36 == *v31)
                {
                  ++v31;
                  ++v36;
                  if (!--v32)
                  {
                    v36 = v37;
                    break;
                  }
                }
              }
            }

            else
            {
              v33 = 0;
              do
              {
                v34 = *&v31[v33];
                v35 = *&v30[v33];
                if (v34 != v35)
                {
                  v38 = (v33 + (__clz(__rbit64(v35 ^ v34)) >> 3));
                  goto LABEL_39;
                }

                v32 -= 8;
                v33 += 8;
              }

              while (v32 > 7);
              v36 = &v30[v33];
              v31 += v33;
              if (v32)
              {
                goto LABEL_33;
              }
            }

            v38 = (v36 - v30);
LABEL_39:
            v39 = v25 - v16;
            v96 = v38;
            if ((v25 - v16) >= 6)
            {
              if (v39 > 0x81)
              {
                if (v39 > 0x841)
                {
                  if (v39 >> 1 > 0xC20)
                  {
                    if (v39 > 0x5841)
                    {
                      v43 = -5784041;
                    }

                    else
                    {
                      v43 = -1589738;
                    }

                    v40 = (v39 << 8) + v43;
                  }

                  else
                  {
                    v40 = (v39 << 8) - 541163;
                  }
                }

                else
                {
                  v42 = __clz(v39 - 66) ^ 0x1F;
                  v40 = (v42 | (((-1 << v42) + v39 - 66) << 8)) + 10;
                }
              }

              else
              {
                v41 = (__clz(v39 - 2) ^ 0x1F) - 1;
                v40 = (((v39 - 2) >> v41) + 2 * v41 + 2) | ((v39 - 2 - ((v39 - 2) >> v41 << v41)) << 8);
              }
            }

            else
            {
              v40 = v25 - v16;
            }

            *v14 = v40;
            v44 = v15;
            memcpy(v15, v16, v39);
            if (v20 == v29)
            {
              v45 = 64;
            }

            else
            {
              v46 = __clz(v29 + 3) ^ 0x1F;
              v45 = (((v29 + 3 - ((((v29 + 3) >> (v46 - 1)) & 1 | 2) << (v46 - 1))) << 8) | (2 * v46) | ((v29 + 3) >> (v46 - 1)) & 1) + 76;
              v20 = v29;
            }

            v47 = (v96 + 6);
            v14[1] = v45;
            if ((v96 + 6) > 0xB)
            {
              if (v47 > 0x47)
              {
                if (v47 > 0x87)
                {
                  if (v47 > 0x847)
                  {
                    v50 = (v47 << 8) - 542657;
                  }

                  else
                  {
                    v51 = __clz(v96 - 66) ^ 0x1F;
                    v50 = (v51 | (((-1 << v51) + v96 - 66) << 8)) + 52;
                  }
                }

                else
                {
                  v50 = (((v96 - 2) >> 5) + 54) | (((v96 - 2) & 0x1F) << 8);
                }

                v14[2] = v50;
                v14[3] = 64;
                v48 = 16;
              }

              else
              {
                v49 = (__clz(v96 - 2) ^ 0x1F) - 1;
                v14[2] = (((v96 - 2) >> v49) + 2 * v49 + 28) | ((v96 - 2 - ((v96 - 2) >> v49 << v49)) << 8);
                v48 = 12;
              }
            }

            else
            {
              v14[2] = v96 + 26;
              v48 = 12;
            }

            v16 = &v25[v47];
            v15 = &v44[v39];
            v14 = (v14 + v48);
            if (&v25[v47] < v18)
            {
              v52 = *(v16 - 5);
              *(a6 + (((0x1E35A7BD0000 * v52) >> 45) & 0x7FFFC)) = v16 - __src - 5;
              *(a6 + (((506832829 * ((v52 << 8) & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16 - __src - 4;
              *(a6 + (((506832829 * (v52 & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16 - __src - 3;
              v53 = *(v16 - 2);
              *(a6 + (((0x1E35A7BD0000 * v53) >> 45) & 0x7FFFC)) = v16 - __src - 2;
              *(a6 + (((506832829 * ((v53 << 8) & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16 - __src - 1;
              v54 = ((506832829 * (v53 & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC;
              v55 = *(a6 + v54);
              *(a6 + v54) = v16 - __src;
              v56 = &__src[v55];
              LODWORD(v57) = v16 - v56;
              v19 = v95;
              if (v16 - v56 < 262129 && *v16 == *v56)
              {
                v11 = v93;
                while (1)
                {
                  v58 = v57;
                  if (v16[4] != v56[4] || v16[5] != v56[5])
                  {
                    break;
                  }

                  v59 = v56 + 6;
                  v60 = (v16 + 6);
                  v61 = v95 - v16;
                  if ((v95 - v16) < 8)
                  {
                    v65 = v59;
                    if (v61)
                    {
LABEL_77:
                      v66 = &v65[v61];
                      while (*v65 == *v60)
                      {
                        ++v60;
                        ++v65;
                        if (!--v61)
                        {
                          v65 = v66;
                          break;
                        }
                      }
                    }
                  }

                  else
                  {
                    v62 = 0;
                    do
                    {
                      v63 = *&v60[v62];
                      v64 = *&v59[v62];
                      if (v63 != v64)
                      {
                        v67 = v62 + (__clz(__rbit64(v64 ^ v63)) >> 3);
                        goto LABEL_83;
                      }

                      v61 -= 8;
                      v62 += 8;
                    }

                    while (v61 > 7);
                    v65 = &v59[v62];
                    v60 += v62;
                    if (v61)
                    {
                      goto LABEL_77;
                    }
                  }

                  v67 = v65 - v59;
LABEL_83:
                  v68 = v67 + 6;
                  if (v67 + 6 > 9)
                  {
                    if (v68 > 0x85)
                    {
                      v71 = v67 - 64;
                      v72 = __clz(v71) ^ 0x1F;
                      v69 = (v72 | (((-1 << v72) + v71) << 8)) + 52;
                      if (v68 > 0x845)
                      {
                        v69 = (v68 << 8) - 542145;
                      }
                    }

                    else
                    {
                      v70 = (__clz(v67) ^ 0x1F) - 1;
                      v69 = ((v67 >> v70) + 2 * v70 + 44) | ((v67 - (v67 >> v70 << v70)) << 8);
                    }
                  }

                  else
                  {
                    v69 = v67 + 44;
                  }

                  v16 += v68;
                  v73 = __clz(v58 + 3);
                  *v14 = v69;
                  v14[1] = (((v58 + 3 - ((((v58 + 3) >> ((v73 ^ 0x1F) - 1)) & 1 | 2) << ((v73 ^ 0x1F) - 1))) << 8) | (2 * (v73 ^ 0x1F)) | ((v58 + 3) >> ((v73 ^ 0x1F) - 1)) & 1) + 76;
                  v14 += 2;
                  if (v16 >= v18)
                  {
                    v9 = __dst;
                    v12 = v90;
                    v13 = v94;
                    goto LABEL_94;
                  }

                  v74 = *(v16 - 5);
                  *(a6 + (((0x1E35A7BD0000 * v74) >> 45) & 0x7FFFC)) = v16 - __src - 5;
                  *(a6 + (((506832829 * ((v74 << 8) & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16 - __src - 4;
                  *(a6 + (((506832829 * (v74 & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16 - __src - 3;
                  v75 = *(v16 - 2);
                  *(a6 + (((0x1E35A7BD0000 * v75) >> 45) & 0x7FFFC)) = v16 - __src - 2;
                  *(a6 + (((506832829 * ((v75 << 8) & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16 - __src - 1;
                  v76 = ((506832829 * (v75 & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC;
                  v77 = *(a6 + v76);
                  *(a6 + v76) = v16 - __src;
                  v56 = &__src[v77];
                  v57 = v16 - &__src[v77];
                  if (v57 < 262129)
                  {
                    v20 = v58;
                    if (*v16 == *v56)
                    {
                      continue;
                    }
                  }

                  v20 = v58;
                  goto LABEL_10;
                }
              }

              goto LABEL_10;
            }

            break;
          }
        }

LABEL_93:
        v9 = __dst;
        v12 = v90;
        v11 = v93;
        v13 = v94;
      }

LABEL_94:
      if (v16 < v13)
      {
        v78 = v13 - v16;
        if ((v13 - v16) >= 6)
        {
          v80 = (v78 << 8) - 1589738;
          if (v78 > 0x5841)
          {
            v80 = (v78 << 8) - 5784041;
          }

          if (v78 >> 1 <= 0xC20)
          {
            v79 = (v78 << 8) - 541163;
          }

          else
          {
            v79 = v80;
          }

          v81 = __clz(v78 - 66) ^ 0x1F;
          if (v78 <= 0x841)
          {
            v79 = (v81 | (((-1 << v81) + v78 - 66) << 8)) + 10;
          }

          v82 = (__clz(v78 - 2) ^ 0x1F) - 1;
          if (v78 <= 0x81)
          {
            v79 = (((v78 - 2) >> v82) + 2 * v82 + 2) | ((v78 - 2 - ((v78 - 2) >> v82 << v82)) << 8);
          }
        }

        else
        {
          v79 = v13 - v16;
        }

        *v14++ = v79;
        v83 = v15;
        memcpy(v15, v16, v78);
        v15 = &v83[v78];
      }

      v84 = v15 - v9;
      if (ShouldCompress(v89, v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        v85 = *a7;
        *(a8 + (*a7 >> 3)) = *(a8 + (*a7 >> 3));
        *a7 = v85 + 13;
        result = StoreCommands(v89, v9, v84, a4, (v14 - a4) >> 2, a7, a8);
      }

      else
      {
        result = EmitUncompressedMetaBlock(v11, v12, a7, a8);
      }

      v11 = v94;
      a3 = v91 - v12;
    }

    while (v91 != v12);
  }

  return result;
}

void *EmitUncompressedMetaBlock(const void *a1, unint64_t a2, unint64_t *a3, uint64_t a4)
{
  BrotliStoreMetaBlockHeader(a2, 1u, a3, a4);
  v8 = (*a3 + 7) & 0xFFFFFFF8;
  *a3 = v8;
  result = memcpy((a4 + (v8 >> 3)), a1, a2);
  v10 = *a3 + 8 * a2;
  *a3 = v10;
  *(a4 + (v10 >> 3)) = 0;
  return result;
}

BOOL ShouldCompress(char *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a3 * 0.98 > a4)
  {
    return 1;
  }

  v8 = a3 * 8.0 * 0.98;
  bzero(a1, 0x400uLL);
  if (a3)
  {
    v9 = 0;
    do
    {
      ++*&a1[4 * *(a2 + v9)];
      v9 += 43;
    }

    while (v9 < a3);
  }

  v10 = 0;
  v11 = 0;
  v12 = 0.0;
  v13 = v8 / 43.0;
  do
  {
    v14 = *&a1[v10];
    if (v14 > 0xFF)
    {
      v16 = v14;
      v15 = log2(v14);
    }

    else
    {
      v15 = kBrotliLog2Table[v14];
      v16 = v14;
    }

    v17 = *&a1[v10 + 4];
    if (v17 > 0xFF)
    {
      v18 = log2(v17);
    }

    else
    {
      v18 = kBrotliLog2Table[v17];
    }

    v10 += 8;
    v11 += v14 + v17;
    v12 = v12 - v16 * v15 - v17 * v18;
  }

  while ((v10 - 8) < 0x3F8);
  v19 = v11;
  if (v11)
  {
    if (v11 > 0xFF)
    {
      v20 = log2(v11);
    }

    else
    {
      v20 = kBrotliLog2Table[v11];
    }

    v12 = v12 + v19 * v20;
  }

  if (v12 >= v19)
  {
    v21 = v12;
  }

  else
  {
    v21 = v11;
  }

  return v21 < v13;
}

unint64_t BrotliStoreMetaBlockHeader(unint64_t result, unsigned int a2, unint64_t *a3, uint64_t a4)
{
  v4 = *a3;
  *(a4 + (*a3 >> 3)) = *(a4 + (*a3 >> 3));
  *a3 = v4 + 1;
  v5 = 5;
  if (result >= 0x100001)
  {
    v5 = 6;
  }

  if (result <= 0x10000)
  {
    v5 = 4;
  }

  *(a4 + ((v4 + 1) >> 3)) = ((v5 - 4) << ((v4 + 1) & 7)) | *(a4 + ((v4 + 1) >> 3));
  v6 = v4 + 3;
  *a3 = v6;
  *(a4 + (v6 >> 3)) = ((result - 1) << (v6 & 7)) | *(a4 + (v6 >> 3));
  v7 = v6 + 4 * v5;
  *a3 = v7;
  *(a4 + (v7 >> 3)) = (a2 << (v7 & 7)) | *(a4 + (v7 >> 3));
  *a3 = v7 + 1;
  return result;
}

unint64_t StoreCommands(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  bzero(a1, 0x400uLL);
  *(a1 + 2416) = 0u;
  *(a1 + 2400) = 0u;
  *(a1 + 2384) = 0u;
  *(a1 + 2368) = 0u;
  *(a1 + 2352) = 0u;
  *(a1 + 2336) = 0u;
  *(a1 + 2320) = 0u;
  *(a1 + 2304) = 0u;
  *(a1 + 2432) = 0u;
  *(a1 + 2448) = 0u;
  *(a1 + 2464) = 0u;
  *(a1 + 2480) = 0u;
  *(a1 + 2496) = 0u;
  *(a1 + 2512) = 0u;
  *(a1 + 2528) = 0u;
  *(a1 + 2544) = 0u;
  *(a1 + 2560) = 0u;
  *(a1 + 2576) = 0u;
  *(a1 + 2592) = 0u;
  *(a1 + 2608) = 0u;
  *(a1 + 2624) = 0u;
  *(a1 + 2640) = 0u;
  *(a1 + 2656) = 0u;
  *(a1 + 2672) = 0u;
  *(a1 + 2288) = 0u;
  *(a1 + 2272) = 0u;
  *(a1 + 2256) = 0u;
  *(a1 + 2240) = 0u;
  *(a1 + 2224) = 0u;
  *(a1 + 2208) = 0u;
  *(a1 + 2192) = 0u;
  *(a1 + 2176) = 0u;
  *(a1 + 2160) = 0u;
  *(a1 + 2144) = 0u;
  *(a1 + 2128) = 0u;
  *(a1 + 2112) = 0u;
  *(a1 + 2096) = 0u;
  *(a1 + 2080) = 0u;
  *(a1 + 2064) = 0u;
  *(a1 + 2048) = 0u;
  *(a1 + 2032) = 0u;
  *(a1 + 2016) = 0u;
  *(a1 + 2000) = 0u;
  *(a1 + 1984) = 0u;
  *(a1 + 1968) = 0u;
  *(a1 + 1952) = 0u;
  *(a1 + 1936) = 0u;
  *(a1 + 1920) = 0u;
  *(a1 + 1904) = 0u;
  *(a1 + 1888) = 0u;
  *(a1 + 1872) = 0u;
  *(a1 + 1856) = 0u;
  *(a1 + 1840) = 0u;
  *(a1 + 1824) = 0u;
  *(a1 + 1808) = 0u;
  *(a1 + 1792) = 0u;
  if (a3)
  {
    v12 = a2;
    v13 = a3;
    do
    {
      v14 = *v12++;
      ++*(a1 + 4 * v14);
      --v13;
    }

    while (v13);
  }

  v15 = (a1 + 6920);
  v38 = (a1 + 2432);
  BrotliBuildAndStoreHuffmanTreeFast(a1 + 2688, a1, a3, 8, (a1 + 1024), a1 + 1280, a6, a7);
  v16 = a5;
  if (a5)
  {
    v17 = a4;
    do
    {
      v18 = *v17;
      v17 += 4;
      ++*(a1 + 1792 + 4 * v18);
      --v16;
    }

    while (v16);
  }

  *(a1 + 1796) = vadd_s32(*(a1 + 1796), 0x100000001);
  ++*(a1 + 2048);
  ++*(a1 + 2128);
  bzero((a1 + 6792), 0x2C0uLL);
  BrotliCreateHuffmanTree(a1 + 1792, 64, 15, a1 + 2688, a1 + 2304);
  BrotliCreateHuffmanTree(a1 + 2048, 64, 14, a1 + 2688, a1 + 2368);
  v19 = *(a1 + 2328);
  *(a1 + 6808) = *(a1 + 2344);
  *(a1 + 6816) = *(a1 + 2304);
  *(a1 + 6824) = *(a1 + 2352);
  *(a1 + 6832) = *(a1 + 2312);
  *(a1 + 6840) = *(a1 + 2360);
  v20 = (a1 + 2320);
  *(a1 + 6848) = *(a1 + 2320);
  *(a1 + 6792) = v19;
  BrotliConvertBitDepthsToSymbols((a1 + 6792), 64, a1 + 7496);
  *v38 = *(a1 + 7544);
  *(a1 + 2448) = *(a1 + 7576);
  *(a1 + 2464) = *(a1 + 7608);
  v21 = *(a1 + 7512);
  *(a1 + 2480) = *(a1 + 7496);
  *(a1 + 2496) = v21;
  v22 = *(a1 + 7560);
  *(a1 + 2512) = *(a1 + 7528);
  *(a1 + 2528) = v22;
  *(a1 + 2544) = *(a1 + 7592);
  BrotliConvertBitDepthsToSymbols((a1 + 2368), 64, a1 + 2560);
  *(a1 + 6824) = 0u;
  *(a1 + 6840) = 0u;
  v23 = *(a1 + 2328);
  *(a1 + 6792) = 0u;
  *(a1 + 6808) = 0u;
  *(a1 + 6792) = v23;
  *(a1 + 6856) = *(a1 + 2336);
  *(a1 + 6920) = *(a1 + 2344);
  *(a1 + 6984) = *(a1 + 2352);
  *(a1 + 7176) = *(a1 + 2360);
  v24 = 8;
  do
  {
    *v15 = *(v20 - 16);
    v15[128] = *(v20 - 8);
    v25 = *v20++;
    v15[320] = v25;
    v15 += 8;
    --v24;
  }

  while (v24);
  BrotliStoreHuffmanTree(a1 + 6792, 0x2C0uLL, a1 + 2688, a6, a7);
  result = BrotliStoreHuffmanTree(a1 + 2368, 0x40uLL, a1 + 2688, a6, a7);
  if (a5)
  {
    v27 = 0;
    v28 = *a6;
    do
    {
      v29 = *&a4[4 * v27];
      v30 = *(a1 + 2304 + v29);
      v31 = *&a4[4 * v27] >> 8;
      result = v28 & 7;
      *(a7 + (v28 >> 3)) = (*(v38 + v29) << (v28 & 7)) | *(a7 + (v28 >> 3));
      v32 = v28 + v30;
      v33 = StoreCommands_kNumExtraBits[v29];
      *a6 = v32;
      *(a7 + (v32 >> 3)) = (v31 << (v32 & 7)) | *(a7 + (v32 >> 3));
      v28 = v32 + v33;
      *a6 = v28;
      if (v29 <= 0x17)
      {
        for (i = StoreCommands_kInsertOffset[v29] + v31; i; --i)
        {
          v35 = *a2++;
          v36 = *(a1 + 1024 + v35);
          *(a7 + (v28 >> 3)) = (*(a1 + 1280 + 2 * v35) << (v28 & 7)) | *(a7 + (v28 >> 3));
          v28 += v36;
          *a6 = v28;
        }
      }

      ++v27;
    }

    while (v27 != a5);
  }

  return result;
}

void *BrotliSharedDictionaryDestroyInstance(void *result)
{
  if (result)
  {
    v1 = result;
    v3 = result[174];
    v2 = result[175];
    v3(v2, result[169]);
    v3(v2, v1[171]);
    v3(v2, v1[172]);

    return v3(v2, v1);
  }

  return result;
}

uint64_t BrotliSharedDictionaryAttach(_DWORD *a1, int a2, uint64_t a3, uint64_t a4)
{
  v4 = 0;
  if (a1 && !a2)
  {
    v5 = *a1;
    if (v5 <= 0xE)
    {
      v6 = &a1[2 * v5];
      *(v6 + 1) = a3;
      *(v6 + 16) = a4;
      *a1 = v5 + 1;
      return 1;
    }

    else
    {
      return 0;
    }
  }

  return v4;
}

_DWORD *BrotliSharedDictionaryCreateInstance(void *(*a1)(int a1, size_t size), void (*a2)(int a1, void *a2), uint64_t a3)
{
  if (a1 | a2)
  {
    v6 = 0;
    if (!a1 || !a2)
    {
      return v6;
    }

    v7 = a1(a3, 1408);
  }

  else
  {
    v7 = malloc_type_malloc(0x580uLL, 0x10F00400AFAC3FDuLL);
  }

  v6 = v7;
  if (v7)
  {
    bzero(v7, 0x580uLL);
    v6[62] = 0;
    *(v6 + 316) = 1;
    *(v6 + 1344) = 0;
    *(v6 + 1360) = 0;
    *(v6 + 40) = BrotliGetDictionary();
    *(v6 + 104) = BrotliGetTransforms();
    if (a1)
    {
      v8 = a1;
    }

    else
    {
      v8 = BrotliDefaultAllocFunc;
    }

    *(v6 + 173) = v8;
    if (a2)
    {
      v9 = a2;
    }

    else
    {
      v9 = BrotliDefaultFreeFunc;
    }

    *(v6 + 174) = v9;
    *(v6 + 175) = a3;
  }

  return v6;
}

id JEMetricsOSLog()
{
  if (JEMetricsOSLog_onceToken != -1)
  {
    JEMetricsOSLog_cold_1();
  }

  v1 = JEDefaultMetricsOSLog;

  return v1;
}

uint64_t __JEMetricsOSLog_block_invoke()
{
  JEDefaultMetricsOSLog = os_log_create("com.apple.JetEngine", "Metrics");

  return MEMORY[0x1EEE66BB8]();
}

void *BrotliInitBitReader(void *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

uint64_t BrotliWarmupBitReader(void *a1)
{
  if (a1[1])
  {
    return 1;
  }

  *a1 = 0;
  v1 = a1[2];
  if (v1 != a1[4])
  {
    *a1 = *v1;
    a1[1] = 8;
    a1[2] = v1 + 1;
    return 1;
  }

  return 0;
}

uint64_t BrotliTransformDictionaryWord(uint64_t a1, char *a2, uint64_t a3, void *a4, int a5)
{
  v5 = a3;
  v8 = a4[1];
  v7 = a4[2];
  v9 = (a4[4] + 3 * a5);
  v10 = *(v7 + 2 * *v9);
  v11 = v9[1];
  v12 = *(v7 + 2 * v9[2]);
  v13 = *(v8 + v10);
  if (*(v8 + v10))
  {
    v14 = 0;
    v15 = v10 + v8 + 1;
    do
    {
      *(a1 + v14) = *(v15 + v14);
      ++v14;
    }

    while (v13 != v14);
  }

  else
  {
    v14 = 0;
  }

  if (v11 > 9)
  {
    if ((v11 - 12) <= 8)
    {
      v16 = (v11 - 11);
      a2 += v16;
      v5 = (a3 - v16);
    }
  }

  else
  {
    v5 = (a3 - v11);
  }

  if (v5 >= 1)
  {
    v14 = v14;
    v17 = v5;
    do
    {
      v18 = *a2++;
      *(a1 + v14++) = v18;
      --v17;
    }

    while (v17);
  }

  if (v11 > 20)
  {
    if (v11 == 21)
    {
      Shift((a1 - v5 + v14), v5, *(a4[5] + 2 * a5) | (*(a4[5] + 2 * a5 + 1) << 8));
    }

    else if (v11 == 22 && v5 >= 1)
    {
      v23 = *(a4[5] + 2 * a5) | (*(a4[5] + 2 * a5 + 1) << 8);
      v24 = (a1 - v5 + v14);
      do
      {
        v25 = Shift(v24, v5, v23);
        v24 += v25;
        v22 = __OFSUB__(v5, v25);
        v5 = (v5 - v25);
      }

      while (!((v5 < 0) ^ v22 | (v5 == 0)));
    }
  }

  else if (v11 == 10)
  {
    v26 = (a1 - v5 + v14);
    v27 = *v26;
    if (v27 > 0xBF)
    {
      if (v27 > 0xDF)
      {
        v26[2] ^= 5u;
      }

      else
      {
        v26[1] ^= 0x20u;
      }
    }

    else if (v27 - 97 <= 0x19)
    {
      *v26 = v27 & 0x5F;
    }
  }

  else if (v11 == 11 && v5 >= 1)
  {
    v19 = (a1 - v5 + v14);
    do
    {
      v20 = *v19;
      if (v20 > 0xBF)
      {
        if (v20 > 0xDF)
        {
          v19[2] ^= 5u;
          v21 = 3;
        }

        else
        {
          v19[1] ^= 0x20u;
          v21 = 2;
        }
      }

      else
      {
        if (v20 - 97 <= 0x19)
        {
          *v19 = v20 & 0x5F;
        }

        v21 = 1;
      }

      v19 += v21;
      v22 = __OFSUB__(v5, v21);
      LODWORD(v5) = v5 - v21;
    }

    while (!((v5 < 0) ^ v22 | (v5 == 0)));
  }

  v28 = *(v8 + v12);
  if (*(v8 + v12))
  {
    v14 = v14;
    v29 = (v12 + v8 + 1);
    do
    {
      v30 = *v29++;
      *(a1 + v14++) = v30;
      --v28;
    }

    while (v28);
  }

  return v14;
}

uint64_t Shift(char *a1, uint64_t a2, __int16 a3)
{
  v3 = *a1;
  if ((*a1 & 0x80000000) == 0)
  {
    *a1 = (v3 + a3) & 0x7F;
    return 1;
  }

  if (v3 < 0xC0)
  {
    return 1;
  }

  v5 = (a3 & 0x7FFF) - (a3 & 0x8000) + 0x1000000;
  if (v3 <= 0xDF)
  {
    if (a2 >= 2)
    {
      v6 = a1[1];
      v7 = (v6 & 0x3F | ((v3 & 0x1F) << 6)) + v5;
      *a1 = (v7 >> 6) & 0x1F | 0xC0;
      a1[1] = v6 & 0xC0 | v7 & 0x3F;
      return 2;
    }

    return 1;
  }

  if (v3 > 0xEF)
  {
    if (v3 > 0xF7)
    {
      return 1;
    }

    if (a2 >= 4)
    {
      v11 = a1[3];
      v12 = a1[2];
      v13 = a1[1];
      v14 = ((v3 & 7) << 18) + v5 + (v11 & 0x3F);
      v15 = v14 + ((v12 & 0x3F) << 6);
      v16 = v15 + ((v13 & 0x3F) << 12);
      *a1 = (v16 >> 18) & 7 | 0xF0;
      a1[1] = v13 & 0xC0 | (v16 >> 12) & 0x3F;
      a1[2] = v12 & 0xC0 | (v15 >> 6) & 0x3F;
      a1[3] = v11 & 0xC0 | v14 & 0x3F;
      return 4;
    }
  }

  else if (a2 >= 3)
  {
    v8 = a1[2];
    v9 = a1[1];
    v10 = ((v3 & 0xF) << 12) + v5 + (v8 & 0x3F);
    *a1 = ((v10 + ((v9 & 0x3F) << 6)) >> 12) | 0xE0;
    a1[1] = v9 & 0xC0 | ((v10 + ((v9 & 0x3Fu) << 6)) >> 6) & 0x3F;
    a1[2] = v8 & 0xC0 | v10 & 0x3F;
    return 3;
  }

  return a2;
}

void *(**BrotliInitMemoryManager(void *(**result)(int a1, size_t size), void *(*a2)(int a1, size_t size), void (*a3)(int a1, void *a2), void *(*a4)(int a1, size_t size)))(int a1, size_t size)
{
  if (a2)
  {
    v4 = a2;
  }

  else
  {
    v4 = BrotliDefaultAllocFunc;
  }

  if (a2)
  {
    v5 = a3;
  }

  else
  {
    v5 = BrotliDefaultFreeFunc;
  }

  if (a2)
  {
    v6 = a4;
  }

  else
  {
    v6 = 0;
  }

  *result = v4;
  result[1] = v5;
  result[2] = v6;
  return result;
}

uint64_t BrotliAllocate(uint64_t a1)
{
  result = (*a1)(*(a1 + 16));
  if (!result)
  {
    exit(1);
  }

  return result;
}

void *BrotliBootstrapAlloc(size_t size, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a2 | a3))
  {
    return malloc_type_malloc(size, 0x266923F6uLL);
  }

  if (a2 && a3)
  {
    return (a2)(a4, size);
  }

  return 0;
}

uint64_t BrotliBootstrapFree(uint64_t result, uint64_t a2)
{
  if (result)
  {
    return (*(a2 + 8))(*(a2 + 16), result);
  }

  return result;
}

uint64_t BrotliSetDepth(int a1, uint64_t a2, uint64_t a3, int a4)
{
  LODWORD(v4) = 0;
  v9 = *MEMORY[0x1E69E9840];
  v8[0] = -1;
  while (1)
  {
    while (1)
    {
      v5 = a2 + 8 * a1;
      a1 = *(v5 + 4);
      if ((a1 & 0x80000000) == 0)
      {
        break;
      }

      *(a3 + *(v5 + 6)) = v4;
      if ((v4 & 0x80000000) != 0)
      {
        return 1;
      }

      while (1)
      {
        a1 = v8[v4];
        if (a1 != -1)
        {
          break;
        }

        v6 = v4 <= 0;
        LODWORD(v4) = v4 - 1;
        if (v6)
        {
          return 1;
        }
      }

      v8[v4] = -1;
    }

    if (v4 >= a4)
    {
      break;
    }

    v4 = v4 + 1;
    v8[v4] = *(v5 + 6);
  }

  return 0;
}

uint64_t BrotliCreateHuffmanTree(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v9 = result;
  v46 = a2 - 1;
  v10 = a4 + 8;
  for (i = 1; ; i *= 2)
  {
    if (!a2)
    {
      goto LABEL_21;
    }

    v12 = 0;
    v13 = v46;
    do
    {
      v14 = *(v9 + 4 * v13);
      if (v14)
      {
        if (v14 <= i)
        {
          v14 = i;
        }

        v15 = a4 + 8 * v12;
        *v15 = v14;
        ++v12;
        *(v15 + 4) = -1;
        *(v15 + 6) = v13;
      }

      --v13;
    }

    while (v13 != -1);
    if (v12 == 1)
    {
      break;
    }

    if (v12 > 0xC)
    {
      v25 = 2 * (v12 < 0x39);
      while (1)
      {
        v26 = kBrotliShellGaps[v25];
        if (v26 >= v12)
        {
          goto LABEL_35;
        }

        v27 = 0;
        v28 = kBrotliShellGaps[v25];
        do
        {
          v29 = *(a4 + 8 * v28);
          v30 = v28;
          if (v28 < v26)
          {
            goto LABEL_34;
          }

          v31 = v27;
          v32 = v28;
          while (1)
          {
            v33 = *(a4 + v31);
            if (v33 != v29)
            {
              break;
            }

            if (*(a4 + v31 + 6) >= SHIWORD(v29))
            {
              goto LABEL_33;
            }

LABEL_31:
            v30 = v32 - v26;
            *(a4 + 8 * v32) = *(a4 + v31);
            v31 -= 8 * v26;
            v32 = v30;
            if (v30 < v26)
            {
              goto LABEL_34;
            }
          }

          if (v33 > v29)
          {
            goto LABEL_31;
          }

LABEL_33:
          v30 = v32;
LABEL_34:
          *(a4 + 8 * v30) = v29;
          ++v28;
          v27 += 8;
        }

        while (v28 != v12);
LABEL_35:
        if (++v25 == 6)
        {
          goto LABEL_36;
        }
      }
    }

    if (v12)
    {
      v16 = 0;
      for (j = 1; j != v12; ++j)
      {
        v18 = *(a4 + 8 * j);
        v19 = v16;
        v20 = j;
        do
        {
          v21 = *(a4 + v19);
          if (v21 == v18)
          {
            if (*(a4 + v19 + 6) >= SHIWORD(v18))
            {
              break;
            }
          }

          else if (v21 <= v18)
          {
            break;
          }

          *(a4 + 8 * v20) = *(a4 + v19);
          v19 -= 8;
          --v20;
        }

        while (v20);
        *(a4 + 8 * v20) = v18;
        v16 += 8;
      }

LABEL_36:
      *&v34 = -1;
      *(&v34 + 1) = -1;
      *(a4 + 8 * v12) = v34;
      v23 = v12 - 1;
      v24 = v12 + 1;
      goto LABEL_37;
    }

LABEL_21:
    v12 = 0;
    *&v22 = -1;
    *(&v22 + 1) = -1;
    *a4 = v22;
    v23 = -1;
    v24 = 1;
LABEL_37:
    v35 = 0;
    v36 = (v10 - 8 * v23 + 16 * v12);
    do
    {
      v37 = *(a4 + 8 * v35);
      v38 = *(a4 + 8 * v24);
      v39 = v37 > v38;
      if (v37 > v38)
      {
        v40 = v35;
      }

      else
      {
        v40 = v35 + 1;
      }

      if (v39)
      {
        v41 = v24 + 1;
      }

      else
      {
        v41 = v24;
      }

      v42 = *(a4 + 8 * v40);
      v43 = *(a4 + 8 * v41);
      if (!v39)
      {
        v24 = v35;
      }

      v44 = v42 > v43;
      if (v42 > v43)
      {
        v45 = v41;
      }

      else
      {
        v45 = v40;
      }

      *(v36 - 2) = *(a4 + 8 * v45) + *(a4 + 8 * v24);
      *(v36 - 2) = v24;
      if (v44)
      {
        v35 = v40;
      }

      else
      {
        v35 = v40 + 1;
      }

      if (v44)
      {
        v24 = v41 + 1;
      }

      else
      {
        v24 = v41;
      }

      *(v36 - 1) = v45;
      *v36++ = -1;
      --v23;
    }

    while (v23);
    result = BrotliSetDepth(2 * v12 - 1, a4, a5, a3);
    if (result)
    {
      return result;
    }
  }

  *(a5 + *(a4 + 6)) = 1;
  return result;
}

void BrotliOptimizeHuffmanCountsForRle(size_t a1, int *a2, char *a3)
{
  if (a1)
  {
    v5 = a1;
    v6 = 0;
    v7 = 0;
    do
    {
      if (a2[v6])
      {
        ++v7;
      }

      ++v6;
    }

    while (a1 != v6);
    if (v7 >= 0x10)
    {
      v8 = a2 - 1;
      while (!v8[v5])
      {
        if (!--v5)
        {
          return;
        }
      }

      v9 = 0;
      v10 = 0;
      v11 = 0x40000000;
      do
      {
        v12 = v9;
        v13 = a2[v10];
        if (v11 >= v13)
        {
          v14 = a2[v10];
        }

        else
        {
          v14 = v11;
        }

        if (v13)
        {
          ++v9;
          v11 = v14;
        }

        ++v10;
      }

      while (v5 != v10);
      if (v9 >= 5)
      {
        if (v13)
        {
          v15 = v12 + 1;
        }

        else
        {
          v15 = v12;
        }

        v16 = v5 - v15;
        if (v11 <= 3 && v16 <= 5 && v5 - 3 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v19 = a2 + 1;
          v20 = v5 - 2;
          do
          {
            if (*(v19 - 1) && !*v19 && v19[1])
            {
              *v19 = 1;
            }

            ++v19;
            --v20;
          }

          while (v20);
        }

        if (v9 >= 0x1C)
        {
          bzero(a3, v5);
          v21 = 0;
          v22 = 0;
          v23 = *a2;
          do
          {
            if (v5 == v22 || a2[v22] != v23)
            {
              if (!v23 && v21 > 4 || v23 && v21 >= 7)
              {
                memset(&a3[v22 - v21], 1, v21);
              }

              if (v5 != v22)
              {
                v23 = a2[v22];
              }

              v21 = 1;
            }

            else
            {
              ++v21;
            }

            v24 = v22++ >= v5;
          }

          while (!v24);
          v25 = 0;
          v26 = 0;
          v27 = 0;
          v28 = vdupq_n_s64(4uLL);
          v29 = ((a2[1] + *a2 + a2[2]) << 8) / 3u + 420;
          do
          {
            if (v5 == v25 || a3[v25] || v25 && a3[v25 - 1] || (v42 = a2[v25], (v42 << 8) - v29 - 1240 <= 0xFFFFFFFFFFFFF64FLL))
            {
              v30 = &a2[v25];
              if (v27 > 3 || v27 == 3 && !v26)
              {
                v31 = 0;
                v32 = v26 + (v27 >> 1);
                if (v27 > v32)
                {
                  v33 = 1;
                }

                else
                {
                  v33 = v32 / v27;
                }

                if (v26)
                {
                  v34 = v33;
                }

                else
                {
                  v34 = 0;
                }

                v35 = (v27 + 3) & 0xFFFFFFFFFFFFFFFCLL;
                v36 = vdupq_n_s64(v27 - 1);
                v37 = v8;
                v38 = xmmword_1AB465FA0;
                v39 = xmmword_1AB465F90;
                do
                {
                  v40 = vmovn_s64(vcgeq_u64(v36, v38));
                  if (vuzp1_s16(v40, 2).u8[0])
                  {
                    *v37 = v34;
                  }

                  if (vuzp1_s16(v40, 2).i8[2])
                  {
                    v30[v31 ^ 0x3FFFFFFFFFFFFFFELL] = v34;
                  }

                  if (vuzp1_s16(2, vmovn_s64(vcgeq_u64(v36, *&v39))).i32[1])
                  {
                    v30[v31 ^ 0xFFFFFFFFFFFFFFFDLL] = v34;
                    v30[v31 ^ 0x3FFFFFFFFFFFFFFCLL] = v34;
                  }

                  v31 += 4;
                  v39 = vaddq_s64(v39, v28);
                  v38 = vaddq_s64(v38, v28);
                  v37 -= 4;
                }

                while (v35 != v31);
              }

              if (v25 >= v5 - 2)
              {
                if (v25 >= v5)
                {
                  v41 = 0;
                }

                else
                {
                  v41 = a2[v25] << 8;
                }
              }

              else
              {
                v41 = ((v30[1] + *v30 + v30[2]) << 8) / 3u + 420;
              }

              v29 = v41;
              if (v5 == v25)
              {
                v26 = 0;
              }

              else
              {
                v26 = a2[v25];
              }

              v27 = 1;
            }

            else
            {
              ++v27;
              v26 += v42;
              if (v27 >= 4)
              {
                v29 = ((v26 << 8) + (v27 >> 1)) / v27;
                if (v27 == 4)
                {
                  v29 += 120;
                }
              }
            }

            ++v8;
            v24 = v25++ >= v5;
          }

          while (!v24);
        }
      }
    }
  }
}

uint64_t BrotliWriteHuffmanTree(uint64_t result, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (!a2)
  {
    return result;
  }

  v5 = -a2;
  v6 = result - 1;
  while (!*(v6 + a2))
  {
    --v6;
    if (__CFADD__(v5++, 1))
    {
      if (a2 <= 0x32)
      {
        return result;
      }

LABEL_28:
      v8 = 0;
      v11 = 0;
      v9 = 0;
      v23 = 2;
      v22 = 2;
      goto LABEL_29;
    }
  }

  v8 = -v5;
  if (a2 <= 0x32)
  {
    v24 = 0;
    v25 = 0;
    if (!v5)
    {
      return result;
    }

LABEL_32:
    v26 = 0;
    v27 = 8;
    while (1)
    {
      v28 = *(result + v26);
      if ((*(result + v26) == 0 || !v24) && (*(result + v26) != 0 || !v25))
      {
        break;
      }

      if (v26 + 1 >= v8)
      {
        break;
      }

      v29 = 1;
      while (*(result + v26 + v29) == v28)
      {
        if (v8 - v26 == ++v29)
        {
          v29 = v8 - v26;
          break;
        }
      }

      if (*(result + v26))
      {
        goto LABEL_44;
      }

      if (v29 == 11)
      {
        *(a4 + *a3) = 0;
        *(a5 + *a3) = 0;
        v30 = *a3 + 1;
        *a3 = v30;
        v29 = 11;
        v31 = 7;
LABEL_70:
        *(a4 + v30) = 17;
        *(a5 + *a3) = v31 & 7;
        v44 = *a3;
        v45 = *a3 + 1;
        *a3 = v45;
        if (v31 >= 8)
        {
          do
          {
            v31 = (v31 >> 3) - 1;
            *(a4 + v45) = 17;
            *(a5 + *a3) = v31 & 7;
            v44 = *a3;
            v45 = *a3 + 1;
            *a3 = v45;
          }

          while (v31 > 7);
        }

        if (v44 > v30)
        {
          v46 = v30;
          do
          {
            v47 = *(a4 + v46);
            *(a4 + v46) = *(a4 + v44);
            *(a4 + v44) = v47;
            ++v46;
            --v44;
          }

          while (v46 < v44);
          v45 = *a3;
        }

        for (i = v45 - 1; v30 < i; --i)
        {
          v49 = *(a5 + v30);
          *(a5 + v30) = *(a5 + i);
          *(a5 + i) = v49;
          ++v30;
        }

        goto LABEL_67;
      }

      v31 = v29 - 3;
      if (v29 >= 3)
      {
        v30 = *a3;
        goto LABEL_70;
      }

      if (v29)
      {
LABEL_65:
        v42 = *a3;
        v43 = v29;
        do
        {
          *(a4 + v42) = 0;
          *(a5 + *a3) = 0;
          v42 = *a3 + 1;
          *a3 = v42;
          --v43;
        }

        while (v43);
      }

LABEL_67:
      v26 += v29;
      if (v26 >= v8)
      {
        return result;
      }
    }

    v29 = 1;
    if (!*(result + v26))
    {
      goto LABEL_65;
    }

LABEL_44:
    v32 = v29;
    if (v27 != v28)
    {
      *(a4 + *a3) = v28;
      *(a5 + (*a3)++) = 0;
      v32 = v29 - 1;
    }

    if (v32 == 7)
    {
      *(a4 + *a3) = v28;
      *(a5 + *a3) = 0;
      v33 = *a3 + 1;
      *a3 = v33;
      v34 = 3;
    }

    else
    {
      v34 = v32 - 3;
      if (v32 < 3)
      {
        if (v32)
        {
          v35 = *a3;
          do
          {
            *(a4 + v35) = v28;
            *(a5 + *a3) = 0;
            v35 = *a3 + 1;
            *a3 = v35;
            --v32;
          }

          while (v32);
        }

        goto LABEL_62;
      }

      v33 = *a3;
    }

    *(a4 + v33) = 16;
    *(a5 + *a3) = v34 & 3;
    v36 = *a3;
    v37 = *a3 + 1;
    *a3 = v37;
    if (v34 >= 4)
    {
      do
      {
        v34 = (v34 >> 2) - 1;
        *(a4 + v37) = 16;
        *(a5 + *a3) = v34 & 3;
        v36 = *a3;
        v37 = *a3 + 1;
        *a3 = v37;
      }

      while (v34 > 3);
    }

    if (v36 > v33)
    {
      v38 = v33;
      do
      {
        v39 = *(a4 + v38);
        *(a4 + v38) = *(a4 + v36);
        *(a4 + v36) = v39;
        ++v38;
        --v36;
      }

      while (v38 < v36);
      v37 = *a3;
    }

    for (j = v37 - 1; v33 < j; --j)
    {
      v41 = *(a5 + v33);
      *(a5 + v33) = *(a5 + j);
      *(a5 + j) = v41;
      ++v33;
    }

LABEL_62:
    v27 = v28;
    goto LABEL_67;
  }

  if (!v5)
  {
    goto LABEL_28;
  }

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = -v5;
  v13 = 1;
  v14 = 1;
  do
  {
    v15 = *(result + v10);
    if (v10 + 1 >= v8)
    {
      ++v10;
      v16 = 1;
    }

    else
    {
      v16 = 1;
      while (*(result + v10 + v16) == v15)
      {
        if (v12 - v10 == ++v16)
        {
          v16 = v12 - v10;
          break;
        }
      }

      v10 += v16;
    }

    v17 = v15 == 0;
    v18 = !v17;
    v19 = (v16 > 2) & v17;
    v14 += v19;
    if (v19)
    {
      v20 = v16;
    }

    else
    {
      v20 = 0;
    }

    v9 += v20;
    v21 = (v16 > 3) & v18;
    if (((v16 > 3) & v18) == 0)
    {
      v16 = 0;
    }

    v11 += v16;
    v13 += v21;
  }

  while (v10 < v8);
  v22 = 2 * v13;
  v23 = 2 * v14;
LABEL_29:
  v24 = v11 > v22;
  v25 = v9 > v23;
  if (v8)
  {
    goto LABEL_32;
  }

  return result;
}

unsigned __int8 *BrotliConvertBitDepthsToSymbols(unsigned __int8 *result, uint64_t a2, uint64_t a3)
{
  v15 = *MEMORY[0x1E69E9840];
  memset(v14, 0, sizeof(v14));
  if (a2)
  {
    v3 = result;
    v4 = a2;
    do
    {
      v5 = *v3++;
      ++*(v14 + v5);
      --v4;
    }

    while (v4);
  }

  v6 = 0;
  v7 = 0;
  LOWORD(v14[0]) = 0;
  do
  {
    v7 = 2 * (v7 + *(v14 + v6));
    *&v13[v6 + 2] = v7;
    v6 += 2;
  }

  while (v6 != 30);
  if (a2)
  {
    for (i = 0; i != a2; ++i)
    {
      v9 = result[i];
      if (result[i])
      {
        v10 = *&v13[2 * v9];
        *&v13[2 * v9] = v10 + 1;
        v11 = BrotliReverseBits_kLut[v10 & 0xF];
        if (v9 >= 5)
        {
          for (j = 4; j < v9; j += 4)
          {
            v10 >>= 4;
            v11 = BrotliReverseBits_kLut[v10] | (16 * v11);
          }
        }

        *(a3 + 2 * i) = v11 >> (-v9 & 3);
      }
    }
  }

  return result;
}

uint64_t BrotliInitDistanceParams(uint64_t result, int a2, unsigned int a3, int a4)
{
  *result = a2;
  *(result + 4) = a3;
  v4 = a3 + 16;
  v5 = a2 + 1;
  if (a4)
  {
    if (a3 > 0x7FFFFFFB)
    {
      v14 = -2147483636;
      a3 = 2147483644;
    }

    else
    {
      v6 = -1;
      v7 = -1 << a2;
      v8 = -5;
      v9 = ((2147483644 - a3) >> a2) + 4;
      do
      {
        ++v6;
        v8 += 2;
        v10 = v9 > 3;
        v9 >>= 1;
      }

      while (v10);
      v11 = (((((2147483644 - a3) >> a2) + 4) >> v6) & 1) + v8;
      if (v11 == -1)
      {
        v14 = a3 + 16;
      }

      else
      {
        v12 = v11 >> 1;
        v13 = (v11 & 1) << ((v11 >> 1) + 1);
        v14 = a3 + ((v11 << a2) | ~v7) + 17;
        a3 = a3 - v7 + (((6 << v12) + v13 - 5) << a2);
      }
    }

    v15 = v4 + (62 << v5);
  }

  else
  {
    v15 = v4 + (24 << v5);
    a3 += (1 << (a2 + 26)) + (-1 << (a2 + 2));
    v14 = v15;
  }

  *(result + 8) = v15;
  *(result + 12) = v14;
  *(result + 16) = a3;
  return result;
}

uint64_t BrotliBuildMetaBlock(uint64_t a1, uint64_t a2, size_t a3, size_t a4, uint64_t a5, unsigned __int8 a6, unsigned __int8 a7, uint64_t a8, size_t a9, int a10, void *a11)
{
  v90 = *(a5 + 56);
  v91 = *(a5 + 72);
  v88 = *(a5 + 56);
  v89 = *(a5 + 72);
  v13 = BrotliAllocate(a1);
  v14 = 0;
  v15 = 0;
  v16 = 1;
  v17 = 1.0e99;
  v19 = v90;
  v18 = DWORD1(v90);
  do
  {
    if (v14 > 0xF)
    {
LABEL_12:
      v14 = (v14 - 1) >> 1;
    }

    else
    {
      while (1)
      {
        v87 = 0.0;
        BrotliInitDistanceParams(&v88, v15, v14 << v15, *(a5 + 36));
        if (v14 << v15 == v18 && v15 == v19)
        {
          v16 = 0;
        }

        if (!ComputeDistanceCost(a8, a9, &v90, &v88, &v87, v13))
        {
          break;
        }

        v21 = v87;
        if (v87 > v17)
        {
          break;
        }

        *(a5 + 56) = v88;
        *(a5 + 72) = v89;
        ++v14;
        v17 = v21;
        if (v14 == 16)
        {
          v17 = v21;
          goto LABEL_12;
        }
      }

      if (v14)
      {
        v14 = (v14 - 1) >> 1;
      }

      else
      {
        v14 = 0;
      }
    }

    ++v15;
  }

  while (v15 != 4);
  if (v16)
  {
    v87 = 0.0;
    ComputeDistanceCost(a8, a9, &v90, &v90, &v87, v13);
    if (v87 < v17)
    {
      *(a5 + 56) = v90;
      *(a5 + 72) = v91;
    }
  }

  v22 = a1;
  BrotliFree(a1);
  if (v19 == *(a5 + 56))
  {
    if (!a9 || v18 == *(a5 + 60))
    {
      goto LABEL_35;
    }
  }

  else if (!a9)
  {
    goto LABEL_35;
  }

  v23 = v18 + 16;
  v24 = a8 + 8;
  v25 = a9;
  do
  {
    if ((*(v24 - 4) & 0x1FFFFFF) != 0 && *(v24 + 4) >= 0x80u)
    {
      v26 = *(v24 + 6);
      v27 = v26 & 0x3FF;
      if (v27 >= v23)
      {
        v27 = ((v27 - v18 - 16) & ~(-1 << v19)) + v23 + ((((((v27 - v18 - 16) >> v19) & 1 | 2) << (v26 >> 10)) + *v24 - 4) << v19);
      }

      v28 = v27;
      v29 = *(a5 + 60);
      v30 = v29 + 16;
      if (v29 + 16 <= v27)
      {
        v32 = *(a5 + 56);
        v33 = v28 - v29 + (4 << v32) - 16;
        v34 = (__clz(v33) ^ 0x1F) - 1;
        v35 = ((v33 >> v34) & 1 | 2) << v34;
        LODWORD(v28) = ((v33 & ~(-1 << v32)) + v30 + ((((v33 >> v34) & 1 | (2 * (v34 - v32))) + 65534) << v32)) | ((v34 - v32) << 10);
        v31 = (v33 - v35) >> v32;
      }

      else
      {
        LODWORD(v31) = 0;
      }

      *(v24 + 6) = v28;
      *v24 = v31;
    }

    v24 += 16;
    --v25;
  }

  while (v25);
LABEL_35:
  v36 = a11 + 12;
  BrotliSplitBlock(a1, a8, a9, a2, a3, a4, a5, a11, (a11 + 6), (a11 + 12));
  v37 = *a11;
  if (*(a5 + 32))
  {
    v79 = 0;
    v38 = 1;
    goto LABEL_50;
  }

  if (!v37)
  {
    v79 = 0;
    goto LABEL_49;
  }

  v39 = BrotliAllocate(a1);
  v37 = *a11;
  v79 = v39;
  if (!*a11)
  {
LABEL_49:
    v38 = 64;
    goto LABEL_50;
  }

  v40 = (v37 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  v41 = vdupq_n_s64(v37 - 1);
  v42 = xmmword_1AB465F90;
  v43 = xmmword_1AB465FA0;
  v44 = (v39 + 8);
  v45 = vdupq_n_s64(4uLL);
  v38 = 64;
  do
  {
    v46 = vmovn_s64(vcgeq_u64(v41, v43));
    if (vuzp1_s16(v46, *v41.i8).u8[0])
    {
      *(v44 - 2) = a10;
    }

    if (vuzp1_s16(v46, *&v41).i8[2])
    {
      *(v44 - 1) = a10;
    }

    if (vuzp1_s16(*&v41, vmovn_s64(vcgeq_u64(v41, *&v42))).i32[1])
    {
      *v44 = a10;
      v44[1] = a10;
    }

    v42 = vaddq_s64(v42, v45);
    v43 = vaddq_s64(v43, v45);
    v44 += 4;
    v40 -= 4;
  }

  while (v40);
LABEL_50:
  v47 = v37 * v38;
  if (v37 * v38)
  {
    v48 = BrotliAllocate(a1);
    v49 = v47;
    v50 = v48;
    do
    {
      bzero(v50, 0x400uLL);
      *(v50 + 128) = 0;
      *(v50 + 129) = 0x7FF0000000000000;
      v50 += 1040;
      --v49;
    }

    while (v49);
    v22 = a1;
  }

  else
  {
    v48 = 0;
  }

  v51 = 4 * *v36;
  if (v51)
  {
    v52 = BrotliAllocate(v22);
    v82 = v52;
    do
    {
      bzero(v52, 0x880uLL);
      *(v52 + 272) = 0;
      *(v52 + 273) = 0x7FF0000000000000;
      v52 += 2192;
      --v51;
    }

    while (v51);
    v22 = a1;
  }

  else
  {
    v82 = 0;
  }

  v53 = a11;
  v54 = a11[6];
  a11[25] = v54;
  if (v54)
  {
    v55 = BrotliAllocate(v22);
    v56 = a11[25];
    a11[24] = v55;
    if (v56)
    {
      do
      {
        bzero(v55, 0xB00uLL);
        v55[352] = 0;
        v55[353] = 0x7FF0000000000000;
        v55 += 354;
        --v56;
      }

      while (v56);
      v53 = a11;
      v22 = a1;
      v55 = a11[24];
    }

    else
    {
      v53 = a11;
    }
  }

  else
  {
    v55 = 0;
    a11[24] = 0;
  }

  BrotliBuildHistogramsWithContext(a8, a9, v53, (a11 + 6), v36, a2, a3, a4, a6, a7, v79, v48, v55, v82);
  BrotliFree(v22);
  v57 = *v53 << 6;
  v53[19] = v57;
  v58 = v53;
  if (v57)
  {
    v59 = BrotliAllocate(v22);
    v53[18] = v59;
    v60 = (v53 + 18);
    v61 = v53[19];
    v53[23] = v61;
    v62 = v53 + 23;
    if (v61)
    {
      v63 = BrotliAllocate(v22);
      v64 = *v60;
    }

    else
    {
      v64 = v59;
      v63 = 0;
    }
  }

  else
  {
    v64 = 0;
    v63 = 0;
    v53[18] = 0;
    v60 = (v53 + 18);
    v53[23] = 0;
    v62 = v53 + 23;
  }

  v58[22] = v63;
  BrotliClusterHistogramsLiteral(v22, v48, v47, 0x100uLL, v63, v62, v64);
  BrotliFree(v22);
  if (*(a5 + 32))
  {
    v65 = *v58;
    if (*v58)
    {
      v66 = *v60;
      v67 = &(*v60)[64 * v65];
      do
      {
        v68 = &v66[--v65];
        v69 = vld1q_dup_f32(v68);
        v70 = 0x3FFFFFFFFFFFFFC0;
        do
        {
          *&v67[v70] = v69;
          v70 += 4;
        }

        while (v70 * 4);
        v67 -= 64;
      }

      while (v65);
    }
  }

  v71 = v58[12];
  v58[21] = 4 * v71;
  if (4 * v71)
  {
    v72 = BrotliAllocate(v22);
    v73 = v58[21];
    v58[27] = v73;
    v74 = v58 + 27;
    v58[20] = v72;
    if (v73)
    {
      v75 = BrotliAllocate(v22);
      v77 = v58[20];
      v76 = v58[21];
    }

    else
    {
      v77 = v72;
      v76 = 0;
      v75 = 0;
    }
  }

  else
  {
    v77 = 0;
    v76 = 0;
    v75 = 0;
    v58[27] = 0;
    v74 = v58 + 27;
    v58[20] = 0;
  }

  v58[26] = v75;
  BrotliClusterHistogramsDistance(v22, v82, v76, 0x100uLL, v75, v74, v77);

  return BrotliFree(v22);
}

uint64_t ComputeDistanceCost(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, double *a5, void *a6)
{
  bzero(a6, 0x880uLL);
  *(a6 + 272) = 0;
  *(a6 + 273) = 0x7FF0000000000000;
  if (*a3 == *a4)
  {
    v12 = a3[1] != *(a4 + 4);
    if (a2)
    {
LABEL_3:
      v13 = 0;
      v14 = a1 + 8;
      v15 = 0.0;
      while (1)
      {
        if ((*(v14 - 4) & 0x1FFFFFF) != 0 && *(v14 + 4) >= 0x80u)
        {
          v16 = *(v14 + 6);
          if (v12)
          {
            v17 = v16 & 0x3FF;
            v18 = a3[1];
            if (v17 >= v18 + 16)
            {
              v17 = v18 + 16 + ((v17 - v18 - 16) & ~(-1 << *a3)) + ((*v14 + ((((v17 - v18 - 16) >> *a3) & 1 | 2) << (v16 >> 10)) - 4) << *a3);
            }

            if (*(a4 + 16) < v17)
            {
              return 0;
            }

            v19 = *(a4 + 4);
            v20 = v19 + 16;
            if (v19 + 16 <= v17)
            {
              v21 = v17 - v19 + (4 << *a4) - 16;
              v22 = (__clz(v21) ^ 0x1F) - 1;
              v16 = ((v21 & ~(-1 << *a4)) + v20 + ((((v21 >> v22) & 1 | (2 * (v22 - *a4))) + 65534) << *a4)) | ((v22 - *a4) << 10);
            }

            else
            {
              LOWORD(v16) = v17;
            }
          }

          ++*(a6 + (v16 & 0x3FF));
          *(a6 + 272) = ++v13;
          v15 = v15 + (v16 >> 10);
        }

        v14 += 16;
        if (!--a2)
        {
          goto LABEL_18;
        }
      }
    }
  }

  else
  {
    v12 = 1;
    if (a2)
    {
      goto LABEL_3;
    }
  }

  v15 = 0.0;
LABEL_18:
  BrotliPopulationCostDistance(a6);
  *a5 = v15 + v23;
  return 1;
}

uint64_t BrotliBuildMetaBlockGreedy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, unint64_t a8, uint64_t a9, unsigned int *a10, unint64_t a11, uint64_t a12)
{
  v18 = a11;
  v19 = a12;
  v20 = BrotliAllocate(a1);
  v21 = v20;
  v73 = a1;
  if (a8 == 1)
  {
    v22 = 0;
    if (a11)
    {
      v23 = a11;
      v24 = a10;
      do
      {
        v25 = *v24;
        v24 += 4;
        v22 += v25;
        --v23;
      }

      while (v23);
    }

    InitBlockSplitterLiteral(a1, v20, v22, a12, (a12 + 176), (a12 + 184));
    InitBlockSplitterCommand(a1, (v21 + 275), a11, a12 + 48, (a12 + 192), (a12 + 200));
    InitBlockSplitterDistance(a1, (v21 + 998), a11, a12 + 96, (a12 + 208), (a12 + 216));
    if (a11)
    {
      for (i = 0; i != a11; ++i)
      {
        v27 = &a10[4 * i];
        v29 = *v27;
        v28 = v27[1];
        v30 = *(v27 + 6);
        v31 = *(v27 + 7);
        BlockSplitterAddSymbolCommand(v21 + 275, *(v27 + 6));
        if (v29)
        {
          do
          {
            BlockSplitterAddSymbolLiteral(v21, *(a2 + (a3++ & a4)));
            --v29;
          }

          while (v29);
        }

        v32 = v28 & 0x1FFFFFF;
        if (v32 && v30 >= 0x80)
        {
          BlockSplitterAddSymbolDistance(v21 + 998, v31 & 0x3FF);
        }

        a3 += v32;
      }
    }

    BlockSplitterFinishBlockLiteral(v21, 1);
    BlockSplitterFinishBlockCommand(v21 + 275, 1);
    BlockSplitterFinishBlockDistance(v21 + 998, 1);
    v33 = v73;
  }

  else
  {
    v69 = a6;
    if (a11)
    {
      v34 = 0;
      v35 = a10;
      do
      {
        v36 = *v35;
        v35 += 4;
        v34 += v36;
        --v18;
      }

      while (v18);
      v18 = v34 >> 9;
    }

    v37 = v18 + 1;
    *v20 = 256;
    v20[1] = a8;
    v20[2] = 0x100 / a8;
    v20[3] = 512;
    v20[4] = 0x4079000000000000;
    v20[5] = 0;
    v20[6] = a12;
    v20[8] = a12 + 184;
    v20[9] = 512;
    v20[40] = 0;
    if (v18 + 1 >= 0x100 / a8 + 1)
    {
      v38 = 0x100 / a8 + 1;
    }

    else
    {
      v38 = v18 + 1;
    }

    v20[10] = 0;
    v20[11] = 0;
    v39 = *(a12 + 32);
    v67 = v38;
    if (v39 <= v18)
    {
      if (!v39)
      {
        v39 = v18 + 1;
      }

      do
      {
        v40 = v39;
        v39 *= 2;
      }

      while (v40 <= v18);
      __dst = BrotliAllocate(a1);
      v41 = *(a12 + 32);
      if (v41)
      {
        memcpy(__dst, *(a12 + 16), v41);
      }

      BrotliFree(a1);
      v38 = v67;
      *(a12 + 16) = __dst;
      *(a12 + 32) = v40;
      v19 = a12;
    }

    v42 = v19[5];
    if (v42 <= v18)
    {
      if (!v42)
      {
        v42 = v18 + 1;
      }

      do
      {
        v43 = v42;
        v42 *= 2;
      }

      while (v43 <= v18);
      v44 = BrotliAllocate(v73);
      v45 = v44;
      v46 = *(a12 + 40);
      if (v46)
      {
        memcpy(v44, *(a12 + 24), 4 * v46);
      }

      BrotliFree(v73);
      *(a12 + 24) = v45;
      *(a12 + 40) = v43;
      v19 = a12;
      v38 = v67;
    }

    v47 = a5;
    v48 = v69;
    v19[1] = v37;
    v19[23] = v38 * a8;
    if (v38 * a8)
    {
      v49 = BrotliAllocate(v73);
    }

    else
    {
      v49 = 0;
    }

    *(a12 + 176) = v49;
    v21[7] = v49;
    if (a8 <= 1)
    {
      v50 = 1;
    }

    else
    {
      v50 = a8;
    }

    do
    {
      bzero(v49, 0x400uLL);
      v49[128] = 0;
      v49[129] = 0x7FF0000000000000;
      v49 += 130;
      --v50;
    }

    while (v50);
    v21[12] = 0;
    v21[13] = 0;
    InitBlockSplitterCommand(v73, (v21 + 275), a11, a12 + 48, (a12 + 192), (a12 + 200));
    InitBlockSplitterDistance(v73, (v21 + 998), a11, a12 + 96, (a12 + 208), (a12 + 216));
    if (a11)
    {
      v51 = 0;
      do
      {
        v72 = v51;
        v52 = &a10[4 * v51];
        v53 = *v52;
        __dsta = *(v52 + 7);
        v68 = *(v52 + 6);
        v70 = v52[1];
        BlockSplitterAddSymbolCommand(v21 + 275, v68);
        if (v53)
        {
          do
          {
            v54 = *(a7 + 256 + v48);
            v48 = v47;
            v47 = *(a2 + (a3 & a4));
            v55 = v21[7] + 1040 * v21[11] + 1040 * *(a9 + 4 * (v54 | *(a7 + v48)));
            ++*(v55 + 4 * v47);
            ++*(v55 + 1024);
            v56 = v21[9];
            v57 = v21[10] + 1;
            v21[10] = v57;
            if (v57 == v56)
            {
              ContextBlockSplitterFinishBlock(v21, v73, 0);
            }

            ++a3;
            --v53;
          }

          while (v53);
        }

        v58 = v70 & 0x1FFFFFF;
        a3 += v58;
        if (v58)
        {
          v48 = *(a2 + ((a3 - 2) & a4));
          v47 = *(a2 + ((a3 - 1) & a4));
          if (v68 >= 0x80)
          {
            BlockSplitterAddSymbolDistance(v21 + 998, __dsta & 0x3FF);
          }
        }

        v51 = v72 + 1;
      }

      while (v72 + 1 != a11);
    }

    v33 = v73;
    ContextBlockSplitterFinishBlock(v21, v73, 1);
    BlockSplitterFinishBlockCommand(v21 + 275, 1);
    BlockSplitterFinishBlockDistance(v21 + 998, 1);
    v59 = *a12;
    v60 = *a12 << 6;
    *(a12 + 152) = v60;
    if (v60)
    {
      v61 = BrotliAllocate(v73);
      v59 = *a12;
    }

    else
    {
      v61 = 0;
    }

    *(a12 + 144) = v61;
    if (v59)
    {
      for (j = 0; j != v59; ++j)
      {
        for (k = 0; k != 256; k += 4)
        {
          *(v61 + k) = *(a9 + k) + j * a8;
        }

        v61 += 256;
      }
    }
  }

  return BrotliFree(v33);
}

void BrotliOptimizeHistograms(unsigned int a1, void *a2)
{
  v11 = *MEMORY[0x1E69E9840];
  if (a2[23])
  {
    v4 = 0;
    v5 = 0;
    do
    {
      BrotliOptimizeHuffmanCountsForRle(0x100uLL, (a2[22] + v4), v10);
      ++v5;
      v4 += 1040;
    }

    while (v5 < a2[23]);
  }

  if (a2[25])
  {
    v6 = 0;
    v7 = 0;
    do
    {
      BrotliOptimizeHuffmanCountsForRle(0x2C0uLL, (a2[24] + v6), v10);
      ++v7;
      v6 += 2832;
    }

    while (v7 < a2[25]);
  }

  if (a2[27])
  {
    v8 = 0;
    v9 = 0;
    do
    {
      BrotliOptimizeHuffmanCountsForRle(a1, (a2[26] + v8), v10);
      ++v9;
      v8 += 2192;
    }

    while (v9 < a2[27]);
  }
}

double InitBlockSplitterLiteral(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  v11 = a3 >> 9;
  v12 = (a3 >> 9) + 1;
  *a2 = xmmword_1AB480490;
  *(a2 + 16) = 0x4079000000000000;
  *(a2 + 24) = 0;
  *(a2 + 32) = a4;
  *(a2 + 48) = a6;
  *(a2 + 2136) = 512;
  *(a2 + 2192) = 0;
  *(a2 + 2144) = 0u;
  v13 = *(a4 + 32);
  if (v13 <= a3 >> 9)
  {
    if (!v13)
    {
      v13 = (a3 >> 9) + 1;
    }

    do
    {
      v14 = v13;
      v13 *= 2;
    }

    while (v14 <= v11);
    v15 = BrotliAllocate(a1);
    v16 = v15;
    v17 = *(a4 + 32);
    if (v17)
    {
      memcpy(v15, *(a4 + 16), v17);
    }

    BrotliFree(a1);
    *(a4 + 16) = v16;
    *(a4 + 32) = v14;
  }

  v18 = *(a4 + 40);
  if (v18 <= v11)
  {
    if (!v18)
    {
      v18 = v12;
    }

    do
    {
      v19 = v18;
      v18 *= 2;
    }

    while (v19 <= v11);
    v20 = BrotliAllocate(a1);
    v21 = v20;
    v22 = *(a4 + 40);
    if (v22)
    {
      memcpy(v20, *(a4 + 24), 4 * v22);
    }

    BrotliFree(a1);
    *(a4 + 24) = v21;
    *(a4 + 40) = v19;
  }

  v23 = 257;
  if (v12 < 0x101)
  {
    v23 = v12;
  }

  *(*(a2 + 32) + 8) = v12;
  *a6 = v23;
  v24 = BrotliAllocate(a1);
  *a5 = v24;
  *(a2 + 40) = v24;
  bzero(v24, 0x400uLL);
  v24[128] = 0;
  v24[129] = 0x7FF0000000000000;
  result = 0.0;
  *(a2 + 2160) = 0u;
  return result;
}

double InitBlockSplitterCommand(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  v11 = a3 >> 10;
  v12 = (a3 >> 10) + 1;
  *a2 = xmmword_1AB4804A0;
  *(a2 + 16) = 0x407F400000000000;
  *(a2 + 24) = 0;
  *(a2 + 32) = a4;
  *(a2 + 48) = a6;
  *(a2 + 5720) = 1024;
  *(a2 + 5776) = 0;
  *(a2 + 5728) = 0u;
  v13 = *(a4 + 32);
  if (v13 <= a3 >> 10)
  {
    if (!v13)
    {
      v13 = (a3 >> 10) + 1;
    }

    do
    {
      v14 = v13;
      v13 *= 2;
    }

    while (v14 <= v11);
    v15 = BrotliAllocate(a1);
    v16 = v15;
    v17 = *(a4 + 32);
    if (v17)
    {
      memcpy(v15, *(a4 + 16), v17);
    }

    BrotliFree(a1);
    *(a4 + 16) = v16;
    *(a4 + 32) = v14;
  }

  v18 = *(a4 + 40);
  if (v18 <= v11)
  {
    if (!v18)
    {
      v18 = v12;
    }

    do
    {
      v19 = v18;
      v18 *= 2;
    }

    while (v19 <= v11);
    v20 = BrotliAllocate(a1);
    v21 = v20;
    v22 = *(a4 + 40);
    if (v22)
    {
      memcpy(v20, *(a4 + 24), 4 * v22);
    }

    BrotliFree(a1);
    *(a4 + 24) = v21;
    *(a4 + 40) = v19;
  }

  v23 = 257;
  if (v12 < 0x101)
  {
    v23 = v12;
  }

  *(*(a2 + 32) + 8) = v12;
  *a6 = v23;
  v24 = BrotliAllocate(a1);
  *a5 = v24;
  *(a2 + 40) = v24;
  bzero(v24, 0xB00uLL);
  v24[352] = 0;
  v24[353] = 0x7FF0000000000000;
  result = 0.0;
  *(a2 + 5744) = 0u;
  return result;
}

double InitBlockSplitterDistance(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  v11 = a3 >> 9;
  v12 = (a3 >> 9) + 1;
  *a2 = xmmword_1AB4804B0;
  *(a2 + 16) = 0x4059000000000000;
  *(a2 + 24) = 0;
  *(a2 + 32) = a4;
  *(a2 + 48) = a6;
  *(a2 + 4440) = 512;
  *(a2 + 4496) = 0;
  *(a2 + 4448) = 0u;
  v13 = *(a4 + 32);
  if (v13 <= a3 >> 9)
  {
    if (!v13)
    {
      v13 = (a3 >> 9) + 1;
    }

    do
    {
      v14 = v13;
      v13 *= 2;
    }

    while (v14 <= v11);
    v15 = BrotliAllocate(a1);
    v16 = v15;
    v17 = *(a4 + 32);
    if (v17)
    {
      memcpy(v15, *(a4 + 16), v17);
    }

    BrotliFree(a1);
    *(a4 + 16) = v16;
    *(a4 + 32) = v14;
  }

  v18 = *(a4 + 40);
  if (v18 <= v11)
  {
    if (!v18)
    {
      v18 = v12;
    }

    do
    {
      v19 = v18;
      v18 *= 2;
    }

    while (v19 <= v11);
    v20 = BrotliAllocate(a1);
    v21 = v20;
    v22 = *(a4 + 40);
    if (v22)
    {
      memcpy(v20, *(a4 + 24), 4 * v22);
    }

    BrotliFree(a1);
    *(a4 + 24) = v21;
    *(a4 + 40) = v19;
  }

  v23 = 257;
  if (v12 < 0x101)
  {
    v23 = v12;
  }

  *(*(a2 + 32) + 8) = v12;
  *a6 = v23;
  v24 = BrotliAllocate(a1);
  *a5 = v24;
  *(a2 + 40) = v24;
  bzero(v24, 0x880uLL);
  v24[272] = 0;
  v24[273] = 0x7FF0000000000000;
  result = 0.0;
  *(a2 + 4464) = 0u;
  return result;
}

void BlockSplitterAddSymbolCommand(void *a1, uint64_t a2)
{
  v2 = a1[5] + 2832 * a1[717];
  ++*(v2 + 4 * a2);
  ++*(v2 + 2816);
  v3 = a1[716] + 1;
  a1[716] = v3;
  if (v3 == a1[715])
  {
    BlockSplitterFinishBlockCommand(a1, 0);
  }
}

void BlockSplitterAddSymbolLiteral(void *a1, uint64_t a2)
{
  v2 = a1[5] + 1040 * a1[269];
  ++*(v2 + 4 * a2);
  ++*(v2 + 1024);
  v3 = a1[268] + 1;
  a1[268] = v3;
  if (v3 == a1[267])
  {
    BlockSplitterFinishBlockLiteral(a1, 0);
  }
}

void BlockSplitterAddSymbolDistance(void *a1, uint64_t a2)
{
  v2 = a1[5] + 2192 * a1[557];
  ++*(v2 + 4 * a2);
  ++*(v2 + 2176);
  v3 = a1[556] + 1;
  a1[556] = v3;
  if (v3 == a1[555])
  {
    BlockSplitterFinishBlockDistance(a1, 0);
  }
}

void BlockSplitterFinishBlockLiteral(void *a1, int a2)
{
  v3 = a1;
  v4 = a1[4];
  v5 = a1[5];
  v6 = a1[268];
  if (v6 <= a1[1])
  {
    v6 = a1[1];
  }

  a1[268] = v6;
  if (!a1[3])
  {
    v12 = 0;
    v13 = 0;
    v14 = v4[2];
    *v4[3] = v6;
    *v14 = 0;
    v15 = &v5[*a1];
    v16 = 0.0;
    v17 = v5;
    if (*a1)
    {
      goto LABEL_13;
    }

    while (1)
    {
      if (v17 >= v15)
      {
        v26 = v12;
        if (v12)
        {
          if (v12 > 0xFF)
          {
            v27 = log2(v12);
          }

          else
          {
            v27 = kBrotliLog2Table[v12];
          }

          v16 = v16 + v26 * v27;
        }

        if (v16 >= v26)
        {
          v28 = v16;
        }

        else
        {
          v28 = v12;
        }

        *(v3 + 272) = v28;
        *(v3 + 273) = v28;
        ++v3[3];
        ++*v4;
        v29 = v3[269] + 1;
        v3[269] = v29;
        if (v29 < *v3[6])
        {
          v30 = &v5[260 * v29];
          bzero(v30, 0x400uLL);
          *(v30 + 128) = 0;
          *(v30 + 129) = 0x7FF0000000000000;
        }

        v3[268] = 0;
        goto LABEL_85;
      }

      v19 = *v17++;
      v18 = v19;
      v13 = v12 + v19;
      v20 = v19;
      if (v19 > 0xFF)
      {
        v21 = log2(v20);
      }

      else
      {
        v21 = kBrotliLog2Table[v18];
      }

      v16 = v16 - v20 * v21;
LABEL_13:
      v23 = *v17++;
      v22 = v23;
      v12 = v13 + v23;
      v24 = v23;
      if (v23 > 0xFF)
      {
        v25 = log2(v24);
      }

      else
      {
        v25 = kBrotliLog2Table[v22];
      }

      v16 = v16 - v24 * v25;
    }
  }

  if (!v6)
  {
    goto LABEL_85;
  }

  v84 = a1[3];
  v7 = 0;
  v8 = 0;
  v92 = a1 + 272;
  v9 = &v5[260 * a1[269]];
  v10 = &v9[*a1];
  v11 = 0.0;
  v89 = *a1;
  if ((*a1 & 1) == 0)
  {
    goto LABEL_28;
  }

  while (1)
  {
    v36 = *v9++;
    v35 = v36;
    v7 = v8 + v36;
    v37 = v36;
    v38 = v36 > 0xFF ? log2(v37) : kBrotliLog2Table[v35];
    v11 = v11 - v37 * v38;
LABEL_28:
    if (v9 >= v10)
    {
      break;
    }

    v32 = *v9++;
    v31 = v32;
    v8 = v7 + v32;
    v33 = v32;
    if (v32 > 0xFF)
    {
      v34 = log2(v33);
    }

    else
    {
      v34 = kBrotliLog2Table[v31];
    }

    v11 = v11 - v33 * v34;
  }

  v39 = v7;
  v86 = a2;
  v85 = v4;
  if (v7)
  {
    if (v7 > 0xFF)
    {
      v40 = log2(v7);
    }

    else
    {
      v40 = kBrotliLog2Table[v7];
    }

    v11 = v11 + v39 * v40;
  }

  v41 = 0;
  if (v11 < v39)
  {
    v11 = v7;
  }

  v90 = v3 + 270;
  v91 = (v3 + 7);
  v87 = v3;
  __src = &v5[260 * v3[269]];
  v42 = &v96;
  v43 = &v94;
  v44 = 1;
  do
  {
    v45 = v44;
    v46 = v90[v41];
    v47 = &v91[1040 * v41];
    memcpy(v47, __src, 0x410uLL);
    v48 = 0;
    v49 = v5;
    v50 = &v5[260 * v46];
    *(v47 + 128) += *(v50 + 128);
    do
    {
      *&v47[v48 * 4] += v50[v48];
      ++v48;
    }

    while (v48 != 256);
    v51 = 0;
    v52 = 0;
    v53 = &v47[4 * v89];
    v54 = 0.0;
    if (v89)
    {
      goto LABEL_57;
    }

    while (v47 < v53)
    {
      v56 = *v47;
      v47 += 4;
      v55 = v56;
      v52 = v51 + v56;
      v57 = v56;
      if (v56 > 0xFF)
      {
        v58 = log2(v57);
      }

      else
      {
        v58 = kBrotliLog2Table[v55];
      }

      v54 = v54 - v57 * v58;
LABEL_57:
      v62 = *v47;
      v47 += 4;
      v61 = v62;
      v51 = v52 + v62;
      v63 = v62;
      if (v62 > 0xFF)
      {
        v64 = log2(v63);
      }

      else
      {
        v64 = kBrotliLog2Table[v61];
      }

      v54 = v54 - v63 * v64;
    }

    v59 = v51;
    if (v51)
    {
      v5 = v49;
      if (v51 > 0xFF)
      {
        v60 = log2(v51);
      }

      else
      {
        v60 = kBrotliLog2Table[v51];
      }

      v54 = v54 + v59 * v60;
    }

    else
    {
      v5 = v49;
    }

    v44 = 0;
    if (v54 >= v59)
    {
      v65 = v54;
    }

    else
    {
      v65 = v51;
    }

    *v42 = v65;
    *v43 = v65 - v11 - *&v92[v41];
    v42 = &v95;
    v43 = &v93;
    v41 = 1;
  }

  while ((v45 & 1) != 0);
  v4 = v85;
  v66 = *v85;
  a2 = v86;
  if (*v85 >= 0x100uLL)
  {
    v67 = v93;
    v68 = v94;
    v3 = v87;
    v71 = v84;
  }

  else
  {
    v67 = v93;
    v68 = v94;
    v3 = v87;
    v69 = *(v87 + 2);
    v70 = v94 <= v69 || v93 <= v69;
    v71 = v84;
    if (!v70)
    {
      v72 = v85[2];
      *(v85[3] + 4 * v84) = v87[268];
      *(v72 + v84) = v66;
      v87[271] = v87[270];
      v87[270] = *v85;
      v87[273] = v87[272];
      *(v87 + 272) = v11;
      ++v87[3];
      ++*v85;
      v73 = v87[269] + 1;
      v87[269] = v73;
      if (v73 < *v87[6])
      {
        v74 = &v5[260 * v73];
        bzero(v74, 0x400uLL);
        *(v74 + 128) = 0;
        *(v74 + 129) = 0x7FF0000000000000;
      }

      v87[268] = 0;
LABEL_79:
      v3[274] = 0;
      v80 = v3[1];
LABEL_84:
      v3[267] = v80;
      goto LABEL_85;
    }
  }

  v75 = *(v3 + 536);
  v76 = (v85[3] + 4 * v71);
  if (v67 < v68 + -20.0)
  {
    *v76 = v75;
    *(v85[2] + v71) = *(v85[2] + v71 - 2);
    v77 = v3[270];
    v78 = v3[271];
    v3[270] = v78;
    v3[271] = v77;
    memcpy(&v5[260 * v78], v3 + 137, 0x410uLL);
    v3[273] = v3[272];
    v3[272] = v95;
    ++v3[3];
    v3[268] = 0;
    v79 = &v5[260 * v3[269]];
    bzero(v79, 0x400uLL);
    *(v79 + 128) = 0;
    *(v79 + 129) = 0x7FF0000000000000;
    goto LABEL_79;
  }

  *(v76 - 1) += v75;
  memcpy(&v5[260 * *v90], v91, 0x410uLL);
  v81 = v96;
  *v92 = v96;
  if (*v85 == 1)
  {
    v3[273] = v81;
  }

  v3[268] = 0;
  v82 = &v5[260 * v3[269]];
  bzero(v82, 0x400uLL);
  *(v82 + 128) = 0;
  *(v82 + 129) = 0x7FF0000000000000;
  v83 = v3[274] + 1;
  v3[274] = v83;
  if (v83 >= 2)
  {
    v80 = v3[267] + v3[1];
    goto LABEL_84;
  }

LABEL_85:
  if (a2)
  {
    *v3[6] = *v4;
    v4[1] = v3[3];
  }
}

void ContextBlockSplitterFinishBlock(uint64_t *a1, uint64_t a2, int a3)
{
  v3 = a1;
  v128[13] = *MEMORY[0x1E69E9840];
  v4 = a1[1];
  v5 = a1[6];
  v6 = a1[7];
  v7 = a1[10];
  v8 = a1[3];
  if (v7 < v8)
  {
    a1[10] = v8;
    v7 = v8;
  }

  v9 = (a1 + 14);
  v119 = v4;
  if (!a1[5])
  {
    v112 = a3;
    v11 = v5[2];
    v114 = v5;
    *v5[3] = v7;
    *v11 = 0;
    if (!v4)
    {
LABEL_29:
      ++v3[5];
      v5 = v114;
      ++*v114;
      v35 = v3[11] + v4;
      v3[11] = v35;
      if (v35 < *v3[8])
      {
        v36 = v3[1];
        if (v36)
        {
          v37 = (v3[7] + 1040 * v35);
          do
          {
            bzero(v37, 0x400uLL);
            v37[128] = 0;
            v37[129] = 0x7FF0000000000000;
            v37 += 130;
            --v36;
          }

          while (v36);
        }
      }

      v3[10] = 0;
      goto LABEL_106;
    }

    v12 = *a1;
    v13 = *a1;
    v14 = v4;
    while (1)
    {
      v15 = v9;
      v16 = v6;
      v17 = 0;
      v18 = 0;
      v19 = &v16[v13];
      v20 = 0.0;
      v21 = v16;
      if (v12)
      {
        goto LABEL_18;
      }

      while (v16 < v19)
      {
        v23 = *v16++;
        v22 = v23;
        v18 = v17 + v23;
        v24 = v23;
        if (v23 > 0xFF)
        {
          v25 = log2(v24);
        }

        else
        {
          v25 = kBrotliLog2Table[v22];
        }

        v20 = v20 - v24 * v25;
LABEL_18:
        v30 = *v16++;
        v29 = v30;
        v17 = v18 + v30;
        v31 = v30;
        if (v30 > 0xFF)
        {
          v32 = log2(v31);
        }

        else
        {
          v32 = kBrotliLog2Table[v29];
        }

        v20 = v20 - v31 * v32;
      }

      v26 = v17;
      if (v17)
      {
        v4 = v119;
        v27 = v15;
        if (v17 > 0xFF)
        {
          v28 = log2(v17);
        }

        else
        {
          v28 = kBrotliLog2Table[v17];
        }

        v33 = v21;
        v20 = v20 + v26 * v28;
      }

      else
      {
        v4 = v119;
        v27 = v15;
        v33 = v21;
      }

      if (v20 >= v26)
      {
        v34 = v20;
      }

      else
      {
        v34 = v26;
      }

      *v27 = v34;
      v27[v4] = v34;
      v9 = v27 + 1;
      v6 = v33 + 260;
      if (!--v14)
      {
        goto LABEL_29;
      }
    }
  }

  if (!v7)
  {
    goto LABEL_107;
  }

  v113 = v5;
  v115 = v6;
  v112 = a3;
  if ((v4 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    v10 = BrotliAllocate(a2);
    v125 = 0.0;
    v126 = 0.0;
LABEL_35:
    v38 = 0;
    v39 = *v3;
    v117 = v3 + 12;
    v118 = v10;
    v116 = 1040 * v4;
    v123 = v6;
    v124 = v10;
    v122 = v3;
    while (1)
    {
      v40 = 0;
      v41 = 0;
      v42 = &v6[260 * v3[11] + 260 * v38];
      v43 = &v42[v39];
      v44 = 0.0;
      __src = v42;
      if (v39)
      {
        goto LABEL_45;
      }

      while (v42 < v43)
      {
        v46 = *v42++;
        v45 = v46;
        v41 = v40 + v46;
        v47 = v46;
        if (v46 > 0xFF)
        {
          v48 = log2(v47);
        }

        else
        {
          v48 = kBrotliLog2Table[v45];
        }

        v44 = v44 - v47 * v48;
LABEL_45:
        v52 = *v42++;
        v51 = v52;
        v40 = v41 + v52;
        v53 = v52;
        if (v52 > 0xFF)
        {
          v54 = log2(v53);
        }

        else
        {
          v54 = kBrotliLog2Table[v51];
        }

        v44 = v44 - v53 * v54;
      }

      v49 = v40;
      if (v40)
      {
        if (v40 > 0xFF)
        {
          v50 = log2(v40);
        }

        else
        {
          v50 = kBrotliLog2Table[v40];
        }

        v44 = v44 + v49 * v50;
      }

      v55 = 0;
      if (v44 < v49)
      {
        v44 = v40;
      }

      *&v128[v38] = v44;
      v56 = v38;
      v120 = &v6[260 * v38];
      v57 = &v126;
      v58 = 1;
      do
      {
        v59 = v9;
        v60 = v58;
        v61 = v56 + v55 * v4;
        v62 = v117[v55];
        v63 = (v118 + 1040 * v61);
        memcpy(v63, __src, 0x410uLL);
        v64 = 0;
        *(v63 + 128) += *&v120[260 * v62 + 256];
        do
        {
          *(v124 + v116 * v55 + v64 * 4) += v123[260 * v62 + v64];
          ++v64;
        }

        while (v64 != 256);
        v65 = 0;
        v66 = 0;
        v39 = *v122;
        v67 = &v63[4 * *v122];
        v68 = 0.0;
        if (*v122)
        {
          goto LABEL_65;
        }

        while (v63 < v67)
        {
          v70 = *v63;
          v63 += 4;
          v69 = v70;
          v66 = v65 + v70;
          v71 = v70;
          if (v70 > 0xFF)
          {
            v72 = log2(v71);
          }

          else
          {
            v72 = kBrotliLog2Table[v69];
          }

          v68 = v68 - v71 * v72;
LABEL_65:
          v76 = *v63;
          v63 += 4;
          v75 = v76;
          v65 = v66 + v76;
          v77 = v76;
          if (v76 > 0xFF)
          {
            v78 = log2(v77);
          }

          else
          {
            v78 = kBrotliLog2Table[v75];
          }

          v68 = v68 - v77 * v78;
        }

        v73 = v65;
        if (v65)
        {
          v4 = v119;
          v9 = v59;
          if (v65 > 0xFF)
          {
            v74 = log2(v65);
          }

          else
          {
            v74 = kBrotliLog2Table[v65];
          }

          v68 = v68 + v73 * v74;
        }

        else
        {
          v4 = v119;
          v9 = v59;
        }

        v58 = 0;
        if (v68 >= v73)
        {
          v79 = v68;
        }

        else
        {
          v79 = v65;
        }

        v127[v61] = v79;
        *v57 = *v57 + v79 - v44 - v9[v61];
        v57 = &v125;
        v55 = 1;
      }

      while ((v60 & 1) != 0);
      v38 = v56 + 1;
      v3 = v122;
      v123 += 260;
      v124 += 1040;
      v6 = v115;
      if (v38 == v4)
      {
        v80 = 0;
        v5 = v113;
        goto LABEL_78;
      }
    }
  }

  v10 = 0;
  v125 = 0.0;
  v126 = 0.0;
  if (v4)
  {
    goto LABEL_35;
  }

  v118 = 0;
  v80 = 1;
LABEL_78:
  v81 = *v5;
  if (*v5 >= v3[2])
  {
    v82 = v125;
    v83 = v126;
  }

  else
  {
    v82 = v125;
    v83 = v126;
    v84 = *(v3 + 4);
    if (v126 > v84 && v125 > v84)
    {
      v86 = v3[5];
      v87 = v5[2];
      *(v5[3] + 4 * v86) = v3[10];
      *(v87 + v86) = v81;
      v3[13] = v3[12];
      v3[12] = *v5 * v4;
      if ((v80 & 1) == 0)
      {
        v88 = v128;
        v89 = v4;
        do
        {
          v9[v4] = *v9;
          v90 = *v88++;
          *v9++ = v90;
          --v89;
        }

        while (v89);
      }

      ++v3[5];
      ++*v5;
      v91 = v3[11] + v4;
      v3[11] = v91;
      if (v91 < *v3[8])
      {
        v92 = v3[1];
        if (v92)
        {
          v93 = (v3[7] + 1040 * v91);
          do
          {
            bzero(v93, 0x400uLL);
            v93[128] = 0;
            v93[129] = 0x7FF0000000000000;
            v93 += 130;
            --v92;
          }

          while (v92);
        }
      }

      v3[40] = 0;
      v94 = v3[3];
      v3[10] = 0;
      goto LABEL_104;
    }
  }

  v95 = *(v3 + 20);
  v96 = v3[5];
  v97 = (v5[3] + 4 * v96);
  if (v82 < v83 + -20.0)
  {
    *v97 = v95;
    *(v5[2] + v96) = *(v5[2] + v96 - 2);
    *(v3 + 6) = vextq_s8(*(v3 + 6), *(v3 + 6), 8uLL);
    v98 = v9;
    if ((v80 & 1) == 0)
    {
      v99 = 0;
      v100 = v127;
      v101 = v4;
      do
      {
        memcpy(&v115[260 * v3[12] + v99], (v118 + 1040 * v4 + v99 * 4), 0x410uLL);
        v98[v4] = *v98;
        *v98++ = v100[v4];
        v102 = &v115[260 * v3[11] + v99];
        bzero(v102, 0x400uLL);
        *(v102 + 128) = 0;
        *(v102 + 129) = 0x7FF0000000000000;
        ++v100;
        v99 += 260;
        --v101;
      }

      while (v101);
    }

    ++v3[5];
    v3[40] = 0;
    v3[9] = v3[3];
    v3[10] = 0;
    v5 = v113;
    goto LABEL_105;
  }

  *(v97 - 1) += v95;
  v103 = v115;
  if ((v80 & 1) == 0)
  {
    v104 = v9;
    v105 = 0;
    v106 = v127;
    v107 = v4;
    do
    {
      memcpy(&v103[260 * v3[12] + v105], (v118 + v105 * 4), 0x410uLL);
      v108 = *v106;
      *v104 = *v106;
      if (*v5 == 1)
      {
        v104[v4] = v108;
      }

      v103 = v115;
      v109 = &v115[260 * v3[11] + v105];
      bzero(v109, 0x400uLL);
      *(v109 + 128) = 0;
      *(v109 + 129) = 0x7FF0000000000000;
      ++v104;
      ++v106;
      v105 += 260;
      --v107;
    }

    while (v107);
  }

  v3[10] = 0;
  v110 = v3[40] + 1;
  v3[40] = v110;
  if (v110 < 2)
  {
    goto LABEL_105;
  }

  v94 = v3[9] + v3[3];
LABEL_104:
  v3[9] = v94;
LABEL_105:
  BrotliFree(a2);
LABEL_106:
  a3 = v112;
LABEL_107:
  if (a3)
  {
    *v3[8] = *v5 * v4;
    v5[1] = v3[5];
  }
}

void BlockSplitterFinishBlockCommand(void *a1, int a2)
{
  v3 = a1;
  v4 = a1[4];
  v5 = a1[5];
  v6 = a1[716];
  if (v6 <= a1[1])
  {
    v6 = a1[1];
  }

  a1[716] = v6;
  if (!a1[3])
  {
    v12 = 0;
    v13 = 0;
    v14 = v4[2];
    *v4[3] = v6;
    *v14 = 0;
    v15 = &v5[*a1];
    v16 = 0.0;
    v17 = v5;
    if (*a1)
    {
      goto LABEL_13;
    }

    while (1)
    {
      if (v17 >= v15)
      {
        v26 = v12;
        if (v12)
        {
          if (v12 > 0xFF)
          {
            v27 = log2(v12);
          }

          else
          {
            v27 = kBrotliLog2Table[v12];
          }

          v16 = v16 + v26 * v27;
        }

        if (v16 >= v26)
        {
          v28 = v16;
        }

        else
        {
          v28 = v12;
        }

        *(v3 + 720) = v28;
        *(v3 + 721) = v28;
        ++v3[3];
        ++*v4;
        v29 = v3[717] + 1;
        v3[717] = v29;
        if (v29 < *v3[6])
        {
          v30 = &v5[708 * v29];
          bzero(v30, 0xB00uLL);
          *(v30 + 352) = 0;
          *(v30 + 353) = 0x7FF0000000000000;
        }

        v3[716] = 0;
        goto LABEL_85;
      }

      v19 = *v17++;
      v18 = v19;
      v13 = v12 + v19;
      v20 = v19;
      if (v19 > 0xFF)
      {
        v21 = log2(v20);
      }

      else
      {
        v21 = kBrotliLog2Table[v18];
      }

      v16 = v16 - v20 * v21;
LABEL_13:
      v23 = *v17++;
      v22 = v23;
      v12 = v13 + v23;
      v24 = v23;
      if (v23 > 0xFF)
      {
        v25 = log2(v24);
      }

      else
      {
        v25 = kBrotliLog2Table[v22];
      }

      v16 = v16 - v24 * v25;
    }
  }

  if (!v6)
  {
    goto LABEL_85;
  }

  v84 = a1[3];
  v7 = 0;
  v8 = 0;
  v92 = a1 + 720;
  v9 = &v5[708 * a1[717]];
  v10 = &v9[*a1];
  v11 = 0.0;
  v89 = *a1;
  if ((*a1 & 1) == 0)
  {
    goto LABEL_28;
  }

  while (1)
  {
    v36 = *v9++;
    v35 = v36;
    v7 = v8 + v36;
    v37 = v36;
    v38 = v36 > 0xFF ? log2(v37) : kBrotliLog2Table[v35];
    v11 = v11 - v37 * v38;
LABEL_28:
    if (v9 >= v10)
    {
      break;
    }

    v32 = *v9++;
    v31 = v32;
    v8 = v7 + v32;
    v33 = v32;
    if (v32 > 0xFF)
    {
      v34 = log2(v33);
    }

    else
    {
      v34 = kBrotliLog2Table[v31];
    }

    v11 = v11 - v33 * v34;
  }

  v39 = v7;
  v86 = a2;
  v85 = v4;
  if (v7)
  {
    if (v7 > 0xFF)
    {
      v40 = log2(v7);
    }

    else
    {
      v40 = kBrotliLog2Table[v7];
    }

    v11 = v11 + v39 * v40;
  }

  v41 = 0;
  if (v11 < v39)
  {
    v11 = v7;
  }

  v90 = v3 + 718;
  v91 = (v3 + 7);
  v87 = v3;
  __src = &v5[708 * v3[717]];
  v42 = &v96;
  v43 = &v94;
  v44 = 1;
  do
  {
    v45 = v44;
    v46 = v90[v41];
    v47 = &v91[2832 * v41];
    memcpy(v47, __src, 0xB10uLL);
    v48 = 0;
    v49 = v5;
    v50 = &v5[708 * v46];
    *(v47 + 352) += *(v50 + 352);
    do
    {
      *&v47[v48 * 4] += v50[v48];
      ++v48;
    }

    while (v48 != 704);
    v51 = 0;
    v52 = 0;
    v53 = &v47[4 * v89];
    v54 = 0.0;
    if (v89)
    {
      goto LABEL_57;
    }

    while (v47 < v53)
    {
      v56 = *v47;
      v47 += 4;
      v55 = v56;
      v52 = v51 + v56;
      v57 = v56;
      if (v56 > 0xFF)
      {
        v58 = log2(v57);
      }

      else
      {
        v58 = kBrotliLog2Table[v55];
      }

      v54 = v54 - v57 * v58;
LABEL_57:
      v62 = *v47;
      v47 += 4;
      v61 = v62;
      v51 = v52 + v62;
      v63 = v62;
      if (v62 > 0xFF)
      {
        v64 = log2(v63);
      }

      else
      {
        v64 = kBrotliLog2Table[v61];
      }

      v54 = v54 - v63 * v64;
    }

    v59 = v51;
    if (v51)
    {
      v5 = v49;
      if (v51 > 0xFF)
      {
        v60 = log2(v51);
      }

      else
      {
        v60 = kBrotliLog2Table[v51];
      }

      v54 = v54 + v59 * v60;
    }

    else
    {
      v5 = v49;
    }

    v44 = 0;
    if (v54 >= v59)
    {
      v65 = v54;
    }

    else
    {
      v65 = v51;
    }

    *v42 = v65;
    *v43 = v65 - v11 - *&v92[v41];
    v42 = &v95;
    v43 = &v93;
    v41 = 1;
  }

  while ((v45 & 1) != 0);
  v4 = v85;
  v66 = *v85;
  a2 = v86;
  if (*v85 >= 0x100uLL)
  {
    v67 = v93;
    v68 = v94;
    v3 = v87;
    v71 = v84;
  }

  else
  {
    v67 = v93;
    v68 = v94;
    v3 = v87;
    v69 = *(v87 + 2);
    v70 = v94 <= v69 || v93 <= v69;
    v71 = v84;
    if (!v70)
    {
      v72 = v85[2];
      *(v85[3] + 4 * v84) = v87[716];
      *(v72 + v84) = v66;
      v87[719] = v87[718];
      v87[718] = *v85;
      v87[721] = v87[720];
      *(v87 + 720) = v11;
      ++v87[3];
      ++*v85;
      v73 = v87[717] + 1;
      v87[717] = v73;
      if (v73 < *v87[6])
      {
        v74 = &v5[708 * v73];
        bzero(v74, 0xB00uLL);
        *(v74 + 352) = 0;
        *(v74 + 353) = 0x7FF0000000000000;
      }

      v87[716] = 0;
LABEL_79:
      v3[722] = 0;
      v80 = v3[1];
LABEL_84:
      v3[715] = v80;
      goto LABEL_85;
    }
  }

  v75 = *(v3 + 1432);
  v76 = (v85[3] + 4 * v71);
  if (v67 < v68 + -20.0)
  {
    *v76 = v75;
    *(v85[2] + v71) = *(v85[2] + v71 - 2);
    v77 = v3[718];
    v78 = v3[719];
    v3[718] = v78;
    v3[719] = v77;
    memcpy(&v5[708 * v78], v3 + 361, 0xB10uLL);
    v3[721] = v3[720];
    v3[720] = v95;
    ++v3[3];
    v3[716] = 0;
    v79 = &v5[708 * v3[717]];
    bzero(v79, 0xB00uLL);
    *(v79 + 352) = 0;
    *(v79 + 353) = 0x7FF0000000000000;
    goto LABEL_79;
  }

  *(v76 - 1) += v75;
  memcpy(&v5[708 * *v90], v91, 0xB10uLL);
  v81 = v96;
  *v92 = v96;
  if (*v85 == 1)
  {
    v3[721] = v81;
  }

  v3[716] = 0;
  v82 = &v5[708 * v3[717]];
  bzero(v82, 0xB00uLL);
  *(v82 + 352) = 0;
  *(v82 + 353) = 0x7FF0000000000000;
  v83 = v3[722] + 1;
  v3[722] = v83;
  if (v83 >= 2)
  {
    v80 = v3[715] + v3[1];
    goto LABEL_84;
  }

LABEL_85:
  if (a2)
  {
    *v3[6] = *v4;
    v4[1] = v3[3];
  }
}

void BlockSplitterFinishBlockDistance(void *a1, int a2)
{
  v3 = a1;
  v4 = a1[4];
  v5 = a1[5];
  v6 = a1[556];
  if (v6 <= a1[1])
  {
    v6 = a1[1];
  }

  a1[556] = v6;
  if (!a1[3])
  {
    v12 = 0;
    v13 = 0;
    v14 = v4[2];
    *v4[3] = v6;
    *v14 = 0;
    v15 = &v5[*a1];
    v16 = 0.0;
    v17 = v5;
    if (*a1)
    {
      goto LABEL_13;
    }

    while (1)
    {
      if (v17 >= v15)
      {
        v26 = v12;
        if (v12)
        {
          if (v12 > 0xFF)
          {
            v27 = log2(v12);
          }

          else
          {
            v27 = kBrotliLog2Table[v12];
          }

          v16 = v16 + v26 * v27;
        }

        if (v16 >= v26)
        {
          v28 = v16;
        }

        else
        {
          v28 = v12;
        }

        *(v3 + 560) = v28;
        *(v3 + 561) = v28;
        ++v3[3];
        ++*v4;
        v29 = v3[557] + 1;
        v3[557] = v29;
        if (v29 < *v3[6])
        {
          v30 = &v5[548 * v29];
          bzero(v30, 0x880uLL);
          *(v30 + 272) = 0;
          *(v30 + 273) = 0x7FF0000000000000;
        }

        v3[556] = 0;
        goto LABEL_85;
      }

      v19 = *v17++;
      v18 = v19;
      v13 = v12 + v19;
      v20 = v19;
      if (v19 > 0xFF)
      {
        v21 = log2(v20);
      }

      else
      {
        v21 = kBrotliLog2Table[v18];
      }

      v16 = v16 - v20 * v21;
LABEL_13:
      v23 = *v17++;
      v22 = v23;
      v12 = v13 + v23;
      v24 = v23;
      if (v23 > 0xFF)
      {
        v25 = log2(v24);
      }

      else
      {
        v25 = kBrotliLog2Table[v22];
      }

      v16 = v16 - v24 * v25;
    }
  }

  if (!v6)
  {
    goto LABEL_85;
  }

  v84 = a1[3];
  v7 = 0;
  v8 = 0;
  v92 = a1 + 560;
  v9 = &v5[548 * a1[557]];
  v10 = &v9[*a1];
  v11 = 0.0;
  v89 = *a1;
  if ((*a1 & 1) == 0)
  {
    goto LABEL_28;
  }

  while (1)
  {
    v36 = *v9++;
    v35 = v36;
    v7 = v8 + v36;
    v37 = v36;
    v38 = v36 > 0xFF ? log2(v37) : kBrotliLog2Table[v35];
    v11 = v11 - v37 * v38;
LABEL_28:
    if (v9 >= v10)
    {
      break;
    }

    v32 = *v9++;
    v31 = v32;
    v8 = v7 + v32;
    v33 = v32;
    if (v32 > 0xFF)
    {
      v34 = log2(v33);
    }

    else
    {
      v34 = kBrotliLog2Table[v31];
    }

    v11 = v11 - v33 * v34;
  }

  v39 = v7;
  v86 = a2;
  v85 = v4;
  if (v7)
  {
    if (v7 > 0xFF)
    {
      v40 = log2(v7);
    }

    else
    {
      v40 = kBrotliLog2Table[v7];
    }

    v11 = v11 + v39 * v40;
  }

  v41 = 0;
  if (v11 < v39)
  {
    v11 = v7;
  }

  v90 = v3 + 558;
  v91 = (v3 + 7);
  v87 = v3;
  __src = &v5[548 * v3[557]];
  v42 = &v96;
  v43 = &v94;
  v44 = 1;
  do
  {
    v45 = v44;
    v46 = v90[v41];
    v47 = &v91[2192 * v41];
    memcpy(v47, __src, 0x890uLL);
    v48 = 0;
    v49 = v5;
    v50 = &v5[548 * v46];
    *(v47 + 272) += *(v50 + 272);
    do
    {
      *&v47[v48 * 4] += v50[v48];
      ++v48;
    }

    while (v48 != 544);
    v51 = 0;
    v52 = 0;
    v53 = &v47[4 * v89];
    v54 = 0.0;
    if (v89)
    {
      goto LABEL_57;
    }

    while (v47 < v53)
    {
      v56 = *v47;
      v47 += 4;
      v55 = v56;
      v52 = v51 + v56;
      v57 = v56;
      if (v56 > 0xFF)
      {
        v58 = log2(v57);
      }

      else
      {
        v58 = kBrotliLog2Table[v55];
      }

      v54 = v54 - v57 * v58;
LABEL_57:
      v62 = *v47;
      v47 += 4;
      v61 = v62;
      v51 = v52 + v62;
      v63 = v62;
      if (v62 > 0xFF)
      {
        v64 = log2(v63);
      }

      else
      {
        v64 = kBrotliLog2Table[v61];
      }

      v54 = v54 - v63 * v64;
    }

    v59 = v51;
    if (v51)
    {
      v5 = v49;
      if (v51 > 0xFF)
      {
        v60 = log2(v51);
      }

      else
      {
        v60 = kBrotliLog2Table[v51];
      }

      v54 = v54 + v59 * v60;
    }

    else
    {
      v5 = v49;
    }

    v44 = 0;
    if (v54 >= v59)
    {
      v65 = v54;
    }

    else
    {
      v65 = v51;
    }

    *v42 = v65;
    *v43 = v65 - v11 - *&v92[v41];
    v42 = &v95;
    v43 = &v93;
    v41 = 1;
  }

  while ((v45 & 1) != 0);
  v4 = v85;
  v66 = *v85;
  a2 = v86;
  if (*v85 >= 0x100uLL)
  {
    v67 = v93;
    v68 = v94;
    v3 = v87;
    v71 = v84;
  }

  else
  {
    v67 = v93;
    v68 = v94;
    v3 = v87;
    v69 = *(v87 + 2);
    v70 = v94 <= v69 || v93 <= v69;
    v71 = v84;
    if (!v70)
    {
      v72 = v85[2];
      *(v85[3] + 4 * v84) = v87[556];
      *(v72 + v84) = v66;
      v87[559] = v87[558];
      v87[558] = *v85;
      v87[561] = v87[560];
      *(v87 + 560) = v11;
      ++v87[3];
      ++*v85;
      v73 = v87[557] + 1;
      v87[557] = v73;
      if (v73 < *v87[6])
      {
        v74 = &v5[548 * v73];
        bzero(v74, 0x880uLL);
        *(v74 + 272) = 0;
        *(v74 + 273) = 0x7FF0000000000000;
      }

      v87[556] = 0;
LABEL_79:
      v3[562] = 0;
      v80 = v3[1];
LABEL_84:
      v3[555] = v80;
      goto LABEL_85;
    }
  }

  v75 = *(v3 + 1112);
  v76 = (v85[3] + 4 * v71);
  if (v67 < v68 + -20.0)
  {
    *v76 = v75;
    *(v85[2] + v71) = *(v85[2] + v71 - 2);
    v77 = v3[558];
    v78 = v3[559];
    v3[558] = v78;
    v3[559] = v77;
    memcpy(&v5[548 * v78], v3 + 281, 0x890uLL);
    v3[561] = v3[560];
    v3[560] = v95;
    ++v3[3];
    v3[556] = 0;
    v79 = &v5[548 * v3[557]];
    bzero(v79, 0x880uLL);
    *(v79 + 272) = 0;
    *(v79 + 273) = 0x7FF0000000000000;
    goto LABEL_79;
  }

  *(v76 - 1) += v75;
  memcpy(&v5[548 * *v90], v91, 0x890uLL);
  v81 = v96;
  *v92 = v96;
  if (*v85 == 1)
  {
    v3[561] = v81;
  }

  v3[556] = 0;
  v82 = &v5[548 * v3[557]];
  bzero(v82, 0x880uLL);
  *(v82 + 272) = 0;
  *(v82 + 273) = 0x7FF0000000000000;
  v83 = v3[562] + 1;
  v3[562] = v83;
  if (v83 >= 2)
  {
    v80 = v3[555] + v3[1];
    goto LABEL_84;
  }

LABEL_85:
  if (a2)
  {
    *v3[6] = *v4;
    v4[1] = v3[3];
  }
}

void *JEConvertUCharToCString(uint64_t a1, int a2)
{
  if (!ucnv_open())
  {
    return 0;
  }

  v5 = (a2 + 10) * ucnv_getMaxCharSize();
  v6 = malloc_type_calloc(v5, 1uLL, 0x100004077774924uLL);
  v4 = v6;
  if (v6)
  {
    v7 = ucnv_fromUChars();
    if (v7 > v5)
    {
      v4 = reallocf(v4, v7);
      if (v4)
      {
        ucnv_fromUChars();
      }
    }
  }

  ucnv_close();
  return v4;
}

double BrotliInitBlockSplit(_OWORD *a1)
{
  result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t BrotliDestroyBlockSplit(uint64_t a1, uint64_t a2)
{
  BrotliFree(a1);
  *(a2 + 16) = 0;
  result = BrotliFree(a1);
  *(a2 + 24) = 0;
  return result;
}

uint64_t BrotliSplitBlock(uint64_t a1, uint64_t a2, size_t a3, uint64_t a4, size_t a5, size_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  v10 = a3;
  v11 = a2;
  v12 = a1;
  v13 = a10;
  if (!a3)
  {
    goto LABEL_29;
  }

  v17 = 0;
  v18 = v11;
  v19 = a3;
  do
  {
    v20 = *v18;
    v18 += 4;
    v17 += v20;
    --v19;
  }

  while (v19);
  v610 = v17;
  if (v17)
  {
    v590 = BrotliAllocate(a1);
  }

  else
  {
    v590 = 0;
  }

  v21 = 0;
  v22 = a6 + 1;
  v23 = (v11 + 4);
  v24 = v10;
  do
  {
    v25 = a5 & a6;
    v26 = *(v23 - 1);
    if (v25 + v26 > a6)
    {
      v27 = v22 - v25;
      memcpy((v590 + v21), (a4 + v25), v22 - v25);
      v25 = 0;
      v21 += v27;
      v26 -= v27;
    }

    if (v26)
    {
      memcpy((v590 + v21), (a4 + v25), v26);
      v21 += v26;
    }

    v28 = *v23;
    v23 += 4;
    a5 = v26 + v25 + (v28 & 0x1FFFFFF);
    --v24;
  }

  while (v24);
  if (v610 >> 7 <= 0x1A8)
  {
    v29 = v610 / 0x220u + 1;
  }

  else
  {
    v29 = 100;
  }

  if (!v610)
  {
    v12 = a1;
    v13 = a10;
    v10 = a3;
    v11 = a2;
LABEL_29:
    *a8 = 1;
    goto LABEL_230;
  }

  v13 = a10;
  v11 = a2;
  if (v610 > 0x7F)
  {
    v39 = BrotliAllocate(a1);
    v625 = v39;
    v40 = v29;
    do
    {
      bzero(v39, 0x400uLL);
      v39[128] = 0;
      v39[129] = 0x7FF0000000000000;
      v39 += 130;
      --v40;
    }

    while (v40);
    v41 = 0;
    LODWORD(v42) = 7;
    v43 = v590;
    do
    {
      v44 = v41 * v610 / v29;
      if (v41)
      {
        v42 = (16807 * v42);
        v44 += v42 % (v610 / v29);
      }

      v45 = 0;
      if (v44 + 70 >= v610)
      {
        v46 = v610 - 71;
      }

      else
      {
        v46 = v44;
      }

      v47 = &v625[130 * v41];
      v48 = v590 + v46;
      v47[128] += 70;
      do
      {
        ++*(v47 + *(v48 + v45++));
      }

      while (v45 != 70);
      ++v41;
    }

    while (v41 != v29);
    v49 = v29 + 2 * v610 / 0x46 + 99;
    v50 = v49 / v29 * v29;
    if (v49 != v49 % v29)
    {
      v51 = 0;
      v52 = &v625[130 * v29];
      LODWORD(v53) = 7;
      do
      {
        bzero(v52, 0x400uLL);
        v52[129] = 0x7FF0000000000000;
        v53 = (16807 * v53);
        v54 = (v590 + v53 % (v610 - 69));
        v52[128] = 70;
        v55 = -70;
        do
        {
          v56 = *v54++;
          ++*(v52 + v56);
          v57 = __CFADD__(v55++, 1);
        }

        while (!v57);
        v58 = 0;
        v59 = 0;
        v60 = &v625[130 * (v51 % v29)];
        v60[128] += 70;
        do
        {
          *(v60 + v59++) += *(v52 + v58);
          v58 += 4;
        }

        while (v58 != 1024);
        ++v51;
      }

      while (v51 < v50);
    }

    v61 = v610;
    v62 = BrotliAllocate(a1);
    v63 = BrotliAllocate(a1);
    v64 = BrotliAllocate(a1);
    if (((v29 + 7) >> 3) * v610)
    {
      v578 = BrotliAllocate(a1);
    }

    else
    {
      v578 = 0;
    }

    v603 = BrotliAllocate(a1);
    v72 = 0;
    v73 = 3;
    if (*(a7 + 4) > 10)
    {
      v73 = 10;
    }

    v596 = v73;
    v554 = (v62 - 2);
    do
    {
      v616 = v72;
      if (v29 > 1)
      {
        bzero(v63, v29 << 11);
        v76 = 0;
        v77 = (v625 + 128);
        do
        {
          v78 = *v77;
          if (v78 > 0xFF)
          {
            v79 = log2(v78);
          }

          else
          {
            v79 = kBrotliLog2Table[v78];
          }

          v77 += 260;
          *&v63[8 * v76++] = v79;
        }

        while (v29 != v76);
        v584 = (v29 + 7) >> 3;
        v80 = &v63[2040 * v29];
        v81 = v625 + 255;
        v82 = 256;
        do
        {
          v83 = 0;
          --v82;
          v84 = v81;
          do
          {
            v85 = *&v63[8 * v83];
            v86 = *v84;
            if (v86)
            {
              if (v86 > 0xFF)
              {
                v87 = log2(v86);
              }

              else
              {
                v87 = kBrotliLog2Table[v86];
              }
            }

            else
            {
              v87 = -2.0;
            }

            v84 += 260;
            *&v80[8 * v83++] = v85 - v87;
          }

          while (v29 != v83);
          v80 -= 8 * v29;
          --v81;
        }

        while (v82);
        bzero(v64, 8 * v29);
        v61 = v610;
        bzero(v578, v584 * v610);
        v88 = 0;
        v43 = v590;
        do
        {
          v89 = 0;
          v90 = &v63[8 * v29 * *(v590 + v88)];
          v91 = 1.0e99;
          do
          {
            v92 = *&v90[8 * v89] + *(v64 + v89);
            *(v64 + v89) = v92;
            if (v92 < v91)
            {
              v62[v88] = v89;
              v91 = v92;
            }

            ++v89;
          }

          while (v29 != v89);
          v93 = 28.1;
          if (v88 <= 0x7CF)
          {
            v93 = (v88 * 0.07 / 2000.0 + 0.77) * 28.1;
          }

          for (i = 0; i != v29; ++i)
          {
            v95 = *(v64 + i) - v91;
            *(v64 + i) = v95;
            if (v95 >= v93)
            {
              *(v64 + i) = v93;
              v578[v88 * v584 + (i >> 3)] |= 1 << (i & 7);
            }
          }

          ++v88;
        }

        while (v88 != v610);
        v96 = v62[v610 - 1];
        v97 = &v578[(v610 - 2) * v584];
        v98 = v610;
        v74 = 1;
        v75 = v603;
        do
        {
          if ((v97[v96 >> 3] >> (v96 & 7)))
          {
            if (v96 != v554[v98])
            {
              ++v74;
            }

            v96 = v554[v98];
          }

          v97 -= v584;
          v554[v98--] = v96;
        }

        while (v98 != 1);
      }

      else
      {
        bzero(v62, v61);
        v74 = 1;
        v75 = v603;
      }

      if (v29)
      {
        memset_pattern16(v75, &unk_1AB4804F0, 2 * v29);
      }

      v99 = 0;
      v100 = 0;
      do
      {
        v101 = v62[v99];
        if (*(v75 + v101) == 256)
        {
          *(v75 + v101) = v100++;
        }

        ++v99;
      }

      while (v61 != v99);
      for (j = 0; j != v61; ++j)
      {
        v62[j] = *(v75 + v62[j]);
      }

      v29 = v100;
      if (v100)
      {
        v103 = v625;
        v104 = v100;
        do
        {
          bzero(v103, 0x400uLL);
          v103[128] = 0;
          v103[129] = 0x7FF0000000000000;
          v103 += 130;
          --v104;
        }

        while (v104);
      }

      v105 = 0;
      v61 = v610;
      do
      {
        v106 = &v625[130 * v62[v105]];
        ++*(v106 + *(v43 + v105));
        ++v106[128];
        ++v105;
      }

      while (v610 != v105);
      v72 = v616 + 1;
    }

    while (v616 + 1 != v596);
    BrotliFree(a1);
    BrotliFree(a1);
    BrotliFree(a1);
    BrotliFree(a1);
    BrotliFree(a1);
    if (v74)
    {
      v107 = BrotliAllocate(a1);
      v108 = v74 + 256;
      if (v74 == -256)
      {
        v634 = 0;
        v109 = 0x3FFFFFFFFFFFFCFLL;
        goto LABEL_120;
      }
    }

    else
    {
      v107 = 0;
      v108 = 256;
    }

    v634 = BrotliAllocate(a1);
    v110 = 16 * v74 + 1008;
    v109 = v110 >> 6;
    if (v110 < 0x40)
    {
      v555 = v110 >> 6;
      v111 = 0;
      v112 = 0;
      if (v74)
      {
LABEL_121:
        v534 = BrotliAllocate(a1);
        goto LABEL_122;
      }

LABEL_119:
      v534 = 0;
LABEL_122:
      v527 = BrotliAllocate(a1);
      v526 = BrotliAllocate(a1);
      bzero(v634, 4 * v108);
      v113 = (v634 + 256);
      v114 = 0;
      v115 = v62 + 1;
      do
      {
        ++v634[v114 + 256];
        if (v61 == 1 || *(v115 - 1) != *v115)
        {
          ++v114;
        }

        ++v115;
        --v61;
      }

      while (v61);
      v579 = v74;
      v529 = v107;
      v585 = v634 + 256;
      if (v74)
      {
        v116 = 0;
        v117 = 0;
        v566 = 0;
        v118 = 0;
        v617 = v634 + 128;
        v626 = 0;
        v611 = v634 + 64;
        v119 = v107;
        v120 = v74;
        v546 = v111;
        v121 = v555;
        *v531 = v634 + 192;
        while (1)
        {
          v597 = v121;
          __src = v112;
          v573 = v118;
          v122 = 0;
          v540 = v120 - 64;
          v543 = v119;
          if (v120 >= 0x40)
          {
            v120 = 64;
          }

          v123 = v120 <= 1 ? 1 : v120;
          v124 = &v113[4 * v118];
          do
          {
            v125 = *&v124[4 * v122];
            v126 = &v534[1040 * v122];
            bzero(v126, 0x400uLL);
            *(v126 + 128) = 0;
            *(v126 + 129) = 0x7FF0000000000000;
            if (v125)
            {
              for (k = 0; k != v125; *(v126 + 128) = k)
              {
                ++*&v126[4 * *(v43 + v626 + k++)];
              }

              v626 += k;
            }

            BrotliPopulationCostLiteral(&v534[1040 * v122]);
            *(v126 + 129) = v128;
            v611[v122] = v122;
            v617[v122] = v122;
            v634[v122++] = 1;
          }

          while (v122 != v123);
          v129 = &v579[-v573] >= 0x40 ? 64 : &v579[-v573];
          v130 = BrotliHistogramCombineLiteral(v534, v526, v634, v617, v611, v527, v129, v129, 0x40uLL, 0x800uLL);
          v604 = v130;
          if (v555 >= v130 + v116)
          {
            v111 = v546;
            v132 = v555;
            v134 = v597;
          }

          else
          {
            if (v555)
            {
              v131 = v555;
            }

            else
            {
              v131 = v130 + v116;
            }

            do
            {
              v132 = v131;
              v131 *= 2;
            }

            while (v132 < v130 + v116);
            v133 = BrotliAllocate(a1);
            v111 = v133;
            if (v555)
            {
              memcpy(v133, v546, 1040 * v555);
            }

            BrotliFree(a1);
            v134 = v597;
            v130 = v604;
          }

          v113 = (v634 + 256);
          if (v134 < v130 + v117)
          {
            break;
          }

          v137 = __src;
          if (v130)
          {
            goto LABEL_162;
          }

LABEL_165:
          v141 = v634 + 128;
          v142 = v543;
          do
          {
            v143 = *v141++;
            *v142++ = *(*v531 + 4 * v143) + v566;
            --v123;
          }

          while (v123);
          v566 += v130;
          v118 = v573 + 64;
          v119 = (v543 + 64);
          v120 = v540;
          v555 = v132;
          v546 = v111;
          v121 = v134;
          v112 = v137;
          v74 = v579;
          if (v573 + 64 >= v579)
          {
            goto LABEL_170;
          }
        }

        if (v134)
        {
          v135 = v134;
        }

        else
        {
          v135 = v130 + v117;
        }

        do
        {
          v134 = v135;
          v135 *= 2;
        }

        while (v134 < v130 + v117);
        v136 = BrotliAllocate(a1);
        v137 = v136;
        if (v597)
        {
          memcpy(v136, __src, 4 * v597);
        }

        BrotliFree(a1);
        v113 = (v634 + 256);
        v130 = v604;
        if (!v604)
        {
          goto LABEL_165;
        }

LABEL_162:
        v138 = v137;
        v139 = 0;
        v140 = (v111 + 1040 * v116);
        v556 = v138;
        v598 = &v138[4 * v117];
        do
        {
          ++v116;
          memcpy(v140, &v534[1040 * v611[v139]], 0x410uLL);
          v130 = v604;
          *&v598[4 * v139] = v634[v611[v139]];
          *(*v531 + 4 * v611[v139]) = v139;
          ++v139;
          v140 += 1040;
        }

        while (v604 != v139);
        v117 += v139;
        v43 = v590;
        v113 = (v634 + 256);
        v137 = v556;
        goto LABEL_165;
      }

      v566 = 0;
      v137 = v112;
LABEL_170:
      BrotliFree(a1);
      if (v566 << 6 >= (v566 >> 1) * v566)
      {
        v144 = (v566 >> 1) * v566;
      }

      else
      {
        v144 = v566 << 6;
      }

      if (v144 >= 0x801)
      {
        BrotliFree(a1);
        v527 = BrotliAllocate(a1);
      }

      if (v566)
      {
        v145 = BrotliAllocate(a1);
        v146 = 0;
        v147 = vdupq_n_s64(v566 - 1);
        v148 = v145 + 2;
        v149 = xmmword_1AB465F90;
        v150 = xmmword_1AB465FA0;
        v151 = vdupq_n_s64(4uLL);
        do
        {
          v152 = vmovn_s64(vcgeq_u64(v147, v150));
          if (vuzp1_s16(v152, *v147.i8).u8[0])
          {
            *(v148 - 2) = v146;
          }

          if (vuzp1_s16(v152, *&v147).i8[2])
          {
            *(v148 - 1) = v146 + 1;
          }

          if (vuzp1_s16(*&v147, vmovn_s64(vcgeq_u64(v147, *&v149))).i32[1])
          {
            *v148 = v146 + 2;
            v148[1] = v146 + 3;
          }

          v146 += 4;
          v149 = vaddq_s64(v149, v151);
          v150 = vaddq_s64(v150, v151);
          v148 += 4;
        }

        while (((v566 + 3) & 0xFFFFFFFFFFFFFFFCLL) != v146);
      }

      else
      {
        v145 = 0;
      }

      v612 = v145;
      v618 = BrotliHistogramCombineLiteral(v111, v526, v137, v529, v145, v527, v566, v74, 0x100uLL, v144);
      BrotliFree(a1);
      BrotliFree(a1);
      if (v566)
      {
        v627 = BrotliAllocate(a1);
        memset(v627, 255, 4 * v566);
      }

      else
      {
        v627 = 0;
      }

      v153 = v529;
      if (v74)
      {
        v154 = 0;
        v155 = 0;
        v156 = 0;
        do
        {
          bzero(v526, 0x400uLL);
          *(v526 + 1024) = 0;
          *(v526 + 1032) = 0x7FF0000000000000;
          if (v585[v155])
          {
            v157 = 0;
            do
            {
              ++*(v526 + 4 * *(v590 + v156 + v157++));
              *(v526 + 1024) = v157;
            }

            while (v157 < v585[v155]);
            v156 += v157;
          }

          v158 = v155 - 1;
          if (!v155)
          {
            v158 = 0;
          }

          v159 = v153[v158];
          v160 = BrotliHistogramBitCostDistanceLiteral(v526, v111 + 1040 * v159, (v526 + 1040));
          v161 = v618;
          if (v618)
          {
            v162 = v160;
            v163 = v612;
            do
            {
              v164 = BrotliHistogramBitCostDistanceLiteral(v526, v111 + 1040 * *v163, (v526 + 1040));
              if (v164 < v162)
              {
                v159 = *v163;
                v162 = v164;
              }

              ++v163;
              --v161;
            }

            while (v161);
          }

          v153 = v529;
          v529[v155] = v159;
          if (*(v627 + v159) == -1)
          {
            *(v627 + v159) = v154++;
          }

          v74 = v579;
          ++v155;
        }

        while (v155 != v579);
      }

      BrotliFree(a1);
      BrotliFree(a1);
      BrotliFree(a1);
      v165 = *(a8 + 32);
      v10 = a3;
      if (v165 < v74)
      {
        if (!v165)
        {
          v165 = v74;
        }

        do
        {
          v166 = v165;
          v165 *= 2;
        }

        while (v166 < v74);
        v167 = BrotliAllocate(a1);
        v168 = v167;
        v169 = *(a8 + 32);
        if (v169)
        {
          memcpy(v167, *(a8 + 16), v169);
        }

        BrotliFree(a1);
        *(a8 + 16) = v168;
        *(a8 + 32) = v166;
      }

      v170 = *(a8 + 40);
      v171 = v634 + 256;
      if (v170 >= v74)
      {
        v12 = a1;
        v176 = v627;
        if (!v74)
        {
          v178 = 0;
          v184 = 1;
LABEL_229:
          *a8 = v184;
          *(a8 + 8) = v178;
          BrotliFree(v12);
          BrotliFree(v12);
          BrotliFree(v12);
          BrotliFree(v12);
          v13 = a10;
          v11 = a2;
          goto LABEL_230;
        }
      }

      else
      {
        if (!v170)
        {
          v170 = v74;
        }

        v12 = a1;
        do
        {
          v172 = v170;
          v170 *= 2;
        }

        while (v172 < v74);
        v173 = BrotliAllocate(a1);
        v174 = v173;
        v175 = *(a8 + 40);
        if (v175)
        {
          memcpy(v173, *(a8 + 24), 4 * v175);
        }

        BrotliFree(a1);
        *(a8 + 24) = v174;
        *(a8 + 40) = v172;
        v176 = v627;
        v171 = v634 + 256;
      }

      v177 = 0;
      v178 = 0;
      v179 = 0;
      v180 = v153 + 1;
      do
      {
        v181 = *v171++;
        v179 += v181;
        v182 = *(v180 - 1);
        if (v74 == 1 || v182 != *v180)
        {
          v183 = v176[v182];
          *(*(a8 + 16) + v178) = v183;
          *(*(a8 + 24) + 4 * v178) = v179;
          if (v177 <= v183)
          {
            v177 = v183;
          }

          ++v178;
          v179 = 0;
        }

        ++v180;
        --v74;
      }

      while (v74);
      v184 = v177 + 1;
      goto LABEL_229;
    }

LABEL_120:
    v111 = BrotliAllocate(a1);
    v555 = v109;
    v112 = BrotliAllocate(a1);
    if (v74)
    {
      goto LABEL_121;
    }

    goto LABEL_119;
  }

  v30 = *(a8 + 32);
  v31 = *(a8 + 8);
  v32 = v31 + 1;
  if (v30 >= v31 + 1)
  {
    v12 = a1;
    v10 = a3;
    v37 = a8;
  }

  else
  {
    if (v30)
    {
      v33 = *(a8 + 32);
    }

    else
    {
      v33 = v31 + 1;
    }

    v12 = a1;
    do
    {
      v34 = v33;
      v33 *= 2;
    }

    while (v34 < v32);
    v35 = BrotliAllocate(a1);
    v36 = v35;
    v37 = a8;
    v38 = *(a8 + 32);
    v10 = a3;
    if (v38)
    {
      memcpy(v35, *(a8 + 16), v38);
    }

    BrotliFree(a1);
    *(a8 + 16) = v36;
    *(a8 + 32) = v34;
    v31 = *(a8 + 8);
    v32 = v31 + 1;
  }

  v65 = v37[5];
  if (v65 < v32)
  {
    if (v65)
    {
      v66 = v37[5];
    }

    else
    {
      v66 = v32;
    }

    do
    {
      v67 = v66;
      v66 *= 2;
    }

    while (v67 < v32);
    v68 = BrotliAllocate(v12);
    v69 = v68;
    v37 = a8;
    v70 = *(a8 + 40);
    if (v70)
    {
      memcpy(v68, *(a8 + 24), 4 * v70);
    }

    BrotliFree(v12);
    *(a8 + 24) = v69;
    *(a8 + 40) = v67;
    v31 = *(a8 + 8);
  }

  *v37 = 1;
  *(v37[2] + v31) = 0;
  v71 = v37[1];
  *(v37[3] + 4 * v71) = v610;
  v37[1] = v71 + 1;
LABEL_230:
  BrotliFree(v12);
  if (!v10)
  {
    *a9 = 1;
    BrotliFree(v12);
LABEL_475:
    *v13 = 1;
    goto LABEL_667;
  }

  v185 = BrotliAllocate(v12);
  v186 = 0;
  v187 = (v11 + 12);
  do
  {
    v188 = *v187;
    v187 += 8;
    *(v185 + 2 * v186++) = v188;
  }

  while (v10 != v186);
  if (v10 <= 0x6783)
  {
    v189 = v10 / 0x212u + 1;
  }

  else
  {
    v189 = 50;
  }

  v613 = v185;
  if (v10 > 0x7F)
  {
    v199 = BrotliAllocate(v12);
    v605 = v199;
    v200 = v189;
    do
    {
      bzero(v199, 0xB00uLL);
      v199[352] = 0;
      v199[353] = 0x7FF0000000000000;
      v199 += 354;
      --v200;
    }

    while (v200);
    v201 = 0;
    LODWORD(v202) = 7;
    v203 = v605;
    do
    {
      v204 = v201 * v10 / v189;
      if (v201)
      {
        v202 = (16807 * v202);
        v204 += v202 % (v10 / v189);
      }

      v205 = 0;
      if (v204 + 40 >= v10)
      {
        v206 = v10 - 41;
      }

      else
      {
        v206 = v204;
      }

      v207 = &v605[354 * v201];
      v208 = v613 + 2 * v206;
      v207[352] += 40;
      do
      {
        ++*(v207 + *(v208 + v205));
        v205 += 2;
      }

      while (v205 != 80);
      ++v201;
    }

    while (v201 != v189);
    v209 = v189 + 2 * v10 / 0x28 + 99;
    v210 = v209 / v189 * v189;
    if (v209 != v209 % v189)
    {
      v211 = 0;
      v212 = &v605[354 * v189];
      LODWORD(v213) = 7;
      do
      {
        bzero(v212, 0xB00uLL);
        v213 = (16807 * v213);
        v214 = (v613 + 2 * (v213 % (v10 - 39)));
        v212[352] = 40;
        v215 = -40;
        do
        {
          v216 = *v214++;
          ++*(v212 + v216);
          v57 = __CFADD__(v215++, 1);
        }

        while (!v57);
        v217 = 0;
        v218 = 0;
        v219 = &v605[354 * (v211 % v189)];
        v219[352] += 40;
        do
        {
          *(v219 + v218++) += *(v212 + v217);
          v217 += 4;
        }

        while (v217 != 2816);
        ++v211;
      }

      while (v211 < v210);
      v212[353] = 0x7FF0000000000000;
      v10 = a3;
      v203 = v605;
    }

    v220 = BrotliAllocate(v12);
    v221 = BrotliAllocate(v12);
    v222 = BrotliAllocate(v12);
    if (((v189 + 7) >> 3) * v10)
    {
      v586 = BrotliAllocate(v12);
    }

    else
    {
      v586 = 0;
    }

    v230 = BrotliAllocate(v12);
    v231 = v230;
    v232 = 0;
    v233 = 3;
    if (*(a7 + 4) > 10)
    {
      v233 = 10;
    }

    v599 = v233;
    v570 = (v203 + 352);
    v574 = v10 - 1;
    *v562 = v10 - 2;
    *v567 = v203 + 2812;
    v619 = v230;
    v557 = (v220 - 2);
    do
    {
      v628 = v232;
      if (v189 > 1)
      {
        v591 = (v189 + 7) >> 3;
        bzero(v221, 5632 * v189);
        v235 = 0;
        v236 = v570;
        do
        {
          v237 = *v236;
          if (v237 > 0xFF)
          {
            v238 = log2(v237);
          }

          else
          {
            v238 = kBrotliLog2Table[v237];
          }

          v236 += 708;
          *&v221[8 * v235++] = v238;
        }

        while (v189 != v235);
        v239 = &v221[5624 * v189];
        v240 = *v567;
        v241 = 704;
        do
        {
          v242 = 0;
          --v241;
          v243 = v240;
          do
          {
            v244 = *&v221[8 * v242];
            v245 = *v243;
            if (v245)
            {
              if (v245 > 0xFF)
              {
                v246 = log2(v245);
              }

              else
              {
                v246 = kBrotliLog2Table[v245];
              }
            }

            else
            {
              v246 = -2.0;
            }

            v243 += 708;
            *&v239[8 * v242++] = v244 - v246;
          }

          while (v189 != v242);
          v239 -= 8 * v189;
          --v240;
        }

        while (v241);
        bzero(v222, 8 * v189);
        v10 = a3;
        bzero(v586, v591 * a3);
        v247 = 0;
        v12 = a1;
        v203 = v605;
        v231 = v619;
        do
        {
          v248 = 0;
          v249 = &v221[8 * v189 * *(v613 + 2 * v247)];
          v250 = 1.0e99;
          do
          {
            v251 = *&v249[8 * v248] + *(v222 + v248);
            *(v222 + v248) = v251;
            if (v251 < v250)
            {
              v220[v247] = v248;
              v250 = v251;
            }

            ++v248;
          }

          while (v189 != v248);
          v252 = 13.5;
          if (v247 <= 0x7CF)
          {
            v252 = (v247 * 0.07 / 2000.0 + 0.77) * 13.5;
          }

          for (m = 0; m != v189; ++m)
          {
            v254 = *(v222 + m) - v250;
            *(v222 + m) = v254;
            if (v254 >= v252)
            {
              *(v222 + m) = v252;
              v586[v247 * v591 + (m >> 3)] |= 1 << (m & 7);
            }
          }

          ++v247;
        }

        while (v247 != a3);
        v255 = v220[v574];
        v256 = &v586[*v562 * v591];
        v257 = a3;
        v234 = 1;
        do
        {
          if ((v256[v255 >> 3] >> (v255 & 7)))
          {
            if (v255 != v557[v257])
            {
              ++v234;
            }

            v255 = v557[v257];
          }

          v256 -= v591;
          v557[v257--] = v255;
        }

        while (v257 != 1);
      }

      else
      {
        bzero(v220, v10);
        v234 = 1;
      }

      if (v189)
      {
        memset_pattern16(v231, &unk_1AB4804F0, 2 * v189);
      }

      v258 = 0;
      v259 = 0;
      do
      {
        v260 = v220[v258];
        if (*(v231 + v260) == 256)
        {
          *(v231 + v260) = v259++;
        }

        ++v258;
      }

      while (v10 != v258);
      v580 = v234;
      v261 = 0;
      do
      {
        v220[v261] = *(v231 + v220[v261]);
        ++v261;
      }

      while (v10 != v261);
      v189 = v259;
      if (v259)
      {
        v262 = v203;
        v263 = v259;
        do
        {
          bzero(v262, 0xB00uLL);
          v262[352] = 0;
          v262[353] = 0x7FF0000000000000;
          v262 += 354;
          --v263;
        }

        while (v263);
      }

      v264 = 0;
      do
      {
        v265 = &v203[354 * v220[v264]];
        ++*(v265 + *(v613 + 2 * v264));
        ++v265[352];
        ++v264;
      }

      while (v10 != v264);
      v231 = v619;
      v232 = v628 + 1;
    }

    while (v628 + 1 != v599);
    BrotliFree(v12);
    BrotliFree(v12);
    BrotliFree(v12);
    BrotliFree(v12);
    BrotliFree(v12);
    if (v580)
    {
      v266 = BrotliAllocate(v12);
      v267 = v580 + 256;
      if (v580 == -256)
      {
        v635 = 0;
        v268 = 0x3FFFFFFFFFFFFCFLL;
        goto LABEL_336;
      }
    }

    else
    {
      v266 = 0;
      v267 = 256;
    }

    v635 = BrotliAllocate(v12);
    v269 = 16 * v580 + 1008;
    v268 = v269 >> 6;
    if (v269 < 0x40)
    {
      v270 = 0;
      v271 = 0;
LABEL_337:
      v547 = v268;
      if (v580)
      {
        v274 = a1;
        v592 = BrotliAllocate(a1);
      }

      else
      {
        v592 = 0;
        v274 = a1;
      }

      v528 = BrotliAllocate(v274);
      v606 = BrotliAllocate(v274);
      bzero(v635, 4 * v267);
      v275 = (v635 + 256);
      v276 = 0;
      v277 = v220 + 1;
      v278 = v271;
      v279 = v268;
      do
      {
        ++v635[v276 + 256];
        if (v10 == 1 || *(v277 - 1) != *v277)
        {
          ++v276;
        }

        ++v277;
        --v10;
      }

      while (v10);
      v530 = v266;
      v575 = (v635 + 256);
      if (v580)
      {
        v280 = 0;
        v558 = 0;
        v281 = 0;
        v282 = 0;
        v620 = v635 + 64;
        v629 = v635 + 128;
        *v568 = v266;
        v283 = v580;
        v284 = v270;
        v285 = v271;
        v286 = 0;
        v287 = v592;
        *v532 = v635 + 192;
        while (1)
        {
          v535 = v284;
          __srca = v285;
          v587 = v279;
          v288 = 0;
          v541 = v283 - 64;
          v544 = v286;
          if (v283 >= 0x40)
          {
            v283 = 64;
          }

          v289 = v283 <= 1 ? 1 : v283;
          *v563 = v281;
          v290 = &v275[4 * v281];
          do
          {
            v291 = *&v290[4 * v288];
            v292 = (v287 + 2832 * v288);
            bzero(v292, 0xB00uLL);
            v292[352] = 0;
            v292[353] = 0x7FF0000000000000;
            if (v291)
            {
              v293 = v291;
              do
              {
                v294 = *(v613 + 2 * v282++);
                ++*(v292 + v294);
                --v293;
              }

              while (v293);
              v292[352] = v291;
            }

            BrotliPopulationCostCommand(v287 + 2832 * v288);
            v292[353] = v295;
            v620[v288] = v288;
            v629[v288] = v288;
            v635[v288++] = 1;
          }

          while (v288 != v289);
          v296 = v580 - *v563 >= 0x40 ? 64 : v580 - *v563;
          v297 = BrotliHistogramCombineCommand(v287, v606, v635, v629, v620, v528, v296, v296, 0x40uLL, 0x800uLL);
          v600 = v297;
          if (v547 >= v297 + v280)
          {
            v302 = v535;
            v299 = v547;
            v279 = v587;
          }

          else
          {
            if (v547)
            {
              v298 = v547;
            }

            else
            {
              v298 = v297 + v280;
            }

            do
            {
              v299 = v298;
              v298 *= 2;
            }

            while (v299 < v297 + v280);
            v300 = BrotliAllocate(a1);
            v301 = v300;
            if (v547)
            {
              memcpy(v300, v535, 2832 * v547);
            }

            BrotliFree(a1);
            v279 = v587;
            v297 = v600;
            v302 = v301;
          }

          v275 = (v635 + 256);
          v571 = v302;
          if (v279 < v558 + v297)
          {
            break;
          }

          v278 = __srca;
          if (v297)
          {
            goto LABEL_380;
          }

LABEL_383:
          v308 = v635 + 128;
          v309 = *v568;
          do
          {
            v310 = *v308++;
            *v309++ = *(*v532 + 4 * v310) + v544;
            --v289;
          }

          while (v289);
          v286 = v297 + v544;
          v281 = *v563 + 64;
          *v568 += 256;
          v283 = v541;
          v547 = v299;
          v284 = v302;
          v285 = v278;
          if (*v563 + 64 >= v580)
          {
            goto LABEL_388;
          }
        }

        if (v279)
        {
          v303 = v279;
        }

        else
        {
          v303 = v558 + v297;
        }

        do
        {
          v279 = v303;
          v303 *= 2;
        }

        while (v279 < v558 + v297);
        v304 = BrotliAllocate(a1);
        v305 = v304;
        if (v587)
        {
          memcpy(v304, __srca, 4 * v587);
        }

        BrotliFree(a1);
        v275 = (v635 + 256);
        v278 = v305;
        v287 = v592;
        v297 = v600;
        if (!v600)
        {
          goto LABEL_383;
        }

LABEL_380:
        v306 = 0;
        v307 = (v302 + 2832 * v280);
        v548 = v278;
        v588 = &v278[4 * v558];
        do
        {
          ++v280;
          memcpy(v307, (v592 + 2832 * v620[v306]), 0xB10uLL);
          v297 = v600;
          *&v588[4 * v306] = v635[v620[v306]];
          *(*v532 + 4 * v620[v306]) = v306;
          ++v306;
          v307 += 2832;
        }

        while (v600 != v306);
        v558 = v558 + v306;
        v302 = v571;
        v275 = (v635 + 256);
        v278 = v548;
        v287 = v592;
        goto LABEL_383;
      }

      v302 = v270;
      v286 = 0;
LABEL_388:
      v311 = v278;
      BrotliFree(a1);
      v312 = v286;
      if (v286 << 6 >= (v286 >> 1) * v286)
      {
        v313 = (v286 >> 1) * v286;
      }

      else
      {
        v313 = v286 << 6;
      }

      if (v313 >= 0x801)
      {
        BrotliFree(a1);
        v528 = BrotliAllocate(a1);
      }

      v10 = a3;
      v314 = 4 * v312;
      if (v312)
      {
        v315 = BrotliAllocate(a1);
        v316 = 0;
        v317 = vdupq_n_s64(v312 - 1);
        v318 = v315 + 2;
        v319 = xmmword_1AB465F90;
        v320 = xmmword_1AB465FA0;
        v321 = vdupq_n_s64(4uLL);
        do
        {
          v322 = vmovn_s64(vcgeq_u64(v317, v320));
          if (vuzp1_s16(v322, *v317.i8).u8[0])
          {
            *(v318 - 2) = v316;
          }

          if (vuzp1_s16(v322, *&v317).i8[2])
          {
            *(v318 - 1) = v316 + 1;
          }

          if (vuzp1_s16(*&v317, vmovn_s64(vcgeq_u64(v317, *&v319))).i32[1])
          {
            *v318 = v316 + 2;
            v318[1] = v316 + 3;
          }

          v316 += 4;
          v319 = vaddq_s64(v319, v321);
          v320 = vaddq_s64(v320, v321);
          v318 += 4;
        }

        while (((v312 + 3) & 0xFFFFFFFFFFFFFFFCLL) != v316);
      }

      else
      {
        v315 = 0;
      }

      v621 = v315;
      v323 = BrotliHistogramCombineCommand(v302, v606, v311, v530, v315, v528, v312, v580, 0x100uLL, v313);
      BrotliFree(a1);
      BrotliFree(a1);
      if (v312)
      {
        v324 = v302;
        v630 = BrotliAllocate(a1);
        memset(v630, 255, v314);
      }

      else
      {
        v324 = v302;
        v630 = 0;
      }

      v325 = v580;
      v326 = v530;
      if (v580)
      {
        v327 = 0;
        v328 = 0;
        v329 = 0;
        do
        {
          bzero(v606, 0xB00uLL);
          *(v606 + 2816) = 0;
          *(v606 + 2824) = 0x7FF0000000000000;
          if (*&v575[4 * v328])
          {
            v330 = 0;
            do
            {
              ++*(v606 + 4 * *(v613 + 2 * v329 + 2 * v330++));
            }

            while (v330 < *&v575[4 * v328]);
            *(v606 + 2816) = v330;
            v329 += v330;
          }

          v331 = v328 - 1;
          if (!v328)
          {
            v331 = 0;
          }

          v332 = v326[v331];
          v333 = BrotliHistogramBitCostDistanceCommand(v606, v324 + 2832 * v332, (v606 + 2832));
          if (v323)
          {
            v334 = v333;
            v335 = v621;
            v336 = v323;
            do
            {
              v337 = BrotliHistogramBitCostDistanceCommand(v606, v324 + 2832 * *v335, (v606 + 2832));
              if (v337 < v334)
              {
                v332 = *v335;
                v334 = v337;
              }

              ++v335;
              --v336;
            }

            while (v336);
          }

          v326 = v530;
          v530[v328] = v332;
          if (*(v630 + v332) == -1)
          {
            *(v630 + v332) = v327++;
          }

          v10 = a3;
          v325 = v580;
          ++v328;
        }

        while (v328 != v580);
      }

      BrotliFree(a1);
      BrotliFree(a1);
      BrotliFree(a1);
      v338 = *(a9 + 32);
      if (v338 < v325)
      {
        if (!v338)
        {
          v338 = v325;
        }

        do
        {
          v339 = v338;
          v338 *= 2;
        }

        while (v339 < v325);
        v340 = BrotliAllocate(a1);
        v341 = v340;
        v342 = *(a9 + 32);
        if (v342)
        {
          memcpy(v340, *(a9 + 16), v342);
        }

        BrotliFree(a1);
        *(a9 + 16) = v341;
        *(a9 + 32) = v339;
      }

      v343 = *(a9 + 40);
      v344 = v635 + 256;
      if (v343 >= v325)
      {
        v12 = a1;
        v349 = v630;
        if (!v325)
        {
          v351 = 0;
          v357 = 1;
LABEL_447:
          *a9 = v357;
          *(a9 + 8) = v351;
          BrotliFree(v12);
          BrotliFree(v12);
          BrotliFree(v12);
          BrotliFree(v12);
          v13 = a10;
          v11 = a2;
          goto LABEL_448;
        }
      }

      else
      {
        if (!v343)
        {
          v343 = v325;
        }

        v12 = a1;
        do
        {
          v345 = v343;
          v343 *= 2;
        }

        while (v345 < v325);
        v346 = BrotliAllocate(a1);
        v347 = v346;
        v348 = *(a9 + 40);
        if (v348)
        {
          memcpy(v346, *(a9 + 24), 4 * v348);
        }

        BrotliFree(a1);
        *(a9 + 24) = v347;
        *(a9 + 40) = v345;
        v349 = v630;
        v344 = v635 + 256;
      }

      v350 = 0;
      v351 = 0;
      v352 = 0;
      v353 = v326 + 1;
      do
      {
        v354 = *v344++;
        v352 += v354;
        v355 = *(v353 - 1);
        if (v325 == 1 || v355 != *v353)
        {
          v356 = v349[v355];
          *(*(a9 + 16) + v351) = v356;
          *(*(a9 + 24) + 4 * v351) = v352;
          if (v350 <= v356)
          {
            v350 = v356;
          }

          ++v351;
          v352 = 0;
        }

        ++v353;
        --v325;
      }

      while (v325);
      v357 = v350 + 1;
      goto LABEL_447;
    }

LABEL_336:
    v272 = BrotliAllocate(v12);
    v273 = v12;
    v270 = v272;
    v271 = BrotliAllocate(v273);
    goto LABEL_337;
  }

  v190 = *(a9 + 32);
  v191 = *(a9 + 8);
  v192 = v191 + 1;
  if (v190 >= v191 + 1)
  {
    v197 = a9;
  }

  else
  {
    if (v190)
    {
      v193 = *(a9 + 32);
    }

    else
    {
      v193 = v191 + 1;
    }

    do
    {
      v194 = v193;
      v193 *= 2;
    }

    while (v194 < v192);
    v195 = BrotliAllocate(v12);
    v196 = v195;
    v197 = a9;
    v198 = *(a9 + 32);
    if (v198)
    {
      memcpy(v195, *(a9 + 16), v198);
    }

    BrotliFree(v12);
    *(a9 + 16) = v196;
    *(a9 + 32) = v194;
    v191 = *(a9 + 8);
    v192 = v191 + 1;
  }

  v223 = v197[5];
  if (v223 < v192)
  {
    if (v223)
    {
      v224 = v197[5];
    }

    else
    {
      v224 = v192;
    }

    do
    {
      v225 = v224;
      v224 *= 2;
    }

    while (v225 < v192);
    v226 = BrotliAllocate(v12);
    v227 = v226;
    v197 = a9;
    v228 = *(a9 + 40);
    if (v228)
    {
      memcpy(v226, *(a9 + 24), 4 * v228);
    }

    BrotliFree(v12);
    *(a9 + 24) = v227;
    *(a9 + 40) = v225;
    v191 = *(a9 + 8);
  }

  *v197 = 1;
  *(v197[2] + v191) = 0;
  v229 = v197[1];
  *(v197[3] + 4 * v229) = v10;
  v197[1] = v229 + 1;
LABEL_448:
  BrotliFree(v12);
  v358 = BrotliAllocate(v12);
  v589 = v358;
  v631 = 0;
  v359 = (v11 + 14);
  do
  {
    if ((*(v359 - 5) & 0x1FFFFFF) != 0 && *(v359 - 1) >= 0x80u)
    {
      *(v358 + 2 * v631++) = *v359 & 0x3FF;
    }

    v359 += 8;
    --v10;
  }

  while (v10);
  v360 = v631;
  if (v631 >> 6 <= 0x1A8)
  {
    v361 = v631 / 0x220u + 1;
  }

  else
  {
    v361 = 50;
  }

  if (!v631)
  {
    goto LABEL_475;
  }

  if (v631 > 0x7F)
  {
    v377 = BrotliAllocate(v12);
    v622 = v377;
    v378 = v361;
    do
    {
      bzero(v377, 0x880uLL);
      v377[272] = 0;
      v377[273] = 0x7FF0000000000000;
      v377 += 274;
      --v378;
    }

    while (v378);
    v379 = 0;
    LODWORD(v380) = 7;
    do
    {
      v381 = v379 * v631 / v361;
      if (v379)
      {
        v380 = (16807 * v380);
        v381 += v380 % (v631 / v361);
      }

      v382 = 0;
      if (v381 + 40 >= v631)
      {
        v383 = v631 - 41;
      }

      else
      {
        v383 = v381;
      }

      v384 = &v622[274 * v379];
      v385 = &v589[2 * v383];
      v384[272] += 40;
      do
      {
        ++*(v384 + *&v385[v382]);
        v382 += 2;
      }

      while (v382 != 80);
      ++v379;
    }

    while (v379 != v361);
    v386 = v361 + 2 * v631 / 0x28 + 99;
    v387 = v386 / v361 * v361;
    if (v386 != v386 % v361)
    {
      v388 = 0;
      v389 = &v622[274 * v361];
      LODWORD(v390) = 7;
      do
      {
        bzero(v389, 0x880uLL);
        v390 = (16807 * v390);
        v391 = &v589[2 * (v390 % (v631 - 39))];
        v389[272] = 40;
        v392 = -40;
        do
        {
          v393 = *v391;
          v391 += 2;
          ++*(v389 + v393);
          v57 = __CFADD__(v392++, 1);
        }

        while (!v57);
        v394 = 0;
        v395 = 0;
        v396 = &v622[274 * (v388 % v361)];
        v396[272] += 40;
        do
        {
          *(v396 + v395++) += *(v389 + v394);
          v394 += 4;
        }

        while (v394 != 2176);
        ++v388;
      }

      while (v388 < v387);
      v389[273] = 0x7FF0000000000000;
      v360 = v631;
    }

    v397 = BrotliAllocate(v12);
    v398 = BrotliAllocate(v12);
    v399 = BrotliAllocate(v12);
    if (((v361 + 7) >> 3) * v360)
    {
      v581 = BrotliAllocate(v12);
    }

    else
    {
      v581 = 0;
    }

    v607 = BrotliAllocate(v12);
    v400 = 0;
    v401 = 3;
    if (*(a7 + 4) > 10)
    {
      v401 = 10;
    }

    v601 = v401;
    v576 = v360 - 1;
    v559 = (v397 - 2);
    *v564 = v360 - 2;
    do
    {
      v614 = v400;
      if (v361 > 1)
      {
        v593 = (v361 + 7) >> 3;
        bzero(v398, 4352 * v361);
        v404 = 0;
        v405 = (v622 + 272);
        do
        {
          v406 = *v405;
          if (v406 > 0xFF)
          {
            v407 = log2(v406);
          }

          else
          {
            v407 = kBrotliLog2Table[v406];
          }

          v405 += 548;
          *&v398[8 * v404++] = v407;
        }

        while (v361 != v404);
        v408 = &v398[4344 * v361];
        v409 = v622 + 543;
        v410 = 544;
        do
        {
          v411 = 0;
          --v410;
          v412 = v409;
          do
          {
            v413 = *&v398[8 * v411];
            v414 = *v412;
            if (v414)
            {
              if (v414 > 0xFF)
              {
                v415 = log2(v414);
              }

              else
              {
                v415 = kBrotliLog2Table[v414];
              }
            }

            else
            {
              v415 = -2.0;
            }

            v412 += 548;
            *&v408[8 * v411++] = v413 - v415;
          }

          while (v361 != v411);
          v408 -= 8 * v361;
          --v409;
        }

        while (v410);
        bzero(v399, 8 * v361);
        v360 = v631;
        bzero(v581, v593 * v631);
        v416 = 0;
        v12 = a1;
        do
        {
          v417 = 0;
          v418 = &v398[8 * v361 * *&v589[2 * v416]];
          v419 = 1.0e99;
          do
          {
            v420 = *&v418[8 * v417] + *(v399 + v417);
            *(v399 + v417) = v420;
            if (v420 < v419)
            {
              v397[v416] = v417;
              v419 = v420;
            }

            ++v417;
          }

          while (v361 != v417);
          v421 = 14.6;
          if (v416 <= 0x7CF)
          {
            v421 = (v416 * 0.07 / 2000.0 + 0.77) * 14.6;
          }

          for (n = 0; n != v361; ++n)
          {
            v423 = *(v399 + n) - v419;
            *(v399 + n) = v423;
            if (v423 >= v421)
            {
              *(v399 + n) = v421;
              v581[v416 * v593 + (n >> 3)] |= 1 << (n & 7);
            }
          }

          ++v416;
        }

        while (v416 != v631);
        v424 = v397[v576];
        v425 = &v581[*v564 * v593];
        v426 = v631;
        v402 = 1;
        v403 = v607;
        do
        {
          if ((v425[v424 >> 3] >> (v424 & 7)))
          {
            if (v424 != v559[v426])
            {
              ++v402;
            }

            v424 = v559[v426];
          }

          v425 -= v593;
          v559[v426--] = v424;
        }

        while (v426 != 1);
      }

      else
      {
        bzero(v397, v360);
        v402 = 1;
        v403 = v607;
      }

      if (v361)
      {
        memset_pattern16(v403, &unk_1AB4804F0, 2 * v361);
      }

      v427 = 0;
      v428 = 0;
      do
      {
        v429 = v397[v427];
        if (*(v403 + v429) == 256)
        {
          *(v403 + v429) = v428++;
        }

        ++v427;
      }

      while (v360 != v427);
      v430 = 0;
      do
      {
        v397[v430] = *(v403 + v397[v430]);
        ++v430;
      }

      while (v360 != v430);
      v361 = v428;
      if (v428)
      {
        v431 = v622;
        v432 = v428;
        do
        {
          bzero(v431, 0x880uLL);
          v431[272] = 0;
          v431[273] = 0x7FF0000000000000;
          v431 += 274;
          --v432;
        }

        while (v432);
      }

      v433 = 0;
      v434 = v589;
      do
      {
        v435 = &v622[274 * v397[v433]];
        ++*(v435 + *&v589[2 * v433]);
        ++v435[272];
        ++v433;
      }

      while (v360 != v433);
      v400 = v614 + 1;
    }

    while (v614 + 1 != v601);
    BrotliFree(v12);
    BrotliFree(v12);
    BrotliFree(v12);
    BrotliFree(v12);
    BrotliFree(v12);
    if (v402)
    {
      v565 = BrotliAllocate(v12);
      v436 = v402 + 256;
      if (v402 == -256)
      {
        v437 = 0;
        v438 = 0x3FFFFFFFFFFFFCFLL;
        goto LABEL_556;
      }
    }

    else
    {
      v565 = 0;
      v436 = 256;
    }

    v437 = BrotliAllocate(v12);
    v439 = 16 * v402 + 1008;
    v438 = v439 >> 6;
    if (v439 < 0x40)
    {
      v440 = 0;
      v441 = 0;
LABEL_557:
      *v551 = v438;
      v442 = v441;
      if (v402)
      {
        v536 = BrotliAllocate(v12);
      }

      else
      {
        v536 = 0;
      }

      v533 = BrotliAllocate(v12);
      v443 = v437 + 256;
      v444 = BrotliAllocate(v12);
      bzero(v437, 4 * v436);
      v445 = 0;
      v446 = v397 + 1;
      v447 = v440;
      v448 = v442;
      do
      {
        ++v443[v445];
        if (v360 == 1 || *(v446 - 1) != *v446)
        {
          ++v445;
        }

        ++v446;
        --v360;
      }

      while (v360);
      v615 = v444;
      v582 = v402;
      v636 = v437;
      v549 = v437 + 256;
      if (v402)
      {
        v449 = 0;
        *v569 = 0;
        v450 = 0;
        v451 = 0;
        v623 = v437 + 64;
        v632 = v437 + 128;
        v452 = (v437 + 192);
        v453 = 0;
        v577 = v565;
        v454 = v402;
        v455 = v447;
        v456 = *v551;
        v457 = v442;
        v602 = v452;
        while (1)
        {
          v560 = v455;
          v594 = v456;
          __srcb = v457;
          v458 = 0;
          v542 = v454 - 64;
          v545 = v453;
          if (v454 >= 0x40)
          {
            v454 = 64;
          }

          v459 = v454 <= 1 ? 1 : v454;
          v572 = v450;
          v460 = &v443[v450];
          do
          {
            v461 = v460[v458];
            v462 = &v536[2192 * v458];
            bzero(v462, 0x880uLL);
            *(v462 + 272) = 0;
            *(v462 + 273) = 0x7FF0000000000000;
            if (v461)
            {
              v463 = v461;
              do
              {
                v464 = *&v434[2 * v451++];
                ++*&v462[4 * v464];
                --v463;
              }

              while (v463);
              *(v462 + 272) = v461;
            }

            BrotliPopulationCostDistance(&v536[2192 * v458]);
            *(v462 + 273) = v465;
            v623[v458] = v458;
            v632[v458] = v458;
            *(v636 + 4 * v458++) = 1;
          }

          while (v458 != v459);
          v466 = &v582[-v572] >= 0x40 ? 64 : &v582[-v572];
          v467 = BrotliHistogramCombineDistance(v536, v615, v636, v632, v623, v533, v466, v466, 0x40uLL, 0x800uLL);
          v608 = v467;
          if (*v551 >= (v467 + v449))
          {
            v447 = v560;
            v469 = *v551;
            v456 = v594;
          }

          else
          {
            if (*v551)
            {
              v468 = *v551;
            }

            else
            {
              v468 = v467 + v449;
            }

            do
            {
              v469 = v468;
              v468 *= 2;
            }

            while (v469 < v467 + v449);
            v470 = BrotliAllocate(a1);
            v447 = v470;
            if (*v551)
            {
              memcpy(v470, v560, 2192 * *v551);
            }

            BrotliFree(a1);
            v456 = v594;
            v467 = v608;
          }

          v471 = v602;
          v561 = v447;
          if (v456 < v467 + *v569)
          {
            break;
          }

          v448 = __srcb;
          if (v467)
          {
            goto LABEL_600;
          }

LABEL_603:
          v478 = v632;
          v479 = v577;
          v443 = v549;
          do
          {
            v480 = *v478++;
            *v479++ = *&v471[4 * v480] + v545;
            --v459;
          }

          while (v459);
          v453 = v467 + v545;
          v450 = v572 + 64;
          v577 += 64;
          v454 = v542;
          *v551 = v469;
          v455 = v447;
          v457 = v448;
          v402 = v582;
          if (v572 + 64 >= v582)
          {
            goto LABEL_608;
          }
        }

        if (v456)
        {
          v472 = v456;
        }

        else
        {
          v472 = v467 + *v569;
        }

        do
        {
          v456 = v472;
          v472 *= 2;
        }

        while (v456 < v467 + *v569);
        v473 = BrotliAllocate(a1);
        v474 = v473;
        if (v594)
        {
          memcpy(v473, __srcb, 4 * v594);
        }

        BrotliFree(a1);
        v448 = v474;
        v471 = v602;
        v467 = v608;
        if (!v608)
        {
          goto LABEL_603;
        }

LABEL_600:
        v475 = v447;
        v476 = 0;
        v477 = (v475 + 2192 * v449);
        *v552 = v448;
        v595 = &v448[4 * *v569];
        do
        {
          ++v449;
          memcpy(v477, &v536[2192 * v623[v476]], 0x890uLL);
          v471 = v602;
          v467 = v608;
          *&v595[4 * v476] = *(v636 + 4 * v623[v476]);
          *&v602[4 * v623[v476]] = v476;
          ++v476;
          v477 += 2192;
        }

        while (v608 != v476);
        *v569 += v476;
        v434 = v589;
        v448 = *v552;
        v447 = v561;
        goto LABEL_603;
      }

      v453 = 0;
LABEL_608:
      v553 = v448;
      v12 = a1;
      BrotliFree(a1);
      v481 = v453;
      if (v453 << 6 >= (v453 >> 1) * v453)
      {
        v482 = (v453 >> 1) * v453;
      }

      else
      {
        v482 = v453 << 6;
      }

      if (v482 >= 0x801)
      {
        BrotliFree(a1);
        v533 = BrotliAllocate(a1);
      }

      if (v481)
      {
        v483 = BrotliAllocate(a1);
        v484 = 0;
        v485 = vdupq_n_s64(v481 - 1);
        v486 = v483 + 2;
        v487 = xmmword_1AB465F90;
        v488 = xmmword_1AB465FA0;
        v489 = vdupq_n_s64(4uLL);
        do
        {
          v490 = vmovn_s64(vcgeq_u64(v485, v488));
          if (vuzp1_s16(v490, *v485.i8).u8[0])
          {
            *(v486 - 2) = v484;
          }

          if (vuzp1_s16(v490, *&v485).i8[2])
          {
            *(v486 - 1) = v484 + 1;
          }

          if (vuzp1_s16(*&v485, vmovn_s64(vcgeq_u64(v485, *&v487))).i32[1])
          {
            *v486 = v484 + 2;
            v486[1] = v484 + 3;
          }

          v484 += 4;
          v487 = vaddq_s64(v487, v489);
          v488 = vaddq_s64(v488, v489);
          v486 += 4;
        }

        while (((v481 + 3) & 0xFFFFFFFFFFFFFFFCLL) != v484);
      }

      else
      {
        v483 = 0;
      }

      v609 = v483;
      v624 = BrotliHistogramCombineDistance(v447, v615, v553, v565, v483, v533, v481, v402, 0x100uLL, v482);
      BrotliFree(a1);
      BrotliFree(a1);
      if (v481)
      {
        v491 = BrotliAllocate(a1);
        memset(v491, 255, 4 * v481);
        if (!v402)
        {
          goto LABEL_643;
        }
      }

      else
      {
        v491 = 0;
        if (!v402)
        {
          goto LABEL_643;
        }
      }

      v492 = 0;
      v493 = 0;
      v633 = 0;
      do
      {
        bzero(v615, 0x880uLL);
        *(v615 + 2176) = 0;
        *(v615 + 2184) = 0x7FF0000000000000;
        if (v443[v493])
        {
          v494 = 0;
          do
          {
            ++*(v615 + 4 * *&v434[2 * v633 + 2 * v494++]);
          }

          while (v494 < v443[v493]);
          *(v615 + 2176) = v494;
          v633 += v494;
        }

        v495 = v491;
        v496 = v493 - 1;
        if (!v493)
        {
          v496 = 0;
        }

        v497 = v565[v496];
        v498 = BrotliHistogramBitCostDistanceDistance(v615, v447 + 2192 * v497, (v615 + 2192));
        v499 = v624;
        if (v624)
        {
          v500 = v498;
          v501 = v609;
          do
          {
            v502 = BrotliHistogramBitCostDistanceDistance(v615, v447 + 2192 * *v501, (v615 + 2192));
            if (v502 < v500)
            {
              v497 = *v501;
              v500 = v502;
            }

            ++v501;
            --v499;
          }

          while (v499);
        }

        v565[v493] = v497;
        v491 = v495;
        if (*(v495 + v497) == -1)
        {
          *(v495 + v497) = v492++;
        }

        v12 = a1;
        v443 = v549;
        ++v493;
      }

      while (v493 != v582);
LABEL_643:
      BrotliFree(v12);
      BrotliFree(v12);
      BrotliFree(v12);
      v503 = *(a10 + 32);
      v504 = v582;
      if (v503 < v582)
      {
        if (!v503)
        {
          v503 = v582;
        }

        do
        {
          v505 = v503;
          v503 *= 2;
        }

        while (v505 < v582);
        v506 = BrotliAllocate(v12);
        v507 = v506;
        v508 = *(a10 + 32);
        if (v508)
        {
          memcpy(v506, *(a10 + 16), v508);
        }

        BrotliFree(v12);
        *(a10 + 16) = v507;
        *(a10 + 32) = v505;
        v443 = v549;
      }

      v509 = *(a10 + 40);
      if (v509 >= v582)
      {
        if (!v582)
        {
          v515 = 0;
          v521 = 1;
LABEL_666:
          *a10 = v521;
          *(a10 + 8) = v515;
          BrotliFree(v12);
          BrotliFree(v12);
          BrotliFree(v12);
          BrotliFree(v12);
          goto LABEL_667;
        }
      }

      else
      {
        if (!v509)
        {
          v509 = v582;
        }

        do
        {
          v510 = v509;
          v509 *= 2;
        }

        while (v510 < v582);
        v511 = BrotliAllocate(v12);
        v512 = v511;
        v513 = *(a10 + 40);
        if (v513)
        {
          memcpy(v511, *(a10 + 24), 4 * v513);
        }

        BrotliFree(v12);
        *(a10 + 24) = v512;
        *(a10 + 40) = v510;
      }

      v514 = 0;
      v515 = 0;
      v516 = 0;
      v517 = v565 + 1;
      do
      {
        v518 = *v443++;
        v516 += v518;
        v519 = *(v517 - 1);
        if (v504 == 1 || v519 != *v517)
        {
          v520 = *(v491 + v519);
          *(*(a10 + 16) + v515) = v520;
          *(*(a10 + 24) + 4 * v515) = v516;
          if (v514 <= v520)
          {
            v514 = v520;
          }

          ++v515;
          v516 = 0;
        }

        ++v517;
        --v504;
      }

      while (v504);
      v521 = v514 + 1;
      goto LABEL_666;
    }

LABEL_556:
    v440 = BrotliAllocate(v12);
    v441 = BrotliAllocate(v12);
    goto LABEL_557;
  }

  v362 = *(v13 + 32);
  v363 = *(v13 + 8);
  v364 = v363 + 1;
  if (v362 < v363 + 1)
  {
    if (v362)
    {
      v365 = *(v13 + 32);
    }

    else
    {
      v365 = v363 + 1;
    }

    do
    {
      v366 = v365;
      v365 *= 2;
    }

    while (v366 < v364);
    v367 = BrotliAllocate(v12);
    v368 = v367;
    v369 = *(v13 + 32);
    if (v369)
    {
      memcpy(v367, *(v13 + 16), v369);
    }

    BrotliFree(v12);
    *(v13 + 16) = v368;
    *(v13 + 32) = v366;
    v363 = *(v13 + 8);
    v364 = v363 + 1;
  }

  v370 = *(v13 + 40);
  if (v370 < v364)
  {
    if (v370)
    {
      v371 = *(v13 + 40);
    }

    else
    {
      v371 = v364;
    }

    do
    {
      v372 = v371;
      v371 *= 2;
    }

    while (v372 < v364);
    v373 = BrotliAllocate(v12);
    v374 = v373;
    v375 = *(v13 + 40);
    if (v375)
    {
      memcpy(v373, *(v13 + 24), 4 * v375);
    }

    BrotliFree(v12);
    *(v13 + 24) = v374;
    *(v13 + 40) = v372;
    v363 = *(v13 + 8);
  }

  *v13 = 1;
  *(*(v13 + 16) + v363) = 0;
  v376 = *(v13 + 8);
  *(*(v13 + 24) + 4 * v376) = v631;
  *(v13 + 8) = v376 + 1;
LABEL_667:

  return BrotliFree(v12);
}