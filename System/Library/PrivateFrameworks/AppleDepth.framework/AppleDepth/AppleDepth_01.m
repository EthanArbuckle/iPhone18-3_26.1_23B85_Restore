uint64_t dbdsqr_(uint64_t *a1, uint64_t *a2, unint64_t *a3, double *a4, double *a5, double *a6, uint64_t *a7, double *a8, double a9, int8x16_t a10, int8x16_t a11, int8x16_t a12, int8x16_t a13, double a14, double a15, int8x16_t a16, uint64_t *a17, double *a18, uint64_t *a19)
{
  v340 = 0.0;
  v20 = *a17;
  v344 = 0.0;
  v345 = 0.0;
  v342 = 0.0;
  v343 = 0.0;
  v341 = 0.0;
  *a19 = 0;
  v21 = *a1;
  if (!*a1)
  {
    return 0;
  }

  v24 = a4 - 1;
  v25 = v21 - 1;
  v337 = v20;
  v338 = a2;
  if (v21 == 1)
  {
    goto LABEL_13;
  }

  v26 = a5;
  v346[0] = *a1;
  v27 = fabs(*a4);
  v28 = *a4 == 0.0 || v21 < 2;
  if (!v28)
  {
    v291 = v21 - 2;
    v292 = a4 + 1;
    v293 = a5;
    v294 = v27;
    do
    {
      v295 = *v292++;
      v296 = fabs(v295);
      v297 = *v293++;
      *a12.i64 = v294 + fabs(v297);
      v294 = v296 * (v294 / *a12.i64);
      if (v27 >= v294)
      {
        v27 = v294;
      }
    }

    while (v27 != 0.0 && v291-- != 0);
  }

  v29 = v27 / sqrt(v21) * 9.99200722e-15;
  v331 = 6 * v21 * v21;
  *a10.i64 = v331 * COERCE_DOUBLE(0x8000000000000);
  v30 = v29 <= *a10.i64 ? v331 * COERCE_DOUBLE(0x8000000000000) : v29;
  if (v21 <= 1)
  {
    return 0;
  }

  v100 = 0;
  v101 = 0;
  v102 = a5 - 1;
  v307 = 2 * v25;
  v308 = v21 - 1;
  v324 = a6;
  v304 = a6 - 1;
  v305 = a8;
  v319 = &a8[~v20 + 1];
  v314 = a4 + 1;
  v316 = &a18[2 * v25];
  v317 = a18 - 1;
  v306 = 3 * v25;
  v315 = &a18[3 * v25];
  v103 = &a18[v21 - 1];
  v332 = a5 - 2;
  v333 = a4 - 2;
  v104 = &a18[3 * v21];
  v311 = v104 - 5;
  v105 = &a18[2 * v21];
  v309 = &a18[v21 - 3];
  v310 = v105 - 4;
  v312 = v105 - 2;
  v313 = v104 - 3;
  v303 = v104 - 4;
  v301 = &a18[v21 - 2];
  v302 = v105 - 3;
  v106 = -1;
  v19.i64[0] = 1.0;
  v107.f64[0] = NAN;
  v107.f64[1] = NAN;
  v108 = vnegq_f64(v107);
  v318 = v108;
  v108.f64[0] = 0.0;
  v335 = v108;
  v108.f64[0] = 0.0;
  v334 = v108;
  v109 = 0.0;
  v110 = 0.0;
  v111 = 0.0;
  v112 = -1;
  v325 = a5 - 1;
  v326 = a7;
  v320 = v103;
LABEL_67:
  v113 = v106;
  v114 = v112;
  v112 = v21;
LABEL_68:
  v116 = v334;
  v115 = v335;
  if (v100 <= v331)
  {
LABEL_69:
    v117 = v112;
    v118 = v112 - 1;
    v119 = &v102[v112 - 1];
    while (1)
    {
      while (1)
      {
        *a11.i64 = fabs(v24[v112]);
        v120 = &v332[v112];
        v121 = &v333[v112];
        v122 = v112 - 1;
        while (1)
        {
          v108.f64[0] = fabs(*v120);
          if (v108.f64[0] <= v30)
          {
            break;
          }

          v123 = *v121--;
          *a10.i64 = fabs(v123);
          if (*a11.i64 > *a10.i64)
          {
            a10.i64[0] = a11.i64[0];
          }

          if (*a10.i64 <= v108.f64[0])
          {
            *a11.i64 = v108.f64[0];
          }

          else
          {
            a11.i64[0] = a10.i64[0];
          }

          --v120;
          if (!--v122)
          {
            goto LABEL_80;
          }
        }

        v102[v122] = 0.0;
        if (v122 == v118)
        {
          goto LABEL_132;
        }

LABEL_80:
        v106 = v122 + 1;
        if (v122 + 1 == v118)
        {
          v336 = v113;
          v327 = v101;
          v321 = v100;
          v130 = &v102[v112 - 1];
          dlasv2_(&v24[v118], v119, &v24[v117], &v341, &v340, &v342, &v343, &v344, v108, a10, a11, a12, a13, a14, a15, a16, &v345);
          v19.i64[0] = 1.0;
          v100 = v321;
          a7 = v326;
          *a10.i64 = v340;
          v108.f64[0] = v341;
          v24[v118] = v340;
          *v130 = 0.0;
          v24[v112] = v108.f64[0];
          v131 = *v338;
          v109 = v342;
          v110 = v343;
          if (*v338 >= 1)
          {
            v132 = &v304[v117];
            if (*v326 == 1)
            {
              v133 = v304[v118];
              do
              {
                a10.i64[0] = *v132;
                v134 = v109 * *v132 + v110 * v133;
                v133 = v110 * *v132 - v133 * v109;
                *(v132 - 1) = v134;
                *v132++ = v133;
                --v131;
              }

              while (v131);
            }

            else
            {
              v135 = 8 * *v326;
              do
              {
                v136 = *(v132 - 1);
                a10.i64[0] = *v132;
                v137 = v109 * *v132 + v110 * v136;
                v138 = v110 * *v132 - v136 * v109;
                *(v132 - 1) = v137;
                *v132 = v138;
                v132 = (v132 + v135);
                --v131;
              }

              while (v131);
            }
          }

          v139 = *a3;
          v115.f64[0] = v344;
          v116.f64[0] = v345;
          v102 = v325;
          v103 = v320;
          v101 = v327;
          v113 = v336;
          if (*a3 >= 1)
          {
            if (v139 < 4 || ((v140 = &v319[v118 * v337], v141 = &v319[v112 * v337], v140 < (&v305[v139] + v337 * (v117 * 8 - 8))) ? (v142 = v141 >= (&v305[v139] + v337 * (v117 * 8 - 16))) : (v142 = 1), !v142))
            {
              v143 = 0;
              goto LABEL_129;
            }

            v143 = v139 & 0x7FFFFFFFFFFFFFFELL;
            v108 = vdupq_lane_s64(*&v345, 0);
            v144 = v139 & 0x7FFFFFFFFFFFFFFELL;
            do
            {
              v145 = *v140;
              a11 = *v141;
              a12 = vmlaq_f64(vmulq_n_f64(*v141, v115.f64[0]), *v140, v108);
              *v140++ = a12;
              a10 = vmlaq_f64(vmulq_n_f64(vnegq_f64(v145), v115.f64[0]), a11, v108);
              *v141++ = a10;
              v144 -= 2;
            }

            while (v144);
            if (v139 != v143)
            {
LABEL_129:
              v146 = v139 - v143;
              v147 = &v305[v143];
              v148 = (v147 + v337 * (v117 * 8 - 8));
              v149 = (v147 + v337 * (v117 * 8 - 16));
              do
              {
                v150 = *v149;
                a10.i64[0] = *v148;
                *v149 = v115.f64[0] * *v148 + v116.f64[0] * *v149;
                ++v149;
                *v148++ = v116.f64[0] * *a10.i64 - v150 * v115.f64[0];
                --v146;
              }

              while (v146);
            }
          }

          v118 = v112 - 2;
LABEL_132:
          v112 = v118;
          if (v118 < 2)
          {
            v21 = *a1;
            a8 = v305;
            a6 = v324;
            v20 = v337;
            a2 = v338;
            if (*a1 < 1)
            {
              return 0;
            }

LABEL_13:
            v31 = a6 - 1;
            v32 = a6 + 2;
            v33 = 1;
            v34 = a6;
            while (2)
            {
              v35 = v24[v33];
              if (v35 < 0.0)
              {
                v24[v33] = -v35;
                v36 = *a2;
                if (*a2 >= 1)
                {
                  v37 = *a7;
                  v38 = v36 >= 4 && v37 == 1;
                  if (v38)
                  {
                    v40 = v36 & 0x7FFFFFFFFFFFFFFCLL;
                    v41 = v32;
                    v42 = v36 & 0x7FFFFFFFFFFFFFFCLL;
                    do
                    {
                      v43 = vnegq_f64(*v41);
                      v41[-1] = vnegq_f64(v41[-1]);
                      *v41 = v43;
                      v41 += 2;
                      v42 -= 4;
                    }

                    while (v42);
                    if (v36 != v40)
                    {
                      v39 = v40 | 1;
                      goto LABEL_26;
                    }
                  }

                  else
                  {
                    v39 = 1;
LABEL_26:
                    v44 = v36 - v39 + 1;
                    v45 = 8 * v37;
                    v46 = (v34 + v45 * (v39 - 1));
                    do
                    {
                      *v46 = -*v46;
                      v46 = (v46 + v45);
                      --v44;
                    }

                    while (v44);
                  }
                }
              }

              ++v32;
              ++v34;
              v38 = v33++ == v21;
              if (v38)
              {
                if (v21 < 2)
                {
                  return 0;
                }

                v47 = 0;
                v48 = v21 + 1;
                v49 = 8 * v21 - 8;
                v50 = -8 * v20;
                v51 = a8 + v20 * v49;
                v52 = v21 - 1;
                v53 = &a6[v21 + 1];
                v54 = &a6[v21];
                v55 = a8 + v20 * v49 + 16;
                v56 = a8 + v20 * v49 - 8;
                v57 = 1;
                while (2)
                {
                  v58 = *a4;
                  v59 = v48 - v57;
                  if (v48 - v57 >= 2)
                  {
                    v61 = a4 + 1;
                    v62 = v52;
                    v60 = 1;
                    v63 = 2;
                    do
                    {
                      v64 = *v61++;
                      v65 = v64;
                      if (v64 <= v58)
                      {
                        v60 = v63;
                        v58 = v65;
                      }

                      ++v63;
                      --v62;
                    }

                    while (v62);
                  }

                  else
                  {
                    v60 = 1;
                  }

                  if (v60 != v59)
                  {
                    v24[v60] = v24[v59];
                    v24[v59] = v58;
                    v66 = *a2;
                    if (*a2 >= 1)
                    {
                      v67 = *a7;
                      v68 = 1;
                      if (v66 >= 4 && v67 == 1)
                      {
                        v69 = a6 + v49 - 8 * v47;
                        if (&v31[v60] < &v69[8 * v66] && v69 < &v31[v60 + v66])
                        {
                          v68 = 1;
                          goto LABEL_49;
                        }

                        v70 = v66 & 0x7FFFFFFFFFFFFFFCLL;
                        v71 = &a6[v60 + 1];
                        v72 = v53;
                        v73 = v66 & 0x7FFFFFFFFFFFFFFCLL;
                        do
                        {
                          v74 = *(v71 - 1);
                          v75 = *v71;
                          v76 = *v72;
                          *(v71 - 1) = *(v72 - 1);
                          *v71 = v76;
                          *(v72 - 1) = v74;
                          *v72 = v75;
                          v72 += 4;
                          v71 += 4;
                          v73 -= 4;
                        }

                        while (v73);
                        v20 = v337;
                        a2 = v338;
                        if (v66 != v70)
                        {
                          v68 = v70 | 1;
                          goto LABEL_49;
                        }
                      }

                      else
                      {
LABEL_49:
                        v77 = v66 - v68 + 1;
                        v78 = 8 * v67;
                        v79 = v78 * (v68 - 1) - 8;
                        v80 = &a6[v60];
                        do
                        {
                          v81 = *(v80 + v79);
                          *(v80 + v79) = *(v54 + v79);
                          *(v54 + v79) = v81;
                          v79 += v78;
                          --v77;
                        }

                        while (v77);
                      }
                    }

                    v82 = *a3;
                    if (*a3 >= 1)
                    {
                      v83 = 8 * v60;
                      if (v82 > 3)
                      {
                        v85 = &v51[v50 * v47];
                        v86 = a8 + v20 * (v83 - 8);
                        if (v86 < v85 + 8 * v82 && v85 < &v86[8 * v82])
                        {
                          v84 = 1;
                          a2 = v338;
                          goto LABEL_63;
                        }

                        v88 = v82 & 0x7FFFFFFFFFFFFFFCLL;
                        v89 = (a8 + v20 * (v83 - 8) + 16);
                        v90 = v55;
                        v91 = v82 & 0x7FFFFFFFFFFFFFFCLL;
                        a2 = v338;
                        do
                        {
                          v92 = *(v89 - 1);
                          v93 = *v89;
                          v94 = *v90;
                          *(v89 - 1) = *(v90 - 1);
                          *v89 = v94;
                          *(v90 - 1) = v92;
                          *v90 = v93;
                          v90 += 2;
                          v89 += 2;
                          v91 -= 4;
                        }

                        while (v91);
                        if (v82 != v88)
                        {
                          v84 = v88 | 1;
                          goto LABEL_63;
                        }
                      }

                      else
                      {
                        v84 = 1;
LABEL_63:
                        v95 = v82 - v84 + 1;
                        v96 = v84;
                        v97 = &v56[8 * v84];
                        v98 = (&a8[v96 - 1] + v20 * (v83 - 8));
                        do
                        {
                          v99 = *v98;
                          *v98++ = *v97;
                          *v97 = v99;
                          v97 += 8;
                          --v95;
                        }

                        while (v95);
                      }
                    }
                  }

                  ++v57;
                  ++v47;
                  --v52;
                  --v53;
                  --v54;
                  v55 += v50;
                  v56 += v50;
                  if (v57 == v21)
                  {
                    return 0;
                  }

                  continue;
                }
              }

              continue;
            }
          }

          goto LABEL_69;
        }

        if (v122 >= v114 || v112 < v113)
        {
          break;
        }

        if (v101 == 1)
        {
          *a10.i64 = v24[v112];
          *a13.i64 = fabs(*a10.i64);
          goto LABEL_87;
        }

        v108.f64[0] = a4[v122];
        v124 = fabs(v108.f64[0]);
LABEL_97:
        v128 = &v26[v122];
        *a10.i64 = fabs(*v128);
        a13.i64[0] = 0x3D06800000000000;
        *a12.i64 = v124 * 9.99200722e-15;
        if (*a10.i64 > *a12.i64)
        {
          *a10.i64 = v24[v112];
          *a12.i64 = fabs(*a10.i64);
          if (v118 <= v122)
          {
LABEL_134:
            v151 = 0;
            goto LABEL_135;
          }

          v129 = v112 - 2;
          a13.i64[0] = a12.i64[0];
          while (1)
          {
            a14 = fabs(v26[v129]);
            a15 = *a13.i64 * 9.99200722e-15;
            if (a14 <= *a13.i64 * 9.99200722e-15)
            {
              break;
            }

            *a13.i64 = *a13.i64 / (*a13.i64 + a14) * fabs(a4[v129]);
            if (*a12.i64 >= *a13.i64)
            {
              a12.i64[0] = a13.i64[0];
            }

            v28 = v129-- <= v122;
            if (v28)
            {
              goto LABEL_134;
            }
          }

          v126 = v129 + 1;
          goto LABEL_109;
        }

LABEL_106:
        *v128 = 0.0;
      }

      v108.f64[0] = a4[v122];
      v124 = fabs(v108.f64[0]);
      *a10.i64 = v24[v112];
      *a13.i64 = fabs(*a10.i64);
      if (v124 < *a13.i64)
      {
        v101 = 2;
        goto LABEL_97;
      }

LABEL_87:
      *a12.i64 = *a13.i64 * 9.99200722e-15;
      if (fabs(*v119) <= *a13.i64 * 9.99200722e-15)
      {
        v128 = &v102[v112 - 1];
        v101 = 1;
        goto LABEL_106;
      }

      v108.f64[0] = a4[v122];
      *a12.i64 = fabs(v108.f64[0]);
      if (v112 <= v106)
      {
        v151 = 1;
        v101 = 1;
LABEL_135:
        v152 = ~v122;
        v153 = *a1;
        if (*a12.i64 / *a11.i64 * (*a1 * 9.99200722e-15) <= 1.11022302e-16)
        {
          goto LABEL_234;
        }

        v154 = fabs(v108.f64[0]);
        if (v151)
        {
          v155 = fabs(v24[v118]);
          v156 = fabs(*a10.i64);
          if (v155 >= v156)
          {
            v157 = v156;
          }

          else
          {
            v157 = v155;
          }

          if (v155 <= v156)
          {
            v158 = v156;
          }

          else
          {
            v158 = v155;
          }

          v159 = 0.0;
          v160 = v154;
          if (v157 == 0.0)
          {
LABEL_154:
            if (v160 <= 0.0)
            {
              goto LABEL_156;
            }

            goto LABEL_155;
          }

          v161 = fabs(*v119);
          v162 = v157 / v158 + *v19.i64;
          v163 = (v158 - v157) / v158;
          if (v161 >= v158)
          {
            v159 = v158 / v161 * (v157 * (2.0 / (sqrt(*v19.i64 + v158 / v161 * v162 * (v158 / v161 * v162)) + sqrt(*v19.i64 + v158 / v161 * v163 * (v158 / v161 * v163)))));
            v160 = v154;
            if (v154 <= 0.0)
            {
              goto LABEL_156;
            }
          }

          else
          {
            v159 = v157 * (2.0 / (sqrt(v161 / v158 * (v161 / v158) + v162 * v162) + sqrt(v161 / v158 * (v161 / v158) + v163 * v163)));
            v160 = v154;
            if (v154 <= 0.0)
            {
              goto LABEL_156;
            }
          }

LABEL_155:
          if (v159 / v160 * (v159 / v160) >= 1.11022302e-16)
          {
            goto LABEL_156;
          }

LABEL_234:
          v167 = v100 + v112 + v152;
          if (v151)
          {
LABEL_235:
            v227 = 1.0;
            v228 = v112 - v106;
            if (v112 <= v106)
            {
              v334 = v116;
              v335 = v115;
              v329 = v101;
              v255 = v167;
              v232 = 1.0;
LABEL_299:
              v283 = v227 * *a10.i64;
              v24[v112] = v232 * v283;
              *v119 = v111 * v283;
              v284 = v228 + 1;
              v346[0] = v228 + 1;
              v285 = &v102[v112 - 1];
              dlasr_("L", "F", v346, v338, a18, &v317[v153], &v324[v122], a7);
              v346[0] = v284;
              dlasr_("R", "F", a3, v346, v316, v315, &v319[v106 * v337], a17);
              v286 = v285;
              v102 = v325;
              a7 = v326;
              v287 = fabs(*v285) > v30;
              v21 = v112;
              v100 = v255;
              v103 = v320;
              goto LABEL_302;
            }

            v229 = 0;
            v230 = &v24[v106];
            v231 = &v102[v106];
            v232 = 1.0;
            v233 = v122 + 1;
            while (2)
            {
              v236 = v227 * v230[v229];
              v237 = v231[v229];
              v238 = 0.0;
              if (v237 == 0.0)
              {
                v227 = 1.0;
                v237 = v236;
              }

              else if (v236 == 0.0)
              {
                v227 = 0.0;
                v238 = 1.0;
              }

              else
              {
                v239 = sqrt(v237 * v237 + v236 * v236);
                v227 = v236 / v239;
                v240 = v237 / v239;
                v241 = fabs(v236) > fabs(v237);
                v242 = v236 / v239 < 0.0;
                v237 = -v239;
                v243 = !v241 || !v242;
                if (!v241 || !v242)
                {
                  v237 = v239;
                }

                v244 = v239;
                if (v243)
                {
                  v238 = v240;
                }

                else
                {
                  v227 = -v227;
                  v238 = -v240;
                }

                if ((*&v244 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  return 0xFFFFFFFFLL;
                }
              }

              if (v233 > v106)
              {
                v231[v229 - 1] = v111 * v237;
              }

              v234 = v232 * v237;
              v235 = v238 * v230[v229 + 1];
              if (v235 == 0.0)
              {
                v232 = 1.0;
                v111 = 0.0;
                goto LABEL_239;
              }

              if (v234 == 0.0)
              {
                v232 = 0.0;
                v111 = 1.0;
                v234 = v238 * v230[v229 + 1];
LABEL_239:
                v230[v229] = v234;
              }

              else
              {
                v245 = sqrt(v235 * v235 + v234 * v234);
                v246 = v234 / v245;
                v247 = v235 / v245;
                v248 = fabs(v234) > fabs(v235);
                v249 = v234 / v245 < 0.0;
                v250 = -v245;
                v251 = !v248 || !v249;
                if (!v248 || !v249)
                {
                  v250 = v245;
                }

                v252 = v245;
                v232 = -v246;
                if (v251)
                {
                  v232 = v246;
                }

                if (v251)
                {
                  v111 = v247;
                }

                else
                {
                  v111 = -v247;
                }

                v230[v229] = v250;
                if ((*&v252 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  return 0xFFFFFFFFLL;
                }
              }

              ++v233;
              a18[v229] = v227;
              v103[v229] = v238;
              v312[v229] = v232;
              v313[v229++] = v111;
              if (v112 == v233)
              {
                v334 = v116;
                v335 = v115;
                v329 = v101;
                v255 = v167;
                *a10.i64 = v24[v112];
                goto LABEL_299;
              }

              continue;
            }
          }

LABEL_266:
          v253 = 1.0;
          if (v112 < v122 + 2)
          {
            v334 = v116;
            v335 = v115;
            v329 = v101;
            v323 = v167;
            v254 = 1.0;
            goto LABEL_301;
          }

          v256 = &v303[-v106];
          v257 = &v302[-v106];
          v258 = &v301[-v106];
          v259 = &v317[-v106];
          v254 = 1.0;
          v261 = v332;
          v260 = v333;
          v262 = v112;
          while (2)
          {
            v265 = &v260[v117];
            v266 = v253 * v260[v117 + 1];
            v267 = v261[v112];
            v268 = 0.0;
            if (v267 == 0.0)
            {
              v253 = 1.0;
              v267 = v266;
            }

            else if (v266 == 0.0)
            {
              v253 = 0.0;
              v268 = 1.0;
            }

            else
            {
              v269 = sqrt(v267 * v267 + v266 * v266);
              v253 = v266 / v269;
              v270 = v267 / v269;
              v271 = fabs(v266) > fabs(v267);
              v272 = v266 / v269 < 0.0;
              v267 = -v269;
              v273 = !v271 || !v272;
              if (!v271 || !v272)
              {
                v267 = v269;
              }

              v274 = v269;
              if (v273)
              {
                v268 = v270;
              }

              else
              {
                v253 = -v253;
                v268 = -v270;
              }

              if ((*&v274 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                return 0xFFFFFFFFLL;
              }
            }

            if (v262 < v112)
            {
              v261[v117 + 1] = v111 * v267;
            }

            v263 = v254 * v267;
            v264 = v268 * v260[v112];
            if (v264 == 0.0)
            {
              v254 = 1.0;
              v111 = 0.0;
              goto LABEL_272;
            }

            if (v263 == 0.0)
            {
              v254 = 0.0;
              v111 = 1.0;
              v263 = v268 * v260[v112];
LABEL_272:
              v265[1] = v263;
            }

            else
            {
              v275 = sqrt(v264 * v264 + v263 * v263);
              v276 = v263 / v275;
              v277 = v264 / v275;
              v278 = fabs(v263) > fabs(v264);
              v279 = v263 / v275 < 0.0;
              v280 = -v275;
              v281 = !v278 || !v279;
              if (!v278 || !v279)
              {
                v280 = v275;
              }

              v282 = v275;
              v254 = -v276;
              if (v281)
              {
                v254 = v276;
              }

              if (v281)
              {
                v111 = v277;
              }

              else
              {
                v111 = -v277;
              }

              v265[1] = v280;
              if ((*&v282 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                return 0xFFFFFFFFLL;
              }
            }

            v259[v112] = v253;
            v258[v112] = -v268;
            v257[v112] = v254;
            --v262;
            v256[v112] = -v111;
            --v261;
            --v256;
            --v257;
            --v258;
            --v259;
            --v260;
            if (v262 + 1 > v122 + 2)
            {
              continue;
            }

            break;
          }

          v334 = v116;
          v335 = v115;
          v329 = v101;
          v323 = v167;
          v108.f64[0] = a4[v122];
LABEL_301:
          v288 = v122;
          v289 = v253 * v108.f64[0];
          a4[v288] = v254 * v289;
          v286 = &v26[v288];
          v26[v288] = v111 * v289;
          v346[0] = v112 - v106 + 1;
          dlasr_("L", "B", v346, v338, v316, v315, &v324[v288], a7);
          v346[0] = v112 - v106 + 1;
          dlasr_("R", "B", a3, v346, a18, &v317[*a1], &v319[v106 * v337], a17);
          v102 = v325;
          a7 = v326;
          v287 = fabs(*v286) > v30;
          v21 = v112;
          v100 = v323;
LABEL_302:
          v19.i64[0] = 1.0;
          v101 = v329;
          if (!v287)
          {
            *v286 = 0.0;
            v21 = v112;
          }

          goto LABEL_67;
        }

        v160 = fabs(*a10.i64);
        v164 = fabs(v314[v122]);
        if (v154 >= v164)
        {
          v165 = v164;
        }

        else
        {
          v165 = v154;
        }

        if (v154 <= v164)
        {
          v166 = v164;
        }

        else
        {
          v166 = v154;
        }

        v159 = 0.0;
        if (v165 == 0.0)
        {
          goto LABEL_154;
        }

        v224 = fabs(v26[v122]);
        v225 = v165 / v166 + *v19.i64;
        v226 = (v166 - v165) / v166;
        if (v224 >= v166)
        {
          v159 = v166 / v224 * (v165 * (2.0 / (sqrt(*v19.i64 + v166 / v224 * v225 * (v166 / v224 * v225)) + sqrt(*v19.i64 + v166 / v224 * v226 * (v166 / v224 * v226)))));
          if (v160 > 0.0)
          {
            goto LABEL_155;
          }
        }

        else
        {
          v159 = v165 * (2.0 / (sqrt(v224 / v166 * (v224 / v166) + v225 * v225) + sqrt(v224 / v166 * (v224 / v166) + v226 * v226)));
          if (v160 > 0.0)
          {
            goto LABEL_155;
          }
        }

LABEL_156:
        v167 = v100 + v112 + v152;
        if (v159 == 0.0)
        {
          if (v151)
          {
            goto LABEL_235;
          }

          goto LABEL_266;
        }

        if (v151)
        {
          v168 = &v102[v112 - 1];
          v169 = (v154 - v159) * (*vbslq_s8(v318, v19, v108).i64 + v159 / v108.f64[0]);
          if (v112 > v106)
          {
            v170 = 0;
            v171 = v26[v122];
            v172 = &v102[v122];
            v173 = &v314[v122];
            v174 = v122 + 1;
            do
            {
              if (v171 == 0.0)
              {
                v110 = 1.0;
                v109 = 0.0;
              }

              else if (v169 == 0.0)
              {
                v110 = 0.0;
                v109 = 1.0;
                v169 = v171;
              }

              else
              {
                v175 = sqrt(v171 * v171 + v169 * v169);
                v176 = v169 / v175;
                v177 = fabs(v169) > fabs(v171);
                v178 = v169 / v175 < 0.0;
                if (v177 && v178)
                {
                  v169 = -v175;
                }

                else
                {
                  v169 = v175;
                }

                if (v177 && v178)
                {
                  v109 = -(v171 / v175);
                }

                else
                {
                  v109 = v171 / v175;
                }

                if (v177 && v178)
                {
                  v110 = -v176;
                }

                else
                {
                  v110 = v176;
                }

                if ((*&v175 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  return 0xFFFFFFFFLL;
                }
              }

              if (v174 > v106)
              {
                v172[v170] = v169;
              }

              v179 = v173[v170 - 1];
              v180 = v172[v170 + 1];
              v181 = v109 * v180 + v110 * v179;
              v172[v170 + 1] = v110 * v180 - v109 * v179;
              v182 = v173[v170];
              v171 = v109 * v182;
              v183 = v110 * v182;
              v173[v170] = v183;
              if (v171 == 0.0)
              {
                v116.f64[0] = 1.0;
                v115.f64[0] = 0.0;
              }

              else if (v181 == 0.0)
              {
                v116.f64[0] = 0.0;
                v115.f64[0] = 1.0;
                v181 = v171;
              }

              else
              {
                v184 = sqrt(v171 * v171 + v181 * v181);
                v185 = v181 / v184;
                v186 = fabs(v181) > fabs(v171);
                v187 = v181 / v184 < 0.0;
                v181 = -v184;
                if (v186 && v187)
                {
                  v115.f64[0] = -(v171 / v184);
                }

                else
                {
                  v181 = v184;
                  v115.f64[0] = v171 / v184;
                }

                if (v186 && v187)
                {
                  v116.f64[0] = -v185;
                }

                else
                {
                  v116.f64[0] = v185;
                }

                if ((*&v184 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  return 0xFFFFFFFFLL;
                }
              }

              v173[v170 - 1] = v181;
              v188 = v172[v170 + 1];
              v173[v170] = v116.f64[0] * v183 - v115.f64[0] * v188;
              if (v174 < v118)
              {
                v189 = v172[v170 + 2];
                v171 = v115.f64[0] * v189;
                v172[v170 + 2] = v116.f64[0] * v189;
              }

              ++v174;
              v169 = v183 * v115.f64[0] + v116.f64[0] * v188;
              a18[v170] = v110;
              v103[v170] = v109;
              v312[v170] = v116.f64[0];
              v313[v170++] = v115.f64[0];
            }

            while (v112 != v174);
          }

          v342 = v109;
          v343 = v110;
          v334 = v116;
          v335 = v115;
          v344 = v115.f64[0];
          v345 = v116.f64[0];
          *v168 = v169;
          v193 = v101;
          v346[0] = v112 - v122;
          v194 = v167;
          dlasr_("L", "F", v346, v338, a18, &v317[v153], &v324[v122], a7);
          v346[0] = v112 - v106 + 1;
          dlasr_("R", "F", a3, v346, v316, v315, &v319[v106 * v337], a17);
          v195 = v168;
          v101 = v193;
          v19.i64[0] = 1.0;
          v102 = v325;
          a7 = v326;
          v100 = v194;
          v103 = v320;
          v108.f64[0] = fabs(*v168);
          v113 = v106;
          v114 = v112;
          if (v108.f64[0] <= v30)
          {
            *v195 = 0.0;
            v113 = v106;
            v114 = v112;
          }
        }

        else
        {
          v190 = (fabs(*a10.i64) - v159) * (*vbslq_s8(v318, v19, a10).i64 + v159 / *a10.i64);
          if (v112 >= v122 + 2)
          {
            v196 = *v119;
            v197 = &v311[-v122];
            v198 = &v310[-v122];
            v199 = &v309[-v122];
            v200 = &a18[-v122 - 2];
            v201 = v102;
            v202 = v333;
            v203 = v112;
            if (*v119 != 0.0)
            {
LABEL_197:
              if (v190 == 0.0)
              {
                v110 = 0.0;
                v109 = 1.0;
                v190 = v196;
                goto LABEL_208;
              }

              v205 = sqrt(v196 * v196 + v190 * v190);
              v206 = v190 / v205;
              v207 = fabs(v190) > fabs(v196);
              v208 = v190 / v205 < 0.0;
              v190 = -v205;
              if (v207 && v208)
              {
                v109 = -(v196 / v205);
              }

              else
              {
                v190 = v205;
                v109 = v196 / v205;
              }

              if (v207 && v208)
              {
                v110 = -v206;
              }

              else
              {
                v110 = v206;
              }

              if ((*&v205 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                goto LABEL_208;
              }

              return 0xFFFFFFFFLL;
            }

            while (1)
            {
              v110 = 1.0;
              v109 = 0.0;
LABEL_208:
              if (v203 < v112)
              {
                v201[v112] = v190;
              }

              v209 = v202[v117 + 1];
              v210 = v201[v117 - 1];
              v211 = v109 * v210 + v110 * v209;
              v201[v117 - 1] = v110 * v210 - v109 * v209;
              v212 = v202[v112];
              v213 = v109 * v212;
              v214 = v110 * v212;
              v202[v112] = v214;
              if (v213 == 0.0)
              {
                v116.f64[0] = 1.0;
                v115.f64[0] = 0.0;
              }

              else if (v211 == 0.0)
              {
                v116.f64[0] = 0.0;
                v115.f64[0] = 1.0;
                v211 = v213;
              }

              else
              {
                v215 = sqrt(v213 * v213 + v211 * v211);
                v216 = v211 / v215;
                v217 = fabs(v211) > fabs(v213);
                v218 = v211 / v215 < 0.0;
                v211 = -v215;
                if (v217 && v218)
                {
                  v115.f64[0] = -(v213 / v215);
                }

                else
                {
                  v211 = v215;
                  v115.f64[0] = v213 / v215;
                }

                if (v217 && v218)
                {
                  v116.f64[0] = -v216;
                }

                else
                {
                  v116.f64[0] = v216;
                }

                if ((*&v215 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  return 0xFFFFFFFFLL;
                }
              }

              v219 = -v109;
              v202[v117 + 1] = v211;
              v220 = v201[v117 - 1];
              v190 = v214 * v115.f64[0] + v116.f64[0] * v220;
              v221 = -v115.f64[0];
              v202[v112] = v116.f64[0] * v214 - v115.f64[0] * v220;
              if (v203 <= v122 + 2)
              {
                break;
              }

              v204 = v201[v117 - 2];
              v201[v117 - 2] = v116.f64[0] * v204;
              v200[v112] = v110;
              v199[v112] = v219;
              v198[v112] = v116.f64[0];
              v197[v112] = v221;
              --v202;
              --v197;
              --v198;
              v196 = v115.f64[0] * v204;
              --v199;
              --v200;
              --v201;
              --v203;
              if (v196 != 0.0)
              {
                goto LABEL_197;
              }
            }

            v191 = a1;
            v328 = v101;
            v322 = v167;
            v192 = a18 - 1;
            v222 = &v317[v203 - v106];
            *v222 = v110;
            v222[v308] = v219;
            v222[v307] = v116.f64[0];
            v222[v306] = v221;
          }

          else
          {
            v191 = a1;
            v328 = v101;
            v322 = v100 + v112 + v152;
            v192 = a18 - 1;
          }

          v342 = v109;
          v343 = v110;
          v334 = v116;
          v335 = v115;
          v344 = v115.f64[0];
          v345 = v116.f64[0];
          v223 = v122;
          if (fabs(v190) <= v30)
          {
            v190 = 0.0;
          }

          v26[v223] = v190;
          v346[0] = v112 - v106 + 1;
          dlasr_("L", "B", v346, v338, v316, v315, &v324[v223], a7);
          v346[0] = v112 - v106 + 1;
          dlasr_("R", "B", a3, v346, a18, &v192[*v191], &v319[v106 * v337], a17);
          v102 = v325;
          a7 = v326;
          v113 = v106;
          v114 = v112;
          v103 = v320;
          v100 = v322;
          v19.i64[0] = 1.0;
          v101 = v328;
        }

        goto LABEL_68;
      }

      v125 = &v26[v122];
      v126 = v122 + 1;
      a13.i64[0] = a12.i64[0];
      while (1)
      {
        a14 = fabs(*v125);
        a15 = *a13.i64 * 9.99200722e-15;
        if (a14 <= *a13.i64 * 9.99200722e-15)
        {
          break;
        }

        v127 = v126 + 1;
        *a13.i64 = *a13.i64 / (*a13.i64 + a14) * fabs(a4[v126]);
        if (*a12.i64 >= *a13.i64)
        {
          a12.i64[0] = a13.i64[0];
        }

        ++v125;
        ++v126;
        if (v112 == v127)
        {
          v101 = 1;
          v151 = 1;
          goto LABEL_135;
        }
      }

      v101 = 1;
LABEL_109:
      v102[v126] = 0.0;
    }
  }

  *a19 = 0;
  if (*a1 < 2)
  {
    return 0;
  }

  v299 = 0;
  v300 = *a1 - 1;
  result = 0;
  do
  {
    if (*v26 != 0.0)
    {
      *a19 = ++v299;
    }

    ++v26;
    --v300;
  }

  while (v300);
  return result;
}

uint64_t dlasv2_(double *a1, double *a2, double *a3, double *a4, double *a5, double *a6, double *a7, double *a8, int8x16_t a9, int8x16_t a10, int8x16_t a11, int8x16_t a12, int8x16_t a13, double a14, double a15, int8x16_t a16, double *a17)
{
  v19 = a17;
  v20 = *a1;
  v21 = fabs(*a1);
  v22 = fabs(*a3);
  v23 = 1;
  if (v22 > v21)
  {
    v24 = v22;
  }

  else
  {
    v24 = v21;
  }

  if (v22 > v21)
  {
    v25 = v21;
  }

  else
  {
    v25 = v22;
  }

  if (v22 > v21)
  {
    a11.i64[0] = *a3;
  }

  else
  {
    a11.i64[0] = *a1;
  }

  if (v22 > v21)
  {
    v23 = 3;
  }

  else
  {
    v20 = *a3;
  }

  a13.i64[0] = *a2;
  if (*a2 == 0.0)
  {
    *a4 = v25;
    *a5 = v24;
    v26 = 0.0;
    v27 = 1.0;
    v28 = 1.0;
    v29 = 0.0;
  }

  else
  {
    v30 = fabs(*a13.i64);
    if (v30 > v24)
    {
      if (v24 / v30 < 1.11022302e-16)
      {
        *a5 = v30;
        if (v25 <= 1.0)
        {
          v31 = v25 * (v24 / v30);
        }

        else
        {
          v31 = v24 / (v30 / v25);
        }

        *a4 = v31;
        v47 = v20 / *a13.i64;
        v48 = *a11.i64 / *a13.i64;
        v49 = v22 <= v21;
        if (v22 <= v21)
        {
          v50 = v47;
        }

        else
        {
          v50 = v48;
        }

        if (v49)
        {
          v51 = v48;
        }

        else
        {
          v51 = v47;
        }

        *a17 = 1.0;
        *a8 = v50;
        *a7 = v51;
        *a6 = 1.0;
        a9.i64[0] = 1.0;
        goto LABEL_53;
      }

      v23 = 2;
    }

    *a16.i64 = v24 - v25;
    v32 = (v24 - v25) / v24;
    v17.i64[0] = 1.0;
    if (v24 - v25 == v24)
    {
      v32 = 1.0;
    }

    v33 = *a13.i64 / *a11.i64;
    v18.i64[0] = 2.0;
    v34 = 2.0 - v32;
    v35 = sqrt(v34 * v34 + v33 * v33);
    v36 = fabs(*a13.i64 / *a11.i64);
    v37 = sqrt(v33 * v33 + v32 * v32);
    if (v32 != 0.0)
    {
      v36 = v37;
    }

    v38 = (v35 + v36) * 0.5;
    *a4 = v25 / v38;
    *a5 = v24 * v38;
    v39.f64[0] = NAN;
    v39.f64[1] = NAN;
    v40 = vnegq_f64(v39);
    v41 = *a13.i64 / *vbslq_s8(v40, a16, a11).i64 + v33 / v34;
    v42 = *vbslq_s8(v40, v18, a11).i64 * *vbslq_s8(v40, v17, a13).i64;
    if (v32 != 0.0)
    {
      v42 = v41;
    }

    if (v33 * v33 != 0.0)
    {
      v42 = (v33 / (v34 + v35) + v33 / (v32 + v36)) * (v38 + 1.0);
    }

    v43 = sqrt(v42 * v42 + 4.0);
    v28 = 2.0 / v43;
    v29 = v42 / v43;
    v27 = (v28 + v29 * v33) / v38;
    v26 = v20 / *a11.i64 * v29 / v38;
  }

  v44 = v22 <= v21;
  if (v22 <= v21)
  {
    v45 = v27;
  }

  else
  {
    v45 = v29;
  }

  if (v44)
  {
    v46 = v26;
  }

  else
  {
    v46 = v28;
  }

  if (v44)
  {
    v26 = v28;
  }

  *a17 = v45;
  *a8 = v46;
  if (v44)
  {
    *a9.i64 = v29;
  }

  else
  {
    *a9.i64 = v27;
  }

  *a7 = v26;
  *a6 = *a9.i64;
  if (v23 != 2)
  {
    if (v23 == 1)
    {
      a9.i64[0] = *a7;
      a2 = a1;
    }

    else
    {
      v19 = a8;
      a2 = a3;
    }
  }

LABEL_53:
  a10.i64[0] = 1.0;
  v52.f64[0] = NAN;
  v52.f64[1] = NAN;
  v53 = vnegq_f64(v52);
  v54 = vbslq_s8(v53, a10, a9);
  a12.i64[0] = *v19;
  v55 = vbslq_s8(v53, a10, a12);
  *v54.i64 = *v54.i64 * *v55.i64;
  v55.i64[0] = *a2;
  v56 = vbslq_s8(v53, a10, v55);
  *v54.i64 = *v54.i64 * *v56.i64;
  v56.i64[0] = *a5;
  v57 = vbslq_s8(v53, v56, v54);
  *a5 = *v57.i64;
  v57.i64[0] = *a1;
  v58 = vbslq_s8(v53, a10, v57);
  *v54.i64 = *v54.i64 * *v58.i64;
  v58.i64[0] = *a3;
  v59 = vbslq_s8(v53, a10, v58);
  *v54.i64 = *v54.i64 * *v59.i64;
  v59.i64[0] = *a4;
  *a4 = vbslq_s8(v53, v59, v54).u64[0];
  return 0;
}

uint64_t dlasr_(const char *a1, const char *a2, uint64_t *a3, uint64_t *a4, double *a5, double *a6, float64x2_t *a7, uint64_t *a8)
{
  v8 = *a3;
  if (!*a3)
  {
    return 0;
  }

  v9 = *a4;
  if (!*a4)
  {
    return 0;
  }

  v10 = a5 - 1;
  v11 = a6 - 1;
  v12 = *a8;
  v13 = *a2;
  if (*a1 != 76)
  {
    v26 = v9 < 2 || v8 < 1;
    if (v13 == 70)
    {
      if (v26)
      {
        return 0;
      }

      v27 = 8 * v12;
      v29 = &a7->f64[v12] < &a7->f64[v8 + v12 * (v9 + 0x1FFFFFFFFFFFFFFELL)] && (&a7->f64[v8] + v12 * (8 * v9 - 8)) > a7;
      v30 = v8 == 1 || (v12 & 0x1000000000000000) != 0 || v29;
      v31 = &a7[-1].f64[1];
      v32 = 1;
      while (1)
      {
        v33 = *&v10[v32];
        v34 = *&v11[v32];
        if (*&v33 == 1.0 && *&v34 == 0.0)
        {
          goto LABEL_35;
        }

        v35 = -*&v34;
        if (v30)
        {
          v36 = 1;
        }

        else
        {
          v37 = vdupq_lane_s64(v33, 0);
          v38 = vdupq_lane_s64(v34, 0);
          v39 = a7;
          v40 = v8 & 0x7FFFFFFFFFFFFFFELL;
          do
          {
            v41 = *(v39 + 8 * v12);
            v42 = *v39;
            *(v39 + 8 * v12) = vmlaq_f64(vmulq_n_f64(*v39, v35), v41, v37);
            *v39++ = vmlaq_f64(vmulq_n_f64(v42, *&v33), v41, v38);
            v40 -= 2;
          }

          while (v40);
          v36 = v8 | 1;
          if (v8 == (v8 & 0x7FFFFFFFFFFFFFFELL))
          {
            goto LABEL_35;
          }
        }

        v43 = v8 + 1 - v36;
        v44 = 8 * v36;
        v45 = &v31[v36];
        v46 = v27 - 8 + v44;
        do
        {
          v47 = *(a7->f64 + v46);
          *(a7->f64 + v46) = *v45 * v35 + *&v33 * v47;
          *v45 = *&v33 * *v45 + *&v34 * v47;
          ++v45;
          v46 += 8;
          --v43;
        }

        while (v43);
LABEL_35:
        ++v32;
        a7 = (a7 + v27);
        v31 = (v31 + v27);
        if (v32 == v9)
        {
          return 0;
        }
      }
    }

    if (v26)
    {
      return 0;
    }

    v59 = (a7 + v12 * (8 * v9 - 8));
    v60 = &a7->f64[v8 + v12];
    v61 = -8 * v12;
    v62 = (a7 + v12 * (8 * v9 - 16));
    v65 = v59 < &a7->f64[v8] && v62 < v60 || v61 < 0 || v8 == 1;
    v66 = v65;
    while (1)
    {
      v67 = *&v10[v9 - 1];
      v68 = *&v11[v9 - 1];
      if (*&v67 == 1.0 && *&v68 == 0.0)
      {
        goto LABEL_69;
      }

      v69 = -*&v68;
      if (v66)
      {
        v70 = 1;
      }

      else
      {
        v71 = vdupq_lane_s64(v67, 0);
        v72 = vdupq_lane_s64(v68, 0);
        v73 = v59;
        v74 = v62;
        v75 = v8 & 0x7FFFFFFFFFFFFFFELL;
        do
        {
          v76 = *v73;
          v77 = *v74;
          *v73 = vmlaq_f64(vmulq_n_f64(*v74, v69), *v73, v71);
          ++v73;
          *v74++ = vmlaq_f64(vmulq_n_f64(v77, *&v67), v76, v72);
          v75 -= 2;
        }

        while (v75);
        v70 = v8 | 1;
        if (v8 == (v8 & 0x7FFFFFFFFFFFFFFELL))
        {
          goto LABEL_69;
        }
      }

      v78 = v70 - 1;
      do
      {
        v79 = v59->f64[v78];
        v59->f64[v78] = v62->f64[v78] * v69 + *&v67 * v79;
        v62->f64[v78] = *&v67 * v62->f64[v78] + *&v68 * v79;
        ++v78;
      }

      while (v8 != v78);
LABEL_69:
      v62 = (v62 + v61);
      v59 = (v59 + v61);
      v15 = v9-- <= 2;
      if (v15)
      {
        return 0;
      }
    }
  }

  v14 = v8 - 2;
  v15 = v8 < 2 || v9 < 1;
  v16 = v15;
  if (v13 == 70)
  {
    if ((v16 & 1) == 0)
    {
      if (v12 == 1)
      {
        v17 = 0;
        v18 = &a7->f64[1];
        do
        {
          v19 = v10[v12];
          v20 = v11[v12];
          if (v19 != 1.0 || v20 != 0.0)
          {
            v21 = a7->f64[v17];
            v22 = v9;
            v23 = v18;
            do
            {
              v24 = v21 * -v20 + v19 * *v23;
              *(v23 - 1) = v19 * v21 + v20 * *v23;
              *v23++ = v24;
              v21 = v24;
              --v22;
            }

            while (v22);
          }

          ++v12;
          ++v17;
          ++v18;
        }

        while (v12 != v8);
      }

      else
      {
        v80 = &a7->f64[1];
        v81 = 8 * v12;
        v82 = 1;
        do
        {
          v83 = v10[v82];
          v84 = v11[v82];
          if (v83 != 1.0 || v84 != 0.0)
          {
            v85 = v80;
            v86 = v9;
            do
            {
              v87 = *(v85 - 1);
              v88 = v87 * -v84 + v83 * *v85;
              *(v85 - 1) = v83 * v87 + v84 * *v85;
              *v85 = v88;
              v85 = (v85 + v81);
              --v86;
            }

            while (v86);
          }

          ++v82;
          ++v80;
        }

        while (v82 != v8);
      }
    }
  }

  else if ((v16 & 1) == 0)
  {
    v48 = v8;
    if (v12 == 1)
    {
      v49 = 0;
      v50 = v48 * 8 - 16;
      v51 = &a7[-1].f64[v8 + 1];
      do
      {
        v52 = v10[--v8];
        v53 = v11[v8];
        if (v52 != 1.0 || v53 != 0.0)
        {
          v54 = *(a7->f64 + v50 - 8 * v49);
          v55 = v9;
          v56 = v51;
          do
          {
            v57 = v54 * -v53 + v52 * *v56;
            *(v56 - 1) = v52 * v54 + v53 * *v56;
            *v56++ = v57;
            v54 = v57;
            --v55;
          }

          while (v55);
        }

        --v51;
        v65 = v49++ == v14;
      }

      while (!v65);
    }

    else
    {
      v89 = &a7->f64[v48 - 1];
      do
      {
        v90 = v10[v8 - 1];
        v91 = v11[v8 - 1];
        if (v90 != 1.0 || v91 != 0.0)
        {
          v92 = v89;
          v93 = v9;
          do
          {
            v94 = *(v92 - 1);
            v95 = v94 * -v91 + v90 * *v92;
            *(v92 - 1) = v90 * v94 + v91 * *v92;
            *v92 = v95;
            v92 += v12;
            --v93;
          }

          while (v93);
        }

        --v89;
        v15 = v8-- <= 2;
      }

      while (!v15);
    }
  }

  return 0;
}

uint64_t bidiagonalSVD(uint64_t a1, double *a2, double *a3, double *a4, double *a5, double *a6, double a7, int8x16_t a8, int8x16_t a9, int8x16_t a10, int8x16_t a11, double a12, double a13, int8x16_t a14)
{
  v16 = a1;
  v17 = 0;
  v14 = dbdsqr_(&v16, &v16, &v16, a2, a3, a5, &v16, a4, a7, a8, a9, a10, a11, a12, a13, a14, &v16, a6, &v17);
  return v14 | v17;
}

void CRandomGenerator::CRandomGenerator(CRandomGenerator *this, unsigned int a2)
{
  *this = &unk_285231298;
  v2 = 5489;
  v3 = 1;
  for (i = 3; i != 626; ++i)
  {
    v5 = 1812433253 * (v2 ^ (v2 >> 30));
    v2 = v5 + v3;
    *(this + i) = i + v5 - 2;
    ++v3;
  }

  *(this + 2) = a2;
  v6 = 1;
  for (j = 3; j != 626; ++j)
  {
    v8 = 1812433253 * (a2 ^ (a2 >> 30));
    a2 = v8 + v6;
    *(this + j) = j + v8 - 2;
    ++v6;
  }

  *(this + 313) = 0;
}

{
  *this = &unk_285231298;
  v2 = 5489;
  v3 = 1;
  for (i = 3; i != 626; ++i)
  {
    v5 = 1812433253 * (v2 ^ (v2 >> 30));
    v2 = v5 + v3;
    *(this + i) = i + v5 - 2;
    ++v3;
  }

  *(this + 2) = a2;
  v6 = 1;
  for (j = 3; j != 626; ++j)
  {
    v8 = 1812433253 * (a2 ^ (a2 >> 30));
    a2 = v8 + v6;
    *(this + j) = j + v8 - 2;
    ++v6;
  }

  *(this + 313) = 0;
}

uint64_t CRandomGenerator::Init(uint64_t this, unsigned int a2)
{
  *(this + 8) = a2;
  v2 = 1;
  for (i = 3; i != 626; ++i)
  {
    v4 = 1812433253 * (a2 ^ (a2 >> 30));
    a2 = v4 + v2;
    *(this + 4 * i) = i + v4 - 2;
    ++v2;
  }

  *(this + 2504) = 0;
  return this;
}

float CRandomGenerator::UniformRand(CRandomGenerator *this)
{
  v1 = *(this + 313);
  v2 = (v1 + 1) % 0x270uLL;
  v3 = *(this + v2 + 2);
  if (v3)
  {
    v4 = -1727483681;
  }

  else
  {
    v4 = 0;
  }

  v5 = v4 ^ *(this + (v1 + 397) % 0x270uLL + 2) ^ ((v3 & 0x7FFFFFFE | *(this + v1 + 2) & 0x80000000) >> 1);
  *(this + v1 + 2) = v5;
  *(this + 313) = v2;
  v6 = ((v5 ^ (v5 >> 11)) << 7) & 0x9D2C5680 ^ v5 ^ (v5 >> 11);
  return vcvts_n_f32_u32((v6 << 15) & 0xEFC60000 ^ v6 ^ (((v6 << 15) & 0xEFC60000 ^ v6) >> 18), 0x20uLL) + 0.0;
}

float CRandomGenerator::NormalRand(CRandomGenerator *this, float a2)
{
  v2 = this + 8;
  v3 = *(this + 313);
  v4 = *(this + v3 + 2);
  do
  {
    v5 = (v3 + 1) % 0x270;
    v6 = *&v2[4 * v5];
    v7 = v6 & 0x7FFFFFFE | v4 & 0x80000000;
    if (v6)
    {
      v8 = -1727483681;
    }

    else
    {
      v8 = 0;
    }

    v9 = v8 ^ *&v2[4 * ((v3 + 397) % 0x270)] ^ (v7 >> 1);
    *&v2[4 * v3] = v9;
    v10 = v9 ^ (v9 >> 11);
    v3 = v5 - 623;
    if (v5 < 0x26F)
    {
      v3 = v5 + 1;
    }

    v11 = (v10 << 7) & 0x9D2C5680 ^ v10;
    v4 = *&v2[4 * v3];
    if (v5 >= 0xE3)
    {
      v12 = -227;
    }

    else
    {
      v12 = 397;
    }

    v13 = *&v2[4 * v12 + 4 * v5];
    if (v4)
    {
      v14 = -1727483681;
    }

    else
    {
      v14 = 0;
    }

    v15 = v14 ^ v13 ^ ((v4 & 0x7FFFFFFE | *&v2[4 * v5] & 0x80000000) >> 1);
    v16 = ((v15 ^ (v15 >> 11)) << 7) & 0x9D2C5680 ^ v15 ^ (v15 >> 11);
    v17 = vcvts_n_f32_u32((v16 << 15) & 0xEFC60000 ^ v16 ^ (((v16 << 15) & 0xEFC60000 ^ v16) >> 18), 0x20uLL);
    v18 = (vcvts_n_f32_u32((v11 << 15) & 0xEFC60000 ^ v11 ^ (((v11 << 15) & 0xEFC60000 ^ v11) >> 18), 0x20uLL) * 2.0) + -1.0;
    v19 = ((v17 * 2.0) + -1.0) * ((v17 * 2.0) + -1.0);
    v20 = v19 + (v18 * v18);
    *&v2[4 * v5] = v15;
  }

  while (v20 > 1.0 || v20 == 0.0);
  *(this + 313) = v3;
  return ((v18 * sqrtf((logf(v19 + (v18 * v18)) * -2.0) / v20)) * a2) + 0.0;
}

void GeomUtils::DistortRadialLiteInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (*(a1 + 16) == 2)
  {
    if (*(a1 + 20))
    {
      operator new[]();
    }

    if (a6)
    {
      v6 = "xqSorted.GetNumOfPoints() > 1";
      v7 = 1381;
      v8 = "Interp1SortedWithExtrap";
    }

    else
    {
      v6 = "xq.GetNumOfPoints() > 0";
      v7 = 1285;
      v8 = "Interp1WithExtrap";
    }

    __assert_rtn(v8, "Algo.hpp", v7, v6);
  }

  __assert_rtn("DistortRadialLiteInternal", "GeomUtils.cpp", 542, "pts.Rows() == 2");
}

void sub_24030B7EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
  if (a27 && a29 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  if (a32 && a34 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  if (a37 && a39 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  *(v39 - 224) = a13;
  if (*(v39 - 216) && *(v39 - 200) == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  *(v39 - 184) = a14;
  if (*(v39 - 176))
  {
    if (*(v39 - 160) == 1)
    {
      MEMORY[0x245CBFC90]();
    }
  }

  _Unwind_Resume(exception_object);
}

double *Interp1WithExtrap<double,LinearInterpolator<double>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(a1 + 20) != *(a2 + 20))
  {
    __assert_rtn("Interp1WithExtrap", "Algo.hpp", 1196, "x.GetNumOfPoints() == v.GetNumOfPoints()");
  }

  v5 = *(a3 + 20);
  result = *(a4 + 8);
  if (*(a4 + 32) < (8 * v5))
  {
    if (result)
    {
      if (*(a4 + 24) == 1)
      {
        MEMORY[0x245CBFC90]();
      }
    }

    operator new[]();
  }

  *(a4 + 16) = 1;
  *(a4 + 20) = v5;
  if (v5 >= 1)
  {
    v7 = *(a1 + 20);
    v8 = *(a3 + 8);
    v9 = *(a2 + 8);
    v10 = *(a1 + 8);
    v11 = *(v10 + 8 * v7 - 8);
    v12 = v7 - 2;
    v13 = v7 - 1;
    if (v7 - 1 >= 100)
    {
      for (i = 0; i != v5; ++i)
      {
        v25 = v8[i];
        v24 = v12;
        if (v25 < v11)
        {
          v23 = 0;
          v26 = v13;
          while (1)
          {
            v27 = (v23 + v26) >> 1;
            v28 = *(*(a1 + 8) + 8 * v27);
            if (v28 == v25)
            {
              break;
            }

            if (v28 > v25)
            {
              v26 = v27 - 1;
            }

            else
            {
              v23 = v27 + 1;
            }

            if (v23 > v26)
            {
              goto LABEL_30;
            }
          }

          v23 = (v23 + v26) >> 1;
LABEL_30:
          if (v26 < v23)
          {
            v23 = v26;
          }

          v24 = v23 & ~(v23 >> 31);
        }

        if (v13 <= v24)
        {
          v24 = v12;
        }

        result[i] = *(v9 + 8 * v24) + (*(v9 + 8 * (v24 + 1)) - *(v9 + 8 * v24)) * ((v25 - *(v10 + 8 * v24)) / (*(v10 + 8 * (v24 + 1)) - *(v10 + 8 * v24)));
      }
    }

    else if (v7 <= 0)
    {
      do
      {
        v15 = *v8++;
        v16 = v15;
        if (v15 >= v11)
        {
          v17 = v12;
        }

        else
        {
          v17 = 0;
        }

        if (v13 <= v17)
        {
          v17 = v12;
        }

        *result++ = *(v9 + 8 * v17) + (*(v9 + 8 * (v17 + 1)) - *(v9 + 8 * v17)) * ((v16 - *(v10 + 8 * v17)) / (*(v10 + 8 * (v17 + 1)) - *(v10 + 8 * v17)));
        --v5;
      }

      while (v5);
    }

    else
    {
      for (j = 0; j != v5; ++j)
      {
        v20 = v8[j];
        v19 = v7 - 2;
        if (v20 < v11)
        {
          v21 = 0;
          while (*(*(a1 + 8) + 8 * v21) <= v20)
          {
            if (v7 == ++v21)
            {
              LODWORD(v21) = 0;
              break;
            }
          }

          v18 = v21 != 0;
          v19 = v21 - 1;
          if (!v18)
          {
            v19 = 0;
          }
        }

        if (v13 <= v19)
        {
          v19 = v7 - 2;
        }

        result[j] = *(v9 + 8 * v19) + (*(v9 + 8 * (v19 + 1)) - *(v9 + 8 * v19)) * ((v20 - *(v10 + 8 * v19)) / (*(v10 + 8 * (v19 + 1)) - *(v10 + 8 * v19)));
      }
    }
  }

  return result;
}

uint64_t GeomUtils::DistortRadialLite<double>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  GeomUtils::DistortRadialLiteInternal(a1, a2, a3, 0, a4, a5);
  return 0;
}

{
  GeomUtils::DistortRadialLiteInternal(a1, a2, a3, 1, a4, a5);
  return 0;
}

void GeomUtils::ToHomg(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *(a1 + 20);
  *a2 = off_285231258;
  if (v2)
  {
    operator new[]();
  }

  *(a2 + 16) = 3;
  *(a2 + 20) = 0;
  *(a2 + 24) = 0;
  *(a2 + 32) = 24 * v2;
  *a2 = &unk_2852312D8;
  *(a2 + 8) = 0;
}

void MatrixNxPts<3u,double>::~MatrixNxPts(uint64_t a1)
{
  *a1 = off_285231258;
  v2 = *(a1 + 8);
  if (v2 && *(a1 + 24) == 1)
  {
    v3 = a1;
    MEMORY[0x245CBFC90](v2, 0x1000C8000313F17);
    a1 = v3;
    *(v3 + 8) = 0;
    *(v3 + 32) = 0;
    *(v3 + 24) = 0;
  }

  *(a1 + 16) = 0;

  JUMPOUT(0x245CBFCB0);
}

uint64_t MatrixNxPts<3u,double>::~MatrixNxPts(uint64_t result)
{
  *result = off_285231258;
  v1 = *(result + 8);
  if (v1 && *(result + 24) == 1)
  {
    v2 = result;
    MEMORY[0x245CBFC90](v1, 0x1000C8000313F17);
    result = v2;
    *(v2 + 8) = 0;
    *(v2 + 32) = 0;
    *(v2 + 24) = 0;
  }

  *(result + 16) = 0;
  return result;
}

float64x2_t GeomUtils::ToNonHomg@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v3 = *(a1 + 20);
  *a2 = off_285231258;
  v4 = (2 * v3);
  if (v4)
  {
    operator new[]();
  }

  v5 = 0;
  *(a2 + 16) = 2;
  *(a2 + 20) = v3;
  *(a2 + 24) = 0;
  *(a2 + 32) = 16 * v3;
  *a2 = &unk_2852312F8;
  *(a2 + 8) = 0;
  if (v3)
  {
    v6 = *(a1 + 8);
    if (v3 < 0x14)
    {
      LODWORD(v7) = 0;
      goto LABEL_6;
    }

    LODWORD(v7) = 0;
    v10 = 8 * (v3 - 1) + 8;
    v11 = 8 * v3;
    v12 = v10 + 8 * v3;
    v13 = &v6->f64[v4];
    v14 = &v13[v10];
    v15 = &v6->f64[v3];
    v16 = v6 + v12;
    if ((v6 + v10))
    {
      v17 = v6 >= v10;
    }

    else
    {
      v17 = 1;
    }

    v18 = !v17;
    if (v14)
    {
      v19 = v13 >= v10;
    }

    else
    {
      v19 = 1;
    }

    v20 = !v19;
    if (v16)
    {
      v21 = v15 >= v10;
    }

    else
    {
      v21 = 1;
    }

    v22 = !v21;
    v24 = v11 < v6 + v10 && v6 < v12;
    v26 = v11 < v14 && v13 < v12;
    v28 = v11 < v16 && v15 < v12;
    v29 = v11 >= v10 || v12 == 0;
    if (!v29 || (v18 & 1) != 0 || (v20 & 1) != 0 || (v22 & 1) != 0 || v24 || v26 || v28)
    {
      goto LABEL_6;
    }

    v7 = v3 & 0xFFFFFFFE;
    v30 = (v6 + 8 * v7);
    v31 = 0;
    v32 = v7;
    do
    {
      v33 = *(v6 + 8 * v4);
      *v31 = vdivq_f64(*v6, v33);
      result = vdivq_f64(*(v6 + 8 * v3), v33);
      *(v31++ + 8 * v3) = result;
      ++v6;
      v32 -= 2;
    }

    while (v32);
    if (v7 != v3)
    {
      v5 = (8 * (v3 & 0xFFFFFFFE));
      v6 = v30;
LABEL_6:
      v8 = v3 - v7;
      do
      {
        *v5 = v6->f64[0] / v6->f64[v4];
        result.f64[0] = v6->f64[v3] / v6->f64[v4];
        v5[v3] = result.f64[0];
        ++v5;
        v6 = (v6 + 8);
        --v8;
      }

      while (v8);
    }
  }

  return result;
}

{
  v3 = *(a1 + 20);
  *a2 = off_285231258;
  v4 = (2 * v3);
  if (v4)
  {
    operator new[]();
  }

  v5 = 0;
  *(a2 + 16) = 2;
  *(a2 + 20) = v3;
  *(a2 + 24) = 0;
  *(a2 + 32) = 16 * v3;
  *a2 = &unk_2852312F8;
  *(a2 + 8) = 0;
  if (v3)
  {
    v6 = *(a1 + 8);
    if (v3 < 0x14)
    {
      LODWORD(v7) = 0;
      goto LABEL_6;
    }

    LODWORD(v7) = 0;
    v10 = 8 * (v3 - 1) + 8;
    v11 = 8 * v3;
    v12 = v10 + 8 * v3;
    v13 = &v6->f64[v4];
    v14 = &v13[v10];
    v15 = &v6->f64[v3];
    v16 = v6 + v12;
    if ((v6 + v10))
    {
      v17 = v6 >= v10;
    }

    else
    {
      v17 = 1;
    }

    v18 = !v17;
    if (v14)
    {
      v19 = v13 >= v10;
    }

    else
    {
      v19 = 1;
    }

    v20 = !v19;
    if (v16)
    {
      v21 = v15 >= v10;
    }

    else
    {
      v21 = 1;
    }

    v22 = !v21;
    v24 = v11 < v6 + v10 && v6 < v12;
    v26 = v11 < v14 && v13 < v12;
    v28 = v11 < v16 && v15 < v12;
    v29 = v11 >= v10 || v12 == 0;
    if (!v29 || (v18 & 1) != 0 || (v20 & 1) != 0 || (v22 & 1) != 0 || v24 || v26 || v28)
    {
      goto LABEL_6;
    }

    v7 = v3 & 0xFFFFFFFE;
    v30 = (v6 + 8 * v7);
    v31 = 0;
    v32 = v7;
    do
    {
      v33 = *(v6 + 8 * v4);
      *v31 = vdivq_f64(*v6, v33);
      result = vdivq_f64(*(v6 + 8 * v3), v33);
      *(v31++ + 8 * v3) = result;
      ++v6;
      v32 -= 2;
    }

    while (v32);
    if (v7 != v3)
    {
      v5 = (8 * (v3 & 0xFFFFFFFE));
      v6 = v30;
LABEL_6:
      v8 = v3 - v7;
      do
      {
        *v5 = v6->f64[0] / v6->f64[v4];
        result.f64[0] = v6->f64[v3] / v6->f64[v4];
        v5[v3] = result.f64[0];
        ++v5;
        v6 = (v6 + 8);
        --v8;
      }

      while (v8);
    }
  }

  return result;
}

void MatrixNxPts<2u,double>::~MatrixNxPts(uint64_t a1)
{
  *a1 = off_285231258;
  v2 = *(a1 + 8);
  if (v2 && *(a1 + 24) == 1)
  {
    v3 = a1;
    MEMORY[0x245CBFC90](v2, 0x1000C8000313F17);
    a1 = v3;
    *(v3 + 8) = 0;
    *(v3 + 32) = 0;
    *(v3 + 24) = 0;
  }

  *(a1 + 16) = 0;

  JUMPOUT(0x245CBFCB0);
}

uint64_t MatrixNxPts<2u,double>::~MatrixNxPts(uint64_t result)
{
  *result = off_285231258;
  v1 = *(result + 8);
  if (v1 && *(result + 24) == 1)
  {
    v2 = result;
    MEMORY[0x245CBFC90](v1, 0x1000C8000313F17);
    result = v2;
    *(v2 + 8) = 0;
    *(v2 + 32) = 0;
    *(v2 + 24) = 0;
  }

  *(result + 16) = 0;
  return result;
}

void GeomUtils::ComputeHomography(uint64_t a1, uint64_t a2)
{
  v87[9] = *MEMORY[0x277D85DE8];
  v3 = *(a1 + 20);
  v4 = *(a2 + 8);
  v5 = *(a2 + 20);
  v6 = 8 * v5;
  v74 = 1;
  v75 = v5;
  v76 = 0;
  v77 = 8 * v5;
  v72 = &unk_285231338;
  v73 = v4;
  v7 = &v4[v5];
  v68 = 1;
  v69 = v5;
  v70 = 0;
  v71 = 8 * v5;
  v66 = &unk_285231338;
  v67 = v7;
  if (v5 < 1)
  {
    v15 = v5;
    v39 = 0.0 / v5;
    v40 = v39;
    goto LABEL_24;
  }

  v8 = &v4[v5];
  v9 = v4 + 1;
  if (v8 <= (v4 + 1))
  {
    v10 = v4 + 1;
  }

  else
  {
    v10 = &v4[v5];
  }

  v11 = ~v4;
  v12 = v10 + ~v4;
  if (v12 > 7)
  {
    v16 = (v12 >> 3) + 1;
    v13 = 0.0;
    v17 = v16 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      v13 = v13 + *(v9 - 1) + *v9;
      v9 += 2;
      v17 -= 2;
    }

    while (v17);
    if (v16 == (v16 & 0x3FFFFFFFFFFFFFFELL))
    {
LABEL_13:
      v15 = v5;
      v19 = (v8 + v6);
      v20 = &v4[v6 / 8 + 1];
      if (v19 <= v20)
      {
        v19 = v20;
      }

      v21 = v19 + v11 - v6;
      if (v21 >= 8)
      {
        v24 = (v21 >> 3) + 1;
        v22 = 0.0;
        v25 = v24 & 0x3FFFFFFFFFFFFFFELL;
        do
        {
          v22 = v22 + *(v20 - 1) + *v20;
          v20 += 2;
          v25 -= 2;
        }

        while (v25);
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFELL))
        {
          goto LABEL_23;
        }

        v23 = &v7[v24 & 0x3FFFFFFFFFFFFFFELL];
      }

      else
      {
        v22 = 0.0;
        v23 = v7;
      }

      v26 = &v7[v5];
      do
      {
        v27 = *v23++;
        v22 = v22 + v27;
      }

      while (v23 < v26);
LABEL_23:
      v40 = v13 / v15;
      v39 = v22 / v15;
LABEL_24:
      *&v87[0] = off_285231258;
      if (!v5)
      {
        v64 = 0;
        v65 = 8 * v5;
        v62 = 0;
        v63 = 1;
        v79 = 0;
        LOBYTE(v81) = 0;
        *&v82 = 8 * v5;
        v78 = COERCE_DOUBLE(off_285231258);
        v80 = 0.0;
        v61 = off_285231258;
        *&v87[0] = off_285231258;
        if (!(v69 * v68))
        {
          v64 = 0;
          v65 = 8 * v68 * v69;
          v61 = &unk_285231338;
          v62 = 0;
          LODWORD(v63) = 1;
          HIDWORD(v63) = v69;
          *&v87[0] = off_285231258;
          if (!v69)
          {
            v28 = 0.0 / v15;
            v29 = 0.0 / 0;
            v87[0] = 1.0 / v28;
            v87[1] = 0.0;
            v87[2] = -v40 / v28;
            v87[3] = 0.0;
            v87[4] = 1.0 / v29;
            v87[5] = -v39 / v29;
            v87[6] = 0.0;
            v87[7] = 0.0;
            v87[8] = 1.0;
            v78 = v28;
            v79 = 0;
            v80 = v40;
            v81 = 0;
            v82 = v29;
            v83 = v39;
            v84 = 0;
            v85 = 0;
            v86 = 0x3FF0000000000000;
            v61 = off_285231258;
            v62 = v87;
            v63 = 0x300000003;
            v64 = 0;
            v65 = 72;
            v56 = off_285231258;
            v57 = &v78;
            v58 = 0x300000003;
            v59 = 0;
            v60 = 72;
            v30 = *(a2 + 20);
            v44 = off_285231258;
            if (v30)
            {
              operator new[]();
            }

            v45 = 0;
            v46 = 3;
            v47 = 0;
            v48 = 0;
            v49 = 24 * v30;
            Matrix<double>::MultAxBToC(&v61, a2, &v44);
            v52 = 3;
            v53 = v47;
            v54 = v48;
            v55 = v49;
            v50 = &unk_2852312D8;
            v51 = v45;
            v44 = off_285231258;
            if (!(18 * v3))
            {
              v31 = 0;
              v45 = 0;
              v46 = 2 * v3;
              v47 = 9;
              v48 = 0;
              v49 = 144 * v3;
              if (v3)
              {
                v32 = v51;
                v33 = *(a1 + 8);
                v34 = v3;
                do
                {
                  v35 = *v33;
                  v36 = v33[v3];
                  v37 = *v32;
                  v38 = v32[v3];
                  *v31 = *v33;
                  *(v31 + 8) = v36;
                  *(v31 + 16) = 0x3FF0000000000000;
                  *(v31 + 24) = 0;
                  *(v31 + 32) = 0;
                  *(v31 + 40) = 0;
                  *(v31 + 48) = -(v37 * v35);
                  *(v31 + 56) = -(v37 * v36);
                  *(v31 + 64) = -v37;
                  *(v31 + 80) = 0;
                  *(v31 + 88) = 0;
                  *(v31 + 72) = 0;
                  *(v31 + 96) = v35;
                  *(v31 + 104) = v36;
                  *(v31 + 112) = 0x3FF0000000000000;
                  *(v31 + 120) = -(v38 * v35);
                  *(v31 + 128) = -(v38 * v36);
                  *(v31 + 136) = -v38;
                  v31 += 144;
                  ++v33;
                  ++v32;
                  --v34;
                }

                while (v34);
                if (v3 > 4)
                {
                  Matrix<double>::Transpose(v41, &v44);
                }
              }

              v41[7] = 1;
              v42 = 0;
              v43 = 0;
              v41[5] = &unk_285231338;
              v41[6] = 0;
              __assert_rtn("Svd0LowestSingularVector", "Matrix.hpp", 2414, "false");
            }

            operator new[]();
          }

          operator new[]();
        }

        operator new[]();
      }

      operator new[]();
    }

    v14 = &v4[v16 & 0x3FFFFFFFFFFFFFFELL];
  }

  else
  {
    v13 = 0.0;
    v14 = v4;
  }

  do
  {
    v18 = *v14++;
    v13 = v13 + v18;
  }

  while (v14 < &v4[v5]);
  goto LABEL_13;
}

{
  v2 = *(a2 + 20);
  v9[0] = off_285231258;
  if (!v2)
  {
    v10 = 3;
    v11 = 0;
    v12 = 0;
    v13 = 24 * v2;
    v9[0] = &unk_2852312D8;
    v9[1] = 0;
    v3 = *(a1 + 20);
    v4[0] = off_285231258;
    if (!v3)
    {
      v5 = 3;
      v6 = 0;
      v7 = 0;
      v8 = 24 * v3;
      v4[0] = &unk_2852312D8;
      v4[1] = 0;
      GeomUtils::ComputeHomography(v4, v9);
    }

    operator new[]();
  }

  operator new[]();
}

void sub_24030D088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t (**a28)(), uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41, uint64_t a42, uint64_t (**a43)(), uint64_t a44, uint64_t a45, char a46, uint64_t a47, uint64_t (**a48)(), uint64_t a49, uint64_t a50, char a51)
{
  Matrix<double>::~Matrix(&a18);
  Matrix<double>::~Matrix(&a13);
  if (a24 && a26 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  a28 = off_285231258;
  if (a29 && a31 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  if (a34 && a36 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  if (a39 && a41 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  a43 = off_285231258;
  if (a44 && a46 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  a48 = off_285231258;
  if (a49)
  {
    if (a51 == 1)
    {
      MEMORY[0x245CBFC90]();
    }
  }

  _Unwind_Resume(a1);
}

void Matrix<double>::MultAxBToC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a1 + 16);
  v7 = *(a1 + 20);
  if (v6 == 1 && v7 == 1)
  {
    v6 = *(a2 + 16);
    v7 = *(a2 + 20);
    if (v7 * v6)
    {
      operator new[]();
    }

    v12 = 8 * v6 * v7;
    v13 = *(a3 + 8);
    if (*(a3 + 32) < v12)
    {
      if (v13 && *(a3 + 24) == 1)
      {
        MEMORY[0x245CBFC90]();
      }

      operator new[]();
    }

    goto LABEL_29;
  }

  v10 = *(a2 + 16);
  v9 = *(a2 + 20);
  if (v9 == 1 && v10 == 1)
  {
    if (v7 * v6)
    {
      operator new[]();
    }

    v12 = 8 * v6 * v7;
    v13 = *(a3 + 8);
    if (*(a3 + 32) < v12)
    {
      if (v13 && *(a3 + 24) == 1)
      {
        MEMORY[0x245CBFC90]();
      }

      operator new[]();
    }

LABEL_29:
    *(a3 + 16) = v6;
    *(a3 + 20) = v7;
    memcpy(v13, 0, v12);
    goto LABEL_30;
  }

  if (v7 != v10)
  {
    __assert_rtn("MultAxBToC", "Matrix.hpp", 1596, "m_cols == B.Rows() && Input dimensions not legal");
  }

  if (v6 != *(a3 + 16) || v9 != *(a3 + 20))
  {
    __assert_rtn("MultAxBToC", "Matrix.hpp", 1597, "m_rows == C->Rows() && B.Cols() == C->Cols() && Output dimensions not legal");
  }

LABEL_30:
  v14 = *(a1 + 16);
  if (v14 >= 1)
  {
    v15 = *(a3 + 20);
    if (v15 >= 1)
    {
      v16 = *(a3 + 8);
      v17 = *(a1 + 20);
      if (v17 <= 0)
      {
        bzero(v16, 8 * v14 * v15);
      }

      else
      {
        v18 = *(a1 + 8);
        v19 = *(a2 + 8);
        if (v17 > 3)
        {
          if (v15 == 1)
          {
            if (v17 == (v17 & 0x7FFFFFFC))
            {
              v26 = 0;
              v27 = v19 + 1;
              v28 = (v18 + 2);
              do
              {
                v29 = 0.0;
                v30 = v28;
                v31 = v27;
                v32 = v17;
                do
                {
                  v33 = vmulq_f64(v30[-1], v31[-1]);
                  v34 = vmulq_f64(*v30, *v31);
                  v29 = v29 + v33.f64[0] + v33.f64[1] + v34.f64[0] + v34.f64[1];
                  v31 += 2;
                  v30 += 2;
                  v32 -= 4;
                }

                while (v32);
                *&v16[8 * v26 * v15] = v29;
                ++v26;
                v28 = (v28 + 8 * v17);
              }

              while (v26 != v14);
            }

            else
            {
              v43 = 0;
              v44 = (v18 + 2);
              v45 = 8 * v17;
              v46 = (v17 >> 2) & 0x1FFFFFFF;
              v47 = &v18[4 * v46];
              do
              {
                v48 = 0.0;
                v49 = v44;
                v50 = v19 + 1;
                v51 = v17 & 0x7FFFFFFC;
                do
                {
                  v52 = vmulq_f64(v49[-1], v50[-1]);
                  v53 = vmulq_f64(*v49, *v50);
                  v48 = v48 + v52.f64[0] + v52.f64[1] + v53.f64[0] + v53.f64[1];
                  v50 += 2;
                  v49 += 2;
                  v51 -= 4;
                }

                while (v51);
                v54 = v47;
                f64 = v19[2 * v46].f64;
                v56 = v17 - (v17 & 0x7FFFFFFC);
                do
                {
                  v57 = *v54++;
                  v48 = v48 + v57 * *f64;
                  f64 += v15;
                  --v56;
                }

                while (v56);
                *&v16[8 * v43 * v15] = v48;
                ++v43;
                v44 = (v44 + v45);
                v47 = (v47 + v45);
              }

              while (v43 != v14);
            }
          }

          else
          {
            for (i = 0; i != v14; ++i)
            {
              v36 = 0;
              v37 = v19;
              do
              {
                v38 = 0.0;
                v39 = v18;
                v40 = v37;
                v41 = v17;
                do
                {
                  v42 = *v39++;
                  v38 = v38 + v42 * *v40;
                  v40 += v15;
                  --v41;
                }

                while (v41);
                *&v16[8 * i * v15 + 8 * v36++] = v38;
                ++v37;
              }

              while (v36 != v15);
              v18 += v17;
            }
          }
        }

        else
        {
          for (j = 0; j != v14; ++j)
          {
            v21 = &v18[j * v17];
            v22 = v19;
            v23 = v16;
            v24 = v15;
            do
            {
              v25 = *v21 * *v22 + 0.0;
              if (v17 != 1)
              {
                v25 = v25 + v21[1] * v22[v15];
                if (v17 != 2)
                {
                  v25 = v25 + v21[2] * v22[2 * v15];
                }
              }

              *v23++ = v25;
              ++v22;
              --v24;
            }

            while (v24);
            v16 += 8 * v15;
          }
        }
      }
    }
  }
}

void sub_24030D8F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Matrix<double>::~Matrix(va);
  _Unwind_Resume(a1);
}

void sub_24030DB7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Matrix<double>::~Matrix(va);
  _Unwind_Resume(a1);
}

void Matrix<double>::Matrix(uint64_t a1, uint64_t a2)
{
  *a1 = off_285231258;
  v2 = *(a2 + 20);
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 20) = v2;
  operator new[]();
}

void sub_24030DC9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Matrix<double>::~Matrix(va);
  _Unwind_Resume(a1);
}

void sub_24030DEBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a15)
  {
    if (a17 == 1)
    {
      v18 = a1;
      MEMORY[0x245CBFC90](a15, v17);
      a1 = v18;
    }
  }

  _Unwind_Resume(a1);
}

void GeomUtils::homography2d(void *a1@<X8>)
{
  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  v5 = 0;
  v3 = 0u;
  v4 = 0u;
  v1 = 0u;
  v2 = 0u;
  *a1 = off_285231258;
  operator new[]();
}

void sub_24030E1B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
  if (a17 && a19 == 1)
  {
    v32 = a1;
    MEMORY[0x245CBFC90](a17, v30);
    a1 = v32;
  }

  if (a22 && a24 == 1)
  {
    v33 = a1;
    MEMORY[0x245CBFC90](a22, v30);
    a1 = v33;
  }

  if (a27 && a29 == 1)
  {
    v34 = a1;
    MEMORY[0x245CBFC90](a27, v30);
    a1 = v34;
  }

  *v29 = v31;
  if (*(v29 + 8))
  {
    if (*(v29 + 24) == 1)
    {
      v35 = a1;
      MEMORY[0x245CBFC90](*(v29 + 8), v30);
      a1 = v35;
      *(v29 + 8) = 0;
      *(v29 + 32) = 0;
      *(v29 + 24) = 0;
    }
  }

  *(v29 + 16) = 0;
  _Unwind_Resume(a1);
}

void GeomUtils::ransacComputeHomography(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 20))
  {
    operator new[]();
  }

  if (*(a2 + 20))
  {
    operator new[]();
  }

  Algo::Normalize2DPts();
}

void sub_24030F69C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, char a38)
{
  MatrixNxPts<3u,double>::~MatrixNxPts(&a17);
  MatrixNxPts<2u,double>::~MatrixNxPts(&a12);
  MatrixNxPts<3u,double>::~MatrixNxPts(&a23);
  MatrixNxPts<3u,double>::~MatrixNxPts(&a28);
  MatrixNxPts<3u,double>::~MatrixNxPts(&a33);
  MatrixNxPts<3u,double>::~MatrixNxPts(&a38);
  _Unwind_Resume(a1);
}

uint64_t GeomUtils::ransacFitPlane(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, unsigned int *a5, _DWORD *a6)
{
  result = Algo::RansacPlane(a1, 3, 10, 50, 1u, a4, a5, a6);
  v11 = *a5;
  if (*a5 > 2)
  {
    if (v11 == 3)
    {
      v12 = 4;
    }

    else
    {
      v12 = v11;
    }

    if (4 * v12)
    {
      operator new[]();
    }

    if (!v11)
    {
      goto LABEL_9;
    }

    v14 = *(a1 + 16);
    v13 = *(a1 + 20);
    if (v14)
    {
      if (v14 == 1)
      {
        v20 = **(a4 + 8);
        if (v13 > v20)
        {
          MEMORY[0] = *(*(a1 + 8) + 8 * v20);
        }
      }

      else
      {
        if (v14 >= 3)
        {
          v15 = 0;
          do
          {
            v16 = *(*(a4 + 8) + v15);
            if (v13 <= v16 || 4 * v12 == v15)
            {
              goto LABEL_26;
            }

            v18 = 8 * v16;
            v19 = ((8 * v15) & 0x7FFFFFFE0);
            *v19 = *(*(a1 + 8) + v18);
            v19[1] = *(*(a1 + 8) + v18 + 8 * v13);
            v19[2] = *(*(a1 + 8) + v18 + 8 * (2 * v13));
            v19[3] = 0x3FF0000000000000;
            v15 += 4;
          }

          while (4 * v11 != v15);
          if (v11 == 3)
          {
            if (v12 <= 3)
            {
              __assert_rtn("operator()", "Matrix.hpp", 120, "row < m_rows && col < m_cols");
            }

            MEMORY[0x60] = 0u;
            MEMORY[0x70] = 0u;
          }

LABEL_9:
          __assert_rtn("Svd0LowestSingularVector", "Matrix.hpp", 2414, "false");
        }

        v21 = **(a4 + 8);
        if (v13 > v21)
        {
          v22 = (*(a1 + 8) + 8 * v21);
          MEMORY[0] = *v22;
          MEMORY[8] = v22[v13];
        }
      }
    }

LABEL_26:
    __assert_rtn("operator()", "Matrix.hpp", 120, "row < m_rows && col < m_cols");
  }

  *a5 = 0;
  *a3 = 0x4197D78400000000;
  return result;
}

void sub_24030F9C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  Matrix<double>::~Matrix(va);
  _Unwind_Resume(a1);
}

void sub_24030FAB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a11 && a13 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  if (a16 && a18 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  *(v19 - 72) = v18;
  if (*(v19 - 64))
  {
    if (*(v19 - 48) == 1)
    {
      MEMORY[0x245CBFC90]();
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_240310104(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
  if (a25 && a27 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  if (a30 && a32 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  if (a35 && a37 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  *(v37 - 224) = off_285231258;
  if (*(v37 - 216))
  {
    if (*(v37 - 200) == 1)
    {
      MEMORY[0x245CBFC90]();
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t GeomUtils::CalcRotTrans(__int128 *a1, double *a2, double *a3, double a4, double a5, float64x2_t a6, __n128 a7, float64x2_t a8, float64x2_t a9, float64x2_t a10, int8x16_t a11, uint64_t a12, float64x2_t *a13, float64x2_t *a14)
{
  v18 = a1[1];
  v80 = *a1;
  v81 = v18;
  v19 = a1[3];
  v82 = a1[2];
  v83 = v19;
  v19.i64[0] = *(&v80 + 1);
  v20 = v81;
  a7.n128_u64[0] = v83.u64[1];
  *&a6.f64[0] = v83.i64[0];
  a8.f64[0] = *(&v81 + 1);
  a9.f64[0] = *(&v82 + 1);
  *(&v80 + 1) = *(&v81 + 1);
  *&v81 = v83.i64[0];
  v79 = 0.0;
  v83.i64[0] = v20;
  v83.i64[1] = *(&v82 + 1);
  v78 = 0u;
  memset(v77, 0, sizeof(v77));
  v76 = 0.0;
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  memset(v71, 0, sizeof(v71));
  v84 = *(a1 + 8);
  *(&v81 + 1) = v19.i64[0];
  *(&v82 + 1) = a7.n128_u64[0];
  svd_os(3, &v80, v77[0].f64, v71, &v72, v19, 0, a6, a7, a8, a9, a10, a11);
  _Q0 = v78;
  v23 = v77[1].f64[0] * 0.0 + 0.0;
  v24 = v79;
  v25 = v23 + v77[2].f64[1] * 0.0 + v79;
  _D5 = *(&v73 + 1);
  _KR10_16 = v74;
  _KR20_16 = v75;
  _D16 = v76;
  v30 = vmlaq_f64(0, 0, v77[0]);
  _Q27 = vmlaq_f64(vaddq_f64(*(&v77[1] + 8), v30), 0, v78);
  __asm { FMOV            V12.2D, #-1.0 }

  _Q28 = vmlaq_f64(vmlaq_f64(vmlaq_f64(0, _Q12, v77[0]), 0, *(&v77[1] + 8)), 0, v78);
  v38 = vmlaq_f64(v30, 0, *(&v77[1] + 8));
  _Q23 = vaddq_f64(v78, v38);
  v38.f64[0] = _Q27.f64[0] * *&v72 + 0.0 + _Q28.f64[0] * *(&v72 + 1) + _Q23.f64[0] * *&v73;
  __asm
  {
    FMLA            D22, D5, V27.D[1]
    FMLA            D22, D4, V28.D[1]
    FMLA            D22, D3, V23.D[1]
  }

  *&v42.f64[0] = v75;
  *&v42.f64[1] = v72;
  v43.f64[0] = *(&v75 + 1);
  v43.f64[1] = *(&v72 + 1);
  v44.f64[0] = v76;
  *&v44.f64[1] = v73;
  if (((*&_D22 ^ *&v38.f64[0]) & 0x8000000000000000) != 0 || (v45 = 0.0 - v77[1].f64[0] + v77[2].f64[1] * 0.0 + v79 * 0.0, v46 = v23 + v77[2].f64[1] + v79 * 0.0, v47 = v46 * *&v75 + 0.0 + v45 * *(&v75 + 1) + v25 * v76, ((*&v47 ^ *&v38.f64[0]) & 0x8000000000000000) != 0))
  {
    v53 = v23 - v77[2].f64[1] + v79 * 0.0;
    v54 = v77[1].f64[0] + 0.0 + v77[2].f64[1] * 0.0 + v79 * 0.0;
    _Q24 = vmlaq_f64(vmlaq_f64(v30, _Q12, *(&v77[1] + 8)), 0, v78);
    _Q8 = vmlaq_f64(vmlaq_f64(vaddq_f64(v77[0], 0), 0, *(&v77[1] + 8)), 0, v78);
    v38.f64[0] = _Q24.f64[0] * *&v72 + 0.0 + _Q8.f64[0] * *(&v72 + 1) + _Q23.f64[0] * *&v73;
    v52 = _Q24.f64[0] * *(&v73 + 1) + 0.0 + _Q8.f64[0] * *&v74 + _Q23.f64[0] * *(&v74 + 1);
    v51 = vmlaq_f64(vmlaq_f64(vmlaq_f64(0, v42, _Q24), v43, _Q8), v44, _Q23);
    __asm
    {
      FMLA            D22, D5, V24.D[1]
      FMLA            D22, D4, V8.D[1]
      FMLA            D22, D3, V23.D[1]
      FMLA            D26, D18, V24.D[1]
      FMLA            D26, D17, V8.D[1]
      FMLA            D26, D16, V23.D[1]
    }

    v49 = v53 * *&v72 + 0.0 + v54 * *(&v72 + 1) + v25 * *&v73;
    v48 = v53 * *(&v73 + 1) + 0.0 + v54 * *&v74 + v25 * *(&v74 + 1);
    v47 = v53 * *&v75 + 0.0 + v54 * *(&v75 + 1) + v25 * v76;
  }

  else
  {
    v48 = v46 * *(&v73 + 1) + 0.0 + v45 * *&v74 + v25 * *(&v74 + 1);
    v49 = v46 * *&v72 + 0.0 + v45 * *(&v72 + 1) + v25 * *&v73;
    _D26 = _Q27.f64[1] * *&v75 + 0.0 + _Q28.f64[1] * *(&v75 + 1) + _Q23.f64[1] * v76;
    v51 = vmlaq_f64(vmlaq_f64(vmlaq_f64(0, v42, _Q27), v43, _Q28), v44, _Q23);
    v52 = _Q27.f64[0] * *(&v73 + 1) + 0.0 + _Q28.f64[0] * *&v74 + _Q23.f64[0] * *(&v74 + 1);
  }

  v21.i64[0] = 1.0;
  _Q3.f64[0] = NAN;
  _Q3.f64[1] = NAN;
  v62 = *vbslq_s8(vnegq_f64(_Q3), v21, v38).i64;
  a13->f64[0] = v38.f64[0] * v62;
  a13->f64[1] = v62 * v52;
  a13[1] = vmulq_n_f64(v51, v62);
  a13[2].f64[0] = v62 * _D22;
  a13[2].f64[1] = v62 * _D26;
  a13[3].f64[0] = v49 * v62;
  a13[3].f64[1] = v62 * v48;
  a13[4].f64[0] = v62 * v47;
  _Q3.f64[0] = a3[1] - a2[1];
  v63 = a3[2] - a2[2];
  v64 = sqrt((*a3 - *a2) * (*a3 - *a2) + 0.0 + _Q3.f64[0] * _Q3.f64[0] + v63 * v63);
  _Q3.f64[0] = _Q3.f64[0] / v64;
  __asm { FMLA            D2, D3, V0.D[1] }

  _NF = _D2 + v63 / v64 * v24 < 0.0;
  v67 = vnegq_f64(_Q0);
  if (_NF)
  {
    v24 = -v24;
  }

  v68 = vdup_n_s32(_NF);
  v69.i64[0] = v68.u32[0];
  v69.i64[1] = v68.u32[1];
  *a14 = vmulq_n_f64(vbslq_s8(vcltzq_s64(vshlq_n_s64(v69, 0x3FuLL)), v67, _Q0), v64);
  a14[1].f64[0] = v64 * v24;
  return 0;
}

char *GeomUtils::homogDist2d(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5, double a6)
{
  v96 = 3;
  v97 = 0;
  v98 = 0;
  v94 = &unk_2852312D8;
  v95 = 0;
  v93 = 0;
  v90 = 0;
  v91 = 0;
  v89 = off_285231258;
  v92 = 0;
  v9 = *(a1 + 16);
  v10 = *(a2 + 20);
  v84 = off_285231258;
  if (v10 * v9)
  {
    operator new[]();
  }

  __src = 0;
  v86 = __PAIR64__(v10, v9);
  v87 = 0;
  v88 = 8 * v9 * v10;
  Matrix<double>::MultAxBToC(a1, a2, &v84);
  v11 = 8 * v86 * HIDWORD(v86);
  if (v93 < v11)
  {
    if (v90)
    {
      if (v92 == 1)
      {
        MEMORY[0x245CBFC90](v90, 0x1000C8000313F17);
      }
    }

    operator new[]();
  }

  v91 = v86;
  memcpy(v90, __src, v11);
  v84 = off_285231258;
  if (__src && v87 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  v84 = off_285231258;
  if (HIDWORD(v91))
  {
    operator new[]();
  }

  v86 = 1;
  v87 = 0;
  v88 = 0;
  v84 = &unk_285231338;
  __src = 0;
  v12 = *(a3 + 20);
  v13 = (2 * v12);
  if (v13)
  {
    operator new[]();
  }

  v14 = 0;
  if (v12)
  {
    v15 = *(a3 + 8);
    if (v12 >= 0x14)
    {
      LODWORD(v16) = 0;
      v35 = 8 * (v12 - 1) + 8;
      v36 = 8 * v12;
      v37 = v35 + 8 * v12;
      v38 = &v15->f64[v13];
      v39 = &v38[v35];
      v40 = &v15->f64[v12];
      v41 = v15 + v37;
      if ((v15 + v35))
      {
        v42 = v15 >= v35;
      }

      else
      {
        v42 = 1;
      }

      v43 = !v42;
      if (v39)
      {
        v44 = v38 >= v35;
      }

      else
      {
        v44 = 1;
      }

      v45 = !v44;
      if (v41)
      {
        v46 = v40 >= v35;
      }

      else
      {
        v46 = 1;
      }

      v47 = !v46;
      v49 = v36 < v15 + v35 && v15 < v37;
      v51 = v36 < v39 && v38 < v37;
      v53 = v36 < v41 && v40 < v37;
      v54 = v36 >= v35 || v37 == 0;
      if (v54 && (v43 & 1) == 0 && (v45 & 1) == 0 && (v47 & 1) == 0 && !v49 && !v51 && !v53)
      {
        v16 = v12 & 0xFFFFFFFE;
        v55 = (v15 + 8 * v16);
        v56 = 0;
        v57 = v16;
        do
        {
          v58 = *(v15 + 8 * v13);
          *v56 = vdivq_f64(*v15, v58);
          *(v56++ + 8 * v12) = vdivq_f64(*(v15++ + 8 * v12), v58);
          v57 -= 2;
        }

        while (v57);
        if (v16 == v12)
        {
LABEL_20:
          operator new[]();
        }

        v14 = (8 * (v12 & 0xFFFFFFFE));
        v15 = v55;
      }
    }

    else
    {
      LODWORD(v16) = 0;
    }

    v17 = v12 - v16;
    do
    {
      *v14 = v15->f64[0] / v15->f64[v13];
      v14[v12] = v15->f64[v12] / v15->f64[v13];
      ++v14;
      v15 = (v15 + 8);
      --v17;
    }

    while (v17);
    goto LABEL_20;
  }

  if (v98 < 24 * v12)
  {
    if (v95 && v97 == 1)
    {
      MEMORY[0x245CBFC90](v95, 0x1000C8000313F17);
    }

    operator new[]();
  }

  v96 = 3;
  memcpy(v95, 0, 24 * v12);
  v18 = HIDWORD(v91);
  v19 = (2 * HIDWORD(v91));
  if (v19)
  {
    operator new[]();
  }

  v20 = 0;
  if (HIDWORD(v91))
  {
    v21 = v90;
    if (HIDWORD(v91) >= 0x14)
    {
      LODWORD(v22) = 0;
      v59 = 8 * (HIDWORD(v91) - 1) + 8;
      v60 = 8 * HIDWORD(v91);
      v61 = v59 + v60;
      v62 = &v90->f64[v19];
      v63 = &v62[v59];
      v64 = v90 + v60;
      v65 = v90 + v59 + v60;
      if ((v90 + v59))
      {
        v66 = v90 >= v59;
      }

      else
      {
        v66 = 1;
      }

      v67 = !v66;
      if (v63)
      {
        v68 = v62 >= v59;
      }

      else
      {
        v68 = 1;
      }

      v69 = !v68;
      if (v65)
      {
        v70 = v64 >= v59;
      }

      else
      {
        v70 = 1;
      }

      v71 = !v70;
      v73 = v60 < v90 + v59 && v90 < v61;
      v75 = v60 < v63 && v62 < v61;
      v77 = v60 < v65 && v64 < v61;
      v78 = v60 >= v59 || v61 == 0;
      if (v78 && (v67 & 1) == 0 && (v69 & 1) == 0 && (v71 & 1) == 0 && !v73 && !v75 && !v77)
      {
        v22 = HIDWORD(v91) & 0xFFFFFFFE;
        v79 = (v90 + 8 * v22);
        v80 = 0;
        v81 = v22;
        do
        {
          v82 = *(v21 + 8 * v19);
          *v80 = vdivq_f64(*v21, v82);
          *(v80++ + 8 * v18) = vdivq_f64(*(v21++ + 8 * v18), v82);
          v81 -= 2;
        }

        while (v81);
        if (v22 == v18)
        {
LABEL_33:
          operator new[]();
        }

        v20 = (8 * (v18 & 0xFFFFFFFE));
        v21 = v79;
      }
    }

    else
    {
      LODWORD(v22) = 0;
    }

    v23 = v18 - v22;
    do
    {
      *v20 = v21->f64[0] / v21->f64[v19];
      v20[v18] = v21->f64[v18] / v21->f64[v19];
      ++v20;
      v21 = (v21 + 8);
      --v23;
    }

    while (v23);
    goto LABEL_33;
  }

  v91 = 3;
  memcpy(v90, 0, 24 * v18);
  v24 = HIDWORD(v91);
  if (HIDWORD(v91))
  {
    v25 = 0;
    v26 = 0;
    v27 = "row < m_rows && col < m_cols";
    while (v96 && v25 < HIDWORD(v96) && v91)
    {
      v28 = 120;
      if (v96 == 1 || v91 == 1 || v96 < 3 || v91 < 3)
      {
        goto LABEL_163;
      }

      if (v25 >= (HIDWORD(v86) * v86))
      {
        goto LABEL_162;
      }

      v29 = &v95[8 * v25];
      v30 = &v90->f64[v25];
      v31 = v29[HIDWORD(v96)] - v30[v24];
      v32 = v31 * v31 + (*v29 - *v30) * (*v29 - *v30);
      v33 = *&v95[8 * (2 * HIDWORD(v96)) + 8 * v25] - v90->f64[(2 * v24) + v25];
      *(__src + v25) = v32 + v33 * v33;
      if (*(__src + v25) < a6)
      {
        if (*(a4 + 20) * *(a4 + 16) <= v26)
        {
LABEL_162:
          v28 = 132;
          v27 = "index < m_rows * m_cols";
LABEL_163:
          __assert_rtn("operator()", "Matrix.hpp", v28, v27);
        }

        *(*(a4 + 8) + 4 * v26++) = v25;
      }

      ++v25;
      v24 = HIDWORD(v91);
      if (v25 >= HIDWORD(v91))
      {
        goto LABEL_49;
      }
    }

    v28 = 120;
    goto LABEL_163;
  }

  v26 = 0;
LABEL_49:
  *a5 = v26;
  v84 = off_285231258;
  if (__src && v87 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  v89 = off_285231258;
  if (v90 && v92 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  v94 = off_285231258;
  result = v95;
  if (v95 && v97 == 1)
  {
    return MEMORY[0x245CBFC90]();
  }

  return result;
}

void sub_240311208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
  MatrixNxPts<3u,double>::~MatrixNxPts(&a18);
  MatrixNxPts<2u,double>::~MatrixNxPts(&a13);
  a23 = a12;
  if (a24 && a26 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  if (a29 && a31 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  *(v31 - 144) = a11;
  if (*(v31 - 136))
  {
    if (*(v31 - 120) == 1)
    {
      MEMORY[0x245CBFC90]();
    }
  }

  _Unwind_Resume(a1);
}

BOOL GeomUtils::check3of4SpotsOnSameLine(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 20) != 4 || *(a1 + 16) != 3)
  {
    __assert_rtn("check3of4SpotsOnSameLine", "GeomUtils.cpp", 1203, "x1.Cols()==4 && x1.Rows()==3");
  }

  if (*(a2 + 20) != 4 || *(a2 + 16) != 3)
  {
    __assert_rtn("check3of4SpotsOnSameLine", "GeomUtils.cpp", 1204, "x2.Cols()==4 && x2.Rows()==3");
  }

  v2 = *(a1 + 8);
  v4 = *v2;
  v3 = v2[1];
  v5 = v2[4];
  v6 = v2[5];
  v8 = v2[8];
  v7 = v2[9];
  v9 = v2[2];
  v10 = v2[6];
  v11 = v2[10];
  v12 = v6 * v11 - v10 * v7;
  v13 = -(v10 * v8);
  v14 = v5 * v7 - v6 * v8;
  if (fabs(*v2 * v12 - v3 * (v8 * v11 - v10 * v8) + v9 * v14) < 0.00000011920929)
  {
    return 1;
  }

  v15 = v2[3];
  v16 = v2[7];
  v17 = v2[11];
  v18 = v8 * v17 - v16 * v8;
  if (fabs(v18 * -v3 + v4 * (v6 * v17 - v16 * v7) + v15 * v14) < 0.00000011920929)
  {
    return 1;
  }

  v19 = v11 * -v16 + v10 * v17;
  if (fabs(v4 * v19 - v9 * v18 + v15 * (v13 + v5 * v11)) < 0.00000011920929)
  {
    return 1;
  }

  if (fabs((v7 * v17 - v16 * v7) * -v9 + v3 * v19 + v15 * v12) < 0.00000011920929)
  {
    return 1;
  }

  v20 = *(a2 + 8);
  v21 = v20[1];
  v22 = v20[5];
  v23 = v20[8];
  v24 = v20[9];
  v25 = v20[4] * v24 - v22 * v23;
  if (fabs(*v20 * (v22 * v20[10] - v20[6] * v24) - v21 * (v23 * v20[10] - v20[6] * v23) + v20[2] * v25) < 0.00000011920929 || fabs((v23 * v20[11] - v20[7] * v23) * -v21 + *v20 * (v22 * v20[11] - v20[7] * v24) + v20[3] * v25) < 0.00000011920929)
  {
    return 1;
  }

  v28 = *Matrix<double>::operator()(a2, 0, 0);
  v29 = *Matrix<double>::operator()(a2, 1u, 0);
  v30 = *Matrix<double>::operator()(a2, 2u, 0);
  v31 = *Matrix<double>::operator()(a2, 0, 2u);
  v32 = *Matrix<double>::operator()(a2, 1u, 2u);
  v33 = *Matrix<double>::operator()(a2, 2u, 2u);
  v34 = *Matrix<double>::operator()(a2, 0, 3u);
  v35 = *Matrix<double>::operator()(a2, 1u, 3u);
  v36 = Matrix<double>::operator()(a2, 2u, 3u);
  result = 1;
  if (fabs(v28 * (v32 * *v36 - v35 * v33) - v31 * (v30 * *v36 - v35 * v30) + v34 * (v29 * v33 - v32 * v30)) >= 0.00000011920929)
  {
    v37 = *Matrix<double>::operator()(a2, 0, 1u);
    v38 = *Matrix<double>::operator()(a2, 1u, 1u);
    v39 = *Matrix<double>::operator()(a2, 2u, 1u);
    v40 = *Matrix<double>::operator()(a2, 0, 2u);
    v41 = *Matrix<double>::operator()(a2, 1u, 2u);
    v42 = *Matrix<double>::operator()(a2, 2u, 2u);
    v43 = *Matrix<double>::operator()(a2, 0, 3u);
    v44 = *Matrix<double>::operator()(a2, 1u, 3u);
    v45 = Matrix<double>::operator()(a2, 2u, 3u);
    return fabs(v37 * (v41 * *v45 - v44 * v42) - v40 * (v39 * *v45 - v44 * v39) + v43 * (v38 * v42 - v41 * v39)) < 0.00000011920929;
  }

  return result;
}

uint64_t Matrix<double>::operator()(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (*(a1 + 16) <= a2 || (v3 = *(a1 + 20), v3 <= a3))
  {
    __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
  }

  return *(a1 + 8) + 8 * a3 + 8 * v3 * a2;
}

float32x2_t GeomUtils::ExtrinsicsToSimd4x3(float64x2_t *a1)
{
  v1 = *a1;
  v1.f64[1] = a1[1].f64[1];
  return vcvt_f32_f64(v1);
}

double GeomUtils::ExtrinsicsFromSimd4x3(float64x2_t *a1, float64x2_t *a2, int8x16_t a3, int8x16_t a4, __n128 a5, __n128 a6)
{
  v6 = vzip1_s32(*a3.i8, *a4.i8);
  v7 = vzip1_s32(*&vextq_s8(a3, a3, 8uLL), *&vextq_s8(a4, a4, 8uLL));
  v8 = vzip2_s32(*a4.i8, a5.n128_u64[0]);
  a5.n128_u32[1] = a3.u32[1];
  *a1 = vcvtq_f64_f32(v6);
  a1[1] = vcvtq_f64_f32(a5.n128_u64[0]);
  a1[2] = vcvtq_f64_f32(v8);
  a1[3] = vcvtq_f64_f32(v7);
  a1[4].f64[0] = a5.n128_f32[2];
  *a2 = vcvtq_f64_f32(a6.n128_u64[0]);
  result = a6.n128_f32[2];
  a2[1].f64[0] = a6.n128_f32[2];
  return result;
}

void SparseMatrix::SparseMatrix(SparseMatrix *this, int a2, int a3, const int *a4, int a5, int a6)
{
  *(this + 10) = a2;
  *(this + 11) = a6;
  *(this + 8) = a5 + a3 * a6;
  *(this + 9) = a3;
  operator new[]();
}

void SparseMatrix::SparseMatrix(SparseMatrix *a1, int a2, int a3, const int **a4, int a5)
{
  v7 = *a4;
  v8 = a4[1];
  if (v7 == v8)
  {
    v10 = 0;
    goto LABEL_5;
  }

  v9 = v8 - v7 - 4;
  if (v9 >= 0x1C)
  {
    v12 = (v9 >> 2) + 1;
    v13 = (v7 + 4);
    v14 = 0uLL;
    v15 = v12 & 0x7FFFFFFFFFFFFFF8;
    v16 = 0uLL;
    do
    {
      v14 = vaddq_s32(v13[-1], v14);
      v16 = vaddq_s32(*v13, v16);
      v13 += 2;
      v15 -= 8;
    }

    while (v15);
    v10 = vaddvq_s32(vaddq_s32(v16, v14));
    if (v12 == (v12 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_5:
      SparseMatrix::SparseMatrix(a1, a2, a3, v7, v10, a5);
    }

    v11 = &v7[v12 & 0x7FFFFFFFFFFFFFF8];
  }

  else
  {
    v10 = 0;
    v11 = v7;
  }

  do
  {
    v17 = *v11++;
    v10 += v17;
  }

  while (v11 != v8);
  goto LABEL_5;
}

{
  v7 = *a4;
  v8 = a4[1];
  if (v7 == v8)
  {
    v10 = 0;
    goto LABEL_5;
  }

  v9 = v8 - v7 - 4;
  if (v9 >= 0x1C)
  {
    v12 = (v9 >> 2) + 1;
    v13 = (v7 + 4);
    v14 = 0uLL;
    v15 = v12 & 0x7FFFFFFFFFFFFFF8;
    v16 = 0uLL;
    do
    {
      v14 = vaddq_s32(v13[-1], v14);
      v16 = vaddq_s32(*v13, v16);
      v13 += 2;
      v15 -= 8;
    }

    while (v15);
    v10 = vaddvq_s32(vaddq_s32(v16, v14));
    if (v12 == (v12 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_5:
      SparseMatrix::SparseMatrix(a1, a2, a3, v7, v10, a5);
    }

    v11 = &v7[v12 & 0x7FFFFFFFFFFFFFF8];
  }

  else
  {
    v10 = 0;
    v11 = v7;
  }

  do
  {
    v17 = *v11++;
    v10 += v17;
  }

  while (v11 != v8);
  goto LABEL_5;
}

void SparseMatrix::SparseMatrix(SparseMatrix *this)
{
  *(this + 1) = 0u;
  *(this + 2) = 0u;
  *this = 0u;
}

{
  *(this + 1) = 0u;
  *(this + 2) = 0u;
  *this = 0u;
}

double SparseMatrix::freeMem(SparseMatrix *this)
{
  v2 = *this;
  if (v2)
  {
    MEMORY[0x245CBFC90](v2, 0x1000C8000313F17);
  }

  v3 = *(this + 1);
  if (v3)
  {
    MEMORY[0x245CBFC90](v3, 0x1000C8052888210);
  }

  v4 = *(this + 2);
  if (v4)
  {
    MEMORY[0x245CBFC90](v4, 0x1000C8052888210);
  }

  v5 = *(this + 3);
  if (v5)
  {
    MEMORY[0x245CBFC90](v5, 0x1000C8052888210);
  }

  result = 0.0;
  *this = 0u;
  *(this + 1) = 0u;
  return result;
}

void SparseMatrix::~SparseMatrix(SparseMatrix *this)
{
  v2 = *this;
  if (v2)
  {
    MEMORY[0x245CBFC90](v2, 0x1000C8000313F17);
  }

  v3 = *(this + 1);
  if (v3)
  {
    MEMORY[0x245CBFC90](v3, 0x1000C8052888210);
  }

  v4 = *(this + 2);
  if (v4)
  {
    MEMORY[0x245CBFC90](v4, 0x1000C8052888210);
  }

  v5 = *(this + 3);
  if (v5)
  {
    MEMORY[0x245CBFC90](v5, 0x1000C8052888210);
  }

  *this = 0u;
  *(this + 1) = 0u;
}

{
  v2 = *this;
  if (v2)
  {
    MEMORY[0x245CBFC90](v2, 0x1000C8000313F17);
  }

  v3 = *(this + 1);
  if (v3)
  {
    MEMORY[0x245CBFC90](v3, 0x1000C8052888210);
  }

  v4 = *(this + 2);
  if (v4)
  {
    MEMORY[0x245CBFC90](v4, 0x1000C8052888210);
  }

  v5 = *(this + 3);
  if (v5)
  {
    MEMORY[0x245CBFC90](v5, 0x1000C8052888210);
  }

  *this = 0u;
  *(this + 1) = 0u;
}

void SparseMatrix::SparseMatrix(SparseMatrix *this, const SparseMatrix *a2)
{
  *(this + 2) = *(a2 + 2);
  operator new[]();
}

{
  *(this + 2) = *(a2 + 2);
  operator new[]();
}

double SparseMatrix::SparseMatrix(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
  v2 = a2[2];
  a1[1] = a2[1];
  a1[2] = v2;
  result = 0.0;
  *a2 = 0u;
  a2[1] = 0u;
  return result;
}

{
  *a1 = *a2;
  v2 = a2[2];
  a1[1] = a2[1];
  a1[2] = v2;
  result = 0.0;
  *a2 = 0u;
  a2[1] = 0u;
  return result;
}

uint64_t *SparseMatrix::operator=(uint64_t *a1, _OWORD *a2)
{
  v4 = *a1;
  if (v4)
  {
    MEMORY[0x245CBFC90](v4, 0x1000C8000313F17);
  }

  v5 = a1[1];
  if (v5)
  {
    MEMORY[0x245CBFC90](v5, 0x1000C8052888210);
  }

  v6 = a1[2];
  if (v6)
  {
    MEMORY[0x245CBFC90](v6, 0x1000C8052888210);
  }

  v7 = a1[3];
  if (v7)
  {
    MEMORY[0x245CBFC90](v7, 0x1000C8052888210);
  }

  *a1 = 0u;
  *(a1 + 1) = 0u;
  *a1 = *a2;
  v8 = a2[2];
  *(a1 + 1) = a2[1];
  *(a1 + 2) = v8;
  *a2 = 0u;
  a2[1] = 0u;
  return a1;
}

uint64_t SparseMatrix::AddValue(uint64_t this, int a2, int a3, double a4)
{
  v4 = 4 * a3;
  v5 = *(this + 24);
  v6 = (*(this + 16) + v4);
  v7 = *(v5 + v4) + *v6;
  if (*(this + 36) - 1 == a3)
  {
    v8 = *(this + 32);
  }

  else
  {
    v8 = v6[1];
  }

  if (v7 >= v8)
  {
    __assert_rtn("AddValue", "SparseMatrix.cpp", 124, "(col != m_width-1 && index < m_colIndices[col+1]) || (col == m_width-1 && index < m_maxNNZ)");
  }

  v9 = *(this + 8);
  *(*this + 8 * v7) = a4;
  *(v9 + 4 * v7) = a2;
  ++*(v5 + 4 * a3);
  return this;
}

uint64_t SparseMatrix::Expand(uint64_t this, int a2, unint64_t a3)
{
  v3 = *(this + 44);
  if (v3 < a3)
  {
    __assert_rtn("Expand", "SparseMatrix.cpp", 134, "newNZPerCol <= (size_t)m_extraSpacePerCol");
  }

  *(this + 40) += a2;
  *(this + 44) = v3 - a3;
  return this;
}

uint64_t SparseMatrix::Squeeze(uint64_t this, int a2, int a3)
{
  v3 = *(this + 36);
  v4 = *(this + 44) + a3;
  *(this + 40) -= a2;
  *(this + 44) = v4;
  if (v3 >= 1)
  {
    v5 = 0;
    v6 = *(this + 24);
    do
    {
      *(v6 + 4 * v5++) -= a3;
    }

    while (v5 < *(this + 36));
  }

  return this;
}

double SparseMatrix::operator()(uint64_t a1, int a2, int a3)
{
  if (*(a1 + 40) <= a2 || *(a1 + 36) <= a3)
  {
    __assert_rtn("operator()", "SparseMatrix.cpp", 154, "row<(int)GetMatrixHeight() && col<(int)GetMatrixWidth()");
  }

  v3 = *(*(a1 + 24) + 4 * a3);
  result = 0.0;
  if (v3 >= 1)
  {
    for (i = *(*(a1 + 16) + 4 * a3); *(*(a1 + 8) + 4 * i) != a2; ++i)
    {
      if (!--v3)
      {
        return result;
      }
    }

    return *(*a1 + 8 * i);
  }

  return result;
}

uint64_t SparseMatrix::MultATagxB@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *(a1 + 36);
  *a2 = off_285231258;
  if (v2)
  {
    operator new[]();
  }

  result = 0;
  *(a2 + 16) = 1;
  *(a2 + 20) = 0;
  *(a2 + 24) = 0;
  *(a2 + 32) = 0;
  *a2 = &unk_285231338;
  *(a2 + 8) = 0;
  return result;
}

void SparseMatrix::operator*(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v6 = *(a1 + 10);
  *a3 = off_285231258;
  if (v6)
  {
    operator new[]();
  }

  *(a3 + 16) = 1;
  *(a3 + 20) = 0;
  *(a3 + 24) = 0;
  *(a3 + 32) = 0;
  *a3 = &unk_285231338;
  *(a3 + 8) = 0;
  bzero(0, 0);
  v7 = *(a1 + 9);
  if (v7 >= 1)
  {
    v8 = 0;
    v9 = a1[2];
    v10 = a1[3];
    do
    {
      v11 = *(v10 + 4 * v8);
      if (v11 >= 1)
      {
        v12 = *(v9 + 4 * v8);
        v13 = v11 + v12;
        v14 = *a1;
        v15 = a1[1];
        do
        {
          *(*(a3 + 8) + 8 * *(v15 + 4 * v12)) = *(*(a3 + 8) + 8 * *(v15 + 4 * v12)) + *(v14 + 8 * v12) * *(*(a2 + 8) + 8 * v8);
          ++v12;
        }

        while (v12 < v13);
      }

      ++v8;
    }

    while (v8 != v7);
  }
}

void *SparseMatrix::ReverseStorageOfColumn(void *this, int a2)
{
  v2 = *(this[3] + 4 * a2);
  if (v2)
  {
    v3 = *(this[2] + 4 * a2);
    v4 = (*this + 8 * v3);
    v5 = (8 * v3 + 8 * v2 + *this - 8);
    do
    {
      if (v5 == v4)
      {
        break;
      }

      v6 = *v4;
      *v4++ = *v5;
      v7 = v5 == v4;
      *v5-- = v6;
    }

    while (!v7);
    v8 = this[1];
    v9 = 4 * v3;
    v10 = (v8 + 4 * v3);
    v11 = (v9 + 4 * v2 + v8 - 4);
    do
    {
      if (v11 == v10)
      {
        break;
      }

      v12 = *v10;
      *v10++ = *v11;
      v7 = v11 == v10;
      *v11-- = v12;
    }

    while (!v7);
  }

  return this;
}

double SparseMatrix::GetColumnAsDenseVector@<D0>(SparseMatrix *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  v6 = *(this + 10);
  *a3 = off_285231258;
  if (v6)
  {
    operator new[]();
  }

  *(a3 + 16) = 1;
  *(a3 + 20) = 0;
  *(a3 + 24) = 0;
  *(a3 + 32) = 0;
  *a3 = &unk_285231338;
  *(a3 + 8) = 0;
  bzero(0, 0);
  v8 = *(*(this + 3) + 4 * a2);
  if (v8 >= 1)
  {
    v9 = *(this + 1);
    v10 = *(*(this + 2) + 4 * a2);
    v11 = v8 + v10;
    v12 = *this;
    do
    {
      result = *(v12 + 8 * v10);
      *(*(a3 + 8) + 8 * *(v9 + 4 * v10++)) = result;
    }

    while (v10 < v11);
  }

  return result;
}

double SparseMatrix::CopyColumnToDenseVector(SparseMatrix *this, int a2, double *a3)
{
  bzero(a3, 8 * *(this + 10));
  v7 = *(*(this + 3) + 4 * a2);
  if (v7 >= 1)
  {
    v8 = *(this + 1);
    v9 = *(*(this + 2) + 4 * a2);
    v10 = v7 + v9;
    v11 = *this;
    do
    {
      result = *(v11 + 8 * v9);
      a3[*(v8 + 4 * v9++)] = result;
    }

    while (v9 < v10);
  }

  return result;
}

uint64_t SparseMatrix::GetColumnAsSparseVector@<X0>(uint64_t this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  v3 = *(this + 40);
  v4 = *(*(this + 24) + 4 * a2);
  v5 = *(*(this + 16) + 4 * a2);
  v6 = *(this + 8) + 4 * v5;
  v7 = *this + 8 * v5;
  *(a3 + 16) = v4;
  *(a3 + 20) = v4;
  *(a3 + 24) = v3;
  *(a3 + 28) = 0;
  *(a3 + 32) = 0;
  *a3 = v7;
  *(a3 + 8) = v6;
  *(a3 + 40) = 0;
  *(a3 + 48) = 0;
  return this;
}

void SparseVector::SparseVector(SparseVector *this, int a2, int a3, int *a4, double *a5, char a6)
{
  *(this + 4) = a3;
  *(this + 5) = a3;
  *(this + 6) = a2;
  *(this + 28) = a6;
  *(this + 8) = 0;
  if (a6)
  {
    operator new[]();
  }

  *this = a5;
  *(this + 1) = a4;
  *(this + 6) = 0;
  *(this + 5) = 0;
}

uint64_t SparseMatrix::SolveLTInPlace(uint64_t result, uint64_t a2)
{
  v2 = *(result + 36);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *(a2 + 8);
    v5 = *result;
    v6 = *(result + 16);
    v7 = *(result + 24);
    v8 = *result + 8;
    v9 = (v4 + 24);
    v10 = *result + 24;
    v11 = v4;
    do
    {
      v12 = (v4 + 8 * v3);
      result = *(v6 + 4 * v3);
      v13 = *v12 / *(*&v5 + 8 * result);
      *v12 = v13;
      v14 = (v12 + 1);
      v15 = *(v7 + 4 * v3);
      if (v15 >= 2)
      {
        if (v15 > 4 && ((v16 = &v12[v15], v14 < *&v5 + 8 * result + 8 * v15) ? (v17 = v8 + 8 * result >= v16) : (v17 = 1), v17))
        {
          v18 = (v15 - 1) & 0xFFFFFFFFFFFFFFFCLL;
          v19 = vdupq_lane_s64(*&v13, 0);
          v20 = (v10 + 8 * result);
          v21 = v9;
          v22 = v18;
          do
          {
            v23 = vmlsq_f64(*v21, v19, *v20);
            v21[-1] = vmlsq_f64(v21[-1], v19, v20[-1]);
            *v21 = v23;
            v21 += 2;
            v20 += 2;
            v22 -= 4;
          }

          while (v22);
          if (v15 - 1 == v18)
          {
            goto LABEL_3;
          }

          v24 = v18 | 1;
        }

        else
        {
          v24 = 1;
        }

        v25 = v15 - v24;
        v26 = 8 * v24;
        v27 = (v11 + 8 * v24);
        result = *&v5 + v26 + 8 * result;
        do
        {
          v28 = *result;
          result += 8;
          *v27 = *v27 - v28 * v13;
          ++v27;
          --v25;
        }

        while (v25);
      }

LABEL_3:
      ++v3;
      v9 = (v9 + 8);
      v11 += 8;
    }

    while (v3 != v2);
  }

  return result;
}

void SparseVector::SparseVector(SparseVector *this, int a2, int a3)
{
  *(this + 4) = a3;
  *(this + 5) = 0;
  *(this + 6) = a2;
  *(this + 28) = 1;
  *(this + 8) = 0;
  operator new[]();
}

{
  *(this + 4) = a3;
  *(this + 5) = 0;
  *(this + 6) = a2;
  *(this + 28) = 1;
  *(this + 8) = 0;
  operator new[]();
}

void SparseVector::~SparseVector(SparseVector *this)
{
  if (*(this + 28) == 1)
  {
    v2 = *(this + 1);
    if (v2)
    {
      MEMORY[0x245CBFC90](v2, 0x1000C8052888210);
    }

    if (*this)
    {
      MEMORY[0x245CBFC90](*this, 0x1000C8000313F17);
    }
  }

  v3 = *(this + 6);
  if (v3)
  {
    MEMORY[0x245CBFC90](v3, 0x1000C8052888210);
  }

  v4 = *(this + 5);
  if (v4)
  {
    MEMORY[0x245CBFC90](v4, 0x1000C8000313F17);
  }
}

{
  if (*(this + 28) == 1)
  {
    v2 = *(this + 1);
    if (v2)
    {
      MEMORY[0x245CBFC90](v2, 0x1000C8052888210);
    }

    if (*this)
    {
      MEMORY[0x245CBFC90](*this, 0x1000C8000313F17);
    }
  }

  v3 = *(this + 6);
  if (v3)
  {
    MEMORY[0x245CBFC90](v3, 0x1000C8052888210);
  }

  v4 = *(this + 5);
  if (v4)
  {
    MEMORY[0x245CBFC90](v4, 0x1000C8000313F17);
  }
}

__n128 SparseVector::SparseVector(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 28) = *(a2 + 28);
  *(a1 + 32) = 0;
  result = *(a2 + 40);
  *(a1 + 40) = result;
  *(a2 + 28) = 0;
  return result;
}

{
  *a1 = *a2;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 28) = *(a2 + 28);
  *(a1 + 32) = 0;
  result = *(a2 + 40);
  *(a1 + 40) = result;
  *(a2 + 28) = 0;
  return result;
}

void SparseVector::SparseVector(SparseVector *this, const SparseVector *a2)
{
  v2 = *(a2 + 20);
  *(this + 4) = v2;
  *(this + 20) = v2;
  *(this + 28) = 1;
  *(this + 8) = 0;
  operator new[]();
}

{
  v2 = *(a2 + 20);
  *(this + 4) = v2;
  *(this + 20) = v2;
  *(this + 28) = 1;
  *(this + 8) = 0;
  operator new[]();
}

uint64_t SparseVector::operator=(uint64_t a1, uint64_t a2)
{
  if ((*(a1 + 28) & 1) == 0)
  {
    __assert_rtn("operator=", "SparseMatrix.cpp", 500, "m_ownsData");
  }

  if (*(a1 + 16) < *(a2 + 16))
  {
    v4 = *(a1 + 8);
    if (v4)
    {
      MEMORY[0x245CBFC90](v4, 0x1000C8052888210);
    }

    if (*a1)
    {
      MEMORY[0x245CBFC90](*a1, 0x1000C8000313F17);
    }

    v5 = *(a1 + 48);
    if (v5)
    {
      MEMORY[0x245CBFC90](v5, 0x1000C8052888210);
    }

    v6 = *(a1 + 40);
    if (v6)
    {
      MEMORY[0x245CBFC90](v6, 0x1000C8000313F17);
    }

    *(a1 + 16) = *(a2 + 16);
    *(a1 + 24) = *(a2 + 24);
    operator new[]();
  }

  memcpy(*(a1 + 8), *(a2 + 8), 4 * *(a2 + 20));
  memcpy(*a1, *a2, 8 * *(a2 + 20));
  *(a1 + 20) = *(a2 + 20);
  return a1;
}

uint64_t SparseVector::MultATagxB(uint64_t this, const SparseVector *a2)
{
  v2 = 0;
  v3 = 0;
  v4 = *(this + 8);
  v5 = *(this + 20);
  v6 = 0.0;
  v7 = *(a2 + 1);
  while (2)
  {
    v8 = *v4;
    while (1)
    {
      v9 = *v7;
      if (v8 < *v7)
      {
        while (++v2 < v5)
        {
          v10 = v4[1];
          ++v4;
          v8 = v10;
          if (v10 >= v9)
          {
            goto LABEL_6;
          }
        }

        return this;
      }

LABEL_6:
      if (v9 >= v8)
      {
        break;
      }

      if (++v3 >= v5)
      {
        return this;
      }

      ++v7;
    }

    v6 = v6 + *(*this + 8 * v2++) * *(*a2 + 8 * v3);
    if (v2 < v5 && ++v3 < *(a2 + 5))
    {
      ++v4;
      ++v7;
      continue;
    }

    return this;
  }
}

uint64_t SparseVector::AddWithFactor(uint64_t this, const SparseVector *a2, double a3)
{
  if ((*(this + 28) & 1) == 0)
  {
    __assert_rtn("AddWithFactor", "SparseMatrix.cpp", 594, "m_ownsData");
  }

  if (*(this + 24) != *(a2 + 6))
  {
    __assert_rtn("AddWithFactor", "SparseMatrix.cpp", 595, "this->m_size == rhs.m_size");
  }

  *(this + 32) = 0;
  v3 = *(a2 + 5);
  v4 = *this;
  v5 = *(this + 8);
  v6 = *(this + 20);
  v7 = *this + 8 * v6;
  v8 = *a2;
  v9 = *(a2 + 1);
  v10 = *a2 + 8 * v3;
  v11 = 0;
  if (v6 < 1 || v3 < 1)
  {
    v14 = *(this + 8);
    v13 = *this;
    goto LABEL_27;
  }

  v13 = *this;
  v14 = *(this + 8);
  do
  {
    v15 = *v14;
    v16 = *v9;
    if (*v14 == *v9)
    {
      if (*(this + 24) <= v15 || v11 >= *(this + 16))
      {
        goto LABEL_35;
      }

      v17 = *v13++;
      v18 = v17 + a3 * *v8;
      v19 = *(this + 40);
      *(*(this + 48) + 4 * v11) = v15;
      v20 = *(this + 32);
      *(v19 + 8 * v20) = v18;
      v11 = v20 + 1;
      *(this + 32) = v11;
      ++v14;
LABEL_21:
      ++v8;
      ++v9;
      if (v13 >= v7)
      {
        break;
      }

      continue;
    }

    if (v15 >= v16)
    {
      if (*(this + 24) <= v16 || v11 >= *(this + 16))
      {
        goto LABEL_35;
      }

      v24 = *v8 * a3;
      v25 = *(this + 40);
      *(*(this + 48) + 4 * v11) = v16;
      v26 = *(this + 32);
      *(v25 + 8 * v26) = v24;
      v11 = v26 + 1;
      *(this + 32) = v11;
      goto LABEL_21;
    }

    if (*(this + 24) <= v15 || v11 >= *(this + 16))
    {
      goto LABEL_35;
    }

    v21 = *v13++;
    v22 = *(this + 40);
    *(*(this + 48) + 4 * v11) = v15;
    v23 = *(this + 32);
    *(v22 + 8 * v23) = v21;
    v11 = v23 + 1;
    *(this + 32) = v11;
    ++v14;
    if (v13 >= v7)
    {
      break;
    }
  }

  while (v8 < v10);
LABEL_27:
  while (v13 < v7)
  {
    if (*(this + 24) <= *v14 || v11 >= *(this + 16))
    {
      goto LABEL_35;
    }

    v27 = *v13++;
    v28 = *(this + 40);
    *(*(this + 48) + 4 * v11) = *v14;
    v29 = *(this + 32);
    *(v28 + 8 * v29) = v27;
    v11 = v29 + 1;
    *(this + 32) = v11;
    ++v14;
  }

  if (v8 < v10)
  {
    while (*(this + 24) > *v9 && v11 < *(this + 16))
    {
      v30 = *v8++;
      v31 = *(this + 40);
      *(*(this + 48) + 4 * v11) = *v9;
      v32 = *(this + 32);
      *(v31 + 8 * v32) = v30 * a3;
      v11 = v32 + 1;
      *(this + 32) = v11;
      ++v9;
      if (v8 >= v10)
      {
        goto LABEL_34;
      }
    }

LABEL_35:
    __assert_rtn("AddValueToHelper", "SparseMatrix.hpp", 175, "pos<m_size && m_helperNNZ<m_maxNNZ");
  }

  v31 = *(this + 40);
LABEL_34:
  *this = v31;
  *(this + 40) = v4;
  *(this + 48) = v5;
  *(this + 20) = v11;
  return this;
}

void SparseVector::operator-(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v3 = *(a1 + 24);
  *(a3 + 16) = (*(a2 + 20) + *(a1 + 20));
  *(a3 + 24) = v3;
  *(a3 + 28) = 1;
  *(a3 + 32) = 0;
  operator new[]();
}

void sub_2403134EC(_Unwind_Exception *a1)
{
  MEMORY[0x245CBFC90](v1, 0x1000C8052888210);
  MEMORY[0x245CBFC90](v2, v5);
  MEMORY[0x245CBFC90](v3, 0x1000C8052888210);
  MEMORY[0x245CBFC90](v4, v5);
  _Unwind_Resume(a1);
}

double operator+=(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 20);
  if (v2 >= 1)
  {
    v3 = *a2;
    v4 = *(a2 + 8);
    do
    {
      v5 = *v3++;
      v6 = v5;
      LODWORD(v5) = *v4++;
      v7 = *(a1 + 8);
      result = v6 + *(v7 + 8 * LODWORD(v5));
      *(v7 + 8 * LODWORD(v5)) = result;
      --v2;
    }

    while (v2);
  }

  return result;
}

double SparseVector::GetAsDenseVector@<D0>(SparseVector *this@<X0>, uint64_t a2@<X8>)
{
  v4 = *(this + 6);
  *a2 = off_285231258;
  if (v4)
  {
    operator new[]();
  }

  *(a2 + 16) = 1;
  *(a2 + 20) = 0;
  *(a2 + 24) = 0;
  *(a2 + 32) = 0;
  *a2 = &unk_285231338;
  *(a2 + 8) = 0;
  bzero(0, 0);
  v6 = *(this + 5);
  if (v6 >= 1)
  {
    v7 = *this;
    v8 = *(this + 1);
    do
    {
      v9 = *v7++;
      result = v9;
      LODWORD(v9) = *v8++;
      *(*(a2 + 8) + 8 * LODWORD(v9)) = result;
      --v6;
    }

    while (v6);
  }

  return result;
}

uint64_t Algo::asin(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  v4 = *(a1 + 20);
  v5 = *(a2 + 8);
  if (*(a2 + 32) < 8 * v3 * v4)
  {
    if (v5)
    {
      if (*(a2 + 24) == 1)
      {
        MEMORY[0x245CBFC90](v5);
      }
    }

    operator new[]();
  }

  *(a2 + 16) = v3;
  *(a2 + 20) = v4;
  for (i = *(a1 + 8) + 8 * (*(a1 + 20) * *(a1 + 16)); v2 < i; ++v5)
  {
    v7 = *v2++;
    *v5 = asin(v7);
  }

  return 0;
}

uint64_t Algo::sin(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  v4 = *(a1 + 20);
  v5 = *(a2 + 8);
  if (*(a2 + 32) < 8 * v3 * v4)
  {
    if (v5)
    {
      if (*(a2 + 24) == 1)
      {
        MEMORY[0x245CBFC90](v5);
      }
    }

    operator new[]();
  }

  *(a2 + 16) = v3;
  *(a2 + 20) = v4;
  v6 = *(a1 + 8);
  v7 = (*(a1 + 20) * *(a1 + 16));
  v8 = v6 + 8 * v7;
  if (v2 < v8)
  {
    v9 = v6 + 8 * v7;
    if (v9 <= v2 + 8)
    {
      v9 = v2 + 8;
    }

    v10 = v9 + ~v2;
    if (v10 < 8 || v5 - v2 < 0x10)
    {
      v12 = v2;
      goto LABEL_18;
    }

    v13 = (v10 >> 3) + 1;
    v14 = v13 & 0x3FFFFFFFFFFFFFFELL;
    v12 = (v2 + 8 * (v13 & 0x3FFFFFFFFFFFFFFELL));
    v15 = v5;
    v16 = v13 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      v17 = *v2;
      v2 += 16;
      v21 = sin(*(&v17 + 1));
      *&v18 = sin(*&v17);
      *(&v18 + 1) = v21;
      *v15 = v18;
      v15 += 2;
      v16 -= 2;
    }

    while (v16);
    if (v13 != v14)
    {
      v5 += v14;
      do
      {
LABEL_18:
        v19 = *v12++;
        *v5++ = sin(v19);
      }

      while (v12 < v8);
    }
  }

  return 0;
}

uint64_t Algo::atan(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  v4 = *(a1 + 20);
  v5 = *(a2 + 8);
  if (*(a2 + 32) < 8 * v3 * v4)
  {
    if (v5)
    {
      if (*(a2 + 24) == 1)
      {
        MEMORY[0x245CBFC90](v5);
      }
    }

    operator new[]();
  }

  *(a2 + 16) = v3;
  *(a2 + 20) = v4;
  for (i = *(a1 + 8) + 8 * (*(a1 + 20) * *(a1 + 16)); v2 < i; ++v5)
  {
    v7 = *v2++;
    *v5 = atan(v7);
  }

  return 0;
}

uint64_t Algo::atan2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a2 + 8);
  v4 = *(a2 + 16);
  v5 = *(a2 + 20);
  v6 = *(a3 + 8);
  if (*(a3 + 32) < 8 * v4 * v5)
  {
    if (v6)
    {
      if (*(a3 + 24) == 1)
      {
        MEMORY[0x245CBFC90](*(a3 + 8), 0x1000C8000313F17);
      }
    }

    operator new[]();
  }

  v7 = *(a3 + 32);
  *(a3 + 16) = v4;
  *(a3 + 20) = v5;
  v8 = *(a1 + 8);
  v9 = *(a2 + 16);
  v10 = *(a2 + 20);
  if (v7 < 8 * v9 * v10)
  {
    if (v6 && *(a3 + 24) == 1)
    {
      MEMORY[0x245CBFC90](v6, 0x1000C8000313F17);
    }

    operator new[]();
  }

  *(a3 + 16) = v9;
  *(a3 + 20) = v10;
  for (i = *(a2 + 8) + 8 * (*(a2 + 20) * *(a2 + 16)); v3 < i; ++v6)
  {
    v12 = *v8++;
    v13 = v12;
    v14 = *v3++;
    *v6 = atan2(v13, v14);
  }

  return 0;
}

uint64_t Algo::tan(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  v4 = *(a1 + 20);
  v5 = *(a2 + 8);
  if (*(a2 + 32) < 8 * v3 * v4)
  {
    if (v5)
    {
      if (*(a2 + 24) == 1)
      {
        MEMORY[0x245CBFC90](v5);
      }
    }

    operator new[]();
  }

  *(a2 + 16) = v3;
  *(a2 + 20) = v4;
  v6 = *(a1 + 8);
  v7 = (*(a1 + 20) * *(a1 + 16));
  v8 = v6 + 8 * v7;
  if (v2 < v8)
  {
    v9 = v6 + 8 * v7;
    if (v9 <= v2 + 8)
    {
      v9 = v2 + 8;
    }

    v10 = v9 + ~v2;
    if (v10 < 8 || v5 - v2 < 0x10)
    {
      v12 = v2;
      goto LABEL_18;
    }

    v13 = (v10 >> 3) + 1;
    v14 = v13 & 0x3FFFFFFFFFFFFFFELL;
    v12 = (v2 + 8 * (v13 & 0x3FFFFFFFFFFFFFFELL));
    v15 = v5;
    v16 = v13 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      v17 = *v2;
      v2 += 16;
      v21 = tan(*(&v17 + 1));
      *&v18 = tan(*&v17);
      *(&v18 + 1) = v21;
      *v15 = v18;
      v15 += 2;
      v16 -= 2;
    }

    while (v16);
    if (v13 != v14)
    {
      v5 += v14;
      do
      {
LABEL_18:
        v19 = *v12++;
        *v5++ = tan(v19);
      }

      while (v12 < v8);
    }
  }

  return 0;
}

uint64_t Algo::acos(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  v4 = *(a1 + 20);
  v5 = *(a2 + 8);
  if (*(a2 + 32) < 8 * v3 * v4)
  {
    if (v5)
    {
      if (*(a2 + 24) == 1)
      {
        MEMORY[0x245CBFC90](v5);
      }
    }

    operator new[]();
  }

  *(a2 + 16) = v3;
  *(a2 + 20) = v4;
  for (i = *(a1 + 8) + 8 * (*(a1 + 20) * *(a1 + 16)); v2 < i; ++v5)
  {
    v7 = *v2++;
    *v5 = acos(v7);
  }

  return 0;
}

uint64_t Algo::cos(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  v4 = *(a1 + 20);
  v5 = *(a2 + 8);
  if (*(a2 + 32) < 8 * v3 * v4)
  {
    if (v5)
    {
      if (*(a2 + 24) == 1)
      {
        MEMORY[0x245CBFC90](v5);
      }
    }

    operator new[]();
  }

  *(a2 + 16) = v3;
  *(a2 + 20) = v4;
  v6 = *(a1 + 8);
  v7 = (*(a1 + 20) * *(a1 + 16));
  v8 = v6 + 8 * v7;
  if (v2 < v8)
  {
    v9 = v6 + 8 * v7;
    if (v9 <= v2 + 8)
    {
      v9 = v2 + 8;
    }

    v10 = v9 + ~v2;
    if (v10 < 8 || v5 - v2 < 0x10)
    {
      v12 = v2;
      goto LABEL_18;
    }

    v13 = (v10 >> 3) + 1;
    v14 = v13 & 0x3FFFFFFFFFFFFFFELL;
    v12 = (v2 + 8 * (v13 & 0x3FFFFFFFFFFFFFFELL));
    v15 = v5;
    v16 = v13 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      v17 = *v2;
      v2 += 16;
      v21 = cos(*(&v17 + 1));
      *&v18 = cos(*&v17);
      *(&v18 + 1) = v21;
      *v15 = v18;
      v15 += 2;
      v16 -= 2;
    }

    while (v16);
    if (v13 != v14)
    {
      v5 += v14;
      do
      {
LABEL_18:
        v19 = *v12++;
        *v5++ = cos(v19);
      }

      while (v12 < v8);
    }
  }

  return 0;
}

uint64_t Algo::cart2sph(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v8 = *(a1 + 16);
  v9 = *(a1 + 20);
  v63 = off_285231258;
  if (v9 * v8)
  {
    operator new[]();
  }

  v64 = 0;
  v65 = __PAIR64__(v9, v8);
  v66 = 0;
  v67 = 8 * v8 * v9;
  v11 = *(a2 + 16);
  v10 = *(a2 + 20);
  v57 = off_285231258;
  if (v10 * v11)
  {
    operator new[]();
  }

  v58 = 0;
  v59 = v11;
  v60 = v10;
  v61 = 0;
  v62 = 8 * v11 * v10;
  if (v10 != HIDWORD(v65) || v11 != v65)
  {
    __assert_rtn("doDimensionsMatchTo", "Matrix.hpp", 1043, "0");
  }

  v69 = 0;
  v71 = 0;
  v72 = 8 * v11 * v10;
  v73 = off_285231258;
  v74 = 0;
  v75 = v11;
  v76 = v10;
  v77 = 0;
  v78 = v72;
  v68 = off_285231258;
  v70 = 0;
  v57 = off_285231258;
  v63 = off_285231258;
  v13 = v10;
  if (a6)
  {
    v57 = off_285231258;
    if (v76 * v75)
    {
      operator new[]();
    }

    v58 = 0;
    v59 = v75;
    v60 = v76;
    v61 = 0;
    v62 = 8 * v75 * v76;
    v15 = *(a3 + 16);
    v14 = *(a3 + 20);
    v51 = off_285231258;
    if (v14 * v15)
    {
      operator new[]();
    }

    v52 = 0;
    v53 = v15;
    v54 = v14;
    v55 = 0;
    v56 = 8 * v15 * v14;
    if (v14 != v60 || v15 != v59)
    {
      __assert_rtn("doDimensionsMatchTo", "Matrix.hpp", 1043, "0");
    }

    v63 = off_285231258;
    v64 = 0;
    v65 = __PAIR64__(v14, v15);
    v66 = 0;
    v67 = 8 * v15 * v14;
    v68 = off_285231258;
    v69 = 0;
    v70 = __PAIR64__(v14, v15);
    v71 = 0;
    v72 = v67;
    v17 = *(a6 + 8);
    if (*(a6 + 32) < v67)
    {
      if (v17)
      {
        if (*(a6 + 24) == 1)
        {
          MEMORY[0x245CBFC90]();
        }
      }

      operator new[]();
    }

    *(a6 + 16) = v15;
    *(a6 + 20) = v14;
    memcpy(v17, 0, 8 * v15 * v14);
    v68 = off_285231258;
    if (v69 && v71 == 1)
    {
      MEMORY[0x245CBFC90]();
      v69 = 0;
      v72 = 0;
      v71 = 0;
    }

    v70 = 0;
    v63 = off_285231258;
    if (v64 && v66 == 1)
    {
      MEMORY[0x245CBFC90]();
      v64 = 0;
      v67 = 0;
      v66 = 0;
    }

    v65 = 0;
    v51 = off_285231258;
    if (v52 && v55 == 1)
    {
      MEMORY[0x245CBFC90]();
    }

    v57 = off_285231258;
    if (v58 && v61 == 1)
    {
      MEMORY[0x245CBFC90]();
    }

    v11 = v75;
    v13 = v76;
  }

  v18 = *(a3 + 8);
  v19 = *(a3 + 16);
  v20 = *(a3 + 20);
  v46 = off_285231258;
  v47 = v18;
  v50 = 8 * v19 * v20;
  v48 = __PAIR64__(v20, v19);
  v49 = 0;
  v41 = off_285231258;
  v42 = v74;
  v45 = 8 * v11 * v13;
  v43 = __PAIR64__(v13, v11);
  v44 = 0;
  Algo::atan2(&v46, &v41, a5);
  v41 = off_285231258;
  if (v42 && v44 == 1)
  {
    MEMORY[0x245CBFC90]();
    v42 = 0;
    v45 = 0;
    v44 = 0;
  }

  v43 = 0;
  v46 = off_285231258;
  if (v47 && v49 == 1)
  {
    MEMORY[0x245CBFC90]();
    v47 = 0;
    v50 = 0;
    v49 = 0;
  }

  v48 = 0;
  v21 = *(a2 + 8);
  v22 = *(a2 + 16);
  v23 = *(a2 + 20);
  v36 = off_285231258;
  v37 = v21;
  v40 = 8 * v22 * v23;
  v38 = __PAIR64__(v23, v22);
  v39 = 0;
  v24 = *(a1 + 8);
  v25 = *(a1 + 16);
  v26 = *(a1 + 20);
  v31 = off_285231258;
  v32 = v24;
  v35 = 8 * v25 * v26;
  v33 = __PAIR64__(v26, v25);
  v34 = 0;
  Algo::atan2(&v36, &v31, a4);
  v31 = off_285231258;
  if (v32 && v34 == 1)
  {
    MEMORY[0x245CBFC90]();
    v32 = 0;
    v35 = 0;
    v34 = 0;
  }

  v33 = 0;
  v36 = off_285231258;
  if (v37 && v39 == 1)
  {
    MEMORY[0x245CBFC90]();
    v37 = 0;
    v40 = 0;
    v39 = 0;
  }

  v38 = 0;
  v73 = off_285231258;
  if (v74 && v77 == 1)
  {
    MEMORY[0x245CBFC90]();
    v74 = 0;
    v78 = 0;
    v77 = 0;
  }

  return 0;
}

void sub_240314C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
  Matrix<double>::~Matrix(v37 - 168);
  Matrix<double>::~Matrix(v37 - 208);
  Matrix<double>::~Matrix(&a37);
  Matrix<double>::~Matrix(v37 - 248);
  Matrix<double>::~Matrix(v37 - 128);
  _Unwind_Resume(a1);
}

uint64_t Algo::LinearSpace@<X0>(Algo *this@<X0>, uint64_t a2@<X8>)
{
  *a2 = off_285231258;
  if (this)
  {
    operator new[]();
  }

  result = 0;
  *(a2 + 16) = 1;
  *(a2 + 20) = 0;
  *(a2 + 24) = 0;
  *(a2 + 32) = 0;
  *a2 = &unk_285231338;
  *(a2 + 8) = 0;
  return result;
}

uint64_t Algo::LinearSpaceByStep@<X0>(Algo *this@<X0>, double a2@<D0>, double a3@<D1>, uint64_t a4@<X8>)
{
  v4 = (a3 - a2) / this;
  *a4 = off_285231258;
  v5 = v4 + 1;
  if (v4 != -1)
  {
    operator new[]();
  }

  result = 0;
  *(a4 + 16) = 1;
  *(a4 + 20) = v5;
  *(a4 + 24) = v5 != 0;
  *(a4 + 32) = 0;
  *a4 = &unk_285231338;
  *(a4 + 8) = 0;
  return result;
}

uint64_t Algo::Fspecial@<X0>(int a1@<W0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  *a3 = off_285231258;
  if (a2 * a2)
  {
    operator new[]();
  }

  *(a3 + 8) = 0;
  *(a3 + 16) = a2;
  *(a3 + 20) = a2;
  *(a3 + 24) = 0;
  *(a3 + 32) = 8 * a2 * a2;
  if (a1)
  {
    return 0;
  }

  if (a2)
  {
    operator new[]();
  }

  *(a3 + 16) = 0;
  *(a3 + 20) = 0;
  v4 = *(a3 + 8);
  v5 = (*(a3 + 20) * *(a3 + 16));
  if (v5)
  {
    v6 = v4 + 8 * v5;
    if (v6 <= v4 + 8)
    {
      v6 = v4 + 8;
    }

    v7 = v6 + ~v4;
    if (v7 >= 8)
    {
      v9 = (v7 >> 3) + 1;
      v10 = *(a3 + 8);
      v11 = v9 & 0x3FFFFFFFFFFFFFFELL;
      do
      {
        __x = *v10;
        v28 = exp(v10[1]);
        *&v12 = exp(*&__x);
        *(&v12 + 1) = v28;
        *v10 = v12;
        v10 += 2;
        v11 -= 2;
      }

      while (v11);
      if (v9 == (v9 & 0x3FFFFFFFFFFFFFFELL))
      {
LABEL_18:
        v4 = *(a3 + 8);
        if (v5 >= 1)
        {
          v14 = -2147483650.0;
          v15 = *(a3 + 8);
          do
          {
            v16 = *v15++;
            v17 = v16;
            if (v16 > v14)
            {
              v14 = v17;
            }
          }

          while (v15 < v4 + 8 * v5);
        }

        goto LABEL_23;
      }

      v8 = (v4 + 8 * (v9 & 0x3FFFFFFFFFFFFFFELL));
    }

    else
    {
      v8 = *(a3 + 8);
    }

    v13 = (v4 + 8 * v5);
    do
    {
      *v8 = exp(*v8);
      ++v8;
    }

    while (v8 < v13);
    goto LABEL_18;
  }

LABEL_23:
  if (!v5)
  {
    return 0;
  }

  v18 = v4 + 8 * v5;
  v19 = (v4 + 8);
  if (v18 > v4 + 8)
  {
    v19 = (v4 + 8 * v5);
  }

  v20 = v19 + ~v4;
  if (v20 < 0x18)
  {
    goto LABEL_31;
  }

  v21 = (v20 >> 3) + 1;
  v22 = vdupq_lane_s64(0, 0);
  v23 = (v4 + 16);
  v24 = v21 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v25 = vdivq_f64(*v23, v22);
    v23[-1] = vdivq_f64(v23[-1], v22);
    *v23 = v25;
    v23 += 2;
    v24 -= 4;
  }

  while (v24);
  if (v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL))
  {
    v4 += 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    do
    {
LABEL_31:
      *v4 = *v4 / 0.0;
      v4 += 8;
    }

    while (v4 < v18);
  }

  return 0;
}

void sub_240315F58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28)
{
  Matrix<double>::~Matrix(&a28);
  MatrixNxPts<1u,double>::~MatrixNxPts(v29 - 224);
  Matrix<double>::~Matrix(v29 - 184);
  Matrix<double>::~Matrix(v29 - 144);
  Matrix<double>::~Matrix(v28);
  _Unwind_Resume(a1);
}

uint64_t Algo::StdFilter(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 <= 0)
  {
    __assert_rtn("StdFilter", "Algo.cpp", 627, "windowSize > 0");
  }

  v5 = *(a1 + 16);
  v4 = *(a1 + 20);
  if (*(a3 + 32) < 8 * v5 * v4)
  {
    if (*(a3 + 8))
    {
      if (*(a3 + 24) == 1)
      {
        MEMORY[0x245CBFC90]();
      }
    }

    operator new[]();
  }

  *(a3 + 16) = v5;
  *(a3 + 20) = v4;
  v6 = *(a1 + 16);
  v7 = *(a1 + 20);
  if (v7 * v6)
  {
    operator new[]();
  }

  v54 = *(a1 + 16);
  if (8 * v6 * v7)
  {
    operator new[]();
  }

  v8 = 0;
  if (v7)
  {
    v9 = *(a1 + 8);
    v10 = 0.0;
    v11 = v7;
    v12 = 0;
    do
    {
      v13 = *v9++;
      v10 = v10 + v13;
      *v12++ = v10;
      --v11;
    }

    while (v11);
    if (v6 >= 2)
    {
      for (i = 1; i != v6; ++i)
      {
        v15 = 0.0;
        v16 = v7;
        do
        {
          v17 = *v9++;
          v15 = v15 + v17;
          v18 = *v8++;
          *v12++ = v15 + v18;
          --v16;
        }

        while (v16);
      }
    }
  }

  v19 = 0;
  if (8 * v6 * v7)
  {
    operator new[]();
  }

  if (v7)
  {
    v20 = 0.0;
    v21 = 0;
    v22 = v7;
    do
    {
      v23 = *v21++;
      v20 = v20 + v23;
      *v19++ = v20;
      --v22;
    }

    while (v22);
    if (v6 >= 2)
    {
      v24 = 1;
      v25 = 0;
      do
      {
        v26 = 0.0;
        v27 = v7;
        do
        {
          v28 = *v21++;
          v26 = v26 + v28;
          v29 = *v25++;
          *v19++ = v26 + v29;
          --v27;
        }

        while (v27);
        ++v24;
      }

      while (v24 != v6);
    }
  }

  v30 = a2 >> 1;
  v31 = (v30 + 1);
  v32 = v5 - v30;
  if (v31 < (v5 - v30))
  {
    v33 = v4 - v30;
    if (v31 < (v4 - v30))
    {
      v34 = (a2 * a2);
      v35 = a2 - v30;
      v36 = sqrt(v34 / (a2 * a2 - 1));
      v37 = 8 * (a2 >> 1) + 8;
      v38 = 2 * v30 - a2 + 1;
      v39 = 8 * v38;
      v40 = (2 * v30) | 1;
      v41 = v40 - a2;
      v42 = (16 * v30) | 8;
      v43 = v30 + 1;
      do
      {
        if (v54 <= v43 + v30 || v6 <= v43 - v35 || v6 <= v43 + v30 || v6 <= v43 - v35)
        {
LABEL_45:
          __assert_rtn("operator()", "Matrix.hpp", 120, "row < m_rows && col < m_cols");
        }

        v44 = 0;
        v45 = 8 * v7 * v41;
        v46 = v39 + v45;
        v47 = 8 * v7 * v40;
        v48 = v39 + v47;
        v49 = v42 + v47;
        v50 = v42 + v45;
        do
        {
          if (((2 * v30) | 1uLL) + v44 >= v7)
          {
            goto LABEL_45;
          }

          if (v7 <= v38 + v44)
          {
            goto LABEL_45;
          }

          if (*(a3 + 16) <= v43)
          {
            goto LABEL_45;
          }

          v51 = *(a3 + 20);
          if (v31 + v44 >= v51)
          {
            goto LABEL_45;
          }

          v52 = *(v42 + 8 * v7 * v40 + 8 * v44) - *(v50 + 8 * v44) - *(v39 + 8 * v7 * v40 + 8 * v44) + *(v46 + 8 * v44);
          *(*(a3 + 8) + 8 * v43 * v51 + v37 + 8 * v44) = v36 * sqrt((*(v49 + 8 * v44) - *(v42 + 8 * v7 * v41 + 8 * v44) - *(v48 + 8 * v44) + *(v39 + 8 * v7 * v41 + 8 * v44)) / v34 - v52 * (v52 / v34) / v34);
          ++v44;
        }

        while (v33 > v31 + v44);
        ++v43;
        ++v41;
        ++v40;
      }

      while (v43 != v32);
    }
  }

  return 0;
}

void sub_2403167A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25)
{
  if (a13 && a15 == 1)
  {
    v25 = a1;
    MEMORY[0x245CBFC90](a13, 0x1000C8000313F17);
    a1 = v25;
  }

  if (a18 && a20 == 1)
  {
    v26 = a1;
    MEMORY[0x245CBFC90](a18, 0x1000C8000313F17);
    a1 = v26;
  }

  if (a23)
  {
    if (a25 == 1)
    {
      v27 = a1;
      MEMORY[0x245CBFC90](a23, 0x1000C8000313F17);
      a1 = v27;
    }
  }

  _Unwind_Resume(a1);
}

uint64_t Algo::NormXcorr2d(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(a2 + 16);
  v6 = *(a2 + 20);
  v7 = *(a1 + 16);
  v8 = *(a1 + 20);
  v9 = *(a3 + 8);
  if (*(a3 + 32) < 8 * v5 * v6)
  {
    if (v9)
    {
      if (*(a3 + 24) == 1)
      {
        MEMORY[0x245CBFC90]();
      }
    }

    operator new[]();
  }

  v177 = *(a2 + 20);
  *(a3 + 16) = v5;
  *(a3 + 20) = v6;
  if ((v6 * v5) >= 1)
  {
    v10 = v9 + 8 * v6 * v5;
    if (v10 <= v9 + 8)
    {
      v10 = v9 + 8;
    }

    bzero(v9, ((v10 + ~v9) & 0xFFFFFFFFFFFFFFF8) + 8);
  }

  v11 = *(a2 + 16);
  v12 = *(a2 + 20);
  if (v12 * v11)
  {
    operator new[]();
  }

  v182 = *(a2 + 16);
  if (8 * v11 * v12)
  {
    operator new[]();
  }

  v13 = 0;
  v180 = *(a2 + 16);
  v181 = *(a2 + 20);
  if (v12)
  {
    v14 = *(a2 + 8);
    v15 = 0.0;
    v16 = *(a2 + 20);
    v17 = 0;
    do
    {
      v18 = *v14++;
      v15 = v15 + v18;
      *v17++ = v15;
      --v16;
    }

    while (v16);
    if (v11 >= 2)
    {
      for (i = 1; i != v11; ++i)
      {
        v20 = 0.0;
        v21 = v12;
        do
        {
          v22 = *v14++;
          v20 = v20 + v22;
          v23 = *v13++;
          *v17++ = v20 + v23;
          --v21;
        }

        while (v21);
      }
    }
  }

  v24 = 0;
  if (8 * v182 * v12)
  {
    operator new[]();
  }

  v179 = v12;
  if (v12)
  {
    v25 = 0.0;
    v26 = 0;
    v27 = v12;
    do
    {
      v28 = *v26++;
      v25 = v25 + v28;
      *v24++ = v25;
      --v27;
    }

    while (v27);
    if (v182 >= 2)
    {
      v29 = 1;
      v30 = 0;
      do
      {
        v31 = 0.0;
        v32 = v12;
        do
        {
          v33 = *v26++;
          v31 = v31 + v33;
          v34 = *v30++;
          *v24++ = v31 + v34;
          --v32;
        }

        while (v32);
        ++v29;
      }

      while (v29 != v182);
    }
  }

  v35 = *(a1 + 8);
  v36 = *(a1 + 20) * *(a1 + 16);
  v37 = v36;
  if (v36 < 1)
  {
    v41 = 0.0;
    goto LABEL_44;
  }

  v38 = v35 + 8 * v36;
  v39 = (v35 + 8);
  if (v38 <= v35 + 8)
  {
    v38 = v35 + 8;
  }

  v40 = v38 + ~v35;
  v41 = 0.0;
  v42 = *(a1 + 8);
  if (v40 < 8)
  {
    goto LABEL_40;
  }

  v43 = (v40 >> 3) + 1;
  v44 = v43 & 0x3FFFFFFFFFFFFFFELL;
  do
  {
    v41 = v41 + *(v39 - 1) + *v39;
    v39 += 2;
    v44 -= 2;
  }

  while (v44);
  if (v43 != (v43 & 0x3FFFFFFFFFFFFFFELL))
  {
    v42 = (v35 + 8 * (v43 & 0x3FFFFFFFFFFFFFFELL));
LABEL_40:
    v45 = v35 + 8 * v36;
    do
    {
      v46 = *v42++;
      v41 = v41 + v46;
    }

    while (v42 < v45);
  }

LABEL_44:
  if (v37)
  {
    operator new[]();
  }

  if (v8 * v7)
  {
    operator new[]();
  }

  if (v7 >= 1 && v8 >= 1)
  {
    v47 = 0;
    v48 = 0;
    v49 = v41 / 0;
    v50 = sqrt(0.0 / 0 - v49 * v49);
    v51 = *(a1 + 16);
    do
    {
      if (v48 == v51)
      {
LABEL_149:
        __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
      }

      v52 = (8 * v47);
      v53 = *(a1 + 20);
      v54 = 8 * (v53 * v48);
      v55 = v8;
      do
      {
        if (!v53)
        {
          goto LABEL_149;
        }

        *v52 = (*(*(a1 + 8) + v54) - v49) / v50;
        v54 += 8;
        ++v52;
        --v53;
        --v55;
      }

      while (v55);
      ++v48;
      v47 += v8;
    }

    while (v48 != (v7 & ~(v7 >> 31)));
  }

  v56 = v7 / 2;
  v57 = v7 / 2 + 1;
  if (v57 < (v5 - v7 / 2))
  {
    v169 = v8 / 2;
    v174 = (v177 - v8 / 2);
    v168 = v8 / 2 + 1;
    if (v168 < v174)
    {
      v58 = 0;
      v59 = v7 - v56;
      v60 = v182;
      v61 = v56 + 2;
      v62 = (v56 + 3);
      v170 = v56 + 2;
      if (v56 + 2 >= v8)
      {
        v61 = v8;
      }

      v63 = v62 & 0xFFFFFFFC;
      v178 = (8 * (v56 + 3)) & 0x7FFFFFFE0;
      v64 = v7 / 2;
      v167 = v5 - v7 / 2;
      while (1)
      {
        v65 = v57;
        v66 = v57 + v56;
        v173 = v179 * (v57 + v56);
        v67 = v57 - v59;
        v68 = v179 * (v57 - v59);
        v69 = v181 * (v57 + v56);
        v70 = v180 > v57 - v59;
        v71 = v181 * v67;
        if (v60 <= v66 || v182 <= v67 || v180 <= v66)
        {
          goto LABEL_150;
        }

        v176 = v65 - v56;
        v172 = v64 + 4;
        if (v179 <= v181)
        {
          break;
        }

        if (!v70)
        {
          goto LABEL_150;
        }

        v117 = (v8 / 2 + 1);
        v119 = v56 + ~v169;
        v118 = v168 - v56;
        v120 = v8 / 2;
        do
        {
          v121 = (v56 + v117);
          if (v179 <= v121)
          {
            goto LABEL_150;
          }

          v122 = v117;
          if (v179 <= v117 - v59 || v181 <= v121 || v181 <= v117 - v59)
          {
            goto LABEL_150;
          }

          v123 = 8 * v121;
          v124 = 8 * (v117 - v59);
          v125 = (*(v123 + 8 * v69) - *(v123 + 8 * v71) - *(v124 + 8 * v69) + *(v124 + 8 * v71)) / v58;
          v126 = sqrt((*(v123 + 8 * v173) - *(v123 + 8 * v68) - *(v124 + 8 * v173) + *(v124 + 8 * v68)) / v58 - v125 * v125);
          v127 = 0.0;
          if (v126 > 0.0 && v176 < v172)
          {
            v171 = v117 - v56;
            if (v117 - v56 < v120 + 4)
            {
              v129 = *(a2 + 16);
              if (v8 > v170)
              {
                v130 = 8 * v118;
                if (v62 >= 4)
                {
                  v142 = 0;
                  v143 = 0;
                  v144 = vdupq_lane_s64(*&v125, 0);
                  v145 = vdupq_lane_s64(*&v126, 0);
                  v146 = v65 - v56;
                  while (v146 < v129)
                  {
                    v88 = *(a2 + 20);
                    if (v143 == v7)
                    {
                      goto LABEL_153;
                    }

                    v147 = v88 <= v118 ? v118 : *(a2 + 20);
                    if (v119 + v147 <= v61)
                    {
                      break;
                    }

                    v148 = v129;
                    v149 = 8 * v142;
                    v150 = (v178 + v149);
                    v151 = (v149 + 16);
                    v152 = *(a2 + 8);
                    v153 = v88 * v146;
                    v154 = (v152 + v130 + 8 * v153 + 16);
                    v155 = v62 & 0xFFFFFFFC;
                    do
                    {
                      v156 = vdivq_f64(vmulq_f64(vsubq_f64(v154[-1], v144), v151[-1]), v145);
                      v157 = vdivq_f64(vmulq_f64(vsubq_f64(*v154, v144), *v151), v145);
                      v127 = v127 + v156.f64[0] + v156.f64[1] + v157.f64[0] + v157.f64[1];
                      v154 += 2;
                      v151 += 2;
                      v155 -= 4;
                    }

                    while (v155);
                    v129 = v148;
                    if (v62 != v63)
                    {
                      v158 = (v152 + v178 + v130 + 8 * v153);
                      v159 = (v56 + 3) & 3;
                      do
                      {
                        v160 = *v158++;
                        v161 = v160 - v125;
                        v162 = *v150++;
                        v127 = v127 + v161 * v162 / v126;
                        --v159;
                      }

                      while (v159);
                    }

                    ++v146;
                    ++v143;
                    v142 += v8;
                    if (v143 == v62)
                    {
                      goto LABEL_129;
                    }
                  }
                }

                else
                {
                  v131 = 0;
                  v132 = 0;
                  v133 = v65 - v56;
                  while (v133 < v129)
                  {
                    v88 = *(a2 + 20);
                    if (v132 == v7)
                    {
                      goto LABEL_153;
                    }

                    v134 = v88 <= v118 ? v118 : *(a2 + 20);
                    if (v119 + v134 <= v61)
                    {
                      break;
                    }

                    v135 = (8 * v131);
                    v136 = (*(a2 + 8) + v130 + 8 * v88 * v133);
                    v137 = (v56 + 3);
                    do
                    {
                      v138 = *v136++;
                      v139 = v138 - v125;
                      v140 = *v135++;
                      v127 = v127 + v139 * v140 / v126;
                      --v137;
                    }

                    while (v137);
                    ++v133;
                    ++v132;
                    v131 += v8;
                    if (v132 == v62)
                    {
                      goto LABEL_129;
                    }
                  }
                }

LABEL_167:
                v164 = 126;
LABEL_168:
                __assert_rtn("operator()", "Matrix.hpp", v164, "row < m_rows && col < m_cols");
              }

              if (v176 >= v129)
              {
                goto LABEL_167;
              }

              v88 = *(a2 + 20);
              if (v7)
              {
                if (v88 <= v118)
                {
                  v166 = v118;
                }

                else
                {
                  v166 = *(a2 + 20);
                }

                if (v119 + v166 <= v61)
                {
                  goto LABEL_159;
                }

LABEL_154:
                v164 = 120;
                goto LABEL_168;
              }

LABEL_153:
              if (v171 < v88)
              {
                goto LABEL_154;
              }

LABEL_159:
              v164 = 126;
              goto LABEL_168;
            }
          }

LABEL_129:
          v59 = v7 - v56;
          if (*(a3 + 16) <= v65)
          {
            goto LABEL_150;
          }

          v141 = *(a3 + 20);
          if (v117 >= v141)
          {
            goto LABEL_150;
          }

          *(*(a3 + 8) + 8 * v117++ + 8 * v141 * v65) = v127 / v58;
          ++v118;
          --v119;
          v120 = v122;
        }

        while (v117 != v174);
LABEL_147:
        v57 = v65 + 1;
        v64 = v65;
        v60 = v182;
        if (v65 + 1 == v167)
        {
          return 0;
        }
      }

      if (!v70)
      {
LABEL_150:
        __assert_rtn("operator()", "Matrix.hpp", 120, "row < m_rows && col < m_cols");
      }

      v72 = (v8 / 2 + 1);
      v73 = v56 + ~v169;
      v74 = v168 - v56;
      v75 = v8 / 2;
      while (1)
      {
        if (v179 <= v56 + v72)
        {
          goto LABEL_150;
        }

        v76 = v72;
        if (v179 <= v72 - v59)
        {
          goto LABEL_150;
        }

        v77 = 8 * (v56 + v72);
        v78 = 8 * (v72 - v59);
        v79 = (*(v77 + 8 * v69) - *(v77 + 8 * v71) - *(v78 + 8 * v69) + *(v78 + 8 * v71)) / v58;
        v80 = sqrt((*(v77 + 8 * v173) - *(v77 + 8 * v68) - *(v78 + 8 * v173) + *(v78 + 8 * v68)) / v58 - v79 * v79);
        v81 = 0.0;
        if (v80 > 0.0 && v176 < v172)
        {
          v171 = v72 - v56;
          if (v72 - v56 < v75 + 4)
          {
            break;
          }
        }

LABEL_87:
        v59 = v7 - v56;
        if (*(a3 + 16) <= v65)
        {
          goto LABEL_150;
        }

        v96 = *(a3 + 20);
        if (v72 >= v96)
        {
          goto LABEL_150;
        }

        *(*(a3 + 8) + 8 * v72++ + 8 * v96 * v65) = v81 / v58;
        ++v74;
        --v73;
        v75 = v76;
        if (v72 == v174)
        {
          goto LABEL_147;
        }
      }

      v83 = *(a2 + 16);
      if (v8 > v170)
      {
        v84 = 8 * v74;
        if (v62 >= 4)
        {
          v97 = 0;
          v98 = 0;
          v99 = vdupq_lane_s64(*&v79, 0);
          v100 = vdupq_lane_s64(*&v80, 0);
          v101 = v65 - v56;
          while (v101 < v83)
          {
            v88 = *(a2 + 20);
            if (v98 == v7)
            {
              goto LABEL_153;
            }

            v102 = v88 <= v74 ? v74 : *(a2 + 20);
            if (v73 + v102 <= v61)
            {
              break;
            }

            v103 = 8 * v97;
            v104 = (v178 + v103);
            v105 = (v103 + 16);
            v106 = *(a2 + 8);
            v107 = v88 * v101;
            v108 = (v106 + v84 + 8 * v107 + 16);
            v109 = v62 & 0xFFFFFFFC;
            do
            {
              v110 = vdivq_f64(vmulq_f64(vsubq_f64(v108[-1], v99), v105[-1]), v100);
              v111 = vdivq_f64(vmulq_f64(vsubq_f64(*v108, v99), *v105), v100);
              v81 = v81 + v110.f64[0] + v110.f64[1] + v111.f64[0] + v111.f64[1];
              v108 += 2;
              v105 += 2;
              v109 -= 4;
            }

            while (v109);
            if (v62 != v63)
            {
              v112 = (v106 + v178 + v84 + 8 * v107);
              v113 = (v56 + 3) & 3;
              do
              {
                v114 = *v112++;
                v115 = v114 - v79;
                v116 = *v104++;
                v81 = v81 + v115 * v116 / v80;
                --v113;
              }

              while (v113);
            }

            ++v101;
            ++v98;
            v97 += v8;
            if (v98 == v62)
            {
              goto LABEL_87;
            }
          }
        }

        else
        {
          v85 = 0;
          v86 = 0;
          v87 = v65 - v56;
          while (v87 < v83)
          {
            v88 = *(a2 + 20);
            if (v86 == v7)
            {
              goto LABEL_153;
            }

            v89 = v88 <= v74 ? v74 : *(a2 + 20);
            if (v73 + v89 <= v61)
            {
              break;
            }

            v90 = (8 * v85);
            v91 = (*(a2 + 8) + v84 + 8 * v88 * v87);
            v92 = (v56 + 3);
            do
            {
              v93 = *v91++;
              v94 = v93 - v79;
              v95 = *v90++;
              v81 = v81 + v94 * v95 / v80;
              --v92;
            }

            while (v92);
            ++v87;
            ++v86;
            v85 += v8;
            if (v86 == v62)
            {
              goto LABEL_87;
            }
          }
        }

        goto LABEL_167;
      }

      if (v176 >= v83)
      {
        goto LABEL_167;
      }

      v88 = *(a2 + 20);
      if (!v7)
      {
        goto LABEL_153;
      }

      if (v88 <= v74)
      {
        v165 = v74;
      }

      else
      {
        v165 = *(a2 + 20);
      }

      if (v73 + v165 > v61)
      {
        goto LABEL_154;
      }

      goto LABEL_159;
    }
  }

  return 0;
}

void sub_240317870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36)
{
  if (a34 && a36 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  *(v36 - 184) = a19;
  if (*(v36 - 176) && *(v36 - 160) == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  *(v36 - 144) = a20;
  if (*(v36 - 136))
  {
    if (*(v36 - 120) == 1)
    {
      MEMORY[0x245CBFC90]();
    }
  }

  _Unwind_Resume(exception_object);
}

void Algo::FundMatrix3x3(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 20))
  {
    operator new[]();
  }

  if (*(a2 + 20))
  {
    operator new[]();
  }

  Algo::Normalize2DPts();
}

void sub_240319C10(_Unwind_Exception *a1)
{
  MatrixNxPts<1u,double>::~MatrixNxPts(&STACK[0x698]);
  MatrixNxPts<1u,double>::~MatrixNxPts(&STACK[0xA30]);
  MatrixNxPts<3u,double>::~MatrixNxPts(&STACK[0x9B8]);
  MatrixNxPts<3u,double>::~MatrixNxPts(&STACK[0x9E0]);
  MatrixNxPts<9u,double>::~MatrixNxPts(&STACK[0xA08]);
  _Unwind_Resume(a1);
}

void sub_24031A2C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  v5 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  MatrixNxPts<3u,double>::~MatrixNxPts(va);
  MatrixNxPts<3u,double>::~MatrixNxPts(va1);
  _Unwind_Resume(a1);
}

uint64_t MatrixMxN<1u,9u,double>::Sort<1u,void>(uint64_t result, uint64_t a2)
{
  *(result + 64) = *(a2 + 64);
  v2 = *(a2 + 48);
  *(result + 32) = *(a2 + 32);
  *(result + 48) = v2;
  v3 = *(a2 + 16);
  *result = *a2;
  *(result + 16) = v3;
  LODWORD(v4) = *(result + 8) < *result;
  if (*(result + 16) < *(result + 8 * (*(result + 8) < *result)))
  {
    LODWORD(v4) = 2;
  }

  v5 = 3;
  if (*(result + 24) >= *(result + 8 * v4))
  {
    v4 = v4;
  }

  else
  {
    v4 = 3;
  }

  v6 = 4;
  if (*(result + 32) < *(result + 8 * v4))
  {
    v4 = 4;
  }

  v7 = 5;
  if (*(result + 40) >= *(result + 8 * v4))
  {
    v8 = v4;
  }

  else
  {
    v8 = 5;
  }

  v9 = 6;
  if (*(result + 48) >= *(result + 8 * v8))
  {
    v10 = v8;
  }

  else
  {
    v10 = 6;
  }

  if (*(result + 56) >= *(result + 8 * v10))
  {
    v11 = v10;
  }

  else
  {
    v11 = 7;
  }

  if (*(result + 64) < *(result + 8 * v11))
  {
    v11 = 8;
  }

  v12 = *(result + 8 * v11);
  *(result + 8 * v11) = *result;
  *result = v12;
  v13 = *(result + 8);
  if (*(result + 16) >= v13)
  {
    LODWORD(v14) = 1;
  }

  else
  {
    LODWORD(v14) = 2;
  }

  if (*(result + 24) >= *(result + 8 * v14))
  {
    v14 = v14;
  }

  else
  {
    v14 = 3;
  }

  if (*(result + 32) < *(result + 8 * v14))
  {
    v14 = 4;
  }

  if (*(result + 40) < *(result + 8 * v14))
  {
    v14 = 5;
  }

  if (*(result + 48) < *(result + 8 * v14))
  {
    v14 = 6;
  }

  if (*(result + 56) < *(result + 8 * v14))
  {
    v14 = 7;
  }

  if (*(result + 64) < *(result + 8 * v14))
  {
    v14 = 8;
  }

  v15 = *(result + 8 * v14);
  *(result + 8 * v14) = v13;
  *(result + 8) = v15;
  v16 = *(result + 16);
  if (*(result + 24) >= v16)
  {
    v17 = 2;
  }

  else
  {
    v17 = 3;
  }

  if (*(result + 32) < *(result + 8 * v17))
  {
    v17 = 4;
  }

  if (*(result + 40) < *(result + 8 * v17))
  {
    v17 = 5;
  }

  if (*(result + 48) < *(result + 8 * v17))
  {
    v17 = 6;
  }

  if (*(result + 56) < *(result + 8 * v17))
  {
    v17 = 7;
  }

  if (*(result + 64) < *(result + 8 * v17))
  {
    v17 = 8;
  }

  v18 = *(result + 8 * v17);
  *(result + 8 * v17) = v16;
  v19 = *(result + 24);
  if (*(result + 32) < v19)
  {
    v5 = 4;
  }

  if (*(result + 40) < *(result + 8 * v5))
  {
    v5 = 5;
  }

  if (*(result + 48) < *(result + 8 * v5))
  {
    v5 = 6;
  }

  if (*(result + 56) < *(result + 8 * v5))
  {
    v5 = 7;
  }

  if (*(result + 64) < *(result + 8 * v5))
  {
    v5 = 8;
  }

  v20 = *(result + 8 * v5);
  *(result + 8 * v5) = v19;
  v21 = *(result + 32);
  if (*(result + 40) < v21)
  {
    v6 = 5;
  }

  if (*(result + 48) < *(result + 8 * v6))
  {
    v6 = 6;
  }

  if (*(result + 56) < *(result + 8 * v6))
  {
    v6 = 7;
  }

  if (*(result + 64) < *(result + 8 * v6))
  {
    v6 = 8;
  }

  v22 = *(result + 8 * v6);
  *(result + 8 * v6) = v21;
  v23 = *(result + 40);
  if (*(result + 48) < v23)
  {
    v7 = 6;
  }

  if (*(result + 56) < *(result + 8 * v7))
  {
    v7 = 7;
  }

  if (*(result + 64) < *(result + 8 * v7))
  {
    v7 = 8;
  }

  v24 = *(result + 8 * v7);
  *(result + 16) = v18;
  *(result + 24) = v20;
  *(result + 8 * v7) = v23;
  *(result + 32) = v22;
  *(result + 40) = v24;
  v25 = *(result + 48);
  if (*(result + 56) < v25)
  {
    v9 = 7;
  }

  if (*(result + 64) < *(result + 8 * v9))
  {
    v9 = 8;
  }

  v26 = *(result + 8 * v9);
  *(result + 8 * v9) = v25;
  v27 = *(result + 56);
  v28 = 56;
  if (*(result + 64) < v27)
  {
    v28 = 64;
  }

  v29 = *(result + v28);
  *(result + v28) = v27;
  *(result + 48) = v26;
  *(result + 56) = v29;
  return result;
}

uint64_t MatrixNxPts<9u,double>::~MatrixNxPts(uint64_t result)
{
  *result = off_285231258;
  v1 = *(result + 8);
  if (v1 && *(result + 24) == 1)
  {
    v2 = result;
    MEMORY[0x245CBFC90](v1, 0x1000C8000313F17);
    result = v2;
    *(v2 + 8) = 0;
    *(v2 + 32) = 0;
    *(v2 + 24) = 0;
  }

  *(result + 16) = 0;
  return result;
}

{
  *result = off_285231258;
  v1 = *(result + 8);
  if (v1 && *(result + 24) == 1)
  {
    v2 = result;
    MEMORY[0x245CBFC90](v1, 0x1000C8000313F17);
    result = v2;
    *(v2 + 8) = 0;
    *(v2 + 32) = 0;
    *(v2 + 24) = 0;
  }

  *(result + 16) = 0;
  return result;
}

uint64_t MatrixMxN<3u,3u,double>::operator*(uint64_t result, uint64_t a2, uint64_t a3)
{
  v3 = result;
  if (*(a3 + 16) == 3)
  {
    v4 = *(a3 + 20);
    *result = off_285231258;
    if (v4)
    {
      operator new[]();
    }

    result = 0;
    *(v3 + 8) = 0;
    *(v3 + 16) = 3;
    *(v3 + 20) = 0;
    *(v3 + 24) = 0;
    *(v3 + 32) = 24 * v4;
  }

  else
  {
    *(result + 32) = 0;
    *(result + 8) = 0;
    *(result + 16) = 0;
    *result = off_285231258;
    *(result + 24) = 0;
  }

  return result;
}

void MatrixNxPts<9u,double>::~MatrixNxPts(uint64_t a1)
{
  *a1 = off_285231258;
  v2 = *(a1 + 8);
  if (v2 && *(a1 + 24) == 1)
  {
    v3 = a1;
    MEMORY[0x245CBFC90](v2, 0x1000C8000313F17);
    a1 = v3;
    *(v3 + 8) = 0;
    *(v3 + 32) = 0;
    *(v3 + 24) = 0;
  }

  *(a1 + 16) = 0;

  JUMPOUT(0x245CBFCB0);
}

uint64_t Algo::RandomSample(unsigned int a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a3 + 20);
  if (v3)
  {
    v4 = 0;
    v5 = a1;
    v6 = a2 + 8;
    v7 = *(a2 + 2504);
    do
    {
      v8 = (v7 + 1) % 0x270;
      v9 = *(v6 + 4 * v8);
      v10 = v9 & 0x7FFFFFFE | *(v6 + 4 * v7) & 0x80000000;
      if (v9)
      {
        v11 = -1727483681;
      }

      else
      {
        v11 = 0;
      }

      v12 = v11 ^ *(v6 + 4 * ((v7 + 397) % 0x270)) ^ (v10 >> 1);
      *(v6 + 4 * v7) = v12;
      *(a2 + 2504) = v8;
      v13 = ((v12 ^ (v12 >> 11)) << 7) & 0x9D2C5680 ^ v12 ^ (v12 >> 11);
      v14 = ((vcvts_n_f32_u32((v13 << 15) & 0xEFC60000 ^ v13 ^ (((v13 << 15) & 0xEFC60000 ^ v13) >> 18), 0x20uLL) + 0.0) * v5);
      if (v4)
      {
        v15 = 0;
        v16 = *(a3 + 8);
        while (*(v16 + 4 * v15) != v14)
        {
          if (v4 == ++v15)
          {
            goto LABEL_3;
          }
        }
      }

      else
      {
        LODWORD(v15) = 0;
      }

      if (v15 == v4)
      {
        v16 = *(a3 + 8);
LABEL_3:
        *(v16 + 4 * v4++) = v14;
      }

      v7 = v8;
    }

    while (v4 < v3);
  }

  return 0;
}

uint64_t Algo::FundDist(uint64_t (***a1)(), uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5, double a6)
{
  v11 = *(a2 + 20);
  v129 = off_285231258;
  if (v11)
  {
    operator new[]();
  }

  v131 = 1;
  v132 = 0;
  v133 = 0;
  v134 = 0;
  v129 = &unk_285231338;
  v130 = 0;
  MatrixMxN<3u,3u,double>::operator*(&v108, a1, a2);
  v124 = v109;
  v126 = HIDWORD(v110);
  v127 = v111;
  v128 = v112;
  v12 = a1[1];
  v13 = a1[2];
  v14 = a1[3];
  v108 = *a1;
  v109 = v14;
  v15 = a1[4];
  v16 = a1[5];
  v114 = v13;
  v115 = v16;
  v17 = a1[7];
  v110 = a1[6];
  v111 = v12;
  v123 = &unk_2852312D8;
  v125 = 3;
  v112 = v15;
  v113 = v17;
  v116 = a1[8];
  MatrixMxN<3u,3u,double>::operator*(&v135, &v108, a3);
  v18 = v136;
  v19 = v138;
  v119 = 3;
  v120 = v138;
  v121 = v139;
  v122 = v140;
  v117 = &unk_2852312D8;
  v118 = v136;
  v20 = v125 * v126;
  if (v20)
  {
    v21 = v124;
    v22 = v124 + 8 * v20;
    if (v22 <= v124 + 8)
    {
      v22 = v124 + 8;
    }

    v23 = v22 + ~v124;
    v24 = v124;
    if (v23 >= 0x18)
    {
      v25 = (v23 >> 3) + 1;
      v26 = (v124 + 16);
      v27 = v25 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v28 = vmulq_f64(*v26, *v26);
        v26[-1] = vmulq_f64(v26[-1], v26[-1]);
        *v26 = v28;
        v26 += 2;
        v27 -= 4;
      }

      while (v27);
      if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL))
      {
        goto LABEL_13;
      }

      v24 = (v21 + 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL));
    }

    v29 = v21 + 8 * v20;
    do
    {
      *v24 = *v24 * *v24;
      ++v24;
    }

    while (v24 < v29);
LABEL_13:
    v18 = v118;
  }

  if (!v19)
  {
    goto LABEL_24;
  }

  v30 = (3 * v19);
  v31 = &v18->f64[v30];
  if (v31 <= &v18->f64[1])
  {
    v31 = &v18->f64[1];
  }

  v32 = v31 + ~v18;
  v33 = v18;
  if (v32 < 0x18)
  {
    goto LABEL_22;
  }

  v34 = (v32 >> 3) + 1;
  v35 = v18 + 1;
  v36 = v34 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v37 = vmulq_f64(*v35, *v35);
    v35[-1] = vmulq_f64(v35[-1], v35[-1]);
    *v35 = v37;
    v35 += 2;
    v36 -= 4;
  }

  while (v36);
  if (v34 != (v34 & 0x3FFFFFFFFFFFFFFCLL))
  {
    v33 = &v18->f64[v34 & 0x3FFFFFFFFFFFFFFCLL];
LABEL_22:
    v38 = &v18->f64[v30];
    do
    {
      *v33 = *v33 * *v33;
      ++v33;
    }

    while (v33 < v38);
  }

LABEL_24:
  v39 = v132;
  v108 = off_285231258;
  if (v131 * v132)
  {
    operator new[]();
  }

  v40 = 8 * v132;
  v139 = 0;
  v140 = v40 * v131;
  v135 = &unk_285231338;
  v136 = 0;
  v137 = 1;
  v138 = v132;
  v41 = v124;
  v42 = v126;
  v43 = 8 * v126;
  LODWORD(v110) = 1;
  HIDWORD(v110) = v126;
  LOBYTE(v111) = 0;
  v112 = v43;
  v108 = &unk_285231338;
  v109 = v124;
  if (v126)
  {
    v44 = v124 + v43;
    v45 = (v43 + v124);
    if (v43 + v124 <= v124 + 8)
    {
      v45 = (v124 + 8);
    }

    v46 = v45 + ~v124;
    if (v46 >= 0x18)
    {
      v49 = (v46 >> 3) + 1;
      v50 = 8 * (v49 & 0x3FFFFFFFFFFFFFFCLL);
      v47 = (v44 + v50);
      v51 = v124;
      v52 = v49 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v53 = vaddq_f64(v51[1], *(v51 + v43 + 16));
        *v51 = vaddq_f64(*v51, *(v51 + v43));
        v51[1] = v53;
        v51 += 2;
        v52 -= 4;
      }

      while (v52);
      if (v49 == (v49 & 0x3FFFFFFFFFFFFFFCLL))
      {
        goto LABEL_37;
      }

      v41 = (v41 + v50);
    }

    else
    {
      v47 = (v124 + v43);
    }

    do
    {
      v54 = *v47++;
      *v41 = *v41 + v54;
      ++v41;
    }

    while (v41 < v44);
LABEL_37:
    v48 = v110 == 1;
    goto LABEL_38;
  }

  v48 = 1;
LABEL_38:
  v55 = v118;
  v56 = v120;
  if (v120 != v42 || !v48)
  {
    __assert_rtn("doDimensionsMatchTo", "Matrix.hpp", 1043, "0");
  }

  if (v42)
  {
    v57 = v109;
    v58 = 8 * v120 + v109;
    if (v58 <= v109 + 8)
    {
      v58 = v109 + 8;
    }

    v59 = v58 + ~v109;
    if (v59 >= 0x88)
    {
      v63 = (v59 & 0xFFFFFFFFFFFFFFF8) + 8;
      if (v109 >= v118 + v63 || (v64 = v109 + v63, v60 = v109, v118 >= v64))
      {
        v65 = (v59 >> 3) + 1;
        v66 = v65 & 0x3FFFFFFFFFFFFFFCLL;
        v67 = &v118->f64[v66];
        v68 = (v109 + 16);
        v69 = v118 + 1;
        v70 = v65 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v71 = vaddq_f64(*v68, *v69);
          v68[-1] = vaddq_f64(v68[-1], v69[-1]);
          *v68 = v71;
          v68 += 2;
          v69 += 2;
          v70 -= 4;
        }

        while (v70);
        if (v65 == (v65 & 0x3FFFFFFFFFFFFFFCLL))
        {
          goto LABEL_54;
        }

        v60 = (v57 + v66 * 8);
        v55 = v67;
      }
    }

    else
    {
      v60 = v109;
    }

    v72 = v57 + 8 * v56;
    do
    {
      v73 = *v55++;
      *v60 = *v60 + v73;
      ++v60;
    }

    while (v60 < v72);
LABEL_54:
    v55 = v118;
    v61 = v120;
    v62 = v110 == 1;
    goto LABEL_55;
  }

  v61 = 0;
  v62 = 1;
LABEL_55:
  v74 = v61;
  v75 = &v55[v74];
  if (v61 != v42 || !v62)
  {
    __assert_rtn("doDimensionsMatchTo", "Matrix.hpp", 1043, "0");
  }

  if (v42)
  {
    v76 = v109;
    v77 = v74 * 8 + v109;
    if (v74 * 8 + v109 <= v109 + 8)
    {
      v77 = v109 + 8;
    }

    v78 = v77 + ~v109;
    if (v78 < 0x98)
    {
      v79 = v109;
      goto LABEL_71;
    }

    v80 = &v55[v74];
    v81 = v109 >= &v55[v74 + 1] + (v78 & 0xFFFFFFFFFFFFFFF8) || v75 >= v109 + (v78 & 0xFFFFFFFFFFFFFFF8) + 8;
    v79 = v109;
    if (!v81)
    {
      goto LABEL_71;
    }

    v82 = (v78 >> 3) + 1;
    v83 = 8 * (v82 & 0x3FFFFFFFFFFFFFFCLL);
    v75 = (v75 + v83);
    v84 = (v109 + 16);
    v85 = v80 + 1;
    v86 = v82 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v87 = vaddq_f64(*v84, *v85);
      v84[-1] = vaddq_f64(v84[-1], v85[-1]);
      *v84 = v87;
      v84 += 2;
      v85 += 2;
      v86 -= 4;
    }

    while (v86);
    if (v82 != (v82 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v79 = (v76 + v83);
LABEL_71:
      v88 = v76 + 8 * v61;
      do
      {
        v89 = *v75++;
        *v79 = *v79 + v89;
        ++v79;
      }

      while (v79 < v88);
    }
  }

  if (v42 != v39)
  {
    __assert_rtn("doDimensionsMatchTo", "Matrix.hpp", 1043, "0");
  }

  if (!v39)
  {
    *a5 = 0;
    goto LABEL_95;
  }

  v90 = v136;
  v91 = v109;
  v92 = v136 + v40;
  if (v92 <= &v136->f64[1])
  {
    v92 = &v136->f64[1];
  }

  v93 = v92 + ~v136;
  if (v93 < 0x78)
  {
    v94 = v136;
    goto LABEL_89;
  }

  v95 = (v93 & 0xFFFFFFFFFFFFFFF8) + 8;
  v96 = v136 >= v109 + v95 || v109 >= v136 + v95;
  v94 = v136;
  if (!v96)
  {
    goto LABEL_89;
  }

  v97 = (v93 >> 3) + 1;
  v98 = v97 & 0x3FFFFFFFFFFFFFFCLL;
  v99 = (v109 + v98 * 8);
  v100 = v136 + 1;
  v101 = (v109 + 16);
  v102 = v97 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v103 = vdivq_f64(*v100, *v101);
    v100[-1] = vdivq_f64(v100[-1], v101[-1]);
    *v100 = v103;
    v100 += 2;
    v101 += 2;
    v102 -= 4;
  }

  while (v102);
  if (v97 != (v97 & 0x3FFFFFFFFFFFFFFCLL))
  {
    v94 = &v90->f64[v98];
    v91 = v99;
    do
    {
LABEL_89:
      v104 = *v91++;
      *v94 = *v94 / v104;
      ++v94;
    }

    while (v94 < &v90->f64[v39]);
  }

  v105 = 0;
  v106 = 0;
  *a5 = 0;
  do
  {
    if (fabs(v136->f64[v106]) < a6)
    {
      *(*(a4 + 8) + 4 * v105) = v106;
      v105 = *a5 + 1;
      *a5 = v105;
      LODWORD(v39) = v138;
    }

    ++v106;
  }

  while (v106 < v39);
  v135 = off_285231258;
LABEL_95:
  v117 = off_285231258;
  if (v118 && v121 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  v123 = off_285231258;
  if (v124 && v127 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  v129 = off_285231258;
  if (v130 && v133 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  return 0;
}

void sub_24031B6C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
  MatrixNxPts<3u,double>::~MatrixNxPts(&a24);
  MatrixNxPts<3u,double>::~MatrixNxPts(&a29);
  MatrixNxPts<1u,double>::~MatrixNxPts(v29 - 184);
  _Unwind_Resume(a1);
}

void sub_24031B984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  v10 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  MatrixNxPts<1u,BOOL>::~MatrixNxPts(va);
  MatrixNxPts<1u,BOOL>::~MatrixNxPts(va1);
  _Unwind_Resume(a1);
}

uint64_t Algo::Ransac(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6, int a7, double a8, uint64_t a9, uint64_t a10, unsigned int *a11)
{
  v15 = *(a1 + 20);
  v60 = &unk_285231298;
  v16 = 5489;
  v17 = 1;
  for (i = 3; i != 626; ++i)
  {
    v19 = 1812433253 * (v16 ^ (v16 >> 30));
    v16 = v19 + v17;
    *(&v60 + i) = i + v19 - 2;
    ++v17;
  }

  v61 = a6;
  v20 = 1;
  for (j = 3; j != 626; ++j)
  {
    v22 = 1812433253 * (a6 ^ (a6 >> 30));
    a6 = v22 + v20;
    *(&v60 + j) = j + v22 - 2;
    ++v20;
  }

  v23 = 0;
  v33 = 0;
  v62 = 0;
  *a11 = 0;
  v59 = 0;
  v58 = 0;
  v38 = 24 * a3;
  v32 = v15;
  v24 = 1.0;
  v37 = a3 != 0;
  do
  {
    if (v24 <= v23)
    {
      break;
    }

    v35 = v23;
    v57 = 0;
    v40 = 1;
    memset(v56, 0, sizeof(v56));
    do
    {
      v51 = off_285231218;
      if (a3)
      {
        operator new[]();
      }

      v53 = 1;
      v54 = v37;
      v55 = 0;
      v51 = &unk_285231318;
      __src = 0;
      if (!a7)
      {
        v47 = 3;
        v48 = 0;
        v49 = v37;
        v50 = v38;
        v46[0] = &unk_2852312D8;
        v46[1] = 0;
        v42 = 3;
        v43 = 0;
        v44 = v37;
        v45 = v38;
        v41[0] = &unk_2852312D8;
        v41[1] = 0;
        Algo::FundMatrix3x3(v46, v41);
      }

      ++v40;
    }

    while (v40 <= a4);
    v25 = *(a1 + 20);
    v51 = off_285231218;
    if (v25)
    {
      operator new[]();
    }

    v53 = 1;
    v54 = 0;
    v55 = 0;
    v51 = &unk_285231318;
    __src = 0;
    LODWORD(v46[0]) = 0;
    Algo::FundDist(v56, a1, a2, &v51, v46, a8);
    v26 = v46[0];
    if (LODWORD(v46[0]) > *a11)
    {
      v27 = HIDWORD(v53);
      v28 = 4 * v53 * HIDWORD(v53);
      v29 = *(a10 + 8);
      if (*(a10 + 32) < v28)
      {
        if (v29)
        {
          if (*(a10 + 24) == 1)
          {
            MEMORY[0x245CBFC90]();
          }
        }

        operator new[]();
      }

      *(a10 + 16) = v53;
      *(a10 + 20) = v27;
      memcpy(v29, __src, v28);
      *a11 = v26;
      v30 = pow(v26 / v32, 0);
      v33 = 1;
      v24 = -6.90775528 / log(fmin(fmax(1.0 - v30, 2.22044605e-16), 1.0));
    }

    v51 = off_285231218;
    if (__src && v54)
    {
      MEMORY[0x245CBFC90]();
    }

    v23 = v35 + 1;
  }

  while (v35 + 1 <= a5);
  return (v33 & 1u) - 1;
}

uint64_t MatrixNxPts<1u,BOOL>::~MatrixNxPts(uint64_t result)
{
  *result = &unk_285231278;
  v1 = *(result + 8);
  if (v1 && *(result + 24) == 1)
  {
    v2 = result;
    MEMORY[0x245CBFC90](v1, 0x1000C8077774924);
    result = v2;
    *(v2 + 8) = 0;
    *(v2 + 32) = 0;
    *(v2 + 24) = 0;
  }

  *(result + 16) = 0;
  return result;
}

uint64_t MatrixNxPts<1u,unsigned int>::~MatrixNxPts(uint64_t result)
{
  *result = off_285231218;
  v1 = *(result + 8);
  if (v1 && *(result + 24) == 1)
  {
    v2 = result;
    MEMORY[0x245CBFC90](v1, 0x1000C8052888210);
    result = v2;
    *(v2 + 8) = 0;
    *(v2 + 32) = 0;
    *(v2 + 24) = 0;
  }

  *(result + 16) = 0;
  return result;
}

void MatrixNxPts<1u,unsigned int>::~MatrixNxPts(uint64_t a1)
{
  *a1 = off_285231218;
  v2 = *(a1 + 8);
  if (v2 && *(a1 + 24) == 1)
  {
    v3 = a1;
    MEMORY[0x245CBFC90](v2, 0x1000C8052888210);
    a1 = v3;
    *(v3 + 8) = 0;
    *(v3 + 32) = 0;
    *(v3 + 24) = 0;
  }

  *(a1 + 16) = 0;

  JUMPOUT(0x245CBFCB0);
}

void Matrix<unsigned int>::~Matrix(uint64_t a1)
{
  *a1 = off_285231218;
  v2 = *(a1 + 8);
  if (v2 && *(a1 + 24) == 1)
  {
    v3 = a1;
    MEMORY[0x245CBFC90](v2, 0x1000C8052888210);
    a1 = v3;
    *(v3 + 8) = 0;
    *(v3 + 32) = 0;
    *(v3 + 24) = 0;
  }

  *(a1 + 16) = 0;

  JUMPOUT(0x245CBFCB0);
}

uint64_t Matrix<unsigned int>::~Matrix(uint64_t result)
{
  *result = off_285231218;
  v1 = *(result + 8);
  if (v1 && *(result + 24) == 1)
  {
    v2 = result;
    MEMORY[0x245CBFC90](v1, 0x1000C8052888210);
    result = v2;
    *(v2 + 8) = 0;
    *(v2 + 32) = 0;
    *(v2 + 24) = 0;
  }

  *(result + 16) = 0;
  return result;
}

void MatrixNxPts<1u,BOOL>::~MatrixNxPts(uint64_t a1)
{
  *a1 = &unk_285231278;
  v2 = *(a1 + 8);
  if (v2 && *(a1 + 24) == 1)
  {
    v3 = a1;
    MEMORY[0x245CBFC90](v2, 0x1000C8077774924);
    a1 = v3;
    *(v3 + 8) = 0;
    *(v3 + 32) = 0;
    *(v3 + 24) = 0;
  }

  *(a1 + 16) = 0;

  JUMPOUT(0x245CBFCB0);
}

uint64_t Algo::RansacHomography(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, _DWORD *a8, _DWORD *a9)
{
  *a8 = 0;
  v17 = &unk_285231298;
  v9 = 5489;
  v10 = 1;
  for (i = 3; i != 626; ++i)
  {
    v12 = 1812433253 * (v9 ^ (v9 >> 30));
    v9 = v12 + v10;
    *(&v17 + i) = i + v12 - 2;
    ++v10;
  }

  v18 = a6;
  v13 = 1;
  for (j = 3; j != 626; ++j)
  {
    v15 = 1812433253 * (a6 ^ (a6 >> 30));
    a6 = v15 + v13;
    *(&v17 + j) = j + v15 - 2;
    ++v13;
  }

  v19 = 0;
  if (0 < 1.0)
  {
    operator new[]();
  }

  if (a9)
  {
    *a9 = -1;
  }

  return 0xFFFFFFFFLL;
}

void sub_24031D64C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, char a59)
{
  MatrixNxPts<1u,unsigned int>::~MatrixNxPts(v59 - 192);
  if (a57)
  {
    if (a59 == 1)
    {
      MEMORY[0x245CBFC90]();
    }
  }

  _Unwind_Resume(a1);
}

uint64_t Algo::RansacPlane(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, _DWORD *a7, _DWORD *a8)
{
  v19 = *MEMORY[0x277D85DE8];
  *a7 = 0;
  v16 = &unk_285231298;
  v8 = 5489;
  v9 = 1;
  for (i = 3; i != 626; ++i)
  {
    v11 = 1812433253 * (v8 ^ (v8 >> 30));
    v8 = v11 + v9;
    *(&v16 + i) = i + v11 - 2;
    ++v9;
  }

  v17 = a5;
  v12 = 1;
  for (j = 3; j != 626; ++j)
  {
    v14 = 1812433253 * (a5 ^ (a5 >> 30));
    a5 = v14 + v12;
    *(&v16 + j) = j + v14 - 2;
    ++v12;
  }

  v18 = 0;
  if (0 < 1.0)
  {
    operator new[]();
  }

  if (a8)
  {
    *a8 = -1;
  }

  return 0xFFFFFFFFLL;
}

void sub_24031EAD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, unint64_t a19, unint64_t a20, unint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, char a60, uint64_t a61, uint64_t a62, uint64_t a63)
{
  if (a58 && a60 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  STACK[0xC18] = a19;
  if (STACK[0xC20] && LOBYTE(STACK[0xC30]) == 1)
  {
    MEMORY[0x245CBFC90]();
    STACK[0xC20] = 0;
    STACK[0xC38] = 0;
    LOBYTE(STACK[0xC30]) = 0;
  }

  STACK[0xC28] = 0;
  STACK[0xBF0] = a20;
  if (STACK[0xBF8] && LOBYTE(STACK[0xC08]) == 1)
  {
    MEMORY[0x245CBFC90]();
    STACK[0xBF8] = 0;
    STACK[0xC10] = 0;
    LOBYTE(STACK[0xC08]) = 0;
  }

  STACK[0xC00] = 0;
  STACK[0xBC8] = a21;
  if (STACK[0xBD0] && LOBYTE(STACK[0xBE0]) == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  if (a63 && a65 == 1)
  {
    MEMORY[0x245CBFC90]();
  }

  if (a68)
  {
    if (a70 == 1)
    {
      MEMORY[0x245CBFC90]();
    }
  }

  _Unwind_Resume(a1);
}

double Algo::Mean(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 16);
  if (v4 == 1)
  {
    if (*(a2 + 32) <= 7uLL)
    {
      if (*(a2 + 8) && *(a2 + 24) == 1)
      {
        MEMORY[0x245CBFC90]();
      }

      operator new[]();
    }

    *(a2 + 16) = 0x100000001;
    v15 = *(a1 + 20) * *(a1 + 16);
    v16 = v15;
    if (v15 < 1)
    {
      v21 = 0.0;
    }

    else
    {
      v17 = *(a1 + 8);
      v18 = v17 + 8 * v15;
      v19 = (v17 + 8);
      if (v18 <= v17 + 8)
      {
        v18 = v17 + 8;
      }

      v20 = v18 + ~v17;
      if (v20 >= 8)
      {
        v34 = (v20 >> 3) + 1;
        v21 = 0.0;
        v35 = v34 & 0x3FFFFFFFFFFFFFFELL;
        do
        {
          v21 = v21 + *(v19 - 1) + *v19;
          v19 += 2;
          v35 -= 2;
        }

        while (v35);
        if (v34 == (v34 & 0x3FFFFFFFFFFFFFFELL))
        {
          goto LABEL_47;
        }

        v22 = (v17 + 8 * (v34 & 0x3FFFFFFFFFFFFFFELL));
      }

      else
      {
        v21 = 0.0;
        v22 = *(a1 + 8);
      }

      v36 = v17 + 8 * v15;
      do
      {
        v37 = *v22++;
        v21 = v21 + v37;
      }

      while (v22 < v36);
    }

LABEL_47:
    result = v21 / v16;
    **(a2 + 8) = result;
    return result;
  }

  if (!v4)
  {
    __assert_rtn("Mean", "Algo.cpp", 1452, "rows > 0");
  }

  v5 = *(a1 + 20);
  v6 = *(a2 + 8);
  if (*(a2 + 32) < (8 * v5))
  {
    if (v6)
    {
      if (*(a2 + 24) == 1)
      {
        MEMORY[0x245CBFC90]();
      }
    }

    operator new[]();
  }

  *(a2 + 16) = 1;
  *(a2 + 20) = v5;
  bzero(v6, 8 * v5);
  if (v5)
  {
    v8 = 0;
    v9 = *(a1 + 16);
    do
    {
      if (v8 == v9)
      {
LABEL_50:
        __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
      }

      v10 = 0;
      v11 = *(a1 + 20);
      do
      {
        if (v11 == v10)
        {
          goto LABEL_50;
        }

        v12 = *(a2 + 16);
        if (!v12 || (v13 = *(a2 + 20), v10 >= v13))
        {
          __assert_rtn("operator()", "Matrix.hpp", 120, "row < m_rows && col < m_cols");
        }

        v14 = *(a2 + 8);
        result = *(*(a1 + 8) + 8 * (v11 * v8) + 8 * v10) + *(v14 + 8 * v10);
        *(v14 + 8 * v10++) = result;
      }

      while (v5 != v10);
      ++v8;
    }

    while (v8 != v4);
  }

  else
  {
    v12 = *(a2 + 16);
    LODWORD(v13) = *(a2 + 20);
  }

  v23 = v13 * v12;
  if (v13 * v12 >= 1)
  {
    result = v4;
    v24 = *(a2 + 8);
    v25 = &v24->f64[v23];
    if (v25 <= &v24->f64[1])
    {
      v25 = &v24->f64[1];
    }

    v26 = v25 + ~v24;
    v27 = *(a2 + 8);
    if (v26 < 0x18)
    {
      goto LABEL_37;
    }

    v28 = (v26 >> 3) + 1;
    v29 = vdupq_lane_s64(*&result, 0);
    v30 = v24 + 1;
    v31 = v28 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v32 = vdivq_f64(*v30, v29);
      v30[-1] = vdivq_f64(v30[-1], v29);
      *v30 = v32;
      v30 += 2;
      v31 -= 4;
    }

    while (v31);
    if (v28 != (v28 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v27 = &v24->f64[v28 & 0x3FFFFFFFFFFFFFFCLL];
LABEL_37:
      v33 = &v24->f64[v23];
      do
      {
        *v27 = *v27 / result;
        ++v27;
      }

      while (v27 < v33);
    }
  }

  return result;
}

uint64_t Algo::Gcd(uint64_t this, uint64_t a2)
{
  if (a2)
  {
    do
    {
      v2 = a2;
      a2 = this % a2;
      LODWORD(this) = v2;
    }

    while (a2);
    return v2;
  }

  return this;
}

uint64_t Algo::Lcm(Algo *this, unsigned int a2)
{
  v2 = this;
  if (a2)
  {
    v3 = a2;
    v4 = this;
    do
    {
      v2 = v3;
      v3 = v4 % v3;
      v4 = v2;
    }

    while (v3);
  }

  return this / v2 * a2;
}

void jpc::PORGMCJ_OutputValidation_Block::process(uint64_t a1, uint64_t a2, void *a3, id *a4, void *a5)
{
  v10[96] = *MEMORY[0x277D85DE8];
  v8 = a5;
  jpc::GMC_StandaloneUtils::convertJpcCorrespondencesToGmcStandaloneDatatypes(a3, a3 + 3, v10);
  jpc::GMC_StandaloneUtils::generateGmcParams(a1 + 8, a4, (0xAAAAAAAAAAAAAAABLL * ((a3[4] - a3[3]) >> 4) + 0x6DB6DB6DB6DB6DB7 * ((a3[1] - *a3) >> 3)), v9);
}

void sub_24031F578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, char a50)
{
  jpc::JPCException::~JPCException(&a9);
  _GMC_Params::~_GMC_Params(&a50);
  std::tuple<MatrixNxPts<2u,double>,MatrixNxPts<2u,double>,MatrixNxPts<1u,double>>::~tuple(&STACK[0x548]);

  _Unwind_Resume(a1);
}

uint64_t jpc::JPCException::JPCException(uint64_t a1, uint64_t a2)
{
  *a1 = &unk_285231B08;
  if (*(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 8), *(a2 + 8), *(a2 + 16));
  }

  else
  {
    v4 = *(a2 + 8);
    *(a1 + 24) = *(a2 + 24);
    *(a1 + 8) = v4;
  }

  if (*(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 32), *(a2 + 32), *(a2 + 40));
  }

  else
  {
    v5 = *(a2 + 32);
    *(a1 + 48) = *(a2 + 48);
    *(a1 + 32) = v5;
  }

  if (*(a2 + 79) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 56), *(a2 + 56), *(a2 + 64));
  }

  else
  {
    v6 = *(a2 + 56);
    *(a1 + 72) = *(a2 + 72);
    *(a1 + 56) = v6;
  }

  v7 = *(a2 + 80);
  *(a1 + 88) = *(a2 + 88);
  *(a1 + 80) = v7;
  v8 = *(a2 + 104);
  *(a1 + 96) = *(a2 + 96);
  *(a1 + 104) = v8;
  if (v8)
  {
    atomic_fetch_add_explicit((v8 + 8), 1uLL, memory_order_relaxed);
  }

  v9 = *(a2 + 120);
  *(a1 + 112) = *(a2 + 112);
  *(a1 + 120) = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((v9 + 8), 1uLL, memory_order_relaxed);
  }

  return a1;
}

void sub_24031F7F8(_Unwind_Exception *a1)
{
  if (*(v1 + 55) < 0)
  {
    operator delete(*(v1 + 32));
  }

  if (*(v1 + 31) < 0)
  {
    operator delete(*v2);
  }

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void jpc::JPCException::~JPCException(std::exception *this)
{
  this->__vftable = &unk_285231B08;
  v2 = this[15].__vftable;
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    (v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  v3 = this[13].__vftable;
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    (v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if ((SHIBYTE(this[9].__vftable) & 0x80000000) == 0)
    {
LABEL_7:
      if ((SHIBYTE(this[6].__vftable) & 0x80000000) == 0)
      {
        goto LABEL_8;
      }

LABEL_14:
      operator delete(this[4].__vftable);
      if ((SHIBYTE(this[3].__vftable) & 0x80000000) == 0)
      {
        goto LABEL_9;
      }

      goto LABEL_15;
    }
  }

  else if ((SHIBYTE(this[9].__vftable) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  operator delete(this[7].__vftable);
  if (SHIBYTE(this[6].__vftable) < 0)
  {
    goto LABEL_14;
  }

LABEL_8:
  if ((SHIBYTE(this[3].__vftable) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }

LABEL_15:
  operator delete(this[1].__vftable);
LABEL_9:

  std::exception::~exception(this);
}

{
  jpc::JPCException::~JPCException(this);

  JUMPOUT(0x245CBFCB0);
}

void jpc::GMCJOutputValidationNotPassedException::GMCJOutputValidationNotPassedException(jpc::GMCJOutputValidationNotPassedException *this)
{
  *(this + 72) = 0u;
  *(this + 56) = 0u;
  *(this + 40) = 0u;
  *(this + 24) = 0u;
  *(this + 8) = 0u;
  *(this + 22) = 0x1000000;
  *(this + 6) = 0u;
  *(this + 7) = 0u;
  *this = &unk_285231450;
  operator new();
}

void _GMC_Params::_calib::_cam::_distLUT::_nonradial::~_nonradial(_GMC_Params::_calib::_cam::_distLUT::_nonradial *this)
{
  *(this + 15) = off_285231258;
  if (*(this + 16) && *(this + 144) == 1)
  {
    MEMORY[0x245CBFC90]();
    *(this + 16) = 0;
    *(this + 19) = 0;
    *(this + 144) = 0;
  }

  *(this + 17) = 0;
  *(this + 10) = off_285231258;
  if (*(this + 11) && *(this + 104) == 1)
  {
    MEMORY[0x245CBFC90]();
    *(this + 11) = 0;
    *(this + 14) = 0;
    *(this + 104) = 0;
  }

  *(this + 12) = 0;
  *(this + 5) = off_285231258;
  if (*(this + 6) && *(this + 64) == 1)
  {
    MEMORY[0x245CBFC90]();
    *(this + 6) = 0;
    *(this + 9) = 0;
    *(this + 64) = 0;
  }

  *(this + 7) = 0;
  *this = off_285231258;
  if (*(this + 1) && *(this + 24) == 1)
  {
    MEMORY[0x245CBFC90]();
    *(this + 1) = 0;
    *(this + 4) = 0;
    *(this + 24) = 0;
  }

  *(this + 2) = 0;
}

void _GMC_Params::~_GMC_Params(_GMC_Params *this)
{
  _GMC_Params::_calib::_cam::_distLUT::_nonradial::~_nonradial((this + 864));
  *(this + 103) = off_285231258;
  if (*(this + 104) && *(this + 848) == 1)
  {
    MEMORY[0x245CBFC90]();
    *(this + 104) = 0;
    *(this + 107) = 0;
    *(this + 848) = 0;
  }

  *(this + 105) = 0;
  _GMC_Params::_calib::_cam::_distLUT::_nonradial::~_nonradial((this + 168));
  *(this + 16) = off_285231258;
  if (*(this + 17) && *(this + 152) == 1)
  {
    MEMORY[0x245CBFC90]();
    *(this + 17) = 0;
    *(this + 20) = 0;
    *(this + 152) = 0;
  }

  *(this + 18) = 0;
}

uint64_t std::tuple<MatrixNxPts<2u,double>,MatrixNxPts<2u,double>,MatrixNxPts<1u,double>>::~tuple(uint64_t a1)
{
  *(a1 + 80) = off_285231258;
  if (*(a1 + 88) && *(a1 + 104) == 1)
  {
    MEMORY[0x245CBFC90]();
    *(a1 + 88) = 0;
    *(a1 + 112) = 0;
    *(a1 + 104) = 0;
  }

  *(a1 + 96) = 0;
  *(a1 + 40) = off_285231258;
  if (*(a1 + 48) && *(a1 + 64) == 1)
  {
    MEMORY[0x245CBFC90]();
    *(a1 + 48) = 0;
    *(a1 + 72) = 0;
    *(a1 + 64) = 0;
  }

  *(a1 + 56) = 0;
  *a1 = off_285231258;
  if (*(a1 + 8) && *(a1 + 24) == 1)
  {
    MEMORY[0x245CBFC90]();
    *(a1 + 8) = 0;
    *(a1 + 32) = 0;
    *(a1 + 24) = 0;
  }

  *(a1 + 16) = 0;
  return a1;
}

void jpc::GMCJOutputValidationNotPassedException::~GMCJOutputValidationNotPassedException(std::exception *this)
{
  jpc::JPCException::~JPCException(this);

  JUMPOUT(0x245CBFCB0);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  if (__sz > 0x16)
  {
    if (__sz < 0x7FFFFFFFFFFFFFF8)
    {
      operator new();
    }

    std::string::__throw_length_error[abi:ne200100]();
  }

  *(&this->__r_.__value_.__s + 23) = __sz;
  v3 = __sz + 1;

  memmove(this, __s, v3);
}

void jpc::GMCJOutputValidationMetricIncreasedException::~GMCJOutputValidationMetricIncreasedException(std::exception *this)
{
  jpc::JPCException::~JPCException(this);

  JUMPOUT(0x245CBFCB0);
}

__n128 jpc::PORGMCJ_OutputValidation_Block::PORGMCJ_OutputValidation_Block(uint64_t a1, __int128 *a2)
{
  *a1 = &unk_285231400;
  v2 = *a2;
  v3 = a2[1];
  *(a1 + 40) = a2[2];
  *(a1 + 24) = v3;
  *(a1 + 8) = v2;
  v4 = a2[3];
  v5 = a2[4];
  v6 = a2[5];
  *(a1 + 104) = a2[6];
  *(a1 + 88) = v6;
  *(a1 + 72) = v5;
  *(a1 + 56) = v4;
  v7 = a2[7];
  v8 = a2[8];
  v9 = a2[9];
  *(a1 + 168) = *(a2 + 20);
  *(a1 + 152) = v9;
  *(a1 + 136) = v8;
  *(a1 + 120) = v7;
  v10 = *(a2 + 168);
  *(a1 + 192) = *(a2 + 23);
  *(a1 + 176) = v10;
  result = a2[12];
  v12 = a2[13];
  v13 = a2[14];
  *(a1 + 241) = *(a2 + 233);
  *(a1 + 232) = v13;
  *(a1 + 216) = v12;
  *(a1 + 200) = result;
  return result;
}

{
  *a1 = &unk_285231400;
  v2 = *a2;
  v3 = a2[1];
  *(a1 + 40) = a2[2];
  *(a1 + 24) = v3;
  *(a1 + 8) = v2;
  v4 = a2[3];
  v5 = a2[4];
  v6 = a2[5];
  *(a1 + 104) = a2[6];
  *(a1 + 88) = v6;
  *(a1 + 72) = v5;
  *(a1 + 56) = v4;
  v7 = a2[7];
  v8 = a2[8];
  v9 = a2[9];
  *(a1 + 168) = *(a2 + 20);
  *(a1 + 152) = v9;
  *(a1 + 136) = v8;
  *(a1 + 120) = v7;
  v10 = *(a2 + 168);
  *(a1 + 192) = *(a2 + 23);
  *(a1 + 176) = v10;
  result = a2[12];
  v12 = a2[13];
  v13 = a2[14];
  *(a1 + 241) = *(a2 + 233);
  *(a1 + 232) = v13;
  *(a1 + 216) = v12;
  *(a1 + 200) = result;
  return result;
}

void jpc::PORGMCJ_OutputValidation_Block::fillTelemetryData(uint64_t a1, double *a2, uint64_t a3, void *a4)
{
  v6 = a4;
  [v6 setGmcjOutputValidationErrorCode:a3];
  [v6 setIsAssignedGMCJValidation:1];
  [v6 setReprojectionErrorBefore:a2[46]];
  [v6 setReprojectionErrorAfter:a2[50]];
  [v6 setJasperMisalignmentBefore:a2[40]];
  [v6 setJasperMisalignmentAfter:a2[42]];
}

void sub_240320414(_Unwind_Exception *a1)
{
  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_2403209C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard(va);
  _Unwind_Resume(a1);
}

void InstrumentsTraceGuard::~InstrumentsTraceGuard(InstrumentsTraceGuard *this)
{
  kdebug_trace();
}

{
  kdebug_trace();
}

void sub_240320AE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard(va);
  _Unwind_Resume(a1);
}

void sub_240321450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  if (v31 < 0)
  {
    operator delete(v30);
  }

  InstrumentsTraceGuard::~InstrumentsTraceGuard(&a16);

  _Unwind_Resume(a1);
}

void filterDepthAndUncertainty<float,float,false>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  v72 = a5;
  v19 = a6;
  v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  v22 = v21;

  v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  v25 = v24;

  v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  v28 = v27;

  v29 = [v19 pipelineParameters];
  v30 = [v29 outputHighConfidencePixelsOnly];

  if (v72)
  {
    v31 = 0;
    v32 = 0;
    while (1)
    {
      v33 = [v72 length];
      v34 = v31 >= v33;
      if (v31 >= v33)
      {
        break;
      }

      if (*([v72 confidences] + 4 * v31) > 0.0)
      {
        v35 = [v19 pipelineParameters];
        v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          v34 = 0;
          break;
        }
      }

      ++v31;
    }
  }

  else
  {
    v34 = 1;
  }

  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4)
  {
    CVPixelBufferLockBaseAddress(a4, 0);
  }

  memset(&v76, 0, sizeof(v76));
  v37 = MEMORY[0x277CBF3A0];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x277CBF3A0], &v76);
  memset(&v75, 0, sizeof(v75));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v75);
  memset(&v74, 0, sizeof(v74));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v74);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v73);
    data = v73.data;
    rowBytes = v73.rowBytes;
    if (a10 <= 0.0)
    {
      goto LABEL_77;
    }
  }

  else
  {
    rowBytes = 0;
    data = 0;
    if (a10 <= 0.0)
    {
      goto LABEL_77;
    }
  }

  if (a9 > 0.0)
  {
    v40 = v75.rowBytes;
    v41 = v76.rowBytes;
    v42 = 4 * a7;
    v43 = v76.data + v76.rowBytes * a8 + v42;
    v44 = v75.data + v75.rowBytes * a8 + v42;
    v45 = v74.data;
    v46 = v74.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if ((v30 & (v22 <= 10.0)) != 0)
        {
          v47 = 0;
          do
          {
            v48 = 0;
            do
            {
              *&v45[4 * v48] = 2143289344;
              *&data[4 * v48++] = 1092616192;
            }

            while (a9 > v48);
            ++v47;
            data += rowBytes;
            v45 += v46;
          }

          while (a10 > v47);
        }

        else
        {
          v68 = 0;
          do
          {
            v69 = 0;
            do
            {
              *&v45[4 * v69] = *&v43[4 * v69];
              *&data[4 * v69++] = 1092616192;
            }

            while (a9 > v69);
            ++v68;
            data += rowBytes;
            v45 += v46;
            v43 += v41;
          }

          while (a10 > v68);
        }
      }

      else
      {
        v53 = 0;
        if (v30)
        {
          do
          {
            v54 = 0;
            do
            {
              v55 = *&v43[4 * v54];
              v56 = *&v44[4 * v54];
              if (v55 < v28 || v55 > v25)
              {
                v56 = 10.0;
              }

              if (v56 >= v22)
              {
                v55 = NAN;
              }

              *&v45[4 * v54] = v55;
              *&data[4 * v54++] = v56;
            }

            while (a9 > v54);
            ++v53;
            data += rowBytes;
            v45 += v46;
            v44 += v40;
            v43 += v41;
          }

          while (a10 > v53);
        }

        else
        {
          do
          {
            v58 = 0;
            do
            {
              v59 = *&v43[4 * v58];
              v60 = *&v44[4 * v58];
              if (v59 < v28 || v59 > v25)
              {
                v60 = 10.0;
              }

              *&v45[4 * v58] = v59;
              *&data[4 * v58++] = v60;
            }

            while (a9 > v58);
            ++v53;
            data += rowBytes;
            v45 += v46;
            v44 += v40;
            v43 += v41;
          }

          while (a10 > v53);
        }
      }
    }

    else if (v34)
    {
      if ((v30 & (v22 <= 10.0)) != 0)
      {
        v49 = 0;
        do
        {
          v50 = v45;
          v51 = 1;
          do
          {
            *v50++ = 2143289344;
            v52 = v51++;
          }

          while (a9 > v52);
          ++v49;
          v45 += v46;
        }

        while (a10 > v49);
      }

      else
      {
        v70 = 0;
        do
        {
          v71 = 0;
          do
          {
            *&v45[4 * v71] = *&v43[4 * v71];
            ++v71;
          }

          while (a9 > v71);
          ++v70;
          v45 += v46;
          v43 += v41;
        }

        while (a10 > v70);
      }
    }

    else
    {
      v62 = 0;
      if (v30)
      {
        do
        {
          v63 = 0;
          do
          {
            v64 = *&v43[4 * v63];
            v65 = *&v44[4 * v63];
            if (v64 < v28 || v64 > v25)
            {
              v65 = 10.0;
            }

            if (v65 >= v22)
            {
              v64 = NAN;
            }

            *&v45[4 * v63++] = v64;
          }

          while (a9 > v63);
          ++v62;
          v45 += v46;
          v44 += v40;
          v43 += v41;
        }

        while (a10 > v62);
      }

      else
      {
        do
        {
          v67 = 0;
          do
          {
            *&v45[4 * v67] = *&v43[4 * v67];
            ++v67;
          }

          while (a9 > v67);
          ++v62;
          v45 += v46;
          v43 += v41;
        }

        while (a10 > v62);
      }
    }
  }

LABEL_77:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4)
  {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}

void filterDepthAndUncertainty<float,half,false>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  v78 = a5;
  v19 = a6;
  v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  v22 = v21;

  v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  v25 = v24;

  v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  v28 = v27;

  v29 = [v19 pipelineParameters];
  v30 = [v29 outputHighConfidencePixelsOnly];

  if (v78)
  {
    v31 = 0;
    v32 = 0;
    while (1)
    {
      v33 = [v78 length];
      v34 = v31 >= v33;
      if (v31 >= v33)
      {
        break;
      }

      if (*([v78 confidences] + 4 * v31) > 0.0)
      {
        v35 = [v19 pipelineParameters];
        v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          v34 = 0;
          break;
        }
      }

      ++v31;
    }
  }

  else
  {
    v34 = 1;
  }

  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4)
  {
    CVPixelBufferLockBaseAddress(a4, 0);
  }

  memset(&v82, 0, sizeof(v82));
  v37 = MEMORY[0x277CBF3A0];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x277CBF3A0], &v82);
  memset(&v81, 0, sizeof(v81));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v81);
  memset(&v80, 0, sizeof(v80));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v80);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v79);
    data = v79.data;
    rowBytes = v79.rowBytes;
    if (a10 <= 0.0)
    {
      goto LABEL_68;
    }
  }

  else
  {
    rowBytes = 0;
    data = 0;
    if (a10 <= 0.0)
    {
      goto LABEL_68;
    }
  }

  if (a9 > 0.0)
  {
    v40 = v81.rowBytes;
    v41 = v82.rowBytes;
    v42 = 4 * a7;
    v43 = v82.data + v82.rowBytes * a8 + v42;
    v44 = v81.data + v81.rowBytes * a8 + v42;
    v45 = v80.data;
    v46 = v80.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if ((v30 & (v22 <= 10.0)) != 0)
        {
          v47 = 0;
          do
          {
            v48 = 0;
            do
            {
              *&v45[2 * v48] = 32256;
              *&data[2 * v48++] = COERCE_UNSIGNED_INT(10.0);
            }

            while (a9 > v48);
            ++v47;
            data += rowBytes;
            v45 += v46;
          }

          while (a10 > v47);
        }

        else
        {
          v72 = 0;
          do
          {
            v73 = 0;
            do
            {
              _S1 = *&v43[4 * v73];
              __asm { FCVT            H1, S1 }

              *&v45[2 * v73] = _S1;
              *&data[2 * v73++] = COERCE_UNSIGNED_INT(10.0);
            }

            while (a9 > v73);
            ++v72;
            data += rowBytes;
            v45 += v46;
            v43 += v41;
          }

          while (a10 > v72);
        }
      }

      else
      {
        v53 = 0;
        do
        {
          v54 = 0;
          do
          {
            _S2 = *&v43[4 * v54];
            _S3 = *&v44[4 * v54];
            if (_S2 < v28 || _S2 > v25)
            {
              _S3 = 10.0;
            }

            __asm { FCVT            H2, S2 }

            if ((v30 & (_S3 >= v22)) != 0)
            {
              _H2 = COERCE_SHORT_FLOAT(32256);
            }

            *&v45[2 * v54] = _H2;
            __asm { FCVT            H2, S3 }

            *&data[2 * v54++] = _H2;
          }

          while (a9 > v54);
          ++v53;
          data += rowBytes;
          v45 += v46;
          v44 += v40;
          v43 += v41;
        }

        while (a10 > v53);
      }
    }

    else if (v34)
    {
      if ((v30 & (v22 <= 10.0)) != 0)
      {
        v49 = 0;
        do
        {
          v50 = v45;
          v51 = 1;
          do
          {
            *v50++ = 32256;
            v52 = v51++;
          }

          while (a9 > v52);
          ++v49;
          v45 += v46;
        }

        while (a10 > v49);
      }

      else
      {
        v75 = 0;
        do
        {
          v76 = 0;
          do
          {
            _S0 = *&v43[4 * v76];
            __asm { FCVT            H0, S0 }

            *&v45[2 * v76++] = _S0;
          }

          while (a9 > v76);
          ++v75;
          v45 += v46;
          v43 += v41;
        }

        while (a10 > v75);
      }
    }

    else
    {
      v64 = 0;
      if (v30)
      {
        do
        {
          v65 = 0;
          do
          {
            _S2 = *&v43[4 * v65];
            v67 = *&v44[4 * v65];
            if (_S2 < v28 || _S2 > v25)
            {
              v67 = 10.0;
            }

            __asm { FCVT            H2, S2 }

            if (v67 >= v22)
            {
              _H2 = COERCE_SHORT_FLOAT(32256);
            }

            *&v45[2 * v65++] = _H2;
          }

          while (a9 > v65);
          ++v64;
          v45 += v46;
          v44 += v40;
          v43 += v41;
        }

        while (a10 > v64);
      }

      else
      {
        do
        {
          v70 = 0;
          do
          {
            _S0 = *&v43[4 * v70];
            __asm { FCVT            H0, S0 }

            *&v45[2 * v70++] = _S0;
          }

          while (a9 > v70);
          ++v64;
          v45 += v46;
          v43 += v41;
        }

        while (a10 > v64);
      }
    }
  }

LABEL_68:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4)
  {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}

void filterDepthAndUncertainty<float,float,true>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  v75 = a5;
  v19 = a6;
  v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  v22 = v21;

  v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  v25 = v24;

  v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  v28 = v27;

  v29 = [v19 pipelineParameters];
  v30 = [v29 outputHighConfidencePixelsOnly];

  if (v75)
  {
    v31 = 0;
    v32 = 0;
    while (1)
    {
      v33 = [v75 length];
      v34 = v31 >= v33;
      if (v31 >= v33)
      {
        break;
      }

      if (*([v75 confidences] + 4 * v31) > 0.0)
      {
        v35 = [v19 pipelineParameters];
        v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          v34 = 0;
          break;
        }
      }

      ++v31;
    }
  }

  else
  {
    v34 = 1;
  }

  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4)
  {
    CVPixelBufferLockBaseAddress(a4, 0);
  }

  memset(&v79, 0, sizeof(v79));
  v37 = MEMORY[0x277CBF3A0];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x277CBF3A0], &v79);
  memset(&v78, 0, sizeof(v78));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v78);
  memset(&v77, 0, sizeof(v77));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v77);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v76);
    data = v76.data;
    rowBytes = v76.rowBytes;
    if (a10 <= 0.0)
    {
      goto LABEL_80;
    }
  }

  else
  {
    rowBytes = 0;
    data = 0;
    if (a10 <= 0.0)
    {
      goto LABEL_80;
    }
  }

  if (a9 > 0.0)
  {
    v40 = v78.rowBytes;
    v41 = v79.rowBytes;
    v42 = 4 * a7;
    v43 = v79.data + v79.rowBytes * a8 + v42;
    v44 = v78.data + v78.rowBytes * a8 + v42;
    v45 = v77.data;
    v46 = v77.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if ((v30 & (v22 <= 10.0)) != 0)
        {
          v47 = 0;
          do
          {
            v48 = 0;
            do
            {
              *&v45[4 * v48] = 2143289344;
              *&data[4 * v48++] = 1092616192;
            }

            while (a9 > v48);
            ++v47;
            data += rowBytes;
            v45 += v46;
          }

          while (a10 > v47);
        }

        else
        {
          v67 = 0;
          do
          {
            v68 = 0;
            do
            {
              v69 = *&v43[4 * v68];
              if (v69 == 0.0)
              {
                v70 = NAN;
              }

              else
              {
                v70 = 1.0 / v69;
              }

              *&v45[4 * v68] = v70;
              *&data[4 * v68++] = 1092616192;
            }

            while (a9 > v68);
            ++v67;
            data += rowBytes;
            v45 += v46;
            v43 += v41;
          }

          while (a10 > v67);
        }
      }

      else
      {
        v53 = 0;
        do
        {
          v54 = 0;
          do
          {
            v55 = *&v43[4 * v54];
            v56 = *&v44[4 * v54];
            if (v55 < v28 || v55 > v25)
            {
              v56 = 10.0;
            }

            if (v56 >= v22)
            {
              v58 = v30;
            }

            else
            {
              v58 = 0;
            }

            if (v55 == 0.0)
            {
              v58 = 1;
            }

            v59 = 1.0 / v55;
            if (v58)
            {
              v59 = NAN;
            }

            *&v45[4 * v54] = v59;
            *&data[4 * v54++] = v56;
          }

          while (a9 > v54);
          ++v53;
          data += rowBytes;
          v45 += v46;
          v44 += v40;
          v43 += v41;
        }

        while (a10 > v53);
      }
    }

    else if (v34)
    {
      if ((v30 & (v22 <= 10.0)) != 0)
      {
        v49 = 0;
        do
        {
          v50 = v45;
          v51 = 1;
          do
          {
            *v50++ = 2143289344;
            v52 = v51++;
          }

          while (a9 > v52);
          ++v49;
          v45 += v46;
        }

        while (a10 > v49);
      }

      else
      {
        v71 = 0;
        do
        {
          v72 = 0;
          do
          {
            v73 = *&v43[4 * v72];
            if (v73 == 0.0)
            {
              v74 = NAN;
            }

            else
            {
              v74 = 1.0 / v73;
            }

            *&v45[4 * v72++] = v74;
          }

          while (a9 > v72);
          ++v71;
          v45 += v46;
          v43 += v41;
        }

        while (a10 > v71);
      }
    }

    else
    {
      v60 = 0;
      do
      {
        v61 = 0;
        do
        {
          v62 = *&v43[4 * v61];
          v63 = *&v44[4 * v61];
          if (v62 < v28 || v62 > v25)
          {
            v63 = 10.0;
          }

          if (v63 >= v22)
          {
            v65 = v30;
          }

          else
          {
            v65 = 0;
          }

          if (v62 == 0.0)
          {
            v65 = 1;
          }

          v66 = 1.0 / v62;
          if (v65)
          {
            v66 = NAN;
          }

          *&v45[4 * v61++] = v66;
        }

        while (a9 > v61);
        ++v60;
        v45 += v46;
        v44 += v40;
        v43 += v41;
      }

      while (a10 > v60);
    }
  }

LABEL_80:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4)
  {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}