void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::GraphOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::GraphOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::GraphOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::GraphOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = *a3;
  v4 = *(a3 + 16);
  v5 = *(a3 + 48);
  *(a2 + 32) = *(a3 + 32);
  *(a2 + 48) = v5;
  *a2 = result;
  *(a2 + 16) = v4;
  return result;
}

uint64_t sub_1002701DC()
{
  {
    sub_1002ABBB0();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::GraphOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100270224()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::GraphOpGenericAdaptorBase::Properties]";
  v6 = 137;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_1002702A4()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ArrayAttr]";
  v6 = 77;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_100270324()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::UnitAttr]";
  v6 = 76;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_1002703A4()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::TypeAttr]";
  v6 = 76;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::IsolatedGroupOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::IsolatedGroupOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::IsolatedGroupOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::IsolatedGroupOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_10027045C()
{
  {
    sub_1002ABC04();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::IsolatedGroupOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_1002704A4()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::IsolatedGroupOpGenericAdaptorBase::Properties]";
  v6 = 145;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::DelegateOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::DelegateOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::DelegateOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::DelegateOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  result = *a3;
  v4 = *(a3 + 16);
  *a2 = *a3;
  a2[1] = v4;
  return result;
}

uint64_t sub_100270554()
{
  {
    sub_1002ABC58();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::DelegateOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_10027059C()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::DelegateOpGenericAdaptorBase::Properties]";
  v6 = 140;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_10027061C()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::detail::DenseArrayAttrImpl<int8_t>]";
  v6 = 102;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = *a3;
  v4 = *(a3 + 16);
  *(a2 + 32) = *(a3 + 32);
  *a2 = result;
  *(a2 + 16) = v4;
  return result;
}

uint64_t sub_1002706D4()
{
  {
    sub_1002ABCAC();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::CallOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_10027071C()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::CallOpGenericAdaptorBase::Properties]";
  v6 = 136;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::InvokeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::InvokeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::InvokeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::InvokeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  result = *a3;
  v4 = *(a3 + 16);
  *a2 = *a3;
  a2[1] = v4;
  return result;
}

uint64_t sub_1002707CC()
{
  {
    sub_1002ABD00();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::InvokeOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100270814()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::InvokeOpGenericAdaptorBase::Properties]";
  v6 = 138;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_100270894()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::SymbolRefAttr]";
  v6 = 81;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

uint64_t sub_100270924(unint64_t **a1, uint64_t a2)
{
  {
    sub_1002A53B8();
  }

  result = (*(**(a2 + 48) + 32))(*(a2 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id);
  if (result)
  {
    v8[0] = &v9;
    v8[1] = &_mh_execute_header;
    mlir::Operation::fold(a2, 0, 0, v8);
    v5 = *v8[0] & 0xFFFFFFFFFFFFFFF8;
    if (mlir::DenseElementsAttr::classof(v5))
    {
      v6 = v5;
    }

    else
    {
      v6 = 0;
    }

    result = v6 != 0;
    if (v6 && *a1)
    {
      **a1 = v6;
    }

    if (v8[0] != &v9)
    {
      v7 = v6 != 0;
      free(v8[0]);
      return v7;
    }
  }

  return result;
}

uint64_t sub_100270D78(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  v40 = *(*(a2 + 72) + 24);
  v39 = *(v40 + 8) & 0xFFFFFFFFFFFFFFF8;
  v38 = *(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  result = mlir::TensorType::hasRank(&v39);
  if (result)
  {
    Shape = mlir::TensorType::getShape(&v39);
    if (v7)
    {
      v8 = 8 * v7;
      while (*Shape != 0x8000000000000000)
      {
        ++Shape;
        v8 -= 8;
        if (!v8)
        {
          goto LABEL_6;
        }
      }

      return 0;
    }

LABEL_6:
    result = mlir::TensorType::hasRank(&v38);
    if (!result)
    {
      return result;
    }

    v9 = mlir::TensorType::getShape(&v38);
    if (v10)
    {
      v11 = 8 * v10;
      while (*v9 != 0x8000000000000000)
      {
        ++v9;
        v11 -= 8;
        if (!v11)
        {
          goto LABEL_11;
        }
      }

      return 0;
    }

LABEL_11:
    v12 = *(*(a2 + 72) + 56);
    v44 = 0;
    v45 = 0;
    RawIntOrFloat = &v44;
    v42 = v12;
    result = mlir::Value::getDefiningOp(&v42);
    if (result)
    {
      result = sub_10026C424(&RawIntOrFloat, result);
      if (result)
      {
        mlir::TensorType::getShape(&v38);
        v44 = v46;
        v45 = 0xC00000000;
        if (v13)
        {
          v14 = v13;
          if (v13 < 0xD)
          {
            v15 = 0;
          }

          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v44, v46, v13, 4);
            v15 = v45;
          }

          if (v14 != v15)
          {
            bzero(v44 + 4 * v15, 4 * (v14 - v15));
          }

          LODWORD(v45) = v14;
        }

        v16 = mlir::TensorType::getShape(&v38);
        if (!v17)
        {
          goto LABEL_30;
        }

        v18 = v44;
        v19 = (v17 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        if (v19 > 6)
        {
          v22 = v19 + 1;
          v20 = (v19 + 1) & 0x3FFFFFFFFFFFFFF8;
          v21 = (v16 + 8 * v20);
          v23 = (v44 + 16);
          v24 = (v16 + 32);
          v25 = v20;
          do
          {
            v27 = v24[-2];
            v26 = v24[-1];
            v29 = *v24;
            v28 = v24[1];
            v24 += 4;
            v23[-1] = vuzp1q_s32(v27, v26);
            *v23 = vuzp1q_s32(v29, v28);
            v23 += 2;
            v25 -= 8;
          }

          while (v25);
          if (v22 == v20)
          {
LABEL_30:
            v32 = *(a2 + 24);
            mlir::TensorType::getShape(&v38);
            v43 = v33;
            IntegerType = mlir::Builder::getIntegerType(a3 + 1, 32, 1);
            v37 = mlir::RankedTensorType::get(&v43, 1, IntegerType, 0);
            v35 = sub_100065C78(&v37);
            RawIntOrFloat = mlir::DenseElementsAttr::getRawIntOrFloat(v35);
            v42 = sub_10026E114(a3 + 1, v32, &RawIntOrFloat);
            v36 = sub_10026E278(a3 + 1, *(a2 + 24), &v38, &v40, &v42);
            ((*a3)[1])(a3, a2, v36);
            if (v44 != v46)
            {
              free(v44);
            }

            return 1;
          }
        }

        else
        {
          v20 = 0;
          v21 = v16;
        }

        v30 = &v18[4 * v20];
        do
        {
          v31 = *v21++;
          *v30 = v31;
          v30 += 4;
        }

        while (v21 != (v16 + 8 * v17));
        goto LABEL_30;
      }
    }
  }

  return result;
}

const char *sub_100271078()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::ReplaceWithReshape<mlir::ODIE::Compiler::CoreML::ExpandDimsOp>]";
  v6 = 154;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_100271420()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::ReplaceWithReshape<mlir::ODIE::Compiler::CoreML::ShrinkDimsOp>]";
  v6 = 154;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void sub_1002714A0(void *a1@<X0>, uint64_t a2@<X8>)
{
  v7 = &v8;
  v8 = 0;
  v9 = a1;
  DefiningOp = mlir::Value::getDefiningOp(&v9);
  if (DefiningOp && (sub_100297C38(&v7, DefiningOp) & 1) != 0)
  {
    sub_1002715EC(v8, &v9);
    *a2 = a2 + 24;
    *(a2 + 8) = xmmword_1002B0E50;
    v4 = v9;
    v5 = v10;
    if (v10 && &v9 != a2)
    {
      if (v9 != v12)
      {
        *a2 = v9;
        *(a2 + 8) = v5;
        *(a2 + 16) = v11;
        *(a2 + 64) = 1;
        return;
      }

      v6 = v10;
      if (v10 < 0x15 || (llvm::SmallVectorBase<unsigned long long>::grow_pod(a2, (a2 + 24), v10, 2), v4 = v9, (v6 = v10) != 0))
      {
        memcpy(*a2, v4, 2 * v6);
        v4 = v9;
      }

      *(a2 + 8) = v5;
      v10 = 0;
    }

    *(a2 + 64) = 1;
    if (v4 != v12)
    {
      free(v4);
    }
  }

  else
  {
    *a2 = 0;
    *(a2 + 64) = 0;
  }
}

void sub_1002715EC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v15 = a1;
  v4 = (a2 + 24);
  *a2 = a2 + 24;
  *(a2 + 8) = xmmword_1002B0E50;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v13, a1, 0);
  NumElements = mlir::DenseElementsAttr::getNumElements(&v15);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v11, a1, NumElements);
  for (; v14 != v12; ++v14)
  {
    mlir::DenseElementsAttr::IntElementIterator::operator*(v13, &v9);
    v6 = v10;
    if (v10 >= 0x41)
    {
      if (v6 - llvm::APInt::countLeadingZerosSlowCase(&v9) <= 0x40)
      {
        v7 = *v9;
      }

      else
      {
        LOWORD(v7) = -1;
      }
    }

    else
    {
      LOWORD(v7) = v9;
    }

    v8 = *(a2 + 8);
    if ((v8 + 1) > *(a2 + 16))
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod(a2, v4, v8 + 1, 2);
      v8 = *(a2 + 8);
    }

    *(*a2 + 2 * v8) = v7;
    ++*(a2 + 8);
    if (v10 >= 0x41)
    {
      if (v9)
      {
        operator delete[]();
      }
    }
  }
}

uint64_t sub_10027173C@<X0>(uint64_t result@<X0>, __int16 *a2@<X1>, uint64_t a3@<X8>)
{
  v4 = *(result + 16);
  if (!v4)
  {
    v9 = 0;
    goto LABEL_5;
  }

  v5 = *result;
  v6 = *a2;
  v7 = v4 - 1;
  v8 = (37 * *a2) & (v4 - 1);
  v9 = (*result + 2 * v8);
  v10 = *v9;
  if (v6 != v10)
  {
    v13 = 0;
    v14 = 1;
    while (v10 != 0x7FFF)
    {
      if (v13)
      {
        v15 = 0;
      }

      else
      {
        v15 = v10 == 0x8000;
      }

      if (v15)
      {
        v13 = v9;
      }

      v16 = v8 + v14++;
      v8 = v16 & v7;
      v9 = (v5 + 2 * (v16 & v7));
      v10 = *v9;
      if (v6 == v10)
      {
        goto LABEL_3;
      }
    }

    if (v13)
    {
      v9 = v13;
    }

LABEL_5:
    v19 = v9;
    v12 = *(result + 8);
    if (4 * v12 + 4 >= 3 * v4)
    {
      v4 *= 2;
    }

    else if (v4 + ~v12 - *(result + 12) > v4 >> 3)
    {
      *(result + 8) = v12 + 1;
      if (*v9 == 0x7FFF)
      {
LABEL_9:
        *v9 = *a2;
        v5 = *result;
        v4 = *(result + 16);
        v11 = 1;
        goto LABEL_10;
      }

LABEL_8:
      --*(result + 12);
      goto LABEL_9;
    }

    v17 = result;
    v18 = a3;
    sub_100271974(result, v4);
    sub_1002718C4(v17, a2, &v19);
    result = v17;
    a3 = v18;
    v9 = v19;
    ++*(v17 + 8);
    if (*v9 == 0x7FFF)
    {
      goto LABEL_9;
    }

    goto LABEL_8;
  }

LABEL_3:
  v11 = 0;
LABEL_10:
  *a3 = v9;
  *(a3 + 8) = v5 + 2 * v4;
  *(a3 + 16) = v11;
  return result;
}

uint64_t sub_1002718C4(uint64_t *a1, __int16 *a2, void *a3)
{
  v3 = *(a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = *a2;
    v6 = v3 - 1;
    v7 = (37 * *a2) & (v3 - 1);
    v8 = (*a1 + 2 * v7);
    v9 = *v8;
    if (v5 == v9)
    {
      result = 1;
      *a3 = v8;
    }

    else
    {
      v11 = 0;
      v12 = 1;
      result = 1;
      while (v9 != 0x7FFF)
      {
        if (v11)
        {
          v13 = 0;
        }

        else
        {
          v13 = v9 == 0x8000;
        }

        if (v13)
        {
          v11 = v8;
        }

        v14 = v7 + v12++;
        v7 = v14 & v6;
        v8 = (v4 + 2 * (v14 & v6));
        v9 = *v8;
        if (v5 == v9)
        {
          goto LABEL_5;
        }
      }

      result = 0;
      if (v11)
      {
        v8 = v11;
      }

      *a3 = v8;
    }
  }

  else
  {
    v8 = 0;
    result = 0;
LABEL_5:
    *a3 = v8;
  }

  return result;
}

void sub_100271974(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  buffer = llvm::allocate_buffer((2 * v8), 2uLL);
  *a1 = buffer;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = buffer;
      memset_pattern16(buffer, &unk_1002B0F80, 2 * v10);
      buffer = v11;
    }

    if (v3)
    {
      v12 = 0;
      v13 = v10 - 1;
      v14 = v4;
      do
      {
        if ((*v14 - 0x7FFF) >= 2u)
        {
          v17 = *v14;
          v18 = (37 * *v14) & v13;
          v16 = &buffer[2 * v18];
          v19 = *v16;
          if (v17 != v19)
          {
            v20 = 0;
            v21 = 1;
            while (v19 != 0x7FFF)
            {
              if (v20)
              {
                v22 = 0;
              }

              else
              {
                v22 = v19 == 0x8000;
              }

              if (v22)
              {
                v20 = v16;
              }

              v23 = v18 + v21++;
              v18 = v23 & v13;
              v16 = &buffer[2 * (v23 & v13)];
              v19 = *v16;
              if (v17 == v19)
              {
                goto LABEL_16;
              }
            }

            if (v20)
            {
              v16 = v20;
            }
          }

LABEL_16:
          *v16 = v17;
          *(a1 + 8) = ++v12;
        }

        v14 = (v14 + 2);
      }

      while (v14 != (v4 + 2 * v3));
    }

    llvm::deallocate_buffer(v4, (2 * v3), 2uLL);
  }

  else
  {
    *(a1 + 8) = 0;
    v15 = *(a1 + 16);
    if (v15)
    {

      memset_pattern16(buffer, &unk_1002B0F80, 2 * v15);
    }
  }
}

uint64_t sub_100271B38@<X0>(uint64_t result@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  v4 = *(result + 16);
  if (!v4)
  {
    v8 = 0;
    goto LABEL_5;
  }

  v5 = *result;
  v6 = v4 - 1;
  v7 = (37 * *a2) & (v4 - 1);
  v8 = (*result + 4 * v7);
  v9 = *v8;
  if (*a2 != *v8)
  {
    v12 = 0;
    v13 = 1;
    while (v9 != 0x7FFFFFFF)
    {
      if (v12)
      {
        v14 = 0;
      }

      else
      {
        v14 = v9 == 0x80000000;
      }

      if (v14)
      {
        v12 = v8;
      }

      v15 = v7 + v13++;
      v7 = v15 & v6;
      v8 = (v5 + 4 * (v15 & v6));
      v9 = *v8;
      if (*a2 == *v8)
      {
        goto LABEL_3;
      }
    }

    if (v12)
    {
      v8 = v12;
    }

LABEL_5:
    v18 = v8;
    v11 = *(result + 8);
    if (4 * v11 + 4 >= 3 * v4)
    {
      v4 *= 2;
    }

    else if (v4 + ~v11 - *(result + 12) > v4 >> 3)
    {
      *(result + 8) = v11 + 1;
      if (*v8 == 0x7FFFFFFF)
      {
LABEL_9:
        *v8 = *a2;
        v5 = *result;
        v4 = *(result + 16);
        v10 = 1;
        goto LABEL_10;
      }

LABEL_8:
      --*(result + 12);
      goto LABEL_9;
    }

    v16 = result;
    v17 = a3;
    sub_100271D60(result, v4);
    sub_100271CB8(v16, a2, &v18);
    result = v16;
    a3 = v17;
    v8 = v18;
    ++*(v16 + 8);
    if (*v8 == 0x7FFFFFFF)
    {
      goto LABEL_9;
    }

    goto LABEL_8;
  }

LABEL_3:
  v10 = 0;
LABEL_10:
  *a3 = v8;
  *(a3 + 8) = v5 + 4 * v4;
  *(a3 + 16) = v10;
  return result;
}

uint64_t sub_100271CB8(uint64_t *a1, _DWORD *a2, void *a3)
{
  v3 = *(a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = (37 * *a2) & (v3 - 1);
    v7 = (*a1 + 4 * v6);
    v8 = *v7;
    if (*a2 == *v7)
    {
      result = 1;
      *a3 = v7;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      result = 1;
      while (v8 != 0x7FFFFFFF)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v8 == 0x80000000;
        }

        if (v12)
        {
          v10 = v7;
        }

        v13 = v6 + v11++;
        v6 = v13 & v5;
        v7 = (v4 + 4 * (v13 & v5));
        v8 = *v7;
        if (*a2 == *v7)
        {
          goto LABEL_5;
        }
      }

      result = 0;
      if (v10)
      {
        v7 = v10;
      }

      *a3 = v7;
    }
  }

  else
  {
    v7 = 0;
    result = 0;
LABEL_5:
    *a3 = v7;
  }

  return result;
}

void sub_100271D60(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  buffer = llvm::allocate_buffer((4 * v8), 4uLL);
  *a1 = buffer;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = buffer;
      memset_pattern16(buffer, &unk_1002B0F90, 4 * v10);
      buffer = v11;
    }

    if (v3)
    {
      v12 = 0;
      v13 = v4;
      do
      {
        v16 = *v13;
        if ((*v13 - 0x7FFFFFFF) >= 2)
        {
          v17 = *(a1 + 16) - 1;
          v18 = v17 & (37 * v16);
          v15 = &buffer[4 * v18];
          v19 = *v15;
          if (v16 != *v15)
          {
            v20 = 0;
            v21 = 1;
            while (v19 != 0x7FFFFFFF)
            {
              if (v20)
              {
                v22 = 0;
              }

              else
              {
                v22 = v19 == 0x80000000;
              }

              if (v22)
              {
                v20 = v15;
              }

              v23 = v18 + v21++;
              v18 = v23 & v17;
              v15 = &buffer[4 * (v23 & v17)];
              v19 = *v15;
              if (v16 == *v15)
              {
                goto LABEL_16;
              }
            }

            if (v20)
            {
              v15 = v20;
            }
          }

LABEL_16:
          *v15 = v16;
          *(a1 + 8) = ++v12;
        }

        v13 = (v13 + 4);
      }

      while (v13 != (v4 + 4 * v3));
    }

    llvm::deallocate_buffer(v4, (4 * v3), 4uLL);
  }

  else
  {
    *(a1 + 8) = 0;
    v14 = *(a1 + 16);
    if (v14)
    {

      memset_pattern16(buffer, &unk_1002B0F90, 4 * v14);
    }
  }
}

BOOL _ZN4llvm12function_refIFNS_11ParseResultERN4mlir4TypeEEE11callback_fnIZNS2_9AsmParser27parseCustomTypeWithFallbackINS2_4ODIE8Compiler6CoreML14AsyncValueTypeEEENSt3__19enable_ifIXsr28detect_type_has_parse_methodIT_EE5valueES1_E4typeERSG_EUlS4_E_EES1_lS4_(mlir::ODIE::Compiler::CoreML::AsyncValueType **a1, mlir::AsmParser *a2)
{
  v3 = mlir::ODIE::Compiler::CoreML::AsyncValueType::parse(*a1, a2);
  *a2 = v3;
  return v3 != 0;
}

void *sub_100271F40(void *result, _OWORD *a2, unsigned int a3, uint64_t *a4, uint64_t a5)
{
  v5 = 0;
  v6 = result + 2;
  *result = result + 2;
  result[1] = &_mh_execute_header;
  if (a3 && a5)
  {
    v7 = a3;
    v8 = (a5 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v8 >= ((a3 - 1) & 0x7FFFFFFFFFFFFFFuLL))
    {
      v8 = (a3 - 1) & 0x7FFFFFFFFFFFFFFLL;
    }

    if (v8)
    {
      v9 = v8 + 1;
      v10 = result;
      v11 = a2;
      v12 = a4;
      v13 = a5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(result, result + 2, v8 + 1, 64);
      a5 = v13;
      a2 = v11;
      a4 = v12;
      result = v10;
      v8 = *(v10 + 2);
      v6 = *v10;
    }

    else
    {
      v9 = 1;
    }

    v14 = &v6[8 * v8];
    v15 = 32 * v7 - 32;
    v16 = 8 * a5 - 8;
    do
    {
      v17 = *a2;
      *(v14 + 12) = *(a2 + 12);
      *v14 = v17;
      v18 = *a4++;
      *(v14 + 56) = 0;
      v14[4] = v18;
      v14[5] = 0;
      *(v14 + 48) = 0;
      if (!v15)
      {
        break;
      }

      a2 += 2;
      v14 += 8;
      v15 -= 32;
      v19 = v16;
      v16 -= 8;
    }

    while (v19);
    v5 = *(result + 2) + v9;
  }

  *(result + 2) = v5;
  return result;
}

BOOL sub_10027204C(uint64_t a1, void *a2)
{
  v4 = (*(*a1 + 40))(a1);
  v19 = 0;
  if (((*(*a1 + 536))(a1, &v19) & 1) == 0)
  {
    return 0;
  }

  v5 = v19;
  v6 = *(*v19 + 136);
  if (v6 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id && v6 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v5 = 0;
  }

  *a2 = v5;
  if (v5)
  {
    return 1;
  }

  v17 = "invalid kind of type specified";
  v18 = 259;
  (*(*a1 + 24))(v20, a1, v4, &v17);
  result = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v20);
  v9 = result;
  if (v20[0])
  {
    mlir::InFlightDiagnostic::report(v20);
    result = v9;
  }

  if (v28 == 1)
  {
    if (v27 != &v28)
    {
      free(v27);
      result = v9;
    }

    v10 = __p;
    if (__p)
    {
      v11 = v26;
      v12 = __p;
      if (v26 != __p)
      {
        do
        {
          v11 = sub_10005BEF4(v11 - 1);
        }

        while (v11 != v10);
        v12 = __p;
      }

      v26 = v10;
      operator delete(v12);
      result = v9;
    }

    v13 = v23;
    if (v23)
    {
      v14 = v24;
      v15 = v23;
      if (v24 != v23)
      {
        do
        {
          v16 = *--v14;
          *v14 = 0;
          if (v16)
          {
            operator delete[]();
          }
        }

        while (v14 != v13);
        v15 = v23;
      }

      v24 = v13;
      operator delete(v15);
      result = v9;
    }

    if (v21 != &v22)
    {
      free(v21);
      return v9;
    }
  }

  return result;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::ClassOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::ClassOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::ClassOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::ClassOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t sub_1002722E0()
{
  {
    sub_1002ABDD4();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::ClassOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100272328()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::ClassOpGenericAdaptorBase::Properties]";
  v6 = 137;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t sub_1002723D8()
{
  {
    sub_1002ABE28();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::ConstantOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100272420()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::ConstantOpGenericAdaptorBase::Properties]";
  v6 = 140;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void sub_1002724A0(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4 = **(a1 + 8);
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v5 = &v24;
    v6 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v6 = v30;
        v5 = (v30 + v22);
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = &v24;
        v6 = v30;
      }
    }

    v7 = &v6[24 * v31];
    v8 = *v5;
    *(v7 + 2) = v5[2];
    *v7 = v8;
    ++v31;
  }

  v24 = *(*(*(a1 + 16) + 8) + 8);
  Value = mlir::StringAttr::getValue(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = Value;
    v25 = v10;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v11 = &v24;
      v12 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v12 = v30;
          v11 = (v30 + v23);
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = &v24;
          v12 = v30;
        }
      }

      v13 = &v12[24 * v31];
      v14 = *v11;
      *(v13 + 2) = v11[2];
      *v13 = v14;
      ++v31;
    }
  }

  sub_10006BAFC(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v15 = __p;
    if (__p)
    {
      v16 = v37;
      v17 = __p;
      if (v37 != __p)
      {
        do
        {
          v16 = sub_10005BEF4(v16 - 1);
        }

        while (v16 != v15);
        v17 = __p;
      }

      v37 = v15;
      operator delete(v17);
    }

    v18 = v34;
    if (v34)
    {
      v19 = v35;
      v20 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v19;
          *v19 = 0;
          if (v21)
          {
            operator delete[]();
          }
        }

        while (v19 != v18);
        v20 = v34;
      }

      v35 = v18;
      operator delete(v20);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::ErrorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::ErrorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

uint64_t sub_100272830()
{
  {
    sub_1002ABE7C();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::ErrorOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100272878()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::ErrorOpGenericAdaptorBase::Properties]";
  v6 = 137;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void sub_1002728F8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4 = **(a1 + 8);
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v5 = &v24;
    v6 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v6 = v30;
        v5 = (v30 + v22);
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = &v24;
        v6 = v30;
      }
    }

    v7 = &v6[24 * v31];
    v8 = *v5;
    *(v7 + 2) = v5[2];
    *v7 = v8;
    ++v31;
  }

  v24 = *(*(*(a1 + 16) + 8) + 8);
  Value = mlir::StringAttr::getValue(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = Value;
    v25 = v10;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v11 = &v24;
      v12 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v12 = v30;
          v11 = (v30 + v23);
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = &v24;
          v12 = v30;
        }
      }

      v13 = &v12[24 * v31];
      v14 = *v11;
      *(v13 + 2) = v11[2];
      *v13 = v14;
      ++v31;
    }
  }

  sub_10006BAFC(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v15 = __p;
    if (__p)
    {
      v16 = v37;
      v17 = __p;
      if (v37 != __p)
      {
        do
        {
          v16 = sub_10005BEF4(v16 - 1);
        }

        while (v16 != v15);
        v17 = __p;
      }

      v37 = v15;
      operator delete(v17);
    }

    v18 = v34;
    if (v34)
    {
      v19 = v35;
      v20 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v19;
          *v19 = 0;
          if (v21)
          {
            operator delete[]();
          }
        }

        while (v19 != v18);
        v20 = v34;
      }

      v35 = v18;
      operator delete(v20);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

BOOL sub_100272C58(uint64_t a1, void *a2)
{
  v4 = (*(*a1 + 40))(a1);
  v17 = 0;
  if (((*(*a1 + 536))(a1, &v17) & 1) == 0)
  {
    return 0;
  }

  v5 = v17;
  if (*(*v17 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v5 = 0;
  }

  *a2 = v5;
  if (v5)
  {
    return 1;
  }

  v15 = "invalid kind of type specified";
  v16 = 259;
  (*(*a1 + 24))(v18, a1, v4, &v15);
  result = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v18);
  v7 = result;
  if (v18[0])
  {
    mlir::InFlightDiagnostic::report(v18);
    result = v7;
  }

  if (v26 == 1)
  {
    if (v25 != &v26)
    {
      free(v25);
      result = v7;
    }

    v8 = __p;
    if (__p)
    {
      v9 = v24;
      v10 = __p;
      if (v24 != __p)
      {
        do
        {
          v9 = sub_10005BEF4(v9 - 1);
        }

        while (v9 != v8);
        v10 = __p;
      }

      v24 = v8;
      operator delete(v10);
      result = v7;
    }

    v11 = v21;
    if (v21)
    {
      v12 = v22;
      v13 = v21;
      if (v22 != v21)
      {
        do
        {
          v14 = *--v12;
          *v12 = 0;
          if (v14)
          {
            operator delete[]();
          }
        }

        while (v12 != v11);
        v13 = v21;
      }

      v22 = v11;
      operator delete(v13);
      result = v7;
    }

    if (v19 != &v20)
    {
      free(v19);
      return v7;
    }
  }

  return result;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::FFIImportOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::FFIImportOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::FFIImportOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::FFIImportOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_100272EE8()
{
  {
    sub_1002ABED0();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::FFIImportOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100272F30()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::FFIImportOpGenericAdaptorBase::Properties]";
  v6 = 141;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

BOOL sub_100272FB0(uint64_t a1, void *a2, uint64_t a3)
{
  v6 = (*(*a1 + 40))(a1);
  v19 = 0;
  if (((*(*a1 + 440))(a1, &v19, a3) & 1) == 0)
  {
    return 0;
  }

  v7 = v19;
  if (*(*v19 + 136) != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    v7 = 0;
  }

  *a2 = v7;
  if (v7)
  {
    return 1;
  }

  v17 = "invalid kind of attribute specified";
  v18 = 259;
  (*(*a1 + 24))(v20, a1, v6, &v17);
  result = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v20);
  v9 = result;
  if (v20[0])
  {
    mlir::InFlightDiagnostic::report(v20);
    result = v9;
  }

  if (v28 == 1)
  {
    if (v27 != &v28)
    {
      free(v27);
      result = v9;
    }

    v10 = __p;
    if (__p)
    {
      v11 = v26;
      v12 = __p;
      if (v26 != __p)
      {
        do
        {
          v11 = sub_10005BEF4(v11 - 1);
        }

        while (v11 != v10);
        v12 = __p;
      }

      v26 = v10;
      operator delete(v12);
      result = v9;
    }

    v13 = v23;
    if (v23)
    {
      v14 = v24;
      v15 = v23;
      if (v24 != v23)
      {
        do
        {
          v16 = *--v14;
          *v14 = 0;
          if (v16)
          {
            operator delete[]();
          }
        }

        while (v14 != v13);
        v15 = v23;
      }

      v24 = v13;
      operator delete(v15);
      result = v9;
    }

    if (v21 != &v22)
    {
      free(v21);
      return v9;
    }
  }

  return result;
}

void sub_100273210(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4 = **(a1 + 8);
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v5 = &v24;
    v6 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v6 = v30;
        v5 = (v30 + v22);
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = &v24;
        v6 = v30;
      }
    }

    v7 = &v6[24 * v31];
    v8 = *v5;
    *(v7 + 2) = v5[2];
    *v7 = v8;
    ++v31;
  }

  v24 = *(*(*(a1 + 16) + 8) + 8);
  Value = mlir::StringAttr::getValue(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = Value;
    v25 = v10;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v11 = &v24;
      v12 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v12 = v30;
          v11 = (v30 + v23);
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = &v24;
          v12 = v30;
        }
      }

      v13 = &v12[24 * v31];
      v14 = *v11;
      *(v13 + 2) = v11[2];
      *v13 = v14;
      ++v31;
    }
  }

  sub_10006BAFC(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v15 = __p;
    if (__p)
    {
      v16 = v37;
      v17 = __p;
      if (v37 != __p)
      {
        do
        {
          v16 = sub_10005BEF4(v16 - 1);
        }

        while (v16 != v15);
        v17 = __p;
      }

      v37 = v15;
      operator delete(v17);
    }

    v18 = v34;
    if (v34)
    {
      v19 = v35;
      v20 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v19;
          *v19 = 0;
          if (v21)
          {
            operator delete[]();
          }
        }

        while (v19 != v18);
        v20 = v34;
      }

      v35 = v18;
      operator delete(v20);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

unint64_t sub_100273570(char *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10)
{
  v22 = a2;
  v15 = sub_10002DCBC(a1, &v22, a3, a4, *a5);
  v23 = v22;
  v16 = sub_10002DCBC(a1, &v23, v15, a4, *a6);
  v24 = v23;
  v17 = sub_10002DCBC(a1, &v24, v16, a4, *a7);
  v25 = v24;
  v18 = sub_10002DCBC(a1, &v25, v17, a4, *a8);
  v26 = v25;
  v19 = sub_10002DCBC(a1, &v26, v18, a4, *a9);
  v27 = v26;
  v20 = sub_10002DCBC(a1, &v27, v19, a4, *a10);
  return sub_10002D330(a1, v27, v20, a4);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = *a3;
  v4 = *(a3 + 16);
  v5 = *(a3 + 48);
  *(a2 + 32) = *(a3 + 32);
  *(a2 + 48) = v5;
  *a2 = result;
  *(a2 + 16) = v4;
  return result;
}

uint64_t sub_1002736C0()
{
  {
    sub_1002ABF24();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::FuncOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100273708()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::FuncOpGenericAdaptorBase::Properties]";
  v6 = 136;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_100273788()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::ExternAttr]";
  v6 = 102;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::GELUOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::GELUOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

uint64_t sub_100273838()
{
  {
    sub_1002ABF78();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::GELUOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100273880()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::GELUOpGenericAdaptorBase::Properties]";
  v6 = 136;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_100273900()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::ApproximateAttr]";
  v6 = 107;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::GetMemberOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::GetMemberOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::GetMemberOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::GetMemberOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t sub_1002739B0()
{
  {
    sub_1002ABFCC();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::GetMemberOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_1002739F8()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::GetMemberOpGenericAdaptorBase::Properties]";
  v6 = 141;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::MemberOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::MemberOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::MemberOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::MemberOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = *a3;
  v4 = *(a3 + 16);
  *(a2 + 32) = *(a3 + 32);
  *a2 = result;
  *(a2 + 16) = v4;
  return result;
}

uint64_t sub_100273AB0()
{
  {
    sub_1002AC020();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::MemberOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100273AF8()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::MemberOpGenericAdaptorBase::Properties]";
  v6 = 138;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_100273B78()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::IntegerAttr]";
  v6 = 79;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::PadOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::PadOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

uint64_t sub_100273C28()
{
  {
    sub_1002AC074();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::PadOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100273C70()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::PadOpGenericAdaptorBase::Properties]";
  v6 = 135;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_100273CF0()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::PaddingModeAttr]";
  v6 = 107;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::PlaceholderOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::PlaceholderOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

uint64_t sub_100273DA0()
{
  {
    sub_1002AC0C8();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::PlaceholderOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100273DE8()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::PlaceholderOpGenericAdaptorBase::Properties]";
  v6 = 143;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void *sub_100273E68(void *a1, uint64_t *a2)
{
  v4 = a1[2];
  v3 = a1[3];
  if (v4 >= v3)
  {
    v7 = a1[1];
    v8 = v4 - v7;
    v9 = (v4 - v7) >> 3;
    v10 = v9 + 1;
    if ((v9 + 1) >> 61)
    {
      sub_100003FC0();
    }

    v11 = v3 - v7;
    if (v11 >> 2 > v10)
    {
      v10 = v11 >> 2;
    }

    if (v11 >= 0x7FFFFFFFFFFFFFF8)
    {
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v12 = v10;
    }

    if (v12)
    {
      if (!(v12 >> 61))
      {
        operator new();
      }

      sub_100003FC0();
    }

    v13 = (v4 - v7) >> 3;
    v14 = (8 * v9);
    v15 = *a2;
    *a2 = 0;
    v16 = (8 * v9 - 8 * v13);
    *v14 = v15;
    v6 = v14 + 1;
    memcpy(v16, v7, v8);
    a1[1] = v16;
    a1[2] = v6;
    a1[3] = 0;
    if (v7)
    {
      operator delete(v7);
    }
  }

  else
  {
    v5 = *a2;
    *a2 = 0;
    *v4 = v5;
    v6 = v4 + 8;
  }

  a1[2] = v6;
  return a1;
}

void sub_100273F78(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  operator delete();
}

void sub_100274060(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4 = **(a1 + 8);
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v5 = &v24;
    v6 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v6 = v30;
        v5 = (v30 + v22);
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = &v24;
        v6 = v30;
      }
    }

    v7 = &v6[24 * v31];
    v8 = *v5;
    *(v7 + 2) = v5[2];
    *v7 = v8;
    ++v31;
  }

  v24 = *(*(*(a1 + 16) + 8) + 8);
  Value = mlir::StringAttr::getValue(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = Value;
    v25 = v10;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v11 = &v24;
      v12 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v12 = v30;
          v11 = (v30 + v23);
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = &v24;
          v12 = v30;
        }
      }

      v13 = &v12[24 * v31];
      v14 = *v11;
      *(v13 + 2) = v11[2];
      *v13 = v14;
      ++v31;
    }
  }

  sub_10006BAFC(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v15 = __p;
    if (__p)
    {
      v16 = v37;
      v17 = __p;
      if (v37 != __p)
      {
        do
        {
          v16 = sub_10005BEF4(v16 - 1);
        }

        while (v16 != v15);
        v17 = __p;
      }

      v37 = v15;
      operator delete(v17);
    }

    v18 = v34;
    if (v34)
    {
      v19 = v35;
      v20 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v19;
          *v19 = 0;
          if (v21)
          {
            operator delete[]();
          }
        }

        while (v19 != v18);
        v20 = v34;
      }

      v35 = v18;
      operator delete(v20);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

llvm::raw_ostream *sub_1002743C0(uint64_t a1, uint64_t *a2)
{
  result = (*(*a1 + 16))(a1);
  v5 = result;
  v6 = *(result + 4);
  if (*(result + 3) - v6 > 3uLL)
  {
    *v6 = 540945696;
    *(result + 4) += 4;
    v7 = a2[1];
    v10 = a2[3];
    if (v7 == v10 || v7 + 1 != v10)
    {
LABEL_20:
      v20 = *(v5 + 4);
      if (v20 >= *(v5 + 3))
      {
        result = llvm::raw_ostream::write(v5, 40);
        v21 = a2[1];
        v22 = a2[3];
        if (v21 == v22)
        {
          goto LABEL_25;
        }
      }

      else
      {
        *(v5 + 4) = v20 + 1;
        *v20 = 40;
        v21 = a2[1];
        v22 = a2[3];
        if (v21 == v22)
        {
LABEL_25:
          v26 = *(v5 + 4);
          if (v26 >= *(v5 + 3))
          {

            return llvm::raw_ostream::write(v5, 41);
          }

          else
          {
            *(v5 + 4) = v26 + 1;
            *v26 = 41;
          }

          return result;
        }
      }

      v23 = *a2;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v23, v21);
      result = (*(*a1 + 32))(a1, *(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
      for (i = v21 + 1; v22 != i; ++i)
      {
        v28 = (*(*a1 + 16))(a1);
        v29 = v28[4];
        if (v28[3] - v29 > 1uLL)
        {
          *v29 = 8236;
          v28[4] += 2;
        }

        else
        {
          llvm::raw_ostream::write(v28, ", ", 2uLL);
        }

        v27 = mlir::detail::OpResultImpl::getNextResultAtOffset(v23, i);
        result = (*(*a1 + 32))(a1, *(v27 + 8) & 0xFFFFFFFFFFFFFFF8);
      }

      goto LABEL_25;
    }
  }

  else
  {
    result = llvm::raw_ostream::write(result, " -> ", 4uLL);
    v5 = result;
    v7 = a2[1];
    v8 = a2[3];
    if (v7 == v8 || v7 + 1 != v8)
    {
      goto LABEL_20;
    }
  }

  result = mlir::detail::OpResultImpl::getNextResultAtOffset(*a2, v7);
  if (*(*(*(result + 1) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
  {
    goto LABEL_20;
  }

  v12 = a2[1];
  v13 = a2[3];
  if (v12 != v13)
  {
    v14 = *a2;
    v15 = mlir::detail::OpResultImpl::getNextResultAtOffset(*a2, a2[1]);
    result = (*(*a1 + 32))(a1, *(v15 + 8) & 0xFFFFFFFFFFFFFFF8);
    for (j = v12 + 1; v13 != j; ++j)
    {
      v18 = (*(*a1 + 16))(a1);
      v19 = v18[4];
      if (v18[3] - v19 > 1uLL)
      {
        *v19 = 8236;
        v18[4] += 2;
      }

      else
      {
        llvm::raw_ostream::write(v18, ", ", 2uLL);
      }

      v17 = mlir::detail::OpResultImpl::getNextResultAtOffset(v14, j);
      result = (*(*a1 + 32))(a1, *(v17 + 8) & 0xFFFFFFFFFFFFFFF8);
    }
  }

  return result;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::ResizeByScaleOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::ResizeByScaleOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::ResizeByScaleOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::ResizeByScaleOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t sub_100274790()
{
  {
    sub_1002AC11C();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::ResizeByScaleOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_1002747D8()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::ResizeByScaleOpGenericAdaptorBase::Properties]";
  v6 = 145;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_100274858()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::InterpolationModeAttr]";
  v6 = 113;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_1002748D8()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::SamplingModeAttr]";
  v6 = 108;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::ScatterAlongAxisOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::ScatterAlongAxisOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

uint64_t sub_100274988()
{
  {
    sub_1002AC170();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::ScatterAlongAxisOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_1002749D0()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::ScatterAlongAxisOpGenericAdaptorBase::Properties]";
  v6 = 148;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_100274A50()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::ScatterModeAttr]";
  v6 = 107;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::SetMemberOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::SetMemberOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::SetMemberOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::SetMemberOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t sub_100274B00()
{
  {
    sub_1002AC1C4();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::SetMemberOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100274B48()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::SetMemberOpGenericAdaptorBase::Properties]";
  v6 = 141;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::Compiler::CoreML::detail::TargetSpecOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::TargetSpecOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    operator delete();
  }
}

uint64_t sub_100274BF8()
{
  {
    sub_1002AC218();
  }

  return llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::TargetSpecOpGenericAdaptorBase::Properties>(void)::Name;
}

const char *sub_100274C40()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::detail::TargetSpecOpGenericAdaptorBase::Properties]";
  v6 = 142;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *sub_100274CC0()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::TargetSpecAttr]";
  v6 = 106;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

BOOL _ZN4llvm12function_refIFNS_11ParseResultERN4mlir9AttributeENS2_4TypeEEE11callback_fnIZNS2_9AsmParser32parseCustomAttributeWithFallbackINS2_4ODIE8Compiler6CoreML14TargetSpecAttrEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES1_E4typeERSH_S5_EUlS4_S5_E_EES1_lS4_S5_(mlir::AsmParser **a1, uint64_t *a2)
{
  v3 = mlir::ODIE::Compiler::CoreML::TargetSpecAttr::parse(*a1);
  *a2 = v3;
  return v3 != 0;
}

void sub_100274D78(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4 = **(a1 + 8);
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v5 = &v24;
    v6 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v6 = v30;
        v5 = (v30 + v22);
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = &v24;
        v6 = v30;
      }
    }

    v7 = &v6[24 * v31];
    v8 = *v5;
    *(v7 + 2) = v5[2];
    *v7 = v8;
    ++v31;
  }

  v24 = *(*(*(a1 + 16) + 8) + 8);
  Value = mlir::StringAttr::getValue(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = Value;
    v25 = v10;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v11 = &v24;
      v12 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v12 = v30;
          v11 = (v30 + v23);
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = &v24;
          v12 = v30;
        }
      }

      v13 = &v12[24 * v31];
      v14 = *v11;
      *(v13 + 2) = v11[2];
      *v13 = v14;
      ++v31;
    }
  }

  sub_10006BAFC(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v15 = __p;
    if (__p)
    {
      v16 = v37;
      v17 = __p;
      if (v37 != __p)
      {
        do
        {
          v16 = sub_10005BEF4(v16 - 1);
        }

        while (v16 != v15);
        v17 = __p;
      }

      v37 = v15;
      operator delete(v17);
    }

    v18 = v34;
    if (v34)
    {
      v19 = v35;
      v20 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v19;
          *v19 = 0;
          if (v21)
          {
            operator delete[]();
          }
        }

        while (v19 != v18);
        v20 = v34;
      }

      v35 = v18;
      operator delete(v20);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

__n128 sub_1002750E4@<Q0>(uint64_t a1@<X8>)
{
  v3 = (a1 + 24 * v1);
  result = *v2;
  v3[1].n128_u64[0] = v2[1].n128_u64[0];
  *v3 = result;
  return result;
}

uint64_t sub_100275220(uint64_t result)
{
  v1 = *(result + 24);
  v2 = *(result + 28);
  return result;
}

uint64_t *sub_100275290(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  v17 = *(v15 + 36);
  v18 = v15 - 16;
  if (!v17)
  {
    v18 = 0;
  }

  a14 = v18;
  a15 = v17;

  return mlir::ResultRange::getTypes(&a14, &a10);
}

uint64_t sub_1002752D4@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(a2 + 2) = 32;
  *a2 = 14880;
  *(result + 32) += 3;
  return result;
}

void sub_100275304(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(v13 + 24, a12, v12 + 1, 24);
}

void sub_100275324()
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(v2 + 24, v1, v0 + 1, 24);
}

void sub_100275344()
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(v2, (v1 + 32), v0 + 1, 24);
}

void sub_100275364()
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(v2, (v1 + 32), v0 + 1, 24);
}

uint64_t *sub_100275394@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  *(v3 - 72) = a3;
  v4 = *result;
  v5 = *a2;
  return result;
}

void *sub_1002753E8()
{

  return llvm::raw_ostream::write(v0, v1, 2uLL);
}

void sub_100275444(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(v5 + 24, a5, a1 + 1, 24);
}

void sub_100275464(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(v13 + 24, a12, v12 + 1, 24);
}

void sub_100275484(uint64_t a1@<X8>)
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(v2 + 24, v1, a1 + 1, 24);
}

void sub_1002754A4()
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(v2 + 24, v1, v0 + 1, 24);
}

void sub_1002754C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  v10 = *(**v8 + 24);

  mlir::emitError(v10, va);
}

void sub_100275510()
{
  v1 = *(v0 + 24);
  v2 = *(v0 + 28);
  v3 = *(v0 + 16);
}

llvm::raw_ostream *sub_1002755E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{

  return mlir::call_interface_impl::printFunctionSignature(v13, a2, a3, v14, 0, a12, a13, a8, 0, 1u);
}

uint64_t sub_10027560C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);

  return mlir::DiagnosticArgument::DiagnosticArgument(va, a5);
}

uint64_t *sub_100275628@<X0>(uint64_t a1@<X8>, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  va_arg(va1, void);
  va_arg(va1, void);
  v8 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  v10 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  v5 = a1;
  v7 = v2;

  return mlir::OperandRange::getTypes(va, va1);
}

llvm::raw_ostream *sub_100275650(uint64_t a1, ...)
{
  va_start(va1, a1);
  va_start(va, a1);
  v4 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  v10 = va_arg(va1, void);

  return sub_100257B04(v1, va1, va);
}

uint64_t *sub_1002756E0@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36)
{
  a10 = a1;
  a11 = v36;

  return mlir::ResultRange::getTypes(&a10, &a36);
}

uint64_t *sub_100275704@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36)
{
  a10 = a1;
  a11 = v36;

  return mlir::OperandRange::getTypes(&a10, &a36);
}

uint64_t sub_100275728@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  result = a2;
  v4 = *(*a1 + 46);
  return result;
}

uint64_t sub_10027573C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  a16 = a1;

  return mlir::DictionaryAttr::getValue(&a16);
}

BOOL sub_100275810()
{
  v3 = *v0;
  v4 = *(*v1 + 8) & 0xFFFFFFFFFFFFFFF8;

  return mlir::ODIE::Compiler::areTypesCompatible(v3, v4);
}

void sub_100275860(void *a1@<X8>)
{

  operator delete(a1);
}

uint64_t sub_100275878(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, char a43)
{

  return sub_10006BAFC(&a43, &a17);
}

unint64_t sub_100275890(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{

  return mlir::Operation::getAttrDictionary(v21);
}

uint64_t mlir::ODIE::Compiler::CoreML::TransformCastOp::verifyInvariantsImpl(mlir::Operation **this)
{
  v2 = sub_100275940(*this, (*(*(*(*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), "operand", 7, 0);
  result = 0;
  if (v2)
  {
    if (*(*this + 9))
    {
      v4 = *this - 16;
    }

    else
    {
      v4 = 0;
    }

    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
    return sub_100275940(*this, (*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), "result", 6, 0) & 1;
  }

  return result;
}

uint64_t sub_100275940(mlir::Operation *a1, uint64_t *a2, void **a3, void **a4, unsigned int a5)
{
  v7 = *a2;
  {
    v8 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id;
    v9 = *(v7 + 8);
    v10 = *(v7 + 16);
    if (!v10)
    {
      goto LABEL_13;
    }
  }

  else
  {
    v60 = a3;
    v61 = a1;
    v59 = a4;
    sub_1002AAB00();
    a4 = v59;
    a3 = v60;
    a1 = v61;
    v8 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id;
    v9 = *(v7 + 8);
    v10 = *(v7 + 16);
    if (!v10)
    {
      goto LABEL_13;
    }
  }

  v11 = v9;
  v12 = v10;
  do
  {
    v13 = v12 >> 1;
    v14 = &v11[2 * (v12 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v12 += ~(v12 >> 1);
    if (v16 < v8)
    {
      v11 = v15;
    }

    else
    {
      v12 = v13;
    }
  }

  while (v12);
  if (v11 != &v9[2 * v10] && *v11 == v8 && v11[1])
  {
    v43 = *a2;
    {
      v44 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id;
      v45 = *(v43 + 8);
      v46 = *(v43 + 16);
      if (!v46)
      {
        goto LABEL_68;
      }
    }

    else
    {
      sub_1002AAB00();
      v44 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id;
      v45 = *(v43 + 8);
      v46 = *(v43 + 16);
      if (!v46)
      {
        goto LABEL_68;
      }
    }

    v47 = v45;
    v48 = v46;
    do
    {
      v49 = v48 >> 1;
      v50 = &v47[2 * (v48 >> 1)];
      v52 = *v50;
      v51 = v50 + 2;
      v48 += ~(v48 >> 1);
      if (v52 < v44)
      {
        v47 = v51;
      }

      else
      {
        v48 = v49;
      }
    }

    while (v48);
    if (v47 != &v45[2 * v46] && *v47 == v44)
    {
      v54 = v47[1];
      goto LABEL_70;
    }

LABEL_68:
    v54 = 0;
LABEL_70:
    v67[0] = a2;
    v67[1] = v54;
    mlir::ShapedType::getElementType(v67);
    return 1;
  }

LABEL_13:
  v63 = 261;
  v62[0] = a3;
  v62[1] = a4;
  mlir::Operation::emitOpError(v67, a1, v62);
  if (v67[0])
  {
    v64 = 3;
    v65 = " #";
    v66 = 2;
    v17 = &v64;
    v18 = v68;
    if (v69 >= v70)
    {
      if (v68 <= &v64 && v68 + 24 * v69 > &v64)
      {
        v55 = &v64 - v68;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v68, v71, v69 + 1, 24);
        v18 = v68;
        v17 = (v68 + v55);
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v68, v71, v69 + 1, 24);
        v17 = &v64;
        v18 = v68;
      }
    }

    v19 = &v18[24 * v69];
    v20 = *v17;
    *(v19 + 2) = *(v17 + 2);
    *v19 = v20;
    v21 = ++v69;
    if (v67[0])
    {
      v64 = 5;
      v65 = a5;
      v22 = &v64;
      v23 = v68;
      if (v21 >= v70)
      {
        if (v68 <= &v64 && v68 + 24 * v21 > &v64)
        {
          v56 = &v64 - v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v68, v71, v21 + 1, 24);
          v23 = v68;
          v22 = (v68 + v56);
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v68, v71, v21 + 1, 24);
          v22 = &v64;
          v23 = v68;
        }
      }

      v24 = &v23[24 * v69];
      v25 = *v22;
      *(v24 + 2) = *(v22 + 2);
      *v24 = v25;
      v26 = ++v69;
      if (v67[0])
      {
        v64 = 3;
        v65 = " must be shaped of any type values, but got ";
        v66 = 44;
        v27 = &v64;
        v28 = v68;
        if (v26 >= v70)
        {
          if (v68 <= &v64 && v68 + 24 * v26 > &v64)
          {
            v57 = &v64 - v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v68, v71, v26 + 1, 24);
            v28 = v68;
            v27 = (v68 + v57);
          }

          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v68, v71, v26 + 1, 24);
            v27 = &v64;
            v28 = v68;
          }
        }

        v29 = &v28[24 * v69];
        v30 = *v27;
        *(v29 + 2) = *(v27 + 2);
        *v29 = v30;
        ++v69;
        if (v67[0])
        {
          v31 = &v64;
          mlir::DiagnosticArgument::DiagnosticArgument(&v64, a2);
          v32 = v68;
          if (v69 >= v70)
          {
            if (v68 <= &v64 && v68 + 24 * v69 > &v64)
            {
              v58 = &v64 - v68;
              llvm::SmallVectorBase<unsigned int>::grow_pod(&v68, v71, v69 + 1, 24);
              v32 = v68;
              v31 = (v68 + v58);
            }

            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(&v68, v71, v69 + 1, 24);
              v31 = &v64;
              v32 = v68;
            }
          }

          v33 = &v32[24 * v69];
          v34 = *v31;
          *(v33 + 2) = *(v31 + 2);
          *v33 = v34;
          ++v69;
        }
      }
    }
  }

  v35 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v67);
  if (v67[0])
  {
    mlir::InFlightDiagnostic::report(v67);
  }

  if (v77 == 1)
  {
    if (v76 != &v77)
    {
      free(v76);
    }

    v36 = __p;
    if (__p)
    {
      v37 = v75;
      v38 = __p;
      if (v75 != __p)
      {
        do
        {
          v37 = sub_10005BEF4(v37 - 1);
        }

        while (v37 != v36);
        v38 = __p;
      }

      v75 = v36;
      operator delete(v38);
    }

    v39 = v72;
    if (v72)
    {
      v40 = v73;
      v41 = v72;
      if (v73 != v72)
      {
        do
        {
          v42 = *--v40;
          *v40 = 0;
          if (v42)
          {
            operator delete[]();
          }
        }

        while (v40 != v39);
        v41 = v72;
      }

      v73 = v39;
      operator delete(v41);
    }

    if (v68 != v71)
    {
      free(v68);
    }
  }

  return v35;
}

uint64_t mlir::ODIE::Compiler::CoreML::TransformCastOp::parse(mlir::ODIE::Compiler::CoreML::TransformCastOp *this, mlir::OpAsmParser *a2, mlir::OperationState *a3)
{
  memset(v11, 0, sizeof(v11));
  v12 = 0;
  v10[0] = v11;
  v10[1] = 1;
  v8[1] = 1;
  v9 = 0;
  v8[0] = &v9;
  v5 = (*(*this + 40))(this, a2, a3);
  if (((*(*this + 704))(this, v11, 1) & 1) == 0)
  {
    return 0;
  }

  if (((*(*this + 104))(this) & 1) == 0)
  {
    return 0;
  }

  v13 = 0;
  v14 = 0;
  if (!sub_100276760(this, &v13))
  {
    return 0;
  }

  v9 = v13;
  v15 = 257;
  if (((*(*this + 400))(this, "to", 2, &v13) & 1) == 0)
  {
    return 0;
  }

  v13 = 0;
  v14 = 0;
  if (!sub_100276760(this, &v13))
  {
    return 0;
  }

  v7 = v13;
  (*(*this + 40))(this);
  if (((*(*this + 488))(this, a2 + 112) & 1) == 0)
  {
    return 0;
  }

  sub_1001EFDBC(a2, &v7, 1);
  return sub_10022A240(this, v10, v8, v5, a2 + 16) & 1;
}

void mlir::ODIE::Compiler::CoreML::TransformCastOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v4 = (*(*a2 + 16))(a2);
  v5 = *(v4 + 4);
  if (v5 >= *(v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }

  else
  {
    *(v4 + 4) = v5 + 1;
    *v5 = 32;
  }

  (*(*a2 + 160))(a2, *(*(*this + 9) + 24));
  v6 = (*(*a2 + 16))(a2);
  v7 = *(v6 + 4);
  if (v7 >= *(v6 + 3))
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    *(v6 + 4) = v7 + 1;
    *v7 = 32;
  }

  v8 = (*(*a2 + 16))(a2);
  v9 = v8[4];
  if (v8[3] == v9)
  {
    llvm::raw_ostream::write(v8, ":", 1uLL);
  }

  else
  {
    *v9 = 58;
    ++v8[4];
  }

  v10 = (*(*a2 + 16))(a2);
  v11 = *(v10 + 4);
  if (v11 >= *(v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }

  else
  {
    *(v10 + 4) = v11 + 1;
    *v11 = 32;
  }

  NextResultAtOffset = *(*(*this + 9) + 24);
  v12 = sub_100276570(&NextResultAtOffset);
  v13 = sub_100276660(v12);
  if (v13)
  {
    v14 = v13;
  }

  else
  {
    v14 = v12;
  }

  (*(*a2 + 32))(a2, v14);
  v15 = (*(*a2 + 16))(a2);
  v16 = *(v15 + 4);
  if (v16 >= *(v15 + 3))
  {
    llvm::raw_ostream::write(v15, 32);
  }

  else
  {
    *(v15 + 4) = v16 + 1;
    *v16 = 32;
  }

  v17 = (*(*a2 + 16))(a2);
  v18 = v17[4];
  if (v17[3] - v18 > 1uLL)
  {
    *v18 = 28532;
    v17[4] += 2;
  }

  else
  {
    llvm::raw_ostream::write(v17, "to", 2uLL);
  }

  v19 = (*(*a2 + 16))(a2);
  v20 = *(v19 + 4);
  if (v20 >= *(v19 + 3))
  {
    llvm::raw_ostream::write(v19, 32);
  }

  else
  {
    *(v19 + 4) = v20 + 1;
    *v20 = 32;
  }

  if (*(*this + 9))
  {
    v21 = *this - 16;
  }

  else
  {
    v21 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v21, 0);
  v22 = sub_100276570(&NextResultAtOffset);
  v23 = sub_100276660(v22);
  if (v23)
  {
    v24 = v23;
  }

  else
  {
    v24 = v22;
  }

  (*(*a2 + 32))(a2, v24);
  NextResultAtOffset = v30;
  v29 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  Value = mlir::DictionaryAttr::getValue(&AttrDictionary);
  (*(*a2 + 192))(a2, Value, v26, NextResultAtOffset, v29);
  if (NextResultAtOffset != v30)
  {
    free(NextResultAtOffset);
  }
}

void *sub_100276570(uint64_t a1)
{
  result = (*(*a1 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (result)
  {
    v2 = *result;
    {
      v3 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id;
      v4 = *(v2 + 8);
      v5 = *(v2 + 16);
      if (!v5)
      {
        return result;
      }
    }

    else
    {
      v13 = v2;
      v14 = result;
      sub_1002AAB00();
      result = v14;
      v3 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id;
      v4 = *(v13 + 8);
      v5 = *(v13 + 16);
      if (!v5)
      {
        return result;
      }
    }

    v6 = v4;
    v7 = v5;
    do
    {
      v8 = v7 >> 1;
      v9 = &v6[2 * (v7 >> 1)];
      v11 = *v9;
      v10 = v9 + 2;
      v7 += ~(v7 >> 1);
      if (v11 < v3)
      {
        v6 = v10;
      }

      else
      {
        v7 = v8;
      }
    }

    while (v7);
    if (v6 != &v4[2 * v5] && *v6 == v3)
    {
      v12 = v6[1];
    }
  }

  return result;
}

void *sub_100276660(void *result)
{
  if (result)
  {
    v1 = *result;
    {
      v2 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id;
      v3 = *(v1 + 8);
      v4 = *(v1 + 16);
      if (!v4)
      {
        return result;
      }
    }

    else
    {
      v12 = v1;
      v13 = result;
      sub_1002AAB00();
      result = v13;
      v2 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id;
      v3 = *(v12 + 8);
      v4 = *(v12 + 16);
      if (!v4)
      {
        return result;
      }
    }

    v5 = v3;
    v6 = v4;
    do
    {
      v7 = v6 >> 1;
      v8 = &v5[2 * (v6 >> 1)];
      v10 = *v8;
      v9 = v8 + 2;
      v6 += ~(v6 >> 1);
      if (v10 < v2)
      {
        v5 = v9;
      }

      else
      {
        v6 = v7;
      }
    }

    while (v6);
    if (v5 != &v3[2 * v4] && *v5 == v2)
    {
      v11 = v5[1];
    }
  }

  return result;
}

BOOL sub_100276760(uint64_t a1, void *a2)
{
  v4 = (*(*a1 + 40))(a1);
  v18 = 0;
  if (((*(*a1 + 536))(a1, &v18) & 1) == 0)
  {
    return 0;
  }

  v5 = sub_100067788(v18);
  *a2 = v5;
  a2[1] = v6;
  if (v5)
  {
    return 1;
  }

  v16 = "invalid kind of type specified";
  v17 = 259;
  (*(*a1 + 24))(v19, a1, v4, &v16);
  result = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v19);
  v8 = result;
  if (v19[0])
  {
    mlir::InFlightDiagnostic::report(v19);
    result = v8;
  }

  if (v27 == 1)
  {
    if (v26 != &v27)
    {
      free(v26);
      result = v8;
    }

    v9 = __p;
    if (__p)
    {
      v10 = v25;
      v11 = __p;
      if (v25 != __p)
      {
        do
        {
          v10 = sub_10005BEF4(v10 - 1);
        }

        while (v10 != v9);
        v11 = __p;
      }

      v25 = v9;
      operator delete(v11);
      result = v8;
    }

    v12 = v22;
    if (v22)
    {
      v13 = v23;
      v14 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = *--v13;
          *v13 = 0;
          if (v15)
          {
            operator delete[]();
          }
        }

        while (v13 != v12);
        v14 = v22;
      }

      v23 = v12;
      operator delete(v14);
      result = v8;
    }

    if (v20 != &v21)
    {
      free(v20);
      return v8;
    }
  }

  return result;
}

uint64_t mlir::ODIE::Compiler::Transforms::getValuesNotUsedByOps@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  v3 = *(result + 24);
  v4 = *(result + 32);
  *a2 = a2 + 16;
  *(a2 + 8) = 0x600000000;
  if (v4)
  {
    v5 = result;
    v6 = v3 + 8 * v4;
    do
    {
      v7 = *(*v3 + 36);
      if (v7)
      {
        v8 = *v3 - 16;
      }

      else
      {
        v8 = 0;
      }

      if (v7)
      {
        for (i = 0; i != v7; ++i)
        {
          result = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, i);
          v13 = *result;
          if (*result)
          {
            v16 = *(v5 + 16);
            if (v16)
            {
              v17 = *v5;
              v18 = v16 - 1;
              while (1)
              {
                v10 = v13[2];
                v11 = ((v10 >> 4) ^ (v10 >> 9)) & v18;
                v12 = *(v17 + 8 * v11);
                if (v12 != v10)
                {
                  break;
                }

LABEL_10:
                if (v11 == v16)
                {
                  goto LABEL_20;
                }

                v13 = *v13;
                if (!v13)
                {
                  goto LABEL_23;
                }
              }

              v14 = 1;
              while (v12 != -4096)
              {
                v15 = v11 + v14++;
                v11 = v15 & v18;
                v12 = *(v17 + 8 * v11);
                if (v12 == v10)
                {
                  goto LABEL_10;
                }
              }
            }

LABEL_20:
            result = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, i);
            v19 = *(a2 + 8);
            if (v19 >= *(a2 + 12))
            {
              v20 = result;
              llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (a2 + 16), v19 + 1, 8);
              result = v20;
              v19 = *(a2 + 8);
            }

            *(*a2 + 8 * v19) = result;
            ++*(a2 + 8);
          }

LABEL_23:
          ;
        }
      }

      v3 += 8;
    }

    while (v3 != v6);
  }

  return result;
}

void mlir::ODIE::Compiler::Transforms::fixupResultTokens(llvm *a1, uint64_t a2, uint64_t a3)
{
  v37[0] = a1;
  v37[1] = 0;
  *&v38 = a1;
  *(&v38 + 1) = a2;
  if (a2)
  {
    v5 = 0;
    do
    {
      if (*(*(*(mlir::ValueRange::dereference_iterator(v37, v5) + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::HandleType,void>::id)
      {
        break;
      }

      v5 = (v37[1] + 1);
      v37[1] = v5;
    }

    while (v5 != *(&v38 + 1));
  }

  v34 = *v37;
  v35 = v38;
  v36 = v39;
  v37[0] = 0;
  v37[1] = 0;
  LODWORD(v38) = 0;
  __src = 0;
  v6 = *(&v34 + 1);
  while (v6 != a2)
  {
    v31 = __src;
    v32 = mlir::ValueRange::dereference_iterator(&v34, v6);
    *sub_100083360(v37, &v32) = v31;
    v6 = *(&v34 + 1) + 1;
    __src = __src + 1;
    for (*(&v34 + 1) = v6; v6 != *(&v35 + 1); *(&v34 + 1) = v6)
    {
      v18 = mlir::ValueRange::dereference_iterator(&v34, v6);
      v6 = *(&v34 + 1);
      if (*(*(*(v18 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::HandleType,void>::id)
      {
        break;
      }

      v6 = *(&v34 + 1) + 1;
    }
  }

  v7 = *a3;
  v8 = *(a3 + 8);
  v9 = *a3 + 8 * v8;
  v10 = *a3;
  if (v8)
  {
    v11 = 8 * v8;
    v10 = *a3;
    while (*(*(*(*v10 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id)
    {
      ++v10;
      v11 -= 8;
      if (!v11)
      {
        __src = &v34 + 8;
        *&v34 = 0x600000000;
        v12 = &v34 + 8;
        goto LABEL_35;
      }
    }
  }

  __src = &v34 + 8;
  *&v34 = 0x600000000;
  if (v10 == v9)
  {
    LODWORD(v11) = 0;
    v12 = &v34 + 8;
    LODWORD(v34) = 0;
    v9 = v7 + 8 * v8;
    v19 = v7;
    if (!v8)
    {
      goto LABEL_39;
    }

    goto LABEL_35;
  }

  v13 = 0;
  v14 = v10;
LABEL_13:
  v15 = v13++;
  while (++v14 != v9)
  {
    if (*(*(*(*v14 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id)
    {
      if (v14 != v9)
      {
        goto LABEL_13;
      }

      break;
    }
  }

  if (v15 < 6)
  {
    v16 = 0;
    v17 = 0;
    v12 = &v34 + 8;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&__src, &v34 + 8, v13, 8);
    v16 = v34;
    v12 = __src;
    v17 = v34;
  }

  v20 = &v12[8 * v16];
  do
  {
    v21 = *v10++;
    *v20 = v21;
    if (v10 == v9)
    {
      break;
    }

    while (*(*(*(*v10 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id)
    {
      if (++v10 == v9)
      {
        goto LABEL_34;
      }
    }

    v20 += 8;
  }

  while (v10 != v9);
LABEL_34:
  LODWORD(v11) = v17 + v13;
  v7 = *a3;
  v22 = *(a3 + 8);
  LODWORD(v34) = v11;
  v9 = v7 + 8 * v22;
  v19 = v7;
  if (v22)
  {
LABEL_35:
    v19 = v7;
    while (*(*(*(*v19 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id)
    {
      v19 += 8;
      if (v19 == v9)
      {
        goto LABEL_46;
      }
    }
  }

LABEL_39:
  if (v19 != v9)
  {
    for (i = v19 + 8; i != v9; i += 8)
    {
      if (*(*(*(*i + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id)
      {
        *v19 = *i;
        v19 += 8;
      }
    }
  }

  v9 = v19;
LABEL_46:
  *(a3 + 8) = (v9 - v7) >> 3;
  v30 = v37;
  v31 = &v30;
  v24 = 126 - 2 * __clz(v11);
  if (v11)
  {
    v25 = v24;
  }

  else
  {
    v25 = 0;
  }

  sub_100277A44(v12, &v12[8 * v11], &v31, v25, 1);
  v26 = __src;
  v27 = v34;
  v28 = *(a3 + 8);
  v29 = v28 + v34;
  if (v29 > *(a3 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (a3 + 16), v29, 8);
    LODWORD(v28) = *(a3 + 8);
  }

  if (v27)
  {
    memcpy((*a3 + 8 * v28), v26, 8 * v27);
    LODWORD(v28) = *(a3 + 8);
  }

  *(a3 + 8) = v28 + v27;
  if (__src != &v34 + 8)
  {
    free(__src);
  }

  llvm::deallocate_buffer(v37[0], (16 * v38), 8uLL);
}

uint64_t mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, mlir::ForwardIterator *), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v54[0] = a5;
  v54[1] = a6;
  v7 = a1 + 64;
  v8 = *(a1 + 44);
  v9 = (v8 >> 23) & 1;
  v10 = (v8 >> 21) & 0x7F8;
  v11 = 32 * *(a1 + 40);
  v12 = (((a1 + 64 + 16 * v9 + v10 + 7) & 0xFFFFFFFFFFFFFFF8) + v11);
  if (*v12 != v12)
  {
    v58 = v60;
    v59 = 0x600000000;
    v16 = v12[1];
    if (v16)
    {
      v17 = v16 - 8;
    }

    else
    {
      v17 = 0;
    }

    v18 = *(v17 + 40);
    v19 = (v17 + 32);
    if (v18 == v19 || (v20 = *v19, v18 == *v19))
    {
      v23 = 0;
      v26 = v60;
    }

    else
    {
      do
      {
        ValuePtr = llvm::ilist_detail::SpecificNodeAccess<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false,void>>::getValuePtr(v18);
        v22 = v59;
        if (v59 >= HIDWORD(v59))
        {
          v24 = ValuePtr;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v58, v60, v59 + 1, 8);
          ValuePtr = v24;
          v22 = v59;
        }

        v58[v22] = ValuePtr;
        v23 = v59 + 1;
        LODWORD(v59) = v59 + 1;
        v18 = v18[1];
      }

      while (v18 != v20);
      v25 = *(a1 + 44);
      v26 = v58;
      v9 = (v25 >> 23) & 1;
      v10 = (v25 >> 21) & 0x7F8;
      v11 = 32 * *(a1 + 40);
    }

    v53 = 0;
    v45[0] = 0;
    v45[1] = 0;
    v46 = 0;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v50 = 0;
    v51 = 0;
    v52 = 0;
    v56[0] = v57;
    v56[1] = 0x600000000;
    v44[0] = a7;
    v44[1] = &v53;
    v44[2] = v45;
    v44[3] = v56;
    v27 = *(a1 + 24);
    v44[4] = v54;
    v44[5] = v27;
    v43[0] = a7;
    v43[1] = v45;
    v42[0] = a7;
    v42[1] = &v53;
    v28 = *(((v7 + 16 * v9 + v10 + 7) & 0xFFFFFFFFFFFFFFF8) + v11 + 8);
    if (v28)
    {
      v29 = v28 - 8;
    }

    else
    {
      v29 = 0;
    }

    v42[2] = v29;
    v42[3] = v45;
    v42[4] = v56;
    if (v23)
    {
      v30 = 8 * v23;
      while (1)
      {
        v31 = *v26;
        if (*v26)
        {
          v32 = *(*(*v26 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp,void>::id;
        }

        else
        {
          v32 = 0;
        }

        if (v32)
        {
          goto LABEL_17;
        }

        {
          sub_1002AB034();
        }

        if ((*(**(v31 + 6) + 32))(*(v31 + 6), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id))
        {
          goto LABEL_18;
        }

        if ((a3(a4, v31) & 1) == 0)
        {
LABEL_17:
          sub_10027739C(v44, v31);
        }

        else
        {
          v33 = v53;
          if (!v53)
          {
            v34 = ((v7 + 16 * ((*(a1 + 44) >> 23) & 1) + ((*(a1 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a1 + 40);
            mlir::TypeRange::TypeRange(&v55, 0, 0);
            mlir::OpBuilder::createBlock();
          }

          v41 = *(a7 + 24);
          *(a7 + 24) = v53;
          *(a7 + 32) = v33 + 32;
          sub_1000B05C8(v31, sub_1002AC26C, v42, 0);
          mlir::RewriterBase::moveOpBefore(a7, v31, v53, v53 + 4);
          sub_1000B05C8(v31, sub_1002AC618, v43, 0);
          if (v41)
          {
            *(a7 + 24) = v41;
          }

          else
          {
            *(a7 + 24) = 0;
            *(a7 + 32) = 0;
          }
        }

LABEL_18:
        v26 += 8;
        v30 -= 8;
        if (!v30)
        {
          v35 = *(a1 + 44);
          v9 = (v35 >> 23) & 1;
          v10 = (v35 >> 21) & 0x7F8;
          v11 = 32 * *(a1 + 40);
          break;
        }
      }
    }

    v36 = *(((v7 + 16 * v9 + v10 + 7) & 0xFFFFFFFFFFFFFFF8) + v11 + 8);
    if (v36)
    {
      v37 = (v36 - 8);
    }

    else
    {
      v37 = 0;
    }

    Terminator = mlir::Block::getTerminator(v37);
    sub_10027739C(v44, Terminator);
    if (v56[0] != v57)
    {
      free(v56[0]);
    }

    llvm::deallocate_buffer(v50, (16 * v52), 8uLL);
    llvm::deallocate_buffer(v47, (16 * v49), 8uLL);
    llvm::deallocate_buffer(v45[0], (16 * v46), 8uLL);
    if (v58 != v60)
    {
      free(v58);
    }
  }

  return 1;
}

uint64_t *sub_10027739C(uint64_t *result, uint64_t a2)
{
  v2 = *result[1];
  if (v2)
  {
    v3 = v2 + 4;
    if (v2[4] != v2 + 4)
    {
      v5 = *result;
      v6 = result[4];
      v7 = result[5];
      v8 = result[3];
      v9 = *v6;
      v20 = *(v6 + 8);
      v24 = 0;
      *v23 = 0u;
      v25 = &v27;
      v26 = 0;
      v33 = v23;
      v10 = v2[5];
      if (v10 != v3)
      {
        do
        {
          v11 = v10[1];
          ValuePtr = llvm::ilist_detail::SpecificNodeAccess<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false,void>>::getValuePtr(v10);
          sub_1000B05C8(ValuePtr, sub_10027795C, &v33, 1);
          v10 = v11;
        }

        while (v11 != v3);
      }

      mlir::ODIE::Compiler::Transforms::getValuesNotUsedByOps(v23, &v33);
      mlir::ValueRange::ValueRange(&v27, v2[6], (v2[7] - v2[6]) >> 3);
      mlir::ODIE::Compiler::Transforms::fixupResultTokens(v27, v28, &v33);
      v21 = *(v5 + 24);
      *(v5 + 24) = v2;
      *(v5 + 32) = v3;
      sub_100277740((v5 + 8), v7, &v33);
      v13 = *(a2 + 16);
      NodePtr = llvm::ilist_detail::SpecificNodeAccess<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false,void>>::getNodePtr(a2);
      *(v5 + 24) = v13;
      *(v5 + 32) = NodePtr;
      v15 = *(v5 + 8);
      mlir::ValueRange::ValueRange(&Results, *v8, *(v8 + 8));
      mlir::TypeRange::TypeRange(&v27, Results, v32);
      v16 = v27;
      v17 = v28;
      mlir::ValueRange::ValueRange(v30, v33, v34);
      mlir::TypeRange::TypeRange(&v27, v30[0], v30[1]);
      v22 = mlir::FunctionType::get(v15, v16, v17, v27, v28);
      Results = mlir::FunctionType::getResults(&v22);
      v32 = v18;
      v29 = 261;
      v27 = v9;
      v28 = v20;
      v30[0] = mlir::Builder::getStringAttr((v5 + 8), &v27, v19);
      sub_100277838(v5 + 8, v7, &Results, v8, v30);
    }
  }

  return result;
}

uint64_t sub_100277740(void *a1, uint64_t a2, uint64_t a3)
{
  v12 = a2;
  Context = mlir::Attribute::getContext(&v12);
  v7 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::YieldOp,void>::id, Context);
  if ((v8 & 1) == 0)
  {
    sub_1002AC7BC(v14, v15, v13);
  }

  mlir::OperationState::OperationState(v14, a2, v7);
  mlir::ValueRange::ValueRange(v15, *a3, *(a3 + 8));
  mlir::ODIE::Compiler::CoreML::YieldOp::build(a1, v14, v15[0], v15[1]);
  v9 = mlir::OpBuilder::create(a1, v14);
  if (*(*(v9 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::YieldOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v14);
  return v10;
}

void sub_100277838(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  v13 = a2;
  Context = mlir::Attribute::getContext(&v13);
  v11 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp,void>::id, Context);
  if (v12)
  {
    mlir::OperationState::OperationState(v14, a2, v11);
    mlir::TypeRange::TypeRange(v16, *a3, *(a3 + 8));
    mlir::ValueRange::ValueRange(v15, *a4, *(a4 + 8));
    mlir::ODIE::Compiler::CoreML::IsolatedGroupOp::build(a1, v14, v16[0], v16[1], v15[0], v15[1], *a5, 0, 0);
  }

  sub_1002AC800(v14, v16, v15);
}

void sub_10027795C(uint64_t *a1, uint64_t a2)
{
  v2 = *a1;
  v5 = a2;
  sub_100153A08(v2, &v5, v6);
  if (v6[16] == 1)
  {
    v3 = v5;
    v4 = *(v2 + 32);
    if (v4 >= *(v2 + 36))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2 + 24, (v2 + 40), v4 + 1, 8);
      LODWORD(v4) = *(v2 + 32);
    }

    *(*(v2 + 24) + 8 * v4) = v3;
    ++*(v2 + 32);
  }
}

uint64_t sub_1002779E8(uint64_t a1, uint64_t a2)
{
  ParentOp = *(a2 + 16);
  while (1)
  {
    v3 = *(ParentOp + 16);
    if (!v3)
    {
      break;
    }

    ParentOp = mlir::Block::getParentOp(v3);
    if (!ParentOp)
    {
      break;
    }

    if (*(*(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp,void>::id)
    {
      return 0;
    }
  }

  return 1;
}

unint64_t sub_100277A44(unint64_t result, uint64_t *a2, uint64_t **a3, uint64_t a4, char a5)
{
  v541 = result;
LABEL_2:
  v527 = a2 - 1;
  v6 = v541;
  while (1)
  {
    v7 = a2 - v6;
    v541 = v6;
    if (v7 > 2)
    {
      v8 = v6;
      switch(v7)
      {
        case 3:
          return sub_10027A7F0(v6, v6 + 1, v527, a3);
        case 4:
          return sub_10027AAF4(v6, v6 + 1, v6 + 2, v527, a3);
        case 5:
          return sub_10027ACF0(v6, v6 + 1, v6 + 2, v6 + 3, v527, a3);
      }

      goto LABEL_10;
    }

    if (v7 < 2)
    {
      return result;
    }

    v8 = v6;
    if (v7 == 2)
    {
      break;
    }

LABEL_10:
    if (v7 <= 23)
    {
      v288 = v8 + 1;
      v290 = v8 == a2 || v288 == a2;
      if (a5)
      {
        if (v290)
        {
          return result;
        }

        v291 = v6;
LABEL_438:
        v293 = v288;
        v294 = *v291;
        v295 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v291[1]);
        if (HandleForToken)
        {
          v296 = *sub_100083360(*v295, &HandleForToken);
          v297 = *a3;
          result = mlir::ODIE::Compiler::getHandleForToken(v294);
          HandleForToken = result;
          if (result)
          {
            goto LABEL_440;
          }
        }

        else
        {
          v296 = -1;
          v297 = *a3;
          result = mlir::ODIE::Compiler::getHandleForToken(v294);
          HandleForToken = result;
          if (result)
          {
LABEL_440:
            result = sub_100083360(*v297, &HandleForToken);
            if (v296 >= *result)
            {
              goto LABEL_437;
            }

LABEL_444:
            v298 = *v293;
            v292 = v293;
            while (1)
            {
              while (1)
              {
                *v292 = *v291;
                if (v291 == v541)
                {
                  v292 = v541;
LABEL_436:
                  *v292 = v298;
LABEL_437:
                  v288 = v293 + 1;
                  v291 = v293;
                  if (v293 + 1 == a2)
                  {
                    return result;
                  }

                  goto LABEL_438;
                }

                v292 = v291;
                v300 = *--v291;
                v299 = v300;
                v301 = *a3;
                v302 = mlir::ODIE::Compiler::getHandleForToken(v298);
                if (v302)
                {
                  break;
                }

                v315 = -1;
                v316 = *a3;
                result = mlir::ODIE::Compiler::getHandleForToken(v299);
                if (result)
                {
                  goto LABEL_467;
                }

LABEL_445:
                if (v315 >= -1)
                {
                  goto LABEL_436;
                }
              }

              v303 = *v301;
              v304 = *(v303 + 16);
              if (!v304)
              {
                break;
              }

              v305 = 0x9DDFEA08EB382D69 * ((8 * v302 - 0xAE502812AA7333) ^ HIDWORD(v302));
              v306 = 0x9DDFEA08EB382D69 * (HIDWORD(v302) ^ (v305 >> 47) ^ v305);
              v307 = v304 - 1;
              v308 = (v304 - 1) & (-348639895 * ((v306 >> 47) ^ v306));
              v309 = (*v303 + 16 * v308);
              v310 = *v309;
              if (*v309 == v302)
              {
                goto LABEL_466;
              }

              v311 = 0;
              v312 = 1;
              while (v310 != -4096)
              {
                if (v311)
                {
                  v313 = 0;
                }

                else
                {
                  v313 = v310 == -8192;
                }

                if (v313)
                {
                  v311 = v309;
                }

                v314 = v308 + v312++;
                v308 = v314 & v307;
                v309 = (*v303 + 16 * (v314 & v307));
                v310 = *v309;
                if (*v309 == v302)
                {
                  goto LABEL_466;
                }
              }

              if (v311)
              {
                v309 = v311;
              }

              v331 = *(v303 + 8);
              if (4 * v331 + 4 >= 3 * v304)
              {
                goto LABEL_488;
              }

              if (v304 + ~v331 - *(v303 + 12) <= v304 >> 3)
              {
                v332 = v302;
                goto LABEL_494;
              }

              *(v303 + 8) = v331 + 1;
              if (*v309 != -4096)
              {
                goto LABEL_464;
              }

LABEL_465:
              *v309 = v302;
              v309[1] = 0;
LABEL_466:
              v315 = *(v309 + 2);
              v316 = *a3;
              result = mlir::ODIE::Compiler::getHandleForToken(v299);
              if (!result)
              {
                goto LABEL_445;
              }

LABEL_467:
              v318 = *v316;
              v319 = *(*v316 + 16);
              if (!v319)
              {
                v330 = (4 * *(v318 + 8) + 4);
                goto LABEL_492;
              }

              v320 = 0x9DDFEA08EB382D69 * ((8 * result - 0xAE502812AA7333) ^ HIDWORD(result));
              v321 = 0x9DDFEA08EB382D69 * (HIDWORD(result) ^ (v320 >> 47) ^ v320);
              v322 = v319 - 1;
              v323 = (v319 - 1) & (-348639895 * ((v321 >> 47) ^ v321));
              v324 = (*v318 + 16 * v323);
              v325 = *v324;
              if (*v324 != result)
              {
                v326 = 0;
                v327 = 1;
                while (v325 != -4096)
                {
                  if (v326)
                  {
                    v328 = 0;
                  }

                  else
                  {
                    v328 = v325 == -8192;
                  }

                  if (v328)
                  {
                    v326 = v324;
                  }

                  v329 = v323 + v327++;
                  v323 = v329 & v322;
                  v324 = (*v318 + 16 * (v329 & v322));
                  v325 = *v324;
                  if (*v324 == result)
                  {
                    goto LABEL_483;
                  }
                }

                if (v326)
                {
                  v324 = v326;
                }

                v333 = *(v318 + 8);
                if (4 * v333 + 4 >= 3 * v319)
                {
LABEL_492:
                  v334 = result;
                  v319 *= 2;
                  goto LABEL_506;
                }

                if (v319 + ~v333 - *(v318 + 12) <= v319 >> 3)
                {
                  v334 = result;
LABEL_506:
                  sub_100083608(v318, v319);
                  v345 = *(v318 + 16);
                  if (v345)
                  {
                    result = v334;
                    v346 = 0x9DDFEA08EB382D69 * ((8 * v334 - 0xAE502812AA7333) ^ HIDWORD(v334));
                    v347 = 0x9DDFEA08EB382D69 * (HIDWORD(v334) ^ (v346 >> 47) ^ v346);
                    LODWORD(v346) = -348639895 * ((v347 >> 47) ^ v347);
                    v348 = v345 - 1;
                    v349 = (v345 - 1) & v346;
                    v324 = (*v318 + 16 * v349);
                    v350 = *v324;
                    if (*v324 != v334)
                    {
                      v351 = 0;
                      v352 = 1;
                      while (v350 != -4096)
                      {
                        if (v351)
                        {
                          v353 = 0;
                        }

                        else
                        {
                          v353 = v350 == -8192;
                        }

                        if (v353)
                        {
                          v351 = v324;
                        }

                        v354 = v349 + v352++;
                        v349 = v354 & v348;
                        v324 = (*v318 + 16 * (v354 & v348));
                        v350 = *v324;
                        if (*v324 == v334)
                        {
                          goto LABEL_521;
                        }
                      }

                      if (v351)
                      {
                        v324 = v351;
                      }
                    }
                  }

                  else
                  {
                    v324 = 0;
                    result = v334;
                  }

LABEL_521:
                  ++*(v318 + 8);
                  if (*v324 != -4096)
                  {
LABEL_481:
                    --*(v318 + 12);
                  }
                }

                else
                {
                  *(v318 + 8) = v333 + 1;
                  if (*v324 != -4096)
                  {
                    goto LABEL_481;
                  }
                }

                *v324 = result;
                v324[1] = 0;
              }

LABEL_483:
              if (v315 >= *(v324 + 2))
              {
                goto LABEL_436;
              }
            }

            v317 = (4 * *(v303 + 8) + 4);
LABEL_488:
            v332 = v302;
            v304 *= 2;
LABEL_494:
            sub_100083608(v303, v304);
            v335 = *(v303 + 16);
            if (v335)
            {
              v302 = v332;
              v336 = 0x9DDFEA08EB382D69 * ((8 * v332 - 0xAE502812AA7333) ^ HIDWORD(v332));
              v337 = 0x9DDFEA08EB382D69 * (HIDWORD(v332) ^ (v336 >> 47) ^ v336);
              LODWORD(v336) = -348639895 * ((v337 >> 47) ^ v337);
              v338 = v335 - 1;
              v339 = (v335 - 1) & v336;
              v309 = (*v303 + 16 * v339);
              v340 = *v309;
              if (*v309 != v332)
              {
                v341 = 0;
                v342 = 1;
                while (v340 != -4096)
                {
                  if (v341)
                  {
                    v343 = 0;
                  }

                  else
                  {
                    v343 = v340 == -8192;
                  }

                  if (v343)
                  {
                    v341 = v309;
                  }

                  v344 = v339 + v342++;
                  v339 = v344 & v338;
                  v309 = (*v303 + 16 * (v344 & v338));
                  v340 = *v309;
                  if (*v309 == v332)
                  {
                    goto LABEL_518;
                  }
                }

                if (v341)
                {
                  v309 = v341;
                }
              }
            }

            else
            {
              v309 = 0;
              v302 = v332;
            }

LABEL_518:
            ++*(v303 + 8);
            if (*v309 == -4096)
            {
              goto LABEL_465;
            }

LABEL_464:
            --*(v303 + 12);
            goto LABEL_465;
          }
        }

        if (v296 >= -1)
        {
          goto LABEL_437;
        }

        goto LABEL_444;
      }

      if (v290)
      {
        return result;
      }

      while (1)
      {
        v459 = v288;
        v460 = *v541;
        v461 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v541[1]);
        if (HandleForToken)
        {
          v462 = *sub_100083360(*v461, &HandleForToken);
          v463 = *a3;
          result = mlir::ODIE::Compiler::getHandleForToken(v460);
          HandleForToken = result;
          if (!result)
          {
            goto LABEL_685;
          }
        }

        else
        {
          v462 = -1;
          v463 = *a3;
          result = mlir::ODIE::Compiler::getHandleForToken(v460);
          HandleForToken = result;
          if (!result)
          {
LABEL_685:
            if (v462 >= -1)
            {
              goto LABEL_679;
            }

LABEL_686:
            v464 = *v459;
            v465 = v459;
            while (2)
            {
              while (2)
              {
                v466 = v465;
                v465 = v541;
                *v466 = *v541;
                v467 = *--v541;
                v468 = *a3;
                v469 = mlir::ODIE::Compiler::getHandleForToken(v464);
                if (v469)
                {
                  v470 = *v468;
                  v471 = *(v470 + 16);
                  if (!v471)
                  {
                    v484 = (4 * *(v470 + 8) + 4);
                    goto LABEL_729;
                  }

                  v472 = 0x9DDFEA08EB382D69 * ((8 * v469 - 0xAE502812AA7333) ^ HIDWORD(v469));
                  v473 = 0x9DDFEA08EB382D69 * (HIDWORD(v469) ^ (v472 >> 47) ^ v472);
                  v474 = v471 - 1;
                  v475 = (v471 - 1) & (-348639895 * ((v473 >> 47) ^ v473));
                  v476 = (*v470 + 16 * v475);
                  v477 = *v476;
                  if (*v476 != v469)
                  {
                    v478 = 0;
                    v479 = 1;
                    while (v477 != -4096)
                    {
                      if (v478)
                      {
                        v480 = 0;
                      }

                      else
                      {
                        v480 = v477 == -8192;
                      }

                      if (v480)
                      {
                        v478 = v476;
                      }

                      v481 = v475 + v479++;
                      v475 = v481 & v474;
                      v476 = (*v470 + 16 * (v481 & v474));
                      v477 = *v476;
                      if (*v476 == v469)
                      {
                        goto LABEL_707;
                      }
                    }

                    if (v478)
                    {
                      v476 = v478;
                    }

                    v498 = *(v470 + 8);
                    if (4 * v498 + 4 >= 3 * v471)
                    {
LABEL_729:
                      v499 = v469;
                      v471 *= 2;
                      goto LABEL_735;
                    }

                    if (v471 + ~v498 - *(v470 + 12) <= v471 >> 3)
                    {
                      v499 = v469;
LABEL_735:
                      sub_100083608(v470, v471);
                      v502 = *(v470 + 16);
                      if (v502)
                      {
                        v469 = v499;
                        v503 = 0x9DDFEA08EB382D69 * ((8 * v499 - 0xAE502812AA7333) ^ HIDWORD(v499));
                        v504 = 0x9DDFEA08EB382D69 * (HIDWORD(v499) ^ (v503 >> 47) ^ v503);
                        LODWORD(v503) = -348639895 * ((v504 >> 47) ^ v504);
                        v505 = v502 - 1;
                        v506 = (v502 - 1) & v503;
                        v476 = (*v470 + 16 * v506);
                        v507 = *v476;
                        if (*v476 != v499)
                        {
                          v508 = 0;
                          v509 = 1;
                          while (v507 != -4096)
                          {
                            if (v508)
                            {
                              v510 = 0;
                            }

                            else
                            {
                              v510 = v507 == -8192;
                            }

                            if (v510)
                            {
                              v508 = v476;
                            }

                            v511 = v506 + v509++;
                            v506 = v511 & v505;
                            v476 = (*v470 + 16 * (v511 & v505));
                            v507 = *v476;
                            if (*v476 == v499)
                            {
                              goto LABEL_759;
                            }
                          }

                          if (v508)
                          {
                            v476 = v508;
                          }
                        }
                      }

                      else
                      {
                        v476 = 0;
                        v469 = v499;
                      }

LABEL_759:
                      ++*(v470 + 8);
                      if (*v476 != -4096)
                      {
LABEL_705:
                        --*(v470 + 12);
                      }
                    }

                    else
                    {
                      *(v470 + 8) = v498 + 1;
                      if (*v476 != -4096)
                      {
                        goto LABEL_705;
                      }
                    }

                    *v476 = v469;
                    v476[1] = 0;
                  }

LABEL_707:
                  v482 = *(v476 + 2);
                  v483 = *a3;
                  result = mlir::ODIE::Compiler::getHandleForToken(v467);
                  if (!result)
                  {
LABEL_687:
                    if (v482 >= -1)
                    {
                      goto LABEL_678;
                    }

                    continue;
                  }
                }

                else
                {
                  v482 = -1;
                  v483 = *a3;
                  result = mlir::ODIE::Compiler::getHandleForToken(v467);
                  if (!result)
                  {
                    goto LABEL_687;
                  }
                }

                break;
              }

              v485 = *v483;
              v486 = *(*v483 + 16);
              if (!v486)
              {
                v497 = (4 * *(v485 + 8) + 4);
                goto LABEL_733;
              }

              v487 = 0x9DDFEA08EB382D69 * ((8 * result - 0xAE502812AA7333) ^ HIDWORD(result));
              v488 = 0x9DDFEA08EB382D69 * (HIDWORD(result) ^ (v487 >> 47) ^ v487);
              v489 = v486 - 1;
              v490 = (v486 - 1) & (-348639895 * ((v488 >> 47) ^ v488));
              v491 = (*v485 + 16 * v490);
              v492 = *v491;
              if (*v491 != result)
              {
                v493 = 0;
                v494 = 1;
                while (v492 != -4096)
                {
                  if (v493)
                  {
                    v495 = 0;
                  }

                  else
                  {
                    v495 = v492 == -8192;
                  }

                  if (v495)
                  {
                    v493 = v491;
                  }

                  v496 = v490 + v494++;
                  v490 = v496 & v489;
                  v491 = (*v485 + 16 * (v496 & v489));
                  v492 = *v491;
                  if (*v491 == result)
                  {
                    goto LABEL_724;
                  }
                }

                if (v493)
                {
                  v491 = v493;
                }

                v500 = *(v485 + 8);
                if (4 * v500 + 4 >= 3 * v486)
                {
LABEL_733:
                  v501 = result;
                  v486 *= 2;
                  goto LABEL_747;
                }

                if (v486 + ~v500 - *(v485 + 12) <= v486 >> 3)
                {
                  v501 = result;
LABEL_747:
                  sub_100083608(v485, v486);
                  v512 = *(v485 + 16);
                  if (v512)
                  {
                    result = v501;
                    v513 = 0x9DDFEA08EB382D69 * ((8 * v501 - 0xAE502812AA7333) ^ HIDWORD(v501));
                    v514 = 0x9DDFEA08EB382D69 * (HIDWORD(v501) ^ (v513 >> 47) ^ v513);
                    LODWORD(v513) = -348639895 * ((v514 >> 47) ^ v514);
                    v515 = v512 - 1;
                    v516 = (v512 - 1) & v513;
                    v491 = (*v485 + 16 * v516);
                    v517 = *v491;
                    if (*v491 != v501)
                    {
                      v518 = 0;
                      v519 = 1;
                      while (v517 != -4096)
                      {
                        if (v518)
                        {
                          v520 = 0;
                        }

                        else
                        {
                          v520 = v517 == -8192;
                        }

                        if (v520)
                        {
                          v518 = v491;
                        }

                        v521 = v516 + v519++;
                        v516 = v521 & v515;
                        v491 = (*v485 + 16 * (v521 & v515));
                        v517 = *v491;
                        if (*v491 == v501)
                        {
                          goto LABEL_762;
                        }
                      }

                      if (v518)
                      {
                        v491 = v518;
                      }
                    }
                  }

                  else
                  {
                    v491 = 0;
                    result = v501;
                  }

LABEL_762:
                  ++*(v485 + 8);
                  if (*v491 != -4096)
                  {
LABEL_722:
                    --*(v485 + 12);
                  }
                }

                else
                {
                  *(v485 + 8) = v500 + 1;
                  if (*v491 != -4096)
                  {
                    goto LABEL_722;
                  }
                }

                *v491 = result;
                v491[1] = 0;
              }

LABEL_724:
              if (v482 >= *(v491 + 2))
              {
LABEL_678:
                *v465 = v464;
                goto LABEL_679;
              }

              continue;
            }
          }
        }

        result = sub_100083360(*v463, &HandleForToken);
        if (v462 < *result)
        {
          goto LABEL_686;
        }

LABEL_679:
        v288 = v459 + 1;
        v541 = v459;
        if (v459 + 1 == a2)
        {
          return result;
        }
      }
    }

    if (!a4)
    {
      if (v8 == a2)
      {
        return result;
      }

      v355 = (v7 - 2) >> 1;
      v535 = a2 - v6;
      v538 = v355;
      v356 = v6;
      while (1)
      {
        v357 = v355;
        if (v538 < v355)
        {
          goto LABEL_532;
        }

        v525 = v355;
        v358 = (2 * v355) | 1;
        v359 = &v356[v358];
        v360 = 2 * v355 + 2;
        if (v360 < v7)
        {
          break;
        }

LABEL_543:
        v357 = v525;
        v366 = &v356[v525];
        v367 = *v366;
        v368 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*v359);
        if (HandleForToken)
        {
          v369 = *sub_100083360(*v368, &HandleForToken);
          v370 = *a3;
          result = mlir::ODIE::Compiler::getHandleForToken(v367);
          HandleForToken = result;
          if (!result)
          {
            goto LABEL_548;
          }
        }

        else
        {
          v369 = -1;
          v370 = *a3;
          result = mlir::ODIE::Compiler::getHandleForToken(v367);
          HandleForToken = result;
          if (!result)
          {
LABEL_548:
            v356 = v541;
            v7 = v535;
            if (v369 >= -1)
            {
LABEL_549:
              v532 = *v366;
              while (1)
              {
                while (1)
                {
                  v371 = v359;
                  *v366 = *v359;
                  if (v538 < v358)
                  {
LABEL_531:
                    *v371 = v532;
                    v357 = v525;
                    goto LABEL_532;
                  }

                  v372 = (2 * v358) | 1;
                  v359 = &v356[v372];
                  v373 = 2 * v358 + 2;
                  if (v373 < v7)
                  {
                    break;
                  }

                  v358 = (2 * v358) | 1;
                  v378 = *a3;
                  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*v359);
                  if (!HandleForToken)
                  {
                    goto LABEL_565;
                  }

LABEL_557:
                  v379 = *sub_100083360(*v378, &HandleForToken);
                  v380 = *a3;
                  result = mlir::ODIE::Compiler::getHandleForToken(v532);
                  HandleForToken = result;
                  if (!result)
                  {
                    goto LABEL_566;
                  }

LABEL_550:
                  result = sub_100083360(*v380, &HandleForToken);
                  v7 = v535;
                  v366 = v371;
                  if (v379 < *result)
                  {
                    goto LABEL_531;
                  }
                }

                v374 = v359[1];
                v375 = *a3;
                HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*v359);
                if (HandleForToken)
                {
                  v528 = *sub_100083360(*v375, &HandleForToken);
                  v376 = *a3;
                  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v374);
                  if (HandleForToken)
                  {
                    goto LABEL_555;
                  }
                }

                else
                {
                  v528 = -1;
                  v376 = *a3;
                  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v374);
                  if (HandleForToken)
                  {
LABEL_555:
                    v377 = *sub_100083360(*v376, &HandleForToken);
                    goto LABEL_561;
                  }
                }

                v377 = -1;
LABEL_561:
                if (v528 >= v377)
                {
                  v358 = v372;
                }

                else
                {
                  ++v359;
                  v358 = v373;
                }

                v356 = v541;
                v378 = *a3;
                HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*v359);
                if (HandleForToken)
                {
                  goto LABEL_557;
                }

LABEL_565:
                v379 = -1;
                v380 = *a3;
                result = mlir::ODIE::Compiler::getHandleForToken(v532);
                HandleForToken = result;
                if (result)
                {
                  goto LABEL_550;
                }

LABEL_566:
                v7 = v535;
                v366 = v371;
                if (v379 < -1)
                {
                  goto LABEL_531;
                }
              }
            }

            goto LABEL_532;
          }
        }

        result = sub_100083360(*v370, &HandleForToken);
        v356 = v541;
        v7 = v535;
        if (v369 >= *result)
        {
          goto LABEL_549;
        }

LABEL_532:
        v355 = v357 - 1;
        if (!v357)
        {
          while (1)
          {
            v382 = 0;
            v383 = v541;
            v529 = *v541;
            v384 = (v7 - 2) >> 1;
            v533 = v384;
            v536 = v7;
            do
            {
              while (1)
              {
                v385 = &v383[v382];
                v386 = v385 + 1;
                v387 = (2 * v382) | 1;
                v388 = 2 * v382 + 2;
                if (v388 < v7)
                {
                  break;
                }

                v382 = (2 * v382) | 1;
                *v383 = *v386;
                v383 = v385 + 1;
                if (v387 > v384)
                {
                  goto LABEL_659;
                }
              }

              v391 = v385[2];
              v390 = v385 + 2;
              v389 = v391;
              v392 = *a3;
              v393 = mlir::ODIE::Compiler::getHandleForToken(*(v390 - 1));
              if (!v393)
              {
                v539 = -1;
                v406 = *a3;
                result = mlir::ODIE::Compiler::getHandleForToken(v389);
                if (!result)
                {
                  goto LABEL_586;
                }

                goto LABEL_593;
              }

              v394 = *v392;
              v395 = *(v394 + 16);
              if (!v395)
              {
                v408 = (4 * *(v394 + 8) + 4);
LABEL_618:
                v540 = v393;
                v395 *= 2;
LABEL_624:
                sub_100083608(v394, v395);
                v424 = *(v394 + 16);
                if (v424)
                {
                  v393 = v540;
                  v425 = 0x9DDFEA08EB382D69 * ((8 * v540 - 0xAE502812AA7333) ^ HIDWORD(v540));
                  v426 = 0x9DDFEA08EB382D69 * (HIDWORD(v540) ^ (v425 >> 47) ^ v425);
                  LODWORD(v425) = -348639895 * ((v426 >> 47) ^ v426);
                  v427 = v424 - 1;
                  v428 = (v424 - 1) & v425;
                  v400 = (*v394 + 16 * v428);
                  v429 = *v400;
                  if (*v400 != v540)
                  {
                    v430 = 0;
                    v431 = 1;
                    while (v429 != -4096)
                    {
                      if (v430)
                      {
                        v432 = 0;
                      }

                      else
                      {
                        v432 = v429 == -8192;
                      }

                      if (v432)
                      {
                        v430 = v400;
                      }

                      v433 = v428 + v431++;
                      v428 = v433 & v427;
                      v400 = (*v394 + 16 * (v433 & v427));
                      v429 = *v400;
                      if (*v400 == v540)
                      {
                        goto LABEL_648;
                      }
                    }

                    if (v430)
                    {
                      v400 = v430;
                    }
                  }
                }

                else
                {
                  v400 = 0;
                  v393 = v540;
                }

LABEL_648:
                ++*(v394 + 8);
                if (*v400 == -4096)
                {
                  goto LABEL_591;
                }

LABEL_590:
                --*(v394 + 12);
                goto LABEL_591;
              }

              v396 = 0x9DDFEA08EB382D69 * ((8 * v393 - 0xAE502812AA7333) ^ HIDWORD(v393));
              v397 = 0x9DDFEA08EB382D69 * (HIDWORD(v393) ^ (v396 >> 47) ^ v396);
              v398 = v395 - 1;
              v399 = (v395 - 1) & (-348639895 * ((v397 >> 47) ^ v397));
              v400 = (*v394 + 16 * v399);
              v401 = *v400;
              if (*v400 == v393)
              {
                goto LABEL_592;
              }

              v402 = 0;
              v403 = 1;
              while (v401 != -4096)
              {
                if (v402)
                {
                  v404 = 0;
                }

                else
                {
                  v404 = v401 == -8192;
                }

                if (v404)
                {
                  v402 = v400;
                }

                v405 = v399 + v403++;
                v399 = v405 & v398;
                v400 = (*v394 + 16 * (v405 & v398));
                v401 = *v400;
                if (*v400 == v393)
                {
                  goto LABEL_592;
                }
              }

              if (v402)
              {
                v400 = v402;
              }

              v422 = *(v394 + 8);
              if (4 * v422 + 4 >= 3 * v395)
              {
                goto LABEL_618;
              }

              if (v395 + ~v422 - *(v394 + 12) <= v395 >> 3)
              {
                v540 = v393;
                goto LABEL_624;
              }

              *(v394 + 8) = v422 + 1;
              if (*v400 != -4096)
              {
                goto LABEL_590;
              }

LABEL_591:
              *v400 = v393;
              v400[1] = 0;
LABEL_592:
              v539 = *(v400 + 2);
              v406 = *a3;
              result = mlir::ODIE::Compiler::getHandleForToken(v389);
              if (!result)
              {
LABEL_586:
                v407 = -1;
                goto LABEL_610;
              }

LABEL_593:
              v409 = *v406;
              v410 = *(*v406 + 16);
              if (!v410)
              {
                v421 = (4 * *(v409 + 8) + 4);
                goto LABEL_622;
              }

              v411 = 0x9DDFEA08EB382D69 * ((8 * result - 0xAE502812AA7333) ^ HIDWORD(result));
              v412 = 0x9DDFEA08EB382D69 * (HIDWORD(result) ^ (v411 >> 47) ^ v411);
              v413 = v410 - 1;
              v414 = (v410 - 1) & (-348639895 * ((v412 >> 47) ^ v412));
              v415 = (*v409 + 16 * v414);
              v416 = *v415;
              if (*v415 != result)
              {
                v417 = 0;
                v418 = 1;
                while (v416 != -4096)
                {
                  if (v417)
                  {
                    v419 = 0;
                  }

                  else
                  {
                    v419 = v416 == -8192;
                  }

                  if (v419)
                  {
                    v417 = v415;
                  }

                  v420 = v414 + v418++;
                  v414 = v420 & v413;
                  v415 = (*v409 + 16 * (v420 & v413));
                  v416 = *v415;
                  if (*v415 == result)
                  {
                    goto LABEL_609;
                  }
                }

                if (v417)
                {
                  v415 = v417;
                }

                v423 = *(v409 + 8);
                if (4 * v423 + 4 >= 3 * v410)
                {
LABEL_622:
                  v526 = result;
                  v410 *= 2;
                  goto LABEL_636;
                }

                if (v410 + ~v423 - *(v409 + 12) <= v410 >> 3)
                {
                  v526 = result;
LABEL_636:
                  sub_100083608(v409, v410);
                  v434 = *(v409 + 16);
                  if (v434)
                  {
                    result = v526;
                    v435 = 0x9DDFEA08EB382D69 * ((8 * v526 - 0xAE502812AA7333) ^ HIDWORD(v526));
                    v436 = 0x9DDFEA08EB382D69 * (HIDWORD(v526) ^ (v435 >> 47) ^ v435);
                    LODWORD(v435) = -348639895 * ((v436 >> 47) ^ v436);
                    v437 = v434 - 1;
                    v438 = (v434 - 1) & v435;
                    v415 = (*v409 + 16 * v438);
                    v439 = *v415;
                    if (*v415 != v526)
                    {
                      v440 = 0;
                      v441 = 1;
                      while (v439 != -4096)
                      {
                        if (v440)
                        {
                          v442 = 0;
                        }

                        else
                        {
                          v442 = v439 == -8192;
                        }

                        if (v442)
                        {
                          v440 = v415;
                        }

                        v443 = v438 + v441++;
                        v438 = v443 & v437;
                        v415 = (*v409 + 16 * (v443 & v437));
                        v439 = *v415;
                        if (*v415 == v526)
                        {
                          goto LABEL_651;
                        }
                      }

                      if (v440)
                      {
                        v415 = v440;
                      }
                    }
                  }

                  else
                  {
                    v415 = 0;
                    result = v526;
                  }

LABEL_651:
                  ++*(v409 + 8);
                  if (*v415 != -4096)
                  {
LABEL_607:
                    --*(v409 + 12);
                  }
                }

                else
                {
                  *(v409 + 8) = v423 + 1;
                  if (*v415 != -4096)
                  {
                    goto LABEL_607;
                  }
                }

                *v415 = result;
                v415[1] = 0;
              }

LABEL_609:
              v407 = *(v415 + 2);
LABEL_610:
              v384 = v533;
              v7 = v536;
              if (v539 >= v407)
              {
                v382 = v387;
              }

              else
              {
                v386 = v390;
                v382 = v388;
              }

              *v383 = *v386;
              v383 = v386;
            }

            while (v382 <= v533);
LABEL_659:
            v444 = a2 - 1;
            v49 = v386 == --a2;
            if (v49)
            {
              *v386 = v529;
              goto LABEL_569;
            }

            *v386 = *v444;
            *v444 = v529;
            v445 = (v386 - v541 + 8) >> 3;
            v381 = v445 < 2;
            v446 = v445 - 2;
            if (!v381)
            {
              v447 = v446 >> 1;
              v448 = &v541[v446 >> 1];
              v449 = *v386;
              v450 = *a3;
              HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*v448);
              if (HandleForToken)
              {
                v451 = *sub_100083360(*v450, &HandleForToken);
                v452 = *a3;
                result = mlir::ODIE::Compiler::getHandleForToken(v449);
                HandleForToken = result;
                if (result)
                {
LABEL_663:
                  result = sub_100083360(*v452, &HandleForToken);
                  v453 = v541;
                  v7 = v536;
                  if (v451 >= *result)
                  {
                    goto LABEL_569;
                  }

                  goto LABEL_667;
                }
              }

              else
              {
                v451 = -1;
                v452 = *a3;
                result = mlir::ODIE::Compiler::getHandleForToken(v449);
                HandleForToken = result;
                if (result)
                {
                  goto LABEL_663;
                }
              }

              v453 = v541;
              v7 = v536;
              if (v451 >= -1)
              {
                goto LABEL_569;
              }

LABEL_667:
              v454 = *v386;
              while (1)
              {
                v455 = v448;
                *v386 = *v448;
                if (!v447)
                {
LABEL_675:
                  *v455 = v454;
                  v7 = v536;
                  break;
                }

                v447 = (v447 - 1) >> 1;
                v448 = &v453[v447];
                v456 = *a3;
                HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*v448);
                if (HandleForToken)
                {
                  v457 = *sub_100083360(*v456, &HandleForToken);
                  v458 = *a3;
                  result = mlir::ODIE::Compiler::getHandleForToken(v454);
                  HandleForToken = result;
                  if (result)
                  {
                    goto LABEL_668;
                  }
                }

                else
                {
                  v457 = -1;
                  v458 = *a3;
                  result = mlir::ODIE::Compiler::getHandleForToken(v454);
                  HandleForToken = result;
                  if (result)
                  {
LABEL_668:
                    result = sub_100083360(*v458, &HandleForToken);
                    v386 = v455;
                    v453 = v541;
                    if (v457 >= *result)
                    {
                      goto LABEL_675;
                    }

                    continue;
                  }
                }

                v386 = v455;
                v453 = v541;
                if (v457 >= -1)
                {
                  goto LABEL_675;
                }
              }
            }

LABEL_569:
            v381 = v7-- <= 2;
            if (v381)
            {
              return result;
            }
          }
        }
      }

      v361 = v359[1];
      v362 = *a3;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*v359);
      if (HandleForToken)
      {
        v363 = *sub_100083360(*v362, &HandleForToken);
        v364 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v361);
        if (HandleForToken)
        {
LABEL_537:
          v365 = *sub_100083360(*v364, &HandleForToken);
LABEL_540:
          if (v363 < v365)
          {
            ++v359;
            v358 = v360;
          }

          v356 = v541;
          goto LABEL_543;
        }
      }

      else
      {
        v363 = -1;
        v364 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v361);
        if (HandleForToken)
        {
          goto LABEL_537;
        }
      }

      v365 = -1;
      goto LABEL_540;
    }

    v9 = v7 >> 1;
    v10 = &v8[v7 >> 1];
    if (v7 < 0x81)
    {
      sub_10027A7F0(&v8[v7 >> 1], v8, v527, a3);
      --a4;
      if ((a5 & 1) == 0)
      {
        goto LABEL_16;
      }

LABEL_19:
      v17 = 0;
      v18 = *v8;
      do
      {
        while (1)
        {
          v19 = *a3;
          HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v8[v17 + 1]);
          if (HandleForToken)
          {
            break;
          }

          v20 = -1;
          v21 = *a3;
          HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v18);
          if (!HandleForToken)
          {
            goto LABEL_25;
          }

LABEL_20:
          ++v17;
          if (v20 >= *sub_100083360(*v21, &HandleForToken))
          {
            goto LABEL_26;
          }
        }

        v20 = *sub_100083360(*v19, &HandleForToken);
        v21 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v18);
        if (HandleForToken)
        {
          goto LABEL_20;
        }

LABEL_25:
        ++v17;
      }

      while (v20 < -1);
LABEL_26:
      v22 = &v8[v17];
      v23 = a2;
      if (v17 == 1)
      {
        v23 = a2;
        while (1)
        {
          if (v22 >= v23)
          {
            goto LABEL_42;
          }

          v28 = *--v23;
          v29 = *a3;
          HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v28);
          if (HandleForToken)
          {
            v30 = *sub_100083360(*v29, &HandleForToken);
            v31 = *a3;
            HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v18);
            if (!HandleForToken)
            {
              goto LABEL_41;
            }

LABEL_35:
            if (v30 < *sub_100083360(*v31, &HandleForToken))
            {
              goto LABEL_42;
            }
          }

          else
          {
            v30 = -1;
            v31 = *a3;
            HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v18);
            if (HandleForToken)
            {
              goto LABEL_35;
            }

LABEL_41:
            if (v30 < -1)
            {
              goto LABEL_42;
            }
          }
        }
      }

      while (2)
      {
        while (2)
        {
          v24 = *--v23;
          v25 = *a3;
          HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v24);
          if (HandleForToken)
          {
            v26 = *sub_100083360(*v25, &HandleForToken);
            v27 = *a3;
            HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v18);
            if (!HandleForToken)
            {
              break;
            }

            goto LABEL_28;
          }

          v26 = -1;
          v27 = *a3;
          HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v18);
          if (HandleForToken)
          {
LABEL_28:
            if (v26 < *sub_100083360(*v27, &HandleForToken))
            {
              goto LABEL_42;
            }

            continue;
          }

          break;
        }

        if (v26 >= -1)
        {
          continue;
        }

        break;
      }

LABEL_42:
      v534 = v22;
      if (v22 < v23)
      {
        v32 = v23;
        v33 = v22;
        while (1)
        {
          v34 = *v33;
          *v33 = *v32;
          *v32 = v34;
          do
          {
            while (1)
            {
              v35 = v33;
              v36 = v33[1];
              ++v33;
              v37 = *a3;
              v38 = mlir::ODIE::Compiler::getHandleForToken(v36);
              if (v38)
              {
                break;
              }

              v51 = -1;
              v52 = *a3;
              v53 = mlir::ODIE::Compiler::getHandleForToken(v18);
              if (v53)
              {
                goto LABEL_67;
              }

LABEL_46:
              if (v51 >= -1)
              {
                goto LABEL_128;
              }
            }

            v39 = *v37;
            v40 = *(*v37 + 16);
            if (!v40)
            {
              v54 = (4 * *(v39 + 8) + 4);
LABEL_88:
              v69 = v38;
              sub_100083608(v39, 2 * v40);
              v70 = *(v39 + 16);
              if (v70)
              {
                goto LABEL_89;
              }

LABEL_114:
              v45 = 0;
              v38 = v69;
LABEL_115:
              ++*(v39 + 8);
              if (*v45 == -4096)
              {
                goto LABEL_65;
              }

LABEL_64:
              --*(v39 + 12);
              goto LABEL_65;
            }

            v41 = 0x9DDFEA08EB382D69 * ((8 * v38 - 0xAE502812AA7333) ^ HIDWORD(v38));
            v42 = 0x9DDFEA08EB382D69 * (HIDWORD(v38) ^ (v41 >> 47) ^ v41);
            v43 = v40 - 1;
            v44 = (v40 - 1) & (-348639895 * ((v42 >> 47) ^ v42));
            v45 = (*v39 + 16 * v44);
            v46 = *v45;
            if (*v45 == v38)
            {
              goto LABEL_66;
            }

            v47 = 0;
            v48 = 1;
            while (v46 != -4096)
            {
              if (v47)
              {
                v49 = 0;
              }

              else
              {
                v49 = v46 == -8192;
              }

              if (v49)
              {
                v47 = v45;
              }

              v50 = v44 + v48++;
              v44 = v50 & v43;
              v45 = (*v39 + 16 * (v50 & v43));
              v46 = *v45;
              if (*v45 == v38)
              {
                goto LABEL_66;
              }
            }

            if (v47)
            {
              v45 = v47;
            }

            v68 = *(v39 + 8);
            if (4 * v68 + 4 >= 3 * v40)
            {
              goto LABEL_88;
            }

            if (v40 + ~v68 - *(v39 + 12) <= v40 >> 3)
            {
              v69 = v38;
              sub_100083608(v39, v40);
              v70 = *(v39 + 16);
              if (!v70)
              {
                goto LABEL_114;
              }

LABEL_89:
              v38 = v69;
              v71 = 0x9DDFEA08EB382D69 * ((8 * v69 - 0xAE502812AA7333) ^ HIDWORD(v69));
              v72 = 0x9DDFEA08EB382D69 * (HIDWORD(v69) ^ (v71 >> 47) ^ v71);
              LODWORD(v71) = -348639895 * ((v72 >> 47) ^ v72);
              v73 = v70 - 1;
              v74 = (v70 - 1) & v71;
              v45 = (*v39 + 16 * v74);
              v75 = *v45;
              if (*v45 != v69)
              {
                v76 = 0;
                v77 = 1;
                while (v75 != -4096)
                {
                  if (v76)
                  {
                    v78 = 0;
                  }

                  else
                  {
                    v78 = v75 == -8192;
                  }

                  if (v78)
                  {
                    v76 = v45;
                  }

                  v79 = v74 + v77++;
                  v74 = v79 & v73;
                  v45 = (*v39 + 16 * (v79 & v73));
                  v75 = *v45;
                  if (*v45 == v69)
                  {
                    goto LABEL_115;
                  }
                }

                if (v76)
                {
                  v45 = v76;
                }
              }

              goto LABEL_115;
            }

            *(v39 + 8) = v68 + 1;
            if (*v45 != -4096)
            {
              goto LABEL_64;
            }

LABEL_65:
            *v45 = v38;
            v45[1] = 0;
LABEL_66:
            v51 = *(v45 + 2);
            v52 = *a3;
            v53 = mlir::ODIE::Compiler::getHandleForToken(v18);
            if (!v53)
            {
              goto LABEL_46;
            }

LABEL_67:
            v55 = *v52;
            v56 = *(v55 + 16);
            if (!v56)
            {
              v67 = (4 * *(v55 + 8) + 4);
LABEL_102:
              v523 = v53;
              sub_100083608(v55, 2 * v56);
              v81 = *(v55 + 16);
              if (v81)
              {
                goto LABEL_103;
              }

LABEL_118:
              v61 = 0;
              v53 = v523;
LABEL_119:
              ++*(v55 + 8);
              if (*v61 == -4096)
              {
                goto LABEL_82;
              }

LABEL_81:
              --*(v55 + 12);
              goto LABEL_82;
            }

            v57 = 0x9DDFEA08EB382D69 * ((8 * v53 - 0xAE502812AA7333) ^ HIDWORD(v53));
            v58 = 0x9DDFEA08EB382D69 * (HIDWORD(v53) ^ (v57 >> 47) ^ v57);
            v59 = v56 - 1;
            v60 = (v56 - 1) & (-348639895 * ((v58 >> 47) ^ v58));
            v61 = (*v55 + 16 * v60);
            v62 = *v61;
            if (*v61 == v53)
            {
              continue;
            }

            v63 = 0;
            v64 = 1;
            while (v62 != -4096)
            {
              if (v63)
              {
                v65 = 0;
              }

              else
              {
                v65 = v62 == -8192;
              }

              if (v65)
              {
                v63 = v61;
              }

              v66 = v60 + v64++;
              v60 = v66 & v59;
              v61 = (*v55 + 16 * (v66 & v59));
              v62 = *v61;
              if (*v61 == v53)
              {
                goto LABEL_83;
              }
            }

            if (v63)
            {
              v61 = v63;
            }

            v80 = *(v55 + 8);
            if (4 * v80 + 4 >= 3 * v56)
            {
              goto LABEL_102;
            }

            if (v56 + ~v80 - *(v55 + 12) <= v56 >> 3)
            {
              v523 = v53;
              sub_100083608(v55, v56);
              v81 = *(v55 + 16);
              if (!v81)
              {
                goto LABEL_118;
              }

LABEL_103:
              v53 = v523;
              v82 = 0x9DDFEA08EB382D69 * ((8 * v523 - 0xAE502812AA7333) ^ HIDWORD(v523));
              v83 = 0x9DDFEA08EB382D69 * (HIDWORD(v523) ^ (v82 >> 47) ^ v82);
              LODWORD(v82) = -348639895 * ((v83 >> 47) ^ v83);
              v84 = v81 - 1;
              v85 = (v81 - 1) & v82;
              v61 = (*v55 + 16 * v85);
              v86 = *v61;
              if (*v61 != v523)
              {
                v87 = 0;
                v88 = 1;
                while (v86 != -4096)
                {
                  if (v87)
                  {
                    v89 = 0;
                  }

                  else
                  {
                    v89 = v86 == -8192;
                  }

                  if (v89)
                  {
                    v87 = v61;
                  }

                  v90 = v85 + v88++;
                  v85 = v90 & v84;
                  v61 = (*v55 + 16 * (v90 & v84));
                  v86 = *v61;
                  if (*v61 == v523)
                  {
                    goto LABEL_119;
                  }
                }

                if (v87)
                {
                  v61 = v87;
                }
              }

              goto LABEL_119;
            }

            *(v55 + 8) = v80 + 1;
            if (*v61 != -4096)
            {
              goto LABEL_81;
            }

LABEL_82:
            *v61 = v53;
            v61[1] = 0;
LABEL_83:
            ;
          }

          while (v51 < *(v61 + 2));
          do
          {
LABEL_128:
            while (1)
            {
              v91 = *--v32;
              v92 = *a3;
              v93 = mlir::ODIE::Compiler::getHandleForToken(v91);
              if (!v93)
              {
                break;
              }

              v94 = *v92;
              v95 = *(*v92 + 16);
              if (!v95)
              {
                v109 = (4 * *(v94 + 8) + 4);
LABEL_169:
                v124 = v93;
                sub_100083608(v94, 2 * v95);
                v125 = *(v94 + 16);
                if (v125)
                {
                  goto LABEL_170;
                }

LABEL_195:
                v100 = 0;
                v93 = v124;
LABEL_196:
                ++*(v94 + 8);
                if (*v100 == -4096)
                {
                  goto LABEL_146;
                }

LABEL_145:
                --*(v94 + 12);
                goto LABEL_146;
              }

              v96 = 0x9DDFEA08EB382D69 * ((8 * v93 - 0xAE502812AA7333) ^ HIDWORD(v93));
              v97 = 0x9DDFEA08EB382D69 * (HIDWORD(v93) ^ (v96 >> 47) ^ v96);
              v98 = v95 - 1;
              v99 = (v95 - 1) & (-348639895 * ((v97 >> 47) ^ v97));
              v100 = (*v94 + 16 * v99);
              v101 = *v100;
              if (*v100 == v93)
              {
                goto LABEL_147;
              }

              v102 = 0;
              v103 = 1;
              while (v101 != -4096)
              {
                if (v102)
                {
                  v104 = 0;
                }

                else
                {
                  v104 = v101 == -8192;
                }

                if (v104)
                {
                  v102 = v100;
                }

                v105 = v99 + v103++;
                v99 = v105 & v98;
                v100 = (*v94 + 16 * (v105 & v98));
                v101 = *v100;
                if (*v100 == v93)
                {
                  goto LABEL_147;
                }
              }

              if (v102)
              {
                v100 = v102;
              }

              v123 = *(v94 + 8);
              if (4 * v123 + 4 >= 3 * v95)
              {
                goto LABEL_169;
              }

              if (v95 + ~v123 - *(v94 + 12) <= v95 >> 3)
              {
                v124 = v93;
                sub_100083608(v94, v95);
                v125 = *(v94 + 16);
                if (!v125)
                {
                  goto LABEL_195;
                }

LABEL_170:
                v93 = v124;
                v126 = 0x9DDFEA08EB382D69 * ((8 * v124 - 0xAE502812AA7333) ^ HIDWORD(v124));
                v127 = 0x9DDFEA08EB382D69 * (HIDWORD(v124) ^ (v126 >> 47) ^ v126);
                LODWORD(v126) = -348639895 * ((v127 >> 47) ^ v127);
                v128 = v125 - 1;
                v129 = (v125 - 1) & v126;
                v100 = (*v94 + 16 * v129);
                v130 = *v100;
                if (*v100 != v124)
                {
                  v131 = 0;
                  v132 = 1;
                  while (v130 != -4096)
                  {
                    if (v131)
                    {
                      v133 = 0;
                    }

                    else
                    {
                      v133 = v130 == -8192;
                    }

                    if (v133)
                    {
                      v131 = v100;
                    }

                    v134 = v129 + v132++;
                    v129 = v134 & v128;
                    v100 = (*v94 + 16 * (v134 & v128));
                    v130 = *v100;
                    if (*v100 == v124)
                    {
                      goto LABEL_196;
                    }
                  }

                  if (v131)
                  {
                    v100 = v131;
                  }
                }

                goto LABEL_196;
              }

              *(v94 + 8) = v123 + 1;
              if (*v100 != -4096)
              {
                goto LABEL_145;
              }

LABEL_146:
              *v100 = v93;
              v100[1] = 0;
LABEL_147:
              v106 = *(v100 + 2);
              v107 = *a3;
              v108 = mlir::ODIE::Compiler::getHandleForToken(v18);
              if (v108)
              {
                goto LABEL_148;
              }

LABEL_127:
              if (v106 < -1)
              {
                goto LABEL_44;
              }
            }

            v106 = -1;
            v107 = *a3;
            v108 = mlir::ODIE::Compiler::getHandleForToken(v18);
            if (!v108)
            {
              goto LABEL_127;
            }

LABEL_148:
            v110 = *v107;
            v111 = *(v110 + 16);
            if (!v111)
            {
              v122 = (4 * *(v110 + 8) + 4);
LABEL_183:
              v524 = v108;
              sub_100083608(v110, 2 * v111);
              v136 = *(v110 + 16);
              if (v136)
              {
                goto LABEL_184;
              }

LABEL_199:
              v116 = 0;
              v108 = v524;
LABEL_200:
              ++*(v110 + 8);
              if (*v116 == -4096)
              {
                goto LABEL_163;
              }

LABEL_162:
              --*(v110 + 12);
              goto LABEL_163;
            }

            v112 = 0x9DDFEA08EB382D69 * ((8 * v108 - 0xAE502812AA7333) ^ HIDWORD(v108));
            v113 = 0x9DDFEA08EB382D69 * (HIDWORD(v108) ^ (v112 >> 47) ^ v112);
            v114 = v111 - 1;
            v115 = (v111 - 1) & (-348639895 * ((v113 >> 47) ^ v113));
            v116 = (*v110 + 16 * v115);
            v117 = *v116;
            if (*v116 == v108)
            {
              continue;
            }

            v118 = 0;
            v119 = 1;
            while (v117 != -4096)
            {
              if (v118)
              {
                v120 = 0;
              }

              else
              {
                v120 = v117 == -8192;
              }

              if (v120)
              {
                v118 = v116;
              }

              v121 = v115 + v119++;
              v115 = v121 & v114;
              v116 = (*v110 + 16 * (v121 & v114));
              v117 = *v116;
              if (*v116 == v108)
              {
                goto LABEL_164;
              }
            }

            if (v118)
            {
              v116 = v118;
            }

            v135 = *(v110 + 8);
            if (4 * v135 + 4 >= 3 * v111)
            {
              goto LABEL_183;
            }

            if (v111 + ~v135 - *(v110 + 12) <= v111 >> 3)
            {
              v524 = v108;
              sub_100083608(v110, v111);
              v136 = *(v110 + 16);
              if (!v136)
              {
                goto LABEL_199;
              }

LABEL_184:
              v108 = v524;
              v137 = 0x9DDFEA08EB382D69 * ((8 * v524 - 0xAE502812AA7333) ^ HIDWORD(v524));
              v138 = 0x9DDFEA08EB382D69 * (HIDWORD(v524) ^ (v137 >> 47) ^ v137);
              LODWORD(v137) = -348639895 * ((v138 >> 47) ^ v138);
              v139 = v136 - 1;
              v140 = (v136 - 1) & v137;
              v116 = (*v110 + 16 * v140);
              v141 = *v116;
              if (*v116 != v524)
              {
                v142 = 0;
                v143 = 1;
                while (v141 != -4096)
                {
                  if (v142)
                  {
                    v144 = 0;
                  }

                  else
                  {
                    v144 = v141 == -8192;
                  }

                  if (v144)
                  {
                    v142 = v116;
                  }

                  v145 = v140 + v143++;
                  v140 = v145 & v139;
                  v116 = (*v110 + 16 * (v145 & v139));
                  v141 = *v116;
                  if (*v116 == v524)
                  {
                    goto LABEL_200;
                  }
                }

                if (v142)
                {
                  v116 = v142;
                }
              }

              goto LABEL_200;
            }

            *(v110 + 8) = v135 + 1;
            if (*v116 != -4096)
            {
              goto LABEL_162;
            }

LABEL_163:
            *v116 = v108;
            v116[1] = 0;
LABEL_164:
            ;
          }

          while (v106 >= *(v116 + 2));
LABEL_44:
          if (v33 >= v32)
          {
            goto LABEL_209;
          }
        }
      }

      v35 = v22 - 1;
LABEL_209:
      if (v35 != v541)
      {
        *v541 = *v35;
      }

      *v35 = v18;
      if (v534 < v23)
      {
LABEL_214:
        result = sub_100277A44(v541, v35, a3, a4, a5 & 1);
        a5 = 0;
        v6 = v35 + 1;
      }

      else
      {
        v146 = sub_10027AF84(v541, v35, a3);
        v6 = v35 + 1;
        result = sub_10027AF84(v35 + 1, a2, a3);
        if (result)
        {
          a2 = v35;
          if (v146)
          {
            return result;
          }

          goto LABEL_2;
        }

        if (!v146)
        {
          goto LABEL_214;
        }
      }
    }

    else
    {
      sub_10027A7F0(v8, &v8[v7 >> 1], v527, a3);
      v11 = v9;
      sub_10027A7F0(v8 + 1, &v8[v11 - 1], a2 - 2, a3);
      sub_10027A7F0(v8 + 2, &v8[v11 + 1], a2 - 3, a3);
      sub_10027A7F0(&v8[v11 - 1], v10, &v8[v11 + 1], a3);
      v12 = *v8;
      *v8 = v8[v11];
      v8[v11] = v12;
      --a4;
      if (a5)
      {
        goto LABEL_19;
      }

LABEL_16:
      v13 = *v8;
      v14 = *a3;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*(v8 - 1));
      if (HandleForToken)
      {
        v15 = *sub_100083360(*v14, &HandleForToken);
        v16 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v13);
        if (!HandleForToken)
        {
          goto LABEL_216;
        }
      }

      else
      {
        v15 = -1;
        v16 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v13);
        if (!HandleForToken)
        {
LABEL_216:
          if (v15 < -1)
          {
            goto LABEL_19;
          }

          goto LABEL_217;
        }
      }

      if (v15 < *sub_100083360(*v16, &HandleForToken))
      {
        goto LABEL_19;
      }

LABEL_217:
      v147 = *v8;
      v148 = *v527;
      v149 = *a3;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*v8);
      if (HandleForToken)
      {
        v150 = *sub_100083360(*v149, &HandleForToken);
        v151 = *a3;
        result = mlir::ODIE::Compiler::getHandleForToken(v148);
        HandleForToken = result;
        if (result)
        {
          goto LABEL_219;
        }
      }

      else
      {
        v150 = -1;
        v151 = *a3;
        result = mlir::ODIE::Compiler::getHandleForToken(v148);
        HandleForToken = result;
        if (result)
        {
LABEL_219:
          result = sub_100083360(*v151, &HandleForToken);
          if (v150 < *result)
          {
            goto LABEL_220;
          }

          goto LABEL_230;
        }
      }

      if (v150 < -1)
      {
LABEL_220:
        v6 = v8;
        while (1)
        {
          v153 = v6[1];
          ++v6;
          v152 = v153;
          v154 = *a3;
          HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v147);
          if (HandleForToken)
          {
            v155 = *sub_100083360(*v154, &HandleForToken);
            v156 = *a3;
            result = mlir::ODIE::Compiler::getHandleForToken(v152);
            HandleForToken = result;
            if (!result)
            {
              goto LABEL_226;
            }

LABEL_221:
            result = sub_100083360(*v156, &HandleForToken);
            if (v155 < *result)
            {
              goto LABEL_238;
            }
          }

          else
          {
            v155 = -1;
            v156 = *a3;
            result = mlir::ODIE::Compiler::getHandleForToken(v152);
            HandleForToken = result;
            if (result)
            {
              goto LABEL_221;
            }

LABEL_226:
            if (v155 < -1)
            {
              goto LABEL_238;
            }
          }
        }
      }

LABEL_230:
      v157 = v8 + 1;
      while (1)
      {
        v6 = v157;
        if (v157 >= a2)
        {
          break;
        }

        v158 = *v157;
        v159 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v147);
        if (HandleForToken)
        {
          v160 = *sub_100083360(*v159, &HandleForToken);
          v161 = *a3;
          result = mlir::ODIE::Compiler::getHandleForToken(v158);
          HandleForToken = result;
          if (!result)
          {
            goto LABEL_237;
          }

LABEL_231:
          result = sub_100083360(*v161, &HandleForToken);
          v157 = v6 + 1;
          if (v160 < *result)
          {
            break;
          }
        }

        else
        {
          v160 = -1;
          v161 = *a3;
          result = mlir::ODIE::Compiler::getHandleForToken(v158);
          HandleForToken = result;
          if (result)
          {
            goto LABEL_231;
          }

LABEL_237:
          v157 = v6 + 1;
          if (v160 < -1)
          {
            break;
          }
        }
      }

LABEL_238:
      v162 = a2;
      if (v6 < a2)
      {
        v162 = a2;
        while (1)
        {
          v164 = *--v162;
          v163 = v164;
          v165 = *a3;
          HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v147);
          if (HandleForToken)
          {
            v166 = *sub_100083360(*v165, &HandleForToken);
            v167 = *a3;
            result = mlir::ODIE::Compiler::getHandleForToken(v163);
            HandleForToken = result;
            if (!result)
            {
              goto LABEL_245;
            }

LABEL_240:
            result = sub_100083360(*v167, &HandleForToken);
            if (v166 >= *result)
            {
              break;
            }
          }

          else
          {
            v166 = -1;
            v167 = *a3;
            result = mlir::ODIE::Compiler::getHandleForToken(v163);
            HandleForToken = result;
            if (result)
            {
              goto LABEL_240;
            }

LABEL_245:
            if (v166 >= -1)
            {
              break;
            }
          }
        }
      }

LABEL_246:
      if (v6 < v162)
      {
        v168 = *v6;
        *v6 = *v162;
        *v162 = v168;
        while (2)
        {
          while (1)
          {
            v170 = v6[1];
            ++v6;
            v169 = v170;
            v171 = *a3;
            v172 = mlir::ODIE::Compiler::getHandleForToken(v147);
            if (v172)
            {
              break;
            }

            v185 = -1;
            v186 = *a3;
            v187 = mlir::ODIE::Compiler::getHandleForToken(v169);
            if (v187)
            {
              goto LABEL_269;
            }

LABEL_248:
            if (v185 < -1)
            {
              goto LABEL_332;
            }
          }

          v173 = *v171;
          v174 = *(*v171 + 16);
          if (!v174)
          {
            v188 = (4 * *(v173 + 8) + 4);
            goto LABEL_290;
          }

          v175 = 0x9DDFEA08EB382D69 * ((8 * v172 - 0xAE502812AA7333) ^ HIDWORD(v172));
          v176 = 0x9DDFEA08EB382D69 * (HIDWORD(v172) ^ (v175 >> 47) ^ v175);
          v177 = v174 - 1;
          v178 = (v174 - 1) & (-348639895 * ((v176 >> 47) ^ v176));
          v179 = (*v173 + 16 * v178);
          v180 = *v179;
          if (*v179 != v172)
          {
            v181 = 0;
            v182 = 1;
            while (v180 != -4096)
            {
              if (v181)
              {
                v183 = 0;
              }

              else
              {
                v183 = v180 == -8192;
              }

              if (v183)
              {
                v181 = v179;
              }

              v184 = v178 + v182++;
              v178 = v184 & v177;
              v179 = (*v173 + 16 * (v184 & v177));
              v180 = *v179;
              if (*v179 == v172)
              {
                goto LABEL_268;
              }
            }

            if (v181)
            {
              v179 = v181;
            }

            v202 = *(v173 + 8);
            if (4 * v202 + 4 >= 3 * v174)
            {
LABEL_290:
              v203 = v172;
              v174 *= 2;
              goto LABEL_296;
            }

            if (v174 + ~v202 - *(v173 + 12) <= v174 >> 3)
            {
              v203 = v172;
LABEL_296:
              sub_100083608(v173, v174);
              v206 = *(v173 + 16);
              if (v206)
              {
                v172 = v203;
                v207 = 0x9DDFEA08EB382D69 * ((8 * v203 - 0xAE502812AA7333) ^ HIDWORD(v203));
                v208 = 0x9DDFEA08EB382D69 * (HIDWORD(v203) ^ (v207 >> 47) ^ v207);
                LODWORD(v207) = -348639895 * ((v208 >> 47) ^ v208);
                v209 = v206 - 1;
                v210 = (v206 - 1) & v207;
                v179 = (*v173 + 16 * v210);
                v211 = *v179;
                if (*v179 != v203)
                {
                  v212 = 0;
                  v213 = 1;
                  while (v211 != -4096)
                  {
                    if (v212)
                    {
                      v214 = 0;
                    }

                    else
                    {
                      v214 = v211 == -8192;
                    }

                    if (v214)
                    {
                      v212 = v179;
                    }

                    v215 = v210 + v213++;
                    v210 = v215 & v209;
                    v179 = (*v173 + 16 * (v215 & v209));
                    v211 = *v179;
                    if (*v179 == v203)
                    {
                      goto LABEL_320;
                    }
                  }

                  if (v212)
                  {
                    v179 = v212;
                  }
                }
              }

              else
              {
                v179 = 0;
                v172 = v203;
              }

LABEL_320:
              ++*(v173 + 8);
              if (*v179 != -4096)
              {
LABEL_266:
                --*(v173 + 12);
              }
            }

            else
            {
              *(v173 + 8) = v202 + 1;
              if (*v179 != -4096)
              {
                goto LABEL_266;
              }
            }

            *v179 = v172;
            v179[1] = 0;
          }

LABEL_268:
          v185 = *(v179 + 2);
          v8 = v541;
          v186 = *a3;
          v187 = mlir::ODIE::Compiler::getHandleForToken(v169);
          if (!v187)
          {
            goto LABEL_248;
          }

LABEL_269:
          v189 = *v186;
          v190 = *(*v186 + 16);
          if (!v190)
          {
            v201 = (4 * *(v189 + 8) + 4);
            goto LABEL_294;
          }

          v191 = 0x9DDFEA08EB382D69 * ((8 * v187 - 0xAE502812AA7333) ^ HIDWORD(v187));
          v192 = 0x9DDFEA08EB382D69 * (HIDWORD(v187) ^ (v191 >> 47) ^ v191);
          v193 = v190 - 1;
          v194 = (v190 - 1) & (-348639895 * ((v192 >> 47) ^ v192));
          v195 = (*v189 + 16 * v194);
          v196 = *v195;
          if (*v195 != v187)
          {
            v197 = 0;
            v198 = 1;
            while (v196 != -4096)
            {
              if (v197)
              {
                v199 = 0;
              }

              else
              {
                v199 = v196 == -8192;
              }

              if (v199)
              {
                v197 = v195;
              }

              v200 = v194 + v198++;
              v194 = v200 & v193;
              v195 = (*v189 + 16 * (v200 & v193));
              v196 = *v195;
              if (*v195 == v187)
              {
                goto LABEL_285;
              }
            }

            if (v197)
            {
              v195 = v197;
            }

            v204 = *(v189 + 8);
            if (4 * v204 + 4 >= 3 * v190)
            {
LABEL_294:
              v205 = v187;
              v190 *= 2;
              goto LABEL_308;
            }

            if (v190 + ~v204 - *(v189 + 12) <= v190 >> 3)
            {
              v205 = v187;
LABEL_308:
              sub_100083608(v189, v190);
              v216 = *(v189 + 16);
              if (v216)
              {
                v187 = v205;
                v217 = 0x9DDFEA08EB382D69 * ((8 * v205 - 0xAE502812AA7333) ^ HIDWORD(v205));
                v218 = 0x9DDFEA08EB382D69 * (HIDWORD(v205) ^ (v217 >> 47) ^ v217);
                LODWORD(v217) = -348639895 * ((v218 >> 47) ^ v218);
                v219 = v216 - 1;
                v220 = (v216 - 1) & v217;
                v195 = (*v189 + 16 * v220);
                v221 = *v195;
                if (*v195 != v205)
                {
                  v222 = 0;
                  v223 = 1;
                  while (v221 != -4096)
                  {
                    if (v222)
                    {
                      v224 = 0;
                    }

                    else
                    {
                      v224 = v221 == -8192;
                    }

                    if (v224)
                    {
                      v222 = v195;
                    }

                    v225 = v220 + v223++;
                    v220 = v225 & v219;
                    v195 = (*v189 + 16 * (v225 & v219));
                    v221 = *v195;
                    v8 = v541;
                    if (*v195 == v205)
                    {
                      goto LABEL_323;
                    }
                  }

                  if (v222)
                  {
                    v195 = v222;
                  }

                  v8 = v541;
                }
              }

              else
              {
                v195 = 0;
                v187 = v205;
              }

LABEL_323:
              ++*(v189 + 8);
              if (*v195 != -4096)
              {
LABEL_283:
                --*(v189 + 12);
              }
            }

            else
            {
              *(v189 + 8) = v204 + 1;
              if (*v195 != -4096)
              {
                goto LABEL_283;
              }
            }

            *v195 = v187;
            v195[1] = 0;
          }

LABEL_285:
          if (v185 < *(v195 + 2))
          {
            while (1)
            {
LABEL_332:
              while (1)
              {
                v227 = *--v162;
                v226 = v227;
                v228 = *a3;
                v229 = mlir::ODIE::Compiler::getHandleForToken(v147);
                if (v229)
                {
                  break;
                }

                v242 = -1;
                v243 = *a3;
                result = mlir::ODIE::Compiler::getHandleForToken(v226);
                if (result)
                {
                  goto LABEL_352;
                }

LABEL_331:
                if (v242 >= -1)
                {
                  goto LABEL_246;
                }
              }

              v230 = *v228;
              v231 = *(*v228 + 16);
              if (!v231)
              {
                break;
              }

              v232 = 0x9DDFEA08EB382D69 * ((8 * v229 - 0xAE502812AA7333) ^ HIDWORD(v229));
              v233 = 0x9DDFEA08EB382D69 * (HIDWORD(v229) ^ (v232 >> 47) ^ v232);
              v234 = v231 - 1;
              v235 = (v231 - 1) & (-348639895 * ((v233 >> 47) ^ v233));
              v236 = (*v230 + 16 * v235);
              v237 = *v236;
              if (*v236 == v229)
              {
                goto LABEL_351;
              }

              v238 = 0;
              v239 = 1;
              while (v237 != -4096)
              {
                if (v238)
                {
                  v240 = 0;
                }

                else
                {
                  v240 = v237 == -8192;
                }

                if (v240)
                {
                  v238 = v236;
                }

                v241 = v235 + v239++;
                v235 = v241 & v234;
                v236 = (*v230 + 16 * (v241 & v234));
                v237 = *v236;
                if (*v236 == v229)
                {
                  goto LABEL_351;
                }
              }

              if (v238)
              {
                v236 = v238;
              }

              v258 = *(v230 + 8);
              if (4 * v258 + 4 >= 3 * v231)
              {
                goto LABEL_373;
              }

              if (v231 + ~v258 - *(v230 + 12) <= v231 >> 3)
              {
                v259 = v229;
                goto LABEL_379;
              }

              *(v230 + 8) = v258 + 1;
              if (*v236 != -4096)
              {
                goto LABEL_349;
              }

LABEL_350:
              *v236 = v229;
              v236[1] = 0;
LABEL_351:
              v242 = *(v236 + 2);
              v8 = v541;
              v243 = *a3;
              result = mlir::ODIE::Compiler::getHandleForToken(v226);
              if (!result)
              {
                goto LABEL_331;
              }

LABEL_352:
              v245 = *v243;
              v246 = *(*v243 + 16);
              if (!v246)
              {
                v257 = (4 * *(v245 + 8) + 4);
                goto LABEL_377;
              }

              v247 = 0x9DDFEA08EB382D69 * ((8 * result - 0xAE502812AA7333) ^ HIDWORD(result));
              v248 = 0x9DDFEA08EB382D69 * (HIDWORD(result) ^ (v247 >> 47) ^ v247);
              v249 = v246 - 1;
              v250 = (v246 - 1) & (-348639895 * ((v248 >> 47) ^ v248));
              v251 = (*v245 + 16 * v250);
              v252 = *v251;
              if (*v251 != result)
              {
                v253 = 0;
                v254 = 1;
                while (v252 != -4096)
                {
                  if (v253)
                  {
                    v255 = 0;
                  }

                  else
                  {
                    v255 = v252 == -8192;
                  }

                  if (v255)
                  {
                    v253 = v251;
                  }

                  v256 = v250 + v254++;
                  v250 = v256 & v249;
                  v251 = (*v245 + 16 * (v256 & v249));
                  v252 = *v251;
                  if (*v251 == result)
                  {
                    goto LABEL_368;
                  }
                }

                if (v253)
                {
                  v251 = v253;
                }

                v260 = *(v245 + 8);
                if (4 * v260 + 4 >= 3 * v246)
                {
LABEL_377:
                  v261 = result;
                  v246 *= 2;
                  goto LABEL_391;
                }

                if (v246 + ~v260 - *(v245 + 12) <= v246 >> 3)
                {
                  v261 = result;
LABEL_391:
                  sub_100083608(v245, v246);
                  v272 = *(v245 + 16);
                  if (v272)
                  {
                    result = v261;
                    v273 = 0x9DDFEA08EB382D69 * ((8 * v261 - 0xAE502812AA7333) ^ HIDWORD(v261));
                    v274 = 0x9DDFEA08EB382D69 * (HIDWORD(v261) ^ (v273 >> 47) ^ v273);
                    LODWORD(v273) = -348639895 * ((v274 >> 47) ^ v274);
                    v275 = v272 - 1;
                    v276 = (v272 - 1) & v273;
                    v251 = (*v245 + 16 * v276);
                    v277 = *v251;
                    if (*v251 != v261)
                    {
                      v278 = 0;
                      v279 = 1;
                      while (v277 != -4096)
                      {
                        if (v278)
                        {
                          v280 = 0;
                        }

                        else
                        {
                          v280 = v277 == -8192;
                        }

                        if (v280)
                        {
                          v278 = v251;
                        }

                        v281 = v276 + v279++;
                        v276 = v281 & v275;
                        v251 = (*v245 + 16 * (v281 & v275));
                        v277 = *v251;
                        v8 = v541;
                        if (*v251 == v261)
                        {
                          goto LABEL_406;
                        }
                      }

                      if (v278)
                      {
                        v251 = v278;
                      }

                      v8 = v541;
                    }
                  }

                  else
                  {
                    v251 = 0;
                    result = v261;
                  }

LABEL_406:
                  ++*(v245 + 8);
                  if (*v251 != -4096)
                  {
LABEL_366:
                    --*(v245 + 12);
                  }
                }

                else
                {
                  *(v245 + 8) = v260 + 1;
                  if (*v251 != -4096)
                  {
                    goto LABEL_366;
                  }
                }

                *v251 = result;
                v251[1] = 0;
              }

LABEL_368:
              if (v242 >= *(v251 + 2))
              {
                goto LABEL_246;
              }
            }

            v244 = (4 * *(v230 + 8) + 4);
LABEL_373:
            v259 = v229;
            v231 *= 2;
LABEL_379:
            sub_100083608(v230, v231);
            v262 = *(v230 + 16);
            if (v262)
            {
              v229 = v259;
              v263 = 0x9DDFEA08EB382D69 * ((8 * v259 - 0xAE502812AA7333) ^ HIDWORD(v259));
              v264 = 0x9DDFEA08EB382D69 * (HIDWORD(v259) ^ (v263 >> 47) ^ v263);
              LODWORD(v263) = -348639895 * ((v264 >> 47) ^ v264);
              v265 = v262 - 1;
              v266 = (v262 - 1) & v263;
              v236 = (*v230 + 16 * v266);
              v267 = *v236;
              if (*v236 != v259)
              {
                v268 = 0;
                v269 = 1;
                while (v267 != -4096)
                {
                  if (v268)
                  {
                    v270 = 0;
                  }

                  else
                  {
                    v270 = v267 == -8192;
                  }

                  if (v270)
                  {
                    v268 = v236;
                  }

                  v271 = v266 + v269++;
                  v266 = v271 & v265;
                  v236 = (*v230 + 16 * (v271 & v265));
                  v267 = *v236;
                  if (*v236 == v259)
                  {
                    goto LABEL_403;
                  }
                }

                if (v268)
                {
                  v236 = v268;
                }
              }
            }

            else
            {
              v236 = 0;
              v229 = v259;
            }

LABEL_403:
            ++*(v230 + 8);
            if (*v236 == -4096)
            {
              goto LABEL_350;
            }

LABEL_349:
            --*(v230 + 12);
            goto LABEL_350;
          }

          continue;
        }
      }

      v282 = v6 - 1;
      if (v6 - 1 != v8)
      {
        *v8 = *v282;
      }

      a5 = 0;
      *v282 = v147;
    }
  }

  v283 = *v6;
  v284 = *a3;
  v285 = mlir::ODIE::Compiler::getHandleForToken(*(a2 - 1));
  HandleForToken = v285;
  if (v285)
  {
    v286 = *sub_100083360(*v284, &HandleForToken);
    v287 = *a3;
    result = mlir::ODIE::Compiler::getHandleForToken(v283);
    HandleForToken = result;
    if (result)
    {
      goto LABEL_422;
    }

LABEL_771:
    if (v286 < -1)
    {
      goto LABEL_772;
    }
  }

  else
  {
    v286 = -1;
    v287 = *a3;
    result = mlir::ODIE::Compiler::getHandleForToken(v283);
    HandleForToken = result;
    if (!result)
    {
      goto LABEL_771;
    }

LABEL_422:
    result = sub_100083360(*v287, &HandleForToken);
    if (v286 < *result)
    {
LABEL_772:
      v522 = *v6;
      *v6 = *(a2 - 1);
      *(a2 - 1) = v522;
    }
  }

  return result;
}

int *sub_10027A7F0(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t **a4)
{
  v8 = *a1;
  v9 = *a4;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a2);
  if (HandleForToken)
  {
    v10 = *sub_100083360(*v9, &HandleForToken);
    v11 = *a4;
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v8);
    if (HandleForToken)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v10 = -1;
    v11 = *a4;
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v8);
    if (HandleForToken)
    {
LABEL_3:
      v12 = *sub_100083360(*v11, &HandleForToken);
      v13 = *a3;
      v14 = *a2;
      v15 = *a4;
      if (v10 < v12)
      {
        goto LABEL_4;
      }

      goto LABEL_10;
    }
  }

  v13 = *a3;
  v14 = *a2;
  v15 = *a4;
  if (v10 < -1)
  {
LABEL_4:
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v13);
    if (HandleForToken)
    {
      v16 = *sub_100083360(*v15, &HandleForToken);
      v17 = *a4;
      result = mlir::ODIE::Compiler::getHandleForToken(v14);
      HandleForToken = result;
      if (result)
      {
        goto LABEL_6;
      }
    }

    else
    {
      v16 = -1;
      v17 = *a4;
      result = mlir::ODIE::Compiler::getHandleForToken(v14);
      HandleForToken = result;
      if (result)
      {
LABEL_6:
        result = sub_100083360(*v17, &HandleForToken);
        v19 = *a1;
        if (v16 < *result)
        {
LABEL_7:
          *a1 = *a3;
          *a3 = v19;
          return result;
        }

LABEL_16:
        *a1 = *a2;
        *a2 = v19;
        v22 = *a4;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a3);
        if (HandleForToken)
        {
          v23 = *sub_100083360(*v22, &HandleForToken);
          v24 = *a4;
          result = mlir::ODIE::Compiler::getHandleForToken(v19);
          HandleForToken = result;
          if (result)
          {
            goto LABEL_18;
          }
        }

        else
        {
          v23 = -1;
          v24 = *a4;
          result = mlir::ODIE::Compiler::getHandleForToken(v19);
          HandleForToken = result;
          if (result)
          {
LABEL_18:
            result = sub_100083360(*v24, &HandleForToken);
            if (v23 >= *result)
            {
              return result;
            }

LABEL_28:
            v30 = *a2;
            *a2 = *a3;
            *a3 = v30;
            return result;
          }
        }

        if (v23 >= -1)
        {
          return result;
        }

        goto LABEL_28;
      }
    }

    v19 = *a1;
    if (v16 < -1)
    {
      goto LABEL_7;
    }

    goto LABEL_16;
  }

LABEL_10:
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v13);
  if (HandleForToken)
  {
    v20 = *sub_100083360(*v15, &HandleForToken);
    v21 = *a4;
    result = mlir::ODIE::Compiler::getHandleForToken(v14);
    HandleForToken = result;
    if (result)
    {
      goto LABEL_12;
    }

LABEL_21:
    if (v20 >= -1)
    {
      return result;
    }

    goto LABEL_22;
  }

  v20 = -1;
  v21 = *a4;
  result = mlir::ODIE::Compiler::getHandleForToken(v14);
  HandleForToken = result;
  if (!result)
  {
    goto LABEL_21;
  }

LABEL_12:
  result = sub_100083360(*v21, &HandleForToken);
  if (v20 >= *result)
  {
    return result;
  }

LABEL_22:
  v25 = *a2;
  *a2 = *a3;
  *a3 = v25;
  v26 = *a1;
  v27 = *a4;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a2);
  if (HandleForToken)
  {
    v28 = *sub_100083360(*v27, &HandleForToken);
    v29 = *a4;
    result = mlir::ODIE::Compiler::getHandleForToken(v26);
    HandleForToken = result;
    if (result)
    {
      goto LABEL_24;
    }

LABEL_30:
    if (v28 >= -1)
    {
      return result;
    }

    goto LABEL_31;
  }

  v28 = -1;
  v29 = *a4;
  result = mlir::ODIE::Compiler::getHandleForToken(v26);
  HandleForToken = result;
  if (!result)
  {
    goto LABEL_30;
  }

LABEL_24:
  result = sub_100083360(*v29, &HandleForToken);
  if (v28 < *result)
  {
LABEL_31:
    v31 = *a1;
    *a1 = *a2;
    *a2 = v31;
  }

  return result;
}

int *sub_10027AAF4(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t **a5)
{
  sub_10027A7F0(a1, a2, a3, a5);
  v10 = *a3;
  v11 = *a5;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a4);
  if (HandleForToken)
  {
    v12 = *sub_100083360(*v11, &HandleForToken);
    v13 = *a5;
    result = mlir::ODIE::Compiler::getHandleForToken(v10);
    HandleForToken = result;
    if (result)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v12 = -1;
    v13 = *a5;
    result = mlir::ODIE::Compiler::getHandleForToken(v10);
    HandleForToken = result;
    if (result)
    {
LABEL_3:
      result = sub_100083360(*v13, &HandleForToken);
      if (v12 >= *result)
      {
        return result;
      }

      goto LABEL_7;
    }
  }

  if (v12 >= -1)
  {
    return result;
  }

LABEL_7:
  v15 = *a3;
  *a3 = *a4;
  *a4 = v15;
  v16 = *a2;
  v17 = *a5;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a3);
  if (HandleForToken)
  {
    v18 = *sub_100083360(*v17, &HandleForToken);
    v19 = *a5;
    result = mlir::ODIE::Compiler::getHandleForToken(v16);
    HandleForToken = result;
    if (result)
    {
      goto LABEL_9;
    }
  }

  else
  {
    v18 = -1;
    v19 = *a5;
    result = mlir::ODIE::Compiler::getHandleForToken(v16);
    HandleForToken = result;
    if (result)
    {
LABEL_9:
      result = sub_100083360(*v19, &HandleForToken);
      if (v18 >= *result)
      {
        return result;
      }

      goto LABEL_13;
    }
  }

  if (v18 >= -1)
  {
    return result;
  }

LABEL_13:
  v20 = *a2;
  *a2 = *a3;
  *a3 = v20;
  v21 = *a1;
  v22 = *a5;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a2);
  if (HandleForToken)
  {
    v23 = *sub_100083360(*v22, &HandleForToken);
    v24 = *a5;
    result = mlir::ODIE::Compiler::getHandleForToken(v21);
    HandleForToken = result;
    if (result)
    {
      goto LABEL_15;
    }
  }

  else
  {
    v23 = -1;
    v24 = *a5;
    result = mlir::ODIE::Compiler::getHandleForToken(v21);
    HandleForToken = result;
    if (result)
    {
LABEL_15:
      result = sub_100083360(*v24, &HandleForToken);
      if (v23 >= *result)
      {
        return result;
      }

      goto LABEL_16;
    }
  }

  if (v23 >= -1)
  {
    return result;
  }

LABEL_16:
  v25 = *a1;
  *a1 = *a2;
  *a2 = v25;
  return result;
}

int *sub_10027ACF0(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t **a6)
{
  sub_10027AAF4(a1, a2, a3, a4, a6);
  v12 = *a4;
  v13 = *a6;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a5);
  if (HandleForToken)
  {
    v14 = *sub_100083360(*v13, &HandleForToken);
    v15 = *a6;
    result = mlir::ODIE::Compiler::getHandleForToken(v12);
    HandleForToken = result;
    if (result)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v14 = -1;
    v15 = *a6;
    result = mlir::ODIE::Compiler::getHandleForToken(v12);
    HandleForToken = result;
    if (result)
    {
LABEL_3:
      result = sub_100083360(*v15, &HandleForToken);
      if (v14 >= *result)
      {
        return result;
      }

      goto LABEL_7;
    }
  }

  if (v14 >= -1)
  {
    return result;
  }

LABEL_7:
  v17 = *a4;
  *a4 = *a5;
  *a5 = v17;
  v18 = *a3;
  v19 = *a6;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a4);
  if (HandleForToken)
  {
    v20 = *sub_100083360(*v19, &HandleForToken);
    v21 = *a6;
    result = mlir::ODIE::Compiler::getHandleForToken(v18);
    HandleForToken = result;
    if (result)
    {
      goto LABEL_9;
    }
  }

  else
  {
    v20 = -1;
    v21 = *a6;
    result = mlir::ODIE::Compiler::getHandleForToken(v18);
    HandleForToken = result;
    if (result)
    {
LABEL_9:
      result = sub_100083360(*v21, &HandleForToken);
      if (v20 >= *result)
      {
        return result;
      }

      goto LABEL_13;
    }
  }

  if (v20 >= -1)
  {
    return result;
  }

LABEL_13:
  v22 = *a3;
  *a3 = *a4;
  *a4 = v22;
  v23 = *a2;
  v24 = *a6;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a3);
  if (HandleForToken)
  {
    v25 = *sub_100083360(*v24, &HandleForToken);
    v26 = *a6;
    result = mlir::ODIE::Compiler::getHandleForToken(v23);
    HandleForToken = result;
    if (result)
    {
      goto LABEL_15;
    }
  }

  else
  {
    v25 = -1;
    v26 = *a6;
    result = mlir::ODIE::Compiler::getHandleForToken(v23);
    HandleForToken = result;
    if (result)
    {
LABEL_15:
      result = sub_100083360(*v26, &HandleForToken);
      if (v25 >= *result)
      {
        return result;
      }

      goto LABEL_19;
    }
  }

  if (v25 >= -1)
  {
    return result;
  }

LABEL_19:
  v27 = *a2;
  *a2 = *a3;
  *a3 = v27;
  v28 = *a1;
  v29 = *a6;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a2);
  if (HandleForToken)
  {
    v30 = *sub_100083360(*v29, &HandleForToken);
    v31 = *a6;
    result = mlir::ODIE::Compiler::getHandleForToken(v28);
    HandleForToken = result;
    if (result)
    {
      goto LABEL_21;
    }
  }

  else
  {
    v30 = -1;
    v31 = *a6;
    result = mlir::ODIE::Compiler::getHandleForToken(v28);
    HandleForToken = result;
    if (result)
    {
LABEL_21:
      result = sub_100083360(*v31, &HandleForToken);
      if (v30 >= *result)
      {
        return result;
      }

      goto LABEL_22;
    }
  }

  if (v30 >= -1)
  {
    return result;
  }

LABEL_22:
  v32 = *a1;
  *a1 = *a2;
  *a2 = v32;
  return result;
}

BOOL sub_10027AF84(uint64_t *a1, uint64_t *a2, uint64_t **a3)
{
  v5 = a2 - a1;
  if (v5 > 2)
  {
    switch(v5)
    {
      case 3:
        sub_10027A7F0(a1, a1 + 1, a2 - 1, a3);
        return 1;
      case 4:
        sub_10027AAF4(a1, a1 + 1, a1 + 2, a2 - 1, a3);
        return 1;
      case 5:
        sub_10027ACF0(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
        return 1;
    }
  }

  else
  {
    if (v5 < 2)
    {
      return 1;
    }

    if (v5 == 2)
    {
      v6 = *a1;
      v7 = *a3;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*(a2 - 1));
      if (HandleForToken)
      {
        v8 = *sub_100083360(*v7, &HandleForToken);
        v9 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v6);
        if (HandleForToken)
        {
          goto LABEL_6;
        }
      }

      else
      {
        v8 = -1;
        v9 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v6);
        if (HandleForToken)
        {
LABEL_6:
          if (v8 >= *sub_100083360(*v9, &HandleForToken))
          {
            return 1;
          }

          goto LABEL_37;
        }
      }

      if (v8 < -1)
      {
LABEL_37:
        v24 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v24;
      }

      return 1;
    }
  }

  v10 = a1 + 2;
  sub_10027A7F0(a1, a1 + 1, a1 + 2, a3);
  v11 = a1 + 3;
  if (a1 + 3 == a2)
  {
    return 1;
  }

  v12 = 0;
  v13 = 0;
  while (1)
  {
    v14 = *v10;
    v15 = *a3;
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*v11);
    if (HandleForToken)
    {
      v16 = *sub_100083360(*v15, &HandleForToken);
      v17 = *a3;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v14);
      if (HandleForToken)
      {
        goto LABEL_19;
      }
    }

    else
    {
      v16 = -1;
      v17 = *a3;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v14);
      if (HandleForToken)
      {
LABEL_19:
        if (v16 < *sub_100083360(*v17, &HandleForToken))
        {
          break;
        }

        goto LABEL_32;
      }
    }

    if (v16 < -1)
    {
      break;
    }

LABEL_32:
    v10 = v11;
    v12 += 8;
    if (++v11 == a2)
    {
      return 1;
    }
  }

  v18 = *v11;
  v19 = v12;
  do
  {
    while (1)
    {
      *(a1 + v19 + 24) = *(a1 + v19 + 16);
      if (v19 == -16)
      {
        *a1 = v18;
        if (++v13 != 8)
        {
          goto LABEL_32;
        }

        return v11 + 1 == a2;
      }

      v20 = *(a1 + v19 + 8);
      v21 = *a3;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v18);
      if (HandleForToken)
      {
        break;
      }

      v22 = -1;
      v23 = *a3;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v20);
      if (!HandleForToken)
      {
        goto LABEL_30;
      }

LABEL_24:
      v19 -= 8;
      if (v22 >= *sub_100083360(*v23, &HandleForToken))
      {
        goto LABEL_31;
      }
    }

    v22 = *sub_100083360(*v21, &HandleForToken);
    v23 = *a3;
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v20);
    if (HandleForToken)
    {
      goto LABEL_24;
    }

LABEL_30:
    v19 -= 8;
  }

  while (v22 < -1);
LABEL_31:
  *(a1 + v19 + 24) = v18;
  if (++v13 != 8)
  {
    goto LABEL_32;
  }

  return v11 + 1 == a2;
}

uint64_t mlir::ODIE::Compiler::CoreMLAX::RemoveRedundantCopyWithConstraintsOp::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = **(*(a2 + 72) + 24);
  if (!v3)
  {
    return 0;
  }

  v6 = 0;
  v7 = a2 - 16;
  do
  {
    v8 = v3[2];
    v3 = *v3;
    if (v8 != a2)
    {
      v9 = *(*(v8 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyWithConstraintsOp,void>::id ? v8 : 0;
      if (v9)
      {
        if (*(v9 + 36))
        {
          v10 = v9 - 16;
        }

        else
        {
          v10 = 0;
        }

        v11 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0) + 8);
        if (*(a2 + 36))
        {
          v12 = v7;
        }

        else
        {
          v12 = 0;
        }

        if ((*(mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0) + 8) ^ v11) <= 7)
        {
          (*(*a3 + 8))(a3, v9, a2);
          v6 = 1;
        }
      }
    }
  }

  while (v3);
  return v6;
}

uint64_t mlir::ODIE::Compiler::CoreMLAX::RemoveRedundantCopyDiscardingConstraintsOp::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = **(*(a2 + 72) + 24);
  if (!v3)
  {
    return 0;
  }

  result = 0;
  do
  {
    v7 = v3[2];
    v3 = *v3;
    if (v7 != a2)
    {
      if (v7)
      {
        v8 = *(*(v7 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyDiscardingConstraintsOp,void>::id;
      }

      else
      {
        v8 = 0;
      }

      if (v8)
      {
        (*(*a3 + 8))(a3);
        result = 1;
      }
    }
  }

  while (v3);
  return result;
}

uint64_t mlir::ODIE::Compiler::CoreMLAX::PromoteToFromPairToCastOp::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  v5 = *(a2 + 36);
  v6 = a2 - 16;
  if (v5)
  {
    v7 = a2 - 16;
  }

  else
  {
    v7 = 0;
  }

  v32.n128_u64[0] = v7;
  v32.n128_u64[1] = v5;
  mlir::ResultRange::use_begin(&v32, v40);
  v8 = *(a2 + 36);
  if (v8)
  {
    v9 = v6;
  }

  else
  {
    v9 = 0;
  }

  v37[0].n128_u64[0] = v9;
  v37[0].n128_u64[1] = v8;
  mlir::ResultRange::use_end(v37, v35);
  v34 = v42;
  v32 = *v40;
  v33 = v41;
  v10 = v36;
  if (v42 == v36)
  {
    v11 = 0;
  }

  else
  {
    v11 = 0;
    do
    {
      ++v11;
      mlir::ResultRange::UseIterator::operator++(v40);
    }

    while (v42 != v10);
  }

  v40[0] = &v41;
  v40[1] = 0x600000000;
  v12 = *(a2 + 36);
  if (v12)
  {
    v13 = v6;
  }

  else
  {
    v13 = 0;
  }

  v32.n128_u64[0] = v13;
  v32.n128_u64[1] = v12;
  mlir::ResultRange::use_begin(&v32, v37);
  v14 = *(a2 + 36);
  if (v14)
  {
    v15 = v6;
  }

  else
  {
    v15 = 0;
  }

  v39.n128_u64[0] = v15;
  v39.n128_u64[1] = v14;
  mlir::ResultRange::use_end(&v39, v35);
  v16 = v38;
  v34 = v38;
  v32 = v37[0];
  v33 = v37[1];
  for (i = v36; v38 != i; v16 = v38)
  {
    v18 = *(v16 + 16);
    if (v18)
    {
      v19 = *(*(v18 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyWithConstraintsOp,void>::id;
    }

    else
    {
      v19 = 0;
    }

    if (v19)
    {
      v20 = LODWORD(v40[1]);
      if (LODWORD(v40[1]) >= HIDWORD(v40[1]))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v40, &v41, LODWORD(v40[1]) + 1, 8);
        v20 = LODWORD(v40[1]);
      }

      *(v40[0] + v20) = v18;
      ++LODWORD(v40[1]);
    }

    mlir::ResultRange::UseIterator::operator++(v37);
  }

  if (LODWORD(v40[1]))
  {
    v21 = v40[0];
    v22 = 8 * LODWORD(v40[1]);
    do
    {
      v24 = *v21++;
      v23 = v24;
      v25 = v24 - 16;
      if (*(v24 + 36))
      {
        v26 = v25;
      }

      else
      {
        v26 = 0;
      }

      v32.n128_u64[0] = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v26, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      v37[0].n128_u64[0] = *(*(a2 + 72) + 24);
      v27 = sub_10027BD40(a3 + 1, *(v23 + 24), &v32, v37);
      (*(*a3 + 8))(a3, v23, v27);
      v22 -= 8;
    }

    while (v22);
    if (v11 == LODWORD(v40[1]))
    {
      (*(*a3 + 16))(a3, a2);
    }

    v28 = 1;
    v29 = v40[0];
    if (v40[0] != &v41)
    {
LABEL_38:
      free(v29);
    }
  }

  else
  {
    v32.n128_u64[0] = "no coremlax.copy_with_constraints users";
    LOWORD(v34) = 259;
    v37[0].n128_u64[0] = &v32;
    v31 = a3[2];
    if (v31 && mlir::RewriterBase::Listener::classof(v31))
    {
      (*(*v31 + 88))(v31, *(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::CoreMLAX::CopyDiscardingConstraintsOp &>(mlir::ODIE::Compiler::CoreMLAX::CopyDiscardingConstraintsOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v37);
    }

    v28 = 0;
    v29 = v40[0];
    if (v40[0] != &v41)
    {
      goto LABEL_38;
    }
  }

  return v28;
}

uint64_t mlir::ODIE::Compiler::CoreMLAX::FoldCastOpIntoCopyWithConstraintsOp::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  v3 = *(*(a2 + 72) + 24);
  if (!*v3)
  {
    return 0;
  }

  if (**v3)
  {
    return 0;
  }

  v12 = *(*(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp(&v12);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyWithConstraintsOp,void>::id)
    {
      return 0;
    }

    if (*(a2 + 36))
    {
      v7 = a2 - 16;
    }

    else
    {
      v7 = 0;
    }

    v8 = result;
    v9 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v11 = *(*(v8 + 72) + 24);
    v12 = v9;
    v10 = sub_10027BE30(a3 + 1, *(v8 + 24), &v12, &v11);
    (*(*a3 + 8))(a3, v8, v10);
    (*(*a3 + 8))(a3, a2, v10);
    return 1;
  }

  return result;
}

uint64_t mlir::ODIE::Compiler::CoreMLAX::PromoteCastOpToViewOp::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  v19 = *(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(a2 + 36))
  {
    v5 = a2 - 16;
  }

  else
  {
    v5 = 0;
  }

  v18 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  ElementType = mlir::RankedTensorType::getElementType(&v19);
  if (ElementType == mlir::RankedTensorType::getElementType(&v18))
  {
    mlir::ODIE::Compiler::CoreMLAX::getStrides(v19, &v26);
    mlir::ODIE::Compiler::CoreMLAX::getStrides(v18, &__s2);
    if (v27)
    {
      v7 = 8 * v27;
      v8 = v26;
      while (*v8 != 0x8000000000000000)
      {
        v8 += 8;
        v7 -= 8;
        if (!v7)
        {
          goto LABEL_9;
        }
      }
    }

    else
    {
LABEL_9:
      if (!v24)
      {
LABEL_13:
        if (v27 == v24 && !memcmp(v26, __s2, 8 * v27))
        {
          v20[0] = *(*(a2 + 72) + 24);
          v17 = sub_10027BF30(a3 + 1, *(a2 + 24), &v18, v20);
          (*(*a3 + 8))(a3, a2, v17);
          v13 = 1;
          v15 = __s2;
          if (__s2 == v25)
          {
LABEL_26:
            if (v26 != v28)
            {
              free(v26);
            }

            return v13;
          }

LABEL_25:
          free(v15);
          goto LABEL_26;
        }

        v11 = "source strides don't match dest strides";
LABEL_21:
        v20[0] = v11;
        v21 = 259;
        v22 = v20;
        v14 = a3[2];
        if (v14 && mlir::RewriterBase::Listener::classof(v14))
        {
          (*(*v14 + 88))(v14, *(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::CoreMLAX::CastOp &>(mlir::ODIE::Compiler::CoreMLAX::CastOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v22);
        }

        v13 = 0;
        v15 = __s2;
        if (__s2 == v25)
        {
          goto LABEL_26;
        }

        goto LABEL_25;
      }

      v9 = 8 * v24;
      v10 = __s2;
      while (*v10 != 0x8000000000000000)
      {
        ++v10;
        v9 -= 8;
        if (!v9)
        {
          goto LABEL_13;
        }
      }
    }

    v11 = "source or result have dynamic shape";
    goto LABEL_21;
  }

  v26 = "source dtype and result dtype are different";
  v28[8] = 259;
  __s2 = &v26;
  v12 = a3[2];
  if (v12 && mlir::RewriterBase::Listener::classof(v12))
  {
    (*(*v12 + 88))(v12, *(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::CoreMLAX::CastOp &>(mlir::ODIE::Compiler::CoreMLAX::CastOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &__s2);
  }

  return 0;
}