@interface _UIKeyboardStateManager
+ (BOOL)_isInputEligibleForSpaceAutodelete:(id)autodelete;
+ (Class)layoutClassForInputMode:(id)mode keyboardType:(int64_t)type screenTraits:(id)traits;
- (BOOL)_canDeleteForward;
- (BOOL)_canHandleResponderCommand:(SEL)command;
- (BOOL)_canHandleResponderCommandConservatively:(SEL)conservatively;
- (BOOL)_cancelOperation:(BOOL)operation testOnly:(BOOL)only;
- (BOOL)_containsUsernamePasswordPairsInAutofillGroup:(id)group;
- (BOOL)_delegateRequiresKeyEvents;
- (BOOL)_handleKeyInputMethodCommandForEvent:(id)event canHandleAppKeyCommand:(BOOL)command;
- (BOOL)_hasMarkedText;
- (BOOL)_insertSupplementalCandidate:(id)candidate overridingCandidateText:(id)text;
- (BOOL)_isShowingCandidateUIWithAvailableCandidates;
- (BOOL)_isShowingSuggestionForKeyboardCamera;
- (BOOL)_isValidKeyInput:(id)input;
- (BOOL)_shouldAcceptAutocorrectionOnSelectionChange;
- (BOOL)_shouldEmitString:(id)string forKeyEvent:(id)event;
- (BOOL)_shouldLoadAutofillSignUpInputViewController;
- (BOOL)_shouldLoadPredictionsBasedOnCurrentTraits;
- (BOOL)_shouldRequestInputManagerSyncForKeyboardOutputCallbacks:(id)callbacks;
- (BOOL)acceptAutofillExtraCandidateIfNeeded:(id)needed;
- (BOOL)acceptInputString:(id)string;
- (BOOL)acceptWord:(id)word firstDelete:(unint64_t)delete forInput:(id)input;
- (BOOL)allowsReachableKeyboard;
- (BOOL)applyAutocorrection:(id)autocorrection;
- (BOOL)assertTextForRemoteDocument:(id)document withSelectionDelta:(id)delta updatingSelection:(BOOL)selection;
- (BOOL)autocapitalizationPreference;
- (BOOL)autocorrectionPreference;
- (BOOL)automaticMinimizationEnabled;
- (BOOL)callLayoutIgnoresShiftState;
- (BOOL)callLayoutIsShiftKeyBeingHeld;
- (BOOL)callLayoutIsShiftKeyPlaneChooser;
- (BOOL)callLayoutUsesAutoShift;
- (BOOL)callShouldDeleteWithWordCountForRapidDelete:(int)delete characterCountForRapidDelete:(int)rapidDelete;
- (BOOL)callShouldInsertText:(id)text;
- (BOOL)callShouldInsertText:(id)text onDelegate:(id)delegate;
- (BOOL)canHandleKeyHitTest;
- (BOOL)canInsertAdaptiveImageGlyph;
- (BOOL)canInsertEmojiImageTextAttachment;
- (BOOL)canInsertStickerAsTextInputPayload;
- (BOOL)canPasteImage;
- (BOOL)canPresentPressAndHoldPopover:(id)popover;
- (BOOL)canShowAppConnections;
- (BOOL)canShowPredictionBar;
- (BOOL)canUseCandidateBarAsSupplementToInlineView;
- (BOOL)candidateSelectionPredictionForTraits;
- (BOOL)checkSpellingPreference;
- (BOOL)checkSpellingPreferenceForTraits;
- (BOOL)continuousPathUnderway;
- (BOOL)currentInputModeRequiresLTRMathExpression;
- (BOOL)currentKeyboardTraitsAllowCandidateBarWhileIgnoringHidePredictionTrait:(BOOL)trait;
- (BOOL)cursorIsAtEndOfMarkedText;
- (BOOL)cursorIsAtStartOfInlineCompletionMarkedText;
- (BOOL)deferEventHandlingToSystemWithContext:(id)context;
- (BOOL)delegateAlreadyInAutofillGroup;
- (BOOL)delegateSuggestionsForCurrentInput;
- (BOOL)delegateSupportsCorrectionUI;
- (BOOL)deleteForwardAndNotify:(BOOL)notify producedByDeleteInput:(BOOL)input;
- (BOOL)disableInputBars;
- (BOOL)dontPushOneTimeCode;
- (BOOL)doubleSpacePeriodPreference;
- (BOOL)exclusivityIdentifierMatched;
- (BOOL)handleCandidateListNavigation:(unsigned int)navigation hasCandidatesForTypedInput:(BOOL)input shiftDown:(BOOL)down keyCommandTypeHandled:(unint64_t *)handled allowRepeat:(BOOL *)repeat beforePublic:(BOOL)public keyEvent:(id)event;
- (BOOL)handleHorizontalArrow:(BOOL)arrow shiftDown:(BOOL)down beforePublicKeyCommands:(BOOL)commands testOnly:(BOOL)only isVerticalCandidate:(BOOL)candidate hasCandidatesForTypedInput:(BOOL)input shouldNavigateCandidateList:(BOOL)list canHandleInputDelegateCommand:(id)self0 savedHistory:(id)self1 keyCommandTypeHandled:(unint64_t *)self2 keyEvent:(id)self3;
- (BOOL)handleInputManagerBasedKeybind:(id)keybind testOnly:(BOOL)only;
- (BOOL)handleInputSwitcherForKeyEvent:(id)event;
- (BOOL)handleKeyAppCommandForCurrentEvent;
- (BOOL)handleKeyCommand:(id)command repeatOkay:(BOOL *)okay beforePublicKeyCommands:(BOOL)commands;
- (BOOL)handleKeyCommandsBeforePublicAsInputUIHost:(id)host;
- (BOOL)handleKeyInputMethodCommandForCurrentEvent;
- (BOOL)handleKeyTextCommandForCurrentEvent;
- (BOOL)handleMoveCursorToEndOfLine:(BOOL)line beforePublicKeyCommands:(BOOL)commands testOnly:(BOOL)only savedHistory:(id)history force:(BOOL)force canHandleSelectableInputDelegateCommand:(id)command keyEvent:(id)event;
- (BOOL)handleMoveCursorToStartOfLine:(BOOL)line beforePublicKeyCommands:(BOOL)commands testOnly:(BOOL)only savedHistory:(id)history force:(BOOL)force canHandleSelectableInputDelegateCommand:(id)command keyEvent:(id)event;
- (BOOL)handleReturnKey:(BOOL)key;
- (BOOL)handleTabWithShift:(BOOL)shift beforePublicKeyCommands:(BOOL)commands isMoveAction:(BOOL)action testOnly:(BOOL)only;
- (BOOL)handleVerticalArrow:(BOOL)arrow shiftDown:(BOOL)down beforePublicKeyCommands:(BOOL)commands testOnly:(BOOL)only isVerticalCandidate:(BOOL)candidate hasCandidatesForTypedInput:(BOOL)input inputDelegateCommandEnabled:(BOOL)enabled canHandleInputDelegateCommand:(id)self0 savedHistory:(id)self1 keyCommandTypeHandled:(unint64_t *)self2 keyEvent:(id)self3;
- (BOOL)hasAdvancedInputDelegate;
- (BOOL)hasAsyncCapableInputDelegate;
- (BOOL)hasAutocorrectPrompt;
- (BOOL)hasDelegate;
- (BOOL)hasEditableMarkedText;
- (BOOL)hasInlineCompletionAsMarkedText;
- (BOOL)imageSuggestionEnabled;
- (BOOL)initializationDone;
- (BOOL)inputModeSwitcherVisible;
- (BOOL)inputUIHandleTabWithShift:(BOOL)shift testOnly:(BOOL)only;
- (BOOL)insertAutoFillTextSuggestion:(id)suggestion;
- (BOOL)insertTextIfShould:(id)should;
- (BOOL)insertsSpaceAfterPredictiveInput;
- (BOOL)isAutoFillMode;
- (BOOL)isCallingInputDelegate;
- (BOOL)isCapsLockASCIIToggle;
- (BOOL)isCapsLockSwitchEnabled;
- (BOOL)isCurrentEditResponderInEditingMode;
- (BOOL)isCurrentEditResponderWebKit;
- (BOOL)isInHardwareKeyboardMode;
- (BOOL)isInlineCompletionEnabled;
- (BOOL)isMemberOfAutofillGroup:(id)group;
- (BOOL)isMemberOfPossibleAutofillGroup:(id)group;
- (BOOL)isMinimized;
- (BOOL)isPredictionViewControllerVisible;
- (BOOL)isRTIClient;
- (BOOL)isRotating;
- (BOOL)isSelecting;
- (BOOL)isSelectionAtSentenceAutoshiftBoundary:(BOOL)boundary;
- (BOOL)isSelectionChanging;
- (BOOL)isShiftKeyBeingHeld;
- (BOOL)isTrackpadMode;
- (BOOL)keyboardInputModeIndicatorControllerShouldPresentIndicator:(id)indicator;
- (BOOL)keyboardIsInPencilTextInputMode;
- (BOOL)keyboardLayoutIsInAnotherProcess;
- (BOOL)keyboardsExpandedPreference;
- (BOOL)maximizing;
- (BOOL)needAutofillLogin;
- (BOOL)needCellularAutofill;
- (BOOL)needOneTimeCodeAutofill;
- (BOOL)needsToDeferUpdateTextCandidateView;
- (BOOL)nextCharacterIsWordCharacter;
- (BOOL)nextInputWouldStartSentence;
- (BOOL)noContent;
- (BOOL)performKeyboardEvent:(id)event;
- (BOOL)performKeyboardOutput:(id)output checkingDelegate:(BOOL)delegate forwardToRemoteInputSource:(BOOL)source;
- (BOOL)performKeyboardOutput:(id)output userInfo:(id)info;
- (BOOL)performSendAction;
- (BOOL)predictionFromPreference;
- (BOOL)preferFallbackAutofillGroup;
- (BOOL)presentTextCompletionAsMarkedText:(id)text;
- (BOOL)prewarmsPredictiveCandidates;
- (BOOL)returnKeyEnabled;
- (BOOL)selectionScrolling;
- (BOOL)shiftLockPreference;
- (BOOL)shouldAcceptCandidate:(id)candidate beforeInputString:(id)string;
- (BOOL)shouldAcceptContinuousPathConversion:(id)conversion;
- (BOOL)shouldAccessInputManagerService;
- (BOOL)shouldAllowRepeatEvent:(id)event;
- (BOOL)shouldAllowSelectionGestures:(BOOL)gestures atPoint:(CGPoint)point toBegin:(BOOL)begin;
- (BOOL)shouldApplyAcceptedAutocorrection:(id)autocorrection;
- (BOOL)shouldApplyKeyboardCommandToUIHost;
- (BOOL)shouldApplyKeyboardInputToUIHost;
- (BOOL)shouldClearConversationContextForClient:(id)client;
- (BOOL)shouldDeferEventHandlingToSystemForTextInput:(id)input context:(id)context;
- (BOOL)shouldDeleteAutospaceBeforeTerminator:(id)terminator;
- (BOOL)shouldGenerateCandidatesAfterSelectionChange;
- (BOOL)shouldLoadAutofillSignUpInputViewController;
- (BOOL)shouldPreventLongFormSmartRepliesFromStarting;
- (BOOL)shouldPrioritizeTextSuggestionsOverCandidateResultSet:(id)set;
- (BOOL)shouldRapidDelete;
- (BOOL)shouldShowCandidateBar;
- (BOOL)shouldShowKeyboardMenu;
- (BOOL)shouldShowLongPredictionList;
- (BOOL)shouldSuppressSelectionCommands;
- (BOOL)shouldSwitchFromInputManagerMode:(id)mode toInputMode:(id)inputMode;
- (BOOL)shouldSwitchInputMode:(id)mode;
- (BOOL)shouldUnderlineCandidate:(id)candidate;
- (BOOL)shouldUseAdaptiveDelete;
- (BOOL)shouldUseCarPlayModes;
- (BOOL)shouldUsePinyinStyleRowNavigation;
- (BOOL)showingEmojiSearch;
- (BOOL)showsCandidateBar;
- (BOOL)showsCandidateInline;
- (BOOL)smartInsertDeleteIsEnabled;
- (BOOL)suppliesCompletions;
- (BOOL)supportsGenmojiCreation;
- (BOOL)supportsNumberKeySelection;
- (BOOL)supportsSetPhraseBoundary;
- (BOOL)suppressOptOutASPCandidateUpdateForDelegate:(id)delegate;
- (BOOL)switchMode:(id)mode withHUD:(BOOL)d withDelay:(BOOL)delay fromCapsLock:(BOOL)lock;
- (BOOL)textInputTraitsNeedAutofill;
- (BOOL)textInputTraitsNeedAutofillExcludeOneTimeCodeAndContact;
- (BOOL)textInputTraitsNeedContactAutoFill;
- (BOOL)textInputTraitsNeedOneTimeCode;
- (BOOL)textInputTraitsNeedSignup;
- (BOOL)uncachedDelegateSupportsImagePaste;
- (BOOL)usesAutoDeleteWord;
- (BOOL)usesCandidateSelection;
- (BOOL)utlizeEuclidModelForDictationReplacement;
- (BOOL)willDoubleSpacePeriodForInputString:(id)string afterSpace:(BOOL)space elapsedTime:(double)time;
- (CGRect)correctionRect;
- (CGRect)getCorrectionRectIsVertical:(BOOL *)vertical;
- (CGRect)subtractKeyboardFrameFromRect:(CGRect)rect inView:(id)view;
- (TIDocumentState)documentState;
- (TIKeyboardInputManagerStub)inputManager;
- (TISmartPunctuationController)smartPunctuationController;
- (TUIKeyboardBackendController)backendController;
- (UIKBRTIPartner)remoteTextInputPartner;
- (UIKBRTIPartner)remoteTextInputPartnerPrivate;
- (UIKeyInput)delegate;
- (UITextInteractionAssistant)textInteractionAssistant;
- (UIView)overlayContainerObserved;
- (_UIKeyboardPresentationDelegate)presentationDelegate;
- (_UIKeyboardStateManager)initWithPresentationDelegateView:(id)view forCustomInputView:(BOOL)inputView;
- (_UIKeyboardTextSelectionController)textSelectionController;
- (_UITextChoiceAccelerationAssistant)_textChoicesAssistant;
- (_UITextInputUserInteractionDelegate)userInteractionDelegate;
- (_UITextInteractionEditMenuAssistant)_editMenuAssistant;
- (double)biasedKeyboardWidthRatio;
- (double)scaleCurrentForceFrom:(double)result to:(double)to;
- (double)shouldExtendLongPressAction:(id)action;
- (double)timeoutForCurrentForce;
- (double)timestampOfLastTouchesEnded;
- (id)UILanguagePreference;
- (id)_acquireWaitingOnPerformAutocorrect;
- (id)_activeAssertionController;
- (id)_attributedCorrectionTextEffectAnimation:(id)animation;
- (id)_attributedCorrectionTextEffectStyle:(id)style;
- (id)_autocorrectionListDemotingAutocorrectionFromList:(id)list;
- (id)_autofillGroup;
- (id)_buildCandidatesFromResults:(id)results selectedText:(id)text;
- (id)_contentsOfUsernameField;
- (id)_fallbackAutofillGroup;
- (id)_getAutocorrection;
- (id)_getAutocorrectionList;
- (id)_getCandidateList;
- (id)_getCurrentKeyboardName;
- (id)_getCurrentKeyplaneName;
- (id)_getLocalizedInputMode;
- (id)_keyboardBehaviorState;
- (id)_markedText;
- (id)_obtainSessionIdentifierAssertionForReason:(id)reason;
- (id)_rangeForAutocorrectionText:(id)text;
- (id)_rangeForSupplementalItemText:(id)text;
- (id)_remoteAppId;
- (id)_remoteAssociatedDomains;
- (id)_remoteLocalizedAppName;
- (id)_remoteUnlocalizedAppName;
- (id)_rtiDocumentStateForAutoFillPopover;
- (id)_supplementalCandidateIcon:(id)icon;
- (id)_targetForResponderCommand:(SEL)command;
- (id)_textInputController;
- (id)acceptAutocorrectionForWordTerminator:(id)terminator;
- (id)acceptCurrentCandidateForInput:(id)input;
- (id)acceptInlineCandidateForInput:(id)input withSpace:(BOOL)space;
- (id)activeLayout;
- (id)asyncCapableInputDelegate;
- (id)asyncInputDelegate;
- (id)asyncWebKitInteractionDelegate;
- (id)attributedCorrectionFromTextAnimationCandidate:(id)candidate;
- (id)attributedText;
- (id)autocorrectPromptRectsFromFirstDelegateRect:(CGRect)rect lastDelegateRect:(CGRect)delegateRect;
- (id)autocorrectionRecordForWord:(id)word;
- (id)buildInputSourceState;
- (id)delegateAsResponder;
- (id)desirableInputModesWithExtensions:(BOOL)extensions;
- (id)dictationAlternativesForReplacement;
- (id)documentIdentifierForInputDelegate:(id)delegate;
- (id)dynamicCaretList;
- (id)emojiCandidate:(id)candidate;
- (id)generateAutocorrectionListForSelectedText;
- (id)generateAutocorrectionReplacements:(id)replacements;
- (id)handleDeleteAutospaceForInputString:(id)string afterSpace:(BOOL)space;
- (id)handleReplacement:(id)replacement forSpaceAndInput:(id)input;
- (id)hardwareKeyboardsSeenPreference;
- (id)inputDelegate;
- (id)inputEventForInputString:(id)string;
- (id)inputModePreference;
- (id)inputOverlayContainerForCandidateView:(BOOL)view;
- (id)inputStringFromPhraseBoundary;
- (id)inputSystemSourceSession;
- (id)inputWordForTerminatorAtSelection;
- (id)internationalKeyDisplayStringOnEmojiKeyboard;
- (id)layoutState;
- (id)physicalKeyboardEventWithInput:(id)input inputFlags:(int)flags;
- (id)replacementsFromSelectedText;
- (id)responderForSendCurrentLocation;
- (id)savedAutocorrectionListForCandidate:(id)candidate;
- (id)searchStringForMarkedText;
- (id)textContentTypeForCurrentInputDelegate;
- (id)textSuggestions;
- (id)updateKeyBehaviors:(id)behaviors withBehaviors:(id)withBehaviors forState:(id)state;
- (id)updateSecureCandidateRenderTraits;
- (id)updatedKeyBehaviors;
- (id)webInputDelegate;
- (int)returnKeyType;
- (int64_t)_textInputSourceForDelegate:(id)delegate;
- (int64_t)autofillSubMode;
- (int64_t)currentHandBias;
- (int64_t)needAutofill;
- (int64_t)needAutofillCandidate:(id)candidate;
- (int64_t)preferredCandidateViewTypeForCandidateResultSet:(id)set;
- (unint64_t)_handleKeyCommandCommon:(id)common options:(unint64_t)options;
- (unint64_t)_updateAutocorrectionPreferenceForTraitsWithCurrentPreference:(BOOL)preference;
- (unint64_t)autocorrectionPreferenceForTraits;
- (unint64_t)delegateConformanceType;
- (unint64_t)handleKeyCommand:(id)command repeatOkay:(BOOL *)okay options:(unint64_t)options;
- (unint64_t)maxNumberOfProactiveCells;
- (unint64_t)phraseBoundary;
- (unint64_t)textLengthToDeleteBeforeSelectedRangeForSmartDelete;
- (unsigned)_setAttributedMarkedText:(id)text selectedRange:(_NSRange)range inputString:(id)string lastInputString:(id)inputString searchString:(id)searchString compareAttributes:(BOOL)attributes;
- (unsigned)assertIntermediateText:(id)text;
- (unsigned)setMarkedText:(id)text selectedRange:(_NSRange)range inputString:(id)string lastInputString:(id)inputString searchString:(id)searchString candidateOffset:(int64_t)offset liveConversionSegments:(id)segments highlighSegmentIndex:(unint64_t)self0;
- (void)_acceptAutocorrection;
- (void)_acceptAutofillCandidateRequiringAuthentication:(id)authentication payloadDelegate:(id)delegate executionContext:(id)context;
- (void)_acceptSupplementalCandidate:(id)candidate completion:(id)completion;
- (void)_addInputString:(id)string withFlags:(unint64_t)flags withInputManagerHint:(id)hint withInputSource:(int64_t)source;
- (void)_attemptAuthenticationWithMessage:(id)message;
- (void)_cancelPendingSupplementalCandidateInsertion;
- (void)_completePerformInputViewControllerOutput:(id)output executionContext:(id)context;
- (void)_conditionallyNotifyPredictionsAreAvailableForCandidates:(id)candidates containingProactiveTriggers:(BOOL)triggers;
- (void)_configureMarkedTextAttributesForConversion:(id)conversion selectedRange:(_NSRange)range highlightRange:(_NSRange)highlightRange;
- (void)_deactiveActiveKeys;
- (void)_deleteFromInputWithFlags:(unint64_t)flags;
- (void)_didReplaceText:(id)text withSupplementalCandidate:(id)candidate;
- (void)_dispatchInsertionPointEnteredText:(id)text range:(id)range withSupplementalCandidate:(id)candidate;
- (void)_dispatchInsertionPointExitedRangeWithSupplementalCandidate;
- (void)_dynamicUserInterfaceTraitDidChange;
- (void)_ensureRTIConnection;
- (void)_forwardNeededShiftStatesToDestination;
- (void)_generateTextSuggestionForKeyboardCamera;
- (void)_handleKeyBehavior:(unint64_t)behavior forKeyType:(id)type;
- (void)_handleKeyEvent:(id)event executionContext:(id)context;
- (void)_handleWebKeyEvent:(id)event withEventType:(int)type withInputString:(id)string withInputStringIgnoringModifiers:(id)modifiers executionContext:(id)context;
- (void)_handleWebKeyEvent:(id)event withEventType:(unint64_t)type withInputString:(id)string withInputStringIgnoringModifiers:(id)modifiers;
- (void)_handleWebKeyEvent:(id)event withIndex:(unint64_t)index inInputString:(id)string;
- (void)_handleWebKeyEvent:(id)event withIndex:(unint64_t)index inInputString:(id)string executionContext:(id)context;
- (void)_handleWebKeyEvent:(id)event withInputString:(id)string executionContext:(id)context;
- (void)_inputManagerDidGenerateSupplementalCandidates:(id)candidates;
- (void)_insertSmartText:(id)text completionHandler:(id)handler;
- (void)_insertStickerAsNonTextAttachment:(id)attachment;
- (void)_insertionPointExitedRangeWithSupplementalCandidate;
- (void)_local_acceptAutocorrection;
- (void)_noteInlineCompletionAsMarkedText:(id)text;
- (void)_notifyDidTeardownExistingDelegate:(id)delegate newDelegate:(id)newDelegate;
- (void)_notifyWillSetupNewDelegate:(id)delegate existingDelegate:(id)existingDelegate;
- (void)_performInputViewControllerOutput:(id)output;
- (void)_performKeyboardOutput:(id)output respectingForwardingDelegate:(BOOL)delegate;
- (void)_performTextOperationsForAutoFill:(id)fill;
- (void)_postInputResponderCapabilitiesChangedNotificationWithOutput:(id)output selectionChanged:(BOOL)changed;
- (void)_postInputResponderChangedNotification;
- (void)_processInputViewControllerKeyboardOutput:(id)output executionContext:(id)context;
- (void)_reloadInputViewsForSameDelegate:(id)delegate existingDelegate:(id)existingDelegate force:(BOOL)force delayEndInputSession:(BOOL)session;
- (void)_remapKeyEvent:(id)event withKeyEventMap:(id)map;
- (void)_requestInputManagerSync;
- (void)_scheduleInputAdditionOrDeletion:(id)deletion;
- (void)_setAutofillGroup:(id)group;
- (void)_setDelegate:(id)delegate existingDelegate:(id)existingDelegate force:(BOOL)force delayEndInputSession:(BOOL)session;
- (void)_setInputManager:(id)manager;
- (void)_setKeyboardInputMode:(id)mode userInitiated:(BOOL)initiated force:(BOOL)force;
- (void)_setKeyboardInputMode:(id)mode userInitiated:(BOOL)initiated updateIndicator:(BOOL)indicator force:(BOOL)force executionContext:(id)context;
- (void)_setSuggestions:(id)suggestions;
- (void)_setTransientSelectionModeEnabled:(BOOL)enabled forInputDelegate:(id)delegate;
- (void)_setWaitingOnPerformAutocorrect:(id)autocorrect;
- (void)_setupDelegate:(id)delegate delegateSame:(BOOL)same hardwareKeyboardStateChanged:(BOOL)changed endingInputSessionIdentifier:(id)identifier force:(BOOL)force delayEndInputSession:(BOOL)session;
- (void)_signalInvocationOfKeyCommandForAction:(uint64_t)action;
- (void)_startSmartReplyWritingToolWithPrompt:(id)prompt entryPoint:(id)point inputContextHistory:(id)history;
- (void)_stopAutoDeleteAtDocumentStart;
- (void)_tagTouchForTypingMenu:(unsigned int)menu;
- (void)_teardownExistingDelegate:(id)delegate forSetDelegate:(id)setDelegate force:(BOOL)force delayEndInputSession:(BOOL)session;
- (void)_updateCanSuggestSupplementalItemsForCurrentSelection;
- (void)_updateCandidatesWithCandidates:(id)candidates usesCandidateSelection:(BOOL)selection;
- (void)_updateDelegateRequiresKeyEventsFromRemoteTextInput;
- (void)_updateInputViewControllerOutput:(id)output forKeyboardOutput:(id)keyboardOutput;
- (void)_updateKeyboardConfigurations;
- (void)_willReplaceText:(id)text withSupplementalCandidate:(id)candidate;
- (void)acceptAutocorrection;
- (void)acceptAutocorrection:(id)autocorrection executionContextPassingTIKeyboardCandidate:(id)candidate;
- (void)acceptAutocorrectionAndEndComposition;
- (void)acceptAutocorrectionForWordTerminator:(id)terminator executionContextPassingTIKeyboardCandidate:(id)candidate;
- (void)acceptAutocorrectionWithCompletionHandler:(id)handler requestedByRemoteInputDestination:(BOOL)destination;
- (void)acceptCandidate:(id)candidate forInput:(id)input;
- (void)acceptCandidate:(id)candidate forInput:(id)input executionContext:(id)context;
- (void)acceptCurrentCandidateIfSelected;
- (void)acceptCurrentCandidateIfSelectedWithExecutionContext:(id)context;
- (void)acceptFirstCandidate;
- (void)acceptHandwritingCandidate;
- (void)acceptInlineCompletionWithCompletionHandler:(id)handler;
- (void)acceptPredictiveInput:(id)input appendSeparator:(BOOL)separator;
- (void)acceptPredictiveInput:(id)input appendSeparator:(BOOL)separator executionContext:(id)context;
- (void)acceptRecentInput:(id)input;
- (void)acceptingCandidateWithTrigger:(id)trigger;
- (void)addInputEvent:(id)event executionContext:(id)context;
- (void)addInputObject:(id)object;
- (void)addInputObject:(id)object executionContext:(id)context;
- (void)addInputString:(id)string fromVariantKey:(BOOL)key;
- (void)addInputString:(id)string withFlags:(unint64_t)flags;
- (void)addInputString:(id)string withFlags:(unint64_t)flags withInputManagerHint:(id)hint;
- (void)addInputString:(id)string withFlags:(unint64_t)flags withInputManagerHint:(id)hint withInputSource:(int64_t)source executionContext:(id)context;
- (void)addSupplementalLexicon:(id)lexicon;
- (void)addWordTerminator:(id)terminator afterSpace:(BOOL)space afterAcceptingCandidate:(id)candidate elapsedTime:(double)time executionContext:(id)context;
- (void)adjustAutoDeleteTimerForForce:(double)force;
- (void)adjustCapsLockDelayOverride;
- (void)adjustPhraseBoundaryInForwardDirection:(BOOL)direction granularity:(int)granularity executionContext:(id)context;
- (void)adjustSegmentSize:(int64_t)size;
- (void)animateAutocorrectionToRect:(CGRect)rect fromRect:(CGRect)fromRect;
- (void)animateAutocorrectionToText:(id)text fromRect:(CGRect)rect;
- (void)applyAssistantItem:(id)item;
- (void)becomeFirstResponderAndMakeVisible:(BOOL)visible;
- (void)beginAcceptingInlineCompletionByDirectTap;
- (void)callChangedDelegate;
- (void)callLayoutLongPressAction;
- (void)callLayoutSetAutoshift:(BOOL)autoshift;
- (void)callLayoutSetShift:(BOOL)shift;
- (void)callLayoutUpdateAllLocalizedKeys;
- (void)callLayoutUpdateLocalizedKeys;
- (void)cancelCandidateRequests;
- (void)cancelDictationOnSendReturnKeyPressed;
- (void)candidateBarDidExtendWithGesture;
- (void)candidateListAcceptCandidate:(id)candidate;
- (void)candidateListSelectionDidChange:(id)change;
- (void)changingContextWithTrigger:(id)trigger;
- (void)cleanUpBeforeInputModeSwitch;
- (void)clearAutoDeleteTimer;
- (void)clearAutocorrectPromptTimer;
- (void)clearAutofillGroup;
- (void)clearCapsLockDelayOverrideTimer;
- (void)clearDelayDeleteTimer;
- (void)clearDelegate;
- (void)clearForwardingInputDelegateAndResign:(BOOL)resign;
- (void)clearIdleDetectionAction;
- (void)clearInput;
- (void)clearInputForMarkedText;
- (void)clearInputWithCandidatesCleared:(BOOL)cleared;
- (void)clearKeyboardWindowSnapshot;
- (void)clearLongPressTimer;
- (void)clearRemoteTextInputPartner;
- (void)clearSelection;
- (void)clearShiftState;
- (void)clearTimers;
- (void)clearTransientState;
- (void)clearUpdateLastUsedInputModeAction;
- (void)collapseSelection;
- (void)completeAcceptCandidate:(id)candidate;
- (void)completeAcceptCandidateBeforeAddingInputObject:(id)object executionContext:(id)context;
- (void)completeAddInputString:(id)string generateCandidates:(BOOL)candidates;
- (void)completeDelete;
- (void)completeDeleteFromInput;
- (void)completeDeleteOnceFromInputWithCharacterBefore:(unsigned int)before;
- (void)completeHandleAutoDelete;
- (void)completeHandleKeyEvent:(id)event;
- (void)completeUpdateForChangedSelection:(BOOL)selection;
- (void)conversationContext:(id)context didChange:(id)change;
- (void)createTypoTrackerReport;
- (void)deactivateLayout;
- (void)dealloc;
- (void)deferReplaceTextActionToSystem:(id)system;
- (void)deleteBackwardAndNotifyAtEnd:(BOOL)end deletionCount:(unint64_t)count reinsertTextInLoop:(BOOL)loop;
- (void)deleteFromInputWithFlags:(unint64_t)flags;
- (void)deleteFromInputWithFlags:(unint64_t)flags executionContext:(id)context;
- (void)deleteHandwritingStrokesAtIndexes:(id)indexes;
- (void)deleteOnceFromInputWithExecutionContext:(id)context;
- (void)detach;
- (void)didAcceptAutocorrection:(id)autocorrection inputCandidate:(id)candidate wordTerminator:(id)terminator learningFlagsMask:(unint64_t)mask;
- (void)didApplyAutocorrection:(id)autocorrection autocorrectPromptFrame:(CGRect)frame;
- (void)didChangeForwardingInputDelegate:(id)delegate;
- (void)didChangePhraseBoundary;
- (void)didClearText;
- (void)didSetDelegate;
- (void)disableTransientSelectionMode;
- (void)dismissAutoFillMenu;
- (void)dismissKeyboard;
- (void)dismissTextChoicePrompt;
- (void)displayAutoFillPopoverIfAutoFillModeDetected;
- (void)documentStateFromInputDelegate:(id)delegate;
- (void)ejectKeyDown;
- (void)emojiSearchWillInsertEmoji:(id)emoji forSearchQuery:(id)query;
- (void)emojiSearchWillInsertEmoji:(id)emoji forSearchQuery:(id)query selectionMethod:(id)method inputType:(id)type;
- (void)enableTransientInputDelegateSelectionMode;
- (void)enableTransientSelectionMode;
- (void)endAcceptingInlineCompletionByDirectTap;
- (void)fadeAutocorrectPrompt;
- (void)finishSetExtensionInputMode:(id)mode didChangeDirection:(BOOL)direction;
- (void)finishSetInputMode:(id)mode didChangeDirection:(BOOL)direction;
- (void)finishSetInputModeToNextInPreferredListWithExecutionContext:(id)context withPreviousInputMode:(id)mode;
- (void)finishSetKeyboardInputMode:(id)mode previousInputMode:(id)inputMode didChangeDirection:(BOOL)direction;
- (void)finishTextChanged;
- (void)flushDelayedTasks;
- (void)flushKeyboardOutputOnInputSourceSession;
- (void)flushTouchEventWaitingForKeyInputEventIfNecessary;
- (void)forceShiftUpdateIfKeyboardStateChanged;
- (void)forwardDictationEvent_cancelDictation;
- (void)forwardDictationEvent_handleDictationShouldPause:(BOOL)pause withNewDelagate:(BOOL)delagate;
- (void)forwardDictationEvent_handleTip:(id)tip title:(id)title;
- (void)forwardDictationEvent_movePopoverView:(id)view;
- (void)forwardDictationEvent_resumeDictation;
- (void)forwardDictationEvent_startDictation;
- (void)forwardDictationEvent_stopDictation:(BOOL)dictation;
- (void)forwardDictationEvent_stopDictationIgnoreFinalizePhrases;
- (void)forwardDictationEvent_switchToDictationInputModeWithOptions:(id)options;
- (void)forwardDictationEvent_switchToDictationLanguage:(id)language;
- (void)forwardDictationEvent_updateIdleDetection:(int64_t)detection;
- (void)forwardKeyboardCameraEvent_selfDestruct;
- (void)forwardKeyboardCameraEvent_startCameraInput:(id)input;
- (void)forwardKeyboardCameraEvent_updatePreviewText:(id)text asMarkedText:(BOOL)markedText;
- (void)forwardKeyboardEventBackToDestination:(id)destination;
- (void)generateAutocorrectionWithExecutionContext:(id)context;
- (void)generateAutocorrectionsWithCompletionHandler:(id)handler;
- (void)generateAutofillCandidateByAddingTask:(BOOL)task;
- (void)generateCandidatesAsynchronously;
- (void)generateCandidatesAsynchronouslyWithRange:(_NSRange)range selectedCandidate:(id)candidate;
- (void)generateCandidatesFromReplacements;
- (void)generateCandidatesWithOptions:(int)options;
- (void)generateReplacementsForString:(id)string candidatesHandler:(id)handler executionContext:(id)context;
- (void)handleAcceptedCandidate:(id)candidate executionContext:(id)context;
- (void)handleAutoDeleteContinuationOnDestinationWithDeletionCount:(unint64_t)count;
- (void)handleAutoDeleteWithExecutionContext:(id)context;
- (void)handleAutoFillContactDetected;
- (void)handleAutoFillContactPopoverCommand;
- (void)handleAutoFillCreditCardDetected;
- (void)handleAutoFillCreditCardPopoverCommand;
- (void)handleAutoFillPasswordDetected;
- (void)handleAutoFillPasswordPopoverCommand;
- (void)handleAutofillCredentialSaveIfNeeded:(id)needed;
- (void)handleClear;
- (void)handleClearWithExecutionContext:(id)context;
- (void)handleClearWithInsertBeforeAdvance:(id)advance;
- (void)handleDelayedActionLongPress:(id)press;
- (void)handleDelete;
- (void)handleDeleteAsRepeat:(BOOL)repeat executionContext:(id)context;
- (void)handleDeleteWithExecutionContext:(id)context;
- (void)handleDeleteWordWithExecutionContext:(id)context;
- (void)handleDeletionForCandidate:(id)candidate;
- (void)handleEmojiInput:(id)input keyboardState:(id)state;
- (void)handleEmojiPopoverKeyCommand;
- (void)handleEventCallbackFromRemoteDestination_didChooseSupplementalItem:(id)item toReplaceText:(id)text;
- (void)handleEventFromRemoteDestination_canSuggestSupplementalItemsForCurrentSelection:(BOOL)selection;
- (void)handleEventFromRemoteSource_autoFillIsMenuPresented:(BOOL)presented;
- (void)handleEventFromRemoteSource_autoFillIsModalUIPresented:(BOOL)presented;
- (void)handleEventFromRemoteSource_chooseSupplementalItem:(id)item toReplaceText:(id)text;
- (void)handleEventFromRemoteSource_insertAutofillContent:(id)content;
- (void)handleEventFromRemoteSource_insertSupplementalCandidate:(id)candidate textToCommit:(id)commit;
- (void)handleEventFromRemoteSource_insertionPointEnteredText:(id)text withSupplementalCandidate:(id)candidate;
- (void)handleGrammarCorrectionEntries:(id)entries;
- (void)handleIdleDetectionAction;
- (void)handleInsertSmartCandidate:(id)candidate;
- (void)handleKeyEvent:(id)event;
- (void)handleKeyEvent:(id)event executionContext:(id)context;
- (void)handleKeyWithString:(id)string forKeyEvent:(id)event executionContext:(id)context;
- (void)handleKeyboardInput:(id)input executionContext:(id)context;
- (void)handleModifiersChangeForKeyEvent:(id)event executionContext:(id)context;
- (void)handleRemoteDictationEvent_cancelDictation;
- (void)handleRemoteDictationEvent_handleTip:(id)tip;
- (void)handleRemoteDictationEvent_movePopoverView:(id)view;
- (void)handleRemoteDictationEvent_resumeDictation;
- (void)handleRemoteDictationEvent_setDisambiguationActive:(BOOL)active maxOptions:(unint64_t)options;
- (void)handleRemoteDictationEvent_setEditMenuFrame:(id)frame;
- (void)handleRemoteDictationEvent_startDictation;
- (void)handleRemoteDictationEvent_stopDictation:(BOOL)dictation;
- (void)handleRemoteDictationEvent_stopDictationIgnoreFinalizePhrases;
- (void)handleRemoteDictationEvent_switchToDictationInputModeWithOptions:(id)options;
- (void)handleRemoteDictationEvent_switchToDictationLanguage:(id)language;
- (void)handleRemoteDictationEvent_updateIdleDetection:(int64_t)detection;
- (void)handleRemoteIndirectGestureWithState:(id)state;
- (void)handleRemoteKeyboardCameraEvent_startCameraInput:(id)input;
- (void)handleStringInput:(id)input withFlags:(unint64_t)flags withInputManagerHint:(id)hint executionContext:(id)context;
- (void)handleUpdateLastUsedInputModeAction:(id)action;
- (void)handleWebViewCredentialsSaveForWebsiteURL:(id)l user:(id)user password:(id)password passwordIsAutoGenerated:(BOOL)generated;
- (void)hostApplicationDidEnterBackground;
- (void)hostApplicationWillEnterForeground;
- (void)inputManagerDidGenerateAutocorrections:(id)autocorrections forPredictiveInput:(id)input executionContext:(id)context;
- (void)inputManagerDidGenerateCandidateResultSet:(id)set;
- (void)insertAdaptiveImageGlyph:(id)glyph;
- (void)insertAttributedText:(id)text;
- (void)insertCustomTextSuggestion:(id)suggestion;
- (void)insertDictationResult:(id)result;
- (void)insertEmojiImageTextAttachment:(id)attachment;
- (void)insertSticker:(id)sticker;
- (void)insertText:(id)text withAlternativePredictions:(id)predictions;
- (void)insertTextSuggestionCandidate:(id)candidate;
- (void)insertedAccentVariantFromPopover:(id)popover;
- (void)insertedEmojiFromPopover:(id)popover selectionMethod:(id)method;
- (void)invalidateTextEntryContextForTextInput:(id)input;
- (void)keyboardInputModeIndicatorControllerDismissIndicator:(id)indicator;
- (void)keyboardInputModeIndicatorControllerPresentIndicator:(id)indicator reason:(id)reason;
- (void)keyboardSceneDelegate:(id)delegate startedPinningInputViewsOnBehalfOfResponder:(id)responder;
- (void)keyboardSceneDelegate:(id)delegate stoppedPinningInputViewsOnBehalfOfResponder:(id)responder;
- (void)layoutDidResize;
- (void)longPressAction:(id)action;
- (void)lookUpResponderChainForCustomInputView;
- (void)modifyTextInputTraits:(id)traits forceSync:(BOOL)sync;
- (void)moveCursorByAmount:(int64_t)amount;
- (void)movePhraseBoundaryToDirection:(int64_t)direction granularity:(int64_t)granularity;
- (void)nonDestructivelyDismissKeyboard;
- (void)notifyInputSourceStateChangeIfNeeded;
- (void)notifyShiftState;
- (void)optOutASPInTextField;
- (void)performAutoDeleteNumberOfTimes:(unint64_t)times deleteOneWord:(BOOL)word forwardToInputSource:(BOOL)source deleteCount:(int64_t *)count;
- (void)performBlockWithTextInputChangesIgnoredForNonMacOS:(id)s;
- (void)performDelete;
- (void)performHitTestForTouchEvent:(id)event executionContextPassingNSNumber:(id)number;
- (void)performHitTestForTouchEvents:(id)events executionContextPassingNSNumber:(id)number;
- (void)performKeyBehaviorCommitInlineWithSpace:(BOOL)space;
- (void)performKeyBehaviorConfirm;
- (void)performKeyBehaviorConfirmFirstCandidate;
- (void)performKeyboardActionButtonAction;
- (void)performKeyboardOutput:(id)output;
- (void)performKeyboardOutput:(id)output forwardToRemoteInputSource:(BOOL)source;
- (void)performKeyboardOutputAsInputViewControllerOutput:(id)output textInputSource:(int64_t)source;
- (void)performKeyboardOutputAsRTIClient:(id)client;
- (void)performKeyboardOutputInfo:(id)info;
- (void)performKeyboardOutputOnInputSourceSession:(id)session shouldFlush:(BOOL)flush;
- (void)performOnInputSourceSessionActionSelector:(SEL)selector;
- (void)performOperations:(id)operations withTextInputSource:(int64_t)source;
- (void)performReturn;
- (void)performSendCurrentLocation;
- (void)performStopAutoDeleteAtDocumentStart;
- (void)performTextOperationActionSelector:(SEL)selector;
- (void)populateDictationAlternativesCandidates:(BOOL)candidates withDictationAlternatives:(id)alternatives;
- (void)populateEuclidCandidates:(BOOL)candidates;
- (void)postInputResponderCapabilitiesChangedNotification;
- (void)postInputViewControllerShouldUpdateNotification:(id)notification;
- (void)prepareForSelectionChange;
- (void)prepareKeyboardInputModeFromPreferences:(id)preferences;
- (void)presentContinuousPathIntroductionView;
- (void)presentEmojiGenerationWithInputString:(id)string;
- (void)presentKeyboardFeedbackAssistantViewControllerForLogURL:(id)l;
- (void)presentTextChoicePromptForRange:(id)range;
- (void)presentationDelegateWillDetach;
- (void)proceedShouldReturnIfNeededForASP;
- (void)processPayloadInfo:(id)info;
- (void)pushAutocorrections:(id)autocorrections requestToken:(id)token;
- (void)pushCandidateResultSet:(id)set requestToken:(id)token;
- (void)queueDelayedTask:(id)task;
- (void)recomputeActiveInputModesWithExtensions:(BOOL)extensions;
- (void)recomputeActiveInputModesWithExtensions:(BOOL)extensions allowNonLinguisticInputModes:(BOOL)modes;
- (void)refreshAutofillModeIfNecessary;
- (void)refreshKeyboardStateUpdatingSecureCandidateRenderTraits:(BOOL)traits;
- (void)refreshSecureCandidatesIfNecessary;
- (void)reinitializeAfterInputModeSwitch:(BOOL)switch;
- (void)rejectAutocorrection:(id)autocorrection;
- (void)rejectAutocorrectionForPromptFade;
- (void)releaseInputManager;
- (void)releaseInputManagerIfInactive;
- (void)reloadCurrentInputMode;
- (void)removeASPVisualEffectsIfNecessary:(id)necessary;
- (void)removeAllDynamicDictionaries;
- (void)removeAutocorrectPrompt;
- (void)removeAutocorrectPromptAndCandidateList;
- (void)removeAutocorrection;
- (void)removeCandidateList;
- (void)removeInlineTextCompletionPrompt;
- (void)removeRecentInput:(id)input completionHandler:(id)handler;
- (void)removeSpaceAfterEmojiForInputString:(id)string;
- (void)removeSupplementalLexicon:(id)lexicon;
- (void)removeTextChoicePrompt;
- (void)removeTextChoicePromptAndAutocorrection;
- (void)removeTextChoicePromptWithUnderline;
- (void)removeTextChoiceUnderlines;
- (void)removeTextChoiceUnderlinesInRange:(id)range;
- (void)removeTextCompletionFromMarkedText:(id)text;
- (void)replaceAllTextInResponder:(id)responder withText:(id)text;
- (void)replaceText:(id)text;
- (void)resetInputDelegate;
- (void)responseContextDidChange;
- (void)restoreTextSuggestions;
- (void)resumeDictationForResponderChange;
- (void)scheduleReplacementsAfterDeletionToEndOfWord;
- (void)scheduleReplacementsWithOptions:(unint64_t)options;
- (void)selectionDidChange:(id)change;
- (void)selectionWillChange:(id)change;
- (void)sendCallbacksForPostCorrectionsRemoval;
- (void)sendCallbacksForPreCorrectionsDisplay;
- (void)setAutocorrectSpellingEnabled:(BOOL)enabled;
- (void)setAutocorrection:(id)autocorrection;
- (void)setAutocorrectionList:(id)list;
- (void)setAutomaticMinimizationEnabled:(BOOL)enabled;
- (void)setCandidateDisplayIsExtended:(BOOL)extended;
- (void)setCandidateList:(id)list;
- (void)setCandidates:(id)candidates;
- (void)setCapsLockIfNeeded;
- (void)setCaretVisible:(BOOL)visible;
- (void)setChangedDelegate;
- (void)setCorrectionLearningAllowed:(BOOL)allowed;
- (void)setCurrentCandidateRequest:(id)request;
- (void)setDefaultTextInputTraits:(id)traits;
- (void)setDelegate:(id)delegate;
- (void)setDelegate:(id)delegate force:(BOOL)force delayEndInputSession:(BOOL)session;
- (void)setDidTeardownExistingDelegate:(id)delegate;
- (void)setDocumentState:(id)state;
- (void)setDocumentStateForAutocorrection:(id)autocorrection;
- (void)setHardwareKeyboardsSeenPreference:(id)preference;
- (void)setInHardwareKeyboardMode:(BOOL)mode forceRebuild:(BOOL)rebuild shouldMoveKeyboard:(BOOL)keyboard;
- (void)setInitialDirectionIgnoreRangeCheck:(BOOL)check;
- (void)setInlineCompletionAsMarkedText:(id)text selectedRange:(_NSRange)range inputString:(id)string searchString:(id)searchString;
- (void)setInputManagerFromCurrentInputMode;
- (void)setInputManagerState:(id)state;
- (void)setInputMode:(id)mode userInitiated:(BOOL)initiated;
- (void)setInputMode:(id)mode userInitiated:(BOOL)initiated updateIndicator:(BOOL)indicator executionContext:(id)context;
- (void)setInputModeFromPreferences;
- (void)setInputModeSwitcherVisibleInRemote:(BOOL)remote;
- (void)setInputModeToNextASCIICapableInPreferredList;
- (void)setInputModeToNextInPreferredListWithExecutionContext:(id)context;
- (void)setKeyboardInputMode:(id)mode userInitiated:(BOOL)initiated updateIndicator:(BOOL)indicator executionContext:(id)context;
- (void)setKeyboardInputModeFromPreferences:(id)preferences;
- (void)setKeyboardMinimizedByDictation:(BOOL)dictation;
- (void)setLayoutRenderConfig:(id)config;
- (void)setOverrideTextInputTraits:(id)traits;
- (void)setPendingAutofillIndex:(int64_t)index;
- (void)setPreviousGlobeKeyEvent:(id)event;
- (void)setPreviousInputString:(id)string;
- (void)setRemoteDelegateSupportsAdaptiveImageGlyph:(BOOL)glyph;
- (void)setRemoteDelegateSupportsImagePaste:(BOOL)paste;
- (void)setRestoresToEmojiInputMode;
- (void)setReturnKeyEnabled:(BOOL)enabled;
- (void)setSelectionWithPoint:(CGPoint)point;
- (void)setShift:(BOOL)shift autoshift:(BOOL)autoshift;
- (void)setShiftLocked:(BOOL)locked;
- (void)setShiftLockedForced:(BOOL)forced;
- (void)setShiftNeedsUpdate;
- (void)setShiftOffIfNeeded;
- (void)setShiftStatesNeededInDestination:(BOOL)destination autoShifted:(BOOL)shifted shiftLocked:(BOOL)locked;
- (void)setShouldSkipCandidateSelection:(BOOL)selection userInitiated:(BOOL)initiated;
- (void)setShowsCandidateBar:(BOOL)bar;
- (void)setSuggestions:(id)suggestions;
- (void)setTwoFingerTapTimestamp:(double)timestamp;
- (void)setUsesCandidateSelection:(BOOL)selection;
- (void)setWillSetupNewDelegate:(id)delegate;
- (void)showCursorAccessory;
- (void)showFirstTextAlternativeWithRangeAdjustment:(int64_t)adjustment;
- (void)showSelectionCommands;
- (void)skipHitTestForTouchEvent:(id)event;
- (void)skipHitTestForTouchEvent:(id)event delayed:(BOOL)delayed;
- (void)skipHitTestForTouchEvents:(id)events;
- (void)smartSelectionForTextInDocument:(id)document inRange:(_NSRange)range options:(unint64_t)options completion:(id)completion;
- (void)startAutoDeleteTimer;
- (void)startAutoDeleteTimerForForce:(double)force;
- (void)startSmartReplyWritingToolWithParams:(id)params;
- (void)stopAutoDelete;
- (void)syncDocumentStateToInputDelegate;
- (void)syncDocumentStateToInputDelegateWithExecutionContext:(id)context;
- (void)syncInputManagerToAcceptedAutocorrection:(id)autocorrection forInput:(id)input;
- (void)syncInputManagerToKeyboardState;
- (void)syncInputManagerToKeyboardStateWithExecutionContext:(id)context;
- (void)syncKeyboardToConfiguration:(id)configuration;
- (void)takeTextInputTraitsFromDelegate;
- (void)textAccepted:(id)accepted;
- (void)textAccepted:(id)accepted executionContext:(id)context;
- (void)textAttributesDidChange:(id)change inRange:(id)range;
- (void)textChanged:(id)changed;
- (void)textChanged:(id)changed executionContext:(id)context;
- (void)textDidChange:(id)change inRange:(id)range;
- (void)textDidScroll;
- (void)textInput:(id)input setCandidateSuggestions:(id)suggestions;
- (void)textLayoutDidChange:(id)change inRange:(id)range;
- (void)textSuggestionDidChange:(id)change;
- (void)textWillChange:(id)change inRange:(id)range;
- (void)textWillScroll;
- (void)toggleSoftwareKeyboard;
- (void)touchAutoDeleteTimerWithThreshold:(double)threshold adjustForPartialCompletion:(BOOL)completion;
- (void)touchAutocorrectPromptTimer;
- (void)touchDelayDeleteTimerWithThreshold:(double)threshold;
- (void)touchLongPressTimerWithDelay:(double)delay userInfo:(id)info;
- (void)touchUpdateLastUsedInputModeAction;
- (void)trackUsageForAcceptedAutocorrection:(id)autocorrection promptWasShowing:(BOOL)showing;
- (void)trackUsageForCandidateAcceptedAction:(id)action;
- (void)trackUsageForPromptedCorrection:(id)correction inputString:(id)string previousPrompt:(id)prompt;
- (void)traitCollectionDidChange;
- (void)triggerPendingKeyup;
- (void)underlineCandidate:(id)candidate;
- (void)undoWithKeyboardInput:(id)input;
- (void)unmarkText:(id)text;
- (void)updateAssistantView;
- (void)updateAssistantViewInfo:(id)info;
- (void)updateAutocorrectPrompt:(id)prompt;
- (void)updateAutocorrectPrompt:(id)prompt executionContext:(id)context;
- (void)updateCandidateDisplay;
- (void)updateCandidateDisplayAsyncWithCandidateSet:(id)set;
- (void)updateDefaultsWithResults:(id)results;
- (void)updateDelegatePasteSupport;
- (void)updateDelegatePasteSupportIfNeeded;
- (void)updateDocumentViewsAfterKeyboardOutput:(id)output;
- (void)updateDoubleSpacePeriodStateForCharacter:(unsigned int)character;
- (void)updateDoubleSpacePeriodStateForString:(id)string;
- (void)updateForChangedSelection;
- (void)updateForChangedSelectionWithExecutionContext:(id)context;
- (void)updateForExpectedRemoteDocumentStateChange:(id)change selectedTextRange:(_NSRange)range forceSync:(BOOL)sync;
- (void)updateFromTextInputTraits;
- (void)updateHardwareKeyboardExclusivityIdentifier;
- (void)updateHardwareKeyboardLayout:(BOOL)layout;
- (void)updateIdleDetection:(int64_t)detection;
- (void)updateInputAssistantButtonItems;
- (void)updateInputDelegateForRemoteDocumentStateChange:(id)change selectedTextRange:(_NSRange)range hasText:(BOOL)text forceSync:(BOOL)sync;
- (void)updateInputDelegateForRemoteTraitChange:(id)change forceSync:(BOOL)sync;
- (void)updateInputManagerAutocapitalizationType;
- (void)updateInputManagerMode;
- (void)updateInputModeIndicatorOnSingleKeyOnly:(BOOL)only preserveIfPossible:(BOOL)possible;
- (void)updateInputModeLastChosenPreference;
- (void)updateKeyboardConfigurations;
- (void)updateKeyboardEventsLagging:(id)lagging;
- (void)updateKeyboardOutput:(id)output withInputForSmartPunctuation:(id)punctuation keyboardConfiguration:(id)configuration;
- (void)updateKeyboardStateForDeletion;
- (void)updateKeyboardStateForInsertion:(id)insertion;
- (void)updateKeyboardStateForReplacingText:(id)text withText:(id)withText;
- (void)updateLayoutAndSetShift;
- (void)updateNoContentViews;
- (void)updatePreferencesWithBlock:(id)block;
- (void)updateReturnKey:(BOOL)key;
- (void)updateShiftState;
- (void)updateShiftStateAfterAsyncSelectionChange;
- (void)updateShowCandidateBar;
- (void)updateSmartPunctuationOptionsForLocaleIdentifier:(id)identifier;
- (void)updateTextCandidateView;
- (void)updateTextChoicePromptSelection:(id)selection toRange:(id)range;
- (void)updateTextInputKeyboardSource;
- (void)updateTextInputKeyboardSource:(id)source;
- (void)willReplaceTextInRangedSelectionWithKeyboardInput;
- (void)writingToolsDidEnd;
@end

@implementation _UIKeyboardStateManager

- (BOOL)isInHardwareKeyboardMode
{
  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  rtiInputSourceState = [remoteTextInputPartner rtiInputSourceState];

  if (rtiInputSourceState)
  {
    remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    rtiInputSourceState2 = [remoteTextInputPartner2 rtiInputSourceState];
    hardwareKeyboardMode = [rtiInputSourceState2 hardwareKeyboardMode];

    return hardwareKeyboardMode;
  }

  else
  {
    m_keyboardState = self->m_keyboardState;

    return [(TIKeyboardState *)m_keyboardState hardwareKeyboardMode];
  }
}

- (void)takeTextInputTraitsFromDelegate
{
  v57 = *MEMORY[0x1E69E9840];
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  textInputTraits = [inputDelegateManager textInputTraits];

  if (!textInputTraits)
  {
    v5 = self->m_defaultTraits;
    if (!v5)
    {
      v5 = objc_alloc_init(UITextInputTraits);
    }

    textInputTraits = v5;
  }

  if (self->m_overrideTraits)
  {
    [textInputTraits overrideWithTraits:?];
  }

  else if (+[UIKeyboard isKeyboardProcess])
  {
    [textInputTraits overrideWithPrivateTraits:self->m_traits];
  }

  v6 = +[UIKeyboard activeKeyboard];
  if ([v6 isAutomatic])
  {
    isSecureTextEntry = [textInputTraits isSecureTextEntry];
    if (isSecureTextEntry != [(UITextInputTraits *)self->m_traits isSecureTextEntry])
    {
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      _rootInputWindowController = [WeakRetained _rootInputWindowController];
      [_rootInputWindowController setDisableUpdateMaskForSecureTextEntry:{objc_msgSend(textInputTraits, "isSecureTextEntry")}];
    }
  }

  else
  {
    v10 = +[UIKeyboardPreferencesController sharedPreferencesController];
    preferencesActions = [v10 preferencesActions];
    v12 = [preferencesActions BOOLForPreferenceKey:@"ShowPasswordKeyboardInVideo"];

    if ((v12 & 1) == 0)
    {
      [v6 _setDisableUpdateMaskForSecureTextEntry:{objc_msgSend(textInputTraits, "isSecureTextEntry")}];
    }
  }

  keyboardType = [textInputTraits keyboardType];
  showingEmojiSearch = [(_UIKeyboardStateManager *)self showingEmojiSearch];
  v54 = keyboardType != 122;
  v15 = [textInputTraits copy];
  m_traits = self->m_traits;
  self->m_traits = v15;

  if (!self->m_correctionLearningAllowed)
  {
    [(UITextInputTraits *)self->m_traits setLearnsCorrections:0];
  }

  if ([(_UIKeyboardStateManager *)self shouldUseCarPlayModes])
  {
    [(UITextInputTraits *)self->m_traits setIsCarPlayIdiom:1];
  }

  if (!+[UIKeyboard isKeyboardProcess]&& ![(UITextInputTraits *)self->m_traits inlinePredictionType])
  {
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager2 keyInputDelegate];
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();

    inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    hasAsyncCapableInputDelegate = [inputDelegateManager3 hasAsyncCapableInputDelegate];

    if ((isKindOfClass & 1) == 0 && (hasAsyncCapableInputDelegate & 1) == 0)
    {
      [(UITextInputTraits *)self->m_traits setInlinePredictionType:1];
    }
  }

  inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate2 = [inputDelegateManager4 keyInputDelegate];

  if (keyInputDelegate2)
  {
    floatingForced = [(_UIKeyboardStateManager *)self floatingForced];
    forceFloatingKeyboard = [(UITextInputTraits *)self->m_traits forceFloatingKeyboard];
    [(_UIKeyboardStateManager *)self setFloatingForced:[(UITextInputTraits *)self->m_traits forceFloatingKeyboard]];
    if (floatingForced != forceFloatingKeyboard)
    {
      if (+[UIKeyboard isMajelEnabled])
      {
        v26 = objc_loadWeakRetained(&self->_presentationDelegate);
        isUsingDictationLayout = [v26 isUsingDictationLayout];

        if ((isUsingDictationLayout & 1) == 0)
        {
          [(_UIKeyboardStateManager *)self recomputeActiveInputModesWithExtensions:[(UITextInputTraits *)self->m_traits isSecureTextEntry]^ 1 allowNonLinguisticInputModes:1];
        }
      }
    }
  }

  v28 = objc_loadWeakRetained(&self->_presentationDelegate);
  [v28 refreshRivenPreferences];

  [(_UIKeyboardStateManager *)self updateInputManagerAutocapitalizationType];
  [(TIKeyboardState *)self->m_keyboardState setWordLearningEnabled:[(UITextInputTraits *)self->m_traits learnsCorrections]];
  textInputTraits2 = [(_UIKeyboardStateManager *)self textInputTraits];
  autocorrectionContext = [textInputTraits2 autocorrectionContext];
  [(TIKeyboardState *)self->m_keyboardState setRecipientIdentifier:autocorrectionContext];

  textInputTraits3 = [(_UIKeyboardStateManager *)self textInputTraits];
  responseContext = [textInputTraits3 responseContext];
  [(TIKeyboardState *)self->m_keyboardState setResponseContext:responseContext];

  inputContextHistory = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];
  textInputTraits4 = [(_UIKeyboardStateManager *)self textInputTraits];
  if ((objc_opt_respondsToSelector() & 1) == 0)
  {
    goto LABEL_34;
  }

  textInputTraits5 = [(_UIKeyboardStateManager *)self textInputTraits];
  conversationContext = [textInputTraits5 conversationContext];
  if (!conversationContext)
  {

LABEL_34:
    goto LABEL_35;
  }

  v37 = conversationContext;
  v38 = _os_feature_enabled_impl();

  if (!v38)
  {
LABEL_35:
    textInputTraits6 = [(_UIKeyboardStateManager *)self textInputTraits];
    inputContextHistory2 = [textInputTraits6 inputContextHistory];
    tiInputContextHistory = [inputContextHistory2 tiInputContextHistory];
    [(TIKeyboardState *)self->m_keyboardState setInputContextHistory:tiInputContextHistory];
    goto LABEL_36;
  }

  if (inputContextHistory)
  {
    goto LABEL_37;
  }

  textInputTraits6 = [(_UIKeyboardStateManager *)self textInputTraits];
  inputContextHistory2 = [textInputTraits6 conversationContext];
  tiInputContextHistory = [inputContextHistory2 inputContextHistoryRepresentation];
  v41TiInputContextHistory = [tiInputContextHistory tiInputContextHistory];
  [(TIKeyboardState *)self->m_keyboardState setInputContextHistory:v41TiInputContextHistory];

LABEL_36:
LABEL_37:
  inputContextHistory3 = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];

  if (inputContextHistory != inputContextHistory3)
  {
    v44 = _UIKeyboardSmartReplyLog();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      inputContextHistory4 = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];
      v46 = [inputContextHistory4 debugDescription];
      *buf = 138477827;
      v56 = v46;
      _os_log_impl(&dword_188A29000, v44, OS_LOG_TYPE_DEFAULT, "Setting state to found ICH: %{private}@", buf, 0xCu);
    }
  }

  inputContextHistory5 = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];

  if (inputContextHistory5)
  {
    smartReplyGenerator = [(_UIKeyboardStateManager *)self smartReplyGenerator];
    [smartReplyGenerator syncToKeyboardState:self->m_keyboardState];
  }

  v49 = v54 ^ showingEmojiSearch;
  if (!+[UIKeyboard isKeyboardProcess])
  {
    supplementalLexicon = [(UITextInputTraits *)self->m_traits supplementalLexicon];
    if (supplementalLexicon)
    {
      supplementalLexicon2 = [(UITextInputTraits *)self->m_traits supplementalLexicon];
      -[TIKeyboardState setSupplementalLexiconIdentifier:](self->m_keyboardState, "setSupplementalLexiconIdentifier:", [supplementalLexicon2[1] identifier]);
    }

    else
    {
      [(TIKeyboardState *)self->m_keyboardState setSupplementalLexiconIdentifier:0];
    }
  }

  if ((v49 & 1) == 0)
  {
    [(_UIKeyboardStateManager *)self notifyInputSourceStateChangeIfNeeded];
  }

  if (self->_remoteTextInputTraits)
  {
    inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    forwardingInputDelegate = [inputDelegateManager5 forwardingInputDelegate];

    if (!forwardingInputDelegate)
    {
      [(_UIKeyboardStateManager *)self updateInputDelegateForRemoteTraitChange:self->_remoteTextInputTraits forceSync:0];
    }
  }
}

- (void)updateInputManagerMode
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = +[UIKeyboardInputModeController sharedInputModeController];
  currentSystemInputMode = [v3 currentSystemInputMode];

  inputMode = [(TIKeyboardState *)self->m_keyboardState inputMode];
  v6 = [(_UIKeyboardStateManager *)self shouldSwitchFromInputManagerMode:inputMode toInputMode:currentSystemInputMode];

  if (v6)
  {
    identifierWithLayouts = [currentSystemInputMode identifierWithLayouts];
    [(TIKeyboardState *)self->m_keyboardState setInputMode:identifierWithLayouts];

    identifier = [currentSystemInputMode identifier];
    v9 = [identifier isEqualToString:@"intl_HWR"];

    if (v9)
    {
      array = [MEMORY[0x1E695DF70] array];
      v18 = 0u;
      v19 = 0u;
      v20 = 0u;
      v21 = 0u;
      v11 = +[UIKeyboardInputModeController sharedInputModeController];
      suggestedInputModesForPreferredLanguages = [v11 suggestedInputModesForPreferredLanguages];

      v13 = [suggestedInputModesForPreferredLanguages countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (v13)
      {
        v14 = v13;
        v15 = *v19;
        do
        {
          v16 = 0;
          do
          {
            if (*v19 != v15)
            {
              objc_enumerationMutation(suggestedInputModesForPreferredLanguages);
            }

            identifier2 = [*(*(&v18 + 1) + 8 * v16) identifier];
            [array addObject:identifier2];

            ++v16;
          }

          while (v14 != v16);
          v14 = [suggestedInputModesForPreferredLanguages countByEnumeratingWithState:&v18 objects:v22 count:16];
        }

        while (v14);
      }
    }

    else
    {
      array = 0;
    }

    [(TIKeyboardState *)self->m_keyboardState setAuxiliaryInputModeLanguages:array];
  }
}

- (BOOL)shouldShowLongPredictionList
{
  longPredictionListEnabled = [(TIKeyboardState *)self->m_keyboardState longPredictionListEnabled];
  if (longPredictionListEnabled)
  {
    LOBYTE(longPredictionListEnabled) = ![(UITextInputTraits *)self->m_traits isSecureTextEntry];
  }

  return longPredictionListEnabled;
}

- (UIKBRTIPartner)remoteTextInputPartner
{
  if (!self->_remoteTextInputPartner)
  {
    v3 = objc_alloc_init(UIKBRTIPartner);
    remoteTextInputPartner = self->_remoteTextInputPartner;
    self->_remoteTextInputPartner = v3;

    [(UIKBRTIPartner *)self->_remoteTextInputPartner setPartnerDelegate:self];
    [(UIKBRTIPartner *)self->_remoteTextInputPartner setInputSystemClientEnabled:[(_UIKeyboardStateManager *)self serviceRole]== 1];
  }

  if (+[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI") && (+[UIKeyboardSceneDelegate activeKeyboardSceneDelegate](UIKeyboardSceneDelegate, "activeKeyboardSceneDelegate"), v5 = objc_claimAutoreleasedReturnValue(), v6 = [v5 automaticAppearanceEnabled], v5, !v6))
  {
    v7 = 0;
  }

  else
  {
    v7 = self->_remoteTextInputPartner;
  }

  return v7;
}

- (BOOL)shouldUseCarPlayModes
{
  if ([UIApp _isSpringBoard])
  {
    return 0;
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  keyboardWindow = [objc_opt_class() keyboardWindow];

  screen = [keyboardWindow screen];
  v7 = [UIKBScreenTraits traitsWithScreen:screen orientation:0];

  v3 = [v7 idiom] == 3;
  return v3;
}

- (void)updateInputManagerAutocapitalizationType
{
  [(TIKeyboardState *)self->m_keyboardState setAutocapitalizationEnabled:self->m_autocapitalizationPreference];
  v3 = [MEMORY[0x1E69D96E0] traitsForUITextInputTraits:self->m_traits];
  [(TIKeyboardState *)self->m_keyboardState setTextInputTraits:v3];
}

- (unint64_t)autocorrectionPreferenceForTraits
{
  autocorrectionPreference = [(_UIKeyboardStateManager *)self autocorrectionPreference];
  self->m_autocorrectionPreference = autocorrectionPreference;

  return [(_UIKeyboardStateManager *)self _updateAutocorrectionPreferenceForTraitsWithCurrentPreference:autocorrectionPreference];
}

- (BOOL)autocorrectionPreference
{
  isInHardwareKeyboardMode = [(_UIKeyboardStateManager *)self isInHardwareKeyboardMode];
  v3 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v3 preferencesActions];
  v5 = preferencesActions;
  v6 = MEMORY[0x1E69D9750];
  if (!isInHardwareKeyboardMode)
  {
    v6 = MEMORY[0x1E69D9808];
  }

  v7 = [preferencesActions BOOLForPreferenceKey:*v6];

  return v7;
}

- (BOOL)checkSpellingPreferenceForTraits
{
  checkSpellingPreference = [(_UIKeyboardStateManager *)self checkSpellingPreference];
  if (checkSpellingPreference)
  {
    spellCheckingType = [(UITextInputTraits *)self->m_traits spellCheckingType];
    if (spellCheckingType == 2)
    {
      LOBYTE(checkSpellingPreference) = 1;
    }

    else if (spellCheckingType)
    {
      LOBYTE(checkSpellingPreference) = 0;
    }

    else
    {
      LOBYTE(checkSpellingPreference) = [(UITextInputTraits *)self->m_traits autocorrectionType]!= 1;
    }
  }

  return checkSpellingPreference;
}

- (BOOL)checkSpellingPreference
{
  v2 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v2 preferencesActions];
  v4 = [preferencesActions BOOLForPreferenceKey:*MEMORY[0x1E69D9830]];

  return v4;
}

- (BOOL)isInlineCompletionEnabled
{
  inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
  v3 = [inlineTextCompletionController currentInlineTextCompletionMode] == 1;

  return v3;
}

- (BOOL)delegateSupportsCorrectionUI
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  textInputView = [inputDelegateManager textInputView];
  v4 = textInputView != 0;

  return v4;
}

- (void)setInputManagerFromCurrentInputMode
{
  [(_UIKeyboardStateManager *)self updateInputManagerMode];
  [(_UIKeyboardImplProxy *)self->m_implProxy setDelegate:self];
  v5 = sharedInputManagerMux();
  if ((_UIApplicationIsKeyboardExtension() & 1) == 0)
  {
    [v5 setResponseDelegate:self];
  }

  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  v4 = +[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", [autofillController delegateNeedsAutofillMode]);

  [v5 setSystemInputManagerFromTextInputTraits:self->m_traits autofillMode:v4 implProxy:self->m_implProxy];
}

- (BOOL)needAutofillLogin
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  v3 = [autofillController delegateNeedsAutofillMode] == 1;

  return v3;
}

- (void)_updateDelegateRequiresKeyEventsFromRemoteTextInput
{
  if (+[UIKeyboard isKeyboardProcess])
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    documentTraits = [inputSystemSourceSession documentTraits];
    self->m_delegateRequiresKeyEvents = ([documentTraits delegateConformanceType] >> 8) & 1;
  }
}

- (void)clearKeyboardWindowSnapshot
{
  m_keyboardWindowSnapshot = self->m_keyboardWindowSnapshot;
  self->m_keyboardWindowSnapshot = 0;
}

- (void)restoreTextSuggestions
{
  if (!+[UIKeyboard isKeyboardProcess]&& self->m_pendingRestoreTextSuggestions)
  {
    textSuggestions = [(_UIKeyboardStateManager *)self textSuggestions];
    [(_UIKeyboardStateManager *)self _setSuggestions:textSuggestions];
  }

  self->m_pendingRestoreTextSuggestions = 0;
}

- (id)textSuggestions
{
  v22 = *MEMORY[0x1E69E9840];
  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  textSuggestionList = [autocorrectionController textSuggestionList];

  if (textSuggestionList && ([textSuggestionList predictions], v4 = objc_claimAutoreleasedReturnValue(), v5 = objc_msgSend(v4, "count"), v4, v5))
  {
    v6 = MEMORY[0x1E695DF70];
    predictions = [textSuggestionList predictions];
    v8 = [v6 arrayWithCapacity:{objc_msgSend(predictions, "count")}];

    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    predictions2 = [textSuggestionList predictions];
    v10 = [predictions2 countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v10)
    {
      v11 = v10;
      v12 = *v18;
      do
      {
        for (i = 0; i != v11; ++i)
        {
          if (*v18 != v12)
          {
            objc_enumerationMutation(predictions2);
          }

          v14 = *(*(&v17 + 1) + 8 * i);
          if (objc_opt_respondsToSelector())
          {
            textSuggestion = [v14 textSuggestion];
            [v8 addObject:textSuggestion];
          }
        }

        v11 = [predictions2 countByEnumeratingWithState:&v17 objects:v21 count:16];
      }

      while (v11);
    }
  }

  else
  {
    v8 = 0;
  }

  return v8;
}

- (BOOL)isRTIClient
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  keyboardScreen = [objc_opt_class() keyboardScreen];
  v5 = objc_loadWeakRetained(&self->_presentationDelegate);
  v6 = +[UIKBScreenTraits traitsWithScreen:orientation:](UIKBScreenTraits, "traitsWithScreen:orientation:", keyboardScreen, [v5 _keyboardOrientation]);

  if ([v6 idiom] == 3)
  {
    inputSystemClientEnabled = 0;
  }

  else
  {
    remoteTextInputPartnerPrivate = [(_UIKeyboardStateManager *)self remoteTextInputPartnerPrivate];
    inputSystemClientEnabled = [remoteTextInputPartnerPrivate inputSystemClientEnabled];
  }

  return inputSystemClientEnabled;
}

- (UIKBRTIPartner)remoteTextInputPartnerPrivate
{
  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  remoteTextInputPartner = remoteTextInputPartner;
  if (!remoteTextInputPartner)
  {
    remoteTextInputPartner = self->_remoteTextInputPartner;
  }

  v5 = remoteTextInputPartner;

  return remoteTextInputPartner;
}

- (BOOL)showingEmojiSearch
{
  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  rtiInputSourceState = [remoteTextInputPartner rtiInputSourceState];

  if (!rtiInputSourceState)
  {
    return [(UITextInputTraits *)self->m_traits keyboardType]== 122;
  }

  remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  rtiInputSourceState2 = [remoteTextInputPartner2 rtiInputSourceState];
  showingEmojiSearch = [rtiInputSourceState2 showingEmojiSearch];

  return showingEmojiSearch;
}

- (BOOL)_hasMarkedText
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  _hasMarkedText = [inputDelegateManager _hasMarkedText];

  return _hasMarkedText;
}

- (void)updateHardwareKeyboardExclusivityIdentifier
{
  v4 = +[UIKeyboardInputModeController sharedInputModeController];
  hardwareKeyboardExclusivityIdentifier = [v4 hardwareKeyboardExclusivityIdentifier];
  [(_UIKeyboardStateManager *)self setHardwareKeyboardExclusivityIdentifier:hardwareKeyboardExclusivityIdentifier];
}

- (UITextInteractionAssistant)textInteractionAssistant
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  textInteractionAssistant = [inputDelegateManager textInteractionAssistant];

  return textInteractionAssistant;
}

- (int)returnKeyType
{
  if ([(UITextInputTraits *)self->m_traits emptyContentReturnKeyType]&& [(_UIKeyboardStateManager *)self noContent])
  {
    m_traits = self->m_traits;

    return [(UITextInputTraits *)m_traits emptyContentReturnKeyType];
  }

  else
  {
    suppressReturnKeyStyling = [(UITextInputTraits *)self->m_traits suppressReturnKeyStyling];
    result = [(UITextInputTraits *)self->m_traits returnKeyType];
    if (suppressReturnKeyStyling)
    {
      return -result;
    }
  }

  return result;
}

- (BOOL)callLayoutIsShiftKeyBeingHeld
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  v5 = objc_opt_respondsToSelector();

  if ((v5 & 1) == 0)
  {
    return 0;
  }

  v6 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout2 = [v6 layout];
  isShiftKeyBeingHeld = [layout2 isShiftKeyBeingHeld];

  return isShiftKeyBeingHeld;
}

- (BOOL)callLayoutIsShiftKeyPlaneChooser
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];

  if (!layout)
  {
    return 1;
  }

  v5 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout2 = [v5 layout];
  v7 = objc_opt_respondsToSelector();

  if ((v7 & 1) == 0)
  {
    return 0;
  }

  v8 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout3 = [v8 layout];
  isShiftKeyPlaneChooser = [layout3 isShiftKeyPlaneChooser];

  return isShiftKeyPlaneChooser;
}

- (id)_keyboardBehaviorState
{
  v3 = objc_alloc_init(MEMORY[0x1E69D95C0]);
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  if ([inputManagerState usesCandidateSelection])
  {
    [v3 setHasInput:{-[_UIKeyboardStateManager _hasMarkedText](self, "_hasMarkedText")}];
  }

  else
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    if ([autocorrectionController hasAutocorrection])
    {
      autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
      autocorrection = [autocorrectionController2 autocorrection];
      [v3 setHasInput:autocorrection != 0];
    }

    else
    {
      [v3 setHasInput:1];
    }
  }

  autocorrectionController3 = [(_UIKeyboardStateManager *)self autocorrectionController];
  if ([autocorrectionController3 hasAutocorrection])
  {
    autocorrectionController4 = [(_UIKeyboardStateManager *)self autocorrectionController];
    autocorrection2 = [autocorrectionController4 autocorrection];
  }

  else
  {
    autocorrection2 = 0;
  }

  candidate = [autocorrection2 candidate];
  if ([candidate length])
  {
    input = [autocorrection2 input];
    candidate2 = [autocorrection2 candidate];
    [v3 setHasAutocorrection:{objc_msgSend(input, "isEqualToString:", candidate2) ^ 1}];
  }

  else
  {
    [v3 setHasAutocorrection:0];
  }

  if (objc_opt_respondsToSelector())
  {
    [v3 setContinuousPathUnderway:{-[_UIKeyboardStateManager continuousPathUnderway](self, "continuousPathUnderway")}];
  }

  [v3 setHasCandidates:{-[TIKeyboardCandidateResultSet hasCandidates](self->m_candidateResultSet, "hasCandidates")}];
  m_candidateList = self->m_candidateList;
  if (m_candidateList)
  {
    v15 = [(UIKeyboardCandidateList *)m_candidateList currentIndex]!= 0x7FFFFFFFFFFFFFFFLL;
  }

  else
  {
    v15 = 0;
  }

  [v3 setHasCandidateSelected:v15];
  if (objc_opt_respondsToSelector())
  {
    [v3 setHasNextPage:{-[UIKeyboardCandidateList hasCandidateInForwardDirection:granularity:](self->m_candidateList, "hasCandidateInForwardDirection:granularity:", 1, 2)}];
  }

  [v3 setUserSelectedCurrentCandidate:{-[TIKeyboardState userSelectedCurrentCandidate](self->m_keyboardState, "userSelectedCurrentCandidate")}];
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  candidateController = [WeakRetained candidateController];
  [v3 setShowsExtendedList:{objc_msgSend(candidateController, "isExtended")}];

  layoutState = [(TIKeyboardState *)self->m_keyboardState layoutState];
  [v3 setShowsCandidatesInLayout:{objc_msgSend(layoutState, "hasCandidateKey")}];

  _markedText = [(_UIKeyboardStateManager *)self _markedText];
  _lastGrapheme = [_markedText _lastGrapheme];

  if ([_lastGrapheme _containsBopomofoOnly])
  {
    v21 = [_lastGrapheme _containsBopomofoToneOnly] ^ 1;
  }

  else
  {
    v21 = 0;
  }

  [v3 setFollowsZhuyin:v21];
  [v3 setFollowsIncompleteRomaji:{-[TIKeyboardInputManagerState shouldFixupIncompleteRomaji](self->m_inputManagerState, "shouldFixupIncompleteRomaji")}];
  v22 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v22 preferencesActions];
  v24 = [preferencesActions valueForPreferenceKey:*MEMORY[0x1E69D9958]];

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    bOOLValue = 1;
    goto LABEL_27;
  }

  if (v24)
  {
    bOOLValue = [v24 BOOLValue];
LABEL_27:

    goto LABEL_28;
  }

  bOOLValue = 1;
LABEL_28:
  [v3 setSpaceConfirmation:bOOLValue];
  [v3 setHardwareKeyboardMode:{-[_UIKeyboardStateManager isInHardwareKeyboardMode](self, "isInHardwareKeyboardMode")}];

  return v3;
}

- (TUIKeyboardBackendController)backendController
{
  if ([(_UIKeyboardStateManager *)self shouldAccessInputManagerService])
  {
    v3 = sharedInputManagerMux();
    if (([v3 hasSystemInputManager] & 1) == 0)
    {
      [(_UIKeyboardStateManager *)self setInputManagerFromCurrentInputMode];
    }

    v10 = 0;
    v11 = &v10;
    v12 = 0x2050000000;
    v4 = getTUIKeyboardBackendControllerClass_softClass;
    v13 = getTUIKeyboardBackendControllerClass_softClass;
    if (!getTUIKeyboardBackendControllerClass_softClass)
    {
      v9[0] = MEMORY[0x1E69E9820];
      v9[1] = 3221225472;
      v9[2] = __getTUIKeyboardBackendControllerClass_block_invoke;
      v9[3] = &unk_1E70F2F20;
      v9[4] = &v10;
      __getTUIKeyboardBackendControllerClass_block_invoke(v9);
      v4 = v11[3];
    }

    v5 = v4;
    _Block_object_dispose(&v10, 8);
    sharedInstance = [v4 sharedInstance];
    if (objc_opt_respondsToSelector())
    {
      implProxy = [(_UIKeyboardStateManager *)self implProxy];
      [sharedInstance setCandidateReceiver:implProxy];
    }
  }

  else
  {
    sharedInstance = 0;
  }

  return sharedInstance;
}

- (BOOL)_shouldLoadPredictionsBasedOnCurrentTraits
{
  predictionFromPreference = [(_UIKeyboardStateManager *)self predictionFromPreference];
  if (predictionFromPreference)
  {
    if (![(_UIKeyboardStateManager *)self prewarmsPredictiveCandidates]&& ([(UITextInputTraits *)self->m_traits disablePrediction]|| [(UITextInputTraits *)self->m_traits hidePrediction]) || [(UITextInputTraits *)self->m_traits autocorrectionType]== 1)
    {
      LOBYTE(predictionFromPreference) = 0;
    }

    else
    {
      LOBYTE(predictionFromPreference) = ![(UITextInputTraits *)self->m_traits isSecureTextEntry];
    }
  }

  return predictionFromPreference;
}

- (BOOL)predictionFromPreference
{
  if ([(_UIKeyboardStateManager *)self disableInputBars])
  {
    return 0;
  }

  v3 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v3 preferencesActions];
  predictionEnabled = [preferencesActions predictionEnabled];

  return predictionEnabled;
}

- (id)updatedKeyBehaviors
{
  _keyboardBehaviorState = [(_UIKeyboardStateManager *)self _keyboardBehaviorState];
  keyboardBehaviors = [(UIKeyboardCandidateList *)self->m_candidateList keyboardBehaviors];
  v5 = [(_UIKeyboardStateManager *)self updateKeyBehaviors:0 withBehaviors:keyboardBehaviors forState:_keyboardBehaviorState];

  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  keyboardBehaviors2 = [inputManagerState keyboardBehaviors];
  v8 = [(_UIKeyboardStateManager *)self updateKeyBehaviors:v5 withBehaviors:keyboardBehaviors2 forState:_keyboardBehaviorState];

  return v8;
}

- (id)_markedText
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  markedText = [inputDelegateManager markedText];

  return markedText;
}

- (void)updateShiftState
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate = [inputDelegateManager keyInputDelegate];
  if (keyInputDelegate)
  {
    v4 = keyInputDelegate;
    suppressUpdateShiftState = [(_UIKeyboardStateManager *)self suppressUpdateShiftState];

    if (suppressUpdateShiftState)
    {
      return;
    }

    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    [WeakRetained layout];

    if (+[UIKeyboard isKeyboardProcess])
    {
      if ([(_UIKeyboardStateManager *)self noContent])
      {
        inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
        documentState = [inputSystemSourceSession documentState];
        v8DocumentState = [documentState documentState];

        if (!v8DocumentState)
        {
          return;
        }
      }
    }

    v10 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [v10 layout];
    if (layout)
    {
      v12 = layout;
      callLayoutIsShiftKeyPlaneChooser = [(_UIKeyboardStateManager *)self callLayoutIsShiftKeyPlaneChooser];

      if (callLayoutIsShiftKeyPlaneChooser)
      {
        goto LABEL_28;
      }
    }

    else
    {
    }

    v14 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v14 layout];
    if (layout2)
    {
      v16 = layout2;
      callLayoutIsShiftKeyBeingHeld = [(_UIKeyboardStateManager *)self callLayoutIsShiftKeyBeingHeld];

      if (callLayoutIsShiftKeyBeingHeld)
      {
        if (!self->m_shift || self->m_shiftHeldDownNeedsUpdated)
        {
          return;
        }

        self->m_shiftHeldDownNeedsUpdated = 1;
        goto LABEL_28;
      }
    }

    else
    {
    }

    self->m_shiftHeldDownNeedsUpdated = 0;
    if ([(_UIKeyboardStateManager *)self keyboardIsKeyPad])
    {
      m_disableAutocapitalization = 1;
    }

    else if ([(_UIKeyboardStateManager *)self _delegateRequiresKeyEvents])
    {
      m_disableAutocapitalization = self->m_disableAutocapitalization;
    }

    else
    {
      m_disableAutocapitalization = 0;
    }

    if (!self->m_autocapitalizationPreference || self->m_shiftPreventAutoshift || self->m_shiftLocked || m_disableAutocapitalization || [(UITextInputTraits *)self->m_traits isSecureTextEntry]&& ![(UITextInputTraits *)self->m_traits displaySecureTextUsingPlainText])
    {
LABEL_28:

      [(_UIKeyboardStateManager *)self notifyShiftState];
      return;
    }

    if (!-[_UIKeyboardStateManager callLayoutUsesAutoShift](self, "callLayoutUsesAutoShift") || -[UITextInputTraits autocapitalizationType](self->m_traits, "autocapitalizationType") == 1 && (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v19 = objc_claimAutoreleasedReturnValue(), [v19 markedTextRange], v20 = objc_claimAutoreleasedReturnValue(), v20, v19, v20))
    {
      *&self->m_autoshift = 0;
    }

    else
    {
      inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];

      if (inputDelegate)
      {
        self->m_autoshift = 0;
        autocapitalizationType = [(UITextInputTraits *)self->m_traits autocapitalizationType];
        if (autocapitalizationType == 1)
        {
          inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          _characterBeforeCaretSelection = [inputDelegateManager2 _characterBeforeCaretSelection];

          if ((_characterBeforeCaretSelection > 0x20 || ((1 << _characterBeforeCaretSelection) & 0x100000401) == 0) && _characterBeforeCaretSelection != 160)
          {
            goto LABEL_37;
          }
        }

        else if (autocapitalizationType != 3 && (autocapitalizationType != 2 || ![(_UIKeyboardStateManager *)self isSelectionAtSentenceAutoshiftBoundary:1]))
        {
          goto LABEL_37;
        }

        *&self->m_autoshift = 257;
      }
    }

LABEL_37:
    [(_UIKeyboardStateManager *)self notifyShiftState];

    [(_UIKeyboardStateManager *)self _forwardNeededShiftStatesToDestination];
    return;
  }
}

- (void)notifyShiftState
{
  [(_UIKeyboardStateManager *)self callLayoutSetShift:self->m_shift];
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  hasLanguageIndicator = [WeakRetained hasLanguageIndicator];

  if (hasLanguageIndicator)
  {
    [(_UIKeyboardStateManager *)self updateInputModeIndicatorOnSingleKeyOnly:0 preserveIfPossible:1];
  }

  [(_UIKeyboardStateManager *)self callLayoutSetAutoshift:self->m_autoshift];
  [(_UIKeyboardStateManager *)self callLayoutUpdateLocalizedKeys];
  shiftState = [(TIKeyboardState *)self->m_keyboardState shiftState];
  if (self->m_shiftLocked && ![(_UIKeyboardStateManager *)self isMinimized])
  {
LABEL_7:
    v8 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [v8 layout];
    if (layout)
    {
      v10 = layout;
      callLayoutIsShiftKeyBeingHeld = [(_UIKeyboardStateManager *)self callLayoutIsShiftKeyBeingHeld];

      if (callLayoutIsShiftKeyBeingHeld)
      {
        m_keyboardState = self->m_keyboardState;
LABEL_14:
        v13 = 1;
        goto LABEL_18;
      }
    }

    else
    {
    }

    m_keyboardState = self->m_keyboardState;
    v13 = 3;
    goto LABEL_18;
  }

  v6 = objc_loadWeakRetained(&self->_presentationDelegate);
  if ([v6 isCapsLockSignOn])
  {
    isMinimized = [(_UIKeyboardStateManager *)self isMinimized];

    if (isMinimized)
    {
      goto LABEL_7;
    }
  }

  else
  {
  }

  if (!self->m_autoshift)
  {
    m_keyboardState = self->m_keyboardState;
    if (!self->m_shift)
    {
      v13 = 0;
      goto LABEL_18;
    }

    goto LABEL_14;
  }

  m_keyboardState = self->m_keyboardState;
  v13 = 2;
LABEL_18:
  [(TIKeyboardState *)m_keyboardState setShiftState:v13];
  [(_UIKeyboardStateManager *)self updateKeyboardConfigurations];
  shiftState2 = [(TIKeyboardState *)self->m_keyboardState shiftState];
  v15 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout2 = [v15 layout];
  isAlphabeticPlane = [layout2 isAlphabeticPlane];

  if (shiftState2 != shiftState && isAlphabeticPlane)
  {
    if ([(_UIKeyboardStateManager *)self usesAutocorrectionLists])
    {
      autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
      [autocorrectionController updateAfterShiftStateChange];
    }

    if ([(TIKeyboardState *)self->m_keyboardState longPredictionListEnabled])
    {
      if ([(_UIKeyboardStateManager *)self usesCandidateSelection])
      {
        if (!-[_UIKeyboardStateManager usesAutocorrectionLists](self, "usesAutocorrectionLists") || (-[_UIKeyboardStateManager autocorrectionController](self, "autocorrectionController"), v19 = objc_claimAutoreleasedReturnValue(), v20 = [v19 hasAutocorrection], v19, (v20 & 1) == 0))
        {
          [(_UIKeyboardStateManager *)self generateCandidates];
        }
      }
    }
  }

  if (shiftState2 != shiftState)
  {
    v21 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout3 = [v21 layout];
    if (layout3)
    {
      v23 = layout3;
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      hasAsyncCapableInputDelegate = [inputDelegateManager hasAsyncCapableInputDelegate];

      if (hasAsyncCapableInputDelegate)
      {
        inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        objc_initWeak(&location, inputDelegateManager2);

        shiftState3 = [(TIKeyboardState *)self->m_keyboardState shiftState];
        if (qword_1ED49D1E8[0] != -1)
        {
          dispatch_once(qword_1ED49D1E8, &__block_literal_global_1223);
        }

        taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
        v30[0] = MEMORY[0x1E69E9820];
        v30[1] = 3221225472;
        v30[2] = __43___UIKeyboardStateManager_notifyShiftState__block_invoke_3;
        v30[3] = &unk_1E70FD848;
        objc_copyWeak(&v31, &location);
        v32 = shiftState;
        v33 = shiftState3;
        [taskQueue addTask:v30 breadcrumb:qword_1ED49D1E0];

        objc_destroyWeak(&v31);
        objc_destroyWeak(&location);
      }
    }

    else
    {
    }
  }

  v29 = objc_loadWeakRetained(&self->_presentationDelegate);
  [v29 setCapsLockSign];
}

- (void)callLayoutUpdateLocalizedKeys
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  v5 = objc_opt_respondsToSelector();

  if (v5)
  {
    v7 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v7 layout];
    [layout2 updateLocalizedKeys:0];
  }
}

- (void)notifyInputSourceStateChangeIfNeeded
{
  if (+[UIKeyboard isKeyboardProcess])
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    if (inputSystemSourceSession)
    {
      v6 = inputSystemSourceSession;
      textOperations = [inputSystemSourceSession textOperations];
      buildInputSourceState = [(_UIKeyboardStateManager *)self buildInputSourceState];
      [textOperations setInputSourceState:buildInputSourceState];

      [v6 flushOperations];
      inputSystemSourceSession = v6;
    }
  }
}

- (BOOL)continuousPathUnderway
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  continuousPathUnderway = [WeakRetained continuousPathUnderway];

  return continuousPathUnderway;
}

- (BOOL)_delegateRequiresKeyEvents
{
  if (self->m_delegateRequiresKeyEvents)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    v3 = [inputDelegateManager shouldRespectForwardingInputDelegate] ^ 1;
  }

  else
  {
    LOBYTE(v3) = 0;
  }

  return v3;
}

- (BOOL)shouldAccessInputManagerService
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  if (WeakRetained)
  {
    shouldAccessInputManagerService = [objc_opt_class() shouldAccessInputManagerService];
  }

  else
  {
    shouldAccessInputManagerService = 1;
  }

  return shouldAccessInputManagerService;
}

- (BOOL)shouldGenerateCandidatesAfterSelectionChange
{
  if ([(_UIKeyboardStateManager *)self usesCandidateSelection])
  {
    return 1;
  }

  if (![(_UIKeyboardStateManager *)self _shouldLoadPredictionsBasedOnCurrentTraits])
  {
    if ([UIApp _isSpringBoard])
    {
      autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
      hasAutocorrection = [autocorrectionController hasAutocorrection];

      if (hasAutocorrection)
      {
        autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
        autocorrectionList = [autocorrectionController2 autocorrectionList];
        if (autocorrectionList)
        {
        }

        else
        {
          autocorrectionController3 = [(_UIKeyboardStateManager *)self autocorrectionController];
          textSuggestionList = [autocorrectionController3 textSuggestionList];

          if (!textSuggestionList)
          {
            return 0;
          }
        }
      }
    }
  }

  if ([(UITextInputTraits *)self->m_traits contentsIsSingleValue])
  {
    return 1;
  }

  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  shouldExtendPriorWord = [inputManagerState shouldExtendPriorWord];

  if (shouldExtendPriorWord)
  {
    return 1;
  }

  return [(_UIKeyboardStateManager *)self _shouldLoadPredictionsBasedOnCurrentTraits];
}

- (void)setShiftOffIfNeeded
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];

  if (layout && !self->m_shiftLocked)
  {
    v5 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v5 layout];
    if (layout2)
    {
      v7 = layout2;
      callLayoutIsShiftKeyBeingHeld = [(_UIKeyboardStateManager *)self callLayoutIsShiftKeyBeingHeld];

      if (callLayoutIsShiftKeyBeingHeld)
      {
        return;
      }
    }

    else
    {
    }

    v9 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout3 = [v9 layout];
    if (layout3)
    {
      v11 = layout3;
      callLayoutIsShiftKeyPlaneChooser = [(_UIKeyboardStateManager *)self callLayoutIsShiftKeyPlaneChooser];

      if (callLayoutIsShiftKeyPlaneChooser)
      {
        return;
      }
    }

    else
    {
    }

    [(_UIKeyboardStateManager *)self setShift:0];

    [(_UIKeyboardStateManager *)self setShiftPreventAutoshift:0];
  }
}

- (void)updateCandidateDisplay
{
  [(_UISmartReplyFeedbackManager *)self->_smartReplyFeedbackManager resetSmartReplyFeedbackUIIfAlreadyShown];
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateCandidateDisplay];
}

- (void)setShiftNeedsUpdate
{
  self->m_shiftNeedsUpdate = 1;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateObserverState];
}

- (void)_forwardNeededShiftStatesToDestination
{
  v14[3] = *MEMORY[0x1E69E9840];
  if (+[UIKeyboard isKeyboardProcess])
  {
    WeakRetained = objc_loadWeakRetained(&qword_1ED49D1F0);
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager keyInputDelegate];

    if (self->m_shift != byte_1ED49CF39 || self->m_autoshift != byte_1ED49CF3A || WeakRetained != keyInputDelegate || self->m_shiftLocked != byte_1ED49CF3B)
    {
      remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      v13[0] = @"shift";
      v7 = [MEMORY[0x1E696AD98] numberWithBool:self->m_shift];
      v14[0] = v7;
      v13[1] = @"autoShift";
      v8 = [MEMORY[0x1E696AD98] numberWithBool:self->m_autoshift];
      v14[1] = v8;
      v13[2] = @"shiftLocked";
      v9 = [MEMORY[0x1E696AD98] numberWithBool:self->m_shiftLocked];
      v14[2] = v9;
      v10 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v14 forKeys:v13 count:3];
      [remoteTextInputPartner forwardKeyboardOperation:sel_setShiftStatesNeededInDestination_autoShifted_shiftLocked_ object:v10];

      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      keyInputDelegate2 = [inputDelegateManager2 keyInputDelegate];
      objc_storeWeak(&qword_1ED49D1F0, keyInputDelegate2);

      byte_1ED49CF39 = self->m_shift;
      byte_1ED49CF3A = self->m_autoshift;
      byte_1ED49CF3B = self->m_shiftLocked;
    }
  }
}

- (void)updateKeyboardConfigurations
{
  if (!self->m_inDealloc)
  {
    [(_UIKeyboardStateManager *)self _updateKeyboardConfigurations];
  }
}

- (void)_updateKeyboardConfigurations
{
  keyboardBehaviors = [(UIKeyboardCandidateList *)self->m_candidateList keyboardBehaviors];
  if (keyboardBehaviors)
  {
  }

  else
  {
    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    keyboardBehaviors2 = [inputManagerState keyboardBehaviors];

    if (!keyboardBehaviors2)
    {
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      layout = [WeakRetained layout];
      [layout restoreDefaultsForAllKeys];

      goto LABEL_10;
    }
  }

  if (self->m_hasInputOnAcceptCandidate)
  {
    [(_UIKeyboardStateManager *)self _handleKeyBehavior:8 forKeyType:@"_keyid_space_"];

    [(_UIKeyboardStateManager *)self _handleKeyBehavior:8 forKeyType:@"_keyid_return_"];
    return;
  }

  WeakRetained = [(_UIKeyboardStateManager *)self updatedKeyBehaviors];
  -[_UIKeyboardStateManager _handleKeyBehavior:forKeyType:](self, "_handleKeyBehavior:forKeyType:", [WeakRetained spaceKeyBehavior], @"_keyid_space_");
  -[_UIKeyboardStateManager _handleKeyBehavior:forKeyType:](self, "_handleKeyBehavior:forKeyType:", [WeakRetained returnKeyBehavior], @"_keyid_return_");
LABEL_10:
}

- (void)clearDelayDeleteTimer
{
  [(UIKeyboardScheduledTask *)self->m_delayDeleteTask invalidate];
  m_delayDeleteTask = self->m_delayDeleteTask;
  self->m_delayDeleteTask = 0;
}

- (_UITextChoiceAccelerationAssistant)_textChoicesAssistant
{
  textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];

  if (textInteractionAssistant)
  {
    textInteractionAssistant2 = [(_UIKeyboardStateManager *)self textInteractionAssistant];
    _textChoicesAssistant = [textInteractionAssistant2 _textChoicesAssistant];

    [_textChoicesAssistant setDelegate:self];
    textInteractionAssistant3 = [(_UIKeyboardStateManager *)self textInteractionAssistant];
    _textChoicesAssistant2 = [textInteractionAssistant3 _textChoicesAssistant];
  }

  else
  {
    _textChoicesAssistant = [(_UIKeyboardStateManager *)self inputDelegate];
    customInputDelegateChoiceAccelerationAssistant = self->_customInputDelegateChoiceAccelerationAssistant;
    if (!customInputDelegateChoiceAccelerationAssistant || ([(_UITextChoiceAccelerationAssistant *)customInputDelegateChoiceAccelerationAssistant textInputResponder], v9 = objc_claimAutoreleasedReturnValue(), v9, v9 != _textChoicesAssistant))
    {
      v10 = [[_UITextChoiceAccelerationAssistant alloc] initWithTextInputResponder:_textChoicesAssistant];
      v11 = self->_customInputDelegateChoiceAccelerationAssistant;
      self->_customInputDelegateChoiceAccelerationAssistant = v10;

      [(_UITextChoiceAccelerationAssistant *)self->_customInputDelegateChoiceAccelerationAssistant setDelegate:self];
    }

    _textChoicesAssistant2 = self->_customInputDelegateChoiceAccelerationAssistant;
  }

  return _textChoicesAssistant2;
}

- (_UIKeyboardTextSelectionController)textSelectionController
{
  textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];

  if (textInteractionAssistant)
  {
    textInteractionAssistant2 = [(_UIKeyboardStateManager *)self textInteractionAssistant];
    activeSelectionController = [textInteractionAssistant2 activeSelectionController];
    goto LABEL_12;
  }

  textInteractionAssistant2 = [(_UIKeyboardStateManager *)self inputDelegate];
  customInputDelegateSelectionController = self->_customInputDelegateSelectionController;
  if (!customInputDelegateSelectionController || ([(_UIKeyboardTextSelectionController *)customInputDelegateSelectionController inputDelegate], v7 = objc_claimAutoreleasedReturnValue(), v7, v7 != textInteractionAssistant2))
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    hasAsyncCapableInputDelegate = [inputDelegateManager hasAsyncCapableInputDelegate];

    if (hasAsyncCapableInputDelegate)
    {
      v10 = _UIKeyboardAsyncTextSelectionController;
    }

    else
    {
      if (!textInteractionAssistant2)
      {
        v11 = 0;
        goto LABEL_10;
      }

      v10 = _UIKeyboardTextSelectionController;
    }

    v11 = [[v10 alloc] initWithInputDelegate:textInteractionAssistant2];
LABEL_10:
    v12 = self->_customInputDelegateSelectionController;
    self->_customInputDelegateSelectionController = v11;
  }

  activeSelectionController = self->_customInputDelegateSelectionController;
LABEL_12:
  v13 = activeSelectionController;

  return v13;
}

- (id)inputDelegate
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  textInputDelegate = [inputDelegateManager textInputDelegate];

  return textInputDelegate;
}

- (BOOL)disableInputBars
{
  if (![(UITextInputTraits *)self->m_traits disableInputBars]&& !self->_disableInputBars)
  {
    return 0;
  }

  if ([(UITextInputTraits *)self->m_traits isDevicePasscodeEntry])
  {
    return 1;
  }

  return [(_UIKeyboardStateManager *)self isMinimized];
}

- (BOOL)usesCandidateSelection
{
  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  rtiInputSourceState = [remoteTextInputPartner rtiInputSourceState];

  if (rtiInputSourceState)
  {
    remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    rtiInputSourceState2 = [remoteTextInputPartner2 rtiInputSourceState];
    usesCandidateSelection = [rtiInputSourceState2 usesCandidateSelection];

    return usesCandidateSelection;
  }

  if (self->m_usesCandidateSelection)
  {
    if ((UIKeyboardNeverShowCandidateBarForCurrentInputMode() & 1) == 0)
    {
      return [(TIKeyboardState *)self->m_keyboardState suppressingCandidateSelection]^ 1;
    }
  }

  else if (UIKeyboardAlwaysShowCandidateBarForCurrentInputMode())
  {
    return [(TIKeyboardState *)self->m_keyboardState suppressingCandidateSelection]^ 1;
  }

  return 0;
}

- (id)inputSystemSourceSession
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  inputSystemSourceSession = [inputDelegateManager inputSystemSourceSession];

  return inputSystemSourceSession;
}

- (id)delegateAsResponder
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  delegateAsResponder = [inputDelegateManager delegateAsResponder];

  return delegateAsResponder;
}

- (void)_cancelPendingSupplementalCandidateInsertion
{
  pendingSupplementalCandidateToInsert = [(_UIKeyboardStateManager *)self pendingSupplementalCandidateToInsert];
  if (pendingSupplementalCandidateToInsert)
  {
    v4 = pendingSupplementalCandidateToInsert;
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    v6 = objc_opt_respondsToSelector();

    if (v6)
    {
      self->m_textInputChangesIgnored = 1;
      inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegate2 _cancelChooseSupplementalItemToInsert];

      self->m_textInputChangesIgnored = 0;
    }
  }

  [(_UIKeyboardStateManager *)self setPendingSupplementalCandidateToInsert:0];
}

- (void)removeAutocorrectPromptAndCandidateList
{
  [(_UIKeyboardStateManager *)self removeAutocorrectPrompt];
  [(_UIKeyboardStateManager *)self removeCandidateList];
  [(_UIKeyboardStateManager *)self removeTextChoicePrompt];
  inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
  [inlineTextCompletionController removeTextCompletionPrompt];
}

- (void)removeAutocorrectPrompt
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained removeAutocorrectPrompt];
}

- (void)removeCandidateList
{
  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = __46___UIKeyboardStateManager_removeCandidateList__block_invoke;
  aBlock[3] = &unk_1E70F3590;
  aBlock[4] = self;
  v3 = _Block_copy(aBlock);
  if (+[UIViewPropertyAnimator _trackedAnimationsStartPaused])
  {
    [UIView performWithoutAnimation:v3];
  }

  else
  {
    v3[2](v3);
  }

  m_candidateList = self->m_candidateList;
  self->m_candidateList = 0;

  [(_UIKeyboardStateManager *)self setUserSelectedCurrentCandidate:0];
  [(_UIKeyboardStateManager *)self updateKeyboardConfigurations];
}

- (void)removeTextChoicePrompt
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained removeTextChoicePrompt];
}

- (void)updateDelegatePasteSupport
{
  v11 = +[UIKeyboard keyboardBundleIdentifier];
  if ([v11 isEqualToString:@"com.apple.springboard"])
  {
    v3 = 1;
  }

  else
  {
    v3 = [v11 isEqualToString:@"com.apple.Spotlight"];
  }

  if (qword_1ED49D000 != -1)
  {
    dispatch_once(&qword_1ED49D000, &__block_literal_global_598);
  }

  v4 = +[UIKeyboardInputModeController sharedInputModeController];
  normalizedEnabledInputModeIdentifiers = [v4 normalizedEnabledInputModeIdentifiers];
  v6 = [normalizedEnabledInputModeIdentifiers containsObject:@"emoji"];

  if ((v3 & 1) != 0 || (_MergedGlobals_1036 & 1) != 0 || [(UITextInputTraits *)self->m_traits isSecureTextEntry]|| v6 != 1)
  {
    *&self->m_needsPasteSupportUpdate = 0;
  }

  else
  {
    uncachedDelegateSupportsImagePaste = [(_UIKeyboardStateManager *)self uncachedDelegateSupportsImagePaste];
    self->m_delegateSupportsImagePaste = uncachedDelegateSupportsImagePaste;
    self->m_needsPasteSupportUpdate = 0;
    if ((uncachedDelegateSupportsImagePaste & v6) == 1)
    {
      v8 = +[UIKeyboardMediaController sharedKeyboardMediaController];
      if ([v8 recentsViewWillBeVisible])
      {
        WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
        isSplit = [objc_opt_class() isSplit];

        if ((isSplit & 1) == 0)
        {
          +[_UIKeyboardMediaServiceWarmUpConnection warmUp];
        }
      }

      else
      {
      }
    }
  }
}

- (BOOL)canInsertStickerAsTextInputPayload
{
  v2 = +[UITextInputPayloadController sharedInstance];
  supportedPayloadIds = [v2 supportedPayloadIds];

  LOBYTE(v2) = [supportedPayloadIds containsObject:@"com.apple.messages.stageSticker"];
  return v2;
}

- (BOOL)canInsertAdaptiveImageGlyph
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v3 = [inputDelegateManager delegateRespectingForwardingDelegate:0];

  if (+[UIKeyboard isRemoteEmojiCollectionViewEnabled]&& (objc_opt_respondsToSelector() & 1) != 0)
  {
    supportsAdaptiveImageGlyph = [v3 supportsAdaptiveImageGlyph];
  }

  else
  {
    supportsAdaptiveImageGlyph = 0;
  }

  return supportsAdaptiveImageGlyph;
}

- (BOOL)returnKeyEnabled
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  returnKeyEnabled = [WeakRetained returnKeyEnabled];

  return returnKeyEnabled;
}

- (BOOL)selectionScrolling
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  selectionScrolling = [WeakRetained selectionScrolling];

  return selectionScrolling;
}

- (BOOL)textInputTraitsNeedAutofill
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  v3 = [autofillController delegateNeedsAutofillMode] != 0;

  return v3;
}

- (void)responseContextDidChange
{
  v40 = *MEMORY[0x1E69E9840];
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  privateInputDelegate = [inputDelegateManager privateInputDelegate];
  textInputTraits = [privateInputDelegate textInputTraits];
  responseContext = [textInputTraits responseContext];

  if (!responseContext)
  {
    delegate = [(_UIKeyboardStateManager *)self delegate];
    v8 = objc_opt_respondsToSelector();

    if (v8)
    {
      delegate2 = [(_UIKeyboardStateManager *)self delegate];
      responseContext = [delegate2 responseContext];
    }

    else
    {
      responseContext = 0;
    }
  }

  [(TIKeyboardState *)self->m_keyboardState setResponseContext:responseContext];
  inputContextHistory = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];
  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  textInputTraits2 = [inputDelegateManager2 textInputTraits];
  inputContextHistory2 = [textInputTraits2 inputContextHistory];

  if (!inputContextHistory2)
  {
    delegate3 = [(_UIKeyboardStateManager *)self delegate];
    v15 = objc_opt_respondsToSelector();

    if (v15)
    {
      delegate4 = [(_UIKeyboardStateManager *)self delegate];
      inputContextHistory2 = [delegate4 inputContextHistory];
    }

    else
    {
      inputContextHistory2 = 0;
    }
  }

  v17 = _UIKeyboardSmartReplyLog();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    v18 = [inputContextHistory debugDescription];
    tiInputContextHistory = [inputContextHistory2 tiInputContextHistory];
    v20 = [tiInputContextHistory debugDescription];
    v36 = 138478083;
    v37 = v18;
    v38 = 2113;
    v39 = v20;
    _os_log_impl(&dword_188A29000, v17, OS_LOG_TYPE_DEFAULT, "Handling responseContextDidChange - existing: %{private}@, new: %{private}@", &v36, 0x16u);
  }

  if (!inputContextHistory2 || ([inputContextHistory2 tiInputContextHistory], v21 = objc_claimAutoreleasedReturnValue(), v21, v21 == inputContextHistory))
  {
    v28 = 0;
  }

  else
  {
    tiInputContextHistory2 = [inputContextHistory2 tiInputContextHistory];
    [(TIKeyboardState *)self->m_keyboardState setInputContextHistory:tiInputContextHistory2];

    v23 = _UIKeyboardSmartReplyLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      inputContextHistory3 = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];
      v25 = [inputContextHistory3 debugDescription];
      v36 = 138477827;
      v37 = v25;
      _os_log_impl(&dword_188A29000, v23, OS_LOG_TYPE_DEFAULT, "Handling setting state to: %{private}@", &v36, 0xCu);
    }

    textInputTraits3 = [(_UIKeyboardStateManager *)self textInputTraits];
    [textInputTraits3 setInputContextHistory:inputContextHistory2];

    tiInputContextHistory3 = [inputContextHistory2 tiInputContextHistory];

    v28 = 1;
    inputContextHistory = tiInputContextHistory3;
  }

  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner documentTraitsChanged];
LABEL_19:

    goto LABEL_20;
  }

  mostRecentNonSenderTextEntry = [inputContextHistory mostRecentNonSenderTextEntry];
  if (mostRecentNonSenderTextEntry && (v31 = mostRecentNonSenderTextEntry, v32 = [inputContextHistory mostRecentTextEntryIsByMe], v31, !v32) || objc_msgSend(responseContext, "length"))
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    if ([inputDelegate hasText])
    {
      v34 = v28 | [inputContextHistory hasPendingEntries];

      if ((v34 & 1) == 0)
      {
        goto LABEL_20;
      }
    }

    else
    {
    }
  }

  else if ((v28 | [inputContextHistory hasPendingEntries]) != 1)
  {
    goto LABEL_20;
  }

  v35 = _UIKeyboardSmartReplyLog();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v36) = 0;
    _os_log_impl(&dword_188A29000, v35, OS_LOG_TYPE_DEFAULT, "Will regenerate smart replies for responseContextDidChange", &v36, 2u);
  }

  if ([(_UIKeyboardStateManager *)self canShowPredictionBar]&& ![(_UIKeyboardStateManager *)self shouldShowLongPredictionList])
  {
    [(_UIKeyboardStateManager *)self _requestInputManagerSync];
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self autocorrectionController];
    [remoteTextInputPartner setNeedsAutocorrection];
    goto LABEL_19;
  }

  if ([(_UIKeyboardStateManager *)self usesCandidateSelection])
  {
    [(_UIKeyboardStateManager *)self _requestInputManagerSync];
    [(_UIKeyboardStateManager *)self generateCandidatesAsynchronouslyWithRange:0 selectedCandidate:0x7FFFFFFFLL, 0];
  }

LABEL_20:
}

- (void)clearTransientState
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained clearTransientState];

  self->m_selecting = 0;
  *&self->m_userChangedSelection = 0;
}

- (void)clearLongPressTimer
{
  [(UIDelayedAction *)self->m_longPressAction setTarget:0];
  m_longPressAction = self->m_longPressAction;
  self->m_longPressAction = 0;

  self->m_longPress = 0;
}

- (void)dismissAutoFillMenu
{
  if (self->m_isAutoFillMenuPresented)
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardInputDestinationEventToUIHost:sel_dismissAutoFillMenu];

    self->m_isAutoFillMenuPresented = 0;
    self->m_shouldSuppressSelectionCommands = 0;
  }
}

- (void)_insertionPointExitedRangeWithSupplementalCandidate
{
  lastMatchedSupplementalCandidate = [(_UIKeyboardStateManager *)self lastMatchedSupplementalCandidate];

  if (lastMatchedSupplementalCandidate)
  {
    [(_UIKeyboardStateManager *)self _dispatchInsertionPointExitedRangeWithSupplementalCandidate];

    [(_UIKeyboardStateManager *)self setLastMatchedSupplementalCandidate:0];
  }
}

- (id)asyncInputDelegate
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  asyncInputDelegate = [inputDelegateManager asyncInputDelegate];

  return asyncInputDelegate;
}

- (id)webInputDelegate
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  webInputDelegate = [inputDelegateManager webInputDelegate];

  return webInputDelegate;
}

- (UIKeyInput)delegate
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate = [inputDelegateManager keyInputDelegate];

  return keyInputDelegate;
}

- (void)deactivateLayout
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained clearLanguageIndicator];

  v5 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [v5 layout];
  [layout deactivateActiveKeys];
}

- (unint64_t)delegateConformanceType
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  delegateConformanceType = [inputDelegateManager delegateConformanceType];

  return delegateConformanceType;
}

- (void)stopAutoDelete
{
  if (pthread_main_np())
  {
    if ([(UIKeyboardScheduledTask *)self->m_autoDeleteTask isValid]|| self->m_repeatDeleteFromHardwareKeyboard)
    {
      self->m_autoDeleteOK = 0;
      [(_UIKeyboardStateManager *)self clearAutoDeleteTimer];
      self->m_autoDeleteUseForce = 0;
      if (self->m_needsOneShotGenerateCandidatesAfterStoppingAutoDelete || self->m_autoDeleteCount > self->m_repeatDeleteFromHardwareKeyboard)
      {
        [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegate];
        [(_UIKeyboardStateManager *)self completeDelete];
      }

      self->m_repeatDeleteFromHardwareKeyboard = 0;
      self->m_needsOneShotGenerateCandidatesAfterStoppingAutoDelete = 0;
    }
  }

  else
  {

    [(_UIKeyboardStateManager *)self performSelectorOnMainThread:a2 withObject:0 waitUntilDone:0];
  }
}

- (BOOL)autocapitalizationPreference
{
  isInHardwareKeyboardMode = [(_UIKeyboardStateManager *)self isInHardwareKeyboardMode];
  v3 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v3 preferencesActions];
  v5 = preferencesActions;
  v6 = MEMORY[0x1E69D9748];
  if (!isInHardwareKeyboardMode)
  {
    v6 = MEMORY[0x1E69D9800];
  }

  v7 = [preferencesActions BOOLForPreferenceKey:*v6];

  return v7;
}

- (void)clearShiftState
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  keyboardLayoutIsInAnotherProcess = [WeakRetained keyboardLayoutIsInAnotherProcess];

  if (keyboardLayoutIsInAnotherProcess)
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardInputDestinationEventToUIHost:sel_clearShiftState];
  }

  else
  {
    [(_UIKeyboardStateManager *)self setShift:0];

    [(_UIKeyboardStateManager *)self setShiftPreventAutoshift:0];
  }
}

- (void)_postInputResponderChangedNotification
{
  v10[1] = *MEMORY[0x1E69E9840];
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate = [inputDelegateManager keyInputDelegate];
  if (keyInputDelegate)
  {
    v9 = @"UITextInputResponderCapabilitiesChangedInputResponderKey";
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate2 = [inputDelegateManager2 keyInputDelegate];
    v10[0] = keyInputDelegate2;
    v7 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v10 forKeys:&v9 count:1];
  }

  else
  {
    v7 = 0;
  }

  defaultCenter = [MEMORY[0x1E696AD88] defaultCenter];
  [defaultCenter postNotificationName:@"UITextInputResponderDidChangeNotification" object:0 userInfo:v7];
}

- (BOOL)isMinimized
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  isMinimized = [WeakRetained isMinimized];

  return isMinimized;
}

- (BOOL)delegateAlreadyInAutofillGroup
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  if (([inputDelegate __isKindOfUIResponder] & 1) == 0)
  {
    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];

    inputDelegate = delegateAsResponder;
  }

  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  [autofillController updateAutofillContextForInputDelegate:inputDelegate];

  v6 = [(_UIKeyboardStateManager *)self isMemberOfAutofillGroup:inputDelegate];
  return v6;
}

- (BOOL)shouldLoadAutofillSignUpInputViewController
{
  if ([(_UIKeyboardStateManager *)self _shouldLoadAutofillSignUpInputViewController])
  {
    return !self->m_usesSystemKeyboardForASP;
  }

  else
  {
    v3 = 0;
    self->m_usesSystemKeyboardForASP = 0;
  }

  return v3;
}

- (BOOL)_shouldLoadAutofillSignUpInputViewController
{
  if ((self->m_cachedAutofillMode & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    return 0;
  }

  _autofillContext = [(_UIKeyboardStateManager *)self _autofillContext];
  v4 = [_autofillContext objectForKey:@"_automaticPasswordKeyboard"];
  bOOLValue = [v4 BOOLValue];

  if (bOOLValue)
  {
    return 1;
  }

  v7 = +[UIKeyboardInputMode autofillSignupInputMode];
  viewControllerClass = [v7 viewControllerClass];

  if (!viewControllerClass)
  {
    return 0;
  }

  if (+[UIKeyboard isKeyboardProcess])
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    documentTraits = [inputSystemSourceSession documentTraits];

    LOBYTE(inputSystemSourceSession) = [documentTraits shouldLoadAutofillSignUp];
    if (inputSystemSourceSession)
    {
      return 1;
    }
  }

  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  autofillGroup = [autofillController autofillGroup];
  v13 = [autofillGroup objectForKey:@"UIAutofillASPOptInKey"];

  if (AutoFillUILibraryCore() && !v13)
  {
    autofillController2 = [(_UIKeyboardStateManager *)self autofillController];
    autofillGroup2 = [autofillController2 autofillGroup];
    v16 = getAFUIAutoFillASPOptInKey();
    v13 = [autofillGroup2 objectForKey:v16];
  }

  if (v13 && ![v13 BOOLValue])
  {
    v6 = 0;
  }

  else
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    if (([inputDelegate __isKindOfUIResponder] & 1) == 0)
    {
      delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];

      inputDelegate = delegateAsResponder;
    }

    autofillController3 = [(_UIKeyboardStateManager *)self autofillController];
    v6 = [autofillController3 shouldLoadASPForResponder:inputDelegate];
  }

  return v6;
}

- (id)_activeAssertionController
{
  textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
  _assertionController = [textInteractionAssistant _assertionController];

  if (!_assertionController)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectionDisplayInteraction = [inputDelegateManager selectionDisplayInteraction];
    _assertionController = [selectionDisplayInteraction _cursorAssertionController];
  }

  return _assertionController;
}

- (BOOL)noContent
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate = [inputDelegateManager keyInputDelegate];

  if (!keyInputDelegate)
  {
    return 0;
  }

  v5 = +[UIDictationLandingView activeInstance];
  delegateWasEmpty = [v5 delegateWasEmpty];

  if (delegateWasEmpty)
  {
    return 1;
  }

  if (+[UIKeyboard isKeyboardProcess])
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    documentState = [inputSystemSourceSession documentState];
    hasText = [documentState hasText];
  }

  else
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputDelegateManager];
    hasText = [inputSystemSourceSession hasText];
  }

  v7 = hasText ^ 1;

  return v7;
}

- (void)updateDelegatePasteSupportIfNeeded
{
  if (self->m_needsPasteSupportUpdate)
  {
    [(_UIKeyboardStateManager *)self updateDelegatePasteSupport];
  }
}

- (CGRect)correctionRect
{
  [(_UIKeyboardStateManager *)self getCorrectionRectIsVertical:0];
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

- (int64_t)needAutofill
{
  if (+[UIKeyboard isKeyboardProcess])
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    documentTraits = [inputSystemSourceSession documentTraits];

    LOBYTE(inputSystemSourceSession) = [documentTraits shouldLoadAutofillSignUp];
    if (inputSystemSourceSession)
    {
      return 2;
    }
  }

  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  delegateNeedsAutofillMode = [autofillController delegateNeedsAutofillMode];

  if (delegateNeedsAutofillMode == 8)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    if ([inputDelegateManager hasText])
    {
      delegateNeedsAutofillMode2 = 0;
    }

    else
    {
      delegateNeedsAutofillMode2 = 8;
    }
  }

  else
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self autofillController];
    delegateNeedsAutofillMode2 = [inputDelegateManager delegateNeedsAutofillMode];
  }

  return delegateNeedsAutofillMode2;
}

- (void)displayAutoFillPopoverIfAutoFillModeDetected
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained displayAutoFillPopoverIfAutoFillModeDetected];
}

- (BOOL)doubleSpacePeriodPreference
{
  isInHardwareKeyboardMode = [(_UIKeyboardStateManager *)self isInHardwareKeyboardMode];
  v3 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v3 preferencesActions];
  v5 = preferencesActions;
  v6 = MEMORY[0x1E69D9770];
  if (!isInHardwareKeyboardMode)
  {
    v6 = MEMORY[0x1E69D98A8];
  }

  v7 = [preferencesActions BOOLForPreferenceKey:*v6];

  return v7;
}

- (void)setInputModeFromPreferences
{
  v3 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputModeInPreference = [v3 currentInputModeInPreference];
  v5 = currentInputModeInPreference;
  if (currentInputModeInPreference && ([currentInputModeInPreference isAllowedForTraits:self->m_traits] & 1) == 0)
  {
    activeInputModes = [v3 activeInputModes];
    v7 = [v3 nextInputModeFromList:activeInputModes withFilter:1 withTraits:self->m_traits];

    v5 = v7;
  }

  activeInputModes2 = [v3 activeInputModes];
  v9 = activeInputModes2;
  if (v5)
  {
    if (([activeInputModes2 containsObject:v5] & 1) == 0)
    {
      v11[0] = MEMORY[0x1E69E9820];
      v11[1] = 3221225472;
      v11[2] = __54___UIKeyboardStateManager_setInputModeFromPreferences__block_invoke;
      v11[3] = &unk_1E70FD190;
      v12 = v5;
      v10 = [v9 indexOfObjectPassingTest:v11];
      if (v10 == 0x7FFFFFFFFFFFFFFFLL)
      {
        v5 = 0;
      }

      else
      {
        v5 = [v9 objectAtIndex:v10];
        if (v5)
        {
          [v3 setCurrentInputModeInPreference:v5];
        }
      }
    }

    if ([(_UIKeyboardStateManager *)self initializationDone])
    {
      goto LABEL_14;
    }

    if (v5)
    {
LABEL_17:
      [(_UIKeyboardStateManager *)self prepareKeyboardInputModeFromPreferences:v5];
      goto LABEL_18;
    }

LABEL_16:
    v5 = +[UIKeyboardInputMode intlInputMode];
    goto LABEL_17;
  }

  if (![(_UIKeyboardStateManager *)self initializationDone])
  {
    goto LABEL_16;
  }

  v5 = 0;
LABEL_14:
  [(_UIKeyboardStateManager *)self setKeyboardInputModeFromPreferences:v5];
LABEL_18:

  [v3 updateCurrentAndNextInputModes];
}

- (BOOL)initializationDone
{
  if (self->m_initializationDone)
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    v3 = [WeakRetained isInitializing] ^ 1;
  }

  else
  {
    LOBYTE(v3) = 0;
  }

  return v3;
}

- (BOOL)shiftLockPreference
{
  v2 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v2 preferencesActions];
  v4 = [preferencesActions BOOLForPreferenceKey:*MEMORY[0x1E69D9828]];

  return v4;
}

- (id)UILanguagePreference
{
  preferredLanguages = [MEMORY[0x1E695DF58] preferredLanguages];
  if ([preferredLanguages count])
  {
    v3 = [preferredLanguages objectAtIndex:0];
  }

  else
  {
    v3 = @"intl";
  }

  return v3;
}

- (id)inputModePreference
{
  v2 = +[UIKeyboardInputModeController sharedInputModeController];
  activeInputModeIdentifiers = [v2 activeInputModeIdentifiers];

  return activeInputModeIdentifiers;
}

- (void)hostApplicationWillEnterForeground
{
  backendController = [(_UIKeyboardStateManager *)self backendController];
  [backendController applicationWillEnterForeground];
}

- (BOOL)callLayoutUsesAutoShift
{
  v3 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v3 currentInputMode];
  isExtensionInputMode = [currentInputMode isExtensionInputMode];

  if (isExtensionInputMode)
  {
    return self->m_usesAutoShiftFor3PK;
  }

  else
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [WeakRetained layout];

    if (layout)
    {
      v9 = objc_loadWeakRetained(&self->_presentationDelegate);
      layout2 = [v9 layout];
      v11 = objc_opt_respondsToSelector();

      if (v11)
      {
        v12 = objc_loadWeakRetained(&self->_presentationDelegate);
        layout3 = [v12 layout];
        usesAutoShift = [layout3 usesAutoShift];

        return usesAutoShift;
      }

      return 0;
    }

    else
    {
      return 1;
    }
  }
}

- (TIKeyboardInputManagerStub)inputManager
{
  v3 = sharedInputManagerMux();
  if (([v3 hasSystemInputManager] & 1) == 0)
  {
    [(_UIKeyboardStateManager *)self setInputManagerFromCurrentInputMode];
  }

  return v3;
}

- (BOOL)hasAdvancedInputDelegate
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  if (inputDelegate)
  {
    v4 = 1;
  }

  else
  {
    asyncInputDelegate = [(_UIKeyboardStateManager *)self asyncInputDelegate];
    v4 = asyncInputDelegate != 0;
  }

  return v4;
}

- (void)clearInput
{
  if ([(_UIKeyboardStateManager *)self usesAutocorrectionLists]|| [(_UIKeyboardStateManager *)self usesCandidateSelection])
  {
    if (self->m_hasInputOnAcceptCandidate)
    {
      v3 = 0;
    }

    else
    {
      v4 = +[UIKeyboardImpl activeInstance];
      textInputTraits = [v4 textInputTraits];

      keyboardType = [textInputTraits keyboardType];
      v3 = (keyboardType > 0xB || ((1 << keyboardType) & 0x930) == 0) && keyboardType != 127;
    }
  }

  else
  {
    v3 = 1;
  }

  [(_UIKeyboardStateManager *)self clearInputWithCandidatesCleared:v3];
}

- (BOOL)isPredictionViewControllerVisible
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  isPredictionViewControllerVisible = [WeakRetained isPredictionViewControllerVisible];

  return isPredictionViewControllerVisible;
}

- (void)clearInputForMarkedText
{
  [(TIKeyboardState *)self->m_keyboardState setInputForMarkedText:0];
  [(TIKeyboardState *)self->m_keyboardState setSearchStringForMarkedText:0];
  self->m_hasEditedMarkedTextInExtendedView = 0;
}

- (void)removeTextChoiceUnderlines
{
  if (+[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled])
  {
    _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
    [_textChoicesAssistant removeAllUnderlines];
  }
}

- (void)updateAssistantView
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateAssistantView];
}

- (TIDocumentState)documentState
{
  documentState = [(TIKeyboardState *)self->m_keyboardState documentState];
  v3 = documentState;
  if (documentState)
  {
    v4 = documentState;
  }

  else
  {
    v4 = objc_alloc_init(MEMORY[0x1E69D9590]);
  }

  v5 = v4;

  return v5;
}

- (id)asyncWebKitInteractionDelegate
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  asyncWebKitInteractionDelegate = [inputDelegateManager asyncWebKitInteractionDelegate];

  return asyncWebKitInteractionDelegate;
}

- (void)flushTouchEventWaitingForKeyInputEventIfNecessary
{
  touchEventWaitingForKeyInputEvent = [(_UIKeyboardStateManager *)self touchEventWaitingForKeyInputEvent];

  if (touchEventWaitingForKeyInputEvent)
  {
    touchEventWaitingForKeyInputEvent2 = [(_UIKeyboardStateManager *)self touchEventWaitingForKeyInputEvent];
    [(_UIKeyboardStateManager *)self skipHitTestForTouchEvent:touchEventWaitingForKeyInputEvent2];

    [(_UIKeyboardStateManager *)self setTouchEventWaitingForKeyInputEvent:0];
  }
}

- (id)layoutState
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layoutState = [WeakRetained layoutState];

  return layoutState;
}

- (BOOL)candidateSelectionPredictionForTraits
{
  if ([(UITextInputTraits *)self->m_traits isSecureTextEntry]|| [(UITextInputTraits *)self->m_traits disablePrediction]|| [(UITextInputTraits *)self->m_traits autocorrectionType]== 1)
  {
    return 0;
  }

  else
  {
    return ![(_UIKeyboardStateManager *)self keyboardIsKeyPad];
  }
}

- (BOOL)prewarmsPredictiveCandidates
{
  v2 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v2 preferencesActions];
  predictionEnabled = [preferencesActions predictionEnabled];
  v5 = kbPrewarmsPredictiveCandidates;

  return predictionEnabled & v5;
}

- (id)responderForSendCurrentLocation
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  if ((objc_opt_respondsToSelector() & 1) != 0 && (v3 = [inputDelegate _sendCurrentLocationAction]) != 0)
  {
    v4 = [inputDelegate targetForAction:v3 withSender:0];
  }

  else
  {
    v4 = 0;
  }

  return v4;
}

- (BOOL)isCurrentEditResponderInEditingMode
{
  if (WebKitFramework)
  {
    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();
  }

  else
  {
    isKindOfClass = 0;
  }

  delegateAsResponder2 = [(_UIKeyboardStateManager *)self delegateAsResponder];
  _responderForEditing = [delegateAsResponder2 _responderForEditing];

  if ((isKindOfClass & 1) != 0 || (objc_opt_respondsToSelector() & 1) == 0)
  {
    delegateAsResponder3 = [(_UIKeyboardStateManager *)self delegateAsResponder];
    v9 = objc_opt_respondsToSelector();

    if (v9)
    {
      delegateAsResponder4 = [(_UIKeyboardStateManager *)self delegateAsResponder];
      if (![delegateAsResponder4 isEditable])
      {
        isFirstResponder = 0;
LABEL_19:

        goto LABEL_20;
      }

      delegateAsResponder5 = [(_UIKeyboardStateManager *)self delegateAsResponder];
      isFirstResponder = [delegateAsResponder5 isFirstResponder];
    }

    else
    {
      textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
      v13 = objc_opt_respondsToSelector();

      if ((v13 & 1) == 0)
      {
        goto LABEL_15;
      }

      delegateAsResponder4 = [(_UIKeyboardStateManager *)self textInteractionAssistant];
      delegateAsResponder5 = [(_UIKeyboardStateManager *)self inputDelegate];
      if ([delegateAsResponder4 viewCouldBecomeEditable:delegateAsResponder5])
      {
        inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
        isFirstResponder = [inputDelegate isFirstResponder];
      }

      else
      {
        isFirstResponder = 0;
      }
    }

    goto LABEL_19;
  }

  if (![_responderForEditing isEditing])
  {
LABEL_15:
    isFirstResponder = 0;
    goto LABEL_20;
  }

  if (objc_opt_respondsToSelector())
  {
    isFirstResponder = [_responderForEditing isEditable];
  }

  else
  {
    isFirstResponder = 1;
  }

LABEL_20:

  return isFirstResponder;
}

- (BOOL)canShowPredictionBar
{
  if (UIKeyboardPredictionEnabledForCurrentInputMode() & 1) != 0 || (UIKeyboardShowsTransliterationCandidatesForCurrentInputMode())
  {
    return 1;
  }

  return [(_UIKeyboardStateManager *)self isAutofillPrediction];
}

- (BOOL)needOneTimeCodeAutofill
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  if ([inputDelegateManager hasText])
  {
    v4 = 0;
  }

  else
  {
    autofillController = [(_UIKeyboardStateManager *)self autofillController];
    v4 = [autofillController delegateNeedsAutofillMode] == 8;
  }

  return v4;
}

- (BOOL)needCellularAutofill
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  if ([inputDelegateManager hasText])
  {
    v4 = 0;
  }

  else
  {
    autofillController = [(_UIKeyboardStateManager *)self autofillController];
    v4 = [autofillController delegateNeedsAutofillMode] == 10;
  }

  return v4;
}

- (int64_t)autofillSubMode
{
  if (!+[UIKeyboard isKeyboardProcess])
  {
    return self->m_autofillSubMode;
  }

  result = [(_UIKeyboardStateManager *)self needAutofill];
  if (result)
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    documentTraits = [inputSystemSourceSession documentTraits];

    autofillSubMode = [documentTraits autofillSubMode];
    return autofillSubMode;
  }

  return result;
}

- (id)updateSecureCandidateRenderTraits
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  if (layout)
  {
    keyboardAppearance = [(UITextInputTraits *)self->m_traits keyboardAppearance];

    if (keyboardAppearance == 127)
    {
      layout = 0;
      goto LABEL_31;
    }

    v6 = +[UIDevice currentDevice];
    if ([v6 userInterfaceIdiom])
    {
      isMinimized = 0;
    }

    else
    {
      isMinimized = [(_UIKeyboardStateManager *)self isMinimized];
    }

    v8 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v8 layout];
    candidateList = [layout2 candidateList];
    v11 = objc_opt_respondsToSelector();

    if (v11)
    {
      candidateController = objc_loadWeakRetained(&self->_presentationDelegate);
      layout3 = [candidateController layout];
      candidateList2 = [layout3 candidateList];
      layout = [candidateList2 secureCandidateRenderTraits];

      goto LABEL_9;
    }

    if (!isMinimized && self->m_usesCandidateSelection)
    {
      v15 = objc_loadWeakRetained(&self->_presentationDelegate);
      candidateController = [v15 candidateController];

      if (objc_opt_respondsToSelector())
      {
        layout = [candidateController secureCandidateRenderTraits];
LABEL_9:

        if (layout)
        {
          goto LABEL_31;
        }

        goto LABEL_16;
      }
    }

LABEL_16:
    v16 = [off_1E70ECC18 systemFontOfSize:14.0];
    WeakRetained = [v16 fontName];

    layout = objc_alloc_init(MEMORY[0x1E69D9648]);
    v17 = objc_loadWeakRetained(&self->_presentationDelegate);
    _inheritedRenderConfig = [v17 _inheritedRenderConfig];
    lightKeyboard = [_inheritedRenderConfig lightKeyboard];

    if (lightKeyboard)
    {
      [MEMORY[0x1E69D9640] blackColor];
    }

    else
    {
      [MEMORY[0x1E69D9640] whiteColor];
    }
    v20 = ;
    v21 = [objc_alloc(MEMORY[0x1E69D9650]) initWithFontName:WeakRetained maxFontSize:v20 minFontSize:14.0 textColor:11.0];
    [layout setHeaderTextTraits:v21];

    v22 = [objc_alloc(MEMORY[0x1E69D9650]) initWithFontName:WeakRetained maxFontSize:v20 minFontSize:17.0 textColor:11.0];
    [layout setInputTextTraits:v22];

    [layout setResultCountToSingleCellWidth:MEMORY[0x1E695E0F0]];
    v23 = +[UIKeyboardPredictionCellMetrics secureCandidateEstimatedMetricsDictionary];
    [layout setCellWidthOptions:v23];

    [layout setMaxCellCount:{-[_UIKeyboardStateManager maxNumberOfProactiveCells](self, "maxNumberOfProactiveCells")}];
    mainScreen = [objc_opt_self() mainScreen];
    [mainScreen scale];
    [layout setScreenScale:?];

    [layout setIsCandidateUI:0];
    v25 = objc_loadWeakRetained(&self->_presentationDelegate);
    traitCollection = [v25 traitCollection];
    [UISystemInputAssistantViewController _defaultPreferredHeightForTraitCollection:traitCollection];
    [layout setSingleCellHeight:ceil(v27)];

    if (isMinimized)
    {
      if ([(TIKeyboardState *)self->m_keyboardState needAutofill]&& (objc_opt_respondsToSelector() & 1) != 0)
      {
        [layout setIsInlinePromptUI:1];
        if (lightKeyboard)
        {
          [MEMORY[0x1E69D9640] darkSecondaryLabelColor];
        }

        else
        {
          [MEMORY[0x1E69D9640] lightSecondaryLabelColor];
        }
        v34 = ;
        headerTextTraits = [layout headerTextTraits];
        [headerTextTraits setTextColor:v34];

        [layout setSingleCellHeight:60.0];
        [layout setMaxCellCount:1];
      }

      else
      {
        v29 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
        existingContainerWindow = [v29 existingContainerWindow];
        [existingContainerWindow safeAreaInsets];
        v32 = v31;
        [layout singleCellHeight];
        [layout setSingleCellHeight:v33 - v32];
      }
    }

    else if ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) != 1)
    {
      [layout singleCellHeight];
      [layout setSingleCellHeight:v28 + -6.0];
    }

    [layout setSingleCellVerticalPadding:0.0];
  }

LABEL_31:

  return layout;
}

- (unint64_t)maxNumberOfProactiveCells
{
  v3 = +[UIPeripheralHost activeInstance];
  loadAwareInputViews = [v3 loadAwareInputViews];
  keyboard = [loadAwareInputViews keyboard];
  interfaceOrientation = [keyboard interfaceOrientation];

  v7 = 2;
  if ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) == 1 && (interfaceOrientation - 3) <= 1)
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    if ([objc_opt_class() isSplit])
    {
      v7 = 2;
    }

    else
    {
      v7 = 3;
    }
  }

  return v7;
}

- (void)_updateCanSuggestSupplementalItemsForCurrentSelection
{
  if (!+[UIKeyboard isKeyboardProcess])
  {
    self->m_textInputChangesIgnored = 1;
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    if (objc_opt_respondsToSelector())
    {
      inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
      -[_UIKeyboardStateManager setCanSuggestSupplementalItemsForCurrentSelection:](self, "setCanSuggestSupplementalItemsForCurrentSelection:", [inputDelegate2 _canSuggestSupplementalItemsForCurrentSelection]);
    }

    else
    {
      [(_UIKeyboardStateManager *)self setCanSuggestSupplementalItemsForCurrentSelection:1];
    }

    self->m_textInputChangesIgnored = 0;
    if (![(_UIKeyboardStateManager *)self canSuggestSupplementalItemsForCurrentSelection])
    {

      [(_UIKeyboardStateManager *)self _insertionPointExitedRangeWithSupplementalCandidate];
    }
  }
}

- (BOOL)imageSuggestionEnabled
{
  if ([(_UIKeyboardStateManager *)self usesCandidateSelection])
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    candidateController = [WeakRetained candidateController];
    activeCandidateViewType = [candidateController activeCandidateViewType];

    if ((activeCandidateViewType & 4) != 0)
    {
      return 0;
    }
  }

  if ([(_UIKeyboardStateManager *)self delegateSupportsImagePaste])
  {
    return 1;
  }

  return [(_UIKeyboardStateManager *)self canInsertAdaptiveImageGlyph];
}

- (void)didSetDelegate
{
  deferredDidSetDelegateAction = [(_UIKeyboardStateManager *)self deferredDidSetDelegateAction];
  [deferredDidSetDelegateAction invalidate];

  [(_UIKeyboardStateManager *)self setDeferredDidSetDelegateAction:0];
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained _updateSoundPreheating];

  [(_UIKeyboardStateManager *)self releaseInputManagerIfInactive];
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  textInputView = [inputDelegate textInputView];

  if (_UIViewIsAnimating(textInputView))
  {
    objc_initWeak(&location, self);
    v18 = MEMORY[0x1E69E9820];
    v19 = 3221225472;
    v20 = __41___UIKeyboardStateManager_didSetDelegate__block_invoke;
    v21 = &unk_1E70F5A28;
    objc_copyWeak(&v22, &location);
    [(_UIKeyboardStateManager *)self queueDelayedTask:&v18];
    objc_destroyWeak(&v22);
    objc_destroyWeak(&location);
  }

  else
  {
    [(_UIKeyboardStateManager *)self updateDelegatePasteSupport];
  }

  if (didSetDelegate_onceToken != -1)
  {
    dispatch_once(&didSetDelegate_onceToken, &__block_literal_global_587);
  }

  keyboardWindow = [(_UIKeyboardStateManager *)self inputDelegateManager:v18];
  keyInputDelegate = [keyboardWindow keyInputDelegate];
  if (keyInputDelegate)
  {
    v9 = keyInputDelegate;
    v10 = +[UIKeyboardInputModeController sharedInputModeController];
    currentInputMode = [v10 currentInputMode];
    isExtensionInputMode = [currentInputMode isExtensionInputMode];

    if (!isExtensionInputMode)
    {
      goto LABEL_10;
    }

    v13 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
    keyboardWindow = [v13 keyboardWindow];

    rootViewController = [keyboardWindow rootViewController];
    [rootViewController updateKeyboardDockViewVisibility];
  }

LABEL_10:
  inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];

  v16 = objc_loadWeakRetained(&self->_presentationDelegate);
  v17 = v16;
  if (inputDelegate2)
  {
    [v16 prewarmEmojiKeyboardIfNeeded];
  }

  else
  {
    [v16 releaseEmojiKeyboardPrewarmingAssertion];
  }
}

- (void)releaseInputManagerIfInactive
{
  delegate = [(_UIKeyboardStateManager *)self delegate];

  if (!delegate)
  {

    [(_UIKeyboardStateManager *)self releaseInputManager];
  }
}

- (void)flushDelayedTasks
{
  deferredUpdateTask = self->_deferredUpdateTask;
  if (deferredUpdateTask)
  {
    deferredUpdateTask[2](deferredUpdateTask, a2);
    v4 = self->_deferredUpdateTask;
    self->_deferredUpdateTask = 0;
  }
}

- (BOOL)canShowAppConnections
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  beginningOfDocument = [inputDelegateManager2 beginningOfDocument];
  inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  endOfDocument = [inputDelegateManager3 endOfDocument];
  v8 = [inputDelegateManager comparePosition:beginningOfDocument toPosition:endOfDocument];

  textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
  textContentType = [textInputTraits textContentType];

  if (v8)
  {
    v11 = 1;
  }

  else
  {
    v11 = textContentType == 0;
  }

  return !v11;
}

- (BOOL)_isShowingSuggestionForKeyboardCamera
{
  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  textSuggestionList = [autocorrectionController textSuggestionList];
  isShowingSuggestionForKeyboardCamera = [textSuggestionList isShowingSuggestionForKeyboardCamera];

  return isShowingSuggestionForKeyboardCamera;
}

- (BOOL)utlizeEuclidModelForDictationReplacement
{
  _textInputController = [(_UIKeyboardStateManager *)self _textInputController];
  v4 = _textInputController;
  if (_textInputController)
  {
    _selectedText = [_textInputController _selectedText];
    v6 = [_selectedText length];
    if (!v6)
    {
      LOBYTE(enableEuclidAlternatives) = 0;
LABEL_15:

      goto LABEL_16;
    }

    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v18 = 0;
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __67___UIKeyboardStateManager_utlizeEuclidModelForDictationReplacement__block_invoke;
    v14[3] = &unk_1E70FDB08;
    v14[4] = &v15;
    [_selectedText enumerateSubstringsInRange:0 options:v6 usingBlock:{3, v14}];
    if (v16[3] > 4)
    {
      LOBYTE(enableEuclidAlternatives) = 0;
LABEL_14:
      _Block_object_dispose(&v15, 8);
      goto LABEL_15;
    }

    dictationLanguageForSelectedText = [v4 dictationLanguageForSelectedText];
    if (dictationLanguageForSelectedText)
    {
      v8 = +[UIDictationController activeInstance];
      enableEuclidAlternatives = [v8 enableEuclidAlternatives];
      if (!enableEuclidAlternatives)
      {
LABEL_8:

LABEL_13:
        goto LABEL_14;
      }

      v10 = [dictationLanguageForSelectedText isEqualToString:@"en_US"];

      if (v10)
      {
        v8 = +[UIDictationController sharedInstance];
        _sessionIdentifier = [(_UIKeyboardStateManager *)self _sessionIdentifier];
        uUIDString = [_sessionIdentifier UUIDString];
        [v8 preheatEuclidModelWithLanguageCode:dictationLanguageForSelectedText clientID:uUIDString];

        goto LABEL_8;
      }
    }

    LOBYTE(enableEuclidAlternatives) = 0;
    goto LABEL_13;
  }

  LOBYTE(enableEuclidAlternatives) = 0;
LABEL_16:

  return enableEuclidAlternatives;
}

- (id)_textInputController
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  v4 = objc_opt_respondsToSelector();

  if (v4)
  {
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    v6 = [inputDelegate2 performSelector:sel_textLayoutController];

    textInputController = [(_UITextLayoutControllerBase *)v6 textInputController];
  }

  else
  {
    textInputController = 0;
  }

  return textInputController;
}

- (void)_requestInputManagerSync
{
  if (qword_1ED49D5B8 != -1)
  {
    dispatch_once(&qword_1ED49D5B8, &__block_literal_global_1942);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = __51___UIKeyboardStateManager__requestInputManagerSync__block_invoke_3;
  v4[3] = &unk_1E70FD058;
  v4[4] = self;
  [taskQueue addTask:v4 breadcrumb:qword_1ED49D5B0];
}

- (BOOL)uncachedDelegateSupportsImagePaste
{
  if (+[UIKeyboard isKeyboardProcess])
  {
    m_remoteDelegateSupportsImagePaste = self->m_remoteDelegateSupportsImagePaste;
  }

  else
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    if (([inputDelegate __isKindOfUIResponder] & 1) == 0)
    {
      delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];

      inputDelegate = delegateAsResponder;
    }

    if ([(_UIKeyboardStateManager *)self showingEmojiSearch])
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v7 = [inputDelegateManager delegateRespectingForwardingDelegate:0];

      inputDelegate = v7;
    }

    _responderForEditing = [inputDelegate _responderForEditing];

    if (_IsKindOfUIView(_responderForEditing))
    {
      v9 = _responderForEditing;
      _responderForEditing = v9;
      if (([v9 _isInAWindow] & 1) == 0)
      {

        _responderForEditing = 0;
      }
    }

    if (_responderForEditing)
    {
      m_remoteDelegateSupportsImagePaste = [_responderForEditing _supportsImagePaste];
    }

    else
    {
      m_remoteDelegateSupportsImagePaste = 0;
    }
  }

  return m_remoteDelegateSupportsImagePaste & 1;
}

- (void)refreshAutofillModeIfNecessary
{
  needAutofillLogin = [(_UIKeyboardStateManager *)self needAutofillLogin];
  needAutofill = [(_UIKeyboardStateManager *)self needAutofill];
  if (needAutofillLogin != [(TIKeyboardState *)self->m_keyboardState needAutofill])
  {
    [(TIKeyboardState *)self->m_keyboardState setNeedAutofill:needAutofillLogin];
  }

  if ([(TIKeyboardState *)self->m_keyboardState autofillMode]!= needAutofill)
  {
    [(TIKeyboardState *)self->m_keyboardState setAutofillMode:needAutofill];
  }

  if (needAutofill)
  {
    v5 = 1;
  }

  else
  {
    v5 = needAutofillLogin;
  }

  if (v5 == 1)
  {
    self->m_keyboardDelegateStateNeedsRefresh = 1;

    [(_UIKeyboardStateManager *)self generateAutofillCandidate];
  }
}

- (void)hostApplicationDidEnterBackground
{
  inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
  [inlineTextCompletionController removeTextCompletionPrompt];

  backendController = [(_UIKeyboardStateManager *)self backendController];
  [backendController applicationDidEnterBackground];
}

- (void)setCapsLockIfNeeded
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained setCapsLockIfNeeded];
}

- (_UIKeyboardStateManager)initWithPresentationDelegateView:(id)view forCustomInputView:(BOOL)inputView
{
  inputViewCopy = inputView;
  v73 = *MEMORY[0x1E69E9840];
  viewCopy = view;
  v65.receiver = self;
  v65.super_class = _UIKeyboardStateManager;
  v7 = [(_UIKeyboardStateManager *)&v65 init];
  v8 = v7;
  if (v7)
  {
    v9 = qword_1ED49D5C0++;
    v7->_id = v9;
    if (os_variant_has_internal_diagnostics())
    {
      v62 = _UIKeyboardExtendedLog();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
      {
        v63 = "No";
        id = v8->_id;
        if (inputViewCopy)
        {
          v63 = "Yes";
        }

        *buf = 136315394;
        *&buf[4] = v63;
        *&buf[12] = 2048;
        *&buf[14] = id;
        _os_log_impl(&dword_188A29000, v62, OS_LOG_TYPE_DEFAULT, "Impl init forCustomInputView:%s (id=%ld)", buf, 0x16u);
      }
    }

    objc_storeWeak(&v8->_presentationDelegate, viewCopy);
    v8->_forCustomInputView = inputViewCopy;
    _UIKBRT_ResetSystemUptimeOnResume();
    v10 = objc_alloc_init(UIKeyboardTaskQueue);
    taskQueue = v8->_taskQueue;
    v8->_taskQueue = v10;

    v12 = objc_alloc_init(_UIKeyboardImplProxy);
    m_implProxy = v8->m_implProxy;
    v8->m_implProxy = v12;

    v14 = objc_alloc_init(MEMORY[0x1E69D9660]);
    m_keyboardState = v8->m_keyboardState;
    v8->m_keyboardState = v14;

    v16 = _UIMainBundleIdentifier();
    [(TIKeyboardState *)v8->m_keyboardState setClientIdentifier:v16];

    v17 = objc_alloc_init(UIKeyboardAutocorrectionController);
    m_autocorrectionController = v8->m_autocorrectionController;
    v8->m_autocorrectionController = v17;

    [(UIKeyboardAutocorrectionController *)v8->m_autocorrectionController setDelegate:v8];
    v19 = [[_UIAssertionController alloc] initWithAssertionSubject:v8];
    assertionController = v8->_assertionController;
    v8->_assertionController = v19;

    if (+[UIKeyboard isInlineTextCompletionUIEnabled](UIKeyboard, "isInlineTextCompletionUIEnabled") && !+[UIKeyboard usesInputSystemUI])
    {
      v21 = objc_alloc_init(UIInlineTextCompletionController);
      m_inlineTextCompletionController = v8->m_inlineTextCompletionController;
      v8->m_inlineTextCompletionController = v21;

      [(UIInlineTextCompletionController *)v8->m_inlineTextCompletionController setDelegate:v8];
      v23 = +[UIKBAnalyticsDispatcher sharedInstance];
      [(UIInlineTextCompletionController *)v8->m_inlineTextCompletionController setAnalyticsDispatcher:v23];
    }

    v66 = 0;
    v67 = &v66;
    v68 = 0x2050000000;
    v24 = qword_1ED49D5C8;
    v69 = qword_1ED49D5C8;
    if (!qword_1ED49D5C8)
    {
      *buf = MEMORY[0x1E69E9820];
      *&buf[8] = 3221225472;
      *&buf[16] = __getTUISmartReplyGeneratorClass_block_invoke;
      v71 = &unk_1E70F2F20;
      v72 = &v66;
      __getTUISmartReplyGeneratorClass_block_invoke(buf);
      v24 = v67[3];
    }

    v25 = v24;
    _Block_object_dispose(&v66, 8);
    sharedInstance = [v24 sharedInstance];
    smartReplyGenerator = v8->_smartReplyGenerator;
    v8->_smartReplyGenerator = sharedInstance;

    v28 = objc_alloc_init(MEMORY[0x1E69D96A0]);
    m_smartPunctuationController = v8->m_smartPunctuationController;
    v8->m_smartPunctuationController = v28;

    v30 = +[_UIKeyboardTextSelectionGestureController sharedInstance];
    [v30 setDelegate:v8];

    v31 = +[_UIKeyboardBasedTextSelectionGestureController sharedInstance];
    [v31 setDelegate:v8];

    v8->m_currentDirection = 0;
    v8->m_textInputSource = 1;
    v8->m_correctionLearningAllowed = 1;
    [(_UIKeyboardStateManager *)v8 takeTextInputTraitsFromDelegate];
    v32 = +[UIDevice currentDevice];
    _isHardwareKeyboardAvailable = [v32 _isHardwareKeyboardAvailable];

    if (_isHardwareKeyboardAvailable)
    {
      v34 = _UIKeyboardLog();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 136315138;
        *&buf[4] = "[_UIKeyboardStateManager initWithPresentationDelegateView:forCustomInputView:]";
        _os_log_impl(&dword_188A29000, v34, OS_LOG_TYPE_DEFAULT, "%s UIDevice.currentDevice._hardwareKeyboardAvailable = YES", buf, 0xCu);
      }

      [(_UIKeyboardStateManager *)v8 updateHardwareKeyboardExclusivityIdentifier];
    }

    v35 = +[UIDevice currentDevice];
    -[_UIKeyboardStateManager setHardwareKeyboardAttached:](v8, "setHardwareKeyboardAttached:", [v35 _isHardwareKeyboardAvailable]);

    m_hardwareKeyboardAttached = v8->m_hardwareKeyboardAttached;
    if (m_hardwareKeyboardAttached)
    {
      v8->m_textInputSource = 4;
    }

    [(TIKeyboardState *)v8->m_keyboardState setHardwareKeyboardMode:m_hardwareKeyboardAttached];
    ++v8->m_updatingPreferences;
    v8->m_shiftLockedEnabled = [(_UIKeyboardStateManager *)v8 shiftLockPreference];
    v8->m_doubleSpacePeriodPreference = [(_UIKeyboardStateManager *)v8 doubleSpacePeriodPreference];
    UIKeyboardAutocorrectSpellingFlag = 0;
    inputModePreference = [(_UIKeyboardStateManager *)v8 inputModePreference];
    UIKeyboardSetActiveInputModes(inputModePreference);

    uILanguagePreference = [(_UIKeyboardStateManager *)v8 UILanguagePreference];
    v39 = [uILanguagePreference copy];
    v40 = UIKeyboardCurrentUILanguage;
    UIKeyboardCurrentUILanguage = v39;

    if (![(_UIKeyboardStateManager *)v8 forCustomInputView])
    {
      [(_UIKeyboardStateManager *)v8 setInputModeFromPreferences];
    }

    --v8->m_updatingPreferences;
    if (m_hardwareKeyboardAttached)
    {
      v41 = UIApp;
      v42 = +[UIKeyboardInputModeController sharedInputModeController];
      hardwareInputMode = [v42 hardwareInputMode];
      automaticHardwareLayout = [hardwareInputMode automaticHardwareLayout];
      [v41 setHardwareKeyboardLayoutName:automaticHardwareLayout];

      [(_UIKeyboardStateManager *)v8 setCapsLockIfNeeded];
    }

    [(_UIKeyboardStateManager *)v8 setServiceRole:+[UIKeyboard serviceRole]];
    WeakRetained = objc_loadWeakRetained(&v8->_presentationDelegate);
    [WeakRetained updateLayout];

    v46 = objc_alloc_init(UIKBAutofillController);
    m_autofillController = v8->m_autofillController;
    v8->m_autofillController = v46;

    v8->m_pendingAutofillIndex = -1;
    v48 = [objc_alloc(MEMORY[0x1E695DF90]) initWithCapacity:5];
    m_hardwareKeyDownCodeToEventMap = v8->m_hardwareKeyDownCodeToEventMap;
    v8->m_hardwareKeyDownCodeToEventMap = v48;

    v50 = objc_alloc_init(UIKeyboardInputModeIndicatorController);
    inputModeIndicatorController = v8->_inputModeIndicatorController;
    v8->_inputModeIndicatorController = v50;

    [(UIKeyboardInputModeIndicatorController *)v8->_inputModeIndicatorController setDelegate:v8];
    v52 = +[UIKeyboardPreferencesController sharedPreferencesController];
    preferencesActions = [v52 preferencesActions];
    v54 = [preferencesActions valueForPreferenceKey:@"kbUserDidPath"];
    v8->m_numCPwords = [v54 integerValue];

    v8->m_lastChooseSupplementalItemToInsertCallbackIdentifier = 0;
    v8->m_initializationDone = 1;
    v55 = objc_loadWeakRetained(&v8->_presentationDelegate);
    [v55 _setSafeAreaInsetsFrozen:1];

    v56 = objc_alloc_init(UIKBInputDelegateManager);
    [(_UIKeyboardStateManager *)v8 setInputDelegateManager:v56];

    inputDelegateManager = [(_UIKeyboardStateManager *)v8 inputDelegateManager];
    [inputDelegateManager setKeyboardStateDelegate:v8];

    v58 = -*MEMORY[0x1E695E460];
    [(_UIKeyboardStateManager *)v8 setDeleteWordLastDelete:v58];
    v8->m_autoDeleteLastDelete = v58;
    v59 = [[_UISmartReplyFeedbackManager alloc] initWithKeyboardStateManagerDelegate:v8];
    [(_UIKeyboardStateManager *)v8 setSmartReplyFeedbackManager:v59];

    v8->m_userInteraction = 10;
    v60 = v8;
  }

  return v8;
}

- (void)presentationDelegateWillDetach
{
  [(_UIKeyboardStateManager *)self detach];

  objc_storeWeak(&self->_presentationDelegate, 0);
}

- (void)detach
{
  v10 = *MEMORY[0x1E69E9840];
  if (os_variant_has_internal_diagnostics())
  {
    v6 = _UIKeyboardExtendedLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      id = self->_id;
      v8 = 134217984;
      v9 = id;
      _os_log_impl(&dword_188A29000, v6, OS_LOG_TYPE_DEFAULT, "KeyboardStateManager detach (id=%ld)", &v8, 0xCu);
    }
  }

  v3 = sharedInputManagerMux();
  responseDelegate = [v3 responseDelegate];

  if (responseDelegate == self)
  {
    [v3 setResponseDelegate:0];
  }

  currentRunLoop = [MEMORY[0x1E695DFD0] currentRunLoop];
  [currentRunLoop cancelPerformSelectorsWithTarget:self];

  [(_UIKeyboardStateManager *)self clearTimers];
  [(_UIKeyboardStateManager *)self clearRemoteTextInputPartner];
}

- (void)dealloc
{
  v30 = *MEMORY[0x1E69E9840];
  if (os_variant_has_internal_diagnostics())
  {
    v25 = _UIKeyboardExtendedLog();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      id = self->_id;
      *buf = 134217984;
      v29 = id;
      _os_log_impl(&dword_188A29000, v25, OS_LOG_TYPE_DEFAULT, "KeyboardStateManager dealloc (id=%ld)", buf, 0xCu);
    }
  }

  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  v3InputDelegate = [inputDelegate inputDelegate];

  if (v3InputDelegate == self)
  {
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate2 setInputDelegate:0];
  }

  asyncInputDelegate = [(_UIKeyboardStateManager *)self asyncInputDelegate];

  if (asyncInputDelegate)
  {
    asyncInputDelegate2 = [(_UIKeyboardStateManager *)self asyncInputDelegate];
    asyncSystemInputDelegate = [asyncInputDelegate2 asyncSystemInputDelegate];

    if (asyncSystemInputDelegate == self)
    {
      asyncInputDelegate3 = [(_UIKeyboardStateManager *)self asyncInputDelegate];
      [asyncInputDelegate3 setAsyncSystemInputDelegate:0];
    }
  }

  webInputDelegate = [(_UIKeyboardStateManager *)self webInputDelegate];

  if (webInputDelegate)
  {
    webInputDelegate2 = [(_UIKeyboardStateManager *)self webInputDelegate];
    asyncInputDelegate4 = [webInputDelegate2 asyncInputDelegate];

    if (asyncInputDelegate4 == self)
    {
      webInputDelegate3 = [(_UIKeyboardStateManager *)self webInputDelegate];
      [webInputDelegate3 setAsyncInputDelegate:0];
    }
  }

  self->m_inDealloc = 1;
  [(_UIKeyboardStateManager *)self detach];
  m_previousInputString = self->m_previousInputString;
  self->m_previousInputString = 0;

  m_previousGlobeKeyEvent = self->m_previousGlobeKeyEvent;
  self->m_previousGlobeKeyEvent = 0;

  [(_UIKeyboardStateManager *)self setChangedDelegate:0];
  [(_UIKeyboardStateManager *)self removeAutocorrectPromptAndCandidateList];
  [(_UIKeyboardStateManager *)self removeTextChoicePrompt];
  [(_UIKeyboardStateManager *)self removeTextChoiceUnderlines];
  [(_UIActionWhenIdle *)self->m_deferredDidSetDelegateAction invalidate];
  [(_UIActionWhenIdle *)self->m_delayedCandidateRequest invalidate];
  v16 = +[_UIKeyboardTextSelectionGestureController sharedInstance];
  delegate = [v16 delegate];

  if (delegate == self)
  {
    v18 = +[_UIKeyboardTextSelectionGestureController sharedInstance];
    [v18 setDelegate:0];
  }

  v19 = +[_UIKeyboardBasedTextSelectionGestureController sharedInstance];
  delegate2 = [v19 delegate];

  if (delegate2 == self)
  {
    v21 = +[_UIKeyboardBasedTextSelectionGestureController sharedInstance];
    [v21 setDelegate:0];
  }

  [(_UIKeyboardImplProxy *)self->m_implProxy setDelegate:0];
  characterRectsForCharacterRange = self->_characterRectsForCharacterRange;
  self->_characterRectsForCharacterRange = 0;

  deferredUpdateTask = self->_deferredUpdateTask;
  self->_deferredUpdateTask = 0;

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained resetIsPhysicallyAttachedHardwareKeyboard];

  v27.receiver = self;
  v27.super_class = _UIKeyboardStateManager;
  [(_UIKeyboardStateManager *)&v27 dealloc];
}

- (BOOL)shouldSwitchFromInputManagerMode:(id)mode toInputMode:(id)inputMode
{
  modeCopy = mode;
  inputModeCopy = inputMode;
  v7 = inputModeCopy;
  if (!modeCopy)
  {
    goto LABEL_6;
  }

  identifier = [inputModeCopy identifier];
  if (![identifier hasPrefix:@"emoji"])
  {

    goto LABEL_6;
  }

  HasWordNgramModelForInputMode = UIKeyboardHasWordNgramModelForInputMode();

  if ((HasWordNgramModelForInputMode & 1) == 0)
  {
LABEL_6:
    v10 = 1;
    goto LABEL_7;
  }

  v10 = 0;
LABEL_7:

  return v10;
}

- (void)refreshKeyboardStateUpdatingSecureCandidateRenderTraits:(BOOL)traits
{
  traitsCopy = traits;
  [(_UIKeyboardStateManager *)self updateInputManagerMode];
  layoutState = [(_UIKeyboardStateManager *)self layoutState];
  [(TIKeyboardState *)self->m_keyboardState setLayoutState:layoutState];

  currentCandidate = [(UIKeyboardCandidateList *)self->m_candidateList currentCandidate];
  [(TIKeyboardState *)self->m_keyboardState setCurrentCandidate:currentCandidate];

  [(TIKeyboardState *)self->m_keyboardState setNeedsCandidateMetadata:1];
  [(TIKeyboardState *)self->m_keyboardState setShortcutConversionEnabled:[(UITextInputTraits *)self->m_traits shortcutConversionType]!= 1];
  [(TIKeyboardState *)self->m_keyboardState setCandidateSelectionPredictionEnabled:[(_UIKeyboardStateManager *)self candidateSelectionPredictionForTraits]];
  v7 = [MEMORY[0x1E69D96E0] traitsForUITextInputTraits:self->m_traits];
  [(TIKeyboardState *)self->m_keyboardState setTextInputTraits:v7];

  if ([(_UIKeyboardStateManager *)self isPredictionViewControllerVisible]|| [(_UIKeyboardStateManager *)self prewarmsPredictiveCandidates])
  {
    [(TIKeyboardState *)self->m_keyboardState setAutocorrectionListUIDisplayed:1];
  }

  else
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    -[TIKeyboardState setAutocorrectionListUIDisplayed:](self->m_keyboardState, "setAutocorrectionListUIDisplayed:", [autocorrectionController hasActiveObservers]);
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  -[TIKeyboardState setFloatingKeyboardMode:](self->m_keyboardState, "setFloatingKeyboardMode:", [objc_opt_class() isFloating]);

  v10 = objc_loadWeakRetained(&self->_presentationDelegate);
  -[TIKeyboardState setLandscapeOrientation:](self->m_keyboardState, "setLandscapeOrientation:", ([v10 _keyboardOrientation] - 3) < 2);

  [(TIKeyboardState *)self->m_keyboardState setOmitEmojiCandidates:[(_UIKeyboardStateManager *)self showingEmojiSearch]];
  if (!+[UIKeyboard isKeyboardProcess])
  {
    textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
    acceptsPayloads = [textInputTraits acceptsPayloads];

    m_keyboardState = self->m_keyboardState;
    if (acceptsPayloads)
    {
      v14 = +[UITextInputPayloadController sharedInstance];
      supportedPayloadIds = [v14 supportedPayloadIds];
      [(TIKeyboardState *)m_keyboardState setSupportedPayloadIds:supportedPayloadIds];
    }

    else
    {
      [(TIKeyboardState *)self->m_keyboardState setSupportedPayloadIds:0];
    }
  }

  responderForSendCurrentLocation = [(_UIKeyboardStateManager *)self responderForSendCurrentLocation];
  [(TIKeyboardState *)self->m_keyboardState setCanSendCurrentLocation:responderForSendCurrentLocation != 0];

  v17 = objc_loadWeakRetained(&self->_presentationDelegate);
  -[TIKeyboardState setLongPredictionListEnabled:](self->m_keyboardState, "setLongPredictionListEnabled:", [v17 accessibilityUsesExtendedKeyboardPredictionsEnabled]);

  [(TIKeyboardState *)self->m_keyboardState setNeedAutofill:[(_UIKeyboardStateManager *)self needAutofillLogin]];
  [(TIKeyboardState *)self->m_keyboardState setNeedOneTimeCodeAutofill:[(_UIKeyboardStateManager *)self needOneTimeCodeAutofill]];
  if (objc_opt_respondsToSelector())
  {
    [(TIKeyboardState *)self->m_keyboardState setNeedCellularAutofill:[(_UIKeyboardStateManager *)self needCellularAutofill]];
  }

  [(TIKeyboardState *)self->m_keyboardState setAutofillMode:[(_UIKeyboardStateManager *)self needAutofill]];
  [(TIKeyboardState *)self->m_keyboardState setAutofillSubMode:[(_UIKeyboardStateManager *)self autofillSubMode]];
  inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];

  if (inlineTextCompletionController)
  {
    [(TIKeyboardState *)self->m_keyboardState setInlineCompletionEnabled:[(_UIKeyboardStateManager *)self isInlineCompletionEnabled]];
  }

  if (traitsCopy)
  {
    updateSecureCandidateRenderTraits = [(_UIKeyboardStateManager *)self updateSecureCandidateRenderTraits];
    [(TIKeyboardState *)self->m_keyboardState setSecureCandidateRenderTraits:updateSecureCandidateRenderTraits];
  }

  if (self->m_keyboardDelegateStateNeedsRefresh)
  {
    v20 = +[UIKeyboardInputModeController sharedInputModeController];
    -[TIKeyboardState setIsScreenLocked:](self->m_keyboardState, "setIsScreenLocked:", [v20 deviceStateIsLocked]);

    self->m_keyboardDelegateStateNeedsRefresh = 0;
  }

  v21 = objc_loadWeakRetained(&self->_presentationDelegate);
  -[TIKeyboardState setEmojiPopoverMode:](self->m_keyboardState, "setEmojiPopoverMode:", [v21 isEmojiPopoverPresented]);

  [(TIKeyboardState *)self->m_keyboardState setEmojiSearchMode:[(_UIKeyboardStateManager *)self showingEmojiSearch]];
  [(_UIKeyboardStateManager *)self _updateCanSuggestSupplementalItemsForCurrentSelection];
  imageSuggestionEnabled = [(_UIKeyboardStateManager *)self imageSuggestionEnabled];
  v23 = self->m_keyboardState;

  [(TIKeyboardState *)v23 setImageSuggestionEnabled:imageSuggestionEnabled];
}

- (id)textContentTypeForCurrentInputDelegate
{
  textContentType = [(UITextInputTraits *)self->m_traits textContentType];
  v4 = textContentType;
  if (textContentType)
  {
    v5 = textContentType;
  }

  else
  {
    autofillController = [(_UIKeyboardStateManager *)self autofillController];
    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
    v5 = [autofillController textContentTypeForInputDelegate:delegateAsResponder];
  }

  return v5;
}

- (BOOL)textInputTraitsNeedAutofillExcludeOneTimeCodeAndContact
{
  textInputTraitsNeedAutofill = [(_UIKeyboardStateManager *)self textInputTraitsNeedAutofill];
  if (textInputTraitsNeedAutofill)
  {
    if ([(_UIKeyboardStateManager *)self textInputTraitsNeedOneTimeCode])
    {
      LOBYTE(textInputTraitsNeedAutofill) = 0;
    }

    else
    {
      LOBYTE(textInputTraitsNeedAutofill) = ![(_UIKeyboardStateManager *)self textInputTraitsNeedContactAutoFill];
    }
  }

  return textInputTraitsNeedAutofill;
}

- (BOOL)textInputTraitsNeedSignup
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  v3 = [autofillController delegateNeedsAutofillMode] == 2;

  return v3;
}

- (BOOL)textInputTraitsNeedOneTimeCode
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  v3 = [autofillController delegateNeedsAutofillMode] == 8;

  return v3;
}

- (BOOL)textInputTraitsNeedContactAutoFill
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  if ([autofillController delegateNeedsAutofillMode] == 5)
  {
    v4 = 1;
  }

  else
  {
    autofillController2 = [(_UIKeyboardStateManager *)self autofillController];
    if ([autofillController2 delegateNeedsAutofillMode] == 6)
    {
      v4 = 1;
    }

    else
    {
      autofillController3 = [(_UIKeyboardStateManager *)self autofillController];
      v4 = [autofillController3 delegateNeedsAutofillMode] == 7;
    }
  }

  return v4;
}

- (id)_contentsOfUsernameField
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  autofillGroup = [autofillController autofillGroup];
  v4 = [autofillGroup objectForKey:@"username"];

  if ([v4 conformsToProtocol:&unk_1EFE8B2D0])
  {
    v5 = v4;
    beginningOfDocument = [v5 beginningOfDocument];
    endOfDocument = [v5 endOfDocument];
    v8 = [v5 textRangeFromPosition:beginningOfDocument toPosition:endOfDocument];
    v9 = [v5 textInRange:v8];
  }

  else
  {
    v9 = 0;
  }

  return v9;
}

- (void)generateAutofillCandidateByAddingTask:(BOOL)task
{
  taskCopy = task;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  keyboardLayoutIsInAnotherProcess = [WeakRetained keyboardLayoutIsInAnotherProcess];

  if ((keyboardLayoutIsInAnotherProcess & 1) == 0)
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    v8 = [(_UIKeyboardStateManager *)self suppressOptOutASPCandidateUpdateForDelegate:inputDelegate];

    if (!v8)
    {
      aBlock[0] = MEMORY[0x1E69E9820];
      aBlock[1] = 3221225472;
      aBlock[2] = __65___UIKeyboardStateManager_generateAutofillCandidateByAddingTask___block_invoke;
      aBlock[3] = &unk_1E70FD058;
      aBlock[4] = self;
      v9 = _Block_copy(aBlock);
      if (taskCopy)
      {
        if (qword_1ED49CF48 != -1)
        {
          dispatch_once(&qword_1ED49CF48, &__block_literal_global_110);
        }

        taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
        [taskQueue addTask:v9 breadcrumb:qword_1ED49CF40];
      }

      else
      {
        if (qword_1ED49CF58 != -1)
        {
          dispatch_once(&qword_1ED49CF58, &__block_literal_global_427);
        }

        taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
        [taskQueue performTask:v9 breadcrumb:qword_1ED49CF50];
      }
    }
  }
}

- (void)refreshSecureCandidatesIfNecessary
{
  self->m_keyboardDelegateStateNeedsRefresh = 1;
  if ([(_UIKeyboardStateManager *)self usesCandidateSelection]&& [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet slottedCandidatesCount])
  {

    [(_UIKeyboardStateManager *)self setCandidates:0];
  }
}

- (void)setPendingAutofillIndex:(int64_t)index
{
  if ((index & 0x8000000000000000) == 0 && self->m_cachedAutofillMode == 1)
  {
    self->m_pendingAutofillIndex = index;
    [(_UIKeyboardStateManager *)self generateAutofillCandidate];
  }
}

- (BOOL)preferFallbackAutofillGroup
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  preferFallbackAutofillGroup = [autofillController preferFallbackAutofillGroup];

  return preferFallbackAutofillGroup;
}

- (int64_t)needAutofillCandidate:(id)candidate
{
  candidateCopy = candidate;
  if (candidateCopy)
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    v6 = inputSystemSourceSession;
    if (inputSystemSourceSession)
    {
      documentTraits = [inputSystemSourceSession documentTraits];
      autofillMode = [documentTraits autofillMode];

      if (autofillMode != 1)
      {
LABEL_20:

        goto LABEL_21;
      }

      documentTraits2 = [v6 documentTraits];
      textInputTraits = [documentTraits2 textInputTraits];
      if ([textInputTraits secureTextEntry])
      {
        isSecureTextEntry = [(UITextInputTraits *)self->m_traits isSecureTextEntry];

        if (isSecureTextEntry)
        {
          autofillController = [(_UIKeyboardStateManager *)self autofillController];
          autofillGroup = [autofillController autofillGroup];
          [autofillGroup setObject:candidateCopy forKey:@"password"];

          goto LABEL_18;
        }
      }

      else
      {
      }

      documentTraits3 = [v6 documentTraits];
      textInputTraits2 = [documentTraits3 textInputTraits];
      textContentType = [textInputTraits2 textContentType];
      v21 = [textContentType isEqual:@"username"];

      if (!v21)
      {
LABEL_19:
        autofillMode = 1;
        goto LABEL_20;
      }

      autofillController = [(_UIKeyboardStateManager *)self autofillController];
      autofillGroup2 = [autofillController autofillGroup];
      [autofillGroup2 setObject:candidateCopy forKey:@"username"];

LABEL_18:
      goto LABEL_19;
    }

    if (self->m_isAutofilling || [(_UIKeyboardStateManager *)self delegateAlreadyInAutofillGroup])
    {
      if ((self->m_cachedAutofillMode & 0xFFFFFFFFFFFFFFFELL) == 2)
      {
        autofillController2 = [(_UIKeyboardStateManager *)self autofillController];
        delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
        self->m_autofillSubMode = [autofillController2 needAutofillCandidate:candidateCopy delegateAsResponder:delegateAsResponder keyboardState:self->m_keyboardState];
      }

      delegateAlreadyInAutofillGroup = [(_UIKeyboardStateManager *)self delegateAlreadyInAutofillGroup];
      v17 = 288;
      if (delegateAlreadyInAutofillGroup)
      {
        v17 = 296;
      }

      autofillMode = *(&self->super.isa + v17);
      goto LABEL_20;
    }

    if ((self->m_cachedAutofillMode & 0xFFFFFFFFFFFFFFFELL) != 2)
    {
LABEL_36:
      autofillController3 = [(_UIKeyboardStateManager *)self autofillController];
      delegateAsResponder2 = [(_UIKeyboardStateManager *)self delegateAsResponder];
      autofillMode = [autofillController3 needAutofillCandidate:candidateCopy delegateAsResponder:delegateAsResponder2 keyboardState:self->m_keyboardState];

      self->m_autofillSubMode = autofillMode;
      if (autofillMode == 8)
      {
        if ([(_UIKeyboardStateManager *)self dontPushOneTimeCode])
        {
          autofillMode = 0;
        }

        else
        {
          autofillMode = 8;
        }
      }

      autofillController4 = [(_UIKeyboardStateManager *)self autofillController];
      autofillGroup3 = [autofillController4 autofillGroup];
      [autofillGroup3 objectForKey:@"password"];

      if ([(_UIKeyboardStateManager *)self delegateAlreadyInAutofillGroup])
      {
        self->m_groupAutofillMode = autofillMode;
      }

      goto LABEL_20;
    }

    autofillController5 = [(_UIKeyboardStateManager *)self autofillController];
    autofillGroup4 = [autofillController5 autofillGroup];
    v26 = [autofillGroup4 objectForKey:@"new-password"];

    if (!v26)
    {
      autofillController6 = [(_UIKeyboardStateManager *)self autofillController];
      autofillGroup5 = [autofillController6 autofillGroup];
      v26 = [autofillGroup5 objectForKey:@"username"];
    }

    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        superview = [candidateCopy superview];
        superview2 = [v26 superview];
        v31 = superview2;
        if (superview == superview2)
        {
        }

        else
        {
          v32 = [(_UIKeyboardStateManager *)self isMemberOfPossibleAutofillGroup:candidateCopy];

          if (!v32)
          {
            goto LABEL_35;
          }
        }

        autofillController7 = [(_UIKeyboardStateManager *)self autofillController];
        autofillGroup6 = [autofillController7 autofillGroup];
        if (!autofillGroup6)
        {
          goto LABEL_34;
        }

        v35 = autofillGroup6;
        autofillController8 = [(_UIKeyboardStateManager *)self autofillController];
        autofillController9 = [(_UIKeyboardStateManager *)self autofillController];
        autofillGroup7 = [autofillController9 autofillGroup];
        v39 = [autofillController8 containsUsernamePasswordPairsInAutofillGroup:autofillGroup7];

        if (v39)
        {
          autofillController7 = [(_UIKeyboardStateManager *)self autofillController];
          autofillGroup8 = [autofillController7 autofillGroup];
          autofillController10 = [(_UIKeyboardStateManager *)self autofillController];
          [autofillController10 setFallbackAutofillGroup:autofillGroup8];

LABEL_34:
        }
      }
    }

LABEL_35:

    goto LABEL_36;
  }

  autofillMode = 0;
LABEL_21:

  return autofillMode;
}

- (BOOL)isMemberOfAutofillGroup:(id)group
{
  if (!group)
  {
    return 0;
  }

  groupCopy = group;
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  autofillGroup = [autofillController autofillGroup];

  v7 = [autofillGroup objectForKey:@"username"];
  v8 = [autofillGroup objectForKey:@"password"];
  v9 = [autofillGroup objectForKey:@"new-password"];

  v12 = v7 == groupCopy || v8 == groupCopy || v9 == groupCopy;
  return v12;
}

- (BOOL)isMemberOfPossibleAutofillGroup:(id)group
{
  v29 = *MEMORY[0x1E69E9840];
  groupCopy = group;
  if ([(_UIKeyboardStateManager *)self isMemberOfAutofillGroup:groupCopy])
  {
    LOBYTE(v5) = 1;
  }

  else
  {
    autofillController = [(_UIKeyboardStateManager *)self autofillController];
    autofillGroup = [autofillController autofillGroup];
    v8 = [autofillGroup objectForKey:@"UIAutofillPossibleRespondersKey"];

    if (AutoFillUILibraryCore() && !v8)
    {
      autofillController2 = [(_UIKeyboardStateManager *)self autofillController];
      autofillGroup2 = [autofillController2 autofillGroup];
      v11 = getAFUIAutoFillPossibleRespondersKey();
      v8 = [autofillGroup2 objectForKey:v11];
    }

    if (v8 && [v8 count] && !-[_UIKeyboardStateManager preferFallbackAutofillGroup](self, "preferFallbackAutofillGroup") || (-[_UIKeyboardStateManager autofillController](self, "autofillController"), v12 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v12, "fallbackAutofillGroup"), v13 = objc_claimAutoreleasedReturnValue(), v13, v12, !v13))
    {
      v16 = v8;
    }

    else
    {
      autofillController3 = [(_UIKeyboardStateManager *)self autofillController];
      fallbackAutofillGroup = [autofillController3 fallbackAutofillGroup];
      v16 = [fallbackAutofillGroup objectForKey:@"UIAutofillPossibleRespondersKey"];

      if (AutoFillUILibraryCore() && !v16)
      {
        autofillController4 = [(_UIKeyboardStateManager *)self autofillController];
        fallbackAutofillGroup2 = [autofillController4 fallbackAutofillGroup];
        v19 = getAFUIAutoFillPossibleRespondersKey();
        v16 = [fallbackAutofillGroup2 objectForKey:v19];
      }
    }

    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v20 = v16;
    v5 = [v20 countByEnumeratingWithState:&v24 objects:v28 count:16];
    if (v5)
    {
      v21 = *v25;
      while (2)
      {
        for (i = 0; i != v5; ++i)
        {
          if (*v25 != v21)
          {
            objc_enumerationMutation(v20);
          }

          if (*(*(&v24 + 1) + 8 * i) == groupCopy)
          {
            LOBYTE(v5) = 1;
            goto LABEL_24;
          }
        }

        v5 = [v20 countByEnumeratingWithState:&v24 objects:v28 count:16];
        if (v5)
        {
          continue;
        }

        break;
      }
    }

LABEL_24:
  }

  return v5;
}

- (void)clearAutofillGroup
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  [autofillController clearAutofillGroup];

  self->m_cachedAutofillMode = 0;
}

- (void)removeASPVisualEffectsIfNecessary:(id)necessary
{
  necessaryCopy = necessary;
  if (self->m_cachedAutofillMode)
  {
    v7 = necessaryCopy;
    v5 = dyld_program_sdk_at_least();
    necessaryCopy = v7;
    if ((v5 & 1) == 0)
    {
      autofillController = [(_UIKeyboardStateManager *)self autofillController];
      [autofillController clearASPVisualEffectsInTextField:v7];

      necessaryCopy = v7;
    }
  }
}

- (void)handleAutofillCredentialSaveIfNeeded:(id)needed
{
  neededCopy = needed;
  preferFallbackAutofillGroup = [(_UIKeyboardStateManager *)self preferFallbackAutofillGroup];
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  v6 = autofillController;
  if (preferFallbackAutofillGroup)
  {
    [autofillController fallbackAutofillGroup];
  }

  else
  {
    [autofillController autofillGroup];
  }
  v7 = ;

  autofillController2 = [(_UIKeyboardStateManager *)self autofillController];
  v9 = [autofillController2 containsUsernamePasswordPairsInAutofillGroup:v7];

  if (v9)
  {
    v10 = [v7 objectForKey:@"UIAutofillASPOptInKey"];
    if (AutoFillUILibraryCore() && !v10)
    {
      v11 = getAFUIAutoFillASPOptInKey();
      v10 = [v7 objectForKey:v11];
    }

    bOOLValue = [v10 BOOLValue];
    autofillController3 = [(_UIKeyboardStateManager *)self autofillController];
    [autofillController3 handleAutofillCredentialSaveIfNeeded:neededCopy fromASP:bOOLValue];
  }

  else
  {
    [(_UIKeyboardStateManager *)self clearAutofillGroup];
  }
}

- (BOOL)suppressOptOutASPCandidateUpdateForDelegate:(id)delegate
{
  m_cachedAutofillMode = self->m_cachedAutofillMode;
  delegateCopy = delegate;
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  autofillGroup = [autofillController autofillGroup];
  v8 = [autofillGroup objectForKey:@"password"];

  autofillController2 = [(_UIKeyboardStateManager *)self autofillController];
  autofillGroup2 = [autofillController2 autofillGroup];
  v11 = [autofillGroup2 objectForKey:@"UIAutofillASPOptInKey"];

  if (AutoFillUILibraryCore() && !v11)
  {
    autofillController3 = [(_UIKeyboardStateManager *)self autofillController];
    autofillGroup3 = [autofillController3 autofillGroup];
    v14 = getAFUIAutoFillASPOptInKey();
    v11 = [autofillGroup3 objectForKey:v14];
  }

  v15 = (v8 == delegateCopy) & ([v11 BOOLValue] ^ 1);
  v16 = (m_cachedAutofillMode & 0xFFFFFFFFFFFFFFFELL) == 2 && v15;

  return v16;
}

- (void)textWillScroll
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained textWillScroll];
}

- (void)textDidScroll
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained textDidScroll];
}

- (void)updatePreferencesWithBlock:(id)block
{
  v9 = *MEMORY[0x1E69E9840];
  blockCopy = block;
  if (pthread_main_np() != 1)
  {
    if (os_variant_has_internal_diagnostics())
    {
      v6 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        v7 = 136315138;
        v8 = "[_UIKeyboardStateManager updatePreferencesWithBlock:]";
        _os_log_fault_impl(&dword_188A29000, v6, OS_LOG_TYPE_FAULT, "Unsupported use of %s off the main thread", &v7, 0xCu);
      }
    }

    else
    {
      v5 = *(__UILogGetCategoryCachedImpl("Assert", &updatePreferencesWithBlock____s_category) + 8);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v7 = 136315138;
        v8 = "[_UIKeyboardStateManager updatePreferencesWithBlock:]";
        _os_log_impl(&dword_188A29000, v5, OS_LOG_TYPE_ERROR, "Unsupported use of %s off the main thread", &v7, 0xCu);
      }
    }
  }

  if (blockCopy)
  {
    ++self->m_updatingPreferences;
    blockCopy[2](blockCopy);
    --self->m_updatingPreferences;
  }
}

- (void)updateDefaultsWithResults:(id)results
{
  v17 = *MEMORY[0x1E69E9840];
  resultsCopy = results;
  if (pthread_main_np() != 1)
  {
    if (os_variant_has_internal_diagnostics())
    {
      v11 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      {
        *buf = 136315138;
        v16 = "[_UIKeyboardStateManager updateDefaultsWithResults:]";
        _os_log_fault_impl(&dword_188A29000, v11, OS_LOG_TYPE_FAULT, "Unsupported use %s off the main thread", buf, 0xCu);
      }
    }

    else
    {
      v10 = *(__UILogGetCategoryCachedImpl("Assert", &updateDefaultsWithResults____s_category) + 8);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *buf = 136315138;
        v16 = "[_UIKeyboardStateManager updateDefaultsWithResults:]";
        _os_log_impl(&dword_188A29000, v10, OS_LOG_TYPE_ERROR, "Unsupported use %s off the main thread", buf, 0xCu);
      }
    }
  }

  if (![(_UIKeyboardStateManager *)self updatingPreferences])
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    if ([WeakRetained isUsingDictationLayout])
    {
    }

    else
    {
      v6 = objc_loadWeakRetained(&self->_presentationDelegate);
      isDictationPopoverPresented = [v6 isDictationPopoverPresented];

      if ((isDictationPopoverPresented & 1) == 0)
      {
        ++self->m_updatingPreferences;
        isInHardwareKeyboardMode = [(_UIKeyboardStateManager *)self isInHardwareKeyboardMode];
        v9 = dispatch_get_global_queue(0, 0);
        block[0] = MEMORY[0x1E69E9820];
        block[1] = 3221225472;
        block[2] = __53___UIKeyboardStateManager_updateDefaultsWithResults___block_invoke;
        block[3] = &unk_1E70FD0C8;
        v14 = isInHardwareKeyboardMode;
        block[4] = self;
        v13 = resultsCopy;
        dispatch_async(v9, block);
      }
    }
  }
}

- (BOOL)keyboardIsInPencilTextInputMode
{
  delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  if ([delegateAsResponder _suppressSoftwareKeyboard])
  {
    v4 = [(_UIKeyboardStateManager *)self _textInputSourceForDelegate:delegateAsResponder]== 3;
  }

  else
  {
    v4 = 0;
  }

  return v4;
}

- (int64_t)_textInputSourceForDelegate:(id)delegate
{
  delegateCopy = delegate;
  if (objc_opt_respondsToSelector())
  {
    _textInputSource = [delegateCopy _textInputSource];
  }

  else
  {
    _textInputSource = 0;
  }

  return _textInputSource;
}

- (void)performReturn
{
  delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  _responderForEditing = [delegateAsResponder _responderForEditing];

  if ((objc_opt_respondsToSelector() & 1) != 0 && [_responderForEditing returnKeyGoesToNextResponder])
  {
    _nextKeyResponder = [_responderForEditing _nextKeyResponder];
    if ([_responderForEditing _suppressSoftwareKeyboard])
    {
      [_nextKeyResponder _setSuppressSoftwareKeyboard:1];
    }

    if (objc_opt_respondsToSelector() & 1) != 0 && (objc_opt_respondsToSelector())
    {
      [_nextKeyResponder set_textInputSource:{objc_msgSend(_responderForEditing, "_textInputSource")}];
    }

    [_nextKeyResponder becomeFirstResponder];
  }

  else
  {
    _nextKeyResponder = objc_alloc_init(MEMORY[0x1E69D9638]);
    [_nextKeyResponder insertText:@"\n"];
    [(_UIKeyboardStateManager *)self performKeyboardOutputAsInputViewControllerOutput:_nextKeyResponder textInputSource:3];
  }
}

- (void)performDelete
{
  v3 = objc_alloc_init(MEMORY[0x1E69D9638]);
  [v3 deleteBackward];
  [(_UIKeyboardStateManager *)self performKeyboardOutputAsInputViewControllerOutput:v3 textInputSource:3];
}

- (void)performOperations:(id)operations withTextInputSource:(int64_t)source
{
  m_textInputSource = self->m_textInputSource;
  self->m_textInputSource = source;
  (*(operations + 2))(operations, a2);
  self->m_textInputSource = m_textInputSource;
}

- (void)updateTextInputKeyboardSource
{
  v12[2] = *MEMORY[0x1E69E9840];
  m_textInputSource = self->m_textInputSource;
  if (m_textInputSource)
  {
    v4 = +[UIKeyboardSceneDelegate automaticTextInputSourceCache];
    lastEventSource = [v4 lastEventSource];

    if ((m_textInputSource - 4) < 5 || m_textInputSource == 1)
    {
      if (lastEventSource == 3)
      {
        v7 = 15;
      }

      else
      {
        v7 = 5;
      }
    }

    else if (m_textInputSource == 3 && (lastEventSource - 1) < 8)
    {
      v7 = qword_18A678E80[lastEventSource - 1];
    }

    else
    {
      v7 = 5;
    }

    v11[0] = @"inputSource";
    v8 = [MEMORY[0x1E696AD98] numberWithInteger:m_textInputSource];
    v11[1] = @"options";
    v12[0] = v8;
    v9 = [MEMORY[0x1E696AD98] numberWithUnsignedInteger:v7];
    v12[1] = v9;
    v10 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v12 forKeys:v11 count:2];
    [(_UIKeyboardStateManager *)self updateTextInputKeyboardSource:v10];
  }
}

- (void)updateTextInputKeyboardSource:(id)source
{
  sourceCopy = source;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateTextInputKeyboardSource:sourceCopy];
}

- (unint64_t)_updateAutocorrectionPreferenceForTraitsWithCurrentPreference:(BOOL)preference
{
  if (!preference)
  {
    v4 = UIKeyboardGetCurrentInputMode();
    v5 = UIKeyboardAutocorrectionRequiredForInputMode(v4);

    if (!v5)
    {
      return 0;
    }
  }

  if ([(UITextInputTraits *)self->m_traits isSecureTextEntry]|| [(_UIKeyboardStateManager *)self keyboardIsKeyPad])
  {
    return 0;
  }

  if ([(_UIKeyboardStateManager *)self showingEmojiSearch])
  {
    return 1;
  }

  autocorrectionType = [(UITextInputTraits *)self->m_traits autocorrectionType];
  result = 1;
  if (autocorrectionType && autocorrectionType != 2)
  {
    if (autocorrectionType != 1)
    {
      return 0;
    }

    v8 = UIKeyboardGetCurrentInputMode();
    v9 = UIKeyboardAutocorrectionRequiredForInputMode(v8);

    if ((v9 & 1) == 0)
    {
      if (_os_feature_enabled_impl() && [(UITextInputTraits *)self->m_traits allowsSuggestionsOnlyMode]&& !+[UIKeyboard isSpotlight])
      {
        return 2;
      }

      return 0;
    }

    return 1;
  }

  return result;
}

- (BOOL)smartInsertDeleteIsEnabled
{
  if ([(UITextInputTraits *)self->m_traits smartInsertDeleteType]== 1 || [(UITextInputTraits *)self->m_traits isSecureTextEntry]|| [(_UIKeyboardStateManager *)self disableSmartInsertDelete])
  {
    v3 = 0;
  }

  else
  {
    v5 = +[UIKeyboardPreferencesController sharedPreferencesController];
    preferencesActions = [v5 preferencesActions];
    v3 = [preferencesActions BOOLForPreferenceKey:*MEMORY[0x1E69D9950]];
  }

  return v3 & 1;
}

- (TISmartPunctuationController)smartPunctuationController
{
  smartPunctuationOptions = [(TISmartPunctuationController *)self->m_smartPunctuationController smartPunctuationOptions];

  if (!smartPunctuationOptions)
  {
    v4 = +[UIKeyboardInputModeController sharedInputModeController];
    currentInputMode = [v4 currentInputMode];
    primaryLanguage = [currentInputMode primaryLanguage];
    [(_UIKeyboardStateManager *)self updateSmartPunctuationOptionsForLocaleIdentifier:primaryLanguage];
  }

  m_smartPunctuationController = self->m_smartPunctuationController;

  return m_smartPunctuationController;
}

- (BOOL)keyboardsExpandedPreference
{
  v2 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v2 preferencesActions];
  v4 = [preferencesActions BOOLForPreferenceKey:*MEMORY[0x1E69D96F0]];

  return v4;
}

- (BOOL)automaticMinimizationEnabled
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  automaticMinimizationEnabled = [WeakRetained automaticMinimizationEnabled];

  return automaticMinimizationEnabled;
}

- (void)setAutomaticMinimizationEnabled:(BOOL)enabled
{
  enabledCopy = enabled;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained setAutomaticMinimizationEnabled:enabledCopy];
}

- (void)updateInputModeLastChosenPreference
{
  if (!self->m_updatingPreferences)
  {
    self->m_updatingPreferences = 1;
    [(_UIKeyboardStateManager *)self autocapitalizationPreference];
    [(_UIKeyboardStateManager *)self doubleSpacePeriodPreference];
    [(_UIKeyboardStateManager *)self shiftLockPreference];
    self->m_updatingPreferences = 0;
  }
}

- (id)hardwareKeyboardsSeenPreference
{
  v2 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v2 preferencesActions];
  v4 = [preferencesActions valueForPreferenceKey:*MEMORY[0x1E69D9848]];

  return v4;
}

- (void)setHardwareKeyboardsSeenPreference:(id)preference
{
  self->m_updatingPreferences = 1;
  preferenceCopy = preference;
  v5 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v5 preferencesActions];
  [preferencesActions setValue:preferenceCopy forPreferenceKey:*MEMORY[0x1E69D9848]];

  self->m_updatingPreferences = 0;
}

- (void)setInputMode:(id)mode userInitiated:(BOOL)initiated
{
  initiatedCopy = initiated;
  v28[2] = *MEMORY[0x1E69E9840];
  modeCopy = mode;
  if (!+[UIKeyboard usesInputSystemUI])
  {
    goto LABEL_19;
  }

  v7 = +[UIKeyboardSceneDelegate automaticKeyboardArbiterClient];
  handlingRemoteEvent = [v7 handlingRemoteEvent];

  if ((handlingRemoteEvent & 1) == 0)
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    v27[0] = @"inputMode";
    v27[1] = @"isUserInitiated";
    v28[0] = modeCopy;
    v10 = [MEMORY[0x1E696AD98] numberWithBool:initiatedCopy];
    v28[1] = v10;
    v11 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v28 forKeys:v27 count:2];
    [remoteTextInputPartner forwardKeyboardInputMode:v11];
  }

  v12 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v12 currentInputMode];
  identifier = [currentInputMode identifier];
  v15 = [identifier isEqualToString:@"autofillsignup"];

  if (v15)
  {
LABEL_19:
    if (-[_UIKeyboardStateManager floatingForced](self, "floatingForced") && [modeCopy hasPrefix:@"emoji"])
    {
      [(_UIKeyboardStateManager *)self updateAssistantView];
    }

    v20 = MEMORY[0x1E69E9820];
    v21 = 3221225472;
    v22 = __54___UIKeyboardStateManager_setInputMode_userInitiated___block_invoke;
    v23 = &unk_1E70FD0F0;
    selfCopy = self;
    v25 = modeCopy;
    v26 = initiatedCopy;
    v16 = _Block_copy(&v20);
    v17 = [(_UIKeyboardStateManager *)self inputDelegateManager:v20];
    insideKeyInputDelegateCall = [v17 insideKeyInputDelegateCall];

    if (insideKeyInputDelegateCall)
    {
      if (qword_1ED49CF68 != -1)
      {
        dispatch_once(&qword_1ED49CF68, &__block_literal_global_464);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      [taskQueue addTask:v16 breadcrumb:qword_1ED49CF60];
    }

    else
    {
      if (qword_1ED49CF78 != -1)
      {
        dispatch_once(&qword_1ED49CF78, &__block_literal_global_470);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      [taskQueue performSingleTask:v16 breadcrumb:qword_1ED49CF70];
    }
  }
}

- (void)setInputMode:(id)mode userInitiated:(BOOL)initiated updateIndicator:(BOOL)indicator executionContext:(id)context
{
  indicatorCopy = indicator;
  initiatedCopy = initiated;
  contextCopy = context;
  v11 = [UIKeyboardInputMode keyboardInputModeWithIdentifier:mode];
  self->m_didAutomaticallyInsertSpaceBeforeChangingInputMode = self->m_didAutomaticallyInsertSpace;
  self->_skipRecomputeInputMode = [(TIKeyboardState *)self->m_keyboardState emojiSearchMode]^ 1;
  [(_UIKeyboardStateManager *)self setKeyboardInputMode:v11 userInitiated:initiatedCopy updateIndicator:indicatorCopy executionContext:contextCopy];

  self->_skipRecomputeInputMode = 0;
}

- (void)_setKeyboardInputMode:(id)mode userInitiated:(BOOL)initiated force:(BOOL)force
{
  modeCopy = mode;
  if (qword_1ED49CF88 != -1)
  {
    dispatch_once(&qword_1ED49CF88, &__block_literal_global_475);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v12[0] = MEMORY[0x1E69E9820];
  v12[1] = 3221225472;
  v12[2] = __69___UIKeyboardStateManager__setKeyboardInputMode_userInitiated_force___block_invoke_3;
  v12[3] = &unk_1E70FD118;
  v12[4] = self;
  v13 = modeCopy;
  initiatedCopy = initiated;
  forceCopy = force;
  v10 = qword_1ED49CF80;
  v11 = modeCopy;
  [taskQueue performSingleTask:v12 breadcrumb:v10];
}

- (void)postInputViewControllerShouldUpdateNotification:(id)notification
{
  notificationCopy = notification;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained postInputViewControllerShouldUpdateNotification:notificationCopy];
}

- (void)reloadCurrentInputMode
{
  v4 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v4 currentInputMode];
  [(_UIKeyboardStateManager *)self _setKeyboardInputMode:currentInputMode userInitiated:0 force:1];
}

- (void)setKeyboardInputMode:(id)mode userInitiated:(BOOL)initiated updateIndicator:(BOOL)indicator executionContext:(id)context
{
  indicatorCopy = indicator;
  initiatedCopy = initiated;
  modeCopy = mode;
  contextCopy = context;
  if (![modeCopy isEmojiInputMode] || !self->m_delegateSupportsImagePaste)
  {
    goto LABEL_7;
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  if ([objc_opt_class() isSplit])
  {

LABEL_7:
    [(_UIKeyboardStateManager *)self _setKeyboardInputMode:modeCopy userInitiated:initiatedCopy updateIndicator:indicatorCopy force:0 executionContext:contextCopy];
    goto LABEL_8;
  }

  v13 = +[UIKeyboardMediaController sharedKeyboardMediaController];
  shouldPrefetchRemoteView = [v13 shouldPrefetchRemoteView];

  if (!shouldPrefetchRemoteView)
  {
    goto LABEL_7;
  }

  [contextCopy returnExecutionToParent];
  v15 = UIKeyboardGetCurrentInputMode();
  v16 = +[UIKeyboardMediaController sharedKeyboardMediaController];
  v18[0] = MEMORY[0x1E69E9820];
  v18[1] = 3221225472;
  v18[2] = __95___UIKeyboardStateManager_setKeyboardInputMode_userInitiated_updateIndicator_executionContext___block_invoke;
  v18[3] = &unk_1E70F43C8;
  v19 = v15;
  selfCopy = self;
  v21 = modeCopy;
  v22 = initiatedCopy;
  v23 = indicatorCopy;
  v17 = v15;
  [v16 prefetchRecentsViewControllerWithCompletion:v18];

LABEL_8:
}

- (void)_setKeyboardInputMode:(id)mode userInitiated:(BOOL)initiated updateIndicator:(BOOL)indicator force:(BOOL)force executionContext:(id)context
{
  forceCopy = force;
  indicatorCopy = indicator;
  initiatedCopy = initiated;
  modeCopy = mode;
  contextCopy = context;
  identifier = [modeCopy identifier];
  v15 = [identifier length];

  if (!v15)
  {
    goto LABEL_3;
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  _rootInputWindowController = [WeakRetained _rootInputWindowController];
  isRotating = [_rootInputWindowController isRotating];

  if (isRotating)
  {
    goto LABEL_3;
  }

  v95 = indicatorCopy;
  v19 = off_1E70EA000;
  v20 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v20 currentInputMode];
  if ([currentInputMode isEqual:modeCopy] && objc_msgSend(modeCopy, "isDisplayed"))
  {
    v22 = initiatedCopy;
    v23 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [v23 layout];
    if (layout)
    {
      v25 = !forceCopy;
    }

    else
    {
      v91 = objc_loadWeakRetained(&self->_presentationDelegate);
      v25 = (([v91 keyboardLayoutIsInAnotherProcess] & 1) != 0 || objc_msgSend(modeCopy, "isExtensionInputMode")) && !forceCopy;
    }

    initiatedCopy = v22;
    v19 = off_1E70EA000;
    if (v25)
    {
      goto LABEL_3;
    }
  }

  else
  {
  }

  v26 = +[UIKeyboardInputMode dictationInputMode];
  v27 = v26;
  if (v26 != modeCopy)
  {

    goto LABEL_13;
  }

  v28 = +[UIKeyboardInputMode dictationInputMode];
  isCurrentDictationLanguageOnDevice = [v28 isCurrentDictationLanguageOnDevice];

  if (!isCurrentDictationLanguageOnDevice)
  {
LABEL_13:
    if (+[UIDictationController isRunning])
    {
      activeDictationLanguage = [(_UIKeyboardStateManager *)self activeDictationLanguage];
      if (activeDictationLanguage)
      {
        dictationLanguage = [modeCopy dictationLanguage];
        v32 = [activeDictationLanguage isEqual:dictationLanguage];

        if ((v32 & 1) == 0)
        {
          [(_UIKeyboardStateManager *)self setSyncingDictationLanguageForInputModeSwitch:1];
          v33 = +[UIDictationController sharedInstance];
          [v33 setReasonType:16];

          v34 = +[UIDictationController activeInstance];
          [v34 cancelDictation];

          if (qword_1ED49CFA8 != -1)
          {
            dispatch_once(&qword_1ED49CFA8, &__block_literal_global_485);
          }

          taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
          v106[0] = MEMORY[0x1E69E9820];
          v106[1] = 3221225472;
          v106[2] = __102___UIKeyboardStateManager__setKeyboardInputMode_userInitiated_updateIndicator_force_executionContext___block_invoke_3;
          v106[3] = &unk_1E70FD058;
          v106[4] = self;
          v36 = [taskQueue scheduleTask:v106 timeInterval:0 repeats:qword_1ED49CFA0 breadcrumb:0.5];
        }
      }
    }

    self->_isSettingExtensionInputMode = [modeCopy isExtensionInputMode];
    self->_needsUpdateAssistantView = 0;
    [(_UIKeyboardStateManager *)self cleanUpBeforeInputModeSwitch];
    self->_isSettingExtensionInputMode = 0;
    v37 = objc_loadWeakRetained(&self->_presentationDelegate);
    _showsScribbleIconsInAssistantView = [v37 _showsScribbleIconsInAssistantView];

    if (_showsScribbleIconsInAssistantView)
    {
      languageWithRegion = [modeCopy languageWithRegion];
      [UIAssistantBarButtonItemProvider setScribbleLanguageIdentifier:languageWithRegion];
    }

    sharedInputModeController = [(__objc2_class *)v19[13] sharedInputModeController];
    [sharedInputModeController setLastInputModeSwitchTriggeredByASCIIToggle:0];

    self->m_predictionType = 0;
    if ([modeCopy isEmojiInputMode])
    {
      v41 = objc_loadWeakRetained(&self->_presentationDelegate);
      canPresentEmojiPopover = [v41 canPresentEmojiPopover];

      if (canPresentEmojiPopover)
      {
        v43 = objc_loadWeakRetained(&self->_presentationDelegate);
        isEmojiPopoverPresented = [v43 isEmojiPopoverPresented];

        if ((isEmojiPopoverPresented & 1) == 0)
        {
          if (+[UIKeyboard usesInputSystemUI])
          {
            block[0] = MEMORY[0x1E69E9820];
            block[1] = 3221225472;
            block[2] = __102___UIKeyboardStateManager__setKeyboardInputMode_userInitiated_updateIndicator_force_executionContext___block_invoke_4;
            block[3] = &unk_1E70F3590;
            block[4] = self;
            dispatch_async(MEMORY[0x1E69E96A0], block);
          }

          else
          {
            v92 = objc_loadWeakRetained(&self->_presentationDelegate);
            [v92 presentEmojiPopoverViaTrigger:@"other" completion:0];
          }
        }

        goto LABEL_3;
      }
    }

    defaultCenter = [MEMORY[0x1E696AD88] defaultCenter];
    [defaultCenter postNotificationName:@"UITextInputCurrentInputModeWillChangeNotification" object:0];

    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];

    if (!forwardingInputDelegate)
    {
      defaultCenter2 = [MEMORY[0x1E696AD88] defaultCenter];
      [defaultCenter2 postNotificationName:@"UITextInputWillPersistFindUINotification" object:0];
    }

    sharedInputModeController2 = [(__objc2_class *)v19[13] sharedInputModeController];
    currentInputMode2 = [sharedInputModeController2 currentInputMode];

    identifier2 = [modeCopy identifier];
    UIKeyboardSetCurrentInputMode(identifier2);

    if (self->_needsUpdateAssistantView)
    {
      [(_UIKeyboardStateManager *)self updateAssistantView];
    }

    v93 = initiatedCopy;
    if ([modeCopy isExtensionInputMode])
    {
      primaryLanguage = [modeCopy primaryLanguage];
      lowercaseString = [primaryLanguage lowercaseString];
      v54 = [lowercaseString hasPrefix:@"und"];

      if (v54)
      {
        isDefaultRightToLeft = [modeCopy isDefaultRightToLeft];
        [(_UIKeyboardStateManager *)self updateSmartPunctuationOptionsForLocaleIdentifier:@"en"];
      }

      else
      {
        v56 = MEMORY[0x1E695DF58];
        primaryLanguage2 = [modeCopy primaryLanguage];
        isDefaultRightToLeft = [v56 characterDirectionForLanguage:primaryLanguage2] == 2;

        primaryLanguage3 = [modeCopy primaryLanguage];
        [(_UIKeyboardStateManager *)self updateSmartPunctuationOptionsForLocaleIdentifier:primaryLanguage3];
      }

      [(_UIKeyboardStateManager *)self setInputManagerFromCurrentInputMode];
      if (initiatedCopy)
      {
        v59 = +[UIPeripheralHost sharedInstance];
        [v59 setDocumentInputMode:currentInputMode2];
      }
    }

    else
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        isDefaultRightToLeft = [currentInputMode2 isDefaultRightToLeft];
      }

      else
      {
        isDefaultRightToLeft = [modeCopy isDefaultRightToLeft];
        primaryLanguage4 = [modeCopy primaryLanguage];
        [(_UIKeyboardStateManager *)self updateSmartPunctuationOptionsForLocaleIdentifier:primaryLanguage4];

        v61 = +[UIKeyboardInputMode dictationInputMode];
        [v61 setTriggeringTouch:0];

        [(_UIKeyboardStateManager *)self setInputManagerFromCurrentInputMode];
      }
    }

    v62 = isDefaultRightToLeft;
    m_currentDirection = self->m_currentDirection;
    v94 = m_currentDirection != isDefaultRightToLeft;
    if (m_currentDirection != isDefaultRightToLeft)
    {
      self->m_currentDirection = isDefaultRightToLeft;
    }

    if ([modeCopy isExtensionInputMode])
    {
      sharedInputModeController3 = [(__objc2_class *)v19[13] sharedInputModeController];
      currentSystemInputMode = [sharedInputModeController3 currentSystemInputMode];
      identifier3 = [currentSystemInputMode identifier];
      v67 = UIKeyboardGetKBStarKeyboard(identifier3, [(UITextInputTraits *)self->m_traits keyboardType]);

      subtrees = [v67 subtrees];
      firstObject = [subtrees firstObject];
      self->m_usesAutoShiftFor3PK = [firstObject BOOLForProperty:@"autoshift"];

      [(_UIKeyboardStateManager *)self updateShiftState];
      [(_UIKeyboardStateManager *)self setShouldSkipCandidateSelection:0];

LABEL_49:
      self->m_keyboardDelegateStateNeedsRefresh = 1;
      [(_UIKeyboardStateManager *)self postInputViewControllerShouldUpdateNotification:modeCopy];
      if (modeCopy)
      {
        if (+[UIKeyboard isKeyboardProcess])
        {
          identifier4 = [modeCopy identifier];
          v76 = [identifier4 isEqualToString:@"autofillsignup"];

          if ((v76 & 1) == 0)
          {
            inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
            v78 = inputSystemSourceSession;
            if (inputSystemSourceSession)
            {
              textOperations = [inputSystemSourceSession textOperations];
              [textOperations setCustomInfoType:0x1EFB7CA70];
              identifier5 = [modeCopy identifier];
              [textOperations setCustomInfo:identifier5];

              buildInputSourceState = [(_UIKeyboardStateManager *)self buildInputSourceState];
              [textOperations setInputSourceState:buildInputSourceState];

              identifier6 = [modeCopy identifier];
              inputSourceState = [textOperations inputSourceState];
              [inputSourceState setInputMode:identifier6];

              [v78 flushOperations];
            }
          }
        }
      }

      if (self->m_updatingPreferences)
      {
        if (self->m_inputManagerState || (UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) != 1)
        {
          [(_UIKeyboardStateManager *)self finishSetKeyboardInputMode:modeCopy previousInputMode:currentInputMode2 didChangeDirection:m_currentDirection != v62];
          [contextCopy returnExecutionToParent];
LABEL_64:

          goto LABEL_4;
        }

        v96[0] = MEMORY[0x1E69E9820];
        v96[1] = 3221225472;
        v96[2] = __102___UIKeyboardStateManager__setKeyboardInputMode_userInitiated_updateIndicator_force_executionContext___block_invoke_6;
        v96[3] = &unk_1E70FD168;
        v96[4] = self;
        v97 = modeCopy;
        v98 = currentInputMode2;
        v99 = v94;
        v84 = [contextCopy childWithContinuation:v96];
        [(_UIKeyboardStateManager *)self syncInputManagerToKeyboardStateWithExecutionContext:v84];

        v85 = v97;
      }

      else
      {
        if (v93)
        {
          self->m_updatingPreferences = 1;
          v86 = +[UIKeyboardPreferencesController sharedPreferencesController];
          preferencesActions = [v86 preferencesActions];
          identifier7 = [modeCopy identifier];
          [preferencesActions setLanguageAwareInputModeLastUsed:identifier7];

          v89 = +[UIKeyboardInputModeController sharedInputModeController];
          [v89 _inputModeChangedWhileContextTracked];

          self->m_updatingPreferences = 0;
        }

        [(_UIKeyboardStateManager *)self setSuppressUpdateAssistantView:1];
        [(_UIKeyboardStateManager *)self setIsCallingTextChangedDuringInputModeSwitch:1];
        v100[0] = MEMORY[0x1E69E9820];
        v100[1] = 3221225472;
        v100[2] = __102___UIKeyboardStateManager__setKeyboardInputMode_userInitiated_updateIndicator_force_executionContext___block_invoke_5;
        v100[3] = &unk_1E70FD140;
        v100[4] = self;
        v101 = modeCopy;
        v102 = currentInputMode2;
        v103 = v94;
        v104 = v93;
        v90 = [contextCopy childWithContinuation:v100];
        [(_UIKeyboardStateManager *)self textChanged:self executionContext:v90];

        [(_UIKeyboardStateManager *)self setSuppressUpdateAssistantView:0];
        [(_UIKeyboardStateManager *)self setIsCallingTextChangedDuringInputModeSwitch:0];

        v85 = v101;
      }

      goto LABEL_64;
    }

    v70 = objc_loadWeakRetained(&self->_presentationDelegate);
    [v70 setAnimateUpdateBars:0];

    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager2 keyInputDelegate];
    if (keyInputDelegate)
    {

      v73 = v95;
    }

    else
    {
      isFrontBoard = [UIApp isFrontBoard];

      v73 = v95;
      if (isFrontBoard)
      {
LABEL_48:
        self->m_usesAutoShiftFor3PK = 1;
        goto LABEL_49;
      }
    }

    [(_UIKeyboardStateManager *)self reinitializeAfterInputModeSwitch:v73];
    goto LABEL_48;
  }

LABEL_3:
  [contextCopy returnExecutionToParent];
LABEL_4:
}

- (void)cleanUpBeforeInputModeSwitch
{
  self->_receivedCandidatesInCurrentInputMode = 0;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate = [inputDelegateManager keyInputDelegate];

  if (keyInputDelegate)
  {
    if (-[_UIKeyboardStateManager _hasMarkedText](self, "_hasMarkedText") || (-[_UIKeyboardStateManager autocorrectionController](self, "autocorrectionController"), v5 = objc_claimAutoreleasedReturnValue(), [v5 autocorrection], v6 = objc_claimAutoreleasedReturnValue(), v6, v5, v6))
    {
      [(_UIKeyboardStateManager *)self setSuppressUpdateAssistantView:1];
      [(_UIKeyboardStateManager *)self acceptAutocorrectionWithCompletionHandler:0];
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager2 unmarkText];

      [(_UIKeyboardStateManager *)self setSuppressUpdateAssistantView:0];
    }

    [(_UIKeyboardStateManager *)self setShiftLocked:0];
  }

  [(_UIKeyboardStateManager *)self clearInput];
  [(_UIKeyboardStateManager *)self removeAutocorrectPromptAndCandidateList];
  self->m_acceptingCandidate = 0;
}

- (void)updateSmartPunctuationOptionsForLocaleIdentifier:(id)identifier
{
  v4 = MEMORY[0x1E69D96A8];
  v5 = [MEMORY[0x1E695DF58] localeWithLocaleIdentifier:identifier];
  v12 = [v4 smartPunctuationOptionsForLocale:v5];

  [(TISmartPunctuationController *)self->m_smartPunctuationController setSmartPunctuationOptions:v12];
  v6 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v6 preferencesActions];
  v8 = [preferencesActions BOOLForPreferenceKey:*MEMORY[0x1E69D9950]];

  autoQuoteType = [(TISmartPunctuationController *)self->m_smartPunctuationController autoQuoteType];
  v10 = ((v8 & 1) != 0 || autoQuoteType == 1) && [(UITextInputTraits *)self->m_traits smartQuotesType]!= 1;
  [(TISmartPunctuationController *)self->m_smartPunctuationController setSmartQuotesEnabled:v10];
  if (v8)
  {
    v11 = [(UITextInputTraits *)self->m_traits smartDashesType]!= 1;
  }

  else
  {
    v11 = 0;
  }

  [(TISmartPunctuationController *)self->m_smartPunctuationController setSmartDashesEnabled:v11];
}

- (void)reinitializeAfterInputModeSwitch:(BOOL)switch
{
  switchCopy = switch;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained reinitializeAfterInputModeSwitch:switchCopy];
}

- (BOOL)canPresentPressAndHoldPopover:(id)popover
{
  popoverCopy = popover;
  _modifiedInput = [popoverCopy _modifiedInput];
  v5 = ([_modifiedInput _isDelete] & 1) == 0 && +[UIPressAndHoldPopoverController canPresentPressAndHoldPopoverForEvent:](UIPressAndHoldPopoverController, "canPresentPressAndHoldPopoverForEvent:", popoverCopy);

  return v5;
}

- (void)handleAutoFillContactPopoverCommand
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained handleAutoFillContactPopoverCommand];
}

- (void)handleAutoFillCreditCardPopoverCommand
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained handleAutoFillCreditCardPopoverCommand];
}

- (void)handleAutoFillPasswordPopoverCommand
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained handleAutoFillPasswordPopoverCommand];
}

- (void)handleAutoFillContactDetected
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained handleAutoFillContactDetected];
}

- (void)handleAutoFillCreditCardDetected
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained handleAutoFillCreditCardDetected];
}

- (void)handleAutoFillPasswordDetected
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained handleAutoFillPasswordDetected];
}

- (void)_performTextOperationsForAutoFill:(id)fill
{
  fillCopy = fill;
  if (+[UIKeyboard inputUIOOP])
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    inputSystemSourceSession = [inputDelegateManager inputSystemSourceSession];

    textOperations = [inputSystemSourceSession textOperations];
    textToAssert = [fillCopy textToAssert];
    [textOperations setTextToAssert:textToAssert];

    keyboardOutput = [fillCopy keyboardOutput];
    insertionText = [keyboardOutput insertionText];
    keyboardOutput2 = [textOperations keyboardOutput];
    [keyboardOutput2 setInsertionText:insertionText];

    keyboardOutput3 = [fillCopy keyboardOutput];

    customInfo = [keyboardOutput3 customInfo];
    keyboardOutput4 = [textOperations keyboardOutput];
    [keyboardOutput4 setCustomInfo:customInfo];

    [inputSystemSourceSession flushOperations];
  }

  else
  {
    textToAssert2 = [fillCopy textToAssert];
    [(_UIKeyboardStateManager *)self assertTextForRemoteDocument:textToAssert2 withSelectionDelta:0 updatingSelection:0, 0];

    inputSystemSourceSession = [fillCopy keyboardOutput];

    [(_UIKeyboardStateManager *)self performKeyboardOutput:inputSystemSourceSession checkingDelegate:1];
  }
}

- (BOOL)keyboardInputModeIndicatorControllerShouldPresentIndicator:(id)indicator
{
  indicatorCopy = indicator;
  if (!qword_1ED49CFB0 && qword_1ED49CFB8 != -1)
  {
    dispatch_once(&qword_1ED49CFB8, &__block_literal_global_501);
  }

  if ([(_UIKeyboardStateManager *)self isInHardwareKeyboardMode])
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    textInputDelegate = [inputDelegateManager textInputDelegate];
    if (textInputDelegate && UIKeyboardHasMultipleActiveLinguisticNonExtensionInputModes())
    {
      v7 = qword_1ED49CFB0;
      v8 = UIKeyboardGetCurrentInputMode();
      v9 = [v7 containsObject:v8] ^ 1;
    }

    else
    {
      LOBYTE(v9) = 0;
    }
  }

  else
  {
    LOBYTE(v9) = 0;
  }

  return v9;
}

- (void)keyboardInputModeIndicatorControllerPresentIndicator:(id)indicator reason:(id)reason
{
  reasonCopy = reason;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained setInputModeAssertionWithReason:reasonCopy];
}

- (void)keyboardInputModeIndicatorControllerDismissIndicator:(id)indicator
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained clearInputModeAssertion];

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  selectionDisplayInteraction = [inputDelegateManager selectionDisplayInteraction];
  [selectionDisplayInteraction clearInputModeCursorAssertion];
}

- (void)finishSetKeyboardInputMode:(id)mode previousInputMode:(id)inputMode didChangeDirection:(BOOL)direction
{
  directionCopy = direction;
  modeCopy = mode;
  inputModeCopy = inputMode;
  if ([modeCopy isExtensionInputMode])
  {
    [(_UIKeyboardStateManager *)self finishSetExtensionInputMode:modeCopy didChangeDirection:directionCopy];
  }

  else
  {
    [(_UIKeyboardStateManager *)self finishSetInputMode:modeCopy didChangeDirection:directionCopy];
  }

  if ([modeCopy isDisplayed])
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [WeakRetained layout];
    if (layout)
    {

LABEL_8:
      v12 = +[UIKeyboardSceneDelegate automaticKeyboardArbiterClient];
      inputWindowRootViewController = [v12 inputWindowRootViewController];
      placement = [inputWindowRootViewController placement];

      if ([placement showsKeyboard] & 1) != 0 || (objc_msgSend(placement, "isUndocked"))
      {
        v15 = 1;
      }

      else
      {
        if ([modeCopy showSWLayoutWithHWKeyboard])
        {
          v16 = objc_loadWeakRetained(&self->_presentationDelegate);
          [v16 showKeyboard];
          goto LABEL_18;
        }

        v15 = 0;
      }

      if (!self->m_hardwareKeyboardAttached || (v15 & [(_UIKeyboardStateManager *)self automaticMinimizationEnabled]) != 1 || [(_UIKeyboardStateManager *)self floatingForced]|| [(_UIKeyboardStateManager *)self showingEmojiSearch])
      {
        goto LABEL_19;
      }

      v16 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v16 hideKeyboard];
LABEL_18:

LABEL_19:
      goto LABEL_20;
    }

    isExtensionInputMode = [modeCopy isExtensionInputMode];

    if (isExtensionInputMode)
    {
      goto LABEL_8;
    }
  }

LABEL_20:
  if ([(_UIKeyboardStateManager *)self textInputTraitsNeedAutofill]&& (UIKeyboardPredictionEnabledForCurrentInputMode() & 1) == 0 && ![(_UIKeyboardStateManager *)self usesCandidateSelection])
  {
    [(_UIKeyboardStateManager *)self generateAutofillCandidate];
  }

  self->m_didAutomaticallyInsertSpace = self->m_didAutomaticallyInsertSpaceBeforeChangingInputMode;
  if (self->m_hardwareKeyboardAttached)
  {
    v17 = UIApp;
    v18 = +[UIKeyboardInputModeController sharedInputModeController];
    hardwareInputMode = [v18 hardwareInputMode];
    automaticHardwareLayout = [hardwareInputMode automaticHardwareLayout];
    [v17 setHardwareKeyboardLayoutName:automaticHardwareLayout];
  }

  v21 = +[UIPeripheralHost sharedInstance];
  inputViews = [v21 inputViews];
  inputView = [inputViews inputView];
  _rootInputWindowController = [inputView _rootInputWindowController];
  [_rootInputWindowController updateKeyboardDockViewVisibility];

  [(_UIKeyboardStateManager *)self touchUpdateLastUsedInputModeAction];
  if (![(_UIKeyboardStateManager *)self showingEmojiSearch])
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager keyInputDelegate];
    if (keyInputDelegate)
    {
    }

    else
    {
      isFrontBoard = [UIApp isFrontBoard];

      if (isFrontBoard)
      {
        goto LABEL_31;
      }
    }

    [(_UIKeyboardStateManager *)self updateInputAssistantButtonItems];
  }

LABEL_31:
  [_UIKeyboardUsageTracking keyboardSetToInputMode:modeCopy fromPrevious:inputModeCopy];
}

- (void)finishSetExtensionInputMode:(id)mode didChangeDirection:(BOOL)direction
{
  directionCopy = direction;
  if ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) == 1)
  {
    v6 = +[UIPeripheralHost sharedInstance];
    inputViews = [v6 inputViews];
    [inputViews refreshPresentation];
  }

  if (self->m_shouldUpdateCacheOnInputModesChange)
  {
    v8 = +[UIKeyboardCache sharedInstance];
    v9 = UIKeyboardActiveInputModes;
    [v8 updateCacheForInputModes:v9];
  }

  if (directionCopy)
  {

    [(_UIKeyboardStateManager *)self setInitialDirection];
  }
}

- (void)finishSetInputMode:(id)mode didChangeDirection:(BOOL)direction
{
  directionCopy = direction;
  modeCopy = mode;
  [(_UIKeyboardStateManager *)self updateTextCandidateView];
  self->m_keyboardDelegateStateNeedsRefresh = 1;
  if ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) == 1)
  {
    v7 = +[UIPeripheralHost sharedInstance];
    inputViews = [v7 inputViews];
    [inputViews refreshPresentation];
  }

  v9 = [(_UIKeyboardStateManager *)self autocorrectionPreferenceForTraits]!= 0;
  [(TIKeyboardState *)self->m_keyboardState setAutocorrectionEnabled:v9];
  [(_UIKeyboardStateManager *)self setAutocorrectSpellingEnabled:v9];
  identifierWithLayouts = [modeCopy identifierWithLayouts];
  v11 = TIStatisticGetKeyForInputMode();
  TIStatisticScalarSetBoolean();

  identifierWithLayouts2 = [modeCopy identifierWithLayouts];

  v13 = TIStatisticGetKeyForInputMode();
  [(_UIKeyboardStateManager *)self predictionFromPreference];
  TIStatisticScalarSetBoolean();

  if ([(UITextInputTraits *)self->m_traits learnsCorrections])
  {
    m_correctionLearningAllowed = self->m_correctionLearningAllowed;
  }

  else
  {
    m_correctionLearningAllowed = 0;
  }

  [(TIKeyboardState *)self->m_keyboardState setWordLearningEnabled:m_correctionLearningAllowed];
  [(TIKeyboardState *)self->m_keyboardState setInlineCompletionEnabled:[(_UIKeyboardStateManager *)self isInlineCompletionEnabled]];
  if (self->m_shouldUpdateCacheOnInputModesChange)
  {
    v15 = +[UIKeyboardCache sharedInstance];
    v16 = UIKeyboardActiveInputModes;
    [v15 updateCacheForInputModes:v16];
  }

  if (directionCopy)
  {

    [(_UIKeyboardStateManager *)self setInitialDirection];
  }
}

- (void)prepareKeyboardInputModeFromPreferences:(id)preferences
{
  preferencesCopy = preferences;
  if (!preferencesCopy)
  {
    v5 = +[UIKeyboardInputModeController sharedInputModeController];
    activeInputModes = [v5 activeInputModes];
    firstObject = [activeInputModes firstObject];

    preferencesCopy = firstObject;
  }

  v7 = MEMORY[0x1E695DF58];
  v12 = preferencesCopy;
  primaryLanguage = [preferencesCopy primaryLanguage];
  v9 = [v7 characterDirectionForLanguage:primaryLanguage] == 2;

  self->m_currentDirection = v9;
  identifier = [v12 identifier];
  UIKeyboardSetCurrentInputMode(identifier);

  [(_UIKeyboardStateManager *)self setInputManagerFromCurrentInputMode];
}

- (void)setKeyboardInputModeFromPreferences:(id)preferences
{
  if (preferences)
  {

    [_UIKeyboardStateManager setKeyboardInputMode:"setKeyboardInputMode:userInitiated:" userInitiated:?];
  }

  else
  {
    v6 = +[UIKeyboardInputModeController sharedInputModeController];
    activeInputModes = [v6 activeInputModes];
    firstObject = [activeInputModes firstObject];
    [(_UIKeyboardStateManager *)self setKeyboardInputMode:firstObject userInitiated:1];
  }
}

- (void)updateInputModeIndicatorOnSingleKeyOnly:(BOOL)only preserveIfPossible:(BOOL)possible
{
  possibleCopy = possible;
  onlyCopy = only;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateInputModeIndicatorOnSingleKeyOnly:onlyCopy preserveIfPossible:possibleCopy];
}

- (void)setInputModeToNextInPreferredListWithExecutionContext:(id)context
{
  contextCopy = context;
  v5 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v5 currentInputMode];

  if (os_variant_has_internal_diagnostics() && (+[UIKeyboardInputMode dictationInputMode](UIKeyboardInputMode, "dictationInputMode"), v17 = objc_claimAutoreleasedReturnValue(), v18 = [v17 isEqual:currentInputMode], v17, v18))
  {
    v19 = +[UIKeyboardInputMode dictationInputMode];
    currentInputModeForDictation = [v19 currentInputModeForDictation];
  }

  else
  {
    currentInputModeForDictation = 0;
  }

  if ([UIKeyboardActiveUserSelectableInputModes count] <= 1 && -[UITextInputTraits keyboardType](self->m_traits, "keyboardType") == 122)
  {
    v8 = [UIKeyboardInputMode keyboardInputModeWithIdentifier:@"emoji@sw=Emoji"];
  }

  else
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [WeakRetained layout];
    keyplaneContainsEmojiKey = [layout keyplaneContainsEmojiKey];

    v12 = +[UIKeyboardInputModeController sharedInputModeController];
    v8 = [v12 nextInputModeInPreferenceListForTraits:self->m_traits updatePreference:1 skipEmoji:keyplaneContainsEmojiKey];

    currentInputModeForDictation = v12;
  }

  identifier = [v8 identifier];
  v14 = +[UIKBAnalyticsDispatcher sharedInstance];
  [v14 setUpdatedInputMode:identifier];

  v20 = MEMORY[0x1E69E9820];
  v21 = 3221225472;
  v22 = __81___UIKeyboardStateManager_setInputModeToNextInPreferredListWithExecutionContext___block_invoke;
  v23 = &unk_1E70FD1B8;
  selfCopy = self;
  v25 = currentInputMode;
  v15 = currentInputMode;
  v16 = [contextCopy childWithContinuation:&v20];

  [(_UIKeyboardStateManager *)self setKeyboardInputMode:v8 userInitiated:1 updateIndicator:1 executionContext:v16, v20, v21, v22, v23, selfCopy];
}

- (void)finishSetInputModeToNextInPreferredListWithExecutionContext:(id)context withPreviousInputMode:(id)mode
{
  modeCopy = mode;
  contextCopy = context;
  [(_UIKeyboardStateManager *)self updateInputModeLastChosenPreference];
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained showInternationalKeyIntroductionIfNeededWithPreviousInputMode:modeCopy];

  [contextCopy returnExecutionToParent];
}

- (void)setInputModeToNextASCIICapableInPreferredList
{
  v6 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v6 currentInputMode];
  if (([currentInputMode defaultLayoutIsASCIICapable] & 1) == 0)
  {
    activeInputModes = [v6 activeInputModes];
    v5 = [v6 nextInputModeFromList:activeInputModes withFilter:4 withTraits:0];

    currentInputMode = v5;
  }

  if (!currentInputMode)
  {
    currentInputMode = +[UIKeyboardInputMode intlInputMode];
  }

  [(_UIKeyboardStateManager *)self setKeyboardInputMode:currentInputMode userInitiated:0];
}

- (BOOL)isRotating
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  isRotating = [WeakRetained isRotating];

  return isRotating;
}

- (void)setCorrectionLearningAllowed:(BOOL)allowed
{
  allowedCopy = allowed;
  m_correctionLearningAllowed = self->m_correctionLearningAllowed;
  self->m_correctionLearningAllowed = allowed;
  if (![(UITextInputTraits *)self->m_traits isSecureTextEntry])
  {
    m_traits = self->m_traits;
    if (allowedCopy)
    {
      v7 = [(UITextInputTraits *)m_traits copy];
      [(_UIKeyboardStateManager *)self takeTextInputTraitsFromDelegate];
      [(UITextInputTraits *)v7 setLearnsCorrections:[(UITextInputTraits *)self->m_traits learnsCorrections]];
      v8 = self->m_traits;
      self->m_traits = v7;
    }

    else
    {
      [(UITextInputTraits *)m_traits setLearnsCorrections:0];
    }

    [(TIKeyboardState *)self->m_keyboardState setWordLearningEnabled:[(UITextInputTraits *)self->m_traits learnsCorrections]];
  }

  if (+[UIKeyboard usesInputSystemUI]&& self->m_correctionLearningAllowed != m_correctionLearningAllowed)
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner documentTraitsChanged];
  }
}

- (void)setLayoutRenderConfig:(id)config
{
  configCopy = config;
  activeLayout = [(_UIKeyboardStateManager *)self activeLayout];
  [activeLayout setRenderConfig:configCopy];
}

- (void)addSupplementalLexicon:(id)lexicon
{
  lexiconCopy = lexicon;
  if (!+[UIKeyboard inputUIOOP](UIKeyboard, "inputUIOOP") || +[UIKeyboard isKeyboardProcess])
  {
    backendController = [(_UIKeyboardStateManager *)self backendController];
    [backendController addUISupplementalLexicon:lexiconCopy];
  }

  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    inputSystemClientEnabled = [remoteTextInputPartner inputSystemClientEnabled];

    if (inputSystemClientEnabled)
    {
      remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      [remoteTextInputPartner2 didAddSupplementalLexicon:lexiconCopy];
    }
  }
}

- (void)removeSupplementalLexicon:(id)lexicon
{
  lexiconCopy = lexicon;
  if (!+[UIKeyboard inputUIOOP](UIKeyboard, "inputUIOOP") || +[UIKeyboard isKeyboardProcess])
  {
    backendController = [(_UIKeyboardStateManager *)self backendController];
    [backendController removeUISupplementalLexicon:lexiconCopy];
  }

  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    inputSystemClientEnabled = [remoteTextInputPartner inputSystemClientEnabled];

    if (inputSystemClientEnabled)
    {
      remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      [remoteTextInputPartner2 didRemoveSupplementalLexicon:lexiconCopy];
    }
  }
}

- (id)_obtainSessionIdentifierAssertionForReason:(id)reason
{
  reasonCopy = reason;
  assertionController = [(_UIKeyboardStateManager *)self assertionController];
  v6 = [assertionController vendAssertionOfType:42 initialState:1 reason:reasonCopy requiresExplicitInvalidation:0];

  return v6;
}

- (id)documentIdentifierForInputDelegate:(id)delegate
{
  delegateCopy = delegate;
  delegateAsResponder = delegateCopy;
  if (([delegateCopy __isKindOfUIResponder] & 1) == 0)
  {
    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  }

  v34 = 0;
  v35 = &v34;
  v36 = 0x2020000000;
  v37 = 0;
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  autofillGroup = [autofillController autofillGroup];
  v28 = MEMORY[0x1E69E9820];
  v29 = 3221225472;
  v30 = __62___UIKeyboardStateManager_documentIdentifierForInputDelegate___block_invoke;
  v31 = &unk_1E70FD1E0;
  v8 = delegateAsResponder;
  v32 = v8;
  v33 = &v34;
  [autofillGroup enumerateKeysAndObjectsUsingBlock:&v28];

  if ((objc_opt_respondsToSelector() & 1) == 0 || ([delegateCopy _rtiSourceSession], v9 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v9, "uuid"), uUID = objc_claimAutoreleasedReturnValue(), v9, !uUID))
  {
    if (*(v35 + 24) != 1)
    {
      goto LABEL_29;
    }

    autofillController2 = [(_UIKeyboardStateManager *)self autofillController];
    autofillGroup2 = [autofillController2 autofillGroup];
    uUID = [autofillGroup2 objectForKey:@"UIAutofillUUIDKey"];

    if (AutoFillUILibraryCore() && !uUID)
    {
      autofillController3 = [(_UIKeyboardStateManager *)self autofillController];
      autofillGroup3 = [autofillController3 autofillGroup];
      v43 = 0;
      v44 = &v43;
      v45 = 0x2020000000;
      v15 = getAFUIAutoFillUUIDKeySymbolLoc_ptr;
      v46 = getAFUIAutoFillUUIDKeySymbolLoc_ptr;
      if (!getAFUIAutoFillUUIDKeySymbolLoc_ptr)
      {
        v38 = MEMORY[0x1E69E9820];
        v39 = 3221225472;
        v40 = __getAFUIAutoFillUUIDKeySymbolLoc_block_invoke;
        v41 = &unk_1E70F2F20;
        v42 = &v43;
        v16 = AutoFillUILibrary();
        v17 = dlsym(v16, "AFUIAutoFillUUIDKey");
        *(v42[1] + 24) = v17;
        getAFUIAutoFillUUIDKeySymbolLoc_ptr = *(v42[1] + 24);
        v15 = v44[3];
      }

      _Block_object_dispose(&v43, 8);
      if (!v15)
      {
        currentHandler = [MEMORY[0x1E696AAA8] currentHandler];
        v27 = [MEMORY[0x1E696AEC0] stringWithUTF8String:"NSString *getAFUIAutoFillUUIDKey(void)"];
        [currentHandler handleFailureInFunction:v27 file:@"_UIKeyboardStateManager.m" lineNumber:320 description:{@"%s", dlerror(), v28, v29, v30, v31}];

        __break(1u);
        return result;
      }

      v18 = *v15;
      uUID = [autofillGroup3 objectForKey:v18];
    }

    if (!uUID)
    {
LABEL_29:
      if (!+[UIKeyboard usingEndInputSessionCompletion]|| ([(_UIKeyboardStateManager *)self skippedEndInputSessionID], (v19 = objc_claimAutoreleasedReturnValue()) == 0) || (v20 = [(_UIKeyboardStateManager *)self skippedEndInputSession], v19, v20 != delegateCopy) || ([(_UIKeyboardStateManager *)self skippedEndInputSessionID], (uUID = objc_claimAutoreleasedReturnValue()) == 0))
      {
        v21 = delegateCopy;
        if (([v21 __isKindOfUIResponder] & 1) == 0)
        {

LABEL_20:
          uUID = [MEMORY[0x1E696AFB0] UUID];
          goto LABEL_21;
        }

        textInputView = [v21 textInputView];
        keyboardSceneDelegate = [textInputView keyboardSceneDelegate];
        localAuthenticationObserver = [keyboardSceneDelegate localAuthenticationObserver];

        uUID = [localAuthenticationObserver sessionIDForInputDelegate:v21];

        if (!uUID)
        {
          goto LABEL_20;
        }
      }
    }
  }

LABEL_21:

  _Block_object_dispose(&v34, 8);

  return uUID;
}

- (void)_postInputResponderCapabilitiesChangedNotificationWithOutput:(id)output selectionChanged:(BOOL)changed
{
  changedCopy = changed;
  outputCopy = output;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained _postInputResponderCapabilitiesChangedNotificationWithOutput:outputCopy selectionChanged:changedCopy];
}

- (void)postInputResponderCapabilitiesChangedNotification
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained postInputResponderCapabilitiesChangedNotification];
}

- (id)asyncCapableInputDelegate
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  asyncCapableInputDelegate = [inputDelegateManager asyncCapableInputDelegate];

  return asyncCapableInputDelegate;
}

- (BOOL)hasAsyncCapableInputDelegate
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  hasAsyncCapableInputDelegate = [inputDelegateManager hasAsyncCapableInputDelegate];

  return hasAsyncCapableInputDelegate;
}

- (void)setDelegate:(id)delegate
{
  delegateCopy = delegate;
  if ([(_UIKeyboardStateManager *)self initializationDone])
  {
    [(_UIKeyboardStateManager *)self setDelegate:delegateCopy force:0];
  }
}

- (void)setDidTeardownExistingDelegate:(id)delegate
{
  aBlock = delegate;
  if (!+[UIKeyboard isKeyboardProcess])
  {
    currentHandler = [MEMORY[0x1E696AAA8] currentHandler];
    [currentHandler handleFailureInMethod:a2 object:self file:@"_UIKeyboardStateManager.m" lineNumber:3218 description:@"didTeardownExistingDelegate callback cannot be set in a non-keyboard process"];
  }

  v5 = aBlock;
  if (self->_didTeardownExistingDelegate != aBlock)
  {
    v6 = _Block_copy(aBlock);
    didTeardownExistingDelegate = self->_didTeardownExistingDelegate;
    self->_didTeardownExistingDelegate = v6;

    v5 = aBlock;
  }
}

- (void)setWillSetupNewDelegate:(id)delegate
{
  aBlock = delegate;
  if (!+[UIKeyboard isKeyboardProcess])
  {
    currentHandler = [MEMORY[0x1E696AAA8] currentHandler];
    [currentHandler handleFailureInMethod:a2 object:self file:@"_UIKeyboardStateManager.m" lineNumber:3226 description:@"willSetupNewDelegate callback cannot be set in a non-keyboard process"];
  }

  v5 = aBlock;
  if (self->_willSetupNewDelegate != aBlock)
  {
    v6 = _Block_copy(aBlock);
    willSetupNewDelegate = self->_willSetupNewDelegate;
    self->_willSetupNewDelegate = v6;

    v5 = aBlock;
  }
}

- (void)_notifyDidTeardownExistingDelegate:(id)delegate newDelegate:(id)newDelegate
{
  delegateCopy = delegate;
  newDelegateCopy = newDelegate;
  if (+[UIKeyboard usingEndInputSessionCompletion])
  {
    if (qword_1ED49CFC8 != -1)
    {
      dispatch_once(&qword_1ED49CFC8, &__block_literal_global_531);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v9[0] = MEMORY[0x1E69E9820];
    v9[1] = 3221225472;
    v9[2] = __74___UIKeyboardStateManager__notifyDidTeardownExistingDelegate_newDelegate___block_invoke_3;
    v9[3] = &unk_1E70FD208;
    v9[4] = self;
    v10 = newDelegateCopy;
    v11 = delegateCopy;
    [taskQueue performSingleTask:v9 breadcrumb:qword_1ED49CFC0];
  }
}

- (void)_notifyWillSetupNewDelegate:(id)delegate existingDelegate:(id)existingDelegate
{
  delegateCopy = delegate;
  existingDelegateCopy = existingDelegate;
  if (+[UIKeyboard usingEndInputSessionCompletion])
  {
    if (qword_1ED49CFD8 != -1)
    {
      dispatch_once(&qword_1ED49CFD8, &__block_literal_global_535);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v9[0] = MEMORY[0x1E69E9820];
    v9[1] = 3221225472;
    v9[2] = __72___UIKeyboardStateManager__notifyWillSetupNewDelegate_existingDelegate___block_invoke_3;
    v9[3] = &unk_1E70FD208;
    v9[4] = self;
    v10 = delegateCopy;
    v11 = existingDelegateCopy;
    [taskQueue performSingleTask:v9 breadcrumb:qword_1ED49CFD0];
  }
}

- (void)setDelegate:(id)delegate force:(BOOL)force delayEndInputSession:(BOOL)session
{
  sessionCopy = session;
  forceCopy = force;
  v32 = *MEMORY[0x1E69E9840];
  delegateCopy = delegate;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v10 = [inputDelegateManager delegateRespectingForwardingDelegate:0];

  self->_isSettingDelegate = 1;
  self->m_keyboardDelegateStateNeedsRefresh = 1;
  self->m_disableSyncTextChanged = 1;
  self->m_disableAutocapitalization = 0;
  self->m_shouldSuppressSelectionCommands = 0;
  self->m_numberpadPopoverHasBeenShown = 0;
  [(_UIKeyboardStateManager *)self updateHardwareKeyboardExclusivityIdentifier];
  m_hardwareKeyboardAttached = self->m_hardwareKeyboardAttached;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  -[_UIKeyboardStateManager setHardwareKeyboardAttached:](self, "setHardwareKeyboardAttached:", [WeakRetained isHardwareKeyboardAttachedNow]);

  v13 = self->m_hardwareKeyboardAttached;
  [(_UIKeyboardStateManager *)self setInHardwareKeyboardMode:self->m_hardwareKeyboardAttached shouldMoveKeyboard:delegateCopy != 0];
  v14 = objc_loadWeakRetained(&self->_presentationDelegate);
  [v14 resetIsPhysicallyAttachedHardwareKeyboard];

  if (v10 == delegateCopy && !forceCopy && (+[UIKeyboard usesInputSystemUI]|| v13 == m_hardwareKeyboardAttached))
  {
    [(_UIKeyboardStateManager *)self _reloadInputViewsForSameDelegate:delegateCopy existingDelegate:v10 force:0 delayEndInputSession:sessionCopy];
    goto LABEL_26;
  }

  if (os_variant_has_internal_diagnostics())
  {
    v16 = _UIKeyboardInputSessionChangeLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = _delegateShortDescr(delegateCopy);
      v18 = v17;
      v19 = "NO";
      if (forceCopy)
      {
        v20 = "YES";
      }

      else
      {
        v20 = "NO";
      }

      *v28 = 138413058;
      *&v28[4] = v17;
      if (sessionCopy)
      {
        v21 = "YES";
      }

      else
      {
        v21 = "NO";
      }

      *&v28[14] = v20;
      *&v28[12] = 2080;
      *&v28[22] = 2080;
      if (v10 == delegateCopy)
      {
        v19 = "YES";
      }

      v29 = v21;
      v30 = 2080;
      v31 = v19;
      _os_log_impl(&dword_188A29000, v16, OS_LOG_TYPE_DEFAULT, "-setDelegate=%@ force:%s delayEndInputSession:%s (delegateSame=%s)", v28, 0x2Au);
    }

    if (v10)
    {
      goto LABEL_7;
    }

LABEL_20:
    v15 = 0;
    goto LABEL_21;
  }

  if (!v10)
  {
    goto LABEL_20;
  }

LABEL_7:
  v15 = [(TIKeyboardState *)self->m_keyboardState documentIdentifier:*v28];
LABEL_21:
  [(_UIKeyboardStateManager *)self _teardownExistingDelegate:v10 forSetDelegate:delegateCopy force:forceCopy delayEndInputSession:sessionCopy];
  [(_UIKeyboardStateManager *)self _notifyDidTeardownExistingDelegate:v10 newDelegate:delegateCopy];
  [(_UIKeyboardStateManager *)self _setDelegate:delegateCopy existingDelegate:v10 force:forceCopy delayEndInputSession:sessionCopy];
  [(_UIKeyboardStateManager *)self _notifyWillSetupNewDelegate:delegateCopy existingDelegate:v10];
  [(_UIKeyboardStateManager *)self _setupDelegate:delegateCopy delegateSame:v10 == delegateCopy hardwareKeyboardStateChanged:v13 != m_hardwareKeyboardAttached endingInputSessionIdentifier:v15 force:forceCopy delayEndInputSession:sessionCopy];
  inputContextHistory = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];
  threadIdentifier = [inputContextHistory threadIdentifier];

  if (threadIdentifier)
  {
    smartReplyFeedbackManager = [(_UIKeyboardStateManager *)self smartReplyFeedbackManager];
    inputContextHistory2 = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];
    threadIdentifier2 = [inputContextHistory2 threadIdentifier];
    [smartReplyFeedbackManager composeFieldInFocusWithMailOrMsgThreadId:threadIdentifier2];
  }

  v27 = _UIKeyboardInputSessionChangeLog();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
  {
    *v28 = 0;
    _os_log_debug_impl(&dword_188A29000, v27, OS_LOG_TYPE_DEBUG, "done with -setDelegate:force:delayEndInputSession:", v28, 2u);
  }

LABEL_26:
}

- (void)_reloadInputViewsForSameDelegate:(id)delegate existingDelegate:(id)existingDelegate force:(BOOL)force delayEndInputSession:(BOOL)session
{
  v82 = *MEMORY[0x1E69E9840];
  delegateCopy = delegate;
  existingDelegateCopy = existingDelegate;
  if (!+[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI") || (+[UIKeyboardSceneDelegate automaticKeyboardArbiterClient](UIKeyboardSceneDelegate, "automaticKeyboardArbiterClient"), v10 = objc_claimAutoreleasedReturnValue(), v11 = [v10 handlingRemoteEvent], v10, (v11 & 1) == 0))
  {
    [(_UIKeyboardStateManager *)self clearForwardingInputDelegateAndResign:1];
  }

  keyboardType = [(UITextInputTraits *)self->m_traits keyboardType];
  textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
  [(_UIKeyboardStateManager *)self takeTextInputTraitsFromDelegate];
  v14 = +[UIKeyboard keyboardBundleIdentifier];
  v15 = [v14 isEqual:@"com.apple.freeform"];

  if (v15)
  {
    [(_UIKeyboardStateManager *)self updateDelegatePasteSupport];
  }

  if (+[UIKeyboard isKeyboardProcess])
  {
    -[UITextInputTraits setUseAutomaticEndpointing:](self->m_traits, "setUseAutomaticEndpointing:", [textInputTraits useAutomaticEndpointing]);
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v17 = [inputDelegateManager delegateRespectingForwardingDelegate:0];
  if (v17)
  {
  }

  else
  {
    m_defaultTraits = self->m_defaultTraits;

    if (m_defaultTraits)
    {
      goto LABEL_12;
    }

    [(UITextInputTraits *)self->m_traits setKeyboardType:keyboardType];
    v30 = [MEMORY[0x1E69D96E0] translateToTextInputKeyboardType:keyboardType];
    inputDelegateManager = [(TIKeyboardState *)self->m_keyboardState textInputTraits];
    [inputDelegateManager setKeyboardType:v30];
  }

LABEL_12:
  WeakRetained = [(_UIKeyboardStateManager *)self textInputTraits];
  v20 = [WeakRetained updateResultComparedToTraits:textInputTraits];

  v21 = off_1E70EA000;
  if (existingDelegateCopy && ![(_UIKeyboardStateManager *)self forCustomInputView])
  {
    v22 = +[UIKeyboard usesInputSystemUI];
    if (v22)
    {
      if (self->m_needsToRecomputeDesirableModes || v20 == 2)
      {
        goto LABEL_39;
      }
    }

    else
    {
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      window = [WeakRetained window];
      if (!window || self->m_needsToRecomputeDesirableModes || v20 == 2)
      {

        goto LABEL_39;
      }

      v72 = window;
    }

    v24 = +[UIKeyboard usesInputSystemUI];
    if (!v24)
    {
      v25 = objc_loadWeakRetained(&self->_presentationDelegate);
      layout = [v25 layout];
      [layout frame];
      v27 = v26;
      v73 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v73 frame];
      if (v27 != v28)
      {
        bOOLValue = 1;
        goto LABEL_34;
      }

      v71 = v25;
    }

    v76 = WeakRetained;
    _autofillContext = [(_UIKeyboardStateManager *)self _autofillContext];
    v32 = [_autofillContext objectForKey:@"_automaticPasswordKeyboard"];
    bOOLValue = [v32 BOOLValue];

    if (v24)
    {
      v21 = off_1E70EA000;
      WeakRetained = v76;
      if (v22)
      {
        goto LABEL_36;
      }

      goto LABEL_35;
    }

    WeakRetained = v76;
    v25 = v71;
LABEL_34:

    v21 = off_1E70EA000;
    if (v22)
    {
LABEL_36:
      if ((bOOLValue & 1) == 0)
      {
        delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
        textInputMode = [delegateAsResponder textInputMode];

        if (!textInputMode)
        {
          goto LABEL_14;
        }

        sharedInputModeController = [(__objc2_class *)v21[13] sharedInputModeController];
        delegateAsResponder2 = [(_UIKeyboardStateManager *)self delegateAsResponder];
        textInputMode2 = [delegateAsResponder2 textInputMode];
        primaryLanguage = [textInputMode2 primaryLanguage];
        currentPublicInputMode = [sharedInputModeController currentPublicInputMode];
        primaryLanguage2 = [currentPublicInputMode primaryLanguage];
        v75 = [primaryLanguage isEqualToString:primaryLanguage2];

        v21 = off_1E70EA000;
        if (v75)
        {
          goto LABEL_14;
        }
      }

LABEL_39:
      suppressUpdateLayout = [(_UIKeyboardStateManager *)self suppressUpdateLayout];
      [(_UIKeyboardStateManager *)self setSuppressUpdateLayout:1];
      [(_UIKeyboardStateManager *)self recomputeActiveInputModesWithExtensions:1];
      [(_UIKeyboardStateManager *)self setSuppressUpdateLayout:suppressUpdateLayout];
      if (self->m_shift)
      {
        v41 = objc_loadWeakRetained(&self->_presentationDelegate);
        layout2 = [v41 layout];
        if (!layout2 || self->m_shiftLocked || [(_UIKeyboardStateManager *)self callLayoutIsShiftKeyBeingHeld])
        {
        }

        else
        {
          callLayoutIsShiftKeyPlaneChooser = [(_UIKeyboardStateManager *)self callLayoutIsShiftKeyPlaneChooser];

          if (callLayoutIsShiftKeyPlaneChooser)
          {
            [(_UIKeyboardStateManager *)self clearShiftState];
          }
        }
      }

      v43 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v43 updateLayout];

      v44 = objc_loadWeakRetained(&self->_presentationDelegate);
      showInputModeIndicator = [v44 showInputModeIndicator];

      if (showInputModeIndicator)
      {
        [(_UIKeyboardStateManager *)self updateInputModeIndicatorOnSingleKeyOnly:0];
      }

      textInputTraits2 = [(_UIKeyboardStateManager *)self textInputTraits];
      isSecureTextEntry = [textInputTraits2 isSecureTextEntry];
      if (isSecureTextEntry == [textInputTraits isSecureTextEntry])
      {
        textInputTraits3 = [(_UIKeyboardStateManager *)self textInputTraits];
        recentInputIdentifier = [textInputTraits3 recentInputIdentifier];
        [textInputTraits recentInputIdentifier];
        v51 = v50 = v21;

        v52 = recentInputIdentifier == v51;
        v21 = v50;
        if (v52)
        {
          goto LABEL_50;
        }
      }

      else
      {
      }

      v53 = [(_UIKeyboardStateManager *)self documentIdentifierForInputDelegate:existingDelegateCopy];
      [(TIKeyboardState *)self->m_keyboardState setDocumentIdentifier:v53];

      goto LABEL_50;
    }

LABEL_35:

    goto LABEL_36;
  }

LABEL_14:
  if (v20 == 1)
  {
    [(_UIKeyboardStateManager *)self updateReturnKey:1];
  }

LABEL_50:
  v54 = [(_UIKeyboardStateManager *)self autocorrectionPreferenceForTraits]!= 0;
  [(TIKeyboardState *)self->m_keyboardState setAutocorrectionEnabled:v54];
  [(_UIKeyboardStateManager *)self setAutocorrectSpellingEnabled:v54];
  sharedInputModeController2 = [(__objc2_class *)v21[13] sharedInputModeController];
  currentInputMode = [sharedInputModeController2 currentInputMode];
  primaryLanguage3 = [currentInputMode primaryLanguage];
  [(_UIKeyboardStateManager *)self updateSmartPunctuationOptionsForLocaleIdentifier:primaryLanguage3];

  [(TISmartPunctuationController *)self->m_smartPunctuationController reset];
  [(TIKeyboardState *)self->m_keyboardState setInlineCompletionEnabled:[(_UIKeyboardStateManager *)self isInlineCompletionEnabled]];
  self->m_disableSyncTextChanged = 0;
  [(_UIKeyboardStateManager *)self setInputManagerFromCurrentInputMode];
  if (self->_remoteTextInputPartner && v20)
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner documentTraitsChanged];
  }

  if (!delegateCopy)
  {
    [(_UIKeyboardStateManager *)self needAutofillLogin];
    self->_isSettingDelegate = 0;
    [(_UIKeyboardStateManager *)self _updateDelegateRequiresKeyEventsFromRemoteTextInput];
    goto LABEL_67;
  }

  documentIdentifier = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
  if (!documentIdentifier)
  {
    assertionController = [(_UIKeyboardStateManager *)self assertionController];
    v61 = [assertionController hasAssertionsOfType:42];

    if (v61)
    {
      goto LABEL_58;
    }

    documentIdentifier = [(_UIKeyboardStateManager *)self documentIdentifierForInputDelegate:delegateCopy];
    [(TIKeyboardState *)self->m_keyboardState setDocumentIdentifier:documentIdentifier];
  }

LABEL_58:
  documentIdentifier2 = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];

  if (documentIdentifier2)
  {
    documentIdentifier3 = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
    v64 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
    _textInputSessionAnalytics = [v64 _textInputSessionAnalytics];
    [_textInputSessionAnalytics setSessionIdentifier:documentIdentifier3];

LABEL_60:
    goto LABEL_63;
  }

  if (os_log_type_enabled(MEMORY[0x1E69E9C10], OS_LOG_TYPE_FAULT))
  {
    m_keyboardState = self->m_keyboardState;
    documentIdentifier3 = [(_UIKeyboardStateManager *)self assertionController];
    v69 = [documentIdentifier3 hasAssertionsOfType:42];
    v70 = @"no";
    if (v69)
    {
      v70 = @"has";
    }

    *buf = 138412546;
    v79 = m_keyboardState;
    v80 = 2112;
    v81 = v70;
    _os_log_fault_impl(&dword_188A29000, MEMORY[0x1E69E9C10], OS_LOG_TYPE_FAULT, "m_keyboardState {%@} documentIdentifier creation failed, %@ sessionIdentifierAssertions", buf, 0x16u);
    goto LABEL_60;
  }

LABEL_63:
  if ([(_UIKeyboardStateManager *)self needAutofillLogin]&& !self->m_isAutofilling)
  {
    [(_UIKeyboardStateManager *)self generateAutofillCandidateByAddingTask:1];
  }

  self->_isSettingDelegate = 0;
  [(_UIKeyboardStateManager *)self _updateDelegateRequiresKeyEventsFromRemoteTextInput];
  defaultCenter = [MEMORY[0x1E696AD88] defaultCenter];
  [defaultCenter postNotificationName:@"UITextInputResponderIsReloadedNotification" object:0 userInfo:0];

LABEL_67:
}

- (void)setCurrentCandidateRequest:(id)request
{
  requestCopy = request;
  if (requestCopy && self->m_cachedAutofillMode)
  {
    delegateForCandidateRequest = [(_UIKeyboardStateManager *)self delegateForCandidateRequest];

    if (!delegateForCandidateRequest)
    {
      dictionary = [MEMORY[0x1E695DF90] dictionary];
      [(_UIKeyboardStateManager *)self setDelegateForCandidateRequest:dictionary];
    }

    v8 = MEMORY[0x1E696B098];
    delegate = [(_UIKeyboardStateManager *)self delegate];
    v10 = [v8 valueWithPointer:delegate];
    delegateForCandidateRequest2 = [(_UIKeyboardStateManager *)self delegateForCandidateRequest];
    [delegateForCandidateRequest2 setObject:v10 forKeyedSubscript:requestCopy];
  }

  objc_storeStrong(&self->_currentCandidateRequest, request);
  smartActionCandidateRequest = self->_smartActionCandidateRequest;
  self->_smartActionCandidateRequest = requestCopy;
}

- (void)_teardownExistingDelegate:(id)delegate forSetDelegate:(id)setDelegate force:(BOOL)force delayEndInputSession:(BOOL)session
{
  sessionCopy = session;
  forceCopy = force;
  v110 = *MEMORY[0x1E69E9840];
  delegateCopy = delegate;
  setDelegateCopy = setDelegate;
  v12 = _UIKeyboardInputSessionChangeLog();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = _delegateShortDescr(delegateCopy);
    v14 = _delegateShortDescr(setDelegateCopy);
    v15 = v14;
    v16 = "NO";
    v104 = 2112;
    *buf = 138413058;
    if (forceCopy)
    {
      v17 = "YES";
    }

    else
    {
      v17 = "NO";
    }

    v103 = v13;
    v105 = v14;
    if (sessionCopy)
    {
      v16 = "YES";
    }

    v106 = 2080;
    v107 = v17;
    v108 = 2080;
    v109 = v16;
    _os_log_impl(&dword_188A29000, v12, OS_LOG_TYPE_DEFAULT, "-_teardownExistingDelegate:%@ forSetDelegate:%@ force:%s delayEndInputSession:%s", buf, 0x2Au);
  }

  if (![(_UIKeyboardStateManager *)self forCustomInputView]&& ![(_UIKeyboardStateManager *)self suppressUpdateLayout])
  {
    if (delegateCopy)
    {
      v18 = sessionCopy;
    }

    else
    {
      v18 = 0;
    }

    [UIDictationController keyboardWillChangeFromDelegate:delegateCopy toDelegate:setDelegateCopy shouldPause:v18];
  }

  v19 = +[UIDictationController activeInstance];
  [v19 setResigningFirstResponder:0];

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  v22 = objc_opt_respondsToSelector();

  if (v22)
  {
    v23 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v23 layout];
    [layout2 dismissGestureKeyboardIntroduction];
  }

  if (!setDelegateCopy)
  {
    v25 = objc_loadWeakRetained(&self->_presentationDelegate);
    [v25 dismissContinuousPathIntroductionView];

    [(_UIKeyboardStateManager *)self dismissAutoFillMenu];
    delegateForCandidateRequest = [(_UIKeyboardStateManager *)self delegateForCandidateRequest];
    [delegateForCandidateRequest removeAllObjects];
  }

  v27 = +[UIPeripheralHost sharedInstance];
  inputViews = [v27 inputViews];
  inputViewController = [inputViews inputViewController];

  _compatibilityController = [inputViewController _compatibilityController];
  [_compatibilityController keyboardWillChangeFromDelegate:delegateCopy toDelegate:setDelegateCopy];
  if (delegateCopy)
  {
    [(_UIKeyboardStateManager *)self clearForwardingInputDelegateAndResign:1];
    if (setDelegateCopy != delegateCopy)
    {
      v97 = _compatibilityController;
      v31 = inputViewController;
      v32 = sessionCopy;
      [(_UIKeyboardStateManager *)self _insertionPointExitedRangeWithSupplementalCandidate];
      v33 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v33 setCaretBlinks:0];

      v34 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v34 setCaretVisible:0];

      v35 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v35 clearCursorAccessory];

      v36 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v36 dismissEmojiPopoverIfNecessaryWithCompletion:0];

      v37 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v37 dismissPressAndHoldPopover];

      v38 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v38 dismissNumberpadPopover];

      v39 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v39 dismissInputModeIndicator];

      v40 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v40 dismissDictationMenu];

      v41 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v41 dismissDictationTip];

      v42 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v42 dismissAutoFillPopover];

      v43 = delegateCopy;
      if ([v43 __isKindOfUIResponder])
      {
        textInputView = [v43 textInputView];
        keyboardSceneDelegate = [textInputView keyboardSceneDelegate];
        localAuthenticationObserver = [keyboardSceneDelegate localAuthenticationObserver];

        documentIdentifier = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
        [localAuthenticationObserver inputDelegateWillTeardown:v43 sessionUUID:documentIdentifier];
      }

      v48 = +[UIDictationController sharedInstance];
      dictationTipController = [v48 dictationTipController];
      [dictationTipController resetShowModelessTipSignal];

      v50 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v50 unsetEmojiPopoverToRestoreAfterRotation];

      sessionCopy = v32;
      inputViewController = v31;
      _compatibilityController = v97;
    }
  }

  v51 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
  _keepInputSession = [v51 _keepInputSession];

  if (!+[UIKeyboard usingEndInputSessionCompletion]&& !((self->_remoteTextInputPartner == 0) | _keepInputSession & 1))
  {
    v101[0] = MEMORY[0x1E69E9820];
    v101[1] = 3221225472;
    v101[2] = __95___UIKeyboardStateManager__teardownExistingDelegate_forSetDelegate_force_delayEndInputSession___block_invoke;
    v101[3] = &unk_1E70FD230;
    v101[4] = self;
    v56 = _Block_copy(v101);
    if (!delegateCopy)
    {
      resigningRTISessionIdentifier = [(_UIKeyboardStateManager *)self resigningRTISessionIdentifier];

      if (resigningRTISessionIdentifier)
      {
        resigningRTISessionIdentifier2 = [(_UIKeyboardStateManager *)self resigningRTISessionIdentifier];
        v56[2](v56, resigningRTISessionIdentifier2, setDelegateCopy == 0);

        [(_UIKeyboardStateManager *)self setResigningRTISessionIdentifier:0];
      }

      goto LABEL_48;
    }

    if (!setDelegateCopy && sessionCopy)
    {
      documentIdentifier2 = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
      [(_UIKeyboardStateManager *)self setResigningRTISessionIdentifier:documentIdentifier2];

      v62 = dispatch_time(0, 35000000);
      block[0] = MEMORY[0x1E69E9820];
      block[1] = 3221225472;
      block[2] = __95___UIKeyboardStateManager__teardownExistingDelegate_forSetDelegate_force_delayEndInputSession___block_invoke_2;
      block[3] = &unk_1E70F37C0;
      block[4] = self;
      v56 = v56;
      v100 = v56;
      dispatch_after(v62, MEMORY[0x1E69E96A0], block);

LABEL_48:
      goto LABEL_49;
    }

    documentIdentifier3 = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
    v56[2](v56, documentIdentifier3, setDelegateCopy == 0);
LABEL_47:

    goto LABEL_48;
  }

  if (+[UIKeyboard usingEndInputSessionCompletion]&& self->m_wasDelegateSetupWithRTIClient)
  {
    v53 = _compatibilityController;
    v54 = inputViewController;
    v55 = sessionCopy;
    aBlock[0] = MEMORY[0x1E69E9820];
    aBlock[1] = 3221225472;
    aBlock[2] = __95___UIKeyboardStateManager__teardownExistingDelegate_forSetDelegate_force_delayEndInputSession___block_invoke_3;
    aBlock[3] = &unk_1E70FD230;
    aBlock[4] = self;
    v56 = _Block_copy(aBlock);
    _keepInputSession2 = 0;
    if (delegateCopy && !setDelegateCopy)
    {
      v58 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
      _keepInputSession2 = [v58 _keepInputSession];
    }

    documentIdentifier3 = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
    if (!delegateCopy || (_keepInputSession2 & 1) != 0)
    {
      inputViewController = v54;
      _compatibilityController = v53;
      if (_keepInputSession2)
      {
        v63 = _UIKeyboardInputSessionChangeLog();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
        {
          v64 = _delegateShortDescr(delegateCopy);
          *buf = 138412546;
          v103 = v64;
          v104 = 2112;
          v105 = documentIdentifier3;
          _os_log_impl(&dword_188A29000, v63, OS_LOG_TYPE_DEFAULT, "Skipping end input session for existingDelegate: %@ (sessionID=%@)", buf, 0x16u);
        }

        [(_UIKeyboardStateManager *)self setSkippedEndInputSession:delegateCopy];
        [(_UIKeyboardStateManager *)self setSkippedEndInputSessionID:documentIdentifier3];
      }
    }

    else
    {
      if (setDelegateCopy)
      {
        v60 = 0;
      }

      else
      {
        v60 = !v55;
      }

      v56[2](v56, documentIdentifier3, v60);
      inputViewController = v54;
      _compatibilityController = v53;
    }

    goto LABEL_47;
  }

LABEL_49:
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];

  if (inputSystemSourceSession)
  {
    inputSystemSourceSession2 = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    [inputSystemSourceSession2 setSessionDelegate:0];
  }

  if (setDelegateCopy != delegateCopy)
  {
    assertionController = [(_UIKeyboardStateManager *)self assertionController];
    v70 = [assertionController hasAssertionsOfType:42];

    if (setDelegateCopy)
    {
      if (v70)
      {
        goto LABEL_60;
      }

      v71 = [(_UIKeyboardStateManager *)self documentIdentifierForInputDelegate:setDelegateCopy];
      [(TIKeyboardState *)self->m_keyboardState setDocumentIdentifier:v71];
    }

    else
    {
      if ((v70 & 1) == 0)
      {
        [(TIKeyboardState *)self->m_keyboardState setDocumentIdentifier:0];
      }

      if (![(UITextInputTraits *)self->m_traits isDevicePasscodeEntry])
      {
        goto LABEL_60;
      }

      v71 = objc_alloc_init(MEMORY[0x1E69D9590]);
      [(TIKeyboardState *)self->m_keyboardState setDocumentState:v71];
    }

LABEL_60:
    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
    _isWritingToolsActive = [delegateAsResponder _isWritingToolsActive];

    if ((_isWritingToolsActive & 1) == 0)
    {
      _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
      [_textChoicesAssistant clearSecureCandidateHashes];
    }
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  isMainThreadExecutingTask = [taskQueue isMainThreadExecutingTask];
  if (delegateCopy && !isMainThreadExecutingTask)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    asyncCapableInputDelegate = [inputDelegateManager asyncCapableInputDelegate];

    if (asyncCapableInputDelegate)
    {
      goto LABEL_67;
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    [taskQueue waitUntilAllTasksAreFinished];
  }

LABEL_67:
  v79 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
  _hasPostPinningReloadState = [v79 _hasPostPinningReloadState];

  if ((_hasPostPinningReloadState & 1) == 0)
  {
    v81 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout3 = [v81 layout];
    [layout3 acceptRecentInputIfNecessary];

    if ([setDelegateCopy __isKindOfTypeSelectKeyInput])
    {
      [(_UIKeyboardStateManager *)self changeCount];
    }

    else
    {
      __isKindOfTypeSelectKeyInput = [delegateCopy __isKindOfTypeSelectKeyInput];
      if ([(_UIKeyboardStateManager *)self changeCount]&& (__isKindOfTypeSelectKeyInput & 1) == 0)
      {
        [(_UIKeyboardStateManager *)self acceptAutocorrectionWithCompletionHandler:0];
        self->m_textInputChangesIgnored = 1;
        inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        [inputDelegateManager2 unmarkText];

        self->m_textInputChangesIgnored = 0;
      }
    }

    if (setDelegateCopy != delegateCopy)
    {
      [(_UIKeyboardStateManager *)self setCurrentCandidateRequest:0];
      [(_UIKeyboardStateManager *)self _cancelPendingSupplementalCandidateInsertion];
      if (self->m_shouldClearTextSuggestions)
      {
        [(_UIKeyboardStateManager *)self setSuggestions:0];
      }

      autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
      [autocorrectionController setAutocorrectionList:0];

      [(_UIKeyboardStateManager *)self clearChangeTimeAndCount];
      [(_UIKeyboardStateManager *)self removeAutocorrectPromptAndCandidateList];
    }
  }

  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  v86InputDelegate = [inputDelegate inputDelegate];

  if (v86InputDelegate == self)
  {
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate2 setInputDelegate:0];
  }

  asyncInputDelegate = [(_UIKeyboardStateManager *)self asyncInputDelegate];

  if (asyncInputDelegate)
  {
    asyncInputDelegate2 = [(_UIKeyboardStateManager *)self asyncInputDelegate];
    asyncSystemInputDelegate = [asyncInputDelegate2 asyncSystemInputDelegate];

    if (asyncSystemInputDelegate == self)
    {
      asyncInputDelegate3 = [(_UIKeyboardStateManager *)self asyncInputDelegate];
      [asyncInputDelegate3 setAsyncSystemInputDelegate:0];
    }
  }

  webInputDelegate = [(_UIKeyboardStateManager *)self webInputDelegate];

  if (webInputDelegate)
  {
    webInputDelegate2 = [(_UIKeyboardStateManager *)self webInputDelegate];
    asyncInputDelegate4 = [webInputDelegate2 asyncInputDelegate];

    if (asyncInputDelegate4 == self)
    {
      webInputDelegate3 = [(_UIKeyboardStateManager *)self webInputDelegate];
      [webInputDelegate3 setAsyncInputDelegate:0];
    }
  }
}

- (void)_setDelegate:(id)delegate existingDelegate:(id)existingDelegate force:(BOOL)force delayEndInputSession:(BOOL)session
{
  sessionCopy = session;
  forceCopy = force;
  v24 = *MEMORY[0x1E69E9840];
  delegateCopy = delegate;
  existingDelegateCopy = existingDelegate;
  v12 = _UIKeyboardInputSessionChangeLog();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    v15 = _delegateShortDescr(delegateCopy);
    v16 = _delegateShortDescr(existingDelegateCopy);
    v17 = v16;
    v18 = "NO";
    *&v20[12] = 2112;
    *v20 = 138413058;
    if (forceCopy)
    {
      v19 = "YES";
    }

    else
    {
      v19 = "NO";
    }

    *&v20[4] = v15;
    *&v20[14] = v16;
    *&v20[22] = 2080;
    if (sessionCopy)
    {
      v18 = "YES";
    }

    v21 = v19;
    v22 = 2080;
    v23 = v18;
    _os_log_debug_impl(&dword_188A29000, v12, OS_LOG_TYPE_DEBUG, "-_setDelegate:%@ existingDelegate:%@ force:%s delayEndInputSession:%s", v20, 0x2Au);
  }

  self->m_editingTraitsMarkedDirty = 1;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager setDelegate:delegateCopy];

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateDictationButtonForDelegate:delegateCopy];

  if (![(_UIKeyboardStateManager *)self forCustomInputView])
  {
    [(_UIKeyboardStateManager *)self _postInputResponderChangedNotification];
  }

  [(_UIKeyboardStateManager *)self responseContextDidChange:*v20];
}

- (void)_setupDelegate:(id)delegate delegateSame:(BOOL)same hardwareKeyboardStateChanged:(BOOL)changed endingInputSessionIdentifier:(id)identifier force:(BOOL)force delayEndInputSession:(BOOL)session
{
  sessionCopy = session;
  forceCopy = force;
  changedCopy = changed;
  sameCopy = same;
  v221 = *MEMORY[0x1E69E9840];
  delegateCopy = delegate;
  identifierCopy = identifier;
  v15 = _UIKeyboardInputSessionChangeLog();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    v87 = _delegateShortDescr(delegateCopy);
    v88 = "NO";
    *buf = 138413570;
    v210 = v87;
    if (sameCopy)
    {
      v89 = "YES";
    }

    else
    {
      v89 = "NO";
    }

    v211 = 2080;
    v212 = v89;
    if (changedCopy)
    {
      v90 = "YES";
    }

    else
    {
      v90 = "NO";
    }

    v213 = 2080;
    if (forceCopy)
    {
      v91 = "YES";
    }

    else
    {
      v91 = "NO";
    }

    v214 = v90;
    v215 = 2112;
    if (sessionCopy)
    {
      v88 = "YES";
    }

    v216 = identifierCopy;
    v217 = 2080;
    v218 = v91;
    v219 = 2080;
    v220 = v88;
    _os_log_debug_impl(&dword_188A29000, v15, OS_LOG_TYPE_DEBUG, "-_setupDelegate:%@ delegateSame:%s hardwareKeyboardStateChanged:%s endingInputSessionIdentifier:%@ force:%s delayEndInputSession:%s", buf, 0x3Eu);
  }

  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];

  if (inputDelegate)
  {
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    v17InputDelegate = [inputDelegate2 inputDelegate];

    if (!v17InputDelegate)
    {
      inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegate3 setInputDelegate:self];
    }
  }

  asyncInputDelegate = [(_UIKeyboardStateManager *)self asyncInputDelegate];

  if (asyncInputDelegate)
  {
    asyncInputDelegate2 = [(_UIKeyboardStateManager *)self asyncInputDelegate];
    asyncSystemInputDelegate = [asyncInputDelegate2 asyncSystemInputDelegate];

    if (!asyncSystemInputDelegate)
    {
      asyncInputDelegate3 = [(_UIKeyboardStateManager *)self asyncInputDelegate];
      [asyncInputDelegate3 setAsyncSystemInputDelegate:self];
    }
  }

  webInputDelegate = [(_UIKeyboardStateManager *)self webInputDelegate];

  if (webInputDelegate)
  {
    webInputDelegate2 = [(_UIKeyboardStateManager *)self webInputDelegate];
    asyncInputDelegate4 = [webInputDelegate2 asyncInputDelegate];

    if (!asyncInputDelegate4)
    {
      webInputDelegate3 = [(_UIKeyboardStateManager *)self webInputDelegate];
      [webInputDelegate3 setAsyncInputDelegate:self];
    }
  }

  self->m_textInputChangingCount = 0;
  self->m_textInputChangingDirection = 0;
  *&self->m_textInputChangesIgnored = 0;
  self->m_wasDelegateSetupWithRTIClient = [(_UIKeyboardStateManager *)self isRTIClient];
  [(_UIKeyboardStateManager *)self setMarkedTextFromClient:0];
  [(_UIKeyboardStateManager *)self deactivateLayout];
  [(_UIKeyboardStateManager *)self stopAutoDelete];
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];

  if (layout)
  {
    [(_UIKeyboardStateManager *)self clearShiftState];
  }

  changedDelegate = [(_UIKeyboardStateManager *)self changedDelegate];

  if (changedDelegate)
  {
    [(_UIKeyboardStateManager *)self callChangedDelegate];
  }

  [(_UIKeyboardStateManager *)self setChangedDelegate:0];
  [(_UIKeyboardStateManager *)self clearTransientState];
  *&self->m_needsPasteSupportUpdate = 1;
  [(_UIKeyboardStateManager *)self setArrowKeyHistory:0];
  keyboardType = [(UITextInputTraits *)self->m_traits keyboardType];
  remoteTextInputTraits = self->_remoteTextInputTraits;
  self->_remoteTextInputTraits = 0;

  floatingForced = [(_UIKeyboardStateManager *)self floatingForced];
  [(_UIKeyboardStateManager *)self takeTextInputTraitsFromDelegate];
  if (floatingForced)
  {
    v34 = ![(_UIKeyboardStateManager *)self floatingForced];
  }

  else
  {
    v34 = 0;
  }

  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];

  if (inputSystemSourceSession)
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    floatingForced2 = [(_UIKeyboardStateManager *)self floatingForced];
    inputSystemSourceSession2 = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    [inputSystemSourceSession2 setSessionDelegate:remoteTextInputPartner];
    [remoteTextInputPartner applyRemoteDocumentTraitsIfNecessary:inputSystemSourceSession2 force:0];
    [remoteTextInputPartner applyRemoteDocumentStateIfNecessary:inputSystemSourceSession2 force:0];
    v34 = 0;
    if (floatingForced2)
    {
      v34 = ![(_UIKeyboardStateManager *)self floatingForced];
    }
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v40 = [inputDelegateManager delegateRespectingForwardingDelegate:0];
  if (v40)
  {
    v41 = v40;
    forCustomInputView = [(_UIKeyboardStateManager *)self forCustomInputView];

    if (!forCustomInputView)
    {
      [(_UIKeyboardStateManager *)self setReturnKeyEnabled:1];
    }
  }

  else
  {
  }

  self->m_autocapitalizationPreference = [(_UIKeyboardStateManager *)self autocapitalizationPreference];
  [(_UIKeyboardStateManager *)self updateInputManagerAutocapitalizationType];
  v43 = [(_UIKeyboardStateManager *)self autocorrectionPreferenceForTraits]!= 0;
  [(TIKeyboardState *)self->m_keyboardState setAutocorrectionEnabled:v43];
  [(_UIKeyboardStateManager *)self setAutocorrectSpellingEnabled:v43];
  [(TIKeyboardState *)self->m_keyboardState setInlineCompletionEnabled:[(_UIKeyboardStateManager *)self isInlineCompletionEnabled]];
  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v45 = [inputDelegateManager2 delegateRespectingForwardingDelegate:0];
  if (v45)
  {

LABEL_28:
    goto LABEL_30;
  }

  m_defaultTraits = self->m_defaultTraits;

  if (!m_defaultTraits)
  {
    [(UITextInputTraits *)self->m_traits setKeyboardType:keyboardType];
    v86 = [MEMORY[0x1E69D96E0] translateToTextInputKeyboardType:keyboardType];
    inputDelegateManager2 = [(TIKeyboardState *)self->m_keyboardState textInputTraits];
    [inputDelegateManager2 setKeyboardType:v86];
    goto LABEL_28;
  }

LABEL_30:
  if (!sameCopy)
  {
    v47 = +[UIKeyboardInputModeController sharedInputModeController];
    currentInputMode = [v47 currentInputMode];
    primaryLanguage = [currentInputMode primaryLanguage];
    [(_UIKeyboardStateManager *)self updateSmartPunctuationOptionsForLocaleIdentifier:primaryLanguage];

    [(TISmartPunctuationController *)self->m_smartPunctuationController reset];
  }

  if (delegateCopy)
  {
    if (!+[UIKeyboard isKeyboardProcess])
    {
      v50 = +[_UIRemoteKeyboards sharedRemoteKeyboards];
      snapshotting = [v50 snapshotting];

      if ((snapshotting & 1) == 0)
      {
        inputDelegate4 = [(_UIKeyboardStateManager *)self inputDelegate];
        v53 = [(_UIKeyboardStateManager *)self needAutofillCandidate:inputDelegate4];
        autofillController = [(_UIKeyboardStateManager *)self autofillController];
        [autofillController setDelegateNeedsAutofillMode:v53];

        [(TIKeyboardState *)self->m_keyboardState setAutofillMode:[(_UIKeyboardStateManager *)self needAutofill]];
        self->m_cachedAutofillMode = [(TIKeyboardState *)self->m_keyboardState autofillMode];
        [(_UIKeyboardStateManager *)self displayAutoFillPopoverIfAutoFillModeDetected];
      }
    }
  }

  v55 = objc_loadWeakRetained(&self->_presentationDelegate);
  canPresentNumberpadPopover = [v55 canPresentNumberpadPopover];

  if (canPresentNumberpadPopover)
  {
    webInputDelegate4 = [(_UIKeyboardStateManager *)self webInputDelegate];

    if (webInputDelegate4)
    {
      v58 = dispatch_time(0, 500000000);
      v59 = MEMORY[0x1E69E96A0];
      v60 = MEMORY[0x1E69E96A0];
      block[0] = MEMORY[0x1E69E9820];
      block[1] = 3221225472;
      block[2] = __140___UIKeyboardStateManager__setupDelegate_delegateSame_hardwareKeyboardStateChanged_endingInputSessionIdentifier_force_delayEndInputSession___block_invoke;
      block[3] = &unk_1E70F3590;
      block[4] = self;
      dispatch_after(v58, v59, block);
    }

    else
    {
      v61 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v61 presentNumberpadPopover];
    }
  }

  v202 = sameCopy;
  v62 = changedCopy;
  v200 = identifierCopy;
  isSecureTextEntry = [(UITextInputTraits *)self->m_traits isSecureTextEntry];
  v64 = +[UIKeyboardInputModeController sharedInputModeController];
  inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate = [inputDelegateManager3 keyInputDelegate];
  v201 = v64;
  if (keyInputDelegate && !-[_UIKeyboardStateManager forCustomInputView](self, "forCustomInputView") && ([v64 inputModeContextIdentifier], (v67 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    v68 = v67;
    v69 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
    isInOnenessSceneAndRTIEnabled = [v69 isInOnenessSceneAndRTIEnabled];

    v64 = v201;
    if ((isInOnenessSceneAndRTIEnabled & 1) == 0)
    {
      v71 = [(_UIKeyboardStateManager *)self desirableInputModesWithExtensions:!isSecureTextEntry];
      currentInputMode2 = [v201 currentInputMode];
      v73 = v200;
      if ([v71 containsObject:currentInputMode2])
      {
        restoresToEmojiInputMode = self->_restoresToEmojiInputMode;

        if (!restoresToEmojiInputMode)
        {
          v75 = [v201 identifiersFromInputModes:v71];
          UIKeyboardSetActiveInputModes(v75);

LABEL_78:
          goto LABEL_79;
        }
      }

      else
      {
      }

      [(_UIKeyboardStateManager *)self recomputeActiveInputModesWithExtensions:[(UITextInputTraits *)self->m_traits isSecureTextEntry]^ 1];
      goto LABEL_78;
    }
  }

  else
  {
  }

  v73 = v200;
  if (!v202)
  {
    inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    v77 = [inputDelegateManager4 delegateRespectingForwardingDelegate:0];
    if (v77)
    {
      v78 = v77;
      forCustomInputView2 = [(_UIKeyboardStateManager *)self forCustomInputView];

      if (!forCustomInputView2)
      {
        currentInputMode3 = [v64 currentInputMode];
        isEmojiInputMode = [currentInputMode3 isEmojiInputMode];

        if (isEmojiInputMode && ![(UITextInputTraits *)self->m_traits acceptsInitialEmojiKeyboard])
        {
          currentInputModeInPreference = [v64 currentInputModeInPreference];
          v83 = [(_UIKeyboardStateManager *)self desirableInputModesWithExtensions:!isSecureTextEntry];
          if ([v83 containsObject:currentInputModeInPreference])
          {
            [(_UIKeyboardStateManager *)self setKeyboardInputMode:currentInputModeInPreference userInitiated:0];
          }
        }

        suppressUpdateLayout = [(_UIKeyboardStateManager *)self suppressUpdateLayout];
        if ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) == 1)
        {
          HasMultipleActiveLinguisticNonExtensionInputModes = UIKeyboardHasMultipleActiveLinguisticNonExtensionInputModes();
        }

        else
        {
          HasMultipleActiveLinguisticNonExtensionInputModes = 0;
        }

        [(_UIKeyboardStateManager *)self setSuppressUpdateLayout:1];
        [(_UIKeyboardStateManager *)self recomputeActiveInputModesWithExtensions:[(UITextInputTraits *)self->m_traits isSecureTextEntry]^ 1 allowNonLinguisticInputModes:[(UITextInputTraits *)self->m_traits acceptsInitialEmojiKeyboard]];
        [(_UIKeyboardStateManager *)self setSuppressUpdateLayout:suppressUpdateLayout];
        if ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) == 1 && HasMultipleActiveLinguisticNonExtensionInputModes != UIKeyboardHasMultipleActiveLinguisticNonExtensionInputModes())
        {
          [(_UIKeyboardStateManager *)self updateInputAssistantButtonItems];
        }
      }
    }

    else
    {
    }
  }

LABEL_79:
  v92 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout2 = [v92 layout];
  [layout2 setIgnoringKeyplaneChange:1];

  [(_UIKeyboardStateManager *)self updateShiftState];
  v94 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout3 = [v94 layout];
  [layout3 setIgnoringKeyplaneChange:0];

  self->m_predictionType = 0;
  if (v34)
  {
    v96 = objc_loadWeakRetained(&self->_presentationDelegate);
    isFloating = [objc_opt_class() isFloating];

    if ((isFloating & 1) == 0)
    {
      inputDelegateManager5 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
      [inputDelegateManager5 reloadPlacement];
      goto LABEL_96;
    }
  }

  if ([(_UIKeyboardStateManager *)self isMinimized])
  {
    v98 = objc_loadWeakRetained(&self->_presentationDelegate);
    _shouldSuppressSoftwareKeyboard = [v98 _shouldSuppressSoftwareKeyboard];

    if (_shouldSuppressSoftwareKeyboard)
    {
      inputDelegateManager5 = objc_loadWeakRetained(&self->_presentationDelegate);
      [inputDelegateManager5 setUpdateLayoutOnShowKeyboard:1];
LABEL_96:

      v105 = 0x1E70E9000uLL;
      goto LABEL_97;
    }
  }

  inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v101 = [inputDelegateManager5 delegateRespectingForwardingDelegate:0];
  if (!v101 && !forceCopy)
  {
    goto LABEL_96;
  }

  v102 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode4 = [v102 currentInputMode];
  isExtensionInputMode = [currentInputMode4 isExtensionInputMode];

  v105 = 0x1E70E9000;
  if (isExtensionInputMode)
  {
LABEL_97:
    [(_UIKeyboardStateManager *)self forCustomInputView];
LABEL_98:
    [(_UIKeyboardStateManager *)self updateShiftState];
    goto LABEL_99;
  }

  v106 = 0;
  if (self->m_traitsForPreviousDelegate && !forceCopy)
  {
    textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
    v106 = [textInputTraits updateResultComparedToTraits:self->m_traitsForPreviousDelegate] != 2;
  }

  if ([(_UIKeyboardStateManager *)self forCustomInputView]|| v106 || v62)
  {
    goto LABEL_98;
  }

  v108 = objc_loadWeakRetained(&self->_presentationDelegate);
  [v108 updateLayout];

  if (self->m_hardwareKeyboardAttached)
  {
    [(_UIKeyboardStateManager *)self callLayoutUpdateAllLocalizedKeys];
  }

  else
  {
    [(_UIKeyboardStateManager *)self callLayoutUpdateLocalizedKeys];
  }

LABEL_99:
  v109 = v202;
  inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v111 = [inputDelegateManager6 delegateRespectingForwardingDelegate:0];
  if (v111)
  {
    v112 = v111;
LABEL_105:

    goto LABEL_106;
  }

  if (![(TIKeyboardState *)self->m_keyboardState hardwareKeyboardMode]|| ![(_UIKeyboardStateManager *)self automaticMinimizationEnabled]|| [(_UIKeyboardStateManager *)self isMinimized])
  {
    v112 = 0;
    goto LABEL_105;
  }

  v193 = UIKeyboardGetCurrentInputMode();
  v194 = TIInputModeGetNormalizedIdentifier();
  v195 = [@"emoji" isEqualToString:v194];

  if (v195)
  {
    inputDelegateManager6 = +[UIKeyboardInputModeController sharedInputModeController];
    v112 = [inputDelegateManager6 nextInputModeInPreferenceListForTraits:self->m_traits];
    [(_UIKeyboardStateManager *)self setKeyboardInputMode:v112 userInitiated:0];
    goto LABEL_105;
  }

LABEL_106:
  self->m_delegateRequiresKeyEvents = ([(_UIKeyboardStateManager *)self delegateConformanceType]>> 8) & 1;
  [(_UIKeyboardStateManager *)self _updateDelegateRequiresKeyEventsFromRemoteTextInput];
  v113 = objc_loadWeakRetained(&self->_presentationDelegate);
  [v113 _updateExternalDeviceInputSetting];

  if (!v202)
  {
    inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    v115 = [inputDelegateManager7 delegateRespectingForwardingDelegate:0];
    v116 = v115;
    if (v115 && self->m_hardwareKeyboardAttached)
    {
      hardwareKeyboardMode = [(TIKeyboardState *)self->m_keyboardState hardwareKeyboardMode];

      if (hardwareKeyboardMode)
      {
        if ([(_UIKeyboardStateManager *)self isCapsLockASCIIToggle])
        {
          [(_UIKeyboardStateManager *)self removeCapsLockDelayOverride];
        }

        else
        {
          [(_UIKeyboardStateManager *)self adjustCapsLockDelayOverride];
        }

        [(_UIKeyboardStateManager *)self setCapsLockIfNeeded];
      }
    }

    else
    {
    }
  }

  inputDelegateManager8 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v119 = [inputDelegateManager8 delegateRespectingForwardingDelegate:0];

  if (!v119)
  {
    v120 = UIKeyboardGetCurrentInputMode();
    v121 = objc_loadWeakRetained(&self->_presentationDelegate);
    isSplit = [objc_opt_class() isSplit];

    if (isSplit)
    {
      v123 = TIStatisticGetKeyForInputMode();
      TIStatisticScalarSetBoolean();

      v124 = TIStatisticGetKeyForInputMode();
      v125 = objc_loadWeakRetained(&self->_presentationDelegate);
      [objc_opt_class() persistentOffset];
      TIStatisticDistributionPushValue();
    }

    else
    {
      v126 = +[UIPeripheralHost sharedInstance];
      isUndocked = [v126 isUndocked];

      if (!isUndocked)
      {
LABEL_119:

        goto LABEL_120;
      }

      v124 = TIStatisticGetKeyForInputMode();
      TIStatisticScalarSetBoolean();
    }

    goto LABEL_119;
  }

LABEL_120:
  deferredDidSetDelegateAction = [(_UIKeyboardStateManager *)self deferredDidSetDelegateAction];
  isValid = [deferredDidSetDelegateAction isValid];

  if ((isValid & 1) == 0)
  {
    v130 = [_UIActionWhenIdle actionWhenIdleWithTarget:self selector:sel_didSetDelegate object:0];
    [(_UIKeyboardStateManager *)self setDeferredDidSetDelegateAction:v130];
  }

  self->m_disableSyncTextChanged = 0;
  self->m_ignoreSelectionChange = 0;
  v131 = sharedInputManagerMux();
  systemInputManager = [v131 systemInputManager];
  v133 = [systemInputManager isMemberOfClass:objc_opt_class()];

  if (delegateCopy || (v133 & 1) == 0)
  {
    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    isMainThreadExecutingTask = [taskQueue isMainThreadExecutingTask];

    if (isMainThreadExecutingTask)
    {
      [(_UIKeyboardStateManager *)self setInputManagerFromCurrentInputMode];
      [(_UIKeyboardStateManager *)self updateForChangedSelection];
      if (!delegateCopy)
      {
        goto LABEL_134;
      }

      goto LABEL_130;
    }

    if (qword_1ED49CFE8 != -1)
    {
      dispatch_once(&qword_1ED49CFE8, &__block_literal_global_564_0);
    }

    taskQueue2 = [(_UIKeyboardStateManager *)self taskQueue];
    v206[0] = MEMORY[0x1E69E9820];
    v206[1] = 3221225472;
    v206[2] = __140___UIKeyboardStateManager__setupDelegate_delegateSame_hardwareKeyboardStateChanged_endingInputSessionIdentifier_force_delayEndInputSession___block_invoke_3;
    v206[3] = &unk_1E70FD1B8;
    v206[4] = self;
    v207 = delegateCopy;
    [taskQueue2 addTask:v206 breadcrumb:qword_1ED49CFE0];

    if (delegateCopy)
    {
LABEL_130:
      documentIdentifier = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];

      if (!documentIdentifier)
      {
        assertionController = [(_UIKeyboardStateManager *)self assertionController];
        v139 = [assertionController hasAssertionsOfType:42];

        if ((v139 & 1) == 0)
        {
          v140 = [(_UIKeyboardStateManager *)self documentIdentifierForInputDelegate:delegateCopy];
          [(TIKeyboardState *)self->m_keyboardState setDocumentIdentifier:v140];
        }
      }

      documentIdentifier2 = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
      v142 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
      _textInputSessionAnalytics = [v142 _textInputSessionAnalytics];
      [_textInputSessionAnalytics setSessionIdentifier:documentIdentifier2];
    }
  }

LABEL_134:
  if ([(_UIKeyboardStateManager *)self isRTIClient])
  {
    if ([*(v105 + 3824) usesInputSystemUIForAutoFillOnly])
    {
      remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      rtiDocumentTraits = [remoteTextInputPartner2 rtiDocumentTraits];
      autofillMode = [rtiDocumentTraits autofillMode];

      if (autofillMode)
      {
        v147 = +[_UIRemoteKeyboards sharedRemoteKeyboards];
        [v147 assertNeedsAutofillUI];
      }
    }
  }

  if (([*(v105 + 3824) usingEndInputSessionCompletion] & 1) == 0)
  {
    if ([(_UIKeyboardStateManager *)self isRTIClient])
    {
      inputDelegateManager9 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v149 = [inputDelegateManager9 delegateRespectingForwardingDelegate:0];

      if (delegateCopy)
      {
        if (v149)
        {
          if ([(_UIKeyboardStateManager *)self isOutOfProcess])
          {
            remoteTextInputPartner3 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
            documentIdentifier3 = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
            [remoteTextInputPartner3 beginAllowingRemoteTextInput:documentIdentifier3];
          }

          remoteTextInputPartner4 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
          documentIdentifier4 = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
          [remoteTextInputPartner4 beginInputSessionWithIdentifier:documentIdentifier4];

          m_keyboardWindowSnapshot = self->m_keyboardWindowSnapshot;
          self->m_keyboardWindowSnapshot = 0;
LABEL_176:

          goto LABEL_177;
        }
      }
    }
  }

  if ([*(v105 + 3824) usingEndInputSessionCompletion] && -[_UIKeyboardStateManager isRTIClient](self, "isRTIClient"))
  {
    skippedEndInputSession = [(_UIKeyboardStateManager *)self skippedEndInputSession];
    skippedEndInputSession2 = [(_UIKeyboardStateManager *)self skippedEndInputSession];
    v157 = skippedEndInputSession2;
    if (delegateCopy && skippedEndInputSession && skippedEndInputSession2 != delegateCopy)
    {
      v158 = _UIKeyboardInputSessionChangeLog();
      if (os_log_type_enabled(v158, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v158, OS_LOG_TYPE_FAULT, "New delegate does not match the delegate for the skipped end input session.", buf, 2u);
      }

      if (os_variant_has_internal_diagnostics())
      {
        v198 = _UIKeyboardExtendedLog();
        if (os_log_type_enabled(v198, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 0;
          _os_log_impl(&dword_188A29000, v198, OS_LOG_TYPE_DEFAULT, "End the session unceremoniously, detected skippedEndInputSession", buf, 2u);
        }

        v109 = v202;
      }

      remoteTextInputPartnerPrivate = [(_UIKeyboardStateManager *)self remoteTextInputPartnerPrivate];
      skippedEndInputSessionID = [(_UIKeyboardStateManager *)self skippedEndInputSessionID];
      [remoteTextInputPartnerPrivate endInputSessionWithIdentifier:skippedEndInputSessionID shouldResign:1 waitForReply:0];

      remoteTextInputPartnerPrivate2 = [(_UIKeyboardStateManager *)self remoteTextInputPartnerPrivate];
      skippedEndInputSessionID2 = [(_UIKeyboardStateManager *)self skippedEndInputSessionID];
      [remoteTextInputPartnerPrivate2 endAllowingRemoteTextInput:skippedEndInputSessionID2];

      [(_UIKeyboardStateManager *)self setSkippedEndInputSession:0];
      [(_UIKeyboardStateManager *)self setSkippedEndInputSessionID:0];
      v105 = 0x1E70E9000uLL;
    }

    if (!((delegateCopy == 0) | ([*(v105 + 3824) usesInputSystemUI] ^ 1) & 1) && skippedEndInputSession)
    {
      remoteTextInputPartner5 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      [remoteTextInputPartner5 forwardApplicationOperation:sel_verifyPlacement object:MEMORY[0x1E695E0F8]];

      remoteTextInputPartner6 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      [remoteTextInputPartner6 documentStateChanged];
    }

    m_keyboardWindowSnapshot = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
    if (!delegateCopy || v157 == delegateCopy)
    {
      v168 = v157 != delegateCopy || delegateCopy == 0;
      v73 = v200;
      if (v168)
      {
        goto LABEL_165;
      }

      p_super = _UIKeyboardInputSessionChangeLog();
      if (os_log_type_enabled(p_super, OS_LOG_TYPE_DEFAULT))
      {
        v192 = _delegateShortDescr(delegateCopy);
        *buf = 138412290;
        v210 = v192;
        _os_log_impl(&dword_188A29000, p_super, OS_LOG_TYPE_DEFAULT, "Skipping begin session because end session was previously skipped for: %@", buf, 0xCu);
      }
    }

    else
    {
      [(_UIKeyboardStateManager *)self updateDelegatePasteSupport];
      remoteTextInputPartner7 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      [remoteTextInputPartner7 beginAllowingRemoteTextInput:m_keyboardWindowSnapshot];

      remoteTextInputPartner8 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      [remoteTextInputPartner8 beginInputSessionWithIdentifier:m_keyboardWindowSnapshot];

      p_super = &self->m_keyboardWindowSnapshot->super.super;
      self->m_keyboardWindowSnapshot = 0;
      v73 = v200;
    }

LABEL_165:
    if (v73)
    {
      skippedEndInputSessionID3 = [(_UIKeyboardStateManager *)self skippedEndInputSessionID];
      v170 = [skippedEndInputSessionID3 isEqual:v73];

      if ((v170 & 1) == 0)
      {
        v171 = _UIKeyboardInputSessionChangeLog();
        if (os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG))
        {
          *buf = 138412290;
          v210 = v73;
          _os_log_debug_impl(&dword_188A29000, v171, OS_LOG_TYPE_DEBUG, "Stop allowing RTI for ending input session with ID: %@", buf, 0xCu);
        }

        remoteTextInputPartnerPrivate3 = [(_UIKeyboardStateManager *)self remoteTextInputPartnerPrivate];
        [remoteTextInputPartnerPrivate3 endAllowingRemoteTextInput:v73];
      }
    }

    if (delegateCopy)
    {
      if ([(_UIKeyboardStateManager *)self skippedEndInputSession]|| ([(_UIKeyboardStateManager *)self skippedEndInputSessionID], v173 = objc_claimAutoreleasedReturnValue(), v173, v173))
      {
        v174 = _UIKeyboardInputSessionChangeLog();
        if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
        {
          skippedEndInputSession3 = [(_UIKeyboardStateManager *)self skippedEndInputSession];
          skippedEndInputSessionID4 = [(_UIKeyboardStateManager *)self skippedEndInputSessionID];
          *buf = 134218242;
          v210 = skippedEndInputSession3;
          v211 = 2112;
          v212 = skippedEndInputSessionID4;
          _os_log_debug_impl(&dword_188A29000, v174, OS_LOG_TYPE_DEBUG, "nilling skippedEndInputSession properties (was %p, sessionID=%@)", buf, 0x16u);
        }

        [(_UIKeyboardStateManager *)self setSkippedEndInputSession:0];
        [(_UIKeyboardStateManager *)self setSkippedEndInputSessionID:0];
      }
    }

    goto LABEL_176;
  }

LABEL_177:
  if (delegateCopy && self->m_cachedAutofillMode)
  {
    if (!self->m_isAutofilling)
    {
      +[_UIKeyboardUsageTracking appAutofillDetectedIncrement];
      [(_UIKeyboardStateManager *)self generateAutofillCandidateByAddingTask:1];
    }
  }

  else if (!self->m_isAutofilling)
  {
    inputDelegateManager10 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    v176 = [inputDelegateManager10 delegateRespectingForwardingDelegate:0];

    if (v176)
    {
      delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v178 = delegateAsResponder;
      }

      else
      {
        v178 = 0;
      }

      v179 = v178;
      _scroller = [v179 _scroller];
      _isAncestorOfFirstResponder = [_scroller _isAncestorOfFirstResponder];

      if (_isAncestorOfFirstResponder)
      {
        if (qword_1ED49CFF8 != -1)
        {
          dispatch_once(&qword_1ED49CFF8, &__block_literal_global_579);
        }

        taskQueue3 = [(_UIKeyboardStateManager *)self taskQueue];
        v205[0] = MEMORY[0x1E69E9820];
        v205[1] = 3221225472;
        v205[2] = __140___UIKeyboardStateManager__setupDelegate_delegateSame_hardwareKeyboardStateChanged_endingInputSessionIdentifier_force_delayEndInputSession___block_invoke_3_583;
        v205[3] = &unk_1E70FD058;
        v205[4] = self;
        [taskQueue3 addTask:v205 breadcrumb:qword_1ED49CFF0];
      }
    }
  }

  inputDelegateManager11 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v184 = [inputDelegateManager11 delegateRespectingForwardingDelegate:0];

  if (!v184)
  {
    v185 = +[UIInputSwitcher activeInstance];
    [v185 hideSwitcherIfNeeded];
    v186 = +[UIKeyboardMediaController sharedKeyboardMediaController];
    [v186 releaseRecentlyUsedMediaViewIfNeeded];

    v187 = +[UIKeyboardMediaController sharedKeyboardMediaController];
    [v187 dismissCardIfNeeded];
  }

  +[_UIKeyboardUsageTracking showLowercaseKeyplanePreference:](_UIKeyboardUsageTracking, "showLowercaseKeyplanePreference:", +[UIKeyboardLayout _showSmallDisplayKeyplane]);
  if (delegateCopy)
  {
    defaultCenter = [MEMORY[0x1E696AD88] defaultCenter];
    [defaultCenter postNotificationName:@"UITextInputResponderIsReloadedNotification" object:0 userInfo:0];

    if (!v109 && (UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) == 1 && [(_UIKeyboardStateManager *)self isMinimized])
    {
      v189 = MEMORY[0x1E69E96A0];
      v190 = MEMORY[0x1E69E96A0];
      v203[0] = MEMORY[0x1E69E9820];
      v203[1] = 3221225472;
      v203[2] = __140___UIKeyboardStateManager__setupDelegate_delegateSame_hardwareKeyboardStateChanged_endingInputSessionIdentifier_force_delayEndInputSession___block_invoke_4;
      v203[3] = &unk_1E70F35B8;
      v203[4] = self;
      v204 = v201;
      dispatch_async(v189, v203);
    }
  }

  self->_isSettingDelegate = 0;
  v191 = objc_loadWeakRetained(&self->_presentationDelegate);
  [v191 unsetPolicyDelegateResult];
}

- (void)keyboardSceneDelegate:(id)delegate startedPinningInputViewsOnBehalfOfResponder:(id)responder
{
  v8 = *MEMORY[0x1E69E9840];
  responderCopy = responder;
  v5 = _UIKeyboardInputSessionChangeLog();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    v6 = 134217984;
    v7 = responderCopy;
    _os_log_debug_impl(&dword_188A29000, v5, OS_LOG_TYPE_DEBUG, "Started pinning input views on behalf of responder: %p", &v6, 0xCu);
  }
}

- (void)keyboardSceneDelegate:(id)delegate stoppedPinningInputViewsOnBehalfOfResponder:(id)responder
{
  v20 = *MEMORY[0x1E69E9840];
  responderCopy = responder;
  v6 = _UIKeyboardInputSessionChangeLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v18 = 134217984;
    v19 = responderCopy;
    _os_log_debug_impl(&dword_188A29000, v6, OS_LOG_TYPE_DEBUG, "Stopped pinning input views on behalf of responder: %p", &v18, 0xCu);
  }

  if (+[UIKeyboard usingEndInputSessionCompletion]&& [(_UIKeyboardStateManager *)self isRTIClient])
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager keyInputDelegate];

    if ([(_UIKeyboardStateManager *)self skippedEndInputSession])
    {
      v9 = [(_UIKeyboardStateManager *)self skippedEndInputSession]!= responderCopy;
      if (keyInputDelegate)
      {
LABEL_7:
        v10 = [(_UIKeyboardStateManager *)self skippedEndInputSession]== keyInputDelegate;
        goto LABEL_10;
      }
    }

    else
    {
      v9 = 1;
      if (keyInputDelegate)
      {
        goto LABEL_7;
      }
    }

    v10 = 0;
LABEL_10:
    v11 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
    _keepInputSession = [v11 _keepInputSession];

    if (!v9 && !v10 && (_keepInputSession & 1) == 0)
    {
      v13 = _UIKeyboardInputSessionChangeLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v18) = 0;
        _os_log_impl(&dword_188A29000, v13, OS_LOG_TYPE_DEFAULT, "Stopped pinning input views on behalf of responder: ending session for skippedEndInputSessionID now.", &v18, 2u);
      }

      remoteTextInputPartnerPrivate = [(_UIKeyboardStateManager *)self remoteTextInputPartnerPrivate];
      skippedEndInputSessionID = [(_UIKeyboardStateManager *)self skippedEndInputSessionID];
      [remoteTextInputPartnerPrivate endInputSessionWithIdentifier:skippedEndInputSessionID shouldResign:1 waitForReply:0];

      remoteTextInputPartnerPrivate2 = [(_UIKeyboardStateManager *)self remoteTextInputPartnerPrivate];
      skippedEndInputSessionID2 = [(_UIKeyboardStateManager *)self skippedEndInputSessionID];
      [remoteTextInputPartnerPrivate2 endAllowingRemoteTextInput:skippedEndInputSessionID2];

      [(_UIKeyboardStateManager *)self setSkippedEndInputSession:0];
      [(_UIKeyboardStateManager *)self setSkippedEndInputSessionID:0];
    }
  }
}

- (void)setRemoteDelegateSupportsImagePaste:(BOOL)paste
{
  if (self->m_remoteDelegateSupportsImagePaste != paste)
  {
    self->m_remoteDelegateSupportsImagePaste = paste;
    [(_UIKeyboardStateManager *)self updateDelegatePasteSupport];
  }
}

- (void)queueDelayedTask:(id)task
{
  taskCopy = task;
  deferredUpdateTask = self->_deferredUpdateTask;
  if (deferredUpdateTask)
  {
    v6 = _Block_copy(deferredUpdateTask);
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __44___UIKeyboardStateManager_queueDelayedTask___block_invoke;
    v12[3] = &unk_1E70F77D0;
    v13 = v6;
    v14 = taskCopy;
    v7 = v6;
    v8 = [v12 copy];
    v9 = self->_deferredUpdateTask;
    self->_deferredUpdateTask = v8;
  }

  else
  {
    v10 = [taskCopy copy];
    v11 = self->_deferredUpdateTask;
    self->_deferredUpdateTask = v10;
  }
}

- (void)setAutocorrectSpellingEnabled:(BOOL)enabled
{
  checkSpellingPreferenceForTraits = [(_UIKeyboardStateManager *)self checkSpellingPreferenceForTraits];
  UIKeyboardAutocorrectSpellingFlag = checkSpellingPreferenceForTraits || enabled;
  if (checkSpellingPreferenceForTraits)
  {
    v6 = UIKeyboardGetCurrentInputMode();
    v7 = UIKeyboardCheckSpellingForInputMode(v6);
  }

  else
  {
    v7 = 0;
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager setContinuousSpellCheckingEnabled:v7];
}

- (BOOL)hasDelegate
{
  v3 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
  responder = [v3 responder];

  if (responder && [UIApp isSuspended] && (+[UIPeripheralHost sharedInstance](UIPeripheralHost, "sharedInstance"), v5 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v5, "containerWindow"), v6 = objc_claimAutoreleasedReturnValue(), v7 = objc_msgSend(v6, "_isHostedInAnotherProcess"), v6, v5, (v7 & 1) == 0))
  {
    if (![responder _requiresKeyboardWhenFirstResponder])
    {
      v10 = 0;
      goto LABEL_6;
    }

    _keyboardResponder = [responder _keyboardResponder];
    keyInputDelegate = _keyboardResponder;
  }

  else
  {
    _keyboardResponder = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [_keyboardResponder keyInputDelegate];
  }

  v10 = keyInputDelegate != 0;

LABEL_6:
  return v10;
}

- (void)_insertSmartText:(id)text completionHandler:(id)handler
{
  v12[3] = *MEMORY[0x1E69E9840];
  handlerCopy = handler;
  v11[0] = 0x1EFB64610;
  v11[1] = 0x1EFB64630;
  v12[0] = MEMORY[0x1E695E118];
  v12[1] = MEMORY[0x1E695E110];
  v11[2] = 0x1EFB64650;
  v12[2] = &unk_1EFE30028;
  v7 = MEMORY[0x1E695DF20];
  textCopy = text;
  v9 = [v7 dictionaryWithObjects:v12 forKeys:v11 count:3];
  v10 = objc_alloc_init(MEMORY[0x1E69D9638]);
  [v10 insertText:textCopy];

  [(_UIKeyboardStateManager *)self performKeyboardOutput:v10 userInfo:v9];
  if (handlerCopy)
  {
    handlerCopy[2](handlerCopy);
  }
}

- (void)textLayoutDidChange:(id)change inRange:(id)range
{
  changeCopy = change;
  rangeCopy = range;
  if (!rangeCopy)
  {
    [(_UIKeyboardStateManager *)self updateCandidateDisplay];
LABEL_7:
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner documentStateChanged];

    goto LABEL_8;
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  selectedTextRange = [inputDelegateManager2 selectedTextRange];
  v10 = [inputDelegateManager _range:selectedTextRange intersectsRange:rangeCopy];

  if (v10)
  {
    [(_UIKeyboardStateManager *)self updateCandidateDisplay];
  }

  inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  extentRangeForDocumentState = [remoteTextInputPartner2 extentRangeForDocumentState];
  v14 = [inputDelegateManager3 _range:extentRangeForDocumentState intersectsRange:rangeCopy];

  if (v14)
  {
    goto LABEL_7;
  }

LABEL_8:
}

- (void)textWillChange:(id)change inRange:(id)range
{
  changeCopy = change;
  rangeCopy = range;
  if (!rangeCopy || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v7 = objc_claimAutoreleasedReturnValue(), -[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v8 = objc_claimAutoreleasedReturnValue(), [v8 selectedTextRange], v9 = objc_claimAutoreleasedReturnValue(), v10 = objc_msgSend(v7, "_range:intersectsRange:", v9, rangeCopy), v9, v8, v7, v10))
  {
    if (!self->m_textInputChangesIgnored)
    {
      self->m_textInputChangingText = 1;
    }

    [(_UIKeyboardStateManager *)self selectionWillChange:changeCopy];
  }
}

- (void)textDidChange:(id)change inRange:(id)range
{
  changeCopy = change;
  rangeCopy = range;
  if (!rangeCopy || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v7 = objc_claimAutoreleasedReturnValue(), -[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v8 = objc_claimAutoreleasedReturnValue(), [v8 selectedTextRange], v9 = objc_claimAutoreleasedReturnValue(), v10 = objc_msgSend(v7, "_range:intersectsRange:", v9, rangeCopy), v9, v8, v7, v10))
  {
    if (!self->m_textInputChangesIgnored)
    {
      v11 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
      _textInputSessionAnalytics = [v11 _textInputSessionAnalytics];
      [_textInputSessionAnalytics didOther];
    }

    [(_UIKeyboardStateManager *)self selectionDidChange:changeCopy];
  }
}

- (void)textAttributesDidChange:(id)change inRange:(id)range
{
  changeCopy = change;
  rangeCopy = range;
  if (!rangeCopy || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v7 = objc_claimAutoreleasedReturnValue(), -[_UIKeyboardStateManager remoteTextInputPartner](self, "remoteTextInputPartner"), v8 = objc_claimAutoreleasedReturnValue(), [v8 extentRangeForDocumentState], v9 = objc_claimAutoreleasedReturnValue(), v10 = objc_msgSend(v7, "_range:intersectsRange:", v9, rangeCopy), v9, v8, v7, v10))
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner documentStateChanged];
  }
}

- (void)invalidateTextEntryContextForTextInput:(id)input
{
  inputCopy = input;
  webInputDelegate = [(_UIKeyboardStateManager *)self webInputDelegate];

  v5 = inputCopy;
  if (webInputDelegate == inputCopy)
  {
    if ([inputCopy hasMarkedText])
    {
      [(_UIKeyboardStateManager *)self layoutHasChanged];
    }

    else
    {
      [(_UIKeyboardStateManager *)self updateForChangedSelection];
    }

    v5 = inputCopy;
  }
}

- (void)textChanged:(id)changed
{
  changedCopy = changed;
  if (pthread_main_np())
  {
    if (+[UIKeyboard isSpotlight](UIKeyboard, "isSpotlight") && (+[UIKeyboardInputModeController sharedInputModeController](UIKeyboardInputModeController, "sharedInputModeController"), v6 = objc_claimAutoreleasedReturnValue(), v7 = [v6 deviceStateIsLocking], v6, v7))
    {
      if (qword_1ED49D010 != -1)
      {
        dispatch_once(&qword_1ED49D010, &__block_literal_global_606);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      v13[0] = MEMORY[0x1E69E9820];
      v13[1] = 3221225472;
      v13[2] = __39___UIKeyboardStateManager_textChanged___block_invoke_3;
      v13[3] = &unk_1E70FD1B8;
      v13[4] = self;
      v14 = changedCopy;
      [taskQueue performTask:v13 breadcrumb:qword_1ED49D008];

      v9 = v14;
    }

    else
    {
      if (qword_1ED49D020 != -1)
      {
        dispatch_once(&qword_1ED49D020, &__block_literal_global_612);
      }

      taskQueue2 = [(_UIKeyboardStateManager *)self taskQueue];
      v11[0] = MEMORY[0x1E69E9820];
      v11[1] = 3221225472;
      v11[2] = __39___UIKeyboardStateManager_textChanged___block_invoke_6;
      v11[3] = &unk_1E70FD1B8;
      v11[4] = self;
      v12 = changedCopy;
      [taskQueue2 performSingleTask:v11 breadcrumb:qword_1ED49D018];

      v9 = v12;
    }
  }

  else
  {
    [(_UIKeyboardStateManager *)self performSelectorOnMainThread:a2 withObject:changedCopy waitUntilDone:0];
  }
}

- (void)textChanged:(id)changed executionContext:(id)context
{
  changedCopy = changed;
  contextCopy = context;
  if (![(_UIKeyboardStateManager *)self initializationDone]|| self->m_disableSyncTextChanged)
  {
    goto LABEL_3;
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  if (([WeakRetained rivenPreference] & 1) == 0)
  {

LABEL_9:
    [(_UIKeyboardStateManager *)self clearChangeTimeAndCount];
    [(_UIKeyboardStateManager *)self clearInput];
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager keyInputDelegate];
    v14 = keyInputDelegate;
    if (changedCopy && keyInputDelegate)
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      keyInputDelegate2 = [inputDelegateManager2 keyInputDelegate];

      if (changedCopy == self || keyInputDelegate2 == changedCopy)
      {
LABEL_17:
        inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        keyInputDelegate3 = [inputDelegateManager3 keyInputDelegate];
        if (keyInputDelegate3)
        {
          v25 = keyInputDelegate3;
          autofillController = [(_UIKeyboardStateManager *)self autofillController];
          if ([autofillController delegateNeedsAutofillMode])
          {
            m_cachedAutofillMode = self->m_cachedAutofillMode;

            if (!m_cachedAutofillMode)
            {
              self->m_cachedAutofillMode = [(_UIKeyboardStateManager *)self needAutofill];
            }

            goto LABEL_23;
          }
        }

LABEL_23:
        v29[0] = MEMORY[0x1E69E9820];
        v29[1] = 3221225472;
        v29[2] = __56___UIKeyboardStateManager_textChanged_executionContext___block_invoke;
        v29[3] = &unk_1E70FD058;
        v29[4] = self;
        v28 = [contextCopy childWithContinuation:v29];
        [(_UIKeyboardStateManager *)self updateForChangedSelectionWithExecutionContext:v28];

        goto LABEL_4;
      }

      assertionController = [(_UIKeyboardStateManager *)self assertionController];
      v18 = [assertionController hasAssertionsOfType:42];

      if ((v18 & 1) == 0)
      {
        inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        keyInputDelegate4 = [inputDelegateManager4 keyInputDelegate];
        v21 = [(_UIKeyboardStateManager *)self documentIdentifierForInputDelegate:keyInputDelegate4];
        [(TIKeyboardState *)self->m_keyboardState setDocumentIdentifier:v21];
      }

      inputDelegateManager = [(TIKeyboardState *)self->m_keyboardState documentIdentifier];
      v14 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
      _textInputSessionAnalytics = [v14 _textInputSessionAnalytics];
      [_textInputSessionAnalytics setSessionIdentifier:inputDelegateManager];
    }

    goto LABEL_17;
  }

  v9 = objc_loadWeakRetained(&self->_presentationDelegate);
  _rootInputWindowController = [v9 _rootInputWindowController];
  isSplitting = [_rootInputWindowController isSplitting];

  if (!isSplitting)
  {
    goto LABEL_9;
  }

LABEL_3:
  [contextCopy returnExecutionToParent];
LABEL_4:
}

- (void)finishTextChanged
{
  [(_UIKeyboardStateManager *)self updateReturnKey:1];
  [(_UIKeyboardStateManager *)self updateNoContentViews];
  [(_UIKeyboardStateManager *)self setChangedDelegate];
  [(_UIKeyboardStateManager *)self setShiftOffIfNeeded];
  textSelectionController = [(_UIKeyboardStateManager *)self textSelectionController];
  [textSelectionController textDidChange];
}

- (void)textSuggestionDidChange:(id)change
{
  changeCopy = change;
  if (qword_1ED49D030 != -1)
  {
    dispatch_once(&qword_1ED49D030, &__block_literal_global_616);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v8[0] = MEMORY[0x1E69E9820];
  v8[1] = 3221225472;
  v8[2] = __51___UIKeyboardStateManager_textSuggestionDidChange___block_invoke_3;
  v8[3] = &unk_1E70FD1B8;
  v8[4] = self;
  v9 = changeCopy;
  v6 = qword_1ED49D028;
  v7 = changeCopy;
  [taskQueue addTask:v8 breadcrumb:v6];
}

- (void)setDefaultTextInputTraits:(id)traits
{
  traitsCopy = traits;
  m_defaultTraits = self->m_defaultTraits;
  if (m_defaultTraits != traitsCopy)
  {
    v13 = traitsCopy;
    v6 = [(UITextInputTraits *)m_defaultTraits isEqual:traitsCopy];
    traitsCopy = v13;
    if (!v6)
    {
      v7 = [(UITextInputTraits *)v13 copy];
      v8 = self->m_defaultTraits;
      self->m_defaultTraits = v7;

      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v10 = [inputDelegateManager delegateRespectingForwardingDelegate:0];
      [(_UIKeyboardStateManager *)self setDelegate:v10 force:1];

      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v12 = [inputDelegateManager2 delegateRespectingForwardingDelegate:0];

      traitsCopy = v13;
      if (v13)
      {
        if (!v12)
        {
          [(_UIKeyboardStateManager *)self recomputeActiveInputModesWithExtensions:1];
          traitsCopy = v13;
        }
      }
    }
  }
}

- (void)setOverrideTextInputTraits:(id)traits
{
  traitsCopy = traits;
  m_overrideTraits = self->m_overrideTraits;
  if (m_overrideTraits != traitsCopy)
  {
    v11 = traitsCopy;
    v6 = [(UITextInputTraits *)m_overrideTraits isEqual:traitsCopy];
    traitsCopy = v11;
    if (!v6)
    {
      if (!v11)
      {
        [(_UIKeyboardStateManager *)self clearForwardingInputDelegateAndResign:1];
        traitsCopy = 0;
      }

      v7 = [(UITextInputTraits *)traitsCopy copy];
      v8 = self->m_overrideTraits;
      self->m_overrideTraits = v7;

      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v10 = [inputDelegateManager delegateRespectingForwardingDelegate:0];
      [(_UIKeyboardStateManager *)self setDelegate:v10 force:1];

      traitsCopy = v11;
    }
  }
}

- (void)textInput:(id)input setCandidateSuggestions:(id)suggestions
{
  v28 = *MEMORY[0x1E69E9840];
  inputCopy = input;
  suggestionsCopy = suggestions;
  v6 = [objc_alloc(MEMORY[0x1E695DF70]) initWithCapacity:{objc_msgSend(suggestionsCopy, "count")}];
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v7 = suggestionsCopy;
  v8 = [v7 countByEnumeratingWithState:&v18 objects:v27 count:16];
  if (v8)
  {
    v9 = *v19;
    do
    {
      v10 = 0;
      do
      {
        if (*v19 != v9)
        {
          objc_enumerationMutation(v7);
        }

        v11 = *(*(&v18 + 1) + 8 * v10);
        v23 = 0;
        v24 = &v23;
        v25 = 0x2050000000;
        v12 = qword_1ED49D5D0;
        v26 = qword_1ED49D5D0;
        if (!qword_1ED49D5D0)
        {
          v22[0] = MEMORY[0x1E69E9820];
          v22[1] = 3221225472;
          v22[2] = __getBEAutoFillTextSuggestionClass_block_invoke;
          v22[3] = &unk_1E70F2F20;
          v22[4] = &v23;
          __getBEAutoFillTextSuggestionClass_block_invoke(v22);
          v12 = v24[3];
        }

        v13 = v12;
        _Block_object_dispose(&v23, 8);
        if (objc_opt_isKindOfClass())
        {
          contents = [v11 contents];
          _uikitTextSuggestion = [UIAutoFillTextSuggestion autoFillSuggestionWithContents:contents];
        }

        else
        {
          _uikitTextSuggestion = [v11 _uikitTextSuggestion];
        }

        [v6 addObject:_uikitTextSuggestion];

        ++v10;
      }

      while (v8 != v10);
      v8 = [v7 countByEnumeratingWithState:&v18 objects:v27 count:16];
    }

    while (v8);
  }

  [(_UIKeyboardStateManager *)self provideCandidateUISuggestions:v6];
}

- (void)setSuggestions:(id)suggestions
{
  suggestionsCopy = suggestions;
  v5 = +[UIKeyboard isKeyboardProcess];
  if (!suggestionsCopy && v5)
  {
    textSuggestions = [(_UIKeyboardStateManager *)self textSuggestions];
    if (textSuggestions)
    {
    }

    else
    {
      autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
      hasAutofillCandidates = [autocorrectionController hasAutofillCandidates];

      if (hasAutofillCandidates)
      {
        goto LABEL_9;
      }
    }
  }

  if (qword_1ED49D040 != -1)
  {
    dispatch_once(&qword_1ED49D040, &__block_literal_global_623);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v10[0] = MEMORY[0x1E69E9820];
  v10[1] = 3221225472;
  v10[2] = __42___UIKeyboardStateManager_setSuggestions___block_invoke_3;
  v10[3] = &unk_1E70FD1B8;
  v10[4] = self;
  v11 = suggestionsCopy;
  [taskQueue addTask:v10 breadcrumb:qword_1ED49D038];

LABEL_9:
}

- (void)_setSuggestions:(id)suggestions
{
  v84 = *MEMORY[0x1E69E9840];
  suggestionsCopy = suggestions;
  selfCopy = self;
  if ([(_UIKeyboardStateManager *)self isRTIClient])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner textSuggestionsChanged:suggestionsCopy];

    remoteTextInputPartner2 = [(_UIKeyboardStateManager *)selfCopy remoteTextInputPartner];
    remoteTextInputClientHasActiveSession = [remoteTextInputPartner2 remoteTextInputClientHasActiveSession];

    self = selfCopy;
    if (suggestionsCopy)
    {
      if ((remoteTextInputClientHasActiveSession & 1) == 0)
      {
        remoteTextInputPartner3 = [(_UIKeyboardStateManager *)selfCopy remoteTextInputPartner];
        [remoteTextInputPartner3 addTextSuggestions:suggestionsCopy];

        self = selfCopy;
      }
    }
  }

  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  textSuggestionList = [autocorrectionController textSuggestionList];

  if (suggestionsCopy && [suggestionsCopy count])
  {
    v9 = [MEMORY[0x1E695DF70] arrayWithCapacity:{objc_msgSend(suggestionsCopy, "count")}];
    v80 = 0u;
    v81 = 0u;
    v78 = 0u;
    v79 = 0u;
    v10 = suggestionsCopy;
    v11 = 0;
    v12 = [v10 countByEnumeratingWithState:&v78 objects:v83 count:16];
    if (v12)
    {
      v13 = *v79;
      do
      {
        for (i = 0; i != v12; ++i)
        {
          if (*v79 != v13)
          {
            objc_enumerationMutation(v10);
          }

          v15 = *(*(&v78 + 1) + 8 * i);
          _keyboardCandidate = [v15 _keyboardCandidate];
          [v9 addObject:_keyboardCandidate];

          if (!v11)
          {
            if ([v15 canDisplayInline])
            {
              v11 = v15;
            }

            else
            {
              v11 = 0;
            }
          }
        }

        v12 = [v10 countByEnumeratingWithState:&v78 objects:v83 count:16];
      }

      while (v12);
    }

    firstObject = [v9 firstObject];
    usesCandidateSelection = [(_UIKeyboardStateManager *)selfCopy usesCandidateSelection];
    v18 = selfCopy;
    if (selfCopy->m_predictionType != 6)
    {
      if (usesCandidateSelection)
      {
        v19 = 2;
      }

      else
      {
        v19 = 4;
      }

      selfCopy->m_predictionType = v19;
      v20 = [MEMORY[0x1E69D9570] listWithCorrections:0 predictions:v9];
      autocorrectionController2 = [(_UIKeyboardStateManager *)selfCopy autocorrectionController];
      [autocorrectionController2 setTextSuggestionList:v20];

      v18 = selfCopy;
    }

    if (v11)
    {
      inlineTextCompletionController = [(_UIKeyboardStateManager *)v18 inlineTextCompletionController];
      [inlineTextCompletionController updateTextCompletionWithExternalSuggestion:v11];

      v18 = selfCopy;
    }

    if ([(_UIKeyboardStateManager *)v18 usesCandidateSelection])
    {
      textInputTraits = [(TIKeyboardState *)selfCopy->m_keyboardState textInputTraits];
      v24 = [textInputTraits mathExpressionCompletionType] != 1;

      _hasMarkedText = [(_UIKeyboardStateManager *)selfCopy _hasMarkedText];
      if (v24 && _hasMarkedText && ![(TIKeyboardCandidateResultSet *)selfCopy->m_candidateResultSet hasCandidates])
      {

        goto LABEL_62;
      }

      array = [MEMORY[0x1E695DF70] array];
      v26 = [MEMORY[0x1E695DFA8] setWithCapacity:{objc_msgSend(v10, "count") + 1}];
      searchStringForMarkedText = [(TIKeyboardState *)selfCopy->m_keyboardState searchStringForMarkedText];
      firstCandidate = [(TIKeyboardCandidateResultSet *)selfCopy->m_candidateResultSet firstCandidate];
      if (firstCandidate != 0 && _hasMarkedText)
      {
        [array addObject:firstCandidate];
        candidate = [firstCandidate candidate];

        if (candidate)
        {
          candidate2 = [firstCandidate candidate];
          [v26 addObject:candidate2];
        }
      }

      v74 = 0;
      v75 = &v74;
      v76 = 0x2020000000;
      v77 = 0;
      v66[0] = MEMORY[0x1E69E9820];
      v66[1] = 3221225472;
      v66[2] = __43___UIKeyboardStateManager__setSuggestions___block_invoke;
      v66[3] = &unk_1E70FD258;
      v52 = searchStringForMarkedText;
      v67 = v52;
      v73 = !_hasMarkedText;
      v53 = firstCandidate;
      v68 = v53;
      v59 = array;
      v69 = v59;
      v70 = v9;
      v31 = v26;
      v71 = v31;
      v72 = &v74;
      [v10 enumerateObjectsUsingBlock:v66];
      p_isa = &selfCopy->super.isa;
      if (*(v75 + 24) == 1)
      {
        v33 = _hasMarkedText;
        if (([(TIKeyboardCandidateResultSet *)selfCopy->m_candidateResultSet hasCandidates:v52]& _hasMarkedText) == 1)
        {
          v64 = 0u;
          v65 = 0u;
          v62 = 0u;
          v63 = 0u;
          candidates = [(TIKeyboardCandidateResultSet *)selfCopy->m_candidateResultSet candidates];
          v35 = [candidates countByEnumeratingWithState:&v62 objects:v82 count:16];
          if (v35)
          {
            v36 = *v63;
            do
            {
              for (j = 0; j != v35; ++j)
              {
                if (*v63 != v36)
                {
                  objc_enumerationMutation(candidates);
                }

                v38 = *(*(&v62 + 1) + 8 * j);
                candidate3 = [v38 candidate];
                v40 = [v31 containsObject:candidate3];

                if ((v40 & 1) == 0)
                {
                  [v59 addObject:v38];
                }
              }

              v35 = [candidates countByEnumeratingWithState:&v62 objects:v82 count:16];
            }

            while (v35);
          }

          p_isa = &selfCopy->super.isa;
          v33 = _hasMarkedText;
        }

        if (([p_isa[4] hasCandidates] & v33) == 1)
        {
          v41 = [p_isa[4] copy];
          [v41 setCandidates:v59];
          [v41 setBatchCandidateLocation:0];
        }

        else
        {
          if (!v33)
          {
            [p_isa setCurrentCandidateRequest:0];
          }

          v41 = [MEMORY[0x1E69D95E8] setWithCandidates:v59];
        }

        if (qword_1ED49D050 != -1)
        {
          dispatch_once(&qword_1ED49D050, &__block_literal_global_631_0);
        }

        taskQueue = [p_isa taskQueue];
        v60[0] = MEMORY[0x1E69E9820];
        v60[1] = 3221225472;
        v60[2] = __43___UIKeyboardStateManager__setSuggestions___block_invoke_4;
        v60[3] = &unk_1E70FD1B8;
        v60[4] = p_isa;
        v49 = v41;
        v61 = v49;
        [taskQueue addDeferredTask:v60 breadcrumb:qword_1ED49D048];
      }

      _Block_object_dispose(&v74, 8);
    }

    goto LABEL_59;
  }

  autocorrectionController3 = [(_UIKeyboardStateManager *)selfCopy autocorrectionController];
  textSuggestionList2 = [autocorrectionController3 textSuggestionList];
  if (textSuggestionList2)
  {

    v44 = selfCopy;
  }

  else
  {
    v44 = selfCopy;
    isAutofillPrediction = [(_UIKeyboardStateManager *)selfCopy isAutofillPrediction];

    if (!isAutofillPrediction)
    {
      goto LABEL_60;
    }
  }

  [(_UIKeyboardStateManager *)v44 isAutofillPrediction];
  v44->m_predictionType = 0;
  autocorrectionController4 = [(_UIKeyboardStateManager *)v44 autocorrectionController];
  [autocorrectionController4 setTextSuggestionList:0];

  v44 = selfCopy;
  [(_UIKeyboardStateManager *)selfCopy removeInlineTextCompletionPrompt];
  if (![(_UIKeyboardStateManager *)selfCopy usesCandidateSelection])
  {
    autocorrectionController5 = [(_UIKeyboardStateManager *)selfCopy autocorrectionController];
    [autocorrectionController5 setNeedsAutocorrection];

LABEL_59:
    v44 = selfCopy;
  }

LABEL_60:
  autocorrectionController6 = [(_UIKeyboardStateManager *)v44 autocorrectionController];
  textSuggestionList3 = [autocorrectionController6 textSuggestionList];

  if ((textSuggestionList != 0) == (textSuggestionList3 == 0))
  {
    [(_UIKeyboardStateManager *)selfCopy updateAssistantView];
  }

LABEL_62:
}

- (void)insertCustomTextSuggestion:(id)suggestion
{
  v35 = *MEMORY[0x1E69E9840];
  suggestionCopy = suggestion;
  selfCopy = self;
  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  textSuggestionList = [autocorrectionController textSuggestionList];

  v29 = textSuggestionList;
  [textSuggestionList predictions];
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v7 = v33 = 0u;
  v8 = [v7 countByEnumeratingWithState:&v30 objects:v34 count:16];
  if (!v8)
  {
    goto LABEL_22;
  }

  v9 = v8;
  v10 = *v31;
  while (2)
  {
    for (i = 0; i != v9; ++i)
    {
      if (*v31 != v10)
      {
        objc_enumerationMutation(v7);
      }

      v12 = *(*(&v30 + 1) + 8 * i);
      textSuggestion = [v12 textSuggestion];
      uuid = [suggestionCopy uuid];
      uuid2 = [textSuggestion uuid];
      v16 = [uuid isEqual:uuid2];

      if (v16)
      {
        inputDelegateManager = [(_UIKeyboardStateManager *)selfCopy inputDelegateManager];
        v18 = [inputDelegateManager insertTextSuggestion:textSuggestion];

        if ((v18 & 1) != 0 || ((objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0) || -[_UIKeyboardStateManager insertAutoFillTextSuggestion:](selfCopy, "insertAutoFillTextSuggestion:", textSuggestion)) && -[_UIKeyboardStateManager acceptWord:firstDelete:](selfCopy, "acceptWord:firstDelete:", v12, [v12 deleteCount]))
        {
          if (!+[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled])
          {
LABEL_21:

            goto LABEL_22;
          }

          inputDelegateManager2 = [(_UIKeyboardStateManager *)selfCopy inputDelegateManager];
          selectedTextRange = [inputDelegateManager2 selectedTextRange];
          if (selectedTextRange)
          {
            v21 = selectedTextRange;
            inputText = [suggestionCopy inputText];

            if (!inputText && +[UIKeyboard usesInputSystemUI])
            {
              _textChoicesAssistant = [(_UIKeyboardStateManager *)selfCopy _textChoicesAssistant];
              inputDelegateManager3 = [(_UIKeyboardStateManager *)selfCopy inputDelegateManager];
              selectedTextRange2 = [inputDelegateManager3 selectedTextRange];
              [_textChoicesAssistant clearUnderlinesInRange:selectedTextRange2 animated:0];

              [(_UIKeyboardStateManager *)selfCopy dismissTextChoicePrompt];
            }

            goto LABEL_21;
          }
        }

        else
        {
          inputDelegateManager2 = [(_UIKeyboardStateManager *)selfCopy inputDelegateManager];
          textInputDelegate = [inputDelegateManager2 textInputDelegate];
          inputText2 = [textSuggestion inputText];
          [(_UIKeyboardStateManager *)selfCopy replaceAllTextInResponder:textInputDelegate withText:inputText2];
        }

        goto LABEL_21;
      }
    }

    v9 = [v7 countByEnumeratingWithState:&v30 objects:v34 count:16];
    if (v9)
    {
      continue;
    }

    break;
  }

LABEL_22:
}

- (void)insertSticker:(id)sticker
{
  stickerCopy = sticker;
  if (!+[UIKeyboard isKeyboardProcess]|| ([(_UIKeyboardStateManager *)self inputSystemSourceSession], (v5 = objc_claimAutoreleasedReturnValue()) == 0))
  {
    if ([(_UIKeyboardStateManager *)self canInsertAdaptiveImageGlyph])
    {
      v10 = _UIStickerCreateAdaptiveImageGlyphFromSticker(stickerCopy);
      v11 = _UIKeyboardStickerLog();
      v12 = v11;
      if (v10)
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 0;
          _os_log_impl(&dword_188A29000, v12, OS_LOG_TYPE_DEFAULT, "Inserting adaptive image glyph", buf, 2u);
        }

        [(_UIKeyboardStateManager *)self insertAdaptiveImageGlyph:v10];
LABEL_19:

LABEL_30:
        [(_UIKeyboardStateManager *)self setPreviousInputString:0];
        goto LABEL_31;
      }

      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *v21 = 0;
        _os_log_error_impl(&dword_188A29000, v12, OS_LOG_TYPE_ERROR, "Error: adaptiveImageGlyph is nil", v21, 2u);
      }
    }

    if ([(_UIKeyboardStateManager *)self canInsertEmojiImageTextAttachment])
    {
      v10 = _UIStickerCreateEmojiTextAttachmentFromSticker(stickerCopy);
      v13 = _UIKeyboardStickerLog();
      v14 = v13;
      if (v10)
      {
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *v20 = 0;
          _os_log_impl(&dword_188A29000, v14, OS_LOG_TYPE_DEFAULT, "Inserting emoji image text attachment", v20, 2u);
        }

        [(_UIKeyboardStateManager *)self insertEmojiImageTextAttachment:v10];
        goto LABEL_19;
      }

      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *v19 = 0;
        _os_log_error_impl(&dword_188A29000, v14, OS_LOG_TYPE_ERROR, "Error: emojiTextAttachment is nil", v19, 2u);
      }
    }

    if (!stickerCopy)
    {
      v15 = _UIKeyboardStickerLog();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *v18 = 0;
        _os_log_error_impl(&dword_188A29000, v15, OS_LOG_TYPE_ERROR, "Error: sticker is nil", v18, 2u);
      }
    }

    v16 = _UIKeyboardStickerLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *v17 = 0;
      _os_log_impl(&dword_188A29000, v16, OS_LOG_TYPE_DEFAULT, "Inserting non text attachment", v17, 2u);
    }

    [(_UIKeyboardStateManager *)self _insertStickerAsNonTextAttachment:stickerCopy];
    goto LABEL_30;
  }

  v6 = v5;
  v7 = _UIStickerCreateTextInputPayloadFromSticker(stickerCopy);
  if (v7)
  {
    textOperations = [v6 textOperations];
    [textOperations setCustomInfo:v7];

    textOperations2 = [v6 textOperations];
    [textOperations2 setCustomInfoType:0x1EFB7CA10];

    [v6 flushOperations];
  }

LABEL_31:
}

- (void)_insertStickerAsNonTextAttachment:(id)attachment
{
  v24 = *MEMORY[0x1E69E9840];
  attachmentCopy = attachment;
  if (![(_UIKeyboardStateManager *)self canInsertStickerAsTextInputPayload])
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    keyboardWindow = [objc_opt_class() keyboardWindow];
    screen = [keyboardWindow screen];

    if (screen)
    {
      [screen scale];
      v12 = v11;
    }

    else
    {
      v12 = 1.0;
    }

    externalURI = [attachmentCopy externalURI];
    representations = [attachmentCopy representations];
    bakedInRep = [attachmentCopy bakedInRep];
    metadata = [attachmentCopy metadata];
    v7 = _UIStickerItemProviderWithMetadata(externalURI, representations, bakedInRep, 1, metadata, v12);

    if (!v7)
    {
      v17 = _UIKeyboardStickerLog();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v22) = 0;
        _os_log_error_impl(&dword_188A29000, v17, OS_LOG_TYPE_ERROR, "Error: itemProvider is nil", &v22, 2u);
      }
    }

    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    payloadDelegate = [inputDelegateManager delegateRespectingForwardingDelegate:0];

    v19 = _UIKeyboardStickerLog();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = objc_opt_class();
      v21 = NSStringFromClass(v20);
      v22 = 138412290;
      v23 = v21;
      _os_log_impl(&dword_188A29000, v19, OS_LOG_TYPE_DEFAULT, "Inserting image. Responder: %@", &v22, 0xCu);
    }

    [payloadDelegate _insertItemFromProvider:v7 completionHandler:0];
    goto LABEL_19;
  }

  screen = _UIStickerCreateTextInputPayloadFromSticker(attachmentCopy);
  v6 = _UIKeyboardStickerLog();
  v7 = v6;
  if (screen)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v22) = 0;
      _os_log_impl(&dword_188A29000, v7, OS_LOG_TYPE_DEFAULT, "Inserting payload", &v22, 2u);
    }

    v7 = +[UITextInputPayloadController sharedInstance];
    payloadDelegate = [v7 payloadDelegate];
    [payloadDelegate handlePayload:screen withPayloadId:@"com.apple.messages.stageSticker"];
LABEL_19:

    goto LABEL_20;
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v22) = 0;
    _os_log_error_impl(&dword_188A29000, v7, OS_LOG_TYPE_ERROR, "Error: payload is nil", &v22, 2u);
  }

  screen = 0;
LABEL_20:
}

- (void)handleWebViewCredentialsSaveForWebsiteURL:(id)l user:(id)user password:(id)password passwordIsAutoGenerated:(BOOL)generated
{
  generatedCopy = generated;
  passwordCopy = password;
  userCopy = user;
  lCopy = l;
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  [autofillController handleWebviewCredentialsSaveForResponder:inputDelegate WebsiteURL:lCopy user:userCopy password:passwordCopy passwordIsAutoGenerated:generatedCopy];
}

- (BOOL)isTrackpadMode
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  isTrackpadMode = [WeakRetained isTrackpadMode];

  return isTrackpadMode;
}

- (CGRect)subtractKeyboardFrameFromRect:(CGRect)rect inView:(id)view
{
  height = rect.size.height;
  width = rect.size.width;
  y = rect.origin.y;
  x = rect.origin.x;
  viewCopy = view;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained subtractKeyboardFrameFromRect:viewCopy inView:{x, y, width, height}];
  v12 = v11;
  v14 = v13;
  v16 = v15;
  v18 = v17;

  v19 = v12;
  v20 = v14;
  v21 = v16;
  v22 = v18;
  result.size.height = v22;
  result.size.width = v21;
  result.origin.y = v20;
  result.origin.x = v19;
  return result;
}

- (void)adjustCapsLockDelayOverride
{
  v2 = -1.0;
  if (os_variant_has_internal_diagnostics())
  {
    if (TIGetCapsLockDelayOverrideInSecondsValue_onceToken[0] != -1)
    {
      dispatch_once(TIGetCapsLockDelayOverrideInSecondsValue_onceToken, &__block_literal_global_3776);
    }

    mEMORY[0x1E69D9680] = [MEMORY[0x1E69D9680] sharedPreferencesController];
    v4 = [mEMORY[0x1E69D9680] valueForPreferenceKey:@"CapsLockDelayOverrideInSeconds"];

    [v4 floatValue];
    v2 = v5;
  }

  v6 = UIApp;

  [v6 setCapsLockDelayOverride:v2];
}

- (void)clearCapsLockDelayOverrideTimer
{
  updateCapsLockDelayOverrideForNonTyping = [(_UIKeyboardStateManager *)self updateCapsLockDelayOverrideForNonTyping];

  if (updateCapsLockDelayOverrideForNonTyping)
  {
    updateCapsLockDelayOverrideForNonTyping2 = [(_UIKeyboardStateManager *)self updateCapsLockDelayOverrideForNonTyping];
    [updateCapsLockDelayOverrideForNonTyping2 cancel];

    [(_UIKeyboardStateManager *)self setUpdateCapsLockDelayOverrideForNonTyping:0];
  }
}

- (void)showCursorAccessory
{
  [(_UIInvalidatable *)self->m_hideCursorAccessoriesAssertion _invalidate];
  m_hideCursorAccessoriesAssertion = self->m_hideCursorAccessoriesAssertion;
  self->m_hideCursorAccessoriesAssertion = 0;

  m_showCursorAccessory = self->m_showCursorAccessory;
  self->m_showCursorAccessory = 0;
}

- (void)performKeyboardOutputAsInputViewControllerOutput:(id)output textInputSource:(int64_t)source
{
  v10[1] = *MEMORY[0x1E69E9840];
  outputCopy = output;
  v7 = objc_alloc_init(_UIInputViewControllerOutput);
  [(_UIInputViewControllerOutput *)v7 setSource:source];
  v8 = [_UIInputViewKeyboardOutput outputWithKeyboardOutput:outputCopy];

  v10[0] = v8;
  v9 = [MEMORY[0x1E695DEC8] arrayWithObjects:v10 count:1];
  [(_UIInputViewControllerOutput *)v7 setKeyboardOutputs:v9];

  [(_UIKeyboardStateManager *)self _performInputViewControllerOutput:v7];
}

- (BOOL)_shouldRequestInputManagerSyncForKeyboardOutputCallbacks:(id)callbacks
{
  callbacksCopy = callbacks;
  if ([callbacksCopy deletionCount])
  {
    insertionText = [callbacksCopy insertionText];

    if (insertionText)
    {
      insertionText2 = [callbacksCopy insertionText];
    }

    else
    {
      insertionText2 = &stru_1EFB14550;
    }

    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    v9 = [inputDelegateManager callShouldReplaceExtendedRange:objc_msgSend(callbacksCopy withText:"deletionCount") includeMarkedText:{insertionText2, 0}];

    if (v9)
    {

      v7 = 0;
      if (insertionText)
      {
        goto LABEL_16;
      }
    }

    else
    {
      [callbacksCopy setDeletionCount:0];
      if (insertionText)
      {
        [callbacksCopy setInsertionText:0];

LABEL_15:
        v7 = 1;
        goto LABEL_16;
      }

      v7 = 1;
    }
  }

  else
  {
    v7 = 0;
  }

  insertionText3 = [callbacksCopy insertionText];

  if (insertionText3)
  {
    insertionText4 = [callbacksCopy insertionText];
    v12 = [(_UIKeyboardStateManager *)self callShouldInsertText:insertionText4];

    if (!v12)
    {
      [callbacksCopy setInsertionText:0];
      goto LABEL_15;
    }
  }

LABEL_16:

  return v7;
}

- (void)_updateInputViewControllerOutput:(id)output forKeyboardOutput:(id)keyboardOutput
{
  outputCopy = output;
  keyboardOutputCopy = keyboardOutput;
  if (outputCopy && keyboardOutputCopy && ([keyboardOutputCopy didBeginOutput] & 1) == 0)
  {
    insertionText = [keyboardOutputCopy insertionText];

    if (insertionText)
    {
      insertionText2 = [keyboardOutputCopy insertionText];
      newlineCharacterSet = [MEMORY[0x1E696AB08] newlineCharacterSet];
      v10 = [insertionText2 rangeOfCharacterFromSet:newlineCharacterSet];

      if (v10 != 0x7FFFFFFFFFFFFFFFLL)
      {
        [outputCopy setShouldPostReturnKeyNotification:1];
        [(_UIKeyboardStateManager *)self cancelDictationOnSendReturnKeyPressed];
      }
    }

    if ([(_UIKeyboardStateManager *)self _shouldRequestInputManagerSyncForKeyboardOutputCallbacks:keyboardOutputCopy])
    {
      v11 = 1;
      v12 = outputCopy;
    }

    else
    {
      requiresInputManagerSync = [outputCopy requiresInputManagerSync];
      v12 = outputCopy;
      v11 = requiresInputManagerSync;
    }

    [v12 setRequiresInputManagerSync:v11];
    if ([keyboardOutputCopy positionOffset])
    {
      [outputCopy setRequiresInputManagerSync:1];
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager collapseSelectionAndAdjustByOffset:{objc_msgSend(keyboardOutputCopy, "positionOffset")}];

      if (+[UIKeyboard isKeyboardProcess])
      {
        [outputCopy setRequiresInputManagerSync:0];
      }

      else
      {
        [keyboardOutputCopy setPositionOffset:0];
      }
    }

    insertionText3 = [keyboardOutputCopy insertionText];

    if (insertionText3)
    {
      insertionText4 = [keyboardOutputCopy insertionText];
      newlineCharacterSet2 = [MEMORY[0x1E696AB08] newlineCharacterSet];
      v18 = [insertionText4 rangeOfCharacterFromSet:newlineCharacterSet2];

      if (v18 != 0x7FFFFFFFFFFFFFFFLL)
      {
        if ([(UITextInputTraits *)self->m_traits returnKeyGoesToNextResponder])
        {
          [outputCopy setShouldAdvanceResponder:1];
          [outputCopy setShouldPostReturnKeyNotification:0];
          if (v18)
          {
            insertionText5 = [keyboardOutputCopy insertionText];
            v20 = [insertionText5 substringToIndex:v18];
            [keyboardOutputCopy setInsertionText:v20];
          }

          else
          {
            [keyboardOutputCopy setInsertionText:0];
          }
        }
      }
    }

    [keyboardOutputCopy setDidBeginOutput:1];
  }
}

- (void)_processInputViewControllerKeyboardOutput:(id)output executionContext:(id)context
{
  outputCopy = output;
  contextCopy = context;
  _delegateRequiresKeyEvents = [(_UIKeyboardStateManager *)self _delegateRequiresKeyEvents];
  v11[0] = MEMORY[0x1E69E9820];
  v11[1] = 3221225472;
  v11[2] = __86___UIKeyboardStateManager__processInputViewControllerKeyboardOutput_executionContext___block_invoke;
  v11[3] = &unk_1E70F5B18;
  v12 = outputCopy;
  selfCopy = self;
  v15 = _delegateRequiresKeyEvents;
  v14 = contextCopy;
  v9 = contextCopy;
  v10 = outputCopy;
  [(_UIKeyboardStateManager *)self _performKeyboardOutput:v11 respectingForwardingDelegate:0];
}

- (void)_completePerformInputViewControllerOutput:(id)output executionContext:(id)context
{
  outputCopy = output;
  contextCopy = context;
  if (([outputCopy requiresInputManagerSync] & 1) == 0 && self->m_didSyncDocumentStateToInputDelegate)
  {
    [outputCopy setRequiresInputManagerSync:1];
  }

  if ([outputCopy shouldAdvanceResponder])
  {
    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
    _nextKeyResponder = [delegateAsResponder _nextKeyResponder];
    [_nextKeyResponder becomeFirstResponder];
  }

  v9 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v9 currentInputMode];

  if ([currentInputMode isExtensionInputMode])
  {
    primaryLanguage = [outputCopy primaryLanguage];
    if (primaryLanguage)
    {
      v12 = primaryLanguage;
      primaryLanguage2 = [outputCopy primaryLanguage];
      lowercaseString = [primaryLanguage2 lowercaseString];
      v15 = [lowercaseString hasPrefix:@"und"];

      if ((v15 & 1) == 0)
      {
        primaryLanguage3 = [currentInputMode primaryLanguage];
        primaryLanguage4 = [outputCopy primaryLanguage];
        v18 = [primaryLanguage3 isEqualToString:primaryLanguage4];

        if ((v18 & 1) == 0)
        {
          primaryLanguage5 = [outputCopy primaryLanguage];
          [currentInputMode setPrimaryLanguage:primaryLanguage5];

          v20 = +[UIKeyboardInputModeController sharedInputModeController];
          [v20 _inputModeChangedWhileContextTracked];

          v21 = +[UIKeyboardPreferencesController sharedPreferencesController];
          preferencesActions = [v21 preferencesActions];
          identifier = [currentInputMode identifier];
          [preferencesActions setLanguageAwareInputModeLastUsed:identifier];

          if (self->m_hardwareKeyboardAttached)
          {
            [(_UIKeyboardStateManager *)self updateHardwareKeyboardLayout];
          }
        }

        v24 = MEMORY[0x1E695DF58];
        primaryLanguage6 = [outputCopy primaryLanguage];
        v26 = [v24 characterDirectionForLanguage:primaryLanguage6] == 2;

        if (self->m_currentDirection != v26)
        {
          self->m_currentDirection = v26;
          [(_UIKeyboardStateManager *)self setInitialDirection];
        }

        defaultCenter = [MEMORY[0x1E696AD88] defaultCenter];
        [defaultCenter postNotificationName:@"UITextInputCurrentInputModeDidChangeNotification" object:0];

        defaultCenter2 = [MEMORY[0x1E696AD88] defaultCenter];
        [defaultCenter2 postNotificationName:@"UITextInputDidPersistFindUINotification" object:0];

        +[_UIKeyboardUsageTracking keyboardExtensionPrimaryLanguageChanged];
      }
    }
  }

  isExtensionInputMode = [currentInputMode isExtensionInputMode];
  v30 = outputCopy;
  if (isExtensionInputMode)
  {
    hasDictation = [outputCopy hasDictation];

    v30 = outputCopy;
    if (hasDictation)
    {
      hasDictation2 = [outputCopy hasDictation];
      [currentInputMode setExtensionInputModeHasDictation:{objc_msgSend(hasDictation2, "BOOLValue")}];

      v33 = +[UIPeripheralHost sharedInstance];
      inputViews = [v33 inputViews];
      inputView = [inputViews inputView];
      _rootInputWindowController = [inputView _rootInputWindowController];
      [_rootInputWindowController updateKeyboardDockViewVisibility];

      v30 = outputCopy;
    }
  }

  if ([v30 shouldPostReturnKeyNotification])
  {
    defaultCenter3 = [MEMORY[0x1E696AD88] defaultCenter];
    [defaultCenter3 postNotificationName:@"UIKeyboardReturnKeyPressed" object:0];
  }

  v38 = +[UIInputSwitcherView sharedInstance];
  if ([outputCopy shouldAdvanceInputMode])
  {
    identifier2 = [currentInputMode identifier];
    v40 = [identifier2 isEqualToString:@"autofillsignup"];

    if (!v40)
    {
      [(_UIKeyboardStateManager *)self setInputModeToNextInPreferredListWithExecutionContext:contextCopy];
      goto LABEL_58;
    }

    autofillController = [(_UIKeyboardStateManager *)self autofillController];
    [autofillController didOptOutOfAutofillSignup];

    autofillController2 = [(_UIKeyboardStateManager *)self autofillController];
    [autofillController2 optOutASPInTextField];

    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    inputSystemSourceSession = [inputDelegateManager inputSystemSourceSession];

    if (inputSystemSourceSession)
    {
      textOperations = [inputSystemSourceSession textOperations];
      [textOperations setEditingActionSelector:sel_optOutASPInTextField];
      [inputSystemSourceSession flushOperations];
    }

    self->m_usesSystemKeyboardForASP = 1;
    if (+[UIKeyboard usesInputSystemUI])
    {
      v46 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
      remoteInputViewHost = [v46 remoteInputViewHost];

      inputViewSet = [remoteInputViewHost inputViewSet];
      hostedCustomInputView = [inputViewSet hostedCustomInputView];
      if (hostedCustomInputView)
      {
        v50 = hostedCustomInputView;
        shouldShowDockView = [remoteInputViewHost shouldShowDockView];

        if (shouldShowDockView)
        {
          [remoteInputViewHost setInputViewSet:0];
          [remoteInputViewHost updateInputViewsIfNecessary];
        }
      }

      else
      {
      }
    }

    [(_UIKeyboardStateManager *)self recomputeActiveInputModesWithExtensions:0];
    goto LABEL_49;
  }

  [outputCopy inputModeListTouchBegan];
  if (v52 != 0.0)
  {
    v53 = +[UIPeripheralHost sharedInstance];
    inputViews2 = [v53 inputViews];
    inputSystemSourceSession = [inputViews2 inputView];

    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [WeakRetained layout];
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();

    if (isKindOfClass)
    {
      v58 = objc_loadWeakRetained(&self->_presentationDelegate);
      layout2 = [v58 layout];
      [v38 setLayout:layout2];
    }

    inputModeListTouchPhase = [outputCopy inputModeListTouchPhase];
    if (inputModeListTouchPhase < 2)
    {
      if (([v38 isVisible] & 1) == 0)
      {
        [outputCopy inputModeListFromLocation];
        [inputSystemSourceSession convertPoint:0 toView:?];
        v62 = v61;
        v64 = v63;
        [outputCopy inputModeListTouchBegan];
        [v38 showAsHUDFromLocation:inputSystemSourceSession withInputView:v62 touchBegan:{v64, v65}];
      }

      if ([v38 isVisible])
      {
        [outputCopy inputModeListUpdatePoint];
        [inputSystemSourceSession convertPoint:v38 toView:?];
        [v38 updateSelectionWithPoint:?];
      }
    }

    else if (inputModeListTouchPhase == 3)
    {
      if ([v38 isVisible])
      {
        [outputCopy inputModeListUpdatePoint];
        [inputSystemSourceSession convertPoint:v38 toView:?];
        [v38 selectItemAtPoint:?];
      }
    }

    else if (inputModeListTouchPhase == 4)
    {
      [v38 hide];
    }

LABEL_49:
    [contextCopy returnExecutionToParent];

    goto LABEL_58;
  }

  if ([outputCopy shouldDismiss])
  {
    [(_UIKeyboardStateManager *)self dismissKeyboard];
  }

  else if ([outputCopy proceedShouldReturn])
  {
    [(_UIKeyboardStateManager *)self proceedShouldReturnIfNeededForASP];
  }

  else if (([outputCopy setMarkedText] & 1) != 0 || objc_msgSend(outputCopy, "unmarkText"))
  {
    self->m_textInputChangesIgnored = 1;
    if ([outputCopy setMarkedText])
    {
      markedText = [outputCopy markedText];
      selectedRange = [outputCopy selectedRange];
      v69 = v68;
      markedText2 = [outputCopy markedText];
      markedText3 = [outputCopy markedText];
      [(_UIKeyboardStateManager *)self setMarkedText:markedText selectedRange:selectedRange inputString:v69 lastInputString:markedText2 searchString:0 candidateOffset:markedText3 liveConversionSegments:0x7FFFFFFFFFFFFFFFLL highlighSegmentIndex:0, 0x7FFFFFFFFFFFFFFFLL];
    }

    if ([outputCopy unmarkText])
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager2 unmarkText];
    }

    self->m_textInputChangesIgnored = 0;
  }

  else if ([outputCopy requiresInputManagerSync])
  {
    [(_UIKeyboardStateManager *)self syncInputManagerToKeyboardState];
  }

  [contextCopy returnExecutionToParent];
LABEL_58:
}

- (id)physicalKeyboardEventWithInput:(id)input inputFlags:(int)flags
{
  v5 = [UIPhysicalKeyboardEvent _eventWithInput:input inputFlags:*&flags];
  [v5 setSource:self->m_textInputSource];

  return v5;
}

- (void)optOutASPInTextField
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  [autofillController didOptOutOfAutofillSignup];

  autofillController2 = [(_UIKeyboardStateManager *)self autofillController];
  [autofillController2 optOutASPInTextField];
}

- (void)performTextOperationActionSelector:(SEL)selector
{
  v66 = *MEMORY[0x1E69E9840];
  arrowKeyHistory = [(_UIKeyboardStateManager *)self arrowKeyHistory];
  [(_UIKeyboardStateManager *)self setArrowKeyHistory:0];
  if (sel_insertNewline_ == selector || sel_insertNewlineIgnoringFieldEditor_ == selector)
  {
    if ([(_UIKeyboardStateManager *)self performSendAction])
    {
      goto LABEL_90;
    }

    v7 = @"\n";
    goto LABEL_80;
  }

  if (sel_insertLineBreak_ == selector)
  {
    v7 = @"\u2028";
    goto LABEL_80;
  }

  if (sel_performSendAction_ == selector)
  {
    [(_UIKeyboardStateManager *)self performSendAction];
    goto LABEL_90;
  }

  if (sel_performKeyboardActionButtonAction_ == selector)
  {
    [(_UIKeyboardStateManager *)self performKeyboardActionButtonAction];
    goto LABEL_90;
  }

  if (sel_deleteBackward_ == selector)
  {
    if ([(_UIKeyboardStateManager *)self callShouldDeleteWithWordCountForRapidDelete:2 characterCountForRapidDelete:3])
    {
      [(_UIKeyboardStateManager *)self deleteBackwardAndNotify:1];
    }
  }

  else
  {
    if (sel_deleteForward_ != selector)
    {
      if (sel_deleteToBeginningOfLine_ == selector)
      {
        WeakRetained = [(_UIKeyboardStateManager *)self inputDelegateManager];
        [WeakRetained _deleteToStartOfLine];
        goto LABEL_89;
      }

      if (sel_deleteToEndOfParagraph_ == selector)
      {
        WeakRetained = [(_UIKeyboardStateManager *)self inputDelegateManager];
        [WeakRetained _deleteToEndOfParagraph];
        goto LABEL_89;
      }

      if (sel_insertTab_ == selector || sel_insertTabIgnoringFieldEditor_ == selector)
      {
        textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
        if ([textInputTraits isSingleLineDocument])
        {
          v14 = [(_UIKeyboardStateManager *)self handleTabWithShift:0 beforePublicKeyCommands:0];

          if (v14)
          {
            goto LABEL_90;
          }
        }

        else
        {
        }

        v7 = @"\t";
      }

      else
      {
        if (sel_insertBacktab_ == selector)
        {
          goto LABEL_98;
        }

        if (sel_insertSingleQuoteIgnoringSubstitution_ == selector)
        {
          v7 = @"'";
        }

        else
        {
          if (sel_insertDoubleQuoteIgnoringSubstitution_ != selector)
          {
            if (sel_transpose_ == selector)
            {
              WeakRetained = [(_UIKeyboardStateManager *)self inputDelegate];
              [WeakRetained _transpose];
              goto LABEL_89;
            }

            if (sel_selectNextKeyView_ == selector)
            {
              selfCopy2 = self;
              v16 = 0;
              goto LABEL_99;
            }

            if (sel_selectPreviousKeyView_ != selector)
            {
              if (sel_deleteWordBackward_ != selector)
              {
                if (sel_moveWordLeft_ == selector)
                {
                  goto LABEL_105;
                }

                if (sel_moveWordRight_ == selector)
                {
                  goto LABEL_107;
                }

                if (sel_moveBackward_ == selector || sel_moveLeft_ == selector)
                {
                  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
                  WeakRetained = inputDelegateManager;
                  v23 = 0;
                }

                else
                {
                  if (sel_moveBackwardAndModifySelection_ != selector && sel_moveLeftAndModifySelection_ != selector)
                  {
                    if (sel_moveForward_ == selector || sel_moveRight_ == selector)
                    {
                      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                      WeakRetained = inputDelegateManager2;
                      v26 = 0;
                    }

                    else
                    {
                      if (sel_moveForwardAndModifySelection_ != selector && sel_moveRightAndModifySelection_ != selector)
                      {
                        if (sel_moveWordLeftAndModifySelection_ == selector)
                        {
LABEL_117:
                          inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                          WeakRetained = inputDelegateManager3;
                          v18 = 1;
                          goto LABEL_106;
                        }

                        if (sel_moveWordRightAndModifySelection_ == selector)
                        {
LABEL_118:
                          inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                          WeakRetained = inputDelegateManager4;
                          v21 = 1;
                          goto LABEL_108;
                        }

                        if (sel_moveDown_ == selector)
                        {
                          inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                          WeakRetained = inputDelegateManager5;
                          v28 = 0;
                        }

                        else
                        {
                          if (sel_moveDownAndModifySelection_ != selector)
                          {
                            if (sel_moveUp_ == selector)
                            {
                              inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                              WeakRetained = inputDelegateManager6;
                              v30 = 0;
                            }

                            else
                            {
                              if (sel_moveUpAndModifySelection_ != selector)
                              {
                                if (sel_moveWordBackward_ != selector)
                                {
                                  if (sel_moveWordBackwardAndModifySelection_ != selector)
                                  {
                                    if (sel_moveWordForward_ != selector)
                                    {
                                      if (sel_moveWordForwardAndModifySelection_ != selector)
                                      {
                                        if (sel_moveToLeftEndOfLine_ == selector)
                                        {
                                          inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                          WeakRetained = inputDelegateManager7;
                                          v32 = 0;
                                        }

                                        else
                                        {
                                          if (sel_moveToLeftEndOfLineAndModifySelection_ != selector)
                                          {
                                            if (sel_moveToRightEndOfLine_ == selector)
                                            {
                                              inputDelegateManager8 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                              WeakRetained = inputDelegateManager8;
                                              v34 = 0;
                                            }

                                            else
                                            {
                                              if (sel_moveToRightEndOfLineAndModifySelection_ != selector)
                                              {
                                                if (sel_moveToBeginningOfParagraph_ == selector)
                                                {
                                                  inputDelegateManager9 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                                  WeakRetained = inputDelegateManager9;
                                                  v36 = 0;
                                                }

                                                else
                                                {
                                                  if (sel_moveToBeginningOfParagraphAndModifySelection_ != selector)
                                                  {
                                                    if (sel_moveToEndOfParagraph_ == selector)
                                                    {
                                                      inputDelegateManager10 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                                      WeakRetained = inputDelegateManager10;
                                                      v38 = 0;
                                                    }

                                                    else
                                                    {
                                                      if (sel_moveToEndOfParagraphAndModifySelection_ != selector)
                                                      {
                                                        if (sel_moveToBeginningOfDocument_ == selector)
                                                        {
                                                          inputDelegateManager11 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                                          WeakRetained = inputDelegateManager11;
                                                          v40 = 0;
                                                        }

                                                        else
                                                        {
                                                          if (sel_moveToBeginningOfDocumentAndModifySelection_ != selector)
                                                          {
                                                            if (sel_moveToEndOfDocument_ == selector)
                                                            {
                                                              inputDelegateManager12 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                                              WeakRetained = inputDelegateManager12;
                                                              v42 = 0;
                                                            }

                                                            else
                                                            {
                                                              if (sel_moveToEndOfDocumentAndModifySelection_ != selector)
                                                              {
                                                                if (sel_cancelOperation_ == selector)
                                                                {
                                                                  WeakRetained = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                  v43 = [WeakRetained targetForAction:sel__cancelOperation_ withSender:0];
                                                                  _responderForEditing = v43;
                                                                  if (v43)
                                                                  {
                                                                    [v43 _cancelOperation:0];
                                                                  }

                                                                  else
                                                                  {
                                                                    [WeakRetained _nonDestructivelyResignFirstResponder];
                                                                  }
                                                                }

                                                                else
                                                                {
                                                                  if (sel_nonDestructivelyDismissKeyboard_ == selector)
                                                                  {
                                                                    [(_UIKeyboardStateManager *)self nonDestructivelyDismissKeyboard];
                                                                    goto LABEL_90;
                                                                  }

                                                                  if (sel_toggleBoldface_ == selector)
                                                                  {
                                                                    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                    if (!delegateAsResponder)
                                                                    {
                                                                      goto LABEL_90;
                                                                    }

                                                                    v45 = delegateAsResponder;
                                                                    v46 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_toggleBoldface_];

                                                                    if (!v46)
                                                                    {
                                                                      goto LABEL_90;
                                                                    }

                                                                    WeakRetained = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                    _responderForEditing = [WeakRetained _responderForEditing];
                                                                    [_responderForEditing toggleBoldface:0];
                                                                  }

                                                                  else if (sel_toggleItalics_ == selector)
                                                                  {
                                                                    delegateAsResponder2 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                    if (!delegateAsResponder2)
                                                                    {
                                                                      goto LABEL_90;
                                                                    }

                                                                    v48 = delegateAsResponder2;
                                                                    v49 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_toggleItalics_];

                                                                    if (!v49)
                                                                    {
                                                                      goto LABEL_90;
                                                                    }

                                                                    WeakRetained = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                    _responderForEditing = [WeakRetained _responderForEditing];
                                                                    [_responderForEditing toggleItalics:0];
                                                                  }

                                                                  else if (sel_toggleUnderline_ == selector)
                                                                  {
                                                                    delegateAsResponder3 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                    if (!delegateAsResponder3)
                                                                    {
                                                                      goto LABEL_90;
                                                                    }

                                                                    v51 = delegateAsResponder3;
                                                                    v52 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_toggleUnderline_];

                                                                    if (!v52)
                                                                    {
                                                                      goto LABEL_90;
                                                                    }

                                                                    WeakRetained = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                    _responderForEditing = [WeakRetained _responderForEditing];
                                                                    [_responderForEditing toggleUnderline:0];
                                                                  }

                                                                  else
                                                                  {
                                                                    if (sel_performUndo == selector)
                                                                    {
                                                                      delegateAsResponder4 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                      _responderForEditing2 = [delegateAsResponder4 _responderForEditing];
                                                                      WeakRetained = [_responderForEditing2 undoManager];

                                                                      if (WeakRetained && [WeakRetained canUndo])
                                                                      {
                                                                        [WeakRetained undo];
                                                                      }

                                                                      goto LABEL_89;
                                                                    }

                                                                    if (sel_performRedo == selector)
                                                                    {
                                                                      delegateAsResponder5 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                      _responderForEditing3 = [delegateAsResponder5 _responderForEditing];
                                                                      WeakRetained = [_responderForEditing3 undoManager];

                                                                      if (WeakRetained && [WeakRetained canRedo])
                                                                      {
                                                                        [WeakRetained redo];
                                                                      }

                                                                      goto LABEL_89;
                                                                    }

                                                                    if (sel_beginUndoGrouping == selector)
                                                                    {
                                                                      delegateAsResponder6 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                      _responderForEditing4 = [delegateAsResponder6 _responderForEditing];
                                                                      WeakRetained = [_responderForEditing4 undoManager];

                                                                      if (WeakRetained)
                                                                      {
                                                                        [WeakRetained beginUndoGrouping];
                                                                      }

                                                                      goto LABEL_89;
                                                                    }

                                                                    if (sel_endUndoGrouping == selector)
                                                                    {
                                                                      delegateAsResponder7 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                                                      _responderForEditing5 = [delegateAsResponder7 _responderForEditing];
                                                                      WeakRetained = [_responderForEditing5 undoManager];

                                                                      if (WeakRetained)
                                                                      {
                                                                        [WeakRetained endUndoGrouping];
                                                                      }

                                                                      goto LABEL_89;
                                                                    }

                                                                    if (sel_removeSelectedText == selector)
                                                                    {
                                                                      WeakRetained = +[UIDictationController sharedInstance];
                                                                      [WeakRetained removeSelectedText];
                                                                      goto LABEL_89;
                                                                    }

                                                                    if (sel_handleRemoteKeyboardCameraEvent_selfDestruct == selector)
                                                                    {
                                                                      WeakRetained = +[UIKeyboardCameraSession activeSession];
                                                                      [WeakRetained endActiveSession];
                                                                      goto LABEL_89;
                                                                    }

                                                                    if (sel_handleStickerEvent_presentCard == selector)
                                                                    {
                                                                      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
                                                                      [WeakRetained handleStickerEvent_presentCard];
                                                                      goto LABEL_89;
                                                                    }

                                                                    if (sel_lookUpResponderChainForCustomInputView == selector)
                                                                    {
                                                                      [(_UIKeyboardStateManager *)self lookUpResponderChainForCustomInputView];
                                                                      goto LABEL_90;
                                                                    }

                                                                    if (sel_setupForAsyncDelegate == selector)
                                                                    {
                                                                      WeakRetained = +[UIDictationController sharedInstance];
                                                                      [WeakRetained setupForAsyncDelegate];
                                                                      goto LABEL_89;
                                                                    }

                                                                    if (sel__presentDictationMenuIfAllowed == selector)
                                                                    {
                                                                      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
                                                                      [WeakRetained _presentDictationMenuIfAllowed];
                                                                      goto LABEL_89;
                                                                    }

                                                                    if (sel_enableTransientSelectionMode == selector)
                                                                    {
                                                                      [(_UIKeyboardStateManager *)self enableTransientSelectionMode];
                                                                      goto LABEL_90;
                                                                    }

                                                                    if (sel_disableTransientSelectionMode == selector)
                                                                    {
                                                                      [(_UIKeyboardStateManager *)self disableTransientSelectionMode];
                                                                      goto LABEL_90;
                                                                    }

                                                                    if (sel_optOutASPInTextField == selector)
                                                                    {
                                                                      [(_UIKeyboardStateManager *)self optOutASPInTextField];
                                                                      goto LABEL_90;
                                                                    }

                                                                    if (sel_setCursorGlowViewMode == selector)
                                                                    {
                                                                      WeakRetained = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                                                      selectionDisplayInteraction = [WeakRetained selectionDisplayInteraction];
                                                                      _responderForEditing = selectionDisplayInteraction;
                                                                      v62 = 1;
                                                                    }

                                                                    else
                                                                    {
                                                                      if (sel_setTrailingGlowViewMode != selector)
                                                                      {
                                                                        v8 = _UIKeyboardImplLog();
                                                                        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
                                                                        {
                                                                          v63 = NSStringFromSelector(selector);
                                                                          v64 = 138412290;
                                                                          v65 = v63;
                                                                          _os_log_error_impl(&dword_188A29000, v8, OS_LOG_TYPE_ERROR, "Unsupported action selector %@", &v64, 0xCu);
                                                                        }

                                                                        goto LABEL_90;
                                                                      }

                                                                      WeakRetained = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                                                      selectionDisplayInteraction = [WeakRetained selectionDisplayInteraction];
                                                                      _responderForEditing = selectionDisplayInteraction;
                                                                      v62 = 2;
                                                                    }

                                                                    [selectionDisplayInteraction _setGlowViewMode:v62];
                                                                  }
                                                                }

                                                                goto LABEL_113;
                                                              }

                                                              inputDelegateManager12 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                                              WeakRetained = inputDelegateManager12;
                                                              v42 = 1;
                                                            }

                                                            v19 = [inputDelegateManager12 _moveToEndOfDocument:v42 withHistory:arrowKeyHistory];
LABEL_112:
                                                            _responderForEditing = v19;
                                                            [(_UIKeyboardStateManager *)self setArrowKeyHistory:v19];
LABEL_113:

                                                            goto LABEL_89;
                                                          }

                                                          inputDelegateManager11 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                                          WeakRetained = inputDelegateManager11;
                                                          v40 = 1;
                                                        }

                                                        v19 = [inputDelegateManager11 _moveToStartOfDocument:v40 withHistory:arrowKeyHistory];
                                                        goto LABEL_112;
                                                      }

                                                      inputDelegateManager10 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                                      WeakRetained = inputDelegateManager10;
                                                      v38 = 1;
                                                    }

                                                    v19 = [inputDelegateManager10 _moveToEndOfParagraph:v38 withHistory:arrowKeyHistory];
                                                    goto LABEL_112;
                                                  }

                                                  inputDelegateManager9 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                                  WeakRetained = inputDelegateManager9;
                                                  v36 = 1;
                                                }

                                                v19 = [inputDelegateManager9 _moveToStartOfParagraph:v36 withHistory:arrowKeyHistory];
                                                goto LABEL_112;
                                              }

                                              inputDelegateManager8 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                              WeakRetained = inputDelegateManager8;
                                              v34 = 1;
                                            }

                                            v19 = [inputDelegateManager8 _moveToEndOfLine:v34 withHistory:arrowKeyHistory];
                                            goto LABEL_112;
                                          }

                                          inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                          WeakRetained = inputDelegateManager7;
                                          v32 = 1;
                                        }

                                        v19 = [inputDelegateManager7 _moveToStartOfLine:v32 withHistory:arrowKeyHistory];
                                        goto LABEL_112;
                                      }

                                      goto LABEL_118;
                                    }

LABEL_107:
                                    inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                    WeakRetained = inputDelegateManager4;
                                    v21 = 0;
LABEL_108:
                                    v19 = [inputDelegateManager4 _moveToEndOfWord:v21 withHistory:arrowKeyHistory];
                                    goto LABEL_112;
                                  }

                                  goto LABEL_117;
                                }

LABEL_105:
                                inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                                WeakRetained = inputDelegateManager3;
                                v18 = 0;
LABEL_106:
                                v19 = [inputDelegateManager3 _moveToStartOfWord:v18 withHistory:arrowKeyHistory];
                                goto LABEL_112;
                              }

                              inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                              WeakRetained = inputDelegateManager6;
                              v30 = 1;
                            }

                            v19 = [inputDelegateManager6 _moveUp:v30 withHistory:arrowKeyHistory];
                            goto LABEL_112;
                          }

                          inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                          WeakRetained = inputDelegateManager5;
                          v28 = 1;
                        }

                        v19 = [inputDelegateManager5 _moveDown:v28 withHistory:arrowKeyHistory];
                        goto LABEL_112;
                      }

                      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                      WeakRetained = inputDelegateManager2;
                      v26 = 1;
                    }

                    v19 = [inputDelegateManager2 _moveRight:v26 withHistory:arrowKeyHistory];
                    goto LABEL_112;
                  }

                  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
                  WeakRetained = inputDelegateManager;
                  v23 = 1;
                }

                v19 = [inputDelegateManager _moveLeft:v23 withHistory:arrowKeyHistory];
                goto LABEL_112;
              }

              WeakRetained = [(_UIKeyboardStateManager *)self inputDelegateManager];
              [WeakRetained _deleteByWord];
LABEL_89:

              goto LABEL_90;
            }

LABEL_98:
            selfCopy2 = self;
            v16 = 1;
LABEL_99:
            [(_UIKeyboardStateManager *)selfCopy2 handleTabWithShift:v16 beforePublicKeyCommands:0];
            goto LABEL_90;
          }

          v7 = @"";
        }
      }

LABEL_80:
      [(_UIKeyboardStateManager *)self insertTextIfShould:v7];
      goto LABEL_90;
    }

    inputDelegateManager13 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    shouldDeleteForward = [inputDelegateManager13 shouldDeleteForward];

    if (shouldDeleteForward)
    {
      [(_UIKeyboardStateManager *)self deleteForwardAndNotify:1];
    }
  }

LABEL_90:
  arrowKeyHistory2 = [(_UIKeyboardStateManager *)self arrowKeyHistory];

  if (arrowKeyHistory2)
  {
    [(_UIKeyboardStateManager *)self updateForChangedSelection];
  }
}

- (void)setDocumentState:(id)state
{
  v17 = *MEMORY[0x1E69E9840];
  stateCopy = state;
  if (!stateCopy)
  {
    if (os_variant_has_internal_diagnostics())
    {
      if (qword_1ED49D058 != -1)
      {
        dispatch_once(&qword_1ED49D058, &__block_literal_global_803);
      }

      v8 = [qword_1ED49D060 dateByAddingTimeInterval:14400.0];
      v9 = [MEMORY[0x1E695DF00] now];
      v10 = [v8 earlierDate:v9];

      if (v10 == v8)
      {
        v11 = *(__UILogGetCategoryCachedImpl("Assert", &qword_1ED49D068) + 8);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          v13 = 134218242;
          v14 = 1801640960;
          v15 = 2114;
          v16 = @"Nil document state as argument to [UIKeyboardInput setDocumentState:]";
          _os_log_impl(&dword_188A29000, v11, OS_LOG_TYPE_ERROR, "Exception Code %llx - %{public}@", &v13, 0x16u);
        }

        v12 = getpid();
        __UISimulateCrash(v12);
      }
    }

    stateCopy = objc_alloc_init(MEMORY[0x1E69D9590]);
  }

  documentState = [(_UIKeyboardStateManager *)self documentState];
  v6 = [stateCopy isEqual:documentState];

  [(TIKeyboardState *)self->m_keyboardState setDocumentState:stateCopy];
  if ((v6 & 1) == 0)
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    [WeakRetained documentStateDidChange];
  }

  os_variant_has_internal_diagnostics();
}

- (id)_rtiDocumentStateForAutoFillPopover
{
  if (+[UIKeyboard inputUIOOP])
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    documentState = [inputSystemSourceSession documentState];
  }

  else
  {
    documentState = objc_alloc_init(MEMORY[0x1E69C6F38]);
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    inputSystemSourceSession = [inputDelegate textInputView];

    window = [inputSystemSourceSession window];
    [inputSystemSourceSession bounds];
    [inputSystemSourceSession convertRect:window toView:?];
    [documentState setClientFrameInWindow:?];
    [documentState clientFrameInWindow];
    v8 = v7;
    v10 = v9;
    v12 = v11;
    v14 = v13;
    screen = [window screen];
    coordinateSpace = [screen coordinateSpace];
    [window convertRect:coordinateSpace toCoordinateSpace:{v8, v10, v12, v14}];
    v18 = v17;
    v20 = v19;
    v22 = v21;
    v24 = v23;

    if ([window _isHostedInAnotherProcess])
    {
      windowScene = [window windowScene];
      v26 = [UITextEffectsWindow activeTextEffectsWindowForWindowScene:windowScene];
      [v26 hostedViewReference];
      v28 = v27;
      v30 = v29;

      v18 = v18 + v28;
      v20 = v20 + v30;
    }

    [documentState setClientFrameInEntitySpace:{v18, v20, v22, v24}];
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager selectedTextRange];
    start = [selectedTextRange start];
    v34 = start;
    if (start)
    {
      beginningOfDocument = start;
    }

    else
    {
      inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
      beginningOfDocument = [inputDelegate2 beginningOfDocument];
    }

    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager2 caretRectForPosition:beginningOfDocument];
    v39 = v38;
    v41 = v40;
    v43 = v42;
    v45 = v44;

    window2 = [inputSystemSourceSession window];
    [inputSystemSourceSession convertRect:window2 toView:{v39, v41, v43, v45}];
    [documentState setCaretRectInWindow:?];

    documentState2 = [(_UIKeyboardStateManager *)self documentState];
    [documentState setDocumentState:documentState2];
  }

  return documentState;
}

- (void)didClearText
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];

  if (!forwardingInputDelegate)
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    if (inputSystemSourceSession)
    {
      v7 = inputSystemSourceSession;
      textOperations = [inputSystemSourceSession textOperations];
      [textOperations setTextToAssert:&stru_1EFB14550];

      [v7 flushOperations];
      inputSystemSourceSession = v7;
    }
  }
}

- (BOOL)callShouldInsertText:(id)text
{
  textCopy = text;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate = [inputDelegateManager keyInputDelegate];

  LOBYTE(inputDelegateManager) = [(_UIKeyboardStateManager *)self callShouldInsertText:textCopy onDelegate:keyInputDelegate];
  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate2 = [inputDelegateManager2 keyInputDelegate];
  LOBYTE(textCopy) = keyInputDelegate == keyInputDelegate2;

  return textCopy & inputDelegateManager;
}

- (BOOL)insertTextIfShould:(id)should
{
  shouldCopy = should;
  v5 = [(_UIKeyboardStateManager *)self callShouldInsertText:shouldCopy];
  if (v5)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager insertText:shouldCopy];
  }

  return v5;
}

- (BOOL)performSendAction
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  performSendAction = [WeakRetained performSendAction];

  return performSendAction;
}

- (void)performKeyboardActionButtonAction
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained performKeyboardActionButtonAction];
}

- (BOOL)usesAutoDeleteWord
{
  if ([(UITextInputTraits *)self->m_traits isSecureTextEntry])
  {
    return 0;
  }

  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  usesAutoDeleteWord = [inputManagerState usesAutoDeleteWord];

  return usesAutoDeleteWord;
}

- (BOOL)shouldRapidDelete
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  legacyInputDelegate = [inputDelegateManager legacyInputDelegate];
  v5 = (objc_opt_respondsToSelector() & 1) != 0 && [(_UIKeyboardStateManager *)self shouldRapidDeleteWithDelegate];

  return v5;
}

- (BOOL)callShouldDeleteWithWordCountForRapidDelete:(int)delete characterCountForRapidDelete:(int)rapidDelete
{
  v5 = *&delete;
  self->m_textInputChangesIgnored = 1;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  legacyInputDelegate = [inputDelegateManager legacyInputDelegate];
  v9 = objc_opt_respondsToSelector();

  if ((v9 & 1) == 0)
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    v14 = objc_opt_respondsToSelector();

    if ((v14 & 1) == 0)
    {
      v31 = 1;
      goto LABEL_20;
    }

    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager2 selectedTextRange];

    if ([selectedTextRange isEmpty])
    {
      inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
      start = [selectedTextRange start];
      inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      beginningOfDocument = [inputDelegateManager3 beginningOfDocument];
      v21 = [inputDelegate2 comparePosition:start toPosition:beginningOfDocument];

      if (v21)
      {
        inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
        start2 = [selectedTextRange start];
        v24 = [inputDelegate3 positionFromPosition:start2 offset:-1];

        if (v24)
        {
          inputDelegate4 = [(_UIKeyboardStateManager *)self inputDelegate];
          v26 = [selectedTextRange end];
          v27 = [inputDelegate4 textRangeFromPosition:v24 toPosition:v26];

          selectedTextRange = inputDelegate4;
        }

        else
        {
          v27 = 0;
        }

        selectedTextRange = v27;
      }
    }

    if (!selectedTextRange)
    {
      v31 = 1;
      goto LABEL_19;
    }

    inputDelegate5 = [(_UIKeyboardStateManager *)self inputDelegate];
    v31 = [inputDelegate5 shouldChangeTextInRange:selectedTextRange replacementText:&stru_1EFB14550];
LABEL_18:

LABEL_19:
    goto LABEL_20;
  }

  if (![(_UIKeyboardStateManager *)self shouldRapidDeleteWithDelegate])
  {
    selectedTextRange = [(_UIKeyboardStateManager *)self inputDelegateManager];
    inputDelegate5 = [selectedTextRange legacyInputDelegate];
    inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    legacyInputDelegate2 = [inputDelegateManager4 legacyInputDelegate];
    v31 = [inputDelegate5 keyboardInputShouldDelete:legacyInputDelegate2];

    goto LABEL_18;
  }

  usesAutoDeleteWord = [(_UIKeyboardStateManager *)self usesAutoDeleteWord];
  inputDelegate6 = [(_UIKeyboardStateManager *)self inputDelegate];
  v12 = inputDelegate6;
  if (usesAutoDeleteWord)
  {
    [inputDelegate6 _expandSelectionToStartOfWordsBeforeCaretSelection:v5];
  }

  else
  {
    [inputDelegate6 _extendCurrentSelection:-rapidDelete];
  }

  inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  legacyInputDelegate3 = [inputDelegateManager5 legacyInputDelegate];
  inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  legacyInputDelegate4 = [inputDelegateManager6 legacyInputDelegate];
  v31 = [legacyInputDelegate3 keyboardInputShouldDelete:legacyInputDelegate4];

  inputDelegate7 = [(_UIKeyboardStateManager *)self inputDelegate];
  [inputDelegate7 _setCaretSelectionAtEndOfSelection];

  [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegate];
LABEL_20:
  self->m_textInputChangesIgnored = 0;
  return v31;
}

- (void)callChangedDelegate
{
  changedDelegate = [(_UIKeyboardStateManager *)self changedDelegate];
  v4 = objc_opt_respondsToSelector();

  if (v4)
  {
    changedDelegate2 = [(_UIKeyboardStateManager *)self changedDelegate];
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    legacyInputDelegate = [inputDelegateManager legacyInputDelegate];
    [changedDelegate2 keyboardInputChanged:legacyInputDelegate];
  }

  [(_UIKeyboardStateManager *)self setChangedDelegate:0];
}

- (void)setChangedDelegate
{
  changedDelegate = [(_UIKeyboardStateManager *)self changedDelegate];

  if (!changedDelegate)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager keyInputDelegate];
    [(_UIKeyboardStateManager *)self setChangedDelegate:keyInputDelegate];
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateObserverState];

  textSelectionController = [(_UIKeyboardStateManager *)self textSelectionController];
  [textSelectionController textDidChange];
}

- (BOOL)shouldAllowRepeatEvent:(id)event
{
  v20 = *MEMORY[0x1E69E9840];
  eventCopy = event;
  _modifiedInput = [eventCopy _modifiedInput];
  _isDelete = [_modifiedInput _isDelete];

  if ((_isDelete & 1) != 0 || [(_UIKeyboardStateManager *)self canPresentPressAndHoldPopover:eventCopy])
  {
    goto LABEL_7;
  }

  if (![eventCopy _hidEvent])
  {
    LOBYTE(v7) = 0;
    goto LABEL_8;
  }

  if (qword_1ED49D078 != -1)
  {
    dispatch_once(&qword_1ED49D078, &__block_literal_global_816);
  }

  if (([eventCopy _keyCode] - 79) < 4)
  {
LABEL_7:
    LOBYTE(v7) = 1;
  }

  else
  {
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v9 = qword_1ED49D070;
    v7 = [v9 countByEnumeratingWithState:&v15 objects:v19 count:16];
    if (v7)
    {
      v10 = *v16;
      while (2)
      {
        for (i = 0; i != v7; ++i)
        {
          if (*v16 != v10)
          {
            objc_enumerationMutation(v9);
          }

          v12 = *(*(&v15 + 1) + 8 * i);
          _modifiedInput2 = [eventCopy _modifiedInput];
          v14 = [_modifiedInput2 rangeOfCharacterFromSet:v12];

          if (v14 != 0x7FFFFFFFFFFFFFFFLL)
          {
            LOBYTE(v7) = 1;
            goto LABEL_20;
          }
        }

        v7 = [v9 countByEnumeratingWithState:&v15 objects:v19 count:16];
        if (v7)
        {
          continue;
        }

        break;
      }
    }

LABEL_20:
  }

LABEL_8:

  return v7;
}

- (id)_targetForResponderCommand:(SEL)command
{
  delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  _responderForEditing = [delegateAsResponder _responderForEditing];
  v6 = _UIResponderTargetForAction(_responderForEditing, command, 0);

  return v6;
}

- (BOOL)_canHandleResponderCommand:(SEL)command
{
  v4 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:?];
  LOBYTE(command) = [v4 canPerformAction:command withSender:0];

  return command;
}

- (BOOL)_canHandleResponderCommandConservatively:(SEL)conservatively
{
  _delegateRequiresKeyEvents = [(_UIKeyboardStateManager *)self _delegateRequiresKeyEvents];
  v6 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:conservatively];
  v7 = v6;
  if (_delegateRequiresKeyEvents)
  {
    v8 = [v6 canPerformAction:conservatively withSender:0];
  }

  else
  {
    v8 = objc_opt_respondsToSelector();
  }

  v9 = v8;

  return v9 & 1;
}

- (BOOL)_cancelOperation:(BOOL)operation testOnly:(BOOL)only
{
  onlyCopy = only;
  operationCopy = operation;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  LOBYTE(onlyCopy) = [WeakRetained _cancelOperation:operationCopy testOnly:onlyCopy];

  return onlyCopy;
}

- (BOOL)isCurrentEditResponderWebKit
{
  if (WebKitFramework)
  {
    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();
  }

  else
  {
    isKindOfClass = 0;
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  asyncCapableInputDelegate = [inputDelegateManager asyncCapableInputDelegate];
  v7 = asyncCapableInputDelegate != 0;

  return (isKindOfClass | v7) & 1;
}

- (BOOL)handleKeyCommand:(id)command repeatOkay:(BOOL *)okay beforePublicKeyCommands:(BOOL)commands
{
  commandCopy = command;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v19 = 0;
  v11[0] = MEMORY[0x1E69E9820];
  v11[1] = 3221225472;
  v11[2] = __79___UIKeyboardStateManager_handleKeyCommand_repeatOkay_beforePublicKeyCommands___block_invoke;
  v11[3] = &unk_1E70FD2A8;
  commandsCopy = commands;
  v13 = &v16;
  v11[4] = self;
  v9 = commandCopy;
  v12 = v9;
  okayCopy = okay;
  [(_UIKeyboardStateManager *)self performOperations:v11 withTextInputSource:0];
  LOBYTE(okay) = *(v17 + 24);

  _Block_object_dispose(&v16, 8);
  return okay;
}

- (BOOL)shouldShowKeyboardMenu
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate = [inputDelegateManager keyInputDelegate];
  if (keyInputDelegate)
  {
    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
    v6 = [delegateAsResponder _disableAutomaticKeyboardUI] ^ 1;
  }

  else
  {
    LOBYTE(v6) = 0;
  }

  return v6;
}

- (BOOL)inputModeSwitcherVisible
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  inputModeSwitcherVisible = [WeakRetained inputModeSwitcherVisible];

  return inputModeSwitcherVisible;
}

- (void)setInputModeSwitcherVisibleInRemote:(BOOL)remote
{
  remoteCopy = remote;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained setInputModeSwitcherVisibleInRemote:remoteCopy];
}

- (unint64_t)handleKeyCommand:(id)command repeatOkay:(BOOL *)okay options:(unint64_t)options
{
  optionsCopy = options;
  commandCopy = command;
  v311 = 0;
  v312 = &v311;
  v313 = 0x2020000000;
  v314 = 1;
  v310 = 1;
  v309 = 0;
  _delegateRequiresKeyEvents = [(_UIKeyboardStateManager *)self _delegateRequiresKeyEvents];
  liveConversionEnabled = [(_UIKeyboardStateManager *)self liveConversionEnabled];
  v9 = commandCopy;
  _cloneEvent = [v9 _cloneEvent];

  [_cloneEvent _privatize];
  v265 = v9;
  _keyCode = [_cloneEvent _keyCode];
  _gsModifierFlags = [_cloneEvent _gsModifierFlags];
  v263 = _gsModifierFlags & 0x220000;
  if ([_cloneEvent _isGlobeKey])
  {
    if ([_cloneEvent _isKeyDown])
    {
      [(_UIKeyboardStateManager *)self setPreviousGlobeKeyEvent:_cloneEvent];
      v13 = 1;
    }

    else
    {
      if (self->m_previousGlobeKeyEvent)
      {
        [_cloneEvent _hidEvent];
        v14 = BKSHIDEventGetBaseAttributes();
        v13 = ([v14 options] & 0x80) == 0;
      }

      else
      {
        v13 = 1;
      }

      [_cloneEvent timestamp];
      v16 = v15;
      [(UIEvent *)self->m_previousGlobeKeyEvent timestamp];
      if (v16 - v17 > 0.9)
      {
        v13 = 1;
      }

      [(_UIKeyboardStateManager *)self setPreviousGlobeKeyEvent:0];
    }
  }

  else
  {
    if ((_gsModifierFlags & 0x4000000) != 0)
    {
      [(_UIKeyboardStateManager *)self setPreviousGlobeKeyEvent:0];
    }

    v13 = 0;
  }

  mEMORY[0x1E69D4E18] = [MEMORY[0x1E69D4E18] sharedInstance];
  v305[0] = MEMORY[0x1E69E9820];
  v305[1] = 3221225472;
  v305[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke;
  v305[3] = &unk_1E70FD2D0;
  v307 = (_gsModifierFlags & 0x220000) != 0;
  v308 = (_gsModifierFlags & 0x1010000) != 0;
  v267 = _cloneEvent;
  v306 = v267;
  [mEMORY[0x1E69D4E18] logBlock:v305 domain:?];

  if ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) != 1 || [UIApp _areKeyboardHUDsEnabled])
  {
    _isGlobeKey = [v267 _isGlobeKey];
    if (optionsCopy & 1) != 0 || ((_isGlobeKey ^ 1))
    {
      v20 = ((v13 | !-[_UIKeyboardStateManager shouldShowKeyboardMenu](self, "shouldShowKeyboardMenu")) & 1) == 0 && ([v267 keyEventForwardedFromInputUIHost] & 1) == 0 && -[_UIKeyboardStateManager handleInputSwitcherForKeyEvent:](self, "handleInputSwitcherForKeyEvent:", v265);
    }

    else
    {
      v20 = 1;
    }

    if (-[_UIKeyboardStateManager inputModeSwitcherVisible](self, "inputModeSwitcherVisible") && [v267 _isGlobeKey] && objc_msgSend(v267, "_isKeyDown"))
    {
      v21 = +[UIKeyShortcutHUDService sharedHUDService];
      [v21 preventUnintendedSystemHUDPresentationIfNeeded];
    }

    if (v20)
    {
      if (okay)
      {
        *okay = 0;
      }

      v22 = 1;
      goto LABEL_711;
    }
  }

  v258 = optionsCopy & 2;
  if (optionsCopy)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager keyInputDelegate];

    if (!keyInputDelegate)
    {
      v22 = 0;
      if (okay)
      {
        *okay = 0;
      }

      goto LABEL_711;
    }
  }

  else if ((optionsCopy & 2) == 0)
  {
    arrowKeyHistory = [(_UIKeyboardStateManager *)self arrowKeyHistory];
    [(_UIKeyboardStateManager *)self setArrowKeyHistory:0];
    v256 = 0;
    goto LABEL_37;
  }

  arrowKeyHistory = 0;
  v256 = 1;
LABEL_37:
  [(_UIKeyboardStateManager *)self setHandlingKeyCommandFromHardwareKeyboard:1];
  hasEditableMarkedText = [(_UIKeyboardStateManager *)self hasEditableMarkedText];
  if ([(_UIKeyboardStateManager *)self _hasMarkedText])
  {
    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    v27 = [inputManagerState supportsSetPhraseBoundary] ^ 1;
  }

  else
  {
    v27 = 0;
  }

  if (!self->m_candidateList || [(_UIKeyboardStateManager *)self isPredictionViewControllerVisible])
  {
    inlineRectIsVertical = 0;
    v28 = 0;
    v253 = 0;
    isExtendedList = 0;
    goto LABEL_52;
  }

  if ([(UIKeyboardCandidateList *)self->m_candidateList hasCandidates]&& [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet hasCandidates])
  {
    inputForMarkedText = [(TIKeyboardState *)self->m_keyboardState inputForMarkedText];
    if ([inputForMarkedText length])
    {

LABEL_50:
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      candidateController = [WeakRetained candidateController];
      inlineRectIsVertical = [candidateController inlineRectIsVertical];

      isExtendedList = [(UIKeyboardCandidateList *)self->m_candidateList isExtendedList];
      v28 = 1;
      goto LABEL_51;
    }

    currentIndex = [(UIKeyboardCandidateList *)self->m_candidateList currentIndex];

    if (currentIndex != 0x7FFFFFFFFFFFFFFFLL)
    {
      goto LABEL_50;
    }
  }

  inlineRectIsVertical = 0;
  v28 = 0;
  isExtendedList = 0;
LABEL_51:
  v253 = 1;
LABEL_52:
  v254 = v28;
  v34 = _gsModifierFlags & 0x5D90000 | _keyCode;
  if (liveConversionEnabled)
  {
    v35 = hasEditableMarkedText;
  }

  else
  {
    v35 = v28;
  }

  v259 = v35;
  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_2;
  aBlock[3] = &unk_1E70FD2F8;
  aBlock[4] = self;
  v257 = _Block_copy(aBlock);
  v303[0] = MEMORY[0x1E69E9820];
  v303[1] = 3221225472;
  v303[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_3;
  v303[3] = &unk_1E70FD2F8;
  v303[4] = self;
  v261 = _Block_copy(v303);
  v302[0] = MEMORY[0x1E69E9820];
  v302[1] = 3221225472;
  v302[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_4;
  v302[3] = &unk_1E70F3CB0;
  v302[4] = self;
  v36 = _Block_copy(v302);
  v300[0] = MEMORY[0x1E69E9820];
  v300[1] = 3221225472;
  v300[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_5;
  v300[3] = &unk_1E70FD320;
  v300[4] = self;
  v37 = v36;
  v301 = v37;
  v260 = _Block_copy(v300);
  [v267 setKeyCommandCode:_gsModifierFlags & 0x5D90000 | _keyCode];
  [v267 setKeyCommandHandlingBeforePublic:optionsCopy & 1];
  v38 = optionsCopy & _delegateRequiresKeyEvents;
  if (v34 > 524367)
  {
    if (v34 <= 4194385)
    {
      if (v34 <= 1048656)
      {
        if (v34 > 1048649)
        {
          if (v34 <= 1048654)
          {
            if (v34 != 1048650)
            {
              v40 = 1048653;
              goto LABEL_155;
            }

            goto LABEL_157;
          }

          if (v34 == 1048655)
          {
            goto LABEL_151;
          }

          v41 = 1048656;
LABEL_148:
          if (v34 != v41)
          {
            goto LABEL_258;
          }

LABEL_149:
          v309 = 1;
          if (v260[2]())
          {
LABEL_150:
            _canDeleteForward = [(_UIKeyboardStateManager *)self handleMoveCursorToEndOfLine:v263 != 0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 savedHistory:arrowKeyHistory force:inlineRectIsVertical ^ 1 canHandleSelectableInputDelegateCommand:v261 keyEvent:v267];
            goto LABEL_302;
          }

          v76 = objc_loadWeakRetained(&self->_presentationDelegate);
          isPressAndHoldPopoverPresented = [v76 isPressAndHoldPopoverPresented];

          if (isPressAndHoldPopoverPresented)
          {
LABEL_251:
            v89 = objc_loadWeakRetained(&self->_presentationDelegate);
            pressAndHoldPopoverController = [v89 pressAndHoldPopoverController];
            v91 = [pressAndHoldPopoverController handleHardwareKeyboardEvent:v267];
            *(v312 + 24) = v91;

            v44 = 1;
            goto LABEL_303;
          }

LABEL_152:
          _canDeleteForward = [(_UIKeyboardStateManager *)self handleMoveCursorToStartOfLine:v263 != 0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 savedHistory:arrowKeyHistory force:inlineRectIsVertical ^ 1 canHandleSelectableInputDelegateCommand:v261 keyEvent:v267];
          goto LABEL_302;
        }

        if (v34 != 524368)
        {
          if (v34 != 524369)
          {
            if (v34 != 524370)
            {
              goto LABEL_258;
            }

LABEL_221:
            v309 = 1;
            if (!hasEditableMarkedText)
            {
              if (optionsCopy)
              {
                goto LABEL_258;
              }

              if (v27)
              {
                goto LABEL_291;
              }

              if (+[UIKeyboard isKeyboardProcess])
              {
                inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                shouldRespectForwardingInputDelegate = [inputDelegateManager2 shouldRespectForwardingInputDelegate];

                if ((shouldRespectForwardingInputDelegate & 1) == 0)
                {
                  if ((optionsCopy & 2) != 0)
                  {
                    goto LABEL_649;
                  }

                  goto LABEL_648;
                }
              }

              v86 = v261[2](v261, sel__moveToStartOfParagraph_withHistory_);
              v44 = 0;
              *(v312 + 24) = v86;
              if (optionsCopy & 2) != 0 || ((v86 ^ 1))
              {
                goto LABEL_303;
              }

              v277[0] = MEMORY[0x1E69E9820];
              v277[1] = 3221225472;
              v277[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_10;
              v277[3] = &unk_1E70F5AF0;
              v277[4] = self;
              v279 = (_gsModifierFlags & 0x220000) != 0;
              v278 = arrowKeyHistory;
              [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v277];
              v63 = v278;
              goto LABEL_267;
            }

            if ((inlineRectIsVertical & 1) == 0)
            {
              goto LABEL_291;
            }

            v44 = 1;
            goto LABEL_261;
          }

LABEL_161:
          v309 = 1;
          if (!hasEditableMarkedText)
          {
            if (optionsCopy)
            {
              goto LABEL_258;
            }

            if (v27)
            {
              goto LABEL_291;
            }

            if (+[UIKeyboard isKeyboardProcess])
            {
              inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
              shouldRespectForwardingInputDelegate2 = [inputDelegateManager3 shouldRespectForwardingInputDelegate];

              if ((shouldRespectForwardingInputDelegate2 & 1) == 0)
              {
                if ((optionsCopy & 2) != 0)
                {
                  goto LABEL_649;
                }

                goto LABEL_648;
              }
            }

            v80 = v261[2](v261, sel__moveToEndOfParagraph_withHistory_);
            v44 = 0;
            *(v312 + 24) = v80;
            if (optionsCopy & 2) != 0 || ((v80 ^ 1))
            {
              goto LABEL_303;
            }

            v283[0] = MEMORY[0x1E69E9820];
            v283[1] = 3221225472;
            v283[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_8;
            v283[3] = &unk_1E70F5AF0;
            v283[4] = self;
            v285 = (_gsModifierFlags & 0x220000) != 0;
            v284 = arrowKeyHistory;
            [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v283];
            v63 = v284;
            goto LABEL_267;
          }

          v44 = 0;
          if ((inlineRectIsVertical & 1) == 0)
          {
            goto LABEL_303;
          }

LABEL_261:
          v55 = 1;
          goto LABEL_262;
        }

LABEL_210:
        v309 = 1;
        v67 = v260[2]();
        v68 = v67;
        if (!hasEditableMarkedText)
        {
          if (optionsCopy)
          {
            goto LABEL_258;
          }

          if (v27)
          {
            goto LABEL_291;
          }

          if (+[UIKeyboard isKeyboardProcess])
          {
            inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
            shouldRespectForwardingInputDelegate3 = [inputDelegateManager4 shouldRespectForwardingInputDelegate];

            if ((shouldRespectForwardingInputDelegate3 & 1) == 0)
            {
              if ((optionsCopy & 2) != 0)
              {
                goto LABEL_649;
              }

              goto LABEL_648;
            }
          }

          v286[0] = MEMORY[0x1E69E9820];
          v286[1] = 3221225472;
          v286[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_7;
          v286[3] = &unk_1E70FD348;
          v290 = v68;
          v289 = &v311;
          v291 = (optionsCopy & 2) >> 1;
          v288 = v261;
          v286[4] = self;
          v292 = (_gsModifierFlags & 0x220000) != 0;
          v287 = arrowKeyHistory;
          [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v286];

          v63 = v288;
          goto LABEL_267;
        }

        if (inlineRectIsVertical)
        {
          v69 = objc_loadWeakRetained(&self->_presentationDelegate);
          isPressAndHoldPopoverPresented2 = [v69 isPressAndHoldPopoverPresented];

          if (!isPressAndHoldPopoverPresented2)
          {
            goto LABEL_291;
          }

          goto LABEL_251;
        }

        v44 = v67 ^ 1;
        goto LABEL_261;
      }

      if (v34 > 4194379)
      {
        if (v34 <= 4194383)
        {
          if (v34 != 4194380)
          {
            v42 = 4194383;
LABEL_166:
            if (v34 != v42)
            {
              goto LABEL_258;
            }

            v309 = 1;
            v44 = v260[2]();
            if (!hasEditableMarkedText)
            {
              if (optionsCopy)
              {
                goto LABEL_258;
              }

              if (v27)
              {
                goto LABEL_291;
              }

              if (+[UIKeyboard isKeyboardProcess])
              {
                inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                shouldRespectForwardingInputDelegate4 = [inputDelegateManager5 shouldRespectForwardingInputDelegate];

                if ((shouldRespectForwardingInputDelegate4 & 1) == 0)
                {
                  if ((optionsCopy & 2) != 0)
                  {
                    goto LABEL_649;
                  }

                  goto LABEL_648;
                }
              }

              v293[0] = MEMORY[0x1E69E9820];
              v293[1] = 3221225472;
              v293[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_6;
              v293[3] = &unk_1E70FD348;
              v297 = v44;
              v296 = &v311;
              v298 = (optionsCopy & 2) >> 1;
              v295 = v261;
              v293[4] = self;
              v299 = (_gsModifierFlags & 0x220000) != 0;
              v294 = arrowKeyHistory;
              [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v293];

              v63 = v295;
              goto LABEL_267;
            }

            if (inlineRectIsVertical)
            {
              v53 = objc_loadWeakRetained(&self->_presentationDelegate);
              isPressAndHoldPopoverPresented3 = [v53 isPressAndHoldPopoverPresented];

              if (!isPressAndHoldPopoverPresented3)
              {
                goto LABEL_291;
              }

              goto LABEL_251;
            }

            goto LABEL_261;
          }

LABEL_180:
          v309 = 1;
          if (v259)
          {
            goto LABEL_291;
          }

          if (optionsCopy)
          {
            goto LABEL_258;
          }

          if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v56 = objc_claimAutoreleasedReturnValue(), v57 = [v56 shouldRespectForwardingInputDelegate], v56, (v57 & 1) != 0))
          {
            if ([(UITextInputTraits *)self->m_traits isSecureTextEntry]&& ![(UITextInputTraits *)self->m_traits displaySecureTextUsingPlainText])
            {
              inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
              v102 = [inputDelegateManager6 canHandleInputDelegateCommandAction:5];
              *(v312 + 24) = v102;

              v44 = 0;
              if ((optionsCopy & 2) != 0 || (v312[3] & 1) == 0)
              {
                goto LABEL_303;
              }

              inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];
              [inputDelegateManager7 _deleteToEndOfLine];
LABEL_290:

              goto LABEL_291;
            }

            inputDelegateManager8 = [(_UIKeyboardStateManager *)self inputDelegateManager];
            v59 = [inputDelegateManager8 canHandleInputDelegateCommandAction:3];
            *(v312 + 24) = v59;

            v44 = 0;
            if ((optionsCopy & 2) != 0 || (v312[3] & 1) == 0)
            {
              goto LABEL_303;
            }

            [(_UIKeyboardStateManager *)self setDisableSmartInsertDelete:1];
            inputDelegateManager9 = [(_UIKeyboardStateManager *)self inputDelegateManager];
            [inputDelegateManager9 _deleteForwardByWord];
            goto LABEL_189;
          }

          if ((optionsCopy & 2) != 0)
          {
            goto LABEL_649;
          }

LABEL_648:
          [(_UIKeyboardStateManager *)self forwardKeyboardEventBackToDestination:v267];
          goto LABEL_649;
        }

        if (v34 != 4194384)
        {
          goto LABEL_161;
        }

        goto LABEL_210;
      }

      if (v34 != 1048657)
      {
        if (v34 != 1048658)
        {
          v43 = 4194346;
LABEL_122:
          if (v34 != v43)
          {
            goto LABEL_258;
          }

          v309 = 1;
          if (v259)
          {
            goto LABEL_291;
          }

          if (optionsCopy)
          {
            goto LABEL_258;
          }

          if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v46 = objc_claimAutoreleasedReturnValue(), v47 = [v46 shouldRespectForwardingInputDelegate], v46, (v47 & 1) != 0))
          {
            if ([(UITextInputTraits *)self->m_traits isSecureTextEntry]&& ![(UITextInputTraits *)self->m_traits displaySecureTextUsingPlainText])
            {
              inputDelegateManager10 = [(_UIKeyboardStateManager *)self inputDelegateManager];
              v104 = [inputDelegateManager10 canHandleInputDelegateCommandAction:4];
              *(v312 + 24) = v104;

              v44 = 0;
              if ((optionsCopy & 2) != 0 || (v312[3] & 1) == 0)
              {
                goto LABEL_303;
              }

              goto LABEL_220;
            }

            inputDelegateManager11 = [(_UIKeyboardStateManager *)self inputDelegateManager];
            v49 = [inputDelegateManager11 canHandleInputDelegateCommandAction:2];
            *(v312 + 24) = v49;

            v44 = 0;
            if ((optionsCopy & 2) != 0 || (v312[3] & 1) == 0)
            {
              goto LABEL_303;
            }

            [(_UIKeyboardStateManager *)self setDisableSmartInsertDelete:1];
            inputDelegateManager9 = [(_UIKeyboardStateManager *)self inputDelegateManager];
            [inputDelegateManager9 _deleteByWord];
LABEL_189:

            [(_UIKeyboardStateManager *)self setDisableSmartInsertDelete:0];
            goto LABEL_291;
          }

          if ((optionsCopy & 2) != 0)
          {
            goto LABEL_649;
          }

          goto LABEL_648;
        }

        goto LABEL_174;
      }

LABEL_177:
      v309 = 1;
      if (hasEditableMarkedText)
      {
        v44 = 0;
        if ((inlineRectIsVertical & 1) == 0)
        {
          goto LABEL_303;
        }

        goto LABEL_179;
      }

      if (optionsCopy)
      {
        goto LABEL_258;
      }

      if (v27)
      {
        goto LABEL_291;
      }

      if (+[UIKeyboard isKeyboardProcess])
      {
        inputDelegateManager12 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        shouldRespectForwardingInputDelegate5 = [inputDelegateManager12 shouldRespectForwardingInputDelegate];

        if ((shouldRespectForwardingInputDelegate5 & 1) == 0)
        {
          if ((optionsCopy & 2) != 0)
          {
            goto LABEL_649;
          }

          goto LABEL_648;
        }
      }

      v66 = v261[2](v261, sel__moveToEndOfDocument_withHistory_);
      v44 = 0;
      *(v312 + 24) = v66;
      if (optionsCopy & 2) != 0 || ((v66 ^ 1))
      {
        goto LABEL_303;
      }

      v280[0] = MEMORY[0x1E69E9820];
      v280[1] = 3221225472;
      v280[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_9;
      v280[3] = &unk_1E70F5AF0;
      v280[4] = self;
      v282 = (_gsModifierFlags & 0x220000) != 0;
      v281 = arrowKeyHistory;
      [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v280];
      v63 = v281;
LABEL_267:

      goto LABEL_291;
    }

    if (v34 > 16777257)
    {
      if (v34 <= 16777294)
      {
        if (v34 == 16777258)
        {
          goto LABEL_214;
        }

        if (v34 != 16777290)
        {
          v40 = 16777293;
          goto LABEL_155;
        }

LABEL_157:
        v309 = 1;
        _canDeleteForward = [(_UIKeyboardStateManager *)self handleMoveCursorToStartOfLine:v263 != 0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 savedHistory:arrowKeyHistory force:1 canHandleSelectableInputDelegateCommand:v261 keyEvent:v267];
        goto LABEL_302;
      }

      if (v34 <= 16777296)
      {
        if (v34 == 16777295)
        {
          goto LABEL_151;
        }

        v41 = 16777296;
        goto LABEL_148;
      }

      if (v34 == 16777297)
      {
        goto LABEL_177;
      }

      v52 = 16777298;
    }

    else
    {
      if (v34 <= 8388686)
      {
        if (v34 != 4194386)
        {
          if (v34 != 8388682)
          {
            v40 = 8388685;
            goto LABEL_155;
          }

          goto LABEL_157;
        }

        goto LABEL_221;
      }

      if (v34 <= 8388688)
      {
        if (v34 == 8388687)
        {
          goto LABEL_151;
        }

        v41 = 8388688;
        goto LABEL_148;
      }

      if (v34 == 8388689)
      {
        goto LABEL_177;
      }

      v52 = 8388690;
    }

    if (v34 != v52)
    {
      goto LABEL_258;
    }

LABEL_174:
    v309 = 1;
    if (hasEditableMarkedText)
    {
      if (!inlineRectIsVertical)
      {
        goto LABEL_291;
      }

      v44 = 1;
LABEL_179:
      v55 = 4;
LABEL_262:
      [(_UIKeyboardStateManager *)self movePhraseBoundaryToDirection:v44 granularity:v55];
      goto LABEL_291;
    }

    if (optionsCopy)
    {
      goto LABEL_258;
    }

    if (v27)
    {
      goto LABEL_291;
    }

    if (+[UIKeyboard isKeyboardProcess])
    {
      inputDelegateManager13 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      shouldRespectForwardingInputDelegate6 = [inputDelegateManager13 shouldRespectForwardingInputDelegate];

      if ((shouldRespectForwardingInputDelegate6 & 1) == 0)
      {
        if ((optionsCopy & 2) != 0)
        {
          goto LABEL_649;
        }

        goto LABEL_648;
      }
    }

    v62 = v261[2](v261, sel__moveToStartOfDocument_withHistory_);
    v44 = 0;
    *(v312 + 24) = v62;
    if (optionsCopy & 2) != 0 || ((v62 ^ 1))
    {
      goto LABEL_303;
    }

    v274[0] = MEMORY[0x1E69E9820];
    v274[1] = 3221225472;
    v274[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_11;
    v274[3] = &unk_1E70F5AF0;
    v274[4] = self;
    v276 = (_gsModifierFlags & 0x220000) != 0;
    v275 = arrowKeyHistory;
    [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v274];
    v63 = v275;
    goto LABEL_267;
  }

  if (v34 > 81)
  {
    if (v34 <= 65614)
    {
      if (v34 > 155)
      {
        if (v34 <= 65609)
        {
          if (v34 == 156)
          {
            *(v312 + 24) = 1;
            [(_UIKeyboardStateManager *)self handleClear];
            goto LABEL_291;
          }

          if (v34 != 65578)
          {
            goto LABEL_258;
          }

LABEL_214:
          v309 = 1;
          if (v259)
          {
            goto LABEL_291;
          }

          if (optionsCopy)
          {
            goto LABEL_258;
          }

          if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v71 = objc_claimAutoreleasedReturnValue(), v72 = [v71 shouldRespectForwardingInputDelegate], v71, (v72 & 1) != 0))
          {
            inputDelegateManager14 = [(_UIKeyboardStateManager *)self inputDelegateManager];
            v74 = [inputDelegateManager14 canHandleInputDelegateCommandAction:4];
            *(v312 + 24) = v74;

            v44 = 0;
            if ((optionsCopy & 2) != 0 || (v312[3] & 1) == 0)
            {
              goto LABEL_303;
            }

LABEL_220:
            inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];
            [inputDelegateManager7 _deleteToStartOfLine];
            goto LABEL_290;
          }

          if ((optionsCopy & 2) == 0)
          {
            goto LABEL_648;
          }

LABEL_649:
          v44 = 0;
          *(v312 + 24) = 1;
          goto LABEL_303;
        }

        if (v34 != 65610)
        {
          v40 = 65613;
LABEL_155:
          if (v34 == v40)
          {
            v309 = 1;
            _canDeleteForward = [(_UIKeyboardStateManager *)self handleMoveCursorToEndOfLine:v263 != 0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 savedHistory:arrowKeyHistory force:1 canHandleSelectableInputDelegateCommand:v261 keyEvent:v267];
            goto LABEL_302;
          }

          goto LABEL_258;
        }

        goto LABEL_157;
      }

      switch(v34)
      {
        case 82:
          v309 = 1;
          LOBYTE(v252) = v259 ^ 1;
          _canDeleteForward = [(_UIKeyboardStateManager *)self handleVerticalArrow:0 shiftDown:v263 != 0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 isVerticalCandidate:inlineRectIsVertical hasCandidatesForTypedInput:v253 inputDelegateCommandEnabled:v252 canHandleInputDelegateCommand:v257 savedHistory:arrowKeyHistory keyCommandTypeHandled:&v310 keyEvent:v267];
          goto LABEL_302;
        case 144:
          if (![(_UIKeyboardStateManager *)self shouldShowKeyboardMenu]|| [(UITextInputTraits *)self->m_traits isSecureTextEntry])
          {
            goto LABEL_291;
          }

          if ([(_UIKeyboardStateManager *)self shouldApplyKeyboardInputToUIHost])
          {
LABEL_239:
            inputDelegateManager7 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
            v81 = [inputDelegateManager7 synchronousForwardKeyCommandsBeforePublicToUIHost:v267];
            *(v312 + 24) = v81;
            goto LABEL_290;
          }

          v98 = +[UIKeyboardInputModeController sharedInputModeController];
          inputDelegateManager7 = [v98 inputModeLastUsedForLanguage:@"ja_JP"];

          identifier = [inputDelegateManager7 identifier];

          if (!identifier)
          {
            goto LABEL_290;
          }

          break;
        case 145:
          if (![(_UIKeyboardStateManager *)self shouldShowKeyboardMenu])
          {
            goto LABEL_291;
          }

          if ([(_UIKeyboardStateManager *)self shouldApplyKeyboardInputToUIHost])
          {
            goto LABEL_239;
          }

          v96 = +[UIKeyboardInputModeController sharedInputModeController];
          inputDelegateManager7 = [v96 inputModeLastUsedForLanguage:@"ASCIICapable"];

          identifier2 = [inputDelegateManager7 identifier];

          if (!identifier2)
          {
            goto LABEL_290;
          }

          break;
        default:
          goto LABEL_258;
      }

      identifier3 = [inputDelegateManager7 identifier];
      [(_UIKeyboardStateManager *)self switchMode:identifier3 withHUD:0 withDelay:0 fromCapsLock:0];

      goto LABEL_290;
    }

    if (v34 > 65617)
    {
      if (v34 <= 524363)
      {
        if (v34 != 65618)
        {
          v43 = 524330;
          goto LABEL_122;
        }

        goto LABEL_174;
      }

      if (v34 != 524364)
      {
        v42 = 524367;
        goto LABEL_166;
      }

      goto LABEL_180;
    }

    if (v34 != 65615)
    {
      if (v34 != 65616)
      {
        goto LABEL_177;
      }

      goto LABEL_149;
    }

LABEL_151:
    v309 = 1;
    if (!v260[2]())
    {
      goto LABEL_150;
    }

    goto LABEL_152;
  }

  if (v34 <= 75)
  {
    if (v34 <= 46)
    {
      if (v34 <= 44)
      {
        if (v34 == 41)
        {
          _canDeleteForward = [(_UIKeyboardStateManager *)self _cancelOperation:optionsCopy & 1 testOnly:v258 != 0];
          goto LABEL_302;
        }

        if (v34 == 43)
        {
          v309 = 1;
          _canDeleteForward = [(_UIKeyboardStateManager *)self handleTabWithShift:v263 != 0 beforePublicKeyCommands:optionsCopy & 1 isMoveAction:0 testOnly:v258 != 0];
LABEL_302:
          v44 = 0;
          *(v312 + 24) = _canDeleteForward;
          goto LABEL_303;
        }

        goto LABEL_258;
      }

      if (v34 != 45)
      {
LABEL_142:
        v309 = 1;
        if (v254 && [(_UIKeyboardStateManager *)self shouldUsePinyinStyleRowNavigation])
        {
          v310 = 2;
          if ((optionsCopy & 2) == 0)
          {
            v51 = inlineRectIsVertical ^ 1;
LABEL_202:
            [(UIKeyboardCandidateList *)self->m_candidateList showCandidateInForwardDirection:v51 granularity:1];
          }

LABEL_291:
          v44 = 0;
          goto LABEL_303;
        }

        goto LABEL_258;
      }

      goto LABEL_197;
    }

    if ((v34 - 74) >= 2)
    {
      if (v34 != 47)
      {
        if (v34 != 48)
        {
          goto LABEL_258;
        }

        goto LABEL_142;
      }

LABEL_197:
      v309 = 1;
      if (v254)
      {
        if ([(_UIKeyboardStateManager *)self shouldUsePinyinStyleRowNavigation])
        {
          v310 = 2;
          if (_keyCode != 45 || (([(UIKeyboardCandidateList *)self->m_candidateList isExtendedList]| inlineRectIsVertical) & 1) != 0)
          {
            v51 = inlineRectIsVertical;
            if ((optionsCopy & 2) == 0)
            {
              goto LABEL_202;
            }

            goto LABEL_291;
          }
        }
      }

LABEL_258:
      v44 = 0;
      *(v312 + 24) = 0;
      goto LABEL_303;
    }

    goto LABEL_103;
  }

  if (v34 > 78)
  {
    if (v34 == 79)
    {
      v309 = 1;
      v87 = objc_loadWeakRetained(&self->_presentationDelegate);
      isPressAndHoldPopoverPresented4 = [v87 isPressAndHoldPopoverPresented];

      if (!isPressAndHoldPopoverPresented4)
      {
        if (((isExtendedList | v254 ^ 1) & 1) == 0)
        {
          LOBYTE(isExtendedList) = [(_UIKeyboardStateManager *)self cursorIsAtEndOfMarkedText];
        }

        LOBYTE(v252) = isExtendedList;
        _canDeleteForward = [(_UIKeyboardStateManager *)self handleHorizontalArrow:1 shiftDown:v263 != 0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 isVerticalCandidate:inlineRectIsVertical hasCandidatesForTypedInput:v254 shouldNavigateCandidateList:v252 canHandleInputDelegateCommand:v257 savedHistory:arrowKeyHistory keyCommandTypeHandled:&v310 keyEvent:v267];
        goto LABEL_302;
      }
    }

    else
    {
      if (v34 != 80)
      {
        v309 = 1;
        LOBYTE(v252) = v259 ^ 1;
        _canDeleteForward = [(_UIKeyboardStateManager *)self handleVerticalArrow:1 shiftDown:v263 != 0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 isVerticalCandidate:inlineRectIsVertical hasCandidatesForTypedInput:v253 inputDelegateCommandEnabled:v252 canHandleInputDelegateCommand:v257 savedHistory:arrowKeyHistory keyCommandTypeHandled:&v310 keyEvent:v267];
        goto LABEL_302;
      }

      v309 = 1;
      v82 = objc_loadWeakRetained(&self->_presentationDelegate);
      isPressAndHoldPopoverPresented5 = [v82 isPressAndHoldPopoverPresented];

      if (!isPressAndHoldPopoverPresented5)
      {
        if (((isExtendedList | v254 ^ 1) & 1) == 0)
        {
          LOBYTE(isExtendedList) = [(_UIKeyboardStateManager *)self cursorIsAtEndOfMarkedText]&& [(UIKeyboardCandidateList *)self->m_candidateList currentIndex]!= 0x7FFFFFFFFFFFFFFFLL && [(UIKeyboardCandidateList *)self->m_candidateList currentIndex]!= 0;
        }

        LOBYTE(v252) = isExtendedList;
        _canDeleteForward = [(_UIKeyboardStateManager *)self handleHorizontalArrow:0 shiftDown:v263 != 0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 isVerticalCandidate:inlineRectIsVertical hasCandidatesForTypedInput:v254 shouldNavigateCandidateList:v252 canHandleInputDelegateCommand:v257 savedHistory:arrowKeyHistory keyCommandTypeHandled:&v310 keyEvent:v267];
        goto LABEL_302;
      }
    }

    goto LABEL_251;
  }

  if ((v34 - 77) >= 2)
  {
    if (v34 == 76)
    {
      v309 = 1;
      if (v254)
      {
        goto LABEL_291;
      }

      if (!v38)
      {
        if ((optionsCopy & 2) != 0)
        {
          _canDeleteForward = [(_UIKeyboardStateManager *)self _canDeleteForward];
        }

        else
        {
          _canDeleteForward = [(_UIKeyboardStateManager *)self deleteForwardAndNotify:1 producedByDeleteInput:1];
        }

        goto LABEL_302;
      }
    }

    goto LABEL_258;
  }

LABEL_103:
  v44 = 0;
  v45 = ![(_UIKeyboardStateManager *)self _delegateRequiresKeyEvents];
  if ((optionsCopy & 2) != 0)
  {
    LOBYTE(v45) = 0;
  }

  *(v312 + 24) = v45;
LABEL_303:
  if ((v312[3] & 1) != 0 || (v105 = objc_loadWeakRetained(&self->_presentationDelegate), v106 = [v105 isPressAndHoldPopoverPresented], v105, !v106))
  {
    if (v312[3])
    {
      if (v44)
      {
        goto LABEL_316;
      }

LABEL_702:
      if (v310 != 2)
      {
        goto LABEL_705;
      }

      goto LABEL_703;
    }
  }

  else
  {
    v107 = objc_loadWeakRetained(&self->_presentationDelegate);
    pressAndHoldPopoverController2 = [v107 pressAndHoldPopoverController];
    v109 = [pressAndHoldPopoverController2 handleHardwareKeyboardEvent:v267];
    *(v312 + 24) = v109;

    if (v312[3])
    {
      goto LABEL_316;
    }

    v44 = 1;
  }

  v110 = objc_loadWeakRetained(&self->_presentationDelegate);
  isEmojiPopoverPresented = [v110 isEmojiPopoverPresented];

  if (isEmojiPopoverPresented)
  {
    v112 = objc_loadWeakRetained(&self->_presentationDelegate);
    emojiPopoverController = [v112 emojiPopoverController];
    v114 = [emojiPopoverController handleHardwareKeyboardEvent:v267];
    *(v312 + 24) = v114;

    if (v312[3])
    {
      v115 = 3;
      if (v44)
      {
        v115 = 4;
      }

      goto LABEL_317;
    }

LABEL_319:
    v117 = [(_UIKeyboardStateManager *)self handleInputManagerBasedKeybind:v267 testOnly:v258 != 0];
    *(v312 + 24) = v117;
    if (v117)
    {
      v310 = 2;
LABEL_703:
      if ([(_UIKeyboardStateManager *)self usesCandidateSelection])
      {
        goto LABEL_705;
      }

LABEL_704:
      v310 = 0;
      goto LABEL_705;
    }

    _commandModifiedInput = [v267 _commandModifiedInput];
    v119 = _commandModifiedInput;
    if (_commandModifiedInput)
    {
      _modifiedInput = _commandModifiedInput;
    }

    else
    {
      _modifiedInput = [v267 _modifiedInput];
    }

    mEMORY[0x1E69D4E18]2 = [MEMORY[0x1E69D4E18] sharedInstance];
    v272[0] = MEMORY[0x1E69E9820];
    v272[1] = 3221225472;
    v272[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_12;
    v272[3] = &unk_1E70FD370;
    v122 = _modifiedInput;
    v273 = v122;
    [mEMORY[0x1E69D4E18]2 logBlock:v272 domain:@"com.apple.keyboard.UIKit"];

    if ([v122 length])
    {
      v123 = [v122 characterAtIndex:0];
    }

    else
    {
      v123 = 0;
    }

    v124 = v123 | _gsModifierFlags & 0x5FB0000;
    v125 = v312;
    *(v312 + 24) = 1;
    if (v124 <= 16777280)
    {
      if (v124 > 65632)
      {
        if (v124 <= 65653)
        {
          if (v124 != 65633)
          {
            v126 = 99;
            goto LABEL_339;
          }

          goto LABEL_350;
        }

        if (v124 != 65654)
        {
          v137 = 120;
          goto LABEL_362;
        }
      }

      else
      {
        if (v124 <= 65621)
        {
          if (v124 != 65601)
          {
            v126 = 67;
LABEL_339:
            v128 = v126 | 0x10000;
LABEL_344:
            if (v124 == v128 && !v38)
            {
              if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v129 = objc_claimAutoreleasedReturnValue(), v130 = [v129 shouldRespectForwardingInputDelegate], v129, (v130 & 1) != 0))
              {
                delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
                if (delegateAsResponder)
                {
                  v132 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_copy_];
                }

                else
                {
                  v132 = 0;
                }

                *(v312 + 24) = v132;

                if (optionsCopy & 2) == 0 && (v312[3])
                {
                  delegateAsResponder2 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                  _dataOwnerForCopy = [delegateAsResponder2 _dataOwnerForCopy];
                  v271[0] = MEMORY[0x1E69E9820];
                  v271[1] = 3221225472;
                  v271[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_13;
                  v271[3] = &unk_1E70F3590;
                  v271[4] = self;
                  [UIPasteboard _performAsDataOwner:_dataOwnerForCopy block:v271];

                  [(_UIKeyboardStateManager *)self _signalInvocationOfKeyCommandForAction:?];
                  [UIKBAnalyticsDispatcher analyticsDispatchEventTextEditingOperation:@"Copy" trigger:@"HWKeyboard"];
                }

                goto LABEL_374;
              }

              if ((optionsCopy & 2) == 0)
              {
                goto LABEL_638;
              }

LABEL_639:
              *(v312 + 24) = 1;
              goto LABEL_374;
            }

LABEL_373:
            *(v125 + 24) = 0;
            goto LABEL_374;
          }

          goto LABEL_350;
        }

        if (v124 != 65622)
        {
          v137 = 88;
LABEL_362:
          v139 = v137 | 0x10000;
          goto LABEL_366;
        }
      }

LABEL_372:
      v309 = 1;
      if (v38)
      {
        goto LABEL_373;
      }

      if (+[UIKeyboard isKeyboardProcess])
      {
        inputDelegateManager15 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        shouldRespectForwardingInputDelegate7 = [inputDelegateManager15 shouldRespectForwardingInputDelegate];
        v155 = (optionsCopy & 2) != 0 ? 1 : shouldRespectForwardingInputDelegate7;

        if ((v155 & 1) == 0)
        {
          goto LABEL_638;
        }
      }

      delegateAsResponder3 = [(_UIKeyboardStateManager *)self delegateAsResponder];
      if (delegateAsResponder3)
      {
        v157 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_paste_];
      }

      else
      {
        v157 = 0;
      }

      *(v312 + 24) = v157;

      if (optionsCopy & 2) == 0 && (v312[3])
      {
        acceptCurrentCandidate = [(_UIKeyboardStateManager *)self acceptCurrentCandidate];
        delegateAsResponder4 = [(_UIKeyboardStateManager *)self delegateAsResponder];
        _dataOwnerForPaste = [delegateAsResponder4 _dataOwnerForPaste];
        v270[0] = MEMORY[0x1E69E9820];
        v270[1] = 3221225472;
        v270[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_14;
        v270[3] = &unk_1E70F3590;
        v270[4] = self;
        [UIPasteboard _performAsDataOwner:_dataOwnerForPaste block:v270];

        [(_UIKeyboardStateManager *)self _signalInvocationOfKeyCommandForAction:?];
        [UIKBAnalyticsDispatcher analyticsDispatchEventTextEditingOperation:@"Paste" trigger:@"HWKeyboard"];
      }

LABEL_374:
      v144 = v123 | _gsModifierFlags & 0x5D90000u;
      v145 = v312;
      if (v312[3])
      {
        goto LABEL_497;
      }

      if (v144 > 17301589)
      {
        if (v144 > 20971605)
        {
          if (v144 == 20971638)
          {
            goto LABEL_387;
          }

          v146 = 20971606;
        }

        else
        {
          if (v144 == 17301590)
          {
            goto LABEL_387;
          }

          v146 = 17301622;
        }
      }

      else if (v144 > 4259925)
      {
        if (v144 == 4259926)
        {
          goto LABEL_387;
        }

        v146 = 4259958;
      }

      else
      {
        if (v144 == 589910)
        {
          goto LABEL_387;
        }

        v146 = 589942;
      }

      if (v144 != v146)
      {
        v147 = 0;
        *(v312 + 24) = 0;
        goto LABEL_409;
      }

LABEL_387:
      v147 = 0;
      if (v263)
      {
        v309 = 1;
        if (v38)
        {
          *(v312 + 24) = 0;
          goto LABEL_497;
        }

        if (+[UIKeyboard isKeyboardProcess])
        {
          inputDelegateManager16 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          shouldRespectForwardingInputDelegate8 = [inputDelegateManager16 shouldRespectForwardingInputDelegate];
          v150 = (optionsCopy & 2) != 0 ? 1 : shouldRespectForwardingInputDelegate8;

          if ((v150 & 1) == 0)
          {
            [(_UIKeyboardStateManager *)self forwardKeyboardEventBackToDestination:v267];
            goto LABEL_496;
          }
        }

        delegateAsResponder5 = [(_UIKeyboardStateManager *)self delegateAsResponder];
        if (delegateAsResponder5)
        {
          v152 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_pasteAndMatchStyle_];
        }

        else
        {
          v152 = 0;
        }

        *(v312 + 24) = v152;

        v145 = v312;
        v147 = *(v312 + 24);
        if (optionsCopy & 2) == 0 && (v312[3])
        {
          acceptCurrentCandidate2 = [(_UIKeyboardStateManager *)self acceptCurrentCandidate];
          delegateAsResponder6 = [(_UIKeyboardStateManager *)self delegateAsResponder];
          _dataOwnerForPaste2 = [delegateAsResponder6 _dataOwnerForPaste];
          v268[0] = MEMORY[0x1E69E9820];
          v268[1] = 3221225472;
          v268[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_16;
          v268[3] = &unk_1E70F3590;
          v268[4] = self;
          [UIPasteboard _performAsDataOwner:_dataOwnerForPaste2 block:v268];

          [(_UIKeyboardStateManager *)self _signalInvocationOfKeyCommandForAction:?];
          [UIKBAnalyticsDispatcher analyticsDispatchEventTextEditingOperation:@"Paste" trigger:@"HWKeyboard"];
          v145 = v312;
          v147 = *(v312 + 24);
        }
      }

LABEL_409:
      if ((optionsCopy | v147))
      {
        v161 = 0;
      }

      else
      {
        v161 = v124;
      }

      if (v161 <= 16777281)
      {
        if (v161 > 65633)
        {
          if (v161 <= 65640)
          {
            if (v161 != 65634)
            {
              v162 = 101;
              goto LABEL_424;
            }

LABEL_434:
            if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v169 = objc_claimAutoreleasedReturnValue(), v170 = [v169 shouldRespectForwardingInputDelegate], v169, (v170 & 1) != 0))
            {
              delegateAsResponder7 = [(_UIKeyboardStateManager *)self delegateAsResponder];
              if (delegateAsResponder7)
              {
                v172 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_toggleBoldface_];
              }

              else
              {
                v172 = 0;
              }

              *(v312 + 24) = v172;

              v145 = v312;
              if (optionsCopy & 2) == 0 && (v312[3])
              {
                v191 = sel_toggleBoldface_;
                v192 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:sel_toggleBoldface_];
                [v192 toggleBoldface:0];
                goto LABEL_491;
              }

              goto LABEL_497;
            }

            [(_UIKeyboardStateManager *)self performOnInputSourceSessionActionSelector:sel_toggleBoldface_];
            goto LABEL_496;
          }

          if (v161 != 65641)
          {
            v173 = 117;
            goto LABEL_444;
          }
        }

        else
        {
          if (v161 <= 65608)
          {
            if (v161 != 65602)
            {
              v162 = 69;
LABEL_424:
              v164 = v162 | 0x10000;
LABEL_429:
              if (v161 != v164)
              {
                goto LABEL_497;
              }

              if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v165 = objc_claimAutoreleasedReturnValue(), v166 = [v165 shouldRespectForwardingInputDelegate], v165, (v166 & 1) != 0))
              {
                delegateAsResponder8 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                if (delegateAsResponder8)
                {
                  v168 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_useSelectionForFind_];
                }

                else
                {
                  v168 = 0;
                }

                *(v312 + 24) = v168;

                v145 = v312;
                if (optionsCopy & 2) == 0 && (v312[3])
                {
                  v191 = sel_useSelectionForFind_;
                  v192 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:sel_useSelectionForFind_];
                  [v192 useSelectionForFind:0];
LABEL_491:

                  [(_UIKeyboardStateManager *)self _signalInvocationOfKeyCommandForAction:v191];
                  v145 = v312;
                  goto LABEL_497;
                }

                goto LABEL_497;
              }

              [(_UIKeyboardStateManager *)self performOnInputSourceSessionActionSelector:sel_useSelectionForFind_];
              goto LABEL_496;
            }

            goto LABEL_434;
          }

          if (v161 != 65609)
          {
            v173 = 85;
LABEL_444:
            v175 = v173 | 0x10000;
LABEL_448:
            if (v161 != v175)
            {
              goto LABEL_497;
            }

            if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v176 = objc_claimAutoreleasedReturnValue(), v177 = [v176 shouldRespectForwardingInputDelegate], v176, (v177 & 1) != 0))
            {
              delegateAsResponder9 = [(_UIKeyboardStateManager *)self delegateAsResponder];
              if (delegateAsResponder9)
              {
                v179 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_toggleUnderline_];
              }

              else
              {
                v179 = 0;
              }

              *(v312 + 24) = v179;

              v145 = v312;
              if (optionsCopy & 2) == 0 && (v312[3])
              {
                v191 = sel_toggleUnderline_;
                v192 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:sel_toggleUnderline_];
                [v192 toggleUnderline:0];
                goto LABEL_491;
              }

LABEL_497:
              v193 = *(v145 + 24);
              *(v145 + 24) = 1;
              if (v144 > 0x800000)
              {
                if (v144 > 16777285)
                {
                  if (v144 <= 17301573)
                  {
                    v194 = v144 - 16777286;
                    goto LABEL_522;
                  }

                  if (v144 > 20971589)
                  {
                    if (v144 == 20971622)
                    {
                      goto LABEL_589;
                    }

                    v207 = 20971590;
                  }

                  else
                  {
                    if (v144 == 17301574)
                    {
                      goto LABEL_589;
                    }

                    v207 = 17301606;
                  }

                  goto LABEL_588;
                }

                if (v144 <= 8388618)
                {
                  if (v144 <= 8388611)
                  {
                    if (v144 != 8388609)
                    {
                      if (v144 != 8388610)
                      {
                        goto LABEL_689;
                      }

                      goto LABEL_597;
                    }

                    goto LABEL_612;
                  }

                  if (v144 == 8388612)
                  {
LABEL_605:
                    v309 = 1;
                    if (v254)
                    {
                      goto LABEL_690;
                    }

                    if (optionsCopy)
                    {
                      v218 = 0;
LABEL_611:
                      *(v145 + 24) = v218;
                      goto LABEL_690;
                    }

                    v218 = [(_UIKeyboardStateManager *)self deleteForwardAndNotify:1];
LABEL_610:
                    v145 = v312;
                    goto LABEL_611;
                  }

                  if (v144 != 8388613)
                  {
                    v208 = 8388614;
LABEL_575:
                    if (v144 != v208)
                    {
                      goto LABEL_689;
                    }

                    v309 = 1;
                    LOBYTE(v252) = v254;
                    v218 = [_UIKeyboardStateManager handleHorizontalArrow:"handleHorizontalArrow:shiftDown:beforePublicKeyCommands:testOnly:isVerticalCandidate:hasCandidatesForTypedInput:shouldNavigateCandidateList:canHandleInputDelegateCommand:savedHistory:keyCommandTypeHandled:keyEvent:" shiftDown:inlineRectIsVertical ^ 1 beforePublicKeyCommands:v263 != 0 testOnly:optionsCopy & 1 isVerticalCandidate:v258 != 0 hasCandidatesForTypedInput:v252 shouldNavigateCandidateList:v257 canHandleInputDelegateCommand:arrowKeyHistory savedHistory:&v310 keyCommandTypeHandled:v267 keyEvent:?];
                    goto LABEL_610;
                  }

LABEL_619:
                  v309 = 1;
                  if (v259)
                  {
                    goto LABEL_690;
                  }

                  if (optionsCopy)
                  {
                    goto LABEL_590;
                  }

                  if (+[UIKeyboard isKeyboardProcess])
                  {
                    inputDelegateManager17 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                    shouldRespectForwardingInputDelegate9 = [inputDelegateManager17 shouldRespectForwardingInputDelegate];

                    if ((shouldRespectForwardingInputDelegate9 & 1) == 0)
                    {
                      if ((optionsCopy & 2) == 0)
                      {
                        goto LABEL_687;
                      }

                      goto LABEL_688;
                    }
                  }

                  v236 = v257[2](v257, sel__moveToEndOfLine_withHistory_);
                  *(v312 + 24) = v236;
                  if (optionsCopy & 2) != 0 || ((v236 ^ 1))
                  {
                    goto LABEL_690;
                  }

                  self->m_textInputChangesIgnored = 1;
                  inputDelegateManager18 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                  v200 = [inputDelegateManager18 _moveToEndOfLine:v263 != 0 withHistory:arrowKeyHistory];
                  [(_UIKeyboardStateManager *)self setArrowKeyHistory:v200];
                  goto LABEL_626;
                }

                if (v144 <= 8388623)
                {
                  if (v144 != 8388619)
                  {
                    if (v144 != 8388622)
                    {
                      v195 = 8388623;
LABEL_512:
                      if (v144 != v195)
                      {
                        goto LABEL_689;
                      }

                      v309 = 1;
                      if (v259)
                      {
                        goto LABEL_690;
                      }

                      if (optionsCopy)
                      {
                        goto LABEL_590;
                      }

                      if (+[UIKeyboard isKeyboardProcess])
                      {
                        inputDelegateManager19 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                        shouldRespectForwardingInputDelegate10 = [inputDelegateManager19 shouldRespectForwardingInputDelegate];

                        if ((shouldRespectForwardingInputDelegate10 & 1) == 0)
                        {
                          if ((optionsCopy & 2) == 0)
                          {
                            goto LABEL_687;
                          }

                          goto LABEL_688;
                        }
                      }

                      v198 = v257[2](v257, sel__moveLeft_withHistory_);
                      *(v312 + 24) = v198;
                      if (optionsCopy & 2) != 0 || ((v198 ^ 1))
                      {
                        goto LABEL_690;
                      }

                      [(_UIKeyboardStateManager *)self insertTextIfShould:@"\n"];
                      self->m_textInputChangesIgnored = 1;
                      inputDelegateManager18 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                      v200 = [inputDelegateManager18 _moveLeft:0 withHistory:arrowKeyHistory];
                      [(_UIKeyboardStateManager *)self setArrowKeyHistory:v200];
LABEL_626:

                      self->m_textInputChangesIgnored = 0;
                      goto LABEL_690;
                    }

LABEL_609:
                    v309 = 1;
                    LOBYTE(v252) = v259 ^ 1;
                    v218 = [(_UIKeyboardStateManager *)self handleVerticalArrow:1 shiftDown:0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 isVerticalCandidate:inlineRectIsVertical hasCandidatesForTypedInput:v253 inputDelegateCommandEnabled:v252 canHandleInputDelegateCommand:v257 savedHistory:arrowKeyHistory keyCommandTypeHandled:&v310 keyEvent:v267];
                    goto LABEL_610;
                  }

LABEL_598:
                  v309 = 1;
                  if (v259)
                  {
                    goto LABEL_690;
                  }

                  if (optionsCopy)
                  {
                    goto LABEL_590;
                  }

                  if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v227 = objc_claimAutoreleasedReturnValue(), v228 = [v227 shouldRespectForwardingInputDelegate], v227, (v228 & 1) != 0))
                  {
                    inputDelegateManager20 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                    v230 = [inputDelegateManager20 canHandleInputDelegateCommandAction:6];
                    *(v312 + 24) = v230;

                    if (optionsCopy & 2) == 0 && (v312[3])
                    {
                      inputDelegateManager21 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                      [inputDelegateManager21 _deleteToEndOfParagraph];
                      goto LABEL_668;
                    }

                    goto LABEL_690;
                  }

                  if ((optionsCopy & 2) == 0)
                  {
                    goto LABEL_687;
                  }

                  goto LABEL_688;
                }

                if (v144 != 8388624)
                {
                  if (v144 != 8388628)
                  {
                    if (v144 != 8388640)
                    {
                      goto LABEL_689;
                    }

                    goto LABEL_565;
                  }

LABEL_579:
                  v309 = 1;
                  if (v259)
                  {
                    goto LABEL_690;
                  }

                  if (optionsCopy)
                  {
                    goto LABEL_590;
                  }

                  if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v219 = objc_claimAutoreleasedReturnValue(), v220 = [v219 shouldRespectForwardingInputDelegate], v219, (v220 & 1) != 0))
                  {
                    inputDelegateManager22 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                    v222 = [inputDelegateManager22 canHandleInputDelegateCommandAction:0];
                    *(v312 + 24) = v222;

                    if (optionsCopy & 2) == 0 && (v312[3])
                    {
                      inputDelegateManager21 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                      [inputDelegateManager21 transposeCharacters];
                      goto LABEL_668;
                    }

                    goto LABEL_690;
                  }

                  if ((optionsCopy & 2) == 0)
                  {
                    goto LABEL_687;
                  }

                  goto LABEL_688;
                }
              }

              else
              {
                if (v144 <= 1048580)
                {
                  if (v144 <= 589893)
                  {
                    v194 = v144 - 65606;
LABEL_522:
                    if (v194 > 0x34)
                    {
                      goto LABEL_689;
                    }

                    if (((1 << v194) & 0x100000001) == 0)
                    {
                      if (((1 << v194) & 0x200000002) == 0)
                      {
                        if (((1 << v194) & 0x10000000100000) != 0)
                        {
                          if (!v38)
                          {
                            if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v201 = objc_claimAutoreleasedReturnValue(), v202 = [v201 shouldRespectForwardingInputDelegate], v201, (v202 & 1) != 0))
                            {
                              v203 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:sel_undoManager];
                              inputDelegateManager21 = [v203 undoManager];

                              if (inputDelegateManager21)
                              {
                                if (v263)
                                {
                                  canRedo = [inputDelegateManager21 canRedo];
                                  if (optionsCopy & 2) != 0 || ((canRedo ^ 1))
                                  {
                                    goto LABEL_667;
                                  }

                                  [inputDelegateManager21 redo];
                                  [(_UIKeyboardStateManager *)self _signalInvocationOfKeyCommandForAction:?];
                                  v206 = UIKBAnalyticsTextEditingOperationRedo;
                                }

                                else
                                {
                                  canUndo = [inputDelegateManager21 canUndo];
                                  if (optionsCopy & 2) != 0 || ((canUndo ^ 1))
                                  {
                                    goto LABEL_667;
                                  }

                                  [inputDelegateManager21 undo];
                                  [(_UIKeyboardStateManager *)self _signalInvocationOfKeyCommandForAction:?];
                                  v206 = UIKBAnalyticsTextEditingOperationUndo;
                                }

                                [UIKBAnalyticsDispatcher analyticsDispatchEventTextEditingOperation:*v206 trigger:@"HWKeyboard"];
LABEL_667:
                                delegateAsResponder10 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                                *(v312 + 24) = delegateAsResponder10 != 0;

                                goto LABEL_668;
                              }

                              *(v312 + 24) = 0;
LABEL_668:

                              goto LABEL_690;
                            }

                            if ((optionsCopy & 2) != 0)
                            {
                              goto LABEL_688;
                            }

                            goto LABEL_687;
                          }

LABEL_590:
                          *(v145 + 24) = 0;
                          goto LABEL_690;
                        }

LABEL_689:
                        *(v145 + 24) = v193;
                        goto LABEL_690;
                      }

                      if (v38)
                      {
                        goto LABEL_590;
                      }

                      if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v209 = objc_claimAutoreleasedReturnValue(), v210 = [v209 shouldRespectForwardingInputDelegate], v209, (v210 & 1) != 0))
                      {
                        if (v263)
                        {
                          delegateAsResponder11 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                          if (delegateAsResponder11)
                          {
                            v212 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_findPrevious_];
                          }

                          else
                          {
                            v212 = 0;
                          }

                          *(v312 + 24) = v212;

                          if (optionsCopy & 2) == 0 && (v312[3])
                          {
                            v237 = sel_findPrevious_;
                            v238 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:sel_findPrevious_];
                            [v238 findPrevious:0];
                            goto LABEL_677;
                          }
                        }

                        else
                        {
                          delegateAsResponder12 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                          if (delegateAsResponder12)
                          {
                            v241 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_findNext_];
                          }

                          else
                          {
                            v241 = 0;
                          }

                          *(v312 + 24) = v241;

                          if (optionsCopy & 2) == 0 && (v312[3])
                          {
                            v237 = sel_findNext_;
                            v238 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:sel_findNext_];
                            [v238 findNext:0];
                            goto LABEL_677;
                          }
                        }

                        goto LABEL_690;
                      }

                      if ((optionsCopy & 2) == 0)
                      {
                        goto LABEL_687;
                      }

                      goto LABEL_688;
                    }

                    if (v38)
                    {
                      goto LABEL_590;
                    }

                    if (+[UIKeyboard isKeyboardProcess])
                    {
                      inputDelegateManager23 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                      shouldRespectForwardingInputDelegate11 = [inputDelegateManager23 shouldRespectForwardingInputDelegate];

                      if ((shouldRespectForwardingInputDelegate11 & 1) == 0)
                      {
                        if ((optionsCopy & 2) == 0)
                        {
                          goto LABEL_687;
                        }

                        goto LABEL_688;
                      }
                    }

                    if (!v263)
                    {
                      delegateAsResponder13 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                      if (delegateAsResponder13)
                      {
                        v216 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_find_];
                      }

                      else
                      {
                        v216 = 0;
                      }

                      *(v312 + 24) = v216;

                      if (optionsCopy & 2) == 0 && (v312[3])
                      {
                        v237 = sel_find_;
                        v238 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:sel_find_];
                        [v238 find:0];
                        goto LABEL_677;
                      }

                      goto LABEL_690;
                    }

LABEL_570:
                    v145 = v312;
                    goto LABEL_590;
                  }

                  if (v144 > 0x100000)
                  {
                    if (v144 != 1048577)
                    {
                      if (v144 != 1048578)
                      {
                        if (v144 != 1048580)
                        {
                          goto LABEL_689;
                        }

                        goto LABEL_605;
                      }

LABEL_597:
                      v309 = 1;
                      LOBYTE(v252) = v254;
                      v218 = [(_UIKeyboardStateManager *)self handleHorizontalArrow:inlineRectIsVertical shiftDown:v263 != 0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 isVerticalCandidate:inlineRectIsVertical hasCandidatesForTypedInput:v252 shouldNavigateCandidateList:v257 canHandleInputDelegateCommand:arrowKeyHistory savedHistory:&v310 keyCommandTypeHandled:v267 keyEvent:?];
                      goto LABEL_610;
                    }

LABEL_612:
                    v309 = 1;
                    if (v259)
                    {
                      goto LABEL_690;
                    }

                    if (optionsCopy)
                    {
                      goto LABEL_590;
                    }

                    if (+[UIKeyboard isKeyboardProcess])
                    {
                      inputDelegateManager24 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                      shouldRespectForwardingInputDelegate12 = [inputDelegateManager24 shouldRespectForwardingInputDelegate];

                      if ((shouldRespectForwardingInputDelegate12 & 1) == 0)
                      {
                        if ((optionsCopy & 2) == 0)
                        {
                          goto LABEL_687;
                        }

                        goto LABEL_688;
                      }
                    }

                    v233 = v257[2](v257, sel__moveToStartOfLine_withHistory_);
                    *(v312 + 24) = v233;
                    if (optionsCopy & 2) != 0 || ((v233 ^ 1))
                    {
                      goto LABEL_690;
                    }

                    self->m_textInputChangesIgnored = 1;
                    inputDelegateManager18 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                    v200 = [inputDelegateManager18 _moveToStartOfLine:v263 != 0 withHistory:arrowKeyHistory];
                    [(_UIKeyboardStateManager *)self setArrowKeyHistory:v200];
                    goto LABEL_626;
                  }

                  if (v144 == 589894)
                  {
LABEL_589:
                    if (v38)
                    {
                      goto LABEL_590;
                    }

                    if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v223 = objc_claimAutoreleasedReturnValue(), v224 = [v223 shouldRespectForwardingInputDelegate], v223, (v224 & 1) != 0))
                    {
                      delegateAsResponder14 = [(_UIKeyboardStateManager *)self delegateAsResponder];
                      if (delegateAsResponder14)
                      {
                        v226 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_findAndReplace_];
                      }

                      else
                      {
                        v226 = 0;
                      }

                      *(v312 + 24) = v226;

                      if (optionsCopy & 2) == 0 && (v312[3])
                      {
                        v237 = sel_findAndReplace_;
                        v238 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:sel_findAndReplace_];
                        [v238 findAndReplace:0];
LABEL_677:

                        [(_UIKeyboardStateManager *)self _signalInvocationOfKeyCommandForAction:v237];
                      }

LABEL_690:
                      if ((v312[3] & 1) == 0)
                      {
                        v244 = _UIMenuLeafKeyboardShortcutGetLocalizedKeyEquivalent(@".");
                        v245 = [v244 characterAtIndex:0];
                        if (v144 == (v245 | 0x1000000) || v144 == (v245 | 0x10000))
                        {
                          v246 = [(_UIKeyboardStateManager *)self _cancelOperation:optionsCopy & 1 testOnly:v258 != 0];
                          *(v312 + 24) = v246;
                        }

                        if ((v312[3] & 1) == 0)
                        {
                          v247 = [(_UIKeyboardStateManager *)self handleCandidateListNavigation:v144 hasCandidatesForTypedInput:v254 shiftDown:v263 != 0 keyCommandTypeHandled:&v310 allowRepeat:&v309 beforePublic:optionsCopy & 1 keyEvent:v267];
                          *(v312 + 24) = v247;
                          v248 = (optionsCopy & 5) != 0 || v247;
                          if ((v248 & 1) == 0 && (_gsModifierFlags & 0x1010000) != 0)
                          {
                            _delegateRequiresKeyEvents2 = [(_UIKeyboardStateManager *)self _delegateRequiresKeyEvents];
                            *(v312 + 24) = !_delegateRequiresKeyEvents2;
                          }
                        }
                      }

                      if ((v312[3] & 1) == 0)
                      {
                        goto LABEL_704;
                      }

                      goto LABEL_702;
                    }

                    if ((optionsCopy & 2) == 0)
                    {
LABEL_687:
                      [(_UIKeyboardStateManager *)self forwardKeyboardEventBackToDestination:v267];
                    }

LABEL_688:
                    v145 = v312;
                    v193 = 1;
                    goto LABEL_689;
                  }

                  v207 = 589926;
LABEL_588:
                  if (v144 != v207)
                  {
                    goto LABEL_689;
                  }

                  goto LABEL_589;
                }

                if (v144 <= 1048591)
                {
                  if (v144 > 1048586)
                  {
                    if (v144 != 1048587)
                    {
                      if (v144 != 1048590)
                      {
                        v195 = 1048591;
                        goto LABEL_512;
                      }

                      goto LABEL_609;
                    }

                    goto LABEL_598;
                  }

                  if (v144 != 1048581)
                  {
                    v208 = 1048582;
                    goto LABEL_575;
                  }

                  goto LABEL_619;
                }

                if (v144 > 1048607)
                {
                  if (v144 != 1048608)
                  {
                    if (v144 == 4259910)
                    {
                      goto LABEL_589;
                    }

                    v207 = 4259942;
                    goto LABEL_588;
                  }

LABEL_565:
                  if (-[_UIKeyboardStateManager shouldShowKeyboardMenu](self, "shouldShowKeyboardMenu") && ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) != 1 || [UIApp _areKeyboardHUDsEnabled]))
                  {
                    [v267 setKeyCommandCode:v144];
                    if ([(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost])
                    {
                      inputDelegateManager21 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
                      v217 = [inputDelegateManager21 synchronousForwardKeyCommandsBeforePublicToUIHost:v267];
                    }

                    else
                    {
                      inputDelegateManager21 = +[UIInputSwitcher sharedInstance];
                      v217 = [inputDelegateManager21 handleSwitchCommand:v263 != 0 withHUD:1 withDelay:1];
                    }

                    *(v312 + 24) = v217;
                    goto LABEL_668;
                  }

                  goto LABEL_570;
                }

                if (v144 != 1048592)
                {
                  if (v144 != 1048596)
                  {
                    goto LABEL_689;
                  }

                  goto LABEL_579;
                }
              }

              v309 = 1;
              LOBYTE(v252) = v259 ^ 1;
              v218 = [(_UIKeyboardStateManager *)self handleVerticalArrow:0 shiftDown:0 beforePublicKeyCommands:optionsCopy & 1 testOnly:v258 != 0 isVerticalCandidate:inlineRectIsVertical hasCandidatesForTypedInput:v253 inputDelegateCommandEnabled:v252 canHandleInputDelegateCommand:v257 savedHistory:arrowKeyHistory keyCommandTypeHandled:&v310 keyEvent:v267];
              goto LABEL_610;
            }

            [(_UIKeyboardStateManager *)self performOnInputSourceSessionActionSelector:sel_toggleUnderline_];
LABEL_496:
            v145 = v312;
            *(v312 + 24) = 1;
            goto LABEL_497;
          }
        }

LABEL_453:
        if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v180 = objc_claimAutoreleasedReturnValue(), v181 = [v180 shouldRespectForwardingInputDelegate], v180, (v181 & 1) != 0))
        {
          delegateAsResponder15 = [(_UIKeyboardStateManager *)self delegateAsResponder];
          if (delegateAsResponder15)
          {
            v183 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_toggleItalics_];
          }

          else
          {
            v183 = 0;
          }

          *(v312 + 24) = v183;

          v145 = v312;
          if (optionsCopy & 2) == 0 && (v312[3])
          {
            v191 = sel_toggleItalics_;
            v192 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:sel_toggleItalics_];
            [v192 toggleItalics:0];
            goto LABEL_491;
          }

          goto LABEL_497;
        }

        [(_UIKeyboardStateManager *)self performOnInputSourceSessionActionSelector:sel_toggleItalics_];
        goto LABEL_496;
      }

      if (v161 > 16777313)
      {
        if (v161 <= 16777320)
        {
          if (v161 == 16777314)
          {
            goto LABEL_434;
          }

          v163 = 101;
LABEL_428:
          v164 = v163 | 0x1000000;
          goto LABEL_429;
        }

        if (v161 == 16777321)
        {
          goto LABEL_453;
        }

        v174 = 117;
      }

      else
      {
        if (v161 <= 16777288)
        {
          if (v161 == 16777282)
          {
            goto LABEL_434;
          }

          v163 = 69;
          goto LABEL_428;
        }

        if (v161 == 16777289)
        {
          goto LABEL_453;
        }

        v174 = 85;
      }

      v175 = v174 | 0x1000000;
      goto LABEL_448;
    }

    if (v124 > 16777312)
    {
      if (v124 <= 16777333)
      {
        if (v124 != 16777313)
        {
          v127 = 99;
          goto LABEL_343;
        }

LABEL_350:
        if (v254)
        {
          goto LABEL_374;
        }

        if (v38)
        {
          goto LABEL_373;
        }

        if (!+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v133 = objc_claimAutoreleasedReturnValue(), v134 = [v133 shouldRespectForwardingInputDelegate], v133, (v134 & 1) != 0))
        {
          delegateAsResponder16 = [(_UIKeyboardStateManager *)self delegateAsResponder];
          if (delegateAsResponder16)
          {
            v136 = [(_UIKeyboardStateManager *)self _canHandleResponderCommandConservatively:sel_selectAll_];
          }

          else
          {
            v136 = 0;
          }

          *(v312 + 24) = v136;

          if (optionsCopy & 2) == 0 && (v312[3])
          {
            v239 = [(_UIKeyboardStateManager *)self _targetForResponderCommand:sel_selectAll_];
            [v239 selectAll:0];

            [(_UIKeyboardStateManager *)self _signalInvocationOfKeyCommandForAction:?];
          }

          goto LABEL_374;
        }

        if ((optionsCopy & 2) != 0)
        {
          goto LABEL_639;
        }

LABEL_638:
        [(_UIKeyboardStateManager *)self forwardKeyboardEventBackToDestination:v267];
        goto LABEL_639;
      }

      if (v124 == 16777334)
      {
        goto LABEL_372;
      }

      v138 = 120;
    }

    else
    {
      if (v124 <= 16777301)
      {
        if (v124 != 16777281)
        {
          v127 = 67;
LABEL_343:
          v128 = v127 | 0x1000000;
          goto LABEL_344;
        }

        goto LABEL_350;
      }

      if (v124 == 16777302)
      {
        goto LABEL_372;
      }

      v138 = 88;
    }

    v139 = v138 | 0x1000000;
LABEL_366:
    if (v124 != v139 || v38)
    {
      goto LABEL_373;
    }

    if (+[UIKeyboard isKeyboardProcess])
    {
      inputDelegateManager25 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      shouldRespectForwardingInputDelegate13 = [inputDelegateManager25 shouldRespectForwardingInputDelegate];

      if ((shouldRespectForwardingInputDelegate13 & 1) == 0)
      {
        if ((optionsCopy & 2) != 0)
        {
          goto LABEL_639;
        }

        goto LABEL_638;
      }
    }

    delegateAsResponder17 = [(_UIKeyboardStateManager *)self delegateAsResponder];
    if (delegateAsResponder17)
    {
      v143 = [(_UIKeyboardStateManager *)self _canHandleResponderCommand:sel_cut_];
    }

    else
    {
      v143 = 0;
    }

    *(v312 + 24) = v143;

    if (optionsCopy & 2) == 0 && (v312[3])
    {
      delegateAsResponder18 = [(_UIKeyboardStateManager *)self delegateAsResponder];
      _dataOwnerForCopy2 = [delegateAsResponder18 _dataOwnerForCopy];
      v269[0] = MEMORY[0x1E69E9820];
      v269[1] = 3221225472;
      v269[2] = __63___UIKeyboardStateManager_handleKeyCommand_repeatOkay_options___block_invoke_15;
      v269[3] = &unk_1E70F3590;
      v269[4] = self;
      [UIPasteboard _performAsDataOwner:_dataOwnerForCopy2 block:v269];

      [(_UIKeyboardStateManager *)self _signalInvocationOfKeyCommandForAction:?];
      [UIKBAnalyticsDispatcher analyticsDispatchEventTextEditingOperation:@"Cut" trigger:@"HWKeyboard"];
    }

    goto LABEL_374;
  }

  v116 = *(v312 + 24);
  if ((v44 & v116 & 1) == 0)
  {
    if ((v116 & 1) == 0)
    {
      goto LABEL_319;
    }

    goto LABEL_702;
  }

LABEL_316:
  v115 = 4;
LABEL_317:
  v310 = v115;
LABEL_705:
  if (okay)
  {
    *okay = v309;
  }

  [(_UIKeyboardStateManager *)self setHandlingKeyCommandFromHardwareKeyboard:0];
  if ((v256 & 1) == 0)
  {
    arrowKeyHistory2 = [(_UIKeyboardStateManager *)self arrowKeyHistory];

    if (arrowKeyHistory2)
    {
      +[UIKBAnalyticsDispatcher incrementAllowCursorMovementCount];
      [(_UIKeyboardStateManager *)self changingContextWithTrigger:@"arrowKey"];
      [(_UIKeyboardStateManager *)self updateForChangedSelection];
      +[UIKBAnalyticsDispatcher decrementAllowCursorMovementCount];
    }
  }

  v22 = v310;

LABEL_711:
  _Block_object_dispose(&v311, 8);

  return v22;
}

- (void)_signalInvocationOfKeyCommandForAction:(uint64_t)action
{
  if (action)
  {
    v3 = +[_UIMainMenuManager existingManager];
    if (v3)
    {
      v5 = v3;
      v4 = [(UICommand *)UIKeyCommand _originalCommandForAction:a2];
      [v5 userDidInvokeKeyboardShortcut:v4];

      v3 = v5;
    }
  }
}

- (BOOL)handleInputManagerBasedKeybind:(id)keybind testOnly:(BOOL)only
{
  keybindCopy = keybind;
  if ([(_UIKeyboardStateManager *)self isInHardwareKeyboardMode])
  {
    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    keyEventMap = [inputManagerState keyEventMap];
    _modifiedInput = [keybindCopy _modifiedInput];
    _unmodifiedInput = [keybindCopy _unmodifiedInput];
    v11 = [keyEventMap inputEventForInputString:_modifiedInput stringWithoutModifiers:_unmodifiedInput modifierFlags:objc_msgSend(keybindCopy keyboardState:{"_gsModifierFlags"), self->m_keyboardState}];

    v12 = v11 != 0;
    if (v11 && !only)
    {
      if (qword_1ED49D088 != -1)
      {
        dispatch_once(&qword_1ED49D088, &__block_literal_global_885);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      v15[0] = MEMORY[0x1E69E9820];
      v15[1] = 3221225472;
      v15[2] = __67___UIKeyboardStateManager_handleInputManagerBasedKeybind_testOnly___block_invoke_3;
      v15[3] = &unk_1E70FD1B8;
      v15[4] = self;
      v16 = v11;
      [taskQueue performSingleTask:v15 breadcrumb:qword_1ED49D080];

      v12 = 1;
    }
  }

  else
  {
    v12 = 0;
  }

  return v12;
}

- (BOOL)handleCandidateListNavigation:(unsigned int)navigation hasCandidatesForTypedInput:(BOOL)input shiftDown:(BOOL)down keyCommandTypeHandled:(unint64_t *)handled allowRepeat:(BOOL *)repeat beforePublic:(BOOL)public keyEvent:(id)event
{
  downCopy = down;
  inputCopy = input;
  v13 = *&navigation;
  eventCopy = event;
  if (![(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost])
  {
    if (inputCopy)
    {
      if (handled)
      {
        *handled = 2;
      }

      inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
      keyEventMap = [inputManagerState keyEventMap];

      if (keyEventMap)
      {
        v18 = [keyEventMap candidateNumberKey:v13];
      }

      else
      {
        v18 = u_charDigitValue(v13);
      }

      if (v18 != -1 && v18 <= 9)
      {
        if ([(_UIKeyboardStateManager *)self supportsNumberKeySelection]&& (objc_opt_respondsToSelector() & 1) != 0)
        {
          LOBYTE(v18) = [(UIKeyboardCandidateList *)self->m_candidateList handleNumberKey:v18];
        }

        else
        {
          LOBYTE(v18) = 0;
        }

        goto LABEL_40;
      }

      v22 = 0;
      LOBYTE(v18) = 0;
      if (v13 <= 31)
      {
        if (v13 != 10 && v13 != 13)
        {
          goto LABEL_39;
        }
      }

      else if (v13 != 8388618 && v13 != 1048586)
      {
        if (v13 == 32)
        {
          inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
          keyboardBehaviors = [inputManagerState2 keyboardBehaviors];
          _keyboardBehaviorState = [(_UIKeyboardStateManager *)self _keyboardBehaviorState];
          v22 = [keyboardBehaviors keyBehaviorsForState:_keyboardBehaviorState];

          spaceKeyBehavior = [v22 spaceKeyBehavior];
          if (spaceKeyBehavior > 4)
          {
            switch(spaceKeyBehavior)
            {
              case 5:
                [(_UIKeyboardStateManager *)self performKeyBehaviorConfirmFirstCandidate];
                goto LABEL_60;
              case 7:
                [(_UIKeyboardStateManager *)self acceptAutocorrectionWithCompletionHandler:0];
                break;
              case 8:
LABEL_60:
                LOBYTE(v18) = 1;
                goto LABEL_39;
            }
          }

          else
          {
            if ((spaceKeyBehavior - 3) < 2)
            {
              if (repeat)
              {
                *repeat = 1;
              }

              [(UIKeyboardCandidateList *)self->m_candidateList showCandidateInForwardDirection:downCopy ^ 1 granularity:0];
              goto LABEL_60;
            }

            if (spaceKeyBehavior == 2)
            {
              [(_UIKeyboardStateManager *)self performKeyBehaviorConfirm];
              goto LABEL_60;
            }
          }

          LOBYTE(v18) = 0;
        }

LABEL_39:

LABEL_40:
        goto LABEL_47;
      }

      LOBYTE(v18) = [(_UIKeyboardStateManager *)self handleReturnKey:downCopy];
      v22 = 0;
      goto LABEL_39;
    }

    if (![(_UIKeyboardStateManager *)self hasEditableMarkedText])
    {
      goto LABEL_19;
    }

    LOBYTE(v18) = 0;
    v21 = 0;
    if (v13 <= 31)
    {
      if (v13 != 10 && v13 != 13)
      {
        goto LABEL_46;
      }
    }

    else
    {
      if (v13 == 32)
      {
        inputManagerState3 = [(_UIKeyboardStateManager *)self inputManagerState];
        keyboardBehaviors2 = [inputManagerState3 keyboardBehaviors];
        _keyboardBehaviorState2 = [(_UIKeyboardStateManager *)self _keyboardBehaviorState];
        v21 = [keyboardBehaviors2 keyBehaviorsForState:_keyboardBehaviorState2];

        spaceKeyBehavior2 = [v21 spaceKeyBehavior];
        if ((spaceKeyBehavior2 - 2) < 4 || spaceKeyBehavior2 == 8)
        {
          [(_UIKeyboardStateManager *)self updateCandidateDisplay];
          LODWORD(v18) = 1;
          if (handled)
          {
LABEL_44:
            if (v18)
            {
              *handled = 2;
              LOBYTE(v18) = 1;
            }
          }
        }

        else
        {
          LOBYTE(v18) = 0;
        }

LABEL_46:

        goto LABEL_47;
      }

      if (v13 != 8388618 && v13 != 1048586)
      {
        goto LABEL_46;
      }
    }

    LODWORD(v18) = [(_UIKeyboardStateManager *)self handleReturnKey:downCopy];
    v21 = 0;
    if (handled)
    {
      goto LABEL_44;
    }

    goto LABEL_46;
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  v17 = [remoteTextInputPartner synchronousForwardKeyCommandsBeforePublicToUIHost:eventCopy];

  if (!v17)
  {
LABEL_19:
    LOBYTE(v18) = 0;
    goto LABEL_47;
  }

  if (handled)
  {
    *handled = 2;
  }

  LOBYTE(v18) = 1;
  if (v13 == 32 && repeat)
  {
    *repeat = 1;
  }

LABEL_47:

  return v18;
}

- (BOOL)handleReturnKey:(BOOL)key
{
  keyCopy = key;
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  keyboardBehaviors = [inputManagerState keyboardBehaviors];
  _keyboardBehaviorState = [(_UIKeyboardStateManager *)self _keyboardBehaviorState];
  v8 = [keyboardBehaviors keyBehaviorsForState:_keyboardBehaviorState];

  returnKeyBehavior = [v8 returnKeyBehavior];
  performReturnAction = 0;
  if (returnKeyBehavior > 4)
  {
    switch(returnKeyBehavior)
    {
      case 5:
        [(_UIKeyboardStateManager *)self performKeyBehaviorConfirmFirstCandidate];
        goto LABEL_11;
      case 9:
        WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
        layout = [WeakRetained layout];
        performReturnAction = [layout performReturnAction];

        break;
      case 10:
        [(_UIKeyboardStateManager *)self performKeyBehaviorCommitInline];
        goto LABEL_11;
    }
  }

  else
  {
    if ((returnKeyBehavior - 3) < 2)
    {
      [(UIKeyboardCandidateList *)self->m_candidateList showCandidateInForwardDirection:!keyCopy granularity:0];
LABEL_11:
      performReturnAction = 1;
      goto LABEL_12;
    }

    if (returnKeyBehavior == 2)
    {
      [(_UIKeyboardStateManager *)self performKeyBehaviorConfirm];
      goto LABEL_11;
    }
  }

LABEL_12:

  return performReturnAction;
}

- (void)handleEmojiPopoverKeyCommand
{
  if ([(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost])
  {
    WeakRetained = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [WeakRetained forwardInputDestinationEventToUIHost:sel_handleEmojiPopoverKeyCommand];
  }

  else
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    if ([WeakRetained canPresentOrDismissEmojiPopover])
    {
      hasEditableMarkedText = [(_UIKeyboardStateManager *)self hasEditableMarkedText];

      if (hasEditableMarkedText)
      {
        return;
      }

      v4 = objc_loadWeakRetained(&self->_presentationDelegate);
      isEmojiPopoverPresented = [v4 isEmojiPopoverPresented];

      v6 = objc_loadWeakRetained(&self->_presentationDelegate);
      v7 = v6;
      if (isEmojiPopoverPresented)
      {
        WeakRetained = v6;
        emojiPopoverController = [WeakRetained emojiPopoverController];
        [WeakRetained dismissKeyboardPopover:emojiPopoverController beforeCleanup:0 completion:0];
      }

      else
      {
        isEmojiPopoverVisibleOrDismissing = [v6 isEmojiPopoverVisibleOrDismissing];

        if (isEmojiPopoverVisibleOrDismissing)
        {
          return;
        }

        WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
        [WeakRetained presentEmojiPopoverViaTrigger:@"keyboardShortcut" completion:0];
      }
    }
  }
}

- (BOOL)currentKeyboardTraitsAllowCandidateBarWhileIgnoringHidePredictionTrait:(BOOL)trait
{
  if ([(_UIKeyboardStateManager *)self keyboardIsKeyPad])
  {
    if (![(_UIKeyboardStateManager *)self canUseCandidateBarAsSupplementToInlineView]&& ![(TIKeyboardCandidateResultSet *)self->m_candidateResultSet hasOnlySlottedCandidates])
    {
      m_predictionType = self->m_predictionType;
      if (m_predictionType != 4 && m_predictionType != 2)
      {
        return 0;
      }
    }
  }

  isSecureTextEntry = [(UITextInputTraits *)self->m_traits isSecureTextEntry];
  result = !isSecureTextEntry;
  if (!isSecureTextEntry && !trait)
  {
    return ![(UITextInputTraits *)self->m_traits hidePrediction];
  }

  return result;
}

- (BOOL)shouldShowCandidateBar
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  shouldShowCandidateBar = [WeakRetained shouldShowCandidateBar];

  return shouldShowCandidateBar;
}

+ (Class)layoutClassForInputMode:(id)mode keyboardType:(int64_t)type screenTraits:(id)traits
{
  typeCopy = type;
  modeCopy = mode;
  traitsCopy = traits;
  if ([modeCopy isEqualToString:@"intl_HWR"])
  {
    v9 = 0;
  }

  else
  {
    if (UIKeyboardInputModeWithTypeUsesKBStar(modeCopy, typeCopy))
    {
      [objc_opt_class() _subclassForScreenTraits:traitsCopy];
    }

    else
    {
      UIKeyboardLayoutClassForInputMode(modeCopy);
    }
    v9 = ;
  }

  return v9;
}

- (double)timestampOfLastTouchesEnded
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  [layout timestampOfLastTouchesEnded];
  v5 = v4;

  return v5;
}

- (BOOL)shouldAllowSelectionGestures:(BOOL)gestures atPoint:(CGPoint)point toBegin:(BOOL)begin
{
  beginCopy = begin;
  y = point.y;
  x = point.x;
  gesturesCopy = gestures;
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  if (inputDelegate && ![(_UIKeyboardStateManager *)self isRotating])
  {
    textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
    isSecureTextEntry = [textInputTraits isSecureTextEntry];

    if (isSecureTextEntry & 1) != 0 || -[_UIKeyboardStateManager usesCandidateSelection](self, "usesCandidateSelection") && (UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) != 1 && (WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate), [WeakRetained candidateController], textInputTraits = objc_claimAutoreleasedReturnValue(), isSecureTextEntry = objc_msgSend(textInputTraits, "activeCandidateViewType"), textInputTraits, WeakRetained, (isSecureTextEntry & 2) != 0) && (v18 = objc_loadWeakRetained(&self->_presentationDelegate), objc_msgSend(v18, "candidateController"), textInputTraits = objc_claimAutoreleasedReturnValue(), isSecureTextEntry = objc_msgSend(textInputTraits, "barIsExtended"), textInputTraits, v18, (isSecureTextEntry))
    {
      LOBYTE(v13) = 0;
      return v13;
    }

    inputDelegate = objc_loadWeakRetained(&self->_presentationDelegate);
    keyboardLayoutIsInAnotherProcess = [inputDelegate keyboardLayoutIsInAnotherProcess];
    if (keyboardLayoutIsInAnotherProcess)
    {
      goto LABEL_15;
    }

    textInputTraits = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [textInputTraits layout];
    if (!layout)
    {
      LOBYTE(v13) = 0;
LABEL_20:

      goto LABEL_4;
    }

    isSecureTextEntry = layout;
    v5 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v5 layout];
    if ([layout2 shouldAllowSelectionGestures:gesturesCopy atPoint:beginCopy toBegin:{x, y}])
    {
LABEL_15:
      v21 = objc_loadWeakRetained(&self->_presentationDelegate);
      _rootInputWindowController = [v21 _rootInputWindowController];
      v13 = [_rootInputWindowController isTransitioningBetweenFloatingStates] ^ 1;

      if (keyboardLayoutIsInAnotherProcess)
      {
        goto LABEL_4;
      }
    }

    else
    {
      LOBYTE(v13) = 0;
    }

    goto LABEL_20;
  }

  LOBYTE(v13) = 0;
LABEL_4:

  return v13;
}

- (void)setTwoFingerTapTimestamp:(double)timestamp
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  [layout setTwoFingerTapTimestamp:timestamp];
}

- (void)updateInputAssistantButtonItems
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateInputAssistantButtonItems];
}

- (unsigned)setMarkedText:(id)text selectedRange:(_NSRange)range inputString:(id)string lastInputString:(id)inputString searchString:(id)searchString candidateOffset:(int64_t)offset liveConversionSegments:(id)segments highlighSegmentIndex:(unint64_t)self0
{
  length = range.length;
  location = range.location;
  textCopy = text;
  stringCopy = string;
  inputStringCopy = inputString;
  searchStringCopy = searchString;
  segmentsCopy = segments;
  [(_UIKeyboardStateManager *)self setCandidateViewOffset:offset];
  if ([(_UIKeyboardStateManager *)self liveConversionEnabled]|| [(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost])
  {
    v18 = [objc_alloc(MEMORY[0x1E696AD40]) initWithString:textCopy];
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    caretVisible = [WeakRetained caretVisible];

    if ((index == 0x7FFFFFFFFFFFFFFFLL) != caretVisible)
    {
      v21 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v21 setCaretVisible:index == 0x7FFFFFFFFFFFFFFFLL];
    }

    v38 = 0;
    v39 = &v38;
    v40 = 0x3010000000;
    v41 = "";
    v42 = 0;
    v43 = 0;
    v34[0] = MEMORY[0x1E69E9820];
    v34[1] = 3221225472;
    v34[2] = __156___UIKeyboardStateManager_setMarkedText_selectedRange_inputString_lastInputString_searchString_candidateOffset_liveConversionSegments_highlighSegmentIndex___block_invoke;
    v34[3] = &unk_1E70FD398;
    v22 = v18;
    v36 = &v38;
    indexCopy = index;
    v35 = v22;
    [segmentsCopy enumerateObjectsUsingBlock:v34];
    [(_UIKeyboardStateManager *)self _configureMarkedTextAttributesForConversion:v22 selectedRange:location highlightRange:length, v39[4], v39[5]];
    v24 = inputStringCopy;
    v23 = stringCopy;
    v25 = [v22 copy];
    LOBYTE(v30) = 1;
    v26 = [(_UIKeyboardStateManager *)self _setAttributedMarkedText:v25 selectedRange:location inputString:length lastInputString:stringCopy searchString:inputStringCopy compareAttributes:searchStringCopy, v30];

    _Block_object_dispose(&v38, 8);
  }

  else if (textCopy)
  {
    v29 = [objc_alloc(MEMORY[0x1E696AD40]) initWithString:textCopy];
    [(_UIKeyboardStateManager *)self _configureMarkedTextAttributesForConversion:v29 selectedRange:location highlightRange:length, 0, 0];
    LOBYTE(v30) = 0;
    v24 = inputStringCopy;
    v23 = stringCopy;
    v26 = [(_UIKeyboardStateManager *)self _setAttributedMarkedText:v29 selectedRange:location inputString:length lastInputString:stringCopy searchString:inputStringCopy compareAttributes:searchStringCopy, v30];
  }

  else
  {
    v26 = 0;
    v24 = inputStringCopy;
    v23 = stringCopy;
  }

  [(_UIKeyboardStateManager *)self updateShiftState];
  v27 = objc_loadWeakRetained(&self->_presentationDelegate);
  [v27 updateHostedInlineCandidateView];

  return v26;
}

- (void)_configureMarkedTextAttributesForConversion:(id)conversion selectedRange:(_NSRange)range highlightRange:(_NSRange)highlightRange
{
  length = highlightRange.length;
  location = highlightRange.location;
  v7 = range.length;
  v8 = range.location;
  conversionCopy = conversion;
  v10 = [conversionCopy length];
  array = [MEMORY[0x1E695DF70] array];
  if (+[UIKeyboard isRedesignedTextCursorEnabled])
  {
    [conversionCopy beginEditing];
    v12 = *off_1E70ECAD8;
    [conversionCopy addAttribute:*off_1E70ECAD8 value:&unk_1EFE30040 range:{0, v10}];
    if (length)
    {
      [conversionCopy addAttribute:v12 value:&unk_1EFE30028 range:{location, length}];
    }

    [array addObject:v12];
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    tintColor = [inputDelegateManager tintColor];

    if (tintColor)
    {
      v15 = *off_1E70ECAD0;
      [conversionCopy addAttribute:*off_1E70ECAD0 value:tintColor range:{0, v10}];
      [array addObject:v15];
    }

    v16 = conversionCopy;
    if (v7)
    {
      v17 = [conversionCopy length];
      v16 = conversionCopy;
      if (v8 + v7 <= v17)
      {
        [conversionCopy addAttribute:@"NSMarkedTextSelectionAttributeName" value:MEMORY[0x1E695E118] range:{v8, v7}];
        [array addObject:@"NSMarkedTextSelectionAttributeName"];
        v16 = conversionCopy;
      }
    }

    [v16 endEditing];
  }

  else
  {
    v18 = *off_1E70EC8D0;
    v19 = +[UIColor _markedTextBackgroundColor];
    [conversionCopy addAttribute:v18 value:v19 range:{0, v10}];

    [array addObject:v18];
  }

  [conversionCopy addAttribute:0x1EFBAA570 value:array range:{0, v10}];
}

- (void)setInlineCompletionAsMarkedText:(id)text selectedRange:(_NSRange)range inputString:(id)string searchString:(id)searchString
{
  length = range.length;
  location = range.location;
  searchStringCopy = searchString;
  stringCopy = string;
  textCopy = text;
  [(_UIKeyboardStateManager *)self _noteInlineCompletionAsMarkedText:textCopy];
  LOBYTE(v13) = 1;
  [(_UIKeyboardStateManager *)self _setAttributedMarkedText:textCopy selectedRange:location inputString:length lastInputString:stringCopy searchString:0 compareAttributes:searchStringCopy, v13];
}

- (unsigned)_setAttributedMarkedText:(id)text selectedRange:(_NSRange)range inputString:(id)string lastInputString:(id)inputString searchString:(id)searchString compareAttributes:(BOOL)attributes
{
  length = range.length;
  location = range.location;
  textCopy = text;
  stringCopy = string;
  inputStringCopy = inputString;
  searchStringCopy = searchString;
  inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
  presentingTextCompletionAsMarkedText = [inlineTextCompletionController presentingTextCompletionAsMarkedText];

  v67 = presentingTextCompletionAsMarkedText;
  v68 = textCopy;
  v65 = searchStringCopy;
  if ([presentingTextCompletionAsMarkedText length])
  {
    string = [textCopy string];
    v21 = [presentingTextCompletionAsMarkedText isEqualToString:string];

    if (![(_UIKeyboardStateManager *)self usesCandidateSelection]&& v21)
    {
      v22 = 0;
      goto LABEL_7;
    }
  }

  else
  {
    [(_UIKeyboardStateManager *)self usesCandidateSelection];
  }

  [(TIKeyboardState *)self->m_keyboardState setInputForMarkedText:stringCopy];
  [(TIKeyboardState *)self->m_keyboardState setSearchStringForMarkedText:searchStringCopy];
  v22 = 1;
LABEL_7:
  v66 = stringCopy;
  string2 = [v68 string];
  v24 = string2;
  if (string2)
  {
    v25 = string2;
  }

  else
  {
    v25 = &stru_1EFB14550;
  }

  v26 = v25;

  if (attributes)
  {
    v27 = v26;
    if (!v68)
    {
      goto LABEL_22;
    }

    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    attributedMarkedText = [inputDelegateManager attributedMarkedText];
    v30 = [attributedMarkedText isEqualToAttributedString:v68];

    if ((v30 & 1) == 0)
    {
      goto LABEL_22;
    }
  }

  else
  {
    _markedText = [(_UIKeyboardStateManager *)self _markedText];
    v32 = _markedText;
    if (_markedText)
    {
      v33 = _markedText;
    }

    else
    {
      v33 = &stru_1EFB14550;
    }

    v34 = v33;

    v27 = v26;
    v35 = [(__CFString *)v34 isEqualToString:v26];

    if (!v35)
    {
      goto LABEL_22;
    }
  }

  v36 = v27;
  if (![(__CFString *)v27 length])
  {
    v41 = 0;
    v50 = v65;
    v60 = v66;
LABEL_50:
    v52 = v67;
    v48 = v68;
    goto LABEL_51;
  }

  documentState = [(_UIKeyboardStateManager *)self documentState];
  selectedRangeInMarkedText = [documentState selectedRangeInMarkedText];
  v40 = v39;

  if (location == selectedRangeInMarkedText && length == v40)
  {
    v41 = 0;
LABEL_49:
    v50 = v65;
    v60 = v66;
    v36 = v27;
    goto LABEL_50;
  }

LABEL_22:
  v42 = +[UIKeyboard usesInputSystemUI];
  if (inputStringCopy)
  {
    if (v42)
    {
      newlineCharacterSet = [MEMORY[0x1E696AB08] newlineCharacterSet];
      v44 = [inputStringCopy rangeOfCharacterFromSet:newlineCharacterSet];

      if (v44 == 0x7FFFFFFFFFFFFFFFLL && ![(_UIKeyboardStateManager *)self callShouldInsertText:inputStringCopy])
      {
        v41 = 2;
        goto LABEL_49;
      }
    }
  }

  v64 = inputStringCopy;
  v36 = v27;
  if (v22)
  {
    documentState2 = [(_UIKeyboardStateManager *)self documentState];
    v46 = [documentState2 documentStateAfterSettingMarkedText:v27 selectedRange:{location, length}];
    [(_UIKeyboardStateManager *)self setDocumentState:v46];
  }

  self->m_textInputChangesIgnored = 1;
  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v48 = v68;
  [inputDelegateManager2 setAttributedMarkedText:v68 selectedRange:{location, length}];

  self->m_textInputChangesIgnored = 0;
  inputForMarkedText = [(_UIKeyboardStateManager *)self inputForMarkedText];
  if ([inputForMarkedText length] && !-[_UIKeyboardStateManager _hasMarkedText](self, "_hasMarkedText"))
  {
    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    suppressPlaceholderCandidate = [inputManagerState suppressPlaceholderCandidate];

    inputStringCopy = v64;
    v50 = v65;
    if ((suppressPlaceholderCandidate & 1) == 0)
    {
      if (qword_1ED49D098 != -1)
      {
        dispatch_once(&qword_1ED49D098, &__block_literal_global_902);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      v70[0] = MEMORY[0x1E69E9820];
      v70[1] = 3221225472;
      v70[2] = __125___UIKeyboardStateManager__setAttributedMarkedText_selectedRange_inputString_lastInputString_searchString_compareAttributes___block_invoke_3;
      v70[3] = &unk_1E70FD058;
      v70[4] = self;
      [taskQueue addTask:v70 breadcrumb:qword_1ED49D090];
    }
  }

  else
  {

    inputStringCopy = v64;
    v50 = v65;
  }

  asyncCapableInputDelegate = [(_UIKeyboardStateManager *)self asyncCapableInputDelegate];

  v52 = v67;
  if (!asyncCapableInputDelegate || ![(_UIKeyboardStateManager *)self isInHardwareKeyboardMode])
  {
    goto LABEL_42;
  }

  inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  if (([inputDelegateManager3 delegateRespondsToSelector:sel_requestDocumentContext_completionHandler_] & 1) == 0)
  {

    inputStringCopy = v64;
    goto LABEL_42;
  }

  candidateViewOffset = [(_UIKeyboardStateManager *)self candidateViewOffset];

  inputStringCopy = v64;
  if (candidateViewOffset == 0x7FFFFFFFFFFFFFFFLL)
  {
LABEL_42:
    [(_UIKeyboardStateManager *)self setCharacterRectsForCharacterRange:0];
    goto LABEL_43;
  }

  v55 = objc_alloc_init(UIWKDocumentRequest);
  [(UIWKDocumentRequest *)v55 setFlags:33];
  inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v69[0] = MEMORY[0x1E69E9820];
  v69[1] = 3221225472;
  v69[2] = __125___UIKeyboardStateManager__setAttributedMarkedText_selectedRange_inputString_lastInputString_searchString_compareAttributes___block_invoke_4;
  v69[3] = &unk_1E70FD3C0;
  v69[4] = self;
  [inputDelegateManager4 requestDocumentContext:v55 completionHandler:v69];

  v52 = v67;
LABEL_43:
  if (objc_opt_respondsToSelector())
  {
    m_candidateList = self->m_candidateList;
    inputStringFromPhraseBoundary = [(_UIKeyboardStateManager *)self inputStringFromPhraseBoundary];
    [(UIKeyboardCandidateList *)m_candidateList setInlineText:inputStringFromPhraseBoundary];

    v52 = v67;
  }

  v60 = v66;
  if ([(UIKeyboardCandidateList *)self->m_candidateList isExtendedList])
  {
    self->m_hasEditedMarkedTextInExtendedView = 1;
  }

  [(_UIKeyboardStateManager *)self setChangedDelegate];
  v41 = 1;
LABEL_51:

  return v41;
}

- (BOOL)supportsSetPhraseBoundary
{
  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  rtiInputSourceState = [remoteTextInputPartner rtiInputSourceState];

  if (rtiInputSourceState)
  {
    remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    rtiInputSourceState2 = [remoteTextInputPartner2 rtiInputSourceState];
    supportsSetPhraseBoundary = [rtiInputSourceState2 supportsSetPhraseBoundary];
  }

  else
  {
    remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self inputManagerState];
    supportsSetPhraseBoundary = [remoteTextInputPartner2 supportsSetPhraseBoundary];
  }

  return supportsSetPhraseBoundary;
}

- (BOOL)hasEditableMarkedText
{
  _hasMarkedText = [(_UIKeyboardStateManager *)self _hasMarkedText];
  if (_hasMarkedText)
  {

    LOBYTE(_hasMarkedText) = [(_UIKeyboardStateManager *)self supportsSetPhraseBoundary];
  }

  return _hasMarkedText;
}

- (BOOL)hasInlineCompletionAsMarkedText
{
  inlineCompletionAsMarkedText = [(_UIKeyboardStateManager *)self inlineCompletionAsMarkedText];
  v3 = inlineCompletionAsMarkedText != 0;

  return v3;
}

- (void)smartSelectionForTextInDocument:(id)document inRange:(_NSRange)range options:(unint64_t)options completion:(id)completion
{
  length = range.length;
  location = range.location;
  documentCopy = document;
  completionCopy = completion;
  array = [MEMORY[0x1E695DF70] array];
  v14 = [(__CFString *)documentCopy length];
  v15 = *MEMORY[0x1E695E480];
  currentLocale = [MEMORY[0x1E695DF58] currentLocale];
  v39.location = 0;
  v39.length = v14;
  v17 = CFStringTokenizerCreate(v15, documentCopy, v39, 0, currentLocale);
  if (v17)
  {
    v18 = v17;
    while (CFStringTokenizerAdvanceToNextToken(v18))
    {
      CurrentTokenRange = CFStringTokenizerGetCurrentTokenRange(v18);
      v20 = [MEMORY[0x1E696B098] valueWithRange:{CurrentTokenRange.location, CurrentTokenRange.length}];
      [array addObject:v20];
    }

    CFRelease(v18);
    v21 = +[UIKeyboardInputModeController sharedInputModeController];
    currentInputMode = [v21 currentInputMode];
    normalizedIdentifier = [currentInputMode normalizedIdentifier];

    v24 = 0;
    v25 = 0;
    do
    {
      v25 |= TISmartSelectionOptionFromUISmartSelectionOption((1 << v24++) & options);
    }

    while (v24 != 64);
    v26 = objc_alloc_init(MEMORY[0x1E696AB30]);
    [v26 lock];
    v35 = 0;
    v36 = &v35;
    v37 = 0x2020000000;
    v38 = 0;
    [v26 unlock];
    inputManager = [(_UIKeyboardStateManager *)self inputManager];
    v31[0] = MEMORY[0x1E69E9820];
    v31[1] = 3221225472;
    v31[2] = __86___UIKeyboardStateManager_smartSelectionForTextInDocument_inRange_options_completion___block_invoke;
    v31[3] = &unk_1E70FD3E8;
    v28 = v26;
    v32 = v28;
    v34 = &v35;
    v29 = completionCopy;
    v33 = v29;
    [inputManager smartSelectionForTextInDocument:documentCopy inRange:location language:length tokenizedRanges:normalizedIdentifier options:array completion:{v25, v31}];

    [v28 lock];
    if ((v36[3] & 1) == 0)
    {
      v30 = [MEMORY[0x1E695DF00] dateWithTimeIntervalSinceNow:1.0];
      [v28 waitUntilDate:v30];

      if ((v36[3] & 1) == 0)
      {
        (*(v29 + 2))(v29, location, length);
        *(v36 + 24) = 1;
      }
    }

    [v28 unlock];

    _Block_object_dispose(&v35, 8);
  }

  else
  {
    (*(completionCopy + 2))(completionCopy, location, length);
  }
}

- (id)searchStringForMarkedText
{
  searchStringForMarkedText = [(TIKeyboardState *)self->m_keyboardState searchStringForMarkedText];
  v4 = searchStringForMarkedText;
  if (searchStringForMarkedText)
  {
    v5 = searchStringForMarkedText;
  }

  else
  {
    _markedText = [(_UIKeyboardStateManager *)self _markedText];
    v7 = _markedText;
    v8 = &stru_1EFB14550;
    if (_markedText)
    {
      v8 = _markedText;
    }

    v5 = v8;
  }

  return v5;
}

- (id)inputStringFromPhraseBoundary
{
  documentState = [(_UIKeyboardStateManager *)self documentState];
  markedText = [documentState markedText];
  v5 = [markedText copy];

  if ([(_UIKeyboardStateManager *)self supportsSetPhraseBoundary])
  {
    documentState2 = [(_UIKeyboardStateManager *)self documentState];
    selectedRangeInMarkedText = [documentState2 selectedRangeInMarkedText];

    if (selectedRangeInMarkedText)
    {
      if (selectedRangeInMarkedText < [v5 length])
      {
        v8 = [v5 substringToIndex:selectedRangeInMarkedText];

        v5 = v8;
      }
    }
  }

  return v5;
}

- (BOOL)cursorIsAtEndOfMarkedText
{
  result = 0;
  if ([(_UIKeyboardStateManager *)self supportsSetPhraseBoundary])
  {
    documentState = [(_UIKeyboardStateManager *)self documentState];
    selectedRangeInMarkedText = [documentState selectedRangeInMarkedText];

    documentState2 = [(_UIKeyboardStateManager *)self documentState];
    markedText = [documentState2 markedText];
    v7 = [markedText length];

    if (selectedRangeInMarkedText == v7)
    {
      return 1;
    }
  }

  return result;
}

- (BOOL)cursorIsAtStartOfInlineCompletionMarkedText
{
  inlineCompletionAsMarkedText = [(_UIKeyboardStateManager *)self inlineCompletionAsMarkedText];

  if (inlineCompletionAsMarkedText)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager selectedTextRange];

    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    markedTextRange = [inputDelegateManager2 markedTextRange];

    if ([selectedTextRange isEmpty])
    {
      v8 = [selectedTextRange end];
      start = [markedTextRange start];
      v10 = [v8 isEqual:start];

      if (v10)
      {
        return 1;
      }
    }

    else
    {
    }
  }

  return 0;
}

- (void)syncDocumentStateToInputDelegate
{
  if (qword_1ED49D0A8 != -1)
  {
    dispatch_once(&qword_1ED49D0A8, &__block_literal_global_914);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = __59___UIKeyboardStateManager_syncDocumentStateToInputDelegate__block_invoke_3;
  v4[3] = &unk_1E70FD058;
  v4[4] = self;
  [taskQueue performSingleTask:v4 breadcrumb:qword_1ED49D0A0];
}

- (void)documentStateFromInputDelegate:(id)delegate
{
  delegateCopy = delegate;
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  if (inputSystemSourceSession)
  {
    if (!self->m_textInputChangingText && !self->m_textInputUpdatingSelection)
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];

      if (!forwardingInputDelegate)
      {
        documentState = [inputSystemSourceSession documentState];
        v14DocumentState = [documentState documentState];
LABEL_16:
        v17 = v14DocumentState;
        delegateCopy[2](delegateCopy, v14DocumentState);

        goto LABEL_10;
      }
    }
  }

  asyncInputDelegate = [(_UIKeyboardStateManager *)self asyncInputDelegate];
  if (!asyncInputDelegate)
  {
    webInputDelegate = [(_UIKeyboardStateManager *)self webInputDelegate];

    if (webInputDelegate)
    {
      goto LABEL_8;
    }

    asyncWebKitInteractionDelegate = [(_UIKeyboardStateManager *)self asyncWebKitInteractionDelegate];

    if (asyncWebKitInteractionDelegate)
    {
      asyncWebKitInteractionDelegate2 = [(_UIKeyboardStateManager *)self asyncWebKitInteractionDelegate];
      v47[0] = MEMORY[0x1E69E9820];
      v47[1] = 3221225472;
      v47[2] = __58___UIKeyboardStateManager_documentStateFromInputDelegate___block_invoke_2;
      v47[3] = &unk_1E70FD438;
      v48 = delegateCopy;
      [asyncWebKitInteractionDelegate2 requestAutocorrectionContextWithCompletionHandler:v47];

      v11 = v48;
      goto LABEL_9;
    }

    if ([(UITextInputTraits *)self->m_traits isSecureTextEntry])
    {
      v16 = MEMORY[0x1E69D9590];
      documentState = [(_UIKeyboardStateManager *)self inputDelegate];
      v14DocumentState = [v16 documentStateOfSecureTextDocument:documentState];
      goto LABEL_16;
    }

    if (inputSystemSourceSession || (-[TIKeyboardState textInputTraits](self->m_keyboardState, "textInputTraits"), v18 = objc_claimAutoreleasedReturnValue(), [v18 recentInputIdentifier], v19 = objc_claimAutoreleasedReturnValue(), v19, v18, v19))
    {
      v20 = MEMORY[0x1E69D9590];
      inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
      v22 = [v20 documentStateOfDocumentWithRecentInputIdentifier:inputDelegate];
    }

    else
    {
      v43 = MEMORY[0x1E69D9590];
      inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
      v22 = [v43 documentStateOfDocument:inputDelegate];
    }

    v23 = v22;

    v24 = +[UIKeyboardInputModeController sharedInputModeController];
    currentInputMode = [v24 currentInputMode];
    isExtensionInputMode = [currentInputMode isExtensionInputMode];

    if (!isExtensionInputMode)
    {
LABEL_31:
      delegateCopy[2](delegateCopy, v23);

      goto LABEL_10;
    }

    if (WebKitFramework)
    {
      inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
      objc_opt_class();
      isKindOfClass = objc_opt_isKindOfClass();

      if (isKindOfClass)
      {
        contextBeforeInput = [v23 contextBeforeInput];
        v30 = [contextBeforeInput length];

        if (!v30)
        {
          v31 = [v23 documentStateAfterInsertingText:@"\n"];

          v23 = v31;
        }
      }
    }

    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager2 selectedTextRange];

    if (selectedTextRange)
    {
      inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
      inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      beginningOfDocument = [inputDelegateManager3 beginningOfDocument];
      start = [selectedTextRange start];
      if ([inputDelegate3 comparePosition:beginningOfDocument toPosition:start] == 1)
      {
      }

      else
      {
        [(_UIKeyboardStateManager *)self inputDelegate];
        v38 = v45 = inputDelegateManager3;
        [selectedTextRange end];
        v39 = v46 = inputDelegate3;
        inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        endOfDocument = [inputDelegateManager4 endOfDocument];
        v44 = [v38 comparePosition:v39 toPosition:endOfDocument];

        if (v44 != 1)
        {
LABEL_30:

          goto LABEL_31;
        }
      }
    }

    v42 = [objc_alloc(MEMORY[0x1E69D9590]) initWithContextBefore:0 markedText:0 selectedText:0 contextAfter:0 selectedRangeInMarkedText:{0x7FFFFFFFFFFFFFFFLL, 0}];

    v23 = v42;
    goto LABEL_30;
  }

LABEL_8:
  inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v49[0] = MEMORY[0x1E69E9820];
  v49[1] = 3221225472;
  v49[2] = __58___UIKeyboardStateManager_documentStateFromInputDelegate___block_invoke;
  v49[3] = &unk_1E70FD410;
  v50 = delegateCopy;
  [inputDelegateManager5 requestTextContextForAutocorrectionWithCompletionHandler:v49];

  v11 = v50;
LABEL_9:

LABEL_10:
}

- (void)syncDocumentStateToInputDelegateWithExecutionContext:(id)context
{
  contextCopy = context;
  documentState = [(_UIKeyboardStateManager *)self documentState];
  _selectedTextRange = [documentState _selectedTextRange];
  v8 = v7;

  v10[0] = MEMORY[0x1E69E9820];
  v10[1] = 3221225472;
  v10[2] = __80___UIKeyboardStateManager_syncDocumentStateToInputDelegateWithExecutionContext___block_invoke;
  v10[3] = &unk_1E70FD488;
  v11 = contextCopy;
  selfCopy = self;
  v13 = _selectedTextRange;
  v14 = v8;
  v9 = contextCopy;
  [(_UIKeyboardStateManager *)self documentStateFromInputDelegate:v10];
}

- (void)prepareForSelectionChange
{
  if (!self->m_selecting && !self->m_textInputChangesIgnored)
  {
    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    if (([taskQueue isMainThreadExecutingTask] & 1) == 0)
    {
      autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
      requestedAutocorrection = [autocorrectionController requestedAutocorrection];

      if (requestedAutocorrection)
      {
        goto LABEL_7;
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      [taskQueue waitUntilAllTasksAreFinished];
    }

LABEL_7:
    if (self->m_textInputChangingText)
    {
LABEL_13:
      [(_UIKeyboardStateManager *)self dismissTextChoicePrompt];
      self->m_selecting = 1;
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      [WeakRetained assertCursorForForSelectionChange];

      textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
      activeSelection = [textInteractionAssistant activeSelection];
      selectedRange = [activeSelection selectedRange];
      self->m_selectionIsEmpty = [selectedRange isEmpty];

      return;
    }

    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    if (([inputDelegateManager insideKeyInputDelegateCall] & 1) == 0 && !-[_UIKeyboardStateManager hasEditableMarkedText](self, "hasEditableMarkedText"))
    {
      v7 = +[UIDictationController activeInstance];
      if (![v7 dictationIsModifyingText])
      {
        utlizeEuclidModelForDictationReplacement = [(_UIKeyboardStateManager *)self utlizeEuclidModelForDictationReplacement];

        if (utlizeEuclidModelForDictationReplacement)
        {
          goto LABEL_13;
        }

        if (+[UIKeyboard usesInputSystemUI]&& ([(_UIKeyboardStateManager *)self inlineCompletionAsMarkedText], v13 = objc_claimAutoreleasedReturnValue(), v13, !v13))
        {
          inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          selectedTextRange = [inputDelegateManager2 selectedTextRange];
          pendingAutocorrectRange = self->_pendingAutocorrectRange;
          self->_pendingAutocorrectRange = selectedTextRange;

          v27[0] = MEMORY[0x1E69E9820];
          v27[1] = 3221225472;
          v27[2] = __52___UIKeyboardStateManager_prepareForSelectionChange__block_invoke;
          v27[3] = &unk_1E70F5AC0;
          v27[4] = self;
          v15 = v27;
          selfCopy2 = self;
        }

        else
        {
          if (![(_UIKeyboardStateManager *)self _shouldAcceptAutocorrectionOnSelectionChange])
          {
            if (self->m_userChangedSelection)
            {
              goto LABEL_13;
            }

            inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];

            if (!inputManagerState)
            {
              goto LABEL_13;
            }

            v17 = MEMORY[0x1E69D95F0];
            inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
            inputString = [inputManagerState2 inputString];
            inputDelegateManager = [v17 candidateWithUnchangedInput:inputString];

            inputManagerState3 = [(_UIKeyboardStateManager *)self inputManagerState];
            LOBYTE(inputString) = objc_opt_respondsToSelector();

            if (inputString)
            {
              v21 = inputDelegateManager;
              inputManagerState4 = [(_UIKeyboardStateManager *)self inputManagerState];
              v23 = [inputManagerState4 valueForKey:@"learningFlagsForLastAcceptedCandidate"];
              [v21 performSelector:sel_setLearningFlags_ withObject:v23];
            }

            [(_UIKeyboardStateManager *)self textAccepted:inputDelegateManager];
            goto LABEL_12;
          }

          selfCopy2 = self;
          v15 = 0;
        }

        [(_UIKeyboardStateManager *)selfCopy2 acceptAutocorrectionWithCompletionHandler:v15];
        goto LABEL_13;
      }
    }

LABEL_12:

    goto LABEL_13;
  }
}

- (void)selectionWillChange:(id)change
{
  changeCopy = change;
  m_textInputChangingCount = self->m_textInputChangingCount;
  self->m_textInputChangingCount = m_textInputChangingCount + 1;
  if (!m_textInputChangingCount && !self->m_textInputChangesIgnored)
  {
    v16 = changeCopy;
    [(_UIKeyboardStateManager *)self prepareForSelectionChange];
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];
    if ([forwardingInputDelegate isEditing])
    {
      v8 = objc_opt_respondsToSelector();

      if (v8)
      {
        interactionAssistant = [v16 interactionAssistant];
        view = [interactionAssistant view];
        inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        forwardingInputDelegate2 = [inputDelegateManager2 forwardingInputDelegate];

        if (view == forwardingInputDelegate2)
        {
          goto LABEL_11;
        }

        goto LABEL_10;
      }
    }

    else
    {
    }

    if (!+[UIKeyboard usesInputSystemUI])
    {
      goto LABEL_11;
    }

    inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    shouldRespectForwardingInputDelegate = [inputDelegateManager3 shouldRespectForwardingInputDelegate];

    if (!shouldRespectForwardingInputDelegate)
    {
      goto LABEL_11;
    }

LABEL_10:
    [(_UIKeyboardStateManager *)self clearForwardingInputDelegateAndResign:1];
LABEL_11:
    inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
    [inlineTextCompletionController selectionWillChange];

    changeCopy = v16;
  }
}

- (void)setSelectionWithPoint:(CGPoint)point
{
  y = point.y;
  x = point.x;
  textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
  activeSelection = [textInteractionAssistant activeSelection];

  [activeSelection setSelectionWithPoint:{x, y}];
  [activeSelection commit];
}

- (void)updateForChangedSelection
{
  if (qword_1ED49D0C8 != -1)
  {
    dispatch_once(&qword_1ED49D0C8, &__block_literal_global_935);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = __52___UIKeyboardStateManager_updateForChangedSelection__block_invoke_3;
  v4[3] = &unk_1E70FD058;
  v4[4] = self;
  [taskQueue performSingleTask:v4 breadcrumb:qword_1ED49D0C0];
}

- (void)updateForChangedSelectionWithExecutionContext:(id)context
{
  contextCopy = context;
  if (![(_UIKeyboardStateManager *)self _hasMarkedText]|| ![(_UIKeyboardStateManager *)self supportsSetPhraseBoundary])
  {
    [(_UIKeyboardStateManager *)self setCurrentCandidateRequest:0];
  }

  if ([(_UIKeyboardStateManager *)self hasAdvancedInputDelegate])
  {
    [(_UIKeyboardStateManager *)self clearTransientState];
    if ([(_UIKeyboardStateManager *)self _hasMarkedText])
    {
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      [WeakRetained clearCursorAssertion];

      [(_UIKeyboardStateManager *)self updateCandidateDisplay];
      v6 = &__block_literal_global_941;
    }

    else
    {
      [(_UIKeyboardStateManager *)self clearInput];
      [(_UIKeyboardStateManager *)self setPreviousInputString:0];
      self->m_userChangedSelection = 1;
      self->m_suggestionsShownForCurrentDeletion = 0;
      v9[0] = MEMORY[0x1E69E9820];
      v9[1] = 3221225472;
      v9[2] = __73___UIKeyboardStateManager_updateForChangedSelectionWithExecutionContext___block_invoke_3;
      v9[3] = &unk_1E70FD058;
      v9[4] = self;
      v6 = v9;
    }

    v8 = [contextCopy childWithContinuation:v6];
    [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegateWithExecutionContext:v8];
  }

  else
  {
    v7 = [objc_alloc(MEMORY[0x1E69D9590]) initWithContextBefore:0 markedText:0 selectedText:0 contextAfter:0 selectedRangeInMarkedText:{0x7FFFFFFFFFFFFFFFLL, 0}];
    [(_UIKeyboardStateManager *)self setDocumentState:v7];

    v8 = [contextCopy childWithContinuation:&__block_literal_global_939];
    [(_UIKeyboardStateManager *)self syncInputManagerToKeyboardStateWithExecutionContext:v8];
  }
}

- (void)completeUpdateForChangedSelection:(BOOL)selection
{
  selectionCopy = selection;
  [(_UIKeyboardStateManager *)self setShiftOffIfNeeded];
  if (selectionCopy)
  {
    [(_UIKeyboardStateManager *)self updateReturnKey];
    [(_UIKeyboardStateManager *)self updateCandidateDisplay];
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  hasCursorAssertion = [WeakRetained hasCursorAssertion];

  if (hasCursorAssertion)
  {
    _activeAssertionController = objc_loadWeakRetained(&self->_presentationDelegate);
    [_activeAssertionController clearCursorAssertion];
  }

  else
  {
    _activeAssertionController = [(_UIKeyboardStateManager *)self _activeAssertionController];
    [_activeAssertionController _updateSubjectWithAssertionState];
  }

  if ([(_UIKeyboardStateManager *)self noContent])
  {
    [(_UIKeyboardStateManager *)self setInitialDirection];
  }

  self->m_doubleSpacePeriodWasAppliedInCurrentContext = 0;
  self->m_suggestionsShownForCurrentDeletion = 0;
  v8 = objc_loadWeakRetained(&self->_presentationDelegate);
  [v8 updateStylingTraitsIfNeeded];

  self->m_didAutomaticallyInsertSpace = 0;
  if (!self->m_textInputChangingText)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager changedSelection];
  }

  textSelectionController = [(_UIKeyboardStateManager *)self textSelectionController];
  [textSelectionController selectionDidChange];

  inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
  [inlineTextCompletionController selectionDidChange];

  _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
  [_textChoicesAssistant selectionDidChange];

  m_selectionIsEmpty = self->m_selectionIsEmpty;
  textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
  activeSelection = [textInteractionAssistant activeSelection];
  selectedRange = [activeSelection selectedRange];
  isEmpty = [selectedRange isEmpty];

  if (m_selectionIsEmpty != isEmpty)
  {
    self->m_editingTraitsMarkedDirty = 1;
  }
}

- (void)selectionDidChange:(id)change
{
  changeCopy = change;
  if (_os_feature_enabled_impl())
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager keyInputDelegate];
    v7 = objc_opt_respondsToSelector();

    if (v7)
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      keyInputDelegate2 = [inputDelegateManager2 keyInputDelegate];
      [keyInputDelegate2 _selectionDidUpdate];
    }
  }

  m_textInputChangingCount = self->m_textInputChangingCount;
  if (m_textInputChangingCount == 1)
  {
    if (!self->m_ignoreSelectionChange || !self->m_textInputChangesIgnored || self->m_textInputChangingText)
    {
      self->m_textInputChangingCount = 0;
      goto LABEL_14;
    }

    if (qword_1ED49D0D8 != -1)
    {
      dispatch_once(&qword_1ED49D0D8, &__block_literal_global_947);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v40[0] = MEMORY[0x1E69E9820];
    v40[1] = 3221225472;
    v40[2] = __46___UIKeyboardStateManager_selectionDidChange___block_invoke_3;
    v40[3] = &unk_1E70FD058;
    v40[4] = self;
    [taskQueue addTask:v40 breadcrumb:qword_1ED49D0D0];

    m_textInputChangingCount = self->m_textInputChangingCount;
  }

  if (!m_textInputChangingCount)
  {
    goto LABEL_39;
  }

  v12 = m_textInputChangingCount - 1;
  self->m_textInputChangingCount = v12;
  if (v12)
  {
    goto LABEL_39;
  }

LABEL_14:
  if (self->m_textInputChangesIgnored)
  {
    goto LABEL_39;
  }

  self->m_textInputUpdatingSelection = 1;
  if (self->m_textInputChangingText)
  {
    [(_UIKeyboardStateManager *)self textChanged:changeCopy];
  }

  else if ([(_UIKeyboardStateManager *)self noContent])
  {
    if (qword_1ED49D0E8 != -1)
    {
      dispatch_once(&qword_1ED49D0E8, &__block_literal_global_953);
    }

    taskQueue2 = [(_UIKeyboardStateManager *)self taskQueue];
    v39[0] = MEMORY[0x1E69E9820];
    v39[1] = 3221225472;
    v39[2] = __46___UIKeyboardStateManager_selectionDidChange___block_invoke_6;
    v39[3] = &unk_1E70FD058;
    v39[4] = self;
    [taskQueue2 addTask:v39 breadcrumb:qword_1ED49D0E0];
  }

  else
  {
    [(_UIKeyboardStateManager *)self updateForChangedSelection];
  }

  self->m_textInputChangingText = 0;
  self->m_textInputUpdatingSelection = 0;
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  _textSelectingContainer = [inputDelegate _textSelectingContainer];
  interactionAssistant = [_textSelectingContainer interactionAssistant];

  if (!interactionAssistant)
  {
    if ([(_UIKeyboardStateManager *)self supportsSetPhraseBoundary])
    {
      inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      markedTextRange = [inputDelegateManager3 markedTextRange];

      if (!markedTextRange)
      {
        inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
        [inputDelegate2 _setGestureRecognizers];
      }
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  if (([remoteTextInputPartner inputSystemClientEnabled] & 1) == 0)
  {
    goto LABEL_31;
  }

  remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  isNotifyingDelegateOfRemoteOutputOperation = [remoteTextInputPartner2 isNotifyingDelegateOfRemoteOutputOperation];

  if ((isNotifyingDelegateOfRemoteOutputOperation & 1) == 0)
  {
    if (qword_1ED49D0F8 != -1)
    {
      dispatch_once(&qword_1ED49D0F8, &__block_literal_global_959);
    }

    remoteTextInputPartner = [(_UIKeyboardStateManager *)self taskQueue];
    v38[0] = MEMORY[0x1E69E9820];
    v38[1] = 3221225472;
    v38[2] = __46___UIKeyboardStateManager_selectionDidChange___block_invoke_9;
    v38[3] = &unk_1E70FD058;
    v38[4] = self;
    [remoteTextInputPartner addTask:v38 breadcrumb:qword_1ED49D0F0];
LABEL_31:
  }

  if (!self->_remoteTextInputPartner)
  {
    goto LABEL_39;
  }

  remoteTextInputPartner3 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  if ([remoteTextInputPartner3 isNotifyingDelegateOfRemoteOutputOperation])
  {
    goto LABEL_34;
  }

  inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
  v25 = objc_opt_respondsToSelector();

  if (v25)
  {
    remoteTextInputPartner3 = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    if (remoteTextInputPartner3)
    {
      v26 = +[UIKeyboard isMajelSupported](UIKeyboard, "isMajelSupported") && +[UIDictationController isRunning];
      v27 = +[UIKeyboardCameraSession activeSession];

      if (!self->m_suppressingDocumentAssertions && !v26 && !v27)
      {
        documentState = [(_UIKeyboardStateManager *)self documentState];
        contextBeforeInput = [documentState contextBeforeInput];
        v30 = [contextBeforeInput length];
        selectedText = [documentState selectedText];
        v32 = [selectedText length];

        if (!+[UIKeyboard isKeyboardProcess])
        {
          fullString = [documentState fullString];
          textOperations = [remoteTextInputPartner3 textOperations];
          [textOperations setTextToAssert:fullString];
        }

        textOperations2 = [remoteTextInputPartner3 textOperations];
        [textOperations2 setSelectionRangeToAssert:{v30, v32}];

        buildInputSourceState = [(_UIKeyboardStateManager *)self buildInputSourceState];
        textOperations3 = [remoteTextInputPartner3 textOperations];
        [textOperations3 setInputSourceState:buildInputSourceState];

        [remoteTextInputPartner3 flushOperations];
      }
    }

LABEL_34:
  }

LABEL_39:
  [(_UIKeyboardStateManager *)self setArrowKeyHistory:0];
  if (!self->m_textInputChangesIgnored)
  {
    [(_UIKeyboardStateManager *)self postInputResponderCapabilitiesChangedNotification];
  }
}

- (void)updateTextChoicePromptSelection:(id)selection toRange:(id)range
{
  selectionCopy = selection;
  rangeCopy = range;
  selectedTextRange = [selectionCopy selectedTextRange];
  if (selectedTextRange)
  {
    start = [rangeCopy start];
    start2 = [selectedTextRange start];
    if ([selectionCopy comparePosition:start toPosition:start2])
    {
    }

    else
    {
      v10 = [rangeCopy end];
      v11 = [selectedTextRange end];
      v12 = [selectionCopy comparePosition:v10 toPosition:v11];

      if (!v12)
      {
        goto LABEL_6;
      }
    }
  }

  [(_UIKeyboardStateManager *)self selectionWillChange:selectionCopy];
  [selectionCopy setSelectedTextRange:rangeCopy];
  [(_UIKeyboardStateManager *)self selectionDidChange:selectionCopy];
LABEL_6:
}

- (void)deleteHandwritingStrokesAtIndexes:(id)indexes
{
  indexesCopy = indexes;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    v7 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v7 layout];
    [layout2 deleteHandwritingStrokesAtIndexes:indexesCopy];
  }
}

- (void)showSelectionCommands
{
  _editMenuAssistant = [(_UIKeyboardStateManager *)self _editMenuAssistant];
  [_editMenuAssistant showSelectionCommands];
}

- (void)acceptingCandidateWithTrigger:(id)trigger
{
  v10[1] = *MEMORY[0x1E69E9840];
  triggerCopy = trigger;
  if (+[UIKeyboard usesInputSystemUI])
  {
    v5 = objc_alloc_init(NSClassFromString(&cfstr_Rtiinputoperat.isa));
    [v5 setActionSelector:sel_acceptingCandidateWithTrigger_];
    v9 = @"candidateAcceptedTrigger";
    v10[0] = triggerCopy;
    v6 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v10 forKeys:&v9 count:1];

    [v5 setCustomInfo:v6];
    [v5 setCustomInfoType:0x1EFB7CB30];
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner performInputOperation:v5];
  }

  else
  {
    inputManager = [(_UIKeyboardStateManager *)self inputManager];
    [inputManager acceptingCandidateWithTrigger:triggerCopy];
  }
}

- (void)changingContextWithTrigger:(id)trigger
{
  v10[1] = *MEMORY[0x1E69E9840];
  triggerCopy = trigger;
  if (+[UIKeyboard usesInputSystemUI])
  {
    v5 = objc_alloc_init(NSClassFromString(&cfstr_Rtiinputoperat.isa));
    [v5 setActionSelector:sel_changingContextWithTrigger_];
    v9 = @"contextChangeTrigger";
    v10[0] = triggerCopy;
    v6 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v10 forKeys:&v9 count:1];

    [v5 setCustomInfo:v6];
    [v5 setCustomInfoType:0x1EFB7CB30];
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner performInputOperation:v5];
  }

  else
  {
    inputManager = [(_UIKeyboardStateManager *)self inputManager];
    [inputManager changingContextWithTrigger:triggerCopy];
  }
}

- (void)syncInputManagerToKeyboardState
{
  if (qword_1ED49D108 != -1)
  {
    dispatch_once(&qword_1ED49D108, &__block_literal_global_976);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = __58___UIKeyboardStateManager_syncInputManagerToKeyboardState__block_invoke_3;
  v4[3] = &unk_1E70FD058;
  v4[4] = self;
  [taskQueue performSingleTask:v4 breadcrumb:qword_1ED49D100];
}

- (void)syncInputManagerToKeyboardStateWithExecutionContext:(id)context
{
  contextCopy = context;
  [(_UIKeyboardStateManager *)self flushTouchEventWaitingForKeyInputEventIfNecessary];
  [(_UIKeyboardStateManager *)self refreshKeyboardState];
  v5 = [(TIKeyboardState *)self->m_keyboardState copy];
  [v5 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
  [v5 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
  v20[0] = MEMORY[0x1E69E9820];
  v20[1] = 3221225472;
  v20[2] = __79___UIKeyboardStateManager_syncInputManagerToKeyboardStateWithExecutionContext___block_invoke;
  v20[3] = &unk_1E70FD4D0;
  v6 = contextCopy;
  v21 = v6;
  selfCopy = self;
  v7 = [v20 copy];
  v8 = +[_UIRemoteKeyboards sharedRemoteKeyboards];
  if ([v8 oldPathForSnapshot] && !+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess"))
  {
    v14 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
    visualModeManager = [v14 visualModeManager];
    if ([visualModeManager useVisualModeWindowed])
    {
      shouldAccessInputManagerService = [(_UIKeyboardStateManager *)self shouldAccessInputManagerService];

      if (shouldAccessInputManagerService)
      {
        goto LABEL_4;
      }
    }

    else
    {
    }

LABEL_11:
    [v6 returnExecutionToParent];
    goto LABEL_12;
  }

  shouldAccessInputManagerService2 = [(_UIKeyboardStateManager *)self shouldAccessInputManagerService];

  if (!shouldAccessInputManagerService2)
  {
    goto LABEL_11;
  }

LABEL_4:
  mEMORY[0x1E69D96B0] = [MEMORY[0x1E69D96B0] sharedInstance];
  flush = [mEMORY[0x1E69D96B0] flush];
  [v5 setStatisticChanges:flush];

  v12 = keyboardPerfLog_Staging();
  if (os_signpost_enabled(v12))
  {
    *v19 = 0;
    _os_signpost_emit_with_name_impl(&dword_188A29000, v12, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "keyboard.syncToKeyboardState", "", v19, 2u);
  }

  backendController = [(_UIKeyboardStateManager *)self backendController];
  [backendController syncToKeyboardState:v5 completionHandler:v7];

LABEL_12:
  inputContextHistory = [v5 inputContextHistory];

  if (inputContextHistory)
  {
    inputContextHistory2 = [v5 inputContextHistory];
    [inputContextHistory2 assertCheckpointForCoding];
  }
}

- (void)syncKeyboardToConfiguration:(id)configuration
{
  v56 = *MEMORY[0x1E69E9840];
  configurationCopy = configuration;
  inputManagerState = [configurationCopy inputManagerState];
  [(_UIKeyboardStateManager *)self setInputManagerState:inputManagerState];

  intermediateText = [configurationCopy intermediateText];

  if (intermediateText)
  {
    intermediateText2 = [configurationCopy intermediateText];
    [(_UIKeyboardStateManager *)self assertIntermediateText:intermediateText2];
  }

  if ([configurationCopy assertDefaultKeyPlane] && -[_UIKeyboardStateManager isShifted](self, "isShifted") && !-[_UIKeyboardStateManager isShiftLocked](self, "isShiftLocked"))
  {
    [(_UIKeyboardStateManager *)self setShift:0];
  }

  layoutTag = [configurationCopy layoutTag];

  if (layoutTag)
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [WeakRetained layout];
    layoutTag2 = [configurationCopy layoutTag];
    [layout setLayoutTag:layoutTag2];
  }

  accentKeyString = [configurationCopy accentKeyString];

  if (accentKeyString)
  {
    v13 = objc_loadWeakRetained(&self->_presentationDelegate);
    accentKeyString2 = [configurationCopy accentKeyString];
    [v13 setLabel:accentKeyString2 forKey:@"_keyid_accent_"];
  }

  v43 = configurationCopy;
  contextualDisplayKeys = [configurationCopy contextualDisplayKeys];
  v16 = contextualDisplayKeys;
  if (contextualDisplayKeys)
  {
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    v45 = [contextualDisplayKeys countByEnumeratingWithState:&v50 objects:v55 count:16];
    if (v45)
    {
      v44 = *v51;
      do
      {
        for (i = 0; i != v45; ++i)
        {
          if (*v51 != v44)
          {
            objc_enumerationMutation(v16);
          }

          v18 = *(*(&v50 + 1) + 8 * i);
          v19 = v16;
          v20 = [v16 objectForKey:v18];
          v21 = objc_loadWeakRetained(&self->_presentationDelegate);
          activeLayout = [v21 activeLayout];
          currentKeyplane = [activeLayout currentKeyplane];
          v24 = [currentKeyplane keysWithRepresentedString:v18];

          v48 = 0u;
          v49 = 0u;
          v46 = 0u;
          v47 = 0u;
          v25 = v24;
          v26 = [v25 countByEnumeratingWithState:&v46 objects:v54 count:16];
          if (v26)
          {
            v27 = v26;
            v28 = *v47;
            do
            {
              for (j = 0; j != v27; ++j)
              {
                if (*v47 != v28)
                {
                  objc_enumerationMutation(v25);
                }

                v30 = *(*(&v46 + 1) + 8 * j);
                v31 = objc_loadWeakRetained(&self->_presentationDelegate);
                name = [v30 name];
                [v31 setLabel:v20 forKey:name];
              }

              v27 = [v25 countByEnumeratingWithState:&v46 objects:v54 count:16];
            }

            while (v27);
          }

          v16 = v19;
        }

        v45 = [v19 countByEnumeratingWithState:&v50 objects:v55 count:16];
      }

      while (v45);
    }
  }

  else if (!accentKeyString)
  {
    goto LABEL_30;
  }

  v33 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout2 = [v33 layout];
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    v36 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout3 = [v36 layout];
    [layout3 updateKeyCentroids];
  }

LABEL_30:
  v38 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v38 currentInputMode];

  multilingualLanguages = [v43 multilingualLanguages];
  [currentInputMode setMultilingualLanguages:multilingualLanguages];

  if ([UIKBMultilingualKeyboardIntroductionView shouldShowIntroductionForInputMode:currentInputMode])
  {
    v41 = objc_loadWeakRetained(&self->_presentationDelegate);
    [v41 presentMultilingualKeyboardTip:currentInputMode];
LABEL_34:

    goto LABEL_35;
  }

  if ([UIKBMultilingualSettingIntroductionView shouldShowIntroductionForInputMode:currentInputMode])
  {
    v41 = objc_loadWeakRetained(&self->_presentationDelegate);
    [v41 presentMultilingualSettingTip:currentInputMode];
    goto LABEL_34;
  }

LABEL_35:
  trialParameters = [v43 trialParameters];
  [UIKBAnalyticsDispatcher setKeyboardTrialParameters:trialParameters];
}

- (void)handleKeyboardInput:(id)input executionContext:(id)context
{
  inputCopy = input;
  contextCopy = context;
  kdebug_trace();
  v8 = kac_get_log();
  v9 = os_signpost_id_make_with_pointer(v8, inputCopy);
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v10 = v9;
    if (os_signpost_enabled(v8))
    {
      *buf = 0;
      _os_signpost_emit_with_name_impl(&dword_188A29000, v8, OS_SIGNPOST_INTERVAL_BEGIN, v10, "appInput", " enableTelemetry=YES ", buf, 2u);
    }
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [objc_opt_class() sendPerformanceNotification:@"UIKeyboardPerformanceHandleInputStartNotification"];

  [(_UIKeyboardStateManager *)self cancelCandidateRequests];
  [(_UIKeyboardStateManager *)self refreshKeyboardStateUpdatingSecureCandidateRenderTraits:0];
  touchEventWaitingForKeyInputEvent = [(_UIKeyboardStateManager *)self touchEventWaitingForKeyInputEvent];
  [inputCopy setTouchEvent:touchEventWaitingForKeyInputEvent];

  [(_UIKeyboardStateManager *)self setTouchEventWaitingForKeyInputEvent:0];
  touchEvent = [inputCopy touchEvent];
  [touchEvent timestamp];
  v15 = v14;

  v16 = [(TIKeyboardState *)self->m_keyboardState copy];
  [v16 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
  [v16 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
  acceptedCandidate = [inputCopy acceptedCandidate];
  slotID = [acceptedCandidate slotID];
  v19 = slotID != 0;

  acceptedCandidate2 = [inputCopy acceptedCandidate];
  isHideMyEmailType = 0;
  if (objc_opt_respondsToSelector())
  {
    acceptedCandidate3 = [inputCopy acceptedCandidate];
    isHideMyEmailType = [acceptedCandidate3 isHideMyEmailType];
  }

  if (slotID && self->m_cachedAutofillMode == 1)
  {
    v23 = 1;
  }

  else
  {
    v23 = (+[UIKeyboard isKeyboardProcess]& isHideMyEmailType) == 1 && self->m_cachedAutofillMode == 3;
  }

  if ([inputCopy isBackspace])
  {
    [(_UIKeyboardStateManager *)self removeTextChoicePromptWithUnderline];
    if ([(_UIKeyboardStateManager *)self usesCandidateSelection]&& [(_UIKeyboardStateManager *)self markedTextFromClient])
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager deleteBackward];

      [(_UIKeyboardStateManager *)self syncInputManagerToKeyboardState];
      [(_UIKeyboardStateManager *)self setMarkedTextFromClient:0];
    }
  }

  else
  {
    [(_UIKeyboardStateManager *)self removeTextChoicePrompt];
  }

  location = 0;
  acceptedCandidate4 = [inputCopy acceptedCandidate];
  customInfoType = [acceptedCandidate4 customInfoType];

  if (customInfoType)
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    autofillPayloadDelegate = [remoteTextInputPartner autofillPayloadDelegate];
    objc_storeWeak(&location, autofillPayloadDelegate);
  }

  *buf = 0;
  v47 = buf;
  v48 = 0x2020000000;
  m_textInputSource = self->m_textInputSource;
  v38[0] = MEMORY[0x1E69E9820];
  v38[1] = 3221225472;
  v38[2] = __64___UIKeyboardStateManager_handleKeyboardInput_executionContext___block_invoke;
  v38[3] = &unk_1E70FD570;
  v29 = inputCopy;
  v43[1] = v15;
  v39 = v29;
  selfCopy = self;
  v44 = v19;
  objc_copyWeak(v43, &location);
  v42 = buf;
  v45 = v23;
  v30 = contextCopy;
  v41 = v30;
  v31 = [v38 copy];
  if (v23)
  {
    objc_initWeak(&from, v30);
    aBlock[0] = MEMORY[0x1E69E9820];
    aBlock[1] = 3221225472;
    aBlock[2] = __64___UIKeyboardStateManager_handleKeyboardInput_executionContext___block_invoke_7;
    aBlock[3] = &unk_1E70F5A28;
    objc_copyWeak(&v36, &from);
    v32 = _Block_copy(aBlock);
    [v30 setPendingCompletionBlock:v32];

    objc_destroyWeak(&v36);
    objc_destroyWeak(&from);
  }

  if ([(_UIKeyboardStateManager *)self shouldAccessInputManagerService])
  {
    v33 = _UIKeyboardLog();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(from) = 0;
      _os_log_impl(&dword_188A29000, v33, OS_LOG_TYPE_DEFAULT, "Keyboard sends inputEvent to kbd", &from, 2u);
    }

    backendController = [(_UIKeyboardStateManager *)self backendController];
    [backendController handleKeyboardInput:v29 keyboardState:v16 completionHandler:v31];
  }

  else
  {
    [v30 returnExecutionToParent];
  }

  objc_destroyWeak(v43);
  _Block_object_dispose(buf, 8);
  objc_destroyWeak(&location);
}

- (void)updateKeyboardOutput:(id)output withInputForSmartPunctuation:(id)punctuation keyboardConfiguration:(id)configuration
{
  outputCopy = output;
  punctuationCopy = punctuation;
  configurationCopy = configuration;
  if ([punctuationCopy isPopupVariant])
  {
    isFlick = 1;
  }

  else
  {
    isFlick = [punctuationCopy isFlick];
  }

  m_smartPunctuationController = self->m_smartPunctuationController;
  insertionText = [outputCopy insertionText];
  documentState = [(_UIKeyboardStateManager *)self documentState];
  v14 = [(TISmartPunctuationController *)m_smartPunctuationController smartPunctuationOutputForInput:insertionText isLockedInput:isFlick documentState:documentState];

  if ([v14 deletionCount])
  {
    intermediateText = [configurationCopy intermediateText];
    displayString = [intermediateText displayString];
    v17 = [displayString length];

    if (!v17)
    {
      [outputCopy setDeletionCount:{objc_msgSend(v14, "deletionCount")}];
    }
  }

  insertionText2 = [v14 insertionText];
  if ([insertionText2 length])
  {
    insertionText3 = [outputCopy insertionText];
    v20 = [insertionText3 length];

    if (!v20)
    {
      goto LABEL_11;
    }

    insertionText2 = [v14 insertionText];
    [outputCopy setInsertionText:insertionText2];
  }

LABEL_11:
}

- (void)replaceAllTextInResponder:(id)responder withText:(id)text
{
  responderCopy = responder;
  textCopy = text;
  if (!+[UIKeyboard isModelessActive])
  {
    v8 = +[UIDictationController activeInstance];
    [v8 cancelDictation];
  }

  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];

  if (inputDelegate == responderCopy)
  {
    if (!+[UIKeyboard isKeyboardProcess]&& (objc_opt_respondsToSelector() & 1) != 0)
    {
      [responderCopy setText:&stru_1EFB14550];
    }

    [(_UIKeyboardStateManager *)self callShouldInsertText:textCopy];
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    hasAsyncCapableInputDelegate = [inputDelegateManager hasAsyncCapableInputDelegate];

    if (hasAsyncCapableInputDelegate)
    {
      if (qword_1ED49D138 != -1)
      {
        dispatch_once(&qword_1ED49D138, &__block_literal_global_1047);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v20[2] = __62___UIKeyboardStateManager_replaceAllTextInResponder_withText___block_invoke_3;
      v20[3] = &unk_1E70FD058;
      v20[4] = self;
      [taskQueue addTask:v20 breadcrumb:qword_1ED49D130];

      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      textInputDelegate = [inputDelegateManager2 textInputDelegate];

      if (!textInputDelegate)
      {
        goto LABEL_18;
      }

      inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      textInputDelegate2 = [inputDelegateManager3 textInputDelegate];
      [textInputDelegate2 selectAll:0];

      inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      textInputDelegate3 = [inputDelegateManager4 textInputDelegate];
      [textInputDelegate3 insertText:textCopy];
    }

    else
    {
      inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegateManager4 _replaceDocumentWithText:textCopy];
    }

LABEL_18:
    v19 = +[_UIRemoteKeyboards sharedRemoteKeyboards];
    [v19 restoreKeyboardIfNeeded];

    goto LABEL_19;
  }

  if ([responderCopy conformsToProtocol:&unk_1EFE8B2D0])
  {
    [(_UIKeyboardStateManager *)self callShouldInsertText:textCopy onDelegate:responderCopy];
    [responderCopy _replaceDocumentWithText:textCopy];
  }

  else if (objc_opt_respondsToSelector())
  {
    [responderCopy setText:textCopy];
  }

LABEL_19:
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && [responderCopy isSecureTextEntry])
  {
    [responderCopy _forceObscureAllText];
  }
}

- (BOOL)dontPushOneTimeCode
{
  v3 = +[UIKeyboard keyboardBundleIdentifier];
  if ([v3 hasPrefix:@"com.apple."])
  {
    v4 = [v3 hasPrefix:@"com.apple.social"] ^ 1;
  }

  else
  {
    LOBYTE(v4) = 0;
  }

  textContentType = [(UITextInputTraits *)self->m_traits textContentType];
  v6 = [textContentType isEqualToString:@"one-time-code"] ^ 1;

  return v6 & v4;
}

- (BOOL)insertAutoFillTextSuggestion:(id)suggestion
{
  v29 = *MEMORY[0x1E69E9840];
  suggestionCopy = suggestion;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
    v6 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
    v22 = delegateAsResponder;
    [v6 _beginPinningInputViewsOnBehalfOfResponder:delegateAsResponder];

    v23 = suggestionCopy;
    contents = [suggestionCopy contents];
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v8 = +[UIKBAutofillController preferredInsertionOrder];
    v9 = [v8 countByEnumeratingWithState:&v24 objects:v28 count:16];
    if (v9)
    {
      v10 = v9;
      v11 = 0;
      v12 = *v25;
      do
      {
        for (i = 0; i != v10; ++i)
        {
          if (*v25 != v12)
          {
            objc_enumerationMutation(v8);
          }

          v14 = *(*(&v24 + 1) + 8 * i);
          v15 = [contents objectForKey:v14];

          if (v15)
          {
            autofillController = [(_UIKeyboardStateManager *)self autofillController];
            autofillGroup = [autofillController autofillGroup];
            v18 = [autofillGroup objectForKey:v14];

            [v18 becomeFirstResponder];
            +[_UIKeyboardUsageTracking appAutofillDetectedDecrement];
            v19 = [contents objectForKey:v14];
            [(_UIKeyboardStateManager *)self replaceAllTextInResponder:v18 withText:v19];

            v11 = 1;
          }
        }

        v10 = [v8 countByEnumeratingWithState:&v24 objects:v28 count:16];
      }

      while (v10);
    }

    else
    {
      v11 = 0;
    }

    v20 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
    [v20 _stopPinningInputViewsOnBehalfOfResponder:v22];

    suggestionCopy = v23;
  }

  else
  {
    v11 = 0;
  }

  return v11 & 1;
}

- (void)performKeyboardOutputInfo:(id)info
{
  v149 = *MEMORY[0x1E69E9840];
  infoCopy = info;
  v5 = infoCopy;
  if (infoCopy)
  {
    v6 = *MEMORY[0x1E69D9878];
    v132 = [infoCopy objectForKey:*MEMORY[0x1E69D9878]];
    if (v132 && (-[_UIKeyboardStateManager textInputTraits](self, "textInputTraits"), v7 = objc_claimAutoreleasedReturnValue(), v8 = [v7 acceptsPayloads], v7, v8))
    {
      v9 = +[UITextInputPayloadController sharedInstance];
      payloadDelegate = [v9 payloadDelegate];

      if (payloadDelegate)
      {
        v11 = [v5 mutableCopy];
        [v11 removeObjectForKey:v6];
        [payloadDelegate handlePayload:v11 withPayloadId:v132];
      }
    }

    else
    {
      v12 = [v5 objectForKey:*MEMORY[0x1E69D9890]];
      bOOLValue = [v12 BOOLValue];

      if (bOOLValue)
      {
        [(_UIKeyboardStateManager *)self performSendCurrentLocation];
      }
    }

    if (-[_UIKeyboardStateManager dontPushOneTimeCode](self, "dontPushOneTimeCode") || ([v5 objectForKey:@"AutofillOneTimeCodeAvailable"], v14 = objc_claimAutoreleasedReturnValue(), (v129 = v14) == 0))
    {
      v129 = 0;
    }

    else if ([v14 BOOLValue])
    {
      [(_UIKeyboardStateManager *)self refreshKeyboardState];
      [(_UIKeyboardStateManager *)self generateAutofillCandidate];
    }

    v130 = [v5 objectForKey:@"ExternalCredentialData"];
    v15 = v130;
    if (v130)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        UIKeyboardSafariPresentExternalCredentialViewControllerForCredentialData(v130);
LABEL_101:

        goto LABEL_102;
      }
    }

    self->m_isAutofilling = 1;
    autofillController = [(_UIKeyboardStateManager *)self autofillController];
    autofillGroup = [autofillController autofillGroup];
    v133 = [autofillGroup objectForKey:@"UIAutofillContextKey"];

    if (!v133)
    {
      if (AutoFillUILibraryCore() && (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v18 = objc_claimAutoreleasedReturnValue(), v19 = [v18 hasAsyncCapableInputDelegate], v18, v19))
      {
        autofillController2 = [(_UIKeyboardStateManager *)self autofillController];
        autofillGroup2 = [autofillController2 autofillGroup];
        v144 = 0;
        v145 = &v144;
        v146 = 0x2020000000;
        v22 = getAFUIAutoFillContextKeySymbolLoc_ptr;
        v147 = getAFUIAutoFillContextKeySymbolLoc_ptr;
        if (!getAFUIAutoFillContextKeySymbolLoc_ptr)
        {
          v139 = MEMORY[0x1E69E9820];
          v140 = 3221225472;
          v141 = __getAFUIAutoFillContextKeySymbolLoc_block_invoke;
          v142 = &unk_1E70F2F20;
          v143 = &v144;
          v23 = AutoFillUILibrary();
          v145[3] = dlsym(v23, "AFUIAutoFillContextKey");
          getAFUIAutoFillContextKeySymbolLoc_ptr = *(v143[1] + 24);
          v22 = v145[3];
        }

        _Block_object_dispose(&v144, 8);
        if (!v22)
        {
          currentHandler = [MEMORY[0x1E696AAA8] currentHandler];
          v122 = [MEMORY[0x1E696AEC0] stringWithUTF8String:"NSString *getAFUIAutoFillContextKey(void)"];
          [currentHandler handleFailureInFunction:v122 file:@"_UIKeyboardStateManager.m" lineNumber:319 description:{@"%s", dlerror()}];

          __break(1u);
        }

        v133 = [autofillGroup2 objectForKey:*v22];
      }

      else
      {
        v133 = 0;
      }
    }

    v131 = [v5 objectForKeyedSubscript:*MEMORY[0x1E69D98A0]];
    v24 = *MEMORY[0x1E69D9888];
    v125 = [v5 objectForKeyedSubscript:*MEMORY[0x1E69D9888]];
    if ([v133 count] && v131 | v125)
    {
      inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
      v26 = [v133 objectForKey:@"_WebViewURL"];

      if (inputDelegate)
      {
        goto LABEL_40;
      }

      delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
      v28 = delegateAsResponder != 0;

      if (v28 && v26 != 0)
      {
        inputDelegate = [(_UIKeyboardStateManager *)self delegateAsResponder];
      }

      else
      {
        inputDelegate = 0;
      }

      if (!inputDelegate && v26)
      {
        autofillController3 = [(_UIKeyboardStateManager *)self autofillController];
        autofillGroup3 = [autofillController3 autofillGroup];
        v31 = [autofillGroup3 objectForKey:@"UIAutofillPossibleRespondersKey"];

        if (AutoFillUILibraryCore() && !v31)
        {
          autofillController4 = [(_UIKeyboardStateManager *)self autofillController];
          autofillGroup4 = [autofillController4 autofillGroup];
          v34 = getAFUIAutoFillPossibleRespondersKey();
          v31 = [autofillGroup4 objectForKey:v34];
        }

        inputDelegate = [v31 firstObject];
        if (objc_opt_respondsToSelector())
        {
          [inputDelegate becomeFirstResponder];
        }
      }

      if (inputDelegate)
      {
LABEL_40:
        autofillController5 = [(_UIKeyboardStateManager *)self autofillController];
        v36 = [autofillController5 autofillContextForInputDelegate:inputDelegate];

        if ([v36 count] && (objc_msgSend(v133, "isEqualToDictionary:", v36) & 1) != 0)
        {
          v37 = [UITextAutofillSuggestion autofillSuggestionWithUsername:v131 password:v125];
          inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
          v39 = [inputDelegateManager insertTextSuggestion:v37];

          if (v39)
          {
            v40 = 0;
            v127 = 1;
            goto LABEL_48;
          }
        }

        else
        {
        }
      }

      else
      {
        objc_storeStrong(&self->m_autofillCustomInfo, info);
      }
    }

    if ([v131 length])
    {
      autofillController6 = [(_UIKeyboardStateManager *)self autofillController];
      autofillGroup5 = [autofillController6 autofillGroup];
      v43 = [autofillGroup5 objectForKey:@"username"];

      [v43 becomeFirstResponder];
      +[_UIKeyboardUsageTracking appAutofillDetectedDecrement];
      [(_UIKeyboardStateManager *)self replaceAllTextInResponder:v43 withText:v131];

      v127 = 0;
      v40 = 1;
    }

    else
    {
      v127 = 0;
      v40 = 0;
    }

LABEL_48:
    v44 = *MEMORY[0x1E69D9898];
    v45 = [v5 objectForKey:*MEMORY[0x1E69D9898]];

    if (!v45)
    {
      goto LABEL_58;
    }

    autofillController7 = [(_UIKeyboardStateManager *)self autofillController];
    autofillGroup6 = [autofillController7 autofillGroup];
    v48 = [autofillGroup6 objectForKey:@"username"];

    v49 = v48 == 0;
    autofillController8 = [(_UIKeyboardStateManager *)self autofillController];
    autofillGroup7 = [autofillController8 autofillGroup];
    autofillGroup15 = autofillGroup7;
    if (v49)
    {
      v54 = [autofillGroup7 objectForKey:@"email"];

      if (!v54)
      {
        v55 = 0;
LABEL_54:
        [v55 becomeFirstResponder];
        v56 = [v5 objectForKey:v44];
        [(_UIKeyboardStateManager *)self replaceAllTextInResponder:v55 withText:v56];

        autofillController9 = [(_UIKeyboardStateManager *)self autofillController];
        autofillGroup8 = [autofillController9 autofillGroup];
        v59 = [autofillGroup8 objectForKey:@"password"];

        if (v59 || (-[_UIKeyboardStateManager autofillController](self, "autofillController"), v60 = objc_claimAutoreleasedReturnValue(), [v60 autofillGroup], v61 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v61, "objectForKey:", @"new-password"), v59 = objc_claimAutoreleasedReturnValue(), v61, v60, v59))
        {
          [v55 resignFirstResponder];
          [v59 becomeFirstResponder];
        }

LABEL_58:
        v62 = *MEMORY[0x1E69D9880];
        v63 = [v5 objectForKey:*MEMORY[0x1E69D9880]];

        if (!v63)
        {
          goto LABEL_75;
        }

        autofillController10 = [(_UIKeyboardStateManager *)self autofillController];
        autofillGroup9 = [autofillController10 autofillGroup];
        v66 = [autofillGroup9 objectForKey:@"one-time-code"];

        delegateAsResponder2 = [(_UIKeyboardStateManager *)self delegateAsResponder];
        LOBYTE(autofillGroup9) = [delegateAsResponder2 isFirstResponder];

        if ((autofillGroup9 & 1) == 0)
        {
          delegateAsResponder3 = [(_UIKeyboardStateManager *)self delegateAsResponder];
          [delegateAsResponder3 becomeFirstResponder];
        }

        v69 = [v5 objectForKey:v62];
        inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
        v71 = inputDelegate2;
        if (v66 == inputDelegate2)
        {
          objc_opt_class();
          isKindOfClass = objc_opt_isKindOfClass();

          if (isKindOfClass)
          {
            [(_UIKeyboardStateManager *)self replaceAllTextInResponder:v66 withText:&stru_1EFB14550];
            v73 = [v69 length];
            if (v73 >= 1)
            {
              v74 = 0;
              v75 = v73 & 0x7FFFFFFF;
              do
              {
                v76 = [v69 substringWithRange:{v74, 1}];
                if ([(_UIKeyboardStateManager *)self callShouldInsertText:v76])
                {
                  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
                  [inputDelegateManager2 insertText:v76];
                }

                ++v74;
              }

              while (v75 != v74);
            }

            goto LABEL_74;
          }
        }

        else
        {
        }

        if (objc_opt_respondsToSelector())
        {
          [v66 setText:v69];
        }

        else if ([v66 conformsToProtocol:&unk_1EFE8A940])
        {
          [v66 insertText:v69];
        }

LABEL_74:
        inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        [inputDelegateManager3 moveSelectionToEndOfWord];

        inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
        v80 = [(_UIKeyboardStateManager *)self needAutofillCandidate:inputDelegate3];
        autofillController11 = [(_UIKeyboardStateManager *)self autofillController];
        [autofillController11 setDelegateNeedsAutofillMode:v80];

LABEL_75:
        if ((v127 & 1) == 0)
        {
          v82 = [v5 objectForKey:v24];
          v83 = v82 == 0;

          if (!v83)
          {
            autofillController12 = [(_UIKeyboardStateManager *)self autofillController];
            autofillGroup10 = [autofillController12 autofillGroup];
            v86 = [autofillGroup10 objectForKey:@"password"];

            [v86 becomeFirstResponder];
            +[_UIKeyboardUsageTracking appAutofillDetectedDecrement];
            v87 = [v5 objectForKey:v24];
            [(_UIKeyboardStateManager *)self replaceAllTextInResponder:v86 withText:v87];

            v40 = 1;
          }
        }

        v88 = [v5 objectForKey:@"NewPassword"];

        if (v88)
        {
          autofillController13 = [(_UIKeyboardStateManager *)self autofillController];
          autofillGroup11 = [autofillController13 autofillGroup];
          v91 = [autofillGroup11 objectForKey:@"new-password"];

          [v91 becomeFirstResponder];
          +[_UIKeyboardUsageTracking appAutofillDetectedDecrement];
          v92 = [v5 objectForKey:@"NewPassword"];
          [(_UIKeyboardStateManager *)self replaceAllTextInResponder:v91 withText:v92];

          v40 = 1;
        }

        v93 = [v5 objectForKey:@"AutofillCellularEID"];

        if (v93)
        {
          autofillController14 = [(_UIKeyboardStateManager *)self autofillController];
          autofillGroup12 = [autofillController14 autofillGroup];
          v96 = [autofillGroup12 objectForKey:@"esim-eid"];

          [v96 becomeFirstResponder];
          +[_UIKeyboardUsageTracking appAutofillDetectedDecrement];
          v97 = [v5 objectForKey:@"AutofillCellularEID"];
          [(_UIKeyboardStateManager *)self replaceAllTextInResponder:v96 withText:v97];

          v40 = 1;
        }

        v98 = [v5 objectForKey:@"AutofillCellularIMEI"];

        if (v98)
        {
          autofillController15 = [(_UIKeyboardStateManager *)self autofillController];
          autofillGroup13 = [autofillController15 autofillGroup];
          v101 = [autofillGroup13 objectForKey:@"esim-imei"];

          [v101 becomeFirstResponder];
          +[_UIKeyboardUsageTracking appAutofillDetectedDecrement];
          v102 = [v5 objectForKey:@"AutofillCellularIMEI"];
          [(_UIKeyboardStateManager *)self replaceAllTextInResponder:v101 withText:v102];

          v40 = 1;
        }

        delegateAsResponder4 = [(_UIKeyboardStateManager *)self delegateAsResponder];
        autofillController16 = [(_UIKeyboardStateManager *)self autofillController];
        v126 = [autofillController16 textContentTypeForInputDelegate:delegateAsResponder4];

        v104 = [v5 objectForKey:v126];

        if (v104)
        {
          v124 = [UIAutoFillTextSuggestion autoFillSuggestionWithContents:v5];
          inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          v106 = [inputDelegateManager4 insertTextSuggestion:v124];

          if ((v106 & 1) == 0)
          {
            delegateAsResponder5 = [(_UIKeyboardStateManager *)self delegateAsResponder];
            v107 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
            [v107 _beginPinningInputViewsOnBehalfOfResponder:delegateAsResponder5];

            v137 = 0u;
            v138 = 0u;
            v135 = 0u;
            v136 = 0u;
            v108 = +[UIKBAutofillController preferredInsertionOrder];
            v109 = [v108 countByEnumeratingWithState:&v135 objects:v148 count:16];
            if (v109)
            {
              v110 = *v136;
              do
              {
                for (i = 0; i != v109; ++i)
                {
                  if (*v136 != v110)
                  {
                    objc_enumerationMutation(v108);
                  }

                  v112 = *(*(&v135 + 1) + 8 * i);
                  v113 = [v5 objectForKey:v112];

                  if (v113)
                  {
                    autofillController17 = [(_UIKeyboardStateManager *)self autofillController];
                    autofillGroup14 = [autofillController17 autofillGroup];
                    v116 = [autofillGroup14 objectForKey:v112];

                    [v116 becomeFirstResponder];
                    +[_UIKeyboardUsageTracking appAutofillDetectedDecrement];
                    v117 = [v5 objectForKey:v112];
                    [(_UIKeyboardStateManager *)self replaceAllTextInResponder:v116 withText:v117];

                    v40 = 1;
                  }
                }

                v109 = [v108 countByEnumeratingWithState:&v135 objects:v148 count:16];
              }

              while (v109);
            }

            v118 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
            [v118 _stopPinningInputViewsOnBehalfOfResponder:delegateAsResponder5];

            if ((v40 & 1) == 0)
            {
              v119 = [v5 objectForKey:&stru_1EFB14550];
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                inputDelegate4 = [(_UIKeyboardStateManager *)self inputDelegate];
                [(_UIKeyboardStateManager *)self replaceAllTextInResponder:inputDelegate4 withText:v119];
              }
            }
          }
        }

        +[_UIKeyboardUsageTracking appAutofillFilled];
        self->m_isAutofilling = 0;

        v15 = v130;
        goto LABEL_101;
      }

      autofillController8 = [(_UIKeyboardStateManager *)self autofillController];
      autofillGroup15 = [autofillController8 autofillGroup];
      v53 = [autofillGroup15 objectForKey:@"email"];
    }

    else
    {
      v53 = [autofillGroup7 objectForKey:@"username"];
    }

    v55 = v53;

    goto LABEL_54;
  }

LABEL_102:
}

- (void)insertDictationResult:(id)result
{
  resultCopy = result;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager insertDictationResult:resultCopy];
}

- (void)handleRemoteIndirectGestureWithState:(id)state
{
  stateCopy = state;
  delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  _responderForEditing = [delegateAsResponder _responderForEditing];
  __textInteractionFromAssistant = [_responderForEditing __textInteractionFromAssistant];

  v7 = [__textInteractionFromAssistant interactionWithGestureForName:0x1EFB7FF50];
  if (!v7)
  {
    v7 = [__textInteractionFromAssistant interactionWithGestureForName:0x1EFB7FF70];
    if (!v7)
    {
      customInputDelegateSelectionInteraction = self->_customInputDelegateSelectionInteraction;
      if (!customInputDelegateSelectionInteraction)
      {
        v9 = +[_UIKeyboardTextSelectionGestureController sharedInstance];
        textSelectionInteractionForRTIForwarding = [v9 textSelectionInteractionForRTIForwarding];
        v11 = self->_customInputDelegateSelectionInteraction;
        self->_customInputDelegateSelectionInteraction = textSelectionInteractionForRTIForwarding;

        customInputDelegateSelectionInteraction = self->_customInputDelegateSelectionInteraction;
      }

      v7 = customInputDelegateSelectionInteraction;
    }
  }

  v12 = v7;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [(_UIKeyboardTextSelectionInteraction *)v12 handleRemoteIndirectGestureWithState:stateCopy];
  }
}

- (void)performKeyboardOutput:(id)output
{
  outputCopy = output;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];
  v6 = forwardingInputDelegate == 0;

  [(_UIKeyboardStateManager *)self performKeyboardOutput:outputCopy forwardToRemoteInputSource:v6];
}

- (void)performKeyboardOutput:(id)output forwardToRemoteInputSource:(BOOL)source
{
  [(_UIKeyboardStateManager *)self performKeyboardOutput:output checkingDelegate:0 forwardToRemoteInputSource:source];
  [(_UIKeyboardStateManager *)self _cancelPendingSupplementalCandidateInsertion];
  lastMatchedSupplementalCandidate = [(_UIKeyboardStateManager *)self lastMatchedSupplementalCandidate];

  if (lastMatchedSupplementalCandidate)
  {

    [(_UIKeyboardStateManager *)self generateCandidates];
  }
}

- (BOOL)performKeyboardEvent:(id)event
{
  eventCopy = event;
  if ([eventCopy keyEventForwardedFromInputUIHost])
  {
    if (qword_1ED49D148 != -1)
    {
      dispatch_once(&qword_1ED49D148, &__block_literal_global_1075);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __48___UIKeyboardStateManager_performKeyboardEvent___block_invoke_3;
    v12[3] = &unk_1E70FD1B8;
    v12[4] = self;
    v13 = eventCopy;
    [taskQueue addTask:v12 breadcrumb:qword_1ED49D140];

    v6 = v13;
LABEL_10:

    v7 = 1;
    goto LABEL_11;
  }

  if (![eventCopy keyCommandHandlingBeforePublic])
  {
    if (qword_1ED49D158 != -1)
    {
      dispatch_once(&qword_1ED49D158, &__block_literal_global_1081);
    }

    taskQueue2 = [(_UIKeyboardStateManager *)self taskQueue];
    v10[0] = MEMORY[0x1E69E9820];
    v10[1] = 3221225472;
    v10[2] = __48___UIKeyboardStateManager_performKeyboardEvent___block_invoke_6;
    v10[3] = &unk_1E70FD1B8;
    v10[4] = self;
    v11 = eventCopy;
    [taskQueue2 addTask:v10 breadcrumb:qword_1ED49D150];

    v6 = v11;
    goto LABEL_10;
  }

  v7 = [(_UIKeyboardStateManager *)self handleKeyCommandsBeforePublicAsInputUIHost:eventCopy];
LABEL_11:

  return v7;
}

- (void)performKeyboardOutputAsRTIClient:(id)client
{
  clientCopy = client;
  if (qword_1ED49D168 != -1)
  {
    dispatch_once(&qword_1ED49D168, &__block_literal_global_1085);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v8[0] = MEMORY[0x1E69E9820];
  v8[1] = 3221225472;
  v8[2] = __60___UIKeyboardStateManager_performKeyboardOutputAsRTIClient___block_invoke_3;
  v8[3] = &unk_1E70FD1B8;
  v8[4] = self;
  v9 = clientCopy;
  v6 = qword_1ED49D160;
  v7 = clientCopy;
  [taskQueue addTask:v8 breadcrumb:v6];
}

- (BOOL)performKeyboardOutput:(id)output checkingDelegate:(BOOL)delegate forwardToRemoteInputSource:(BOOL)source
{
  sourceCopy = source;
  delegateCopy = delegate;
  v15[2] = *MEMORY[0x1E69E9840];
  v14[0] = 0x1EFB64610;
  v8 = MEMORY[0x1E696AD98];
  outputCopy = output;
  v10 = [v8 numberWithBool:delegateCopy];
  v14[1] = 0x1EFB64630;
  v15[0] = v10;
  v11 = [MEMORY[0x1E696AD98] numberWithBool:sourceCopy];
  v15[1] = v11;
  v12 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v15 forKeys:v14 count:2];

  LOBYTE(v11) = [(_UIKeyboardStateManager *)self performKeyboardOutput:outputCopy userInfo:v12];
  return v11;
}

- (BOOL)performKeyboardOutput:(id)output userInfo:(id)info
{
  v184 = *MEMORY[0x1E69E9840];
  outputCopy = output;
  infoCopy = info;
  v9 = [infoCopy objectForKeyedSubscript:0x1EFB64610];
  bOOLValue = [v9 BOOLValue];

  v10 = [infoCopy objectForKeyedSubscript:0x1EFB64630];
  bOOLValue2 = [v10 BOOLValue];

  v11 = _UIKeyboardLog();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    v145 = "NO";
    *&buf[4] = "[_UIKeyboardStateManager performKeyboardOutput:userInfo:]";
    if (bOOLValue)
    {
      v146 = "YES";
    }

    else
    {
      v146 = "NO";
    }

    *buf = 136315650;
    *&buf[14] = v146;
    *&buf[12] = 2080;
    if (bOOLValue2)
    {
      v145 = "YES";
    }

    *&buf[22] = 2080;
    v183 = v145;
    _os_log_debug_impl(&dword_188A29000, v11, OS_LOG_TYPE_DEBUG, "%s shouldCheckDelegate=%s, forwardToRemote=%s", buf, 0x20u);
  }

  *buf = 0;
  *&buf[8] = buf;
  *&buf[16] = 0x2020000000;
  LOBYTE(v183) = 0;
  if (+[UIDictationController isRunning](UIDictationController, "isRunning") && (+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || !+[UIKeyboard usesInputSystemUI]))
  {
    [(_UIKeyboardStateManager *)self updateIdleDetection:2];
  }

  inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
  [inlineTextCompletionController willPerformKeyboardOutput:outputCopy];

  if ((bOOLValue2 & 1) == 0)
  {
    inlineTextCompletionController = [(_UIKeyboardStateManager *)self inputDelegateManager];
    inputSystemSourceSession = [inlineTextCompletionController inputSystemSourceSession];
    if (inputSystemSourceSession)
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];
      if (!forwardingInputDelegate)
      {
        goto LABEL_7;
      }
    }

LABEL_18:

    goto LABEL_19;
  }

LABEL_7:
  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];

  if (bOOLValue2)
  {
    if (!remoteTextInputPartner)
    {
      goto LABEL_19;
    }

    goto LABEL_14;
  }

  if (remoteTextInputPartner)
  {
LABEL_14:
    if (+[UIKeyboard isKeyboardProcess])
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      delegateAdoptsWebTextInputPrivate = [inputDelegateManager2 delegateAdoptsWebTextInputPrivate];

      if (delegateAdoptsWebTextInputPrivate)
      {
        [(_UIKeyboardStateManager *)self updateChangeTimeAndIncrementCount];
      }
    }

    v175[0] = MEMORY[0x1E69E9820];
    v175[1] = 3221225472;
    v175[2] = __58___UIKeyboardStateManager_performKeyboardOutput_userInfo___block_invoke;
    v175[3] = &unk_1E70FD598;
    v176 = outputCopy;
    selfCopy = self;
    v178 = buf;
    [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v175 shouldFlush:0];
    inlineTextCompletionController = v176;
    goto LABEL_18;
  }

LABEL_19:
  self->m_didSyncDocumentStateToInputDelegate = 0;
  acceptedCandidate = [outputCopy acceptedCandidate];

  if (acceptedCandidate)
  {
    acceptedCandidate2 = [outputCopy acceptedCandidate];
    v19 = [(_UIKeyboardStateManager *)self acceptAutofillExtraCandidateIfNeeded:acceptedCandidate2];

    if (!v19)
    {
      if (!+[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI") || ([outputCopy acceptedCandidate], v20 = objc_claimAutoreleasedReturnValue(), v21 = objc_msgSend(v20, "isSupplementalItemCandidate"), v20, !v21) || (objc_msgSend(outputCopy, "acceptedCandidate"), v22 = objc_claimAutoreleasedReturnValue(), v23 = -[_UIKeyboardStateManager _insertSupplementalCandidate:overridingCandidateText:](self, "_insertSupplementalCandidate:overridingCandidateText:", v22, 0), v22, !v23))
      {
        acceptedCandidate3 = [outputCopy acceptedCandidate];
        candidate = [acceptedCandidate3 candidate];

        if (candidate)
        {
          v26 = +[UIKBAnalyticsDispatcher sharedInstance];
          [v26 setNextCommitTextSource:5];

          [(_UIKeyboardStateManager *)self acceptCandidate:acceptedCandidate3];
        }

        else
        {
          stickerIdentifier = [acceptedCandidate3 stickerIdentifier];
          if (stickerIdentifier && +[UIKeyboard usesInputSystemUI])
          {
            v28 = +[UIKeyboard isKeyboardProcess];

            if (!v28)
            {
              [(_UIKeyboardStateManager *)self applyAutocorrection:acceptedCandidate3];
            }
          }

          else
          {
          }
        }
      }
    }
  }

  if (*(*&buf[8] + 24) == 1)
  {
    [(_UIKeyboardStateManager *)self flushKeyboardOutputOnInputSourceSession];
  }

  if (+[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI") && [outputCopy positionOffset])
  {
    positionOffset = [outputCopy positionOffset];
    inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager3 collapseSelectionAndAdjustByOffset:positionOffset];

    v166 = 0;
  }

  else
  {
    v166 = 1;
  }

  textToCommit = [outputCopy textToCommit];

  if (textToCommit)
  {
    inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    deletionCount = [outputCopy deletionCount];
    textToCommit2 = [outputCopy textToCommit];
    LODWORD(deletionCount) = [inputDelegateManager4 callShouldReplaceExtendedRange:deletionCount withText:textToCommit2 includeMarkedText:1];

    if (deletionCount)
    {
      textToCommit3 = [outputCopy textToCommit];
      [(_UIKeyboardStateManager *)self unmarkText:textToCommit3];
    }

    else
    {
      [(_UIKeyboardStateManager *)self unmarkText:&stru_1EFB14550];
      v166 = 0;
    }
  }

  if ([outputCopy unmarkIfNecessary] && -[_UIKeyboardStateManager _hasMarkedText](self, "_hasMarkedText"))
  {
    self->m_textInputChangesIgnored = 1;
    inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager5 unmarkText];

    self->m_textInputChangesIgnored = 0;
  }

  if ([outputCopy forwardDeletionCount])
  {
    for (i = 0; i < [outputCopy forwardDeletionCount]; ++i)
    {
      -[_UIKeyboardStateManager deleteForwardAndNotify:producedByDeleteInput:](self, "deleteForwardAndNotify:producedByDeleteInput:", 0, [outputCopy producedByDeleteInput]);
    }
  }

  insertionTextAfterSelection = [outputCopy insertionTextAfterSelection];

  if (insertionTextAfterSelection)
  {
    self->m_suppressingDocumentAssertions = 1;
    inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    insertionTextAfterSelection2 = [outputCopy insertionTextAfterSelection];
    [inputDelegateManager6 insertTextAfterSelection:insertionTextAfterSelection2];

    self->m_suppressingDocumentAssertions = 0;
  }

  v164 = [outputCopy performSelector:sel_producedByDeleteInput];
  if ([outputCopy deletionCount])
  {
    insertionText = [outputCopy insertionText];
    if (insertionText)
    {
      insertionText2 = [outputCopy insertionText];
      v43 = [insertionText2 length] == 0;

      if (!v43)
      {
        v44 = +[UIKBAnalyticsDispatcher sharedInstance];
        if (v164)
        {
          [v44 setNextCandidateReplacementSource:10];
        }

        else
        {
          [v44 setNextCandidateReplacementSource:9];
        }
      }
    }
  }

  if ([outputCopy deletionCount])
  {
    if (v164)
    {
      v45 = bOOLValue;
    }

    else
    {
      v45 = 0;
    }

    if (v45 == 1 && (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v46 = objc_claimAutoreleasedReturnValue(), v47 = [v46 callShouldDeleteBackwardWithCount:{objc_msgSend(outputCopy, "deletionCount")}], v46, !v47))
    {
      v53 = objc_alloc_init(MEMORY[0x1E69C6F48]);
      v54 = objc_alloc_init(MEMORY[0x1E69D95F8]);
      [v53 setKeyboardInput:v54];

      v55 = objc_alloc_init(MEMORY[0x1E69D9638]);
      keyboardInput = [v53 keyboardInput];
      [keyboardInput setOutput:v55];

      [v55 setDeletionCount:0];
      insertionText3 = [outputCopy insertionText];
      v58 = [insertionText3 length];

      for (j = v58 - 1; (j & 0x80000000) == 0; j -= v62)
      {
        [v55 setDeletionCount:{objc_msgSend(v55, "deletionCount") + 1}];
        insertionText4 = [outputCopy insertionText];
        [insertionText4 _rangeOfBackwardDeletionClusterAtIndex:j];
        v62 = v61;
      }

      string = [MEMORY[0x1E696AD60] string];
      documentState = [(_UIKeyboardStateManager *)self documentState];
      contextBeforeInput = [documentState contextBeforeInput];

      v66 = [contextBeforeInput length];
      deletionCount2 = [outputCopy deletionCount];
      v68 = v66 - 1;
      if (v66 - 1 >= 0)
      {
        v69 = deletionCount2;
        if (deletionCount2 >= 1)
        {
          do
          {
            v70 = [contextBeforeInput _rangeOfBackwardDeletionClusterAtIndex:v68];
            v72 = v71;
            v73 = [contextBeforeInput substringWithRange:{v70, v71}];
            [string insertString:v73 atIndex:0];

            v68 -= v72;
            if ((v68 & 0x80000000) != 0)
            {
              break;
            }
          }

          while (v69-- > 1);
        }
      }

      [v55 setInsertionText:string];
      remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      [remoteTextInputPartner2 performInputOperation:v53];

      [outputCopy setInsertionText:0];
      v166 = 0;
    }

    else
    {
      insertionText5 = [outputCopy insertionText];

      if (insertionText5)
      {
        asyncCapableInputDelegate = [(_UIKeyboardStateManager *)self asyncCapableInputDelegate];
        v50 = asyncCapableInputDelegate == 0;
      }

      else
      {
        v50 = 0;
      }

      -[_UIKeyboardStateManager deleteBackwardAndNotifyAtEnd:deletionCount:reinsertTextInLoop:](self, "deleteBackwardAndNotifyAtEnd:deletionCount:reinsertTextInLoop:", insertionText5 == 0, [outputCopy deletionCount], v50);
    }

    v52 = +[UIDictationController activeInstance];
    [v52 markKeyboardDeleteMetricEvent];
  }

  else
  {
    v51 = +[UIDictationController activeInstance];
    [v51 markKeyboardInputMetricEvent];

    v52 = +[UIDictationController activeInstance];
    [v52 markDictationTipInputEvent];
  }

  if (_os_feature_enabled_impl())
  {
    acceptedCandidate4 = [outputCopy acceptedCandidate];
    stickerIdentifier2 = [acceptedCandidate4 stickerIdentifier];
    if (stickerIdentifier2)
    {
      acceptedCandidate5 = [outputCopy acceptedCandidate];
      v79 = [acceptedCandidate5 customInfoType] == 4096;

      if (v79)
      {
        acceptedCandidate6 = [outputCopy acceptedCandidate];
        stickerIdentifier3 = [acceptedCandidate6 stickerIdentifier];

        v181[0] = @"com.apple.stickers.role.still";
        v181[1] = @"com.apple.stickers.role.animated";
        v181[2] = @"com.apple.stickers.role.stillVariant_40";
        v181[3] = @"com.apple.stickers.role.stillVariant_64";
        v181[4] = @"com.apple.stickers.role.stillVariant_96";
        v181[5] = @"com.apple.stickers.role.stillVariant_160";
        v181[6] = @"com.apple.stickers.role.stillVariant_320";
        v163 = [MEMORY[0x1E695DEC8] arrayWithObjects:v181 count:7];
        backendController = [(_UIKeyboardStateManager *)self backendController];
        [backendController stickerWithIdentifier:stickerIdentifier3 stickerRoles:v163 completionHandler:&__block_literal_global_1098];

        v159 = +[_UISignalAnalytics getIASignalGenmojiUsage];
        v161 = +[_UISignalAnalytics getIAPayloadKeyGenmojiBundleID];
        v179[0] = v161;
        v160 = +[UIKeyboard keyboardBundleIdentifier];
        v180[0] = v160;
        v82 = +[_UISignalAnalytics getIAPayloadKeyGenmojiImageType];
        v179[1] = v82;
        v83 = +[_UISignalAnalytics getIAPayloadValueGenmojiUnspecified];
        v180[1] = v83;
        v84 = +[_UISignalAnalytics getIAPayloadKeyGenmojiUsageSource];
        v179[2] = v84;
        v85 = +[_UISignalAnalytics getIAPayloadValueGenmojiUsageSourceCandidateBarSuggestion];
        v180[2] = v85;
        v86 = +[_UISignalAnalytics getIAPayloadKeyGenmojiUsageType];
        v179[3] = v86;
        v87 = +[_UISignalAnalytics getIAPayloadValueGenmojiUsageTypeTap];
        v180[3] = v87;
        v88 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v180 forKeys:v179 count:4];
        [_UISignalAnalytics sendGenmojiSignal:v159 payload:v88];

        goto LABEL_88;
      }
    }

    else
    {
    }
  }

  insertionText6 = [outputCopy insertionText];
  if (![insertionText6 length])
  {

    goto LABEL_88;
  }

  customInfo = [outputCopy customInfo];
  v91 = [customInfo objectForKey:@"AutofillOneTimeCode"];
  v92 = v91 == 0;

  if (v92)
  {
    v93 = +[UIKeyboardInputModeController sharedInputModeController];
    currentInputMode = [v93 currentInputMode];
    identifier = [currentInputMode identifier];
    v96 = [identifier isEqualToString:@"autofillsignup"];

    if (v96)
    {
      v97 = +[UIKeyboardInputModeController sharedInputModeController];
      currentLinguisticInputMode = [v97 currentLinguisticInputMode];
      isDefaultRightToLeft = [currentLinguisticInputMode isDefaultRightToLeft];

      autofillController = [(_UIKeyboardStateManager *)self autofillController];
      v172[0] = MEMORY[0x1E69E9820];
      v172[1] = 3221225472;
      v172[2] = __58___UIKeyboardStateManager_performKeyboardOutput_userInfo___block_invoke_4;
      v172[3] = &unk_1E70FD5E0;
      v172[4] = self;
      v173 = outputCopy;
      v174 = isDefaultRightToLeft;
      [autofillController enumeratePasswordFieldsUsingBlock:v172];

      goto LABEL_88;
    }

    if (bOOLValue)
    {
      insertionText7 = [outputCopy insertionText];
      v143 = [(_UIKeyboardStateManager *)self callShouldInsertText:insertionText7];

      if (!v143)
      {
        v166 = 0;
        goto LABEL_88;
      }
    }

    if (_UIIsPrivateMainBundle() && !dyld_program_sdk_at_least())
    {
      v144 = 0;
    }

    else
    {
      v144 = 1;
      self->m_textInputChangesIgnored = 1;
    }

    documentState2 = [(_UIKeyboardStateManager *)self documentState];
    [documentState2 _selectedTextRange];
    if (v148)
    {
      documentState3 = [(_UIKeyboardStateManager *)self documentState];
      contextBeforeInput2 = [documentState3 contextBeforeInput];
      if (!contextBeforeInput2)
      {
        documentState4 = [(_UIKeyboardStateManager *)self documentState];
        contextAfterInput = [documentState4 contextAfterInput];
        v158 = contextAfterInput == 0;

        if (v158)
        {
          [(_UIKeyboardStateManager *)self setInitialDirectionIgnoreRangeCheck:1];
        }

        goto LABEL_149;
      }
    }

LABEL_149:
    v151 = [infoCopy objectForKeyedSubscript:0x1EFB64650];
    inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    insertionText8 = [outputCopy insertionText];
    if (v151)
    {
      [inputDelegateManager7 insertText:insertionText8 withEnumeratedAnimationStyle:{objc_msgSend(v151, "integerValue")}];
    }

    else
    {
      [inputDelegateManager7 insertText:insertionText8];
    }

    if (v164)
    {
      inputDelegateManager8 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager8 callShouldDeleteBackwardWithCount:1];
    }

    if (v144)
    {
      self->m_textInputChangesIgnored = 0;
    }

    v155 = _UIKeyboardLog();
    if (os_log_type_enabled(v155, OS_LOG_TYPE_DEFAULT))
    {
      *v171 = 0;
      _os_log_impl(&dword_188A29000, v155, OS_LOG_TYPE_DEFAULT, "Keyboard inserts text", v171, 2u);
    }
  }

LABEL_88:
  shortcutConversion = [outputCopy shortcutConversion];
  if (shortcutConversion)
  {
    v102 = +[UIKeyboard usesInputSystemUI];

    if (!v102)
    {
      shortcutConversion2 = [outputCopy shortcutConversion];
      documentState5 = [(_UIKeyboardStateManager *)self documentState];
      contextBeforeInput3 = [documentState5 contextBeforeInput];

      if ([outputCopy deletionCount])
      {
        if (contextBeforeInput3)
        {
          input = [shortcutConversion2 input];
          v107 = [contextBeforeInput3 hasSuffix:input];

          if ((v107 & 1) == 0)
          {
            insertionText9 = [outputCopy insertionText];
            candidate2 = [shortcutConversion2 candidate];
            v110 = [shortcutConversion2 candidateByReplacingWithCandidate:candidate2 input:insertionText9];

            shortcutConversion2 = v110;
          }
        }
      }

      [(_UIKeyboardStateManager *)self setAutocorrection:shortcutConversion2];
      if ([(_UIKeyboardStateManager *)self hasAutocorrectPrompt])
      {
        inputDelegateManager9 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        asyncCapableInputDelegate2 = [inputDelegateManager9 asyncCapableInputDelegate];
        v113 = asyncCapableInputDelegate2 == 0;

        if (!v113)
        {
          [(_UIKeyboardStateManager *)self removeAutocorrectPrompt];
        }

        shortcutConversion3 = [outputCopy shortcutConversion];
        [(_UIKeyboardStateManager *)self updateAutocorrectPrompt:shortcutConversion3];
      }

      else
      {
        [(_UIKeyboardStateManager *)self touchAutocorrectPromptTimer];
      }
    }
  }

  handwritingStrokesToDelete = [outputCopy handwritingStrokesToDelete];

  if (handwritingStrokesToDelete)
  {
    handwritingStrokesToDelete2 = [outputCopy handwritingStrokesToDelete];
    [(_UIKeyboardStateManager *)self deleteHandwritingStrokesAtIndexes:handwritingStrokesToDelete2];
  }

  customInfo2 = [outputCopy customInfo];

  if (customInfo2)
  {
    customInfo3 = [outputCopy customInfo];
    [(_UIKeyboardStateManager *)self performKeyboardOutputInfo:customInfo3];

    if (bOOLValue2)
    {
      remoteTextInputPartner3 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      if (remoteTextInputPartner3)
      {
        v120 = *(*&buf[8] + 24);

        if ((v120 & 1) == 0)
        {
          v169[0] = MEMORY[0x1E69E9820];
          v169[1] = 3221225472;
          v169[2] = __58___UIKeyboardStateManager_performKeyboardOutput_userInfo___block_invoke_1104;
          v169[3] = &unk_1E70FD608;
          v170 = outputCopy;
          [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v169];
        }
      }
    }
  }

  inlineTextCompletionController2 = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
  [inlineTextCompletionController2 didPerformKeyboardOutput:outputCopy];

  if (+[UIKeyboard usesInputSystemUI])
  {
    textSuggestionDelegate = [(UITextInputTraits *)self->m_traits textSuggestionDelegate];
    v123 = textSuggestionDelegate == 0;

    if (!v123)
    {
      [(_UIKeyboardStateManager *)self delegateSuggestionsForCurrentInput];
    }
  }

  [(_UIKeyboardStateManager *)self _postInputResponderCapabilitiesChangedNotificationWithOutput:outputCopy selectionChanged:0];
  _acquireWaitingOnPerformAutocorrect = [(_UIKeyboardStateManager *)self _acquireWaitingOnPerformAutocorrect];
  v125 = _acquireWaitingOnPerformAutocorrect;
  if (_acquireWaitingOnPerformAutocorrect)
  {
    (*(_acquireWaitingOnPerformAutocorrect + 16))(_acquireWaitingOnPerformAutocorrect, 1);
  }

  if (+[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled])
  {
    if ([outputCopy deletionCount])
    {
      [(_UIKeyboardStateManager *)self removeTextChoicePromptWithUnderline];
      inputDelegateManager10 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      selectedTextRange = [inputDelegateManager10 selectedTextRange];

      if (selectedTextRange)
      {
        _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
        inputDelegateManager11 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        selectedTextRange2 = [inputDelegateManager11 selectedTextRange];
        start = [selectedTextRange2 start];
        [_textChoicesAssistant updateUnderlinesIfNeededAfterPosition:start];
LABEL_118:
      }
    }

    else
    {
      inputDelegateManager12 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      selectedTextRange3 = [inputDelegateManager12 selectedTextRange];

      if (selectedTextRange3)
      {
        _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
        inputDelegateManager11 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        selectedTextRange2 = [inputDelegateManager11 selectedTextRange];
        start = [selectedTextRange2 start];
        [_textChoicesAssistant clearUnderlinesIfNeededBeforePosition:start];
        goto LABEL_118;
      }
    }
  }

  insertionText10 = [outputCopy insertionText];
  if ([insertionText10 length] || objc_msgSend(outputCopy, "deletionCount"))
  {
    v135 = +[UIKeyboard isKeyboardProcess];

    if (v135)
    {
      goto LABEL_127;
    }

    v136 = +[UIEventSessionActionAnalytics sharedInstance];
    insertionText10 = v136;
    if (self->m_textInputSource == 4)
    {
      v137 = 6;
    }

    else
    {
      v137 = 5;
    }

    [v136 didTypingWithSource:v137];
  }

LABEL_127:
  v138 = +[UIKBAnalyticsDispatcher sharedInstance];
  if ([v138 nextCandidateReplacementSource] == 9)
  {

LABEL_130:
    +[UIKBAnalyticsDispatcher didCandidateReplacement];
    goto LABEL_131;
  }

  v139 = +[UIKBAnalyticsDispatcher sharedInstance];
  v140 = [v139 nextCandidateReplacementSource] == 10;

  if (v140)
  {
    goto LABEL_130;
  }

LABEL_131:

  _Block_object_dispose(buf, 8);
  return v166;
}

- (void)generateCandidatesAsynchronously
{
  generatedCandidateCount = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet generatedCandidateCount];
  candidates = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet candidates];
  v5 = [candidates count];

  if (generatedCandidateCount > v5)
  {
    candidates2 = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet candidates];
    -[_UIKeyboardStateManager generateCandidatesAsynchronouslyWithRange:selectedCandidate:](self, "generateCandidatesAsynchronouslyWithRange:selectedCandidate:", [candidates2 count], 0x7FFFFFFFLL, 0);
  }
}

- (void)generateCandidatesAsynchronouslyWithRange:(_NSRange)range selectedCandidate:(id)candidate
{
  length = range.length;
  location = range.location;
  v32[4] = *MEMORY[0x1E69E9840];
  candidateCopy = candidate;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [objc_opt_class() sendPerformanceNotification:@"UIKeyboardPerformanceSearchCandidatesStartNotification"];

  [(_UIKeyboardStateManager *)self cancelCandidateRequests];
  if (self->m_shiftNeedsUpdate)
  {
    self->m_shiftNeedsUpdate = 0;
    [(_UIKeyboardStateManager *)self updateShiftState];
  }

  [(_UIKeyboardStateManager *)self refreshKeyboardState];
  v9 = [(TIKeyboardState *)self->m_keyboardState copy];
  [v9 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
  [v9 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
  v10 = [MEMORY[0x1E69D9580] tokenForKeyboardState:v9];
  [(_UIKeyboardStateManager *)self setCurrentCandidateRequest:v10];
  v31[0] = @"keyboardState";
  null = v9;
  if (!v9)
  {
    null = [MEMORY[0x1E695DFB0] null];
  }

  v32[0] = null;
  v31[1] = @"index";
  v25 = location;
  v12 = [MEMORY[0x1E696AD98] numberWithUnsignedInteger:location];
  v32[1] = v12;
  v31[2] = @"candidateCount";
  v13 = length;
  v14 = [MEMORY[0x1E696AD98] numberWithUnsignedInteger:length];
  v32[2] = v14;
  v31[3] = @"selectedCandidate";
  null2 = candidateCopy;
  if (!candidateCopy)
  {
    null2 = [MEMORY[0x1E695DFB0] null];
  }

  v32[3] = null2;
  v16 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v32 forKeys:v31 count:4];
  [(_UIKeyboardStateManager *)self setCurrentCandidateRequestInfo:v16];

  if (!candidateCopy)
  {
  }

  if (!v9)
  {
  }

  v17 = arc4random();
  kdebug_trace();
  v18 = kac_get_log();
  v19 = os_signpost_id_make_with_pointer(v18, v17);
  if (v19 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v20 = v19;
    if (os_signpost_enabled(v18))
    {
      *buf = 0;
      _os_signpost_emit_with_name_impl(&dword_188A29000, v18, OS_SIGNPOST_INTERVAL_BEGIN, v20, "appCandidates", " enableTelemetry=YES ", buf, 2u);
    }
  }

  v26[0] = MEMORY[0x1E69E9820];
  v26[1] = 3221225472;
  v26[2] = __87___UIKeyboardStateManager_generateCandidatesAsynchronouslyWithRange_selectedCandidate___block_invoke;
  v26[3] = &unk_1E70FD658;
  v26[4] = self;
  v27 = v10;
  v28 = v9;
  v29 = v17;
  v21 = v9;
  v22 = v10;
  v23 = [v26 copy];
  backendController = [(_UIKeyboardStateManager *)self backendController];
  [backendController generateCandidatesWithKeyboardState:v21 candidateRange:v25 requestToken:v13 completionHandler:{v22, v23}];
}

- (void)cancelCandidateRequests
{
  [(_UIKeyboardStateManager *)self setCurrentCandidateRequest:0];
  [(_UIKeyboardStateManager *)self setCurrentCandidateRequestInfo:0];
  delayedCandidateRequest = [(_UIKeyboardStateManager *)self delayedCandidateRequest];
  [delayedCandidateRequest invalidate];

  [(_UIKeyboardStateManager *)self setDelayedCandidateRequest:0];
}

- (BOOL)shouldPrioritizeTextSuggestionsOverCandidateResultSet:(id)set
{
  setCopy = set;
  candidates = [setCopy candidates];
  v6 = [candidates count];
  if (!v6)
  {
    committedText = [setCopy committedText];
    if (![committedText length])
    {
      LOBYTE(v7) = 1;
LABEL_9:

      goto LABEL_10;
    }
  }

  LOBYTE(v7) = [setCopy isDummySet];
  if ((v7 & 1) == 0 && [setCopy hasOnlyCompletionCandidates])
  {
    v7 = [setCopy hasAutofillCandidates] ^ 1;
  }

  if (!v6)
  {
    goto LABEL_9;
  }

LABEL_10:

  return v7;
}

- (int64_t)preferredCandidateViewTypeForCandidateResultSet:(id)set
{
  setCopy = set;
  inputForMarkedText = [(TIKeyboardState *)self->m_keyboardState inputForMarkedText];
  if (![inputForMarkedText length] || (objc_msgSend(setCopy, "hasOnlyCompletionCandidates") & 1) != 0 || (objc_msgSend(setCopy, "hasOnlySlottedCandidates") & 1) != 0)
  {
    hasOnlyProactiveCandidates = 1;
  }

  else
  {
    hasOnlyProactiveCandidates = [setCopy hasOnlyProactiveCandidates];
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  candidateController = [WeakRetained candidateController];
  activeCandidateViewType = [candidateController activeCandidateViewType];

  if (activeCandidateViewType == 4 && (hasOnlyProactiveCandidates & 1) != 0)
  {
    v10 = 0;
  }

  else if ([(_UIKeyboardStateManager *)self canUseCandidateBarAsSupplementToInlineView])
  {
    v11 = objc_loadWeakRetained(&self->_presentationDelegate);
    candidateController2 = [v11 candidateController];
    activeCandidateViewType2 = [candidateController2 activeCandidateViewType];

    v14 = 4;
    if (hasOnlyProactiveCandidates)
    {
      v14 = 2;
    }

    if (activeCandidateViewType2 == 6)
    {
      v10 = v14;
    }

    else
    {
      v10 = -1;
    }
  }

  else
  {
    v10 = -1;
  }

  return v10;
}

- (id)_rangeForSupplementalItemText:(id)text
{
  textCopy = text;
  self->m_textInputChangesIgnored = 1;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  selectedTextRange = [inputDelegateManager selectedTextRange];

  self->m_textInputChangesIgnored = 0;
  if (selectedTextRange)
  {
    if ([textCopy length])
    {
      self->m_textInputChangesIgnored = 1;
      v7 = [textCopy length];
      v8 = [selectedTextRange end];
      v9 = v8;
      if (v8 && v7)
      {
        v10 = 1;
        while (1)
        {
          inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          v12 = [inputDelegateManager2 _rangeOfText:textCopy endingAtPosition:v9];

          if (v12)
          {
            break;
          }

          inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          v14 = [inputDelegateManager3 positionFromPosition:v9 offset:1];

          if (v14)
          {
            v9 = v14;
            if (v10++ < v7)
            {
              continue;
            }
          }

          goto LABEL_14;
        }

        self->m_textInputChangesIgnored = 0;
      }

      else
      {
        v14 = v8;
LABEL_14:
        self->m_textInputChangesIgnored = 0;
        v12 = selectedTextRange;
        v9 = v14;
      }
    }

    else
    {
      v12 = selectedTextRange;
    }
  }

  else
  {
    v12 = 0;
  }

  return v12;
}

- (void)_dispatchInsertionPointEnteredText:(id)text range:(id)range withSupplementalCandidate:(id)candidate
{
  textCopy = text;
  rangeCopy = range;
  candidateCopy = candidate;
  if (+[UIKeyboard isKeyboardProcess])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    v11 = [remoteTextInputPartner textOperation_insertionPointEnteredText:textCopy withSupplementalCandidate:candidateCopy];

    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    v13 = inputSystemSourceSession;
    if (v11 && inputSystemSourceSession)
    {
      customInfoType = [v11 customInfoType];
      textOperations = [v13 textOperations];
      [textOperations setCustomInfoType:customInfoType];

      customInfo = [v11 customInfo];
      textOperations2 = [v13 textOperations];
      [textOperations2 setCustomInfo:customInfo];

      [v13 flushOperations];
    }
  }

  else if (([rangeCopy isEmpty] & 1) == 0)
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    v19 = objc_opt_respondsToSelector();

    if (v19)
    {
      self->m_textInputChangesIgnored = 1;
      inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
      input = [candidateCopy input];
      ui_supplementalItems = [candidateCopy ui_supplementalItems];
      [inputDelegate2 _insertionPointEnteredRange:rangeCopy string:input supplementalItems:ui_supplementalItems];

      self->m_textInputChangesIgnored = 0;
    }
  }
}

- (void)_inputManagerDidGenerateSupplementalCandidates:(id)candidates
{
  candidatesCopy = candidates;
  if (self->m_selecting || self->m_autoDeleteOK || -[_UIKeyboardStateManager continuousPathUnderway](self, "continuousPathUnderway") || ![candidatesCopy count] || self->m_autoDeleteUseForce && !-[_UIKeyboardStateManager usesCandidateSelection](self, "usesCandidateSelection") || (v4 = objc_msgSend(candidatesCopy, "indexOfObjectPassingTest:", &__block_literal_global_1129), v4 == 0x7FFFFFFFFFFFFFFFLL))
  {
    [(_UIKeyboardStateManager *)self _insertionPointExitedRangeWithSupplementalCandidate];
    goto LABEL_9;
  }

  v5 = [candidatesCopy objectAtIndexedSubscript:v4];
  input = [v5 input];
  v7 = [(_UIKeyboardStateManager *)self _rangeForSupplementalItemText:input];

  v8 = [_UIStringAndPositionPair alloc];
  input2 = [v5 input];
  start = [v7 start];
  v11 = [(_UIStringAndPositionPair *)&v8->super.isa initWithString:input2 position:start];

  lastMatchedSupplementalCandidate = [(_UIKeyboardStateManager *)self lastMatchedSupplementalCandidate];
  if (lastMatchedSupplementalCandidate)
  {
  }

  else
  {
    inputWithoutSupplementalItemPrefix = [v5 inputWithoutSupplementalItemPrefix];
    v20 = [inputWithoutSupplementalItemPrefix length];

    if (v20)
    {
      if ([v7 isEmpty])
      {
        goto LABEL_18;
      }

      goto LABEL_17;
    }
  }

  lastMatchedSupplementalCandidate2 = [(_UIKeyboardStateManager *)self lastMatchedSupplementalCandidate];
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  v15 = [(_UIStringAndPositionPair *)lastMatchedSupplementalCandidate2 isEqualToPair:v11 inputDelegate:inputDelegate];

  if (!v15)
  {
    [(_UIKeyboardStateManager *)self _insertionPointExitedRangeWithSupplementalCandidate];
    if ([v7 isEmpty])
    {
      goto LABEL_18;
    }

    inputWithoutSupplementalItemPrefix2 = [v5 inputWithoutSupplementalItemPrefix];
    v17 = [inputWithoutSupplementalItemPrefix2 length];

    if (!v17)
    {
      goto LABEL_18;
    }

LABEL_17:
    input3 = [v5 input];
    [(_UIKeyboardStateManager *)self _dispatchInsertionPointEnteredText:input3 range:v7 withSupplementalCandidate:v5];

LABEL_18:
    [(_UIKeyboardStateManager *)self setLastMatchedSupplementalCandidate:v11];
  }

LABEL_9:
}

- (void)inputManagerDidGenerateCandidateResultSet:(id)set
{
  v30 = *MEMORY[0x1E69E9840];
  setCopy = set;
  if (![(_UIKeyboardStateManager *)self _hasMarkedText])
  {
    ui_uniqueSupplementalCandidates = [setCopy ui_uniqueSupplementalCandidates];
    [(_UIKeyboardStateManager *)self _inputManagerDidGenerateSupplementalCandidates:ui_uniqueSupplementalCandidates];
  }

  acceptedCandidate = [setCopy acceptedCandidate];

  if (acceptedCandidate)
  {
    acceptedCandidate2 = [setCopy acceptedCandidate];
    [(_UIKeyboardStateManager *)self acceptCandidate:acceptedCandidate2];

    [(_UIKeyboardStateManager *)self flushKeyboardOutputOnInputSourceSession];
  }

  if (setCopy)
  {
    if ([(_UIKeyboardStateManager *)self shouldPrioritizeTextSuggestionsOverCandidateResultSet:setCopy])
    {
      if ([(TIKeyboardCandidateResultSet *)self->m_candidateResultSet hasOnlySlottedCandidates])
      {
        goto LABEL_24;
      }

      textSuggestionList = [(UIKeyboardAutocorrectionController *)self->m_autocorrectionController textSuggestionList];
      predictions = [textSuggestionList predictions];
      v10 = [predictions count];

      if (v10)
      {
        v24 = setCopy;
        array = [MEMORY[0x1E695DF70] array];
        v25 = 0u;
        v26 = 0u;
        v27 = 0u;
        v28 = 0u;
        textSuggestionList2 = [(UIKeyboardAutocorrectionController *)self->m_autocorrectionController textSuggestionList];
        predictions2 = [textSuggestionList2 predictions];

        v14 = [predictions2 countByEnumeratingWithState:&v25 objects:v29 count:16];
        if (v14)
        {
          v15 = v14;
          v16 = *v26;
          do
          {
            for (i = 0; i != v15; ++i)
            {
              if (*v26 != v16)
              {
                objc_enumerationMutation(predictions2);
              }

              v18 = *(*(&v25 + 1) + 8 * i);
              if ([v18 customInfoType] == 32)
              {
                textSuggestionList3 = [(UIKeyboardAutocorrectionController *)self->m_autocorrectionController textSuggestionList];
                predictions3 = [textSuggestionList3 predictions];
                v21 = [predictions3 count];

                if (v21 > 1)
                {
                  continue;
                }
              }

              [array addObject:v18];
            }

            v15 = [predictions2 countByEnumeratingWithState:&v25 objects:v29 count:16];
          }

          while (v15);
        }

        setCopy = [MEMORY[0x1E69D95E8] setWithCandidates:array];
      }
    }

    [(_UIKeyboardStateManager *)self updateCandidateDisplayAsyncWithCandidateSet:setCopy];
  }

  currentCandidateRequestInfo = [(_UIKeyboardStateManager *)self currentCandidateRequestInfo];
  v23 = [currentCandidateRequestInfo objectForKey:@"selectedCandidate"];

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [(UIKeyboardCandidateList *)self->m_candidateList showCandidate:v23];
  }

LABEL_24:
}

- (void)generateAutocorrectionWithExecutionContext:(id)context
{
  contextCopy = context;
  v5 = sharedInputManagerMux();
  if (![v5 hasSystemInputManager] || !+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") && self->m_disableSyncTextChanged || +[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI") || (-[_UIKeyboardStateManager inputDelegate](self, "inputDelegate"), v6 = objc_claimAutoreleasedReturnValue(), v7 = -[_UIKeyboardStateManager suppressOptOutASPCandidateUpdateForDelegate:](self, "suppressOptOutASPCandidateUpdateForDelegate:", v6), v6, v7))
  {
    [contextCopy returnExecutionToParent];
  }

  else
  {
    v8[0] = MEMORY[0x1E69E9820];
    v8[1] = 3221225472;
    v8[2] = __70___UIKeyboardStateManager_generateAutocorrectionWithExecutionContext___block_invoke;
    v8[3] = &unk_1E70FD6A0;
    v9 = contextCopy;
    selfCopy = self;
    [(_UIKeyboardStateManager *)self generateAutocorrectionsWithCompletionHandler:v8];
  }
}

- (void)generateAutocorrectionsWithCompletionHandler:(id)handler
{
  handlerCopy = handler;
  shouldAccessInputManagerService = [(_UIKeyboardStateManager *)self shouldAccessInputManagerService];
  if (handlerCopy && !shouldAccessInputManagerService)
  {
    handlerCopy[2](handlerCopy, 0);
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [objc_opt_class() sendPerformanceNotification:@"UIKeyboardPerformanceSearchCandidatesStartNotification"];

  [(_UIKeyboardStateManager *)self refreshKeyboardState];
  v7 = [(TIKeyboardState *)self->m_keyboardState copy];
  [v7 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
  [v7 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
  v11 = [handlerCopy copy];

  v8 = [MEMORY[0x1E69D9580] tokenForKeyboardState:v7];
  [(_UIKeyboardStateManager *)self setCurrentCandidateRequest:v8];
  backendController = [(_UIKeyboardStateManager *)self backendController];
  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  [backendController generateAutocorrectionsWithKeyboardState:v7 candidateRange:0 requestToken:objc_msgSend(autocorrectionController completionHandler:{"maximumNumberOfCandidates"), v8, v11}];
}

- (BOOL)shouldAcceptContinuousPathConversion:(id)conversion
{
  conversionCopy = conversion;
  if ([conversionCopy isContinuousPathConversion])
  {
    shouldAccept = [conversionCopy shouldAccept];
  }

  else
  {
    shouldAccept = 0;
  }

  return shouldAccept;
}

- (void)_dispatchInsertionPointExitedRangeWithSupplementalCandidate
{
  if (+[UIKeyboard isKeyboardProcess])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    textOperation_insertionPointExitedTextWithSupplementalItems = [remoteTextInputPartner textOperation_insertionPointExitedTextWithSupplementalItems];

    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    if (textOperation_insertionPointExitedTextWithSupplementalItems && inputSystemSourceSession)
    {
      customInfoType = [textOperation_insertionPointExitedTextWithSupplementalItems customInfoType];
      textOperations = [inputSystemSourceSession textOperations];
      [textOperations setCustomInfoType:customInfoType];

      customInfo = [textOperation_insertionPointExitedTextWithSupplementalItems customInfo];
      textOperations2 = [inputSystemSourceSession textOperations];
      [textOperations2 setCustomInfo:customInfo];

      [inputSystemSourceSession flushOperations];
    }
  }

  else
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    v10 = objc_opt_respondsToSelector();

    if (v10)
    {
      self->m_textInputChangesIgnored = 1;
      inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegate2 _insertionPointExitedRangeWithSupplementalItems];

      self->m_textInputChangesIgnored = 0;
    }
  }
}

- (void)inputManagerDidGenerateAutocorrections:(id)autocorrections forPredictiveInput:(id)input executionContext:(id)context
{
  v101 = *MEMORY[0x1E69E9840];
  autocorrectionsCopy = autocorrections;
  inputCopy = input;
  contextCopy = context;
  ui_allSupplementalCandidates = [autocorrectionsCopy ui_allSupplementalCandidates];
  [(_UIKeyboardStateManager *)self _inputManagerDidGenerateSupplementalCandidates:ui_allSupplementalCandidates];

  if ((_os_feature_enabled_impl() & 1) == 0)
  {
    candidates = [autocorrectionsCopy candidates];
    firstObject = [candidates firstObject];
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();

    if (isKindOfClass)
    {
      candidates2 = [autocorrectionsCopy candidates];
      firstObject2 = [candidates2 firstObject];

      if (objc_opt_respondsToSelector())
      {
        if (([firstObject2 candidateProperty] & 0x20) != 0)
        {
          if (os_variant_has_internal_diagnostics())
          {
            v80 = __UIFaultDebugAssertLog();
            if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
            {
              *buf = 0;
              _os_log_fault_impl(&dword_188A29000, v80, OS_LOG_TYPE_FAULT, "The enum for the LongFormReply candidateProperty has changed. Please update to latest TextInputUI and TextInput", buf, 2u);
            }
          }

          else
          {
            v79 = *(__UILogGetCategoryCachedImpl("Assert", &inputManagerDidGenerateAutocorrections_forPredictiveInput_executionContext____s_category) + 8);
            if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
            {
              *buf = 0;
              _os_log_impl(&dword_188A29000, v79, OS_LOG_TYPE_ERROR, "The enum for the LongFormReply candidateProperty has changed. Please update to latest TextInputUI and TextInput", buf, 2u);
            }
          }
        }

        if (([firstObject2 candidateProperty] & 0x40) != 0)
        {
          v55 = _UIKeyboardSmartReplyLog();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            *buf = 0;
            _os_log_impl(&dword_188A29000, v55, OS_LOG_TYPE_DEFAULT, "Received long form reply, accepting immediately", buf, 2u);
          }

          v94[0] = MEMORY[0x1E69E9820];
          v94[1] = 3221225472;
          v94[2] = __102___UIKeyboardStateManager_inputManagerDidGenerateAutocorrections_forPredictiveInput_executionContext___block_invoke;
          v94[3] = &unk_1E70FD1B8;
          v95 = firstObject2;
          selfCopy = self;
          autocorrection5 = firstObject2;
          v57 = [contextCopy childWithContinuation:v94];
          [(_UIKeyboardStateManager *)self acceptPredictiveInput:autocorrection5 appendSeparator:0 executionContext:v57];

LABEL_72:
          goto LABEL_73;
        }
      }
    }
  }

  emojiList = [autocorrectionsCopy emojiList];
  if (emojiList)
  {
  }

  else
  {
    predictions = [autocorrectionsCopy predictions];

    if (!predictions)
    {
      v20 = 0;
      v21 = 0;
      goto LABEL_14;
    }
  }

  corrections = [autocorrectionsCopy corrections];
  autocorrection = [corrections autocorrection];
  if (autocorrection || ([autocorrectionsCopy containsAutofillCandidates] & 1) != 0)
  {
    v20 = 0;
  }

  else
  {
    v20 = [autocorrectionsCopy containsProactiveTriggers] ^ 1;
  }

  v21 = 1;
LABEL_14:
  [autocorrectionsCopy updateLabelsWithSmartPunctuation:self->m_smartPunctuationController];
  corrections2 = [autocorrectionsCopy corrections];
  autocorrection2 = [corrections2 autocorrection];
  if (([autocorrection2 isContinuousPathConversion] & 1) == 0)
  {

LABEL_18:
    [(_UIKeyboardStateManager *)self setAutocorrectionToAcceptBeforeProgressiveCandidates:0];
    corrections3 = [autocorrectionsCopy corrections];
    autocorrection3 = [corrections3 autocorrection];
    v32 = [(_UIKeyboardStateManager *)self shouldAcceptContinuousPathConversion:autocorrection3];

    if (v32)
    {
      corrections4 = [autocorrectionsCopy corrections];
      autocorrection4 = [corrections4 autocorrection];
      v89[0] = MEMORY[0x1E69E9820];
      v89[1] = 3221225472;
      v89[2] = __102___UIKeyboardStateManager_inputManagerDidGenerateAutocorrections_forPredictiveInput_executionContext___block_invoke_4;
      v89[3] = &unk_1E70FD1B8;
      v90 = autocorrectionsCopy;
      selfCopy2 = self;
      v35 = [contextCopy childWithContinuation:v89];
      [(_UIKeyboardStateManager *)self acceptPredictiveInput:autocorrection4 executionContext:v35];

      v29 = v90;
      goto LABEL_20;
    }

    proactiveSuggestionsEmpty = [autocorrectionsCopy proactiveSuggestionsEmpty];
    if (v20 && ([inputCopy isContinuousPathConversion] & 1) == 0 && !-[_UIKeyboardStateManager _shouldLoadPredictionsBasedOnCurrentTraits](self, "_shouldLoadPredictionsBasedOnCurrentTraits") && -[_UIKeyboardStateManager autocorrectionPreferenceForTraits](self, "autocorrectionPreferenceForTraits") == 2)
    {
      selfCopy4 = self;
      v38 = 0;
LABEL_36:
      [(_UIKeyboardStateManager *)selfCopy4 setAutocorrectionList:v38];
LABEL_54:
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      candidates3 = [autocorrectionsCopy candidates];
      v63 = [candidates3 countByEnumeratingWithState:&v83 objects:v100 count:16];
      if (v63)
      {
        v64 = *v84;
        while (2)
        {
          for (i = 0; i != v63; ++i)
          {
            if (*v84 != v64)
            {
              objc_enumerationMutation(candidates3);
            }

            if ([*(*(&v83 + 1) + 8 * i) slotID])
            {
              v63 = 1;
              goto LABEL_64;
            }
          }

          v63 = [candidates3 countByEnumeratingWithState:&v83 objects:v100 count:16];
          if (v63)
          {
            continue;
          }

          break;
        }
      }

LABEL_64:

      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      v67 = objc_opt_class();
      v98 = @"UIKeyboardPerformanceSearchFoundProactiveResults";
      v68 = [MEMORY[0x1E696AD98] numberWithBool:v63];
      v99 = v68;
      v69 = [MEMORY[0x1E695DF20] dictionaryWithObjects:&v99 forKeys:&v98 count:1];
      [v67 sendPerformanceNotification:@"UIKeyboardPerformanceSearchCandidatesEndNotification" userInfo:v69];

      autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
      if ([autocorrectionController hasAutocorrection])
      {
        autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
        autocorrection5 = [autocorrectionController2 autocorrection];
      }

      else
      {
        autocorrection5 = 0;
      }

      if ([(_UIKeyboardStateManager *)self hasAutocorrectPrompt])
      {
        v82[0] = MEMORY[0x1E69E9820];
        v82[1] = 3221225472;
        v82[2] = __102___UIKeyboardStateManager_inputManagerDidGenerateAutocorrections_forPredictiveInput_executionContext___block_invoke_6;
        v82[3] = &unk_1E70FD058;
        v82[4] = self;
        v72 = [contextCopy childWithContinuation:v82];
        [(_UIKeyboardStateManager *)self updateAutocorrectPrompt:autocorrection5 executionContext:v72];
      }

      else
      {
        [(_UIKeyboardStateManager *)self touchAutocorrectPromptTimer];
        candidates4 = [autocorrectionsCopy candidates];
        -[_UIKeyboardStateManager _conditionallyNotifyPredictionsAreAvailableForCandidates:containingProactiveTriggers:](self, "_conditionallyNotifyPredictionsAreAvailableForCandidates:containingProactiveTriggers:", candidates4, [autocorrectionsCopy containsProactiveTriggers]);

        inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];

        if (inlineTextCompletionController)
        {
          inlineTextCompletionController2 = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
          [inlineTextCompletionController2 updateTextCompletionPromptExecutionContext:contextCopy];
        }

        else
        {
          [contextCopy returnExecutionToParent];
        }
      }

      goto LABEL_72;
    }

    if ((v21 & 1) != 0 || ([autocorrectionsCopy corrections], v39 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v39, "autocorrection"), v40 = objc_claimAutoreleasedReturnValue(), v41 = objc_msgSend(v40, "isContinuousPathConversion"), v40, v39, v41))
    {
      if (![autocorrectionsCopy containsProactiveTriggers])
      {
        selfCopy4 = self;
        v38 = autocorrectionsCopy;
        goto LABEL_36;
      }

      v42 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
      [(_UIKeyboardStateManager *)self setAutocorrectionList:autocorrectionsCopy];
      autocorrectionController3 = [(_UIKeyboardStateManager *)self autocorrectionController];
      [autocorrectionController3 setAutocorrectionList:autocorrectionsCopy];

      systemInputAssistantViewController = [v42 systemInputAssistantViewController];
      if ([systemInputAssistantViewController isInputAssistantItemEmpty])
      {
        systemInputAssistantViewController2 = [v42 systemInputAssistantViewController];
        view = [systemInputAssistantViewController2 view];
        window = [view window];
        _isRemoteKeyboardWindow = [window _isRemoteKeyboardWindow];

        if ((_isRemoteKeyboardWindow & 1) == 0)
        {
          containerRootController = [v42 containerRootController];
          isTransitioning = [containerRootController isTransitioning];

          if (isTransitioning)
          {
            containerRootController2 = [v42 containerRootController];
            v87[0] = MEMORY[0x1E69E9820];
            v87[1] = 3221225472;
            v87[2] = __102___UIKeyboardStateManager_inputManagerDidGenerateAutocorrections_forPredictiveInput_executionContext___block_invoke_5;
            v87[3] = &unk_1E70F3590;
            v88 = v42;
            [containerRootController2 addPendingActivity:v87];
          }

          else
          {
            [v42 forceReloadInputViews];
          }

          goto LABEL_53;
        }
      }

      else
      {
      }

      [(_UIKeyboardStateManager *)self updateAssistantView];
LABEL_53:

      goto LABEL_54;
    }

    autocorrectionController4 = [(_UIKeyboardStateManager *)self autocorrectionController];
    v42 = autocorrectionController4;
    if (!proactiveSuggestionsEmpty)
    {
      [autocorrectionController4 setAutocorrectionList:autocorrectionsCopy];
      goto LABEL_53;
    }

    if ([autocorrectionController4 hasAutocorrection])
    {
      autocorrectionController5 = [(_UIKeyboardStateManager *)self autocorrectionController];
      autocorrection6 = [autocorrectionController5 autocorrection];
      if (autocorrection6)
      {

LABEL_52:
        goto LABEL_53;
      }

      autocorrectionController6 = [(_UIKeyboardStateManager *)self autocorrectionController];
      autocorrectionList = [autocorrectionController6 autocorrectionList];
      emojiList2 = [autocorrectionList emojiList];
      if (emojiList2)
      {

        goto LABEL_52;
      }

      autocorrectionController7 = [(_UIKeyboardStateManager *)self autocorrectionController];
      autocorrectionList2 = [autocorrectionController7 autocorrectionList];
      predictions2 = [autocorrectionList2 predictions];

      if (predictions2)
      {
        goto LABEL_54;
      }
    }

    else
    {
    }

    autocorrectionController8 = [(_UIKeyboardStateManager *)self autocorrectionController];
    [autocorrectionController8 clearAutocorrectionAndNotifyObservers:1];

    [(_UIKeyboardStateManager *)self updateAssistantView];
    goto LABEL_54;
  }

  autocorrectionToAcceptBeforeProgressiveCandidates = [(_UIKeyboardStateManager *)self autocorrectionToAcceptBeforeProgressiveCandidates];
  input = [autocorrectionToAcceptBeforeProgressiveCandidates input];
  v26 = [input length];

  if (!v26)
  {
    goto LABEL_18;
  }

  [(_UIKeyboardStateManager *)self acceptingCandidateWithTrigger:*MEMORY[0x1E69D9718]];
  autocorrectionToAcceptBeforeProgressiveCandidates2 = [(_UIKeyboardStateManager *)self autocorrectionToAcceptBeforeProgressiveCandidates];
  v92[0] = MEMORY[0x1E69E9820];
  v92[1] = 3221225472;
  v92[2] = __102___UIKeyboardStateManager_inputManagerDidGenerateAutocorrections_forPredictiveInput_executionContext___block_invoke_3;
  v92[3] = &unk_1E70FD1B8;
  v92[4] = self;
  v93 = autocorrectionsCopy;
  v28 = [contextCopy childWithContinuation:v92];
  [(_UIKeyboardStateManager *)self acceptPredictiveInput:autocorrectionToAcceptBeforeProgressiveCandidates2 executionContext:v28];

  v29 = v93;
LABEL_20:

LABEL_73:
}

- (BOOL)_insertSupplementalCandidate:(id)candidate overridingCandidateText:(id)text
{
  candidateCopy = candidate;
  textCopy = text;
  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = __80___UIKeyboardStateManager__insertSupplementalCandidate_overridingCandidateText___block_invoke;
  aBlock[3] = &unk_1E70FD6C8;
  aBlock[4] = self;
  v8 = _Block_copy(aBlock);
  ui_supplementalItems = [candidateCopy ui_supplementalItems];
  v10 = [ui_supplementalItems objectAtIndexedSubscript:0];

  if (textCopy)
  {
    v11 = [(_UIKeyboardStateManager *)self _rangeForSupplementalItemText:textCopy];
  }

  else
  {
    input = [candidateCopy input];
    v11 = [(_UIKeyboardStateManager *)self _rangeForSupplementalItemText:input];
  }

  v13 = ([v11 isEmpty] & 1) == 0 && (v8[2](v8, v10, candidateCopy, v11) & 1) != 0;

  return v13;
}

- (void)_willReplaceText:(id)text withSupplementalCandidate:(id)candidate
{
  textCopy = text;
  _hasMarkedText = [(_UIKeyboardStateManager *)self _hasMarkedText];
  v6 = textCopy;
  if (!_hasMarkedText)
  {
    v7 = [(_UIKeyboardStateManager *)self _rangeForSupplementalItemText:textCopy];
    if (v7)
    {
      self->m_textInputChangesIgnored = 1;
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v9 = [v7 end];
      [inputDelegateManager _setSelectionToPosition:v9];

      [(_UIKeyboardStateManager *)self updateForChangedSelection];
      [textCopy rangeOfComposedCharacterSequencesForRange:{0, objc_msgSend(textCopy, "length")}];
      if (v10)
      {
        v11 = v10;
        do
        {
          --v11;
          [(_UIKeyboardStateManager *)self deleteBackwardAndNotify:0];
        }

        while (v11);
      }

      self->m_textInputChangesIgnored = 0;
    }

    v6 = textCopy;
  }
}

- (void)_didReplaceText:(id)text withSupplementalCandidate:(id)candidate
{
  textCopy = text;
  candidateCopy = candidate;
  input = [candidateCopy input];
  if ([input length])
  {
    input2 = [candidateCopy input];
    v9 = [input2 characterAtIndex:0];
    v10 = v9 == [candidateCopy supplementalItemPrefix];
  }

  else
  {
    v10 = 0;
  }

  if ([candidateCopy supplementalItemPrefix] && !v10)
  {
    v11 = [(_UIKeyboardStateManager *)self _rangeForSupplementalItemText:textCopy];
    if (v11)
    {
      self->m_textInputChangesIgnored = 0;
    }
  }
}

- (void)_acceptAutofillCandidateRequiringAuthentication:(id)authentication payloadDelegate:(id)delegate executionContext:(id)context
{
  authenticationCopy = authentication;
  delegateCopy = delegate;
  contextCopy = context;
  v11 = _UIKeyboardImplLog();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0]) = 0;
    _os_log_impl(&dword_188A29000, v11, OS_LOG_TYPE_DEFAULT, "Accepting autofill candidate requiring authentication", buf, 2u);
  }

  v12 = [(TIKeyboardState *)self->m_keyboardState copy];
  [v12 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
  [v12 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
  objc_initWeak(buf, delegateCopy);
  inputManager = [(_UIKeyboardStateManager *)self inputManager];
  v14 = MEMORY[0x1E69E9820];
  v15 = 3221225472;
  v16 = __108___UIKeyboardStateManager__acceptAutofillCandidateRequiringAuthentication_payloadDelegate_executionContext___block_invoke;
  v17 = &unk_1E70FD718;
  selfCopy = self;
  objc_copyWeak(&v19, buf);
  [inputManager handleAcceptedCandidate:authenticationCopy keyboardState:v12 completionHandler:&v14];

  [contextCopy returnExecutionToParent];
  objc_destroyWeak(&v19);
  objc_destroyWeak(buf);
}

- (void)handleAcceptedCandidate:(id)candidate executionContext:(id)context
{
  candidateCopy = candidate;
  contextCopy = context;
  [(_UIKeyboardStateManager *)self refreshKeyboardState];
  if (+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") && (v8 = [candidateCopy slotID], v9 = objc_msgSend(candidateCopy, "customInfoType"), v8) && self->m_cachedAutofillMode == 1 && v9 && (-[_UIKeyboardStateManager remoteTextInputPartner](self, "remoteTextInputPartner"), v10 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v10, "autofillPayloadDelegate"), v11 = objc_claimAutoreleasedReturnValue(), v10, v11))
  {
    [(_UIKeyboardStateManager *)self _acceptAutofillCandidateRequiringAuthentication:candidateCopy payloadDelegate:v11 executionContext:contextCopy];
  }

  else
  {
    v11 = [(TIKeyboardState *)self->m_keyboardState copy];
    [v11 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
    [v11 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
    v15[0] = MEMORY[0x1E69E9820];
    v15[1] = 3221225472;
    v15[2] = __68___UIKeyboardStateManager_handleAcceptedCandidate_executionContext___block_invoke;
    v15[3] = &unk_1E70FD740;
    v16 = contextCopy;
    v12 = candidateCopy;
    v17 = v12;
    selfCopy = self;
    v13 = [v15 copy];
    backendController = [(_UIKeyboardStateManager *)self backendController];
    [backendController handleAcceptedCandidate:v12 keyboardState:v11 completionHandler:v13];
  }
}

- (void)generateReplacementsForString:(id)string candidatesHandler:(id)handler executionContext:(id)context
{
  handlerCopy = handler;
  contextCopy = context;
  v16 = MEMORY[0x1E69E9820];
  v17 = 3221225472;
  v18 = __92___UIKeyboardStateManager_generateReplacementsForString_candidatesHandler_executionContext___block_invoke;
  v19 = &unk_1E70FD790;
  v20 = contextCopy;
  v21 = handlerCopy;
  v10 = handlerCopy;
  v11 = contextCopy;
  stringCopy = string;
  v13 = [&v16 copy];
  v14 = [(_UIKeyboardStateManager *)self inputManager:v16];
  keyLayout = [(TIKeyboardState *)self->m_keyboardState keyLayout];
  [v14 generateReplacementsForString:stringCopy keyLayout:keyLayout continuation:v13];
}

- (void)skipHitTestForTouchEvent:(id)event
{
  v8 = *MEMORY[0x1E69E9840];
  if (event)
  {
    eventCopy = event;
    v4 = MEMORY[0x1E695DEC8];
    eventCopy2 = event;
    v6 = [v4 arrayWithObjects:&eventCopy count:1];

    [(_UIKeyboardStateManager *)self skipHitTestForTouchEvents:v6, eventCopy, v8];
  }
}

- (void)skipHitTestForTouchEvents:(id)events
{
  eventsCopy = events;
  if ([eventsCopy count])
  {
    if ([eventsCopy indexOfObjectPassingTest:&__block_literal_global_1170] != 0x7FFFFFFFFFFFFFFFLL)
    {
      [(_UIKeyboardStateManager *)self refreshKeyboardStateUpdatingSecureCandidateRenderTraits:0];
    }

    v4 = [(TIKeyboardState *)self->m_keyboardState copy];
    [v4 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
    [v4 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
    backendController = [(_UIKeyboardStateManager *)self backendController];
    [backendController skipHitTestForTouchEvents:eventsCopy keyboardState:v4];
  }
}

- (void)skipHitTestForTouchEvent:(id)event delayed:(BOOL)delayed
{
  if (delayed)
  {
    [(_UIKeyboardStateManager *)self setTouchEventWaitingForKeyInputEvent:event];
  }

  else
  {
    [(_UIKeyboardStateManager *)self skipHitTestForTouchEvent:event];
  }
}

- (void)performHitTestForTouchEvent:(id)event executionContextPassingNSNumber:(id)number
{
  v11 = *MEMORY[0x1E69E9840];
  eventCopy = event;
  v6 = MEMORY[0x1E695DEC8];
  numberCopy = number;
  eventCopy2 = event;
  v9 = [v6 arrayWithObjects:&eventCopy count:1];

  [(_UIKeyboardStateManager *)self performHitTestForTouchEvents:v9 executionContextPassingNSNumber:numberCopy, eventCopy, v11];
}

- (void)performHitTestForTouchEvents:(id)events executionContextPassingNSNumber:(id)number
{
  numberCopy = number;
  eventsCopy = events;
  if (![(_UIKeyboardStateManager *)self shouldAccessInputManagerService])
  {
    [numberCopy returnExecutionToParent];
  }

  [(_UIKeyboardStateManager *)self refreshKeyboardStateUpdatingSecureCandidateRenderTraits:0];
  v8 = [(TIKeyboardState *)self->m_keyboardState copy];
  [v8 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
  [v8 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
  v12[0] = MEMORY[0x1E69E9820];
  v12[1] = 3221225472;
  v12[2] = __88___UIKeyboardStateManager_performHitTestForTouchEvents_executionContextPassingNSNumber___block_invoke;
  v12[3] = &unk_1E70F5DB8;
  v13 = numberCopy;
  v9 = numberCopy;
  v10 = [v12 copy];
  backendController = [(_UIKeyboardStateManager *)self backendController];
  [backendController performHitTestForTouchEvents:eventsCopy keyboardState:v8 completionHandler:v10];
}

- (void)adjustPhraseBoundaryInForwardDirection:(BOOL)direction granularity:(int)granularity executionContext:(id)context
{
  v5 = *&granularity;
  directionCopy = direction;
  contextCopy = context;
  [(_UIKeyboardStateManager *)self refreshKeyboardState];
  v9 = [(TIKeyboardState *)self->m_keyboardState copy];
  [v9 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
  [v9 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
  v13 = MEMORY[0x1E69E9820];
  v14 = 3221225472;
  v15 = __95___UIKeyboardStateManager_adjustPhraseBoundaryInForwardDirection_granularity_executionContext___block_invoke;
  v16 = &unk_1E70FD4D0;
  v17 = contextCopy;
  selfCopy = self;
  v10 = contextCopy;
  v11 = [&v13 copy];
  v12 = [(_UIKeyboardStateManager *)self inputManager:v13];
  [v12 adjustPhraseBoundaryInForwardDirection:directionCopy granularity:v5 keyboardState:v9 completionHandler:v11];
}

- (void)removeAllDynamicDictionaries
{
  v2 = [objc_alloc(MEMORY[0x1E696B0B8]) initWithMachServiceName:@"com.apple.TextInput.rdt" options:4096];
  v3 = [MEMORY[0x1E696B0D0] interfaceWithProtocol:&unk_1F016C4C0];
  [v2 setRemoteObjectInterface:v3];

  [v2 resume];
  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = __55___UIKeyboardStateManager_removeAllDynamicDictionaries__block_invoke;
  aBlock[3] = &unk_1E70FD7F8;
  v8 = v2;
  v4 = v2;
  v5 = _Block_copy(aBlock);
  v6 = [v4 remoteObjectProxyWithErrorHandler:v5];
  [v6 removeAllDynamicDictionariesWithCompletionHandler:v5];
}

- (void)releaseInputManager
{
  m_inputManagerState = self->m_inputManagerState;
  self->m_inputManagerState = 0;

  [(_UIKeyboardImplProxy *)self->m_implProxy setDelegate:0];
  v4 = sharedInputManagerMux();
  [v4 releaseConnectedClients];
  [(_UISmartReplyFeedbackManager *)self->_smartReplyFeedbackManager resetWithDebug:@"releaseInputManager"];
}

- (BOOL)switchMode:(id)mode withHUD:(BOOL)d withDelay:(BOOL)delay fromCapsLock:(BOOL)lock
{
  lockCopy = lock;
  dCopy = d;
  modeCopy = mode;
  [(_UIKeyboardStateManager *)self showCursorAccessory];
  v10 = +[UIInputSwitcher sharedInstance];
  LOBYTE(lockCopy) = [v10 switchMode:modeCopy withHUD:dCopy withDelay:dCopy fromCapsLock:lockCopy];

  return lockCopy;
}

- (BOOL)shouldSwitchInputMode:(id)mode
{
  modeCopy = mode;
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  delegateNeedsAutofillMode = [autofillController delegateNeedsAutofillMode];

  keyboardType = [(UITextInputTraits *)self->m_traits keyboardType];
  v8 = keyboardType == 1;
  v9 = +[UIKeyboard keyboardBundleIdentifier];
  if ([v9 isEqualToString:@"com.apple.purplebuddy"])
  {
    v10 = [UITextInputTraits keyboardTypeRequiresASCIICapable:[(UITextInputTraits *)self->m_traits keyboardType]];
    v8 = keyboardType == 1 || v10;
  }

  v11 = [modeCopy isDesiredForTraits:self->m_traits withExtended:0];
  LOBYTE(v12) = v11 ^ 1;
  if ((v11 & 1) == 0 && !v8)
  {
    v12 = (delegateNeedsAutofillMode < 5) & (0x16u >> delegateNeedsAutofillMode) | [(UITextInputTraits *)self->m_traits isCarPlayIdiom];
  }

  return v12;
}

- (id)desirableInputModesWithExtensions:(BOOL)extensions
{
  extensionsCopy = extensions;
  v56[1] = *MEMORY[0x1E69E9840];
  if ([(UITextInputTraits *)self->m_traits keyboardType]== 124)
  {
    v5 = [UIKeyboardInputMode keyboardInputModeWithIdentifier:@"emoji@sw=Emoji"];
    v56[0] = v5;
    v6 = [MEMORY[0x1E695DEC8] arrayWithObjects:v56 count:1];
  }

  else
  {
    v7 = +[UIKeyboardInputModeController sharedInputModeController];
    if ([(UITextInputTraits *)self->m_traits isSecureTextEntry]|| [(UITextInputTraits *)self->m_traits keyboardType]== 7 || [(UITextInputTraits *)self->m_traits keyboardType]== 3)
    {
      v8 = [(UITextInputTraits *)self->m_traits copy];
      [v8 setKeyboardType:1];
    }

    else
    {
      v8 = 0;
    }

    if ([(UITextInputTraits *)self->m_traits loadKeyboardsForSiriLanguage])
    {
      [v7 loadSuggestedInputModesForSiriLanguage];
    }

    array = [MEMORY[0x1E695DF70] array];
    array2 = [MEMORY[0x1E695DF70] array];
    self->m_needsToRecomputeDesirableModes = 0;
    if (extensionsCopy)
    {
      textContentType = [(UITextInputTraits *)self->m_traits textContentType];
      v12 = [textContentType isEqualToString:@"cc-number"];
    }

    else
    {
      v12 = 1;
    }

    v40 = v7;
    activeInputModes = [v7 activeInputModes];
    v49[0] = MEMORY[0x1E69E9820];
    v49[1] = 3221225472;
    v49[2] = __61___UIKeyboardStateManager_desirableInputModesWithExtensions___block_invoke;
    v49[3] = &unk_1E70FD820;
    v53 = v12;
    v49[4] = self;
    v14 = v8;
    v50 = v14;
    v15 = array;
    v51 = v15;
    v16 = array2;
    v52 = v16;
    [activeInputModes enumerateObjectsUsingBlock:v49];

    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v17 = v15;
    v18 = [v17 countByEnumeratingWithState:&v45 objects:v55 count:16];
    if (v18)
    {
      v19 = v18;
      v38 = v16;
      v20 = *v46;
      while (2)
      {
        for (i = 0; i != v19; ++i)
        {
          if (*v46 != v20)
          {
            objc_enumerationMutation(v17);
          }

          v22 = *(*(&v45 + 1) + 8 * i);
          identifier = [v22 identifier];
          v24 = [identifier hasPrefix:@"emoji"];

          if (v24 & 1) == 0 && ([v22 isDesiredForTraits:self->m_traits])
          {
            v39 = 1;
            goto LABEL_23;
          }
        }

        v19 = [v17 countByEnumeratingWithState:&v45 objects:v55 count:16];
        if (v19)
        {
          continue;
        }

        break;
      }

      v39 = 0;
LABEL_23:
      v16 = v38;
    }

    else
    {
      v39 = 0;
    }

    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v25 = v16;
    v26 = [v25 countByEnumeratingWithState:&v41 objects:v54 count:16];
    if (v26)
    {
      v27 = v26;
      v28 = 0;
      v29 = *v42;
      do
      {
        for (j = 0; j != v27; ++j)
        {
          if (*v42 != v29)
          {
            objc_enumerationMutation(v25);
          }

          v31 = *(*(&v41 + 1) + 8 * j);
          v32 = [v31 isDesiredForTraits:v14];
          if (([v17 containsObject:v31] & 1) == 0)
          {
            [v17 addObject:v31];
          }

          v28 |= v32;
        }

        v27 = [v25 countByEnumeratingWithState:&v41 objects:v54 count:16];
      }

      while (v27);
    }

    else
    {
      v28 = 0;
    }

    if ((v39 & ((v14 == 0) | v28) & 1) == 0)
    {
      v33 = +[UIKeyboardInputMode intlInputMode];
      [v17 addObject:v33];
    }

    v5 = v40;
    if ([(_UIKeyboardStateManager *)self shouldLoadAutofillSignUpInputViewController])
    {
      v34 = +[UIKeyboardInputMode autofillSignupInputMode];
      [v17 addObject:v34];
    }

    keyboardType = [(UITextInputTraits *)self->m_traits keyboardType];
    if (keyboardType <= 0xB && ((1 << keyboardType) & 0x930) != 0 || keyboardType == 127)
    {
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      v6 = [objc_opt_class() uniqueNumberPadInputModesFromInputModes:v17 forKeyboardType:{-[UITextInputTraits keyboardType](self->m_traits, "keyboardType")}];
    }

    else
    {
      v6 = v17;
    }
  }

  return v6;
}

- (void)recomputeActiveInputModesWithExtensions:(BOOL)extensions
{
  extensionsCopy = extensions;
  acceptsInitialEmojiKeyboard = [(UITextInputTraits *)self->m_traits acceptsInitialEmojiKeyboard];

  [(_UIKeyboardStateManager *)self recomputeActiveInputModesWithExtensions:extensionsCopy allowNonLinguisticInputModes:acceptsInitialEmojiKeyboard];
}

- (void)recomputeActiveInputModesWithExtensions:(BOOL)extensions allowNonLinguisticInputModes:(BOOL)modes
{
  modesCopy = modes;
  extensionsCopy = extensions;
  v102 = *MEMORY[0x1E69E9840];
  if (![(_UIKeyboardStateManager *)self skipRecomputeInputMode])
  {
    v7 = +[UIKeyboardSceneDelegate automaticKeyboardArbiterClient];
    handlingRemoteEvent = [v7 handlingRemoteEvent];

    if ((handlingRemoteEvent & 1) == 0)
    {
      v9 = +[UIKeyboardInputModeController sharedInputModeController];
      v10 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
      isInOnenessSceneAndRTIEnabled = [v10 isInOnenessSceneAndRTIEnabled];

      if (isInOnenessSceneAndRTIEnabled)
      {
        [v9 setInputModeByMacOSInputSource];
LABEL_79:

        return;
      }

      delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
      _additionalTextInputLocales = [delegateAsResponder _additionalTextInputLocales];
      [v9 setAdditionalTextInputLocales:_additionalTextInputLocales];

      v84 = [(_UIKeyboardStateManager *)self desirableInputModesWithExtensions:extensionsCopy];
      v14 = [v9 identifiersFromInputModes:?];
      v15 = UIKeyboardActiveInputModes;
      v16 = [v15 isEqualToArray:v14];

      UIKeyboardSetActiveInputModes(v14);
      if ((v16 & 1) == 0)
      {
        defaultCenter = [MEMORY[0x1E696AD88] defaultCenter];
        [defaultCenter postNotificationName:@"UIKeyboardActiveInputModesDidChange" object:0 userInfo:0];
      }

      v18 = +[UIKeyboardInputModeController sharedInputModeController];
      lastInputModeSwitchTriggeredByASCIIToggle = [v18 lastInputModeSwitchTriggeredByASCIIToggle];

      if (lastInputModeSwitchTriggeredByASCIIToggle)
      {
        [v9 currentInputModeInPreference];
      }

      else
      {
        [v9 currentInputMode];
      }
      v20 = ;
      v21 = +[UIKeyboardInputMode dictationInputMode];
      v22 = [v20 isEqual:v21];

      if (v22)
      {
        v23 = +[UIKeyboardInputMode dictationInputMode];
        currentInputModeForDictation = [v23 currentInputModeForDictation];

        v20 = currentInputModeForDictation;
      }

      v25 = v20;
      inputModeContextIdentifier = [v9 inputModeContextIdentifier];

      currentInputModeInPreference = v25;
      if (!inputModeContextIdentifier)
      {
        if (!modesCopy || self->_suppressUpdateInputMode)
        {
          currentInputModeInPreference = v25;
          if (self->_suppressUpdateInputMode)
          {
            goto LABEL_13;
          }
        }

        else
        {
          normalizedIdentifier = [v25 normalizedIdentifier];
          IsNonLinguistic = UIKeyboardInputModeIsNonLinguistic(normalizedIdentifier);

          currentInputModeInPreference = v25;
          if (IsNonLinguistic)
          {
            goto LABEL_13;
          }
        }

        currentInputModeInPreference = v25;
        if (!+[UIKeyboard isKeyboardProcess])
        {
          delegateAsResponder2 = [(_UIKeyboardStateManager *)self delegateAsResponder];
          v53 = [v9 textInputModeForResponder:delegateAsResponder2];
          currentInputModeInPreference = [v9 lastUsedInputModeForTextInputMode:v53];
        }

        if (!currentInputModeInPreference)
        {
          currentInputModeInPreference = [v9 currentInputModeInPreference];
        }
      }

LABEL_13:
      if ([(_UIKeyboardStateManager *)self shouldLoadAutofillSignUpInputViewController])
      {
        v28 = +[UIKeyboardInputMode autofillSignupInputMode];
        [(_UIKeyboardStateManager *)self setKeyboardInputMode:v28 userInitiated:0];

        v29 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
        v30 = [v29 remoteHostInputViewSet:0];

        v31 = v84;
LABEL_78:

        goto LABEL_79;
      }

      v83 = v14;
      if ((self->m_cachedAutofillMode - 1) > 2)
      {
        if (!self->_restoresToEmojiInputMode)
        {
          v31 = v84;
LABEL_55:
          if (([currentInputModeInPreference isEqual:v25] & 1) != 0 || objc_msgSend(v31, "indexOfObject:", currentInputModeInPreference) == 0x7FFFFFFFFFFFFFFFLL)
          {
            if (([v25 isDisplayed] & 1) == 0)
            {
              [(_UIKeyboardStateManager *)self postInputViewControllerShouldUpdateNotification:v25];
            }
          }

          else
          {
            if (!+[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI") || (-[_UIKeyboardStateManager remoteTextInputPartner](self, "remoteTextInputPartner"), v59 = objc_claimAutoreleasedReturnValue(), v98[0] = @"inputMode", v98[1] = @"isUserInitiated", v99[0] = currentInputModeInPreference, v99[1] = MEMORY[0x1E695E110], [MEMORY[0x1E695DF20] dictionaryWithObjects:v99 forKeys:v98 count:2], v60 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v59, "forwardInputDestinationEventToUIHost:params:", sel_setKeyboardInputMode_userInitiated_, v60), v60, v59, objc_msgSend(v9, "currentInputMode"), v61 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v61, "identifier"), v62 = objc_claimAutoreleasedReturnValue(), LODWORD(v60) = objc_msgSend(v62, "isEqualToString:", @"autofillsignup"), v62, v61, v60))
            {
              [(_UIKeyboardStateManager *)self setKeyboardInputMode:currentInputModeInPreference userInitiated:0];
            }

            v63 = currentInputModeInPreference;

            v25 = v63;
          }

          v64 = [v31 indexOfObject:v25];
          if (v64 == 0x7FFFFFFFFFFFFFFFLL || ([v31 objectAtIndex:v64], v65 = objc_claimAutoreleasedReturnValue(), v66 = -[_UIKeyboardStateManager shouldSwitchInputMode:](self, "shouldSwitchInputMode:", v65), v65, v66))
          {
            v82 = v25;
            v67 = +[UIKeyboardInputModeController sharedInputModeController];
            currentInputMode = [v9 currentInputMode];
            v69 = [v67 fallbackCurrentInputModeForFilteredInputMode:currentInputMode fromInputModes:v31];

            array = [MEMORY[0x1E695DF70] array];
            v71 = array;
            if (v69)
            {
              [array addObject:v69];
            }

            v72 = v31;
            [v71 addObjectsFromArray:v31];
            v87 = 0u;
            v88 = 0u;
            v85 = 0u;
            v86 = 0u;
            v73 = v71;
            v74 = [v73 countByEnumeratingWithState:&v85 objects:v97 count:16];
            if (v74)
            {
              v75 = v74;
              v76 = *v86;
              while (2)
              {
                for (i = 0; i != v75; ++i)
                {
                  if (*v86 != v76)
                  {
                    objc_enumerationMutation(v73);
                  }

                  v78 = *(*(&v85 + 1) + 8 * i);
                  if ([v78 isDesiredForTraits:self->m_traits withExtended:0])
                  {
                    currentInputMode2 = [v9 currentInputMode];
                    [(_UIKeyboardStateManager *)self setKeyboardInputMode:v78 userInitiated:0];
                    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
                    [WeakRetained setShowInputModeIndicator:1];

                    goto LABEL_77;
                  }
                }

                v75 = [v73 countByEnumeratingWithState:&v85 objects:v97 count:16];
                if (v75)
                {
                  continue;
                }

                break;
              }
            }

LABEL_77:

            v25 = v82;
            v14 = v83;
            v31 = v72;
          }

          goto LABEL_78;
        }

        v44 = v14;
        self->_restoresToEmojiInputMode = 0;
        if (([v25 isEmojiInputMode] & 1) == 0)
        {
          v45 = +[UIKeyboardInputModeController sharedInputModeController];
          [v45 setInputModeThatInvokeEmoji:v25];
        }

        v91 = 0u;
        v92 = 0u;
        v89 = 0u;
        v90 = 0u;
        v46 = v84;
        v47 = [v46 countByEnumeratingWithState:&v89 objects:v100 count:16];
        if (v47)
        {
          v48 = v47;
          v49 = *v90;
          while (2)
          {
            for (j = 0; j != v48; ++j)
            {
              if (*v90 != v49)
              {
                objc_enumerationMutation(v46);
              }

              v51 = *(*(&v89 + 1) + 8 * j);
              if ([v51 isEmojiInputMode])
              {
                v58 = v51;

                currentInputModeInPreference = v58;
                goto LABEL_53;
              }
            }

            v48 = [v46 countByEnumeratingWithState:&v89 objects:v100 count:16];
            if (v48)
            {
              continue;
            }

            break;
          }
        }

LABEL_53:
        v14 = v44;
        v31 = v46;
      }

      else
      {
        identifier = [currentInputModeInPreference identifier];
        v33 = [identifier hasPrefix:@"emoji"];

        if (v33)
        {
          v95 = 0u;
          v96 = 0u;
          v93 = 0u;
          v94 = 0u;
          v34 = v84;
          v35 = [v34 countByEnumeratingWithState:&v93 objects:v101 count:16];
          if (v35)
          {
            v36 = v35;
            v37 = *v94;
            v81 = v25;
            while (2)
            {
              v38 = 0;
              v39 = currentInputModeInPreference;
              do
              {
                if (*v94 != v37)
                {
                  objc_enumerationMutation(v34);
                }

                currentInputModeInPreference = *(*(&v93 + 1) + 8 * v38);

                identifier2 = [currentInputModeInPreference identifier];
                v41 = [identifier2 hasPrefix:@"emoji"];

                if (!v41)
                {
                  v25 = v81;
                  goto LABEL_49;
                }

                ++v38;
                v39 = currentInputModeInPreference;
              }

              while (v36 != v38);
              v36 = [v34 countByEnumeratingWithState:&v93 objects:v101 count:16];
              v25 = v81;
              if (v36)
              {
                continue;
              }

              break;
            }
          }

          currentInputModeInPreference = 0;
LABEL_49:

          v14 = v83;
        }

        v31 = v84;
        identifier3 = [currentInputModeInPreference identifier];
        v55 = [identifier3 hasPrefix:@"emoji"];

        if (!v55)
        {
          goto LABEL_55;
        }

        v56 = +[UIKeyboardInputMode intlInputMode];

        v57 = [v84 arrayByAddingObject:v56];

        v46 = [v9 identifiersFromInputModes:v57];
        UIKeyboardSetActiveInputModes(v46);
        currentInputModeInPreference = v56;
        v31 = v57;
      }

      goto LABEL_55;
    }
  }
}

- (void)setRestoresToEmojiInputMode
{
  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardInputDestinationEventToUIHost:sel_setRestoresToEmojiInputMode];
  }

  else
  {
    self->_restoresToEmojiInputMode = 1;
  }
}

- (void)_startSmartReplyWritingToolWithPrompt:(id)prompt entryPoint:(id)point inputContextHistory:(id)history
{
  promptCopy = prompt;
  pointCopy = point;
  historyCopy = history;
  if (!+[UIKeyboard isKeyboardProcess])
  {
    goto LABEL_8;
  }

  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  if ([(_UIKeyboardStateManager *)self shouldPreventLongFormSmartRepliesFromStarting])
  {
    dictionary = _UIKeyboardSmartReplyLog();
    if (os_log_type_enabled(dictionary, OS_LOG_TYPE_DEFAULT))
    {
      *v16 = 0;
      _os_log_impl(&dword_188A29000, dictionary, OS_LOG_TYPE_DEFAULT, "Not starting SmartReplies because WritingTools is already in use", v16, 2u);
    }

    goto LABEL_7;
  }

  if (!inputSystemSourceSession)
  {
LABEL_8:
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputDelegateManager];
    textInputDelegate = [inputSystemSourceSession textInputDelegate];
    [textInputDelegate _startWritingToolsWithTool:@"WTUIRequestedToolSmartReply" prompt:promptCopy entryPoint:pointCopy inputContextHistory:historyCopy sender:self];

    goto LABEL_9;
  }

  dictionary = [MEMORY[0x1E695DF90] dictionary];
  [dictionary setObject:promptCopy forKeyedSubscript:@"prompt"];
  [dictionary setObject:pointCopy forKeyedSubscript:@"entryPoint"];
  [dictionary setObject:historyCopy forKeyedSubscript:@"inputContextHistory"];
  textOperations = [inputSystemSourceSession textOperations];
  [textOperations setCustomInfo:dictionary];

  textOperations2 = [inputSystemSourceSession textOperations];
  [textOperations2 setCustomInfoType:0x1EFB7CB90];

  [inputSystemSourceSession flushOperations];
LABEL_7:

LABEL_9:
}

- (void)writingToolsDidEnd
{
  smartReplyFeedbackManager = [(_UIKeyboardStateManager *)self smartReplyFeedbackManager];
  [smartReplyFeedbackManager reportWritingToolsPanelDismissed];
}

- (void)startSmartReplyWritingToolWithParams:(id)params
{
  paramsCopy = params;
  v7 = [paramsCopy objectForKeyedSubscript:@"prompt"];
  v5 = [paramsCopy objectForKeyedSubscript:@"entryPoint"];
  v6 = [paramsCopy objectForKeyedSubscript:@"inputContextHistory"];

  [(_UIKeyboardStateManager *)self _startSmartReplyWritingToolWithPrompt:v7 entryPoint:v5 inputContextHistory:v6];
}

- (BOOL)canPasteImage
{
  if (self->m_needsPasteSupportUpdate)
  {
    uncachedDelegateSupportsImagePaste = [(_UIKeyboardStateManager *)self uncachedDelegateSupportsImagePaste];
    self->m_delegateSupportsImagePaste = uncachedDelegateSupportsImagePaste;
    self->m_needsPasteSupportUpdate = 0;
  }

  else
  {
    return self->m_delegateSupportsImagePaste;
  }

  return uncachedDelegateSupportsImagePaste;
}

- (void)setRemoteDelegateSupportsAdaptiveImageGlyph:(BOOL)glyph
{
  glyphCopy = glyph;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v5 = [inputDelegateManager delegateRespectingForwardingDelegate:0];

  if (objc_opt_respondsToSelector())
  {
    [v5 setSupportsAdaptiveImageGlyph:glyphCopy];
  }
}

- (BOOL)canInsertEmojiImageTextAttachment
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v3 = [inputDelegateManager delegateRespectingForwardingDelegate:0];

  if (+[UIKeyboard isRemoteEmojiCollectionViewEnabled]&& (objc_opt_respondsToSelector() & 1) != 0)
  {
    supportsEmojiImageTextAttachments = [v3 supportsEmojiImageTextAttachments];
  }

  else
  {
    supportsEmojiImageTextAttachments = 0;
  }

  return supportsEmojiImageTextAttachments;
}

- (BOOL)supportsGenmojiCreation
{
  if (+[UIKeyboard isKeyboardProcess])
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    documentTraits = [inputSystemSourceSession documentTraits];

    if (objc_opt_respondsToSelector())
    {
      supportsGenmojiCreation = [documentTraits supportsGenmojiCreation];
    }

    else
    {
      supportsGenmojiCreation = 1;
    }
  }

  else
  {
    if (qword_1ED49D1F8 != -1)
    {
      dispatch_once(&qword_1ED49D1F8, &__block_literal_global_1244);
    }

    supportsGenmojiCreation = byte_1ED49CF3C ^ 1;
  }

  return supportsGenmojiCreation & 1;
}

- (BOOL)isSelectionAtSentenceAutoshiftBoundary:(BOOL)boundary
{
  boundaryCopy = boundary;
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];

  if (inputManagerState && boundaryCopy)
  {
    inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
    nextInputWouldStartSentence = [inputManagerState2 nextInputWouldStartSentence];

    return nextInputWouldStartSentence;
  }

  else
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    v10 = [inputDelegate _characterInRelationToRangedSelection:0xFFFFFFFFLL];

    v11 = (v10 & 0xFFFFFF7F) == 32;
    if ((v10 & 0xFFFFFF7F) != 0x20)
    {
      goto LABEL_22;
    }

    v12 = 4294967294;
    v13 = -1;
    do
    {
      ++v13;
      inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
      v10 = [inputDelegate2 _characterInRelationToRangedSelection:v12];

      v12 = (v12 - 1);
    }

    while ((v10 & 0xFFFFFF7F) == 0x20 && v13 < 2);
    if (v13 > 1)
    {
      return 1;
    }

LABEL_22:
    if (v10 > 0x3F)
    {
      return v10 == 161 || v10 == 191;
    }

    if (((1 << v10) & 0x8000400200000000) == 0)
    {
      v11 = 1;
      if (((1 << v10) & 0x401) == 0)
      {
        return v10 == 161 || v10 == 191;
      }
    }

    return v11;
  }
}

- (BOOL)nextInputWouldStartSentence
{
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];

  if (!inputManagerState)
  {
    return 0;
  }

  inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
  nextInputWouldStartSentence = [inputManagerState2 nextInputWouldStartSentence];

  return nextInputWouldStartSentence;
}

- (void)setShift:(BOOL)shift autoshift:(BOOL)autoshift
{
  if ((!autoshift || [(_UIKeyboardStateManager *)self callLayoutUsesAutoShift]) && !self->m_settingShift)
  {
    self->m_settingShift = 1;
    self->m_shift = shift;
    self->m_autoshift = autoshift;
    if (!shift)
    {
      self->m_shiftLocked = 0;
    }

    [(_UIKeyboardStateManager *)self setShiftNeedsUpdate];
    self->m_settingShift = 0;

    [(_UIKeyboardStateManager *)self _forwardNeededShiftStatesToDestination];
  }
}

- (void)setShiftLocked:(BOOL)locked
{
  if (self->m_shiftLockedEnabled)
  {
    self->m_shiftLocked = locked;
    if (locked)
    {
      [(_UIKeyboardStateManager *)self setShift:1 autoshift:0];
    }

    else
    {
      [(_UIKeyboardStateManager *)self _forwardNeededShiftStatesToDestination];
    }
  }
}

- (void)setShiftLockedForced:(BOOL)forced
{
  self->m_shiftLocked = forced;
  if (forced)
  {
    [(_UIKeyboardStateManager *)self setShift:1 autoshift:0];
  }
}

- (void)setShiftStatesNeededInDestination:(BOOL)destination autoShifted:(BOOL)shifted shiftLocked:(BOOL)locked
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  keyboardLayoutIsInAnotherProcess = [WeakRetained keyboardLayoutIsInAnotherProcess];

  if (keyboardLayoutIsInAnotherProcess)
  {
    self->m_shift = destination;
    self->m_autoshift = shifted;
    self->m_shiftLocked = locked;
  }
}

- (void)updateShiftStateAfterAsyncSelectionChange
{
  if ([(UITextInputTraits *)self->m_traits autocapitalizationType]== 1 && ![(_UIKeyboardStateManager *)self isShiftLocked])
  {

    [(_UIKeyboardStateManager *)self clearShiftState];
  }
}

- (BOOL)isCapsLockASCIIToggle
{
  if (![(_UIKeyboardStateManager *)self isCapsLockSwitchEnabled])
  {
    return 0;
  }

  v3 = +[UIKeyboardInputModeController sharedInputModeController];
  v4 = [v3 inputModeForASCIIToggleWithTraits:self->m_traits];
  v5 = v4 != 0;

  return v5;
}

- (BOOL)isCapsLockSwitchEnabled
{
  v3 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v3 preferencesActions];
  v5 = [preferencesActions valueForPreferenceKey:*MEMORY[0x1E69D9758]];

  if (!v5)
  {
    if (self->m_didUpdateCapsLockLanguageSwitchSetting)
    {
LABEL_10:
      m_shouldEnableCapsLockLanguageSwitchByDefault = self->m_shouldEnableCapsLockLanguageSwitchByDefault;
      goto LABEL_11;
    }

    v7 = [MEMORY[0x1E695DFD8] setWithArray:&unk_1EFE2B5C0];
    v8 = MEMORY[0x1E695DF58];
    _deviceLanguage = [MEMORY[0x1E695DF58] _deviceLanguage];
    v10 = [v8 localeWithLocaleIdentifier:_deviceLanguage];
    languageCode = [v10 languageCode];

    if ([v7 containsObject:languageCode])
    {
      HasLanguageSwitchLabel = 1;
    }

    else
    {
      if (self->m_shouldEnableCapsLockLanguageSwitchByDefault)
      {
LABEL_9:
        self->m_didUpdateCapsLockLanguageSwitchSetting = 1;

        goto LABEL_10;
      }

      HasLanguageSwitchLabel = BKSHIDServicesCapsLockKeyHasLanguageSwitchLabel();
    }

    self->m_shouldEnableCapsLockLanguageSwitchByDefault = HasLanguageSwitchLabel;
    goto LABEL_9;
  }

  m_shouldEnableCapsLockLanguageSwitchByDefault = [v5 BOOLValue];
LABEL_11:

  return m_shouldEnableCapsLockLanguageSwitchByDefault & 1;
}

- (void)forceShiftUpdateIfKeyboardStateChanged
{
  changedDelegate = [(_UIKeyboardStateManager *)self changedDelegate];

  if (changedDelegate)
  {
    [(_UIKeyboardStateManager *)self updateShiftState];
    self->m_shiftNeedsUpdate = 0;
  }
}

- (void)setShouldSkipCandidateSelection:(BOOL)selection userInitiated:(BOOL)initiated
{
  initiatedCopy = initiated;
  v6 = [(UITextInputTraits *)self->m_traits isSecureTextEntry]| selection;
  if (initiatedCopy && v6 && ([(TIKeyboardState *)self->m_keyboardState shouldSkipCandidateSelection]& 1) == 0 && [(_UIKeyboardStateManager *)self usesCandidateSelection])
  {
    updatedKeyBehaviors = [(_UIKeyboardStateManager *)self updatedKeyBehaviors];
    returnKeyBehavior = [updatedKeyBehaviors returnKeyBehavior];

    if (returnKeyBehavior == 10)
    {
      v9 = [(_UIKeyboardStateManager *)self acceptInlineCandidateWithSpace:0];
    }

    else
    {
      [(_UIKeyboardStateManager *)self acceptAutocorrectionWithCompletionHandler:0];
    }
  }

  m_keyboardState = self->m_keyboardState;

  [(TIKeyboardState *)m_keyboardState setShouldSkipCandidateSelection:v6];
}

- (void)setInputManagerState:(id)state
{
  stateCopy = state;
  m_inputManagerState = self->m_inputManagerState;
  if (m_inputManagerState == stateCopy)
  {
    goto LABEL_14;
  }

  p_m_inputManagerState = &self->m_inputManagerState;
  v17 = stateCopy;
  usesContinuousPath = [(TIKeyboardInputManagerState *)m_inputManagerState usesContinuousPath];
  supportsSetPhraseBoundary = [(TIKeyboardInputManagerState *)self->m_inputManagerState supportsSetPhraseBoundary];
  supportsSetPhraseBoundary2 = [(TIKeyboardInputManagerState *)v17 supportsSetPhraseBoundary];
  objc_storeStrong(&self->m_inputManagerState, state);
  if ([(TIKeyboardState *)self->m_keyboardState longPredictionListEnabled])
  {
    if (self->m_usesCandidateSelection)
    {
      goto LABEL_9;
    }

    self->m_usesCandidateSelection = 1;
  }

  else
  {
    if (!*p_m_inputManagerState)
    {
      goto LABEL_9;
    }

    m_usesCandidateSelection = self->m_usesCandidateSelection;
    if (m_usesCandidateSelection == [*p_m_inputManagerState usesCandidateSelection])
    {
      goto LABEL_9;
    }

    self->m_usesCandidateSelection = [(TIKeyboardInputManagerState *)self->m_inputManagerState usesCandidateSelection];
  }

  [(_UIKeyboardStateManager *)self updateShowCandidateBar];
LABEL_9:
  v12 = supportsSetPhraseBoundary ^ supportsSetPhraseBoundary2;
  [(TISmartPunctuationController *)self->m_smartPunctuationController setAutoQuoteType:[(TIKeyboardInputManagerState *)self->m_inputManagerState autoquoteType]];
  v13 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v13 currentInputMode];
  primaryLanguage = [currentInputMode primaryLanguage];
  [(_UIKeyboardStateManager *)self updateSmartPunctuationOptionsForLocaleIdentifier:primaryLanguage];

  if ((usesContinuousPath & 1) == 0 && [*p_m_inputManagerState usesContinuousPath])
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    [WeakRetained presentContinuousPathIntroductionView];
  }

  stateCopy = v17;
  if (v12)
  {
    [(_UIKeyboardStateManager *)self notifyInputSourceStateChangeIfNeeded];
    stateCopy = v17;
  }

LABEL_14:
}

- (void)updateShowCandidateBar
{
  shouldShowCandidateBar = [(_UIKeyboardStateManager *)self shouldShowCandidateBar];

  [(_UIKeyboardStateManager *)self setShowsCandidateBar:shouldShowCandidateBar];
}

- (void)setUsesCandidateSelection:(BOOL)selection
{
  selectionCopy = selection;
  usesCandidateSelection = [(_UIKeyboardStateManager *)self usesCandidateSelection];
  v6 = !selectionCopy;
  [(TIKeyboardState *)self->m_keyboardState setSuppressingCandidateSelection:v6];
  if (!v6)
  {
    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    usesCandidateSelection2 = [inputManagerState usesCandidateSelection];

    if (!usesCandidateSelection && (usesCandidateSelection2 & 1) != 0)
    {

      [(_UIKeyboardStateManager *)self clearInput];
    }
  }
}

- (BOOL)suppliesCompletions
{
  m_candidateList = self->m_candidateList;
  if (m_candidateList && [(UIKeyboardCandidateList *)m_candidateList isFloatingList]&& ![(_UIKeyboardStateManager *)self canUseCandidateBarAsSupplementToInlineView])
  {
    return 0;
  }

  textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
  isSingleLineDocument = [textInputTraits isSingleLineDocument];

  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  v7 = inputManagerState;
  if (isSingleLineDocument)
  {
    if ([inputManagerState suppressCompletionsForFieldEditor])
    {
      hasOnlySlottedCandidates = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet hasOnlySlottedCandidates];
LABEL_10:
      v9 = hasOnlySlottedCandidates;
      goto LABEL_11;
    }
  }

  else if (([inputManagerState suppliesCompletions] & 1) == 0)
  {
    hasOnlySlottedCandidates = [(_UIKeyboardStateManager *)self shouldShowLongPredictionList];
    goto LABEL_10;
  }

  v9 = 1;
LABEL_11:

  return v9;
}

- (BOOL)supportsNumberKeySelection
{
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  supportsNumberKeySelection = [inputManagerState supportsNumberKeySelection];

  return supportsNumberKeySelection;
}

- (BOOL)shouldUsePinyinStyleRowNavigation
{
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  usesPunctuationKeysForRowNavigation = [inputManagerState usesPunctuationKeysForRowNavigation];

  return usesPunctuationKeysForRowNavigation;
}

- (void)handleDeleteAsRepeat:(BOOL)repeat executionContext:(id)context
{
  repeatCopy = repeat;
  contextCopy = context;
  if (![(_UIKeyboardStateManager *)self _delegateRequiresKeyEvents]|| +[UIKeyboard isKeyboardProcess]&& [(_UIKeyboardStateManager *)self _hasMarkedText])
  {
    if (repeatCopy && self->m_repeatDeleteWord)
    {
      v6 = 512;
    }

    else if ([(_UIKeyboardStateManager *)self shouldUseAdaptiveDelete])
    {
      v6 = 512;
    }

    else
    {
      v6 = 0;
    }

    [(_UIKeyboardStateManager *)self deleteFromInputWithFlags:v6 executionContext:contextCopy];
  }

  else
  {
    v7 = [(_UIKeyboardStateManager *)self physicalKeyboardEventWithInput:@"\x7F" inputFlags:repeatCopy];
    [(_UIKeyboardStateManager *)self _handleKeyEvent:v7 executionContext:contextCopy];
  }
}

- (void)handleDeleteWithExecutionContext:(id)context
{
  contextCopy = context;
  inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
  canUndoAcceptedTextCompletion = [inlineTextCompletionController canUndoAcceptedTextCompletion];

  if (canUndoAcceptedTextCompletion)
  {
    [(_UIKeyboardStateManager *)self flushTouchEventWaitingForKeyInputEventIfNecessary];
    [(_UIKeyboardStateManager *)self setDeleteWordLastDelete:-*MEMORY[0x1E695E460]];
    [(_UIKeyboardStateManager *)self setDeletedString:0];
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    [WeakRetained playDeleteKeyFeedbackIfNecessaryRepeat:0 rapid:0 deleteCount:1];

    inlineTextCompletionController2 = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
    v8 = [contextCopy childWithContinuation:&__block_literal_global_1273];
    [inlineTextCompletionController2 undoAcceptedTextCompletionExecutionContext:v8];
  }

  else
  {
    Current = CFAbsoluteTimeGetCurrent();
    [(_UIKeyboardStateManager *)self deleteWordLastDelete];
    if (Current - v10 <= 1.0)
    {
      [(_UIKeyboardStateManager *)self startDelayDeleteTimer];
      [(_UIKeyboardStateManager *)self flushTouchEventWaitingForKeyInputEventIfNecessary];
      [contextCopy returnExecutionToParent];
    }

    else
    {
      [(_UIKeyboardStateManager *)self setDeleteWordLastDelete:-*MEMORY[0x1E695E460]];
      [(_UIKeyboardStateManager *)self setDeletedString:0];
      v11 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v11 playDeleteKeyFeedbackIfNecessaryRepeat:0 rapid:0 deleteCount:1];

      [(_UIKeyboardStateManager *)self handleDeleteAsRepeat:0 executionContext:contextCopy];
    }
  }
}

- (void)completeDelete
{
  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  isSmartReplyCandidates = [autocorrectionController isSmartReplyCandidates];

  if ((isSmartReplyCandidates & 1) == 0)
  {
    [(_UIKeyboardStateManager *)self generateCandidates];
    [(_UIKeyboardStateManager *)self updateCandidateDisplay];
  }

  [(_UIKeyboardStateManager *)self updateReturnKey];

  [(_UIKeyboardStateManager *)self updateNoContentViews];
}

- (BOOL)shouldUseAdaptiveDelete
{
  if (+[UIKeyboard isKeyboardProcess])
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    documentState = [inputSystemSourceSession documentState];
    v4DocumentState = [documentState documentState];
  }

  else
  {
    v4DocumentState = [(_UIKeyboardStateManager *)self documentState];
  }

  contextBeforeInput = [v4DocumentState contextBeforeInput];
  _lastGrapheme = [contextBeforeInput _lastGrapheme];
  v8 = [_lastGrapheme containsString:@"\n"];

  if (v8)
  {
    LOBYTE(languageSupportsAdaptiveDelete) = 0;
  }

  else
  {
    v10 = +[UIDictationController sharedInstance];
    languageSupportsAdaptiveDelete = [v10 languageSupportsAdaptiveDelete];

    if (languageSupportsAdaptiveDelete)
    {
      v11 = +[UIDictationController sharedInstance];
      startRangeOfCurrentHypothesis = [v11 startRangeOfCurrentHypothesis];
      contextBeforeInput2 = [v4DocumentState contextBeforeInput];
      whitespaceAndNewlineCharacterSet = [MEMORY[0x1E696AB08] whitespaceAndNewlineCharacterSet];
      v15 = [contextBeforeInput2 stringByTrimmingCharactersInSet:whitespaceAndNewlineCharacterSet];
      v16 = [v15 length];

      if (startRangeOfCurrentHypothesis >= v16)
      {
        v23 = +[UIDictationController sharedInstance];
        [v23 setStartRangeOfCurrentHypothesis:{0x7FFFFFFFFFFFFFFFLL, 0}];
        LOBYTE(languageSupportsAdaptiveDelete) = 0;
      }

      else
      {
        v17 = +[UIDictationUtilities trackingPunctuations];
        contextBeforeInput3 = [v4DocumentState contextBeforeInput];
        whitespaceAndNewlineCharacterSet2 = [MEMORY[0x1E696AB08] whitespaceAndNewlineCharacterSet];
        v20 = [contextBeforeInput3 stringByTrimmingCharactersInSet:whitespaceAndNewlineCharacterSet2];
        _lastGrapheme2 = [v20 _lastGrapheme];
        v22 = [v17 containsObject:_lastGrapheme2];

        v23 = +[UIDictationController sharedInstance];
        languageSupportsAdaptiveDelete = [v23 shouldDeleteWordOnBackspaceTap] & (v22 ^ 1);
      }
    }
  }

  return languageSupportsAdaptiveDelete;
}

- (void)handleDeleteWordWithExecutionContext:(id)context
{
  contextCopy = context;
  [(_UIKeyboardStateManager *)self clearDelayDeleteTimer];
  deletedString = [(_UIKeyboardStateManager *)self deletedString];

  if (deletedString)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    deletedString2 = [(_UIKeyboardStateManager *)self deletedString];
    [inputDelegateManager insertText:deletedString2];

    [(_UIKeyboardStateManager *)self setDeletedString:0];
  }

  else
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    [WeakRetained playDeleteKeyFeedbackRepeat:0 rapid:0 deleteCount:1];
  }

  [(_UIKeyboardStateManager *)self deleteFromInputWithFlags:512 executionContext:contextCopy];
}

- (void)handleDelete
{
  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  isMainThreadExecutingTask = [taskQueue isMainThreadExecutingTask];

  if (isMainThreadExecutingTask)
  {
    currentHandler = [MEMORY[0x1E696AAA8] currentHandler];
    [currentHandler handleFailureInMethod:a2 object:self file:@"_UIKeyboardStateManager.m" lineNumber:11526 description:{@"Received %s while performing another keyboard action.", "-[_UIKeyboardStateManager handleDelete]"}];
  }

  if (qword_1ED49D208 != -1)
  {
    dispatch_once(&qword_1ED49D208, &__block_literal_global_1279);
  }

  taskQueue2 = [(_UIKeyboardStateManager *)self taskQueue];
  v8[0] = MEMORY[0x1E69E9820];
  v8[1] = 3221225472;
  v8[2] = __39___UIKeyboardStateManager_handleDelete__block_invoke_3;
  v8[3] = &unk_1E70FD058;
  v8[4] = self;
  [taskQueue2 addTask:v8 breadcrumb:qword_1ED49D200];
}

- (void)handleClearWithInsertBeforeAdvance:(id)advance
{
  advanceCopy = advance;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager replaceRange:0 oldText:0 withText:advanceCopy forReplaceAction:2];
}

- (void)handleClear
{
  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  isMainThreadExecutingTask = [taskQueue isMainThreadExecutingTask];

  if ((isMainThreadExecutingTask & 1) == 0)
  {
    taskQueue2 = [(_UIKeyboardStateManager *)self taskQueue];
    [taskQueue2 waitUntilAllTasksAreFinished];
  }

  if (qword_1ED49D218 != -1)
  {
    dispatch_once(&qword_1ED49D218, &__block_literal_global_1283);
  }

  taskQueue3 = [(_UIKeyboardStateManager *)self taskQueue];
  v7[0] = MEMORY[0x1E69E9820];
  v7[1] = 3221225472;
  v7[2] = __38___UIKeyboardStateManager_handleClear__block_invoke_3;
  v7[3] = &unk_1E70FD058;
  v7[4] = self;
  [taskQueue3 addTask:v7 breadcrumb:qword_1ED49D210];
}

- (void)handleClearWithExecutionContext:(id)context
{
  contextCopy = context;
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate2 _clearButtonClicked:0];
  }

  else
  {
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegate2 replaceRange:0 oldText:0 withText:&stru_1EFB14550 forReplaceAction:2];
  }

  [contextCopy returnExecutionToParent];
}

- (BOOL)handleMoveCursorToStartOfLine:(BOOL)line beforePublicKeyCommands:(BOOL)commands testOnly:(BOOL)only savedHistory:(id)history force:(BOOL)force canHandleSelectableInputDelegateCommand:(id)command keyEvent:(id)event
{
  forceCopy = force;
  commandsCopy = commands;
  historyCopy = history;
  commandCopy = command;
  eventCopy = event;
  hasEditableMarkedText = [(_UIKeyboardStateManager *)self hasEditableMarkedText];
  if ([(_UIKeyboardStateManager *)self _hasMarkedText])
  {
    [(_UIKeyboardStateManager *)self inputManagerState];
    selfCopy = self;
    v19 = commandsCopy;
    v20 = forceCopy;
    v21 = commandCopy;
    v22 = eventCopy;
    v23 = historyCopy;
    onlyCopy = only;
    v26 = v25 = line;
    v27 = [v26 supportsSetPhraseBoundary] ^ 1;

    line = v25;
    only = onlyCopy;
    historyCopy = v23;
    eventCopy = v22;
    commandCopy = v21;
    forceCopy = v20;
    commandsCopy = v19;
    self = selfCopy;
    if (!hasEditableMarkedText)
    {
      goto LABEL_3;
    }

LABEL_6:
    if (forceCopy)
    {
      LOBYTE(v28) = 1;
      [(_UIKeyboardStateManager *)self movePhraseBoundaryToDirection:1 granularity:4];
      goto LABEL_16;
    }

LABEL_15:
    LOBYTE(v28) = 1;
    goto LABEL_16;
  }

  v27 = 0;
  if (hasEditableMarkedText)
  {
    goto LABEL_6;
  }

LABEL_3:
  if ((commandsCopy | v27))
  {
    LOBYTE(v28) = !commandsCopy;
    goto LABEL_16;
  }

  if (+[UIKeyboard isKeyboardProcess])
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    shouldRespectForwardingInputDelegate = [inputDelegateManager shouldRespectForwardingInputDelegate];

    if ((shouldRespectForwardingInputDelegate & 1) == 0)
    {
      if (!only)
      {
        [(_UIKeyboardStateManager *)self forwardKeyboardEventBackToDestination:eventCopy];
      }

      goto LABEL_15;
    }
  }

  v28 = commandCopy[2](commandCopy, sel__moveToStartOfLine_withHistory_);
  if (v28 && !only)
  {
    v33[0] = MEMORY[0x1E69E9820];
    v33[1] = 3221225472;
    v33[2] = __158___UIKeyboardStateManager_handleMoveCursorToStartOfLine_beforePublicKeyCommands_testOnly_savedHistory_force_canHandleSelectableInputDelegateCommand_keyEvent___block_invoke;
    v33[3] = &unk_1E70F5AF0;
    v33[4] = self;
    lineCopy = line;
    v34 = historyCopy;
    [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v33];
  }

LABEL_16:

  return v28;
}

- (BOOL)handleMoveCursorToEndOfLine:(BOOL)line beforePublicKeyCommands:(BOOL)commands testOnly:(BOOL)only savedHistory:(id)history force:(BOOL)force canHandleSelectableInputDelegateCommand:(id)command keyEvent:(id)event
{
  forceCopy = force;
  commandsCopy = commands;
  historyCopy = history;
  commandCopy = command;
  eventCopy = event;
  hasEditableMarkedText = [(_UIKeyboardStateManager *)self hasEditableMarkedText];
  if ([(_UIKeyboardStateManager *)self _hasMarkedText])
  {
    [(_UIKeyboardStateManager *)self inputManagerState];
    selfCopy = self;
    v19 = commandsCopy;
    v20 = forceCopy;
    v21 = commandCopy;
    v22 = eventCopy;
    v23 = historyCopy;
    onlyCopy = only;
    v26 = v25 = line;
    v27 = [v26 supportsSetPhraseBoundary] ^ 1;

    line = v25;
    only = onlyCopy;
    historyCopy = v23;
    eventCopy = v22;
    commandCopy = v21;
    forceCopy = v20;
    commandsCopy = v19;
    self = selfCopy;
    if (!hasEditableMarkedText)
    {
      goto LABEL_3;
    }

LABEL_6:
    if (forceCopy)
    {
      [(_UIKeyboardStateManager *)self movePhraseBoundaryToDirection:0 granularity:4];
    }

    goto LABEL_8;
  }

  v27 = 0;
  if (hasEditableMarkedText)
  {
    goto LABEL_6;
  }

LABEL_3:
  if ((commandsCopy | v27))
  {
    LOBYTE(v28) = !commandsCopy;
    goto LABEL_9;
  }

  if (+[UIKeyboard isKeyboardProcess])
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    shouldRespectForwardingInputDelegate = [inputDelegateManager shouldRespectForwardingInputDelegate];

    if ((shouldRespectForwardingInputDelegate & 1) == 0)
    {
      if (!only)
      {
        [(_UIKeyboardStateManager *)self forwardKeyboardEventBackToDestination:eventCopy];
      }

LABEL_8:
      LOBYTE(v28) = 1;
      goto LABEL_9;
    }
  }

  v28 = commandCopy[2](commandCopy, sel__moveToEndOfLine_withHistory_);
  if (v28 && !only)
  {
    v33[0] = MEMORY[0x1E69E9820];
    v33[1] = 3221225472;
    v33[2] = __156___UIKeyboardStateManager_handleMoveCursorToEndOfLine_beforePublicKeyCommands_testOnly_savedHistory_force_canHandleSelectableInputDelegateCommand_keyEvent___block_invoke;
    v33[3] = &unk_1E70F5AF0;
    v33[4] = self;
    lineCopy = line;
    v34 = historyCopy;
    [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v33];
  }

LABEL_9:

  return v28;
}

- (void)forwardKeyboardEventBackToDestination:(id)destination
{
  destinationCopy = destination;
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  textOperations = [inputSystemSourceSession textOperations];
  [destinationCopy setKeyEventForwardedFromInputUIHost:1];
  [textOperations setCustomInfoType:0x1EFB7C9B0];
  [textOperations setCustomInfo:destinationCopy];

  buildInputSourceState = [(_UIKeyboardStateManager *)self buildInputSourceState];
  [textOperations setInputSourceState:buildInputSourceState];

  [inputSystemSourceSession flushOperations];
}

- (BOOL)handleHorizontalArrow:(BOOL)arrow shiftDown:(BOOL)down beforePublicKeyCommands:(BOOL)commands testOnly:(BOOL)only isVerticalCandidate:(BOOL)candidate hasCandidatesForTypedInput:(BOOL)input shouldNavigateCandidateList:(BOOL)list canHandleInputDelegateCommand:(id)self0 savedHistory:(id)self1 keyCommandTypeHandled:(unint64_t *)self2 keyEvent:(id)self3
{
  inputCopy = input;
  candidateCopy = candidate;
  LODWORD(v48) = down;
  HIDWORD(v48) = only;
  commandsCopy = commands;
  arrowCopy = arrow;
  commandCopy = command;
  historyCopy = history;
  eventCopy = event;
  liveConversionEnabled = [(_UIKeyboardStateManager *)self liveConversionEnabled];
  if (commandsCopy)
  {
    if ([(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost])
    {
      [eventCopy setKeyCommandHandlingBeforePublic:1];
      remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      LOBYTE(v23) = [remoteTextInputPartner synchronousForwardKeyCommandsBeforePublicToUIHost:eventCopy];

LABEL_30:
      v25 = commandCopy;
      goto LABEL_31;
    }

    if (![(_UIKeyboardStateManager *)self hasEditableMarkedText])
    {
      LOBYTE(v23) = 0;
      goto LABEL_30;
    }

    goto LABEL_12;
  }

  if ([(_UIKeyboardStateManager *)self hasEditableMarkedText])
  {
LABEL_12:
    if (candidateCopy)
    {
      if (handled)
      {
        *handled = 2;
      }

      if ((v48 & 0x100000000) == 0)
      {
        [(UIKeyboardCandidateList *)self->m_candidateList showCandidateInForwardDirection:arrowCopy ^ 1u granularity:0];
      }

      goto LABEL_29;
    }

    if (liveConversionEnabled)
    {
      if (handled)
      {
        *handled = 2;
      }

      if ((v48 & 0x100000000) != 0)
      {
        goto LABEL_29;
      }

      v26 = arrowCopy ^ 1u;
      v27 = v48;
      selfCopy2 = self;
      goto LABEL_28;
    }

    if (v48)
    {
      v26 = arrowCopy ^ 1u;
      selfCopy2 = self;
      v27 = 0;
LABEL_28:
      [(_UIKeyboardStateManager *)selfCopy2 movePhraseBoundaryToDirection:v26 granularity:v27, v48];
LABEL_29:
      LOBYTE(v23) = 1;
      goto LABEL_30;
    }

    v25 = commandCopy;
    if (list)
    {
      if ((v48 & 0x100000000) == 0)
      {
        m_candidateList = self->m_candidateList;
        v32 = +[UIKeyboardInputModeController sharedInputModeController];
        currentInputMode = [v32 currentInputMode];
        normalizedIdentifier = [currentInputMode normalizedIdentifier];
        [(UIKeyboardCandidateList *)m_candidateList showCandidateInForwardDirection:UIKeyboardInputModeIsDefaultRightToLeft(normalizedIdentifier) ^ arrowCopy granularity:0];
      }
    }

    else
    {
      if (!arrowCopy)
      {
        LOBYTE(v23) = 1;
        [(_UIKeyboardStateManager *)self movePhraseBoundaryToDirection:1 granularity:1];
        goto LABEL_31;
      }

      [(_UIKeyboardStateManager *)self movePhraseBoundaryToDirection:0 granularity:0];
    }

LABEL_55:
    LOBYTE(v23) = 1;
    goto LABEL_31;
  }

  if (inputCopy)
  {
    if (handled)
    {
      *handled = 2;
    }

    if ((v48 & 0x100000000) != 0)
    {
      goto LABEL_29;
    }

    v24 = self->m_candidateList;
    v25 = commandCopy;
    if (candidateCopy)
    {
      [(UIKeyboardCandidateList *)v24 showCandidateInForwardDirection:arrowCopy ^ 1u granularity:0];
      goto LABEL_55;
    }

    inlineTextCompletionController = +[UIKeyboardInputModeController sharedInputModeController];
    currentInputMode2 = [inlineTextCompletionController currentInputMode];
    normalizedIdentifier2 = [currentInputMode2 normalizedIdentifier];
    [(UIKeyboardCandidateList *)v24 showCandidateInForwardDirection:UIKeyboardInputModeIsDefaultRightToLeft(normalizedIdentifier2) ^ arrowCopy granularity:0];

LABEL_42:
    goto LABEL_55;
  }

  v25 = commandCopy;
  if ([(_UIKeyboardStateManager *)self _hasMarkedText])
  {
    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    if ([inputManagerState supportsSetPhraseBoundary])
    {
    }

    else
    {
      inlineCompletionAsMarkedText = [(_UIKeyboardStateManager *)self inlineCompletionAsMarkedText];

      if (!inlineCompletionAsMarkedText)
      {
        goto LABEL_55;
      }
    }
  }

  if (+[UIKeyboard isKeyboardProcess])
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    shouldRespectForwardingInputDelegate = [inputDelegateManager shouldRespectForwardingInputDelegate];

    if ((shouldRespectForwardingInputDelegate & 1) == 0)
    {
      if ((v50 & 1) == 0)
      {
        [(_UIKeyboardStateManager *)self forwardKeyboardEventBackToDestination:eventCopy];
      }

      goto LABEL_55;
    }
  }

  v41 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode3 = [v41 currentInputMode];
  normalizedIdentifier3 = [currentInputMode3 normalizedIdentifier];
  IsDefaultRightToLeft = UIKeyboardInputModeIsDefaultRightToLeft(normalizedIdentifier3);

  if (IsDefaultRightToLeft != arrowCopy && [(_UIKeyboardStateManager *)self cursorIsAtStartOfInlineCompletionMarkedText])
  {
    inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
    [inlineTextCompletionController acceptTextCompletionWithInteraction:4 wordTerminator:0];
    goto LABEL_42;
  }

  inlineTextCompletionController2 = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
  [inlineTextCompletionController2 removeTextCompletionPrompt];

  v46 = commandCopy[2];
  if (arrowCopy)
  {
    v23 = v46(commandCopy, sel__moveRight_withHistory_);
    if (v23 && (v50 & 1) == 0)
    {
      v54[0] = MEMORY[0x1E69E9820];
      v54[1] = 3221225472;
      v54[2] = __241___UIKeyboardStateManager_handleHorizontalArrow_shiftDown_beforePublicKeyCommands_testOnly_isVerticalCandidate_hasCandidatesForTypedInput_shouldNavigateCandidateList_canHandleInputDelegateCommand_savedHistory_keyCommandTypeHandled_keyEvent___block_invoke;
      v54[3] = &unk_1E70F5AF0;
      v54[4] = self;
      v56 = v49;
      v55 = historyCopy;
      [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v54];
      v47 = v55;
LABEL_50:
    }
  }

  else
  {
    v23 = v46(commandCopy, sel__moveLeft_withHistory_);
    if (v23 && (v50 & 1) == 0)
    {
      v51[0] = MEMORY[0x1E69E9820];
      v51[1] = 3221225472;
      v51[2] = __241___UIKeyboardStateManager_handleHorizontalArrow_shiftDown_beforePublicKeyCommands_testOnly_isVerticalCandidate_hasCandidatesForTypedInput_shouldNavigateCandidateList_canHandleInputDelegateCommand_savedHistory_keyCommandTypeHandled_keyEvent___block_invoke_2;
      v51[3] = &unk_1E70F5AF0;
      v51[4] = self;
      v53 = v49;
      v52 = historyCopy;
      [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v51];
      v47 = v52;
      goto LABEL_50;
    }
  }

LABEL_31:

  return v23;
}

- (BOOL)handleKeyCommandsBeforePublicAsInputUIHost:(id)host
{
  hostCopy = host;
  [hostCopy _gsModifierFlags];
  [(_UIKeyboardStateManager *)self liveConversionEnabled];
  if (!self->m_candidateList || [(_UIKeyboardStateManager *)self isPredictionViewControllerVisible]|| ![(UIKeyboardCandidateList *)self->m_candidateList hasCandidates]|| ![(TIKeyboardCandidateResultSet *)self->m_candidateResultSet hasCandidates])
  {
    goto LABEL_9;
  }

  inputForMarkedText = [(TIKeyboardState *)self->m_keyboardState inputForMarkedText];
  if ([inputForMarkedText length])
  {
  }

  else
  {
    currentIndex = [(UIKeyboardCandidateList *)self->m_candidateList currentIndex];

    if (currentIndex == 0x7FFFFFFFFFFFFFFFLL)
    {
      goto LABEL_9;
    }
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  candidateController = [WeakRetained candidateController];
  [candidateController inlineRectIsVertical];

LABEL_9:
  [(_UIKeyboardStateManager *)self hasEditableMarkedText];
  if ([(_UIKeyboardStateManager *)self handleInputSwitcherForKeyEvent:hostCopy])
  {
    v9 = 1;
  }

  else
  {
    v11 = 0;
    v9 = [(_UIKeyboardStateManager *)self handleKeyCommand:hostCopy repeatOkay:&v11 options:1]!= 0;
  }

  return v9;
}

- (BOOL)handleInputSwitcherForKeyEvent:(id)event
{
  eventCopy = event;
  if ([(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    v6 = [remoteTextInputPartner synchronousForwardKeyCommandsBeforePublicToUIHost:eventCopy];

    goto LABEL_17;
  }

  _gsModifierFlags = [eventCopy _gsModifierFlags];
  if (!+[UIKeyboard isKeyboardProcess])
  {
    goto LABEL_14;
  }

  if (![eventCopy _isGlobeKey])
  {
    if ((_gsModifierFlags & 0x4000000) != 0)
    {
      [(_UIKeyboardStateManager *)self setPreviousGlobeKeyEvent:0];
    }

    goto LABEL_14;
  }

  if ([eventCopy _isKeyDown])
  {
    [(_UIKeyboardStateManager *)self setPreviousGlobeKeyEvent:eventCopy];
    goto LABEL_16;
  }

  if (self->m_previousGlobeKeyEvent)
  {
    [eventCopy _hidEvent];
    v8 = BKSHIDEventGetBaseAttributes();
    v9 = ([v8 options] & 0x80) == 0;
  }

  else
  {
    v9 = 1;
  }

  [eventCopy timestamp];
  v11 = v10;
  [(UIEvent *)self->m_previousGlobeKeyEvent timestamp];
  v13 = v12;
  [(_UIKeyboardStateManager *)self setPreviousGlobeKeyEvent:0];
  v6 = 0;
  if (!v9 && v11 - v13 <= 0.9)
  {
LABEL_14:
    [(_UIKeyboardStateManager *)self showCursorAccessory];
    v14 = +[UIInputSwitcher sharedInstance];
    v15 = [v14 handleSwitchingKeyEvent:eventCopy];

    if (v15)
    {
      [(_UIKeyboardStateManager *)self setCapsLockIfNeeded];
      v6 = 1;
      goto LABEL_17;
    }

LABEL_16:
    v6 = 0;
  }

LABEL_17:

  return v6;
}

- (BOOL)handleVerticalArrow:(BOOL)arrow shiftDown:(BOOL)down beforePublicKeyCommands:(BOOL)commands testOnly:(BOOL)only isVerticalCandidate:(BOOL)candidate hasCandidatesForTypedInput:(BOOL)input inputDelegateCommandEnabled:(BOOL)enabled canHandleInputDelegateCommand:(id)self0 savedHistory:(id)self1 keyCommandTypeHandled:(unint64_t *)self2 keyEvent:(id)self3
{
  inputCopy = input;
  candidateCopy = candidate;
  downCopy = down;
  arrowCopy = arrow;
  commandCopy = command;
  historyCopy = history;
  eventCopy = event;
  liveConversionEnabled = [(_UIKeyboardStateManager *)self liveConversionEnabled];
  if ([(_UIKeyboardStateManager *)self _hasMarkedText])
  {
    if (!only && [(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost])
    {
      remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      LOBYTE(v24) = [remoteTextInputPartner synchronousForwardKeyCommandsBeforePublicToUIHost:eventCopy];

      goto LABEL_32;
    }

    if (candidateCopy)
    {
      inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
      supportsSetPhraseBoundary = [inputManagerState supportsSetPhraseBoundary];

      if (supportsSetPhraseBoundary)
      {
        if (only)
        {
LABEL_31:
          LOBYTE(v24) = 1;
          goto LABEL_32;
        }

        v29 = liveConversionEnabled & downCopy;
        v30 = !arrowCopy;
        selfCopy2 = self;
LABEL_28:
        [(_UIKeyboardStateManager *)selfCopy2 movePhraseBoundaryToDirection:v30 granularity:v29];
        goto LABEL_31;
      }
    }

    if (!inputCopy)
    {
      if (!liveConversionEnabled)
      {
        goto LABEL_31;
      }

      inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
      supportsSetPhraseBoundary2 = [inputManagerState2 supportsSetPhraseBoundary];

      if (!supportsSetPhraseBoundary2)
      {
        goto LABEL_31;
      }

      if (handled)
      {
        *handled = 2;
      }

      if (only)
      {
        goto LABEL_31;
      }

      v30 = !arrowCopy;
      selfCopy2 = self;
      v29 = 4;
      goto LABEL_28;
    }

    if (handled)
    {
      *handled = 2;
    }

    LOBYTE(v24) = 1;
    if ([(UIKeyboardCandidateList *)self->m_candidateList hasCandidates]&& !only)
    {
      [(UIKeyboardCandidateList *)self->m_candidateList showCandidateInForwardDirection:arrowCopy granularity:!liveConversionEnabled];
    }
  }

  else
  {
    LOBYTE(v24) = !enabled;
    if (enabled && !commands)
    {
      if (+[UIKeyboard isKeyboardProcess])
      {
        inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
        shouldRespectForwardingInputDelegate = [inputDelegateManager shouldRespectForwardingInputDelegate];

        if ((shouldRespectForwardingInputDelegate & 1) == 0)
        {
          if (!only)
          {
            [(_UIKeyboardStateManager *)self forwardKeyboardEventBackToDestination:eventCopy];
          }

          goto LABEL_31;
        }
      }

      v24 = commandCopy[2](commandCopy, sel__moveDown_withHistory_);
      if (v24 && !only)
      {
        v36[0] = MEMORY[0x1E69E9820];
        v36[1] = 3221225472;
        v36[2] = __239___UIKeyboardStateManager_handleVerticalArrow_shiftDown_beforePublicKeyCommands_testOnly_isVerticalCandidate_hasCandidatesForTypedInput_inputDelegateCommandEnabled_canHandleInputDelegateCommand_savedHistory_keyCommandTypeHandled_keyEvent___block_invoke;
        v36[3] = &unk_1E70F67F8;
        v38 = arrowCopy;
        v36[4] = self;
        v39 = downCopy;
        v37 = historyCopy;
        [(_UIKeyboardStateManager *)self performBlockWithTextInputChangesIgnoredForNonMacOS:v36];
      }
    }
  }

LABEL_32:

  return v24;
}

- (BOOL)inputUIHandleTabWithShift:(BOOL)shift testOnly:(BOOL)only
{
  shiftCopy = shift;
  candidateList = [(_UIKeyboardStateManager *)self candidateList];
  if (objc_opt_respondsToSelector())
  {
    candidateList2 = [(_UIKeyboardStateManager *)self candidateList];
    v9 = [candidateList2 handleTabKeyWithShift:shiftCopy];

    if (v9)
    {
      v10 = 1;
      goto LABEL_15;
    }
  }

  else
  {
  }

  if ([(_UIKeyboardStateManager *)self hasEditableMarkedText])
  {
    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    keyboardBehaviors = [inputManagerState keyboardBehaviors];
    _keyboardBehaviorState = [(_UIKeyboardStateManager *)self _keyboardBehaviorState];
    v14 = [keyboardBehaviors keyBehaviorsForState:_keyboardBehaviorState];

    v15 = [v14 tabKeyBehavior] - 5;
    v10 = v15 > 0xFFFFFFFFFFFFFFFDLL;
    if (v15 >= 0xFFFFFFFFFFFFFFFELL && !only)
    {
      candidateList3 = [(_UIKeyboardStateManager *)self candidateList];

      if (candidateList3)
      {
        candidateList4 = [(_UIKeyboardStateManager *)self candidateList];
        [candidateList4 showCandidateInForwardDirection:shiftCopy ^ 1 granularity:0];
      }

      else if ([(_UIKeyboardStateManager *)self liveConversionEnabled])
      {
        [(_UIKeyboardStateManager *)self movePhraseBoundaryToDirection:shiftCopy granularity:4];
      }

      v10 = 1;
    }
  }

  else
  {
    v10 = 0;
  }

LABEL_15:
  inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
  hasPrompt = [inlineTextCompletionController hasPrompt];

  if (hasPrompt)
  {
    inlineTextCompletionController2 = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
    v10 = 1;
    [inlineTextCompletionController2 acceptTextCompletionWithInteraction:1 wordTerminator:0];
  }

  return v10;
}

- (void)becomeFirstResponderAndMakeVisible:(BOOL)visible
{
  delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  v11 = delegateAsResponder;
  if (visible)
  {
    [delegateAsResponder _previousKeyResponder];
  }

  else
  {
    [delegateAsResponder _nextKeyResponder];
  }
  v6 = ;
  if (v6)
  {
    delegate = [(_UIKeyboardStateManager *)self delegate];

    if (v6 != delegate)
    {
      textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
      m_traitsForPreviousDelegate = self->m_traitsForPreviousDelegate;
      self->m_traitsForPreviousDelegate = textInputTraits;

      [v6 _becomeFirstResponderAndMakeVisible];
      v10 = self->m_traitsForPreviousDelegate;
      self->m_traitsForPreviousDelegate = 0;
    }
  }
}

- (BOOL)handleTabWithShift:(BOOL)shift beforePublicKeyCommands:(BOOL)commands isMoveAction:(BOOL)action testOnly:(BOOL)only
{
  onlyCopy = only;
  commandsCopy = commands;
  shiftCopy = shift;
  if ([(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost]&& commandsCopy)
  {
    v11 = objc_alloc_init(UIPhysicalKeyboardEvent);
    [(UIPhysicalKeyboardEvent *)v11 setKeyCommandCode:43];
    [(UIPhysicalKeyboardEvent *)v11 setShiftDown:shiftCopy];
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    v13 = [remoteTextInputPartner synchronousForwardKeyCommandsBeforePublicToUIHost:v11];
  }

  else
  {
    v13 = [(_UIKeyboardStateManager *)self inputUIHandleTabWithShift:shiftCopy testOnly:onlyCopy];
  }

  delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  if (!delegateAsResponder)
  {
    if ([UIApp _isSpringBoard])
    {
      delegateAsResponder = 0;
    }

    else
    {
      delegateAsResponder = +[UIWindow _applicationKeyWindow];
    }
  }

  _responderWindow = [delegateAsResponder _responderWindow];
  v16 = 0;
  if (dyld_program_sdk_at_least() && _responderWindow)
  {
    v17 = [_UIFocusSystemSceneComponent sceneComponentForEnvironment:_responderWindow];
    focusSystem = [v17 focusSystem];
    v16 = focusSystem != 0;
  }

  if (((v13 | v16) & 1) != 0 || commandsCopy)
  {
    goto LABEL_35;
  }

  if (!+[UIKeyboard isInputSystemUI])
  {
    if (shiftCopy)
    {
      _previousKeyResponder = [delegateAsResponder _previousKeyResponder];
    }

    else
    {
      if (!action)
      {
        delegateAsResponder2 = [(_UIKeyboardStateManager *)self delegateAsResponder];
        if (delegateAsResponder2)
        {
          v24 = delegateAsResponder2;
          textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
          isSingleLineDocument = [textInputTraits isSingleLineDocument];

          if (!isSingleLineDocument)
          {
            remoteTextInputPartner2 = 0;
            goto LABEL_33;
          }
        }
      }

      _previousKeyResponder = [delegateAsResponder _nextKeyResponder];
    }

    remoteTextInputPartner2 = _previousKeyResponder;
    if (_previousKeyResponder)
    {
      delegate = [(_UIKeyboardStateManager *)self delegate];

      LOBYTE(v13) = remoteTextInputPartner2 != delegate;
      if (remoteTextInputPartner2 == delegate || onlyCopy)
      {
        goto LABEL_34;
      }

      textInputTraits2 = [(_UIKeyboardStateManager *)self textInputTraits];
      m_traitsForPreviousDelegate = self->m_traitsForPreviousDelegate;
      self->m_traitsForPreviousDelegate = textInputTraits2;

      [remoteTextInputPartner2 _becomeFirstResponderAndMakeVisible];
      v22 = self->m_traitsForPreviousDelegate;
      self->m_traitsForPreviousDelegate = 0;
      LOBYTE(v13) = 1;
      goto LABEL_31;
    }

LABEL_33:
    LOBYTE(v13) = 0;
    goto LABEL_34;
  }

  if (shiftCopy)
  {
    hasPreviousKeyResponder = [(_UIKeyboardStateManager *)self hasPreviousKeyResponder];
  }

  else
  {
    hasPreviousKeyResponder = [(_UIKeyboardStateManager *)self hasNextKeyResponder];
  }

  LOBYTE(v13) = hasPreviousKeyResponder;
  if (hasPreviousKeyResponder && !onlyCopy)
  {
    remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    v22 = [MEMORY[0x1E696AD98] numberWithBool:shiftCopy];
    [remoteTextInputPartner2 forwardKeyboardOperation:sel_becomeFirstResponderAndMakeVisible_ object:v22];
LABEL_31:

LABEL_34:
  }

LABEL_35:

  return v13;
}

- (void)handleStringInput:(id)input withFlags:(unint64_t)flags withInputManagerHint:(id)hint executionContext:(id)context
{
  inputCopy = input;
  hintCopy = hint;
  contextCopy = context;
  if ([inputCopy length])
  {
    if ([inputCopy characterAtIndex:0] == 46 && objc_msgSend(inputCopy, "length") >= 2 && (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v12 = objc_claimAutoreleasedReturnValue(), v13 = objc_msgSend(v12, "_characterBeforeCaretSelection"), v12, v13 == 46))
    {
      v14 = [inputCopy substringFromIndex:1];

      v15 = v14;
    }

    else
    {
      v15 = inputCopy;
    }

    inputCopy = v15;
    [(_UIKeyboardStateManager *)self addInputString:v15 withFlags:flags withInputManagerHint:hintCopy executionContext:contextCopy];
  }

  else
  {
    [contextCopy returnExecutionToParent];
  }
}

- (BOOL)acceptInputString:(id)string
{
  stringCopy = string;
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  if (inputManagerState)
  {
    inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
    v7 = [inputManagerState2 acceptInputString:stringCopy];
  }

  else
  {
    v7 = 1;
  }

  return v7;
}

- (void)setPreviousInputString:(id)string
{
  v4 = [string copy];
  m_previousInputString = self->m_previousInputString;
  self->m_previousInputString = v4;
}

- (void)setPreviousGlobeKeyEvent:(id)event
{
  _cloneEvent = [event _cloneEvent];
  m_previousGlobeKeyEvent = self->m_previousGlobeKeyEvent;
  self->m_previousGlobeKeyEvent = _cloneEvent;
}

- (void)updateKeyboardStateForReplacingText:(id)text withText:(id)withText
{
  withTextCopy = withText;
  textCopy = text;
  documentState = [(_UIKeyboardStateManager *)self documentState];
  v8 = [documentState documentStateAfterReplacingText:textCopy withText:withTextCopy];

  [(_UIKeyboardStateManager *)self setDocumentState:v8];
}

- (void)updateKeyboardStateForInsertion:(id)insertion
{
  insertionCopy = insertion;
  if (!-[_UIKeyboardStateManager showingEmojiSearch](self, "showingEmojiSearch") || ([insertionCopy _containsEmojiOnly] & 1) == 0)
  {
    documentState = [(_UIKeyboardStateManager *)self documentState];
    v5 = [documentState documentStateAfterInsertingText:insertionCopy];
    [(_UIKeyboardStateManager *)self setDocumentState:v5];
  }

  [(_UIKeyboardStateManager *)self clearInputForMarkedText];
}

- (void)moveCursorByAmount:(int64_t)amount
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager _moveCurrentSelection:amount];
}

- (void)deleteBackwardAndNotifyAtEnd:(BOOL)end deletionCount:(unint64_t)count reinsertTextInLoop:(BOOL)loop
{
  loopCopy = loop;
  endCopy = end;
  v9 = +[UIDictationLandingView activeInstance];
  hasActivePlaceholder = [v9 hasActivePlaceholder];

  if (hasActivePlaceholder)
  {
    v11 = +[UIDictationLandingView activeInstance];
    [v11 stopLanding];

    v14 = +[UIDictationController activeInstance];
    [v14 cancelDictation];
  }

  else
  {
    if (+[UIDictationController isRunning](UIDictationController, "isRunning") && !+[UIDictationController isRunningInTypeAndTalkMode](UIDictationController, "isRunningInTypeAndTalkMode") && !+[UIDictationController supportsInlineDelete])
    {
      v12 = +[UIDictationController activeInstance];
      [v12 cancelDictation];
    }

    [(_UIKeyboardStateManager *)self removeTextChoicePromptWithUnderline];
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    v14 = inputDelegateManager;
    if (count < 2)
    {
      [inputDelegateManager _deleteBackwardAndNotify:endCopy reinsertText:loopCopy];
    }

    else
    {
      [inputDelegateManager _deleteBackwardWhileOverridingContextAndNotifyAtEnd:endCopy deletionCount:count reinsertTextInLoop:loopCopy];
    }
  }
}

- (unint64_t)textLengthToDeleteBeforeSelectedRangeForSmartDelete
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  _textLengthToDeleteBeforeSelectedRangeForSmartDelete = [inputDelegateManager _textLengthToDeleteBeforeSelectedRangeForSmartDelete];

  return _textLengthToDeleteBeforeSelectedRangeForSmartDelete;
}

- (void)updateKeyboardStateForDeletion
{
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  v9 = inputSystemSourceSession;
  if (inputSystemSourceSession)
  {
    documentState = [inputSystemSourceSession documentState];
    v4DocumentState = [documentState documentState];
    contextBeforeInput = [v4DocumentState contextBeforeInput];
  }

  else
  {
    documentState = [(_UIKeyboardStateManager *)self documentState];
    contextBeforeInput = [documentState contextBeforeInput];
  }

  if ([contextBeforeInput length] && !objc_msgSend(contextBeforeInput, "_isNewlineOrReturn"))
  {
    documentState2 = [(_UIKeyboardStateManager *)self documentState];
    documentStateAfterDeletingBackward = [documentState2 documentStateAfterDeletingBackward];
    [(_UIKeyboardStateManager *)self setDocumentState:documentStateAfterDeletingBackward];
  }

  else
  {
    [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegate];
    [(_UIKeyboardStateManager *)self _requestInputManagerSync];
  }

  [(_UIKeyboardStateManager *)self clearInputForMarkedText];
}

- (BOOL)_canDeleteForward
{
  if (![(_UIKeyboardStateManager *)self _delegateRequiresKeyEvents])
  {
    return 1;
  }

  delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  _responderForEditing = [delegateAsResponder _responderForEditing];
  if ([_responderForEditing canPerformAction:sel__deleteForwardAndNotify_ withSender:0])
  {
    v5 = 1;
  }

  else
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    v5 = [inputDelegateManager canHandleInputDelegateCommandAction:1];
  }

  return v5;
}

- (BOOL)deleteForwardAndNotify:(BOOL)notify producedByDeleteInput:(BOOL)input
{
  notifyCopy = notify;
  _canDeleteForward = [(_UIKeyboardStateManager *)self _canDeleteForward];
  if (_canDeleteForward)
  {
    if (+[UIKeyboard isKeyboardProcess])
    {
      self->m_suppressingDocumentAssertions = 1;
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v9 = [inputDelegateManager _deleteForwardAndNotify:notifyCopy];

      self->m_suppressingDocumentAssertions = 0;
      if (v9)
      {
        v13[0] = MEMORY[0x1E69E9820];
        v13[1] = 3221225472;
        v13[2] = __72___UIKeyboardStateManager_deleteForwardAndNotify_producedByDeleteInput___block_invoke;
        v13[3] = &__block_descriptor_33_e26_v16__0__TIKeyboardOutput_8l;
        inputCopy = input;
        [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v13];
        LOBYTE(_canDeleteForward) = 1;
      }

      else
      {
        LOBYTE(_canDeleteForward) = 0;
      }
    }

    else
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v11 = [inputDelegateManager2 _deleteForwardAndNotify:notifyCopy];

      LOBYTE(_canDeleteForward) = v11;
    }
  }

  return _canDeleteForward;
}

- (BOOL)isCallingInputDelegate
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  insideKeyInputDelegateCall = [inputDelegateManager insideKeyInputDelegateCall];

  return insideKeyInputDelegateCall;
}

- (BOOL)_handleKeyInputMethodCommandForEvent:(id)event canHandleAppKeyCommand:(BOOL)command
{
  eventCopy = event;
  v7 = [(_UIKeyboardStateManager *)self _handleKeyCommandCommon:eventCopy options:2];
  if (v7 == 2)
  {
    [(_UIKeyboardStateManager *)self _handleKeyCommandCommon:eventCopy options:0];
    v8 = 1;
    self->m_webEventWasHandledByInputManager = 1;
    goto LABEL_21;
  }

  if (v7 != 1 && (v7 || !command))
  {
    _modifiedInput = [eventCopy _modifiedInput];
    if (!-[_UIKeyboardStateManager _shouldEmitString:forKeyEvent:](self, "_shouldEmitString:forKeyEvent:", _modifiedInput, eventCopy) || !-[_UIKeyboardStateManager _isValidKeyInput:](self, "_isValidKeyInput:", _modifiedInput) || !-[_UIKeyboardStateManager _hasMarkedText](self, "_hasMarkedText") && (([_modifiedInput _isNewlineOrReturn] & 1) != 0 || (objc_msgSend(_modifiedInput, "_isDelete") & 1) != 0 || (objc_msgSend(_modifiedInput, "isEqualToString:", @"\t") & 1) != 0))
    {
      goto LABEL_19;
    }

    v10 = [(_UIKeyboardStateManager *)self shouldAllowRepeatEvent:eventCopy];
    if (![eventCopy _isARepeat] || v10)
    {
      if (![(_UIKeyboardStateManager *)self usesCandidateSelection]|| ([(TIKeyboardState *)self->m_keyboardState longPredictionListEnabled]& 1) != 0)
      {
LABEL_19:
        v8 = 0;
        goto LABEL_20;
      }

      if (qword_1ED49D228 != -1)
      {
        dispatch_once(&qword_1ED49D228, &__block_literal_global_1300);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      v13[0] = MEMORY[0x1E69E9820];
      v13[1] = 3221225472;
      v13[2] = __87___UIKeyboardStateManager__handleKeyInputMethodCommandForEvent_canHandleAppKeyCommand___block_invoke_3;
      v13[3] = &unk_1E70FD208;
      v13[4] = self;
      v14 = _modifiedInput;
      v15 = eventCopy;
      [taskQueue addTask:v13 breadcrumb:qword_1ED49D220];
    }

    v8 = 1;
    self->m_webEventWasHandledByInputManager = 1;
LABEL_20:

    goto LABEL_21;
  }

  v8 = 0;
LABEL_21:

  return v8;
}

- (BOOL)handleKeyInputMethodCommandForCurrentEvent
{
  if (self->m_webEventIsKeyDown)
  {
    eventForCurrentWebEvent = [(_UIKeyboardStateManager *)self eventForCurrentWebEvent];
    if (eventForCurrentWebEvent)
    {
      v4 = [UIApp _hasKeyboardShortcutForKeyboardEvent:eventForCurrentWebEvent];
      if ([(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost])
      {
        remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
        self->m_webEventWasHandledByInputManager = [remoteTextInputPartner synchronousForwardKeyInputMethodCommandEventToUIHost:eventForCurrentWebEvent canHandleAppKeyCommand:v4];

        m_webEventWasHandledByInputManager = self->m_webEventWasHandledByInputManager;
      }

      else
      {
        m_webEventWasHandledByInputManager = [(_UIKeyboardStateManager *)self _handleKeyInputMethodCommandForEvent:eventForCurrentWebEvent canHandleAppKeyCommand:v4];
        self->m_webEventWasHandledByInputManager = m_webEventWasHandledByInputManager;
      }
    }

    else
    {
      m_webEventWasHandledByInputManager = 0;
    }
  }

  else
  {
    return 0;
  }

  return m_webEventWasHandledByInputManager;
}

- (BOOL)handleKeyTextCommandForCurrentEvent
{
  if (self->m_webEventWasHandledAsKeyCommand || self->m_webEventWasHandledByInputManager)
  {
    return 0;
  }

  else
  {
    eventForCurrentWebEvent = [(_UIKeyboardStateManager *)self eventForCurrentWebEvent];
    if ([eventForCurrentWebEvent _isKeyDown])
    {
      v5 = [UIApp _currentKeyboardShortcutInvocationForKeyboardEvent:eventForCurrentWebEvent];
      keyboardShortcutLeaf = [v5 keyboardShortcutLeaf];

      if ([keyboardShortcutLeaf _wantsPriorityOverSystemBehavior:1])
      {
        m_webEventWasHandledAsKeyCommand = 0;
      }

      else
      {
        self->m_inHandleKeyTextCommandForCurrentEvent = 1;
        if ([(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost])
        {
          remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
          self->m_webEventWasHandledAsKeyCommand = [remoteTextInputPartner synchronousForwardKeyCommandsToUIHost:eventForCurrentWebEvent];

          m_webEventWasHandledAsKeyCommand = self->m_webEventWasHandledAsKeyCommand;
        }

        else
        {
          m_webEventWasHandledAsKeyCommand = [(_UIKeyboardStateManager *)self _handleKeyCommand:eventForCurrentWebEvent];
          self->m_webEventWasHandledAsKeyCommand = m_webEventWasHandledAsKeyCommand;
        }

        self->m_inHandleKeyTextCommandForCurrentEvent = 0;
      }
    }

    else
    {
      m_webEventWasHandledAsKeyCommand = 0;
    }
  }

  return m_webEventWasHandledAsKeyCommand;
}

- (BOOL)handleKeyAppCommandForCurrentEvent
{
  if (self->m_webEventWasHandledAsKeyCommand || self->m_webEventWasHandledByInputManager)
  {
    return 0;
  }

  eventForCurrentWebEvent = [(_UIKeyboardStateManager *)self eventForCurrentWebEvent];
  if ([eventForCurrentWebEvent _isKeyDown])
  {
    if (self->m_inHandleKeyAppCommandForCurrentEvent || self->m_inHandleKeyTextCommandForCurrentEvent)
    {
      v3 = 1;
    }

    else
    {
      v6 = [UIApp _currentKeyboardShortcutInvocationForKeyboardEvent:eventForCurrentWebEvent];
      keyboardShortcutLeaf = [v6 keyboardShortcutLeaf];
      v8 = keyboardShortcutLeaf;
      if (keyboardShortcutLeaf && ([keyboardShortcutLeaf _wantsPriorityOverSystemBehavior:1] & 1) == 0 && (objc_msgSend(v6, "originatingResponder"), v9 = objc_claimAutoreleasedReturnValue(), IsLikelyToUnintentionallyConflictWithTextInputResponderWithOriginatingResponder = _UIMenuLeafIsLikelyToUnintentionallyConflictWithTextInputResponderWithOriginatingResponder(v8, 0, v9), v9, (IsLikelyToUnintentionallyConflictWithTextInputResponderWithOriginatingResponder & 1) != 0))
      {
        v3 = 0;
      }

      else
      {
        self->m_inHandleKeyAppCommandForCurrentEvent = 1;
        v3 = [UIApp _handleKeyboardShortcutForKeyboardEvent:eventForCurrentWebEvent allowsRepeat:0];
        self->m_webEventWasHandledAsKeyCommand = v3;
        self->m_inHandleKeyAppCommandForCurrentEvent = 0;
      }
    }
  }

  else
  {
    v3 = 0;
  }

  return v3;
}

- (void)addInputString:(id)string fromVariantKey:(BOOL)key
{
  if (key)
  {
    v4 = 2;
  }

  else
  {
    v4 = 0;
  }

  [(_UIKeyboardStateManager *)self addInputString:string withFlags:v4];
}

- (id)inputEventForInputString:(id)string
{
  stringCopy = string;
  v5 = objc_alloc_init(MEMORY[0x1E69D95F8]);
  if (![(_UIKeyboardStateManager *)self isInHardwareKeyboardMode])
  {
    if ([(_UIKeyboardStateManager *)self callLayoutIgnoresShiftState])
    {
      goto LABEL_13;
    }

    [v5 setUppercase:self->m_shift];
    m_autoshift = self->m_autoshift;
    goto LABEL_12;
  }

  if (self->m_autoshift)
  {
    [v5 setAutoshifted:1];
    v6 = MEMORY[0x1E695DF58];
    v7 = +[UIKeyboardInputModeController sharedInputModeController];
    currentInputMode = [v7 currentInputMode];
    languageWithRegion = [currentInputMode languageWithRegion];
    v10 = [v6 localeWithLocaleIdentifier:languageWithRegion];
    v11 = [stringCopy uppercaseStringWithLocale:v10];

    stringCopy = v11;
  }

  if (stringCopy)
  {
    uppercaseLetterCharacterSet = [MEMORY[0x1E696AB08] uppercaseLetterCharacterSet];
    v13 = [stringCopy rangeOfCharacterFromSet:uppercaseLetterCharacterSet];

    v14 = v13 == 0;
  }

  else
  {
    v14 = 0;
  }

  [v5 setUppercase:v14];
  if ([v5 isAutoshifted] && (objc_msgSend(v5, "isUppercase") & 1) == 0)
  {
    m_autoshift = 0;
LABEL_12:
    [v5 setAutoshifted:m_autoshift];
  }

LABEL_13:
  [v5 setString:stringCopy];

  return v5;
}

- (void)updateDoubleSpacePeriodStateForCharacter:(unsigned int)character
{
  if (self->m_doubleSpacePeriodWasAppliedInCurrentContext)
  {
    if (TICharEstablishesContextForDoubleSpacePeriod())
    {
      self->m_doubleSpacePeriodWasAppliedInCurrentContext = 0;
    }
  }
}

- (void)updateDoubleSpacePeriodStateForString:(id)string
{
  stringCopy = string;
  v5 = stringCopy;
  if (self->m_doubleSpacePeriodWasAppliedInCurrentContext)
  {
    v9 = stringCopy;
    v6 = [stringCopy length];
    v5 = v9;
    if (v6)
    {
      v7 = [v9 characterAtIndex:0];
      if ([v9 length] == 2 && (v7 & 0xFC00) == 0xD800)
      {
        v8 = [v9 characterAtIndex:1];
        if ((v8 & 0xFC00) == 0xDC00)
        {
          v7 = (v8 + (v7 << 10) - 56613888);
        }

        else
        {
          v7 = v7;
        }
      }

      [(_UIKeyboardStateManager *)self updateDoubleSpacePeriodStateForCharacter:v7];
      v5 = v9;
    }
  }
}

- (BOOL)willDoubleSpacePeriodForInputString:(id)string afterSpace:(BOOL)space elapsedTime:(double)time
{
  spaceCopy = space;
  stringCopy = string;
  if (!self->m_doubleSpacePeriodPreference)
  {
    goto LABEL_10;
  }

  v9 = 0;
  if ([(UITextInputTraits *)self->m_traits isSecureTextEntry]|| !spaceCopy)
  {
    goto LABEL_11;
  }

  if (![stringCopy _isPlainSpace] || (-[_UIKeyboardStateManager inputManagerState](self, "inputManagerState"), v10 = objc_claimAutoreleasedReturnValue(), v11 = objc_msgSend(v10, "nextInputWouldStartSentence"), v10, (v11 & 1) != 0) || (-[_UIKeyboardStateManager inputDelegate](self, "inputDelegate"), v12 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v12, "_characterInRelationToCaretSelection:", 4294967294), v12, !TICharEstablishesContextForDoubleSpacePeriod()))
  {
LABEL_10:
    v9 = 0;
    goto LABEL_11;
  }

  v9 = 0;
  if (time <= 1.2 && !self->m_doubleSpacePeriodWasAppliedInCurrentContext)
  {
    v9 = 1;
    self->m_doubleSpacePeriodWasAppliedInCurrentContext = 1;
  }

LABEL_11:

  return v9;
}

- (BOOL)shouldDeleteAutospaceBeforeTerminator:(id)terminator
{
  terminatorCopy = terminator;
  if ([terminatorCopy isEqualToString:@" "])
  {
    goto LABEL_3;
  }

  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  v6 = [inputManagerState shouldDeleteAutospaceBeforeTerminator:terminatorCopy];

  if (v6)
  {
    goto LABEL_3;
  }

  textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
  if ([textInputTraits keyboardType] != 7)
  {

LABEL_9:
    v7 = 0;
    goto LABEL_4;
  }

  v10 = [terminatorCopy isEqualToString:@"@"];

  if ((v10 & 1) == 0)
  {
    goto LABEL_9;
  }

LABEL_3:
  v7 = 1;
LABEL_4:

  return v7;
}

- (id)handleDeleteAutospaceForInputString:(id)string afterSpace:(BOOL)space
{
  spaceCopy = space;
  stringCopy = string;
  if ([(_UIKeyboardStateManager *)self usesAutocorrectionLists])
  {
    if (!spaceCopy)
    {
LABEL_9:
      v7 = 0;
      goto LABEL_10;
    }

LABEL_6:
    if (self->m_didAutomaticallyInsertSpace && [(_UIKeyboardStateManager *)self shouldDeleteAutospaceBeforeTerminator:stringCopy])
    {
      self->m_didAutomaticallyInsertSpace = 0;
      v7 = stringCopy;
      goto LABEL_10;
    }

    goto LABEL_9;
  }

  v7 = 0;
  if ([(_UIKeyboardStateManager *)self shouldShowLongPredictionList]&& spaceCopy)
  {
    goto LABEL_6;
  }

LABEL_10:

  return v7;
}

- (id)handleReplacement:(id)replacement forSpaceAndInput:(id)input
{
  inputCopy = input;
  replacementCopy = replacement;
  v8 = [replacementCopy rangeOfComposedCharacterSequenceAtIndex:{objc_msgSend(replacementCopy, "length") - 1}];
  v10 = [replacementCopy substringWithRange:{v8, v9}];
  [inputCopy setString:v10];

  v11 = [replacementCopy substringToIndex:v8];

  if (([v11 isEqualToString:@" "] & 1) == 0)
  {
    acceptedCandidate = [inputCopy acceptedCandidate];

    if (!acceptedCandidate)
    {
      v13 = [MEMORY[0x1E69D95F0] candidateWithCandidate:v11 forInput:@" "];
      [inputCopy setAcceptedCandidate:v13];

      if ([v11 length])
      {
        v17[0] = MEMORY[0x1E69E9820];
        v17[1] = 3221225472;
        v17[2] = __62___UIKeyboardStateManager_handleReplacement_forSpaceAndInput___block_invoke_2;
        v17[3] = &unk_1E70FD608;
        v14 = inputCopy;
        v18 = v14;
        [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v17];
        acceptedCandidate2 = [v14 acceptedCandidate];
        [(_UIKeyboardStateManager *)self applyAutocorrection:acceptedCandidate2];
      }

      else
      {
        [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:&__block_literal_global_1307];
        [(_UIKeyboardStateManager *)self deleteBackwardAndNotify:0];
      }
    }
  }

  return inputCopy;
}

- (BOOL)shouldAcceptCandidate:(id)candidate beforeInputString:(id)string
{
  candidateCopy = candidate;
  stringCopy = string;
  candidate = [candidateCopy candidate];
  if ([candidate length] || objc_msgSend(candidateCopy, "slotID"))
  {
  }

  else
  {
    customInfoType = [candidateCopy customInfoType];

    if (!customInfoType)
    {
      goto LABEL_5;
    }
  }

  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  v10 = [inputManagerState shouldSuppressAutocorrectionWithTerminator:stringCopy];

  if (v10)
  {
LABEL_5:
    v11 = 0;
    goto LABEL_12;
  }

  if (([candidateCopy isForShortcutConversion] & 1) == 0 && objc_msgSend(stringCopy, "length") && (objc_msgSend(candidateCopy, "input"), (v12 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    v13 = v12;
    candidate2 = [candidateCopy candidate];
    if (candidate2)
    {
      v15 = candidate2;
      input = [candidateCopy input];
      v17 = [input stringByAppendingString:stringCopy];
      candidate3 = [candidateCopy candidate];
      v11 = [candidate3 rangeOfString:v17 options:9] == 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v11 = 1;
    }
  }

  else
  {
    v11 = 1;
  }

LABEL_12:

  return v11;
}

- (void)removeSpaceAfterEmojiForInputString:(id)string
{
  if (self->m_didAutomaticallyInsertSpace && [string _containsEmoji])
  {
    documentState = [(_UIKeyboardStateManager *)self documentState];
    contextBeforeInput = [documentState contextBeforeInput];

    if ([contextBeforeInput length] >= 2)
    {
      v5 = [contextBeforeInput substringFromIndex:{objc_msgSend(contextBeforeInput, "length") - 1}];
      if ([v5 _isPlainSpace])
      {
        v6 = [contextBeforeInput rangeOfComposedCharacterSequenceAtIndex:{objc_msgSend(contextBeforeInput, "length") - 2}];
        v8 = [contextBeforeInput substringWithRange:{v6, v7}];

        if ([v8 _containsEmoji])
        {
          [(_UIKeyboardStateManager *)self deleteBackwardAndNotify:0];
        }
      }

      else
      {
        v8 = v5;
      }
    }
  }
}

- (void)_scheduleInputAdditionOrDeletion:(id)deletion
{
  deletionCopy = deletion;
  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  if ([taskQueue isMainThreadExecutingTask])
  {

LABEL_4:
    [(_UIKeyboardStateManager *)self setExternalTask:deletionCopy];
    goto LABEL_8;
  }

  delegateRequiresKeyEvents = [(_UIKeyboardStateManager *)self delegateRequiresKeyEvents];

  if (delegateRequiresKeyEvents)
  {
    goto LABEL_4;
  }

  if (qword_1ED49D238 != -1)
  {
    dispatch_once(&qword_1ED49D238, &__block_literal_global_1309);
  }

  taskQueue2 = [(_UIKeyboardStateManager *)self taskQueue];
  [taskQueue2 addTask:deletionCopy breadcrumb:qword_1ED49D230];

LABEL_8:
}

- (void)addInputString:(id)string withFlags:(unint64_t)flags
{
  stringCopy = string;
  v8[0] = MEMORY[0x1E69E9820];
  v8[1] = 3221225472;
  v8[2] = __52___UIKeyboardStateManager_addInputString_withFlags___block_invoke;
  v8[3] = &unk_1E70FD8B0;
  v8[4] = self;
  v9 = stringCopy;
  flagsCopy = flags;
  v7 = stringCopy;
  [(_UIKeyboardStateManager *)self _scheduleInputAdditionOrDeletion:v8];
}

- (void)addInputString:(id)string withFlags:(unint64_t)flags withInputManagerHint:(id)hint
{
  stringCopy = string;
  hintCopy = hint;
  v12[0] = MEMORY[0x1E69E9820];
  v12[1] = 3221225472;
  v12[2] = __73___UIKeyboardStateManager_addInputString_withFlags_withInputManagerHint___block_invoke;
  v12[3] = &unk_1E70FD8D8;
  v12[4] = self;
  v13 = stringCopy;
  v14 = hintCopy;
  flagsCopy = flags;
  v10 = hintCopy;
  v11 = stringCopy;
  [(_UIKeyboardStateManager *)self _scheduleInputAdditionOrDeletion:v12];
}

- (void)_addInputString:(id)string withFlags:(unint64_t)flags withInputManagerHint:(id)hint withInputSource:(int64_t)source
{
  stringCopy = string;
  hintCopy = hint;
  if (qword_1ED49D248 != -1)
  {
    dispatch_once(&qword_1ED49D248, &__block_literal_global_1313);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v16[0] = MEMORY[0x1E69E9820];
  v16[1] = 3221225472;
  v16[2] = __90___UIKeyboardStateManager__addInputString_withFlags_withInputManagerHint_withInputSource___block_invoke_3;
  v16[3] = &unk_1E70FD900;
  v16[4] = self;
  v17 = stringCopy;
  v18 = hintCopy;
  flagsCopy = flags;
  sourceCopy = source;
  v13 = qword_1ED49D240;
  v14 = hintCopy;
  v15 = stringCopy;
  [taskQueue addTask:v16 breadcrumb:v13];
}

+ (BOOL)_isInputEligibleForSpaceAutodelete:(id)autodelete
{
  autodeleteCopy = autodelete;
  string = [autodeleteCopy string];
  if (![(__CFString *)string isEqualToString:@" "])
  {
    v18 = 0;
LABEL_16:

    goto LABEL_17;
  }

  acceptedCandidate = [autodeleteCopy acceptedCandidate];

  if (acceptedCandidate)
  {
    acceptedCandidate2 = [autodeleteCopy acceptedCandidate];
    input = [acceptedCandidate2 input];
    lowercaseString = [input lowercaseString];
    v9 = lowercaseString;
    if (lowercaseString)
    {
      v10 = lowercaseString;
    }

    else
    {
      v10 = &stru_1EFB14550;
    }

    string = v10;

    acceptedCandidate3 = [autodeleteCopy acceptedCandidate];
    candidate = [acceptedCandidate3 candidate];
    lowercaseString2 = [candidate lowercaseString];
    v14 = lowercaseString2;
    if (lowercaseString2)
    {
      v15 = lowercaseString2;
    }

    else
    {
      v15 = &stru_1EFB14550;
    }

    v16 = v15;

    if ([(__CFString *)string length]&& ![(__CFString *)v16 hasPrefix:string])
    {
      v18 = 0;
    }

    else
    {
      v17 = [(__CFString *)string length];
      v18 = v17 < [(__CFString *)v16 length];
    }

    goto LABEL_16;
  }

  v18 = 0;
LABEL_17:

  return v18;
}

- (void)addInputString:(id)string withFlags:(unint64_t)flags withInputManagerHint:(id)hint withInputSource:(int64_t)source executionContext:(id)context
{
  stringCopy = string;
  hintCopy = hint;
  contextCopy = context;
  v15 = _UIKeyboardLog();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&dword_188A29000, v15, OS_LOG_TYPE_DEFAULT, "Keyboard adds a string", buf, 2u);
  }

  if ([(_UIKeyboardStateManager *)self isCurrentEditResponderWebKit]&& [(_UIKeyboardStateManager *)self shouldApplyKeyboardInputToUIHost])
  {
    eventForCurrentWebEvent = [(_UIKeyboardStateManager *)self eventForCurrentWebEvent];
    v17 = objc_alloc_init(NSClassFromString(&cfstr_Rtiinputoperat.isa));
    v18 = objc_alloc_init(MEMORY[0x1E695DF90]);
    [v18 setObject:stringCopy forKey:@"string"];
    v19 = [MEMORY[0x1E696AD98] numberWithUnsignedInteger:flags];
    [v18 setObject:v19 forKey:@"flags"];

    if (hintCopy)
    {
      v20 = hintCopy;
    }

    else
    {
      v20 = &stru_1EFB14550;
    }

    [v18 setObject:v20 forKey:@"inputManagerHint"];
    [v18 setObject:@"_addInputString:withFlags:withInputManagerHint:withInputSource:" forKey:@"selector"];
    v21 = [MEMORY[0x1E696AD98] numberWithInteger:{objc_msgSend(eventForCurrentWebEvent, "source")}];
    [v18 setObject:v21 forKey:@"source"];

    v22 = [v18 copy];
    [v17 setCustomInfo:v22];

    [v17 setCustomInfoType:0x1EFB7CA50];
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner performInputOperation:v17];

    [contextCopy returnExecutionToParent];
    goto LABEL_17;
  }

  v24 = +[UIKeyboardInputModeController sharedInputModeController];
  v25 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v25 currentInputMode];
  [v24 updateLastUsedInputMode:currentInputMode];

  [(_UIKeyboardStateManager *)self setDeleteWordLastDelete:-*MEMORY[0x1E695E460]];
  if (![(_UIKeyboardStateManager *)self _isValidKeyInput:stringCopy])
  {
    goto LABEL_16;
  }

  [(_UIKeyboardStateManager *)self removeSpaceAfterEmojiForInputString:stringCopy];
  if ((flags & 0x80) != 0)
  {
    if ([(_UIKeyboardStateManager *)self callShouldInsertText:stringCopy])
    {
      v32 = objc_alloc_init(MEMORY[0x1E69D9638]);
      [v32 setInsertionText:stringCopy];
      [(_UIKeyboardStateManager *)self performKeyboardOutput:v32];
      [(_UIKeyboardStateManager *)self updateReturnKey];
      [(_UIKeyboardStateManager *)self updateNoContentViews];
    }

    goto LABEL_16;
  }

  if (![(_UIKeyboardStateManager *)self acceptInputString:stringCopy])
  {
LABEL_16:
    [contextCopy returnExecutionToParent];
    goto LABEL_17;
  }

  v27 = [(_UIKeyboardStateManager *)self inputEventForInputString:stringCopy];
  [v27 setPopupVariant:(flags >> 1) & 1];
  [v27 setMultitap:(flags >> 2) & 1];
  [v27 setFlick:(flags >> 6) & 1];
  [v27 setGesture:(flags >> 8) & 1];
  [v27 setInputManagerHint:hintCopy];
  v28 = +[UIKBAnalyticsDispatcher sharedInstance];
  [v28 setNextCandidateReplacementSource:1];

  v36 = MEMORY[0x1E69E9820];
  v37 = 3221225472;
  v38 = __106___UIKeyboardStateManager_addInputString_withFlags_withInputManagerHint_withInputSource_executionContext___block_invoke;
  v39 = &unk_1E70F6B40;
  selfCopy = self;
  v41 = stringCopy;
  v42 = contextCopy;
  v29 = v27;
  v43 = v29;
  v30 = _Block_copy(&v36);
  v31 = v30;
  if (source)
  {
    [(_UIKeyboardStateManager *)self performOperations:v30 withTextInputSource:source, v36, v37, v38, v39, selfCopy, v41, v42];
  }

  else
  {
    (*(v30 + 2))(v30);
  }

  v33 = [(_UIKeyboardStateManager *)self inputDelegateManager:v36];
  hasText = [v33 hasText];

  if ((hasText & 1) == 0)
  {
    m_cachedAutofillMode = self->m_cachedAutofillMode;
    if (m_cachedAutofillMode == 2)
    {
      +[_UIKeyboardUsageTracking signupPasswordFromKeyboardIncrement];
    }

    else if (m_cachedAutofillMode == 1)
    {
      +[_UIKeyboardUsageTracking loginPasswordFromKeyboardIncrement];
    }
  }

LABEL_17:
}

- (void)addInputEvent:(id)event executionContext:(id)context
{
  eventCopy = event;
  contextCopy = context;
  string = [eventCopy string];
  m_changeTime = self->m_changeTime;
  [(_UIKeyboardStateManager *)self updateChangeTimeAndIncrementCount];
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  v12 = [inputManagerState stringEndsWord:string];

  if ([string isEqualToString:@"'"])
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    if ([autocorrectionController hasAutocorrection])
    {
      autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
      autocorrection = [autocorrectionController2 autocorrection];
      isForShortcutConversion = [autocorrection isForShortcutConversion];

      v12 |= isForShortcutConversion;
    }
  }

  if ([eventCopy isSynthesizedByAcceptingCandidate])
  {
    string2 = [eventCopy string];
    v18 = [string2 length] == 0;

    v12 |= v18;
  }

  _isPlainSpace = [(NSString *)self->m_previousInputString _isPlainSpace];
  [(_UIKeyboardStateManager *)self setPreviousInputString:string];
  self->m_acceptingCandidate = 0;
  [(_UIKeyboardStateManager *)self clearTransientState];
  if ((v12 & 1) == 0 || [(UITextInputTraits *)self->m_traits contentsIsSingleValue]|| ![(_UIKeyboardStateManager *)self hasAdvancedInputDelegate])
  {
    if (![(_UIKeyboardStateManager *)self callShouldInsertText:string])
    {
      [(_UIKeyboardStateManager *)self setShiftOffIfNeeded];
      [(_UIKeyboardStateManager *)self updateReturnKey];
      [(_UIKeyboardStateManager *)self updateNoContentViews];
      [(_UIKeyboardStateManager *)self clearInputForMarkedText];
      [contextCopy returnExecutionToParent];
      goto LABEL_22;
    }

    if ([(TIKeyboardInputManagerState *)self->m_inputManagerState shouldExtendPriorWord])
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      selectedTextRange = [inputDelegateManager selectedTextRange];
      _isRanged = [selectedTextRange _isRanged];

      if (_isRanged)
      {
        [(_UIKeyboardStateManager *)self willReplaceTextInRangedSelectionWithKeyboardInput];
      }
    }

    autocorrectionController3 = [(_UIKeyboardStateManager *)self autocorrectionController];
    [autocorrectionController3 clearAutocorrection];

    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager2 keyInputDelegate];

    [(_UIKeyboardStateManager *)self updateTextInputKeyboardSource];
    v31 = [(_UIKeyboardStateManager *)self handleDeleteAutospaceForInputString:string afterSpace:_isPlainSpace];
    if ([v31 length])
    {
      v32 = [(_UIKeyboardStateManager *)self handleReplacement:v31 forSpaceAndInput:eventCopy];

      eventCopy = v32;
    }

    v36 = MEMORY[0x1E69E9820];
    v37 = 3221225472;
    v38 = __58___UIKeyboardStateManager_addInputEvent_executionContext___block_invoke_2;
    v39 = &unk_1E70FD1B8;
    selfCopy = self;
    v41 = string;
    v33 = [contextCopy childWithContinuation:&v36];
    [(_UIKeyboardStateManager *)self handleKeyboardInput:eventCopy executionContext:v33, v36, v37, v38, v39, selfCopy];

    goto LABEL_20;
  }

  v20 = self->m_changeTime - m_changeTime;
  inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
  inputString = [inputManagerState2 inputString];
  inputManagerState3 = [(_UIKeyboardStateManager *)self inputManagerState];
  +[UITextChecker setString:isExemptFromChecker:](UITextChecker, "setString:isExemptFromChecker:", inputString, [inputManagerState3 inputStringIsExemptFromChecker]);

  if ([(_UIKeyboardStateManager *)self usesCandidateSelection]&& ![(_UIKeyboardStateManager *)self shouldShowLongPredictionList])
  {
    if (self->m_candidateList && (-[TIKeyboardCandidateResultSet candidates](self->m_candidateResultSet, "candidates"), v34 = objc_claimAutoreleasedReturnValue(), v35 = [v34 count], v34, v35))
    {
      keyInputDelegate = [(_UIKeyboardStateManager *)self acceptCurrentCandidateForInput:eventCopy];
      [(_UIKeyboardStateManager *)self setPreviousInputString:string];
    }

    else
    {
      keyInputDelegate = 0;
    }

    [(_UIKeyboardStateManager *)self addWordTerminator:eventCopy afterSpace:_isPlainSpace afterAcceptingCandidate:keyInputDelegate elapsedTime:contextCopy executionContext:v20];
LABEL_20:

    goto LABEL_22;
  }

  v42[0] = MEMORY[0x1E69E9820];
  v42[1] = 3221225472;
  v42[2] = __58___UIKeyboardStateManager_addInputEvent_executionContext___block_invoke;
  v42[3] = &unk_1E70FD928;
  v45 = a2;
  v42[4] = self;
  v43 = string;
  eventCopy = eventCopy;
  v44 = eventCopy;
  v47 = _isPlainSpace;
  v46 = v20;
  v24 = [contextCopy childWithContinuation:v42];
  [(_UIKeyboardStateManager *)self acceptAutocorrectionForWordTerminator:eventCopy executionContextPassingTIKeyboardCandidate:v24];

LABEL_22:
}

- (id)acceptAutocorrectionForWordTerminator:(id)terminator
{
  terminatorCopy = terminator;
  v12 = 0;
  v13 = &v12;
  v14 = 0x3032000000;
  v15 = __Block_byref_object_copy__36;
  v16 = __Block_byref_object_dispose__36;
  v17 = 0;
  if (qword_1ED49D258 != -1)
  {
    dispatch_once(&qword_1ED49D258, &__block_literal_global_1341);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v9[0] = MEMORY[0x1E69E9820];
  v9[1] = 3221225472;
  v9[2] = __65___UIKeyboardStateManager_acceptAutocorrectionForWordTerminator___block_invoke_3;
  v9[3] = &unk_1E70FD978;
  v9[4] = self;
  v6 = terminatorCopy;
  v10 = v6;
  v11 = &v12;
  [taskQueue performSingleTask:v9 breadcrumb:qword_1ED49D250];

  v7 = v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

- (void)acceptAutocorrectionForWordTerminator:(id)terminator executionContextPassingTIKeyboardCandidate:(id)candidate
{
  terminatorCopy = terminator;
  candidateCopy = candidate;
  if (!+[UIKeyboard doesSpacebarAcceptInlineTextCompletion](UIKeyboard, "doesSpacebarAcceptInlineTextCompletion") || ((-[_UIKeyboardStateManager inlineTextCompletionController](self, "inlineTextCompletionController"), v9 = objc_claimAutoreleasedReturnValue(), v10 = [v9 currentlyAcceptingInlineCompletionByDirectTap], v9, !v10) ? (v11 = 0) : (v11 = 2), -[_UIKeyboardStateManager inlineTextCompletionController](self, "inlineTextCompletionController"), v12 = objc_claimAutoreleasedReturnValue(), objc_msgSend(terminatorCopy, "string"), v13 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v12, "acceptTextCompletionWithInteraction:wordTerminator:outputHandledByCaller:", v11, v13, 1), autocorrection = objc_claimAutoreleasedReturnValue(), v13, v12, !autocorrection))
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    autocorrection = [autocorrectionController autocorrection];

    if (autocorrection)
    {
      inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
      [inlineTextCompletionController removeTextCompletionPrompt];
    }
  }

  string = [terminatorCopy string];
  v18 = [(_UIKeyboardStateManager *)self shouldAcceptCandidate:autocorrection beforeInputString:string];

  if (v18 && (-[_UIKeyboardStateManager autocorrectionPreferenceForTraits](self, "autocorrectionPreferenceForTraits") != 2 || ([terminatorCopy isSynthesizedByAcceptingCandidate] & 1) != 0 || objc_msgSend(autocorrection, "isForShortcutConversion")))
  {
    v21 = MEMORY[0x1E69E9820];
    v22 = 3221225472;
    v23 = __108___UIKeyboardStateManager_acceptAutocorrectionForWordTerminator_executionContextPassingTIKeyboardCandidate___block_invoke;
    v24 = &unk_1E70FD8D8;
    v28 = a2;
    selfCopy = self;
    v19 = autocorrection;
    v26 = v19;
    v27 = terminatorCopy;
    v20 = [candidateCopy childWithContinuation:&v21];
    [(_UIKeyboardStateManager *)self acceptAutocorrection:v19 executionContextPassingTIKeyboardCandidate:v20, v21, v22, v23, v24, selfCopy];
  }

  else
  {
    [(_UIKeyboardStateManager *)self didAcceptAutocorrection:0 inputCandidate:autocorrection wordTerminator:terminatorCopy];
    [(_UIKeyboardStateManager *)self setAutocorrection:0];
    [candidateCopy returnExecutionToParent];
  }
}

- (id)inputWordForTerminatorAtSelection
{
  documentState = [(_UIKeyboardStateManager *)self documentState];

  if (documentState)
  {
    documentState2 = [(_UIKeyboardStateManager *)self documentState];
    documentState = [documentState2 selectedText];

    if (!documentState)
    {
      documentState3 = [(_UIKeyboardStateManager *)self documentState];
      v7[0] = MEMORY[0x1E69E9820];
      v7[1] = 3221225472;
      v7[2] = __60___UIKeyboardStateManager_inputWordForTerminatorAtSelection__block_invoke;
      v7[3] = &unk_1E70FD9A0;
      v7[4] = self;
      documentState = [documentState3 inputStemWithTerminatorPredicate:v7];

      if (![documentState length])
      {

        documentState = 0;
      }
    }
  }

  return documentState;
}

- (void)didAcceptAutocorrection:(id)autocorrection inputCandidate:(id)candidate wordTerminator:(id)terminator learningFlagsMask:(unint64_t)mask
{
  autocorrectionCopy = autocorrection;
  candidateCopy = candidate;
  terminatorCopy = terminator;
  inputWordForTerminatorAtSelection = [(_UIKeyboardStateManager *)self inputWordForTerminatorAtSelection];
  if (inputWordForTerminatorAtSelection)
  {
    v14 = UIKeyboardGetCurrentInputMode();
    v15 = UIKeyboardInputModeGetIdentifierWithKeyboardLayouts(v14);

    v16 = TIStatisticGetKeyForInputMode();
    TIStatisticScalarIncrement();

    if ([autocorrectionCopy isContinuousPathConversion])
    {
      ++self->m_numCPwords;
    }

    if ([(_UIKeyboardStateManager *)self autocorrectionPreferenceForTraits]== 1)
    {
      v17 = TIStatisticGetKeyForInputMode();
      TIStatisticScalarIncrement();
    }

    if ([(_UIKeyboardStateManager *)self usesAutocorrectionLists])
    {
      v18 = TIStatisticGetKeyForInputMode();
      TIStatisticScalarIncrement();
    }

    if (self->m_layoutAllowsCP && [inputWordForTerminatorAtSelection length] >= 2 && self->m_numCPwords && (objc_msgSend(autocorrectionCopy, "isContinuousPathConversion") & 1) == 0 && (objc_msgSend(autocorrectionCopy, "isEmojiCandidate") & 1) == 0 && (objc_msgSend(autocorrectionCopy, "isPunctuationKeyCandidate") & 1) == 0 && (objc_msgSend(autocorrectionCopy, "isCompletionCandidate") & 1) == 0)
    {
      v19 = TIStatisticGetKeyForInputMode();
      TIStatisticScalarIncrement();
    }
  }

  if ([(UITextInputTraits *)self->m_traits isSingleLineDocument])
  {
    string = [terminatorCopy string];
    v21 = [string isEqualToString:@"\n"];
  }

  else
  {
    v21 = 0;
  }

  if (autocorrectionCopy)
  {
    if ((terminatorCopy == 0) | v21 & 1 && [(_UIKeyboardStateManager *)self nextCharacterIsWordCharacter])
    {
      if ((objc_opt_respondsToSelector() & 1) != 0 && ([autocorrectionCopy wordSeparator], v22 = objc_claimAutoreleasedReturnValue(), v22, v22))
      {
        m_inputManagerState = autocorrectionCopy;
      }

      else
      {
        m_inputManagerState = self->m_inputManagerState;
      }

      wordSeparator = [(TIKeyboardInputManagerState *)m_inputManagerState wordSeparator];
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v38 = inputDelegateManager;
      if (wordSeparator)
      {
        v39 = wordSeparator;
      }

      else
      {
        v39 = @" ";
      }

      [inputDelegateManager insertText:v39 updateInputSource:0];
    }

    selfCopy2 = self;
    v41 = autocorrectionCopy;
LABEL_44:
    [(_UIKeyboardStateManager *)selfCopy2 syncInputManagerToAcceptedAutocorrection:v41 forInput:terminatorCopy];
    goto LABEL_45;
  }

  if ((terminatorCopy == 0) | v21 & 1 && [(_UIKeyboardStateManager *)self nextCharacterIsWordCharacter])
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    _wordContainingCaretSelection = [inputDelegate _wordContainingCaretSelection];

    if (v21)
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager2 moveSelectionToEndOfWord];
    }

    inputWordForTerminatorAtSelection = _wordContainingCaretSelection;
  }

  if ([inputWordForTerminatorAtSelection length])
  {
    acceptedCandidate = [terminatorCopy acceptedCandidate];
    slotID = [acceptedCandidate slotID];

    if (!slotID)
    {
      if (candidateCopy)
      {
        v46 = 0;
        v47 = &v46;
        v48 = 0x2050000000;
        v29 = getTUITypedStringCandidateClass_softClass;
        v49 = getTUITypedStringCandidateClass_softClass;
        if (!getTUITypedStringCandidateClass_softClass)
        {
          v45[0] = MEMORY[0x1E69E9820];
          v45[1] = 3221225472;
          v45[2] = __getTUITypedStringCandidateClass_block_invoke;
          v45[3] = &unk_1E70F2F20;
          v45[4] = &v46;
          __getTUITypedStringCandidateClass_block_invoke(v45);
          v29 = v47[3];
        }

        v30 = v29;
        _Block_object_dispose(&v46, 8);
        if (objc_opt_isKindOfClass())
        {
          v31 = objc_alloc(MEMORY[0x1E69D95F0]);
          candidate = [candidateCopy candidate];
          input = [candidateCopy input];
          rawInput = [candidateCopy rawInput];
          v35 = [v31 initWithCandidate:candidate forInput:input rawInput:rawInput];

          candidateCopy = v35;
        }
      }

      else
      {
        candidateCopy = [MEMORY[0x1E69D95F0] candidateWithUnchangedInput:inputWordForTerminatorAtSelection];
      }

      if (objc_opt_respondsToSelector())
      {
        v42 = MEMORY[0x1E696AD98];
        v43 = candidateCopy;
        v44 = [v42 numberWithUnsignedInt:mask];
        [v43 performSelector:sel_setLearningFlags_ withObject:v44];
      }

      selfCopy2 = self;
      v41 = candidateCopy;
      goto LABEL_44;
    }
  }

LABEL_45:
}

- (void)syncInputManagerToAcceptedAutocorrection:(id)autocorrection forInput:(id)input
{
  autocorrectionCopy = autocorrection;
  inputCopy = input;
  if (![(UITextInputTraits *)self->m_traits isSecureTextEntry])
  {
    if (inputCopy)
    {
      [inputCopy setAcceptedCandidate:autocorrectionCopy];
    }

    else
    {
      [(_UIKeyboardStateManager *)self flushTouchEventWaitingForKeyInputEventIfNecessary];
      [(_UIKeyboardStateManager *)self textAccepted:autocorrectionCopy];
    }
  }
}

- (void)setDocumentStateForAutocorrection:(id)autocorrection
{
  autocorrectionCopy = autocorrection;
  candidate = [autocorrectionCopy candidate];
  documentState = [(_UIKeyboardStateManager *)self documentState];
  input = [autocorrectionCopy input];
  v7 = [input length];

  if (v7)
  {
    input2 = [autocorrectionCopy input];
    inputDelegate = [documentState documentStateAfterReplacingText:input2 withText:candidate];

    if (!inputDelegate)
    {
      v10 = objc_alloc(MEMORY[0x1E69D9590]);
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      contextBeforeInput = [documentState contextBeforeInput];
      v13 = [WeakRetained _normalizedStringForRangeComparison:contextBeforeInput];
      markedText = [documentState markedText];
      selectedText = [documentState selectedText];
      contextAfterInput = [documentState contextAfterInput];
      selectedRangeInMarkedText = [documentState selectedRangeInMarkedText];
      v19 = [v10 initWithContextBefore:v13 markedText:markedText selectedText:selectedText contextAfter:contextAfterInput selectedRangeInMarkedText:{selectedRangeInMarkedText, v18}];

      input3 = [autocorrectionCopy input];
      inputDelegate = [v19 documentStateAfterReplacingText:input3 withText:candidate];

      if (!inputDelegate)
      {
        goto LABEL_4;
      }
    }
  }

  else
  {
    inputDelegate = [documentState documentStateAfterInsertingText:candidate];
    if (!inputDelegate)
    {
LABEL_4:
      v21 = MEMORY[0x1E69D9590];
      inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
      v22 = [v21 documentStateOfDocument:inputDelegate];
      [(_UIKeyboardStateManager *)self setDocumentState:v22];

      goto LABEL_7;
    }
  }

  [(_UIKeyboardStateManager *)self setDocumentState:inputDelegate];
LABEL_7:
}

- (void)insertedEmojiFromPopover:(id)popover selectionMethod:(id)method
{
  popoverCopy = popover;
  [UIKBAnalyticsDispatcher emojiInsertedByMethod:method inputType:@"Popover"];
  emojiString = [popoverCopy emojiString];

  v8 = [(_UIKeyboardStateManager *)self inputEventForInputString:emojiString];

  [v8 setPopupVariant:1];
  [(_UIKeyboardStateManager *)self handleEmojiInput:v8 keyboardState:self->m_keyboardState];
}

- (void)insertedAccentVariantFromPopover:(id)popover
{
  popoverCopy = popover;
  if (qword_1ED49D268 != -1)
  {
    dispatch_once(&qword_1ED49D268, &__block_literal_global_1353);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v12[0] = MEMORY[0x1E69E9820];
  v12[1] = 3221225472;
  v12[2] = __60___UIKeyboardStateManager_insertedAccentVariantFromPopover___block_invoke_3;
  v12[3] = &unk_1E70FD058;
  v12[4] = self;
  [taskQueue performSingleTask:v12 breadcrumb:qword_1ED49D260];

  if (qword_1ED49D278 != -1)
  {
    dispatch_once(&qword_1ED49D278, &__block_literal_global_1359);
  }

  taskQueue2 = [(_UIKeyboardStateManager *)self taskQueue];
  v9[0] = MEMORY[0x1E69E9820];
  v9[1] = 3221225472;
  v9[2] = __60___UIKeyboardStateManager_insertedAccentVariantFromPopover___block_invoke_6;
  v9[3] = &unk_1E70FD1B8;
  v10 = popoverCopy;
  selfCopy = self;
  v7 = qword_1ED49D270;
  v8 = popoverCopy;
  [taskQueue2 performSingleTask:v9 breadcrumb:v7];
}

- (void)emojiSearchWillInsertEmoji:(id)emoji forSearchQuery:(id)query
{
  emojiCopy = emoji;
  queryCopy = query;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateIdleDetection:0];

  if (+[UIDictationController isRunning])
  {
    v8 = +[UIDictationController sharedInstance];
    dictationTipController = [v8 dictationTipController];
    [dictationTipController signalDictationInsertionTip:emojiCopy];
  }

  v10 = @"Search";
  if (!queryCopy || ![queryCopy length])
  {
    v11 = @"SearchFavorites";

    v10 = v11;
  }

  [(_UIKeyboardStateManager *)self emojiSearchWillInsertEmoji:emojiCopy forSearchQuery:queryCopy selectionMethod:@"Touch" inputType:v10];
}

- (void)emojiSearchWillInsertEmoji:(id)emoji forSearchQuery:(id)query selectionMethod:(id)method inputType:(id)type
{
  typeCopy = type;
  methodCopy = method;
  queryCopy = query;
  emojiCopy = emoji;
  [(_UIKeyboardStateManager *)self refreshKeyboardState];
  v19 = [(TIKeyboardState *)self->m_keyboardState copy];
  [v19 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
  [v19 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v15 = [inputDelegateManager delegateRespectingForwardingDelegate:0];

  if ([v15 conformsToProtocol:&unk_1EFE8B2D0])
  {
    v16 = [MEMORY[0x1E69D9590] documentStateOfDocument:v15];
    [v19 setDocumentState:v16];
  }

  v17 = [(_UIKeyboardStateManager *)self inputEventForInputString:emojiCopy];
  v18 = [MEMORY[0x1E69D95F0] candidateWithCandidate:emojiCopy forInput:queryCopy];

  [v17 setAcceptedCandidate:v18];
  [v17 setSynthesizedByAcceptingCandidate:1];
  [(_UIKeyboardStateManager *)self acceptingCandidateWithTrigger:*MEMORY[0x1E69D9720]];
  [(_UIKeyboardStateManager *)self handleEmojiInput:v17 keyboardState:v19];
  [UIKBAnalyticsDispatcher emojiInsertedByMethod:methodCopy inputType:typeCopy];
}

- (void)handleEmojiInput:(id)input keyboardState:(id)state
{
  inputCopy = input;
  stateCopy = state;
  if ([(_UIKeyboardStateManager *)self shouldAccessInputManagerService])
  {
    if (qword_1ED49D288 != -1)
    {
      dispatch_once(&qword_1ED49D288, &__block_literal_global_1365);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v9[0] = MEMORY[0x1E69E9820];
    v9[1] = 3221225472;
    v9[2] = __58___UIKeyboardStateManager_handleEmojiInput_keyboardState___block_invoke_3;
    v9[3] = &unk_1E70FD208;
    v9[4] = self;
    v10 = inputCopy;
    v11 = stateCopy;
    [taskQueue addTask:v9 breadcrumb:qword_1ED49D280];
  }
}

- (BOOL)currentInputModeRequiresLTRMathExpression
{
  v2 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v2 currentInputMode];
  primaryLanguage = [currentInputMode primaryLanguage];
  v5 = [primaryLanguage isEqual:@"he-IL"];

  return v5;
}

- (void)acceptAutocorrection:(id)autocorrection executionContextPassingTIKeyboardCandidate:(id)candidate
{
  v107 = *MEMORY[0x1E69E9840];
  autocorrectionCopy = autocorrection;
  candidateCopy = candidate;
  if (+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || ![autocorrectionCopy isSupplementalItemCandidate] || !-[_UIKeyboardStateManager _insertSupplementalCandidate:overridingCandidateText:](self, "_insertSupplementalCandidate:overridingCandidateText:", autocorrectionCopy, 0))
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    autocorrectPrompt = [WeakRetained autocorrectPrompt];

    if (autocorrectPrompt)
    {
      [autocorrectPrompt frame];
      v11 = v10;
      v13 = v12;
      v15 = v14;
      v17 = v16;
    }

    else
    {
      v11 = *MEMORY[0x1E695F050];
      v13 = *(MEMORY[0x1E695F050] + 8);
      v15 = *(MEMORY[0x1E695F050] + 16);
      v17 = *(MEMORY[0x1E695F050] + 24);
    }

    v18 = autocorrectionCopy;
    m_smartPunctuationController = self->m_smartPunctuationController;
    candidate = [v18 candidate];
    v21 = [(TISmartPunctuationController *)m_smartPunctuationController smartPunctuationResultsForString:candidate];

    v22 = v18;
    if ([v21 count])
    {
      v78 = autocorrectPrompt;
      v74 = candidateCopy;
      v75 = autocorrectionCopy;
      candidate2 = [v18 candidate];
      v24 = [candidate2 mutableCopy];

      v104 = 0u;
      v105 = 0u;
      v102 = 0u;
      v103 = 0u;
      v76 = v21;
      v25 = v21;
      v26 = [v25 countByEnumeratingWithState:&v102 objects:v106 count:16];
      if (v26)
      {
        v27 = v26;
        v28 = *v103;
        do
        {
          for (i = 0; i != v27; ++i)
          {
            if (*v103 != v28)
            {
              objc_enumerationMutation(v25);
            }

            v30 = *(*(&v102 + 1) + 8 * i);
            range = [v30 range];
            v33 = v32;
            replacementString = [v30 replacementString];
            [v24 replaceCharactersInRange:range withString:{v33, replacementString}];
          }

          v27 = [v25 countByEnumeratingWithState:&v102 objects:v106 count:16];
        }

        while (v27);
      }

      v22 = [v18 candidateByReplacingWithCandidate:v24];

      candidateCopy = v74;
      autocorrectionCopy = v75;
      v21 = v76;
      autocorrectPrompt = v78;
    }

    if ([(_UIKeyboardStateManager *)self shouldApplyAcceptedAutocorrection:v18])
    {
      v35 = off_1E70EA000;
      if (+[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled]&& [(_UIKeyboardStateManager *)self shouldUnderlineCandidate:v22])
      {
        autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
        v37 = [autocorrectionController storedListForCandidate:v22];

        _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
        [_textChoicesAssistant addList:v37 forCandidate:v22];

        candidate3 = [v22 candidate];
        [UITextChecker setString:candidate3 isExemptFromChecker:1];

        v35 = off_1E70EA000;
      }

      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];

      if (!forwardingInputDelegate)
      {
        v100[0] = MEMORY[0x1E69E9820];
        v100[1] = 3221225472;
        v100[2] = __91___UIKeyboardStateManager_acceptAutocorrection_executionContextPassingTIKeyboardCandidate___block_invoke;
        v100[3] = &unk_1E70FD608;
        v101 = v22;
        [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v100];
      }

      if ([(_UIKeyboardStateManager *)self hasAsyncCapableInputDelegate])
      {
        self->m_textInputChangesIgnored = 1;
        if ([v18 isContinuousPathConversion])
        {
          inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          selectedTextRange = [inputDelegateManager2 selectedTextRange];
          isEmpty = [selectedTextRange isEmpty];

          if ((isEmpty & 1) == 0)
          {
            v77 = v21;
            v79 = autocorrectPrompt;
            v45 = candidateCopy;
            input = [v18 input];
            candidate4 = [v22 candidate];
            inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
            inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
            selectedTextRange2 = [inputDelegateManager4 selectedTextRange];
            v51 = [inputDelegateManager3 textInRange:selectedTextRange2];

            if (([v51 hasPrefix:@" "] & 1) != 0 || !objc_msgSend(candidate4, "hasPrefix:", @" "))
            {
              candidateCopy = v45;
              autocorrectPrompt = v79;
            }

            else
            {
              candidateCopy = v45;
              autocorrectPrompt = v79;
              if ([candidate4 length] >= 2)
              {
                v52 = [candidate4 substringFromIndex:1];

                candidate4 = v52;
              }
            }

            v21 = v77;
            v60 = [v22 candidateByReplacingWithCandidate:candidate4 input:v51];

            v22 = v60;
          }

          v35 = off_1E70EA000;
        }

        if ([(__objc2_class *)v35[359] isTextAccelerationUIEnabled])
        {
          inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          candidate5 = [v22 candidate];
          [v22 input];
          v64 = v63 = autocorrectPrompt;
          v65 = [(_UIKeyboardStateManager *)self shouldUnderlineCandidate:v22];
          v93[0] = MEMORY[0x1E69E9820];
          v93[1] = 3221225472;
          v93[2] = __91___UIKeyboardStateManager_acceptAutocorrection_executionContextPassingTIKeyboardCandidate___block_invoke_2;
          v93[3] = &unk_1E70FDA18;
          v93[4] = self;
          v22 = v22;
          v94 = v22;
          v95 = candidateCopy;
          v96 = v11;
          v97 = v13;
          v98 = v15;
          v99 = v17;
          [inputDelegateManager5 applyAutocorrection:candidate5 toString:v64 shouldUnderline:v65 withCompletionHandler:v93];

          autocorrectPrompt = v63;
        }

        else
        {
          aBlock[0] = MEMORY[0x1E69E9820];
          aBlock[1] = 3221225472;
          aBlock[2] = __91___UIKeyboardStateManager_acceptAutocorrection_executionContextPassingTIKeyboardCandidate___block_invoke_6;
          aBlock[3] = &unk_1E70FDA18;
          aBlock[4] = self;
          v22 = v22;
          v87 = v22;
          v88 = candidateCopy;
          v89 = v11;
          v90 = v13;
          v91 = v15;
          v92 = v17;
          v66 = _Block_copy(aBlock);
          webInputDelegate = [(_UIKeyboardStateManager *)self webInputDelegate];

          v68 = autocorrectPrompt;
          if (webInputDelegate)
          {
            webInputDelegate2 = [(_UIKeyboardStateManager *)self webInputDelegate];
            input2 = [v22 input];
            candidate6 = [v22 candidate];
            v84[0] = MEMORY[0x1E69E9820];
            v84[1] = 3221225472;
            v84[2] = __91___UIKeyboardStateManager_acceptAutocorrection_executionContextPassingTIKeyboardCandidate___block_invoke_10;
            v84[3] = &unk_1E70FDA40;
            v72 = &v85;
            v85 = v66;
            [webInputDelegate2 replaceText:input2 withText:candidate6 options:0 completionHandler:v84];
          }

          else
          {
            asyncInputDelegate = [(_UIKeyboardStateManager *)self asyncInputDelegate];

            if (asyncInputDelegate)
            {
              webInputDelegate2 = [(_UIKeyboardStateManager *)self asyncInputDelegate];
              input2 = [v22 input];
              candidate6 = [v22 candidate];
              v82[0] = MEMORY[0x1E69E9820];
              v82[1] = 3221225472;
              v82[2] = __91___UIKeyboardStateManager_acceptAutocorrection_executionContextPassingTIKeyboardCandidate___block_invoke_11;
              v82[3] = &unk_1E70FDA40;
              v72 = &v83;
              v83 = v66;
              [webInputDelegate2 replaceText:input2 withText:candidate6 options:0 withCompletionHandler:v82];
            }

            else
            {
              webInputDelegate2 = [(_UIKeyboardStateManager *)self asyncWebKitInteractionDelegate];
              input2 = [v22 candidate];
              candidate6 = [v22 input];
              v80[0] = MEMORY[0x1E69E9820];
              v80[1] = 3221225472;
              v80[2] = __91___UIKeyboardStateManager_acceptAutocorrection_executionContextPassingTIKeyboardCandidate___block_invoke_12;
              v80[3] = &unk_1E70FDA68;
              v72 = &v81;
              v81 = v66;
              [webInputDelegate2 applyAutocorrection:input2 toString:candidate6 withCompletionHandler:v80];
            }
          }

          autocorrectPrompt = v68;
        }

        goto LABEL_37;
      }

      [(_UIKeyboardStateManager *)self deleteWordLastDelete];
      v56 = -*MEMORY[0x1E695E460];
      if (v57 > v56)
      {
        inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        [inputDelegateManager6 insertText:@" " updateInputSource:0];

        [(_UIKeyboardStateManager *)self setDeleteWordLastDelete:v56];
      }

      if ([(_UIKeyboardStateManager *)self applyAutocorrection:v22])
      {
        [(_UIKeyboardStateManager *)self underlineCandidate:v22];
        candidate7 = [v18 candidate];
        [(_UIKeyboardStateManager *)self animateAutocorrectionToText:candidate7 fromRect:v11, v13, v15, v17];

        [(_UIKeyboardStateManager *)self didApplyAutocorrection:v18 autocorrectPromptFrame:v11, v13, v15, v17];
        [candidateCopy returnExecutionToParentWithInfo:v22];
LABEL_37:

        goto LABEL_38;
      }
    }

    else
    {
      inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      selectedTextRange3 = [inputDelegateManager7 selectedTextRange];
      isEmpty2 = [selectedTextRange3 isEmpty];

      if ((isEmpty2 & 1) == 0)
      {
        [(_UIKeyboardStateManager *)self collapseSelection];
      }
    }

    [candidateCopy returnExecutionToParent];
    goto LABEL_37;
  }

  [candidateCopy returnExecutionToParent];
LABEL_38:
}

- (BOOL)shouldApplyAcceptedAutocorrection:(id)autocorrection
{
  autocorrectionCopy = autocorrection;
  v6 = (objc_opt_respondsToSelector() & 1) == 0 || ([autocorrectionCopy candidateProperty] & 4) == 0;
  v7 = (objc_opt_respondsToSelector() & 1) == 0 || [autocorrectionCopy performSelector:sel_shouldHintAtAlternativeInput] == 0;
  candidate = [autocorrectionCopy candidate];
  if (!candidate)
  {
    input = [autocorrectionCopy input];
    if (!input)
    {
      goto LABEL_23;
    }
  }

  candidate2 = [autocorrectionCopy candidate];
  input2 = [autocorrectionCopy input];
  if ([candidate2 isEqualToString:input2])
  {
    v11 = ([autocorrectionCopy isSupplementalItemCandidate] ^ 1) & (v6 && v7);

    if (candidate)
    {

      if (v11)
      {
        goto LABEL_23;
      }
    }

    else
    {

      if (v11)
      {
LABEL_23:
        v13 = 0;
        goto LABEL_26;
      }
    }
  }

  else
  {

    if (candidate)
    {
      v12 = candidate;
    }

    else
    {
      v12 = input;
    }
  }

  if ([autocorrectionCopy slotID] || (-[_UIKeyboardStateManager inputDelegate](self, "inputDelegate"), v14 = objc_claimAutoreleasedReturnValue(), v14, !v14))
  {
    v13 = 1;
  }

  else
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager selectedTextRange];
    if ([selectedTextRange isEmpty])
    {
      input3 = [autocorrectionCopy input];
      v18 = [input3 length];
    }

    else
    {
      v18 = 0;
    }

    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    candidate3 = [autocorrectionCopy candidate];
    v13 = [inputDelegateManager2 callShouldReplaceExtendedRange:v18 withText:candidate3 includeMarkedText:0];
  }

LABEL_26:

  return v13;
}

- (void)didApplyAutocorrection:(id)autocorrection autocorrectPromptFrame:(CGRect)frame
{
  height = frame.size.height;
  width = frame.size.width;
  y = frame.origin.y;
  x = frame.origin.x;
  autocorrectionCopy = autocorrection;
  input = [autocorrectionCopy input];
  v10 = [input length];

  if (!v10)
  {
    v11 = objc_alloc_init(MEMORY[0x1E69D9638]);
    [v11 setAcceptedCandidate:autocorrectionCopy];
    candidate = [autocorrectionCopy candidate];
    [v11 insertText:candidate];

    [(_UIKeyboardStateManager *)self _postInputResponderCapabilitiesChangedNotificationWithOutput:v11 selectionChanged:0];
  }

  [(_UIKeyboardStateManager *)self setChangedDelegate];
  if ([(_UIKeyboardStateManager *)self isAutoFillMode])
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    privateInputDelegate = [inputDelegateManager privateInputDelegate];
    v15 = objc_opt_respondsToSelector();

    if (v15)
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      privateInputDelegate2 = [inputDelegateManager2 privateInputDelegate];
      candidate2 = [autocorrectionCopy candidate];
      [privateInputDelegate2 acceptedAutoFillWord:candidate2];
    }
  }

  v21.origin.x = x;
  v21.origin.y = y;
  v21.size.width = width;
  v21.size.height = height;
  [(_UIKeyboardStateManager *)self trackUsageForAcceptedAutocorrection:autocorrectionCopy promptWasShowing:!CGRectIsNull(v21)];
}

- (void)addWordTerminator:(id)terminator afterSpace:(BOOL)space afterAcceptingCandidate:(id)candidate elapsedTime:(double)time executionContext:(id)context
{
  spaceCopy = space;
  terminatorCopy = terminator;
  candidateCopy = candidate;
  contextCopy = context;
  string = [terminatorCopy string];
  if (![(_UIKeyboardStateManager *)self callShouldInsertText:string])
  {
    acceptedCandidate = [terminatorCopy acceptedCandidate];
    if ([acceptedCandidate isAutofillCandidate])
    {
    }

    else
    {
      acceptedCandidate2 = [terminatorCopy acceptedCandidate];
      isSlottedCandidate = [acceptedCandidate2 isSlottedCandidate];

      if (!isSlottedCandidate)
      {
        self->m_textInputChangingText = 1;
        [(_UIKeyboardStateManager *)self updateForChangedSelection];
        self->m_textInputChangingText = 0;
        [contextCopy returnExecutionToParent];
        goto LABEL_17;
      }
    }
  }

  [(_UIKeyboardStateManager *)self clearInputWithCandidatesCleared:0];
  v19 = [(_UIKeyboardStateManager *)self handleDeleteAutospaceForInputString:string afterSpace:spaceCopy];
  if (!v19)
  {
    if ([(_UIKeyboardStateManager *)self willDoubleSpacePeriodForInputString:string afterSpace:spaceCopy elapsedTime:time])
    {
      inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
      replacementForDoubleSpace = [inputManagerState replacementForDoubleSpace];
      v22 = [replacementForDoubleSpace copy];
      v23 = v22;
      v24 = @". ";
      if (v22)
      {
        v24 = v22;
      }

      v19 = v24;

      if ([(_UIKeyboardStateManager *)self _hasMarkedText])
      {
        self->m_textInputChangesIgnored = 1;
        inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
        [inputDelegateManager unmarkText];

        self->m_textInputChangesIgnored = 0;
      }
    }

    else
    {
      v19 = 0;
    }
  }

  if ([(__CFString *)v19 length])
  {
    v26 = [(_UIKeyboardStateManager *)self handleReplacement:v19 forSpaceAndInput:terminatorCopy];

    terminatorCopy = v26;
  }

  if (terminatorCopy)
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    [autocorrectionController clearAutocorrection];

    [UITextChecker noteWordTerminator:terminatorCopy replacement:v19];
    v29[0] = MEMORY[0x1E69E9820];
    v29[1] = 3221225472;
    v29[2] = __109___UIKeyboardStateManager_addWordTerminator_afterSpace_afterAcceptingCandidate_elapsedTime_executionContext___block_invoke;
    v29[3] = &unk_1E70FD208;
    v29[4] = self;
    v30 = candidateCopy;
    v31 = string;
    v28 = [contextCopy childWithContinuation:v29];
    [(_UIKeyboardStateManager *)self handleKeyboardInput:terminatorCopy executionContext:v28];
  }

LABEL_17:
}

- (void)completeAddInputString:(id)string generateCandidates:(BOOL)candidates
{
  candidatesCopy = candidates;
  stringCopy = string;
  [(_UIKeyboardStateManager *)self setShiftOffIfNeeded];
  if (candidatesCopy)
  {
    [(_UIKeyboardStateManager *)self generateCandidates];
  }

  if ([stringCopy isEqualToString:@"\n"] && !-[UITextInputTraits isSingleLineDocument](self->m_traits, "isSingleLineDocument"))
  {
    [(_UIKeyboardStateManager *)self setInitialDirection];
  }

  [(_UIKeyboardStateManager *)self updateCandidateDisplay];
  [(_UIKeyboardStateManager *)self updateReturnKey];
  [(_UIKeyboardStateManager *)self updateNoContentViews];
  [(_UIKeyboardStateManager *)self setChangedDelegate];
  [(_UIKeyboardStateManager *)self updateDoubleSpacePeriodStateForString:stringCopy];
  self->m_suggestionsShownForCurrentDeletion = 0;
  self->m_didAutomaticallyInsertSpace = 0;
  [(_UIKeyboardStateManager *)self removeTextChoicePrompt];
}

- (void)updateDocumentViewsAfterKeyboardOutput:(id)output
{
  outputCopy = output;
  insertionText = [outputCopy insertionText];
  if ([insertionText _isNewlineOrReturn])
  {
    isSingleLineDocument = [(UITextInputTraits *)self->m_traits isSingleLineDocument];

    if (!isSingleLineDocument)
    {
      [(_UIKeyboardStateManager *)self setInitialDirection];
    }
  }

  else
  {
  }

  [(_UIKeyboardStateManager *)self updateNoContentViews];
  [(_UIKeyboardStateManager *)self setChangedDelegate];
  insertionText2 = [outputCopy insertionText];

  if (insertionText2)
  {
    insertionText3 = [outputCopy insertionText];
    newlineCharacterSet = [MEMORY[0x1E696AB08] newlineCharacterSet];
    v9 = [insertionText3 rangeOfCharacterFromSet:newlineCharacterSet];

    if (v9 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if ([(UITextInputTraits *)self->m_traits returnKeyGoesToNextResponder])
      {
        delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
        _nextKeyResponder = [delegateAsResponder _nextKeyResponder];
        [_nextKeyResponder becomeFirstResponder];
      }

      else
      {
        delegateAsResponder = [MEMORY[0x1E696AD88] defaultCenter];
        [delegateAsResponder postNotificationName:@"UIKeyboardReturnKeyPressed" object:0];
      }
    }
  }

  self->m_textInputChangingCount = 0;
  *&self->m_textInputChangesIgnored = 0;
  self->m_textInputChangingDirection = 0;
}

- (void)didChangePhraseBoundary
{
  if ([(_UIKeyboardStateManager *)self supportsSetPhraseBoundary])
  {
    [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegate];
    if (+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || !+[UIKeyboard usesInputSystemUI])
    {
      [(_UIKeyboardStateManager *)self setUserSelectedCurrentCandidate:0];
      [(_UIKeyboardStateManager *)self generateCandidates];

      [(_UIKeyboardStateManager *)self updateCandidateDisplay];
    }
  }
}

- (unint64_t)phraseBoundary
{
  if (![(_UIKeyboardStateManager *)self supportsSetPhraseBoundary])
  {
    return 0x7FFFFFFFFFFFFFFFLL;
  }

  documentState = [(_UIKeyboardStateManager *)self documentState];

  if (!documentState)
  {
    return 0x7FFFFFFFFFFFFFFFLL;
  }

  documentState2 = [(_UIKeyboardStateManager *)self documentState];
  markedText = [documentState2 markedText];
  v6 = [markedText length];

  if (!v6)
  {
    return 0;
  }

  documentState3 = [(_UIKeyboardStateManager *)self documentState];
  selectedRangeInMarkedText = [documentState3 selectedRangeInMarkedText];

  return selectedRangeInMarkedText;
}

- (void)adjustSegmentSize:(int64_t)size
{
  if (size >= 0)
  {
    sizeCopy = size;
  }

  else
  {
    sizeCopy = -size;
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  markedTextRange = [inputDelegateManager2 markedTextRange];
  v9 = [inputDelegateManager textInRange:markedTextRange];
  v10 = [v9 length];

  if (v10 >= sizeCopy)
  {
    v11 = sizeCopy;
  }

  else
  {
    v11 = v10;
  }

  if (v10 <= 0)
  {
    v12 = sizeCopy;
  }

  else
  {
    v12 = v11;
  }

  if (v12 >= 1)
  {
    v13 = size >> 63;
    do
    {
      [(_UIKeyboardStateManager *)self movePhraseBoundaryToDirection:v13 granularity:1];
      --v12;
    }

    while (v12);
  }
}

- (void)movePhraseBoundaryToDirection:(int64_t)direction granularity:(int64_t)granularity
{
  if ([(_UIKeyboardStateManager *)self hasEditableMarkedText]&& [(_UIKeyboardStateManager *)self phraseBoundary]!= 0x7FFFFFFFFFFFFFFFLL)
  {
    if (qword_1ED49D2C8 != -1)
    {
      dispatch_once(&qword_1ED49D2C8, &__block_literal_global_1395);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v8[0] = MEMORY[0x1E69E9820];
    v8[1] = 3221225472;
    v8[2] = __69___UIKeyboardStateManager_movePhraseBoundaryToDirection_granularity___block_invoke_3;
    v8[3] = &unk_1E70FDA90;
    v8[4] = self;
    v8[5] = direction;
    v8[6] = granularity;
    [taskQueue performTask:v8 breadcrumb:qword_1ED49D2C0];
  }
}

- (void)updateLayoutAndSetShift
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateLayout];

  [(_UIKeyboardStateManager *)self setShift:1];
}

- (void)deleteOnceFromInputWithExecutionContext:(id)context
{
  contextCopy = context;
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  inputIndex = [inputManagerState inputIndex];

  if (!inputIndex)
  {
    goto LABEL_5;
  }

  inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
  shadowTyping = [inputManagerState2 shadowTyping];

  if ([shadowTyping length] < inputIndex)
  {

LABEL_5:
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    _characterBeforeCaretSelection = [inputDelegateManager _characterBeforeCaretSelection];

    goto LABEL_6;
  }

  _characterBeforeCaretSelection = [shadowTyping characterAtIndex:inputIndex - 1];

  if (!_characterBeforeCaretSelection)
  {
    goto LABEL_5;
  }

LABEL_6:
  v11 = objc_alloc_init(MEMORY[0x1E69D95F8]);
  [v11 setBackspace:1];
  [v11 setShiftDown:{-[_UIKeyboardStateManager isShiftKeyBeingHeld](self, "isShiftKeyBeingHeld")}];
  v13[0] = MEMORY[0x1E69E9820];
  v13[1] = 3221225472;
  v13[2] = __67___UIKeyboardStateManager_deleteOnceFromInputWithExecutionContext___block_invoke;
  v13[3] = &unk_1E70FDAB8;
  v13[4] = self;
  v14 = _characterBeforeCaretSelection;
  v12 = [contextCopy childWithContinuation:v13];

  [(_UIKeyboardStateManager *)self handleKeyboardInput:v11 executionContext:v12];
}

- (BOOL)nextCharacterIsWordCharacter
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  _characterAfterCaretSelection = [inputDelegate _characterAfterCaretSelection];

  m_inputManagerState = self->m_inputManagerState;
  if (m_inputManagerState)
  {
    v6 = _characterAfterCaretSelection == 0;
  }

  else
  {
    v6 = 1;
  }

  if (v6)
  {
    LOBYTE(v8) = 0;
  }

  else
  {
    v7 = [MEMORY[0x1E696AEC0] _stringWithUnichar:_characterAfterCaretSelection];
    v8 = [(TIKeyboardInputManagerState *)m_inputManagerState stringEndsWord:v7]^ 1;
  }

  return v8;
}

- (void)collapseSelection
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager collapseSelectionAndAdjustByOffset:0];
}

- (void)scheduleReplacementsAfterDeletionToEndOfWord
{
  if ([(_UIKeyboardStateManager *)self supportsScheduleReplacementsAfterDeletionToEndOfWord])
  {
    v3 = +[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled];
    v4 = 9;
    if (v3)
    {
      v4 = 41;
    }

    if (self->m_suggestionsShownForCurrentDeletion)
    {
      v5 = v4 | 2;
    }

    else
    {
      v5 = v4;
    }

    self->m_suggestionsShownForCurrentDeletion = 1;
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    hasAsyncCapableInputDelegate = [inputDelegateManager hasAsyncCapableInputDelegate];

    if (hasAsyncCapableInputDelegate)
    {
      v8 = v5 | 0x10;
    }

    else
    {
      v8 = v5;
    }

    [(_UIKeyboardStateManager *)self scheduleReplacementsWithOptions:v8];
  }
}

- (void)completeDeleteOnceFromInputWithCharacterBefore:(unsigned int)before
{
  v3 = *&before;
  v5 = [MEMORY[0x1E696AEC0] _stringWithUnichar:?];
  [(_UIKeyboardStateManager *)self setDeletedString:v5];

  if (![(_UIKeyboardStateManager *)self usesCandidateSelection]|| [(_UIKeyboardStateManager *)self shouldShowLongPredictionList])
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    hasAsyncCapableInputDelegate = [inputDelegateManager hasAsyncCapableInputDelegate];

    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    deletedString = [(_UIKeyboardStateManager *)self deletedString];
    v10 = [inputManagerState stringEndsWord:deletedString];
    if (!v10 || (hasAsyncCapableInputDelegate & 1) != 0)
    {

      if (!v10)
      {
        goto LABEL_14;
      }
    }

    else
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      selectionIsEndOfWord = [inputDelegateManager2 selectionIsEndOfWord];

      if ((selectionIsEndOfWord & 1) == 0)
      {
        goto LABEL_14;
      }
    }

    [(_UIKeyboardStateManager *)self clearInput];
    [(_UIKeyboardStateManager *)self scheduleReplacementsAfterDeletionToEndOfWord];
    [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegate];
    goto LABEL_14;
  }

  if (!self->m_candidateList)
  {
    goto LABEL_14;
  }

  _markedText = [(_UIKeyboardStateManager *)self _markedText];
  if (![_markedText length])
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    candidateController = [WeakRetained candidateController];
    barIsExtended = [candidateController barIsExtended];

    if (!barIsExtended)
    {
      goto LABEL_14;
    }

    _markedText = objc_loadWeakRetained(&self->_presentationDelegate);
    candidateController2 = [_markedText candidateController];
    [candidateController2 collapse];
  }

LABEL_14:
  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  if ([autocorrectionController hasProactiveCandidates])
  {
    documentState = [(_UIKeyboardStateManager *)self documentState];
    contextBeforeInput = [documentState contextBeforeInput];

    if (v3 && !contextBeforeInput)
    {
      autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
      [autocorrectionController2 clearAutocorrectionAndNotifyObservers:1];

      [(_UIKeyboardStateManager *)self updateAssistantView];
    }
  }

  else
  {
  }

  [(_UIKeyboardStateManager *)self setShiftOffIfNeeded];
  [(_UIKeyboardStateManager *)self updateDoubleSpacePeriodStateForCharacter:v3];
  self->m_didAutomaticallyInsertSpace = 0;
}

- (void)_deleteFromInputWithFlags:(unint64_t)flags
{
  if (qword_1ED49D2D8 != -1)
  {
    dispatch_once(&qword_1ED49D2D8, &__block_literal_global_1399);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v6[0] = MEMORY[0x1E69E9820];
  v6[1] = 3221225472;
  v6[2] = __53___UIKeyboardStateManager__deleteFromInputWithFlags___block_invoke_3;
  v6[3] = &unk_1E70FDAE0;
  v6[4] = self;
  v6[5] = flags;
  [taskQueue addTask:v6 breadcrumb:qword_1ED49D2D0];
}

- (void)deleteFromInputWithFlags:(unint64_t)flags
{
  v11[2] = *MEMORY[0x1E69E9840];
  if ([(_UIKeyboardStateManager *)self isCurrentEditResponderWebKit]&& [(_UIKeyboardStateManager *)self shouldApplyKeyboardInputToUIHost])
  {
    v5 = objc_alloc_init(NSClassFromString(&cfstr_Rtiinputoperat.isa));
    v10[0] = @"flags";
    v6 = [MEMORY[0x1E696AD98] numberWithUnsignedInteger:flags];
    v10[1] = @"selector";
    v11[0] = v6;
    v11[1] = @"_deleteFromInputWithFlags:";
    v7 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v11 forKeys:v10 count:2];
    [v5 setCustomInfo:v7];

    [v5 setCustomInfoType:0x1EFB7CA50];
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner performInputOperation:v5];
  }

  else
  {
    v9[0] = MEMORY[0x1E69E9820];
    v9[1] = 3221225472;
    v9[2] = __52___UIKeyboardStateManager_deleteFromInputWithFlags___block_invoke;
    v9[3] = &unk_1E70FDAE0;
    v9[4] = self;
    v9[5] = flags;
    [(_UIKeyboardStateManager *)self _scheduleInputAdditionOrDeletion:v9];
  }
}

- (void)undoWithKeyboardInput:(id)input
{
  inputCopy = input;
  if (qword_1ED49D2E8 != -1)
  {
    dispatch_once(&qword_1ED49D2E8, &__block_literal_global_1406);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v8[0] = MEMORY[0x1E69E9820];
  v8[1] = 3221225472;
  v8[2] = __49___UIKeyboardStateManager_undoWithKeyboardInput___block_invoke_3;
  v8[3] = &unk_1E70FD1B8;
  v8[4] = self;
  v9 = inputCopy;
  v6 = qword_1ED49D2E0;
  v7 = inputCopy;
  [taskQueue addTask:v8 breadcrumb:v6];
}

- (void)performAutoDeleteNumberOfTimes:(unint64_t)times deleteOneWord:(BOOL)word forwardToInputSource:(BOOL)source deleteCount:(int64_t *)count
{
  countCopy = count;
  sourceCopy = source;
  if (times)
  {
    v7 = 0;
    v8 = 0;
    v60 = v70;
    v61 = v67;
    v62 = v72;
    while (1)
    {
      v9 = [(_UIKeyboardStateManager *)self inputSystemSourceSession:countCopy];
      textOperations = [v9 textOperations];
      keyboardOutput = [textOperations keyboardOutput];
      [keyboardOutput setProducedByDeleteInput:1];

      v80 = 0;
      v81 = &v80;
      v82 = 0x2020000000;
      v83 = 0;
      if (!word && (times == 1 || ![(_UIKeyboardStateManager *)self usesAutoDeleteWord]))
      {
        goto LABEL_19;
      }

      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      asyncCapableInputDelegate = [inputDelegateManager asyncCapableInputDelegate];

      if (!asyncCapableInputDelegate)
      {
        break;
      }

      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager2 _deleteByWord];

      v15 = 1;
LABEL_20:
      inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v27 = 0;
      self->m_autoDeleteShiftCharacter = [inputDelegateManager3 _characterBeforeCaretSelection];
      v37 = 1;
      v36 = 1;
LABEL_21:

      if (!-[_UIKeyboardStateManager shouldShowLongPredictionList](self, "shouldShowLongPredictionList") && -[_UIKeyboardStateManager usesCandidateSelection](self, "usesCandidateSelection") && (-[_UIKeyboardStateManager inputManagerState](self, "inputManagerState"), v38 = objc_claimAutoreleasedReturnValue(), v39 = [v38 inputCount], v38, v39))
      {
        if (v37)
        {
          v40 = [MEMORY[0x1E696AEC0] _stringWithUnichar:self->m_autoDeleteShiftCharacter];
        }

        else
        {
          inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          v40 = [inputDelegateManager4 textInRange:v27];
        }

        v47 = [v40 length];
        if (v47 <= 1)
        {
          v48 = 1;
        }

        else
        {
          v48 = v47;
        }

        inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
        inputCount = [inputManagerState inputCount];

        if (v48 < inputCount)
        {
          LODWORD(inputCount) = v48;
        }

        if (sourceCopy)
        {
          v69[0] = MEMORY[0x1E69E9820];
          v69[1] = 3221225472;
          v70[0] = __105___UIKeyboardStateManager_performAutoDeleteNumberOfTimes_deleteOneWord_forwardToInputSource_deleteCount___block_invoke_3;
          v70[1] = &unk_1E70FDB58;
          v70[2] = &v80;
          [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v69];
        }

        if (inputCount >= 1)
        {
          do
          {
            if (qword_1ED49D2F8 != -1)
            {
              dispatch_once(&qword_1ED49D2F8, &__block_literal_global_1411);
            }

            taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
            v68[0] = MEMORY[0x1E69E9820];
            v68[1] = 3221225472;
            v68[2] = __105___UIKeyboardStateManager_performAutoDeleteNumberOfTimes_deleteOneWord_forwardToInputSource_deleteCount___block_invoke_6;
            v68[3] = &unk_1E70FD058;
            v68[4] = self;
            [taskQueue performSingleTask:v68 breadcrumb:qword_1ED49D2F0];

            LODWORD(inputCount) = inputCount - 1;
          }

          while (inputCount);
        }
      }

      else
      {
        if ((v37 & 1) == 0)
        {
          self->m_textInputChangesIgnored = 1;
          inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          [inputDelegateManager5 setSelectedTextRange:v27];

          [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegate];
          self->m_textInputChangesIgnored = 0;
        }

        if (sourceCopy)
        {
          inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          hasAsyncCapableInputDelegate = [inputDelegateManager6 hasAsyncCapableInputDelegate];

          v44 = &__block_literal_global_1415;
          if (((v37 | hasAsyncCapableInputDelegate) & 1) == 0)
          {
            textLengthToDeleteBeforeSelectedRangeForSmartDelete = [(_UIKeyboardStateManager *)self textLengthToDeleteBeforeSelectedRangeForSmartDelete];
            *(v81 + 6) += textLengthToDeleteBeforeSelectedRangeForSmartDelete;
            v44 = v66;
            v66[0] = MEMORY[0x1E69E9820];
            v66[1] = 3221225472;
            v67[0] = __105___UIKeyboardStateManager_performAutoDeleteNumberOfTimes_deleteOneWord_forwardToInputSource_deleteCount___block_invoke_7;
            v67[1] = &unk_1E70FDB58;
            v67[2] = &v80;
          }

          [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v44];
        }

        if ((v15 & 1) == 0)
        {
          [(_UIKeyboardStateManager *)self deleteBackward];
        }

        [(_UIKeyboardStateManager *)self syncInputManagerToKeyboardState];
        if (+[UIKeyboard isKeyboardProcess])
        {
          [(_UIKeyboardStateManager *)self changingContextWithTrigger:@"rapidDeletion"];
          [(_UIKeyboardStateManager *)self removeAutocorrectPromptAndCandidateList];
        }
      }

      v8 += v36;
      _Block_object_dispose(&v80, 8);

      if (++v7 == times)
      {
        goto LABEL_52;
      }
    }

    inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager7 selectedTextRange];

    start = [selectedTextRange start];
    v19 = [selectedTextRange end];
    [start isEqual:v19];

    start2 = [selectedTextRange start];
    if (start2)
    {
      inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
      start3 = [selectedTextRange start];
      v23 = [inputDelegate _positionAtStartOfWords:1 beforePosition:start3];

      if (v23)
      {
        v24 = [selectedTextRange end];
        if (v24)
        {
          inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
          v26 = [selectedTextRange end];
          v27 = [inputDelegate2 textRangeFromPosition:v23 toPosition:v26];
        }

        else
        {
          v27 = 0;
        }

LABEL_17:
        self->m_autoDeleteShiftCharacter = 0;
        inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
        documentState = [inputSystemSourceSession documentState];
        v29DocumentState = [documentState documentState];
        contextBeforeInput = [v29DocumentState contextBeforeInput];

        v76 = 0;
        v77 = &v76;
        v78 = 0x2020000000;
        v79 = 0;
        v32 = [contextBeforeInput length];
        v71[0] = MEMORY[0x1E69E9820];
        v71[1] = 3221225472;
        v72[0] = __105___UIKeyboardStateManager_performAutoDeleteNumberOfTimes_deleteOneWord_forwardToInputSource_deleteCount___block_invoke;
        v72[1] = &unk_1E70FDB30;
        v74 = &v80;
        v75 = &v76;
        v33 = contextBeforeInput;
        v73 = v33;
        [v33 enumerateSubstringsInRange:0 options:v32 usingBlock:{258, v71}];
        *(v81 + 6) += *(v77 + 6);

        _Block_object_dispose(&v76, 8);
        if (v27)
        {
          inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          v35 = [inputDelegateManager3 textInRange:v27];
          v36 = [v35 length];

          v37 = 0;
          v15 = 0;
          goto LABEL_21;
        }

LABEL_19:
        v15 = 0;
        goto LABEL_20;
      }
    }

    else
    {
      v23 = 0;
    }

    v27 = 0;
    goto LABEL_17;
  }

  v8 = 0;
LABEL_52:
  if (+[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled])
  {
    inputDelegateManager8 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange2 = [inputDelegateManager8 selectedTextRange];

    if (selectedTextRange2)
    {
      _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
      inputDelegateManager9 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      selectedTextRange3 = [inputDelegateManager9 selectedTextRange];
      start4 = [selectedTextRange3 start];
      [_textChoicesAssistant updateUnderlinesIfNeededAfterPosition:start4];
    }
  }

  if (v59)
  {
    *v59 = v8;
  }
}

- (void)deleteFromInputWithFlags:(unint64_t)flags executionContext:(id)context
{
  contextCopy = context;
  [(_UIKeyboardStateManager *)self setPreviousInputString:0];
  if ((flags & 0x80) != 0)
  {
    [(_UIKeyboardStateManager *)self flushTouchEventWaitingForKeyInputEventIfNecessary];
    if (![(_UIKeyboardStateManager *)self callShouldDeleteWithWordCountForRapidDelete:2 characterCountForRapidDelete:3])
    {
LABEL_25:
      [contextCopy returnExecutionToParent];
      goto LABEL_26;
    }

    taskQueue = objc_alloc_init(MEMORY[0x1E69D9638]);
    [taskQueue setDeletionCount:1];
    [taskQueue setProducedByDeleteInput:1];
    [(_UIKeyboardStateManager *)self performKeyboardOutput:taskQueue];
    [(_UIKeyboardStateManager *)self updateReturnKey];
    [(_UIKeyboardStateManager *)self updateNoContentViews];
LABEL_24:

    goto LABEL_25;
  }

  if ((flags & 0x400) == 0 && ![(_UIKeyboardStateManager *)self callShouldDeleteWithWordCountForRapidDelete:2 characterCountForRapidDelete:3])
  {
    [(_UIKeyboardStateManager *)self flushTouchEventWaitingForKeyInputEventIfNecessary];
    self->m_needsOneShotGenerateCandidatesAfterStoppingAutoDelete = 1;
    if (qword_1ED49D308 != -1)
    {
      dispatch_once(&qword_1ED49D308, &__block_literal_global_1420);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v18[0] = MEMORY[0x1E69E9820];
    v18[1] = 3221225472;
    v18[2] = __69___UIKeyboardStateManager_deleteFromInputWithFlags_executionContext___block_invoke_3;
    v18[3] = &unk_1E70FD058;
    v18[4] = self;
    [taskQueue addTask:v18 breadcrumb:qword_1ED49D300];
    goto LABEL_24;
  }

  [(_UIKeyboardStateManager *)self updateChangeTimeAndIncrementCount];
  [(_UIKeyboardStateManager *)self clearTransientState];
  if ((flags & 0x200) != 0 || self->m_autoDeleteOK)
  {
    if ((flags & 0x200) != 0 || self->m_autoDeleteCount < 0x14)
    {
      v11 = 0;
      v10 = 1;
    }

    else
    {
      if ([(_UIKeyboardStateManager *)self usesAutoDeleteWord])
      {
        v10 = 2;
      }

      else
      {
        v10 = 3;
      }

      [(_UIKeyboardStateManager *)self setLastDeletionCountForFastDelete:v10];
      v11 = 1;
    }

    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];
    v14 = forwardingInputDelegate == 0;

    v17 = 0;
    [(_UIKeyboardStateManager *)self performAutoDeleteNumberOfTimes:v10 deleteOneWord:(flags >> 9) & 1 forwardToInputSource:v14 deleteCount:&v17];
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    [WeakRetained playDeleteKeyFeedbackIfNecessaryRepeat:1 rapid:v11 deleteCount:v17];

    self->m_doubleSpacePeriodWasAppliedInCurrentContext = 0;
    self->m_didAutomaticallyInsertSpace = 0;
    [(_UIKeyboardStateManager *)self setShiftOffIfNeeded];
    [(_UIKeyboardStateManager *)self completeDeleteFromInput];
    goto LABEL_25;
  }

  if ([(_UIKeyboardStateManager *)self userSelectedCurrentCandidate])
  {
    [(UIKeyboardCandidateList *)self->m_candidateList showCandidateAtIndex:0x7FFFFFFFFFFFFFFFLL];
    [(_UIKeyboardStateManager *)self setUserSelectedCurrentCandidate:0];
  }

  if (self->m_acceptingCandidate)
  {
    inputManager = [(_UIKeyboardStateManager *)self inputManager];
    [inputManager lastAcceptedCandidateCorrected];
  }

  v16[0] = MEMORY[0x1E69E9820];
  v16[1] = 3221225472;
  v16[2] = __69___UIKeyboardStateManager_deleteFromInputWithFlags_executionContext___block_invoke_8;
  v16[3] = &unk_1E70FD058;
  v16[4] = self;
  v8 = [contextCopy childWithContinuation:v16];

  [(_UIKeyboardStateManager *)self deleteOnceFromInputWithExecutionContext:v8];
  contextCopy = v8;
LABEL_26:
}

- (void)completeDeleteFromInput
{
  documentState = [(_UIKeyboardStateManager *)self documentState];
  v6[0] = MEMORY[0x1E69E9820];
  v6[1] = 3221225472;
  v6[2] = __50___UIKeyboardStateManager_completeDeleteFromInput__block_invoke;
  v6[3] = &unk_1E70FD9A0;
  v6[4] = self;
  v4 = [documentState inputStringWithTerminatorPredicate:v6];

  if (![v4 length])
  {
    [(_UIKeyboardStateManager *)self setInitialDirection];
    _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
    [_textChoicesAssistant clearSecureCandidateHashes];
  }

  [(_UIKeyboardStateManager *)self setChangedDelegate];
}

- (void)willReplaceTextInRangedSelectionWithKeyboardInput
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  selectedTextRange = [inputDelegateManager selectedTextRange];

  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  selectionIsWord = [inputDelegateManager2 selectionIsWord];

  if (selectionIsWord)
  {
    inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange2 = [inputDelegateManager4 selectedTextRange];
    v9 = [inputDelegateManager3 textInRange:selectedTextRange2];

    if ([v9 length])
    {
      inputManager = [(_UIKeyboardStateManager *)self inputManager];
      [inputManager setOriginalInput:v9];
    }
  }

  [(_UIKeyboardStateManager *)self removeTextChoicePrompt];
  if (([selectedTextRange isEmpty] & 1) == 0)
  {
    [(_UIKeyboardStateManager *)self removeTextChoiceUnderlinesInRange:selectedTextRange];
  }
}

- (id)_acquireWaitingOnPerformAutocorrect
{
  selfCopy = self;
  objc_sync_enter(selfCopy);
  v3 = _Block_copy(selfCopy->_waitingOnPerformAutocorrect);
  waitingOnPerformAutocorrect = selfCopy->_waitingOnPerformAutocorrect;
  selfCopy->_waitingOnPerformAutocorrect = 0;

  v5 = _Block_copy(v3);
  objc_sync_exit(selfCopy);

  return v5;
}

- (void)_setWaitingOnPerformAutocorrect:(id)autocorrect
{
  autocorrectCopy = autocorrect;
  selfCopy = self;
  objc_sync_enter(selfCopy);
  v5 = [autocorrectCopy copy];
  waitingOnPerformAutocorrect = selfCopy->_waitingOnPerformAutocorrect;
  selfCopy->_waitingOnPerformAutocorrect = v5;

  objc_sync_exit(selfCopy);
}

- (BOOL)_shouldAcceptAutocorrectionOnSelectionChange
{
  if (self->m_skipAcceptAutocorrection)
  {
    return 0;
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v5 = [inputDelegateManager delegateRespectingForwardingDelegate:0];

  if ((objc_opt_respondsToSelector() & 1) != 0 && ![v5 _shouldAcceptAutocorrection])
  {
    _hasMarkedText = 0;
  }

  else
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    if ([autocorrectionController requestedAutocorrection])
    {
      _hasMarkedText = [(_UIKeyboardStateManager *)self _hasMarkedText];
    }

    else
    {
      autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
      autocorrection = [autocorrectionController2 autocorrection];
      if (autocorrection)
      {
        _hasMarkedText = 1;
      }

      else
      {
        _hasMarkedText = [(_UIKeyboardStateManager *)self _hasMarkedText];
      }
    }
  }

  return _hasMarkedText;
}

- (void)acceptInlineCompletionWithCompletionHandler:(id)handler
{
  v11 = *MEMORY[0x1E69E9840];
  handlerCopy = handler;
  v5 = _UIKeyboardLog();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 136315138;
    v10 = "[_UIKeyboardStateManager acceptInlineCompletionWithCompletionHandler:]";
    _os_log_impl(&dword_188A29000, v5, OS_LOG_TYPE_DEFAULT, "%s Initiating accept inline completion", buf, 0xCu);
  }

  [(_UIKeyboardStateManager *)self beginAcceptingInlineCompletionByDirectTap];
  v7[0] = MEMORY[0x1E69E9820];
  v7[1] = 3221225472;
  v7[2] = __71___UIKeyboardStateManager_acceptInlineCompletionWithCompletionHandler___block_invoke;
  v7[3] = &unk_1E70FE248;
  v7[4] = self;
  v8 = handlerCopy;
  v6 = handlerCopy;
  [(_UIKeyboardStateManager *)self acceptAutocorrectionWithCompletionHandler:v7];
}

- (void)beginAcceptingInlineCompletionByDirectTap
{
  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardInputDestinationEventToUIHost:sel_beginAcceptingInlineCompletionByDirectTap];
  }

  else
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
    [remoteTextInputPartner setCurrentlyAcceptingInlineCompletionByDirectTap:1];
  }
}

- (void)endAcceptingInlineCompletionByDirectTap
{
  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardInputDestinationEventToUIHost:sel_endAcceptingInlineCompletionByDirectTap];
  }

  else
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
    [remoteTextInputPartner setCurrentlyAcceptingInlineCompletionByDirectTap:0];
  }
}

- (void)acceptAutocorrectionWithCompletionHandler:(id)handler requestedByRemoteInputDestination:(BOOL)destination
{
  v31 = *MEMORY[0x1E69E9840];
  handlerCopy = handler;
  if (+[UIKeyboard usesInputSystemUI])
  {
    v25 = 0;
    v26 = &v25;
    v27 = 0x2020000000;
    v28 = 1;
    v8 = _UIKeyboardLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 136315138;
      v30 = "[_UIKeyboardStateManager acceptAutocorrectionWithCompletionHandler:requestedByRemoteInputDestination:]";
      _os_log_impl(&dword_188A29000, v8, OS_LOG_TYPE_DEFAULT, "%s Forwarding to keyboard UI host", buf, 0xCu);
    }

    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v21[2] = __103___UIKeyboardStateManager_acceptAutocorrectionWithCompletionHandler_requestedByRemoteInputDestination___block_invoke;
    v21[3] = &unk_1E70FDB80;
    v10 = handlerCopy;
    v21[4] = self;
    v22 = v10;
    v23 = &v25;
    v24 = a2;
    [remoteTextInputPartner forwardSelectorToUIHost:sel_acceptAutocorrectionWithCompletionHandler_requestedByRemoteInputDestination_ completionHandler:v21];

    if (!v10)
    {
      mainBundle = [MEMORY[0x1E696AAE8] mainBundle];
      bundleIdentifier = [mainBundle bundleIdentifier];
      v13 = [bundleIdentifier hasPrefix:@"com.apple."];

      if ((v13 & 1) == 0 && *(v26 + 24) == 1)
      {
        v14 = *MEMORY[0x1E695D918];
        do
        {
          currentRunLoop = [MEMORY[0x1E695DFD0] currentRunLoop];
          distantFuture = [MEMORY[0x1E695DF00] distantFuture];
          [currentRunLoop runMode:v14 beforeDate:distantFuture];
        }

        while ((v26[3] & 1) != 0);
      }
    }

    _Block_object_dispose(&v25, 8);
  }

  else
  {
    aBlock[0] = MEMORY[0x1E69E9820];
    aBlock[1] = 3221225472;
    aBlock[2] = __103___UIKeyboardStateManager_acceptAutocorrectionWithCompletionHandler_requestedByRemoteInputDestination___block_invoke_3;
    aBlock[3] = &unk_1E70FD0C8;
    aBlock[4] = self;
    destinationCopy = destination;
    v19 = handlerCopy;
    v17 = _Block_copy(aBlock);
    if (pthread_main_np() == 1)
    {
      v17[2](v17);
    }

    else
    {
      dispatch_async(MEMORY[0x1E69E96A0], v17);
    }
  }
}

- (void)_local_acceptAutocorrection
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  privateInputDelegate = [inputDelegateManager privateInputDelegate];

  if (!privateInputDelegate || [privateInputDelegate isEditing])
  {
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    hasAsyncCapableInputDelegate = [inputDelegateManager2 hasAsyncCapableInputDelegate];

    if (hasAsyncCapableInputDelegate && (-[_UIKeyboardStateManager taskQueue](self, "taskQueue"), v7 = objc_claimAutoreleasedReturnValue(), v8 = [v7 isMainThreadExecutingTask], v7, (v8 & 1) == 0))
    {
      aBlock[0] = MEMORY[0x1E69E9820];
      aBlock[1] = 3221225472;
      aBlock[2] = __54___UIKeyboardStateManager__local_acceptAutocorrection__block_invoke;
      aBlock[3] = &unk_1E70FD058;
      aBlock[4] = self;
      v12 = _Block_copy(aBlock);
      if (qword_1ED49D328 != -1)
      {
        dispatch_once(&qword_1ED49D328, &__block_literal_global_1441);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      [taskQueue addTask:v12 breadcrumb:qword_1ED49D320];
    }

    else if (-[_UIKeyboardStateManager _hasMarkedText](self, "_hasMarkedText") && (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v9 = objc_claimAutoreleasedReturnValue(), [v9 keyInputDelegate], v10 = objc_claimAutoreleasedReturnValue(), v10, v9, v10))
    {
      self->m_textInputChangesIgnored = 1;
      inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager3 unmarkText];

      self->m_textInputChangesIgnored = 0;
    }

    else
    {
      [(_UIKeyboardStateManager *)self clearInput];
    }
  }
}

- (void)_acceptAutocorrection
{
  v36 = *MEMORY[0x1E69E9840];
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  privateInputDelegate = [inputDelegateManager privateInputDelegate];

  if (!privateInputDelegate || [privateInputDelegate isEditing])
  {
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    hasAsyncCapableInputDelegate = [inputDelegateManager2 hasAsyncCapableInputDelegate];

    if (hasAsyncCapableInputDelegate)
    {
      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      isMainThreadExecutingTask = [taskQueue isMainThreadExecutingTask];

      if ((isMainThreadExecutingTask & 1) == 0)
      {
        aBlock[0] = MEMORY[0x1E69E9820];
        aBlock[1] = 3221225472;
        aBlock[2] = __48___UIKeyboardStateManager__acceptAutocorrection__block_invoke;
        aBlock[3] = &unk_1E70FD058;
        aBlock[4] = self;
        autocorrection = _Block_copy(aBlock);
        if (qword_1ED49D338 != -1)
        {
          dispatch_once(&qword_1ED49D338, &__block_literal_global_1445);
        }

        taskQueue2 = [(_UIKeyboardStateManager *)self taskQueue];
        [taskQueue2 addTask:autocorrection breadcrumb:qword_1ED49D330];

        goto LABEL_37;
      }
    }

    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    requestedAutocorrection = [autocorrectionController requestedAutocorrection];

    if (requestedAutocorrection)
    {
      v12 = _UIKeyboardImplLog();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136315138;
        v35 = "[_UIKeyboardStateManager _acceptAutocorrection]";
        _os_log_debug_impl(&dword_188A29000, v12, OS_LOG_TYPE_DEBUG, "Detected and avoided autocorrect deadlock in %s", buf, 0xCu);
      }
    }

    else
    {
      autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
      autocorrection = [autocorrectionController2 autocorrection];

      if (autocorrection)
      {
        v15 = 0;
        goto LABEL_13;
      }
    }

    autocorrectionController2 = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
    if (([autocorrectionController2 currentlyAcceptingInlineCompletionByDirectTap] & 1) == 0)
    {

      autocorrection = 0;
      goto LABEL_20;
    }

    autocorrection = 0;
    v15 = 1;
LABEL_13:
    inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager3 keyInputDelegate];

    if (v15)
    {
    }

    if (keyInputDelegate)
    {
      [(_UIKeyboardStateManager *)self updateChangeTimeAndIncrementCount];
      inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
      currentlyAcceptingInlineCompletionByDirectTap = [inlineTextCompletionController currentlyAcceptingInlineCompletionByDirectTap];

      if (currentlyAcceptingInlineCompletionByDirectTap)
      {
        inlineTextCompletionController2 = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
        [inlineTextCompletionController2 acceptTextCompletionWithInteraction:2 wordTerminator:0];
LABEL_18:

        goto LABEL_35;
      }

      v28 = [(_UIKeyboardStateManager *)self acceptAutocorrectionForWordTerminator:0];
LABEL_35:
      if (![(_UIKeyboardStateManager *)self usesCandidateSelection])
      {
        [(_UIKeyboardStateManager *)self clearInput];
      }

LABEL_37:

      goto LABEL_38;
    }

LABEL_20:
    if (![(_UIKeyboardStateManager *)self currentKeyboardTraitsAllowCandidateBarWhileIgnoringHidePredictionTrait:1]|| ![(_UIKeyboardStateManager *)self usesCandidateSelection]|| [(_UIKeyboardStateManager *)self shouldShowLongPredictionList])
    {
      goto LABEL_35;
    }

    inlineTextCompletionController2 = [(_UIKeyboardStateManager *)self inputManagerState];
    inputCount = [inlineTextCompletionController2 inputCount];
    if (!inputCount)
    {
      keyInputDelegate = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet candidates];
      if (![keyInputDelegate count])
      {

        goto LABEL_18;
      }
    }

    inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate2 = [inputDelegateManager4 keyInputDelegate];

    if (!inputCount)
    {
    }

    if (!keyInputDelegate2)
    {
      goto LABEL_35;
    }

    [(_UIKeyboardStateManager *)self updateChangeTimeAndIncrementCount];
    self->m_shouldSkipCandidateGeneration = 1;
    v23 = +[UIKBAnalyticsDispatcher sharedInstance];
    [v23 setNextCommitTextSource:1];

    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    if ([inputManagerState acceptAutocorrectionCommitsInline])
    {
      userSelectedCurrentCandidate = [(TIKeyboardState *)self->m_keyboardState userSelectedCurrentCandidate];

      if ((userSelectedCurrentCandidate & 1) == 0)
      {
        v26 = [(_UIKeyboardStateManager *)self acceptInlineCandidateWithSpace:0];
LABEL_41:
        inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
        inputCount2 = [inputManagerState2 inputCount];

        if (inputCount2)
        {
          [(_UIKeyboardStateManager *)self cancelCandidateRequests];
          acceptCurrentCandidate = [(_UIKeyboardStateManager *)self acceptCurrentCandidate];
        }

        self->m_shouldSkipCandidateGeneration = 0;
        goto LABEL_35;
      }
    }

    else
    {
    }

    acceptCurrentCandidate2 = [(_UIKeyboardStateManager *)self acceptCurrentCandidate];
    goto LABEL_41;
  }

LABEL_38:
}

- (void)acceptAutocorrection
{
  if (+[UIKeyboard usesInputSystemUI]&& ([(_UIKeyboardStateManager *)self remoteTextInputPartner], v3 = objc_claimAutoreleasedReturnValue(), v3, v3))
  {
    objc_initWeak(&location, self);
    v4 = dispatch_time(0, 800000000);
    v5 = dispatch_get_global_queue(25, 0);
    block[0] = MEMORY[0x1E69E9820];
    block[1] = 3221225472;
    block[2] = __47___UIKeyboardStateManager_acceptAutocorrection__block_invoke;
    block[3] = &unk_1E70F5A28;
    objc_copyWeak(&v16, &location);
    dispatch_after(v4, v5, block);

    if (qword_1ED49D358 != -1)
    {
      dispatch_once(&qword_1ED49D358, &__block_literal_global_1456);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v9 = MEMORY[0x1E69E9820];
    v10 = 3221225472;
    v11 = __47___UIKeyboardStateManager_acceptAutocorrection__block_invoke_6;
    v12 = &unk_1E70FDBD0;
    objc_copyWeak(&v14, &location);
    selfCopy = self;
    [taskQueue performSingleTask:&v9 breadcrumb:qword_1ED49D350];

    objc_destroyWeak(&v14);
    v7 = [(_UIKeyboardStateManager *)self remoteTextInputPartner:v9];
    pendingOutputOperation = [v7 pendingOutputOperation];
    [(_UIKeyboardStateManager *)self performKeyboardOutput:pendingOutputOperation checkingDelegate:1 forwardToRemoteInputSource:0];

    objc_destroyWeak(&v16);
    objc_destroyWeak(&location);
  }

  else
  {

    [(_UIKeyboardStateManager *)self _acceptAutocorrection];
  }
}

- (void)removeAutocorrection
{
  [(_UIKeyboardStateManager *)self removeAutocorrectPrompt];

  [(_UIKeyboardStateManager *)self setAutocorrection:0];
}

- (void)insertTextSuggestionCandidate:(id)candidate
{
  candidateCopy = candidate;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  candidateController = [WeakRetained candidateController];
  [candidateController clearCurrentCandidate];

  if (+[UIKeyboard isKeyboardProcess]&& ([(_UIKeyboardStateManager *)self inputSystemSourceSession], (v6 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    textSuggestion3 = v6;
    if ([candidateCopy customInfoType] == 0x10000)
    {
      textOperations = [textSuggestion3 textOperations];
      [textOperations setCustomInfoType:0x1EFB7CBB0];

      textSuggestion = [candidateCopy textSuggestion];
      action = [textSuggestion action];

      textOperations4 = NSStringFromSelector(action);
      textOperations2 = [textSuggestion3 textOperations];
      [textOperations2 setCustomInfo:textOperations4];
    }

    else
    {
      textSuggestion2 = [candidateCopy textSuggestion];
      textOperations3 = [textSuggestion3 textOperations];
      [textOperations3 setCustomInfo:textSuggestion2];

      textOperations4 = [textSuggestion3 textOperations];
      [textOperations4 setCustomInfoType:0x1EFB7C950];
    }

    [textSuggestion3 flushOperations];
  }

  else
  {
    textSuggestion3 = [candidateCopy textSuggestion];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [textSuggestion3 performActionWihSender:self];
    }

    else
    {
      autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
      [autocorrectionController setTextSuggestionList:0];

      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v15 = [inputDelegateManager insertTextSuggestion:textSuggestion3];

      if ((v15 & 1) == 0)
      {
        if (objc_opt_class(), (objc_opt_isKindOfClass()) && !-[_UIKeyboardStateManager insertAutoFillTextSuggestion:](self, "insertAutoFillTextSuggestion:", textSuggestion3) || !-[_UIKeyboardStateManager acceptWord:firstDelete:](self, "acceptWord:firstDelete:", candidateCopy, [candidateCopy deleteCount]))
        {
          inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          textInputDelegate = [inputDelegateManager2 textInputDelegate];
          inputText = [textSuggestion3 inputText];
          [(_UIKeyboardStateManager *)self replaceAllTextInResponder:textInputDelegate withText:inputText];
        }
      }
    }

    self->m_predictionType = 0;
  }
}

- (id)emojiCandidate:(id)candidate
{
  candidateCopy = candidate;
  v4 = +[UIKeyboardEmojiPreferences sharedInstance];
  candidate = [candidateCopy candidate];
  v6 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v6 currentInputMode];
  primaryLanguage = [currentInputMode primaryLanguage];
  v9 = [v4 typingNameForEmoji:candidate language:primaryLanguage];

  candidate2 = [candidateCopy candidate];
  input = [candidateCopy input];
  LODWORD(v6) = [candidate2 isEqualToString:input];

  if (v6)
  {
    v12 = MEMORY[0x1E69D95F0];
    input2 = [candidateCopy input];
    [v12 candidateWithCandidate:v9 forInput:input2];
    candidateCopy = v14 = candidateCopy;
  }

  else
  {
    input2 = [candidateCopy input];
    if ([input2 _containsEmoji])
    {
      v15 = +[UIKeyboardEmojiPreferences sharedInstance];
      v16 = +[UIKeyboardInputModeController sharedInputModeController];
      currentInputMode2 = [v16 currentInputMode];
      primaryLanguage2 = [currentInputMode2 primaryLanguage];
      v19 = [v15 typingNameForEmoji:input2 language:primaryLanguage2];

      input2 = v19;
    }

    v14 = +[UIKeyboardEmojiPreferences sharedInstance];
    candidate3 = [candidateCopy candidate];
    v21 = +[UIKeyboardInputModeController sharedInputModeController];
    currentInputMode3 = [v21 currentInputMode];
    primaryLanguage3 = [currentInputMode3 primaryLanguage];
    [v14 emojiPredicted:candidate3 typingName:input2 language:primaryLanguage3];
  }

  return candidateCopy;
}

- (void)_acceptSupplementalCandidate:(id)candidate completion:(id)completion
{
  v30[1] = *MEMORY[0x1E69E9840];
  candidateCopy = candidate;
  completionCopy = completion;
  v24 = MEMORY[0x1E69E9820];
  v25 = 3221225472;
  v26 = __67___UIKeyboardStateManager__acceptSupplementalCandidate_completion___block_invoke;
  v27 = &unk_1E70FDC20;
  selfCopy = self;
  v8 = completionCopy;
  v29 = v8;
  v9 = _Block_copy(&v24);
  ui_supplementalItems = [candidateCopy ui_supplementalItems];
  input = [candidateCopy input];
  v12 = [(_UIKeyboardStateManager *)self _rangeForSupplementalItemText:input];

  v13 = [_UIStringAndPositionPair alloc];
  input2 = [candidateCopy input];
  start = [v12 start];
  v16 = [(_UIStringAndPositionPair *)&v13->super.isa initWithString:input2 position:start];

  pendingSupplementalCandidateToInsert = [(_UIKeyboardStateManager *)self pendingSupplementalCandidateToInsert];
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  v19 = [(_UIStringAndPositionPair *)pendingSupplementalCandidateToInsert isEqualToPair:v16 inputDelegate:inputDelegate];

  if (!v19)
  {
    [(_UIKeyboardStateManager *)self setPendingSupplementalCandidateToInsert:v16];
    if ([ui_supplementalItems count] == 1 || (v9[2](v9, ui_supplementalItems, candidateCopy, v12) & 1) == 0)
    {
      [(_UIKeyboardStateManager *)self setPendingSupplementalCandidateToInsert:0];
      v20 = MEMORY[0x1E696AD98];
      v21 = [ui_supplementalItems objectAtIndexedSubscript:0];
      v22 = [v20 numberWithUnsignedLongLong:{objc_msgSend(v21[1], "identifier")}];
      v30[0] = v22;
      v23 = [MEMORY[0x1E695DEC8] arrayWithObjects:v30 count:1];
      [candidateCopy setSupplementalItemIdentifiers:v23];

      (*(v8 + 2))(v8, candidateCopy);
    }
  }
}

- (void)handleInsertSmartCandidate:(id)candidate
{
  candidateCopy = candidate;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  privateInputDelegate = [inputDelegateManager privateInputDelegate];

  if (NSClassFromString(&cfstr_Tuismartaction.isa) && (objc_opt_isKindOfClass() & 1) != 0)
  {
    v7 = candidateCopy;
    smartReplyFeedbackManager = [(_UIKeyboardStateManager *)self smartReplyFeedbackManager];
    title = [v7 title];
    inputContextHistory = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];
    [smartReplyFeedbackManager userSelectedPollAction:title withInputContextHistory:inputContextHistory];

    v11 = objc_alloc_init(MEMORY[0x1E695DF70]);
    options = [v7 options];
    v17[0] = MEMORY[0x1E69E9820];
    v17[1] = 3221225472;
    v17[2] = __54___UIKeyboardStateManager_handleInsertSmartCandidate___block_invoke;
    v17[3] = &unk_1E70FDC48;
    v13 = v11;
    v18 = v13;
    [options enumerateObjectsUsingBlock:v17];

    v14 = [UISmartActionPollSuggestion alloc];
    title2 = [v7 title];
    v16 = [(UISmartActionPollSuggestion *)v14 initWithTitle:title2 options:v13];

    if (objc_opt_respondsToSelector())
    {
      [privateInputDelegate performSelector:sel_insertInputSuggestion_ withObject:v16];
    }
  }
}

- (void)acceptPredictiveInput:(id)input appendSeparator:(BOOL)separator
{
  inputCopy = input;
  if (inputCopy)
  {
    v7 = inputCopy;
    inlineTextCompletionController = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
    [inlineTextCompletionController willAcceptPredictiveInput:v7];

    [(_UIKeyboardStateManager *)self acceptingCandidateWithTrigger:*MEMORY[0x1E69D9720]];
    m_cachedAutofillMode = self->m_cachedAutofillMode;
    if (m_cachedAutofillMode == 2)
    {
      +[_UIKeyboardUsageTracking signupPasswordFromAutofillIncrement];
    }

    else if (m_cachedAutofillMode == 1)
    {
      +[_UIKeyboardUsageTracking loginPasswordFromAutofillIncrement];
    }

    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [(_UIKeyboardStateManager *)self insertTextSuggestionCandidate:v7];
LABEL_35:

      return;
    }

    if (([v7 candidateProperty] & 0x80) != 0)
    {
      [(_UIKeyboardStateManager *)self handleInsertSmartCandidate:v7];
      goto LABEL_35;
    }

    if (!_os_feature_enabled_impl() || ([v7 candidateProperty] & 0x10) == 0)
    {
      if ((objc_opt_respondsToSelector() & 1) == 0 || ([v7 candidateProperty] & 0x10) == 0 || (-[_UIKeyboardStateManager backendController](self, "backendController"), v10 = objc_claimAutoreleasedReturnValue(), v11 = objc_opt_respondsToSelector(), v10, (v11 & 1) == 0))
      {
        objc_initWeak(&location, self);
        aBlock[0] = MEMORY[0x1E69E9820];
        aBlock[1] = 3221225472;
        aBlock[2] = __65___UIKeyboardStateManager_acceptPredictiveInput_appendSeparator___block_invoke_5;
        aBlock[3] = &unk_1E70FDCE8;
        objc_copyWeak(&v39, &location);
        separatorCopy = separator;
        v17 = _Block_copy(aBlock);
        if ([v7 isSupplementalItemCandidate])
        {
          [(_UIKeyboardStateManager *)self _acceptSupplementalCandidate:v7 completion:v17];
        }

        else
        {
          candidate = [v7 candidate];
          _containsEmoji = [candidate _containsEmoji];

          if (_containsEmoji)
          {
            v20 = [(_UIKeyboardStateManager *)self emojiCandidate:v7];

            v7 = v20;
          }

          v17[2](v17, v7);
        }

        objc_destroyWeak(&v39);
        objc_destroyWeak(&location);
        goto LABEL_35;
      }

      [UIKeyboardImpl sendPerformanceNotification:@"UIKeyboardPerformanceSearchCandidatesStartNotification"];
      [(_UIKeyboardStateManager *)self refreshKeyboardState];
      v12 = [(TIKeyboardState *)self->m_keyboardState copy];
      v13 = [MEMORY[0x1E69D9580] tokenForKeyboardState:v12];
      [(_UIKeyboardStateManager *)self setCurrentCandidateRequest:v13];
      objc_initWeak(&location, self);
      if (qword_1ED49D378 != -1)
      {
        dispatch_once(&qword_1ED49D378, &__block_literal_global_1491);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      v41[0] = MEMORY[0x1E69E9820];
      v41[1] = 3221225472;
      v41[2] = __65___UIKeyboardStateManager_acceptPredictiveInput_appendSeparator___block_invoke_3;
      v41[3] = &unk_1E70FDC98;
      objc_copyWeak(&v45, &location);
      v7 = v7;
      v42 = v7;
      inputContextHistory = v12;
      v43 = inputContextHistory;
      v16 = v13;
      v44 = v16;
      [taskQueue addTask:v41 breadcrumb:qword_1ED49D370];

      objc_destroyWeak(&v45);
      objc_destroyWeak(&location);

      goto LABEL_34;
    }

    v21 = +[UIKeyboardImpl activeInstance];
    textInputTraits = [v21 textInputTraits];
    inputContextHistory = [textInputTraits inputContextHistory];

    if ([_UISmartReplyFeedbackManager candidateIsSmartReply:v7])
    {
      label = [v7 label];
      inputContextHistory2 = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];
      threadIdentifier = [inputContextHistory2 threadIdentifier];
      smartReplyFeedbackManager = [(_UIKeyboardStateManager *)self smartReplyFeedbackManager];
      [_UISmartReplyFeedbackManager userSelectedSmartReply:label isLongForm:1 withMailOrMsgThreadId:threadIdentifier withConversationType:2 withSmartReplyFeedbackManagerInstance:smartReplyFeedbackManager];
    }

    mainBundle = [MEMORY[0x1E696AAE8] mainBundle];
    bundleIdentifier = [mainBundle bundleIdentifier];
    if ([bundleIdentifier isEqualToString:@"com.apple.mobilemail"])
    {
    }

    else
    {
      v29 = +[UIKeyboard isKeyboardProcess];

      if (!v29)
      {
        if (!_os_feature_enabled_impl())
        {
LABEL_32:
          mainBundle2 = [MEMORY[0x1E696AAE8] mainBundle];
          bundleIdentifier2 = [mainBundle2 bundleIdentifier];
          v34 = [(_UIKeyboardStateManager *)self shouldClearConversationContextForClient:bundleIdentifier2];

          if (v34)
          {
            [(_UIKeyboardStateManager *)self conversationContext:0 didChange:0];
          }

LABEL_34:

          goto LABEL_35;
        }

        inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
        textInputDelegate = [inputDelegateManager textInputDelegate];

        if ((objc_opt_respondsToSelector() & 1) == 0)
        {
LABEL_31:

          goto LABEL_32;
        }

        v36 = [UISmartReplySuggestion alloc];
        candidate2 = [v7 candidate];
        tiInputContextHistory = [(UISmartReplySuggestion *)v36 initWithSmartReply:candidate2];

        [textInputDelegate performSelector:sel_insertInputSuggestion_ withObject:tiInputContextHistory];
LABEL_30:

        goto LABEL_31;
      }
    }

    textInputDelegate = [v7 candidate];
    tiInputContextHistory = [inputContextHistory tiInputContextHistory];
    [(_UIKeyboardStateManager *)self _startSmartReplyWritingToolWithPrompt:0 entryPoint:textInputDelegate inputContextHistory:tiInputContextHistory];
    goto LABEL_30;
  }
}

- (BOOL)shouldClearConversationContextForClient:(id)client
{
  clientCopy = client;
  if (+[UIKeyboard isKeyboardProcess])
  {
    v5 = ![(_UIKeyboardStateManager *)self shouldPreventLongFormSmartRepliesFromStarting];
  }

  else if ([clientCopy isEqualToString:@"com.apple.mobilemail"])
  {
    LOBYTE(v5) = 0;
  }

  else
  {
    LOBYTE(v5) = _os_feature_enabled_impl();
  }

  return v5;
}

- (BOOL)shouldPreventLongFormSmartRepliesFromStarting
{
  if (!+[UIKeyboard isKeyboardProcess])
  {
    return 0;
  }

  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  documentTraits = [inputSystemSourceSession documentTraits];
  userInfo = [documentTraits userInfo];

  v6 = [userInfo objectForKeyedSubscript:0x1EFB53450];
  bOOLValue = [v6 BOOLValue];

  v8 = bOOLValue ^ 1;
  return v8;
}

- (void)rejectAutocorrection:(id)autocorrection
{
  autocorrectionCopy = autocorrection;
  if (autocorrectionCopy)
  {
    if (qword_1ED49D398 != -1)
    {
      dispatch_once(&qword_1ED49D398, &__block_literal_global_1500);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v6[0] = MEMORY[0x1E69E9820];
    v6[1] = 3221225472;
    v6[2] = __48___UIKeyboardStateManager_rejectAutocorrection___block_invoke_3;
    v6[3] = &unk_1E70FD1B8;
    v6[4] = self;
    v7 = autocorrectionCopy;
    [taskQueue addTask:v6 breadcrumb:qword_1ED49D390];
  }
}

- (BOOL)insertsSpaceAfterPredictiveInput
{
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  insertsSpaceAfterPredictiveInput = [inputManagerState insertsSpaceAfterPredictiveInput];

  return insertsSpaceAfterPredictiveInput;
}

- (void)textAccepted:(id)accepted
{
  acceptedCopy = accepted;
  if ((objc_opt_respondsToSelector() & 1) != 0 && ([acceptedCopy candidateProperty] & 4) != 0)
  {
    v6 = MEMORY[0x1E69D95F0];
    candidate = [acceptedCopy candidate];
    input = [acceptedCopy input];
    v5 = [v6 candidateWithCandidate:candidate forInput:input property:{objc_msgSend(acceptedCopy, "candidateProperty")}];
  }

  else
  {
    v5 = acceptedCopy;
  }

  v9 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v9 currentInputMode];

  if (qword_1ED49D3A8 != -1)
  {
    dispatch_once(&qword_1ED49D3A8, &__block_literal_global_1504);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v15[0] = MEMORY[0x1E69E9820];
  v15[1] = 3221225472;
  v15[2] = __40___UIKeyboardStateManager_textAccepted___block_invoke_3;
  v15[3] = &unk_1E70FD208;
  v16 = currentInputMode;
  selfCopy = self;
  v18 = v5;
  v12 = qword_1ED49D3A0;
  v13 = v5;
  v14 = currentInputMode;
  [taskQueue addTask:v15 breadcrumb:v12];
}

- (void)textAccepted:(id)accepted executionContext:(id)context
{
  contextCopy = context;
  acceptedCopy = accepted;
  inputManager = [(_UIKeyboardStateManager *)self inputManager];
  v10[0] = MEMORY[0x1E69E9820];
  v10[1] = 3221225472;
  v10[2] = __57___UIKeyboardStateManager_textAccepted_executionContext___block_invoke;
  v10[3] = &unk_1E70FD4D0;
  v11 = contextCopy;
  selfCopy = self;
  v9 = contextCopy;
  [inputManager textAccepted:acceptedCopy completionHandler:v10];
}

- (BOOL)acceptAutofillExtraCandidateIfNeeded:(id)needed
{
  neededCopy = needed;
  customInfoType = [neededCopy customInfoType];
  if ((customInfoType & 0x20) != 0)
  {
    if (objc_opt_respondsToSelector())
    {
      keyboardCandidateInputStringUsedWithAutofillExtraThatSignifiesOTPExtra = [MEMORY[0x1E69D95D8] keyboardCandidateInputStringUsedWithAutofillExtraThatSignifiesOTPExtra];
    }

    else
    {
      keyboardCandidateInputStringUsedWithAutofillExtraThatSignifiesOTPExtra = 0;
    }

    if (+[UIKeyboard isKeyboardProcess])
    {
      v12[0] = MEMORY[0x1E69E9820];
      v12[1] = 3221225472;
      v12[2] = __64___UIKeyboardStateManager_acceptAutofillExtraCandidateIfNeeded___block_invoke;
      v12[3] = &unk_1E70FD608;
      v13 = neededCopy;
      [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v12];
    }

    else
    {
      input = [neededCopy input];
      v8 = [keyboardCandidateInputStringUsedWithAutofillExtraThatSignifiesOTPExtra isEqualToString:input];

      if (v8)
      {
        v9 = 4;
      }

      else
      {
        v9 = 1;
      }

      UIKeyboardSafariPresentCredentialPickerForType(v9);
      +[_UIKeyboardUsageTracking appAutofillExtraKeyTapped];
    }
  }

  return (customInfoType >> 5) & 1;
}

- (void)acceptPredictiveInput:(id)input appendSeparator:(BOOL)separator executionContext:(id)context
{
  inputCopy = input;
  contextCopy = context;
  if ([(_UIKeyboardStateManager *)self acceptAutofillExtraCandidateIfNeeded:inputCopy])
  {
    goto LABEL_5;
  }

  if (([inputCopy customInfoType] & 0x8000) == 0)
  {
    handler = [inputCopy handler];

    if (handler)
    {
      handler2 = [inputCopy handler];
      handler2[2]();

LABEL_5:
      [contextCopy returnExecutionToParent];
      goto LABEL_9;
    }

    if (_os_feature_enabled_impl() && (objc_opt_respondsToSelector() & 1) != 0 && [inputCopy isHideMyEmailType])
    {
      [(_UIKeyboardStateManager *)self proceedShouldReturnIfNeededForASP];
    }

    if (separator)
    {
      if (-[_UIKeyboardStateManager insertsSpaceAfterPredictiveInput](self, "insertsSpaceAfterPredictiveInput") || ([inputCopy isContinuousPathConversion] & 1) == 0)
      {
        [(_UIKeyboardStateManager *)self shouldForwardInsertSpaceAfterAcceptingPredictiveInput:inputCopy];
        goto LABEL_22;
      }

      shouldAccept = [inputCopy shouldAccept];
      v18 = [(_UIKeyboardStateManager *)self shouldForwardInsertSpaceAfterAcceptingPredictiveInput:inputCopy];
      if ((shouldAccept & 1) == 0)
      {
LABEL_22:
        v23 = &unk_1ED473000;
        v24 = +[UIKBAnalyticsDispatcher sharedInstance];
        nextCandidateReplacementSource = [v24 nextCandidateReplacementSource];

        if (nextCandidateReplacementSource == 7)
        {
          if ([inputCopy isToucanInlineCompletionCandidate])
          {
            goto LABEL_27;
          }

          v26 = 4;
        }

        else
        {
          v26 = 5;
        }

        v27 = +[UIKBAnalyticsDispatcher sharedInstance];
        [v27 setNextCandidateReplacementSource:v26];

LABEL_27:
        if ((objc_opt_respondsToSelector() & 1) != 0 && ([inputCopy wordSeparator], v28 = objc_claimAutoreleasedReturnValue(), v28, v28))
        {
          wordSeparator = [inputCopy wordSeparator];
        }

        else
        {
          inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
          wordSeparator = [inputManagerState wordSeparator];
        }

        isAutofillCandidate = [inputCopy isAutofillCandidate];
        if ([(_UIKeyboardStateManager *)self textInputTraitsNeedContactAutoFill])
        {
          autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
          autocorrectionList = [autocorrectionController autocorrectionList];
          containsProactiveTriggers = [autocorrectionList containsProactiveTriggers];
        }

        else
        {
          containsProactiveTriggers = 0;
        }

        if ([inputCopy isSlottedCandidate])
        {
          textContentType = [(UITextInputTraits *)self->m_traits textContentType];
          if (textContentType)
          {
            textContentType2 = [(UITextInputTraits *)self->m_traits textContentType];
            v37 = [textContentType2 isEqualToString:&stru_1EFB14550] ^ 1;
          }

          else
          {
            LOBYTE(v37) = 0;
          }
        }

        else
        {
          LOBYTE(v37) = 0;
        }

        if (wordSeparator)
        {
          candidate = [inputCopy candidate];
          v39 = [candidate hasSuffix:wordSeparator];
        }

        else
        {
          v39 = 1;
        }

        inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
        if (inputDelegate)
        {
          v41 = inputDelegate;
          v56 = wordSeparator;
          inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
          [inputDelegateManager selectedTextRange];
          v43 = isAutofillCandidate;
          v45 = v44 = containsProactiveTriggers;
          v57 = v43;
          v46 = v43 | ~[v45 isEmpty] | v44 | v37 | v39;

          if (v46)
          {

            wordSeparator = &stru_1EFB14550;
            v23 = &unk_1ED473000;
            isAutofillCandidate = v57;
          }

          else
          {
            v23 = &unk_1ED473000;
            isAutofillCandidate = v43;
            wordSeparator = v56;
          }
        }

        v47 = [(_UIKeyboardStateManager *)self inputEventForInputString:wordSeparator];
        [v47 setAcceptedCandidate:inputCopy];
        [v47 setSynthesizedByAcceptingCandidate:1];
        if (isAutofillCandidate)
        {
          v48 = [MEMORY[0x1E69D9570] listWithCorrections:0 predictions:0];
          autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
          [autocorrectionController2 setAutocorrectionList:v48];
        }

        else
        {
          v48 = [objc_alloc(MEMORY[0x1E69D9588]) initWithAutocorrection:inputCopy alternateCorrections:0];
          autocorrectionController2 = [MEMORY[0x1E69D9570] listWithCorrections:v48 predictions:0];
          autocorrectionController3 = [(_UIKeyboardStateManager *)self autocorrectionController];
          [autocorrectionController3 setAutocorrectionList:autocorrectionController2];
        }

        [(_UIKeyboardStateManager *)self setPreviousInputString:0];
        self->m_doubleSpacePeriodWasAppliedInCurrentContext = 0;
        candidate2 = [inputCopy candidate];
        [(_UIKeyboardStateManager *)self removeSpaceAfterEmojiForInputString:candidate2];

        candidate3 = [inputCopy candidate];
        _containsEmojiOnly = [candidate3 _containsEmojiOnly];

        if (_containsEmojiOnly)
        {
          [v23 + 3632 emojiInsertedByMethod:@"Touch" inputType:@"PredictionBar"];
        }

        self->m_didAutomaticallyInsertSpace = 0;
        v61[0] = MEMORY[0x1E69E9820];
        v61[1] = 3221225472;
        v61[2] = __82___UIKeyboardStateManager_acceptPredictiveInput_appendSeparator_executionContext___block_invoke;
        v61[3] = &unk_1E70FD208;
        v61[4] = self;
        v62 = wordSeparator;
        v63 = inputCopy;
        v54 = wordSeparator;
        v55 = [contextCopy childWithContinuation:v61];
        [(_UIKeyboardStateManager *)self addInputEvent:v47 executionContext:v55];

        goto LABEL_9;
      }
    }

    else
    {
      v18 = [(_UIKeyboardStateManager *)self shouldForwardInsertSpaceAfterAcceptingPredictiveInput:inputCopy];
    }

    v19 = v18;
    v20 = +[UIKBAnalyticsDispatcher sharedInstance];
    [v20 setNextCandidateReplacementSource:2];

    v58[0] = MEMORY[0x1E69E9820];
    v58[1] = 3221225472;
    v58[2] = __82___UIKeyboardStateManager_acceptPredictiveInput_appendSeparator_executionContext___block_invoke_2;
    v58[3] = &unk_1E70FD0F0;
    v58[4] = self;
    v21 = inputCopy;
    v59 = v21;
    v60 = v19;
    v22 = [contextCopy childWithContinuation:v58];
    [(_UIKeyboardStateManager *)self acceptAutocorrection:v21 executionContextPassingTIKeyboardCandidate:v22];

    goto LABEL_9;
  }

  delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  _responderForEditing = [delegateAsResponder _responderForEditing];

  if (objc_opt_respondsToSelector())
  {
    autocorrectionController4 = [(_UIKeyboardStateManager *)self autocorrectionController];
    autocorrectionList2 = [autocorrectionController4 autocorrectionList];

    self->m_skipAcceptAutocorrection = 1;
    [_responderForEditing performSelector:sel__showTextFormattingAnimationOptions_ withObject:0];
    self->m_skipAcceptAutocorrection = 0;
    autocorrectionController5 = [(_UIKeyboardStateManager *)self autocorrectionController];
    [autocorrectionController5 setAutocorrectionList:autocorrectionList2];
  }

  [contextCopy returnExecutionToParent];

LABEL_9:
}

- (void)acceptCandidate:(id)candidate forInput:(id)input
{
  v90 = *MEMORY[0x1E69E9840];
  candidateCopy = candidate;
  inputCopy = input;
  if (![(_UIKeyboardStateManager *)self committingCandidate])
  {
    v8 = 1;
    [(_UIKeyboardStateManager *)self setCommittingCandidate:1];
    [(_UIKeyboardStateManager *)self updateChangeTimeAndIncrementCount];
    m_candidateResultSet = self->m_candidateResultSet;
    v10 = 0x7FFFFFFFFFFFFFFFLL;
    if (m_candidateResultSet)
    {
      candidates = [(TIKeyboardCandidateResultSet *)m_candidateResultSet candidates];
      v12 = [candidates indexOfObject:candidateCopy];

      if (v12 != 0x7FFFFFFFFFFFFFFFLL)
      {
        [(UIKeyboardCandidateList *)self->m_candidateList candidateAcceptedAtIndex:v12];
        v8 = 0;
        v10 = v12;
      }
    }

    if (+[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled])
    {
      if ([(_UIKeyboardStateManager *)self shouldUnderlineCandidate:candidateCopy])
      {
        autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
        v14 = [autocorrectionController storedListForCandidate:candidateCopy];

        _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
        [_textChoicesAssistant addList:v14 forCandidate:candidateCopy];

        candidate = [candidateCopy candidate];
        [UITextChecker setString:candidate isExemptFromChecker:1];
LABEL_8:

        goto LABEL_12;
      }

      if (+[UIKeyboard usesInputSystemUI])
      {
        if (([candidateCopy isAutocorrection] & 1) == 0)
        {
          candidate2 = [candidateCopy candidate];
          input = [candidateCopy input];
          v19 = [candidate2 isEqualToString:input];

          if ((v19 & 1) == 0)
          {
            input2 = [candidateCopy input];
            v14 = [(_UIKeyboardStateManager *)self _rangeForAutocorrectionText:input2];

            candidate3 = [candidateCopy candidate];
            v74 = [candidate3 length];
            input3 = [candidateCopy input];
            v76 = v74 - [input3 length];

            candidate = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
            start = [v14 start];
            [candidate adjustRangesAfterPosition:start byOffset:v76];

            goto LABEL_8;
          }
        }
      }
    }

LABEL_12:
    if (candidateCopy)
    {
      currentCandidate = [(UIKeyboardCandidateList *)self->m_candidateList currentCandidate];
      type = [objc_opt_class() type];

      if (type != 3)
      {
        v22 = UIKeyboardGetCurrentInputMode();
        v23 = UIKeyboardInputModeGetIdentifierWithKeyboardLayouts(v22);
        statisticsIdentifier = [(UIKeyboardCandidateList *)self->m_candidateList statisticsIdentifier];
        v25 = TIStatisticGetKeyForCandidateAccepted();
        TIStatisticScalarIncrement();

        if (v8)
        {
          candidates2 = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet candidates];
          v87[0] = MEMORY[0x1E69E9820];
          v87[1] = 3221225472;
          v87[2] = __52___UIKeyboardStateManager_acceptCandidate_forInput___block_invoke;
          v87[3] = &unk_1E70FDD38;
          v88 = candidateCopy;
          v10 = [candidates2 indexOfObjectPassingTest:v87];
        }

        if (self->m_hasEditedMarkedTextInExtendedView)
        {
          v27 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        v28 = TIStatisticGetKeyForCandidateAccepted();
        candidate4 = [candidateCopy candidate];
        [candidate4 length];
        TIStatisticDistributionPushValue();

        if ([candidateCopy isExtensionCandidate])
        {
          v30 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isCompletionCandidate])
        {
          v31 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isInlineCompletionCandidate])
        {
          v32 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isForShortcutConversion])
        {
          v33 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isEmojiCandidate])
        {
          v34 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isStickerCandidate])
        {
          v35 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isFacemarkCandidate])
        {
          v36 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isOTAWordListCandidate])
        {
          v37 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isRegionalCandidate])
        {
          v38 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if (([candidateCopy isCompletionCandidate] & 1) == 0 && !v10)
        {
          v39 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isFullwidthCandidate])
        {
          v40 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isPunctuationKeyCandidate])
        {
          v41 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if ([candidateCopy isPunctuationCompletionCandidate])
        {
          v42 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();
        }

        if (v10 != 0x7FFFFFFFFFFFFFFFLL)
        {
          v43 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticDistributionPushValue();

          if ((objc_opt_respondsToSelector() & 1) != 0 && [(UIKeyboardCandidateList *)self->m_candidateList rowForCandidateAtIndex:v10]!= 0x7FFFFFFFFFFFFFFFLL)
          {
            v44 = TIStatisticGetKeyForCandidateAccepted();
            TIStatisticDistributionPushValue();
          }

          v82 = inputCopy;
          if ((objc_opt_respondsToSelector() & 1) != 0 && [(UIKeyboardCandidateList *)self->m_candidateList viewOffsetForCandidateAtIndex:v10]!= 0x7FFFFFFFFFFFFFFFLL)
          {
            v45 = TIStatisticGetKeyForCandidateAccepted();
            TIStatisticDistributionPushValue();
          }

          v78 = statisticsIdentifier;
          v79 = v23;
          v80 = v22;
          v81 = v8;
          isOTAWordListCandidate = [candidateCopy isOTAWordListCandidate];
          isRegionalCandidate = [candidateCopy isRegionalCandidate];
          v83 = 0u;
          v84 = 0u;
          v85 = 0u;
          v86 = 0u;
          candidates3 = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet candidates];
          v49 = [candidates3 countByEnumeratingWithState:&v83 objects:v89 count:16];
          if (v49)
          {
            v50 = v49;
            v51 = 0;
            v52 = *v84;
            do
            {
              for (i = 0; i != v50; ++i)
              {
                if (*v84 != v52)
                {
                  objc_enumerationMutation(candidates3);
                }

                v54 = *(*(&v83 + 1) + 8 * i);
                if (isOTAWordListCandidate)
                {
                  isOTAWordListCandidate = 1;
                  if (isRegionalCandidate)
                  {
                    goto LABEL_59;
                  }
                }

                else
                {
                  isOTAWordListCandidate = [*(*(&v83 + 1) + 8 * i) isOTAWordListCandidate];
                  if (isRegionalCandidate)
                  {
LABEL_59:
                    isRegionalCandidate = 1;
                    goto LABEL_62;
                  }
                }

                isRegionalCandidate = [v54 isRegionalCandidate];
LABEL_62:
                if (v51 == 9)
                {
                  goto LABEL_65;
                }

                ++v51;
              }

              v50 = [candidates3 countByEnumeratingWithState:&v83 objects:v89 count:16];
            }

            while (v50);
          }

LABEL_65:

          statisticsIdentifier = v78;
          v23 = v79;
          if (isOTAWordListCandidate)
          {
            v55 = TIStatisticGetKeyForCandidateAccepted();
            TIStatisticScalarIncrement();
          }

          inputCopy = v82;
          v8 = v81;
          v22 = v80;
          if (isRegionalCandidate)
          {
            v56 = TIStatisticGetKeyForCandidateAccepted();
            TIStatisticScalarIncrement();
          }
        }
      }

      v57 = [candidateCopy copy];

      self->m_acceptingCandidate = 1;
      if (!v8 || ([v57 candidate], v58 = objc_claimAutoreleasedReturnValue(), v59 = objc_msgSend(v58, "length"), v58, v59))
      {
        candidate5 = [v57 candidate];
        [(_UIKeyboardStateManager *)self setPreviousInputString:candidate5];
      }

      if ([_UISmartReplyFeedbackManager candidateIsSmartReply:v57])
      {
        label = [v57 label];
        inputContextHistory = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];
        threadIdentifier = [inputContextHistory threadIdentifier];
        smartReplyFeedbackManager = [(_UIKeyboardStateManager *)self smartReplyFeedbackManager];
        [_UISmartReplyFeedbackManager userSelectedSmartReply:label isLongForm:0 withMailOrMsgThreadId:threadIdentifier withConversationType:1 withSmartReplyFeedbackManagerInstance:smartReplyFeedbackManager];
      }

      inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
      if ([inputManagerState commitsAcceptedCandidate])
      {

LABEL_79:
        WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
        [WeakRetained setSuppressUpdateCandidateView:1];

        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          [(_UIKeyboardStateManager *)self insertTextSuggestionCandidate:v57];
        }

        else if (([v57 candidateProperty] & 0x80) != 0)
        {
          [(_UIKeyboardStateManager *)self handleInsertSmartCandidate:v57];
        }

        else
        {
          -[_UIKeyboardStateManager acceptWord:firstDelete:forInput:](self, "acceptWord:firstDelete:forInput:", v57, [v57 deleteCount], inputCopy);
        }

        v69 = objc_loadWeakRetained(&self->_presentationDelegate);
        [v69 setSuppressUpdateCandidateView:0];

        candidate6 = [v57 candidate];
        [UIKBAnalyticsDispatcher didCommitText:candidate6];

LABEL_88:
        if ([(UIKeyboardCandidateList *)self->m_candidateList isFloatingList]&& ([(UIKeyboardCandidateList *)self->m_candidateList isExtendedList]& 1) != 0)
        {
          v71 = 0;
        }

        else if (([(UIKeyboardCandidateList *)self->m_candidateList isFloatingList]& 1) != 0)
        {
          v71 = 1;
        }

        else
        {
          v71 = [(UIKeyboardCandidateList *)self->m_candidateList isExtendedList]^ 1;
        }

        [(_UIKeyboardStateManager *)self clearInputWithCandidatesCleared:v71];
        goto LABEL_95;
      }

      v66 = objc_loadWeakRetained(&self->_presentationDelegate);
      keyboardLayoutIsInAnotherProcess = [v66 keyboardLayoutIsInAnotherProcess];

      if (keyboardLayoutIsInAnotherProcess)
      {
        goto LABEL_79;
      }

      if (([v57 candidateProperty] & 0x80) != 0)
      {
        [(_UIKeyboardStateManager *)self handleInsertSmartCandidate:v57];
      }

      else
      {
        [(TIKeyboardState *)self->m_keyboardState setUserSelectedCurrentCandidate:0];
        self->m_doubleSpacePeriodWasAppliedInCurrentContext = 0;
        if ([objc_opt_class() type] != 3)
        {
          [(_UIKeyboardStateManager *)self handleDeletionForCandidate:v57];
          goto LABEL_88;
        }
      }
    }

    else
    {
      v57 = 0;
    }

LABEL_95:
    [(_UIKeyboardStateManager *)self setCommittingCandidate:0];
    candidateCopy = v57;
  }
}

- (void)handleDeletionForCandidate:(id)candidate
{
  candidateCopy = candidate;
  deleteCount = [candidateCopy deleteCount];
  candidate = [candidateCopy candidate];

  if (deleteCount)
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];

    if (inputDelegate)
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v9 = [inputDelegateManager callShouldReplaceExtendedRange:deleteCount withText:candidate includeMarkedText:{-[_UIKeyboardStateManager _hasMarkedText](self, "_hasMarkedText")}];

      if (v9)
      {
        v10[0] = MEMORY[0x1E69E9820];
        v10[1] = 3221225472;
        v10[2] = __54___UIKeyboardStateManager_handleDeletionForCandidate___block_invoke;
        v10[3] = &__block_descriptor_40_e26_v16__0__TIKeyboardOutput_8l;
        v10[4] = deleteCount;
        [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v10];
        [(_UIKeyboardStateManager *)self deleteBackwardAndNotifyAtEnd:0 deletionCount:deleteCount reinsertTextInLoop:0];
        [(_UIKeyboardStateManager *)self setChangedDelegate];
      }
    }
  }
}

- (void)acceptHandwritingCandidate
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  isHandwritingPlane = [layout isHandwritingPlane];

  if (isHandwritingPlane)
  {
    acceptCurrentCandidate = [(_UIKeyboardStateManager *)self acceptCurrentCandidate];
  }
}

- (id)acceptCurrentCandidateForInput:(id)input
{
  inputCopy = input;
  currentCandidate = [(UIKeyboardCandidateList *)self->m_candidateList currentCandidate];
  v6 = currentCandidate;
  if (currentCandidate)
  {
    defaultCandidate = currentCandidate;
  }

  else
  {
    defaultCandidate = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet defaultCandidate];
  }

  v8 = defaultCandidate;

  if (_os_feature_enabled_impl() && ([v8 candidateProperty] & 0x10) != 0)
  {
    v12 = +[UIKeyboardImpl activeInstance];
    textInputTraits = [v12 textInputTraits];
    inputContextHistory = [textInputTraits inputContextHistory];

    if ([_UISmartReplyFeedbackManager candidateIsSmartReply:v8])
    {
      label = [v8 label];
      inputContextHistory2 = [(TIKeyboardState *)self->m_keyboardState inputContextHistory];
      threadIdentifier = [inputContextHistory2 threadIdentifier];
      smartReplyFeedbackManager = [(_UIKeyboardStateManager *)self smartReplyFeedbackManager];
      [_UISmartReplyFeedbackManager userSelectedSmartReply:label isLongForm:1 withMailOrMsgThreadId:threadIdentifier withConversationType:2 withSmartReplyFeedbackManagerInstance:smartReplyFeedbackManager];
    }

    mainBundle = [MEMORY[0x1E696AAE8] mainBundle];
    bundleIdentifier = [mainBundle bundleIdentifier];
    if ([bundleIdentifier isEqualToString:@"com.apple.mobilemail"])
    {
    }

    else
    {
      v20 = +[UIKeyboard isKeyboardProcess];

      if (!v20)
      {
        if (!_os_feature_enabled_impl())
        {
          goto LABEL_20;
        }

        inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
        privateInputDelegate = [inputDelegateManager privateInputDelegate];

        if (objc_opt_respondsToSelector())
        {
          v26 = [UISmartReplySuggestion alloc];
          candidate = [v8 candidate];
          v28 = [(UISmartReplySuggestion *)v26 initWithSmartReply:candidate];

          [privateInputDelegate performSelector:sel_insertInputSuggestion_ withObject:v28];
        }

        [(_UIKeyboardStateManager *)self conversationContext:0 didChange:0];
LABEL_19:

LABEL_20:
        v23 = v8;
        goto LABEL_21;
      }
    }

    privateInputDelegate = [v8 candidate];
    tiInputContextHistory = [inputContextHistory tiInputContextHistory];
    [(_UIKeyboardStateManager *)self _startSmartReplyWritingToolWithPrompt:0 entryPoint:privateInputDelegate inputContextHistory:tiInputContextHistory];

    goto LABEL_19;
  }

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [(_UIKeyboardStateManager *)self insertTextSuggestionCandidate:v8];
    v9 = v8;
    goto LABEL_22;
  }

  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = __58___UIKeyboardStateManager_acceptCurrentCandidateForInput___block_invoke;
  aBlock[3] = &unk_1E70FDD80;
  aBlock[4] = self;
  inputContextHistory = _Block_copy(aBlock);
  if (![v8 isSupplementalItemCandidate])
  {
    if (([v8 customInfoType] & 0x20) != 0)
    {
      [(_UIKeyboardStateManager *)self acceptAutofillExtraCandidateIfNeeded:v8];
    }

    (inputContextHistory)[2](inputContextHistory, v8, inputCopy);
    goto LABEL_20;
  }

  v29[0] = MEMORY[0x1E69E9820];
  v29[1] = 3221225472;
  v29[2] = __58___UIKeyboardStateManager_acceptCurrentCandidateForInput___block_invoke_5;
  v29[3] = &unk_1E70FDDA8;
  v31 = inputContextHistory;
  v30 = inputCopy;
  [(_UIKeyboardStateManager *)self _acceptSupplementalCandidate:v8 completion:v29];
  v11 = v8;

LABEL_21:
LABEL_22:

  return v8;
}

- (id)acceptInlineCandidateForInput:(id)input withSpace:(BOOL)space
{
  spaceCopy = space;
  inputCopy = input;
  defaultCandidate = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet defaultCandidate];
  v8 = defaultCandidate;
  if (spaceCopy && defaultCandidate)
  {
    candidate = [defaultCandidate candidate];
    v10 = [candidate stringByAppendingString:@" "];

    v11 = [v8 candidateByReplacingWithCandidate:v10];

    v8 = v11;
  }

  if (qword_1ED49D3D8 != -1)
  {
    dispatch_once(&qword_1ED49D3D8, &__block_literal_global_1536);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v17[0] = MEMORY[0x1E69E9820];
  v17[1] = 3221225472;
  v17[2] = __67___UIKeyboardStateManager_acceptInlineCandidateForInput_withSpace___block_invoke_3;
  v17[3] = &unk_1E70FD208;
  v17[4] = self;
  v13 = v8;
  v18 = v13;
  v19 = inputCopy;
  v14 = qword_1ED49D3D0;
  v15 = inputCopy;
  [taskQueue performSingleTask:v17 breadcrumb:v14];

  return v13;
}

- (void)acceptCandidate:(id)candidate forInput:(id)input executionContext:(id)context
{
  candidateCopy = candidate;
  contextCopy = context;
  [(_UIKeyboardStateManager *)self acceptCandidate:candidateCopy forInput:input];
  [(_UIKeyboardStateManager *)self flushKeyboardOutputOnInputSourceSession];
  if ([(_UIKeyboardStateManager *)self usesAutocorrectionLists])
  {
    [contextCopy returnExecutionToParent];
  }

  else
  {
    v12 = MEMORY[0x1E69E9820];
    v13 = 3221225472;
    v14 = __69___UIKeyboardStateManager_acceptCandidate_forInput_executionContext___block_invoke;
    v15 = &unk_1E70FD1B8;
    selfCopy = self;
    v10 = candidateCopy;
    v17 = v10;
    v11 = [contextCopy childWithContinuation:&v12];

    [(_UIKeyboardStateManager *)self handleAcceptedCandidate:v10 executionContext:v11, v12, v13, v14, v15, selfCopy];
  }
}

- (void)acceptFirstCandidate
{
  v24 = *MEMORY[0x1E69E9840];
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  candidates = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet candidates];
  v4 = [candidates countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v4)
  {
    v5 = v4;
    v6 = *v20;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*v20 != v6)
        {
          objc_enumerationMutation(candidates);
        }

        v8 = *(*(&v19 + 1) + 8 * i);
        null = [MEMORY[0x1E695DFB0] null];

        if (v8 != null)
        {
          if ([v8 isSupplementalItemCandidate])
          {
            defaultCandidate = 0;
          }

          else
          {
            defaultCandidate = v8;
          }

          if ([v8 supplementalItemPrefix])
          {
            supplementalItemIdentifiers = [v8 supplementalItemIdentifiers];
            v12 = [supplementalItemIdentifiers count];

            if (v12 == 1)
            {
              v13 = v8;

              defaultCandidate = v13;
            }
          }

          if (-[_UIKeyboardStateManager liveConversionEnabled](self, "liveConversionEnabled") && ([v8 isInlineCandidate] & 1) == 0)
          {
          }

          else if (defaultCandidate)
          {

            goto LABEL_21;
          }
        }
      }

      v5 = [candidates countByEnumeratingWithState:&v19 objects:v23 count:16];
    }

    while (v5);
  }

  defaultCandidate = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet defaultCandidate];
  if (defaultCandidate)
  {
LABEL_21:
    if (qword_1ED49D3E8 != -1)
    {
      dispatch_once(&qword_1ED49D3E8, &__block_literal_global_1540);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v17[0] = MEMORY[0x1E69E9820];
    v17[1] = 3221225472;
    v17[2] = __47___UIKeyboardStateManager_acceptFirstCandidate__block_invoke_3;
    v17[3] = &unk_1E70FD1B8;
    v17[4] = self;
    v18 = defaultCandidate;
    v15 = qword_1ED49D3E0;
    v16 = defaultCandidate;
    [taskQueue performTask:v17 breadcrumb:v15];
  }
}

- (void)acceptCurrentCandidateIfSelected
{
  if ([(_UIKeyboardStateManager *)self userSelectedCurrentCandidate])
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    geometryIsChanging = [WeakRetained geometryIsChanging];

    if ((geometryIsChanging & 1) == 0)
    {
      if (qword_1ED49D3F8 != -1)
      {
        dispatch_once(&qword_1ED49D3F8, &__block_literal_global_1544);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      v6[0] = MEMORY[0x1E69E9820];
      v6[1] = 3221225472;
      v6[2] = __59___UIKeyboardStateManager_acceptCurrentCandidateIfSelected__block_invoke_3;
      v6[3] = &unk_1E70FD058;
      v6[4] = self;
      [taskQueue performSingleTask:v6 breadcrumb:qword_1ED49D3F0];
    }
  }
}

- (void)acceptCurrentCandidateIfSelectedWithExecutionContext:(id)context
{
  contextCopy = context;
  if ([(_UIKeyboardStateManager *)self userSelectedCurrentCandidate])
  {
    currentCandidate = [(UIKeyboardCandidateList *)self->m_candidateList currentCandidate];
    [(_UIKeyboardStateManager *)self acceptCandidate:currentCandidate];
    [(_UIKeyboardStateManager *)self flushKeyboardOutputOnInputSourceSession];
    v8 = MEMORY[0x1E69E9820];
    v9 = 3221225472;
    v10 = __80___UIKeyboardStateManager_acceptCurrentCandidateIfSelectedWithExecutionContext___block_invoke;
    v11 = &unk_1E70FD1B8;
    selfCopy = self;
    v13 = currentCandidate;
    v6 = currentCandidate;
    v7 = [contextCopy childWithContinuation:&v8];
    [(_UIKeyboardStateManager *)self handleAcceptedCandidate:v6 executionContext:v7, v8, v9, v10, v11, selfCopy];
  }

  else
  {
    [contextCopy returnExecutionToParent];
  }
}

- (void)completeAcceptCandidate:(id)candidate
{
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  inputCount = [inputManagerState inputCount];

  if (inputCount)
  {
    [(_UIKeyboardStateManager *)self completeAddInputString:0];
    if (!candidate)
    {
      return;
    }
  }

  else if (!self->m_shouldSkipCandidateGeneration && (v7 = [(_UIKeyboardStateManager *)self suppliesCompletions], candidate) && v7)
  {
    [(_UIKeyboardStateManager *)self generateCandidatesWithOptions:2];
    [(_UIKeyboardStateManager *)self updateCandidateDisplay];
    [(_UIKeyboardStateManager *)self updateReturnKey];
  }

  else
  {
    [(_UIKeyboardStateManager *)self updateReturnKey];
    if (!candidate)
    {
      return;
    }
  }

  [(_UIKeyboardStateManager *)self _postInputResponderCapabilitiesChangedNotificationWithOutput:0 selectionChanged:0];
}

- (void)candidateListAcceptCandidate:(id)candidate
{
  v4 = *MEMORY[0x1E69D9720];
  candidateCopy = candidate;
  [(_UIKeyboardStateManager *)self acceptingCandidateWithTrigger:v4];
  +[UIKBAnalyticsDispatcher didCandidateBarAction];
  v6 = +[UIKBAnalyticsDispatcher sharedInstance];
  [v6 setNextCommitTextSource:2];

  m_candidateList = self->m_candidateList;
  if (m_candidateList == candidateCopy)
  {
    currentCandidate = [(UIKeyboardCandidateList *)m_candidateList currentCandidate];
    type = [objc_opt_class() type];

    if (type != 3)
    {
      [(_UIKeyboardStateManager *)self trackUsageForCandidateAcceptedAction:*MEMORY[0x1E69D99F0]];
    }

    if ([(_UIKeyboardStateManager *)self usesCandidateSelection]&& ![(_UIKeyboardStateManager *)self shouldShowLongPredictionList])
    {
      acceptCurrentCandidate = [(_UIKeyboardStateManager *)self acceptCurrentCandidate];
    }

    else
    {
      if (qword_1ED49D408 != -1)
      {
        dispatch_once(&qword_1ED49D408, &__block_literal_global_1548);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      v12[0] = MEMORY[0x1E69E9820];
      v12[1] = 3221225472;
      v12[2] = __56___UIKeyboardStateManager_candidateListAcceptCandidate___block_invoke_3;
      v12[3] = &unk_1E70FD058;
      v12[4] = self;
      [taskQueue performTask:v12 breadcrumb:qword_1ED49D400];
    }
  }
}

- (void)candidateListSelectionDidChange:(id)change
{
  changeCopy = change;
  currentIndex = [(UIKeyboardCandidateList *)changeCopy currentIndex];
  if (currentIndex != [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet initialSelectedIndex])
  {
    currentCandidate = [(UIKeyboardCandidateList *)changeCopy currentCandidate];
    if (currentCandidate)
    {
      v6 = currentCandidate;
      currentCandidate2 = [(UIKeyboardCandidateList *)changeCopy currentCandidate];
      type = [objc_opt_class() type];

      if (type != 3)
      {
        [(_UIKeyboardStateManager *)self setUserSelectedCurrentCandidate:1];
      }
    }
  }

  if (![(_UIKeyboardStateManager *)self committingCandidate]&& self->m_candidateList == changeCopy && ![(_UIKeyboardStateManager *)self usesAutocorrectionLists])
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [WeakRetained layout];
    hasActiveContinuousPathInput = [layout hasActiveContinuousPathInput];

    if ((hasActiveContinuousPathInput & 1) == 0)
    {
      [(_UIKeyboardStateManager *)self syncInputManagerToKeyboardState];
      [(_UIKeyboardStateManager *)self updateKeyboardConfigurations];
    }
  }
}

- (void)clearInputWithCandidatesCleared:(BOOL)cleared
{
  clearedCopy = cleared;
  [(_UIKeyboardStateManager *)self clearInputForMarkedText];
  if (clearedCopy)
  {
    if (!self->m_disableClearingTextSuggestions)
    {
      if (self->m_textInputUpdatingSelection)
      {
        v5 = ![(_UIKeyboardStateManager *)self noContent];
      }

      else
      {
        LOBYTE(v5) = 1;
      }

      if ((v5 & self->m_shouldClearTextSuggestions) != 0)
      {
        autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
        [autocorrectionController clearAutofillAndTextSuggestions];
      }
    }

    if ([(_UIKeyboardStateManager *)self noContent])
    {
      [(_UIKeyboardStateManager *)self removeTextChoiceUnderlines];
      [(_UIKeyboardStateManager *)self removeTextChoicePrompt];
    }

    [(_UIKeyboardStateManager *)self setAutocorrection:0];
    [(_UIKeyboardStateManager *)self setCandidates:0];
    [(_UIKeyboardStateManager *)self updateCandidateDisplay];
    if (self->_isSettingExtensionInputMode)
    {
      self->_needsUpdateAssistantView = 1;
    }

    else
    {
      [(_UIKeyboardStateManager *)self updateAssistantView];
    }

    [(_UISmartReplyFeedbackManager *)self->_smartReplyFeedbackManager resetOnKeyboardCandidatesCleared];
  }

  else
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    candidateController = [WeakRetained candidateController];
    [candidateController clearCurrentCandidate];

    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager selectedTextRange];

    if (selectedTextRange)
    {
      _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      selectedTextRange2 = [inputDelegateManager2 selectedTextRange];
      start = [selectedTextRange2 start];
      [_textChoicesAssistant clearUnderlinesIfNeededBeforePosition:start];
    }
  }

  v15 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [v15 layout];
  [layout didClearInput];

  if (!self->m_hasInputOnAcceptCandidate)
  {
    v18 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v18 layout];
    [layout2 restoreDefaultsForAllKeys];
  }
}

- (void)removeRecentInput:(id)input completionHandler:(id)handler
{
  handlerCopy = handler;
  v6 = MEMORY[0x1E69D9690];
  m_keyboardState = self->m_keyboardState;
  inputCopy = input;
  textInputTraits = [(TIKeyboardState *)m_keyboardState textInputTraits];
  recentInputIdentifier = [textInputTraits recentInputIdentifier];
  [v6 removeInput:inputCopy forSystemIdentifier:recentInputIdentifier];

  v11 = MEMORY[0x1E69D9690];
  textInputTraits2 = [(TIKeyboardState *)self->m_keyboardState textInputTraits];
  recentInputIdentifier2 = [textInputTraits2 recentInputIdentifier];
  v14 = [v11 recentInputForIdentifier:recentInputIdentifier2];

  v15 = [UILexicon _lexiconWithTILexicon:v14];
  if (handlerCopy)
  {
    handlerCopy[2](handlerCopy, v15);
  }
}

- (void)acceptRecentInput:(id)input
{
  inputCopy = input;
  if (qword_1ED49D418 != -1)
  {
    dispatch_once(&qword_1ED49D418, &__block_literal_global_1554);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v8[0] = MEMORY[0x1E69E9820];
  v8[1] = 3221225472;
  v8[2] = __45___UIKeyboardStateManager_acceptRecentInput___block_invoke_3;
  v8[3] = &unk_1E70FD1B8;
  v8[4] = self;
  v9 = inputCopy;
  v6 = qword_1ED49D410;
  v7 = inputCopy;
  [taskQueue performTask:v8 breadcrumb:v6];
}

- (void)addInputObject:(id)object
{
  objectCopy = object;
  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  isMainThreadExecutingTask = [taskQueue isMainThreadExecutingTask];

  if (isMainThreadExecutingTask)
  {
    currentHandler = [MEMORY[0x1E696AAA8] currentHandler];
    [currentHandler handleFailureInMethod:a2 object:self file:@"_UIKeyboardStateManager.m" lineNumber:15317 description:{@"Received %s while performing another keyboard action.", "-[_UIKeyboardStateManager addInputObject:]"}];
  }

  if (qword_1ED49D428 != -1)
  {
    dispatch_once(&qword_1ED49D428, &__block_literal_global_1558);
  }

  taskQueue2 = [(_UIKeyboardStateManager *)self taskQueue];
  v12[0] = MEMORY[0x1E69E9820];
  v12[1] = 3221225472;
  v12[2] = __42___UIKeyboardStateManager_addInputObject___block_invoke_3;
  v12[3] = &unk_1E70FD1B8;
  v12[4] = self;
  v13 = objectCopy;
  v9 = qword_1ED49D420;
  v10 = objectCopy;
  [taskQueue2 addTask:v12 breadcrumb:v9];
}

- (void)addInputObject:(id)object executionContext:(id)context
{
  objectCopy = object;
  contextCopy = context;
  if ([(_UIKeyboardStateManager *)self isInHardwareKeyboardMode])
  {
    [(TIKeyboardState *)self->m_keyboardState setHardwareKeyboardMode:0];
    [(_UIKeyboardStateManager *)self syncInputManagerToKeyboardState];
    [(_UIKeyboardStateManager *)self removeCandidateList];
    if (qword_1ED49D438 != -1)
    {
      dispatch_once(&qword_1ED49D438, &__block_literal_global_1562);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v16[0] = MEMORY[0x1E69E9820];
    v16[1] = 3221225472;
    v16[2] = __59___UIKeyboardStateManager_addInputObject_executionContext___block_invoke_3;
    v16[3] = &unk_1E70FD058;
    v16[4] = self;
    [taskQueue addTask:v16 breadcrumb:qword_1ED49D430];
  }

  v9 = +[UIKeyboardInputModeController sharedInputModeController];
  v10 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v10 currentInputMode];
  [v9 updateLastUsedInputMode:currentInputMode];

  v14[0] = MEMORY[0x1E69E9820];
  v14[1] = 3221225472;
  v14[2] = __59___UIKeyboardStateManager_addInputObject_executionContext___block_invoke_4;
  v14[3] = &unk_1E70FD1B8;
  v14[4] = self;
  v15 = objectCopy;
  v12 = objectCopy;
  v13 = [contextCopy childWithContinuation:v14];

  [(_UIKeyboardStateManager *)self acceptCurrentCandidateIfSelectedWithExecutionContext:v13];
}

- (void)completeAcceptCandidateBeforeAddingInputObject:(id)object executionContext:(id)context
{
  contextCopy = context;
  objectCopy = object;
  [(_UIKeyboardStateManager *)self updateChangeTimeAndIncrementCount];
  [(_UIKeyboardStateManager *)self setPreviousInputString:&stru_1EFB14550];
  self->m_acceptingCandidate = 0;
  [(_UIKeyboardStateManager *)self clearTransientState];
  v8 = objc_alloc_init(MEMORY[0x1E69D95F8]);
  [v8 setObject:objectCopy];

  v10[0] = MEMORY[0x1E69E9820];
  v10[1] = 3221225472;
  v10[2] = __91___UIKeyboardStateManager_completeAcceptCandidateBeforeAddingInputObject_executionContext___block_invoke;
  v10[3] = &unk_1E70FD058;
  v10[4] = self;
  v9 = [contextCopy childWithContinuation:v10];

  [(_UIKeyboardStateManager *)self handleKeyboardInput:v8 executionContext:v9];
}

- (void)clearDelegate
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  v3InputDelegate = [inputDelegate inputDelegate];

  if (v3InputDelegate == self)
  {
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate2 setInputDelegate:0];
  }

  asyncInputDelegate = [(_UIKeyboardStateManager *)self asyncInputDelegate];

  if (asyncInputDelegate)
  {
    asyncInputDelegate2 = [(_UIKeyboardStateManager *)self asyncInputDelegate];
    asyncSystemInputDelegate = [asyncInputDelegate2 asyncSystemInputDelegate];

    if (asyncSystemInputDelegate == self)
    {
      asyncInputDelegate3 = [(_UIKeyboardStateManager *)self asyncInputDelegate];
      [asyncInputDelegate3 setAsyncSystemInputDelegate:0];
    }
  }

  webInputDelegate = [(_UIKeyboardStateManager *)self webInputDelegate];

  if (webInputDelegate)
  {
    webInputDelegate2 = [(_UIKeyboardStateManager *)self webInputDelegate];
    asyncInputDelegate4 = [webInputDelegate2 asyncInputDelegate];

    if (asyncInputDelegate4 == self)
    {
      webInputDelegate3 = [(_UIKeyboardStateManager *)self webInputDelegate];
      [webInputDelegate3 setAsyncInputDelegate:0];
    }
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager clearDelegate];
}

- (void)clearRemoteTextInputPartner
{
  if (+[UIKeyboard usesInputSystemUI])
  {
    [(UIKBRTIPartner *)self->_remoteTextInputPartner invalidate];
    [(UIKBRTIPartner *)self->_remoteTextInputPartner setPartnerDelegate:0];
    remoteTextInputPartner = self->_remoteTextInputPartner;
    self->_remoteTextInputPartner = 0;
  }
}

- (void)deferReplaceTextActionToSystem:(id)system
{
  systemCopy = system;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    currentHandler = [MEMORY[0x1E696AAA8] currentHandler];
    [currentHandler handleFailureInMethod:a2 object:self file:@"_UIKeyboardStateManager.m" lineNumber:15425 description:@"Expected argument to be of class UITextReplacement"];
  }

  [(_UIKeyboardStateManager *)self replaceText:systemCopy];
}

- (void)replaceText:(id)text
{
  textCopy = text;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  hasAsyncCapableInputDelegate = [inputDelegateManager hasAsyncCapableInputDelegate];

  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  v7 = inputDelegate;
  if (!inputDelegate || hasAsyncCapableInputDelegate)
  {
  }

  else
  {
    originalText = [textCopy originalText];
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    range = [textCopy range];
    v11 = [inputDelegateManager2 textInRange:range];
    v12 = [originalText isEqual:v11];

    if (!v12)
    {
      goto LABEL_26;
    }
  }

  inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
  [(_UIKeyboardStateManager *)self textWillChange:inputDelegate2];

  range2 = [textCopy range];
  inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager3 setSelectedTextRange:range2];

  [UITextChecker noteTextReplacement:textCopy];
  replacementText = [textCopy replacementText];
  if (!+[UIDictationController supportsSiriDictationVoiceCommandsAdjacentEdits](UIDictationController, "supportsSiriDictationVoiceCommandsAdjacentEdits") && [textCopy isDictationCommandReplacement] && -[_UIKeyboardStateManager isSelectionAtSentenceAutoshiftBoundary:](self, "isSelectionAtSentenceAutoshiftBoundary:", 0))
  {
    v17 = [UIDictationUtilities capitalizeFirstWord:replacementText];

    replacementText = v17;
  }

  v18 = MEMORY[0x1E69D95F0];
  originalText2 = [textCopy originalText];
  v20 = [v18 candidateWithCandidate:replacementText forInput:originalText2];

  candidate = [v20 candidate];
  _containsEmojiOnly = [candidate _containsEmojiOnly];

  if (_containsEmojiOnly)
  {
    v23 = [(_UIKeyboardStateManager *)self emojiCandidate:v20];

    v20 = v23;
  }

  v24 = 1;
  self->m_replacingWord = 1;
  [(_UIKeyboardStateManager *)self acceptWord:v20 firstDelete:0];
  [(_UIKeyboardStateManager *)self flushKeyboardOutputOnInputSourceSession];
  self->m_replacingWord = 0;
  self->m_suppressingDocumentAssertions = 1;
  inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
  [(_UIKeyboardStateManager *)self textDidChange:inputDelegate3];

  self->m_suppressingDocumentAssertions = 0;
  lowercaseString = [replacementText lowercaseString];
  originalText3 = [textCopy originalText];
  lowercaseString2 = [originalText3 lowercaseString];
  v29 = [lowercaseString isEqualToString:lowercaseString2];

  if ((v29 & 1) == 0)
  {
    replacementText2 = [textCopy replacementText];
    v31 = latinRatio(replacementText2);

    originalText4 = [textCopy originalText];
    v33 = latinRatio(originalText4);

    if (v31 <= v33)
    {
      if (v33 <= v31)
      {
        v24 = 0;
      }

      else
      {
        v24 = 3;
      }
    }

    else
    {
      v24 = 2;
    }
  }

  v34 = +[UIKBAnalyticsDispatcher sharedInstance];
  nextCandidateReplacementSource = [v34 nextCandidateReplacementSource];

  if (nextCandidateReplacementSource == 8)
  {
    originalText5 = [textCopy originalText];
    [UIKBAnalyticsDispatcher didCandidateReplacementWithRemovedText:originalText5 insertedText:replacementText];
    goto LABEL_22;
  }

  if (!nextCandidateReplacementSource)
  {
    originalText5 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
    _textInputSessionAnalytics = [originalText5 _textInputSessionAnalytics];
    [_textInputSessionAnalytics didReplaceWithCandidate:v24];

LABEL_22:
  }

  if ([textCopy usageTrackingMask])
  {
    v38 = UIKeyboardGetCurrentInputMode();
    v39 = UIKeyboardInputModeGetIdentifierWithKeyboardLayouts(v38);

    [textCopy usageTrackingMask];
    TIStatisticScalarIncrementAutocorrectionKey();
  }

LABEL_26:
}

- (void)scheduleReplacementsWithOptions:(unint64_t)options
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  interactionAssistant = [inputDelegate interactionAssistant];

  v6 = interactionAssistant;
  if (interactionAssistant)
  {
    [interactionAssistant scheduleReplacementsWithOptions:options];
  }

  else
  {
    if ((options & 0x20) == 0)
    {
      goto LABEL_6;
    }

    _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager selectedTextRange];
    [_textChoicesAssistant showAutocorrectReplacementChoicesIfNeeded:inputDelegate2 forRange:selectedTextRange];
  }

  v6 = interactionAssistant;
LABEL_6:
}

- (BOOL)acceptWord:(id)word firstDelete:(unint64_t)delete forInput:(id)input
{
  wordCopy = word;
  inputCopy = input;
  v9 = wordCopy;
  candidate = [v9 candidate];
  v11 = [candidate length];
  input = [v9 input];
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  inputString = [inputManagerState inputString];

  if (!input)
  {
    input = inputString;
  }

  LODWORD(v15) = [input length];
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];

  if (!candidate)
  {
    goto LABEL_57;
  }

  v55 = inputString;
  v18 = inputCopy;
  if (+[UIKeyboard usesInputSystemUI]&& [(_UIKeyboardStateManager *)self isRTIClient])
  {
    v19 = ![(_UIKeyboardStateManager *)self performingRemoteTextOperations];
    if (!v11)
    {
      goto LABEL_10;
    }
  }

  else
  {
    candidates = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet candidates];
    LOBYTE(v19) = [candidates count] == 0;

    if (!v11)
    {
      goto LABEL_10;
    }
  }

  if (!(v19 & 1 | ![(_UIKeyboardStateManager *)self usesCandidateSelection]))
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];

    if (!inputDelegate || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v28 = objc_claimAutoreleasedReturnValue(), v29 = [v28 callShouldReplaceExtendedRange:delete withText:candidate includeMarkedText:{-[_UIKeyboardStateManager _hasMarkedText](self, "_hasMarkedText")}], v28, v29))
    {
      inputCopy = v18;
      if (!forwardingInputDelegate)
      {
        v60[0] = MEMORY[0x1E69E9820];
        v60[1] = 3221225472;
        v60[2] = __59___UIKeyboardStateManager_acceptWord_firstDelete_forInput___block_invoke;
        v60[3] = &unk_1E70FDDD0;
        v61 = v9;
        v62 = candidate;
        [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v60 shouldFlush:0];
      }

      deleteCopy = delete;
      if (delete > v15)
      {
        if (v15)
        {
          self->m_textInputChangesIgnored = 1;
          inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          [inputDelegateManager2 unmarkText];

          self->m_textInputChangesIgnored = 0;
          deleteCopy = delete - v15;
          inputCopy = v18;
        }

        [(_UIKeyboardStateManager *)self deleteBackwardAndNotifyAtEnd:0 deletionCount:deleteCopy reinsertTextInLoop:0];
      }

      self->m_textInputChangesIgnored = 1;
      isSupplementalItemCandidate = [v9 isSupplementalItemCandidate];
      if (isSupplementalItemCandidate)
      {
        [(_UIKeyboardStateManager *)self _willReplaceText:candidate withSupplementalCandidate:v9];
      }

      if (self->m_replacingWord || ([input isEqualToString:@" "] & 1) == 0 && (+[UIKeyboard isKeyboardProcess](UIKeyboard, "isKeyboardProcess") || !_AXSExtendedKeyboardPredictionsEnabled()))
      {
        documentState = [(_UIKeyboardStateManager *)self documentState];
        v34 = [documentState documentStateAfterSettingMarkedText:candidate selectedRange:{objc_msgSend(candidate, "length"), 0}];
        [(_UIKeyboardStateManager *)self setDocumentState:v34];

        inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        [inputDelegateManager3 _setMarkedText:candidate selectedRange:{objc_msgSend(candidate, "length"), 0}];

        inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        [inputDelegateManager4 unmarkText];
      }

      else
      {
        [(_UIKeyboardStateManager *)self applyAutocorrection:v9];
      }

      if (!+[UIKeyboard isKeyboardProcess]&& ((isSupplementalItemCandidate ^ 1) & 1) == 0)
      {
        [(_UIKeyboardStateManager *)self _didReplaceText:candidate withSupplementalCandidate:v9];
        [(_UIKeyboardStateManager *)self _insertSupplementalCandidate:v9 overridingCandidateText:candidate];
      }

      self->m_textInputChangesIgnored = 0;
      [(_UIKeyboardStateManager *)self removeAutocorrectPromptAndCandidateList];
      goto LABEL_50;
    }

LABEL_33:
    v37 = 0;
    inputCopy = v18;
    goto LABEL_51;
  }

LABEL_10:
  if (v15 && ([candidate isEqualToString:input] & 1) != 0)
  {
    goto LABEL_33;
  }

  inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];

  inputCopy = v18;
  if (inputDelegate2)
  {
    inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager5 selectedTextRange];
    v15 = [selectedTextRange isEmpty] ? v15 : 0;

    inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    v25 = [inputDelegateManager6 callShouldReplaceExtendedRange:v15 withText:candidate includeMarkedText:0];

    if (!v25)
    {
      v37 = 0;
      goto LABEL_51;
    }
  }

  if (!forwardingInputDelegate)
  {
    v57[0] = MEMORY[0x1E69E9820];
    v57[1] = 3221225472;
    v57[2] = __59___UIKeyboardStateManager_acceptWord_firstDelete_forInput___block_invoke_2;
    v57[3] = &unk_1E70FDDD0;
    v58 = v9;
    v59 = candidate;
    [(_UIKeyboardStateManager *)self performKeyboardOutputOnInputSourceSession:v57 shouldFlush:0];
  }

  if (self->m_replacingWord)
  {
    inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager7 replaceRange:0 oldText:0 withText:candidate forReplaceAction:1];
  }

  else
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    inputDelegateManager7 = [WeakRetained autocorrectPrompt];

    if (inputDelegateManager7)
    {
      [inputDelegateManager7 frame];
      v40 = v39;
      v42 = v41;
      v44 = v43;
      v46 = v45;
    }

    else
    {
      v40 = *MEMORY[0x1E695F050];
      v42 = *(MEMORY[0x1E695F050] + 8);
      v44 = *(MEMORY[0x1E695F050] + 16);
      v46 = *(MEMORY[0x1E695F050] + 24);
    }

    [(_UIKeyboardStateManager *)self applyAutocorrection:v9];
    [(_UIKeyboardStateManager *)self underlineCandidate:v9];
    candidate2 = [v9 candidate];
    [(_UIKeyboardStateManager *)self animateAutocorrectionToText:candidate2 fromRect:v40, v42, v44, v46];

    [(_UIKeyboardStateManager *)self setAutocorrection:0];
  }

  if ([(_UIKeyboardStateManager *)self isAutoFillMode])
  {
    inputDelegateManager8 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager8 keyInputDelegate];
    v50 = objc_opt_respondsToSelector();

    if (v50)
    {
      inputDelegateManager9 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      keyInputDelegate2 = [inputDelegateManager9 keyInputDelegate];
      [keyInputDelegate2 acceptedAutoFillWord:candidate];
    }
  }

LABEL_50:
  v37 = 1;
LABEL_51:
  inputString = v55;
  if (![(UITextInputTraits *)self->m_traits isSecureTextEntry])
  {
    if (!inputCopy)
    {
      [(_UIKeyboardStateManager *)self flushTouchEventWaitingForKeyInputEventIfNecessary];
      [(_UIKeyboardStateManager *)self textAccepted:v9];
      if (v37)
      {
        goto LABEL_55;
      }

LABEL_57:
      v53 = 0;
      goto LABEL_58;
    }

    [inputCopy setAcceptedCandidate:v9];
  }

  if (!v37)
  {
    goto LABEL_57;
  }

LABEL_55:
  [(_UIKeyboardStateManager *)self setChangedDelegate];
  v53 = 1;
LABEL_58:

  return v53;
}

- (void)processPayloadInfo:(id)info
{
  infoCopy = info;
  v7 = MEMORY[0x1E69E9820];
  v8 = 3221225472;
  v9 = __46___UIKeyboardStateManager_processPayloadInfo___block_invoke;
  v10 = &unk_1E70F35B8;
  selfCopy = self;
  v12 = infoCopy;
  v5 = infoCopy;
  v6 = _Block_copy(&v7);
  if (pthread_main_np() == 1)
  {
    v6[2](v6);
  }

  else
  {
    dispatch_async(MEMORY[0x1E69E96A0], v6);
  }

  [_UIKeyboardUsageTracking appAutofillCredentialFromSafariUI:v7];
}

- (void)pushAutocorrections:(id)autocorrections requestToken:(id)token
{
  autocorrectionsCopy = autocorrections;
  tokenCopy = token;
  if (qword_1ED49D448 != -1)
  {
    dispatch_once(&qword_1ED49D448, &__block_literal_global_1570);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v12[0] = MEMORY[0x1E69E9820];
  v12[1] = 3221225472;
  v12[2] = __60___UIKeyboardStateManager_pushAutocorrections_requestToken___block_invoke_3;
  v12[3] = &unk_1E70FD208;
  v12[4] = self;
  v13 = tokenCopy;
  v14 = autocorrectionsCopy;
  v9 = qword_1ED49D440;
  v10 = autocorrectionsCopy;
  v11 = tokenCopy;
  [taskQueue addTask:v12 breadcrumb:v9];
}

- (void)pushCandidateResultSet:(id)set requestToken:(id)token
{
  setCopy = set;
  tokenCopy = token;
  if (qword_1ED49D458 != -1)
  {
    dispatch_once(&qword_1ED49D458, &__block_literal_global_1584);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v12[0] = MEMORY[0x1E69E9820];
  v12[1] = 3221225472;
  v12[2] = __63___UIKeyboardStateManager_pushCandidateResultSet_requestToken___block_invoke_3;
  v12[3] = &unk_1E70FD208;
  v12[4] = self;
  v13 = tokenCopy;
  v14 = setCopy;
  v9 = qword_1ED49D450;
  v10 = setCopy;
  v11 = tokenCopy;
  [taskQueue addDeferredTask:v12 breadcrumb:v9];
}

- (void)setCandidateList:(id)list
{
  listCopy = list;
  m_candidateList = self->m_candidateList;
  if (m_candidateList != listCopy)
  {
    v11 = listCopy;
    if (([(UIKeyboardCandidateList *)m_candidateList isExtendedList]& 1) != 0 || ![(UIKeyboardCandidateList *)v11 isExtendedList])
    {
      v7 = 0;
    }

    else
    {
      v7 = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet hasMetadata]^ 1;
    }

    v8 = self->m_candidateList;
    objc_storeStrong(&self->m_candidateList, list);
    [(UIKeyboardCandidateList *)self->m_candidateList setUIKeyboardCandidateListDelegate:self];
    [(_UIKeyboardStateManager *)self setUserSelectedCurrentCandidate:0];
    if (v7)
    {
      currentCandidate = [(UIKeyboardCandidateList *)v8 currentCandidate];
      [(_UIKeyboardStateManager *)self generateCandidatesAsynchronouslyWithRange:0 selectedCandidate:0x7FFFFFFFLL, currentCandidate];

      [(_UIKeyboardStateManager *)self updateKeyboardConfigurations];
    }

    else
    {
      if (![(_UIKeyboardStateManager *)self committingCandidate])
      {
        [(_UIKeyboardStateManager *)self syncInputManagerToKeyboardState];
      }

      [(_UIKeyboardStateManager *)self updateKeyboardConfigurations];
      currentCandidate2 = [(UIKeyboardCandidateList *)v8 currentCandidate];
      [(_UIKeyboardStateManager *)self updateCandidateDisplay];
      [(UIKeyboardCandidateList *)self->m_candidateList showCandidate:currentCandidate2];
    }

    listCopy = v11;
  }
}

- (void)_conditionallyNotifyPredictionsAreAvailableForCandidates:(id)candidates containingProactiveTriggers:(BOOL)triggers
{
  triggersCopy = triggers;
  v22 = *MEMORY[0x1E69E9840];
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  candidatesCopy = candidates;
  v7 = [candidatesCopy countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v7)
  {
    v8 = v7;
    v9 = 0;
    v10 = *v18;
LABEL_3:
    v11 = 0;
    while (1)
    {
      if (*v18 != v10)
      {
        objc_enumerationMutation(candidatesCopy);
      }

      v12 = *(*(&v17 + 1) + 8 * v11);
      if ([v12 isResponseKitCandidate])
      {
        responseKitCategory = [v12 responseKitCategory];
        v14 = [&unk_1EFE2B5D8 containsObject:responseKitCategory];

        v9 = 1;
        if (!v14)
        {
          break;
        }
      }

      if (v8 == ++v11)
      {
        v8 = [candidatesCopy countByEnumeratingWithState:&v17 objects:v21 count:16];
        if (v8)
        {
          goto LABEL_3;
        }

        v9 = triggersCopy & ~v9;
        break;
      }
    }
  }

  else
  {
    v9 = triggersCopy;
  }

  predictionFromPreference = [(_UIKeyboardStateManager *)self predictionFromPreference];
  if (predictionFromPreference)
  {
    predictionFromPreference = [(_UIKeyboardStateManager *)self continuousPathUnderway];
  }

  if (predictionFromPreference | v9)
  {
    defaultCenter = [MEMORY[0x1E696AD88] defaultCenter];
    [defaultCenter postNotificationName:@"UIKeyboardPredictionsAvailable" object:0];
  }
}

- (void)setCandidateDisplayIsExtended:(BOOL)extended
{
  extendedCopy = extended;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  candidateController = [WeakRetained candidateController];
  [candidateController setIsExtended:extendedCopy];
}

- (void)updateCandidateDisplayAsyncWithCandidateSet:(id)set
{
  v75 = *MEMORY[0x1E69E9840];
  setCopy = set;
  [setCopy candidates];
  v66 = 0u;
  v67 = 0u;
  v68 = 0u;
  v5 = v69 = 0u;
  v6 = [v5 countByEnumeratingWithState:&v66 objects:v74 count:16];
  if (v6)
  {
    v7 = v6;
    v8 = *v67;
    while (2)
    {
      for (i = 0; i != v7; ++i)
      {
        if (*v67 != v8)
        {
          objc_enumerationMutation(v5);
        }

        v10 = *(*(&v66 + 1) + 8 * i);
        if ([v10 slotID] || (objc_msgSend(v10, "isResponseKitCandidate") & 1) != 0)
        {
          v11 = 1;
          goto LABEL_13;
        }
      }

      v7 = [v5 countByEnumeratingWithState:&v66 objects:v74 count:16];
      v11 = 0;
      if (v7)
      {
        continue;
      }

      break;
    }
  }

  else
  {
    v11 = 0;
  }

LABEL_13:

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  v13 = objc_opt_class();
  v72 = @"UIKeyboardPerformanceSearchFoundProactiveResults";
  v14 = [MEMORY[0x1E696AD98] numberWithBool:v11];
  v73 = v14;
  v15 = [MEMORY[0x1E695DF20] dictionaryWithObjects:&v73 forKeys:&v72 count:1];
  [v13 sendPerformanceNotification:@"UIKeyboardPerformanceSearchCandidatesEndNotification" userInfo:v15];

  committedText = [setCopy committedText];

  if (committedText)
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];

    if (inputDelegate && (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v18 = objc_claimAutoreleasedReturnValue(), [setCopy committedText], v19 = objc_claimAutoreleasedReturnValue(), v20 = objc_msgSend(v18, "callShouldReplaceExtendedRange:withText:includeMarkedText:", 0, v19, -[_UIKeyboardStateManager _hasMarkedText](self, "_hasMarkedText")), v19, v18, !v20))
    {
      [(_UIKeyboardStateManager *)self unmarkText:&stru_1EFB14550];
    }

    else
    {
      committedText2 = [setCopy committedText];
      [(_UIKeyboardStateManager *)self unmarkText:committedText2];
    }

    v22 = objc_loadWeakRetained(&self->_presentationDelegate);
    candidateController = [v22 candidateController];
    barIsExtended = [candidateController barIsExtended];

    if (barIsExtended)
    {
      v25 = objc_loadWeakRetained(&self->_presentationDelegate);
      candidateController2 = [v25 candidateController];
      [candidateController2 collapse];
    }
  }

  uncommittedText = [setCopy uncommittedText];
  if ([(_UIKeyboardStateManager *)self _hasMarkedText])
  {
    v28 = 0;
    if (!uncommittedText)
    {
      goto LABEL_29;
    }
  }

  else
  {
    displayString = [uncommittedText displayString];
    if ([displayString length] || (objc_msgSend(uncommittedText, "selectedRange"), v30))
    {
      v28 = 0;
    }

    else
    {
      inputString = [uncommittedText inputString];
      if ([inputString length])
      {
        v28 = 0;
      }

      else
      {
        searchString = [uncommittedText searchString];
        v28 = [searchString length] == 0;
      }
    }

    if (!uncommittedText)
    {
      goto LABEL_29;
    }
  }

  if (!v28)
  {
    [(_UIKeyboardStateManager *)self assertIntermediateText:uncommittedText];
  }

LABEL_29:
  candidates = [setCopy candidates];
  firstObject = [candidates firstObject];

  if (objc_opt_respondsToSelector())
  {
    v33 = ([firstObject candidateProperty] >> 1) & 1;
  }

  else
  {
    LODWORD(v33) = 0;
  }

  if (![(_UIKeyboardStateManager *)self userSelectedCurrentCandidate])
  {
    [(_UIKeyboardStateManager *)self setCommittingCandidate:0];
    [(_UIKeyboardStateManager *)self setCandidates:setCopy];
    if ([setCopy hasCandidates] && (((v11 | v33) & 1) != 0 || !-[_UIKeyboardStateManager shouldPrioritizeTextSuggestionsOverCandidateResultSet:](self, "shouldPrioritizeTextSuggestionsOverCandidateResultSet:", setCopy)))
    {
      defaultCenter = [MEMORY[0x1E696AD88] defaultCenter];
      [defaultCenter postNotificationName:@"UIKeyboardCandidatesAvailable" object:0];

      if (+[UIKeyboard isKeyboardProcess])
      {
        textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
        hidePrediction = [textInputTraits hidePrediction];

        if (hidePrediction)
        {
          textInputTraits2 = [(_UIKeyboardStateManager *)self textInputTraits];
          [textInputTraits2 setHidePrediction:0];

          remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
          v70 = @"name";
          v71 = @"UIKeyboardCandidatesAvailable";
          v39 = [MEMORY[0x1E695DF20] dictionaryWithObjects:&v71 forKeys:&v70 count:1];
          [remoteTextInputPartner forwardKeyboardOperation:sel_postNotificationName_ object:v39];
        }
      }
    }

    [(_UIKeyboardStateManager *)self updateCandidateDisplay];
    [(_UIKeyboardStateManager *)self updateReturnKey];
    v40 = +[UIKeyboard activeKeyboard];
    [v40 _didChangeCandidateList];

    if ([(_UIKeyboardStateManager *)self shouldShowLongPredictionList]&& (objc_opt_respondsToSelector() & 1) != 0)
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      selectedTextRange = [inputDelegateManager selectedTextRange];
      start = [selectedTextRange start];

      inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
      tokenizer = [inputDelegate2 tokenizer];
      v46 = [tokenizer rangeEnclosingPosition:start withGranularity:2 inDirection:1];

      if (v46)
      {
        start2 = [v46 start];
        inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
        v48 = [inputDelegate3 textRangeFromPosition:start2 toPosition:start];

        inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        v50 = [inputDelegateManager2 textInRange:v48];

        [(UIKeyboardCandidateList *)self->m_candidateList setInlineText:v50];
      }
    }

    generatedCandidateCount = [setCopy generatedCandidateCount];
    batchCandidateLocation = [setCopy batchCandidateLocation];
    candidates2 = [setCopy candidates];
    v54 = [candidates2 count] + batchCandidateLocation;

    if (generatedCandidateCount > v54)
    {
      delayedCandidateRequest = [(_UIKeyboardStateManager *)self delayedCandidateRequest];
      [delayedCandidateRequest invalidate];

      v56 = [_UIActionWhenIdle actionWhenIdleWithTarget:self selector:sel_generateCandidatesAsynchronously object:0];
      [(_UIKeyboardStateManager *)self setDelayedCandidateRequest:v56];
LABEL_46:

      goto LABEL_51;
    }

    if (self->m_candidateList)
    {
      if (![(_UIKeyboardStateManager *)self _hasMarkedText])
      {
        inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        selectedTextRange2 = [inputDelegateManager3 selectedTextRange];
        isEmpty = [selectedTextRange2 isEmpty];

        if (isEmpty)
        {
          v60 = UIKeyboardGetCurrentInputMode();
          v56 = UIKeyboardInputModeGetIdentifierWithKeyboardLayouts(v60);

          statisticsIdentifier = [(UIKeyboardCandidateList *)self->m_candidateList statisticsIdentifier];
          v62 = TIStatisticGetKeyForCandidateAccepted();
          TIStatisticScalarIncrement();

          goto LABEL_46;
        }
      }
    }
  }

LABEL_51:
  [(_UIKeyboardStateManager *)self _setNeedsCandidates:0];
}

- (unsigned)assertIntermediateText:(id)text
{
  textCopy = text;
  displayString = [textCopy displayString];
  selectedRange = [textCopy selectedRange];
  v8 = v7;
  inputString = [textCopy inputString];
  lastInputString = [textCopy lastInputString];
  searchString = [textCopy searchString];
  candidateOffset = [textCopy candidateOffset];
  liveConversionSegments = [textCopy liveConversionSegments];
  v14 = -[_UIKeyboardStateManager setMarkedText:selectedRange:inputString:lastInputString:searchString:candidateOffset:liveConversionSegments:highlighSegmentIndex:](self, "setMarkedText:selectedRange:inputString:lastInputString:searchString:candidateOffset:liveConversionSegments:highlighSegmentIndex:", displayString, selectedRange, v8, inputString, lastInputString, searchString, candidateOffset, liveConversionSegments, [textCopy highlightSegmentIndex]);

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];

  if (remoteTextInputPartner && !forwardingInputDelegate)
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    v19 = inputSystemSourceSession;
    if (inputSystemSourceSession)
    {
      textOperations = [inputSystemSourceSession textOperations];
      [textOperations setIntermediateText:textCopy];

      [v19 flushOperations];
    }
  }

  return v14;
}

- (BOOL)presentTextCompletionAsMarkedText:(id)text
{
  textCopy = text;
  if ([(_UIKeyboardStateManager *)self _hasMarkedText]&& ![(_UIKeyboardStateManager *)self hasInlineCompletionAsMarkedText])
  {
    v12 = 0;
  }

  else
  {
    displayString = [textCopy displayString];
    [(_UIKeyboardStateManager *)self _noteInlineCompletionAsMarkedText:displayString];

    displayString2 = [textCopy displayString];
    selectedRange = [textCopy selectedRange];
    v9 = v8;
    inputString = [textCopy inputString];
    searchString = [textCopy searchString];
    v12 = 1;
    LOBYTE(v21) = 1;
    [(_UIKeyboardStateManager *)self _setAttributedMarkedText:displayString2 selectedRange:selectedRange inputString:v9 lastInputString:inputString searchString:0 compareAttributes:searchString, v21];

    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];

    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];

    if (remoteTextInputPartner && !forwardingInputDelegate)
    {
      inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
      v17 = inputSystemSourceSession;
      if (inputSystemSourceSession)
      {
        textOperations = [inputSystemSourceSession textOperations];
        [textOperations setStyledIntermediateText:textCopy];

        textOperations2 = [v17 textOperations];
        [textOperations2 setCustomInfoType:0x1EFB7CB10];

        [v17 flushOperations];
      }

      v12 = 1;
    }
  }

  return v12;
}

- (void)removeTextCompletionFromMarkedText:(id)text
{
  textCopy = text;
  if ([textCopy length])
  {
    _markedText = [(_UIKeyboardStateManager *)self _markedText];
    if (!_markedText || [textCopy isEqualToString:_markedText])
    {
      [(_UIKeyboardStateManager *)self _noteInlineCompletionAsMarkedText:0];
      v5 = [objc_alloc(MEMORY[0x1E696AAB0]) initWithString:&stru_1EFB14550];
      v6 = [MEMORY[0x1E69C6F88] intermediateTextWithInputString:&stru_1EFB14550 displayString:v5 selectionLocation:0];
      displayString = [v6 displayString];
      selectedRange = [v6 selectedRange];
      v10 = v9;
      inputString = [v6 inputString];
      searchString = [v6 searchString];
      LOBYTE(v20) = 1;
      [(_UIKeyboardStateManager *)self _setAttributedMarkedText:displayString selectedRange:selectedRange inputString:v10 lastInputString:inputString searchString:0 compareAttributes:searchString, v20];

      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];

      remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];

      if (remoteTextInputPartner && !forwardingInputDelegate)
      {
        inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
        v17 = inputSystemSourceSession;
        if (inputSystemSourceSession)
        {
          textOperations = [inputSystemSourceSession textOperations];
          [textOperations setStyledIntermediateText:v6];

          textOperations2 = [v17 textOperations];
          [textOperations2 setCustomInfoType:0x1EFB7CB10];

          [v17 flushOperations];
        }
      }
    }
  }
}

- (BOOL)needsToDeferUpdateTextCandidateView
{
  hasCandidates = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet hasCandidates];
  if (hasCandidates)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate = [inputDelegateManager keyInputDelegate];
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();
    LOBYTE(hasCandidates) = (isKindOfClass & 1) != 0 && (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v7 = ;
  }

  return hasCandidates;
}

- (BOOL)canUseCandidateBarAsSupplementToInlineView
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  _rootInputWindowController = [WeakRetained _rootInputWindowController];
  placement = [_rootInputWindowController placement];

  v6 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
  visualModeManager = [v6 visualModeManager];
  if ([visualModeManager useVisualModeWindowed])
  {
    visualModeManager2 = [v6 visualModeManager];
    if ([visualModeManager2 windowingModeEnabled])
    {
      isFloatingAssistantView = [placement isFloatingAssistantView];
    }

    else
    {
      isFloatingAssistantView = 0;
    }
  }

  else
  {
    isFloatingAssistantView = 0;
  }

  if ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) == 1)
  {
    v10 = objc_loadWeakRetained(&self->_presentationDelegate);
    if ([objc_opt_class() isFloating] && !objc_msgSend(placement, "isFloatingAssistantView"))
    {
      hasAutofillCandidates = 0;
    }

    else if (([(UITextInputTraits *)self->m_traits autocorrectionType]== 1) | isFloatingAssistantView & 1)
    {
      autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
      hasAutofillCandidates = [autocorrectionController hasAutofillCandidates];
    }

    else
    {
      hasAutofillCandidates = 1;
    }
  }

  else
  {
    hasAutofillCandidates = 0;
  }

  return hasAutofillCandidates;
}

- (BOOL)showsCandidateInline
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  showsCandidateInline = [WeakRetained showsCandidateInline];

  return showsCandidateInline;
}

- (BOOL)showsCandidateBar
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  showsCandidateBar = [WeakRetained showsCandidateBar];

  return showsCandidateBar;
}

- (void)setShowsCandidateBar:(BOOL)bar
{
  barCopy = bar;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained setShowsCandidateBar:barCopy];
}

- (void)candidateBarDidExtendWithGesture
{
  inputManager = [(_UIKeyboardStateManager *)self inputManager];
  [inputManager logDiscoverabilityEvent:1 userInfo:0];
}

- (BOOL)maximizing
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  maximizing = [WeakRetained maximizing];

  return maximizing;
}

- (void)layoutDidResize
{
  inputManager = [(_UIKeyboardStateManager *)self inputManager];
  [inputManager logDiscoverabilityEvent:0 userInfo:0];
}

- (void)conversationContext:(id)context didChange:(id)change
{
  inputContextHistoryRepresentation = [context inputContextHistoryRepresentation];
  tiInputContextHistory = [inputContextHistoryRepresentation tiInputContextHistory];
  [(TIKeyboardState *)self->m_keyboardState setInputContextHistory:tiInputContextHistory];

  if ([(_UIKeyboardStateManager *)self canShowPredictionBar]&& ![(_UIKeyboardStateManager *)self shouldShowLongPredictionList])
  {
    [(_UIKeyboardStateManager *)self _requestInputManagerSync];
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    [autocorrectionController setNeedsAutocorrection];
  }

  else if ([(_UIKeyboardStateManager *)self usesCandidateSelection])
  {
    [(_UIKeyboardStateManager *)self _requestInputManagerSync];

    [(_UIKeyboardStateManager *)self generateCandidatesAsynchronouslyWithRange:0 selectedCandidate:0x7FFFFFFFLL, 0];
  }
}

- (void)setAutocorrection:(id)autocorrection
{
  autocorrectionCopy = autocorrection;
  if (autocorrectionCopy)
  {
    autocorrectionController = [objc_alloc(MEMORY[0x1E69D9588]) initWithAutocorrection:autocorrectionCopy alternateCorrections:0];
    v5 = [MEMORY[0x1E69D9570] listWithCorrections:autocorrectionController predictions:0];
    [(_UIKeyboardStateManager *)self setAutocorrectionList:v5];
  }

  else
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    [autocorrectionController clearAutocorrection];
  }
}

- (id)_supplementalCandidateIcon:(id)icon
{
  ui_supplementalItems = [icon ui_supplementalItems];
  if (![ui_supplementalItems count])
  {
    v7 = 0;
    goto LABEL_8;
  }

  if ([ui_supplementalItems count] == 1)
  {
    textInputTraits2 = [ui_supplementalItems objectAtIndexedSubscript:0];
    icon = [textInputTraits2 icon];
LABEL_7:
    v7 = icon;

    goto LABEL_8;
  }

  textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
  supplementalLexiconAmbiguousItemIcon = [textInputTraits supplementalLexiconAmbiguousItemIcon];

  if (supplementalLexiconAmbiguousItemIcon)
  {
    textInputTraits2 = [(_UIKeyboardStateManager *)self textInputTraits];
    icon = [textInputTraits2 supplementalLexiconAmbiguousItemIcon];
    goto LABEL_7;
  }

  v7 = [UIImage systemImageNamed:@"questionmark.circle"];
LABEL_8:

  return v7;
}

- (void)setAutocorrectionList:(id)list
{
  v59 = *MEMORY[0x1E69E9840];
  listCopy = list;
  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = __49___UIKeyboardStateManager_setAutocorrectionList___block_invoke;
  aBlock[3] = &unk_1E70FDE48;
  aBlock[4] = self;
  v5 = _Block_copy(aBlock);
  autocorrectionIfSupplemental = [listCopy autocorrectionIfSupplemental];
  if (autocorrectionIfSupplemental)
  {
    v5[2](v5, autocorrectionIfSupplemental);
  }

  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  predictionsIfSupplemental = [listCopy predictionsIfSupplemental];
  v8 = [predictionsIfSupplemental countByEnumeratingWithState:&v53 objects:v58 count:16];
  if (v8)
  {
    v9 = v8;
    v10 = *v54;
    do
    {
      for (i = 0; i != v9; ++i)
      {
        if (*v54 != v10)
        {
          objc_enumerationMutation(predictionsIfSupplemental);
        }

        v5[2](v5, *(*(&v53 + 1) + 8 * i));
      }

      v9 = [predictionsIfSupplemental countByEnumeratingWithState:&v53 objects:v58 count:16];
    }

    while (v9);
  }

  if (self->m_pendingAutofillIndex < 0 || ([listCopy predictions], v12 = objc_claimAutoreleasedReturnValue(), v12, !v12))
  {
    predictions = [listCopy predictions];
    firstObject = [predictions firstObject];

    if ([(_UIKeyboardStateManager *)self usesCandidateSelection])
    {
      if (![firstObject slotID])
      {
LABEL_21:
        corrections = [listCopy corrections];
        autocorrection = [corrections autocorrection];
        isContinuousPathConversion = [autocorrection isContinuousPathConversion];

        if ((isContinuousPathConversion & 1) == 0)
        {
          if ((self->m_predictionType | 2) == 3)
          {
            self->m_predictionType = 0;
          }

LABEL_25:
          if ([listCopy containsAlternativeInputCandidates])
          {
            self->m_predictionType = 6;
          }

          else
          {
            m_predictionType = self->m_predictionType;
            if (m_predictionType == 4 || m_predictionType == 2)
            {
              corrections2 = [listCopy corrections];
              autocorrection2 = [corrections2 autocorrection];
              isForShortcutConversion = [autocorrection2 isForShortcutConversion];

              if (!isForShortcutConversion)
              {
                goto LABEL_45;
              }
            }
          }

          if ([(_UIKeyboardStateManager *)self prewarmsPredictiveCandidates])
          {
            v29 = 1;
          }

          else
          {
            v30 = +[UIKeyboardPreferencesController sharedPreferencesController];
            preferencesActions = [v30 preferencesActions];
            if ([preferencesActions predictionEnabled])
            {
              v29 = 1;
            }

            else
            {
              corrections3 = [listCopy corrections];
              autocorrection3 = [corrections3 autocorrection];
              v29 = autocorrection3 != 0;
            }
          }

          v34 = self->m_predictionType;
          if ((v34 | 2) == 3 || (((v34 - 5) > 1) & ~v29) == 0)
          {
            autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
            corrections6 = autocorrectionController;
            v37 = listCopy;
LABEL_46:
            [autocorrectionController setAutocorrectionList:v37];
            goto LABEL_47;
          }

          corrections4 = [listCopy corrections];
          autocorrection4 = [corrections4 autocorrection];
          input = [autocorrection4 input];
          if (input)
          {
            v52 = input;
            corrections5 = [listCopy corrections];
            autocorrection5 = [corrections5 autocorrection];
            input2 = [autocorrection5 input];
            [listCopy corrections];
            v42 = v51 = corrections4;
            autocorrection6 = [v42 autocorrection];
            candidate = [autocorrection6 candidate];
            v48 = [input2 isEqualToString:candidate];

            if ((v48 & 1) == 0)
            {
              v45 = MEMORY[0x1E69D9570];
              corrections6 = [listCopy corrections];
              v46 = [v45 listWithCorrections:corrections6 predictions:0];
              autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
              [autocorrectionController2 setAutocorrectionList:v46];

LABEL_47:
              goto LABEL_48;
            }
          }

          else
          {
          }

LABEL_45:
          autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
          corrections6 = autocorrectionController;
          v37 = 0;
          goto LABEL_46;
        }
      }

LABEL_22:
      v18 = 1;
LABEL_23:
      self->m_predictionType = v18;
      corrections7 = [listCopy corrections];
      autocorrection7 = [corrections7 autocorrection];
      isContinuousPathConversion2 = [autocorrection7 isContinuousPathConversion];

      if (isContinuousPathConversion2)
      {
        self->m_predictionType = 5;
      }

      goto LABEL_25;
    }

    isAutofillCandidate = [firstObject isAutofillCandidate];
    if ([firstObject slotID])
    {
      if ((isAutofillCandidate & 1) == 0)
      {
        goto LABEL_22;
      }
    }

    else if ((isAutofillCandidate & 1) == 0)
    {
      goto LABEL_21;
    }

    v18 = 3;
    goto LABEL_23;
  }

  predictions2 = [listCopy predictions];
  v14 = [predictions2 objectAtIndex:self->m_pendingAutofillIndex];
  [(_UIKeyboardStateManager *)self acceptPredictiveInput:v14];

  self->m_pendingAutofillIndex = -1;
LABEL_48:
}

- (BOOL)hasAutocorrectPrompt
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  hasAutocorrectPrompt = [WeakRetained hasAutocorrectPrompt];

  return hasAutocorrectPrompt;
}

- (void)removeInlineTextCompletionPrompt
{
  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardInputDestinationEventToUIHost:sel_removeInlineTextCompletionPrompt];
  }

  else
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self inlineTextCompletionController];
    [remoteTextInputPartner removeTextCompletionPrompt];
  }
}

- (void)removeTextChoicePromptWithUnderline
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained removeTextChoicePromptWithUnderline];
}

- (void)removeTextChoicePromptAndAutocorrection
{
  if (+[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled])
  {

    [(_UIKeyboardStateManager *)self removeTextChoicePrompt];
  }

  else
  {

    [(_UIKeyboardStateManager *)self removeAutocorrection];
  }
}

- (void)removeTextChoiceUnderlinesInRange:(id)range
{
  rangeCopy = range;
  v4 = +[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled];
  v5 = rangeCopy;
  if (rangeCopy && v4)
  {
    isEmpty = [rangeCopy isEmpty];
    _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
    v8 = _textChoicesAssistant;
    if (isEmpty)
    {
      start = [rangeCopy start];
      [v8 clearUnderlineForPosition:start];
    }

    else
    {
      [_textChoicesAssistant removeAllUnderlines];
    }

    v5 = rangeCopy;
  }
}

- (id)_autocorrectionListDemotingAutocorrectionFromList:(id)list
{
  v33[1] = *MEMORY[0x1E69E9840];
  listCopy = list;
  corrections = [listCopy corrections];
  autocorrection = [corrections autocorrection];

  if (autocorrection && (([autocorrection candidate], v6 = objc_claimAutoreleasedReturnValue(), objc_msgSend(autocorrection, "input"), v7 = objc_claimAutoreleasedReturnValue(), (v8 = v7) != 0) ? (v9 = v7) : (v9 = &stru_1EFB14550), v10 = objc_msgSend(v6, "isEqualToString:", v9), v8, v6, (v10 & 1) == 0))
  {
    v12 = MEMORY[0x1E69D95F0];
    input = [autocorrection input];
    v14 = input;
    if (input)
    {
      v15 = input;
    }

    else
    {
      v15 = &stru_1EFB14550;
    }

    v16 = [v12 candidateWithUnchangedInput:v15];

    v33[0] = autocorrection;
    v17 = [MEMORY[0x1E695DEC8] arrayWithObjects:v33 count:1];
    corrections2 = [listCopy corrections];
    alternateCorrections = [corrections2 alternateCorrections];
    v20 = alternateCorrections;
    if (alternateCorrections)
    {
      v21 = alternateCorrections;
    }

    else
    {
      v21 = MEMORY[0x1E695E0F0];
    }

    v22 = [v17 arrayByAddingObjectsFromArray:v21];

    v23 = [objc_alloc(MEMORY[0x1E69D9588]) initWithAutocorrection:v16 alternateCorrections:v22 autocorrectionBlocked:1];
    predictions = [listCopy predictions];

    if (predictions)
    {
      v32 = autocorrection;
      v25 = [MEMORY[0x1E695DEC8] arrayWithObjects:&v32 count:1];
      predictions2 = [listCopy predictions];
      predictions = [v25 arrayByAddingObjectsFromArray:predictions2];
    }

    v27 = MEMORY[0x1E69D9570];
    emojiList = [listCopy emojiList];
    inlineCompletions = [listCopy inlineCompletions];
    proactiveTriggers = [listCopy proactiveTriggers];
    v11 = [v27 listWithCorrections:v23 predictions:predictions emojiList:emojiList inlineCompletionList:inlineCompletions proactiveTriggers:proactiveTriggers];
  }

  else
  {
    v11 = listCopy;
  }

  return v11;
}

- (void)dismissTextChoicePrompt
{
  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardInputDestinationEventToUIHost:sel_dismissTextChoicePrompt];
  }

  else
  {
    [(_UIKeyboardStateManager *)self removeTextChoicePrompt];
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    hasAutocorrection = [autocorrectionController hasAutocorrection];

    if (!hasAutocorrection)
    {
      return;
    }

    autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
    remoteTextInputPartner = [autocorrectionController2 autocorrectionList];

    v6 = [(_UIKeyboardStateManager *)self _autocorrectionListDemotingAutocorrectionFromList:remoteTextInputPartner];
    if (remoteTextInputPartner != v6)
    {
      autocorrectionController3 = [(_UIKeyboardStateManager *)self autocorrectionController];
      [autocorrectionController3 setAutocorrectionList:v6];
    }
  }
}

- (void)presentTextChoicePromptForRange:(id)range
{
  rangeCopy = range;
  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardInputDestinationEventToUIHost:sel_presentTextChoicePromptForRange_];
  }

  else
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
    [remoteTextInputPartner presentIfNeededForRange:rangeCopy];
  }
}

- (void)setCandidates:(id)candidates
{
  v46 = *MEMORY[0x1E69E9840];
  candidatesCopy = candidates;
  p_m_candidateResultSet = &self->m_candidateResultSet;
  m_candidateResultSet = self->m_candidateResultSet;
  if (m_candidateResultSet != candidatesCopy)
  {
    v7 = candidatesCopy;
    if ([(TIKeyboardCandidateResultSet *)v7 batchCandidateLocation])
    {
      v8 = [(TIKeyboardCandidateResultSet *)*p_m_candidateResultSet setByAppendingSet:v7];
      v9 = v8;
      if (!v8)
      {
        v9 = *p_m_candidateResultSet;
      }

      v10 = v9;

      v7 = v10;
    }

    if (*p_m_candidateResultSet != v7)
    {
      candidates = [(TIKeyboardCandidateResultSet *)v7 candidates];
      v12 = [candidates count];

      if (v12)
      {
        objc_storeStrong(&self->m_candidateResultSet, v7);
        v42 = 0u;
        v43 = 0u;
        v40 = 0u;
        v41 = 0u;
        candidatesIfSupplemental = [(TIKeyboardCandidateResultSet *)v7 candidatesIfSupplemental];
        v14 = [candidatesIfSupplemental countByEnumeratingWithState:&v40 objects:v45 count:16];
        if (v14)
        {
          v15 = v14;
          v16 = *v41;
          do
          {
            for (i = 0; i != v15; ++i)
            {
              if (*v41 != v16)
              {
                objc_enumerationMutation(candidatesIfSupplemental);
              }

              v18 = *(*(&v40 + 1) + 8 * i);
              v19 = [(_UIKeyboardStateManager *)self _supplementalCandidateIcon:v18];
              [v18 setIcon:v19];
            }

            v15 = [candidatesIfSupplemental countByEnumeratingWithState:&v40 objects:v45 count:16];
          }

          while (v15);
        }

        candidates2 = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet candidates];
        firstObject = [candidates2 firstObject];

        if ([(_UIKeyboardStateManager *)self shouldShowLongPredictionList])
        {
          null = [MEMORY[0x1E695DFB0] null];

          if (firstObject != null)
          {
            v34 = MEMORY[0x1E69E9820];
            v35 = 3221225472;
            v36 = __41___UIKeyboardStateManager_setCandidates___block_invoke;
            v37 = &unk_1E70FD1B8;
            v38 = firstObject;
            selfCopy = self;
            v23 = _Block_copy(&v34);
            if (qword_1ED49D468 != -1)
            {
              dispatch_once(&qword_1ED49D468, &__block_literal_global_1656);
            }

            v24 = [(_UIKeyboardStateManager *)self taskQueue:v34];
            [v24 addTask:v23 breadcrumb:qword_1ED49D460];
          }
        }
      }

      else
      {
        v25 = *p_m_candidateResultSet;
        *p_m_candidateResultSet = 0;
      }
    }

    m_candidateResultSet = *p_m_candidateResultSet;
  }

  if ([(TIKeyboardCandidateResultSet *)m_candidateResultSet hasCandidates])
  {
    self->_receivedCandidatesInCurrentInputMode = 1;
    if (!self->m_candidateList)
    {
      [(_UIKeyboardStateManager *)self updateTextCandidateView];
      v26 = +[UIKeyboard activeKeyboard];
      [v26 _didChangeCandidateList];

      v27 = +[UIDevice currentDevice];
      userInterfaceIdiom = [v27 userInterfaceIdiom];

      if (!userInterfaceIdiom)
      {
        if ([(_UIKeyboardStateManager *)self isMinimized])
        {
          firstCandidate = [(TIKeyboardCandidateResultSet *)*p_m_candidateResultSet firstCandidate];
          slotID = [firstCandidate slotID];

          if (slotID)
          {
            _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
            firstCandidate2 = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet firstCandidate];
            v44 = firstCandidate2;
            v33 = [MEMORY[0x1E695DEC8] arrayWithObjects:&v44 count:1];
            [_textChoicesAssistant showChoicesForCandidates:v33];
          }
        }
      }
    }
  }
}

- (void)setReturnKeyEnabled:(BOOL)enabled
{
  enabledCopy = enabled;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained setReturnKeyEnabled:enabledCopy];
}

- (void)updateReturnKey:(BOOL)key
{
  keyCopy = key;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateReturnKey:keyCopy];
}

- (void)_handleKeyBehavior:(unint64_t)behavior forKeyType:(id)type
{
  typeCopy = type;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained _handleKeyBehavior:behavior forKeyType:typeCopy];
}

- (void)performKeyBehaviorConfirm
{
  v3 = +[UIKBAnalyticsDispatcher sharedInstance];
  [v3 setNextCommitTextSource:3];

  if ([(_UIKeyboardStateManager *)self usesCandidateSelection])
  {
    handlingKeyCommandFromHardwareKeyboard = [(_UIKeyboardStateManager *)self handlingKeyCommandFromHardwareKeyboard];
    v5 = MEMORY[0x1E69D9A38];
    if (!handlingKeyCommandFromHardwareKeyboard)
    {
      v5 = MEMORY[0x1E69D9A08];
    }

    [(_UIKeyboardStateManager *)self trackUsageForCandidateAcceptedAction:*v5];
    acceptCurrentCandidate = [(_UIKeyboardStateManager *)self acceptCurrentCandidate];
  }

  else
  {
    [(_UIKeyboardStateManager *)self acceptAutocorrectionWithCompletionHandler:0];
    [(_UIKeyboardStateManager *)self removeTextChoicePrompt];
    if ([(_UIKeyboardStateManager *)self usesAutocorrectionLists])
    {
      inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
      wordSeparator = [inputManagerState wordSeparator];
      v9 = [wordSeparator isEqualToString:&stru_1EFB14550];

      if (v9)
      {
        [(_UIKeyboardStateManager *)self generateCandidates];

        [(_UIKeyboardStateManager *)self updateCandidateDisplay];
      }
    }
  }
}

- (void)performKeyBehaviorConfirmFirstCandidate
{
  v3 = +[UIKBAnalyticsDispatcher sharedInstance];
  [v3 setNextCommitTextSource:3];

  handlingKeyCommandFromHardwareKeyboard = [(_UIKeyboardStateManager *)self handlingKeyCommandFromHardwareKeyboard];
  v5 = MEMORY[0x1E69D9A30];
  if (!handlingKeyCommandFromHardwareKeyboard)
  {
    v5 = MEMORY[0x1E69D9A00];
  }

  [(_UIKeyboardStateManager *)self trackUsageForCandidateAcceptedAction:*v5];

  [(_UIKeyboardStateManager *)self acceptFirstCandidate];
}

- (void)performKeyBehaviorCommitInlineWithSpace:(BOOL)space
{
  spaceCopy = space;
  v5 = +[UIKBAnalyticsDispatcher sharedInstance];
  [v5 setNextCommitTextSource:4];

  v6 = [(_UIKeyboardStateManager *)self acceptInlineCandidateWithSpace:spaceCopy];
  if (!v6)
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    autocorrectionList = [autocorrectionController autocorrectionList];
    predictions = [autocorrectionList predictions];
    firstObject = [predictions firstObject];
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();

    v6 = 0;
    if (isKindOfClass)
    {
      v12 = objc_alloc_init(MEMORY[0x1E69D9638]);
      [v12 setInsertionText:@"\n"];
      [(_UIKeyboardStateManager *)self performKeyboardOutput:v12];

      v6 = 0;
    }
  }
}

- (id)updateKeyBehaviors:(id)behaviors withBehaviors:(id)withBehaviors forState:(id)state
{
  behaviorsCopy = behaviors;
  v8 = [withBehaviors keyBehaviorsForState:state];
  spaceKeyBehavior = [v8 spaceKeyBehavior];
  if (!spaceKeyBehavior)
  {
    spaceKeyBehavior = [behaviorsCopy spaceKeyBehavior];
  }

  returnKeyBehavior = [v8 returnKeyBehavior];
  if (!returnKeyBehavior)
  {
    returnKeyBehavior = [behaviorsCopy returnKeyBehavior];
  }

  if ([v8 spaceKeyBehavior] != spaceKeyBehavior || objc_msgSend(v8, "returnKeyBehavior") != returnKeyBehavior)
  {
    v11 = [MEMORY[0x1E69D9620] behaviorForSpaceKey:spaceKeyBehavior forReturnKey:returnKeyBehavior];

    v8 = v11;
  }

  return v8;
}

- (id)activeLayout
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  activeLayout = [WeakRetained activeLayout];

  return activeLayout;
}

- (BOOL)callLayoutIgnoresShiftState
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];

  if (!layout)
  {
    return 0;
  }

  v5 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout2 = [v5 layout];
  v7 = objc_opt_respondsToSelector();

  if ((v7 & 1) == 0)
  {
    return 0;
  }

  v8 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout3 = [v8 layout];
  ignoresShiftState = [layout3 ignoresShiftState];

  return ignoresShiftState;
}

- (void)callLayoutSetShift:(BOOL)shift
{
  shiftCopy = shift;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  v7 = objc_opt_respondsToSelector();

  if (v7)
  {
    v9 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v9 layout];
    [layout2 setShift:shiftCopy];
  }
}

- (void)callLayoutSetAutoshift:(BOOL)autoshift
{
  autoshiftCopy = autoshift;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  v7 = objc_opt_respondsToSelector();

  if (v7)
  {
    v9 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v9 layout];
    [layout2 setAutoshift:autoshiftCopy];
  }
}

- (void)callLayoutLongPressAction
{
  activeLayout = [(_UIKeyboardStateManager *)self activeLayout];
  v4 = objc_opt_respondsToSelector();

  if (v4)
  {
    activeLayout2 = [(_UIKeyboardStateManager *)self activeLayout];
    [activeLayout2 longPressAction];
  }
}

- (void)callLayoutUpdateAllLocalizedKeys
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  v5 = objc_opt_respondsToSelector();

  if (v5)
  {
    v7 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v7 layout];
    [layout2 updateLocalizedKeys:1];
  }
}

- (id)inputOverlayContainerForCandidateView:(BOOL)view
{
  viewCopy = view;
  if ([(_UIKeyboardStateManager *)self usesCandidateSelection])
  {
    if ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) == 1)
    {
      delegate = [(_UIKeyboardStateManager *)self delegate];
      textInputView = [delegate textInputView];
      v7 = [_UIPopoverView popoverViewContainingView:textInputView];
      if (v7)
      {

        if (!viewCopy)
        {
          goto LABEL_13;
        }

        goto LABEL_9;
      }

      if (viewCopy)
      {
LABEL_9:
        WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
        candidateController = [WeakRetained candidateController];
        if ([candidateController inlineRectIsVertical])
        {
          v10 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
          visualModeManager = [v10 visualModeManager];
          shouldShowWithinAppWindow = [visualModeManager shouldShowWithinAppWindow];

          if (shouldShowWithinAppWindow)
          {
            v13 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
            keyboardWindow = [v13 keyboardWindow];
            goto LABEL_16;
          }
        }

        else
        {
        }

LABEL_13:
        v15 = objc_loadWeakRetained(&self->_presentationDelegate);
        isEmojiPopoverPresented = [v15 isEmojiPopoverPresented];

        if (isEmojiPopoverPresented)
        {
          v13 = objc_loadWeakRetained(&self->_presentationDelegate);
          emojiPopoverController = [v13 emojiPopoverController];
          popoverPresentationController = [emojiPopoverController popoverPresentationController];
          containerView = [popoverPresentationController containerView];

          goto LABEL_17;
        }

        v13 = +[UIPeripheralHost sharedInstance];
        keyboardWindow = [v13 transformedContainerView];
LABEL_16:
        containerView = keyboardWindow;
LABEL_17:

        if (containerView)
        {
          goto LABEL_30;
        }
      }
    }

    else if (viewCopy)
    {
      goto LABEL_9;
    }
  }

  v20 = objc_loadWeakRetained(&self->_presentationDelegate);
  selectionScrolling = [v20 selectionScrolling];

  if (!selectionScrolling || (-[_UIKeyboardStateManager inputDelegate](self, "inputDelegate"), v22 = objc_claimAutoreleasedReturnValue(), [v22 textInputView], containerView = objc_claimAutoreleasedReturnValue(), v22, !containerView))
  {
    if (!-[_UIKeyboardStateManager usesCandidateSelection](self, "usesCandidateSelection") || !-[_UIKeyboardStateManager showsCandidateInline](self, "showsCandidateInline") && !-[_UIKeyboardStateManager floatingForced](self, "floatingForced") || -[_UIKeyboardStateManager isMinimized](self, "isMinimized") || (+[UIPeripheralHost sharedInstance](UIPeripheralHost, "sharedInstance"), v23 = objc_claimAutoreleasedReturnValue(), [v23 transformedContainerView], containerView = objc_claimAutoreleasedReturnValue(), v23, !containerView))
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];

      if (!inputDelegateManager || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v25 = objc_claimAutoreleasedReturnValue(), [v25 automaticallySelectedOverlay], containerView = objc_claimAutoreleasedReturnValue(), v25, !containerView))
      {
        inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
        v27 = objc_opt_respondsToSelector();

        if ((v27 & 1) == 0 || (-[_UIKeyboardStateManager inputDelegate](self, "inputDelegate"), v28 = objc_claimAutoreleasedReturnValue(), [v28 textInputView], containerView = objc_claimAutoreleasedReturnValue(), v28, !containerView))
        {
          v29 = +[UIPeripheralHost sharedInstance];
          containerView = [v29 transformedContainerView];
        }
      }
    }
  }

LABEL_30:

  return containerView;
}

- (CGRect)getCorrectionRectIsVertical:(BOOL *)vertical
{
  x = *MEMORY[0x1E695F050];
  y = *(MEMORY[0x1E695F050] + 8);
  width = *(MEMORY[0x1E695F050] + 16);
  height = *(MEMORY[0x1E695F050] + 24);
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  markedTextRange = [inputDelegateManager markedTextRange];

  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  inputIndex = [inputManagerState inputIndex];
  v13 = inputIndex - [(_UIKeyboardStateManager *)self candidateViewOffset];

  if (v13 >= 5)
  {
    v14 = 5;
  }

  else
  {
    v14 = v13;
  }

  if (!markedTextRange)
  {
    goto LABEL_13;
  }

  if ([(_UIKeyboardStateManager *)self candidateViewOffset]== 0x7FFFFFFFFFFFFFFFLL)
  {
    goto LABEL_10;
  }

  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  start = [markedTextRange start];
  v17 = [inputDelegateManager2 positionFromPosition:start offset:{-[_UIKeyboardStateManager candidateViewOffset](self, "candidateViewOffset")}];

  inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v19 = [inputDelegateManager3 positionFromPosition:v17 offset:v14];

  if (!v19 || (-[_UIKeyboardStateManager inputDelegate](self, "inputDelegate"), v20 = objc_claimAutoreleasedReturnValue(), [markedTextRange end], v21 = objc_claimAutoreleasedReturnValue(), v22 = objc_msgSend(v20, "comparePosition:toPosition:", v19, v21), v21, v20, v22 == 1))
  {
    v23 = [markedTextRange end];

    v19 = v23;
  }

  inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v25 = [inputDelegateManager4 textRangeFromPosition:v17 toPosition:v19];

  markedTextRange = v25;
  if (v25)
  {
LABEL_10:
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate _lastRectForRange:markedTextRange];
    x = v27;
    y = v28;
    width = v29;
    height = v30;

    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate2 firstRectForRange:markedTextRange];
    v33 = v32;
    v35 = v34;
    v37 = v36;
    v39 = v38;

    v122.origin.x = x;
    v122.origin.y = y;
    v122.size.width = width;
    v122.size.height = height;
    v131.origin.x = v33;
    v131.origin.y = v35;
    v131.size.width = v37;
    v131.size.height = v39;
    if (!CGRectEqualToRect(v122, v131))
    {
      v123.origin.x = x;
      v123.origin.y = y;
      v123.size.width = width;
      v123.size.height = height;
      v132.origin.x = v33;
      v132.origin.y = v35;
      v132.size.width = v37;
      v132.size.height = v39;
      v124 = CGRectUnion(v123, v132);
      x = v124.origin.x;
      y = v124.origin.y;
      width = v124.size.width;
      height = v124.size.height;
    }

    v40 = 1;
  }

  else
  {
LABEL_13:
    v40 = 0;
  }

  inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  asyncCapableInputDelegate = [inputDelegateManager5 asyncCapableInputDelegate];
  if (!asyncCapableInputDelegate)
  {

    goto LABEL_25;
  }

  v43 = asyncCapableInputDelegate;
  inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  hasMarkedText = [inputDelegateManager6 hasMarkedText];

  if (!hasMarkedText)
  {
    goto LABEL_25;
  }

  characterRectsForCharacterRange = [(_UIKeyboardStateManager *)self characterRectsForCharacterRange];

  if (characterRectsForCharacterRange)
  {
    characterRectsForCharacterRange2 = [(_UIKeyboardStateManager *)self characterRectsForCharacterRange];
    firstObject = [characterRectsForCharacterRange2 firstObject];
    [firstObject rectValue];
    x = v49;
    y = v50;
    width = v51;
    height = v52;

    characterRectsForCharacterRange3 = [(_UIKeyboardStateManager *)self characterRectsForCharacterRange];
    lastObject = [characterRectsForCharacterRange3 lastObject];
    [lastObject rectValue];
    v56 = v55;
    v58 = v57;
    v60 = v59;
    v62 = v61;

    if ([(_UIKeyboardStateManager *)self candidateViewOffset]!= 0x7FFFFFFFFFFFFFFFLL)
    {
      candidateViewOffset = [(_UIKeyboardStateManager *)self candidateViewOffset];
      characterRectsForCharacterRange4 = [(_UIKeyboardStateManager *)self characterRectsForCharacterRange];
      v65 = [characterRectsForCharacterRange4 count];

      if (candidateViewOffset < v65)
      {
        characterRectsForCharacterRange5 = [(_UIKeyboardStateManager *)self characterRectsForCharacterRange];
        v67 = [characterRectsForCharacterRange5 objectAtIndexedSubscript:{-[_UIKeyboardStateManager candidateViewOffset](self, "candidateViewOffset")}];
        [v67 rectValue];
        x = v68;
        y = v69;
        width = v70;
        height = v71;
      }

      characterRectsForCharacterRange6 = [(_UIKeyboardStateManager *)self characterRectsForCharacterRange];
      v73 = [characterRectsForCharacterRange6 count];

      if (v14 < v73)
      {
        characterRectsForCharacterRange7 = [(_UIKeyboardStateManager *)self characterRectsForCharacterRange];
        v75 = [characterRectsForCharacterRange7 objectAtIndexedSubscript:v14];
        [v75 rectValue];
        v56 = v76;
        v58 = v77;
        v60 = v78;
        v62 = v79;
      }
    }
  }

  else
  {
    inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager7 textLastRect];
    x = v81;
    y = v82;
    width = v83;
    height = v84;

    inputDelegateManager8 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager8 textFirstRect];
    v56 = v86;
    v58 = v87;
    v60 = v88;
    v62 = v89;

    v125.origin.x = x;
    v125.origin.y = y;
    v125.size.width = width;
    v125.size.height = height;
    v133.origin.x = v56;
    v133.origin.y = v58;
    v133.size.width = v60;
    v133.size.height = v62;
    if (CGRectEqualToRect(v125, v133))
    {
      goto LABEL_25;
    }
  }

  v126.origin.x = x;
  v126.origin.y = y;
  v126.size.width = width;
  v126.size.height = height;
  v134.origin.x = v56;
  v134.origin.y = v58;
  v134.size.width = v60;
  v134.size.height = v62;
  v127 = CGRectUnion(v126, v134);
  x = v127.origin.x;
  y = v127.origin.y;
  width = v127.size.width;
  height = v127.size.height;
LABEL_25:
  v128.origin.x = x;
  v128.origin.y = y;
  v128.size.width = width;
  v128.size.height = height;
  if (CGRectIsEmpty(v128))
  {
    inputDelegateManager9 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager9 selectedTextRange];

    if (selectedTextRange)
    {
      inputDelegateManager10 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      start2 = [selectedTextRange start];
      [inputDelegateManager10 caretRectForPosition:start2];
      x = v94;
      y = v95;
      width = v96;
      height = v97;
    }
  }

  v129.origin.x = x;
  v129.origin.y = y;
  v129.size.width = width;
  v129.size.height = height;
  if (CGRectIsNull(v129))
  {
    inputDelegateManager11 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    privateInputDelegate = [inputDelegateManager11 privateInputDelegate];
    if (privateInputDelegate)
    {
      v100 = privateInputDelegate;
      inputDelegateManager12 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      __content = [inputDelegateManager12 __content];

      if (!__content)
      {
        goto LABEL_34;
      }

      inputDelegateManager11 = [(_UIKeyboardStateManager *)self textInteractionAssistant];
      activeSelection = [inputDelegateManager11 activeSelection];
      [activeSelection caretRect];
      x = v104;
      y = v105;
      width = v106;
      height = v107;
    }
  }

LABEL_34:
  v108 = v40 ^ 1;
  if (!vertical)
  {
    v108 = 1;
  }

  if ((v108 & 1) == 0)
  {
    inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
    v110 = objc_opt_respondsToSelector();

    if (v110)
    {
      inputDelegateManager13 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v112 = [inputDelegateManager13 selectionRectsForRange:markedTextRange];
      lastObject2 = [v112 lastObject];

      *vertical = [lastObject2 isVertical];
      if ([lastObject2 isVertical])
      {
        [lastObject2 rect];
        x = v114;
        y = v115;
        width = v116;
        height = v117;
      }
    }
  }

  v118 = x;
  v119 = y;
  v120 = width;
  v121 = height;
  result.size.height = v121;
  result.size.width = v120;
  result.origin.y = v119;
  result.origin.x = v118;
  return result;
}

- (void)updateTextCandidateView
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateTextCandidateView];
}

- (void)sendCallbacksForPreCorrectionsDisplay
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  v4 = objc_opt_respondsToSelector();

  if (v4)
  {
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate2 _willShowCorrections];
  }
}

- (void)sendCallbacksForPostCorrectionsRemoval
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  v4 = objc_opt_respondsToSelector();

  if (v4)
  {
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate2 _didHideCorrections];
  }
}

- (void)touchAutocorrectPromptTimer
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained touchAutocorrectPromptTimer];
}

- (void)touchDelayDeleteTimerWithThreshold:(double)threshold
{
  [(_UIKeyboardStateManager *)self clearDelayDeleteTimer];
  if (qword_1ED49D478 != -1)
  {
    dispatch_once(&qword_1ED49D478, &__block_literal_global_1688);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v8[0] = MEMORY[0x1E69E9820];
  v8[1] = 3221225472;
  v8[2] = __62___UIKeyboardStateManager_touchDelayDeleteTimerWithThreshold___block_invoke_3;
  v8[3] = &unk_1E70FD058;
  v8[4] = self;
  v6 = [taskQueue scheduleTask:v8 timeInterval:0 repeats:qword_1ED49D470 breadcrumb:threshold];
  m_delayDeleteTask = self->m_delayDeleteTask;
  self->m_delayDeleteTask = v6;
}

- (void)clearAutocorrectPromptTimer
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained clearAutocorrectPromptTimer];
}

- (id)_rangeForAutocorrectionText:(id)text
{
  textCopy = text;
  if (!+[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI") || !self->_pendingAutocorrectRange || (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v5 = objc_claimAutoreleasedReturnValue(), -[UITextRange end](self->_pendingAutocorrectRange, "end"), v6 = objc_claimAutoreleasedReturnValue(), [v5 _rangeOfText:textCopy endingAtPosition:v6], v7 = objc_claimAutoreleasedReturnValue(), v6, v5, !v7))
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager selectedTextRange];

    if (!selectedTextRange)
    {
      goto LABEL_8;
    }

    if ([textCopy length])
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v11 = [selectedTextRange end];
      v7 = [inputDelegateManager2 _rangeOfText:textCopy endingAtPosition:v11];

      if (v7)
      {
LABEL_10:

        goto LABEL_11;
      }

      if ([selectedTextRange isEmpty])
      {
LABEL_8:
        v7 = 0;
        goto LABEL_10;
      }
    }

    v7 = selectedTextRange;
    goto LABEL_10;
  }

LABEL_11:

  return v7;
}

- (id)autocorrectPromptRectsFromFirstDelegateRect:(CGRect)rect lastDelegateRect:(CGRect)delegateRect
{
  height = delegateRect.size.height;
  width = delegateRect.size.width;
  y = delegateRect.origin.y;
  x = delegateRect.origin.x;
  v8 = rect.size.height;
  v9 = rect.size.width;
  v10 = rect.origin.y;
  v11 = rect.origin.x;
  v37[4] = *MEMORY[0x1E69E9840];
  v13 = v35;
  if (CGRectIsNull(rect))
  {
    v14 = 0;
  }

  else
  {
    v13 = v37;
    *v35 = v11;
    *&v35[1] = v10;
    v14 = 1;
    *v36 = v9;
    *&v36[1] = v8;
  }

  v39.origin.x = x;
  v39.origin.y = y;
  v39.size.width = width;
  v39.size.height = height;
  if (!CGRectIsEmpty(v39))
  {
    v40.origin.x = x;
    v40.origin.y = y;
    v40.size.width = width;
    v40.size.height = height;
    v41.origin.x = v11;
    v41.origin.y = v10;
    v41.size.width = v9;
    v41.size.height = v8;
    if (!CGRectIntersectsRect(v40, v41))
    {
      ++v14;
      *v13 = x;
      v13[1] = y;
      v13[2] = width;
      v13[3] = height;
    }
  }

  v15 = [MEMORY[0x1E695DF70] arrayWithCapacity:v14];
  if (v14)
  {
    v16 = v36;
    do
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      textInputView = [inputDelegateManager textInputView];

      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      inputOverlayContainer = [(_UIKeyboardStateManager *)self inputOverlayContainer];
      v21 = *(v16 - 2);
      v22 = *(v16 - 1);
      v23 = *v16;
      v24 = v16[1];
      v16 += 4;
      [WeakRetained convertRectToAutocorrectRect:textInputView delegateView:inputOverlayContainer container:{v21, v22, v23, v24}];
      v26 = v25;
      v28 = v27;
      v30 = v29;
      v32 = v31;

      v33 = [UISimpleSelectionRect rectWithCGRect:v26, v28, v30, v32];
      [v15 addObject:v33];

      --v14;
    }

    while (v14);
  }

  return v15;
}

- (void)updateAutocorrectPrompt:(id)prompt
{
  promptCopy = prompt;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateAutocorrectPrompt:promptCopy];
}

- (void)updateAutocorrectPrompt:(id)prompt executionContext:(id)context
{
  contextCopy = context;
  promptCopy = prompt;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateAutocorrectPrompt:promptCopy executionContext:contextCopy];
}

- (void)insertText:(id)text withAlternativePredictions:(id)predictions
{
  v21 = *MEMORY[0x1E69E9840];
  textCopy = text;
  predictionsCopy = predictions;
  array = [MEMORY[0x1E695DF70] array];
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v9 = predictionsCopy;
  v10 = [v9 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v10)
  {
    v11 = v10;
    v12 = *v17;
    do
    {
      v13 = 0;
      do
      {
        if (*v17 != v12)
        {
          objc_enumerationMutation(v9);
        }

        candidate = [*(*(&v16 + 1) + 8 * v13) candidate];
        [array addObject:candidate];

        ++v13;
      }

      while (v11 != v13);
      v11 = [v9 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }

    while (v11);
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager insertText:textCopy alternatives:array style:1];
}

- (BOOL)applyAutocorrection:(id)autocorrection
{
  autocorrectionCopy = autocorrection;
  v5 = autocorrectionCopy;
  if ((!autocorrectionCopy || [autocorrectionCopy slotID]) && objc_msgSend(v5, "customInfoType") != 4096)
  {
    LOBYTE(inputDelegate) = 0;
    goto LABEL_59;
  }

  if (![(_UIKeyboardStateManager *)self hasAsyncCapableInputDelegate])
  {
    v14 = +[UIKBAnalyticsDispatcher sharedInstance];
    nextCandidateReplacementSource = [v14 nextCandidateReplacementSource];

    if (nextCandidateReplacementSource != 1)
    {
      goto LABEL_19;
    }

    if ([v5 isToucanInlineCompletionCandidate])
    {
      v16 = 6;
    }

    else
    {
      input = [v5 input];
      v18 = [input length];

      if (!v18)
      {
        goto LABEL_17;
      }

      v16 = 3;
    }

    v19 = +[UIKBAnalyticsDispatcher sharedInstance];
    [v19 setNextCandidateReplacementSource:v16];

LABEL_17:
    v20 = +[UIKBAnalyticsDispatcher sharedInstance];
    nextCandidateReplacementSource2 = [v20 nextCandidateReplacementSource];

    if (nextCandidateReplacementSource2 != 1)
    {
      input2 = [v5 input];
      v23 = +[UIKBAnalyticsDispatcher sharedInstance];
      [v23 setNextCandidateReplacementRemovedText:input2];

      label = [v5 label];
      v25 = +[UIKBAnalyticsDispatcher sharedInstance];
      [v25 setNextCandidateReplacementInsertedText:label];

      v26 = +[UIKBAnalyticsDispatcher sharedInstance];
      [v26 setAnalyticsShouldCallDidKeyPress:0];
    }

LABEL_19:
    input3 = [v5 input];
    v28 = [input3 length];

    if (!v28)
    {
      LOBYTE(inputDelegate) = 1;
      self->m_textInputChangesIgnored = 1;
      candidate = [v5 candidate];
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager insertText:candidate];

      self->m_textInputChangesIgnored = 0;
LABEL_58:

      goto LABEL_59;
    }

    candidate = [v5 input];
    if (objc_opt_respondsToSelector())
    {
      v30 = [v5 performSelector:sel_rawInput];
    }

    else
    {
      v30 = 0;
    }

    v32 = [(_UIKeyboardStateManager *)self _rangeForAutocorrectionText:candidate];
    if (!v32 && v30)
    {
      if ([v30 isEqual:candidate])
      {
        v32 = 0;
LABEL_36:
        LOBYTE(inputDelegate) = 0;
        goto LABEL_57;
      }

      v32 = [(_UIKeyboardStateManager *)self _rangeForAutocorrectionText:v30];
    }

    if (!v32)
    {
      goto LABEL_36;
    }

    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];

    if (!inputDelegate)
    {
LABEL_57:

      goto LABEL_58;
    }

    self->m_textInputChangesIgnored = 1;
    inputDelegate = [v5 candidate];
    if (-[_UIKeyboardStateManager currentInputModeRequiresLTRMathExpression](self, "currentInputModeRequiresLTRMathExpression") && [v5 candidateProperty] == 1)
    {
      v33 = [MEMORY[0x1E696AEC0] stringWithFormat:@"%@%@%@", @"", inputDelegate, @""];

      inputDelegate = v33;
    }

    v34 = [(_UIKeyboardStateManager *)self attributedCorrectionFromTextAnimationCandidate:v5];
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager2 selectedTextRange];

    inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    v37 = inputDelegateManager3;
    if (v34)
    {
      [inputDelegateManager3 replaceRange:v32 oldText:0 withAttributedText:v34 forReplaceAction:0];
    }

    else
    {
      [inputDelegateManager3 replaceRange:v32 oldText:0 withText:inputDelegate forReplaceAction:0];
    }

    inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange2 = [inputDelegateManager4 selectedTextRange];

    if (self->_pendingAutocorrectRange)
    {
      objc_storeStrong(&self->_pendingAutocorrectRange, selectedTextRange2);
    }

    if (!+[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI") || ([selectedTextRange isEqual:selectedTextRange2] & 1) != 0 || !self->_pendingAutocorrectRange)
    {
LABEL_53:
      v52 = selectedTextRange2;
      documentState = [(_UIKeyboardStateManager *)self documentState];
      v54 = [documentState documentStateAfterReplacingText:candidate withText:inputDelegate];
      if (v54)
      {
        [(_UIKeyboardStateManager *)self setDocumentState:v54];
      }

      else
      {
        v66 = v34;
        v55 = MEMORY[0x1E69D9590];
        [(_UIKeyboardStateManager *)self inputDelegate];
        v56 = v64 = inputDelegate;
        v57 = [v55 documentStateOfDocument:v56];
        [(_UIKeyboardStateManager *)self setDocumentState:v57];

        v34 = v66;
        inputDelegate = v64;
      }

      self->m_textInputChangesIgnored = 0;
      LOBYTE(inputDelegate) = 1;
      goto LABEL_57;
    }

    v40 = selectedTextRange;
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    if (inputDelegate2 && v40)
    {
      v62 = selectedTextRange2;
      v60 = [inputDelegate length];
      inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [v32 start];
      v42 = v63 = v40;
      v43 = [v32 end];
      v59 = [inputDelegateManager5 offsetFromPosition:v42 toPosition:v43];

      start = [v63 start];
      v45 = [v32 end];
      v46 = [inputDelegate2 comparePosition:start toPosition:v45];

      v47 = v60 - v59;
      if (v60 == v59 || v46 != 1)
      {
        selectedTextRange2 = v62;
        v40 = v63;
LABEL_51:
        inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        [inputDelegateManager6 setSelectedTextRange:v40];

LABEL_52:
        goto LABEL_53;
      }

      start2 = [v63 start];
      v61 = [inputDelegate2 positionFromPosition:start2 offset:v47];

      v49 = [v63 end];
      v50 = [inputDelegate2 positionFromPosition:v49 offset:v47];

      v40 = [inputDelegate2 textRangeFromPosition:v61 toPosition:v50];

      selectedTextRange2 = v62;
    }

    if (!v40)
    {
      goto LABEL_52;
    }

    goto LABEL_51;
  }

  LOBYTE(inputDelegate) = 1;
  self->m_textInputChangesIgnored = 1;
  inputDelegateManager7 = [(_UIKeyboardStateManager *)self inputDelegateManager];

  if (inputDelegateManager7)
  {
    v8 = +[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled];
    inputDelegateManager8 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    candidate2 = [v5 candidate];
    input4 = [v5 input];
    if (v8)
    {
      v12 = [(_UIKeyboardStateManager *)self shouldUnderlineCandidate:v5];
      v70[0] = MEMORY[0x1E69E9820];
      v70[1] = 3221225472;
      v70[2] = __47___UIKeyboardStateManager_applyAutocorrection___block_invoke;
      v70[3] = &unk_1E70FDE70;
      v70[4] = self;
      v71 = v5;
      [inputDelegateManager8 applyAutocorrection:candidate2 toString:input4 shouldUnderline:v12 withCompletionHandler:v70];

      v13 = v71;
    }

    else
    {
      v68[0] = MEMORY[0x1E69E9820];
      v68[1] = 3221225472;
      v68[2] = __47___UIKeyboardStateManager_applyAutocorrection___block_invoke_2;
      v68[3] = &unk_1E70FDE70;
      v68[4] = self;
      v69 = v5;
      [inputDelegateManager8 applyAutocorrection:candidate2 toString:input4 withCompletionHandler:v68];

      v13 = v69;
    }

    LOBYTE(inputDelegate) = 1;
  }

LABEL_59:

  return inputDelegate;
}

- (id)attributedCorrectionFromTextAnimationCandidate:(id)candidate
{
  candidateCopy = candidate;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    v8 = 0;
    goto LABEL_10;
  }

  v5 = candidateCopy;
  textEffectName = [v5 textEffectName];
  if ([&unk_1EFE2B5F0 containsObject:textEffectName])
  {
    v7 = [(_UIKeyboardStateManager *)self _attributedCorrectionTextEffectAnimation:v5];
  }

  else
  {
    if (![&unk_1EFE2B608 containsObject:textEffectName])
    {
      v8 = 0;
      goto LABEL_9;
    }

    v7 = [(_UIKeyboardStateManager *)self _attributedCorrectionTextEffectStyle:v5];
  }

  v8 = v7;
LABEL_9:

LABEL_10:

  return v8;
}

- (id)_attributedCorrectionTextEffectAnimation:(id)animation
{
  animationCopy = animation;
  textEffectName = [animationCopy textEffectName];
  v5 = [_UITextAnimation animationWithName:textEffectName];

  if (v5 && ([animationCopy candidate], v6 = objc_claimAutoreleasedReturnValue(), v7 = objc_msgSend(v6, "length"), v6, v7))
  {
    candidate = [animationCopy candidate];
    v9 = [candidate length];

    v10 = objc_alloc(MEMORY[0x1E696AD40]);
    candidate2 = [animationCopy candidate];
    v12 = [v10 initWithString:candidate2];

    [v12 addAttribute:*off_1E70ECA08 value:v5 range:{0, v9}];
  }

  else
  {
    v12 = 0;
  }

  return v12;
}

- (id)_attributedCorrectionTextEffectStyle:(id)style
{
  styleCopy = style;
  textEffectName = [styleCopy textEffectName];
  candidate = [styleCopy candidate];
  v6 = [candidate length];

  if ([textEffectName isEqualToString:@"bold"])
  {
    v7 = objc_alloc(MEMORY[0x1E696AD40]);
    candidate2 = [styleCopy candidate];
    v9 = [v7 initWithString:candidate2];

    v10 = *off_1E70EC918;
    v11 = [off_1E70ECC18 boldSystemFontOfSize:12.0];
LABEL_5:
    v14 = v11;
    [v9 addAttribute:v10 value:v11 range:{0, v6}];

    goto LABEL_6;
  }

  if ([textEffectName isEqualToString:@"italic"])
  {
    v12 = objc_alloc(MEMORY[0x1E696AD40]);
    candidate3 = [styleCopy candidate];
    v9 = [v12 initWithString:candidate3];

    v10 = *off_1E70EC918;
    v11 = [off_1E70ECC18 italicSystemFontOfSize:12.0];
    goto LABEL_5;
  }

  if ([textEffectName isEqualToString:@"underline"])
  {
    v16 = objc_alloc(MEMORY[0x1E696AD40]);
    candidate4 = [styleCopy candidate];
    v9 = [v16 initWithString:candidate4];

    v18 = off_1E70ECAD8;
LABEL_13:
    [v9 addAttribute:*v18 value:&unk_1EFE30040 range:{0, v6}];
    goto LABEL_6;
  }

  if ([textEffectName isEqualToString:@"strikeThrough"])
  {
    v19 = objc_alloc(MEMORY[0x1E696AD40]);
    candidate5 = [styleCopy candidate];
    v9 = [v19 initWithString:candidate5];

    v18 = off_1E70EC9C8;
    goto LABEL_13;
  }

  v9 = 0;
LABEL_6:

  return v9;
}

- (void)animateAutocorrectionToText:(id)text fromRect:(CGRect)rect
{
  height = rect.size.height;
  width = rect.size.width;
  y = rect.origin.y;
  x = rect.origin.x;
  textCopy = text;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained animateAutocorrectionToText:textCopy fromRect:{x, y, width, height}];
}

- (void)animateAutocorrectionToRect:(CGRect)rect fromRect:(CGRect)fromRect
{
  height = fromRect.size.height;
  width = fromRect.size.width;
  y = fromRect.origin.y;
  x = fromRect.origin.x;
  v8 = rect.size.height;
  v9 = rect.size.width;
  v10 = rect.origin.y;
  v11 = rect.origin.x;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained animateAutocorrectionToRect:v11 fromRect:{v10, v9, v8, x, y, width, height}];
}

- (void)rejectAutocorrectionForPromptFade
{
  inputManager = [(_UIKeyboardStateManager *)self inputManager];
  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  autocorrection = [autocorrectionController autocorrection];
  [inputManager candidateRejected:autocorrection];
}

- (void)fadeAutocorrectPrompt
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained fadeAutocorrectPrompt];
}

- (void)underlineCandidate:(id)candidate
{
  candidateCopy = candidate;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained underlineCandidate:candidateCopy];
}

- (BOOL)shouldUnderlineCandidate:(id)candidate
{
  candidateCopy = candidate;
  if ((objc_opt_respondsToSelector() & 1) != 0 && [candidateCopy performSelector:sel_shouldHintAtAlternativeInput])
  {
    v4 = 1;
  }

  else if ([candidateCopy confidence])
  {
    v4 = [candidateCopy confidence] != 3;
  }

  else
  {
    v4 = 0;
  }

  return v4;
}

- (id)autocorrectionRecordForWord:(id)word
{
  wordCopy = word;
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  inputString = [inputManagerState inputString];
  v7 = [wordCopy isEqualToString:inputString];

  if (!v7 || (-[_UIKeyboardStateManager inputManagerState](self, "inputManagerState"), v8 = objc_claimAutoreleasedReturnValue(), [v8 autocorrectionRecordForInputString], v9 = objc_claimAutoreleasedReturnValue(), v8, !v9))
  {
    if (+[UITextSelectionDisplayInteraction isTextAccelerationUIEnabled])
    {
      _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
      v9 = [_textChoicesAssistant candidateForFinalString:wordCopy];
    }

    else
    {
      v9 = 0;
    }
  }

  return v9;
}

- (BOOL)delegateSuggestionsForCurrentInput
{
  textSuggestionDelegate = [(UITextInputTraits *)self->m_traits textSuggestionDelegate];
  if ((objc_opt_respondsToSelector() & 1) == 0)
  {
LABEL_34:
    v28 = 1;
    goto LABEL_35;
  }

  if ((objc_opt_respondsToSelector() & 1) == 0 || [textSuggestionDelegate hasCurrentSuggestions])
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    _fullText = [inputDelegate _fullText];

    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    _selectedNSRange = [inputDelegate2 _selectedNSRange];

    v8 = [textSuggestionDelegate suggestionsForString:_fullText inputIndex:_selectedNSRange];
    v10 = v9;
    v11 = v8;
    if ([v11 count])
    {
      v12 = [v11 objectAtIndex:0];
    }

    else
    {
      v12 = 0;
    }

    v13 = [v12 length];
    if (v13)
    {
      v14 = v13;
      if ([_fullText isEqualToString:v12])
      {
LABEL_28:
        if ([v11 count] < 2)
        {
          v32 = 0;
        }

        else
        {
          v30 = [v11 objectAtIndex:1];
          objc_opt_class();
          isKindOfClass = objc_opt_isKindOfClass();

          if (isKindOfClass)
          {
            v32 = [v11 objectAtIndex:1];
          }

          else
          {
            v33 = MEMORY[0x1E69D95F0];
            v34 = [v11 objectAtIndex:1];
            v32 = [v33 candidateWithCandidate:v34 forInput:_fullText];
          }
        }

        [(_UIKeyboardStateManager *)self setAutocorrection:v32];
        [(_UIKeyboardStateManager *)self syncInputManagerToKeyboardState];

        goto LABEL_34;
      }

      if (!delegateSuggestionsForCurrentInput_nbspString)
      {
        v15 = [MEMORY[0x1E696AEC0] _stringWithUnichar:160];
        v16 = delegateSuggestionsForCurrentInput_nbspString;
        delegateSuggestionsForCurrentInput_nbspString = v15;
      }

      inputDelegateManager2 = [objc_alloc(MEMORY[0x1E696AD60]) initWithString:v12];
      [inputDelegateManager2 replaceOccurrencesOfString:@" " withString:delegateSuggestionsForCurrentInput_nbspString options:2 range:{0, v14}];
      self->m_textInputChangesIgnored = 1;
      inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegate3 _selectAll];

      [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegate];
      self->m_textInputChangesIgnored = 0;
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager insertText:inputDelegateManager2 updateInputSource:0];

      if (v10 >= v14)
      {
        v20 = v14;
      }

      else
      {
        v20 = v10;
      }

      if (v14 > v10)
      {
        self->m_textInputChangesIgnored = 1;
        inputDelegate4 = [(_UIKeyboardStateManager *)self inputDelegate];
        [inputDelegate4 _moveCurrentSelection:(v20 - v14)];

        inputDelegate5 = [(_UIKeyboardStateManager *)self inputDelegate];
        LOBYTE(inputDelegate4) = objc_opt_respondsToSelector();

        if (inputDelegate4)
        {
          _isNaturallyRTL = [v12 _isNaturallyRTL];
          if (v20 > 5 || (_isNaturallyRTL & 1) != 0)
          {
            v29 = _isNaturallyRTL ^ 1;
            if (v20 < v14 - 5)
            {
              v29 = 1;
            }

            if (v29)
            {
              goto LABEL_26;
            }

            inputDelegate6 = [(_UIKeyboardStateManager *)self inputDelegate];
            v25 = inputDelegate6;
            v26 = v14 - 1;
          }

          else
          {
            inputDelegate6 = [(_UIKeyboardStateManager *)self inputDelegate];
            v25 = inputDelegate6;
            v26 = 0;
          }

          [inputDelegate6 _scrollRangeToVisible:v26 animated:{0, 0}];
        }

LABEL_26:
        [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegate];
        self->m_textInputChangesIgnored = 0;
      }
    }

    else
    {
      self->m_textInputChangesIgnored = 1;
      inputDelegate7 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegate7 _selectAll];

      [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegate];
      self->m_textInputChangesIgnored = 0;
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager2 insertText:&stru_1EFB14550 updateInputSource:0];
    }

    goto LABEL_28;
  }

  v28 = 0;
LABEL_35:

  return v28;
}

- (void)generateCandidatesWithOptions:(int)options
{
  optionsCopy = options;
  v59[1] = *MEMORY[0x1E69E9840];
  if ((options & 0x10) == 0)
  {
    [(_UIKeyboardStateManager *)self setCurrentCandidateRequest:0];
  }

  if (![(_UIKeyboardStateManager *)self canShowPredictionBar]&& ![(_UIKeyboardStateManager *)self usesCandidateSelection])
  {
    [(_UIKeyboardStateManager *)self setCandidates:0];
  }

  delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  if ([UIKeyboardCameraSession shouldShowTextSuggestionForResponder:delegateAsResponder])
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    autocorrectionList = [autocorrectionController autocorrectionList];
    predictions = [autocorrectionList predictions];
    v9 = [predictions count] == 0;
  }

  else
  {
    v9 = 0;
  }

  canShowAppConnections = [(_UIKeyboardStateManager *)self canShowAppConnections];
  if (![(_UIKeyboardStateManager *)self canShowPredictionBar]&& ![(_UIKeyboardStateManager *)self usesCandidateSelection]&& self->m_userChangedSelection && !canShowAppConnections && !v9)
  {

    [(_UIKeyboardStateManager *)self setAutocorrection:0];
    return;
  }

  if (!v9 && [(_UIKeyboardStateManager *)self _isShowingSuggestionForKeyboardCamera])
  {
    [(_UIKeyboardStateManager *)self setSuggestions:0];
  }

  delegateAsResponder2 = [(_UIKeyboardStateManager *)self delegateAsResponder];
  _shouldEvaluateForWritingToolsInCandidateBarAsynchronously = [delegateAsResponder2 _shouldEvaluateForWritingToolsInCandidateBarAsynchronously];

  delegateAsResponder3 = [(_UIKeyboardStateManager *)self delegateAsResponder];
  _shouldDisplayWritingToolsCandidateOptions = [delegateAsResponder3 _shouldDisplayWritingToolsCandidateOptions];

  if ((_shouldDisplayWritingToolsCandidateOptions & 1) == 0)
  {
    autocorrectionController2 = [(_UIKeyboardStateManager *)self autocorrectionController];
    textSuggestionList = [autocorrectionController2 textSuggestionList];
    isShowingSuggestionForWritingTools = [textSuggestionList isShowingSuggestionForWritingTools];

    if (isShowingSuggestionForWritingTools)
    {
      [(_UIKeyboardStateManager *)self setSuggestions:0];
    }
  }

  if ((optionsCopy & 4) == 0)
  {
    textSuggestionDelegate = [(UITextInputTraits *)self->m_traits textSuggestionDelegate];
    if (textSuggestionDelegate)
    {
      delegateSuggestionsForCurrentInput = [(_UIKeyboardStateManager *)self delegateSuggestionsForCurrentInput];

      if (delegateSuggestionsForCurrentInput)
      {
        autocorrectionController3 = [(_UIKeyboardStateManager *)self autocorrectionController];
        v21 = ([autocorrectionController3 hasTextSuggestionCandidates] ^ 1) & v9;

        if (v21 != 1)
        {
          autocorrectionController4 = [(_UIKeyboardStateManager *)self autocorrectionController];
          v23 = ([autocorrectionController4 hasTextSuggestionCandidates] ^ 1) & _shouldDisplayWritingToolsCandidateOptions;

          if (v23 != 1)
          {
            return;
          }

LABEL_68:
          delegateAsResponder4 = [(_UIKeyboardStateManager *)self delegateAsResponder];
          _textSuggestionsForWritingTools = [delegateAsResponder4 _textSuggestionsForWritingTools];
          [(_UIKeyboardStateManager *)self setSuggestions:_textSuggestionsForWritingTools];

          goto LABEL_73;
        }

LABEL_64:

        [(_UIKeyboardStateManager *)self _generateTextSuggestionForKeyboardCamera];
        return;
      }
    }
  }

  v24 = optionsCopy & 4;
  usesCandidateSelection = [(_UIKeyboardStateManager *)self usesCandidateSelection];
  utlizeEuclidModelForDictationReplacement = [(_UIKeyboardStateManager *)self utlizeEuclidModelForDictationReplacement];
  if (v24 || !utlizeEuclidModelForDictationReplacement)
  {
    if (!usesCandidateSelection)
    {
      if ([(_UIKeyboardStateManager *)self autocorrectionPreferenceForTraits])
      {
        v31 = [(_UIKeyboardStateManager *)self changeCount]!= 0;
      }

      else
      {
        v31 = 0;
      }

      _shouldLoadPredictionsBasedOnCurrentTraits = [(_UIKeyboardStateManager *)self _shouldLoadPredictionsBasedOnCurrentTraits];
      needContactAutofill = [(TIKeyboardState *)self->m_keyboardState needContactAutofill];
      if (v31 || _shouldLoadPredictionsBasedOnCurrentTraits || canShowAppConnections || v24 != 0 || (needContactAutofill & 1) != 0 || UIKeyboardCurrentInputModeIsMultiscript())
      {
        aBlock[0] = MEMORY[0x1E69E9820];
        aBlock[1] = 3221225472;
        aBlock[2] = __57___UIKeyboardStateManager_generateCandidatesWithOptions___block_invoke;
        aBlock[3] = &unk_1E70FDE98;
        aBlock[4] = self;
        v56 = v24 >> 2;
        v57 = _shouldDisplayWritingToolsCandidateOptions;
        v58 = v9;
        v43 = _Block_copy(aBlock);
        if (((v24 == 0) & _shouldEvaluateForWritingToolsInCandidateBarAsynchronously) == 1 && (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v44 = objc_claimAutoreleasedReturnValue(), [v44 selectedTextRange], v45 = objc_claimAutoreleasedReturnValue(), v46 = objc_msgSend(v45, "isEmpty"), v45, v44, v46))
        {
          objc_initWeak(&location, self);
          delegateAsResponder5 = [(_UIKeyboardStateManager *)self delegateAsResponder];
          v51[0] = MEMORY[0x1E69E9820];
          v51[1] = 3221225472;
          v51[2] = __57___UIKeyboardStateManager_generateCandidatesWithOptions___block_invoke_2;
          v51[3] = &unk_1E70FDEC0;
          objc_copyWeak(&v53, &location);
          v52 = v43;
          [delegateAsResponder5 _asyncShouldDisplayWritingToolsCandidateOptionsWithCompletionHandler:v51];

          objc_destroyWeak(&v53);
          objc_destroyWeak(&location);
        }

        else
        {
          if (v24)
          {
            v48 = 0;
          }

          else
          {
            v48 = _shouldDisplayWritingToolsCandidateOptions;
          }

          (*(v43 + 2))(v43, v48);
        }

        return;
      }

      if (!v9)
      {
        if (!_shouldDisplayWritingToolsCandidateOptions)
        {
          if ([(_UIKeyboardStateManager *)self _isShowingSuggestionForKeyboardCamera])
          {
            [(_UIKeyboardStateManager *)self setSuggestions:0];
          }

          delegateAsResponder4 = [(_UIKeyboardStateManager *)self autocorrectionController];
          [delegateAsResponder4 clearAutocorrectionAndNotifyObservers:1];
          goto LABEL_73;
        }

        goto LABEL_68;
      }

      goto LABEL_64;
    }

    if (v24)
    {
      [(_UIKeyboardStateManager *)self setUserSelectedCurrentCandidate:0];
    }

    else if (v9 && ([(_UIKeyboardStateManager *)self inputForMarkedText], v27 = objc_claimAutoreleasedReturnValue(), v27, !v27))
    {
      [(_UIKeyboardStateManager *)self _generateTextSuggestionForKeyboardCamera];
    }

    else if (_shouldDisplayWritingToolsCandidateOptions)
    {
      inputForMarkedText = [(_UIKeyboardStateManager *)self inputForMarkedText];

      if (!inputForMarkedText)
      {
        delegateAsResponder6 = [(_UIKeyboardStateManager *)self delegateAsResponder];
        _textSuggestionsForWritingTools2 = [delegateAsResponder6 _textSuggestionsForWritingTools];
        [(_UIKeyboardStateManager *)self setSuggestions:_textSuggestionsForWritingTools2];
      }
    }

    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    -[_UIKeyboardStateManager generateCandidatesAsynchronouslyWithRange:selectedCandidate:](self, "generateCandidatesAsynchronouslyWithRange:selectedCandidate:", 0, [inputManagerState initialCandidateBatchCount], 0);

    v33 = MEMORY[0x1E69D95F0];
    inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
    if ([inputManagerState2 suppressPlaceholderCandidate])
    {
      v35 = [v33 candidateWithUnchangedInput:0];
    }

    else
    {
      _markedText = [(_UIKeyboardStateManager *)self _markedText];
      v35 = [v33 candidateWithUnchangedInput:_markedText];
    }

    v37 = MEMORY[0x1E69D95E8];
    null = [MEMORY[0x1E695DFB0] null];
    v59[0] = null;
    v39 = [MEMORY[0x1E695DEC8] arrayWithObjects:v59 count:1];
    v40 = [v37 setWithCandidates:v39 initialSelectedIndex:0x7FFFFFFFFFFFFFFFLL defaultCandidate:v35 sortMethods:0 sortMethodGroups:0 indexTitles:0 showExtensionCandidates:0 disambiguationCandidates:0 selectedDisambiguationCandidateIndex:0x7FFFFFFFFFFFFFFFLL];
    [(_UIKeyboardStateManager *)self setCandidates:v40];

    [(_UIKeyboardStateManager *)self updateKeyboardConfigurations];
  }

  else
  {
    if (_os_feature_enabled_impl())
    {
      delegateAsResponder4 = [(_UIKeyboardStateManager *)self dictationAlternativesForReplacement];
      if ([delegateAsResponder4 count])
      {
        [(_UIKeyboardStateManager *)self populateDictationAlternativesCandidates:usesCandidateSelection withDictationAlternatives:delegateAsResponder4];
      }

      else
      {
        [(_UIKeyboardStateManager *)self populateEuclidCandidates:usesCandidateSelection];
      }

LABEL_73:

      return;
    }

    [(_UIKeyboardStateManager *)self populateEuclidCandidates:usesCandidateSelection];
  }
}

- (id)_buildCandidatesFromResults:(id)results selectedText:(id)text
{
  v25 = *MEMORY[0x1E69E9840];
  resultsCopy = results;
  textCopy = text;
  v8 = [(_UIKeyboardStateManager *)self isSelectionAtSentenceAutoshiftBoundary:1];
  array = [MEMORY[0x1E695DF70] array];
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v10 = resultsCopy;
  v11 = [v10 countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (v11)
  {
    v12 = v11;
    v13 = *v21;
    do
    {
      for (i = 0; i != v12; ++i)
      {
        if (*v21 != v13)
        {
          objc_enumerationMutation(v10);
        }

        v15 = *(*(&v20 + 1) + 8 * i);
        if (v8)
        {
          v16 = [UIDictationUtilities capitalizeFirstWord:v15, v20];
        }

        else
        {
          v16 = v15;
        }

        v17 = v16;
        v18 = [MEMORY[0x1E69D95F0] candidateWithCandidate:v16 forInput:textCopy property:{32, v20}];
        [array addObject:v18];
      }

      v12 = [v10 countByEnumeratingWithState:&v20 objects:v24 count:16];
    }

    while (v12);
  }

  return array;
}

- (void)_updateCandidatesWithCandidates:(id)candidates usesCandidateSelection:(BOOL)selection
{
  candidatesCopy = candidates;
  v7 = [MEMORY[0x1E69D9570] listWithCorrections:0 predictions:candidatesCopy];
  v10[0] = MEMORY[0x1E69E9820];
  v10[1] = 3221225472;
  v10[2] = __82___UIKeyboardStateManager__updateCandidatesWithCandidates_usesCandidateSelection___block_invoke;
  v10[3] = &unk_1E70F5B18;
  selectionCopy = selection;
  v10[4] = self;
  v11 = candidatesCopy;
  v12 = v7;
  v8 = v7;
  v9 = candidatesCopy;
  dispatch_async(MEMORY[0x1E69E96A0], v10);
}

- (void)populateEuclidCandidates:(BOOL)candidates
{
  _textInputController = [(_UIKeyboardStateManager *)self _textInputController];
  _selectedText = [_textInputController _selectedText];
  v7 = +[UIDictationController activeInstance];
  v9[0] = MEMORY[0x1E69E9820];
  v9[1] = 3221225472;
  v9[2] = __52___UIKeyboardStateManager_populateEuclidCandidates___block_invoke;
  v9[3] = &unk_1E70FDEE8;
  v9[4] = self;
  v10 = _selectedText;
  candidatesCopy = candidates;
  v8 = _selectedText;
  [v7 euclidPhoneticString:v8 maxResultsCount:10 completion:v9];
}

- (void)populateDictationAlternativesCandidates:(BOOL)candidates withDictationAlternatives:(id)alternatives
{
  candidatesCopy = candidates;
  alternativesCopy = alternatives;
  _textInputController = [(_UIKeyboardStateManager *)self _textInputController];
  _selectedText = [_textInputController _selectedText];
  v8 = [(_UIKeyboardStateManager *)self _buildCandidatesFromResults:alternativesCopy selectedText:_selectedText];

  [(_UIKeyboardStateManager *)self _updateCandidatesWithCandidates:v8 usesCandidateSelection:candidatesCopy];
}

- (id)dictationAlternativesForReplacement
{
  _textInputController = [(_UIKeyboardStateManager *)self _textInputController];
  dictationAlternativesForSelectedText = [_textInputController dictationAlternativesForSelectedText];

  return dictationAlternativesForSelectedText;
}

- (void)_generateTextSuggestionForKeyboardCamera
{
  v8[1] = *MEMORY[0x1E69E9840];
  delegate = [(_UIKeyboardStateManager *)self delegate];
  v4 = [UIAction _textFromCameraTitleForResponder:delegate];
  v5 = [UITextSuggestionWithAction textSuggestionWithInputText:v4];
  [v5 setTarget:delegate];
  [v5 setAction:sel_captureTextFromCamera_];
  v6 = +[UIAction _textFromCameraImage];
  [v5 setImage:v6];

  v8[0] = v5;
  v7 = [MEMORY[0x1E695DEC8] arrayWithObjects:v8 count:1];
  [(_UIKeyboardStateManager *)self setSuggestions:v7];
}

- (id)replacementsFromSelectedText
{
  v3 = objc_alloc_init(UITextReplacementGeneratorForCorrections);
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  selectedTextRange = [inputDelegateManager selectedTextRange];
  [(UITextReplacementGenerator *)v3 setReplacementRange:selectedTextRange];

  inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  replacementRange = [(UITextReplacementGenerator *)v3 replacementRange];
  v8 = [inputDelegateManager2 textInRange:replacementRange];
  [(UITextReplacementGenerator *)v3 setStringToReplace:v8];

  v9 = [[UITextChecker alloc] _initWithAsynchronousLoading:1];
  if ([v9 _doneLoading])
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  [(UITextReplacementGeneratorForCorrections *)v3 setTextChecker:v10];
  stringToReplace = [(UITextReplacementGenerator *)v3 stringToReplace];
  v12 = [(_UIKeyboardStateManager *)self autocorrectionRecordForWord:stringToReplace];
  [(UITextReplacementGeneratorForCorrections *)v3 setAutocorrectionRecord:v12];

  [(UITextReplacementGeneratorForCorrections *)v3 setForceHistoryReplacement:1];
  [(UITextReplacementGeneratorForCorrections *)v3 setForceAutocorrectionGuesses:1];
  [(UITextReplacementGeneratorForCorrections *)v3 setForceSpellingGuesses:1];
  [(UITextReplacementGeneratorForCorrections *)v3 setMaxCountAfterAutocorrectionGuesses:1];
  [(UITextReplacementGeneratorForCorrections *)v3 setMaxCountAfterSpellingGuesses:3];
  replacements = [(UITextReplacementGeneratorForCorrections *)v3 replacements];

  return replacements;
}

- (void)generateCandidatesFromReplacements
{
  v23 = *MEMORY[0x1E69E9840];
  replacementsFromSelectedText = [(_UIKeyboardStateManager *)self replacementsFromSelectedText];
  v4 = [objc_alloc(MEMORY[0x1E695DF70]) initWithCapacity:{objc_msgSend(replacementsFromSelectedText, "count")}];
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v5 = replacementsFromSelectedText;
  v6 = [v5 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v6)
  {
    v7 = v6;
    v8 = *v19;
    do
    {
      for (i = 0; i != v7; ++i)
      {
        if (*v19 != v8)
        {
          objc_enumerationMutation(v5);
        }

        v10 = *(*(&v18 + 1) + 8 * i);
        v11 = MEMORY[0x1E69D95F0];
        replacementText = [v10 replacementText];
        originalText = [v10 originalText];
        v14 = [v11 candidateWithCandidate:replacementText forInput:originalText];
        [v4 addObject:v14];
      }

      v7 = [v5 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }

    while (v7);
  }

  v15 = [MEMORY[0x1E69D9570] listWithCorrections:0 predictions:v4];
  [v15 updateLabelsWithSmartPunctuation:self->m_smartPunctuationController];
  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  [autocorrectionController setAutocorrectionList:v15];

  v17 = [MEMORY[0x1E69D95E8] setWithCandidates:v4];
  [(_UIKeyboardStateManager *)self setCandidates:v17];
}

- (id)generateAutocorrectionReplacements:(id)replacements
{
  replacementsCopy = replacements;
  v12 = 0;
  v13 = &v12;
  v14 = 0x3032000000;
  v15 = __Block_byref_object_copy__36;
  v16 = __Block_byref_object_dispose__36;
  v17 = 0;
  if (qword_1ED49D488 != -1)
  {
    dispatch_once(&qword_1ED49D488, &__block_literal_global_1766);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v9[0] = MEMORY[0x1E69E9820];
  v9[1] = 3221225472;
  v9[2] = __62___UIKeyboardStateManager_generateAutocorrectionReplacements___block_invoke_3;
  v9[3] = &unk_1E70FD978;
  v9[4] = self;
  v6 = replacementsCopy;
  v10 = v6;
  v11 = &v12;
  [taskQueue performSingleTask:v9 breadcrumb:qword_1ED49D480];

  [v13[5] updateLabelsWithSmartPunctuation:self->m_smartPunctuationController];
  predictions = [v13[5] predictions];
  _Block_object_dispose(&v12, 8);

  return predictions;
}

- (id)generateAutocorrectionListForSelectedText
{
  if ([(_UIKeyboardStateManager *)self shouldAccessInputManagerService]&& ([(_UIKeyboardStateManager *)self refreshKeyboardState], ([(TIKeyboardState *)self->m_keyboardState autocorrectionListUIDisplayed]& 1) == 0))
  {
    v12 = 0;
    v13 = &v12;
    v14 = 0x3032000000;
    v15 = __Block_byref_object_copy__36;
    v16 = __Block_byref_object_dispose__36;
    v17 = 0;
    v4 = [(TIKeyboardState *)self->m_keyboardState copy];
    [v4 setAutofillMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillMode](self->m_keyboardState, "autofillMode"))}];
    [v4 setAutofillSubMode:{+[UIKBAutofillController translateToTextInputAutofillMode:](UIKBAutofillController, "translateToTextInputAutofillMode:", -[TIKeyboardState autofillSubMode](self->m_keyboardState, "autofillSubMode"))}];
    if (qword_1ED49D498 != -1)
    {
      dispatch_once(&qword_1ED49D498, &__block_literal_global_1770);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v8[0] = MEMORY[0x1E69E9820];
    v8[1] = 3221225472;
    v8[2] = __68___UIKeyboardStateManager_generateAutocorrectionListForSelectedText__block_invoke_3;
    v8[3] = &unk_1E70FD978;
    v6 = v4;
    v9 = v6;
    selfCopy = self;
    v11 = &v12;
    [taskQueue performSingleTask:v8 breadcrumb:qword_1ED49D490];

    [v13[5] updateLabelsWithSmartPunctuation:self->m_smartPunctuationController];
    v3 = v13[5];

    _Block_object_dispose(&v12, 8);
  }

  else
  {
    v3 = 0;
  }

  return v3;
}

- (id)savedAutocorrectionListForCandidate:(id)candidate
{
  candidateCopy = candidate;
  _textChoicesAssistant = [(_UIKeyboardStateManager *)self _textChoicesAssistant];
  candidate = [candidateCopy candidate];

  v7 = [_textChoicesAssistant listForFinalString:candidate];

  return v7;
}

- (void)clearAutoDeleteTimer
{
  [(UIKeyboardScheduledTask *)self->m_autoDeleteTask invalidate];
  m_autoDeleteTask = self->m_autoDeleteTask;
  self->m_autoDeleteTask = 0;
}

- (void)touchAutoDeleteTimerWithThreshold:(double)threshold adjustForPartialCompletion:(BOOL)completion
{
  completionCopy = completion;
  [(_UIKeyboardStateManager *)self clearAutoDeleteTimer];
  thresholdCopy = threshold;
  if (completionCopy)
  {
    thresholdCopy = threshold - (CFAbsoluteTimeGetCurrent() - self->m_autoDeleteLastDelete);
  }

  if (qword_1ED49D4B8 != -1)
  {
    dispatch_once(&qword_1ED49D4B8, &__block_literal_global_1778);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v11[0] = MEMORY[0x1E69E9820];
  v11[1] = 3221225472;
  v11[2] = __88___UIKeyboardStateManager_touchAutoDeleteTimerWithThreshold_adjustForPartialCompletion___block_invoke_3;
  v11[3] = &unk_1E70FDF88;
  v12 = completionCopy;
  v11[4] = self;
  *&v11[5] = threshold;
  v9 = [taskQueue scheduleTask:v11 timeInterval:!completionCopy repeats:qword_1ED49D4B0 breadcrumb:thresholdCopy];
  m_autoDeleteTask = self->m_autoDeleteTask;
  self->m_autoDeleteTask = v9;
}

- (void)handleAutoDeleteContinuationOnDestinationWithDeletionCount:(unint64_t)count
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];

  if (inputDelegate)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    _selectionAtDocumentStart = [inputDelegateManager _selectionAtDocumentStart];

    if (_selectionAtDocumentStart)
    {
      remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      [remoteTextInputPartner forwardInputDestinationEventToUIHost:sel_performStopAutoDeleteAtDocumentStart];
    }

    else
    {
      if (!count)
      {
        return;
      }

      [(_UIKeyboardStateManager *)self performAutoDeleteNumberOfTimes:count deleteOneWord:1 forwardToInputSource:0];
      remoteTextInputPartner = +[UIDictationController activeInstance];
      [remoteTextInputPartner markKeyboardDeleteMetricEvent];
    }
  }
}

- (void)performStopAutoDeleteAtDocumentStart
{
  if (qword_1ED49D4C8 != -1)
  {
    dispatch_once(&qword_1ED49D4C8, &__block_literal_global_1784);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = __63___UIKeyboardStateManager_performStopAutoDeleteAtDocumentStart__block_invoke_3;
  v4[3] = &unk_1E70FD058;
  v4[4] = self;
  [taskQueue addTask:v4 breadcrumb:qword_1ED49D4C0];
}

- (void)_stopAutoDeleteAtDocumentStart
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  [layout deactivateActiveKeys];

  [(_UIKeyboardStateManager *)self clearAutoDeleteTimer];

  [(_UIKeyboardStateManager *)self clearShiftState];
}

- (void)handleAutoDeleteWithExecutionContext:(id)context
{
  contextCopy = context;
  if (![(_UIKeyboardStateManager *)self hasAdvancedInputDelegate])
  {
    goto LABEL_10;
  }

  self->m_autoDeleteOK = 1;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  _selectionAtDocumentStart = [inputDelegateManager _selectionAtDocumentStart];

  if (_selectionAtDocumentStart)
  {
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    forwardingInputDelegate = [inputDelegateManager2 forwardingInputDelegate];

    if (!+[UIKeyboard isKeyboardProcess]|| forwardingInputDelegate)
    {
      [(_UIKeyboardStateManager *)self _stopAutoDeleteAtDocumentStart];
    }

    else
    {
      inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
      textOperations = [inputSystemSourceSession textOperations];
      [textOperations setCustomInfoType:0x1EFB7CA30];

      v11 = [MEMORY[0x1E696AD98] numberWithUnsignedInteger:{-[_UIKeyboardStateManager lastDeletionCountForFastDelete](self, "lastDeletionCountForFastDelete")}];
      textOperations2 = [inputSystemSourceSession textOperations];
      [textOperations2 setCustomInfo:v11];

      [inputSystemSourceSession flushOperations];
    }

    goto LABEL_10;
  }

  Current = CFAbsoluteTimeGetCurrent();
  if (self->m_autoDeleteCount)
  {
    if (Current - self->m_autoDeleteLastDelete < self->m_autoDeleteInterval * 0.5)
    {
LABEL_10:
      [contextCopy returnExecutionToParent];
      goto LABEL_11;
    }
  }

  self->m_autoDeleteLastDelete = Current;
  v15[0] = MEMORY[0x1E69E9820];
  v15[1] = 3221225472;
  v15[2] = __64___UIKeyboardStateManager_handleAutoDeleteWithExecutionContext___block_invoke;
  v15[3] = &unk_1E70FD058;
  v15[4] = self;
  v14 = [contextCopy childWithContinuation:v15];
  [(_UIKeyboardStateManager *)self handleDeleteAsRepeat:1 executionContext:v14];

LABEL_11:
}

- (void)completeHandleAutoDelete
{
  m_autoDeleteInterval = self->m_autoDeleteInterval;
  if (self->m_repeatDeleteWord)
  {
    uncommittedText = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet uncommittedText];

    if (!uncommittedText)
    {
      v7 = +[UIKeyboardPreferencesController sharedPreferencesController];
      preferencesActions = [v7 preferencesActions];
      v9 = [preferencesActions valueForPreferenceKey:@"RepeatDeleteWordRepeatInterfal"];
      [v9 floatValue];
      v11 = v10;

      v12 = +[UIKeyboardPreferencesController sharedPreferencesController];
      preferencesActions2 = [v12 preferencesActions];
      v14 = [preferencesActions2 valueForPreferenceKey:@"RepeatDeleteWordCountForDecrement"];
      integerValue = [v14 integerValue];

      m_autoDeleteInterval = v11 + (self->m_autoDeleteCount / integerValue) * -0.1;
LABEL_10:
      if (m_autoDeleteInterval < 0.05)
      {
        goto LABEL_15;
      }

      goto LABEL_13;
    }
  }

  m_autoDeleteCount = self->m_autoDeleteCount;
  if (m_autoDeleteCount != 20)
  {
    if (m_autoDeleteCount)
    {
      goto LABEL_10;
    }

    if (!self->m_autoDeleteUseForce)
    {
      m_autoDeleteInterval = 0.1;
      goto LABEL_13;
    }

    goto LABEL_8;
  }

  if (self->m_autoDeleteUseForce)
  {
LABEL_8:
    [(_UIKeyboardStateManager *)self timeoutForCurrentForce];
    m_autoDeleteInterval = v6;
    goto LABEL_10;
  }

  m_autoDeleteInterval = 0.35;
LABEL_13:
  if (m_autoDeleteInterval != self->m_autoDeleteInterval)
  {
    self->m_autoDeleteInterval = m_autoDeleteInterval;
    [(_UIKeyboardStateManager *)self touchAutoDeleteTimerWithThreshold:0 adjustForPartialCompletion:m_autoDeleteInterval];
  }

LABEL_15:
  ++self->m_autoDeleteCount;
}

- (void)startAutoDeleteTimer
{
  v3 = +[UIKeyboardPreferencesController sharedPreferencesController];
  preferencesActions = [v3 preferencesActions];
  self->m_repeatDeleteWord = [preferencesActions BOOLForPreferenceKey:@"RepeatDeleteWordEnabled"];

  if (self->m_repeatDeleteWord)
  {
    v5 = +[UIKeyboardPreferencesController sharedPreferencesController];
    preferencesActions2 = [v5 preferencesActions];
    v7 = [preferencesActions2 valueForPreferenceKey:@"RepeatDeleteWordFirstDelay"];
    [v7 floatValue];
    self->m_autoDeleteInterval = v8;

    m_autoDeleteInterval = self->m_autoDeleteInterval;
  }

  else
  {
    self->m_autoDeleteInterval = 0.5;
    m_autoDeleteInterval = 0.5;
  }

  [(_UIKeyboardStateManager *)self touchAutoDeleteTimerWithThreshold:0 adjustForPartialCompletion:m_autoDeleteInterval];
  self->m_autoDeleteCount = 0;
  self->m_autoDeleteLastDelete = -*MEMORY[0x1E695E460];
  self->m_autoDeleteShiftCharacter = 0;
}

- (double)scaleCurrentForceFrom:(double)result to:(double)to
{
  v4 = 0.5;
  if (self->m_autoDeleteUseForce)
  {
    v4 = (self->m_autoDeleteCurrentForce + -80.0) / 420.0;
  }

  v5 = (to - result) * v4 + result;
  if (result >= to)
  {
    toCopy = result;
  }

  else
  {
    toCopy = to;
  }

  if (result >= to)
  {
    result = to;
  }

  if (v5 >= toCopy)
  {
    v7 = toCopy;
  }

  else
  {
    v7 = v5;
  }

  if (v7 >= result)
  {
    return v7;
  }

  return result;
}

- (double)timeoutForCurrentForce
{
  shouldRapidDelete = [(_UIKeyboardStateManager *)self shouldRapidDelete];
  v4 = 0.3;
  if (!shouldRapidDelete)
  {
    v4 = 0.1;
  }

  [(_UIKeyboardStateManager *)self scaleCurrentForceFrom:v4 to:?];
  return result;
}

- (void)startAutoDeleteTimerForForce:(double)force
{
  if (_AXSForceTouchEnabled())
  {
    self->m_autoDeleteUseForce = 1;
    _AXSForceTouchSensitivity();
    self->m_autoDeleteCurrentForceMultipler = v5;
    [(_UIKeyboardStateManager *)self convertForceToGrams:force];
    self->m_autoDeleteCurrentForce = v6;
  }

  [(_UIKeyboardStateManager *)self startAutoDeleteTimer];
}

- (void)adjustAutoDeleteTimerForForce:(double)force
{
  if (self->m_autoDeleteUseForce)
  {
    [(_UIKeyboardStateManager *)self convertForceToGrams:force];
    if (v4 != self->m_autoDeleteCurrentForce)
    {
      self->m_autoDeleteCurrentForce = v4;
      if (self->m_autoDeleteCount)
      {
        [(_UIKeyboardStateManager *)self timeoutForCurrentForce];

        [(_UIKeyboardStateManager *)self touchAutoDeleteTimerWithThreshold:1 adjustForPartialCompletion:?];
      }
    }
  }
}

- (void)touchUpdateLastUsedInputModeAction
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  isPossibleToTypeFast = [layout isPossibleToTypeFast];

  if (isPossibleToTypeFast)
  {
    v6 = +[UIKeyboardInputModeController sharedInputModeController];
    disablesUpdateLastUsedInputModeTimer = [v6 disablesUpdateLastUsedInputModeTimer];

    if ((disablesUpdateLastUsedInputModeTimer & 1) == 0)
    {
      m_updateLastUsedInputModeAction = self->m_updateLastUsedInputModeAction;
      if (m_updateLastUsedInputModeAction)
      {

        [(UIDelayedAction *)m_updateLastUsedInputModeAction touch];
      }

      else
      {
        if (TIGetUpdateLastUsedInputModeDelayValue_onceToken[0] != -1)
        {
          dispatch_once(TIGetUpdateLastUsedInputModeDelayValue_onceToken, &__block_literal_global_3798);
        }

        mEMORY[0x1E69D9680] = [MEMORY[0x1E69D9680] sharedPreferencesController];
        v10 = [mEMORY[0x1E69D9680] valueForPreferenceKey:@"UpdateLastUsedInputModeDelay"];

        [v10 doubleValue];
        v12 = v11;

        if (v12 > 0.0)
        {
          v13 = [[UIDelayedAction alloc] initWithTarget:self action:sel_handleUpdateLastUsedInputModeAction_ userInfo:0 delay:v12];
          v14 = self->m_updateLastUsedInputModeAction;
          self->m_updateLastUsedInputModeAction = v13;
        }
      }
    }
  }
}

- (void)clearUpdateLastUsedInputModeAction
{
  [(UIDelayedAction *)self->m_updateLastUsedInputModeAction cancel];
  m_updateLastUsedInputModeAction = self->m_updateLastUsedInputModeAction;
  self->m_updateLastUsedInputModeAction = 0;
}

- (void)handleUpdateLastUsedInputModeAction:(id)action
{
  v3 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v3 currentInputMode];

  if (([currentInputMode isEmojiInputMode] & 1) == 0)
  {
    v4 = +[UIKeyboardInputModeController sharedInputModeController];
    [v4 updateLastUsedInputMode:currentInputMode];
  }
}

- (void)touchLongPressTimerWithDelay:(double)delay userInfo:(id)info
{
  infoCopy = info;
  m_longPressAction = self->m_longPressAction;
  if (!m_longPressAction)
  {
    goto LABEL_4;
  }

  [(UIDelayedAction *)m_longPressAction delay];
  if (v7 != delay)
  {
    [(_UIKeyboardStateManager *)self clearLongPressTimer];
LABEL_4:
    v8 = [[UIDelayedAction alloc] initWithTarget:self action:sel_handleDelayedActionLongPress_ userInfo:infoCopy delay:delay];
    v9 = self->m_longPressAction;
    self->m_longPressAction = v8;

    goto LABEL_6;
  }

  [(UIDelayedAction *)self->m_longPressAction touch];
LABEL_6:
}

- (double)shouldExtendLongPressAction:(id)action
{
  v31 = *MEMORY[0x1E69E9840];
  actionCopy = action;
  processInfo = [MEMORY[0x1E696AE30] processInfo];
  [processInfo systemUptime];
  v7 = v6;

  [(_UIKeyboardStateManager *)self timestampOfLastTouchesEnded];
  v9 = 0.0;
  if (v8 + 0.4 < v7)
  {
    if (self->m_didExtendLongPressDelayForContinuousPath || (v10 = objc_loadWeakRetained(&self->_presentationDelegate), [v10 layout], v11 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v11, "typingStyleEstimator"), v12 = objc_claimAutoreleasedReturnValue(), v13 = objc_msgSend(v12, "currentTypingStyleEstimation"), v12, v11, v10, v13 < 2))
    {
      self->m_didExtendLongPressDelayForContinuousPath = 0;
      v26 = 0u;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      layout = [WeakRetained layout];
      gestureRecognizers = [layout gestureRecognizers];

      v17 = [gestureRecognizers countByEnumeratingWithState:&v26 objects:v30 count:16];
      if (v17)
      {
        v18 = v17;
        v19 = *v27;
        do
        {
          v20 = 0;
          do
          {
            if (*v27 != v19)
            {
              objc_enumerationMutation(gestureRecognizers);
            }

            v21 = *(*(&v26 + 1) + 8 * v20);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0 && ![v21 state] && objc_msgSend(v21, "forceHasIncreasedForTimeInterval:", 0.1))
            {
              [v21 minimumPressDuration];
              v23 = v22;
              [actionCopy delay];
              v9 = v23 - v24 + 0.01;
            }

            ++v20;
          }

          while (v18 != v20);
          v18 = [gestureRecognizers countByEnumeratingWithState:&v26 objects:v30 count:16];
        }

        while (v18);
      }
    }

    else
    {
      self->m_didExtendLongPressDelayForContinuousPath = 1;
      v9 = 1.0;
    }
  }

  return v9;
}

- (void)handleDelayedActionLongPress:(id)press
{
  pressCopy = press;
  [(_UIKeyboardStateManager *)self shouldExtendLongPressAction:self->m_longPressAction];
  if (v5 <= 0.0)
  {
    v6 = self->m_longPressAction;
    if (qword_1ED49D4D8 != -1)
    {
      dispatch_once(&qword_1ED49D4D8, &__block_literal_global_1795);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    v10[0] = MEMORY[0x1E69E9820];
    v10[1] = 3221225472;
    v10[2] = __56___UIKeyboardStateManager_handleDelayedActionLongPress___block_invoke_3;
    v10[3] = &unk_1E70FD208;
    v11 = v6;
    selfCopy = self;
    v13 = pressCopy;
    v8 = qword_1ED49D4D0;
    v9 = v6;
    [taskQueue addTask:v10 breadcrumb:v8];
  }

  else
  {
    [(_UIKeyboardStateManager *)self touchLongPressTimerWithDelay:?];
  }
}

- (void)longPressAction:(id)action
{
  [(_UIKeyboardStateManager *)self clearLongPressTimer];
  self->m_longPress = 1;

  [(_UIKeyboardStateManager *)self callLayoutLongPressAction];
}

- (void)clearTimers
{
  if (pthread_main_np())
  {
    [(_UIKeyboardStateManager *)self clearLongPressTimer];
    [(_UIKeyboardStateManager *)self clearAutocorrectPromptTimer];
    [(_UIKeyboardStateManager *)self clearAutoDeleteTimer];
    [(_UIKeyboardStateManager *)self clearCapsLockDelayOverrideTimer];
    [(_UIKeyboardStateManager *)self clearUpdateLastUsedInputModeAction];

    [(_UIKeyboardStateManager *)self clearIdleDetectionAction];
  }

  else
  {

    [(_UIKeyboardStateManager *)self performSelectorOnMainThread:a2 withObject:0 waitUntilDone:0];
  }
}

- (void)updateHardwareKeyboardLayout:(BOOL)layout
{
  layoutCopy = layout;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateHardwareKeyboardLayout:layoutCopy];
}

- (void)setInHardwareKeyboardMode:(BOOL)mode forceRebuild:(BOOL)rebuild shouldMoveKeyboard:(BOOL)keyboard
{
  keyboardCopy = keyboard;
  rebuildCopy = rebuild;
  modeCopy = mode;
  v9 = [(TIKeyboardState *)self->m_keyboardState hardwareKeyboardMode]^ mode;
  if (v9 == 1)
  {
    [(TIKeyboardState *)self->m_keyboardState setHardwareKeyboardMode:modeCopy];
    v10 = 4;
    if (!modeCopy)
    {
      v10 = 1;
    }

    self->m_textInputSource = v10;
    [(_UIKeyboardStateManager *)self _requestInputManagerSync];
  }

  if (!keyboardCopy)
  {
    goto LABEL_13;
  }

  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    remoteTextInputClientHasActiveSession = [remoteTextInputPartner remoteTextInputClientHasActiveSession];

    if (remoteTextInputClientHasActiveSession)
    {
      goto LABEL_13;
    }
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  geometryDelegate = [WeakRetained geometryDelegate];
  if (![geometryDelegate isAutomatic])
  {

    goto LABEL_12;
  }

  if (v9)
  {
  }

  else
  {
    v15 = objc_loadWeakRetained(&self->_presentationDelegate);
    geometryDelegate2 = [v15 geometryDelegate];
    isMinimized = [geometryDelegate2 isMinimized];

    if (isMinimized == modeCopy)
    {
      return;
    }
  }

  if ([(TIKeyboardState *)self->m_keyboardState hardwareKeyboardMode]&& ![(_UIKeyboardStateManager *)self floatingForced])
  {
    if (![(_UIKeyboardStateManager *)self automaticMinimizationEnabled])
    {
      goto LABEL_13;
    }

    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    [WeakRetained hideKeyboard];
LABEL_12:

    goto LABEL_13;
  }

  v18 = +[UIKeyboardSceneDelegate automaticKeyboardArbiterClient];
  handlingRemoteEvent = [v18 handlingRemoteEvent];

  if ((handlingRemoteEvent & 1) == 0)
  {
    v20 = objc_loadWeakRetained(&self->_presentationDelegate);
    isUsingDictationLayout = [v20 isUsingDictationLayout];

    if (isUsingDictationLayout)
    {
      v22 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v22 showKeyboard];

      WeakRetained = +[UIDictationView sharedInstance];
      v23 = +[UIDictationController sharedInstance];
      [WeakRetained setState:{objc_msgSend(v23, "state")}];
    }

    else
    {
      [(_UIKeyboardStateManager *)self recomputeActiveInputModesWithExtensions:1 allowNonLinguisticInputModes:1];
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      [WeakRetained showKeyboard];
    }

    goto LABEL_12;
  }

LABEL_13:
  if (v9)
  {
    if (self->m_hardwareKeyboardAttached)
    {
      [(_UIKeyboardStateManager *)self updateHardwareKeyboardLayout:rebuildCopy];
    }

    [(_UIKeyboardStateManager *)self notifyInputSourceStateChangeIfNeeded];
  }
}

- (void)proceedShouldReturnIfNeededForASP
{
  v3 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v3 currentInputMode];
  identifier = [currentInputMode identifier];
  if ([identifier isEqualToString:@"autofillsignup"])
  {
    delegateAlreadyInAutofillGroup = [(_UIKeyboardStateManager *)self delegateAlreadyInAutofillGroup];

    if (delegateAlreadyInAutofillGroup)
    {
      inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
      objc_opt_class();
      isKindOfClass = objc_opt_isKindOfClass();

      if (isKindOfClass)
      {
        inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
        delegate = [inputDelegate2 delegate];
        v10 = objc_opt_respondsToSelector();

        if (v10)
        {
          [(_UIKeyboardStateManager *)self callShouldInsertText:@"\n"];
        }

        else
        {
          [(_UIKeyboardStateManager *)self dismissKeyboard];
        }

        return;
      }
    }
  }

  else
  {
  }

  [(_UIKeyboardStateManager *)self dismissKeyboard];
}

- (void)nonDestructivelyDismissKeyboard
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained nonDestructivelyDismissKeyboard];
}

- (void)dismissKeyboard
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained dismissKeyboard];
}

- (void)_attemptAuthenticationWithMessage:(id)message
{
  if (message)
  {
    [(TIKeyboardState *)self->m_keyboardState setEventAuthenticationMessage:?];
  }
}

- (BOOL)_isValidKeyInput:(id)input
{
  inputCopy = input;
  if ([(UITextInputTraits *)self->m_traits isSecureTextEntry])
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [WeakRetained layout];
    if (layout)
    {
      v7 = layout;
      v8 = objc_loadWeakRetained(&self->_presentationDelegate);
      layout2 = [v8 layout];
      v10 = [layout2 canProduceString:inputCopy];

      if (!v10)
      {
        goto LABEL_4;
      }
    }

    else
    {
    }
  }

  v12 = [inputCopy length];
  if (!v12)
  {
LABEL_11:
    v11 = 1;
    goto LABEL_12;
  }

  v13 = v12;
  v14 = 0;
  while (1)
  {
    v15 = [inputCopy characterAtIndex:v14];
    if (v15 < 0x20 && ((0xFFFFD8FF >> v15) & 1) != 0)
    {
      break;
    }

    if (v13 == ++v14)
    {
      goto LABEL_11;
    }
  }

LABEL_4:
  v11 = 0;
LABEL_12:

  return v11;
}

- (void)updateKeyboardEventsLagging:(id)lagging
{
  laggingCopy = lagging;
  v5 = GSCurrentEventTimestamp() / 1000000000.0;
  [laggingCopy timestamp];
  v7 = v6;

  m_keyboardState = self->m_keyboardState;

  [(TIKeyboardState *)m_keyboardState setKeyboardEventsLagging:v5 - v7 > 0.004, v5 - v7];
}

- (void)_handleWebKeyEvent:(id)event withEventType:(unint64_t)type withInputString:(id)string withInputStringIgnoringModifiers:(id)modifiers
{
  eventCopy = event;
  stringCopy = string;
  modifiersCopy = modifiers;
  if (qword_1ED49D4E8 != -1)
  {
    dispatch_once(&qword_1ED49D4E8, &__block_literal_global_1802);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v18[0] = MEMORY[0x1E69E9820];
  v18[1] = 3221225472;
  v18[2] = __109___UIKeyboardStateManager__handleWebKeyEvent_withEventType_withInputString_withInputStringIgnoringModifiers___block_invoke_3;
  v18[3] = &unk_1E70FD630;
  v18[4] = self;
  v19 = eventCopy;
  v21 = modifiersCopy;
  typeCopy = type;
  v20 = stringCopy;
  v14 = qword_1ED49D4E0;
  v15 = modifiersCopy;
  v16 = stringCopy;
  v17 = eventCopy;
  [taskQueue addTask:v18 breadcrumb:v14];
}

- (void)_handleWebKeyEvent:(id)event withEventType:(int)type withInputString:(id)string withInputStringIgnoringModifiers:(id)modifiers executionContext:(id)context
{
  v10 = *&type;
  eventCopy = event;
  stringCopy = string;
  modifiersCopy = modifiers;
  contextCopy = context;
  if (+[UIKeyboard isKeyboardProcess])
  {
    inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
    v17 = inputSystemSourceSession;
    if (inputSystemSourceSession)
    {
      textOperations = [inputSystemSourceSession textOperations];
      [eventCopy setKeyEventForwardedFromInputUIHost:1];
      [textOperations setCustomInfoType:0x1EFB7CA50];
      dictionary = [MEMORY[0x1E695DF90] dictionary];
      [dictionary setObject:@"_handleWebKeyEvent:withEventType:withInputString:withInputStringIgnoringModifiers:" forKeyedSubscript:@"selector"];
      [dictionary setObject:eventCopy forKeyedSubscript:@"keyEvent"];
      v20 = [MEMORY[0x1E696AD98] numberWithUnsignedInt:v10];
      [dictionary setObject:v20 forKeyedSubscript:@"webEventType"];

      if (stringCopy)
      {
        [dictionary setObject:stringCopy forKeyedSubscript:@"inputString"];
      }

      if (modifiersCopy)
      {
        [dictionary setObject:modifiersCopy forKeyedSubscript:@"inputStringIgnoringModifiers"];
      }

      [textOperations setCustomInfo:dictionary];
      buildInputSourceState = [(_UIKeyboardStateManager *)self buildInputSourceState];
      [textOperations setInputSourceState:buildInputSourceState];

      [v17 flushOperations];
    }

    [contextCopy returnExecutionToParent];
  }

  else
  {
    location = 0;
    p_location = &location;
    v59 = 0x2050000000;
    v22 = qword_1ED49D5F0;
    v60 = qword_1ED49D5F0;
    if (!qword_1ED49D5F0)
    {
      v51 = MEMORY[0x1E69E9820];
      v52 = 3221225472;
      v53 = __getWebEventClass_block_invoke;
      v54 = &unk_1E70F2F20;
      v55 = &location;
      __getWebEventClass_block_invoke(&v51);
      v22 = p_location[3];
    }

    v23 = v22;
    _Block_object_dispose(&location, 8);
    v41 = [v22 alloc];
    [eventCopy timestamp];
    v25 = v24;
    _gsModifierFlags = [eventCopy _gsModifierFlags];
    v43 = modifiersCopy;
    v44 = stringCopy;
    val = contextCopy;
    v27 = v10;
    if ([eventCopy _hidEvent] || self->m_shiftLocked)
    {
      v28 = 0;
    }

    else if (self->m_shift)
    {
      v28 = 0x20000;
    }

    else
    {
      v28 = 0;
    }

    _isARepeat = [eventCopy _isARepeat];
    _inputFlags = [eventCopy _inputFlags];
    _hint = [eventCopy _hint];
    _keyCode = [eventCopy _keyCode];
    _modifiedInput = [eventCopy _modifiedInput];
    BYTE2(v40) = [_modifiedInput isEqualToString:@"\t"];
    LOWORD(v40) = _keyCode;
    v34 = [v41 initWithKeyEventType:v27 timeStamp:v44 characters:v43 charactersIgnoringModifiers:v28 | _gsModifierFlags modifiers:_isARepeat isRepeating:_inputFlags withFlags:v25 withInputManagerHint:_hint keyCode:v40 isTabKey:?];

    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    delegateAdoptsWebTextInputPrivate = [inputDelegateManager delegateAdoptsWebTextInputPrivate];

    if (delegateAdoptsWebTextInputPrivate)
    {
      v51 = 0;
      v52 = &v51;
      v53 = 0x3032000000;
      v54 = __Block_byref_object_copy__36;
      v55 = __Block_byref_object_dispose__36;
      v56 = 0;
      contextCopy = val;
      objc_initWeak(&location, val);
      aBlock[0] = MEMORY[0x1E69E9820];
      aBlock[1] = 3221225472;
      aBlock[2] = __126___UIKeyboardStateManager__handleWebKeyEvent_withEventType_withInputString_withInputStringIgnoringModifiers_executionContext___block_invoke;
      aBlock[3] = &unk_1E70FDFB0;
      objc_copyWeak(&v50, &location);
      aBlock[4] = &v51;
      v37 = _Block_copy(aBlock);
      [val setPendingCompletionBlock:v37];
      ++self->m_changeCount;
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v45[0] = MEMORY[0x1E69E9820];
      v45[1] = 3221225472;
      v45[2] = __126___UIKeyboardStateManager__handleWebKeyEvent_withEventType_withInputString_withInputStringIgnoringModifiers_executionContext___block_invoke_2;
      v45[3] = &unk_1E70FDFD8;
      selfCopy = self;
      v48 = &v51;
      v46 = val;
      [inputDelegateManager2 handleKeyWebEvent:v34 withCompletionHandler:v45];

      objc_destroyWeak(&v50);
      objc_destroyWeak(&location);
      _Block_object_dispose(&v51, 8);
    }

    else
    {
      inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager3 handleKeyWebEvent:v34];

      contextCopy = val;
      [val returnExecutionToParentWithInfo:MEMORY[0x1E695E118]];
    }

    modifiersCopy = v43;

    stringCopy = v44;
  }
}

- (void)_handleWebKeyEvent:(id)event withIndex:(unint64_t)index inInputString:(id)string
{
  eventCopy = event;
  stringCopy = string;
  if (qword_1ED49D4F8 != -1)
  {
    dispatch_once(&qword_1ED49D4F8, &__block_literal_global_1822);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v14[0] = MEMORY[0x1E69E9820];
  v14[1] = 3221225472;
  v14[2] = __70___UIKeyboardStateManager__handleWebKeyEvent_withIndex_inInputString___block_invoke_3;
  v14[3] = &unk_1E70FD8D8;
  v14[4] = self;
  v15 = eventCopy;
  v16 = stringCopy;
  indexCopy = index;
  v11 = qword_1ED49D4F0;
  v12 = stringCopy;
  v13 = eventCopy;
  [taskQueue addTask:v14 breadcrumb:v11];
}

- (void)_handleWebKeyEvent:(id)event withIndex:(unint64_t)index inInputString:(id)string executionContext:(id)context
{
  eventCopy = event;
  stringCopy = string;
  contextCopy = context;
  if ([(__CFString *)stringCopy length]<= index)
  {
    [contextCopy returnExecutionToParent];
  }

  else
  {
    if (+[UIKeyboard isKeyboardProcess])
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      delegateAdoptsWebTextInputPrivate = [inputDelegateManager delegateAdoptsWebTextInputPrivate];

      if (delegateAdoptsWebTextInputPrivate)
      {
        [(_UIKeyboardStateManager *)self updateChangeTimeAndIncrementCount];
      }

      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      inputSystemSourceSession = [inputDelegateManager2 inputSystemSourceSession];

      if (inputSystemSourceSession)
      {
        textOperations = [inputSystemSourceSession textOperations];
        dictionary = [MEMORY[0x1E695DF90] dictionary];
        [dictionary setObject:@"_handleWebKeyEvent:withIndex:inInputString:" forKeyedSubscript:@"selector"];
        [dictionary setObject:eventCopy forKeyedSubscript:@"event"];
        v19 = [MEMORY[0x1E696AD98] numberWithUnsignedInteger:index];
        [dictionary setObject:v19 forKeyedSubscript:@"index"];

        if (stringCopy)
        {
          v20 = stringCopy;
        }

        else
        {
          v20 = &stru_1EFB14550;
        }

        [dictionary setObject:v20 forKeyedSubscript:@"inputString"];
        [textOperations setCustomInfoType:0x1EFB7CA50];
        [textOperations setCustomInfo:dictionary];
        [inputSystemSourceSession flushOperations];
      }

      [contextCopy returnExecutionToParent];
    }

    else
    {
      [(_UIKeyboardStateManager *)self setExternalTask:0];
      [(_UIKeyboardStateManager *)self setEventForCurrentWebEvent:eventCopy];
      *&self->m_webEventWasHandledAsKeyCommand = 0;
      v21 = [(__CFString *)stringCopy rangeOfComposedCharacterSequenceAtIndex:index];
      v22 = [(__CFString *)stringCopy length];
      if (v22)
      {
        v47 = stringCopy;
        _shiftModifiedInput = [eventCopy _shiftModifiedInput];
        v24 = _shiftModifiedInput;
        if (_shiftModifiedInput)
        {
          _unmodifiedInput = _shiftModifiedInput;
        }

        else
        {
          _unmodifiedInput = [eventCopy _unmodifiedInput];
        }

        v46 = _unmodifiedInput;
      }

      else
      {
        v47 = [(__CFString *)stringCopy substringWithRange:v21, 0];
        v46 = [(__CFString *)v47 copy];
      }

      _hidEvent = [eventCopy _hidEvent];
      aBlock[0] = MEMORY[0x1E69E9820];
      aBlock[1] = 3221225472;
      aBlock[2] = __87___UIKeyboardStateManager__handleWebKeyEvent_withIndex_inInputString_executionContext___block_invoke;
      aBlock[3] = &unk_1E70FD900;
      aBlock[4] = self;
      v27 = eventCopy;
      v63 = v27;
      v65 = v21;
      v66 = v22;
      v64 = stringCopy;
      v28 = _Block_copy(aBlock);
      v61[0] = MEMORY[0x1E69E9820];
      v61[1] = 3221225472;
      v61[2] = __87___UIKeyboardStateManager__handleWebKeyEvent_withIndex_inInputString_executionContext___block_invoke_2;
      v61[3] = &unk_1E70FE000;
      v61[4] = self;
      v29 = _Block_copy(v61);
      v59[0] = MEMORY[0x1E69E9820];
      v59[1] = 3221225472;
      v59[2] = __87___UIKeyboardStateManager__handleWebKeyEvent_withIndex_inInputString_executionContext___block_invoke_3;
      v59[3] = &unk_1E70FE028;
      v60 = _hidEvent != 0;
      v59[4] = self;
      v30 = _Block_copy(v59);
      if (_hidEvent)
      {
        if ([v27 _isKeyDown])
        {
          v31 = 4;
        }

        else
        {
          v31 = 5;
        }

        self->m_webEventIsKeyDown = [v27 _isKeyDown];
        v55[0] = MEMORY[0x1E69E9820];
        v55[1] = 3221225472;
        v55[2] = __87___UIKeyboardStateManager__handleWebKeyEvent_withIndex_inInputString_executionContext___block_invoke_4;
        v55[3] = &unk_1E70FE078;
        v55[4] = self;
        v56 = v29;
        v57 = v30;
        v58 = v28;
        v32 = v30;
        v33 = [contextCopy childWithContinuation:v55];
        selfCopy = self;
        v35 = v31;
        v36 = v46;
        inputSystemSourceSession = v47;
        [(_UIKeyboardStateManager *)selfCopy _handleWebKeyEvent:v27 withEventType:v35 withInputString:v47 withInputStringIgnoringModifiers:v46 executionContext:v33];

        v37 = v56;
      }

      else
      {
        self->m_webEventIsKeyDown = 1;
        v48[0] = MEMORY[0x1E69E9820];
        v48[1] = 3221225472;
        v48[2] = __87___UIKeyboardStateManager__handleWebKeyEvent_withIndex_inInputString_executionContext___block_invoke_8;
        v48[3] = &unk_1E70FE0A0;
        v48[4] = self;
        v45 = v27;
        v49 = v45;
        v44 = v47;
        v50 = v44;
        v36 = v46;
        v38 = v46;
        v51 = v38;
        v52 = v29;
        v53 = v30;
        v54 = v28;
        v39 = v30;
        [contextCopy childWithContinuation:v48];
        v40 = v29;
        v42 = v41 = v28;
        selfCopy2 = self;
        inputSystemSourceSession = v47;
        [(_UIKeyboardStateManager *)selfCopy2 _handleWebKeyEvent:v45 withEventType:4 withInputString:v44 withInputStringIgnoringModifiers:v38 executionContext:v42];

        v28 = v41;
        v29 = v40;

        v37 = v49;
      }
    }
  }
}

- (void)triggerPendingKeyup
{
  if (self->_pendingKeyupOperation)
  {
    if (qword_1ED49D548 != -1)
    {
      dispatch_once(&qword_1ED49D548, &__block_literal_global_1853);
    }

    taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
    operation = [(_UIKeyboardImplHeldOperation *)self->_pendingKeyupOperation operation];
    [taskQueue addDeferredTask:operation breadcrumb:qword_1ED49D540];

    pendingKeyupOperation = self->_pendingKeyupOperation;
    self->_pendingKeyupOperation = 0;
  }
}

- (void)_handleWebKeyEvent:(id)event withInputString:(id)string executionContext:(id)context
{
  eventCopy = event;
  stringCopy = string;
  contextCopy = context;
  if ([stringCopy length] >= 2 && objc_msgSend(stringCopy, "characterAtIndex:", 0) == 46)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    privateInputDelegate = [inputDelegateManager privateInputDelegate];
    if (privateInputDelegate)
    {
      v12 = privateInputDelegate;
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      _characterBeforeCaretSelection = [inputDelegateManager2 _characterBeforeCaretSelection];

      if (_characterBeforeCaretSelection != 46)
      {
        goto LABEL_7;
      }

      [stringCopy substringFromIndex:1];
      stringCopy = inputDelegateManager = stringCopy;
    }
  }

LABEL_7:
  [(_UIKeyboardStateManager *)self _handleWebKeyEvent:eventCopy withIndex:0 inInputString:stringCopy executionContext:contextCopy];
}

- (void)_remapKeyEvent:(id)event withKeyEventMap:(id)map
{
  eventCopy = event;
  mapCopy = map;
  LODWORD(map) = [eventCopy _gsModifierFlags];
  _modifiedInput = [eventCopy _modifiedInput];
  _unmodifiedInput = [eventCopy _unmodifiedInput];
  v9 = [mapCopy remapKeyWithString:_modifiedInput stringWithoutModifiers:_unmodifiedInput modifierFlags:map keyboardState:self->m_keyboardState];

  if (v9)
  {
    _modifiedInput2 = [eventCopy _modifiedInput];
    v11 = [_modifiedInput2 isEqualToString:v9];

    if ((v11 & 1) == 0)
    {
      [eventCopy set_modifiedInput:v9];
    }
  }
}

- (void)_handleKeyEvent:(id)event executionContext:(id)context
{
  eventCopy = event;
  contextCopy = context;
  [(_UIKeyboardStateManager *)self setExternalTask:0];
  kdebug_trace();
  v8 = kac_get_log();
  v9 = os_signpost_id_make_with_pointer(v8, eventCopy);
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v10 = v9;
    if (os_signpost_enabled(v8))
    {
      *buf = 0;
      _os_signpost_emit_with_name_impl(&dword_188A29000, v8, OS_SIGNPOST_INTERVAL_BEGIN, v10, "appKey", "", buf, 2u);
    }
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained allowResponderChainFirstChanceToHandleKeyEvent:eventCopy];

  kdebug_trace();
  v12 = kac_get_log();
  v13 = os_signpost_id_make_with_pointer(v12, eventCopy);
  if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v14 = v13;
    if (os_signpost_enabled(v12))
    {
      *buf = 0;
      _os_signpost_emit_with_name_impl(&dword_188A29000, v12, OS_SIGNPOST_INTERVAL_END, v14, "appKey", "", buf, 2u);
    }
  }

  externalTask = [(_UIKeyboardStateManager *)self externalTask];

  if (externalTask)
  {
    externalTask2 = [(_UIKeyboardStateManager *)self externalTask];
    [(_UIKeyboardStateManager *)self setExternalTask:0];
    v18[0] = MEMORY[0x1E69E9820];
    v18[1] = 3221225472;
    v18[2] = __60___UIKeyboardStateManager__handleKeyEvent_executionContext___block_invoke;
    v18[3] = &unk_1E70FD058;
    v18[4] = self;
    v17 = [contextCopy childWithContinuation:v18];
    (externalTask2)[2](externalTask2, v17);
  }

  else
  {
    [(_UIKeyboardStateManager *)self flushTouchEventWaitingForKeyInputEventIfNecessary];
    [contextCopy returnExecutionToParent];
  }
}

- (void)handleKeyEvent:(id)event
{
  v21 = *MEMORY[0x1E69E9840];
  eventCopy = event;
  _cloneEvent = eventCopy;
  if ([eventCopy _hidEvent])
  {
    _cloneEvent = [eventCopy _cloneEvent];
  }

  v6 = _UIKeyboardLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 134218240;
    type = [eventCopy type];
    v19 = 2048;
    subtype = [eventCopy subtype];
    _os_log_impl(&dword_188A29000, v6, OS_LOG_TYPE_DEFAULT, "Keyboard receives keyEvent type: %li; subtype: %li", buf, 0x16u);
  }

  if (![_cloneEvent _hidEvent] || objc_msgSend(_cloneEvent, "_modifierFlags") != 0x40000 || objc_msgSend(_cloneEvent, "_keyCode") != 40)
  {
    v11 = MEMORY[0x1E69E9820];
    v12 = 3221225472;
    v13 = __42___UIKeyboardStateManager_handleKeyEvent___block_invoke;
    v14 = &unk_1E70FD1B8;
    selfCopy = self;
    v16 = _cloneEvent;
    v7 = _Block_copy(&v11);
    v8 = [(_UIKeyboardStateManager *)self taskQueue:v11];
    isMainThreadExecutingTask = [v8 isMainThreadExecutingTask];

    if (isMainThreadExecutingTask)
    {
      [(_UIKeyboardStateManager *)self setExternalTask:v7];
    }

    else
    {
      if (qword_1ED49D558 != -1)
      {
        dispatch_once(&qword_1ED49D558, &__block_literal_global_1857);
      }

      taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
      [taskQueue addTask:v7 breadcrumb:qword_1ED49D550];
    }
  }
}

- (unint64_t)_handleKeyCommandCommon:(id)common options:(unint64_t)options
{
  v10 = 0;
  commonCopy = common;
  _hidEvent = [commonCopy _hidEvent];
  v8 = [(_UIKeyboardStateManager *)self handleKeyCommand:commonCopy repeatOkay:&v10 options:options];

  result = 0;
  if (_hidEvent && v8)
  {
    if ((options & 2) == 0 && (v10 & 1) == 0)
    {
      [(_UIKeyboardStateManager *)self cancelAllKeyEvents];
    }

    return v8;
  }

  return result;
}

- (BOOL)_shouldEmitString:(id)string forKeyEvent:(id)event
{
  stringCopy = string;
  if ([event _inputFlags] & 0x10) != 0 && (-[TIKeyboardInputManagerState ignoresDeadKeys](self->m_inputManagerState, "ignoresDeadKeys") & 1) != 0 || (WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate), v8 = objc_msgSend(WeakRetained, "returnKeyState"), WeakRetained, v8 == 1) && (objc_msgSend(stringCopy, "_isNewlineOrReturn"))
  {
    v9 = 0;
  }

  else
  {
    inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
    keyboardBehaviors = [inputManagerState keyboardBehaviors];
    _keyboardBehaviorState = [(_UIKeyboardStateManager *)self _keyboardBehaviorState];
    v13 = [keyboardBehaviors keyBehaviorsForState:_keyboardBehaviorState];

    v9 = !v13 || ([v13 tabKeyBehavior] == 1 || (objc_msgSend(stringCopy, "isEqualToString:", @"\t") & 1) == 0) && ((objc_msgSend(v13, "spaceKeyBehavior") - 3) > 1 || (objc_msgSend(stringCopy, "isEqualToString:", @" ") & 1) == 0);
  }

  return v9;
}

- (void)handleKeyEvent:(id)event executionContext:(id)context
{
  eventCopy = event;
  contextCopy = context;
  [eventCopy _privatize];
  if (-[_UIKeyboardStateManager shouldApplyKeyboardCommandToUIHost](self, "shouldApplyKeyboardCommandToUIHost") || (v9 = 0x1E70E9000uLL, +[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI")) && ([eventCopy _inputFlags] & 0x80) != 0)
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardKeyboardEventToUIHost:eventCopy];

    [contextCopy returnExecutionToParent];
  }

  else
  {
    if (([eventCopy _inputFlags] & 0x20) == 0)
    {
      [(_UIKeyboardStateManager *)self updateKeyboardEventsLagging:eventCopy];
      _hidEvent = [eventCopy _hidEvent];
      WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
      isEmojiPopoverPresented = [WeakRetained isEmojiPopoverPresented];

      _isFromEmojiPopover = [eventCopy _isFromEmojiPopover];
      v14 = +[UIKeyboardInputModeController sharedInputModeController];
      currentInputMode = [v14 currentInputMode];
      isExtensionInputMode = [currentInputMode isExtensionInputMode];

      if (self->m_hardwareKeyboardAttached)
      {
        if (_hidEvent && [(_UIKeyboardStateManager *)self exclusivityIdentifierMatched])
        {
          v17 = 1;
        }

        else
        {
          v17 = isEmojiPopoverPresented | _isFromEmojiPopover;
        }
      }

      else
      {
        v17 = 0;
      }

      [(_UIKeyboardStateManager *)self setInHardwareKeyboardMode:v17 & 1];
      if (self->m_hardwareKeyboardAttached && _hidEvent)
      {
        v18 = objc_loadWeakRetained(&self->_presentationDelegate);
        [v18 setHardwareKeyboardIsSeen];

        if ((isExtensionInputMode & 1) == 0)
        {
          [(_UIKeyboardStateManager *)self setAutomaticMinimizationEnabled:1];
          v19 = objc_loadWeakRetained(&self->_presentationDelegate);
          geometryDelegate = [v19 geometryDelegate];
          isMinimized = [geometryDelegate isMinimized];

          if ((isMinimized & 1) == 0)
          {
            [(_UIKeyboardStateManager *)self toggleSoftwareKeyboard];
          }

          v22 = objc_loadWeakRetained(&self->_presentationDelegate);
          [v22 dismissFloatingKeyboardFromPencilKitIfNeeded];
        }

        v23 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
        [v23 updateSystemInputAssistantVisibilityAfterHardwareKeyEvent];
        if ([(_UIKeyboardStateManager *)self isCapsLockASCIIToggle])
        {
          updateCapsLockDelayOverrideForNonTyping = [(_UIKeyboardStateManager *)self updateCapsLockDelayOverrideForNonTyping];
          scheduled = [updateCapsLockDelayOverrideForNonTyping scheduled];

          if (scheduled)
          {
            m_updateCapsLockDelayOverrideForNonTyping = [(_UIKeyboardStateManager *)self updateCapsLockDelayOverrideForNonTyping];
            [m_updateCapsLockDelayOverrideForNonTyping touch];
          }

          else
          {
            [(_UIKeyboardStateManager *)self adjustCapsLockDelayOverride];
            [(_UIKeyboardStateManager *)self clearCapsLockDelayOverrideTimer];
            v27 = [[UIDelayedAction alloc] initWithTarget:self action:sel_removeCapsLockDelayOverride userInfo:0 delay:0.15];
            m_updateCapsLockDelayOverrideForNonTyping = self->m_updateCapsLockDelayOverrideForNonTyping;
            self->m_updateCapsLockDelayOverrideForNonTyping = v27;
          }
        }
      }

      else if (!_hidEvent)
      {
        goto LABEL_36;
      }

      if ([eventCopy _isKeyDown])
      {
        if ([eventCopy _isARepeat])
        {
          _modifiedInput = [eventCopy _modifiedInput];
          _isDelete = [_modifiedInput _isDelete];

          if (_isDelete)
          {
            self->m_repeatDeleteFromHardwareKeyboard = 1;
            self->m_autoDeleteCount = 0;
          }
        }
      }

      if ([eventCopy _isKeyDown] && objc_msgSend(eventCopy, "_isARepeat"))
      {
        inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
        if (!inputDelegate || [(_UIKeyboardStateManager *)self _hasMarkedText])
        {
LABEL_35:

          goto LABEL_36;
        }

        v41 = [(_UIKeyboardStateManager *)self canPresentPressAndHoldPopover:eventCopy];

        if (v41)
        {
          documentState = [(_UIKeyboardStateManager *)self documentState];
          inputDelegate = [documentState contextBeforeInput];

          if ([inputDelegate length])
          {
            v43 = [inputDelegate rangeOfComposedCharacterSequenceAtIndex:{objc_msgSend(inputDelegate, "length") - 1}];
            v45 = [inputDelegate substringWithRange:{v43, v44}];
            if ([UIPressAndHoldPopoverController canPresentPressAndHoldPopoverForKeyString:v45])
            {
              v46 = objc_loadWeakRetained(&self->_presentationDelegate);
              [v46 presentPressAndHoldPopoverWithKeyString:v45];
            }

            [contextCopy returnExecutionToParent];

            goto LABEL_112;
          }

          goto LABEL_35;
        }
      }

LABEL_36:
      inputDelegate = +[UIInputSwitcher activeInstance];
      if (_hidEvent)
      {
        if (([eventCopy _isARepeat] & 1) == 0)
        {
          _isKeyDown = [eventCopy _isKeyDown];
          m_hardwareKeyDownCodeToEventMap = self->m_hardwareKeyDownCodeToEventMap;
          v33 = [MEMORY[0x1E696AD98] numberWithLong:{objc_msgSend(eventCopy, "_keyCode")}];
          if (_isKeyDown)
          {
            [(NSMutableDictionary *)m_hardwareKeyDownCodeToEventMap setObject:eventCopy forKey:v33];
          }

          else
          {
            v34 = [(NSMutableDictionary *)m_hardwareKeyDownCodeToEventMap objectForKey:v33];

            if (v34)
            {
              v35 = self->m_hardwareKeyDownCodeToEventMap;
              v36 = [MEMORY[0x1E696AD98] numberWithLong:{objc_msgSend(eventCopy, "_keyCode")}];
              [(NSMutableDictionary *)v35 removeObjectForKey:v36];

              if (self->m_repeatDeleteFromHardwareKeyboard)
              {
                [(_UIKeyboardStateManager *)self stopAutoDelete];
              }

              if ([(_UIKeyboardStateManager *)self _delegateRequiresKeyEvents])
              {
                _cloneEvent = [eventCopy _cloneEvent];
                _modifiedInput2 = [v34 _modifiedInput];
                [_cloneEvent set_modifiedInput:_modifiedInput2];

                _unmodifiedInput = [v34 _unmodifiedInput];
                [_cloneEvent set_unmodifiedInput:_unmodifiedInput];

                _modifiedInput3 = [_cloneEvent _modifiedInput];
                [(_UIKeyboardStateManager *)self _handleWebKeyEvent:_cloneEvent withInputString:_modifiedInput3 executionContext:contextCopy];

LABEL_112:
                goto LABEL_113;
              }

              v33 = v34;
            }

            else
            {
              v33 = 0;
            }
          }
        }

        updatedKeyBehaviors = [(_UIKeyboardStateManager *)self updatedKeyBehaviors];
        if (![eventCopy _isKeyDown])
        {
          goto LABEL_110;
        }

        _modifiedInput4 = [eventCopy _modifiedInput];
        if ([_modifiedInput4 _isPlainSpace] && objc_msgSend(updatedKeyBehaviors, "spaceKeyBehavior") == 8)
        {

          goto LABEL_110;
        }

        _modifiedInput5 = [eventCopy _modifiedInput];
        if ([_modifiedInput5 _isNewlineOrReturn])
        {
          v50 = inputDelegate;
          v51 = isEmojiPopoverPresented;
          returnKeyBehavior = [updatedKeyBehaviors returnKeyBehavior];

          v53 = returnKeyBehavior == 8;
          isEmojiPopoverPresented = v51;
          inputDelegate = v50;
          v9 = 0x1E70E9000;
          if (v53)
          {
            goto LABEL_110;
          }
        }

        else
        {
        }
      }

      v54 = [UIApp _hardwareKeyboardForPhysicalKeyboardEvent:eventCopy createIfNeeded:0];
      v55 = v54;
      if (v54)
      {
        CFRetain(v54);
        v56 = (GSKeyboardGetModifierState() & 0x220000) == 0;
      }

      else
      {
        v56 = 1;
      }

      [inputDelegate hideSwitcherIfNeeded];
      v57 = [UIApp _hardwareKeyboardForPhysicalKeyboardEvent:eventCopy createIfNeeded:0];
      if (_hidEvent)
      {
        v58 = v57;
        if (v55 != v57)
        {
          if (!v56)
          {
            v97 = 0;
            v90 = 0;
            v91 = 7;
            v88 = 0;
            v89 = &v97;
            v86 = 0;
            v87 = &v97;
            v85 = &v97;
            GSKeyboardTranslateKeyExtendedCommandWithUsagePage();
          }

          [eventCopy _setHIDEvent:objc_msgSend(eventCopy keyboard:{"_hidEvent", v85, v86, v87, v88, v89, v90, v91), v58}];
        }
      }

      if (v55)
      {
        CFRelease(v55);
      }

      if ([*(v9 + 3824) isRedesignedTextCursorEnabled] && objc_msgSend(eventCopy, "_keyCode") != 57 && (objc_msgSend(eventCopy, "_isGlobeKey") & 1) == 0)
      {
        inputModeIndicatorController = [(_UIKeyboardStateManager *)self inputModeIndicatorController];
        [inputModeIndicatorController keyPressed];

        m_showCursorAccessory = self->m_showCursorAccessory;
        if (!m_showCursorAccessory)
        {
          v61 = [[UIDelayedAction alloc] initWithTarget:self action:sel_showCursorAccessory userInfo:0 delay:0.5];
          v62 = self->m_showCursorAccessory;
          self->m_showCursorAccessory = v61;

          m_showCursorAccessory = self->m_showCursorAccessory;
        }

        [(UIDelayedAction *)m_showCursorAccessory touch];
        if (!self->m_hideCursorAccessoriesAssertion)
        {
          textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
          _selectionViewManager = [textInteractionAssistant _selectionViewManager];
          v65 = [_selectionViewManager _obtainHideCursorAccessoriesAssertionWithReason:@"key press"];
          m_hideCursorAccessoriesAssertion = self->m_hideCursorAccessoriesAssertion;
          self->m_hideCursorAccessoriesAssertion = v65;
        }
      }

      inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
      keyEventMap = [inputManagerState keyEventMap];

      if (keyEventMap)
      {
        inputManagerState2 = [(_UIKeyboardStateManager *)self inputManagerState];
        keyEventMap2 = [inputManagerState2 keyEventMap];
        [(_UIKeyboardStateManager *)self _remapKeyEvent:eventCopy withKeyEventMap:keyEventMap2];
      }

      updatedKeyBehaviors = [eventCopy _modifiedInput];
      v71 = [(_UIKeyboardStateManager *)self _shouldEmitString:updatedKeyBehaviors forKeyEvent:eventCopy];
      if (v71)
      {
        if ([updatedKeyBehaviors length])
        {
          if ([(_UIKeyboardStateManager *)self _isValidKeyInput:updatedKeyBehaviors])
          {
            if ([(_UIKeyboardStateManager *)self delayedCandidateList])
            {
              if (self->m_candidateList)
              {
                if (![(_UIKeyboardStateManager *)self isPredictionViewControllerVisible])
                {
                  v92 = objc_loadWeakRetained(&self->_presentationDelegate);
                  [v92 candidateController];
                  v72 = inputDelegate;
                  v74 = v73 = isEmojiPopoverPresented;
                  inlineCandidateView = [v74 inlineCandidateView];

                  isEmojiPopoverPresented = v73;
                  inputDelegate = v72;

                  if (inlineCandidateView)
                  {
                    [(_UIKeyboardStateManager *)self removeCandidateList];
                  }
                }
              }
            }
          }
        }
      }

      if (isEmojiPopoverPresented && [eventCopy _isKeyDown])
      {
        v76 = objc_loadWeakRetained(&self->_presentationDelegate);
        emojiPopoverController = [v76 emojiPopoverController];
        v78 = [emojiPopoverController handleHardwareKeyboardEvent:eventCopy];

        v71 = v78 ^ 1;
        if ((v78 & 1) != 0 || _hidEvent)
        {
          goto LABEL_95;
        }

        v79 = objc_loadWeakRetained(&self->_presentationDelegate);
        emojiPopoverController2 = [v79 emojiPopoverController];
        [v79 dismissKeyboardPopover:emojiPopoverController2 beforeCleanup:0 completion:0];
      }

      LOBYTE(v78) = 0;
LABEL_95:
      if (!-[_UIKeyboardStateManager _delegateRequiresKeyEvents](self, "_delegateRequiresKeyEvents") || ([eventCopy _isGlobeKey] & 1) != 0 || ((v71 ^ 1) & 1) != 0)
      {
        if ((v78 & 1) == 0 && [(_UIKeyboardStateManager *)self _handleKeyCommand:eventCopy])
        {
          goto LABEL_110;
        }

        inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
        keyInputDelegate = [inputDelegateManager keyInputDelegate];

        if (!keyInputDelegate || !v71 || [updatedKeyBehaviors length] && !-[_UIKeyboardStateManager _isValidKeyInput:](self, "_isValidKeyInput:", updatedKeyBehaviors))
        {
          goto LABEL_110;
        }

        if ([updatedKeyBehaviors length])
        {
          v93[0] = MEMORY[0x1E69E9820];
          v93[1] = 3221225472;
          v93[2] = __59___UIKeyboardStateManager_handleKeyEvent_executionContext___block_invoke;
          v93[3] = &unk_1E70F6B40;
          v93[4] = self;
          v94 = updatedKeyBehaviors;
          v95 = eventCopy;
          v96 = contextCopy;
          -[_UIKeyboardStateManager performOperations:withTextInputSource:](self, "performOperations:withTextInputSource:", v93, [v95 source]);

LABEL_111:
          goto LABEL_112;
        }
      }

      else
      {
        [inputDelegate hideSwitcherIfNeeded];
        if ([updatedKeyBehaviors length])
        {
          [(_UIKeyboardStateManager *)self _handleWebKeyEvent:eventCopy withInputString:updatedKeyBehaviors executionContext:contextCopy];
          if (([eventCopy _modifierFlags] & 0x100000) != 0)
          {
            v81 = self->m_hardwareKeyDownCodeToEventMap;
            v82 = [MEMORY[0x1E696AD98] numberWithLong:{objc_msgSend(eventCopy, "_keyCode")}];
            [(NSMutableDictionary *)v81 removeObjectForKey:v82];
          }

          goto LABEL_111;
        }
      }

      [(_UIKeyboardStateManager *)self completeHandleKeyEvent:eventCopy];
LABEL_110:
      [contextCopy returnExecutionToParent];
      goto LABEL_111;
    }

    [(_UIKeyboardStateManager *)self handleModifiersChangeForKeyEvent:eventCopy executionContext:contextCopy];
  }

LABEL_113:
}

- (void)handleModifiersChangeForKeyEvent:(id)event executionContext:(id)context
{
  eventCopy = event;
  contextCopy = context;
  if ([eventCopy _hidEvent] && (objc_msgSend(eventCopy, "_modifierFlags") & 0x20000) != 0 && self->m_autoshift)
  {
    self->m_autoshift = 0;
    [(_UIKeyboardStateManager *)self _forwardNeededShiftStatesToDestination];
  }

  [(_UIKeyboardStateManager *)self showCursorAccessory];
  v7 = +[UIInputSwitcher sharedInstance];
  [v7 handleModifiersChangedEvent:eventCopy];

  _keyCode = [eventCopy _keyCode];
  if (-[_UIKeyboardStateManager shouldShowKeyboardMenu](self, "shouldShowKeyboardMenu") && _keyCode == 57 && [eventCopy _hidEvent] && -[_UIKeyboardStateManager isCapsLockSwitchEnabled](self, "isCapsLockSwitchEnabled") && objc_msgSend(eventCopy, "_isKeyDown"))
  {
    v9 = +[UIKeyboardInputModeController sharedInputModeController];
    v10 = [v9 inputModeForASCIIToggleWithTraits:self->m_traits];

    if (v10)
    {
      v11 = +[UIKeyboardInputModeController sharedInputModeController];
      activeInputModes = [v11 activeInputModes];
      v13 = [activeInputModes containsObject:v10];

      if (v13)
      {
        [(_UIKeyboardStateManager *)self showCursorAccessory];
        identifier = [v10 identifier];
        v15 = [(_UIKeyboardStateManager *)self switchMode:identifier withHUD:1 withDelay:1 fromCapsLock:1];

        if (!v15)
        {
          goto LABEL_15;
        }

        v16 = UIApp;
        v10 = +[UIKeyboardInputModeController sharedInputModeController];
        hardwareInputMode = [v10 hardwareInputMode];
        automaticHardwareLayout = [hardwareInputMode automaticHardwareLayout];
        [v16 setHardwareKeyboardLayoutName:automaticHardwareLayout];
      }
    }
  }

LABEL_15:
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained setCapsLockIfNeededForPhysicalKeyboardEvent:eventCopy];

  if ([eventCopy _isKeyDown])
  {
    v20 = 4;
  }

  else
  {
    v20 = 5;
  }

  _unmodifiedInput = [eventCopy _unmodifiedInput];
  _modifiedInput = [eventCopy _modifiedInput];
  [(_UIKeyboardStateManager *)self _handleWebKeyEvent:eventCopy withEventType:v20 withInputString:_unmodifiedInput withInputStringIgnoringModifiers:_modifiedInput executionContext:contextCopy];
}

- (void)cancelDictationOnSendReturnKeyPressed
{
  if ([(UITextInputTraits *)self->m_traits returnKeyType]== 7 && +[UIDictationController isRunning])
  {
    v2 = +[UIDictationController sharedInstance];
    [v2 cancelDictation];
  }
}

- (void)handleKeyWithString:(id)string forKeyEvent:(id)event executionContext:(id)context
{
  stringCopy = string;
  eventCopy = event;
  contextCopy = context;
  _inputFlags = [eventCopy _inputFlags];
  v12 = _inputFlags;
  v13 = _inputFlags & 0x18;
  v14 = v13 != 0;
  if ([stringCopy length] >= 2)
  {
    v15 = [stringCopy substringFromIndex:{objc_msgSend(stringCopy, "length") - 1}];
    _isDelete = [v15 _isDelete];

    if ((_isDelete & 1) == 0)
    {
      goto LABEL_3;
    }

LABEL_7:
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    [WeakRetained playDeleteKeyFeedbackIfNecessaryRepeat:0 rapid:0 deleteCount:1];

    v36[0] = MEMORY[0x1E69E9820];
    v36[1] = 3221225472;
    v36[2] = __76___UIKeyboardStateManager_handleKeyWithString_forKeyEvent_executionContext___block_invoke;
    v36[3] = &unk_1E70FD1B8;
    v36[4] = self;
    v37 = eventCopy;
    v20 = [contextCopy childWithContinuation:v36];
    [(_UIKeyboardStateManager *)self handleDeleteAsRepeat:0 executionContext:v20];

    v21 = v37;
LABEL_19:

    goto LABEL_20;
  }

  if ([stringCopy _isDelete])
  {
    goto LABEL_7;
  }

LABEL_3:
  if (![stringCopy _isNewlineOrReturn])
  {
    shouldSkipCandidateSelection = [(_UIKeyboardStateManager *)self shouldSkipCandidateSelection];
    self->m_originalShouldSkipCandidateSelection = shouldSkipCandidateSelection;
    if ((v13 != 0) == shouldSkipCandidateSelection || [(_UIKeyboardStateManager *)self isInHardwareKeyboardMode])
    {
      textInputTraits = [(_UIKeyboardStateManager *)self textInputTraits];
      keyboardType = [textInputTraits keyboardType];
      if ((keyboardType > 0xB || ((1 << keyboardType) & 0x930) == 0) && keyboardType != 127)
      {

        goto LABEL_15;
      }

      v14 = 1;
    }

    [(_UIKeyboardStateManager *)self setShouldSkipCandidateSelection:v14];
LABEL_15:
    if (+[UIKeyboard usesInputSystemUI])
    {
      [(_UIKeyboardStateManager *)self updateShiftState];
    }

    _hint = [eventCopy _hint];
    v28 = MEMORY[0x1E69E9820];
    v29 = 3221225472;
    v30 = __76___UIKeyboardStateManager_handleKeyWithString_forKeyEvent_executionContext___block_invoke_3;
    v31 = &unk_1E70FD1B8;
    selfCopy = self;
    v33 = eventCopy;
    v26 = [contextCopy childWithContinuation:&v28];
    [(_UIKeyboardStateManager *)self handleStringInput:stringCopy withFlags:v12 withInputManagerHint:_hint executionContext:v26, v28, v29, v30, v31, selfCopy];

    v21 = v33;
    goto LABEL_19;
  }

  [(_UIKeyboardStateManager *)self cancelDictationOnSendReturnKeyPressed];
  if (![(UITextInputTraits *)self->m_traits returnKeyGoesToNextResponder])
  {
    v34[0] = MEMORY[0x1E69E9820];
    v34[1] = 3221225472;
    v34[2] = __76___UIKeyboardStateManager_handleKeyWithString_forKeyEvent_executionContext___block_invoke_2;
    v34[3] = &unk_1E70FD1B8;
    v34[4] = self;
    v35 = eventCopy;
    v27 = [contextCopy childWithContinuation:v34];
    [(_UIKeyboardStateManager *)self handleStringInput:@"\n" withFlags:v12 withInputManagerHint:0 executionContext:v27];

    v21 = v35;
    goto LABEL_19;
  }

  delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];
  _nextKeyResponder = [delegateAsResponder _nextKeyResponder];
  [_nextKeyResponder becomeFirstResponder];

  [(_UIKeyboardStateManager *)self completeHandleKeyEvent:eventCopy];
  [contextCopy returnExecutionToParent];
LABEL_20:
}

- (void)completeHandleKeyEvent:(id)event
{
  _markedInput = [event _markedInput];
  if ([_markedInput length])
  {
    self->m_textInputChangesIgnored = 1;
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager _setMarkedText:_markedInput selectedRange:{objc_msgSend(_markedInput, "length"), 0}];

    documentState = [(_UIKeyboardStateManager *)self documentState];
    v6 = [documentState documentStateAfterSettingMarkedText:_markedInput selectedRange:{objc_msgSend(_markedInput, "length"), 0}];
    [(_UIKeyboardStateManager *)self setDocumentState:v6];

    [(TIKeyboardState *)self->m_keyboardState setInputForMarkedText:_markedInput];
    self->m_textInputChangesIgnored = 0;
    [(_UIKeyboardStateManager *)self updateChangeTimeAndIncrementCount];
    [(_UIKeyboardStateManager *)self setShiftOffIfNeeded];
  }

  self->m_textInputChangingCount = 0;
  *&self->m_textInputChangesIgnored = 0;
  self->m_textInputChangingDirection = 0;
}

- (BOOL)shouldDeferEventHandlingToSystemForTextInput:(id)input context:(id)context
{
  _uikitKeyEventContext = [context _uikitKeyEventContext];
  LOBYTE(self) = [(_UIKeyboardStateManager *)self deferEventHandlingToSystemWithContext:_uikitKeyEventContext];

  return self;
}

- (BOOL)deferEventHandlingToSystemWithContext:(id)context
{
  contextCopy = context;
  keyEvent = [contextCopy keyEvent];
  if (![contextCopy shouldEvaluateForInputSystemHandling])
  {
    if (([contextCopy documentIsEditable] & 1) == 0 && objc_msgSend(keyEvent, "keyCode") == 43)
    {
      v8 = _UIKeyboardImplLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *v20 = 0;
        v9 = "deferEventHandlingToSystemWithContext, handled tab";
LABEL_41:
        _os_log_debug_impl(&dword_188A29000, v8, OS_LOG_TYPE_DEBUG, v9, v20, 2u);
        goto LABEL_42;
      }

      goto LABEL_42;
    }

    if (([contextCopy shouldInsertChar] & 1) == 0 && -[_UIKeyboardStateManager handleKeyTextCommandForCurrentEvent](self, "handleKeyTextCommandForCurrentEvent"))
    {
      v10 = _UIKeyboardImplLog();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *v20 = 0;
        v11 = "deferEventHandlingToSystemWithContext, handleKeyTextCommandForCurrentEvent";
LABEL_45:
        _os_log_debug_impl(&dword_188A29000, v10, OS_LOG_TYPE_DEBUG, v11, v20, 2u);
        goto LABEL_16;
      }

      goto LABEL_16;
    }

    if ([contextCopy shouldInsertChar] && -[_UIKeyboardStateManager handleKeyAppCommandForCurrentEvent](self, "handleKeyAppCommandForCurrentEvent"))
    {
      v10 = _UIKeyboardImplLog();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *v20 = 0;
        v11 = "deferEventHandlingToSystemWithContext, handleKeyAppCommandForCurrentEvent";
        goto LABEL_45;
      }

      goto LABEL_16;
    }

    if (([keyEvent modifierFlags] & 0x100000) != 0)
    {
      v8 = _UIKeyboardImplLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *v20 = 0;
        v9 = "deferEventHandlingToSystemWithContext, handled command modifier";
        goto LABEL_41;
      }

LABEL_42:

      handleKeyInputMethodCommandForCurrentEvent = 0;
      goto LABEL_43;
    }

    characters = [keyEvent characters];
    v13 = [characters length];

    if (!v13)
    {
      v8 = _UIKeyboardImplLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *v20 = 0;
        v9 = "deferEventHandlingToSystemWithContext, handled no characters";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    characters2 = [keyEvent characters];
    v15 = [characters2 characterAtIndex:0];

    if (v15 > 12)
    {
      if (v15 != 13)
      {
        if (v15 != 127)
        {
          goto LABEL_22;
        }

        goto LABEL_32;
      }
    }

    else if (v15 != 3)
    {
      if (v15 != 8)
      {
LABEL_22:
        if ([contextCopy documentIsEditable] && objc_msgSend(contextCopy, "shouldInsertChar"))
        {
          characters3 = [keyEvent characters];
          inputFlags = [keyEvent inputFlags];
          inputManagerHint = [keyEvent inputManagerHint];
          [(_UIKeyboardStateManager *)self addInputString:characters3 withFlags:inputFlags withInputManagerHint:inputManagerHint];

          v10 = _UIKeyboardImplLog();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          {
            *v20 = 0;
            v11 = "deferEventHandlingToSystemWithContext, addInputString for character";
            goto LABEL_45;
          }

LABEL_16:

          handleKeyInputMethodCommandForCurrentEvent = 1;
          goto LABEL_43;
        }

LABEL_39:
        v8 = _UIKeyboardImplLog();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          *v20 = 0;
          v9 = "deferEventHandlingToSystemWithContext, did not handle";
          goto LABEL_41;
        }

        goto LABEL_42;
      }

LABEL_32:
      if ([contextCopy documentIsEditable])
      {
        -[_UIKeyboardStateManager deleteFromInputWithFlags:](self, "deleteFromInputWithFlags:", [keyEvent inputFlags]);
        v10 = _UIKeyboardImplLog();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          *v20 = 0;
          v11 = "deferEventHandlingToSystemWithContext, deleteFromInputWithFlags";
          goto LABEL_45;
        }

        goto LABEL_16;
      }

      goto LABEL_39;
    }

    if ([contextCopy documentIsEditable] && objc_msgSend(contextCopy, "shouldInsertChar"))
    {
      [(_UIKeyboardStateManager *)self addInputString:@"\n" withFlags:0 withInputManagerHint:0];
      v10 = _UIKeyboardImplLog();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *v20 = 0;
        v11 = "deferEventHandlingToSystemWithContext, addInputString for enter";
        goto LABEL_45;
      }

      goto LABEL_16;
    }

    goto LABEL_39;
  }

  v6 = _UIKeyboardImplLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    *v20 = 0;
    _os_log_debug_impl(&dword_188A29000, v6, OS_LOG_TYPE_DEBUG, "deferEventHandlingToSystemWithContext, shouldEvaluateForInputSystemHandling", v20, 2u);
  }

  handleKeyInputMethodCommandForCurrentEvent = [(_UIKeyboardStateManager *)self handleKeyInputMethodCommandForCurrentEvent];
LABEL_43:

  return handleKeyInputMethodCommandForCurrentEvent;
}

- (void)toggleSoftwareKeyboard
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained toggleSoftwareKeyboard];
}

- (void)ejectKeyDown
{
  if ([(_UIKeyboardStateManager *)self shouldApplyKeyboardCommandToUIHost])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardInputDestinationEventToUIHost:sel_ejectKeyDown];
  }

  else
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    [WeakRetained setHardwareKeyboardIsSeen];

    [(_UIKeyboardStateManager *)self toggleSoftwareKeyboard];
  }
}

- (void)setKeyboardMinimizedByDictation:(BOOL)dictation
{
  dictationCopy = dictation;
  v20[2] = *MEMORY[0x1E69E9840];
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  geometryDelegate = [WeakRetained geometryDelegate];
  isMinimized = [geometryDelegate isMinimized];

  if (isMinimized != dictationCopy)
  {
    v8 = +[UIDictationController activeInstance];
    [v8 setShouldSuppressSoftwareKeyboard:dictationCopy];

    v9 = objc_loadWeakRetained(&self->_presentationDelegate);
    geometryDelegate2 = [v9 geometryDelegate];
    [geometryDelegate2 setMinimized:dictationCopy];

    if (+[UIKeyboard isKeyboardProcess])
    {
      inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
      v12 = inputSystemSourceSession;
      if (inputSystemSourceSession)
      {
        textOperations = [inputSystemSourceSession textOperations];
        [textOperations setCustomInfoType:0x1EFB7C8F0];
        v19[0] = @"selector";
        v14 = NSStringFromSelector(sel_setKeyboardMinimizedByDictation_);
        v19[1] = @"minimized";
        v20[0] = v14;
        v15 = [MEMORY[0x1E696AD98] numberWithBool:dictationCopy];
        v20[1] = v15;
        v16 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v20 forKeys:v19 count:2];
        [textOperations setCustomInfo:v16];

        [v12 flushOperations];
      }
    }

    else if (+[UIKeyboard usesInputSystemUI])
    {
      remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      v17 = [MEMORY[0x1E696AD98] numberWithBool:dictationCopy];
      [remoteTextInputPartner forwardDictationEventToUIHost:sel_setKeyboardMinimizedByDictation_ withOptionalObject:v17];
    }
  }
}

- (void)setCaretVisible:(BOOL)visible
{
  visibleCopy = visible;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained setCaretVisible:visibleCopy];
}

- (void)clearSelection
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  __content = [inputDelegateManager __content];
  v5 = objc_opt_respondsToSelector();

  if (v5)
  {
    self->m_textInputChangesIgnored = 1;
    textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
    activeSelection = [textInteractionAssistant activeSelection];

    [activeSelection clearSelection];
    [activeSelection commit];
    [(_UIKeyboardStateManager *)self syncDocumentStateToInputDelegate];
    self->m_textInputChangesIgnored = 0;
  }
}

- (id)dynamicCaretList
{
  textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
  _legacySelectionView = [textInteractionAssistant _legacySelectionView];
  dynamicCaretList = [_legacySelectionView dynamicCaretList];

  return dynamicCaretList;
}

- (void)updateNoContentViews
{
  dynamicCaretList = [(_UIKeyboardStateManager *)self dynamicCaretList];

  if (dynamicCaretList)
  {
    textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
    _legacySelectionView = [textInteractionAssistant _legacySelectionView];
    [_legacySelectionView updateDocumentHasContent:{-[_UIKeyboardStateManager noContent](self, "noContent") ^ 1}];
  }
}

- (BOOL)canHandleKeyHitTest
{
  inputManagerState = [(_UIKeyboardStateManager *)self inputManagerState];
  canHandleKeyHitTest = [inputManagerState canHandleKeyHitTest];

  return canHandleKeyHitTest;
}

- (BOOL)isAutoFillMode
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate = [inputDelegateManager keyInputDelegate];
  if (objc_opt_respondsToSelector())
  {
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    keyInputDelegate2 = [inputDelegateManager2 keyInputDelegate];
    isAutoFillMode = [keyInputDelegate2 isAutoFillMode];
  }

  else
  {
    isAutoFillMode = 0;
  }

  return isAutoFillMode;
}

- (void)trackUsageForAcceptedAutocorrection:(id)autocorrection promptWasShowing:(BOOL)showing
{
  showingCopy = showing;
  autocorrectionCopy = autocorrection;
  v5 = UIKeyboardGetCurrentInputMode();
  v6 = UIKeyboardInputModeGetIdentifierWithKeyboardLayouts(v5);

  if ([autocorrectionCopy isForShortcutConversion])
  {
    v7 = TIStatisticGetKeyForCandidateAccepted();
    TIStatisticScalarIncrement();
  }

  else if ([autocorrectionCopy wordOriginFeedbackID])
  {
    [autocorrectionCopy usageTrackingMask];
    TIStatisticScalarIncrementAutocorrectionKey();
    if (showingCopy)
    {
      [autocorrectionCopy usageTrackingMask];
      TIStatisticScalarIncrementAutocorrectionKey();
    }
  }
}

- (void)trackUsageForPromptedCorrection:(id)correction inputString:(id)string previousPrompt:(id)prompt
{
  promptCopy = prompt;
  correctionCopy = correction;
  correction = [promptCopy correction];
  v9 = [correctionCopy isEqualToString:correction];

  if ((v9 & 1) == 0)
  {
    v10 = UIKeyboardGetCurrentInputMode();
    v11 = UIKeyboardInputModeGetIdentifierWithKeyboardLayouts(v10);

    if (correction)
    {
      [promptCopy usageTrackingMask];
      TIStatisticScalarIncrementAutocorrectionKey();
    }

    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    autocorrection = [autocorrectionController autocorrection];
    [autocorrection usageTrackingMask];
    TIStatisticScalarIncrementAutocorrectionKey();
  }
}

- (void)trackUsageForCandidateAcceptedAction:(id)action
{
  actionCopy = action;
  statisticsIdentifier = [(UIKeyboardCandidateList *)self->m_candidateList statisticsIdentifier];
  if (!statisticsIdentifier)
  {
    goto LABEL_11;
  }

  v5 = UIKeyboardGetCurrentInputMode();
  v6 = UIKeyboardInputModeGetIdentifierWithKeyboardLayouts(v5);

  v7 = TIStatisticGetKeyForCandidateAccepted();
  TIStatisticScalarIncrement();

  if ((UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL) != 1)
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [WeakRetained layout];
    currentKeyplane = [layout currentKeyplane];
    if (!currentKeyplane)
    {

      goto LABEL_7;
    }

    v11 = currentKeyplane;
    v12 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v12 layout];
    currentKeyplane2 = [layout2 currentKeyplane];
    visualStyling = [currentKeyplane2 visualStyling];

    if ((visualStyling & 0x40) != 0)
    {
      WeakRetained = TIStatisticGetKeyForCandidateAccepted();
      TIStatisticScalarIncrement();
LABEL_7:
    }
  }

  if ([(UIKeyboardCandidateList *)self->m_candidateList selectedSortIndex]!= 0x7FFFFFFFFFFFFFFFLL)
  {
    v16 = TIStatisticGetKeyForCandidateAcceptedSelectedSortingMethod();
    TIStatisticScalarIncrement();
  }

LABEL_11:
}

- (void)performSendCurrentLocation
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  responderForSendCurrentLocation = [(_UIKeyboardStateManager *)self responderForSendCurrentLocation];
  if (responderForSendCurrentLocation)
  {
    _sendCurrentLocationAction = [inputDelegate _sendCurrentLocationAction];
    if (dyld_program_sdk_at_least())
    {
      [responderForSendCurrentLocation _sendCurrentLocationAction];
    }

    else
    {
      [responderForSendCurrentLocation performSelector_];
    }
  }
}

- (void)enableTransientInputDelegateSelectionMode
{
  mainRunLoop = [MEMORY[0x1E695DFD0] mainRunLoop];
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = __68___UIKeyboardStateManager_enableTransientInputDelegateSelectionMode__block_invoke;
  v4[3] = &unk_1E70F3590;
  v4[4] = self;
  [mainRunLoop performBlock:v4];
}

- (void)enableTransientSelectionMode
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v4 = [inputDelegateManager delegateRespectingForwardingDelegate:0];
  [(_UIKeyboardStateManager *)self _setTransientSelectionModeEnabled:1 forInputDelegate:v4];

  if (+[UIKeyboard isKeyboardProcess])
  {
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    inputSystemSourceSession = [inputDelegateManager2 inputSystemSourceSession];

    if (inputSystemSourceSession)
    {
      textOperations = [inputSystemSourceSession textOperations];
      [textOperations setEditingActionSelector:sel_enableTransientSelectionMode];
      [inputSystemSourceSession flushOperations];
    }
  }
}

- (void)disableTransientSelectionMode
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v4 = [inputDelegateManager delegateRespectingForwardingDelegate:0];
  [(_UIKeyboardStateManager *)self _setTransientSelectionModeEnabled:0 forInputDelegate:v4];

  if (+[UIKeyboard isKeyboardProcess])
  {
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    inputSystemSourceSession = [inputDelegateManager2 inputSystemSourceSession];

    if (inputSystemSourceSession)
    {
      textOperations = [inputSystemSourceSession textOperations];
      [textOperations setEditingActionSelector:sel_disableTransientSelectionMode];
      [inputSystemSourceSession flushOperations];
    }
  }
}

- (void)clearForwardingInputDelegateAndResign:(BOOL)resign
{
  resignCopy = resign;
  if ([(_UIKeyboardStateManager *)self _hasMarkedText])
  {
    if (+[UIKeyboard isInputSystemUI])
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];

      if (forwardingInputDelegate)
      {
        inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        [inputDelegateManager2 unmarkText];
      }
    }
  }

  inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager3 clearForwardingInputDelegateAndResign:resignCopy];

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  [remoteTextInputPartner forwardClearForwardingInputDelegateAndResign:resignCopy];
}

- (void)didChangeForwardingInputDelegate:(id)delegate
{
  [(_UIKeyboardStateManager *)self takeTextInputTraitsFromDelegate];
  if (delegate)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];
    keyboardType = [forwardingInputDelegate keyboardType];

    if (keyboardType == 122)
    {

      [(_UIKeyboardStateManager *)self recomputeActiveInputModesWithExtensions:0 allowNonLinguisticInputModes:1];
    }
  }

  else
  {
    [(_UIKeyboardStateManager *)self disableTransientSelectionMode];
    [(_UIKeyboardStateManager *)self recomputeActiveInputModesWithExtensions:1 allowNonLinguisticInputModes:1];
    v8 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
    [v8 updateRenderConfigForCurrentResponder];

    [(_UIKeyboardStateManager *)self reinitializeAfterInputModeSwitch:0];
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [WeakRetained layout];
    v11 = objc_opt_respondsToSelector();

    if (v11)
    {
      v13 = objc_loadWeakRetained(&self->_presentationDelegate);
      layout2 = [v13 layout];
      [layout2 didTriggerDestructiveRenderConfigChange];
    }
  }
}

- (void)_setTransientSelectionModeEnabled:(BOOL)enabled forInputDelegate:(id)delegate
{
  enabledCopy = enabled;
  delegateCopy = delegate;
  if (objc_opt_respondsToSelector())
  {
    interactionAssistant = [delegateCopy interactionAssistant];
    [interactionAssistant setSelectionDisplayVisible:1];
    [interactionAssistant setCursorBlinkAnimationEnabled:enabledCopy ^ 1];
    [interactionAssistant setGhostAppearance:enabledCopy];
  }
}

- (void)_performKeyboardOutput:(id)output respectingForwardingDelegate:(BOOL)delegate
{
  delegateCopy = delegate;
  outputCopy = output;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  forwardingInputDelegate = [inputDelegateManager forwardingInputDelegate];

  if (!forwardingInputDelegate || delegateCopy)
  {
    outputCopy[2]();
  }

  else
  {
    inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    shouldRespectForwardingInputDelegate = [inputDelegateManager2 shouldRespectForwardingInputDelegate];

    inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager3 setShouldRespectForwardingInputDelegate:0];

    inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager4 updateRespectForwardingInputDelegateFlagInDestination];

    outputCopy[2]();
    inputDelegateManager5 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager5 setShouldRespectForwardingInputDelegate:shouldRespectForwardingInputDelegate];

    inputDelegateManager6 = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager6 updateRespectForwardingInputDelegateFlagInDestination];
  }
}

- (void)_ensureRTIConnection
{
  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  [remoteTextInputPartner ensureRTIConnection];
}

- (id)buildInputSourceState
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  buildInputSourceState = [WeakRetained buildInputSourceState];

  return buildInputSourceState;
}

- (void)resetInputDelegate
{
  delegate = [(_UIKeyboardStateManager *)self delegate];
  [(_UIKeyboardStateManager *)self setDelegate:0];
  [(_UIKeyboardStateManager *)self setDelegate:delegate];
}

- (void)modifyTextInputTraits:(id)traits forceSync:(BOOL)sync
{
  syncCopy = sync;
  remoteTextInputTraits = self->_remoteTextInputTraits;
  traitsCopy = traits;
  v8 = [(UITextInputTraits *)remoteTextInputTraits copy];
  traitsCopy[2](traitsCopy, v8);

  [(_UIKeyboardStateManager *)self updateInputDelegateForRemoteTraitChange:v8 forceSync:syncCopy];
}

- (void)updateInputDelegateForRemoteTraitChange:(id)change forceSync:(BOOL)sync
{
  syncCopy = sync;
  v94[1] = *MEMORY[0x1E69E9840];
  changeCopy = change;
  if (![(_UIKeyboardStateManager *)self showingEmojiSearch])
  {
    objc_storeStrong(&self->_remoteTextInputTraits, change);
    autocapitalizationType = [changeCopy autocapitalizationType];
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate setAutocapitalizationType:autocapitalizationType];

    autocorrectionType = [changeCopy autocorrectionType];
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate2 setAutocorrectionType:autocorrectionType];

    spellCheckingType = [changeCopy spellCheckingType];
    inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate3 setSpellCheckingType:spellCheckingType];

    keyboardType = [changeCopy keyboardType];
    inputDelegate4 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate4 setKeyboardType:keyboardType];

    returnKeyType = [changeCopy returnKeyType];
    inputDelegate5 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate5 setReturnKeyType:returnKeyType];

    enablesReturnKeyAutomatically = [changeCopy enablesReturnKeyAutomatically];
    inputDelegate6 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate6 setEnablesReturnKeyAutomatically:enablesReturnKeyAutomatically];

    isSecureTextEntry = [changeCopy isSecureTextEntry];
    inputDelegate7 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate7 setSecureTextEntry:isSecureTextEntry];

    textContentType = [changeCopy textContentType];
    inputDelegate8 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate8 setTextContentType:textContentType];

    smartInsertDeleteType = [changeCopy smartInsertDeleteType];
    inputDelegate9 = [(_UIKeyboardStateManager *)self inputDelegate];
    [inputDelegate9 setSmartInsertDeleteType:smartInsertDeleteType];

    inputDelegate10 = [(_UIKeyboardStateManager *)self inputDelegate];
    LOBYTE(inputDelegate9) = objc_opt_respondsToSelector();

    if (inputDelegate9)
    {
      inputDelegate11 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegate11 setForceEnableDictation:{objc_msgSend(changeCopy, "forceEnableDictation")}];
    }

    inputDelegate12 = [(_UIKeyboardStateManager *)self inputDelegate];
    v29 = objc_opt_respondsToSelector();

    if (v29)
    {
      inputDelegate13 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegate13 setDevicePasscodeEntry:{objc_msgSend(changeCopy, "isDevicePasscodeEntry")}];
    }

    -[UITextInputTraits setHidePrediction:](self->m_traits, "setHidePrediction:", [changeCopy hidePrediction]);
    inputDelegate14 = [(_UIKeyboardStateManager *)self inputDelegate];
    v32 = objc_opt_respondsToSelector();

    if (v32)
    {
      inputDelegate15 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegate15 setHidePrediction:{objc_msgSend(changeCopy, "hidePrediction")}];
    }

    -[UITextInputTraits setDisablePrediction:](self->m_traits, "setDisablePrediction:", [changeCopy disablePrediction]);
    inputDelegate16 = [(_UIKeyboardStateManager *)self inputDelegate];
    v35 = objc_opt_respondsToSelector();

    if (v35)
    {
      inputDelegate17 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegate17 setDisablePrediction:{objc_msgSend(changeCopy, "disablePrediction")}];
    }

    inputDelegate18 = [(_UIKeyboardStateManager *)self inputDelegate];
    v38 = objc_opt_respondsToSelector();

    inputDelegate19 = [(_UIKeyboardStateManager *)self inputDelegate];
    if (v38)
    {
      [inputDelegate19 setInlinePredictionType:{objc_msgSend(changeCopy, "inlinePredictionType")}];
    }

    else
    {
      v40 = objc_opt_respondsToSelector();

      if ((v40 & 1) == 0)
      {
        goto LABEL_15;
      }

      inputDelegate19 = [(_UIKeyboardStateManager *)self inputDelegate];
      [inputDelegate19 setInlineCompletionType:{objc_msgSend(changeCopy, "inlinePredictionType")}];
    }
  }

LABEL_15:
  forceFloatingKeyboard = [(UITextInputTraits *)self->m_traits forceFloatingKeyboard];
  if (forceFloatingKeyboard != [changeCopy forceFloatingKeyboard])
  {
    -[UITextInputTraits setForceFloatingKeyboard:](self->m_traits, "setForceFloatingKeyboard:", [changeCopy forceFloatingKeyboard]);
    -[_UIKeyboardStateManager setFloatingForced:](self, "setFloatingForced:", [changeCopy forceFloatingKeyboard]);
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    [WeakRetained refreshRivenPreferences];

    [(_UIKeyboardStateManager *)self notifyInputSourceStateChangeIfNeeded];
  }

  autofillMode = [(TIKeyboardState *)self->m_keyboardState autofillMode];
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  v91 = autofillMode;
  [autofillController setDelegateNeedsAutofillMode:autofillMode];

  if (syncCopy)
  {
    [(_UIKeyboardStateManager *)self _requestInputManagerSync];
  }

  forceEnableDictation = [changeCopy forceEnableDictation];
  forceEnableDictation2 = [(UITextInputTraits *)self->m_traits forceEnableDictation];
  inputContextHistory = [changeCopy inputContextHistory];
  inputContextHistory2 = [(UITextInputTraits *)self->m_traits inputContextHistory];

  v92 = inputContextHistory;
  responseContext = [changeCopy responseContext];
  v49 = responseContext;
  if (responseContext)
  {
    v50 = responseContext;
  }

  else
  {
    v50 = &stru_1EFB14550;
  }

  responseContext2 = [(UITextInputTraits *)self->m_traits responseContext];
  v52 = responseContext2;
  if (responseContext2)
  {
    v53 = responseContext2;
  }

  else
  {
    v53 = &stru_1EFB14550;
  }

  v89 = [(__CFString *)v50 isEqualToString:v53];

  keyboardAppearance = [changeCopy keyboardAppearance];
  keyboardAppearance2 = [(UITextInputTraits *)self->m_traits keyboardAppearance];
  v56 = [changeCopy updateResultComparedToTraits:self->m_traits];
  isSecureTextEntry2 = [(UITextInputTraits *)self->m_traits isSecureTextEntry];
  if (isSecureTextEntry2 == [changeCopy isSecureTextEntry] && (v58 = -[UITextInputTraits keyboardType](self->m_traits, "keyboardType"), v58 == objc_msgSend(changeCopy, "keyboardType")))
  {
    v88 = keyboardAppearance;
    textContentType2 = [(UITextInputTraits *)self->m_traits textContentType];
    textContentType3 = [changeCopy textContentType];
    v61 = textContentType3;
    if (textContentType2 == textContentType3)
    {

      v83 = [changeCopy copy];
      m_traits = self->m_traits;
      self->m_traits = v83;

      keyboardAppearance = v88;
      goto LABEL_32;
    }

    [(UITextInputTraits *)self->m_traits textContentType];
    v62 = v87 = keyboardAppearance2;
    textContentType4 = [changeCopy textContentType];
    v86 = [v62 isEqualToString:textContentType4];

    keyboardAppearance2 = v87;
    v64 = [changeCopy copy];
    v65 = self->m_traits;
    self->m_traits = v64;

    keyboardAppearance = v88;
    if (v86)
    {
      goto LABEL_32;
    }
  }

  else
  {
    v66 = [changeCopy copy];
    v67 = self->m_traits;
    self->m_traits = v66;
  }

  -[_UIKeyboardStateManager recomputeActiveInputModesWithExtensions:](self, "recomputeActiveInputModesWithExtensions:", [changeCopy isSecureTextEntry] ^ 1);
LABEL_32:
  v68 = forceEnableDictation ^ forceEnableDictation2;
  if (syncCopy && ([(_UIKeyboardStateManager *)self delegate], v69 = objc_claimAutoreleasedReturnValue(), v69, v69) && v56 == 2)
  {
    v70 = keyboardAppearance2;
    if (self->m_shift)
    {
      v71 = objc_loadWeakRetained(&self->_presentationDelegate);
      layout = [v71 layout];
      if (!layout || self->m_shiftLocked || [(_UIKeyboardStateManager *)self callLayoutIsShiftKeyBeingHeld])
      {
      }

      else
      {
        callLayoutIsShiftKeyPlaneChooser = [(_UIKeyboardStateManager *)self callLayoutIsShiftKeyPlaneChooser];

        if (callLayoutIsShiftKeyPlaneChooser)
        {
          [(_UIKeyboardStateManager *)self clearShiftState];
        }
      }
    }

    if (keyboardAppearance != v70 && +[UIKeyboard isKeyboardProcess])
    {
      v73 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
      [v73 traitCollectionDidChange];
    }

    v74 = objc_loadWeakRetained(&self->_presentationDelegate);
    [v74 updateLayout];
  }

  else if (v56 == 1)
  {
    [(_UIKeyboardStateManager *)self updateReturnKey:1];
  }

  if (v68)
  {
    v75 = +[UIDictationController sharedInstance];
    v93 = 0x1EFB1B590;
    v94[0] = @"Dictation state changed due to trait change";
    v76 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v94 forKeys:&v93 count:1];
    [v75 postNotificationName:@"UIKeyboardDictationAvailabilityDidChangeNotification" userInfo:v76];
  }

  self->m_cachedAutofillMode = [(_UIKeyboardStateManager *)self needAutofill];
  if (v91)
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    if ([autocorrectionController hasAutofillCandidates])
    {
    }

    else
    {
      hasOnlySlottedCandidates = [(TIKeyboardCandidateResultSet *)self->m_candidateResultSet hasOnlySlottedCandidates];

      if (!hasOnlySlottedCandidates)
      {
        [(_UIKeyboardStateManager *)self generateAutofillCandidateByAddingTask:1];
      }
    }
  }

  if ((v92 != inputContextHistory2) | v89 & 1)
  {
    inputContextHistory3 = [changeCopy inputContextHistory];
    tiInputContextHistory = [inputContextHistory3 tiInputContextHistory];
    [(TIKeyboardState *)self->m_keyboardState setInputContextHistory:tiInputContextHistory];

    [(_UIKeyboardStateManager *)self responseContextDidChange];
  }

  if ((+[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI") || +[UIKeyboard usesInputSystemUIForAutoFillOnlyWithRTI]) && [(_UIKeyboardStateManager *)self isRTIClient])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner documentTraitsChanged];
  }

  if (+[UIKeyboard isKeyboardProcess])
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    [inputDelegateManager updateDelegateConformanceForRemoteTraits];
  }
}

- (void)updateInputDelegateForRemoteDocumentStateChange:(id)change selectedTextRange:(_NSRange)range hasText:(BOOL)text forceSync:(BOOL)sync
{
  length = range.length;
  location = range.location;
  changeCopy = change;
  fullString = [changeCopy fullString];
  selectedText = [changeCopy selectedText];
  if (selectedText)
  {
    v14 = selectedText;
    selectedText2 = [changeCopy selectedText];
    v16 = [selectedText2 length];

    if (!v16)
    {
      v27 = objc_alloc(MEMORY[0x1E69D9590]);
      contextBeforeInput = [changeCopy contextBeforeInput];
      markedText = [changeCopy markedText];
      contextAfterInput = [changeCopy contextAfterInput];
      selectedRangeInMarkedText = [changeCopy selectedRangeInMarkedText];
      v21 = [v27 initWithUnboundedContextBefore:contextBeforeInput markedText:markedText selectedText:0 unboundedContextAfter:contextAfterInput selectedRangeInMarkedText:{selectedRangeInMarkedText, v20}];

      changeCopy = v21;
    }
  }

  if (qword_1ED49D568 != -1)
  {
    dispatch_once(&qword_1ED49D568, &__block_literal_global_1898);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v28[0] = MEMORY[0x1E69E9820];
  v28[1] = 3221225472;
  v28[2] = __111___UIKeyboardStateManager_updateInputDelegateForRemoteDocumentStateChange_selectedTextRange_hasText_forceSync___block_invoke_3;
  v28[3] = &unk_1E70FE0F0;
  syncCopy = sync;
  textCopy = text;
  v28[4] = self;
  v29 = fullString;
  v30 = changeCopy;
  v31 = location;
  v32 = length;
  v23 = qword_1ED49D560;
  v24 = changeCopy;
  v25 = fullString;
  [taskQueue addTask:v28 breadcrumb:v23];
}

- (void)updateForExpectedRemoteDocumentStateChange:(id)change selectedTextRange:(_NSRange)range forceSync:(BOOL)sync
{
  syncCopy = sync;
  changeCopy = change;
  if (syncCopy && [(_UIKeyboardStateManager *)self hasAutocorrectPrompt]&& +[UIKeyboard isKeyboardProcess])
  {
    autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
    autocorrection = [autocorrectionController autocorrection];
    [(_UIKeyboardStateManager *)self updateAutocorrectPrompt:autocorrection];
  }

  if (qword_1ED49D578 != -1)
  {
    dispatch_once(&qword_1ED49D578, &__block_literal_global_1902);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v11[0] = MEMORY[0x1E69E9820];
  v11[1] = 3221225472;
  v11[2] = __98___UIKeyboardStateManager_updateForExpectedRemoteDocumentStateChange_selectedTextRange_forceSync___block_invoke_3;
  v11[3] = &unk_1E70FD058;
  v11[4] = self;
  [taskQueue addTask:v11 breadcrumb:qword_1ED49D570];
}

- (BOOL)assertTextForRemoteDocument:(id)document withSelectionDelta:(id)delta updatingSelection:(BOOL)selection
{
  selectionCopy = selection;
  var1 = delta.var1;
  var0 = delta.var0;
  documentCopy = document;
  v10 = documentCopy != 0;
  if (documentCopy)
  {
    inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
    [(_UIKeyboardStateManager *)self replaceAllTextInResponder:inputDelegate withText:documentCopy];
  }

  if (var0 | var1)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    asyncCapableInputDelegate = [inputDelegateManager asyncCapableInputDelegate];

    if (asyncCapableInputDelegate)
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v19[0] = MEMORY[0x1E69E9820];
      v19[1] = 3221225472;
      v19[2] = __92___UIKeyboardStateManager_assertTextForRemoteDocument_withSelectionDelta_updatingSelection___block_invoke;
      v19[3] = &unk_1E70F3590;
      v19[4] = self;
      [inputDelegateManager2 adjustSelection:var0 completionHandler:{var1, v19}];

      v10 = 1;
    }

    else
    {
      inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
      v16 = [inputDelegate2 _rangeFromCurrentRangeWithDelta:{var0, var1}];

      inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager3 setSelectedTextRange:v16];

      if (selectionCopy)
      {
        [(_UIKeyboardStateManager *)self updateForChangedSelection];
        v10 = 1;
      }
    }
  }

  return v10;
}

- (void)insertAttributedText:(id)text
{
  textCopy = text;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager insertAttributedText:textCopy];
}

- (void)insertAdaptiveImageGlyph:(id)glyph
{
  glyphCopy = glyph;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v5 = [inputDelegateManager delegateRespectingForwardingDelegate:0];

  if ([(_UIKeyboardStateManager *)self canInsertAdaptiveImageGlyph]&& (objc_opt_respondsToSelector() & 1) != 0)
  {
    selectedTextRange = [v5 selectedTextRange];
    [v5 insertAdaptiveImageGlyph:glyphCopy replacementRange:selectedTextRange];

    [(_UIKeyboardStateManager *)self setPreviousInputString:0];
  }
}

- (void)insertEmojiImageTextAttachment:(id)attachment
{
  attachmentCopy = attachment;
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  v5 = [inputDelegateManager delegateRespectingForwardingDelegate:0];

  if ([(_UIKeyboardStateManager *)self canInsertEmojiImageTextAttachment]&& (objc_opt_respondsToSelector() & 1) != 0)
  {
    selectedTextRange = [v5 selectedTextRange];
    [v5 insertEmojiImageTextAttachment:attachmentCopy replacementRange:selectedTextRange];

    [(_UIKeyboardStateManager *)self setPreviousInputString:0];
  }
}

- (void)presentEmojiGenerationWithInputString:(id)string
{
  stringCopy = string;
  v4 = +[UIKeyboardEmojiGenerationPresenter sharedInstance];
  [v4 presentEmojiGenerationControllerWithInputString:stringCopy];
}

- (void)updateAssistantViewInfo:(id)info
{
  infoCopy = info;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained updateAssistantViewInfo:infoCopy];
}

- (void)applyAssistantItem:(id)item
{
  itemCopy = item;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained applyAssistantItem:itemCopy];
}

- (void)unmarkText:(id)text
{
  textCopy = text;
  [UIKBAnalyticsDispatcher didCommitText:textCopy];
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  [inputDelegateManager unmarkText:textCopy];
}

- (void)handleRemoteDictationEvent_switchToDictationInputModeWithOptions:(id)options
{
  optionsCopy = options;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v5 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v5)
    {
      v7 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v7, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v5)
  {
    v8 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_switchToDictationInputModeWithOptions____s_category) + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *v9 = 0;
      _os_log_impl(&dword_188A29000, v8, OS_LOG_TYPE_ERROR, "Unexpected event handling", v9, 2u);
    }
  }

  v6 = +[UIDictationController sharedInstance];
  [v6 switchToDictationInputModeWithOptions:optionsCopy];
}

- (void)handleRemoteDictationEvent_switchToDictationLanguage:(id)language
{
  languageCopy = language;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v5 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v5)
    {
      v7 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v7, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v5)
  {
    v8 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_switchToDictationLanguage____s_category) + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *v9 = 0;
      _os_log_impl(&dword_188A29000, v8, OS_LOG_TYPE_ERROR, "Unexpected event handling", v9, 2u);
    }
  }

  v6 = +[UIDictationController sharedInstance];
  [v6 switchToDictationLanguage:languageCopy];
}

- (void)handleRemoteDictationEvent_startDictation
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v3 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v3)
    {
      v5 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v5, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v3)
  {
    v6 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_startDictation___s_category) + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *v7 = 0;
      _os_log_impl(&dword_188A29000, v6, OS_LOG_TYPE_ERROR, "Unexpected event handling", v7, 2u);
    }
  }

  v4 = +[UIDictationController sharedInstance];
  [v4 startDictation];
}

- (void)handleRemoteDictationEvent_stopDictation:(BOOL)dictation
{
  dictationCopy = dictation;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v5 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v5)
    {
      v8 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v8, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v5)
  {
    v9 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_stopDictation____s_category) + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *v10 = 0;
      _os_log_impl(&dword_188A29000, v9, OS_LOG_TYPE_ERROR, "Unexpected event handling", v10, 2u);
    }
  }

  v6 = +[UIDictationController sharedInstance];
  [v6 stopDictation:dictationCopy];

  v7 = +[UIDictationController activeInstance];
  [v7 resignFirstResponderWhenIdleIfNeeded];
}

- (void)handleRemoteDictationEvent_cancelDictation
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v3 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v3)
    {
      v6 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v6, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v3)
  {
    v7 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_cancelDictation___s_category) + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *v8 = 0;
      _os_log_impl(&dword_188A29000, v7, OS_LOG_TYPE_ERROR, "Unexpected event handling", v8, 2u);
    }
  }

  v4 = +[UIDictationController sharedInstance];
  [v4 cancelDictation];

  v5 = +[UIDictationController activeInstance];
  [v5 resignFirstResponderWhenIdleIfNeeded];
}

- (void)handleRemoteDictationEvent_handleTip:(id)tip
{
  tipCopy = tip;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v12 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v12, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v13 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_handleTip____s_category) + 8);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *v14 = 0;
      _os_log_impl(&dword_188A29000, v13, OS_LOG_TYPE_ERROR, "Unexpected event handling", v14, 2u);
    }
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  dictationPopoverController = [WeakRetained dictationPopoverController];
  v9 = dictationPopoverController;
  if (tipCopy)
  {
    v10 = [tipCopy objectForKeyedSubscript:@"text"];
    v11 = [tipCopy objectForKeyedSubscript:@"title"];
    [v9 presentTip:v10 tipDescription:v11];
  }

  else
  {
    [dictationPopoverController dismissTip];
  }
}

- (void)handleRemoteDictationEvent_setDisambiguationActive:(BOOL)active maxOptions:(unint64_t)options
{
  activeCopy = active;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v7 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v7)
    {
      v10 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v10, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v7)
  {
    v11 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_setDisambiguationActive_maxOptions____s_category) + 8);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *v12 = 0;
      _os_log_impl(&dword_188A29000, v11, OS_LOG_TYPE_ERROR, "Unexpected event handling", v12, 2u);
    }
  }

  v8 = +[UIDictationController sharedInstance];
  [v8 setDisambiguationActiveEnabled:activeCopy];

  v9 = +[UIDictationController sharedInstance];
  [v9 setMaxDisambiguationOptions:options];
}

- (void)handleRemoteDictationEvent_movePopoverView:(id)view
{
  viewCopy = view;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v16 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v16, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v17 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_movePopoverView____s_category) + 8);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *v18 = 0;
      _os_log_impl(&dword_188A29000, v17, OS_LOG_TYPE_ERROR, "Unexpected event handling", v18, 2u);
    }
  }

  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  _window = [inputDelegate _window];
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  window = [WeakRetained window];

  if (_window != window)
  {
    v11 = objc_loadWeakRetained(&self->_presentationDelegate);
    dictationPopoverController = [v11 dictationPopoverController];
    v13 = [viewCopy objectForKeyedSubscript:@"sourceRect"];
    [v13 rectValue];
    [dictationPopoverController movePopoverView:?];

    v14 = [viewCopy objectForKeyedSubscript:@"editMenuFrame"];
    if (v14)
    {
      v15 = objc_loadWeakRetained(&self->_presentationDelegate);
      [v14 rectValue];
      [v15 setEditMenuFrame:?];
    }
  }
}

- (void)handleRemoteDictationEvent_setEditMenuFrame:(id)frame
{
  frameCopy = frame;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v13 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v13, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v14 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_setEditMenuFrame____s_category) + 8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *v15 = 0;
      _os_log_impl(&dword_188A29000, v14, OS_LOG_TYPE_ERROR, "Unexpected event handling", v15, 2u);
    }
  }

  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  _window = [inputDelegate _window];
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  window = [WeakRetained window];

  if (_window != window)
  {
    v11 = objc_loadWeakRetained(&self->_presentationDelegate);
    v12 = [frameCopy objectForKeyedSubscript:@"editMenuFrame"];
    [v12 rectValue];
    [v11 setEditMenuFrame:?];
  }
}

- (void)handleRemoteDictationEvent_updateIdleDetection:(int64_t)detection
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v7 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v7, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v8 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_updateIdleDetection____s_category) + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *v9 = 0;
      _os_log_impl(&dword_188A29000, v8, OS_LOG_TYPE_ERROR, "Unexpected event handling", v9, 2u);
    }
  }

  [(_UIKeyboardStateManager *)self updateIdleDetection:detection];
}

- (void)handleRemoteDictationEvent_stopDictationIgnoreFinalizePhrases
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v3 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v3)
    {
      v5 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v5, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v3)
  {
    v6 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_stopDictationIgnoreFinalizePhrases___s_category) + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *v7 = 0;
      _os_log_impl(&dword_188A29000, v6, OS_LOG_TYPE_ERROR, "Unexpected event handling", v7, 2u);
    }
  }

  v4 = +[UIDictationController sharedInstance];
  [v4 stopDictationIgnoreFinalizePhrases];
}

- (void)handleRemoteDictationEvent_resumeDictation
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v3 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v3)
    {
      v5 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v5, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v3)
  {
    v6 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteDictationEvent_resumeDictation___s_category) + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *v7 = 0;
      _os_log_impl(&dword_188A29000, v6, OS_LOG_TYPE_ERROR, "Unexpected event handling", v7, 2u);
    }
  }

  v4 = +[UIDictationController sharedInstance];
  [v4 resumeDictation];
}

- (void)handleRemoteKeyboardCameraEvent_startCameraInput:(id)input
{
  inputCopy = input;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v9 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v9, OS_LOG_TYPE_FAULT, "Unexpected event handling", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v10 = *(__UILogGetCategoryCachedImpl("Assert", &handleRemoteKeyboardCameraEvent_startCameraInput____s_category) + 8);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *v11 = 0;
      _os_log_impl(&dword_188A29000, v10, OS_LOG_TYPE_ERROR, "Unexpected event handling", v11, 2u);
    }
  }

  v7 = +[UIKeyboardCameraSession sharedSession];
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  [v7 showForResponder:inputDelegate sender:0 rtiConfiguration:inputCopy];
}

- (void)handleEventFromRemoteSource_insertSupplementalCandidate:(id)candidate textToCommit:(id)commit
{
  candidateCopy = candidate;
  commitCopy = commit;
  self->m_didSyncDocumentStateToInputDelegate = 0;
  if (!commitCopy)
  {
    goto LABEL_11;
  }

  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];

  if (inputDelegate && (-[_UIKeyboardStateManager inputDelegateManager](self, "inputDelegateManager"), v8 = objc_claimAutoreleasedReturnValue(), v9 = [v8 callShouldReplaceExtendedRange:0 withText:commitCopy includeMarkedText:{-[_UIKeyboardStateManager _hasMarkedText](self, "_hasMarkedText")}], v8, !v9))
  {
    v11 = &stru_1EFB14550;
    selfCopy2 = self;
  }

  else
  {
    if ([candidateCopy isSupplementalItemCandidate])
    {
      [(_UIKeyboardStateManager *)self _willReplaceText:commitCopy withSupplementalCandidate:candidateCopy];
      [(_UIKeyboardStateManager *)self unmarkText:commitCopy];
      [(_UIKeyboardStateManager *)self _didReplaceText:commitCopy withSupplementalCandidate:candidateCopy];
      goto LABEL_9;
    }

    selfCopy2 = self;
    v11 = commitCopy;
  }

  [(_UIKeyboardStateManager *)selfCopy2 unmarkText:v11];
LABEL_9:
  if ([candidateCopy isSupplementalItemCandidate])
  {
    [(_UIKeyboardStateManager *)self _insertSupplementalCandidate:candidateCopy overridingCandidateText:commitCopy];
  }

LABEL_11:
}

- (void)handleEventFromRemoteSource_chooseSupplementalItem:(id)item toReplaceText:(id)text
{
  itemCopy = item;
  textCopy = text;
  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = __92___UIKeyboardStateManager_handleEventFromRemoteSource_chooseSupplementalItem_toReplaceText___block_invoke;
  aBlock[3] = &unk_1E70FE118;
  aBlock[4] = self;
  v8 = _Block_copy(aBlock);
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  v10 = objc_opt_respondsToSelector();

  if ((v10 & 1) != 0 && [itemCopy count])
  {
    v11 = [(_UIKeyboardStateManager *)self _rangeForSupplementalItemText:textCopy];
    v12 = [_UIStringAndPositionPair alloc];
    start = [v11 start];
    v14 = [(_UIStringAndPositionPair *)&v12->super.isa initWithString:textCopy position:start];

    pendingSupplementalCandidateToInsert = [(_UIKeyboardStateManager *)self pendingSupplementalCandidateToInsert];
    inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
    v17 = [(_UIStringAndPositionPair *)pendingSupplementalCandidateToInsert isEqualToPair:v14 inputDelegate:inputDelegate2];

    if (!v17)
    {
      [(_UIKeyboardStateManager *)self setPendingSupplementalCandidateToInsert:v14];
      if ([itemCopy count] == 1)
      {
        [(_UIKeyboardStateManager *)self setPendingSupplementalCandidateToInsert:0];
        firstObject = [itemCopy firstObject];
        v8[2](v8, firstObject, textCopy);
      }

      else
      {
        objc_initWeak(&location, self);
        v19 = (self->m_lastChooseSupplementalItemToInsertCallbackIdentifier + 1);
        self->m_lastChooseSupplementalItemToInsertCallbackIdentifier = v19;
        self->m_textInputChangesIgnored = 1;
        inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
        v21[0] = MEMORY[0x1E69E9820];
        v21[1] = 3221225472;
        v21[2] = __92___UIKeyboardStateManager_handleEventFromRemoteSource_chooseSupplementalItem_toReplaceText___block_invoke_2;
        v21[3] = &unk_1E70FE140;
        objc_copyWeak(v25, &location);
        v24 = v8;
        v22 = textCopy;
        v25[1] = v19;
        v23 = v11;
        [inputDelegate3 _chooseSupplementalItemToInsert:itemCopy replacementRange:v23 completionHandler:v21];

        self->m_textInputChangesIgnored = 0;
        objc_destroyWeak(v25);
        objc_destroyWeak(&location);
      }
    }
  }

  else
  {
    v8[2](v8, 0, textCopy);
  }
}

- (void)handleEventCallbackFromRemoteDestination_didChooseSupplementalItem:(id)item toReplaceText:(id)text
{
  itemCopy = item;
  textCopy = text;
  chooseSupplementalCandidateCompletion = [(_UIKeyboardStateManager *)self chooseSupplementalCandidateCompletion];

  if (chooseSupplementalCandidateCompletion)
  {
    chooseSupplementalCandidateCompletion2 = [(_UIKeyboardStateManager *)self chooseSupplementalCandidateCompletion];
    (chooseSupplementalCandidateCompletion2)[2](chooseSupplementalCandidateCompletion2, itemCopy, textCopy);

    [(_UIKeyboardStateManager *)self setChooseSupplementalCandidateCompletion:0];
  }
}

- (void)handleEventFromRemoteSource_insertionPointEnteredText:(id)text withSupplementalCandidate:(id)candidate
{
  textCopy = text;
  candidateCopy = candidate;
  v7 = [(_UIKeyboardStateManager *)self _rangeForSupplementalItemText:textCopy];
  if (([v7 isEmpty] & 1) == 0)
  {
    [(_UIKeyboardStateManager *)self _dispatchInsertionPointEnteredText:textCopy range:v7 withSupplementalCandidate:candidateCopy];
  }
}

- (void)handleEventFromRemoteDestination_canSuggestSupplementalItemsForCurrentSelection:(BOOL)selection
{
  if (qword_1ED49D588 != -1)
  {
    dispatch_once(&qword_1ED49D588, &__block_literal_global_1922);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v6[0] = MEMORY[0x1E69E9820];
  v6[1] = 3221225472;
  v6[2] = __107___UIKeyboardStateManager_handleEventFromRemoteDestination_canSuggestSupplementalItemsForCurrentSelection___block_invoke_3;
  v6[3] = &unk_1E70FDD10;
  v6[4] = self;
  selectionCopy = selection;
  [taskQueue addTask:v6 breadcrumb:qword_1ED49D580];
}

- (void)handleEventFromRemoteSource_insertAutofillContent:(id)content
{
  v4 = MEMORY[0x1E69D9638];
  contentCopy = content;
  v6 = objc_alloc_init(v4);
  v7 = [contentCopy copy];

  [v6 setCustomInfo:v7];
  if (qword_1ED49D598 != -1)
  {
    dispatch_once(&qword_1ED49D598, &__block_literal_global_1926);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v11[0] = MEMORY[0x1E69E9820];
  v11[1] = 3221225472;
  v11[2] = __77___UIKeyboardStateManager_handleEventFromRemoteSource_insertAutofillContent___block_invoke_3;
  v11[3] = &unk_1E70FD1B8;
  v11[4] = self;
  v12 = v6;
  v9 = qword_1ED49D590;
  v10 = v6;
  [taskQueue addTask:v11 breadcrumb:v9];
}

- (void)handleEventFromRemoteSource_autoFillIsMenuPresented:(BOOL)presented
{
  if (self->m_isAutoFillMenuPresented == presented)
  {
    if (presented)
    {
LABEL_3:
      self->m_shouldSuppressSelectionCommands = 1;
    }
  }

  else
  {
    self->m_isAutoFillMenuPresented = presented;
    if (presented)
    {
      +[UIPeripheralHost visiblePeripheralFrame];
      v5 = v4;
      v7 = v6;
      v9 = v8;
      v11 = v10;
      remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
      rtiDocumentState = [remoteTextInputPartner rtiDocumentState];
      [rtiDocumentState caretRectInWindow];
      v50.origin.x = v14;
      v50.origin.y = v15;
      v50.size.width = v16;
      v50.size.height = v17;
      v48.origin.x = v5;
      v48.origin.y = v7;
      v48.size.width = v9;
      v48.size.height = v11;
      v18 = CGRectContainsRect(v48, v50);

      if (v18)
      {
        [(_UIKeyboardStateManager *)self dismissAutoFillMenu];
        inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
        inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
        selectedTextRange = [inputDelegateManager2 selectedTextRange];
        start = [selectedTextRange start];
        [inputDelegateManager caretRectForPosition:start];
        v24 = v23;
        v26 = v25;
        v28 = v27;
        v30 = v29;

        inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
        textInputView = [inputDelegate textInputView];
        inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
        textInputView2 = [inputDelegate2 textInputView];
        window = [textInputView2 window];
        [textInputView convertRect:window toView:{v24, v26, v28, v30}];
        v37 = v36;
        v39 = v38;
        v41 = v40;
        v43 = v42;

        +[UIPeripheralHost visiblePeripheralFrame];
        v51.origin.x = v37;
        v51.origin.y = v39;
        v51.size.width = v41;
        v51.size.height = v43;
        if (CGRectContainsRect(v49, v51))
        {
          return;
        }

        remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
        [remoteTextInputPartner2 documentStateChanged];
      }

      else
      {
        _editMenuAssistant = [(_UIKeyboardStateManager *)self _editMenuAssistant];
        _editMenuIsVisible = [_editMenuAssistant _editMenuIsVisible];

        if (!_editMenuIsVisible)
        {
          goto LABEL_3;
        }

        remoteTextInputPartner2 = [(_UIKeyboardStateManager *)self _editMenuAssistant];
        [remoteTextInputPartner2 hideSelectionCommands];
      }
    }

    else
    {
      self->m_shouldSuppressSelectionCommands = 0;
    }
  }
}

- (void)handleEventFromRemoteSource_autoFillIsModalUIPresented:(BOOL)presented
{
  presentedCopy = presented;
  object = [(_UIKeyboardStateManager *)self delegateAsResponder];
  if (presentedCopy)
  {
    v4 = +[_UIRemoteKeyboards sharedRemoteKeyboards];
    v5 = [v4 vendKeyboardSuppressionAssertionForReason:@"Modal AutoFill UI"];

    objc_setAssociatedObject(object, &kAutoFillKeyboardSuppressionAssertionKey, v5, 1);
  }

  else
  {
    objc_setAssociatedObject(object, &kAutoFillKeyboardSuppressionAssertionKey, 0, 1);
  }
}

- (BOOL)shouldSuppressSelectionCommands
{
  m_shouldSuppressSelectionCommands = self->m_shouldSuppressSelectionCommands;
  if (m_shouldSuppressSelectionCommands)
  {
    self->m_shouldSuppressSelectionCommands = 0;
  }

  else if (self->m_isAutoFillMenuPresented)
  {
    [(_UIKeyboardStateManager *)self dismissAutoFillMenu];
  }

  return m_shouldSuppressSelectionCommands;
}

- (void)resumeDictationForResponderChange
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained resumeDictationForResponderChange];
}

- (BOOL)isSelecting
{
  if (self->m_selecting)
  {
    LOBYTE(v2) = 1;
  }

  else
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager selectedTextRange];
    v2 = [selectedTextRange isEmpty] ^ 1;
  }

  return v2;
}

- (void)_noteInlineCompletionAsMarkedText:(id)text
{
  textCopy = text;
  string = [textCopy string];
  v5 = [string length];

  if (v5)
  {
    v6 = [textCopy copy];
  }

  else
  {
    v6 = 0;
  }

  inlineCompletionAsMarkedText = self->_inlineCompletionAsMarkedText;
  self->_inlineCompletionAsMarkedText = v6;
}

- (void)handleGrammarCorrectionEntries:(id)entries
{
  entriesCopy = entries;
  if (+[UIKeyboard usesInputSystemUI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner forwardGrammarCorrectionEntries:entriesCopy];
  }

  else
  {
    [UITextChecker handleGrammarCorrectionEntries:entriesCopy];
  }
}

- (void)_setInputManager:(id)manager
{
  managerCopy = manager;
  v5 = sharedInputManagerMux();
  [v5 addClient:managerCopy];

  [(_UIKeyboardStateManager *)self syncInputManagerToKeyboardState];
}

- (void)updateFromTextInputTraits
{
  [(_UIKeyboardStateManager *)self takeTextInputTraitsFromDelegate];

  [(_UIKeyboardStateManager *)self updateReturnKey:1];
}

- (BOOL)_isShowingCandidateUIWithAvailableCandidates
{
  _UIDeviceNativeUserInterfaceIdiom();
  showsCandidateBar = [(_UIKeyboardStateManager *)self showsCandidateBar];
  if (showsCandidateBar)
  {
    m_candidateList = self->m_candidateList;

    LOBYTE(showsCandidateBar) = [(UIKeyboardCandidateList *)m_candidateList hasCandidates];
  }

  return showsCandidateBar;
}

- (void)_setAutofillGroup:(id)group
{
  groupCopy = group;
  [(_UIKeyboardStateManager *)self _clearAutofillGroup];
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  [autofillController performSelector:sel__setAutofillGroup_ withObject:groupCopy];
}

- (id)_autofillGroup
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  autofillGroup = [autofillController autofillGroup];

  return autofillGroup;
}

- (id)_fallbackAutofillGroup
{
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  fallbackAutofillGroup = [autofillController fallbackAutofillGroup];

  return fallbackAutofillGroup;
}

- (BOOL)_containsUsernamePasswordPairsInAutofillGroup:(id)group
{
  groupCopy = group;
  autofillController = [(_UIKeyboardStateManager *)self autofillController];
  v6 = [autofillController containsUsernamePasswordPairsInAutofillGroup:groupCopy];

  return v6;
}

- (BOOL)isSelectionChanging
{
  m_textInputChangingCount = self->m_textInputChangingCount;
  if (m_textInputChangingCount)
  {
    LOBYTE(m_textInputChangingCount) = !self->m_textInputChangesIgnored;
  }

  return m_textInputChangingCount & 1;
}

- (void)createTypoTrackerReport
{
  inputManager = [(_UIKeyboardStateManager *)self inputManager];
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = __50___UIKeyboardStateManager_createTypoTrackerReport__block_invoke;
  v4[3] = &unk_1E70FE168;
  v4[4] = self;
  [inputManager writeTypologyLogWithCompletionHandler:v4];
}

- (void)presentKeyboardFeedbackAssistantViewControllerForLogURL:(id)l
{
  lCopy = l;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained presentKeyboardFeedbackAssistantViewControllerForLogURL:lCopy];
}

- (void)_performInputViewControllerOutput:(id)output
{
  outputCopy = output;
  if (qword_1ED49D5A8 != -1)
  {
    dispatch_once(&qword_1ED49D5A8, &__block_literal_global_1938);
  }

  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  v8[0] = MEMORY[0x1E69E9820];
  v8[1] = 3221225472;
  v8[2] = __61___UIKeyboardStateManager__performInputViewControllerOutput___block_invoke_3;
  v8[3] = &unk_1E70FD1B8;
  v9 = outputCopy;
  selfCopy = self;
  v6 = qword_1ED49D5A0;
  v7 = outputCopy;
  [taskQueue addTask:v8 breadcrumb:v6];
}

- (void)_tagTouchForTypingMenu:(unsigned int)menu
{
  v3 = *&menu;
  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v4 = off_1ED49D600;
  v11 = off_1ED49D600;
  if (!off_1ED49D600)
  {
    v7[0] = MEMORY[0x1E69E9820];
    v7[1] = 3221225472;
    v7[2] = __getSBSTagTouchForTypingMenuSymbolLoc_block_invoke;
    v7[3] = &unk_1E70F2F20;
    v7[4] = &v8;
    __getSBSTagTouchForTypingMenuSymbolLoc_block_invoke(v7);
    v4 = v9[3];
  }

  _Block_object_dispose(&v8, 8);
  if (v4)
  {
    v4(v3);
  }

  else
  {
    currentHandler = [MEMORY[0x1E696AAA8] currentHandler];
    v6 = [MEMORY[0x1E696AEC0] stringWithUTF8String:"void UIKBSBSTagTouchForTypingMenu(uint32_t)"];
    [currentHandler handleFailureInFunction:v6 file:@"_UIKeyboardStateManager.m" lineNumber:245 description:{@"%s", dlerror()}];

    __break(1u);
  }
}

- (void)setInitialDirectionIgnoreRangeCheck:(BOOL)check
{
  checkCopy = check;
  v23[1] = *MEMORY[0x1E69E9840];
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  if (inputDelegate)
  {
    v6 = inputDelegate;
    if (checkCopy)
    {
    }

    else
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      selectedTextRange = [inputDelegateManager selectedTextRange];
      isEmpty = [selectedTextRange isEmpty];

      if (!isEmpty)
      {
        return;
      }
    }

    keyboardType = [(UITextInputTraits *)self->m_traits keyboardType];
    if (keyboardType > 0xB || ((1 << keyboardType) & 0x930) == 0)
    {
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      _characterBeforeCaretSelection = [inputDelegateManager2 _characterBeforeCaretSelection];

      if (_characterBeforeCaretSelection == 10 || !_characterBeforeCaretSelection)
      {
        inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
        _characterAfterCaretSelection = [inputDelegate2 _characterAfterCaretSelection];

        if ((_characterAfterCaretSelection == 10 || !_characterAfterCaretSelection) && !self->m_textInputChangingDirection)
        {
          self->m_textInputChangingDirection = 1;
          inputDelegateManager3 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          m_currentDirection = self->m_currentDirection;
          inputDelegateManager4 = [(_UIKeyboardStateManager *)self inputDelegateManager];
          selectedTextRange2 = [inputDelegateManager4 selectedTextRange];
          [inputDelegateManager3 setBaseWritingDirection:m_currentDirection forRange:selectedTextRange2];

          defaultCenter = [MEMORY[0x1E696AD88] defaultCenter];
          v22 = @"writingDirection";
          v20 = [MEMORY[0x1E696AD98] numberWithInteger:self->m_currentDirection];
          v23[0] = v20;
          v21 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v23 forKeys:&v22 count:1];
          [defaultCenter postNotificationName:0x1EFB79210 object:0 userInfo:v21];

          self->m_textInputChangingDirection = 0;
        }
      }
    }
  }
}

- (_UITextInteractionEditMenuAssistant)_editMenuAssistant
{
  textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
  _editMenuAssistant = [textInteractionAssistant _editMenuAssistant];

  return _editMenuAssistant;
}

- (void)traitCollectionDidChange
{
  [(_UIKeyboardStateManager *)self takeTextInputTraitsFromDelegate];
  activeLayout = [(_UIKeyboardStateManager *)self activeLayout];
  [activeLayout traitCollectionDidChange];

  if (+[UIKeyboard usesInputSystemUI](UIKeyboard, "usesInputSystemUI") || +[UIKeyboard usesInputSystemUIForAutoFillOnlyWithRTI])
  {
    remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
    [remoteTextInputPartner documentTraitsChanged];
  }
}

- (void)_dynamicUserInterfaceTraitDidChange
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  keyInputDelegate = [inputDelegateManager keyInputDelegate];

  if (([keyInputDelegate __isKindOfUIResponder] & 1) == 0)
  {
    delegateAsResponder = [(_UIKeyboardStateManager *)self delegateAsResponder];

    keyInputDelegate = delegateAsResponder;
  }

  if (keyInputDelegate)
  {
    v6 = (objc_opt_respondsToSelector() & 1) == 0 || [keyInputDelegate keyboardAppearance] == 10;
  }

  else
  {
    v6 = 1;
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  traitCollection = [WeakRetained traitCollection];
  userInterfaceStyle = [traitCollection userInterfaceStyle];

  if (v6)
  {
    m_traits = self->m_traits;
    if (m_traits)
    {
      if (userInterfaceStyle == 2)
      {
        v11 = 1;
      }

      else
      {
        v11 = 2;
      }

      [(UITextInputTraits *)m_traits setKeyboardAppearance:v11];
    }
  }
}

- (BOOL)allowsReachableKeyboard
{
  mainScreen = [objc_opt_self() mainScreen];
  [mainScreen _unjailedReferenceBounds];
  v5 = v4;

  _UIDeviceNativeUserInterfaceIdiom();
  v6 = UIKeyboardGetSafeDeviceIdiom() & 0xFFFFFFFFFFFFFFFBLL;
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  orientation = [layout orientation];

  result = 0;
  if (v6 != 1 && v5 > 320.0 && (orientation - 3) >= 2)
  {
    return ![(_UIKeyboardStateManager *)self keyboardIsKeyPad];
  }

  return result;
}

- (int64_t)currentHandBias
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  currentHandBias = [layout currentHandBias];

  return currentHandBias;
}

- (double)biasedKeyboardWidthRatio
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  [layout biasedKeyboardWidthRatio];
  v5 = v4;

  return v5;
}

- (void)acceptAutocorrectionAndEndComposition
{
  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  autocorrection = [autocorrectionController autocorrection];

  if (autocorrection)
  {

    [(_UIKeyboardStateManager *)self acceptAutocorrectionWithCompletionHandler:0];
  }

  else
  {

    [(_UIKeyboardStateManager *)self textAccepted:0];
  }
}

- (id)internationalKeyDisplayStringOnEmojiKeyboard
{
  v3 = +[UIKeyboardInputModeController sharedInputModeController];
  currentInputMode = [v3 currentInputMode];
  isExtensionInputMode = [currentInputMode isExtensionInputMode];

  if (isExtensionInputMode)
  {
    internationalKeyDisplayStringOnEmojiKeyboard = 0;
  }

  else
  {
    WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
    layout = [WeakRetained layout];
    internationalKeyDisplayStringOnEmojiKeyboard = [layout internationalKeyDisplayStringOnEmojiKeyboard];
  }

  return internationalKeyDisplayStringOnEmojiKeyboard;
}

- (id)_remoteAppId
{
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  documentTraits = [inputSystemSourceSession documentTraits];
  appId = [documentTraits appId];

  return appId;
}

- (id)_remoteLocalizedAppName
{
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  documentTraits = [inputSystemSourceSession documentTraits];
  localizedAppName = [documentTraits localizedAppName];

  return localizedAppName;
}

- (id)_remoteUnlocalizedAppName
{
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  documentTraits = [inputSystemSourceSession documentTraits];
  appName = [documentTraits appName];

  return appName;
}

- (id)_remoteAssociatedDomains
{
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  documentTraits = [inputSystemSourceSession documentTraits];
  associatedDomains = [documentTraits associatedDomains];

  return associatedDomains;
}

- (void)_deactiveActiveKeys
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  [layout deactivateActiveKeys];
}

- (void)performBlockWithTextInputChangesIgnoredForNonMacOS:(id)s
{
  m_textInputChangesIgnored = self->m_textInputChangesIgnored;
  self->m_textInputChangesIgnored = 1;
  (*(s + 2))(s, a2);
  self->m_textInputChangesIgnored = m_textInputChangesIgnored;
}

- (BOOL)exclusivityIdentifierMatched
{
  v3 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
  hardwareKeyboardExclusivityIdentifier = [v3 hardwareKeyboardExclusivityIdentifier];

  hardwareKeyboardExclusivityIdentifier2 = [(_UIKeyboardStateManager *)self hardwareKeyboardExclusivityIdentifier];
  if (hardwareKeyboardExclusivityIdentifier2 == hardwareKeyboardExclusivityIdentifier)
  {
    v7 = 1;
  }

  else
  {
    hardwareKeyboardExclusivityIdentifier3 = [(_UIKeyboardStateManager *)self hardwareKeyboardExclusivityIdentifier];
    v7 = [hardwareKeyboardExclusivityIdentifier isEqualToString:hardwareKeyboardExclusivityIdentifier3];
  }

  return v7;
}

- (BOOL)isShiftKeyBeingHeld
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  isHardwareShiftKeyBeingHeld = [objc_opt_class() isHardwareShiftKeyBeingHeld];

  LOBYTE(WeakRetained) = [(_UIKeyboardStateManager *)self callLayoutIsShiftKeyBeingHeld];
  return (isHardwareShiftKeyBeingHeld | WeakRetained | [(_UIKeyboardStateManager *)self _mimicShiftBeingHeld]) & 1;
}

- (void)lookUpResponderChainForCustomInputView
{
  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  inputSystemSourceSession = [inputDelegateManager inputSystemSourceSession];

  if (inputSystemSourceSession)
  {
    textOperations = [inputSystemSourceSession textOperations];
    [textOperations setEditingActionSelector:sel_lookUpResponderChainForCustomInputView];
    [inputSystemSourceSession flushOperations];
  }

  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  if (inputDelegate)
  {
    v6 = inputDelegate;
    while ((objc_opt_respondsToSelector() & 1) == 0)
    {
      nextResponder = [v6 nextResponder];

      v6 = nextResponder;
      if (!nextResponder)
      {
        goto LABEL_9;
      }
    }

    [v6 _showCustomInputView];
  }

LABEL_9:
}

- (id)attributedText
{
  inputDelegate = [(_UIKeyboardStateManager *)self inputDelegate];
  _textSelectingContainer = [inputDelegate _textSelectingContainer];
  v5 = objc_opt_respondsToSelector();

  inputDelegate2 = [(_UIKeyboardStateManager *)self inputDelegate];
  inputDelegate3 = inputDelegate2;
  if (v5)
  {
    _textSelectingContainer2 = [inputDelegate2 _textSelectingContainer];
    attributedText = [_textSelectingContainer2 attributedText];

LABEL_5:
    goto LABEL_7;
  }

  v10 = objc_opt_respondsToSelector();

  if (v10)
  {
    inputDelegate3 = [(_UIKeyboardStateManager *)self inputDelegate];
    attributedText = [inputDelegate3 attributedText];
    goto LABEL_5;
  }

  attributedText = 0;
LABEL_7:

  return attributedText;
}

- (void)showFirstTextAlternativeWithRangeAdjustment:(int64_t)adjustment
{
  location = self->m_textAlternativesRange.location;
  if (location != 0x7FFFFFFFFFFFFFFFLL)
  {
    self->m_textAlternativesRange.location = location - adjustment;
    attributedText = [(_UIKeyboardStateManager *)self attributedText];
    v6 = self->m_textAlternativesRange.length + self->m_textAlternativesRange.location;
    if (v6 <= [attributedText length])
    {
      v8 = self->m_textAlternativesRange.location;
      length = self->m_textAlternativesRange.length;
    }

    else
    {
      v7 = [attributedText length];
      v8 = self->m_textAlternativesRange.location;
      length = v7 - v8;
      if (v7 <= v8)
      {
        length = 0;
        self->m_textAlternativesRange.location = v7;
        self->m_textAlternativesRange.length = 0;
        v8 = v7;
      }

      else
      {
        self->m_textAlternativesRange.length = length;
      }
    }

    v13 = 0;
    v14 = &v13;
    v15 = 0x2020000000;
    v16 = length == 0;
    [attributedText enumerateAttribute:*off_1E70EC9F8 inRange:v8 options:? usingBlock:?];
    if (*(v14 + 24) == 1)
    {
      inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
      v11 = [inputDelegateManager _textRangeFromNSRange:{self->m_textAlternativesRange.location, self->m_textAlternativesRange.length}];
      inputDelegateManager2 = [(_UIKeyboardStateManager *)self inputDelegateManager];
      [inputDelegateManager2 setSelectedTextRange:v11];
    }

    _Block_object_dispose(&v13, 8);
  }
}

- (BOOL)callShouldInsertText:(id)text onDelegate:(id)delegate
{
  textCopy = text;
  delegateCopy = delegate;
  if ([delegateCopy conformsToProtocol:&unk_1EFE8A188])
  {
    v8 = delegateCopy;
  }

  else
  {
    v8 = 0;
  }

  v9 = v8;
  if ([delegateCopy conformsToProtocol:&unk_1EFE8B2D0])
  {
    v10 = delegateCopy;
  }

  else
  {
    v10 = 0;
  }

  v11 = v10;
  if (objc_opt_respondsToSelector())
  {
    v12 = [v9 keyboardInput:v9 shouldInsertText:textCopy isMarkedText:0];
  }

  else if (objc_opt_respondsToSelector())
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    selectedTextRange = [inputDelegateManager selectedTextRange];
    v12 = [v11 shouldChangeTextInRange:selectedTextRange replacementText:textCopy];
  }

  else
  {
    v12 = 1;
  }

  return v12;
}

- (BOOL)keyboardLayoutIsInAnotherProcess
{
  if (+[UIKeyboard usesInputSystemUI]&& [(_UIKeyboardStateManager *)self isRTIClient])
  {
    v3 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
    if ([v3 automaticAppearanceEnabled])
    {
      v4 = !+[UIKeyboard usesLocalKeyboard];
    }

    else
    {
      LOBYTE(v4) = 0;
    }
  }

  else
  {
    LOBYTE(v4) = 0;
  }

  return v4;
}

- (BOOL)shouldApplyKeyboardCommandToUIHost
{
  if (!self->m_hardwareKeyboardAttached)
  {
    return 0;
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  keyboardLayoutIsInAnotherProcess = [WeakRetained keyboardLayoutIsInAnotherProcess];

  return keyboardLayoutIsInAnotherProcess;
}

- (BOOL)shouldApplyKeyboardInputToUIHost
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  keyboardLayoutIsInAnotherProcess = [WeakRetained keyboardLayoutIsInAnotherProcess];

  return keyboardLayoutIsInAnotherProcess;
}

- (void)performKeyboardOutputOnInputSourceSession:(id)session shouldFlush:(BOOL)flush
{
  flushCopy = flush;
  sessionCopy = session;
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  if (sessionCopy && inputSystemSourceSession)
  {
    buildInputSourceState = [(_UIKeyboardStateManager *)self buildInputSourceState];
    textOperations = [inputSystemSourceSession textOperations];
    [textOperations setInputSourceState:buildInputSourceState];

    textOperations2 = [inputSystemSourceSession textOperations];
    keyboardOutput = [textOperations2 keyboardOutput];

    sessionCopy[2](sessionCopy, keyboardOutput);
    if (flushCopy)
    {
      [inputSystemSourceSession flushOperations];
    }
  }
}

- (void)flushKeyboardOutputOnInputSourceSession
{
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  if (inputSystemSourceSession)
  {
    v3 = inputSystemSourceSession;
    [inputSystemSourceSession flushOperations];
    inputSystemSourceSession = v3;
  }
}

- (void)performOnInputSourceSessionActionSelector:(SEL)selector
{
  inputSystemSourceSession = [(_UIKeyboardStateManager *)self inputSystemSourceSession];
  if (inputSystemSourceSession)
  {
    v6 = inputSystemSourceSession;
    textOperations = [inputSystemSourceSession textOperations];
    [textOperations setEditingActionSelector:selector];

    [v6 flushOperations];
    inputSystemSourceSession = v6;
  }
}

- (void)presentContinuousPathIntroductionView
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  [WeakRetained presentContinuousPathIntroductionView];
}

- (void)updateIdleDetection:(int64_t)detection
{
  if (+[UIKeyboard usesInputSystemUI])
  {

    [(_UIKeyboardStateManager *)self forwardDictationEvent_updateIdleDetection:detection];
  }

  else
  {
    self->m_userInteraction = detection;
    userInteractionDelegate = [(_UIKeyboardStateManager *)self userInteractionDelegate];

    if (userInteractionDelegate)
    {
      m_idleDetection = self->m_idleDetection;
      if (m_idleDetection)
      {
        [(UIDelayedAction *)m_idleDetection touch];
      }

      else
      {
        v7 = [[UIDelayedAction alloc] initWithTarget:self action:sel_handleIdleDetectionAction userInfo:0 delay:0.5];
        v8 = self->m_idleDetection;
        self->m_idleDetection = v7;
      }

      userInteractionDelegate2 = [(_UIKeyboardStateManager *)self userInteractionDelegate];
      [userInteractionDelegate2 beginUserInteraction:detection];
    }
  }
}

- (void)handleIdleDetectionAction
{
  [(_UIKeyboardStateManager *)self clearIdleDetectionAction];
  taskQueue = [(_UIKeyboardStateManager *)self taskQueue];
  if (![taskQueue isEmpty] || -[UIDelayedAction scheduled](self->m_longPressAction, "scheduled") || -[_UIKeyboardStateManager isAutoDeleteActive](self, "isAutoDeleteActive"))
  {
    goto LABEL_11;
  }

  usesCandidateSelection = [(_UIKeyboardStateManager *)self usesCandidateSelection];
  v6 = usesCandidateSelection;
  if (usesCandidateSelection)
  {
    inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
    if ([inputDelegateManager _hasMarkedText])
    {
      goto LABEL_10;
    }
  }

  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  if ([layout hasActiveContinuousPathInput])
  {
    goto LABEL_9;
  }

  textInteractionAssistant = [(_UIKeyboardStateManager *)self textInteractionAssistant];
  if ([textInteractionAssistant hasActiveSelectionInteraction])
  {

LABEL_9:
    if (!v6)
    {
LABEL_11:

LABEL_12:
      m_userInteraction = self->m_userInteraction;
      selfCopy2 = self;
LABEL_13:

      [(_UIKeyboardStateManager *)selfCopy2 updateIdleDetection:m_userInteraction];
      return;
    }

LABEL_10:

    goto LABEL_11;
  }

  isRotating = [(_UIKeyboardStateManager *)self isRotating];

  if (v6)
  {
  }

  if (isRotating)
  {
    goto LABEL_12;
  }

  taskQueue = objc_loadWeakRetained(&self->_presentationDelegate);
  inputDelegateManager = [taskQueue emojiPopoverController];
  layout2 = [inputDelegateManager layout];
  if ([layout2 hasActiveKeys])
  {

    goto LABEL_10;
  }

  v14 = objc_loadWeakRetained(&self->_presentationDelegate);
  isPressAndHoldPopoverPresented = [v14 isPressAndHoldPopoverPresented];

  if (isPressAndHoldPopoverPresented)
  {
    goto LABEL_12;
  }

  v16 = objc_loadWeakRetained(&self->_presentationDelegate);
  layout3 = [v16 layout];
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    v19 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout4 = [v19 layout];

    LODWORD(v19) = [layout4 hasActiveKeys];
    if (v19)
    {
      goto LABEL_12;
    }
  }

  if ([(_UIKeyboardStateManager *)self isTrackpadMode])
  {
    v21 = +[UIKeyboardInputMode dictationInputMode];
    usingTypeAndTalk = [v21 usingTypeAndTalk];

    if (usingTypeAndTalk)
    {
      selfCopy2 = self;
      m_userInteraction = 0;
      goto LABEL_13;
    }
  }

  userInteractionDelegate = [(_UIKeyboardStateManager *)self userInteractionDelegate];
  [userInteractionDelegate endUserInteraction];
}

- (void)clearIdleDetectionAction
{
  [(UIDelayedAction *)self->m_idleDetection cancel];
  m_idleDetection = self->m_idleDetection;
  self->m_idleDetection = 0;
}

- (void)forwardDictationEvent_switchToDictationInputModeWithOptions:(id)options
{
  optionsCopy = options;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v8 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v8, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v9 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_switchToDictationInputModeWithOptions____s_category) + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *v10 = 0;
      _os_log_impl(&dword_188A29000, v9, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v10, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_switchToDictationInputModeWithOptions_ withOptionalObject:optionsCopy];
}

- (void)forwardDictationEvent_handleDictationShouldPause:(BOOL)pause withNewDelagate:(BOOL)delagate
{
  delagateCopy = delagate;
  pauseCopy = pause;
  v17[2] = *MEMORY[0x1E69E9840];
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v8 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v8)
    {
      v13 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      {
        *v15 = 0;
        _os_log_fault_impl(&dword_188A29000, v13, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", v15, 2u);
      }
    }
  }

  else if (!v8)
  {
    v14 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_handleDictationShouldPause_withNewDelagate____s_category) + 8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *v15 = 0;
      _os_log_impl(&dword_188A29000, v14, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v15, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  v16[0] = @"shouldPause";
  v10 = [MEMORY[0x1E696AD98] numberWithBool:pauseCopy];
  v16[1] = @"withNewDelagate";
  v17[0] = v10;
  v11 = [MEMORY[0x1E696AD98] numberWithBool:delagateCopy];
  v17[1] = v11;
  v12 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v17 forKeys:v16 count:2];
  [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleDictationShouldPause_withNewDelagate_ withOptionalObject:v12];
}

- (void)forwardDictationEvent_switchToDictationLanguage:(id)language
{
  languageCopy = language;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v8 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v8, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v9 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_switchToDictationLanguage____s_category) + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *v10 = 0;
      _os_log_impl(&dword_188A29000, v9, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v10, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_switchToDictationLanguage_ withOptionalObject:languageCopy];
}

- (void)forwardDictationEvent_startDictation
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v4 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v4)
    {
      v6 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v6, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v4)
  {
    v7 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_startDictation___s_category) + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *v8 = 0;
      _os_log_impl(&dword_188A29000, v7, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v8, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_startDictation withOptionalObject:0];
}

- (void)forwardDictationEvent_stopDictation:(BOOL)dictation
{
  dictationCopy = dictation;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v9 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v9, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v10 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_stopDictation____s_category) + 8);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *v11 = 0;
      _os_log_impl(&dword_188A29000, v10, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v11, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  v8 = [MEMORY[0x1E696AD98] numberWithBool:dictationCopy];
  [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_stopDictation_ withOptionalObject:v8];
}

- (void)forwardDictationEvent_cancelDictation
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v4 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v4)
    {
      v6 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v6, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v4)
  {
    v7 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_cancelDictation___s_category) + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *v8 = 0;
      _os_log_impl(&dword_188A29000, v7, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v8, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_cancelDictation withOptionalObject:0];
}

- (void)forwardDictationEvent_movePopoverView:(id)view
{
  viewCopy = view;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v8 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v8, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v9 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_movePopoverView____s_category) + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *v10 = 0;
      _os_log_impl(&dword_188A29000, v9, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v10, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_movePopoverView_ withOptionalObject:viewCopy];
}

- (void)forwardDictationEvent_handleTip:(id)tip title:(id)title
{
  v17[2] = *MEMORY[0x1E69E9840];
  tipCopy = tip;
  titleCopy = title;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v9 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v9)
    {
      v13 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      {
        *v15 = 0;
        _os_log_fault_impl(&dword_188A29000, v13, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", v15, 2u);
      }
    }
  }

  else if (!v9)
  {
    v14 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_handleTip_title____s_category) + 8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *v15 = 0;
      _os_log_impl(&dword_188A29000, v14, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v15, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  v11 = remoteTextInputPartner;
  if (tipCopy)
  {
    v16[0] = @"text";
    v16[1] = @"title";
    v17[0] = tipCopy;
    v17[1] = titleCopy;
    v12 = [MEMORY[0x1E695DF20] dictionaryWithObjects:v17 forKeys:v16 count:2];
    [v11 forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_handleTip_ withOptionalObject:v12];
  }

  else
  {
    [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_handleTip_ withOptionalObject:0];
  }
}

- (void)forwardDictationEvent_updateIdleDetection:(int64_t)detection
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v10 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v10, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v11 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_updateIdleDetection____s_category) + 8);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *v12 = 0;
      _os_log_impl(&dword_188A29000, v11, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v12, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  v8 = [MEMORY[0x1E696AD98] numberWithInteger:detection];
  [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_updateIdleDetection_ withOptionalObject:v8];

  v9 = +[UIDictationController sharedInstance];
  [v9 insertLastHypothesisAsFinalResultLocally];
}

- (void)forwardDictationEvent_stopDictationIgnoreFinalizePhrases
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v4 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v4)
    {
      v6 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v6, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v4)
  {
    v7 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_stopDictationIgnoreFinalizePhrases___s_category) + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *v8 = 0;
      _os_log_impl(&dword_188A29000, v7, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v8, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_stopDictationIgnoreFinalizePhrases withOptionalObject:0];
}

- (void)forwardDictationEvent_resumeDictation
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v4 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v4)
    {
      v6 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v6, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v4)
  {
    v7 = *(__UILogGetCategoryCachedImpl("Assert", &forwardDictationEvent_resumeDictation___s_category) + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *v8 = 0;
      _os_log_impl(&dword_188A29000, v7, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v8, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  [remoteTextInputPartner forwardDictationEventToUIHost:sel_handleRemoteDictationEvent_resumeDictation withOptionalObject:0];
}

- (void)forwardKeyboardCameraEvent_startCameraInput:(id)input
{
  inputCopy = input;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v6 = +[UIKeyboard usesInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v6)
    {
      v8 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v8, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v6)
  {
    v9 = *(__UILogGetCategoryCachedImpl("Assert", &forwardKeyboardCameraEvent_startCameraInput____s_category) + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *v10 = 0;
      _os_log_impl(&dword_188A29000, v9, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v10, 2u);
    }
  }

  remoteTextInputPartner = [(_UIKeyboardStateManager *)self remoteTextInputPartner];
  [remoteTextInputPartner forwardKeyboardCameraEvent_startCameraInput:inputCopy];
}

- (void)forwardKeyboardCameraEvent_selfDestruct
{
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v4 = +[UIKeyboard isInputSystemUI];
  if (has_internal_diagnostics)
  {
    if (!v4)
    {
      v8 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v8, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v4)
  {
    v9 = *(__UILogGetCategoryCachedImpl("Assert", &forwardKeyboardCameraEvent_selfDestruct___s_category) + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *v10 = 0;
      _os_log_impl(&dword_188A29000, v9, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v10, 2u);
    }
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  inputSystemSourceSession = [inputDelegateManager inputSystemSourceSession];

  if (inputSystemSourceSession)
  {
    textOperations = [inputSystemSourceSession textOperations];
    [textOperations setEditingActionSelector:sel_handleRemoteKeyboardCameraEvent_selfDestruct];
    [inputSystemSourceSession flushOperations];
  }
}

- (void)forwardKeyboardCameraEvent_updatePreviewText:(id)text asMarkedText:(BOOL)markedText
{
  markedTextCopy = markedText;
  textCopy = text;
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  v8 = +[UIKeyboard isKeyboardProcess];
  if (has_internal_diagnostics)
  {
    if (!v8)
    {
      v15 = __UIFaultDebugAssertLog();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      {
        *buf = 0;
        _os_log_fault_impl(&dword_188A29000, v15, OS_LOG_TYPE_FAULT, "Unexpected forwarding event", buf, 2u);
      }
    }
  }

  else if (!v8)
  {
    v16 = *(__UILogGetCategoryCachedImpl("Assert", &forwardKeyboardCameraEvent_updatePreviewText_asMarkedText____s_category) + 8);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *v17 = 0;
      _os_log_impl(&dword_188A29000, v16, OS_LOG_TYPE_ERROR, "Unexpected forwarding event", v17, 2u);
    }
  }

  inputDelegateManager = [(_UIKeyboardStateManager *)self inputDelegateManager];
  inputSystemSourceSession = [inputDelegateManager inputSystemSourceSession];

  if (inputSystemSourceSession)
  {
    if (markedTextCopy)
    {
      textOperations3 = [MEMORY[0x1E69D9618] intermediateTextWithInputString:&stru_1EFB14550 displayString:textCopy];
      textOperations = [inputSystemSourceSession textOperations];
      [textOperations setIntermediateText:textOperations3];
    }

    else
    {
      v13 = [MEMORY[0x1E69D9618] intermediateTextWithInputString:&stru_1EFB14550 displayString:&stru_1EFB14550];
      textOperations2 = [inputSystemSourceSession textOperations];
      [textOperations2 setIntermediateText:v13];

      textOperations3 = [inputSystemSourceSession textOperations];
      textOperations = [textOperations3 keyboardOutput];
      [textOperations insertText:textCopy];
    }

    [inputSystemSourceSession flushOperations];
  }
}

- (id)_getCurrentKeyplaneName
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    v6 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v6 layout];
    keyplaneName = [layout2 keyplaneName];
  }

  else
  {
    keyplaneName = 0;
  }

  return keyplaneName;
}

- (id)_getCurrentKeyboardName
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    v6 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v6 layout];
    keyboardName = [layout2 keyboardName];
  }

  else
  {
    keyboardName = 0;
  }

  return keyboardName;
}

- (id)_getLocalizedInputMode
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  layout = [WeakRetained layout];
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    v6 = objc_loadWeakRetained(&self->_presentationDelegate);
    layout2 = [v6 layout];
    localizedInputMode = [layout2 localizedInputMode];
  }

  else
  {
    localizedInputMode = 0;
  }

  return localizedInputMode;
}

- (id)_getAutocorrection
{
  autocorrectionController = [(_UIKeyboardStateManager *)self autocorrectionController];
  autocorrection = [autocorrectionController autocorrection];
  candidate = [autocorrection candidate];

  return candidate;
}

- (id)_getAutocorrectionList
{
  v2 = +[UIKeyboardSceneDelegate activeKeyboardSceneDelegate];
  systemInputAssistantViewController = [v2 systemInputAssistantViewController];
  centerViewController = [systemInputAssistantViewController centerViewController];
  displayedCandidates = [centerViewController displayedCandidates];

  return displayedCandidates;
}

- (id)_getCandidateList
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);
  candidateController = [WeakRetained candidateController];
  candidates = [candidateController candidates];
  v4Candidates = [candidates candidates];

  return v4Candidates;
}

- (_UITextInputUserInteractionDelegate)userInteractionDelegate
{
  WeakRetained = objc_loadWeakRetained(&self->_userInteractionDelegate);

  return WeakRetained;
}

- (_UIKeyboardPresentationDelegate)presentationDelegate
{
  WeakRetained = objc_loadWeakRetained(&self->_presentationDelegate);

  return WeakRetained;
}

- (UIView)overlayContainerObserved
{
  WeakRetained = objc_loadWeakRetained(&self->_overlayContainerObserved);

  return WeakRetained;
}

@end