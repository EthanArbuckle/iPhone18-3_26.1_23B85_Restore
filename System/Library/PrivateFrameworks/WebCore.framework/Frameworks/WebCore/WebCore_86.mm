unint64_t maybe_add_words(int8x16_t *a1, unint64_t a2, const unint64_t *a3, int8x16_t *a4, unint64_t a5)
{
  if (!a5)
  {
    return 0;
  }

  if (a5 < 4)
  {
    v5 = 0;
    v6 = a5;
    v7 = a1;
    v8 = a4;
    do
    {
LABEL_17:
      v28 = *v7++;
      v27 = v28;
      v29 = *a3++;
      v12 = __CFADD__(v27, v29);
      v30 = v27 + v29;
      v31 = v12;
      v12 = __CFADD__(v30, v5);
      v32 = v30 + v5;
      if (v12)
      {
        v5 = 1;
      }

      else
      {
        v5 = v31;
      }

      *v8++ = v32;
      --v6;
    }

    while (v6);
    goto LABEL_24;
  }

  v5 = 0;
  v6 = a5;
  v7 = a1;
  v8 = a4;
  do
  {
    v10 = *v7 + *a3;
    v11 = __CFADD__(*v7, *a3);
    v12 = __CFADD__(v10, v5);
    v13 = v10 + v5;
    v14 = v12 || v11;
    v12 = v14 != 0;
    *v8 = v13;
    v15 = v7[1];
    v16 = a3[1];
    v18 = v12;
    v12 = __CFADD__(v12, v15);
    v17 = v18 + v15;
    v12 |= __CFADD__(v16, v17);
    v8[1] = v16 + v17;
    v19 = v7[2];
    v20 = a3[2];
    v22 = v12;
    v12 = __CFADD__(v12, v19);
    v21 = v22 + v19;
    v12 |= __CFADD__(v20, v21);
    v8[2] = v20 + v21;
    v23 = v7[3];
    v24 = a3[3];
    v26 = v12 + v23;
    v12 = __CFADD__(v12, v23) | __CFADD__(v24, v26);
    v25 = v24 + v26;
    v5 = v12;
    v8[3] = v25;
    v7 += 4;
    a3 += 4;
    v8 += 4;
    v6 -= 4;
  }

  while (v6 >= 4);
  if (v6)
  {
    goto LABEL_17;
  }

LABEL_24:
  v33 = ~a2;
  if (a5 >= 4 && ((a4 + 8 * a5) <= a1 || (a1 + 8 * a5) <= a4))
  {
    v40 = vdupq_n_s64(a2);
    v34 = a5 & 0xFFFFFFFFFFFFFFFCLL;
    v41 = vdupq_n_s64(v33);
    v42 = a4 + 1;
    v43 = a1 + 1;
    v44 = a5 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v45 = vorrq_s8(vandq_s8(*v43, v41), vandq_s8(*v42, v40));
      v43[-1] = vorrq_s8(vandq_s8(v43[-1], v41), vandq_s8(v42[-1], v40));
      *v43 = v45;
      v42 += 2;
      v43 += 2;
      v44 -= 4;
    }

    while (v44);
    if (v34 == a5)
    {
      return v5 & a2;
    }
  }

  else
  {
    v34 = 0;
  }

  v35 = a5 - v34;
  v36 = v34;
  v37 = a1 + v34;
  v38 = &a4->u64[v36];
  do
  {
    v39 = *v38++;
    *v37 = *v37 & v33 | v39 & a2;
    ++v37;
    --v35;
  }

  while (v35);
  return v5 & a2;
}

unint64_t bn_mul_add_words(unint64_t *rp, const unint64_t *ap, int num, unint64_t w)
{
  if (!*&num)
  {
    return 0;
  }

  if (*&num >= 4uLL)
  {
    v4 = 0;
    do
    {
      v6 = rp[1];
      v7 = __CFADD__(*rp, v4);
      v8 = *rp + v4;
      v9 = v7;
      v10 = __PAIR128__(v9, v8) + *ap * w;
      *rp = v10;
      v11 = ap[1];
      v12 = (v11 * w) >> 64;
      v13 = v11 * w;
      v7 = __CFADD__(v13, v6);
      v14 = v13 + v6;
      if (v7)
      {
        ++v12;
      }

      v7 = __CFADD__(v14, *(&v10 + 1));
      v15 = v14 + *(&v10 + 1);
      if (v7)
      {
        v16 = v12 + 1;
      }

      else
      {
        v16 = v12;
      }

      rp[1] = v15;
      v17 = ap[2];
      v18 = rp[2];
      v19 = rp[3];
      v7 = __CFADD__(v17 * w, v18);
      v20 = v17 * w + v18;
      v21 = (v17 * w) >> 64;
      if (v7)
      {
        ++v21;
      }

      v7 = __CFADD__(v20, v16);
      v22 = v20 + v16;
      if (v7)
      {
        ++v21;
      }

      rp[2] = v22;
      v23 = ap[3];
      v24 = (v23 * w) >> 64;
      v25 = v23 * w;
      v7 = __CFADD__(v25, v19);
      v26 = v25 + v19;
      if (v7)
      {
        ++v24;
      }

      v7 = __CFADD__(v26, v21);
      v27 = v26 + v21;
      if (v7)
      {
        v4 = v24 + 1;
      }

      else
      {
        v4 = v24;
      }

      rp[3] = v27;
      ap += 4;
      rp += 4;
      *&num -= 4;
    }

    while (*&num >= 4uLL);
    if (!*&num)
    {
      return v4;
    }
  }

  else
  {
    v4 = 0;
  }

  do
  {
    v28 = *ap++;
    v29 = (w * v28) >> 64;
    v30 = w * v28;
    v7 = __CFADD__(*rp, v4);
    v31 = *rp + v4;
    v32 = v7;
    v33 = __PAIR128__(v32, v31) + __PAIR128__(v29, v30);
    v4 = (__PAIR128__(v32, v31) + __PAIR128__(v29, v30)) >> 64;
    *rp++ = v33;
    --*&num;
  }

  while (*&num);
  return v4;
}

void *bn_sqr_add_words(void *result, unint64_t *a2, unint64_t a3)
{
  if (!a3)
  {
    return result;
  }

  if (a3 < 4)
  {
    v3 = 0;
    do
    {
LABEL_16:
      v38 = *a2++;
      v37 = v38;
      v39 = result[1];
      v40 = *result + v37 * v37;
      v41 = __CFADD__(*result, v37 * v37);
      v8 = __CFADD__(v40, v3);
      v42 = v40 + v3;
      v43 = (v37 * v37) >> 64;
      v44 = v8 || v41;
      v8 = __CFADD__(v44 != 0, v39);
      v45 = (v44 != 0) + v39;
      v8 |= __CFADD__(v43, v45);
      v45 += v43;
      v3 = v8;
      *result = v42;
      result[1] = v45;
      result += 2;
      --a3;
    }

    while (a3);
    return result;
  }

  v3 = 0;
  do
  {
    v4 = *a2;
    v5 = result[1];
    v6 = *result + v4 * v4;
    v7 = __CFADD__(*result, v4 * v4);
    v8 = __CFADD__(v6, v3);
    v9 = v6 + v3;
    v10 = (v4 * v4) >> 64;
    v11 = v8 || v7;
    v8 = __CFADD__(v11 != 0, v5) | __CFADD__(v10, (v11 != 0) + v5);
    *result = v9;
    result[1] = v10 + (v11 != 0) + v5;
    v12 = a2[1];
    v13 = (v12 * v12) >> 64;
    v14 = v12 * v12;
    v15 = result[2];
    v16 = result[3];
    v18 = v8 + v15;
    v8 = __CFADD__(v8, v15) | __CFADD__(v14, v18);
    v17 = v14 + v18;
    v19 = v8 + v16;
    v8 = __CFADD__(v8, v16) | __CFADD__(v13, v19);
    result[2] = v17;
    result[3] = v13 + v19;
    v20 = a2[2];
    v21 = (v20 * v20) >> 64;
    v22 = v20 * v20;
    v23 = result[4];
    v24 = result[5];
    v26 = v8 + v23;
    v8 = __CFADD__(v8, v23) | __CFADD__(v22, v26);
    v25 = v22 + v26;
    v27 = v8 + v24;
    v8 = __CFADD__(v8, v24) | __CFADD__(v21, v27);
    result[4] = v25;
    result[5] = v21 + v27;
    v28 = a2[3];
    v29 = (v28 * v28) >> 64;
    v30 = v28 * v28;
    v31 = result[6];
    v32 = result[7];
    v34 = v8;
    v8 = __CFADD__(v8, v31);
    v33 = v34 + v31;
    v8 |= __CFADD__(v30, v33);
    v33 += v30;
    v36 = v8 + v32;
    v8 = __CFADD__(v8, v32) | __CFADD__(v29, v36);
    v35 = v29 + v36;
    v3 = v8;
    result[6] = v33;
    result[7] = v35;
    a2 += 4;
    result += 8;
    a3 -= 4;
  }

  while (a3 >= 4);
  if (a3)
  {
    goto LABEL_16;
  }

  return result;
}

void *bn_mul_comba8(void *result, unint64_t *a2, unint64_t *a3)
{
  v4 = *a3;
  v5 = *a2;
  v3 = (*a3 * v5) >> 64;
  *result = *a3 * *a2;
  v6 = a2[1];
  v8 = *a3;
  v7 = a3[1];
  v9 = (__PAIR128__(v7, v4) * v5) >> 64;
  if (__CFADD__(v7 * *a2, v3))
  {
    v10 = ((v7 * *a2) >> 64) + 1;
  }

  else
  {
    v10 = (v7 * *a2) >> 64;
  }

  v11 = (v8 * v6) >> 64;
  v12 = v8 * v6;
  v13 = __CFADD__(v12, v9);
  v14 = v12 + v9;
  if (v13)
  {
    v15 = v11 + 1;
  }

  else
  {
    v15 = v11;
  }

  result[1] = v14;
  v16 = a2[2];
  v17 = a3[1];
  v18 = (*a3 * v16) >> 64;
  v19 = *a3 * v16;
  v13 = __CFADD__(v19, v15 + v10);
  v20 = v19 + v15 + v10;
  if (v13)
  {
    v21 = v18 + 1;
  }

  else
  {
    v21 = v18;
  }

  v13 = __CFADD__(__CFADD__(v15, v10), v21);
  v22 = __CFADD__(v15, v10) + v21;
  v23 = v13;
  v25 = *a2;
  v24 = a2[1];
  v26 = (v17 * v24) >> 64;
  v27 = v17 * v24;
  v13 = __CFADD__(v20, v27);
  v28 = v20 + v27;
  if (v13)
  {
    v29 = v26 + 1;
  }

  else
  {
    v29 = v26;
  }

  v13 = __CFADD__(v22, v29);
  v30 = v22 + v29;
  v31 = v13;
  v32 = a3[2];
  v33 = (v32 * v25) >> 64;
  v34 = v32 * v25;
  v13 = __CFADD__(v28, v34);
  v35 = v28 + v34;
  if (v13)
  {
    v36 = v33 + 1;
  }

  else
  {
    v36 = v33;
  }

  v13 = __CFADD__(v30, v36);
  v37 = v30 + v36;
  v38 = v23 + v13 + v31;
  result[2] = v35;
  v39 = a2[1];
  v41 = a3[2];
  v40 = a3[3];
  v42 = v40 * *a2;
  v13 = __CFADD__(v42, v37);
  v43 = v42 + v37;
  if (v13)
  {
    v44 = ((v40 * *a2) >> 64) + 1;
  }

  else
  {
    v44 = (v40 * *a2) >> 64;
  }

  v45 = v38 + v44;
  v46 = (v41 * v39) >> 64;
  v47 = v41 * v39;
  v13 = __CFADD__(v43, v47);
  v48 = v43 + v47;
  if (v13)
  {
    v49 = v46 + 1;
  }

  else
  {
    v49 = v46;
  }

  v13 = __CFADD__(v45, v49);
  v50 = v45 + v49;
  v51 = v13;
  if (__CFADD__(v38, v44))
  {
    v52 = v51 + 1;
  }

  else
  {
    v52 = v51;
  }

  v53 = a2[2];
  v54 = a2[3];
  v56 = *a3;
  v55 = a3[1];
  v57 = (v55 * v53) >> 64;
  v58 = v55 * v53;
  v13 = __CFADD__(v48, v58);
  v59 = v48 + v58;
  if (v13)
  {
    v60 = v57 + 1;
  }

  else
  {
    v60 = v57;
  }

  v13 = __CFADD__(v50, v60);
  v61 = v50 + v60;
  v62 = v13;
  v63 = (v56 * v54) >> 64;
  v64 = v56 * v54;
  v13 = __CFADD__(v59, v64);
  v65 = v59 + v64;
  if (v13)
  {
    v66 = v63 + 1;
  }

  else
  {
    v66 = v63;
  }

  v67 = __PAIR128__(v52, v61) + __PAIR128__(v62, v66);
  result[3] = v65;
  v68 = a3[1];
  v69 = *a3 * a2[4] + v67;
  v70 = *(&v67 + 1) + v67;
  v71 = __CFADD__(*(&v67 + 1), v67);
  v73 = a2[2];
  v72 = a2[3];
  v74 = (v68 * v72) >> 64;
  v75 = v68 * v72;
  v13 = __CFADD__(v69, v75);
  v76 = v69 + v75;
  if (v13)
  {
    v77 = v74 + 1;
  }

  else
  {
    v77 = v74;
  }

  v13 = __CFADD__(v70, v77);
  v78 = v70 + v77;
  v79 = v13;
  v80 = a3[2];
  v81 = a3[3];
  v82 = (v80 * v73) >> 64;
  v83 = v80 * v73;
  v13 = __CFADD__(v76, v83);
  v84 = v76 + v83;
  if (v13)
  {
    v85 = v82 + 1;
  }

  else
  {
    v85 = v82;
  }

  v13 = __CFADD__(v78, v85);
  v86 = v78 + v85;
  v87 = v71 + v13 + v79;
  v89 = *a2;
  v88 = a2[1];
  v90 = (v81 * v88) >> 64;
  v91 = v81 * v88;
  v13 = __CFADD__(v84, v91);
  v92 = v84 + v91;
  if (v13)
  {
    v93 = v90 + 1;
  }

  else
  {
    v93 = v90;
  }

  v13 = __CFADD__(v86, v93);
  v94 = v86 + v93;
  v95 = v13;
  v96 = a3[4];
  v97 = (v96 * v89) >> 64;
  v98 = v96 * v89;
  v13 = __CFADD__(v92, v98);
  v99 = v92 + v98;
  if (v13)
  {
    v100 = v97 + 1;
  }

  else
  {
    v100 = v97;
  }

  v101 = __PAIR128__(v87, v94) + __PAIR128__(v95, v100);
  result[4] = v99;
  v102 = a2[1];
  v103 = a3[4];
  v104 = a3[5] * *a2 + v101;
  v105 = *(&v101 + 1) + v101;
  v106 = (v103 * v102) >> 64;
  v107 = v103 * v102;
  v13 = __CFADD__(v104, v107);
  v108 = v104 + v107;
  if (v13)
  {
    v109 = v106 + 1;
  }

  else
  {
    v109 = v106;
  }

  v13 = __CFADD__(v105, v109);
  v110 = v105 + v109;
  v111 = v13;
  if (__CFADD__(*(&v101 + 1), v101))
  {
    v112 = v111 + 1;
  }

  else
  {
    v112 = v111;
  }

  v113 = a2[2];
  v114 = a2[3];
  v116 = a3[2];
  v115 = a3[3];
  v117 = (v115 * v113) >> 64;
  v118 = v115 * v113;
  v13 = __CFADD__(v108, v118);
  v119 = v108 + v118;
  if (v13)
  {
    v120 = v117 + 1;
  }

  else
  {
    v120 = v117;
  }

  v13 = __CFADD__(v110, v120);
  v121 = v110 + v120;
  v122 = v13;
  v123 = (v116 * v114) >> 64;
  v124 = v116 * v114;
  v13 = __CFADD__(v119, v124);
  v125 = v119 + v124;
  if (v13)
  {
    v126 = v123 + 1;
  }

  else
  {
    v126 = v123;
  }

  v127 = __PAIR128__(v112, v121) + __PAIR128__(v122, v126);
  v128 = a2[4];
  v129 = a2[5];
  v131 = *a3;
  v130 = a3[1];
  v132 = (v130 * v128) >> 64;
  v133 = v130 * v128;
  v13 = __CFADD__(v125, v133);
  v134 = v125 + v133;
  if (v13)
  {
    v135 = v132 + 1;
  }

  else
  {
    v135 = v132;
  }

  v136 = __CFADD__(v127, v135);
  v137 = (v131 * v129) >> 64;
  v138 = v131 * v129;
  v13 = __CFADD__(v134, v138);
  v139 = v134 + v138;
  if (v13)
  {
    v140 = v137 + 1;
  }

  else
  {
    v140 = v137;
  }

  v141 = v127 + __PAIR128__(v136, v140);
  result[5] = v139;
  v142 = a3[1];
  v143 = *a3 * a2[6] + v141;
  v144 = *(&v141 + 1) + v141;
  v145 = __CFADD__(*(&v141 + 1), v141);
  v147 = a2[4];
  v146 = a2[5];
  v148 = (v142 * v146) >> 64;
  v149 = v142 * v146;
  v13 = __CFADD__(v143, v149);
  v150 = v143 + v149;
  if (v13)
  {
    v151 = v148 + 1;
  }

  else
  {
    v151 = v148;
  }

  v13 = __CFADD__(v144, v151);
  v152 = v144 + v151;
  v153 = v13;
  v154 = a3[2];
  v155 = a3[3];
  v156 = (v154 * v147) >> 64;
  v157 = v154 * v147;
  v13 = __CFADD__(v150, v157);
  v158 = v150 + v157;
  if (v13)
  {
    v159 = v156 + 1;
  }

  else
  {
    v159 = v156;
  }

  v13 = __CFADD__(v152, v159);
  v160 = v152 + v159;
  v161 = v145 + v13 + v153;
  v163 = a2[2];
  v162 = a2[3];
  v164 = (v155 * v162) >> 64;
  v165 = v155 * v162;
  v13 = __CFADD__(v158, v165);
  v166 = v158 + v165;
  if (v13)
  {
    v167 = v164 + 1;
  }

  else
  {
    v167 = v164;
  }

  v13 = __CFADD__(v160, v167);
  v168 = v160 + v167;
  v169 = v13;
  v170 = a3[4];
  v171 = a3[5];
  v172 = (v170 * v163) >> 64;
  v173 = v170 * v163;
  v13 = __CFADD__(v166, v173);
  v174 = v166 + v173;
  if (v13)
  {
    v175 = v172 + 1;
  }

  else
  {
    v175 = v172;
  }

  v176 = __PAIR128__(v161, v168) + __PAIR128__(v169, v175);
  v178 = *a2;
  v177 = a2[1];
  v179 = (v171 * v177) >> 64;
  v180 = v171 * v177;
  v13 = __CFADD__(v174, v180);
  v181 = v174 + v180;
  if (v13)
  {
    v182 = v179 + 1;
  }

  else
  {
    v182 = v179;
  }

  v183 = __CFADD__(v176, v182);
  v184 = a3[6];
  v185 = (v184 * v178) >> 64;
  v186 = v184 * v178;
  v13 = __CFADD__(v181, v186);
  v187 = v181 + v186;
  if (v13)
  {
    v188 = v185 + 1;
  }

  else
  {
    v188 = v185;
  }

  v189 = v176 + __PAIR128__(v183, v188);
  result[6] = v187;
  v190 = a2[1];
  v191 = a3[6];
  v192 = a3[7] * *a2 + v189;
  v193 = *(&v189 + 1) + v189;
  v194 = (v191 * v190) >> 64;
  v195 = v191 * v190;
  v13 = __CFADD__(v192, v195);
  v196 = v192 + v195;
  if (v13)
  {
    v197 = v194 + 1;
  }

  else
  {
    v197 = v194;
  }

  v13 = __CFADD__(v193, v197);
  v198 = v193 + v197;
  v199 = v13;
  if (__CFADD__(*(&v189 + 1), v189))
  {
    v200 = v199 + 1;
  }

  else
  {
    v200 = v199;
  }

  v201 = a2[2];
  v202 = a2[3];
  v204 = a3[4];
  v203 = a3[5];
  v205 = (v203 * v201) >> 64;
  v206 = v203 * v201;
  v13 = __CFADD__(v196, v206);
  v207 = v196 + v206;
  if (v13)
  {
    v208 = v205 + 1;
  }

  else
  {
    v208 = v205;
  }

  v13 = __CFADD__(v198, v208);
  v209 = v198 + v208;
  v210 = v13;
  v211 = (v204 * v202) >> 64;
  v212 = v204 * v202;
  v13 = __CFADD__(v207, v212);
  v213 = v207 + v212;
  if (v13)
  {
    v214 = v211 + 1;
  }

  else
  {
    v214 = v211;
  }

  v215 = __PAIR128__(v200, v209) + __PAIR128__(v210, v214);
  v216 = a2[4];
  v217 = a2[5];
  v219 = a3[2];
  v218 = a3[3];
  v220 = (v218 * v216) >> 64;
  v221 = v218 * v216;
  v13 = __CFADD__(v213, v221);
  v222 = v213 + v221;
  if (v13)
  {
    v223 = v220 + 1;
  }

  else
  {
    v223 = v220;
  }

  v224 = __CFADD__(v215, v223);
  v225 = (v219 * v217) >> 64;
  v226 = v219 * v217;
  v13 = __CFADD__(v222, v226);
  v227 = v222 + v226;
  if (v13)
  {
    v228 = v225 + 1;
  }

  else
  {
    v228 = v225;
  }

  v229 = v215 + __PAIR128__(v224, v228);
  v230 = a2[6];
  v231 = a2[7];
  v233 = *a3;
  v232 = a3[1];
  v234 = (v232 * v230) >> 64;
  v235 = v232 * v230;
  v13 = __CFADD__(v227, v235);
  v236 = v227 + v235;
  if (v13)
  {
    v237 = v234 + 1;
  }

  else
  {
    v237 = v234;
  }

  v238 = __CFADD__(v229, v237);
  v239 = (v233 * v231) >> 64;
  v240 = v233 * v231;
  v13 = __CFADD__(v236, v240);
  v241 = v236 + v240;
  if (v13)
  {
    v242 = v239 + 1;
  }

  else
  {
    v242 = v239;
  }

  v243 = v229 + __PAIR128__(v238, v242);
  result[7] = v241;
  v244 = a3[2];
  v245 = a3[1] * a2[7] + v243;
  v246 = *(&v243 + 1) + v243;
  v247 = __CFADD__(*(&v243 + 1), v243);
  v249 = a2[5];
  v248 = a2[6];
  v250 = (v244 * v248) >> 64;
  v251 = v244 * v248;
  v13 = __CFADD__(v245, v251);
  v252 = v245 + v251;
  if (v13)
  {
    v253 = v250 + 1;
  }

  else
  {
    v253 = v250;
  }

  v13 = __CFADD__(v246, v253);
  v254 = v246 + v253;
  v255 = v13;
  v256 = a3[3];
  v257 = a3[4];
  v258 = (v256 * v249) >> 64;
  v259 = v256 * v249;
  v13 = __CFADD__(v252, v259);
  v260 = v252 + v259;
  if (v13)
  {
    v261 = v258 + 1;
  }

  else
  {
    v261 = v258;
  }

  v13 = __CFADD__(v254, v261);
  v262 = v254 + v261;
  v263 = v247 + v13 + v255;
  v265 = a2[3];
  v264 = a2[4];
  v266 = (v257 * v264) >> 64;
  v267 = v257 * v264;
  v13 = __CFADD__(v260, v267);
  v268 = v260 + v267;
  if (v13)
  {
    v269 = v266 + 1;
  }

  else
  {
    v269 = v266;
  }

  v13 = __CFADD__(v262, v269);
  v270 = v262 + v269;
  v271 = v13;
  v272 = a3[5];
  v273 = a3[6];
  v274 = (v272 * v265) >> 64;
  v275 = v272 * v265;
  v13 = __CFADD__(v268, v275);
  v276 = v268 + v275;
  if (v13)
  {
    v277 = v274 + 1;
  }

  else
  {
    v277 = v274;
  }

  v278 = __PAIR128__(v263, v270) + __PAIR128__(v271, v277);
  v280 = a2[1];
  v279 = a2[2];
  v281 = (v273 * v279) >> 64;
  v282 = v273 * v279;
  v13 = __CFADD__(v276, v282);
  v283 = v276 + v282;
  if (v13)
  {
    v284 = v281 + 1;
  }

  else
  {
    v284 = v281;
  }

  v285 = __CFADD__(v278, v284);
  v286 = a3[7];
  v287 = (v286 * v280) >> 64;
  v288 = v286 * v280;
  v13 = __CFADD__(v283, v288);
  v289 = v283 + v288;
  if (v13)
  {
    v290 = v287 + 1;
  }

  else
  {
    v290 = v287;
  }

  v291 = v278 + __PAIR128__(v285, v290);
  result[8] = v289;
  v292 = a2[3];
  v293 = a3[6];
  v294 = a3[7] * a2[2] + v291;
  v295 = *(&v291 + 1) + v291;
  v296 = (v293 * v292) >> 64;
  v297 = v293 * v292;
  v13 = __CFADD__(v294, v297);
  v298 = v294 + v297;
  if (v13)
  {
    v299 = v296 + 1;
  }

  else
  {
    v299 = v296;
  }

  v13 = __CFADD__(v295, v299);
  v300 = v295 + v299;
  v301 = v13;
  if (__CFADD__(*(&v291 + 1), v291))
  {
    v302 = v301 + 1;
  }

  else
  {
    v302 = v301;
  }

  v303 = a2[4];
  v304 = a2[5];
  v306 = a3[4];
  v305 = a3[5];
  v307 = (v305 * v303) >> 64;
  v308 = v305 * v303;
  v13 = __CFADD__(v298, v308);
  v309 = v298 + v308;
  if (v13)
  {
    v310 = v307 + 1;
  }

  else
  {
    v310 = v307;
  }

  v13 = __CFADD__(v300, v310);
  v311 = v300 + v310;
  v312 = v13;
  v313 = (v306 * v304) >> 64;
  v314 = v306 * v304;
  v13 = __CFADD__(v309, v314);
  v315 = v309 + v314;
  if (v13)
  {
    v316 = v313 + 1;
  }

  else
  {
    v316 = v313;
  }

  v317 = __PAIR128__(v302, v311) + __PAIR128__(v312, v316);
  v318 = a2[6];
  v319 = a2[7];
  v321 = a3[2];
  v320 = a3[3];
  v322 = (v320 * v318) >> 64;
  v323 = v320 * v318;
  v13 = __CFADD__(v315, v323);
  v324 = v315 + v323;
  if (v13)
  {
    v325 = v322 + 1;
  }

  else
  {
    v325 = v322;
  }

  v326 = __CFADD__(v317, v325);
  v327 = (v321 * v319) >> 64;
  v328 = v321 * v319;
  v13 = __CFADD__(v324, v328);
  v329 = v324 + v328;
  if (v13)
  {
    v330 = v327 + 1;
  }

  else
  {
    v330 = v327;
  }

  v331 = v317 + __PAIR128__(v326, v330);
  result[9] = v329;
  v332 = a3[4];
  v333 = a3[3] * a2[7] + v331;
  v334 = *(&v331 + 1) + v331;
  v335 = __CFADD__(*(&v331 + 1), v331);
  v337 = a2[5];
  v336 = a2[6];
  v338 = (v332 * v336) >> 64;
  v339 = v332 * v336;
  v13 = __CFADD__(v333, v339);
  v340 = v333 + v339;
  if (v13)
  {
    v341 = v338 + 1;
  }

  else
  {
    v341 = v338;
  }

  v13 = __CFADD__(v334, v341);
  v342 = v334 + v341;
  v343 = v13;
  v344 = a3[5];
  v345 = a3[6];
  v346 = (v344 * v337) >> 64;
  v347 = v344 * v337;
  v13 = __CFADD__(v340, v347);
  v348 = v340 + v347;
  if (v13)
  {
    v349 = v346 + 1;
  }

  else
  {
    v349 = v346;
  }

  v13 = __CFADD__(v342, v349);
  v350 = v342 + v349;
  v351 = v335 + v13 + v343;
  v353 = a2[3];
  v352 = a2[4];
  v354 = (v345 * v352) >> 64;
  v355 = v345 * v352;
  v13 = __CFADD__(v348, v355);
  v356 = v348 + v355;
  if (v13)
  {
    v357 = v354 + 1;
  }

  else
  {
    v357 = v354;
  }

  v13 = __CFADD__(v350, v357);
  v358 = v350 + v357;
  v359 = v13;
  v360 = a3[7];
  v361 = (v360 * v353) >> 64;
  v362 = v360 * v353;
  v13 = __CFADD__(v356, v362);
  v363 = v356 + v362;
  if (v13)
  {
    v364 = v361 + 1;
  }

  else
  {
    v364 = v361;
  }

  v365 = __PAIR128__(v351, v358) + __PAIR128__(v359, v364);
  result[10] = v363;
  v366 = a2[5];
  v367 = a3[6];
  v368 = a3[7] * a2[4] + v365;
  v369 = *(&v365 + 1) + v365;
  v370 = (v367 * v366) >> 64;
  v371 = v367 * v366;
  v13 = __CFADD__(v368, v371);
  v372 = v368 + v371;
  if (v13)
  {
    v373 = v370 + 1;
  }

  else
  {
    v373 = v370;
  }

  v13 = __CFADD__(v369, v373);
  v374 = v369 + v373;
  v375 = v13;
  v376 = a2[6];
  v377 = a2[7];
  v379 = a3[4];
  v378 = a3[5];
  v380 = (v378 * v376) >> 64;
  v381 = v378 * v376;
  if (__CFADD__(*(&v365 + 1), v365))
  {
    ++v375;
  }

  v13 = __CFADD__(v372, v381);
  v382 = v372 + v381;
  if (v13)
  {
    v383 = v380 + 1;
  }

  else
  {
    v383 = v380;
  }

  v13 = __CFADD__(v374, v383);
  v384 = v374 + v383;
  v385 = v13;
  v386 = (v379 * v377) >> 64;
  v387 = v379 * v377;
  v13 = __CFADD__(v382, v387);
  v388 = v382 + v387;
  if (v13)
  {
    v389 = v386 + 1;
  }

  else
  {
    v389 = v386;
  }

  v390 = __PAIR128__(v375, v384) + __PAIR128__(v385, v389);
  result[11] = v388;
  v391 = a3[6];
  v392 = a3[5] * a2[7] + v390;
  v393 = *(&v390 + 1) + v390;
  v394 = __CFADD__(*(&v390 + 1), v390);
  v396 = a2[5];
  v395 = a2[6];
  v397 = (v391 * v395) >> 64;
  v398 = v391 * v395;
  v13 = __CFADD__(v392, v398);
  v399 = v392 + v398;
  if (v13)
  {
    v400 = v397 + 1;
  }

  else
  {
    v400 = v397;
  }

  v13 = __CFADD__(v393, v400);
  v401 = v393 + v400;
  v402 = v13;
  v403 = a3[7];
  v404 = (v403 * v396) >> 64;
  v405 = v403 * v396;
  v13 = __CFADD__(v399, v405);
  v406 = v399 + v405;
  if (v13)
  {
    v407 = v404 + 1;
  }

  else
  {
    v407 = v404;
  }

  v13 = __CFADD__(v401, v407);
  v408 = v401 + v407;
  v409 = v394 + v13 + v402;
  result[12] = v406;
  v410 = a2[6];
  v411 = a2[7];
  v413 = a3[6];
  v412 = a3[7];
  v414 = (v412 * v410) >> 64;
  v415 = v412 * v410;
  v13 = __CFADD__(v415, v408);
  v416 = v415 + v408;
  if (v13)
  {
    v417 = v414 + 1;
  }

  else
  {
    v417 = v414;
  }

  v418 = v409 + v417;
  v419 = (v413 * v411) >> 64;
  v420 = v413 * v411;
  v13 = __CFADD__(v416, v420);
  v421 = v416 + v420;
  if (v13)
  {
    v422 = v419 + 1;
  }

  else
  {
    v422 = v419;
  }

  v13 = __CFADD__(v418, v422);
  v423 = v418 + v422;
  v424 = v13;
  result[13] = v421;
  v425 = a2[7];
  v426 = a3[7];
  v427 = (v426 * v425) >> 64;
  v428 = v426 * v425;
  v13 = __CFADD__(v428, v423);
  v429 = v428 + v423;
  if (v13)
  {
    v430 = v427 + 1;
  }

  else
  {
    v430 = v427;
  }

  result[14] = v429;
  result[15] = v424 + __CFADD__(v409, v417) + v430;
  return result;
}

void *bn_sqr_comba8(void *result, unint64_t *a2)
{
  v2 = (*a2 * *a2) >> 64;
  *result = *a2 * *a2;
  v3 = a2[1];
  v4 = (*a2 * v3) >> 64;
  v5 = *a2 * v3;
  v6 = __CFADD__(v5, v2);
  v7 = v5 + v2;
  if (v6)
  {
    v8 = v4 + 1;
  }

  else
  {
    v8 = v4;
  }

  v6 = __CFADD__(v7, v5);
  v9 = v7 + v5;
  if (v6)
  {
    v10 = v4 + 1;
  }

  else
  {
    v10 = v4;
  }

  result[1] = v9;
  v12 = *a2;
  v11 = a2[1];
  v13 = (v11 * v11) >> 64;
  v14 = v11 * v11;
  v6 = __CFADD__(v14, v10 + v8);
  v15 = v14 + v10 + v8;
  if (v6)
  {
    v16 = v13 + 1;
  }

  else
  {
    v16 = v13;
  }

  v6 = __CFADD__(__CFADD__(v10, v8), v16);
  v17 = __CFADD__(v10, v8) + v16;
  v18 = v6;
  v19 = a2[2];
  v20 = (v12 * v19) >> 64;
  v21 = v12 * v19;
  v6 = __CFADD__(v15, v21);
  v22 = v15 + v21;
  if (v6)
  {
    v23 = v20 + 1;
  }

  else
  {
    v23 = v20;
  }

  v6 = __CFADD__(v17, v23);
  v24 = v17 + v23;
  v25 = v6;
  v6 = __CFADD__(v22, v21);
  v26 = v22 + v21;
  if (v6)
  {
    v27 = v20 + 1;
  }

  else
  {
    v27 = v20;
  }

  v6 = __CFADD__(v24, v27);
  v28 = v24 + v27;
  v29 = v18 + v6 + v25;
  result[2] = v26;
  v31 = a2[2];
  v30 = a2[3];
  v32 = a2[1];
  v33 = (*a2 * v30) >> 64;
  v34 = *a2 * v30;
  v6 = __CFADD__(v34, v28);
  v35 = v34 + v28;
  if (v6)
  {
    v36 = v33 + 1;
  }

  else
  {
    v36 = v33;
  }

  v37 = v29 + v36;
  v6 = __CFADD__(v35, v34);
  v38 = v35 + v34;
  if (v6)
  {
    v39 = v33 + 1;
  }

  else
  {
    v39 = v33;
  }

  v6 = __CFADD__(v37, v39);
  v40 = v37 + v39;
  v41 = v6;
  if (__CFADD__(v29, v36))
  {
    v42 = v41 + 1;
  }

  else
  {
    v42 = v41;
  }

  v43 = (v32 * v31) >> 64;
  v44 = v32 * v31;
  v6 = __CFADD__(v38, v44);
  v45 = v38 + v44;
  if (v6)
  {
    v46 = v43 + 1;
  }

  else
  {
    v46 = v43;
  }

  v6 = __CFADD__(v40, v46);
  v47 = v40 + v46;
  v48 = v6;
  v6 = __CFADD__(v45, v44);
  v49 = v45 + v44;
  if (v6)
  {
    v50 = v43 + 1;
  }

  else
  {
    v50 = v43;
  }

  v51 = __PAIR128__(v42, v47) + __PAIR128__(v48, v50);
  result[3] = v49;
  v52 = a2[3];
  v53 = a2[2] * a2[2] + v51;
  v54 = *(&v51 + 1) + v51;
  v55 = __CFADD__(*(&v51 + 1), v51);
  v57 = *a2;
  v56 = a2[1];
  v58 = (v56 * v52) >> 64;
  v59 = v56 * v52;
  v6 = __CFADD__(v53, v59);
  v60 = v53 + v59;
  if (v6)
  {
    v61 = v58 + 1;
  }

  else
  {
    v61 = v58;
  }

  v6 = __CFADD__(v54, v61);
  v62 = v54 + v61;
  v63 = v6;
  v6 = __CFADD__(v60, v59);
  v64 = v60 + v59;
  if (v6)
  {
    v65 = v58 + 1;
  }

  else
  {
    v65 = v58;
  }

  v6 = __CFADD__(v62, v65);
  v66 = v62 + v65;
  v67 = v55 + v6 + v63;
  v68 = a2[4];
  v69 = (v57 * v68) >> 64;
  v70 = v57 * v68;
  v6 = __CFADD__(v64, v70);
  v71 = v64 + v70;
  if (v6)
  {
    v72 = v69 + 1;
  }

  else
  {
    v72 = v69;
  }

  v6 = __CFADD__(v66, v72);
  v73 = v66 + v72;
  v74 = v6;
  v6 = __CFADD__(v71, v70);
  v75 = v71 + v70;
  if (v6)
  {
    v76 = v69 + 1;
  }

  else
  {
    v76 = v69;
  }

  v77 = __PAIR128__(v67, v73) + __PAIR128__(v74, v76);
  result[4] = v75;
  v79 = a2[4];
  v78 = a2[5];
  v80 = a2[1];
  v81 = (*a2 * v78) >> 64;
  v82 = *a2 * v78;
  v83 = v82 + v77;
  if (__CFADD__(v82, v77))
  {
    v84 = v81 + 1;
  }

  else
  {
    v84 = v81;
  }

  v85 = *(&v77 + 1) + v84;
  v6 = __CFADD__(v83, v82);
  v86 = v83 + v82;
  if (v6)
  {
    v87 = v81 + 1;
  }

  else
  {
    v87 = v81;
  }

  v6 = __CFADD__(v85, v87);
  v88 = v85 + v87;
  v89 = v6;
  if (__CFADD__(*(&v77 + 1), v84))
  {
    v90 = v89 + 1;
  }

  else
  {
    v90 = v89;
  }

  v91 = (v80 * v79) >> 64;
  v92 = v80 * v79;
  v6 = __CFADD__(v86, v92);
  v93 = v86 + v92;
  if (v6)
  {
    v94 = v91 + 1;
  }

  else
  {
    v94 = v91;
  }

  v6 = __CFADD__(v88, v94);
  v95 = v88 + v94;
  v96 = v6;
  v6 = __CFADD__(v93, v92);
  v97 = v93 + v92;
  if (v6)
  {
    v98 = v91 + 1;
  }

  else
  {
    v98 = v91;
  }

  v99 = __PAIR128__(v90, v95) + __PAIR128__(v96, v98);
  v101 = a2[2];
  v100 = a2[3];
  v102 = (v101 * v100) >> 64;
  v103 = v101 * v100;
  v6 = __CFADD__(v97, v103);
  v104 = v97 + v103;
  if (v6)
  {
    v105 = v102 + 1;
  }

  else
  {
    v105 = v102;
  }

  v106 = __CFADD__(v99, v105);
  v6 = __CFADD__(v104, v103);
  v107 = v104 + v103;
  if (v6)
  {
    v108 = v102 + 1;
  }

  else
  {
    v108 = v102;
  }

  v109 = v99 + __PAIR128__(v106, v108);
  result[5] = v107;
  v110 = a2[2];
  v111 = a2[3] * a2[3] + v109;
  v112 = *(&v109 + 1) + v109;
  v113 = __CFADD__(*(&v109 + 1), v109);
  v114 = a2[4];
  v115 = a2[5];
  v116 = (v110 * v114) >> 64;
  v117 = v110 * v114;
  v6 = __CFADD__(v111, v117);
  v118 = v111 + v117;
  if (v6)
  {
    v119 = v116 + 1;
  }

  else
  {
    v119 = v116;
  }

  v6 = __CFADD__(v112, v119);
  v120 = v112 + v119;
  v121 = v6;
  v6 = __CFADD__(v118, v117);
  v122 = v118 + v117;
  if (v6)
  {
    v123 = v116 + 1;
  }

  else
  {
    v123 = v116;
  }

  v6 = __CFADD__(v120, v123);
  v124 = v120 + v123;
  v125 = v113 + v6 + v121;
  v127 = *a2;
  v126 = a2[1];
  v128 = (v126 * v115) >> 64;
  v129 = v126 * v115;
  v6 = __CFADD__(v122, v129);
  v130 = v122 + v129;
  if (v6)
  {
    v131 = v128 + 1;
  }

  else
  {
    v131 = v128;
  }

  v6 = __CFADD__(v124, v131);
  v132 = v124 + v131;
  v133 = v6;
  v6 = __CFADD__(v130, v129);
  v134 = v130 + v129;
  if (v6)
  {
    v135 = v128 + 1;
  }

  else
  {
    v135 = v128;
  }

  v136 = __PAIR128__(v125, v132) + __PAIR128__(v133, v135);
  v137 = a2[6];
  v138 = (v127 * v137) >> 64;
  v139 = v127 * v137;
  v6 = __CFADD__(v134, v139);
  v140 = v134 + v139;
  if (v6)
  {
    v141 = v138 + 1;
  }

  else
  {
    v141 = v138;
  }

  v142 = __CFADD__(v136, v141);
  v6 = __CFADD__(v140, v139);
  v143 = v140 + v139;
  if (v6)
  {
    v144 = v138 + 1;
  }

  else
  {
    v144 = v138;
  }

  v145 = v136 + __PAIR128__(v142, v144);
  result[6] = v143;
  v147 = a2[6];
  v146 = a2[7];
  v148 = a2[1];
  v149 = (*a2 * v146) >> 64;
  v150 = *a2 * v146;
  v151 = v150 + v145;
  if (__CFADD__(v150, v145))
  {
    v152 = v149 + 1;
  }

  else
  {
    v152 = v149;
  }

  v153 = *(&v145 + 1) + v152;
  v6 = __CFADD__(v151, v150);
  v154 = v151 + v150;
  if (v6)
  {
    v155 = v149 + 1;
  }

  else
  {
    v155 = v149;
  }

  v6 = __CFADD__(v153, v155);
  v156 = v153 + v155;
  v157 = v6;
  if (__CFADD__(*(&v145 + 1), v152))
  {
    v158 = v157 + 1;
  }

  else
  {
    v158 = v157;
  }

  v159 = (v148 * v147) >> 64;
  v160 = v148 * v147;
  v6 = __CFADD__(v154, v160);
  v161 = v154 + v160;
  if (v6)
  {
    v162 = v159 + 1;
  }

  else
  {
    v162 = v159;
  }

  v6 = __CFADD__(v156, v162);
  v163 = v156 + v162;
  v164 = v6;
  v6 = __CFADD__(v161, v160);
  v165 = v161 + v160;
  if (v6)
  {
    v166 = v159 + 1;
  }

  else
  {
    v166 = v159;
  }

  v167 = __PAIR128__(v158, v163) + __PAIR128__(v164, v166);
  v169 = a2[4];
  v168 = a2[5];
  v170 = a2[2];
  v171 = a2[3];
  v172 = (v170 * v168) >> 64;
  v173 = v170 * v168;
  v6 = __CFADD__(v165, v173);
  v174 = v165 + v173;
  if (v6)
  {
    v175 = v172 + 1;
  }

  else
  {
    v175 = v172;
  }

  v176 = __CFADD__(v167, v175);
  v6 = __CFADD__(v174, v173);
  v177 = v174 + v173;
  if (v6)
  {
    v178 = v172 + 1;
  }

  else
  {
    v178 = v172;
  }

  v179 = v167 + __PAIR128__(v176, v178);
  v180 = (v171 * v169) >> 64;
  v181 = v171 * v169;
  v6 = __CFADD__(v177, v181);
  v182 = v177 + v181;
  if (v6)
  {
    v183 = v180 + 1;
  }

  else
  {
    v183 = v180;
  }

  v184 = __CFADD__(v179, v183);
  v6 = __CFADD__(v182, v181);
  v185 = v182 + v181;
  if (v6)
  {
    ++v180;
  }

  v186 = v179 + __PAIR128__(v184, v180);
  result[7] = v185;
  v187 = a2[3];
  v188 = a2[4] * a2[4] + v186;
  v189 = *(&v186 + 1) + v186;
  v190 = __CFADD__(*(&v186 + 1), v186);
  v191 = a2[5];
  v192 = a2[6];
  v193 = (v187 * v191) >> 64;
  v194 = v187 * v191;
  v6 = __CFADD__(v188, v194);
  v195 = v188 + v194;
  if (v6)
  {
    v196 = v193 + 1;
  }

  else
  {
    v196 = v193;
  }

  v6 = __CFADD__(v189, v196);
  v197 = v189 + v196;
  v198 = v6;
  v6 = __CFADD__(v195, v194);
  v199 = v195 + v194;
  if (v6)
  {
    v200 = v193 + 1;
  }

  else
  {
    v200 = v193;
  }

  v6 = __CFADD__(v197, v200);
  v201 = v197 + v200;
  v202 = v190 + v6 + v198;
  v204 = a2[1];
  v203 = a2[2];
  v205 = (v203 * v192) >> 64;
  v206 = v203 * v192;
  v6 = __CFADD__(v199, v206);
  v207 = v199 + v206;
  if (v6)
  {
    v208 = v205 + 1;
  }

  else
  {
    v208 = v205;
  }

  v6 = __CFADD__(v201, v208);
  v209 = v201 + v208;
  v210 = v6;
  v6 = __CFADD__(v207, v206);
  v211 = v207 + v206;
  if (v6)
  {
    v212 = v205 + 1;
  }

  else
  {
    v212 = v205;
  }

  v213 = __PAIR128__(v202, v209) + __PAIR128__(v210, v212);
  v214 = a2[7];
  v215 = (v204 * v214) >> 64;
  v216 = v204 * v214;
  v6 = __CFADD__(v211, v216);
  v217 = v211 + v216;
  if (v6)
  {
    v218 = v215 + 1;
  }

  else
  {
    v218 = v215;
  }

  v219 = __CFADD__(v213, v218);
  v6 = __CFADD__(v217, v216);
  v220 = v217 + v216;
  if (v6)
  {
    v221 = v215 + 1;
  }

  else
  {
    v221 = v215;
  }

  v222 = v213 + __PAIR128__(v219, v221);
  result[8] = v220;
  v224 = a2[6];
  v223 = a2[7];
  v225 = a2[2];
  v226 = a2[3];
  v227 = (v225 * v223) >> 64;
  v228 = v225 * v223;
  v229 = v228 + v222;
  if (__CFADD__(v228, v222))
  {
    v230 = v227 + 1;
  }

  else
  {
    v230 = v227;
  }

  v231 = *(&v222 + 1) + v230;
  v6 = __CFADD__(v229, v228);
  v232 = v229 + v228;
  if (v6)
  {
    v233 = v227 + 1;
  }

  else
  {
    v233 = v227;
  }

  v6 = __CFADD__(v231, v233);
  v234 = v231 + v233;
  v235 = v6;
  if (__CFADD__(*(&v222 + 1), v230))
  {
    v236 = v235 + 1;
  }

  else
  {
    v236 = v235;
  }

  v237 = (v226 * v224) >> 64;
  v238 = v226 * v224;
  v6 = __CFADD__(v232, v238);
  v239 = v232 + v238;
  if (v6)
  {
    v240 = v237 + 1;
  }

  else
  {
    v240 = v237;
  }

  v6 = __CFADD__(v234, v240);
  v241 = v234 + v240;
  v242 = v6;
  v6 = __CFADD__(v239, v238);
  v243 = v239 + v238;
  if (v6)
  {
    v244 = v237 + 1;
  }

  else
  {
    v244 = v237;
  }

  v245 = __PAIR128__(v236, v241) + __PAIR128__(v242, v244);
  v247 = a2[4];
  v246 = a2[5];
  v248 = (v247 * v246) >> 64;
  v249 = v247 * v246;
  v6 = __CFADD__(v243, v249);
  v250 = v243 + v249;
  if (v6)
  {
    v251 = v248 + 1;
  }

  else
  {
    v251 = v248;
  }

  v252 = __CFADD__(v245, v251);
  v6 = __CFADD__(v250, v249);
  v253 = v250 + v249;
  if (v6)
  {
    v254 = v248 + 1;
  }

  else
  {
    v254 = v248;
  }

  v255 = v245 + __PAIR128__(v252, v254);
  result[9] = v253;
  v256 = a2[6];
  v257 = a2[5] * a2[5] + v255;
  v258 = *(&v255 + 1) + v255;
  v259 = __CFADD__(*(&v255 + 1), v255);
  v261 = a2[3];
  v260 = a2[4];
  v262 = (v260 * v256) >> 64;
  v263 = v260 * v256;
  v6 = __CFADD__(v257, v263);
  v264 = v257 + v263;
  if (v6)
  {
    v265 = v262 + 1;
  }

  else
  {
    v265 = v262;
  }

  v6 = __CFADD__(v258, v265);
  v266 = v258 + v265;
  v267 = v6;
  v6 = __CFADD__(v264, v263);
  v268 = v264 + v263;
  if (v6)
  {
    v269 = v262 + 1;
  }

  else
  {
    v269 = v262;
  }

  v6 = __CFADD__(v266, v269);
  v270 = v266 + v269;
  v271 = v259 + v6 + v267;
  v272 = a2[7];
  v273 = (v261 * v272) >> 64;
  v274 = v261 * v272;
  v6 = __CFADD__(v268, v274);
  v275 = v268 + v274;
  if (v6)
  {
    v276 = v273 + 1;
  }

  else
  {
    v276 = v273;
  }

  v6 = __CFADD__(v270, v276);
  v277 = v270 + v276;
  v278 = v6;
  v6 = __CFADD__(v275, v274);
  v279 = v275 + v274;
  if (v6)
  {
    v280 = v273 + 1;
  }

  else
  {
    v280 = v273;
  }

  v281 = __PAIR128__(v271, v277) + __PAIR128__(v278, v280);
  result[10] = v279;
  v283 = a2[6];
  v282 = a2[7];
  v284 = a2[4];
  v285 = a2[5];
  v286 = (v284 * v282) >> 64;
  v287 = v284 * v282;
  v288 = v287 + v281;
  if (__CFADD__(v287, v281))
  {
    v289 = v286 + 1;
  }

  else
  {
    v289 = v286;
  }

  v290 = *(&v281 + 1) + v289;
  v6 = __CFADD__(v288, v287);
  v291 = v288 + v287;
  if (v6)
  {
    v292 = v286 + 1;
  }

  else
  {
    v292 = v286;
  }

  v6 = __CFADD__(v290, v292);
  v293 = v290 + v292;
  v294 = v6;
  if (__CFADD__(*(&v281 + 1), v289))
  {
    v295 = v294 + 1;
  }

  else
  {
    v295 = v294;
  }

  v296 = (v285 * v283) >> 64;
  v297 = v285 * v283;
  v6 = __CFADD__(v291, v297);
  v298 = v291 + v297;
  if (v6)
  {
    v299 = v296 + 1;
  }

  else
  {
    v299 = v296;
  }

  v6 = __CFADD__(v293, v299);
  v300 = v293 + v299;
  v301 = v6;
  v6 = __CFADD__(v298, v297);
  v302 = v298 + v297;
  if (v6)
  {
    v303 = v296 + 1;
  }

  else
  {
    v303 = v296;
  }

  v304 = __PAIR128__(v295, v300) + __PAIR128__(v301, v303);
  result[11] = v302;
  v305 = a2[5];
  v306 = a2[6] * a2[6] + v304;
  v307 = *(&v304 + 1) + v304;
  v308 = __CFADD__(*(&v304 + 1), v304);
  v309 = a2[7];
  v310 = (v305 * v309) >> 64;
  v311 = v305 * v309;
  v6 = __CFADD__(v306, v311);
  v312 = v306 + v311;
  if (v6)
  {
    v313 = v310 + 1;
  }

  else
  {
    v313 = v310;
  }

  v6 = __CFADD__(v307, v313);
  v314 = v307 + v313;
  v315 = v6;
  v6 = __CFADD__(v312, v311);
  v316 = v312 + v311;
  if (v6)
  {
    v317 = v310 + 1;
  }

  else
  {
    v317 = v310;
  }

  v6 = __CFADD__(v314, v317);
  v318 = v314 + v317;
  v319 = v308 + v6 + v315;
  result[12] = v316;
  v321 = a2[6];
  v320 = a2[7];
  v322 = (v321 * v320) >> 64;
  v323 = v321 * v320;
  v6 = __CFADD__(v323, v318);
  v324 = v323 + v318;
  if (v6)
  {
    v325 = v322 + 1;
  }

  else
  {
    v325 = v322;
  }

  v326 = v319 + v325;
  v6 = __CFADD__(v324, v323);
  v327 = v324 + v323;
  if (v6)
  {
    v328 = v322 + 1;
  }

  else
  {
    v328 = v322;
  }

  v6 = __CFADD__(v326, v328);
  v329 = v326 + v328;
  v330 = v6;
  result[13] = v327;
  v331 = a2[7];
  v332 = (v331 * v331) >> 64;
  v333 = v331 * v331;
  v6 = __CFADD__(v333, v329);
  v334 = v333 + v329;
  if (v6)
  {
    v335 = v332 + 1;
  }

  else
  {
    v335 = v332;
  }

  result[14] = v334;
  result[15] = v330 + __CFADD__(v319, v325) + v335;
  return result;
}

void *bn_sqr_comba4(void *result, unint64_t *a2)
{
  v2 = (*a2 * *a2) >> 64;
  *result = *a2 * *a2;
  v3 = a2[1];
  v4 = (*a2 * v3) >> 64;
  v5 = *a2 * v3;
  v6 = __CFADD__(v5, v2);
  v7 = v5 + v2;
  if (v6)
  {
    v8 = v4 + 1;
  }

  else
  {
    v8 = v4;
  }

  v6 = __CFADD__(v7, v5);
  v9 = v7 + v5;
  if (v6)
  {
    v10 = v4 + 1;
  }

  else
  {
    v10 = v4;
  }

  result[1] = v9;
  v12 = *a2;
  v11 = a2[1];
  v13 = (v11 * v11) >> 64;
  v14 = v11 * v11;
  v6 = __CFADD__(v14, v10 + v8);
  v15 = v14 + v10 + v8;
  if (v6)
  {
    v16 = v13 + 1;
  }

  else
  {
    v16 = v13;
  }

  v6 = __CFADD__(__CFADD__(v10, v8), v16);
  v17 = __CFADD__(v10, v8) + v16;
  v18 = v6;
  v19 = a2[2];
  v20 = (v12 * v19) >> 64;
  v21 = v12 * v19;
  v6 = __CFADD__(v15, v21);
  v22 = v15 + v21;
  if (v6)
  {
    v23 = v20 + 1;
  }

  else
  {
    v23 = v20;
  }

  v6 = __CFADD__(v17, v23);
  v24 = v17 + v23;
  v25 = v6;
  v6 = __CFADD__(v22, v21);
  v26 = v22 + v21;
  if (v6)
  {
    v27 = v20 + 1;
  }

  else
  {
    v27 = v20;
  }

  v6 = __CFADD__(v24, v27);
  v28 = v24 + v27;
  v29 = v18 + v6 + v25;
  result[2] = v26;
  v31 = a2[2];
  v30 = a2[3];
  v32 = a2[1];
  v33 = (*a2 * v30) >> 64;
  v34 = *a2 * v30;
  v6 = __CFADD__(v34, v28);
  v35 = v34 + v28;
  if (v6)
  {
    v36 = v33 + 1;
  }

  else
  {
    v36 = v33;
  }

  v37 = v29 + v36;
  v6 = __CFADD__(v35, v34);
  v38 = v35 + v34;
  if (v6)
  {
    v39 = v33 + 1;
  }

  else
  {
    v39 = v33;
  }

  v6 = __CFADD__(v37, v39);
  v40 = v37 + v39;
  v41 = v6;
  if (__CFADD__(v29, v36))
  {
    v42 = v41 + 1;
  }

  else
  {
    v42 = v41;
  }

  v43 = (v32 * v31) >> 64;
  v44 = v32 * v31;
  v6 = __CFADD__(v38, v44);
  v45 = v38 + v44;
  if (v6)
  {
    v46 = v43 + 1;
  }

  else
  {
    v46 = v43;
  }

  v6 = __CFADD__(v40, v46);
  v47 = v40 + v46;
  v48 = v6;
  v6 = __CFADD__(v45, v44);
  v49 = v45 + v44;
  if (v6)
  {
    v50 = v43 + 1;
  }

  else
  {
    v50 = v43;
  }

  v51 = __PAIR128__(v42, v47) + __PAIR128__(v48, v50);
  result[3] = v49;
  v52 = a2[1];
  v53 = a2[2] * a2[2] + v51;
  v54 = *(&v51 + 1) + v51;
  v55 = __CFADD__(*(&v51 + 1), v51);
  v56 = a2[3];
  v57 = (v52 * v56) >> 64;
  v58 = v52 * v56;
  v6 = __CFADD__(v53, v58);
  v59 = v53 + v58;
  if (v6)
  {
    v60 = v57 + 1;
  }

  else
  {
    v60 = v57;
  }

  v6 = __CFADD__(v54, v60);
  v61 = v54 + v60;
  v62 = v6;
  v6 = __CFADD__(v59, v58);
  v63 = v59 + v58;
  if (v6)
  {
    v64 = v57 + 1;
  }

  else
  {
    v64 = v57;
  }

  v6 = __CFADD__(v61, v64);
  v65 = v61 + v64;
  v66 = v55 + v6 + v62;
  result[4] = v63;
  v68 = a2[2];
  v67 = a2[3];
  v69 = (v68 * v67) >> 64;
  v70 = v68 * v67;
  v6 = __CFADD__(v70, v65);
  v71 = v70 + v65;
  if (v6)
  {
    v72 = v69 + 1;
  }

  else
  {
    v72 = v69;
  }

  v73 = v66 + v72;
  v6 = __CFADD__(v71, v70);
  v74 = v71 + v70;
  if (v6)
  {
    v75 = v69 + 1;
  }

  else
  {
    v75 = v69;
  }

  v6 = __CFADD__(v73, v75);
  v76 = v73 + v75;
  v77 = v6;
  result[5] = v74;
  v78 = a2[3];
  v79 = (v78 * v78) >> 64;
  v80 = v78 * v78;
  v6 = __CFADD__(v80, v76);
  v81 = v80 + v76;
  if (v6)
  {
    v82 = v79 + 1;
  }

  else
  {
    v82 = v79;
  }

  result[6] = v81;
  result[7] = v77 + __CFADD__(v66, v72) + v82;
  return result;
}

void BN_MONT_CTX_free(BN_MONT_CTX *mont)
{
  if (!mont)
  {
    return;
  }

  dmax = mont->RR.dmax;
  if ((dmax & 2) == 0)
  {
    v3 = *&mont->ri;
    if (*&mont->ri)
    {
      v5 = *(v3 - 8);
      v4 = (v3 - 8);
      v6 = v5 + 8;
      if (v5 != -8)
      {
        bzero(v4, v6);
      }

      free(v4);
      dmax = mont->RR.dmax;
    }
  }

  if ((dmax & 1) == 0)
  {
    *&mont->ri = 0;
    v7 = mont->N.dmax;
    if ((v7 & 2) != 0)
    {
      goto LABEL_18;
    }

    goto LABEL_14;
  }

  v8 = *&mont[-1].flags;
  if (v8 != -8)
  {
    bzero(&mont[-1].flags, v8 + 8);
  }

  free(&mont[-1].flags);
  v7 = mont->N.dmax;
  if ((v7 & 2) == 0)
  {
LABEL_14:
    v9 = *&mont->RR.neg;
    if (v9)
    {
      v11 = *(v9 - 8);
      v10 = (v9 - 8);
      v12 = v11 + 8;
      if (v11 != -8)
      {
        bzero(v10, v12);
      }

      free(v10);
      v7 = mont->N.dmax;
    }
  }

LABEL_18:
  if (v7)
  {
    v16 = *&mont->RR.top;
    if (v16 != -8)
    {
      bzero(&mont->RR.top, v16 + 8);
    }

    free(&mont->RR.top);
    v17 = *&mont[-1].flags;
    p_flags = &mont[-1].flags;
    v15 = v17 + 8;
    if (v17 == -8)
    {
      goto LABEL_25;
    }
  }

  else
  {
    *&mont->RR.neg = 0;
    v14 = *&mont[-1].flags;
    p_flags = &mont[-1].flags;
    v15 = v14 + 8;
    if (v14 == -8)
    {
      goto LABEL_25;
    }
  }

  bzero(p_flags, v15);
LABEL_25:

  free(p_flags);
}

int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)
{
  if (!bn_mont_ctx_set_N_and_n0(mont, mod))
  {
    return 0;
  }

  if (ctx)
  {
    v5 = 0;
  }

  else
  {
    v7 = malloc_type_malloc(0x48uLL, 0xB4E622C9uLL);
    if (!v7)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc", 217);
      return 0;
    }

    *v7 = 64;
    *(v7 + 8) = 0u;
    v5 = (v7 + 8);
    *(v7 + 24) = 0u;
    *(v7 + 40) = 0u;
    *(v7 + 56) = 0u;
    ctx = (v7 + 8);
  }

  d = mont->N.d;
  mont->RR.top = 0;
  LODWORD(mont->RR.d) = 0;
  if (BN_set_bit(mont, d << 7) && BN_div(0, mont, mont, &mont->RR.neg, ctx))
  {
    v9 = bn_resize_words(&mont->ri, SLODWORD(mont->N.d));
  }

  else
  {
    v9 = 0;
  }

  BN_CTX_free(v5);
  return v9;
}

uint64_t bn_mont_ctx_set_N_and_n0(bn_mont_ctx_st *a1, const bignum_st *a2)
{
  top = a2->top;
  if (!top)
  {
    goto LABEL_13;
  }

  d = a2->d;
  if (top < 4)
  {
    v4 = 0;
    v5 = 0;
LABEL_7:
    v11 = top - v4;
    v12 = &d[v4];
    do
    {
      v13 = *v12++;
      *&v5 |= v13;
      --v11;
    }

    while (v11);
    goto LABEL_9;
  }

  v4 = top & 0xFFFFFFFFFFFFFFFCLL;
  v6 = (d + 2);
  v7 = 0uLL;
  v8 = top & 0xFFFFFFFFFFFFFFFCLL;
  v9 = 0uLL;
  do
  {
    v7 = vorrq_s8(v6[-1], v7);
    v9 = vorrq_s8(*v6, v9);
    v6 += 2;
    v8 -= 4;
  }

  while (v8);
  v10 = vorrq_s8(v9, v7);
  v5 = vorr_s8(*v10.i8, *&vextq_s8(v10, v10, 8uLL));
  if (v4 != top)
  {
    goto LABEL_7;
  }

LABEL_9:
  if (!*&v5)
  {
LABEL_13:
    ERR_put_error(3, 0, 105, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/montgomery.cc.inc", 75);
    return 0;
  }

  if (top < 1 || (*d & 1) == 0)
  {
    ERR_put_error(3, 0, 104, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/montgomery.cc.inc", 79);
    return 0;
  }

  if (a2->neg)
  {
    ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/montgomery.cc.inc", 83);
    return 0;
  }

  if (top < 0x101)
  {
    goto LABEL_26;
  }

  v15 = top - 256;
  if ((top - 256) < 4)
  {
    v16 = 0;
    v17 = 256;
LABEL_22:
    v23 = top - v17;
    v24 = &d[v17];
    do
    {
      v25 = *v24++;
      *&v16 |= v25;
      --v23;
    }

    while (v23);
    goto LABEL_24;
  }

  v17 = (v15 & 0xFFFFFFFFFFFFFFFCLL) + 256;
  v18 = (d + 258);
  v19 = 0uLL;
  v20 = v15 & 0xFFFFFFFFFFFFFFFCLL;
  v21 = 0uLL;
  do
  {
    v19 = vorrq_s8(v18[-1], v19);
    v21 = vorrq_s8(*v18, v21);
    v18 += 2;
    v20 -= 4;
  }

  while (v20);
  v22 = vorrq_s8(v21, v19);
  v16 = vorr_s8(*v22.i8, *&vextq_s8(v22, v22, 8uLL));
  if (v15 != (v15 & 0xFFFFFFFFFFFFFFFCLL))
  {
    goto LABEL_22;
  }

LABEL_24:
  if (v16)
  {
    ERR_put_error(3, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/montgomery.cc.inc", 87);
    return 0;
  }

LABEL_26:
  if (BN_copy(&a1->RR.neg, a2))
  {
    v27 = a1->N.d;
    if (v27 < 1)
    {
      if (!v27)
      {
LABEL_34:
        a1->N.top = 0;
      }
    }

    else
    {
      while (!*(*&a1->RR.neg - 8 + 8 * v27))
      {
        v28 = __OFSUB__(v27--, 1);
        if ((v27 < 0) ^ v28 | (v27 == 0))
        {
          LODWORD(a1->N.d) = 0;
          goto LABEL_34;
        }
      }

      LODWORD(a1->N.d) = v27;
    }

    v29 = 0;
    v30 = 1;
    v31 = 64;
    do
    {
      v32 = v29;
      v33 = -(v30 & 1);
      v30 = (**&a1->RR.neg & v33 & v30) + ((**&a1->RR.neg & v33 ^ v30) >> 1);
      v29 = v33 & 0x8000000000000000 | (v32 >> 1);
      --v31;
    }

    while (v31);
    *&a1->N.neg = v29;
    a1->Ni.d = 0;
    return 1;
  }

  else
  {
    ERR_put_error(3, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/montgomery.cc.inc", 93);
    return 0;
  }
}

int BN_set_bit(BIGNUM *a, int n)
{
  if (n < 0)
  {
    return 0;
  }

  v2 = n >> 6;
  top = a->top;
  if (top > (n >> 6))
  {
    goto LABEL_7;
  }

  v4 = v2 + 1;
  if (a->dmax <= v2)
  {
    if (n < 0x1FFFFFC0)
    {
      if ((a->flags & 2) != 0)
      {
        v10 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
        v11 = 3;
        v12 = 106;
        v13 = 306;
      }

      else
      {
        v14 = n;
        v15 = a;
        v16 = (8 * v4);
        v17 = malloc_type_malloc(v16 + 8, 0xB4E622C9uLL);
        if (v17)
        {
          *v17 = v16;
          v18 = v17 + 1;
          bzero(v17 + 1, (8 * v4));
          a = v15;
          v19 = v15->top;
          if (v19)
          {
            memcpy(v18, v15->d, 8 * v19);
            a = v15;
          }

          d = a->d;
          if (a->d)
          {
            v22 = *(d - 1);
            v21 = d - 1;
            v23 = v22 + 8;
            if (v22 != -8)
            {
              bzero(v21, v23);
            }

            free(v21);
            a = v15;
          }

          a->d = v18;
          a->dmax = v4;
          top = a->top;
          LOBYTE(n) = v14;
          v5 = v2 - top;
          if (v2 < top)
          {
            goto LABEL_6;
          }

          goto LABEL_5;
        }

        v10 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc";
        v11 = 14;
        v12 = 65;
        v13 = 217;
      }
    }

    else
    {
      v10 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
      v11 = 3;
      v12 = 102;
      v13 = 301;
    }

    ERR_put_error(v11, 0, v12, v10, v13);
    return 0;
  }

  v5 = v2 - top;
  if (v2 >= top)
  {
LABEL_5:
    v6 = n;
    v7 = a;
    bzero(&a->d[top], 8 * v5 + 8);
    LOBYTE(n) = v6;
    a = v7;
  }

LABEL_6:
  a->top = v4;
LABEL_7:
  v8 = 1;
  a->d[v2] |= 1 << (n & 0x3F);
  return v8;
}

uint64_t *BN_MONT_CTX_new_for_modulus(const BIGNUM *a1, BN_CTX *a2)
{
  v4 = malloc_type_malloc(0x48uLL, 0xB4E622C9uLL);
  if (!v4)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc", 217);
    return 0;
  }

  v5 = v4;
  *v4 = 64;
  *(v4 + 8) = 0u;
  v6 = (v4 + 8);
  *(v4 + 24) = 0u;
  *(v4 + 40) = 0u;
  *(v4 + 56) = 0u;
  if (BN_MONT_CTX_set((v4 + 8), a1, a2))
  {
    return v6;
  }

  v8 = v5[7];
  if ((v8 & 2) == 0)
  {
    v9 = *v6;
    if (*v6)
    {
      v11 = *(v9 - 8);
      v10 = (v9 - 8);
      v12 = v11 + 8;
      if (v11 != -8)
      {
        bzero(v10, v12);
      }

      free(v10);
      v8 = v5[7];
    }
  }

  if ((v8 & 1) == 0)
  {
    *v6 = 0;
    v13 = v5[13];
    if ((v13 & 2) != 0)
    {
      goto LABEL_18;
    }

LABEL_14:
    v14 = *(v5 + 4);
    if (v14)
    {
      v16 = *(v14 - 8);
      v15 = (v14 - 8);
      v17 = v16 + 8;
      if (v16 != -8)
      {
        bzero(v15, v17);
      }

      free(v15);
      v13 = v5[13];
    }

    goto LABEL_18;
  }

  free(v5);
  v13 = v5[13];
  if ((v13 & 2) == 0)
  {
    goto LABEL_14;
  }

LABEL_18:
  if (v13)
  {
    v18 = *(v5 + 3);
    if (v18 != -8)
    {
      bzero(v5 + 6, v18 + 8);
    }

    free(v5 + 6);
  }

  free(v5);
  return 0;
}

uint64_t bn_mont_ctx_set_RR_consttime(BIGNUM *a, uint64_t a2)
{
  top = a[1].top;
  if (top < 1)
  {
    if (!top)
    {
LABEL_27:
      v16 = 0;
      goto LABEL_28;
    }

    d = a[1].d;
    v6 = a[1].top;
  }

  else
  {
    d = a[1].d;
    v6 = a[1].top;
    while (!d[v6 - 1])
    {
      v7 = __OFSUB__(v6--, 1);
      if ((v6 < 0) ^ v7 | (v6 == 0))
      {
        goto LABEL_27;
      }
    }
  }

  v8 = v6 - 1;
  v9 = d[v8];
  v10 = v9 != 0;
  v11 = HIDWORD(v9) != 0;
  if (HIDWORD(v9))
  {
    v9 >>= 32;
  }

  v12 = v9 >> 16 != 0;
  if (v9 >> 16)
  {
    v9 >>= 16;
  }

  v13 = v9 > 0xFF;
  if (v9 > 0xFF)
  {
    v9 >>= 8;
  }

  v14 = v9 > 0xF;
  if (v9 > 0xF)
  {
    v9 >>= 4;
  }

  v15 = v9 > 3;
  if (v9 > 3)
  {
    v9 >>= 2;
  }

  if (v9 <= 1)
  {
    v16 = v10 | (v8 << 6) | (32 * v11) | (16 * v12) | (8 * v13) | (4 * v14) | (2 * v15);
  }

  else
  {
    v16 = (v10 | (v8 << 6) | (32 * v11) | (16 * v12) | (8 * v13) | (4 * v14) | (2 * v15)) + 1;
  }

  if (v16 != 1)
  {
LABEL_28:
    if (!BN_set_bit(a, v16 - 1) || !a || !bn_resize_words(a, a[1].top))
    {
      return 0;
    }

    if ((*(a2 + 56) & 1) == 0)
    {
      v18 = *(a2 + 48);
      if (!bssl::Vector<unsigned long>::MaybeGrow((a2 + 24)))
      {
        *(a2 + 56) = 257;
        ERR_clear_error();
        v19 = a[1].top;
        v20 = BN_CTX_get(a2);
        if (v20)
        {
LABEL_35:
          v21 = v20;
          if (v20->dmax >= v19)
          {
            goto LABEL_50;
          }

          if (v19 >= 0x800000)
          {
            v22 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
            v23 = 3;
            v24 = 102;
            v25 = 301;
            goto LABEL_59;
          }

          if ((v20->flags & 2) != 0)
          {
            v22 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
            v23 = 3;
            v24 = 106;
            v25 = 306;
          }

          else
          {
            v27 = malloc_type_malloc(8 * v19 + 8, 0xB4E622C9uLL);
            if (v27)
            {
              *v27 = 8 * v19;
              v28 = v27 + 1;
              bzero(v27 + 1, 8 * v19);
              v29 = v21->top;
              if (v29)
              {
                memcpy(v28, v21->d, 8 * v29);
              }

              v30 = v21->d;
              if (v21->d)
              {
                v32 = *(v30 - 1);
                v31 = (v30 - 1);
                v33 = v32 + 8;
                if (v32 != -8)
                {
                  bzero(v31, v33);
                }

                free(v31);
              }

              v21->d = v28;
              v21->dmax = v19;
LABEL_50:
              v21->neg = 0;
              v21->top = v19;
              if (65 * top - v16 + 1 >= 1)
              {
                v34 = ~(65 * top) + v16;
                do
                {
                  bn_mod_add_words(a->d, a->d, a->d, a[1].d, v21->d, a[1].top);
                }

                while (!__CFADD__(v34++, 1));
              }

              v26 = 0;
              a->neg = 0;
              if (*(a2 + 56))
              {
                goto LABEL_55;
              }

LABEL_60:
              v36 = *(a2 + 32);
              if (!v36)
              {
                abort();
              }

              *(a2 + 48) = *(*(a2 + 24) + 8 * v36 - 8);
              *(a2 + 32) = v36 - 1;
              if (v26)
              {
                return 0;
              }

LABEL_62:
              if (BN_mod_mul_montgomery(a, a, a, a, a2) && BN_mod_mul_montgomery(a, a, a, a, a2) && BN_mod_mul_montgomery(a, a, a, a, a2) && BN_mod_mul_montgomery(a, a, a, a, a2) && BN_mod_mul_montgomery(a, a, a, a, a2) && BN_mod_mul_montgomery(a, a, a, a, a2))
              {
                top = a[1].top;
                goto LABEL_24;
              }

              return 0;
            }

            v22 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc";
            v23 = 14;
            v24 = 65;
            v25 = 217;
          }

LABEL_59:
          ERR_put_error(v23, 0, v24, v22, v25);
          v26 = 1;
          if ((*(a2 + 56) & 1) == 0)
          {
            goto LABEL_60;
          }

LABEL_55:
          if (v26)
          {
            return 0;
          }

          goto LABEL_62;
        }

LABEL_39:
        v26 = 1;
        if (*(a2 + 56))
        {
          goto LABEL_55;
        }

        goto LABEL_60;
      }

      *(*(a2 + 24) + 8 * (*(a2 + 32))++) = v18;
    }

    v19 = a[1].top;
    v20 = BN_CTX_get(a2);
    if (v20)
    {
      goto LABEL_35;
    }

    goto LABEL_39;
  }

  a->neg = 0;
  a->top = 0;
LABEL_24:

  return bn_resize_words(a, top);
}

BN_MONT_CTX *__cdecl BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock, const BIGNUM *mod, BN_CTX *ctx)
{
  v6 = *&lock;
  if (pthread_rwlock_rdlock(*&lock))
  {
    goto LABEL_10;
  }

  v8 = *pmont;
  if (pthread_rwlock_unlock(v6))
  {
    goto LABEL_10;
  }

  if (v8)
  {
    return 1;
  }

  if (pthread_rwlock_wrlock(v6))
  {
    goto LABEL_10;
  }

  if (*pmont)
  {
    v10 = pthread_rwlock_unlock(v6);
    result = 1;
    if (!v10)
    {
      return result;
    }

LABEL_10:
    abort();
  }

  v11 = BN_MONT_CTX_new_for_modulus(mod, ctx);
  *pmont = v11;
  v12 = v11 != 0;
  v13 = pthread_rwlock_unlock(v6);
  result = v12;
  if (v13)
  {
    goto LABEL_10;
  }

  return result;
}

uint64_t bn_mul_impl(bignum_st *a1, const bignum_st *a2, const bignum_st *a3, bignum_ctx *ctx)
{
  top = a2->top;
  v6 = a3->top;
  if (top)
  {
    v7 = v6 == 0;
  }

  else
  {
    v7 = 1;
  }

  if (v7)
  {
    a1->neg = 0;
    a1->top = 0;
    return 1;
  }

  if (*(ctx + 56))
  {
LABEL_10:
    if (a1 != a2)
    {
      goto LABEL_11;
    }

    goto LABEL_12;
  }

  v12 = *(ctx + 6);
  if (bssl::Vector<unsigned long>::MaybeGrow(ctx + 3))
  {
    *(*(ctx + 3) + 8 * (*(ctx + 4))++) = v12;
    goto LABEL_10;
  }

  *(ctx + 28) = 257;
  ERR_clear_error();
  if (a1 != a2)
  {
LABEL_11:
    v13 = a1;
    if (a1 != a3)
    {
      goto LABEL_13;
    }
  }

LABEL_12:
  result = BN_CTX_get(ctx);
  v13 = result;
  if (!result)
  {
    goto LABEL_38;
  }

LABEL_13:
  v14 = v6;
  v13->neg = a3->neg ^ a2->neg;
  if (top == 8 && v6 == 8)
  {
    if (v13->dmax >= 0x10u)
    {
      d = v13->d;
      goto LABEL_35;
    }

    if ((v13->flags & 2) == 0)
    {
      v15 = malloc_type_malloc(0x88uLL, 0xB4E622C9uLL);
      if (v15)
      {
        *v15 = 128;
        v16 = v15;
        *(v15 + 8) = 0u;
        d = (v15 + 8);
        *(v16 + 24) = 0u;
        *(v16 + 40) = 0u;
        *(v16 + 56) = 0u;
        *(v16 + 72) = 0u;
        *(v16 + 88) = 0u;
        *(v16 + 104) = 0u;
        *(v16 + 120) = 0u;
        v18 = v13->top;
        if (v18)
        {
          v19 = d;
          memcpy(d, v13->d, 8 * v18);
          d = v19;
        }

        v20 = v13->d;
        if (v13->d)
        {
          v21 = d;
          v23 = *(v20 - 1);
          v22 = v20 - 1;
          v24 = v23 + 8;
          if (v23 != -8)
          {
            bzero(v22, v24);
          }

          free(v22);
          d = v21;
        }

        v13->d = d;
        v13->dmax = 16;
LABEL_35:
        v13->top = 16;
        bn_mul_comba8(d, a2->d, a3->d);
        if (v13 != a1)
        {
LABEL_36:
          result = BN_copy(a1, v13);
          if (!result)
          {
            goto LABEL_38;
          }
        }

LABEL_37:
        result = 1;
LABEL_38:
        if (*(ctx + 56))
        {
          return result;
        }

        goto LABEL_52;
      }

LABEL_51:
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc", 217);
      result = 0;
      if (*(ctx + 56))
      {
        return result;
      }

      goto LABEL_52;
    }

LABEL_49:
    ERR_put_error(3, 0, 106, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc", 306);
    result = 0;
    if (*(ctx + 56))
    {
      return result;
    }

    goto LABEL_52;
  }

  v25 = v6 + top;
  if (v13->dmax >= (v6 + top))
  {
    v26 = v13->d;
    goto LABEL_32;
  }

  if (v25 < 0x800000)
  {
    if ((v13->flags & 2) != 0)
    {
      goto LABEL_49;
    }

    v27 = v6;
    v28 = 8 * v25;
    v29 = malloc_type_malloc(v28 + 8, 0xB4E622C9uLL);
    if (!v29)
    {
      goto LABEL_51;
    }

    *v29 = v28;
    v30 = v29 + 1;
    bzero(v29 + 1, 8 * v25);
    v31 = v13->top;
    if (v31)
    {
      memcpy(v30, v13->d, 8 * v31);
    }

    v32 = v13->d;
    if (v13->d)
    {
      v34 = *(v32 - 1);
      v33 = v32 - 1;
      v35 = v34 + 8;
      if (v34 != -8)
      {
        bzero(v33, v35);
      }

      free(v33);
    }

    v26 = v30;
    v13->d = v30;
    v13->dmax = v25;
    v14 = v27;
LABEL_32:
    v13->top = v25;
    bn_mul_normal(v26, a2->d, top, a3->d, v14);
    if (v13 != a1)
    {
      goto LABEL_36;
    }

    goto LABEL_37;
  }

  ERR_put_error(3, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc", 301);
  result = 0;
  if (*(ctx + 56))
  {
    return result;
  }

LABEL_52:
  v36 = *(ctx + 4);
  if (!v36)
  {
    abort();
  }

  *(ctx + 6) = *(*(ctx + 3) + 8 * v36 - 8);
  *(ctx + 4) = v36 - 1;
  return result;
}

void bn_mul_normal(void *a1, const unint64_t *a2, unint64_t a3, const unint64_t *a4, unint64_t a5)
{
  if (a3 < a5)
  {
    v6 = a5;
  }

  else
  {
    v6 = a3;
  }

  if (a3 < a5)
  {
    v7 = a2;
  }

  else
  {
    v7 = a4;
  }

  if (a3 < a5)
  {
    v8 = a3;
  }

  else
  {
    v8 = a5;
  }

  if (a3 < a5)
  {
    v9 = a4;
  }

  else
  {
    v9 = a2;
  }

  if (v8)
  {
    if (v6)
    {
      v10 = *v7;
      if (v6 >= 4)
      {
        v11 = 0;
        v12 = a1;
        v13 = v9;
        for (i = v6; i >= 4; i -= 4)
        {
          v15 = *v13 * v10;
          v16 = __CFADD__(v15, v11);
          v17 = v15 + v11;
          if (v16)
          {
            v18 = ((*v13 * v10) >> 64) + 1;
          }

          else
          {
            v18 = (*v13 * v10) >> 64;
          }

          *v12 = v17;
          v19 = v13[1];
          v20 = (v19 * v10) >> 64;
          v21 = v19 * v10;
          v16 = __CFADD__(v21, v18);
          v22 = v21 + v18;
          if (v16)
          {
            v23 = v20 + 1;
          }

          else
          {
            v23 = v20;
          }

          v12[1] = v22;
          v24 = v13[2];
          v25 = (v24 * v10) >> 64;
          v26 = v24 * v10;
          v16 = __CFADD__(v26, v23);
          v27 = v26 + v23;
          if (v16)
          {
            v28 = v25 + 1;
          }

          else
          {
            v28 = v25;
          }

          v12[2] = v27;
          v29 = v13[3];
          v30 = (v29 * v10) >> 64;
          v31 = v29 * v10;
          v16 = __CFADD__(v31, v28);
          v32 = v31 + v28;
          if (v16)
          {
            v11 = v30 + 1;
          }

          else
          {
            v11 = v30;
          }

          v12[3] = v32;
          v13 += 4;
          v12 += 4;
        }

        if (!i)
        {
          goto LABEL_41;
        }
      }

      else
      {
        v11 = 0;
        v12 = a1;
        v13 = v9;
        i = v6;
      }

      do
      {
        v33 = *v13++;
        v34 = (v33 * v10) >> 64;
        v35 = v33 * v10 + v11;
        if (__CFADD__(v33 * v10, v11))
        {
          v11 = v34 + 1;
        }

        else
        {
          v11 = v34;
        }

        *v12++ = v35;
        --i;
      }

      while (i);
    }

    else
    {
      v11 = 0;
    }

LABEL_41:
    a1[v6] = v11;
    if (v8 != 1)
    {
      v36 = 0;
      v37 = v7 + 4;
      v38 = 2 - v8;
      v39 = &a1[v6 + 2];
      do
      {
        *&v39[v36 * 8 - 8] = bn_mul_add_words(&a1[v36 + 1], v9, v6, v37[v36 - 3]);
        if (!v38)
        {
          break;
        }

        *&v39[v36 * 8] = bn_mul_add_words(&a1[v36 + 2], v9, v6, v37[v36 - 2]);
        if (v38 == -1)
        {
          break;
        }

        *&v39[v36 * 8 + 8] = bn_mul_add_words(&a1[v36 + 3], v9, v6, v37[v36 - 1]);
        if (v38 == -2)
        {
          break;
        }

        *&v39[v36 * 8 + 16] = bn_mul_add_words(&a1[v36 + 4], v9, v6, v37[v36]);
        v38 += 4;
        v36 += 4;
      }

      while (v38 != 1);
    }

    return;
  }

  if (v6)
  {

    bzero(a1, 8 * v6);
  }
}

int BN_mul_word(BIGNUM *a, unint64_t w)
{
  top = a->top;
  if (!top)
  {
    return 1;
  }

  if (!w)
  {
    a->neg = 0;
    a->top = 0;
    return 1;
  }

  d = a->d;
  if (top < 4)
  {
    v4 = 0;
    v5 = a->d;
    v6 = a->top;
    do
    {
LABEL_21:
      v25 = *v5 * w;
      v11 = __CFADD__(v25, v4);
      v26 = v25 + v4;
      if (v11)
      {
        v4 = ((*v5 * w) >> 64) + 1;
      }

      else
      {
        v4 = (*v5 * w) >> 64;
      }

      *v5++ = v26;
      --v6;
    }

    while (v6);
    goto LABEL_25;
  }

  v4 = 0;
  v5 = a->d;
  v6 = a->top;
  do
  {
    v8 = v5[1];
    v9 = (*v5 * w) >> 64;
    v10 = *v5 * w;
    v11 = __CFADD__(v10, v4);
    v12 = v10 + v4;
    if (v11)
    {
      ++v9;
    }

    v13 = (v8 * w) >> 64;
    v14 = v8 * w;
    v11 = __CFADD__(v14, v9);
    v15 = v14 + v9;
    if (v11)
    {
      v16 = v13 + 1;
    }

    else
    {
      v16 = v13;
    }

    *v5 = v12;
    v5[1] = v15;
    v17 = v5[2];
    v18 = v5[3];
    v19 = (v17 * w) >> 64;
    v20 = v17 * w;
    v11 = __CFADD__(v20, v16);
    v21 = v20 + v16;
    if (v11)
    {
      v22 = v19 + 1;
    }

    else
    {
      v22 = v19;
    }

    v11 = __CFADD__(v18 * w, v22);
    v23 = v18 * w + v22;
    v24 = (v18 * w) >> 64;
    if (v11)
    {
      v4 = v24 + 1;
    }

    else
    {
      v4 = v24;
    }

    v5[2] = v21;
    v5[3] = v23;
    v5 += 4;
    v6 -= 4;
  }

  while (v6 >= 4);
  if (v6)
  {
    goto LABEL_21;
  }

LABEL_25:
  if (!v4)
  {
    return 1;
  }

  v27 = top + 1;
  if (a->dmax >= (top + 1))
  {
LABEL_38:
    a->top = v27;
    d[top] = v4;
    return 1;
  }

  if (v27 < 0x800000)
  {
    if ((a->flags & 2) != 0)
    {
      v28 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
      v29 = 3;
      v30 = 106;
      v31 = 306;
      goto LABEL_42;
    }

    v32 = a;
    v33 = 8 * v27;
    v34 = malloc_type_malloc(v33 + 8, 0xB4E622C9uLL);
    if (!v34)
    {
      v28 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc";
      v29 = 14;
      v30 = 65;
      v31 = 217;
      goto LABEL_42;
    }

    *v34 = v33;
    d = v34 + 1;
    bzero(v34 + 1, 8 * v27);
    a = v32;
    v35 = v32->top;
    if (v35)
    {
      memcpy(d, v32->d, 8 * v35);
      a = v32;
    }

    v36 = a->d;
    if (a->d)
    {
      v38 = *(v36 - 1);
      v37 = v36 - 1;
      v39 = v38 + 8;
      if (v38 != -8)
      {
        bzero(v37, v39);
      }

      free(v37);
      a = v32;
    }

    a->d = d;
    a->dmax = v27;
    top = a->top;
    v27 = top + 1;
    goto LABEL_38;
  }

  v28 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
  v29 = 3;
  v30 = 102;
  v31 = 301;
LABEL_42:
  ERR_put_error(v29, 0, v30, v28, v31);
  return 0;
}

uint64_t bn_sqr_consttime(BIGNUM *a1, BIGNUM *a2, BN_CTX *ctx)
{
  v3 = a1;
  top = a2->top;
  if (top <= 0)
  {
    a1->top = 0;
    a1->neg = 0;
    return 1;
  }

  if ((*(ctx + 56) & 1) == 0)
  {
    v14 = *(ctx + 6);
    if (bssl::Vector<unsigned long>::MaybeGrow(ctx + 3))
    {
      *(*(ctx + 3) + 8 * (*(ctx + 4))++) = v14;
      v7 = v3;
      if (a2 == v3)
      {
        goto LABEL_17;
      }
    }

    else
    {
      *(ctx + 28) = 257;
      ERR_clear_error();
      v7 = v3;
      if (a2 == v3)
      {
        goto LABEL_17;
      }
    }

LABEL_4:
    if (v7)
    {
      goto LABEL_5;
    }

    goto LABEL_18;
  }

  v7 = a1;
  if (a2 != a1)
  {
    goto LABEL_4;
  }

LABEL_17:
  v7 = BN_CTX_get(ctx);
  if (v7)
  {
LABEL_5:
    v8 = 2 * top;
    if (v7->dmax < (2 * top))
    {
      if (top >= 0x400000)
      {
        v9 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
        v10 = 3;
        v11 = 102;
        v12 = 301;
        goto LABEL_81;
      }

      if ((v7->flags & 2) != 0)
      {
        v9 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
        v10 = 3;
        v11 = 106;
        v12 = 306;
      }

      else
      {
        v17 = malloc_type_malloc((16 * top) | 8, 0xB4E622C9uLL);
        if (v17)
        {
          *v17 = 16 * top;
          v18 = v17 + 1;
          bzero(v17 + 1, 16 * top);
          v19 = v7->top;
          if (v19)
          {
            memcpy(v18, v7->d, 8 * v19);
          }

          d = v7->d;
          if (v7->d)
          {
            v22 = *(d - 1);
            v21 = d - 1;
            v23 = v22 + 8;
            if (v22 != -8)
            {
              bzero(v21, v23);
            }

            free(v21);
          }

          v15 = v18;
          v7->d = v18;
          v7->dmax = v8;
          v16 = a2->d;
          if (top == 8)
          {
LABEL_29:
            bn_sqr_comba8(v15, v16);
            v7->neg = 0;
            v7->top = v8;
            if (v7 == v3)
            {
              goto LABEL_77;
            }

LABEL_76:
            result = BN_copy(v3, v7);
            if (!result)
            {
              goto LABEL_78;
            }

            goto LABEL_77;
          }

LABEL_13:
          if (top == 4)
          {
            bn_sqr_comba4(v15, v16);
            v7->neg = 0;
            v7->top = v8;
            if (v7 != v3)
            {
              goto LABEL_76;
            }

            goto LABEL_77;
          }

          v15[2 * top - 1] = 0;
          *v15 = 0;
          if (top == 1)
          {
            v24 = 0;
            v25 = 2;
            v26 = v15;
          }

          else
          {
            v27 = v15 + 1;
            v28 = v16 + 1;
            v29 = *v16;
            v30 = top - 1;
            v74 = v3;
            v31 = 0;
            if (top < 5)
            {
              goto LABEL_88;
            }

            do
            {
              v32 = *v28 * v29;
              v33 = __CFADD__(v32, v31);
              v34 = v32 + v31;
              if (v33)
              {
                v35 = ((*v28 * v29) >> 64) + 1;
              }

              else
              {
                v35 = (*v28 * v29) >> 64;
              }

              *v27 = v34;
              v36 = v28[1];
              v37 = (v36 * v29) >> 64;
              v38 = v36 * v29;
              v33 = __CFADD__(v38, v35);
              v39 = v38 + v35;
              if (v33)
              {
                v40 = v37 + 1;
              }

              else
              {
                v40 = v37;
              }

              v27[1] = v39;
              v41 = v28[2];
              v42 = (v41 * v29) >> 64;
              v43 = v41 * v29;
              v33 = __CFADD__(v43, v40);
              v44 = v43 + v40;
              if (v33)
              {
                v45 = v42 + 1;
              }

              else
              {
                v45 = v42;
              }

              v27[2] = v44;
              v46 = v28[3];
              v47 = (v46 * v29) >> 64;
              v48 = v46 * v29;
              v33 = __CFADD__(v48, v45);
              v49 = v48 + v45;
              if (v33)
              {
                v31 = v47 + 1;
              }

              else
              {
                v31 = v47;
              }

              v27[3] = v49;
              v28 += 4;
              v27 += 4;
              v30 -= 4;
            }

            while (v30 >= 4);
            if (v30)
            {
LABEL_88:
              do
              {
                v50 = *v28++;
                v51 = (v50 * v29) >> 64;
                v52 = v50 * v29 + v31;
                if (__CFADD__(v50 * v29, v31))
                {
                  v31 = v51 + 1;
                }

                else
                {
                  v31 = v51;
                }

                *v27++ = v52;
                --v30;
              }

              while (v30);
            }

            v25 = 2 * top;
            v75 = v15;
            v15[top] = v31;
            if (top > 2)
            {
              v53 = 0;
              v54 = top - 2;
              v55 = v15 + 3;
              v56 = &v15[top + 1];
              do
              {
                v57 = v16;
                v58 = bn_mul_add_words(v55, &v16[v53 / 8 + 2], v54, v16[v53 / 8 + 1]);
                v16 = v57;
                *(v56 + v53) = v58;
                v55 += 2;
                --v54;
                v53 += 8;
              }

              while (8 * top - 16 != v53);
            }

            v24 = 0;
            v15 = v75;
            v26 = v75;
            do
            {
              v59 = v26[1];
              v60 = 2 * *v26;
              v61 = __CFADD__(*v26, *v26);
              v33 = __CFADD__(v60, v24);
              v62 = v60 + v24;
              v63 = v33 || v61;
              v33 = __CFADD__(v63 != 0, v59);
              v64 = (v63 != 0) + v59;
              v33 |= __CFADD__(v59, v64);
              *v26 = v62;
              v26[1] = v59 + v64;
              v65 = v26[2];
              v66 = v26[3];
              v67 = v65 + v33 + v65;
              v69 = (__CFADD__(v33, v65) | __CFADD__(v65, v33 + v65)) + v66;
              v33 = __CFADD__(__CFADD__(v33, v65) | __CFADD__(v65, v33 + v65), v66) | __CFADD__(v66, v69);
              v68 = v66 + v69;
              v24 = v33;
              v26[2] = v67;
              v26[3] = v68;
              v26 += 4;
              v25 -= 4;
            }

            while (v25 >= 4);
            v3 = v74;
            if (!v25)
            {
LABEL_75:
              bn_sqr_add_words(v15, v16, top);
              v7->neg = 0;
              v7->top = v8;
              if (v7 != v3)
              {
                goto LABEL_76;
              }

LABEL_77:
              result = 1;
LABEL_78:
              if (*(ctx + 56))
              {
                return result;
              }

              goto LABEL_82;
            }
          }

          do
          {
            v70 = 2 * *v26;
            v71 = __CFADD__(*v26, *v26);
            v33 = __CFADD__(v70, v24);
            v72 = v70 + v24;
            v24 = v33 || v71;
            *v26++ = v72;
            --v25;
          }

          while (v25);
          goto LABEL_75;
        }

        v9 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc";
        v10 = 14;
        v11 = 65;
        v12 = 217;
      }

LABEL_81:
      ERR_put_error(v10, 0, v11, v9, v12);
      result = 0;
      if (*(ctx + 56))
      {
        return result;
      }

      goto LABEL_82;
    }

    v15 = v7->d;
    v16 = a2->d;
    if (top == 8)
    {
      goto LABEL_29;
    }

    goto LABEL_13;
  }

LABEL_18:
  result = 0;
  if (*(ctx + 56))
  {
    return result;
  }

LABEL_82:
  v73 = *(ctx + 4);
  if (!v73)
  {
    abort();
  }

  *(ctx + 6) = *(*(ctx + 3) + 8 * v73 - 8);
  *(ctx + 4) = v73 - 1;
  return result;
}

uint64_t bn_miller_rabin_init(uint64_t a1, BIGNUM *a2, BN_CTX *ctx)
{
  *a1 = BN_CTX_get(ctx);
  *(a1 + 8) = BN_CTX_get(ctx);
  *(a1 + 16) = BN_CTX_get(ctx);
  v6 = BN_CTX_get(ctx);
  *(a1 + 24) = v6;
  v7 = *a1;
  if (!*a1 || !*(a1 + 8) || !*(a1 + 16) || !v6)
  {
    return 0;
  }

  if (pthread_once(&_MergedGlobals, BN_value_one_init))
  {
    abort();
  }

  if (!bn_usub_consttime(v7, &a2[1].d, &_MergedGlobals_95))
  {
    return 0;
  }

  v8 = *a1;
  v9 = *(*a1 + 8);
  if (v9 < 1)
  {
    *(a1 + 36) = 0;
    if (!bn_rshift_secret_shift(*(a1 + 8), v8, 0, ctx))
    {
      return 0;
    }
  }

  else
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    d = v8->d;
    v14 = v9 << 6;
    do
    {
      v15 = *d++;
      v16 = (((v15 << 32) - 1) & ~(v15 << 32)) >> 63;
      v17 = v16 & 0x20;
      v18 = v16 & HIDWORD(v15) | v15 & ~v16;
      v19 = (((v18 << 48) - 1) & ~(v18 << 48)) >> 63;
      v20 = v19 & 0x10;
      v21 = v19 & (v18 >> 16) | v18 & ~v19;
      v22 = (((v21 << 56) - 1) & ~(v21 << 56)) >> 63;
      v23 = v22 & 8;
      v24 = v22 & (v21 >> 8) | v21 & ~v22;
      v25 = (((v24 << 60) - 1) & ~(v24 << 60)) >> 63;
      v26 = v25 & (v24 >> 4) | v24 & ~v25;
      v27 = (((v26 << 62) - 1) & ~(v26 << 62)) >> 63;
      v28 = ((v15 - 1) & ~v15) >> 63;
      v29 = (v27 & (v26 >> 2) | v26 & ~v27) << 63;
      v30 = v17 | v20 | v23 | v25 & 4 | v27 & 2 | (((v29 - 1) & ~v29) >> 63);
      LODWORD(v29) = v28 | v12;
      v12 |= ~v28;
      v11 |= (v10 + v30) & ~v29;
      v10 += 64;
    }

    while (v14 != v10);
    *(a1 + 36) = v11;
    if (!bn_rshift_secret_shift(*(a1 + 8), v8, v11, ctx))
    {
      return 0;
    }
  }

  top = a2[1].top;
  if (top < 1)
  {
    if (!top)
    {
      goto LABEL_33;
    }

    v32 = a2[1].d;
  }

  else
  {
    v32 = a2[1].d;
    while (!v32[top - 1])
    {
      v33 = __OFSUB__(top--, 1);
      if ((top < 0) ^ v33 | (top == 0))
      {
        top = 0;
        goto LABEL_33;
      }
    }
  }

  v34 = top - 1;
  v35 = v32[v34];
  v36 = v35 != 0;
  v37 = HIDWORD(v35) != 0;
  if (HIDWORD(v35))
  {
    v35 >>= 32;
  }

  v38 = v35 >> 16 != 0;
  if (v35 >> 16)
  {
    v35 >>= 16;
  }

  v39 = v35 > 0xFF;
  if (v35 > 0xFF)
  {
    v35 >>= 8;
  }

  v40 = v35 > 0xF;
  if (v35 > 0xF)
  {
    v35 >>= 4;
  }

  v41 = v35 > 3;
  if (v35 > 3)
  {
    v35 >>= 2;
  }

  top = v36 | (v34 << 6) | (32 * v37) | (16 * v38) | (8 * v39) | (4 * v40) | (2 * v41);
  if (v35 > 1)
  {
    ++top;
  }

LABEL_33:
  *(a1 + 32) = top;
  if (!bn_one_to_montgomery(*(a1 + 16), a2, ctx))
  {
    return 0;
  }

  v43 = *(a1 + 16);
  v42 = *(a1 + 24);

  return bn_usub_consttime(v42, &a2[1].d, v43);
}

uint64_t BN_primality_test(_BOOL4 *a1, const bignum_st *a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  v11 = a1;
  *a1 = 0;
  if (pthread_once(&_MergedGlobals, BN_value_one_init))
  {
    goto LABEL_320;
  }

  if (a2)
  {
    neg = a2->neg;
    if (neg == dword_2808D4520)
    {
      v13 = BN_ucmp(a2, &_MergedGlobals_95);
      if (neg)
      {
        v14 = -v13;
      }

      else
      {
        v14 = v13;
      }

      if (v14 < 1)
      {
        return 1;
      }
    }

    else if (neg)
    {
      return 1;
    }
  }

  top = a2->top;
  if (top < 1)
  {
    if (!top)
    {
LABEL_26:
      v31 = 0;
LABEL_65:
      *v11 = v31;
      return 1;
    }

    v18 = *a2->d ^ 2;
    goto LABEL_25;
  }

  d = a2->d;
  v17 = *a2->d;
  if ((v17 & 1) == 0)
  {
    v18 = v17 ^ 2;
    if (top == 1)
    {
      goto LABEL_25;
    }

    if (top >= 5)
    {
      v22 = (top - 1) & 0xFFFFFFFFFFFFFFFCLL;
      v19 = v22 | 1;
      v23 = 0uLL;
      v24 = v17 ^ 2uLL;
      v25 = (d + 3);
      v26 = v22;
      do
      {
        v24 = vorrq_s8(v25[-1], v24);
        v23 = vorrq_s8(*v25, v23);
        v25 += 2;
        v26 -= 4;
      }

      while (v26);
      v27 = vorrq_s8(v23, v24);
      v18 = vorr_s8(*v27.i8, *&vextq_s8(v27, v27, 8uLL));
      if (top - 1 == v22)
      {
LABEL_25:
        if (v18)
        {
          goto LABEL_26;
        }

LABEL_64:
        v31 = a2->neg == 0;
        goto LABEL_65;
      }
    }

    else
    {
      v19 = 1;
    }

    v28 = top - v19;
    v29 = &d[v19];
    do
    {
      v30 = *v29++;
      v18 |= v30;
      --v28;
    }

    while (v28);
    goto LABEL_25;
  }

  v20 = v17 ^ 3;
  if (top != 1)
  {
    if (top >= 5)
    {
      v32 = (top - 1) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = v32 | 1;
      v33 = 0uLL;
      v34 = v17 ^ 3uLL;
      v35 = (d + 3);
      v36 = v32;
      do
      {
        v34 = vorrq_s8(v35[-1], v34);
        v33 = vorrq_s8(*v35, v33);
        v35 += 2;
        v36 -= 4;
      }

      while (v36);
      v37 = vorrq_s8(v33, v34);
      v20 = vorr_s8(*v37.i8, *&vextq_s8(v37, v37, 8uLL));
      if (top - 1 == v32)
      {
        goto LABEL_32;
      }
    }

    else
    {
      v21 = 1;
    }

    v38 = top - v21;
    v39 = &d[v21];
    do
    {
      v40 = *v39++;
      v20 |= v40;
      --v38;
    }

    while (v38);
  }

LABEL_32:
  if (!v20 && !a2->neg)
  {
    result = 1;
    *v11 = 1;
    return result;
  }

  if (a5)
  {
    v331 = a4;
    if (top <= 16)
    {
      v41 = 512;
    }

    else
    {
      v41 = 1024;
    }

    if (!bn_mod_u16_consttime(a2, 3u))
    {
      v42 = v17 ^ 3;
      if (top == 1)
      {
        goto LABEL_63;
      }

      goto LABEL_40;
    }

    v327 = a6;
    v329 = v11;
    v44 = v41 - 2;
    v45 = -1;
    v46 = &word_273BA753C;
    do
    {
      if (!v44)
      {
        goto LABEL_48;
      }

      v48 = *v46++;
      v47 = v48;
      --v45;
      --v44;
    }

    while (bn_mod_u16_consttime(a2, v48));
    if (-v45 < v41)
    {
      v11 = v329;
      v42 = v17 ^ v47;
      if (top == 1)
      {
        goto LABEL_63;
      }

LABEL_40:
      if (top >= 5)
      {
        v53 = (top - 1) & 0xFFFFFFFFFFFFFFFCLL;
        v43 = v53 | 1;
        v54 = 0uLL;
        v55 = v42;
        v56 = (d + 3);
        v57 = v53;
        do
        {
          v55 = vorrq_s8(v56[-1], v55);
          v54 = vorrq_s8(*v56, v54);
          v56 += 2;
          v57 -= 4;
        }

        while (v57);
        v58 = vorrq_s8(v54, v55);
        v42 = vorr_s8(*v58.i8, *&vextq_s8(v58, v58, 8uLL));
        if (top - 1 == v53)
        {
LABEL_63:
          if (v42)
          {
            goto LABEL_26;
          }

          goto LABEL_64;
        }
      }

      else
      {
        v43 = 1;
      }

      v59 = top - v43;
      v60 = &d[v43];
      do
      {
        v61 = *v60++;
        v42 |= v61;
        --v59;
      }

      while (v59);
      goto LABEL_63;
    }

LABEL_48:
    v11 = v329;
    a4 = v331;
    a6 = v327;
    if (v327)
    {
      result = (*(v327 + 8))(1, 0xFFFFFFFFLL, v327);
      if (!result)
      {
        return result;
      }
    }
  }

  if (!a3)
  {
    v50 = a2->top;
    if (v50 < 1)
    {
      if (!v50)
      {
LABEL_84:
        a3 = 34;
        goto LABEL_98;
      }

      v51 = a2->d;
    }

    else
    {
      v51 = a2->d;
      while (!a2->d[v50 - 1])
      {
        v52 = __OFSUB__(v50--, 1);
        if ((v50 < 0) ^ v52 | (v50 == 0))
        {
          goto LABEL_84;
        }
      }
    }

    v62 = v50 - 1;
    v63 = v51[v62];
    v64 = v63 != 0;
    v65 = HIDWORD(v63) != 0;
    if (HIDWORD(v63))
    {
      v63 >>= 32;
    }

    v66 = v63 >> 16 != 0;
    if (v63 >> 16)
    {
      v63 >>= 16;
    }

    v67 = v63 > 0xFF;
    if (v63 > 0xFF)
    {
      v63 >>= 8;
    }

    v68 = v63 > 0xF;
    if (v63 > 0xF)
    {
      v63 >>= 4;
    }

    v69 = v63 > 3;
    if (v63 > 3)
    {
      v63 >>= 2;
    }

    v70 = v64 | (v62 << 6) | (32 * v65) | (16 * v66) | (8 * v67) | (4 * v68) | (2 * v69);
    if (v63 > 1)
    {
      ++v70;
    }

    if (v70 <= 3746)
    {
      if (v70 <= 1344)
      {
        if (v70 <= 475)
        {
          if (v70 <= 399)
          {
            if (v70 <= 346)
            {
              if (v70 <= 307)
              {
                if (v70 <= 54)
                {
                  a3 = 34;
                }

                else
                {
                  a3 = 27;
                }
              }

              else
              {
                a3 = 8;
              }
            }

            else
            {
              a3 = 7;
            }
          }

          else
          {
            a3 = 6;
          }
        }

        else
        {
          a3 = 5;
        }
      }

      else
      {
        a3 = 4;
      }
    }

    else
    {
      a3 = 3;
    }
  }

LABEL_98:
  if (a4)
  {
    v71 = 0;
    if (*(a4 + 56))
    {
      goto LABEL_106;
    }

    goto LABEL_103;
  }

  v72 = malloc_type_malloc(0x48uLL, 0xB4E622C9uLL);
  if (!v72)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc", 217);
    return 0;
  }

  *v72 = 64;
  *(v72 + 8) = 0u;
  v71 = (v72 + 8);
  *(v72 + 24) = 0u;
  *(v72 + 40) = 0u;
  *(v72 + 56) = 0u;
  a4 = (v72 + 8);
  if ((v72[64] & 1) == 0)
  {
LABEL_103:
    v73 = *(a4 + 48);
    if (bssl::Vector<unsigned long>::MaybeGrow((a4 + 24)))
    {
      *(*(a4 + 24) + 8 * (*(a4 + 32))++) = v73;
    }

    else
    {
      *(a4 + 56) = 257;
      ERR_clear_error();
    }
  }

LABEL_106:
  v74 = BN_CTX_get(a4);
  v75 = malloc_type_malloc(0x48uLL, 0xB4E622C9uLL);
  if (!v75)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc", 217);
    v76 = 0;
LABEL_303:
    BN_MONT_CTX_free(v76);
    v309 = 0;
    v336 = 0;
    goto LABEL_304;
  }

  *v75 = 64;
  *(v75 + 8) = 0u;
  v76 = (v75 + 8);
  *(v75 + 24) = 0u;
  *(v75 + 40) = 0u;
  v330 = v75;
  *(v75 + 56) = 0u;
  if (!bn_mont_ctx_set_N_and_n0((v75 + 8), a2) || !bn_mont_ctx_set_RR_consttime(v76, a4))
  {
    goto LABEL_303;
  }

  v336 = v76;
  if (!v74 || !bn_miller_rabin_init(v333, v76, a4))
  {
LABEL_311:
    v309 = 0;
    goto LABEL_304;
  }

  v77 = 0;
  v78 = v333[0];
  p = v333[1];
  v316 = a3;
  v317 = v333[2];
  v321 = v333[3];
  v322 = 1;
  v319 = v335;
  v320 = v334;
  v323 = v333[0];
  v324 = v71;
  v328 = v74;
  v318 = v76;
  while (1)
  {
    v79 = *(v78 + 2);
    if (!v79)
    {
      goto LABEL_312;
    }

    v80 = 0;
    v81 = 0;
    v82 = *v78;
    v83 = v79 - 1;
    v84 = v79;
    while (1)
    {
      v85 = v82[v79 - 1 + v81];
      if (v85)
      {
        break;
      }

      --v81;
      v80 += 8;
      --v83;
      --v84;
      if (!(v79 + v81))
      {
        goto LABEL_312;
      }
    }

    v86 = v79 + v81;
    v87 = v79 + v81 - 1;
    if (v79 + v81 == 1 && *v82 <= 2uLL)
    {
LABEL_312:
      v306 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/random.cc.inc";
      v307 = 108;
      v308 = 134;
LABEL_313:
      ERR_put_error(3, 0, v307, v306, v308);
      v309 = 0;
      v71 = v324;
      goto LABEL_304;
    }

    v88 = 8 * v79;
    v315 = v77;
    v325 = v79 + v81;
    if (v86 > v328->dmax)
    {
      break;
    }

LABEL_130:
    v97 = v85 | (v85 >> 1) | ((v85 | (v85 >> 1)) >> 2);
    v98 = v97 | (v97 >> 4) | ((v97 | (v97 >> 4)) >> 8);
    v99 = v98 | (v98 >> 16) | ((v98 | (v98 >> 16)) >> 32);
    if (!v87 && v99 <= 3)
    {
      v306 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/random.cc.inc";
      v307 = 108;
      v308 = 227;
      goto LABEL_313;
    }

    v100 = v88 - v80;
    v101 = v88;
    BCM_rand_bytes_with_additional_data(v328->d, v100, BCM_rand_bytes::kZeroAdditionalData);
    v102 = v99;
    v103 = v328->d;
    v104 = &v328->d[v81] + v101;
    *(v104 - 8) &= v99;
    v105 = v79 + v81;
    if (v325 == 1)
    {
      v107 = 0;
      v71 = v324;
    }

    else
    {
      v71 = v324;
      if (!v325)
      {
        goto LABEL_145;
      }

      v106 = v79 + v81 - 1;
      if (v106 > 3)
      {
        v108 = v106 & 0xFFFFFFFFFFFFFFFCLL | 1;
        v109 = (v103 + 24);
        v110 = v83 & 0xFFFFFFFFFFFFFFFCLL;
        v111 = 0uLL;
        v112 = 0uLL;
        do
        {
          v111 = vorrq_s8(v109[-1], v111);
          v112 = vorrq_s8(*v109, v112);
          v109 += 2;
          v110 -= 4;
        }

        while (v110);
        v113 = vorrq_s8(v112, v111);
        v107 = vorr_s8(*v113.i8, *&vextq_s8(v113, v113, 8uLL));
        if (v106 == (v106 & 0xFFFFFFFFFFFFFFFCLL))
        {
          goto LABEL_142;
        }
      }

      else
      {
        v107 = 0;
        v108 = 1;
      }

      v114 = v84 - v108;
      v115 = &v103[8 * v108];
      do
      {
        v116 = *v115;
        v115 += 8;
        *&v107 |= v116;
        --v114;
      }

      while (v114);
    }

LABEL_142:
    v117 = 0;
    v118 = 0;
    v119 = (1 - *v103) | *&v107 | -*&v107 | *v103;
    do
    {
      v120 = *&v103[8 * v118];
      v121 = *(*v323 + 8 * v118);
      v122 = (((v121 ^ v120) - 1) & ~(v121 ^ v120)) >> 63;
      v117 = v122 & v117 | ((((v120 - v121) ^ v120 | v121 ^ v120) ^ v120) >> 63) & ~v122;
      ++v118;
    }

    while (v84 != v118);
    v105 = (v119 >> 63) & (v117 >> 31);
LABEL_145:
    v326 = v105;
    *v103 |= (v105 - 1) & 2;
    *(v104 - 8) &= -v105 | (v102 >> 1);
    v328->neg = 0;
    v328->top = v79 + v81;
    if ((*(a4 + 56) & 1) == 0)
    {
      v123 = *(a4 + 48);
      if (bssl::Vector<unsigned long>::MaybeGrow((a4 + 24)))
      {
        *(*(a4 + 24) + 8 * (*(a4 + 32))++) = v123;
      }

      else
      {
        *(a4 + 56) = 257;
        ERR_clear_error();
      }
    }

    v124 = BN_CTX_get(a4);
    if (!v124 || (v125 = v124, !BN_mod_exp_mont_consttime(v124, v328, p, (v330 + 32), a4, v318)) || !BN_mod_mul_montgomery(v125, v125, v318, v318, a4))
    {
      v133 = 1;
      v134 = 1;
      goto LABEL_292;
    }

    v126 = v125->top;
    v127 = *(v317 + 8);
    if (v126 >= v127)
    {
      v131 = 0;
      v130 = v321;
      goto LABEL_162;
    }

    v128 = *v317;
    v129 = v127 - v126;
    v130 = v321;
    if ((v127 - v126) <= 3)
    {
      v131 = 0;
      v132 = v125->top;
LABEL_160:
      v140 = v127 - v132;
      v141 = &v128->i64[v132];
      do
      {
        v142 = *v141++;
        *&v131 |= v142;
        --v140;
      }

      while (v140);
      goto LABEL_162;
    }

    v132 = (v129 & 0xFFFFFFFFFFFFFFFCLL) + v126;
    v135 = (v128 + 8 * v126 + 16);
    v136 = 0uLL;
    v137 = v129 & 0xFFFFFFFFFFFFFFFCLL;
    v138 = 0uLL;
    do
    {
      v136 = vorrq_s8(v135[-1], v136);
      v138 = vorrq_s8(*v135, v138);
      v135 += 2;
      v137 -= 4;
    }

    while (v137);
    v139 = vorrq_s8(v138, v136);
    v131 = vorr_s8(*v139.i8, *&vextq_s8(v139, v139, 8uLL));
    if (v129 != (v129 & 0xFFFFFFFFFFFFFFFCLL))
    {
      goto LABEL_160;
    }

LABEL_162:
    if (v127 < v126)
    {
      v143 = v125->d;
      v144 = v126 - v127;
      if ((v126 - v127) > 3)
      {
        v145 = (v144 & 0xFFFFFFFFFFFFFFFCLL) + v127;
        v146 = 0uLL;
        v147 = v131;
        v148 = &v143[v127 + 2];
        v149 = v144 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v147 = vorrq_s8(v148[-1], v147);
          v146 = vorrq_s8(*v148, v146);
          v148 += 2;
          v149 -= 4;
        }

        while (v149);
        v150 = vorrq_s8(v146, v147);
        v131 = vorr_s8(*v150.i8, *&vextq_s8(v150, v150, 8uLL));
        if (v144 == (v144 & 0xFFFFFFFFFFFFFFFCLL))
        {
          goto LABEL_170;
        }
      }

      else
      {
        v145 = *(v317 + 8);
      }

      v151 = v126 - v145;
      v152 = &v143[v145];
      do
      {
        v153 = *v152++;
        *&v131 |= v153;
        --v151;
      }

      while (v151);
    }

LABEL_170:
    if (v126 >= v127)
    {
      v154 = v127;
    }

    else
    {
      v154 = v126;
    }

    if (v154 >= 1)
    {
      v155 = v125->d;
      v156 = *v317;
      if (v154 <= 3)
      {
        v157 = 0;
LABEL_179:
        v164 = v154 - v157;
        v165 = v157;
        v166 = &v156->i64[v165];
        v167 = &v155->i64[v165];
        do
        {
          v169 = *v167++;
          v168 = v169;
          v170 = *v166++;
          *&v131 |= v170 ^ v168;
          --v164;
        }

        while (v164);
        goto LABEL_181;
      }

      v157 = v154 & 0x7FFFFFFC;
      v158 = 0uLL;
      v159 = v131;
      v160 = v155 + 1;
      v161 = v156 + 1;
      v162 = v157;
      do
      {
        v159 = vorrq_s8(veorq_s8(v161[-1], v160[-1]), v159);
        v158 = vorrq_s8(veorq_s8(*v161, *v160), v158);
        v160 += 2;
        v161 += 2;
        v162 -= 4;
      }

      while (v162);
      v163 = vorrq_s8(v158, v159);
      v131 = vorr_s8(*v163.i8, *&vextq_s8(v163, v163, 8uLL));
      if (v157 != v154)
      {
        goto LABEL_179;
      }
    }

LABEL_181:
    v171 = v125->neg;
    v172 = *(v130 + 8);
    if (v126 >= v172)
    {
      v175 = 0;
      goto LABEL_190;
    }

    v173 = *v130;
    v174 = v172 - v126;
    if ((v172 - v126) <= 3)
    {
      v175 = 0;
      v176 = v125->top;
LABEL_188:
      v182 = v172 - v176;
      v183 = &v173->i64[v176];
      do
      {
        v184 = *v183++;
        *&v175 |= v184;
        --v182;
      }

      while (v182);
      goto LABEL_190;
    }

    v176 = (v174 & 0xFFFFFFFFFFFFFFFCLL) + v126;
    v177 = (v173 + 8 * v126 + 16);
    v178 = 0uLL;
    v179 = v174 & 0xFFFFFFFFFFFFFFFCLL;
    v180 = 0uLL;
    do
    {
      v178 = vorrq_s8(v177[-1], v178);
      v180 = vorrq_s8(*v177, v180);
      v177 += 2;
      v179 -= 4;
    }

    while (v179);
    v181 = vorrq_s8(v180, v178);
    v175 = vorr_s8(*v181.i8, *&vextq_s8(v181, v181, 8uLL));
    v130 = v321;
    if (v174 != (v174 & 0xFFFFFFFFFFFFFFFCLL))
    {
      goto LABEL_188;
    }

LABEL_190:
    if (v172 < v126)
    {
      v185 = v125->d;
      v186 = v126 - v172;
      if ((v126 - v172) > 3)
      {
        v187 = (v186 & 0xFFFFFFFFFFFFFFFCLL) + v172;
        v188 = 0uLL;
        v189 = v175;
        v190 = &v185[v172 + 2];
        v191 = v186 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v189 = vorrq_s8(v190[-1], v189);
          v188 = vorrq_s8(*v190, v188);
          v190 += 2;
          v191 -= 4;
        }

        while (v191);
        v192 = vorrq_s8(v188, v189);
        v175 = vorr_s8(*v192.i8, *&vextq_s8(v192, v192, 8uLL));
        v130 = v321;
        if (v186 == (v186 & 0xFFFFFFFFFFFFFFFCLL))
        {
          goto LABEL_198;
        }
      }

      else
      {
        v187 = v172;
      }

      v193 = v126 - v187;
      v194 = &v185[v187];
      do
      {
        v195 = *v194++;
        *&v175 |= v195;
        --v193;
      }

      while (v193);
    }

LABEL_198:
    if (v126 >= v172)
    {
      v172 = v172;
    }

    else
    {
      v172 = v126;
    }

    if (v172 < 1)
    {
      v198 = a4;
      goto LABEL_210;
    }

    v196 = v125->d;
    v197 = *v130;
    if (v172 <= 3)
    {
      v198 = a4;
      v199 = 0;
LABEL_208:
      v206 = v172 - v199;
      v207 = v199;
      v208 = &v197->i64[v207];
      v209 = &v196->i64[v207];
      do
      {
        v211 = *v209++;
        v210 = v211;
        v212 = *v208++;
        *&v175 |= v212 ^ v210;
        --v206;
      }

      while (v206);
      goto LABEL_210;
    }

    v199 = v172 & 0x7FFFFFFC;
    v200 = 0uLL;
    v201 = v175;
    v202 = v196 + 1;
    v203 = v197 + 1;
    v204 = v199;
    do
    {
      v201 = vorrq_s8(veorq_s8(v203[-1], v202[-1]), v201);
      v200 = vorrq_s8(veorq_s8(*v203, *v202), v200);
      v202 += 2;
      v203 += 2;
      v204 -= 4;
    }

    while (v204);
    v198 = a4;
    v205 = vorrq_s8(v200, v201);
    v175 = vorr_s8(*v205.i8, *&vextq_s8(v205, v205, 8uLL));
    if (v199 != v172)
    {
      goto LABEL_208;
    }

LABEL_210:
    if (*&v131 | *(v317 + 16) ^ v171)
    {
      v213 = (*&v175 | *(v130 + 16) ^ v171) == 0;
    }

    else
    {
      v213 = 1;
    }

    v214 = v213;
    v215 = v214 << 63 >> 63;
    if (v320 > 1)
    {
      v216 = 1;
      while (1)
      {
        if (v319 == v216)
        {
          v219 = ~v215;
        }

        else
        {
          v219 = 0;
        }

        if (v219)
        {
          goto LABEL_290;
        }

        if (!BN_mod_mul_montgomery(v125, v125, v125, v318, v198))
        {
          v133 = 1;
          v134 = 1;
          goto LABEL_291;
        }

        v220 = v125->top;
        v221 = *(v321 + 8);
        if (v220 >= v221)
        {
          v224 = 0;
          goto LABEL_240;
        }

        v222 = *v321;
        v223 = v221 - v220;
        if ((v221 - v220) <= 3)
        {
          break;
        }

        v225 = (v223 & 0xFFFFFFFFFFFFFFFCLL) + v220;
        v226 = (v222 + 8 * v220 + 16);
        v227 = 0uLL;
        v228 = v223 & 0xFFFFFFFFFFFFFFFCLL;
        v229 = 0uLL;
        do
        {
          v227 = vorrq_s8(v226[-1], v227);
          v229 = vorrq_s8(*v226, v229);
          v226 += 2;
          v228 -= 4;
        }

        while (v228);
        v230 = vorrq_s8(v229, v227);
        v224 = vorr_s8(*v230.i8, *&vextq_s8(v230, v230, 8uLL));
        if (v223 != (v223 & 0xFFFFFFFFFFFFFFFCLL))
        {
          goto LABEL_238;
        }

LABEL_240:
        if (v221 < v220)
        {
          v234 = v125->d;
          v235 = v220 - v221;
          if ((v220 - v221) > 3)
          {
            v236 = (v235 & 0xFFFFFFFFFFFFFFFCLL) + v221;
            v237 = 0uLL;
            v238 = v224;
            v239 = &v234[v221 + 2];
            v240 = v235 & 0xFFFFFFFFFFFFFFFCLL;
            do
            {
              v238 = vorrq_s8(v239[-1], v238);
              v237 = vorrq_s8(*v239, v237);
              v239 += 2;
              v240 -= 4;
            }

            while (v240);
            v241 = vorrq_s8(v237, v238);
            v224 = vorr_s8(*v241.i8, *&vextq_s8(v241, v241, 8uLL));
            if (v235 == (v235 & 0xFFFFFFFFFFFFFFFCLL))
            {
              goto LABEL_248;
            }
          }

          else
          {
            v236 = *(v321 + 8);
          }

          v242 = v220 - v236;
          v243 = &v234[v236];
          do
          {
            v244 = *v243++;
            *&v224 |= v244;
            --v242;
          }

          while (v242);
        }

LABEL_248:
        if (v220 >= v221)
        {
          v245 = v221;
        }

        else
        {
          v245 = v220;
        }

        if (v245 >= 1)
        {
          v246 = v125->d;
          v247 = *v321;
          if (v245 <= 3)
          {
            v248 = 0;
LABEL_257:
            v255 = v245 - v248;
            v256 = v248;
            v257 = &v247->i64[v256];
            v258 = &v246->i64[v256];
            do
            {
              v260 = *v258++;
              v259 = v260;
              v261 = *v257++;
              *&v224 |= v261 ^ v259;
              --v255;
            }

            while (v255);
            goto LABEL_259;
          }

          v248 = v245 & 0x7FFFFFFC;
          v249 = 0uLL;
          v250 = v224;
          v251 = v246 + 1;
          v252 = v247 + 1;
          v253 = v248;
          do
          {
            v250 = vorrq_s8(veorq_s8(v252[-1], v251[-1]), v250);
            v249 = vorrq_s8(veorq_s8(*v252, *v251), v249);
            v251 += 2;
            v252 += 2;
            v253 -= 4;
          }

          while (v253);
          v254 = vorrq_s8(v249, v250);
          v224 = vorr_s8(*v254.i8, *&vextq_s8(v254, v254, 8uLL));
          if (v248 != v245)
          {
            goto LABEL_257;
          }
        }

LABEL_259:
        v262 = v125->neg;
        if (!(*&v224 | *(v321 + 16) ^ v262))
        {
          v215 = -1;
        }

        v263 = *(v317 + 8);
        if (v220 >= v263)
        {
          v266 = 0;
          goto LABEL_270;
        }

        v264 = *v317;
        v265 = v263 - v220;
        if ((v263 - v220) <= 3)
        {
          v266 = 0;
          v267 = v125->top;
LABEL_268:
          v273 = v263 - v267;
          v274 = &v264->i64[v267];
          do
          {
            v275 = *v274++;
            *&v266 |= v275;
            --v273;
          }

          while (v273);
          goto LABEL_270;
        }

        v267 = (v265 & 0xFFFFFFFFFFFFFFFCLL) + v220;
        v268 = (v264 + 8 * v220 + 16);
        v269 = 0uLL;
        v270 = v265 & 0xFFFFFFFFFFFFFFFCLL;
        v271 = 0uLL;
        do
        {
          v269 = vorrq_s8(v268[-1], v269);
          v271 = vorrq_s8(*v268, v271);
          v268 += 2;
          v270 -= 4;
        }

        while (v270);
        v272 = vorrq_s8(v271, v269);
        v266 = vorr_s8(*v272.i8, *&vextq_s8(v272, v272, 8uLL));
        if (v265 != (v265 & 0xFFFFFFFFFFFFFFFCLL))
        {
          goto LABEL_268;
        }

LABEL_270:
        if (v263 < v220)
        {
          v276 = v125->d;
          v277 = v220 - v263;
          if ((v220 - v263) > 3)
          {
            v278 = (v277 & 0xFFFFFFFFFFFFFFFCLL) + v263;
            v279 = 0uLL;
            v280 = v266;
            v281 = &v276[v263 + 2];
            v282 = v277 & 0xFFFFFFFFFFFFFFFCLL;
            do
            {
              v280 = vorrq_s8(v281[-1], v280);
              v279 = vorrq_s8(*v281, v279);
              v281 += 2;
              v282 -= 4;
            }

            while (v282);
            v283 = vorrq_s8(v279, v280);
            v266 = vorr_s8(*v283.i8, *&vextq_s8(v283, v283, 8uLL));
            if (v277 == (v277 & 0xFFFFFFFFFFFFFFFCLL))
            {
              goto LABEL_278;
            }
          }

          else
          {
            v278 = *(v317 + 8);
          }

          v284 = v220 - v278;
          v285 = &v276[v278];
          do
          {
            v286 = *v285++;
            *&v266 |= v286;
            --v284;
          }

          while (v284);
        }

LABEL_278:
        if (v220 >= v263)
        {
          v263 = v263;
        }

        else
        {
          v263 = v220;
        }

        if (v263 < 1)
        {
          goto LABEL_218;
        }

        v287 = v125->d;
        v288 = *v317;
        if (v263 <= 3)
        {
          v289 = 0;
LABEL_287:
          v296 = v263 - v289;
          v297 = v289;
          v298 = &v288->i64[v297];
          v299 = &v287->i64[v297];
          do
          {
            v301 = *v299++;
            v300 = v301;
            v302 = *v298++;
            *&v266 |= v302 ^ v300;
            --v296;
          }

          while (v296);
          goto LABEL_218;
        }

        v289 = v263 & 0x7FFFFFFC;
        v290 = 0uLL;
        v291 = v266;
        v292 = v287 + 1;
        v293 = v288 + 1;
        v294 = v289;
        do
        {
          v291 = vorrq_s8(veorq_s8(v293[-1], v292[-1]), v291);
          v290 = vorrq_s8(veorq_s8(*v293, *v292), v290);
          v292 += 2;
          v293 += 2;
          v294 -= 4;
        }

        while (v294);
        v295 = vorrq_s8(v290, v291);
        v266 = vorr_s8(*v295.i8, *&vextq_s8(v295, v295, 8uLL));
        if (v289 != v263)
        {
          goto LABEL_287;
        }

LABEL_218:
        if (*&v266 | *(v317 + 16) ^ v262)
        {
          v217 = 0;
        }

        else
        {
          v217 = (v215 & 1) == 0;
        }

        ++v216;
        if (v217 || v216 >= v320)
        {
          goto LABEL_290;
        }
      }

      v224 = 0;
      v225 = v125->top;
LABEL_238:
      v231 = v221 - v225;
      v232 = &v222->i64[v225];
      do
      {
        v233 = *v232++;
        *&v224 |= v233;
        --v231;
      }

      while (v231);
      goto LABEL_240;
    }

LABEL_290:
    v134 = 0;
    v133 = (v215 & 1) == 0;
LABEL_291:
    a4 = v198;
LABEL_292:
    v303 = v322;
    if ((*(a4 + 56) & 1) == 0)
    {
      v304 = *(a4 + 32);
      if (!v304)
      {
        goto LABEL_320;
      }

      *(a4 + 48) = *(*(a4 + 24) + 8 * v304 - 8);
      *(a4 + 32) = v304 - 1;
    }

    if (v134)
    {
      goto LABEL_311;
    }

    if (v133)
    {
      *v11 = 0;
      v309 = 1;
      goto LABEL_304;
    }

    if (a6 && !(*(a6 + 8))(1, (v322 - 1), a6))
    {
      goto LABEL_311;
    }

    ++v322;
    v77 = v326 + v315;
    v78 = v323;
    if (!((v303 < 0x10) | ((((v77 - v316) ^ v77 | v77 ^ v316) ^ v77) >> 63)))
    {
      v309 = 1;
      *v11 = 1;
      goto LABEL_304;
    }
  }

  if (v86 >= 0x800000)
  {
    v306 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
    v307 = 102;
    v308 = 301;
    goto LABEL_313;
  }

  v332 = a4;
  if ((v328->flags & 2) == 0)
  {
    v89 = v88 - v80;
    v90 = malloc_type_malloc(v88 - v80 + 8, 0xB4E622C9uLL);
    if (!v90)
    {
      v310 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc";
      v311 = 14;
      v312 = 65;
      v313 = 217;
      goto LABEL_319;
    }

    *v90 = v89;
    v91 = v90 + 1;
    bzero(v90 + 1, v89);
    v92 = v328->top;
    if (v92)
    {
      memcpy(v91, v328->d, 8 * v92);
    }

    v93 = v328->d;
    if (v328->d)
    {
      v95 = *(v93 - 1);
      v94 = v93 - 8;
      v96 = v95 + 8;
      if (v95 != -8)
      {
        bzero(v94, v96);
      }

      free(v94);
    }

    v328->d = v91;
    v88 = 8 * v79;
    v328->dmax = v79 + v81;
    a4 = v332;
    v87 = v79 + v81 - 1;
    goto LABEL_130;
  }

  v310 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
  v311 = 3;
  v312 = 106;
  v313 = 306;
LABEL_319:
  ERR_put_error(v311, 0, v312, v310, v313);
  v309 = 0;
  a4 = v332;
  v71 = v324;
LABEL_304:
  std::unique_ptr<bn_mont_ctx_st,bssl::internal::Deleter>::~unique_ptr[abi:sn200100](&v336);
  if ((*(a4 + 56) & 1) == 0)
  {
    v305 = *(a4 + 32);
    if (v305)
    {
      *(a4 + 48) = *(*(a4 + 24) + 8 * v305 - 8);
      *(a4 + 32) = v305 - 1;
      goto LABEL_307;
    }

LABEL_320:
    abort();
  }

LABEL_307:
  if (v71)
  {
    BN_CTX_free(v71);
  }

  return v309;
}

uint64_t BN_enhanced_miller_rabin_primality_test(int *a1, BIGNUM *a, uint64_t a3)
{
  top = a->top;
  if (top < 1 || (d = a->d, (*a->d & 1) == 0) || (v75 = 3, *&b.neg = 0x200000000, b.d = &v75, *&b.top = 0x100000001, a->neg) || BN_ucmp(a, &b) <= 0)
  {
    ERR_put_error(3, 0, 119, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/prime.cc.inc", 692);
    return 0;
  }

  v9 = a3;
  v10 = (top << 6) - 64;
  v11 = &d[top - 1];
  while (!d[top - 1])
  {
    --top;
    v10 -= 64;
    --v11;
    if (top + 1 <= 1)
    {
      v12 = 34;
      goto LABEL_40;
    }
  }

  v13 = *v11;
  v14 = HIDWORD(*v11);
  v15 = v14 != 0;
  if (!v14)
  {
    v14 = v13;
  }

  v16 = v14 >> 16 != 0;
  if (v14 >> 16)
  {
    v14 >>= 16;
  }

  v17 = v14 > 0xFF;
  if (v14 > 0xFF)
  {
    v14 >>= 8;
  }

  v18 = v14 > 0xF;
  if (v14 > 0xF)
  {
    v14 >>= 4;
  }

  v19 = v14 > 3;
  if (v14 > 3)
  {
    v14 >>= 2;
  }

  v20 = v13 == 0;
  v21 = (16 * v16) | (32 * v15) | (8 * v17) | (4 * v18) | (2 * v19);
  if (!v20)
  {
    ++v21;
  }

  if (v14 > 1)
  {
    ++v21;
  }

  v22 = v21 + v10;
  if (v22 <= 3746)
  {
    if (v22 <= 1344)
    {
      if (v22 <= 475)
      {
        if (v22 <= 399)
        {
          if (v22 <= 346)
          {
            if (v22 <= 307)
            {
              if (v22 <= 54)
              {
                v12 = 34;
              }

              else
              {
                v12 = 27;
              }
            }

            else
            {
              v12 = 8;
            }
          }

          else
          {
            v12 = 7;
          }
        }

        else
        {
          v12 = 6;
        }
      }

      else
      {
        v12 = 5;
      }
    }

    else
    {
      v12 = 4;
    }
  }

  else
  {
    v12 = 3;
  }

LABEL_40:
  if ((*(a3 + 56) & 1) == 0)
  {
    v23 = *(a3 + 48);
    if (bssl::Vector<unsigned long>::MaybeGrow((a3 + 24)))
    {
      v9 = a3;
      *(*(a3 + 24) + 8 * (*(a3 + 32))++) = v23;
    }

    else
    {
      *(a3 + 56) = 257;
      ERR_clear_error();
      v9 = a3;
    }
  }

  result = BN_CTX_get(v9);
  if (!result)
  {
    goto LABEL_104;
  }

  v24 = result;
  result = BN_copy(result, a);
  if (!result)
  {
    goto LABEL_104;
  }

  result = BN_sub_word(v24, 1uLL);
  if (!result)
  {
    goto LABEL_104;
  }

    ;
  }

  result = BN_CTX_get(a3);
  if (!result || (v26 = result, result = BN_rshift(result, v24, i), !result) || (v71 = v12, p = v26, v27 = BN_CTX_get(a3), v28 = BN_CTX_get(a3), v29 = BN_CTX_get(a3), v30 = BN_CTX_get(a3), v31 = v27, v32 = BN_CTX_get(a3), result = 0, !v27))
  {
LABEL_104:
    v33 = a3;
    goto LABEL_105;
  }

  v33 = a3;
  if (!v28 || !v29 || !v30 || !v32)
  {
LABEL_105:
    if ((*(v33 + 56) & 1) == 0)
    {
      goto LABEL_106;
    }

    return result;
  }

  aa = v32;
  v73 = BN_MONT_CTX_new_for_modulus(a, a3);
  if (!v73)
  {
    goto LABEL_119;
  }

  v70 = 1;
  v68 = v28;
  while (1)
  {
    if (!BN_rand_range_ex(v31, 2uLL, v24))
    {
      goto LABEL_119;
    }

    LODWORD(b.d) = 0;
    if (!bn_gcd_consttime(v28, &b, v31, a, a3) || !BN_lshift(v28, v28, b.d))
    {
      goto LABEL_119;
    }

    *&b.neg = 0x200000000;
    v75 = 1;
    b.d = &v75;
    *&b.top = 0x100000001;
    if (!v28->neg && BN_ucmp(v28, &b) >= 1)
    {
      v65 = 1;
      *a1 = 1;
      goto LABEL_120;
    }

    v34 = v31;
    if (!BN_mod_exp_mont(v29, v31, p, a, a3, v73))
    {
      goto LABEL_119;
    }

    if (!v29->neg)
    {
      v52 = v29->top;
      if (v52)
      {
        v53 = v29->d;
        v54 = *v29->d ^ 1;
        if (v52 < 2)
        {
          goto LABEL_100;
        }

        if (v52 >= 5)
        {
          v56 = (v52 - 1) & 0xFFFFFFFFFFFFFFFCLL;
          v55 = v56 | 1;
          v57 = 0uLL;
          v58 = *v29->d ^ 1uLL;
          v59 = (v53 + 3);
          v60 = v56;
          do
          {
            v58 = vorrq_s8(v59[-1], v58);
            v57 = vorrq_s8(*v59, v57);
            v59 += 2;
            v60 -= 4;
          }

          while (v60);
          v61 = vorrq_s8(v57, v58);
          v54 = vorr_s8(*v61.i8, *&vextq_s8(v61, v61, 8uLL));
          if (v52 - 1 == v56)
          {
LABEL_100:
            if (!v54)
            {
              goto LABEL_101;
            }

            goto LABEL_67;
          }
        }

        else
        {
          v55 = 1;
        }

        v62 = v52 - v55;
        v63 = &v53[v55];
        do
        {
          v64 = *v63++;
          v54 |= v64;
          --v62;
        }

        while (v62);
        goto LABEL_100;
      }
    }

LABEL_67:
    if (BN_cmp(v29, v24))
    {
      break;
    }

LABEL_101:
    v20 = v70++ == v71;
    v28 = v68;
    v31 = v34;
    if (v20)
    {
      *a1 = 0;
      v65 = 1;
      goto LABEL_120;
    }
  }

  if (i >= 2)
  {
    v35 = 1;
    while (1)
    {
      if (!BN_copy(v30, v29) || !BN_mod_mul(v29, v30, v30, a, a3))
      {
        goto LABEL_119;
      }

      neg = v29->neg;
      if (neg == v24->neg)
      {
        v37 = BN_ucmp(v29, v24);
        if (!(neg ? -v37 : v37))
        {
          goto LABEL_101;
        }
      }

      if (!neg)
      {
        v39 = v29->top;
        if (v39)
        {
          break;
        }
      }

LABEL_71:
      if (i == ++v35)
      {
        goto LABEL_108;
      }
    }

    v40 = v29->d;
    v41 = *v29->d ^ 1;
    if (v39 >= 2)
    {
      if (v39 < 5)
      {
        v42 = 1;
        goto LABEL_87;
      }

      v43 = (v39 - 1) & 0xFFFFFFFFFFFFFFFCLL;
      v42 = v43 | 1;
      v44 = 0uLL;
      v45 = *v29->d ^ 1uLL;
      v46 = (v40 + 3);
      v47 = v43;
      do
      {
        v45 = vorrq_s8(v46[-1], v45);
        v44 = vorrq_s8(*v46, v44);
        v46 += 2;
        v47 -= 4;
      }

      while (v47);
      v48 = vorrq_s8(v44, v45);
      v41 = vorr_s8(*v48.i8, *&vextq_s8(v48, v48, 8uLL));
      if (v39 - 1 != v43)
      {
LABEL_87:
        v49 = v39 - v42;
        v50 = &v40[v42];
        do
        {
          v51 = *v50++;
          v41 |= v51;
          --v49;
        }

        while (v49);
      }
    }

    if (!v41)
    {
      goto LABEL_112;
    }

    goto LABEL_71;
  }

LABEL_108:
  if (!BN_copy(v30, v29) || !BN_mod_mul(v29, v30, v30, a, a3) || !BN_is_one(&v29->d) && !BN_copy(v30, v29))
  {
    goto LABEL_119;
  }

LABEL_112:
  if (!BN_copy(aa, v30) || !BN_sub_word(aa, 1uLL) || !BN_gcd(v68, aa, a, a3))
  {
LABEL_119:
    v65 = 0;
    goto LABEL_120;
  }

  v65 = 1;
  if (BN_cmp_word(v68) >= 1)
  {
    v67 = 1;
  }

  else
  {
    v67 = 2;
  }

  *a1 = v67;
LABEL_120:
  std::unique_ptr<bn_mont_ctx_st,bssl::internal::Deleter>::~unique_ptr[abi:sn200100](&v73);
  v33 = a3;
  result = v65;
  if ((*(a3 + 56) & 1) == 0)
  {
LABEL_106:
    v66 = *(v33 + 32);
    if (!v66)
    {
      abort();
    }

    *(v33 + 48) = *(*(v33 + 24) + 8 * v66 - 8);
    *(v33 + 32) = v66 - 1;
  }

  return result;
}

int BN_rand(BIGNUM *rnd, int bits, int top, int bottom)
{
  if (rnd)
  {
    if ((top - 2) <= 0xFFFFFFFC)
    {
      v4 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/random.cc.inc";
      v5 = 66;
      v6 = 36;
LABEL_9:
      ERR_put_error(3, 0, v5, v4, v6);
      LODWORD(rnd) = 0;
      return rnd;
    }

    if (bottom >= 2)
    {
      v4 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/random.cc.inc";
      v5 = 66;
      v6 = 41;
      goto LABEL_9;
    }

    if (!bits)
    {
      rnd->neg = 0;
      rnd->top = 0;
LABEL_43:
      LODWORD(rnd) = 1;
      return rnd;
    }

    if (bits >= 2147483585)
    {
      v4 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/random.cc.inc";
      v5 = 102;
      v6 = 51;
      goto LABEL_9;
    }

    v7 = bits + 63;
    if (bits < -63)
    {
      v7 = bits + 126;
    }

    v8 = v7 >> 6;
    if (1 - bits >= 0)
    {
      v9 = -((1 - bits) & 0x3F);
    }

    else
    {
      v9 = (bits - 1) & 0x3F;
    }

    v10 = v7 >> 6;
    if (rnd->dmax >= v8)
    {
      v11 = bits;
      v12 = top;
      v13 = bottom;
      v14 = rnd;
      rnd = rnd->d;
    }

    else
    {
      if (v8 >= 0x800000)
      {
        v4 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
        v5 = 102;
        v6 = 301;
        goto LABEL_9;
      }

      if ((rnd->flags & 2) != 0)
      {
        v4 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
        v5 = 106;
        v6 = 306;
        goto LABEL_9;
      }

      v11 = bits;
      v12 = top;
      v13 = bottom;
      v14 = rnd;
      rnd = OPENSSL_calloc(v10, 8uLL);
      if (!rnd)
      {
        return rnd;
      }

      v21 = v14;
      v22 = v14->top;
      if (v22)
      {
        v23 = rnd;
        memcpy(rnd, v14->d, 8 * v22);
        rnd = v23;
        v21 = v14;
      }

      d = v21->d;
      if (v21->d)
      {
        v25 = rnd;
        v27 = *(d - 1);
        v26 = d - 1;
        v28 = v27 + 8;
        if (v27 != -8)
        {
          bzero(v26, v28);
        }

        free(v26);
        v21 = v14;
        rnd = v25;
      }

      v21->d = rnd;
      v21->dmax = v8;
    }

    if (v9 < 63)
    {
      v15 = ~(-1 << (v9 + 1));
    }

    else
    {
      v15 = -1;
    }

    v16 = v10;
    BCM_rand_bytes_with_additional_data(rnd, v16 * 8, BCM_rand_bytes::kZeroAdditionalData);
    v17 = v14->d;
    v18 = &v14->d[v16];
    v19 = *(v18 - 1) & v15;
    *(v18 - 1) = v19;
    if (v12 != -1)
    {
      if (v11 >= 2 && v12 == 1)
      {
        if (!v9)
        {
          *(v18 - 1) = v19 | 1;
          v17[v8 - 2] |= 0x8000000000000000;
          if (v13 != 1)
          {
            goto LABEL_42;
          }

          goto LABEL_41;
        }

        v20 = 3 << (v9 - 1);
      }

      else
      {
        v20 = 1 << v9;
      }

      *(v18 - 1) = v19 | v20;
    }

    if (v13 != 1)
    {
LABEL_42:
      v14->neg = 0;
      v14->top = v8;
      goto LABEL_43;
    }

LABEL_41:
    *v17 |= 1uLL;
    goto LABEL_42;
  }

  return rnd;
}

uint64_t bn_rand_range_words(char *a1, unint64_t a2, unint64_t *a3, uint64_t a4, int8x16_t *a5)
{
  if (!a4)
  {
    goto LABEL_25;
  }

  v9 = 0;
  v10 = a4;
  while (1)
  {
    v11 = a3[v10 - 1];
    if (v11)
    {
      break;
    }

    v9 += 8;
    if (!--v10)
    {
      goto LABEL_25;
    }
  }

  v12 = v10 - 1;
  if (v10 == 1 && *a3 <= a2)
  {
LABEL_25:
    v34 = 108;
    v35 = 134;
  }

  else
  {
    v13 = v11 | (v11 >> 1) | ((v11 | (v11 >> 1)) >> 2);
    v14 = v13 | (v13 >> 4) | ((v13 | (v13 >> 4)) >> 8);
    v15 = v14 | (v14 >> 16);
    v16 = &a1[8 * v10];
    if (v9)
    {
      v17 = a4;
      bzero(&a1[8 * v10], v9);
      a4 = v17;
    }

    v18 = v15 | HIDWORD(v15);
    v19 = 8 * a4 - v9;
    if (a2)
    {
      v20 = 100;
      while (1)
      {
        if (!--v20)
        {
          goto LABEL_33;
        }

        BCM_rand_bytes_with_additional_data(a1, v19, a5);
        *(v16 - 1) &= v18;
        if (v10 == 1)
        {
          v21 = 0;
        }

        else
        {
          if (v12 >= 4)
          {
            v23 = 0uLL;
            v24 = v12 & 0xFFFFFFFFFFFFFFFCLL;
            v25 = (a1 + 24);
            v26 = 0uLL;
            do
            {
              v23 = vorrq_s8(v25[-1], v23);
              v26 = vorrq_s8(*v25, v26);
              v25 += 2;
              v24 -= 4;
            }

            while (v24);
            v27 = vorrq_s8(v26, v23);
            v21 = vorr_s8(*v27.i8, *&vextq_s8(v27, v27, 8uLL));
            v22 = v12 & 0xFFFFFFFFFFFFFFFCLL | 1;
            if (v12 == (v12 & 0xFFFFFFFFFFFFFFFCLL))
            {
              goto LABEL_21;
            }
          }

          else
          {
            v21 = 0;
            v22 = 1;
          }

          do
          {
            *&v21 |= *&a1[8 * v22++];
          }

          while (v10 != v22);
        }

LABEL_21:
        v28 = 0;
        v29 = 0;
        v30 = (*&v21 - 1) & ~*&v21 & (((*a1 - a2) ^ *a1 | *a1 ^ a2) ^ *a1);
        do
        {
          v31 = *&a1[8 * v29];
          v32 = a3[v29];
          v33 = (((v32 ^ v31) - 1) & ~(v32 ^ v31)) >> 63;
          v28 = v33 & v28 | ((((v31 - v32) ^ v31 | v32 ^ v31) ^ v31) >> 63) & ~v33;
          ++v29;
        }

        while (v10 != v29);
        if (((v28 >> 31) & 1 & ~(v30 >> 63)) != 0)
        {
          return 1;
        }
      }
    }

    v37 = 100;
    while (--v37)
    {
      BCM_rand_bytes_with_additional_data(a1, v19, a5);
      v38 = 0;
      v39 = 0;
      *(v16 - 1) &= v18;
      do
      {
        v40 = *&a1[8 * v39];
        v41 = a3[v39];
        v42 = (((v41 ^ v40) - 1) & ~(v41 ^ v40)) >> 63;
        v38 = v42 & v38 | ((((v40 - v41) ^ v40 | v41 ^ v40) ^ v40) >> 63) & ~v42;
        ++v39;
      }

      while (v10 != v39);
      if ((v38 >> 31))
      {
        return 1;
      }
    }

LABEL_33:
    v34 = 115;
    v35 = 175;
  }

  ERR_put_error(3, 0, v34, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/random.cc.inc", v35);
  return 0;
}

uint64_t BCM_rand_bytes_with_additional_data(char *a1, unint64_t a2, int8x16_t *a3)
{
  v32 = *MEMORY[0x277D85DE8];
  if (!a2)
  {
    return 0;
  }

  fork_generation = CRYPTO_get_fork_generation();
  if (fork_generation)
  {
    v9 = 0;
    v28.i64[1] = 0;
    *(v28.i64 + 1) = 0;
    v10 = 0uLL;
  }

  else
  {
    if (CCRandomGenerateBytes(&bytes, 0x20uLL))
    {
      goto LABEL_34;
    }

    v10 = bytes;
    v9 = v28.u8[0];
  }

  v7.i16[0] = v28.i16[1];
  v8.i32[0] = v9;
  v8.i8[1] = v28.i8[1];
  v11 = vzip1_s16(v8, v7);
  v8.i32[0] = v28.i32[1];
  *v12.i8 = vzip1_s32(v11, v8);
  v12.i64[1] = v28.i64[1];
  v13 = veorq_s8(a3[1], v12);
  bytes = veorq_s8(*a3, v10);
  v28 = v13;
  thread_local = CRYPTO_get_thread_local(1);
  if (thread_local)
  {
    v15 = thread_local;
    v16 = thread_local + 37;
    if (*(thread_local + 74) > 0xFFFu || thread_local[36] != fork_generation || *(thread_local + 76))
    {
      if (CCRandomGenerateBytes(&v23, 0x30uLL))
      {
        goto LABEL_34;
      }

      *(v15 + 69) = bswap32(bswap32(*(v15 + 69)) + 1);
      (*(v15 + 31))(v15 + 264, &v29, v15);
      *(v15 + 69) = bswap32(bswap32(*(v15 + 69)) + 1);
      (*(v15 + 31))(v15 + 264, &v30, v15);
      *(v15 + 69) = bswap32(bswap32(*(v15 + 69)) + 1);
      (*(v15 + 31))(v15 + 264, &v31, v15);
      v29 = veorq_s8(v29, v23);
      v30 = veorq_s8(v30, v24);
      v31 = veorq_s8(v31, v25);
      aes_nohw_set_encrypt_key(&v29, 256, v15);
      *(v15 + 31) = aes_nohw_encrypt;
      *(v15 + 32) = aes_nohw_ctr32_encrypt_blocks;
      *(v15 + 264) = v31;
      *(v15 + 35) = 1;
      *v16 = 0;
      *(v15 + 36) = fork_generation;
      *(v15 + 76) = 0;
    }

    goto LABEL_20;
  }

  v17 = malloc_type_malloc(0x140uLL, 0xB4E622C9uLL);
  if (!v17)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc", 217);
LABEL_15:
    v15 = v26;
    goto LABEL_16;
  }

  *v17 = 312;
  *(v17 + 8) = 0u;
  v15 = v17 + 8;
  *(v17 + 24) = 0u;
  *(v17 + 40) = 0u;
  *(v17 + 56) = 0u;
  *(v17 + 72) = 0u;
  *(v17 + 88) = 0u;
  *(v17 + 104) = 0u;
  *(v17 + 120) = 0u;
  *(v17 + 136) = 0u;
  *(v17 + 152) = 0u;
  *(v17 + 168) = 0u;
  *(v17 + 184) = 0u;
  *(v17 + 200) = 0u;
  *(v17 + 216) = 0u;
  *(v17 + 232) = 0u;
  *(v17 + 248) = 0u;
  *(v17 + 39) = 0;
  *(v17 + 264) = 0u;
  *(v17 + 280) = 0u;
  *(v17 + 296) = 0u;
  if (!CRYPTO_set_thread_local(1u, (v17 + 8), rand_thread_state_free))
  {
    goto LABEL_15;
  }

LABEL_16:
  *(v15 + 75) = 0;
  if (CCRandomGenerateBytes(&v23, 0x30uLL))
  {
    goto LABEL_34;
  }

  v29 = veorq_s8(v23, xmmword_273BA6E90);
  v30 = veorq_s8(v24, xmmword_273BA6EA0);
  v31 = veorq_s8(v25, xmmword_273BA6EB0);
  aes_nohw_set_encrypt_key(&v29, 256, v15);
  *(v15 + 31) = aes_nohw_encrypt;
  *(v15 + 32) = aes_nohw_ctr32_encrypt_blocks;
  *(v15 + 264) = v31;
  v16 = v15 + 296;
  *(v15 + 74) = 0;
  *(v15 + 35) = 1;
  *(v15 + 36) = fork_generation;
  *(v15 + 76) = 0;
LABEL_20:
  if (a2 >= 0x10000)
  {
    v18 = 0x10000;
  }

  else
  {
    v18 = a2;
  }

  if (!CTR_DRBG_generate(v15, a1, v18, &bytes, 0x20uLL))
  {
    goto LABEL_34;
  }

  ++*v16;
  v19 = a2 - v18;
  if (a2 != v18)
  {
    v20 = &a1[v18];
    while (1)
    {
      v21 = v19 >= 0x10000 ? 0x10000 : v19;
      if (!CTR_DRBG_generate(v15, v20, v21, &bytes, 0))
      {
        break;
      }

      v20 += v21;
      ++*v16;
      v19 -= v21;
      if (!v19)
      {
        goto LABEL_31;
      }
    }

LABEL_34:
    abort();
  }

LABEL_31:
  if (v15 == v26)
  {
    *(v15 + 16) = 0u;
    *(v15 + 17) = 0u;
    *(v15 + 14) = 0u;
    *(v15 + 15) = 0u;
    *(v15 + 12) = 0u;
    *(v15 + 13) = 0u;
    *(v15 + 10) = 0u;
    *(v15 + 11) = 0u;
    *(v15 + 8) = 0u;
    *(v15 + 9) = 0u;
    *(v15 + 6) = 0u;
    *(v15 + 7) = 0u;
    *(v15 + 4) = 0u;
    *(v15 + 5) = 0u;
    *(v15 + 2) = 0u;
    *(v15 + 3) = 0u;
    *v15 = 0u;
    *(v15 + 1) = 0u;
  }

  return 0;
}

BIGNUM *__cdecl BN_mod_sqrt(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
{
  top = n->top;
  if (top < 1)
  {
    goto LABEL_15;
  }

  v5 = n->d;
  v6 = *n->d;
  if ((v6 & 1) == 0)
  {
    goto LABEL_17;
  }

  v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
  if (top == 1)
  {
    goto LABEL_11;
  }

  if (top < 5)
  {
    v8 = 1;
LABEL_9:
    v15 = top - v8;
    v16 = &v5[v8];
    do
    {
      v17 = *v16++;
      v7 |= v17;
      --v15;
    }

    while (v15);
    goto LABEL_11;
  }

  v9 = (top - 1) & 0xFFFFFFFFFFFFFFFCLL;
  v8 = v9 | 1;
  v10 = 0uLL;
  v11 = v7;
  v12 = (v5 + 3);
  v13 = v9;
  do
  {
    v11 = vorrq_s8(v12[-1], v11);
    v10 = vorrq_s8(*v12, v10);
    v12 += 2;
    v13 -= 4;
  }

  while (v13);
  v14 = vorrq_s8(v10, v11);
  v7 = vorr_s8(*v14.i8, *&vextq_s8(v14, v14, 8uLL));
  if (top - 1 != v9)
  {
    goto LABEL_9;
  }

LABEL_11:
  if (!v7)
  {
LABEL_15:
    if (!top)
    {
      goto LABEL_26;
    }

    v5 = n->d;
    v6 = *n->d;
LABEL_17:
    v22 = v6 ^ 2;
    if (top < 2)
    {
      goto LABEL_25;
    }

    if (top >= 5)
    {
      v24 = (top - 1) & 0xFFFFFFFFFFFFFFFCLL;
      v23 = v24 | 1;
      v25 = 0uLL;
      v26 = v22;
      v27 = (v5 + 3);
      v28 = v24;
      do
      {
        v26 = vorrq_s8(v27[-1], v26);
        v25 = vorrq_s8(*v27, v25);
        v27 += 2;
        v28 -= 4;
      }

      while (v28);
      v29 = vorrq_s8(v25, v26);
      v22 = vorr_s8(*v29.i8, *&vextq_s8(v29, v29, 8uLL));
      if (top - 1 == v24)
      {
LABEL_25:
        if (!v22)
        {
          if (!a->top || (*a->d & 1) == 0)
          {
            goto LABEL_83;
          }

          if (ret->dmax)
          {
            p_d = ret->d;
          }

          else
          {
            if ((ret->flags & 2) != 0)
            {
LABEL_97:
              v33 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.cc.inc";
              v34 = 106;
              v35 = 306;
              goto LABEL_27;
            }

            v48 = ret;
            ret = OPENSSL_calloc(1uLL, 8uLL);
            if (!ret)
            {
              return ret;
            }

            p_d = &ret->d;
            ret = v48;
            v49 = v48->top;
            if (v49)
            {
              memcpy(p_d, v48->d, 8 * v49);
              ret = v48;
            }

            v50 = ret->d;
            if (ret->d)
            {
              v52 = *(v50 - 1);
              v51 = v50 - 1;
              v53 = v52 + 8;
              if (v52 != -8)
              {
                bzero(v51, v53);
              }

              free(v51);
              ret = v48;
            }

            ret->d = p_d;
            ret->dmax = 1;
          }

          ret->neg = 0;
          *p_d = 1;
          ret->top = 1;
          return ret;
        }

LABEL_26:
        v33 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/sqrt.cc.inc";
        v34 = 114;
        v35 = 48;
LABEL_27:
        ERR_put_error(3, 0, v34, v33, v35);
        return 0;
      }
    }

    else
    {
      v23 = 1;
    }

    v30 = top - v23;
    v31 = &v5[v23];
    do
    {
      v32 = *v31++;
      v22 |= v32;
      --v30;
    }

    while (v30);
    goto LABEL_25;
  }

  v18 = a->top;
  if (!v18)
  {
    goto LABEL_83;
  }

  v19 = a->d;
  if (v18 < 4)
  {
    v20 = 0;
    v21 = 0;
LABEL_36:
    v42 = v18 - v20;
    v43 = &v19[v20];
    do
    {
      v44 = *v43++;
      *&v21 |= v44;
      --v42;
    }

    while (v42);
    goto LABEL_38;
  }

  v20 = v18 & 0xFFFFFFFFFFFFFFFCLL;
  v37 = (v19 + 2);
  v38 = 0uLL;
  v39 = v18 & 0xFFFFFFFFFFFFFFFCLL;
  v40 = 0uLL;
  do
  {
    v38 = vorrq_s8(v37[-1], v38);
    v40 = vorrq_s8(*v37, v40);
    v37 += 2;
    v39 -= 4;
  }

  while (v39);
  v41 = vorrq_s8(v40, v38);
  v21 = vorr_s8(*v41.i8, *&vextq_s8(v41, v41, 8uLL));
  if (v20 != v18)
  {
    goto LABEL_36;
  }

LABEL_38:
  neg = a->neg;
  if (!*&v21)
  {
    if (!neg)
    {
LABEL_63:
      v66 = *v19 ^ 1;
      if (v18 >= 2)
      {
        if (v18 >= 5)
        {
          v79 = (v18 - 1) & 0xFFFFFFFFFFFFFFFCLL;
          v67 = v79 | 1;
          v80 = 0uLL;
          v81 = *v19 ^ 1uLL;
          v82 = (v19 + 3);
          v83 = v79;
          do
          {
            v81 = vorrq_s8(v82[-1], v81);
            v80 = vorrq_s8(*v82, v80);
            v82 += 2;
            v83 -= 4;
          }

          while (v83);
          v84 = vorrq_s8(v80, v81);
          v66 = vorr_s8(*v84.i8, *&vextq_s8(v84, v84, 8uLL));
          if (v18 - 1 == v79)
          {
            goto LABEL_82;
          }
        }

        else
        {
          v67 = 1;
        }

        v85 = v18 - v67;
        v86 = &v19[v67];
        do
        {
          v87 = *v86++;
          v66 |= v87;
          --v85;
        }

        while (v85);
      }

LABEL_82:
      v88 = v66 == 0;
      if (v66)
      {
        goto LABEL_83;
      }

      if (ret->dmax)
      {
        v89 = ret->d;
        goto LABEL_87;
      }

      if ((ret->flags & 2) == 0)
      {
        v90 = ret;
        ret = OPENSSL_calloc(1uLL, 8uLL);
        if (!ret)
        {
          return ret;
        }

        v89 = &ret->d;
        ret = v90;
        v91 = v90->top;
        if (v91)
        {
          memcpy(v89, v90->d, 8 * v91);
          ret = v90;
        }

        v92 = ret->d;
        if (ret->d)
        {
          v94 = *(v92 - 1);
          v93 = v92 - 1;
          v95 = v94 + 8;
          if (v94 != -8)
          {
            bzero(v93, v95);
          }

          free(v93);
          ret = v90;
        }

        ret->d = v89;
        ret->dmax = 1;
LABEL_87:
        ret->neg = 0;
        *v89 = v88;
        ret->top = 1;
        return ret;
      }

      goto LABEL_97;
    }

LABEL_83:
    ret->neg = 0;
    ret->top = 0;
    return ret;
  }

  if (neg)
  {
    goto LABEL_60;
  }

  v46 = *v19 ^ 1;
  if (v18 >= 2)
  {
    if (v18 < 5)
    {
      v47 = 1;
LABEL_57:
      v60 = v18 - v47;
      v61 = &v19[v47];
      do
      {
        v62 = *v61++;
        v46 |= v62;
        --v60;
      }

      while (v60);
      goto LABEL_59;
    }

    v54 = (v18 - 1) & 0xFFFFFFFFFFFFFFFCLL;
    v47 = v54 | 1;
    v55 = 0uLL;
    v56 = *v19 ^ 1uLL;
    v57 = (v19 + 3);
    v58 = v54;
    do
    {
      v56 = vorrq_s8(v57[-1], v56);
      v55 = vorrq_s8(*v57, v55);
      v57 += 2;
      v58 -= 4;
    }

    while (v58);
    v59 = vorrq_s8(v55, v56);
    v46 = vorr_s8(*v59.i8, *&vextq_s8(v59, v59, 8uLL));
    if (v18 - 1 != v54)
    {
      goto LABEL_57;
    }
  }

LABEL_59:
  if (!v46)
  {
    goto LABEL_63;
  }

LABEL_60:
  aa = ret;
  v64 = ctx;
  if ((*(ctx + 56) & 1) == 0)
  {
    v65 = *(ctx + 6);
    if (bssl::Vector<unsigned long>::MaybeGrow(ctx + 3))
    {
      ctx = v64;
      *(*(v64 + 3) + 8 * (*(v64 + 4))++) = v65;
    }

    else
    {
      *(v64 + 28) = 257;
      ERR_clear_error();
      ctx = v64;
    }
  }

  v68 = ctx;
  v69 = BN_CTX_get(ctx);
  v70 = BN_CTX_get(v68);
  v71 = BN_CTX_get(v68);
  v72 = BN_CTX_get(v68);
  v73 = BN_CTX_get(v68);
  v74 = BN_CTX_get(v68);
  if (!v74)
  {
    goto LABEL_228;
  }

  v75 = v74;
  if (!BN_div(0, v69, a, n, v64))
  {
    goto LABEL_228;
  }

  v76 = n;
  if (v69->neg)
  {
    if (!bn_usub_consttime(v69, n, v69))
    {
      goto LABEL_228;
    }

    v77 = v69->top;
    if (v77 < 1)
    {
      v76 = n;
      if (!v77)
      {
LABEL_99:
        v69->neg = 0;
      }
    }

    else
    {
      v76 = n;
      while (!v69->d[v77 - 1])
      {
        v78 = __OFSUB__(v77--, 1);
        if ((v77 < 0) ^ v78 | (v77 == 0))
        {
          v69->top = 0;
          goto LABEL_99;
        }
      }

      v69->top = v77;
    }
  }

  r = v70;
    ;
  }

  if (i == 2)
  {
    if (!bn_mod_add_consttime(v72, v69, v69, v76, v64))
    {
      goto LABEL_228;
    }

    if (!BN_rshift(v71, n, 3))
    {
      goto LABEL_228;
    }

    v71->neg = 0;
    if (!BN_mod_exp_mont(v70, v72, v71, n, v64, 0) || !BN_mod_sqr(v75, v70, n, v64) || !BN_mod_mul(v72, v72, v75, n, v64) || !BN_sub_word(v72, 1uLL) || !BN_mod_mul(v73, v69, v70, n, v64) || !BN_mod_mul(v73, v73, v72, n, v64) || !BN_copy(aa, v73))
    {
      goto LABEL_228;
    }

    goto LABEL_110;
  }

  if (i == 1)
  {
    if (!BN_rshift(v71, v76, 2))
    {
      goto LABEL_228;
    }

    v71->neg = 0;
    if (!BN_add_word(v71, 1uLL) || !BN_mod_exp_mont(aa, v69, v71, n, v64, 0))
    {
      goto LABEL_228;
    }

LABEL_110:
    if (!BN_mod_sqr(v73, aa, n, v64))
    {
      goto LABEL_228;
    }

    v97 = BN_cmp(v73, v69);
    v98 = aa;
    v99 = v64;
    if (!v97)
    {
      goto LABEL_230;
    }

    v100 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/sqrt.cc.inc";
    v101 = 110;
    v102 = 369;
    goto LABEL_235;
  }

  if (!BN_copy(v71, v76))
  {
    goto LABEL_228;
  }

  v71->neg = 0;
  v103 = 2;
  v104 = n;
  b = v73;
  p = v72;
  while (2)
  {
    if (v103 > 0x15)
    {
      v105 = BN_num_bits(v104);
      if (!BN_rand(v75, v105, 0, 0) || (BN_ucmp(v75, n) & 0x80000000) == 0 && BN_usub(v75, v75, n))
      {
        goto LABEL_228;
      }

      v106 = v75->top;
      if (v106)
      {
        v99 = v64;
        v107 = v75->d;
        if (v106 >= 4)
        {
          v108 = v106 & 0xFFFFFFFFFFFFFFFCLL;
          v110 = v107 + 1;
          v111 = 0uLL;
          v112 = v106 & 0xFFFFFFFFFFFFFFFCLL;
          v113 = 0uLL;
          do
          {
            v111 = vorrq_s8(v110[-1], v111);
            v113 = vorrq_s8(*v110, v113);
            v110 += 2;
            v112 -= 4;
          }

          while (v112);
          v114 = vorrq_s8(v113, v111);
          v109 = vorr_s8(*v114.i8, *&vextq_s8(v114, v114, 8uLL));
          if (v108 == v106)
          {
LABEL_137:
            if (v109)
            {
              goto LABEL_139;
            }

            goto LABEL_138;
          }
        }

        else
        {
          v108 = 0;
          v109 = 0;
        }

        v115 = v106 - v108;
        v116 = &v107->i64[v108];
        do
        {
          v117 = *v116++;
          *&v109 |= v117;
          --v115;
        }

        while (v115);
        goto LABEL_137;
      }
    }

LABEL_138:
    v118 = BN_set_word(v75, v103);
    v99 = v64;
    if (!v118)
    {
      goto LABEL_236;
    }

LABEL_139:
    if (v71->top < 1 || (*v71->d & 1) == 0)
    {
      v100 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/jacobi.cc.inc";
      v101 = 104;
      v102 = 35;
LABEL_235:
      ERR_put_error(3, 0, v101, v100, v102);
      v99 = v64;
      goto LABEL_236;
    }

    if (v71->neg)
    {
      v100 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/jacobi.cc.inc";
      v101 = 109;
      v102 = 41;
      goto LABEL_235;
    }

    if ((*(v99 + 56) & 1) == 0)
    {
      v119 = *(v99 + 6);
      if (bssl::Vector<unsigned long>::MaybeGrow(v99 + 3))
      {
        v99 = v64;
        *(*(v64 + 3) + 8 * (*(v64 + 4))++) = v119;
      }

      else
      {
        *(v64 + 28) = 257;
        ERR_clear_error();
        v99 = v64;
      }
    }

    v120 = v99;
    v121 = BN_CTX_get(v99);
    v122 = BN_CTX_get(v120);
    if (!v122 || (v123 = v122, !BN_copy(v121, v75)) || !BN_copy(v123, v71))
    {
      v126 = -2;
      v99 = v64;
      v104 = n;
      goto LABEL_152;
    }

    v202 = v69;
    p_top = &v121->top;
    v124 = v121->top;
    v104 = n;
    v126 = 1;
    if (!v124)
    {
      v99 = v64;
      v69 = v202;
      if (!v123->neg)
      {
        goto LABEL_210;
      }

LABEL_207:
      v126 = 0;
      goto LABEL_152;
    }

    v127 = v123;
    v99 = v64;
    while (1)
    {
      v123 = v121;
      v121 = v127;
      v129 = v124;
      v130 = v123->d;
      if (v124 < 4)
      {
        v131 = 0;
        v132 = 0;
LABEL_166:
        v138 = v129 - v131;
        v139 = &v130->i64[v131];
        do
        {
          v140 = *v139++;
          *&v132 |= v140;
          --v138;
        }

        while (v138);
        goto LABEL_168;
      }

      v131 = v124 & 0xFFFFFFFFFFFFFFFCLL;
      v133 = v130 + 1;
      v134 = 0uLL;
      v135 = v129 & 0xFFFFFFFFFFFFFFFCLL;
      v136 = 0uLL;
      do
      {
        v134 = vorrq_s8(v133[-1], v134);
        v136 = vorrq_s8(*v133, v136);
        v133 += 2;
        v135 -= 4;
      }

      while (v135);
      v137 = vorrq_s8(v136, v134);
      v132 = vorr_s8(*v137.i8, *&vextq_s8(v137, v137, 8uLL));
      if (v131 != v129)
      {
        goto LABEL_166;
      }

LABEL_168:
      if (!*&v132)
      {
        break;
      }

        ;
      }

      if (!BN_rshift(v123, v123, j))
      {
        v126 = -2;
        v99 = v64;
        v104 = n;
        v69 = v202;
        v72 = p;
        goto LABEL_152;
      }

      if (j)
      {
        if (v121->top)
        {
          v142 = *v121->d & 7;
        }

        else
        {
          v142 = 0;
        }

        v72 = p;
        v126 *= bn_jacobi::tab[v142];
      }

      else
      {
        v72 = p;
      }

      v143 = *p_top;
      if (v123->neg)
      {
        if (v143)
        {
          v144 = ~*v123->d;
        }

        else
        {
          LOBYTE(v144) = -1;
        }
      }

      else if (v143)
      {
        v144 = *v123->d;
      }

      else
      {
        LOBYTE(v144) = 0;
      }

      p_top = &v121->top;
      if (v121->top)
      {
        v145 = *v121->d;
      }

      else
      {
        LOBYTE(v145) = 0;
      }

      if ((v144 & v145 & 2) != 0)
      {
        v126 = -v126;
      }

      if (!BN_div(0, v121, v121, v123, v64))
      {
LABEL_208:
        v126 = -2;
        v99 = v64;
        v104 = n;
        v69 = v202;
        goto LABEL_152;
      }

      if (v121->neg)
      {
        if (!bn_usub_consttime(v121, v123, v121))
        {
          goto LABEL_208;
        }

        v124 = *p_top;
        v99 = v64;
        v104 = n;
        if (*p_top < 1)
        {
          if (!v124)
          {
LABEL_205:
            v121->neg = 0;
            v123->neg = 0;
LABEL_206:
            v69 = v202;
            if (!v123->neg)
            {
              goto LABEL_210;
            }

            goto LABEL_207;
          }
        }

        else
        {
          while (!v121->d[v124 - 1])
          {
            v78 = __OFSUB__(v124--, 1);
            if ((v124 < 0) ^ v78 | (v124 == 0))
            {
              v121->top = 0;
              goto LABEL_205;
            }
          }

          *p_top = v124;
        }
      }

      else
      {
        v124 = *p_top;
        v99 = v64;
        v104 = n;
      }

      v123->neg = 0;
      v127 = v123;
      if (!v124)
      {
        goto LABEL_206;
      }
    }

    v123 = v121;
    v69 = v202;
    v72 = p;
    if (v121->neg)
    {
      goto LABEL_207;
    }

LABEL_210:
    v146 = v123->top;
    if (!v146)
    {
      goto LABEL_207;
    }

    v147 = v123->d;
    v148 = *v123->d ^ 1;
    if (v146 >= 2)
    {
      if (v146 < 5)
      {
        v149 = 1;
        goto LABEL_218;
      }

      v150 = (v146 - 1) & 0xFFFFFFFFFFFFFFFCLL;
      v149 = v150 | 1;
      v151 = 0uLL;
      v152 = *v123->d ^ 1uLL;
      v153 = (v147 + 3);
      v154 = v150;
      do
      {
        v152 = vorrq_s8(v153[-1], v152);
        v151 = vorrq_s8(*v153, v151);
        v153 += 2;
        v154 -= 4;
      }

      while (v154);
      v155 = vorrq_s8(v151, v152);
      v148 = vorr_s8(*v155.i8, *&vextq_s8(v155, v155, 8uLL));
      if (v146 - 1 != v150)
      {
LABEL_218:
        v156 = v146 - v149;
        v157 = &v147[v149];
        do
        {
          v158 = *v157++;
          v148 |= v158;
          --v156;
        }

        while (v156);
      }
    }

    if (v148)
    {
      goto LABEL_207;
    }

LABEL_152:
    if (*(v99 + 56))
    {
      goto LABEL_155;
    }

    v128 = *(v99 + 4);
    if (!v128)
    {
      goto LABEL_299;
    }

    *(v99 + 6) = *(*(v99 + 3) + 8 * v128 - 8);
    *(v99 + 4) = v128 - 1;
LABEL_155:
    if (v126 < -1)
    {
LABEL_236:
      v98 = 0;
      goto LABEL_230;
    }

    if (v126 == 1)
    {
      if (++v103 == 82)
      {
LABEL_226:
        v159 = 115;
        v160 = 227;
        goto LABEL_227;
      }

      continue;
    }

    break;
  }

  if (v126 != -1)
  {
    if (v126)
    {
      goto LABEL_226;
    }

    v159 = 114;
    v160 = 217;
LABEL_227:
    ERR_put_error(3, 0, v159, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/sqrt.cc.inc", v160);
    goto LABEL_228;
  }

  if (!BN_rshift(v71, v71, i) || !BN_mod_exp_mont(v75, v75, v71, n, v64, 0))
  {
    goto LABEL_228;
  }

  if (BN_is_one(&v75->d))
  {
    v159 = 114;
    v160 = 242;
    goto LABEL_227;
  }

  if (BN_rshift1(v72, v71))
  {
    v162 = p->top;
    if (v162)
    {
      v163 = p->d;
      if (v162 < 4)
      {
        v164 = 0;
        v165 = 0;
        goto LABEL_248;
      }

      v164 = v162 & 0xFFFFFFFFFFFFFFFCLL;
      v166 = v163 + 1;
      v167 = 0uLL;
      v168 = v162 & 0xFFFFFFFFFFFFFFFCLL;
      v169 = 0uLL;
      do
      {
        v167 = vorrq_s8(v166[-1], v167);
        v169 = vorrq_s8(*v166, v169);
        v166 += 2;
        v168 -= 4;
      }

      while (v168);
      v170 = vorrq_s8(v169, v167);
      v165 = vorr_s8(*v170.i8, *&vextq_s8(v170, v170, 8uLL));
      if (v164 != v162)
      {
LABEL_248:
        v171 = v162 - v164;
        v172 = &v163->i64[v164];
        do
        {
          v173 = *v172++;
          *&v165 |= v173;
          --v171;
        }

        while (v171);
      }

      if (v165)
      {
        if (!BN_mod_exp_mont(b, v69, p, n, v64, 0))
        {
          goto LABEL_228;
        }

        v174 = b->top;
        if (v174)
        {
          v175 = b->d;
          if (v174 < 4)
          {
            v176 = 0;
            v177 = 0;
            goto LABEL_270;
          }

          v176 = v174 & 0xFFFFFFFFFFFFFFFCLL;
          v190 = v175 + 1;
          v191 = 0uLL;
          v192 = v174 & 0xFFFFFFFFFFFFFFFCLL;
          v193 = 0uLL;
          do
          {
            v191 = vorrq_s8(v190[-1], v191);
            v193 = vorrq_s8(*v190, v193);
            v190 += 2;
            v192 -= 4;
          }

          while (v192);
          v194 = vorrq_s8(v193, v191);
          v177 = vorr_s8(*v194.i8, *&vextq_s8(v194, v194, 8uLL));
          if (v176 != v174)
          {
LABEL_270:
            v195 = v174 - v176;
            v196 = &v175->i64[v176];
            do
            {
              v197 = *v196++;
              *&v177 |= v197;
              --v195;
            }

            while (v195);
          }

          if (v177)
          {
LABEL_273:
            if (BN_mod_sqr(r, b, n, v64) && BN_mod_mul(r, r, v69, n, v64) && BN_mod_mul(b, b, v69, n, v64))
            {
              while (!BN_is_one(&r->d))
              {
                if (i < 2)
                {
                  goto LABEL_295;
                }

                if (!BN_mod_sqr(p, r, n, v64))
                {
                  goto LABEL_228;
                }

                if (!BN_is_one(&p->d))
                {
                  if (i == 2)
                  {
LABEL_295:
                    v159 = 110;
                    v160 = 337;
                    goto LABEL_227;
                  }

                  v198 = 2;
                  while (BN_mod_mul(p, p, p, n, v64))
                  {
                    if (BN_is_one(&p->d))
                    {
                      goto LABEL_281;
                    }

                    if (i == ++v198)
                    {
                      goto LABEL_295;
                    }
                  }

                  goto LABEL_228;
                }

                v198 = 1;
LABEL_281:
                if (!BN_copy(p, v75))
                {
                  goto LABEL_228;
                }

                if (i + ~v198 >= 1)
                {
                  v199 = i - v198;
                  while (BN_mod_sqr(p, p, n, v64))
                  {
                    if (--v199 < 2)
                    {
                      goto LABEL_286;
                    }
                  }

                  goto LABEL_228;
                }

LABEL_286:
                if (!BN_mod_mul(v75, p, p, n, v64) || !BN_mod_mul(b, b, p, n, v64))
                {
                  goto LABEL_228;
                }

                v200 = BN_mod_mul(r, r, v75, n, v64);
                v99 = v64;
                v98 = 0;
                LODWORD(i) = v198;
                if (!v200)
                {
                  goto LABEL_230;
                }
              }

              v73 = b;
              if (BN_copy(aa, b))
              {
                goto LABEL_110;
              }
            }

            goto LABEL_228;
          }
        }

        goto LABEL_296;
      }
    }

    if (!BN_nnmod(p, v69, n, v64))
    {
      goto LABEL_228;
    }

    v178 = p->top;
    if (!v178)
    {
      goto LABEL_296;
    }

    v179 = p->d;
    if (v178 < 4)
    {
      v180 = 0;
      v181 = 0;
      goto LABEL_262;
    }

    v180 = v178 & 0xFFFFFFFFFFFFFFFCLL;
    v182 = v179 + 1;
    v183 = 0uLL;
    v184 = v178 & 0xFFFFFFFFFFFFFFFCLL;
    v185 = 0uLL;
    do
    {
      v183 = vorrq_s8(v182[-1], v183);
      v185 = vorrq_s8(*v182, v185);
      v182 += 2;
      v184 -= 4;
    }

    while (v184);
    v186 = vorrq_s8(v185, v183);
    v181 = vorr_s8(*v186.i8, *&vextq_s8(v186, v186, 8uLL));
    if (v180 != v178)
    {
LABEL_262:
      v187 = v178 - v180;
      v188 = &v179->i64[v180];
      do
      {
        v189 = *v188++;
        *&v181 |= v189;
        --v187;
      }

      while (v187);
    }

    if (v181)
    {
      if (!BN_one(b))
      {
        goto LABEL_228;
      }

      goto LABEL_273;
    }

LABEL_296:
    v98 = aa;
    aa->neg = 0;
    aa->top = 0;
  }

  else
  {
LABEL_228:
    v98 = 0;
  }

  v99 = v64;
LABEL_230:
  if ((*(v99 + 56) & 1) == 0)
  {
    v161 = *(v99 + 4);
    if (v161)
    {
      *(v99 + 6) = *(*(v99 + 3) + 8 * v161 - 8);
      *(v99 + 4) = v161 - 1;
      return v98;
    }

LABEL_299:
    abort();
  }

  return v98;
}

uint64_t EVP_AEAD_CTX_init(void *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v6 = *(a2 + 1);
  if (!v6)
  {
    ERR_put_error(30, 0, 124, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/aead.cc.inc", 69);
    goto LABEL_6;
  }

  if (*a2 != a4)
  {
    ERR_put_error(30, 0, 120, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/aead.cc.inc", 82);
    result = 0;
    *a1 = 0;
    return result;
  }

  *a1 = a2;
  result = v6(a1, a3, a4, a5);
  if (!result)
  {
LABEL_6:
    result = 0;
    *a1 = 0;
  }

  return result;
}

uint64_t EVP_AEAD_CTX_seal(uint64_t a1, char *a2, void *a3, size_t a4, uint64_t a5, uint64_t a6, char *a7, size_t a8, uint64_t a9, uint64_t a10)
{
  if (__CFADD__(a8, *(*a1 + 2)))
  {
    v13 = 117;
    v14 = 127;
LABEL_10:
    ERR_put_error(30, 0, v13, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/aead.cc.inc", v14);
    goto LABEL_11;
  }

  if (a4 < a8)
  {
    v13 = 103;
    v14 = 132;
    goto LABEL_10;
  }

  if (a7 != a2 && &a2[a4] > a7 && &a7[a8] > a2)
  {
    v13 = 115;
    v14 = 137;
    goto LABEL_10;
  }

  v16 = *(*a1 + 40);
  v18 = 0;
  if (v16(a1, a2, &a2[a8], &v18, a4 - a8, a5, a6, a7, a8, 0, 0, a9, a10))
  {
    result = 1;
    *a3 = v18 + a8;
    return result;
  }

LABEL_11:
  if (a4)
  {
    bzero(a2, a4);
  }

  result = 0;
  *a3 = 0;
  return result;
}

uint64_t EVP_AEAD_CTX_seal_scatter(uint64_t *a1, char *a2, char *a3, void *a4, size_t a5, uint64_t a6, uint64_t a7, char *a8, size_t a9, uint64_t a10, uint64_t a11)
{
  v15 = &a8[a9];
  v16 = &a2[a9];
  if (a8 != a2 && (v15 > a2 ? (v17 = v16 > a8) : (v17 = 0), v17) || &a3[a5] > a2 && v16 > a3 || &a3[a5] > a8 && v15 > a3)
  {
    v18 = 115;
    v19 = 168;
LABEL_11:
    ERR_put_error(30, 0, v18, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/aead.cc.inc", v19);
    goto LABEL_12;
  }

  v21 = *a1;
  if (a11 && !*(v21 + 4))
  {
    v18 = 112;
    v19 = 173;
    goto LABEL_11;
  }

  if ((*(v21 + 40))(a1, a2, a3, a4, a5))
  {
    return 1;
  }

LABEL_12:
  if (a9)
  {
    bzero(a2, a9);
  }

  if (a5)
  {
    bzero(a3, a5);
  }

  result = 0;
  *a4 = 0;
  return result;
}

uint64_t EVP_AEAD_CTX_open(unsigned __int8 *a1, char *a2, size_t *a3, size_t a4, uint64_t a5, uint64_t a6, char *a7, unint64_t a8)
{
  if (a7 != a2 && &a2[a4] > a7 && &a7[a8] > a2)
  {
    v11 = 115;
    v12 = 198;
LABEL_5:
    ERR_put_error(30, 0, v11, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/aead.cc.inc", v12);
LABEL_6:
    if (a4)
    {
      bzero(a2, a4);
    }

    v13 = 0;
    result = 0;
    goto LABEL_9;
  }

  v15 = *(*a1 + 32);
  if (!v15)
  {
    v16 = a1[568];
    v13 = a8 - v16;
    if (a8 < v16)
    {
      v11 = 101;
      v12 = 215;
      goto LABEL_5;
    }

    if (v13 > a4)
    {
      v11 = 103;
      v12 = 221;
      goto LABEL_5;
    }

    if (a7 != a2 && (&a7[v13] > a2 ? (v17 = &a2[v13] > a7) : (v17 = 0), v17))
    {
      v18 = a8;
      v19 = 115;
      v20 = 245;
    }

    else
    {
      v18 = a8;
      v21 = *(*a1 + 48);
      if (v21)
      {
        if (v21(a1, a2))
        {
          result = 1;
LABEL_9:
          *a3 = v13;
          return result;
        }

        goto LABEL_29;
      }

      v19 = 104;
      v20 = 250;
    }

    ERR_put_error(30, 0, v19, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/aead.cc.inc", v20);
LABEL_29:
    if (v18 != v16)
    {
      bzero(a2, v13);
    }

    goto LABEL_6;
  }

  if (!v15(a1, a2))
  {
    goto LABEL_6;
  }

  return 1;
}

int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv, int enc)
{
  if (enc != -1)
  {
    v10 = enc != 0;
    *&ctx->oiv[4] = v10;
    v11 = ctx->cipher;
    if (cipher)
    {
      goto LABEL_3;
    }

LABEL_16:
    if (v11)
    {
      goto LABEL_23;
    }

    v19 = 114;
    v20 = 142;
LABEL_48:
    ERR_put_error(30, 0, v19, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", v20);
    return 0;
  }

  v10 = *&ctx->oiv[4];
  v11 = ctx->cipher;
  if (!cipher)
  {
    goto LABEL_16;
  }

LABEL_3:
  if (v11)
  {
    cleanup = v11->cleanup;
    if (cleanup)
    {
      (cleanup)(ctx);
    }

    v13 = *&ctx->encrypt;
    if (v13)
    {
      v15 = *(v13 - 8);
      v14 = (v13 - 8);
      v16 = v15 + 8;
      if (v15 != -8)
      {
        bzero(v14, v16);
      }

      free(v14);
    }

    *ctx->oiv = 0u;
    *ctx->final = 0u;
    *&ctx->cipher_data = 0u;
    *&ctx->key_len = 0u;
    *&ctx->num = 0u;
    *&ctx->buf[16] = 0u;
    *ctx->buf = 0u;
    *ctx->iv = 0u;
    *&ctx->engine = 0u;
    *&ctx->oiv[4] = v10;
  }

  ctx->cipher = cipher;
  flags_low = LODWORD(cipher->flags);
  if (!flags_low)
  {
    *&ctx->encrypt = 0;
    v11 = cipher;
    *ctx->oiv = cipher->key_len;
    *&ctx->oiv[8] = 0;
    if ((cipher->flags & 0x20000000000) == 0)
    {
      goto LABEL_23;
    }

LABEL_19:
    v21 = *&v11->ctx_size;
    if (v21)
    {
      v22 = v21(ctx, 0, 0, 0);
      if (v22 != -1)
      {
        if (v22)
        {
          v11 = ctx->cipher;
          goto LABEL_23;
        }

        goto LABEL_47;
      }

      v29 = 105;
      v30 = 588;
    }

    else
    {
      v29 = 104;
      v30 = 582;
    }

    ERR_put_error(30, 0, v29, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", v30);
LABEL_47:
    ctx->cipher = 0;
    v19 = 107;
    v20 = 137;
    goto LABEL_48;
  }

  v18 = malloc_type_malloc(flags_low + 8, 0xB4E622C9uLL);
  if (!v18)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc", 217);
    result = 0;
    *&ctx->encrypt = 0;
    ctx->cipher = 0;
    return result;
  }

  *v18 = flags_low;
  *&ctx->encrypt = v18 + 1;
  v11 = ctx->cipher;
  *ctx->oiv = cipher->key_len;
  *&ctx->oiv[8] = 0;
  if ((v11->flags & 0x20000000000) != 0)
  {
    goto LABEL_19;
  }

LABEL_23:
  flags_high = HIDWORD(v11->flags);
  if ((flags_high & 0x100) != 0)
  {
    goto LABEL_56;
  }

  result = 0;
  v25 = HIDWORD(v11->flags) & 0x3F;
  if (v25 > 2)
  {
    if (v25 - 4 < 2)
    {
      ctx->key_len = 0;
      if (!iv)
      {
        goto LABEL_56;
      }

      iv_len = v11->iv_len;
      if (!iv_len)
      {
        goto LABEL_56;
      }

      v27 = &ctx->iv[12];
      v28 = iv;
      goto LABEL_55;
    }

    if (v25 != 3)
    {
      return result;
    }

    ctx->key_len = 0;
  }

  else
  {
    if (v25 < 2)
    {
      goto LABEL_56;
    }

    if (v25 != 2)
    {
      return result;
    }
  }

  if (iv)
  {
    v31 = v11->iv_len;
    if (v31)
    {
      memcpy(&ctx->oiv[12], iv, v31);
      flags_high = HIDWORD(v11->flags);
    }
  }

  if ((flags_high & 0x3F) != 6)
  {
    goto LABEL_52;
  }

  LODWORD(__n) = 0;
  v32 = *&v11->ctx_size;
  if (!v32)
  {
    v35 = 104;
    v36 = 582;
LABEL_51:
    ERR_put_error(30, 0, v35, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", v36);
    goto LABEL_52;
  }

  v33 = v32(ctx, 25, 0, &__n);
  if (v33 == -1)
  {
    v35 = 105;
    v36 = 588;
    goto LABEL_51;
  }

  if (v33 != 1)
  {
LABEL_52:
    v34 = ctx->cipher->iv_len;
    goto LABEL_53;
  }

  v34 = __n;
LABEL_53:
  if (!v34)
  {
    goto LABEL_56;
  }

  iv_len = v34;
  v27 = &ctx->iv[12];
  v28 = &ctx->oiv[12];
LABEL_55:
  memcpy(v27, v28, iv_len);
LABEL_56:
  v37 = ctx->cipher;
  if (!key && (v37->flags & 0x8000000000) == 0 || (result = (v37->init)(ctx, key, iv, v10)) != 0)
  {
    HIDWORD(ctx->app_data) = 0;
    *(&ctx->key_len + 1) = 0;
    result = 1;
    *&ctx->final[8] = 0;
  }

  return result;
}

int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  if (*&ctx->final[8])
  {
    v5 = 66;
    v6 = 218;
LABEL_13:
    ERR_put_error(30, 0, v5, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", v6);
    return 0;
  }

  v7 = inl;
  *&ctx->final[8] = 1;
  cipher = ctx->cipher;
  block_size = ctx->cipher->block_size;
  if (block_size >= 2 && (block_size ^ 0x7FFFFFFF) < inl)
  {
    v5 = 69;
    v6 = 230;
    goto LABEL_13;
  }

  if ((cipher->flags & 0x40000000000) != 0)
  {
    v19 = outl;
    v20 = ctx;
    v21 = (cipher->do_cipher)();
    if (v21 < 0)
    {
      return 0;
    }

    *v19 = v21;
    *&v20->final[8] = 0;
    return 1;
  }

  if (inl <= 0)
  {
    *outl = 0;
    if (inl)
    {
      return 0;
    }

    goto LABEL_32;
  }

  app_data_high = SHIDWORD(ctx->app_data);
  if (!app_data_high)
  {
    if (((block_size + 0x7FFFFFFF) & inl) != 0)
    {
      block_size = 0;
      goto LABEL_26;
    }

    v34 = outl;
    v35 = ctx;
    result = (cipher->do_cipher)();
    if (!result)
    {
      *v34 = 0;
      return result;
    }

    *v34 = v7;
    *&v35->final[8] = 0;
    return 1;
  }

  v12 = block_size - app_data_high;
  v13 = &ctx->buf[12];
  v14 = inl - (block_size - app_data_high);
  if (inl < block_size - app_data_high)
  {
    v15 = ctx;
    v16 = &v13[app_data_high];
    v17 = outl;
    memcpy(v16, in, inl);
    HIDWORD(v15->app_data) += v7;
    *v17 = 0;
    *&v15->final[8] = 0;
    return 1;
  }

  v22 = in;
  v23 = outl;
  v24 = v12;
  if (block_size != app_data_high)
  {
    v25 = ctx;
    memcpy(&v13[app_data_high], in, v12);
    ctx = v25;
    cipher = v25->cipher;
  }

  v26 = ctx;
  result = (cipher->do_cipher)();
  if (!result)
  {
    return result;
  }

  in = &v22[v24];
  ctx = v26;
  cipher = v26->cipher;
  v7 = v14;
  outl = v23;
LABEL_26:
  *outl = block_size;
  v27 = (cipher->block_size - 1) & v7;
  v28 = v7 - v27;
  if (v28 < 1)
  {
LABEL_29:
    if (v27)
    {
      v32 = &in[v28];
      v33 = ctx;
      memcpy(&ctx->buf[12], v32, v27);
      ctx = v33;
    }

    HIDWORD(ctx->app_data) = v27;
LABEL_32:
    *&ctx->final[8] = 0;
    return 1;
  }

  v29 = outl;
  v30 = ctx;
  v31 = in;
  result = (cipher->do_cipher)();
  if (result)
  {
    *v29 += v28;
    ctx = v30;
    in = v31;
    goto LABEL_29;
  }

  return result;
}

int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl)
{
  if (*&ctx->final[8])
  {
    v3 = 66;
    v4 = 311;
LABEL_3:
    ERR_put_error(30, 0, v3, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", v4);
    return 0;
  }

  cipher = ctx->cipher;
  if ((ctx->cipher->flags & 0x40000000000) != 0)
  {
    v9 = (cipher->do_cipher)();
    if (v9 < 0)
    {
      return 0;
    }

    else
    {
      *outl = v9;
      return 1;
    }
  }

  else
  {
    block_size = cipher->block_size;
    if (block_size == 1)
    {
      goto LABEL_7;
    }

    app_data_high = HIDWORD(ctx->app_data);
    if ((ctx->oiv[9] & 8) != 0)
    {
      if (app_data_high)
      {
        v3 = 106;
        v4 = 337;
        goto LABEL_3;
      }

LABEL_7:
      *outl = 0;
      return 1;
    }

    if (block_size > app_data_high)
    {
      v12 = ctx;
      v13 = out;
      memset(&ctx->buf[app_data_high + 12], block_size - app_data_high, (block_size + ~app_data_high) + 1);
      ctx = v12;
      out = v13;
    }

    result = (cipher->do_cipher)(ctx, out, &ctx->buf[12], block_size);
    if (result)
    {
      *outl = block_size;
      return 1;
    }
  }

  return result;
}

int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  if (*&ctx->final[8])
  {
    v5 = 66;
    v6 = 361;
LABEL_21:
    ERR_put_error(30, 0, v5, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", v6);
    return 0;
  }

  cipher = ctx->cipher;
  block_size = ctx->cipher->block_size;
  if (block_size >= 2 && (block_size ^ 0x7FFFFFFF) < inl)
  {
    v5 = 69;
    v6 = 369;
    goto LABEL_21;
  }

  if ((cipher->flags & 0x40000000000) != 0)
  {
    v19 = outl;
    v20 = (cipher->do_cipher)();
    v21 = v20 & ~(v20 >> 31);
    result = v20 >= 0;
    *v19 = v21;
    return result;
  }

  if (inl <= 0)
  {
    *outl = 0;
    return inl == 0;
  }

  if ((ctx->oiv[9] & 8) != 0)
  {

    return EVP_EncryptUpdate(ctx, out, outl, in, inl);
  }

  else
  {
    v11 = *(&ctx->key_len + 1);
    v12 = ctx;
    if (v11)
    {
      if (block_size)
      {
        v13 = out;
        v14 = outl;
        v15 = in;
        memcpy(out, &ctx->flags, block_size);
        in = v15;
        ctx = v12;
        out = v13;
        outl = v14;
      }

      out += block_size;
    }

    v16 = out;
    v17 = outl;
    result = EVP_EncryptUpdate(ctx, out, outl, in, inl);
    if (result)
    {
      if (block_size < 2 || HIDWORD(v12->app_data))
      {
        *(&v12->key_len + 1) = 0;
        if (!v11)
        {
          return 1;
        }
      }

      else
      {
        *v17 -= block_size;
        *(&v12->key_len + 1) = 1;
        memcpy(&v12->flags, &v16[*v17], block_size);
        if (!v11)
        {
          return 1;
        }
      }

      *v17 += block_size;
      return 1;
    }
  }

  return result;
}

int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *outm, int *outl)
{
  *outl = 0;
  if (*&ctx->final[8])
  {
    ERR_put_error(30, 0, 66, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", 428);
    return 0;
  }

  cipher = ctx->cipher;
  if ((ctx->cipher->flags & 0x40000000000) != 0)
  {
    v7 = (cipher->do_cipher)();
    if ((v7 & 0x80000000) == 0)
    {
      *outl = v7;
      return 1;
    }

    return 0;
  }

  if ((ctx->oiv[9] & 8) != 0)
  {
    if (!HIDWORD(ctx->app_data))
    {
      return 1;
    }

    ERR_put_error(30, 0, 106, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", 445);
    return 0;
  }

  block_size = cipher->block_size;
  if (block_size < 2)
  {
    return 1;
  }

  if (HIDWORD(ctx->app_data) || !*(&ctx->key_len + 1))
  {
    ERR_put_error(30, 0, 123, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", 454);
    return 0;
  }

  else
  {
    v8 = block_size - 1;
    v9 = *(&ctx->key_len + block_size + 7);
    if (*(&ctx->key_len + block_size + 7))
    {
      v10 = block_size < v9;
    }

    else
    {
      v10 = 1;
    }

    if (v10)
    {
      ERR_put_error(30, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", 463);
      return 0;
    }

    else
    {
      v11 = *(&ctx->flags + v8);
      while (*(&ctx->flags + v8) == v9)
      {
        --v8;
        if (!--v11)
        {
          v12 = block_size - v9;
          if (v12 >= 1)
          {
            if (v12 < 8 || (outm - ctx - 112) < 0x20)
            {
              v13 = 0;
              goto LABEL_27;
            }

            if (v12 >= 0x20)
            {
              v13 = v12 & 0x7FFFFFE0;
              p_final_used = &ctx->final_used;
              v19 = outm + 16;
              v20 = v13;
              do
              {
                v21 = *p_final_used;
                *(v19 - 1) = *(p_final_used - 1);
                *v19 = v21;
                p_final_used += 8;
                v19 += 32;
                v20 -= 32;
              }

              while (v20);
              if (v13 != v12)
              {
                if ((v12 & 0x18) == 0)
                {
                  goto LABEL_27;
                }

                goto LABEL_37;
              }
            }

            else
            {
              v13 = 0;
LABEL_37:
              v22 = v13;
              v13 = v12 & 0x7FFFFFF8;
              v23 = (&ctx->flags + v22);
              v24 = &outm[v22];
              v25 = v22 - v13;
              do
              {
                v26 = *v23++;
                *v24 = v26;
                v24 += 8;
                v25 += 8;
              }

              while (v25);
              if (v13 != v12)
              {
LABEL_27:
                v14 = v12 - v13;
                v15 = &outm[v13];
                v16 = &ctx->flags + v13;
                do
                {
                  v17 = *v16++;
                  *v15++ = v17;
                  --v14;
                }

                while (v14);
              }
            }
          }

          *outl = v12;
          return 1;
        }
      }

      ERR_put_error(30, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.cc.inc", 469);
      return 0;
    }
  }
}

int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  if (*&ctx->oiv[4])
  {
    return EVP_EncryptUpdate(ctx, out, outl, in, inl);
  }

  else
  {
    return EVP_DecryptUpdate(ctx, out, outl, in, inl);
  }
}

int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *outm, int *outl)
{
  if (*&ctx->oiv[4])
  {
    return EVP_EncryptFinal_ex(ctx, outm, outl);
  }

  else
  {
    return EVP_DecryptFinal_ex(ctx, outm, outl);
  }
}

const EVP_CIPHER *EVP_aes_128_cbc(void)
{
  if (pthread_once(&EVP_aes_128_cbc_once, EVP_aes_128_cbc_init))
  {
    abort();
  }

  return &EVP_aes_128_cbc_storage;
}

double EVP_aes_128_cbc_init(void)
{
  unk_2808D4018 = 0u;
  EVP_aes_128_cbc_storage = xmmword_273BA6EC0;
  *&result = 0x200000108;
  qword_2808D4000 = 0x200000108;
  qword_2808D4008 = aes_init_key;
  qword_2808D4010 = aes_cbc_cipher;
  return result;
}

__int128 *EVP_aes_128_ctr()
{
  if (pthread_once(&EVP_aes_128_ctr_once, EVP_aes_128_ctr_init))
  {
    abort();
  }

  return &EVP_aes_128_ctr_storage;
}

double EVP_aes_128_ctr_init(void)
{
  unk_2808D4058 = 0u;
  EVP_aes_128_ctr_storage = xmmword_273BA6ED0;
  *&result = 0x500000108;
  qword_2808D4040 = 0x500000108;
  qword_2808D4048 = aes_init_key;
  qword_2808D4050 = aes_ctr_cipher;
  return result;
}

__int128 *EVP_aes_128_gcm()
{
  if (pthread_once(&EVP_aes_128_gcm_once, EVP_aes_128_gcm_init))
  {
    abort();
  }

  return &EVP_aes_128_gcm_storage;
}

double EVP_aes_128_gcm_init(void)
{
  EVP_aes_128_gcm_storage = xmmword_273BA6EE0;
  *&result = 0x1F86000002A0;
  qword_2808D4080 = 0x1F86000002A0;
  qword_2808D4088 = aes_gcm_init_key;
  qword_2808D4090 = aes_gcm_cipher;
  qword_2808D4098 = aes_gcm_cleanup;
  qword_2808D40A0 = aes_gcm_ctrl;
  return result;
}

const EVP_CIPHER *EVP_aes_192_cbc(void)
{
  if (pthread_once(&EVP_aes_192_cbc_once, EVP_aes_192_cbc_init))
  {
    abort();
  }

  return &EVP_aes_192_cbc_storage;
}

double EVP_aes_192_cbc_init(void)
{
  unk_2808D40D8 = 0u;
  EVP_aes_192_cbc_storage = xmmword_273BA6EF0;
  *&result = 0x200000108;
  qword_2808D40C0 = 0x200000108;
  qword_2808D40C8 = aes_init_key;
  qword_2808D40D0 = aes_cbc_cipher;
  return result;
}

__int128 *EVP_aes_192_ctr()
{
  if (pthread_once(&EVP_aes_192_ctr_once, EVP_aes_192_ctr_init))
  {
    abort();
  }

  return &EVP_aes_192_ctr_storage;
}

double EVP_aes_192_ctr_init(void)
{
  unk_2808D4118 = 0u;
  EVP_aes_192_ctr_storage = xmmword_273BA6F00;
  *&result = 0x500000108;
  qword_2808D4100 = 0x500000108;
  qword_2808D4108 = aes_init_key;
  qword_2808D4110 = aes_ctr_cipher;
  return result;
}

const EVP_CIPHER *EVP_aes_256_cbc(void)
{
  if (pthread_once(&EVP_aes_256_cbc_once, EVP_aes_256_cbc_init))
  {
    abort();
  }

  return &EVP_aes_256_cbc_storage;
}

double EVP_aes_256_cbc_init(void)
{
  unk_2808D4158 = 0u;
  EVP_aes_256_cbc_storage = xmmword_273BA6F10;
  *&result = 0x200000108;
  qword_2808D4140 = 0x200000108;
  qword_2808D4148 = aes_init_key;
  qword_2808D4150 = aes_cbc_cipher;
  return result;
}

__int128 *EVP_aes_256_ctr()
{
  if (pthread_once(&EVP_aes_256_ctr_once, EVP_aes_256_ctr_init))
  {
    abort();
  }

  return &EVP_aes_256_ctr_storage;
}

double EVP_aes_256_ctr_init(void)
{
  unk_2808D4198 = 0u;
  EVP_aes_256_ctr_storage = xmmword_273BA6F20;
  *&result = 0x500000108;
  qword_2808D4180 = 0x500000108;
  qword_2808D4188 = aes_init_key;
  qword_2808D4190 = aes_ctr_cipher;
  return result;
}

__int128 *EVP_aes_256_gcm()
{
  if (pthread_once(&EVP_aes_256_gcm_once, EVP_aes_256_gcm_init))
  {
    abort();
  }

  return &EVP_aes_256_gcm_storage;
}

double EVP_aes_256_gcm_init(void)
{
  EVP_aes_256_gcm_storage = xmmword_273BA6F30;
  *&result = 0x1F86000002A0;
  qword_2808D41C0 = 0x1F86000002A0;
  qword_2808D41C8 = aes_gcm_init_key;
  qword_2808D41D0 = aes_gcm_cipher;
  qword_2808D41D8 = aes_gcm_cleanup;
  qword_2808D41E0 = aes_gcm_ctrl;
  return result;
}

int *EVP_aead_aes_128_gcm()
{
  if (pthread_once(&EVP_aead_aes_128_gcm_once, EVP_aead_aes_128_gcm_init))
  {
    abort();
  }

  return &EVP_aead_aes_128_gcm_storage;
}

double EVP_aead_aes_128_gcm_init(void)
{
  xmmword_2808D41F8 = 0u;
  unk_2808D4208 = 0u;
  xmmword_2808D4218 = 0u;
  qword_2808D4228 = 0;
  *&result = 269487120;
  EVP_aead_aes_128_gcm_storage = 269487120;
  dword_2808D41EC = 1;
  qword_2808D41F0 = aead_aes_gcm_init;
  *(&xmmword_2808D41F8 + 1) = aead_aes_gcm_cleanup;
  qword_2808D4210 = aead_aes_gcm_seal_scatter;
  *&xmmword_2808D4218 = aead_aes_gcm_open_gather;
  return result;
}

int *EVP_aead_aes_256_gcm()
{
  if (pthread_once(&EVP_aead_aes_256_gcm_once, EVP_aead_aes_256_gcm_init))
  {
    abort();
  }

  return &EVP_aead_aes_256_gcm_storage;
}

double EVP_aead_aes_256_gcm_init(void)
{
  xmmword_2808D4240 = 0u;
  unk_2808D4250 = 0u;
  xmmword_2808D4260 = 0u;
  qword_2808D4270 = 0;
  *&result = 269487136;
  EVP_aead_aes_256_gcm_storage = 269487136;
  dword_2808D4234 = 1;
  qword_2808D4238 = aead_aes_gcm_init;
  *(&xmmword_2808D4240 + 1) = aead_aes_gcm_cleanup;
  qword_2808D4258 = aead_aes_gcm_seal_scatter;
  *&xmmword_2808D4260 = aead_aes_gcm_open_gather;
  return result;
}

int *EVP_aead_aes_128_gcm_tls12()
{
  if (pthread_once(&EVP_aead_aes_128_gcm_tls12_once, EVP_aead_aes_128_gcm_tls12_init))
  {
    abort();
  }

  return &EVP_aead_aes_128_gcm_tls12_storage;
}

double EVP_aead_aes_128_gcm_tls12_init(void)
{
  xmmword_2808D4288 = 0u;
  unk_2808D4298 = 0u;
  xmmword_2808D42A8 = 0u;
  qword_2808D42B8 = 0;
  *&result = 269487120;
  EVP_aead_aes_128_gcm_tls12_storage = 269487120;
  dword_2808D427C = 1;
  qword_2808D4280 = aead_aes_gcm_tls12_init;
  *(&xmmword_2808D4288 + 1) = aead_aes_gcm_cleanup;
  qword_2808D42A0 = aead_aes_gcm_tls12_seal_scatter;
  *&xmmword_2808D42A8 = aead_aes_gcm_open_gather;
  return result;
}

int *EVP_aead_aes_256_gcm_tls12()
{
  if (pthread_once(&EVP_aead_aes_256_gcm_tls12_once, EVP_aead_aes_256_gcm_tls12_init))
  {
    abort();
  }

  return &EVP_aead_aes_256_gcm_tls12_storage;
}

double EVP_aead_aes_256_gcm_tls12_init(void)
{
  xmmword_2808D42D0 = 0u;
  unk_2808D42E0 = 0u;
  xmmword_2808D42F0 = 0u;
  qword_2808D4300 = 0;
  *&result = 269487136;
  EVP_aead_aes_256_gcm_tls12_storage = 269487136;
  dword_2808D42C4 = 1;
  qword_2808D42C8 = aead_aes_gcm_tls12_init;
  *(&xmmword_2808D42D0 + 1) = aead_aes_gcm_cleanup;
  qword_2808D42E8 = aead_aes_gcm_tls12_seal_scatter;
  *&xmmword_2808D42F0 = aead_aes_gcm_open_gather;
  return result;
}

int *EVP_aead_aes_128_gcm_tls13()
{
  if (pthread_once(&EVP_aead_aes_128_gcm_tls13_once, EVP_aead_aes_128_gcm_tls13_init))
  {
    abort();
  }

  return &EVP_aead_aes_128_gcm_tls13_storage;
}

double EVP_aead_aes_128_gcm_tls13_init(void)
{
  xmmword_2808D4318 = 0u;
  unk_2808D4328 = 0u;
  xmmword_2808D4338 = 0u;
  qword_2808D4348 = 0;
  *&result = 269487120;
  EVP_aead_aes_128_gcm_tls13_storage = 269487120;
  dword_2808D430C = 1;
  qword_2808D4310 = aead_aes_gcm_tls13_init;
  *(&xmmword_2808D4318 + 1) = aead_aes_gcm_cleanup;
  qword_2808D4330 = aead_aes_gcm_tls13_seal_scatter;
  *&xmmword_2808D4338 = aead_aes_gcm_open_gather;
  return result;
}

int *EVP_aead_aes_256_gcm_tls13()
{
  if (pthread_once(&EVP_aead_aes_256_gcm_tls13_once, EVP_aead_aes_256_gcm_tls13_init))
  {
    abort();
  }

  return &EVP_aead_aes_256_gcm_tls13_storage;
}

double EVP_aead_aes_256_gcm_tls13_init(void)
{
  xmmword_2808D4360 = 0u;
  unk_2808D4370 = 0u;
  xmmword_2808D4380 = 0u;
  qword_2808D4390 = 0;
  *&result = 269487136;
  EVP_aead_aes_256_gcm_tls13_storage = 269487136;
  dword_2808D4354 = 1;
  qword_2808D4358 = aead_aes_gcm_tls13_init;
  *(&xmmword_2808D4360 + 1) = aead_aes_gcm_cleanup;
  qword_2808D4378 = aead_aes_gcm_tls13_seal_scatter;
  *&xmmword_2808D4380 = aead_aes_gcm_open_gather;
  return result;
}

int EVP_Digest(const void *data, size_t count, unsigned __int8 *md, unsigned int *size, const EVP_MD *type, ENGINE *impl)
{
  *v23 = 0u;
  v24 = 0u;
  final_high = HIDWORD(type->final);
  v12 = malloc_type_malloc(final_high + 8, 0xB4E622C9uLL);
  if (!v12)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc", 217);
    v20 = 0;
    v21 = *(&v24 + 1);
    if (!*(&v24 + 1))
    {
      return v20;
    }

    goto LABEL_11;
  }

  *v12 = final_high;
  v23[0] = type;
  v23[1] = v12 + 1;
  (type->flags)(v23);
  (*(v23[0] + 3))(v23, data, count);
  (*(v23[0] + 4))(v23, md);
  v13 = v23[0];
  if (size)
  {
    *size = *(v23[0] + 1);
  }

  v14 = v23[1];
  v15 = v13[11];
  if (v15)
  {
    bzero(v23[1], v15);
    v14 = v23[1];
  }

  if (v14)
  {
    v17 = *(v14 - 1);
    v16 = (v14 - 1);
    v18 = v17 + 8;
    if (v17 != -8)
    {
      v19 = v16;
      bzero(v16, v18);
      v16 = v19;
    }

    free(v16);
  }

  v20 = 1;
  v21 = *(&v24 + 1);
  if (*(&v24 + 1))
  {
LABEL_11:
    (*v21)(v24);
  }

  return v20;
}

int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx)
{
  engine = ctx->engine;
  if (engine)
  {
    v4 = *(engine - 1);
    v3 = engine - 8;
    v5 = v4 + 8;
    if (v4 != -8)
    {
      bzero(v3, v5);
    }

    free(v3);
  }

  md_data = ctx->md_data;
  if (md_data)
  {
    (*md_data)(ctx->flags);
  }

  *&ctx->digest = 0u;
  *&ctx->flags = 0u;
  return 1;
}

int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
{
  if (!in)
  {
    goto LABEL_12;
  }

  if (in->flags)
  {
    v4 = (*(in->md_data + 1))();
    if (!v4)
    {
      return v4;
    }

    v5 = v4;
    digest = in->digest;
    if (!in->digest)
    {
      v9 = 0;
      engine = out->engine;
      if (engine)
      {
        goto LABEL_15;
      }

LABEL_18:
      md_data = out->md_data;
      if (md_data)
      {
        (*md_data)(out->flags);
      }

      *&out->digest = 0u;
      *&out->flags = 0u;
      v15 = in->digest;
      out->digest = in->digest;
      out->engine = v9;
      if (v15)
      {
        final_high = HIDWORD(v15->final);
        if (final_high)
        {
          memcpy(v9, in->engine, final_high);
        }
      }

      v17 = in->md_data;
      out->flags = v5;
      out->md_data = v17;
      LODWORD(v4) = 1;
      return v4;
    }

    if (out->digest != digest)
    {
      goto LABEL_6;
    }

LABEL_11:
    v9 = out->engine;
    out->engine = 0;
    goto LABEL_18;
  }

  digest = in->digest;
  if (!in->digest)
  {
LABEL_12:
    ERR_put_error(29, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/digest/digest.cc.inc", 97);
    LODWORD(v4) = 0;
    return v4;
  }

  v5 = 0;
  if (out->digest == digest)
  {
    goto LABEL_11;
  }

LABEL_6:
  v7 = HIDWORD(digest->final);
  v8 = malloc_type_malloc(v7 + 8, 0xB4E622C9uLL);
  if (v8)
  {
    *v8 = v7;
    v9 = (v8 + 1);
    engine = out->engine;
    if (!engine)
    {
      goto LABEL_18;
    }

LABEL_15:
    v12 = *(engine - 1);
    v11 = engine - 8;
    v13 = v12 + 8;
    if (v12 != -8)
    {
      bzero(v11, v13);
    }

    free(v11);
    goto LABEL_18;
  }

  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.cc", 217);
  if (v5)
  {
    (*in->md_data)(v5);
  }

  LODWORD(v4) = 0;
  return v4;
}