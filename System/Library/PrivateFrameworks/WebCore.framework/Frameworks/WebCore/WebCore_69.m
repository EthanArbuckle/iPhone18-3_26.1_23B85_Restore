void std::__tree<std::__value_type<webrtc::TransportFeedbackAdapter::SsrcAndRtpSequencenumber,long long>,std::__map_value_compare<webrtc::TransportFeedbackAdapter::SsrcAndRtpSequencenumber,std::__value_type<webrtc::TransportFeedbackAdapter::SsrcAndRtpSequencenumber,long long>,std::less<webrtc::TransportFeedbackAdapter::SsrcAndRtpSequencenumber>,true>,std::allocator<std::__value_type<webrtc::TransportFeedbackAdapter::SsrcAndRtpSequencenumber,long long>>>::__erase_unique<webrtc::TransportFeedbackAdapter::SsrcAndRtpSequencenumber>(uint64_t **a1, unsigned int a2, unsigned __int16 a3)
{
  v5 = a1 + 1;
  v4 = a1[1];
  if (v4)
  {
    v6 = v5;
    v7 = v4;
    do
    {
      v10 = *(v7 + 8);
      v11 = v10 == a2;
      if (v10 >= a2)
      {
        v12 = 1;
      }

      else
      {
        v12 = -1;
      }

      if (v11)
      {
        v13 = *(v7 + 18);
        v14 = v13 == a3;
        v12 = v13 >= a3 ? 1 : -1;
        if (v14)
        {
          v12 = 0;
        }
      }

      v8 = v12 & 0x80;
      v11 = v8 == 0;
      v9 = v8 >> 4;
      if (v11)
      {
        v6 = v7;
      }

      v7 = *(v7 + v9);
    }

    while (v7);
    if (v6 != v5)
    {
      v15 = *(v6 + 8);
      v16 = v15 == a2;
      if (v15 <= a2)
      {
        v17 = 1;
      }

      else
      {
        v17 = -1;
      }

      if (v16)
      {
        v18 = *(v6 + 18);
        v19 = -1;
        if (v18 <= a3)
        {
          v19 = 1;
        }

        if (v18 == a3)
        {
          v17 = 0;
        }

        else
        {
          v17 = v19;
        }
      }

      if ((v17 & 0x80) == 0)
      {
        v20 = v6[1];
        if (v20)
        {
          do
          {
            v21 = v20;
            v20 = *v20;
          }

          while (v20);
        }

        else
        {
          v22 = v6;
          do
          {
            v21 = v22[2];
            v11 = *v21 == v22;
            v22 = v21;
          }

          while (!v11);
        }

        if (*a1 == v6)
        {
          *a1 = v21;
        }

        a1[2] = (a1[2] - 1);
        std::__tree_remove[abi:sn200100]<std::__tree_node_base<void *> *>(v4, v6);

        operator delete(v6);
      }
    }
  }
}

void webrtc::FunctionView<void ()(unsigned short,webrtc::TimeDelta)>::CallVoidPtr<webrtc::TransportFeedbackAdapter::ProcessTransportFeedback(webrtc::rtcp::TransportFeedback const&,webrtc::Timestamp)::$_0>(uint64_t *a1, unsigned int a2, uint64_t a3)
{
  v5 = *a1;
  if (*(*a1 + 34))
  {
    v6 = *(v5 + 32);
    v7 = a2 >= v6;
    LODWORD(v8) = a2 - v6;
    v9 = v8 != 0 && v7;
    v10 = (v8 & 0x8000u) == 0;
    if (v8 == 0x8000)
    {
      v10 = v9;
    }

    if (v10)
    {
      v8 = v8;
    }

    else
    {
      v8 |= 0xFFFFFFFFFFFF0000;
    }

    v11 = v8 + *(v5 + 24);
  }

  else
  {
    v11 = a2;
  }

  *(v5 + 24) = v11;
  *(v5 + 32) = a2;
  *(v5 + 34) = 1;
  webrtc::TransportFeedbackAdapter::RetrievePacketFeedback(v35, v5, v11, (a3 + 0x7FFFFFFFFFFFFFFFLL) < 0xFFFFFFFFFFFFFFFELL);
  if (v58)
  {
    if (v44[23] == *(v5 + 72) && v45 == *(v5 + 76) && v46 == *(v5 + 80) && v47 == *(v5 + 82) && v48 == *(v5 + 84) && v49 == *(v5 + 88) && v50 == *(v5 + 92) && v51 == *(v5 + 94) && v52 == *(v5 + 96) && v54 == *(v5 + 104) && v53 == *(v5 + 100))
    {
      v12 = 0x7FFFFFFFFFFFFFFFLL;
      if ((a3 + 0x7FFFFFFFFFFFFFFFLL) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v13 = *(v5 + 112);
        if (v13 != 0x7FFFFFFFFFFFFFFFLL)
        {
          v14 = 1000 * (a3 / 1000);
          if (v14 != 0x7FFFFFFFFFFFFFFFLL)
          {
            v12 = 0x8000000000000000;
            v15 = v14 == 0x8000000000000000 || v13 == 0x8000000000000000;
            v16 = v13 + v14;
            if (!v15)
            {
              v12 = v16;
            }
          }
        }
      }

      v18 = v39;
      v17 = v40;
      v20 = v41;
      v19 = v42;
      v21 = v43;
      v22 = *&v44[15];
      v23 = v55;
      v24 = v56;
      v25 = v57;
      v26 = a1[2];
      v28 = v26[1];
      v27 = v26[2];
      if (v28 >= v27)
      {
        v30 = *v26;
        v31 = v28 - *v26;
        v32 = 0xAAAAAAAAAAAAAAABLL * (v31 >> 5) + 1;
        if (v32 > 0x2AAAAAAAAAAAAAALL)
        {
          goto LABEL_49;
        }

        v33 = 0x5555555555555556 * ((v27 - v30) >> 5);
        if (v33 <= v32)
        {
          v33 = 0xAAAAAAAAAAAAAAABLL * (v31 >> 5) + 1;
        }

        if (0xAAAAAAAAAAAAAAABLL * ((v27 - v30) >> 5) >= 0x155555555555555)
        {
          v34 = 0x2AAAAAAAAAAAAAALL;
        }

        else
        {
          v34 = v33;
        }

        if (v34)
        {
          if (v34 <= 0x2AAAAAAAAAAAAAALL)
          {
            operator new();
          }

          std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
        }
      }

      else if (v28)
      {
        *v28 = v36;
        *(v28 + 8) = v37;
        *(v28 + 24) = v38;
        *(v28 + 32) = v18;
        *(v28 + 36) = v17;
        *(v28 + 40) = v20;
        *(v28 + 44) = v19;
        *(v28 + 48) = v21;
        *(v28 + 49) = *v44;
        *(v28 + 56) = *&v44[7];
        *(v28 + 64) = v22;
        *(v28 + 72) = v12;
        *(v28 + 80) = 0;
        *(v28 + 84) = v23 | (v24 << 32) | (v25 << 48);
        *(v28 + 92) = 1;
        v26[1] = v28 + 96;
        return;
      }

      __break(1u);
LABEL_49:
      std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
    }

    v29 = a1[3];
  }

  else
  {
    v29 = a1[1];
  }

  ++*v29;
}

__n128 std::__introsort<std::_ClassicAlgPolicy,webrtc::TransportFeedbackAdapter::ProcessCongestionControlFeedback(webrtc::rtcp::CongestionControlFeedback const&,webrtc::Timestamp)::$_0 &,webrtc::PacketResult *,false>(unint64_t a1, __n128 *a2, uint64_t a3, char a4, __n128 result)
{
LABEL_1:
  v9 = a2 - 6;
  v10 = a2 - 12;
  v11 = a2 - 18;
  for (i = a1; ; *(i - 16) = *&v453[16])
  {
LABEL_2:
    a1 = i;
    v13 = a2 - i;
    v14 = 0xAAAAAAAAAAAAAAABLL * ((a2 - i) >> 5);
    if (v14 <= 2)
    {
      if (v14 < 2)
      {
        return result;
      }

      if (v14 == 2)
      {
        if (a2[-3].n128_u64[1] < *(i + 56))
        {
          v322 = *i;
          v360 = *(i + 16);
          *&v452[13] = *(i + 77);
          v437 = *(i + 48);
          *v452 = *(i + 64);
          v399 = *(i + 32);
          v181 = a2[-1];
          v183 = a2[-4];
          v182 = a2[-3];
          *(i + 64) = a2[-2];
          *(i + 80) = v181;
          *(i + 32) = v183;
          *(i + 48) = v182;
          v184 = a2[-5];
          *i = a2[-6];
          *(i + 16) = v184;
          a2[-6] = v322;
          a2[-5] = v360;
          result = v399;
          a2[-2] = *v452;
          a2[-1] = *&v452[16];
          a2[-4] = v399;
          a2[-3] = v437;
        }

        return result;
      }

      goto LABEL_9;
    }

    switch(v14)
    {
      case 3:
        v175 = *(i + 152);
        v176 = a2[-3].n128_i64[1];
        if (v175 < *(i + 56))
        {
          if (v176 >= v175)
          {
            goto LABEL_192;
          }

          v321 = *i;
          v359 = *(i + 16);
          *&v452[13] = *(i + 77);
          v436 = *(i + 48);
          *v452 = *(i + 64);
          v398 = *(i + 32);
          v177 = a2[-1];
          v179 = a2[-4];
          v178 = a2[-3];
          *(i + 64) = a2[-2];
          *(i + 80) = v177;
          *(i + 32) = v179;
          *(i + 48) = v178;
          v180 = a2[-5];
          *i = *v9;
          *(i + 16) = v180;
LABEL_194:
          *v9 = v321;
          a2[-5] = v359;
          result = v398;
          a2[-2] = *v452;
          a2[-1] = *&v452[16];
          a2[-4] = v398;
          a2[-3] = v436;
          return result;
        }

        if (v176 >= v175)
        {
          return result;
        }

        v403 = *(i + 128);
        v442 = *(i + 144);
        *v452 = *(i + 160);
        *&v452[13] = *(i + 173);
        v326 = *(i + 96);
        v365 = *(i + 112);
        v253 = a2[-5];
        *(i + 96) = *v9;
        *(i + 112) = v253;
        v254 = a2[-1];
        v256 = a2[-4];
        v255 = a2[-3];
        *(i + 160) = a2[-2];
        *(i + 176) = v254;
        *(i + 128) = v256;
        *(i + 144) = v255;
        *v9 = v326;
        a2[-5] = v365;
        result = v403;
        a2[-2] = *v452;
        a2[-1] = *&v452[16];
        a2[-4] = v403;
        a2[-3] = v442;
        goto LABEL_200;
      case 4:
        v185 = (i + 192);
        v186 = *(i + 152);
        v187 = *(i + 248);
        if (v186 >= *(i + 56))
        {
          if (v187 < v186)
          {
            v404 = *(i + 128);
            v443 = *(i + 144);
            *v452 = *(i + 160);
            *&v452[13] = *(i + 173);
            v327 = *(i + 96);
            v366 = *(i + 112);
            v257 = *(i + 240);
            *(i + 128) = *(i + 224);
            *(i + 144) = v257;
            v258 = *(i + 272);
            *(i + 160) = *(i + 256);
            *(i + 176) = v258;
            v259 = *(i + 208);
            *(i + 96) = *v185;
            *(i + 112) = v259;
            *v185 = v327;
            *(i + 208) = v366;
            *(i + 256) = *v452;
            *(i + 272) = *&v452[16];
            result = v443;
            *(i + 224) = v404;
            *(i + 240) = v443;
            if (*(i + 152) < *(i + 56))
            {
              v328 = *i;
              v367 = *(i + 16);
              *&v452[13] = *(i + 77);
              v444 = *(i + 48);
              *v452 = *(i + 64);
              v405 = *(i + 32);
              v260 = *(i + 176);
              *(i + 64) = *(i + 160);
              *(i + 80) = v260;
              v261 = *(i + 144);
              *(i + 32) = *(i + 128);
              *(i + 48) = v261;
              v262 = *(i + 112);
              *i = *(i + 96);
              *(i + 16) = v262;
              *(i + 96) = v328;
              *(i + 112) = v367;
              result = v405;
              *(i + 160) = *v452;
              *(i + 176) = *&v452[16];
              *(i + 128) = v405;
              *(i + 144) = v444;
            }
          }
        }

        else if (v187 >= v186)
        {
          v331 = *i;
          v370 = *(i + 16);
          *&v452[13] = *(i + 77);
          v447 = *(i + 48);
          *v452 = *(i + 64);
          v408 = *(i + 32);
          v282 = *(i + 176);
          *(i + 64) = *(i + 160);
          *(i + 80) = v282;
          v283 = *(i + 144);
          *(i + 32) = *(i + 128);
          *(i + 48) = v283;
          v284 = *(i + 112);
          *i = *(i + 96);
          *(i + 16) = v284;
          *(i + 96) = v331;
          *(i + 112) = v370;
          result = v408;
          *(i + 160) = *v452;
          *(i + 176) = *&v452[16];
          *(i + 128) = v408;
          *(i + 144) = v447;
          if (*(i + 248) < *(i + 152))
          {
            v409 = *(i + 128);
            v448 = *(i + 144);
            *v452 = *(i + 160);
            *&v452[13] = *(i + 173);
            v332 = *(i + 96);
            v371 = *(i + 112);
            v285 = *(i + 240);
            *(i + 128) = *(i + 224);
            *(i + 144) = v285;
            v286 = *(i + 272);
            *(i + 160) = *(i + 256);
            *(i + 176) = v286;
            v287 = *(i + 208);
            *(i + 96) = *v185;
            *(i + 112) = v287;
            *v185 = v332;
            *(i + 208) = v371;
            *(i + 256) = *v452;
            *(i + 272) = *&v452[16];
            result = v448;
            *(i + 224) = v409;
            *(i + 240) = v448;
          }
        }

        else
        {
          v323 = *i;
          v361 = *(i + 16);
          *&v452[13] = *(i + 77);
          v438 = *(i + 48);
          *v452 = *(i + 64);
          v400 = *(i + 32);
          v188 = *(i + 272);
          *(i + 64) = *(i + 256);
          *(i + 80) = v188;
          v189 = *(i + 240);
          *(i + 32) = *(i + 224);
          *(i + 48) = v189;
          v190 = *(i + 208);
          *i = *v185;
          *(i + 16) = v190;
          *v185 = v323;
          *(i + 208) = v361;
          result = v400;
          *(i + 256) = *v452;
          *(i + 272) = *&v452[16];
          *(i + 224) = v400;
          *(i + 240) = v438;
        }

        if (a2[-3].n128_u64[1] >= *(i + 248))
        {
          return result;
        }

        v410 = *(i + 224);
        v449 = *(i + 240);
        *v452 = *(i + 256);
        *&v452[13] = *(i + 269);
        v333 = *v185;
        v372 = *(i + 208);
        v288 = a2[-5];
        *v185 = a2[-6];
        *(i + 208) = v288;
        v289 = a2[-1];
        v291 = a2[-4];
        v290 = a2[-3];
        *(i + 256) = a2[-2];
        *(i + 272) = v289;
        *(i + 224) = v291;
        *(i + 240) = v290;
        a2[-6] = v333;
        a2[-5] = v372;
        result = v410;
        a2[-2] = *v452;
        a2[-1] = *&v452[16];
        a2[-4] = v410;
        a2[-3] = v449;
        if (*(i + 248) >= *(i + 152))
        {
          return result;
        }

        v411 = *(i + 128);
        v450 = *(i + 144);
        *v452 = *(i + 160);
        *&v452[13] = *(i + 173);
        v334 = *(i + 96);
        v373 = *(i + 112);
        v292 = *(i + 240);
        *(i + 128) = *(i + 224);
        *(i + 144) = v292;
        v293 = *(i + 272);
        *(i + 160) = *(i + 256);
        *(i + 176) = v293;
        v294 = *(i + 208);
        *(i + 96) = *v185;
        *(i + 112) = v294;
        *v185 = v334;
        *(i + 208) = v373;
        *(i + 256) = *v452;
        *(i + 272) = *&v452[16];
        result = v450;
        *(i + 224) = v411;
        *(i + 240) = v450;
LABEL_200:
        if (*(i + 152) < *(i + 56))
        {
          v335 = *i;
          v374 = *(i + 16);
          *&v452[13] = *(i + 77);
          v451 = *(i + 48);
          *v452 = *(i + 64);
          v412 = *(i + 32);
          v295 = *(i + 176);
          *(i + 64) = *(i + 160);
          *(i + 80) = v295;
          v296 = *(i + 144);
          *(i + 32) = *(i + 128);
          *(i + 48) = v296;
          v297 = *(i + 112);
          *i = *(i + 96);
          *(i + 16) = v297;
          *(i + 96) = v335;
          *(i + 112) = v374;
          result = v412;
          *(i + 160) = *v452;
          *(i + 176) = *&v452[16];
          *(i + 128) = v412;
          *(i + 144) = v451;
        }

        return result;
      case 5:

        result.n128_u64[0] = std::__sort5[abi:sn200100]<std::_ClassicAlgPolicy,webrtc::TransportFeedbackAdapter::ProcessCongestionControlFeedback(webrtc::rtcp::CongestionControlFeedback const&,webrtc::Timestamp)::$_0 &,webrtc::PacketResult *,0>(i, i + 96, i + 192, i + 288, &a2[-6]).n128_u64[0];
        return result;
    }

LABEL_9:
    if (v13 <= 2303)
    {
      break;
    }

    if (!a3)
    {
      if (i != a2)
      {
        v206 = (v14 - 2) >> 1;
        v207 = v206;
        do
        {
          if (v206 >= v207)
          {
            v208 = (2 * (v207 & 0x3FFFFFFFFFFFFFFFLL)) | 1;
            v209 = i + 96 * v208;
            if (2 * v207 + 2 < v14)
            {
              v210 = *(v209 + 56);
              v211 = *(v209 + 152);
              v212 = v210 < v211;
              v213 = v210 >= v211 ? 0 : 96;
              v209 += v213;
              if (v212)
              {
                v208 = 2 * v207 + 2;
              }
            }

            v214 = i + 96 * v207;
            if (*(v209 + 56) >= *(v214 + 56))
            {
              v440 = *(v214 + 48);
              v363 = *(v214 + 16);
              v401 = *(v214 + 32);
              v324 = *v214;
              v215 = *(v214 + 56);
              *&v454[13] = *(v214 + 77);
              *v454 = *(v214 + 64);
              do
              {
                v216 = v209;
                v217 = *(v209 + 16);
                *v214 = *v209;
                *(v214 + 16) = v217;
                v218 = *(v209 + 32);
                v219 = *(v209 + 48);
                v220 = *(v209 + 80);
                *(v214 + 64) = *(v209 + 64);
                *(v214 + 80) = v220;
                *(v214 + 32) = v218;
                *(v214 + 48) = v219;
                if (v206 < v208)
                {
                  break;
                }

                v221 = (2 * v208) | 1;
                v209 = i + 96 * v221;
                v222 = 2 * v208 + 2;
                if (v222 < v14)
                {
                  v223 = *(v209 + 56);
                  v224 = *(v209 + 152);
                  v225 = v223 < v224;
                  v226 = v223 >= v224 ? 0 : 96;
                  v209 += v226;
                  if (v225)
                  {
                    v221 = v222;
                  }
                }

                v214 = v216;
                v208 = v221;
              }

              while (*(v209 + 56) >= v215);
              *v216 = v324;
              *(v216 + 16) = v363;
              *(v216 + 32) = v401;
              *(v216 + 48) = v440;
              *(v216 + 56) = v215;
              *(v216 + 64) = *v454;
              *(v216 + 80) = *&v454[16];
            }
          }

          v212 = v207-- <= 0;
        }

        while (!v212);
        v227 = 0xAAAAAAAAAAAAAAABLL * (v13 >> 5);
        do
        {
          v228 = 0;
          v325 = *i;
          v364 = *(i + 16);
          *&v452[13] = *(i + 77);
          v441 = *(i + 48);
          *v452 = *(i + 64);
          v402 = *(i + 32);
          v229 = i;
          do
          {
            v238 = &v229[6 * v228];
            v233 = v238 + 6;
            v239 = (2 * v228) | 1;
            v228 = 2 * v228 + 2;
            if (v228 < v227)
            {
              v230 = v238[9].n128_i64[1];
              v231 = v238[15].n128_i64[1];
              v232 = v238 + 12;
              if (v230 >= v231)
              {
                v228 = v239;
              }

              else
              {
                v233 = v232;
              }
            }

            else
            {
              v228 = v239;
            }

            v234 = v233[1];
            *v229 = *v233;
            v229[1] = v234;
            v235 = v233[2];
            v236 = v233[3];
            v237 = v233[5];
            v229[4] = v233[4];
            v229[5] = v237;
            v229[2] = v235;
            v229[3] = v236;
            v229 = v233;
          }

          while (v228 <= ((v227 - 2) >> 1));
          a2 -= 6;
          if (v233 == a2)
          {
            *v233 = v325;
            v233[1] = v364;
            result = v402;
            v233[4] = *v452;
            v233[5] = *&v452[16];
            v233[2] = v402;
            v233[3] = v441;
          }

          else
          {
            v240 = a2[1];
            *v233 = *a2;
            v233[1] = v240;
            v241 = a2[2];
            v242 = a2[3];
            v243 = a2[5];
            v233[4] = a2[4];
            v233[5] = v243;
            v233[2] = v241;
            v233[3] = v242;
            a2[4] = *v452;
            a2[5] = *&v452[16];
            a2[2] = v402;
            a2[3] = v441;
            result = v325;
            *a2 = v325;
            a2[1] = v364;
            v244 = &v233[6] - i;
            if (v244 >= 97)
            {
              v245 = (-2 - 0x5555555555555555 * (v244 >> 5)) >> 1;
              v246 = i + 96 * v245;
              if (*(v246 + 56) < v233[3].n128_u64[1])
              {
                v462 = v233[3].n128_i64[0];
                v456 = v233[1];
                v459 = v233[2];
                v455 = *v233;
                v247 = v233[3].n128_i64[1];
                *&v453[13] = *(v233 + 77);
                *v453 = v233[4];
                do
                {
                  v248 = v246;
                  v249 = *(v246 + 16);
                  *v233 = *v246;
                  v233[1] = v249;
                  v250 = *(v246 + 32);
                  v251 = *(v246 + 48);
                  v252 = *(v246 + 80);
                  v233[4] = *(v246 + 64);
                  v233[5] = v252;
                  v233[2] = v250;
                  v233[3] = v251;
                  if (!v245)
                  {
                    break;
                  }

                  v245 = (v245 - 1) >> 1;
                  v246 = i + 96 * v245;
                  v233 = v248;
                }

                while (*(v246 + 56) < v247);
                *v248 = v455;
                *(v248 + 16) = v456;
                *(v248 + 32) = v459;
                *(v248 + 48) = v462;
                *(v248 + 56) = v247;
                result = *v453;
                *(v248 + 64) = *v453;
                *(v248 + 80) = *&v453[16];
              }
            }
          }

          v212 = v227-- <= 2;
        }

        while (!v212);
      }

      return result;
    }

    v15 = v14 >> 1;
    v16 = i + 96 * (v14 >> 1);
    v17 = a2[-3].n128_i64[1];
    if (v13 > 0x3000)
    {
      v18 = *(v16 + 56);
      if (v18 >= *(i + 56))
      {
        if (v17 < v18)
        {
          v300 = *v16;
          v338 = *(v16 + 16);
          *&v452[13] = *(v16 + 77);
          v415 = *(v16 + 48);
          *v452 = *(v16 + 64);
          v377 = *(v16 + 32);
          v28 = a2[-1];
          v30 = a2[-4];
          v29 = a2[-3];
          *(v16 + 64) = a2[-2];
          *(v16 + 80) = v28;
          *(v16 + 32) = v30;
          *(v16 + 48) = v29;
          v31 = a2[-5];
          *v16 = *v9;
          *(v16 + 16) = v31;
          *v9 = v300;
          a2[-5] = v338;
          a2[-2] = *v452;
          a2[-1] = *&v452[16];
          a2[-4] = v377;
          a2[-3] = v415;
          if (*(v16 + 56) < *(i + 56))
          {
            v301 = *i;
            v339 = *(i + 16);
            *&v452[13] = *(i + 77);
            v416 = *(i + 48);
            *v452 = *(i + 64);
            v378 = *(i + 32);
            v32 = *(v16 + 80);
            v34 = *(v16 + 32);
            v33 = *(v16 + 48);
            *(i + 64) = *(v16 + 64);
            *(i + 80) = v32;
            *(i + 32) = v34;
            *(i + 48) = v33;
            v35 = *(v16 + 16);
            *i = *v16;
            *(i + 16) = v35;
            *v16 = v301;
            *(v16 + 16) = v339;
            *(v16 + 64) = *v452;
            *(v16 + 80) = *&v452[16];
            *(v16 + 32) = v378;
            *(v16 + 48) = v416;
          }
        }
      }

      else
      {
        if (v17 < v18)
        {
          v298 = *i;
          v336 = *(i + 16);
          *&v452[13] = *(i + 77);
          v413 = *(i + 48);
          *v452 = *(i + 64);
          v375 = *(i + 32);
          v19 = a2[-1];
          v21 = a2[-4];
          v20 = a2[-3];
          *(i + 64) = a2[-2];
          *(i + 80) = v19;
          *(i + 32) = v21;
          *(i + 48) = v20;
          v22 = a2[-5];
          *i = *v9;
          *(i + 16) = v22;
          goto LABEL_27;
        }

        v304 = *i;
        v342 = *(i + 16);
        *&v452[13] = *(i + 77);
        v419 = *(i + 48);
        *v452 = *(i + 64);
        v381 = *(i + 32);
        v44 = *(v16 + 80);
        v46 = *(v16 + 32);
        v45 = *(v16 + 48);
        *(i + 64) = *(v16 + 64);
        *(i + 80) = v44;
        *(i + 32) = v46;
        *(i + 48) = v45;
        v47 = *(v16 + 16);
        *i = *v16;
        *(i + 16) = v47;
        *v16 = v304;
        *(v16 + 16) = v342;
        *(v16 + 64) = *v452;
        *(v16 + 80) = *&v452[16];
        *(v16 + 32) = v381;
        *(v16 + 48) = v419;
        if (a2[-3].n128_u64[1] < *(v16 + 56))
        {
          v298 = *v16;
          v336 = *(v16 + 16);
          *&v452[13] = *(v16 + 77);
          v413 = *(v16 + 48);
          *v452 = *(v16 + 64);
          v375 = *(v16 + 32);
          v48 = a2[-1];
          v50 = a2[-4];
          v49 = a2[-3];
          *(v16 + 64) = a2[-2];
          *(v16 + 80) = v48;
          *(v16 + 32) = v50;
          *(v16 + 48) = v49;
          v51 = a2[-5];
          *v16 = *v9;
          *(v16 + 16) = v51;
LABEL_27:
          *v9 = v298;
          a2[-5] = v336;
          a2[-2] = *v452;
          a2[-1] = *&v452[16];
          a2[-4] = v375;
          a2[-3] = v413;
        }
      }

      v52 = i + 96 * v15;
      v53 = v52 - 96;
      v54 = *(v52 - 40);
      v55 = a2[-9].n128_i64[1];
      if (v54 >= *(i + 152))
      {
        if (v55 < v54)
        {
          v306 = *v53;
          v344 = *(v53 + 16);
          *&v452[13] = *(v53 + 77);
          v421 = *(v53 + 48);
          *v452 = *(v53 + 64);
          v383 = *(v53 + 32);
          v60 = a2[-7];
          v62 = a2[-10];
          v61 = a2[-9];
          *(v53 + 64) = a2[-8];
          *(v53 + 80) = v60;
          *(v53 + 32) = v62;
          *(v53 + 48) = v61;
          v63 = a2[-11];
          *v53 = *v10;
          *(v53 + 16) = v63;
          *v10 = v306;
          a2[-11] = v344;
          a2[-8] = *v452;
          a2[-7] = *&v452[16];
          a2[-10] = v383;
          a2[-9] = v421;
          if (*(v53 + 56) < *(i + 152))
          {
            v384 = *(i + 128);
            v422 = *(i + 144);
            *v452 = *(i + 160);
            *&v452[13] = *(i + 173);
            v307 = *(i + 96);
            v345 = *(i + 112);
            v64 = *(v53 + 16);
            *(i + 96) = *v53;
            *(i + 112) = v64;
            v65 = *(v53 + 80);
            v67 = *(v53 + 32);
            v66 = *(v53 + 48);
            *(i + 160) = *(v53 + 64);
            *(i + 176) = v65;
            *(i + 128) = v67;
            *(i + 144) = v66;
            *v53 = v307;
            *(v53 + 16) = v345;
            *(v53 + 64) = *v452;
            *(v53 + 80) = *&v452[16];
            *(v53 + 32) = v384;
            *(v53 + 48) = v422;
          }
        }
      }

      else
      {
        if (v55 < v54)
        {
          v382 = *(i + 128);
          v420 = *(i + 144);
          *v452 = *(i + 160);
          *&v452[13] = *(i + 173);
          v305 = *(i + 96);
          v343 = *(i + 112);
          v56 = a2[-11];
          *(i + 96) = *v10;
          *(i + 112) = v56;
          v57 = a2[-7];
          v59 = a2[-10];
          v58 = a2[-9];
          *(i + 160) = a2[-8];
          *(i + 176) = v57;
          *(i + 128) = v59;
          *(i + 144) = v58;
          goto LABEL_41;
        }

        v386 = *(i + 128);
        v424 = *(i + 144);
        *v452 = *(i + 160);
        *&v452[13] = *(i + 173);
        v309 = *(i + 96);
        v347 = *(i + 112);
        v77 = *(v53 + 16);
        *(i + 96) = *v53;
        *(i + 112) = v77;
        v78 = *(v53 + 80);
        v80 = *(v53 + 32);
        v79 = *(v53 + 48);
        *(i + 160) = *(v53 + 64);
        *(i + 176) = v78;
        *(i + 128) = v80;
        *(i + 144) = v79;
        *v53 = v309;
        *(v53 + 16) = v347;
        *(v53 + 64) = *v452;
        *(v53 + 80) = *&v452[16];
        *(v53 + 32) = v386;
        *(v53 + 48) = v424;
        if (a2[-9].n128_u64[1] < *(v53 + 56))
        {
          v305 = *v53;
          v343 = *(v53 + 16);
          *&v452[13] = *(v53 + 77);
          v420 = *(v53 + 48);
          *v452 = *(v53 + 64);
          v382 = *(v53 + 32);
          v81 = a2[-7];
          v83 = a2[-10];
          v82 = a2[-9];
          *(v53 + 64) = a2[-8];
          *(v53 + 80) = v81;
          *(v53 + 32) = v83;
          *(v53 + 48) = v82;
          v84 = a2[-11];
          *v53 = *v10;
          *(v53 + 16) = v84;
LABEL_41:
          *v10 = v305;
          a2[-11] = v343;
          a2[-8] = *v452;
          a2[-7] = *&v452[16];
          a2[-10] = v382;
          a2[-9] = v420;
        }
      }

      v85 = (i + 192);
      v86 = i + 96 * v15;
      v87 = *(v86 + 152);
      v88 = a2[-15].n128_i64[1];
      if (v87 >= *(i + 248))
      {
        if (v88 < v87)
        {
          v311 = *(v86 + 96);
          v349 = *(v86 + 112);
          *&v452[13] = *(v86 + 173);
          v426 = *(v86 + 144);
          *v452 = *(v86 + 160);
          v388 = *(v86 + 128);
          v93 = a2[-13];
          v95 = a2[-16];
          v94 = a2[-15];
          *(v86 + 160) = a2[-14];
          *(v86 + 176) = v93;
          *(v86 + 128) = v95;
          *(v86 + 144) = v94;
          v96 = a2[-17];
          *(v86 + 96) = *v11;
          *(v86 + 112) = v96;
          *v11 = v311;
          a2[-17] = v349;
          a2[-14] = *v452;
          a2[-13] = *&v452[16];
          a2[-16] = v388;
          a2[-15] = v426;
          if (*(v86 + 152) < *(i + 248))
          {
            v389 = *(i + 224);
            v427 = *(i + 240);
            *v452 = *(i + 256);
            *&v452[13] = *(i + 269);
            v312 = *v85;
            v350 = *(i + 208);
            v97 = *(v86 + 112);
            *v85 = *(v86 + 96);
            *(i + 208) = v97;
            v98 = *(v86 + 176);
            v100 = *(v86 + 128);
            v99 = *(v86 + 144);
            *(i + 256) = *(v86 + 160);
            *(i + 272) = v98;
            *(i + 224) = v100;
            *(i + 240) = v99;
            *(v86 + 96) = v312;
            *(v86 + 112) = v350;
            *(v86 + 160) = *v452;
            *(v86 + 176) = *&v452[16];
            *(v86 + 128) = v389;
            *(v86 + 144) = v427;
          }
        }
      }

      else
      {
        if (v88 < v87)
        {
          v387 = *(i + 224);
          v425 = *(i + 240);
          *v452 = *(i + 256);
          *&v452[13] = *(i + 269);
          v310 = *v85;
          v348 = *(i + 208);
          v89 = a2[-17];
          *v85 = *v11;
          *(i + 208) = v89;
          v90 = a2[-13];
          v92 = a2[-16];
          v91 = a2[-15];
          *(i + 256) = a2[-14];
          *(i + 272) = v90;
          *(i + 224) = v92;
          *(i + 240) = v91;
          goto LABEL_50;
        }

        v390 = *(i + 224);
        v428 = *(i + 240);
        *v452 = *(i + 256);
        *&v452[13] = *(i + 269);
        v313 = *v85;
        v351 = *(i + 208);
        v101 = *(v86 + 112);
        *v85 = *(v86 + 96);
        *(i + 208) = v101;
        v102 = *(v86 + 176);
        v104 = *(v86 + 128);
        v103 = *(v86 + 144);
        *(i + 256) = *(v86 + 160);
        *(i + 272) = v102;
        *(i + 224) = v104;
        *(i + 240) = v103;
        *(v86 + 96) = v313;
        *(v86 + 112) = v351;
        *(v86 + 160) = *v452;
        *(v86 + 176) = *&v452[16];
        *(v86 + 128) = v390;
        *(v86 + 144) = v428;
        if (a2[-15].n128_u64[1] < *(v86 + 152))
        {
          v310 = *(v86 + 96);
          v348 = *(v86 + 112);
          *&v452[13] = *(v86 + 173);
          v425 = *(v86 + 144);
          *v452 = *(v86 + 160);
          v387 = *(v86 + 128);
          v105 = a2[-13];
          v107 = a2[-16];
          v106 = a2[-15];
          *(v86 + 160) = a2[-14];
          *(v86 + 176) = v105;
          *(v86 + 128) = v107;
          *(v86 + 144) = v106;
          v108 = a2[-17];
          *(v86 + 96) = *v11;
          *(v86 + 112) = v108;
LABEL_50:
          *v11 = v310;
          a2[-17] = v348;
          a2[-14] = *v452;
          a2[-13] = *&v452[16];
          a2[-16] = v387;
          a2[-15] = v425;
        }
      }

      v109 = *(v16 + 56);
      v110 = *(v86 + 152);
      if (v109 >= *(v53 + 56))
      {
        if (v110 < v109)
        {
          v315 = *v16;
          v353 = *(v16 + 16);
          *&v452[13] = *(v16 + 77);
          v430 = *(v16 + 48);
          *v452 = *(v16 + 64);
          v392 = *(v16 + 32);
          v114 = *(v86 + 176);
          *(v16 + 64) = *(v86 + 160);
          *(v16 + 80) = v114;
          v115 = *(v86 + 144);
          *(v16 + 32) = *(v86 + 128);
          *(v16 + 48) = v115;
          v116 = *(v86 + 112);
          *v16 = *(v86 + 96);
          *(v16 + 16) = v116;
          *(v86 + 96) = v315;
          *(v86 + 112) = v353;
          *(v86 + 160) = *v452;
          *(v86 + 176) = *&v452[16];
          *(v86 + 128) = v392;
          *(v86 + 144) = v430;
          if (*(v16 + 56) < *(v53 + 56))
          {
            v316 = *v53;
            v354 = *(v53 + 16);
            *&v452[13] = *(v53 + 77);
            v431 = *(v53 + 48);
            *v452 = *(v53 + 64);
            v393 = *(v53 + 32);
            v117 = *(v16 + 80);
            *(v53 + 64) = *(v16 + 64);
            *(v53 + 80) = v117;
            v118 = *(v16 + 48);
            *(v53 + 32) = *(v16 + 32);
            *(v53 + 48) = v118;
            v119 = *(v16 + 16);
            *v53 = *v16;
            *(v53 + 16) = v119;
            *v16 = v316;
            *(v16 + 16) = v354;
            *(v16 + 64) = *v452;
            *(v16 + 80) = *&v452[16];
            *(v16 + 32) = v393;
            *(v16 + 48) = v431;
          }
        }
      }

      else
      {
        if (v110 < v109)
        {
          v314 = *v53;
          v352 = *(v53 + 16);
          *&v452[13] = *(v53 + 77);
          v429 = *(v53 + 48);
          *v452 = *(v53 + 64);
          v391 = *(v53 + 32);
          v111 = *(v86 + 176);
          *(v53 + 64) = *(v86 + 160);
          *(v53 + 80) = v111;
          v112 = *(v86 + 144);
          *(v53 + 32) = *(v86 + 128);
          *(v53 + 48) = v112;
          v113 = *(v86 + 112);
          *v53 = *(v86 + 96);
          *(v53 + 16) = v113;
          goto LABEL_59;
        }

        v317 = *v53;
        v355 = *(v53 + 16);
        *&v452[13] = *(v53 + 77);
        v432 = *(v53 + 48);
        *v452 = *(v53 + 64);
        v394 = *(v53 + 32);
        v120 = *(v16 + 80);
        *(v53 + 64) = *(v16 + 64);
        *(v53 + 80) = v120;
        v121 = *(v16 + 48);
        *(v53 + 32) = *(v16 + 32);
        *(v53 + 48) = v121;
        v122 = *(v16 + 16);
        *v53 = *v16;
        *(v53 + 16) = v122;
        *v16 = v317;
        *(v16 + 16) = v355;
        *(v16 + 64) = *v452;
        *(v16 + 80) = *&v452[16];
        *(v16 + 32) = v394;
        *(v16 + 48) = v432;
        if (*(v86 + 152) < *(v16 + 56))
        {
          v314 = *v16;
          v352 = *(v16 + 16);
          *&v452[13] = *(v16 + 77);
          v429 = *(v16 + 48);
          *v452 = *(v16 + 64);
          v391 = *(v16 + 32);
          v123 = *(v86 + 176);
          *(v16 + 64) = *(v86 + 160);
          *(v16 + 80) = v123;
          v124 = *(v86 + 144);
          *(v16 + 32) = *(v86 + 128);
          *(v16 + 48) = v124;
          v125 = *(v86 + 112);
          *v16 = *(v86 + 96);
          *(v16 + 16) = v125;
LABEL_59:
          *(v86 + 96) = v314;
          *(v86 + 112) = v352;
          *(v86 + 160) = *v452;
          *(v86 + 176) = *&v452[16];
          *(v86 + 128) = v391;
          *(v86 + 144) = v429;
        }
      }

      v318 = *i;
      v356 = *(i + 16);
      *&v452[13] = *(i + 77);
      v433 = *(i + 48);
      *v452 = *(i + 64);
      v395 = *(i + 32);
      v126 = *(v16 + 80);
      v128 = *(v16 + 32);
      v127 = *(v16 + 48);
      *(i + 64) = *(v16 + 64);
      *(i + 80) = v126;
      *(i + 32) = v128;
      *(i + 48) = v127;
      v129 = *(v16 + 16);
      *i = *v16;
      *(i + 16) = v129;
      *v16 = v318;
      *(v16 + 16) = v356;
      *(v16 + 64) = *v452;
      *(v16 + 80) = *&v452[16];
      *(v16 + 32) = v395;
      *(v16 + 48) = v433;
      --a3;
      if ((a4 & 1) == 0)
      {
        goto LABEL_61;
      }

LABEL_38:
      v76 = *(i + 56);
LABEL_62:
      v130 = 0;
      v460 = *(i + 48);
      *&v454[16] = *(i + 16);
      v457 = *(i + 32);
      *v454 = *i;
      *v453 = *(i + 64);
      *&v453[13] = *(i + 77);
      do
      {
        if ((i + v130 + 96) == a2)
        {
          goto LABEL_191;
        }

        v131 = *(i + v130 + 152);
        v130 += 96;
      }

      while (v131 < v76);
      v132 = (i + v130);
      v133 = a2;
      if (v130 != 96)
      {
        while (v133 != i)
        {
          v134 = &v133[-6];
          v135 = v133[-3].n128_i64[1];
          v133 -= 6;
          if (v135 < v76)
          {
            goto LABEL_72;
          }
        }

LABEL_191:
        __break(1u);
LABEL_192:
        v330 = *a1;
        v369 = *(a1 + 16);
        *&v452[13] = *(a1 + 77);
        v446 = *(a1 + 48);
        *v452 = *(a1 + 64);
        v407 = *(a1 + 32);
        v275 = *(a1 + 176);
        *(a1 + 64) = *(a1 + 160);
        *(a1 + 80) = v275;
        v276 = *(a1 + 144);
        *(a1 + 32) = *(a1 + 128);
        *(a1 + 48) = v276;
        v277 = *(a1 + 112);
        *a1 = *(a1 + 96);
        *(a1 + 16) = v277;
        *(a1 + 96) = v330;
        *(a1 + 112) = v369;
        result = v407;
        *(a1 + 160) = *v452;
        *(a1 + 176) = *&v452[16];
        *(a1 + 128) = v407;
        *(a1 + 144) = v446;
        if (a2[-3].n128_u64[1] >= *(a1 + 152))
        {
          return result;
        }

        v398 = *(a1 + 128);
        v436 = *(a1 + 144);
        *v452 = *(a1 + 160);
        *&v452[13] = *(a1 + 173);
        v321 = *(a1 + 96);
        v359 = *(a1 + 112);
        v278 = a2[-5];
        *(a1 + 96) = *v9;
        *(a1 + 112) = v278;
        v279 = a2[-1];
        v281 = a2[-4];
        v280 = a2[-3];
        *(a1 + 160) = a2[-2];
        *(a1 + 176) = v279;
        *(a1 + 128) = v281;
        *(a1 + 144) = v280;
        goto LABEL_194;
      }

      v136 = a2;
      do
      {
        if (v132 >= v136)
        {
          v134 = v136;
          goto LABEL_84;
        }

        v134 = &v136[-6];
        v137 = v136[-3].n128_i64[1];
        v136 -= 6;
      }

      while (v137 >= v76);
LABEL_72:
      if (v132 < v134)
      {
        v138 = v132;
        v139 = v134;
LABEL_74:
        v319 = *v138;
        v357 = v138[1];
        *&v452[13] = *(v138 + 77);
        v434 = v138[3];
        *v452 = v138[4];
        v396 = v138[2];
        v140 = v139[5];
        v142 = v139[2];
        v141 = v139[3];
        v138[4] = v139[4];
        v138[5] = v140;
        v138[2] = v142;
        v138[3] = v141;
        v143 = v139[1];
        *v138 = *v139;
        v138[1] = v143;
        *v139 = v319;
        v139[1] = v357;
        v139[4] = *v452;
        v139[5] = *&v452[16];
        v139[2] = v396;
        v139[3] = v434;
        v144 = (v138 + 6);
        while (v144 != a2)
        {
          v145 = v144[3].n128_i64[1];
          v144 += 6;
          if (v145 >= v76)
          {
            v138 = &v144[-6];
            v146 = v139;
            while (v146 != i)
            {
              v139 = v146 - 6;
              v147 = *(v146 - 5);
              v146 -= 6;
              if (v147 < v76)
              {
                if (v138 < v139)
                {
                  goto LABEL_74;
                }

                v148 = &v144[-12];
                if (&v144[-12] != i)
                {
                  goto LABEL_85;
                }

                goto LABEL_86;
              }
            }

            goto LABEL_191;
          }
        }

        goto LABEL_191;
      }

LABEL_84:
      v148 = &v132[-6];
      if (&v132[-6] != i)
      {
LABEL_85:
        v149 = *(v148 + 16);
        *i = *v148;
        *(i + 16) = v149;
        v150 = *(v148 + 32);
        v151 = *(v148 + 48);
        v152 = *(v148 + 80);
        *(i + 64) = *(v148 + 64);
        *(i + 80) = v152;
        *(i + 32) = v150;
        *(i + 48) = v151;
      }

LABEL_86:
      *v148 = *v454;
      *(v148 + 16) = *&v454[16];
      *(v148 + 32) = v457;
      *(v148 + 48) = v460;
      *(v148 + 56) = v76;
      *(v148 + 64) = *v453;
      *(v148 + 80) = *&v453[16];
      if (v132 < v134)
      {
LABEL_89:
        std::__introsort<std::_ClassicAlgPolicy,webrtc::TransportFeedbackAdapter::ProcessCongestionControlFeedback(webrtc::rtcp::CongestionControlFeedback const&,webrtc::Timestamp)::$_0 &,webrtc::PacketResult *,false>(a1, v148, a3, a4 & 1);
        a4 = 0;
        i = v148 + 96;
        goto LABEL_2;
      }

      v153 = std::__insertion_sort_incomplete[abi:sn200100]<std::_ClassicAlgPolicy,webrtc::TransportFeedbackAdapter::ProcessCongestionControlFeedback(webrtc::rtcp::CongestionControlFeedback const&,webrtc::Timestamp)::$_0 &,webrtc::PacketResult *>(i, v148);
      i = v148 + 96;
      if (!std::__insertion_sort_incomplete[abi:sn200100]<std::_ClassicAlgPolicy,webrtc::TransportFeedbackAdapter::ProcessCongestionControlFeedback(webrtc::rtcp::CongestionControlFeedback const&,webrtc::Timestamp)::$_0 &,webrtc::PacketResult *>(v148 + 96, a2))
      {
        if (v153)
        {
          goto LABEL_2;
        }

        goto LABEL_89;
      }

      a2 = v148;
      if (v153)
      {
        return result;
      }

      goto LABEL_1;
    }

    v23 = *(i + 56);
    if (v23 >= *(v16 + 56))
    {
      if (v17 < v23)
      {
        v302 = *i;
        v340 = *(i + 16);
        *&v452[13] = *(i + 77);
        v417 = *(i + 48);
        *v452 = *(i + 64);
        v379 = *(i + 32);
        v36 = a2[-1];
        v38 = a2[-4];
        v37 = a2[-3];
        *(i + 64) = a2[-2];
        *(i + 80) = v36;
        *(i + 32) = v38;
        *(i + 48) = v37;
        v39 = a2[-5];
        *i = *v9;
        *(i + 16) = v39;
        *v9 = v302;
        a2[-5] = v340;
        a2[-2] = *v452;
        a2[-1] = *&v452[16];
        a2[-4] = v379;
        a2[-3] = v417;
        if (*(i + 56) < *(v16 + 56))
        {
          v303 = *v16;
          v341 = *(v16 + 16);
          *&v452[13] = *(v16 + 77);
          v418 = *(v16 + 48);
          *v452 = *(v16 + 64);
          v380 = *(v16 + 32);
          v40 = *(i + 80);
          v42 = *(i + 32);
          v41 = *(i + 48);
          *(v16 + 64) = *(i + 64);
          *(v16 + 80) = v40;
          *(v16 + 32) = v42;
          *(v16 + 48) = v41;
          v43 = *(i + 16);
          *v16 = *i;
          *(v16 + 16) = v43;
          *i = v303;
          *(i + 16) = v341;
          *(i + 64) = *v452;
          *(i + 80) = *&v452[16];
          *(i + 32) = v380;
          *(i + 48) = v418;
          --a3;
          if (a4)
          {
            goto LABEL_38;
          }

          goto LABEL_61;
        }
      }
    }

    else
    {
      if (v17 >= v23)
      {
        v308 = *v16;
        v346 = *(v16 + 16);
        *&v452[13] = *(v16 + 77);
        v423 = *(v16 + 48);
        *v452 = *(v16 + 64);
        v385 = *(v16 + 32);
        v68 = *(i + 80);
        v70 = *(i + 32);
        v69 = *(i + 48);
        *(v16 + 64) = *(i + 64);
        *(v16 + 80) = v68;
        *(v16 + 32) = v70;
        *(v16 + 48) = v69;
        v71 = *(i + 16);
        *v16 = *i;
        *(v16 + 16) = v71;
        *i = v308;
        *(i + 16) = v346;
        *(i + 64) = *v452;
        *(i + 80) = *&v452[16];
        *(i + 32) = v385;
        *(i + 48) = v423;
        if (a2[-3].n128_u64[1] >= *(i + 56))
        {
          goto LABEL_37;
        }

        v299 = *i;
        v337 = *(i + 16);
        *&v452[13] = *(i + 77);
        v414 = *(i + 48);
        *v452 = *(i + 64);
        v376 = *(i + 32);
        v72 = a2[-1];
        v74 = a2[-4];
        v73 = a2[-3];
        *(i + 64) = a2[-2];
        *(i + 80) = v72;
        *(i + 32) = v74;
        *(i + 48) = v73;
        v75 = a2[-5];
        *i = *v9;
        *(i + 16) = v75;
      }

      else
      {
        v299 = *v16;
        v337 = *(v16 + 16);
        *&v452[13] = *(v16 + 77);
        v414 = *(v16 + 48);
        *v452 = *(v16 + 64);
        v376 = *(v16 + 32);
        v24 = a2[-1];
        v26 = a2[-4];
        v25 = a2[-3];
        *(v16 + 64) = a2[-2];
        *(v16 + 80) = v24;
        *(v16 + 32) = v26;
        *(v16 + 48) = v25;
        v27 = a2[-5];
        *v16 = *v9;
        *(v16 + 16) = v27;
      }

      *v9 = v299;
      a2[-5] = v337;
      a2[-2] = *v452;
      a2[-1] = *&v452[16];
      a2[-4] = v376;
      a2[-3] = v414;
    }

LABEL_37:
    --a3;
    if (a4)
    {
      goto LABEL_38;
    }

LABEL_61:
    v76 = *(i + 56);
    if (*(i - 40) < v76)
    {
      goto LABEL_62;
    }

    v461 = *(i + 48);
    *&v454[16] = *(i + 16);
    v458 = *(i + 32);
    *v454 = *i;
    v154 = *(i + 56);
    *v453 = *(i + 64);
    *&v453[13] = *(i + 77);
    if (v154 >= a2[-3].n128_u64[1])
    {
      v157 = i + 96;
      do
      {
        i = v157;
        if (v157 >= a2)
        {
          break;
        }

        v158 = *(v157 + 56);
        v157 += 96;
      }

      while (v154 >= v158);
    }

    else
    {
      v155 = i + 96;
      do
      {
        if (v155 == a2)
        {
          goto LABEL_191;
        }

        v156 = *(v155 + 56);
        v155 += 96;
      }

      while (v154 >= v156);
      i = v155 - 96;
    }

    v159 = a2;
    if (i < a2)
    {
      v160 = a2;
      do
      {
        if (v160 == a1)
        {
          goto LABEL_191;
        }

        v159 = v160 - 6;
        v161 = v160[-3].n128_i64[1];
        v160 -= 6;
      }

      while (v154 < v161);
    }

    while (i < v159)
    {
      v320 = *i;
      v358 = *(i + 16);
      *&v452[13] = *(i + 77);
      v435 = *(i + 48);
      *v452 = *(i + 64);
      v397 = *(i + 32);
      v162 = v159[5];
      v164 = v159[2];
      v163 = v159[3];
      *(i + 64) = v159[4];
      *(i + 80) = v162;
      *(i + 32) = v164;
      *(i + 48) = v163;
      v165 = v159[1];
      *i = *v159;
      *(i + 16) = v165;
      *v159 = v320;
      v159[1] = v358;
      v159[4] = *v452;
      v159[5] = *&v452[16];
      v159[2] = v397;
      v159[3] = v435;
      v166 = i + 96;
      do
      {
        if (v166 == a2)
        {
          goto LABEL_191;
        }

        v167 = *(v166 + 56);
        v166 += 96;
      }

      while (v154 >= v167);
      i = v166 - 96;
      v168 = v159;
      do
      {
        if (v168 == a1)
        {
          goto LABEL_191;
        }

        v159 = v168 - 6;
        v169 = v168[-3].n128_i64[1];
        v168 -= 6;
      }

      while (v154 < v169);
    }

    v170 = (i - 96);
    if (i - 96 != a1)
    {
      v171 = *(i - 80);
      *a1 = *v170;
      *(a1 + 16) = v171;
      v172 = *(i - 64);
      v173 = *(i - 48);
      v174 = *(i - 16);
      *(a1 + 64) = *(i - 32);
      *(a1 + 80) = v174;
      *(a1 + 32) = v172;
      *(a1 + 48) = v173;
    }

    a4 = 0;
    *v170 = *v454;
    *(i - 80) = *&v454[16];
    *(i - 64) = v458;
    *(i - 48) = v461;
    *(i - 40) = v154;
    result = *v453;
    *(i - 32) = *v453;
  }

  if (a4)
  {
    if (i != a2)
    {
      v191 = i + 96;
      if ((i + 96) != a2)
      {
        v192 = 0;
        v193 = i;
        do
        {
          v195 = *(v193 + 152);
          v196 = *(v193 + 56);
          v193 = v191;
          if (v195 < v196)
          {
            v197 = *v191;
            v198 = *(v191 + 16);
            v199 = *(v191 + 32);
            v200 = *(v191 + 56);
            v439 = *(v193 + 48);
            v362 = v198;
            *v454 = *(v193 + 64);
            v201 = v192;
            *&v454[13] = *(v193 + 77);
            do
            {
              v202 = (i + v201);
              v203 = *(i + v201 + 48);
              v202[8] = *(i + v201 + 32);
              v202[9] = v203;
              v204 = *(i + v201 + 80);
              v202[10] = *(i + v201 + 64);
              v202[11] = v204;
              v205 = *(i + v201 + 16);
              v202[6] = *(i + v201);
              v202[7] = v205;
              if (!v201)
              {
                v194 = i;
                goto LABEL_131;
              }

              v201 -= 96;
            }

            while (v200 < *(v202 - 5));
            v194 = i + v201 + 96;
LABEL_131:
            *v194 = v197;
            *(v194 + 16) = v362;
            *(v194 + 32) = v199;
            *(v194 + 48) = v439;
            *(v194 + 56) = v200;
            result = *v454;
            *(v194 + 64) = *v454;
            *(v194 + 80) = *&v454[16];
          }

          v191 = v193 + 96;
          v192 += 96;
        }

        while ((v193 + 96) != a2);
      }
    }
  }

  else if (i != a2)
  {
    v263 = i + 96;
    if ((i + 96) != a2)
    {
      v264 = 0;
      v265 = -96;
      v266 = 96;
      do
      {
        v267 = i + v264;
        v264 = v266;
        if (*(v267 + 152) < *(v267 + 56))
        {
          v268 = *(v263 + 56);
          v445 = *(v263 + 48);
          v368 = *(v263 + 16);
          v406 = *(v263 + 32);
          v329 = *v263;
          *v454 = *(v263 + 64);
          v269 = v265;
          v270 = v263;
          *&v454[13] = *(v263 + 77);
          do
          {
            v271 = *(v270 - 48);
            *(v270 + 32) = *(v270 - 64);
            *(v270 + 48) = v271;
            v272 = *(v270 - 16);
            *(v270 + 64) = *(v270 - 32);
            *(v270 + 80) = v272;
            v273 = *(v270 - 80);
            *v270 = *(v270 - 96);
            *(v270 + 16) = v273;
            if (!v269)
            {
              goto LABEL_191;
            }

            v274 = *(v270 - 136);
            v270 -= 96;
            v269 += 96;
          }

          while (v268 < v274);
          *v270 = v329;
          *(v270 + 16) = v368;
          *(v270 + 32) = v406;
          *(v270 + 48) = v445;
          *(v270 + 56) = v268;
          result = *v454;
          *(v270 + 64) = *v454;
          *(v270 + 80) = *&v454[16];
        }

        v266 = v264 + 96;
        v263 += 96;
        v265 -= 96;
      }

      while (v263 != a2);
    }
  }

  return result;
}

__n128 std::__sort5[abi:sn200100]<std::_ClassicAlgPolicy,webrtc::TransportFeedbackAdapter::ProcessCongestionControlFeedback(webrtc::rtcp::CongestionControlFeedback const&,webrtc::Timestamp)::$_0 &,webrtc::PacketResult *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5 = *(a2 + 56);
  v6 = *(a3 + 56);
  if (v5 >= *(a1 + 56))
  {
    if (v6 < v5)
    {
      v79 = *(a2 + 32);
      v90 = *(a2 + 48);
      *v100 = *(a2 + 64);
      *&v100[13] = *(a2 + 77);
      v57 = *a2;
      v68 = *(a2 + 16);
      v11 = *(a3 + 16);
      *a2 = *a3;
      *(a2 + 16) = v11;
      v12 = *(a3 + 80);
      v14 = *(a3 + 32);
      v13 = *(a3 + 48);
      *(a2 + 64) = *(a3 + 64);
      *(a2 + 80) = v12;
      *(a2 + 32) = v14;
      *(a2 + 48) = v13;
      *(a3 + 64) = *v100;
      *(a3 + 80) = *&v100[16];
      *(a3 + 32) = v79;
      *(a3 + 48) = v90;
      result = v57;
      *a3 = v57;
      *(a3 + 16) = v68;
      if (*(a2 + 56) < *(a1 + 56))
      {
        v80 = *(a1 + 32);
        v91 = *(a1 + 48);
        *v100 = *(a1 + 64);
        *&v100[13] = *(a1 + 77);
        v58 = *a1;
        v69 = *(a1 + 16);
        v16 = *(a2 + 16);
        *a1 = *a2;
        *(a1 + 16) = v16;
        v17 = *(a2 + 80);
        v19 = *(a2 + 32);
        v18 = *(a2 + 48);
        *(a1 + 64) = *(a2 + 64);
        *(a1 + 80) = v17;
        *(a1 + 32) = v19;
        *(a1 + 48) = v18;
        *(a2 + 64) = *v100;
        *(a2 + 80) = *&v100[16];
        *(a2 + 32) = v80;
        *(a2 + 48) = v91;
        result = v58;
        *a2 = v58;
        *(a2 + 16) = v69;
      }
    }
  }

  else
  {
    if (v6 < v5)
    {
      v78 = *(a1 + 32);
      v89 = *(a1 + 48);
      *v100 = *(a1 + 64);
      *&v100[13] = *(a1 + 77);
      v56 = *a1;
      v67 = *(a1 + 16);
      v7 = *(a3 + 16);
      *a1 = *a3;
      *(a1 + 16) = v7;
      v8 = *(a3 + 80);
      v10 = *(a3 + 32);
      v9 = *(a3 + 48);
      *(a1 + 64) = *(a3 + 64);
      *(a1 + 80) = v8;
      *(a1 + 32) = v10;
      *(a1 + 48) = v9;
LABEL_9:
      *(a3 + 64) = *v100;
      *(a3 + 80) = *&v100[16];
      *(a3 + 32) = v78;
      *(a3 + 48) = v89;
      result = v56;
      *a3 = v56;
      *(a3 + 16) = v67;
      goto LABEL_10;
    }

    v81 = *(a1 + 32);
    v92 = *(a1 + 48);
    *v100 = *(a1 + 64);
    *&v100[13] = *(a1 + 77);
    v59 = *a1;
    v70 = *(a1 + 16);
    v20 = *(a2 + 16);
    *a1 = *a2;
    *(a1 + 16) = v20;
    v21 = *(a2 + 80);
    v23 = *(a2 + 32);
    v22 = *(a2 + 48);
    *(a1 + 64) = *(a2 + 64);
    *(a1 + 80) = v21;
    *(a1 + 32) = v23;
    *(a1 + 48) = v22;
    *(a2 + 64) = *v100;
    *(a2 + 80) = *&v100[16];
    *(a2 + 32) = v81;
    *(a2 + 48) = v92;
    result = v59;
    *a2 = v59;
    *(a2 + 16) = v70;
    if (*(a3 + 56) < *(a2 + 56))
    {
      v78 = *(a2 + 32);
      v89 = *(a2 + 48);
      *v100 = *(a2 + 64);
      *&v100[13] = *(a2 + 77);
      v56 = *a2;
      v67 = *(a2 + 16);
      v24 = *(a3 + 16);
      *a2 = *a3;
      *(a2 + 16) = v24;
      v25 = *(a3 + 80);
      v27 = *(a3 + 32);
      v26 = *(a3 + 48);
      *(a2 + 64) = *(a3 + 64);
      *(a2 + 80) = v25;
      *(a2 + 32) = v27;
      *(a2 + 48) = v26;
      goto LABEL_9;
    }
  }

LABEL_10:
  if (*(a4 + 56) < *(a3 + 56))
  {
    v82 = *(a3 + 32);
    v93 = *(a3 + 48);
    *v100 = *(a3 + 64);
    *&v100[13] = *(a3 + 77);
    v60 = *a3;
    v71 = *(a3 + 16);
    v28 = *(a4 + 16);
    *a3 = *a4;
    *(a3 + 16) = v28;
    v29 = *(a4 + 80);
    v31 = *(a4 + 32);
    v30 = *(a4 + 48);
    *(a3 + 64) = *(a4 + 64);
    *(a3 + 80) = v29;
    *(a3 + 32) = v31;
    *(a3 + 48) = v30;
    *(a4 + 64) = *v100;
    *(a4 + 80) = *&v100[16];
    *(a4 + 32) = v82;
    *(a4 + 48) = v93;
    result = v60;
    *a4 = v60;
    *(a4 + 16) = v71;
    if (*(a3 + 56) < *(a2 + 56))
    {
      v83 = *(a2 + 32);
      v94 = *(a2 + 48);
      *v100 = *(a2 + 64);
      *&v100[13] = *(a2 + 77);
      v61 = *a2;
      v72 = *(a2 + 16);
      v32 = *(a3 + 16);
      *a2 = *a3;
      *(a2 + 16) = v32;
      v33 = *(a3 + 80);
      v35 = *(a3 + 32);
      v34 = *(a3 + 48);
      *(a2 + 64) = *(a3 + 64);
      *(a2 + 80) = v33;
      *(a2 + 32) = v35;
      *(a2 + 48) = v34;
      *(a3 + 64) = *v100;
      *(a3 + 80) = *&v100[16];
      *(a3 + 32) = v83;
      *(a3 + 48) = v94;
      result = v61;
      *a3 = v61;
      *(a3 + 16) = v72;
      if (*(a2 + 56) < *(a1 + 56))
      {
        v84 = *(a1 + 32);
        v95 = *(a1 + 48);
        *v100 = *(a1 + 64);
        *&v100[13] = *(a1 + 77);
        v62 = *a1;
        v73 = *(a1 + 16);
        v36 = *(a2 + 16);
        *a1 = *a2;
        *(a1 + 16) = v36;
        v37 = *(a2 + 80);
        v39 = *(a2 + 32);
        v38 = *(a2 + 48);
        *(a1 + 64) = *(a2 + 64);
        *(a1 + 80) = v37;
        *(a1 + 32) = v39;
        *(a1 + 48) = v38;
        *(a2 + 64) = *v100;
        *(a2 + 80) = *&v100[16];
        *(a2 + 32) = v84;
        *(a2 + 48) = v95;
        result = v62;
        *a2 = v62;
        *(a2 + 16) = v73;
      }
    }
  }

  if (*(a5 + 56) < *(a4 + 56))
  {
    v85 = *(a4 + 32);
    v96 = *(a4 + 48);
    *v100 = *(a4 + 64);
    *&v100[13] = *(a4 + 77);
    v63 = *a4;
    v74 = *(a4 + 16);
    v40 = *(a5 + 16);
    *a4 = *a5;
    *(a4 + 16) = v40;
    v41 = *(a5 + 80);
    v43 = *(a5 + 32);
    v42 = *(a5 + 48);
    *(a4 + 64) = *(a5 + 64);
    *(a4 + 80) = v41;
    *(a4 + 32) = v43;
    *(a4 + 48) = v42;
    *(a5 + 64) = *v100;
    *(a5 + 80) = *&v100[16];
    *(a5 + 32) = v85;
    *(a5 + 48) = v96;
    result = v63;
    *a5 = v63;
    *(a5 + 16) = v74;
    if (*(a4 + 56) < *(a3 + 56))
    {
      v86 = *(a3 + 32);
      v97 = *(a3 + 48);
      *v100 = *(a3 + 64);
      *&v100[13] = *(a3 + 77);
      v64 = *a3;
      v75 = *(a3 + 16);
      v44 = *(a4 + 16);
      *a3 = *a4;
      *(a3 + 16) = v44;
      v45 = *(a4 + 80);
      v47 = *(a4 + 32);
      v46 = *(a4 + 48);
      *(a3 + 64) = *(a4 + 64);
      *(a3 + 80) = v45;
      *(a3 + 32) = v47;
      *(a3 + 48) = v46;
      *(a4 + 64) = *v100;
      *(a4 + 80) = *&v100[16];
      *(a4 + 32) = v86;
      *(a4 + 48) = v97;
      result = v64;
      *a4 = v64;
      *(a4 + 16) = v75;
      if (*(a3 + 56) < *(a2 + 56))
      {
        v87 = *(a2 + 32);
        v98 = *(a2 + 48);
        *v100 = *(a2 + 64);
        *&v100[13] = *(a2 + 77);
        v65 = *a2;
        v76 = *(a2 + 16);
        v48 = *(a3 + 16);
        *a2 = *a3;
        *(a2 + 16) = v48;
        v49 = *(a3 + 80);
        v51 = *(a3 + 32);
        v50 = *(a3 + 48);
        *(a2 + 64) = *(a3 + 64);
        *(a2 + 80) = v49;
        *(a2 + 32) = v51;
        *(a2 + 48) = v50;
        *(a3 + 64) = *v100;
        *(a3 + 80) = *&v100[16];
        *(a3 + 32) = v87;
        *(a3 + 48) = v98;
        result = v65;
        *a3 = v65;
        *(a3 + 16) = v76;
        if (*(a2 + 56) < *(a1 + 56))
        {
          v88 = *(a1 + 32);
          v99 = *(a1 + 48);
          *v100 = *(a1 + 64);
          *&v100[13] = *(a1 + 77);
          v66 = *a1;
          v77 = *(a1 + 16);
          v52 = *(a2 + 16);
          *a1 = *a2;
          *(a1 + 16) = v52;
          v53 = *(a2 + 80);
          v55 = *(a2 + 32);
          v54 = *(a2 + 48);
          *(a1 + 64) = *(a2 + 64);
          *(a1 + 80) = v53;
          *(a1 + 32) = v55;
          *(a1 + 48) = v54;
          *(a2 + 64) = *v100;
          *(a2 + 80) = *&v100[16];
          *(a2 + 32) = v88;
          *(a2 + 48) = v99;
          result = v66;
          *a2 = v66;
          *(a2 + 16) = v77;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:sn200100]<std::_ClassicAlgPolicy,webrtc::TransportFeedbackAdapter::ProcessCongestionControlFeedback(webrtc::rtcp::CongestionControlFeedback const&,webrtc::Timestamp)::$_0 &,webrtc::PacketResult *>(uint64_t a1, uint64_t a2)
{
  v2 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 5);
  if (v2 > 2)
  {
    if (v2 == 3)
    {
      v8 = (a2 - 96);
      v9 = *(a1 + 152);
      v10 = *(a2 - 40);
      if (v9 < *(a1 + 56))
      {
        if (v10 >= v9)
        {
          v125 = *(a1 + 32);
          v141 = *(a1 + 48);
          *v148 = *(a1 + 64);
          *&v148[13] = *(a1 + 77);
          v93 = *a1;
          v109 = *(a1 + 16);
          v45 = *(a1 + 144);
          *(a1 + 32) = *(a1 + 128);
          *(a1 + 48) = v45;
          v46 = *(a1 + 176);
          *(a1 + 64) = *(a1 + 160);
          *(a1 + 80) = v46;
          v47 = *(a1 + 112);
          *a1 = *(a1 + 96);
          *(a1 + 16) = v47;
          *(a1 + 96) = v93;
          *(a1 + 112) = v109;
          *(a1 + 160) = *v148;
          *(a1 + 176) = *&v148[16];
          *(a1 + 128) = v125;
          *(a1 + 144) = v141;
          if (*(a2 - 40) >= *(a1 + 152))
          {
            return 1;
          }

          v117 = *(a1 + 128);
          v133 = *(a1 + 144);
          *v148 = *(a1 + 160);
          *&v148[13] = *(a1 + 173);
          v85 = *(a1 + 96);
          v101 = *(a1 + 112);
          v48 = *(a2 - 80);
          *(a1 + 96) = *v8;
          *(a1 + 112) = v48;
          v49 = *(a2 - 16);
          v51 = *(a2 - 64);
          v50 = *(a2 - 48);
          *(a1 + 160) = *(a2 - 32);
          *(a1 + 176) = v49;
          *(a1 + 128) = v51;
          *(a1 + 144) = v50;
        }

        else
        {
          v117 = *(a1 + 32);
          v133 = *(a1 + 48);
          *v148 = *(a1 + 64);
          *&v148[13] = *(a1 + 77);
          v85 = *a1;
          v101 = *(a1 + 16);
          v11 = *(a2 - 80);
          *a1 = *v8;
          *(a1 + 16) = v11;
          v12 = *(a2 - 16);
          v14 = *(a2 - 64);
          v13 = *(a2 - 48);
          *(a1 + 64) = *(a2 - 32);
          *(a1 + 80) = v12;
          *(a1 + 32) = v14;
          *(a1 + 48) = v13;
        }

        *(a2 - 32) = *v148;
        *(a2 - 16) = *&v148[16];
        *(a2 - 64) = v117;
        *(a2 - 48) = v133;
        result = 1;
        *v8 = v85;
        *(a2 - 80) = v101;
        return result;
      }

      if (v10 >= v9)
      {
        return 1;
      }

      v120 = *(a1 + 128);
      v136 = *(a1 + 144);
      *v148 = *(a1 + 160);
      *&v148[13] = *(a1 + 173);
      v88 = *(a1 + 96);
      v104 = *(a1 + 112);
      v29 = *(a2 - 80);
      *(a1 + 96) = *v8;
      *(a1 + 112) = v29;
      v30 = *(a2 - 16);
      v32 = *(a2 - 64);
      v31 = *(a2 - 48);
      *(a1 + 160) = *(a2 - 32);
      *(a1 + 176) = v30;
      *(a1 + 128) = v32;
      *(a1 + 144) = v31;
      *(a2 - 32) = *v148;
      *(a2 - 16) = *&v148[16];
      *(a2 - 64) = v120;
      *(a2 - 48) = v136;
      *v8 = v88;
      *(a2 - 80) = v104;
LABEL_49:
      if (*(a1 + 152) < *(a1 + 56))
      {
        v131 = *(a1 + 32);
        v147 = *(a1 + 48);
        *v148 = *(a1 + 64);
        *&v148[13] = *(a1 + 77);
        v99 = *a1;
        v115 = *(a1 + 16);
        v81 = *(a1 + 144);
        *(a1 + 32) = *(a1 + 128);
        *(a1 + 48) = v81;
        v82 = *(a1 + 176);
        *(a1 + 64) = *(a1 + 160);
        *(a1 + 80) = v82;
        v83 = *(a1 + 112);
        *a1 = *(a1 + 96);
        *(a1 + 16) = v83;
        *(a1 + 96) = v99;
        *(a1 + 112) = v115;
        *(a1 + 160) = *v148;
        *(a1 + 176) = *&v148[16];
        *(a1 + 128) = v131;
        *(a1 + 144) = v147;
      }

      return 1;
    }

    if (v2 != 4)
    {
      if (v2 != 5)
      {
        goto LABEL_13;
      }

      std::__sort5[abi:sn200100]<std::_ClassicAlgPolicy,webrtc::TransportFeedbackAdapter::ProcessCongestionControlFeedback(webrtc::rtcp::CongestionControlFeedback const&,webrtc::Timestamp)::$_0 &,webrtc::PacketResult *,0>(a1, a1 + 96, a1 + 192, a1 + 288, a2 - 96);
      return 1;
    }

    v22 = (a1 + 192);
    v23 = *(a1 + 152);
    v24 = *(a1 + 56);
    v25 = *(a1 + 248);
    if (v23 >= v24)
    {
      if (v25 < v23)
      {
        v123 = *(a1 + 128);
        v139 = *(a1 + 144);
        *v148 = *(a1 + 160);
        *&v148[13] = *(a1 + 173);
        v91 = *(a1 + 96);
        v107 = *(a1 + 112);
        v39 = *(a1 + 240);
        *(a1 + 128) = *(a1 + 224);
        *(a1 + 144) = v39;
        v40 = *(a1 + 272);
        *(a1 + 160) = *(a1 + 256);
        *(a1 + 176) = v40;
        v41 = *(a1 + 208);
        *(a1 + 96) = *v22;
        *(a1 + 112) = v41;
        *v22 = v91;
        *(a1 + 208) = v107;
        *(a1 + 256) = *v148;
        *(a1 + 272) = *&v148[16];
        *(a1 + 224) = v123;
        *(a1 + 240) = v139;
        if (*(a1 + 152) < v24)
        {
          v124 = *(a1 + 32);
          v140 = *(a1 + 48);
          *v148 = *(a1 + 64);
          *&v148[13] = *(a1 + 77);
          v92 = *a1;
          v108 = *(a1 + 16);
          v42 = *(a1 + 144);
          *(a1 + 32) = *(a1 + 128);
          *(a1 + 48) = v42;
          v43 = *(a1 + 176);
          *(a1 + 64) = *(a1 + 160);
          *(a1 + 80) = v43;
          v44 = *(a1 + 112);
          *a1 = *(a1 + 96);
          *(a1 + 16) = v44;
          *(a1 + 96) = v92;
          *(a1 + 112) = v108;
          *(a1 + 160) = *v148;
          *(a1 + 176) = *&v148[16];
          *(a1 + 128) = v124;
          *(a1 + 144) = v140;
        }
      }

      goto LABEL_46;
    }

    if (v25 >= v23)
    {
      v128 = *(a1 + 32);
      v144 = *(a1 + 48);
      *v148 = *(a1 + 64);
      *&v148[13] = *(a1 + 77);
      v96 = *a1;
      v112 = *(a1 + 16);
      v68 = *(a1 + 144);
      *(a1 + 32) = *(a1 + 128);
      *(a1 + 48) = v68;
      v69 = *(a1 + 176);
      *(a1 + 64) = *(a1 + 160);
      *(a1 + 80) = v69;
      v70 = *(a1 + 112);
      *a1 = *(a1 + 96);
      *(a1 + 16) = v70;
      *(a1 + 96) = v96;
      *(a1 + 112) = v112;
      *(a1 + 160) = *v148;
      *(a1 + 176) = *&v148[16];
      *(a1 + 128) = v128;
      *(a1 + 144) = v144;
      if (v25 >= *(a1 + 152))
      {
        goto LABEL_46;
      }

      v119 = *(a1 + 128);
      v135 = *(a1 + 144);
      *v148 = *(a1 + 160);
      *&v148[13] = *(a1 + 173);
      v87 = *(a1 + 96);
      v103 = *(a1 + 112);
      v71 = *(a1 + 240);
      *(a1 + 128) = *(a1 + 224);
      *(a1 + 144) = v71;
      v72 = *(a1 + 272);
      *(a1 + 160) = *(a1 + 256);
      *(a1 + 176) = v72;
      v73 = *(a1 + 208);
      *(a1 + 96) = *v22;
      *(a1 + 112) = v73;
    }

    else
    {
      v119 = *(a1 + 32);
      v135 = *(a1 + 48);
      *v148 = *(a1 + 64);
      *&v148[13] = *(a1 + 77);
      v87 = *a1;
      v103 = *(a1 + 16);
      v26 = *(a1 + 240);
      *(a1 + 32) = *(a1 + 224);
      *(a1 + 48) = v26;
      v27 = *(a1 + 272);
      *(a1 + 64) = *(a1 + 256);
      *(a1 + 80) = v27;
      v28 = *(a1 + 208);
      *a1 = *v22;
      *(a1 + 16) = v28;
    }

    *v22 = v87;
    *(a1 + 208) = v103;
    *(a1 + 256) = *v148;
    *(a1 + 272) = *&v148[16];
    *(a1 + 224) = v119;
    *(a1 + 240) = v135;
LABEL_46:
    if (*(a2 - 40) >= *(a1 + 248))
    {
      return 1;
    }

    v129 = *(a1 + 224);
    v145 = *(a1 + 240);
    *v148 = *(a1 + 256);
    *&v148[13] = *(a1 + 269);
    v97 = *v22;
    v113 = *(a1 + 208);
    v74 = *(a2 - 80);
    *v22 = *(a2 - 96);
    *(a1 + 208) = v74;
    v75 = *(a2 - 16);
    v77 = *(a2 - 64);
    v76 = *(a2 - 48);
    *(a1 + 256) = *(a2 - 32);
    *(a1 + 272) = v75;
    *(a1 + 224) = v77;
    *(a1 + 240) = v76;
    *(a2 - 64) = v129;
    *(a2 - 48) = v145;
    *(a2 - 32) = *v148;
    *(a2 - 16) = *&v148[16];
    *(a2 - 96) = v97;
    *(a2 - 80) = v113;
    if (*(a1 + 248) >= *(a1 + 152))
    {
      return 1;
    }

    v130 = *(a1 + 128);
    v146 = *(a1 + 144);
    *v148 = *(a1 + 160);
    *&v148[13] = *(a1 + 173);
    v98 = *(a1 + 96);
    v114 = *(a1 + 112);
    v78 = *(a1 + 240);
    *(a1 + 128) = *(a1 + 224);
    *(a1 + 144) = v78;
    v79 = *(a1 + 272);
    *(a1 + 160) = *(a1 + 256);
    *(a1 + 176) = v79;
    v80 = *(a1 + 208);
    *(a1 + 96) = *v22;
    *(a1 + 112) = v80;
    *v22 = v98;
    *(a1 + 208) = v114;
    *(a1 + 256) = *v148;
    *(a1 + 272) = *&v148[16];
    *(a1 + 224) = v130;
    *(a1 + 240) = v146;
    goto LABEL_49;
  }

  if (v2 < 2)
  {
    return 1;
  }

  if (v2 == 2)
  {
    if (*(a2 - 40) < *(a1 + 56))
    {
      v116 = *(a1 + 32);
      v132 = *(a1 + 48);
      *v148 = *(a1 + 64);
      *&v148[13] = *(a1 + 77);
      v84 = *a1;
      v100 = *(a1 + 16);
      v3 = *(a2 - 80);
      *a1 = *(a2 - 96);
      *(a1 + 16) = v3;
      v4 = *(a2 - 16);
      v6 = *(a2 - 64);
      v5 = *(a2 - 48);
      *(a1 + 64) = *(a2 - 32);
      *(a1 + 80) = v4;
      *(a1 + 32) = v6;
      *(a1 + 48) = v5;
      *(a2 - 64) = v116;
      *(a2 - 48) = v132;
      *(a2 - 32) = *v148;
      *(a2 - 16) = *&v148[16];
      result = 1;
      *(a2 - 96) = v84;
      *(a2 - 80) = v100;
      return result;
    }

    return 1;
  }

LABEL_13:
  v15 = a1 + 192;
  v16 = *(a1 + 152);
  v17 = *(a1 + 56);
  v18 = *(a1 + 248);
  if (v16 >= v17)
  {
    if (v18 < v16)
    {
      v121 = *(a1 + 128);
      v137 = *(a1 + 144);
      *v148 = *(a1 + 160);
      *&v148[13] = *(a1 + 173);
      v89 = *(a1 + 96);
      v105 = *(a1 + 112);
      v33 = *(a1 + 240);
      *(a1 + 128) = *(a1 + 224);
      *(a1 + 144) = v33;
      v34 = *(a1 + 272);
      *(a1 + 160) = *(a1 + 256);
      *(a1 + 176) = v34;
      v35 = *(a1 + 208);
      *(a1 + 96) = *v15;
      *(a1 + 112) = v35;
      *v15 = v89;
      *(a1 + 208) = v105;
      *(a1 + 256) = *v148;
      *(a1 + 272) = *&v148[16];
      *(a1 + 224) = v121;
      *(a1 + 240) = v137;
      if (*(a1 + 152) < v17)
      {
        v122 = *(a1 + 32);
        v138 = *(a1 + 48);
        *v148 = *(a1 + 64);
        *&v148[13] = *(a1 + 77);
        v90 = *a1;
        v106 = *(a1 + 16);
        v36 = *(a1 + 144);
        *(a1 + 32) = *(a1 + 128);
        *(a1 + 48) = v36;
        v37 = *(a1 + 176);
        *(a1 + 64) = *(a1 + 160);
        *(a1 + 80) = v37;
        v38 = *(a1 + 112);
        *a1 = *(a1 + 96);
        *(a1 + 16) = v38;
        *(a1 + 96) = v90;
        *(a1 + 112) = v106;
        *(a1 + 160) = *v148;
        *(a1 + 176) = *&v148[16];
        *(a1 + 128) = v122;
        *(a1 + 144) = v138;
      }
    }
  }

  else
  {
    if (v18 >= v16)
    {
      v126 = *(a1 + 32);
      v142 = *(a1 + 48);
      *v148 = *(a1 + 64);
      *&v148[13] = *(a1 + 77);
      v94 = *a1;
      v110 = *(a1 + 16);
      v52 = *(a1 + 144);
      *(a1 + 32) = *(a1 + 128);
      *(a1 + 48) = v52;
      v53 = *(a1 + 176);
      *(a1 + 64) = *(a1 + 160);
      *(a1 + 80) = v53;
      v54 = *(a1 + 112);
      *a1 = *(a1 + 96);
      *(a1 + 16) = v54;
      *(a1 + 96) = v94;
      *(a1 + 112) = v110;
      *(a1 + 160) = *v148;
      *(a1 + 176) = *&v148[16];
      *(a1 + 128) = v126;
      *(a1 + 144) = v142;
      if (v18 >= *(a1 + 152))
      {
        goto LABEL_33;
      }

      v118 = *(a1 + 128);
      v134 = *(a1 + 144);
      *v148 = *(a1 + 160);
      *&v148[13] = *(a1 + 173);
      v86 = *(a1 + 96);
      v102 = *(a1 + 112);
      v55 = *(a1 + 240);
      *(a1 + 128) = *(a1 + 224);
      *(a1 + 144) = v55;
      v56 = *(a1 + 272);
      *(a1 + 160) = *(a1 + 256);
      *(a1 + 176) = v56;
      v57 = *(a1 + 208);
      *(a1 + 96) = *v15;
      *(a1 + 112) = v57;
    }

    else
    {
      v118 = *(a1 + 32);
      v134 = *(a1 + 48);
      *v148 = *(a1 + 64);
      *&v148[13] = *(a1 + 77);
      v86 = *a1;
      v102 = *(a1 + 16);
      v19 = *(a1 + 240);
      *(a1 + 32) = *(a1 + 224);
      *(a1 + 48) = v19;
      v20 = *(a1 + 272);
      *(a1 + 64) = *(a1 + 256);
      *(a1 + 80) = v20;
      v21 = *(a1 + 208);
      *a1 = *v15;
      *(a1 + 16) = v21;
    }

    *v15 = v86;
    *(a1 + 208) = v102;
    *(a1 + 256) = *v148;
    *(a1 + 272) = *&v148[16];
    *(a1 + 224) = v118;
    *(a1 + 240) = v134;
  }

LABEL_33:
  v58 = a1 + 288;
  if (a1 + 288 == a2)
  {
    return 1;
  }

  v59 = 0;
  v60 = 0;
  while (1)
  {
    v62 = *(v58 + 56);
    if (v62 < *(v15 + 56))
    {
      v95 = *v58;
      v111 = *(v58 + 16);
      v127 = *(v58 + 32);
      v143 = *(v58 + 48);
      *v149 = *(v58 + 64);
      v63 = v59;
      *&v149[13] = *(v58 + 77);
      do
      {
        v64 = a1 + v63;
        v65 = *(a1 + v63 + 240);
        *(v64 + 320) = *(a1 + v63 + 224);
        *(v64 + 336) = v65;
        v66 = *(a1 + v63 + 272);
        *(v64 + 352) = *(a1 + v63 + 256);
        *(v64 + 368) = v66;
        v67 = *(a1 + v63 + 208);
        *(v64 + 288) = *(a1 + v63 + 192);
        *(v64 + 304) = v67;
        if (v63 == -192)
        {
          v61 = a1;
          goto LABEL_36;
        }

        v63 -= 96;
      }

      while (v62 < *(v64 + 152));
      v61 = a1 + v63 + 288;
LABEL_36:
      *v61 = v95;
      *(v61 + 16) = v111;
      *(v61 + 32) = v127;
      *(v61 + 48) = v143;
      *(v61 + 56) = v62;
      ++v60;
      *(v61 + 64) = *v149;
      *(v61 + 80) = *&v149[16];
      if (v60 == 8)
      {
        return v58 + 96 == a2;
      }
    }

    v15 = v58;
    v59 += 96;
    v58 += 96;
    if (v58 == a2)
    {
      return 1;
    }
  }
}

void *webrtc::TransportFeedbackDemuxer::RegisterStreamFeedbackObserver(void *result, void *a2, uint64_t a3)
{
  v3 = a2[1];
  if (v3 != *a2)
  {
    if (((v3 - *a2) & 0x8000000000000000) == 0)
    {
      operator new();
    }

LABEL_16:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  v4 = result[2];
  v5 = result[3];
  if (v4 >= v5)
  {
    v6 = result[1];
    v7 = ((v4 - v6) >> 5) + 1;
    if (v7 >> 59)
    {
      std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
    }

    v8 = v5 - v6;
    if (v8 >> 4 > v7)
    {
      v7 = v8 >> 4;
    }

    if (v8 >= 0x7FFFFFFFFFFFFFE0)
    {
      v7 = 0x7FFFFFFFFFFFFFFLL;
    }

    if (v7)
    {
      if (!(v7 >> 59))
      {
        operator new();
      }

      std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
    }

    goto LABEL_15;
  }

  if (!v4)
  {
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }

  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a3;
  result[2] = v4 + 4;
  return result;
}

void webrtc::TransportFeedbackDemuxer::DeRegisterStreamFeedbackObserver(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v3 == v4)
  {
    goto LABEL_5;
  }

  do
  {
    if (*(v3 + 24) == a2)
    {
      goto LABEL_5;
    }

    v3 += 32;
  }

  while (v3 != v4);
  do
  {
    __break(1u);
LABEL_5:
    ;
  }

  while (v4 == v3);
  if (v3 + 32 == v4)
  {
    if (v4 == v3)
    {
      goto LABEL_17;
    }

    goto LABEL_13;
  }

  do
  {
    v9 = *v3;
    if (*v3)
    {
      *(v3 + 8) = v9;
      operator delete(v9);
      *(v3 + 8) = 0;
      *(v3 + 16) = 0;
    }

    v5 = v3 + 32;
    *v3 = *(v3 + 32);
    v6 = *(v3 + 48);
    v7 = *(v3 + 56);
    *(v3 + 40) = 0;
    *(v3 + 48) = 0;
    *(v3 + 32) = 0;
    *(v3 + 16) = v6;
    *(v3 + 24) = v7;
    v8 = v3 + 64;
    v3 += 32;
  }

  while (v8 != v4);
  v4 = *(a1 + 16);
  v3 = v5;
  if (v4 != v5)
  {
LABEL_13:
    v10 = v4;
    do
    {
      v12 = *(v10 - 32);
      v10 -= 32;
      v11 = v12;
      if (v12)
      {
        *(v4 - 24) = v11;
        operator delete(v11);
      }

      v4 = v10;
    }

    while (v10 != v3);
  }

LABEL_17:
  *(a1 + 16) = v3;
}

void webrtc::TransportFeedbackDemuxer::OnTransportFeedback(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 24);
  for (i = *(a2 + 32); v2 != i; v2 += 96)
  {
    if (*(v2 + 92) == 1)
    {
      operator new();
    }
  }
}

void webrtc::TransportFeedbackDemuxer::~TransportFeedbackDemuxer(webrtc::TransportFeedbackDemuxer *this)
{
  v2 = *(this + 1);
  if (v2)
  {
    v3 = *(this + 2);
    v4 = *(this + 1);
    if (v3 != v2)
    {
      v5 = *(this + 2);
      do
      {
        v7 = *(v5 - 32);
        v5 -= 32;
        v6 = v7;
        if (v7)
        {
          *(v3 - 24) = v6;
          operator delete(v6);
        }

        v3 = v5;
      }

      while (v5 != v2);
      v4 = *(this + 1);
    }

    *(this + 2) = v2;
    operator delete(v4);
  }
}

{
  v2 = *(this + 1);
  if (v2)
  {
    v3 = *(this + 2);
    v4 = *(this + 1);
    if (v3 != v2)
    {
      v5 = *(this + 2);
      do
      {
        v7 = *(v5 - 32);
        v5 -= 32;
        v6 = v7;
        if (v7)
        {
          *(v3 - 24) = v6;
          operator delete(v6);
        }

        v3 = v5;
      }

      while (v5 != v2);
      v4 = *(this + 1);
    }

    *(this + 2) = v2;
    operator delete(v4);
  }

  JUMPOUT(0x2743DA540);
}

uint64_t webrtc::TransportSequenceNumberFeedbackGenenerator::TransportSequenceNumberFeedbackGenenerator(uint64_t a1, uint64_t a2)
{
  v21 = *MEMORY[0x277D85DE8];
  *a1 = &unk_2882A1358;
  v3 = a1 + 8;
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 32) = v3;
      (*(**(a2 + 24) + 24))(*(a2 + 24), v3);
    }

    else
    {
      *(a1 + 32) = v4;
      *(a2 + 24) = 0;
    }
  }

  else
  {
    *(a1 + 32) = 0;
  }

  *(a1 + 40) = 0x8000000000000000;
  pthread_mutexattr_init(&v19);
  pthread_mutexattr_setpolicy_np(&v19, 3);
  pthread_mutex_init((a1 + 48), &v19);
  pthread_mutexattr_destroy(&v19);
  *(a1 + 112) = 0;
  *(a1 + 116) = 0;
  *(a1 + 120) = 0;
  *(a1 + 128) = 0;
  *(a1 + 130) = 0;
  *(a1 + 136) = 0;
  *(a1 + 144) = 0;
  *(a1 + 152) = 0;
  *(a1 + 160) = -1;
  *(a1 + 168) = 0;
  *(a1 + 176) = 0;
  *(a1 + 184) = 100000;
  *(a1 + 192) = 1;
  if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>() & 1) == 0)
  {
    v16[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/remote_bitrate_estimator/transport_sequence_number_feedback_generator.cc";
    v16[1] = 417;
    v16[2] = &v15;
    v17[0] = "Maximum interval between transport feedback RTCP messages: ";
    v17[1] = v16;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v19, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      v13 = v17;
      v20 = v17;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        v13 = v20;
      }
    }

    else
    {
      v19 = __p;
      v13 = v17;
      v20 = v17;
    }

    webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::ToStringVal>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::ToStringVal const&)::t, v6, v7, v8, v9, v10, v11, v12, *v13[1]);
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
  }

  return a1;
}

void webrtc::TransportSequenceNumberFeedbackGenenerator::~TransportSequenceNumberFeedbackGenenerator(webrtc::TransportSequenceNumberFeedbackGenenerator *this)
{
  *this = &unk_2882A1358;
  v2 = *(this + 19);
  *(this + 19) = 0;
  if (v2)
  {
    MEMORY[0x2743DA520](v2, 0x1000C8000313F17);
  }

  pthread_mutex_destroy((this + 48));
  v3 = *(this + 4);
  if (v3 == (this + 8))
  {
    (*(*v3 + 32))(v3);
  }

  else if (v3)
  {
    (*(*v3 + 40))(v3);
  }
}

{
  *this = &unk_2882A1358;
  v2 = *(this + 19);
  *(this + 19) = 0;
  if (v2)
  {
    MEMORY[0x2743DA520](v2, 0x1000C8000313F17);
  }

  pthread_mutex_destroy((this + 48));
  v3 = *(this + 4);
  if (v3 == (this + 8))
  {
    (*(*v3 + 32))(v3);
  }

  else if (v3)
  {
    (*(*v3 + 40))(v3);
  }

  JUMPOUT(0x2743DA540);
}

void webrtc::TransportSequenceNumberFeedbackGenenerator::OnReceivedPacket(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 112) - 0x7FFFFFFFFFFFFFFFLL) <= 1)
  {
    if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
    {
      webrtc::webrtc_logging_impl::Log("\r\t", v2, v3, v4, v5, v6, v7, v8, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/remote_bitrate_estimator/transport_sequence_number_feedback_generator.cc");
    }

    return;
  }

  if (*(a2 + 40))
  {
    v9 = *(a2 + 56);
    v10 = *(a2 + 64);
    if (v9 != v10)
    {
      while (*v9 != *(a2 + 40))
      {
        v9 += 4;
        if (v9 == v10)
        {
          goto LABEL_13;
        }
      }

      v11 = *(a2 + 88);
      if (v11)
      {
        v11 = *(v11 + 16) + *(a2 + 96);
      }

      if (v9[1] == 2)
      {
        v12 = a2;
        v13 = 0;
        v14 = 0;
        v15 = bswap32(*(v11 + *(v9 + 1))) >> 16;
        goto LABEL_31;
      }
    }
  }

LABEL_13:
  if (*(a2 + 41))
  {
    v16 = *(a2 + 56);
    v17 = *(a2 + 64);
    if (v16 != v17)
    {
      while (*v16 != *(a2 + 41))
      {
        v16 += 4;
        if (v16 == v17)
        {
          return;
        }
      }

      v18 = *(a2 + 88);
      if (v18)
      {
        v18 = *(v18 + 16) + *(a2 + 96);
      }

      v19 = v16[1];
      if (v16[1])
      {
        if (v19 == 4 || v19 == 2)
        {
          v21 = (v18 + *(v16 + 1));
          v15 = bswap32(*v21) >> 16;
          v12 = a2;
          if (v19 == 4)
          {
            v22 = *(v21 + 2);
            v23 = *(v21 + 3) | ((v21[1] & 0x7F) << 8);
            v13 = v23 != 0;
            if (v23)
            {
              v14 = (v22 >> 7) | (v23 << 32);
            }

            else
            {
              v14 = 0;
            }
          }

          else
          {
            v13 = 0;
            v14 = 0;
          }

LABEL_31:
          pthread_mutex_lock((a1 + 48));
          v25 = v12;
          v26 = *(v12 + 40);
          if (*(v12 + 40))
          {
            v27 = *(v12 + 56);
            v28 = *(v12 + 64);
            v29 = a1;
            if (v27 == v28)
            {
              v31 = 0;
              *(a1 + 192) = 0;
              *(a1 + 112) = *(v12 + 12);
              if (*(a1 + 130))
              {
                goto LABEL_40;
              }
            }

            else
            {
              v30 = v27 + 4;
              do
              {
                v31 = *(v30 - 4) == v26;
                v32 = *(v30 - 4) == v26 || v30 == v28;
                v30 += 4;
              }

              while (!v32);
              *(a1 + 192) = v31;
              *(a1 + 112) = *(v12 + 12);
              if (*(a1 + 130))
              {
LABEL_40:
                v33 = *(v29 + 128);
                v34 = v15 >= v33;
                LODWORD(v35) = v15 - v33;
                v36 = v35 != 0 && v34;
                v37 = (v35 & 0x8000u) == 0;
                if (v35 == 0x8000)
                {
                  v37 = v36;
                }

                if (v37)
                {
                  v35 = v35;
                }

                else
                {
                  v35 |= 0xFFFFFFFFFFFF0000;
                }

                v38 = v35 + *(v29 + 120);
                *(v29 + 120) = v38;
                *(v29 + 128) = v15;
                *(v29 + 130) = 1;
                if (!v31)
                {
                  goto LABEL_72;
                }

                goto LABEL_52;
              }
            }
          }

          else
          {
            v31 = 0;
            v29 = a1;
            *(a1 + 192) = 0;
            *(a1 + 112) = *(v12 + 12);
            if (*(a1 + 130))
            {
              goto LABEL_40;
            }
          }

          v38 = v15;
          *(v29 + 120) = v15;
          *(v29 + 128) = v15;
          *(v29 + 130) = 1;
          if (!v31)
          {
            goto LABEL_72;
          }

LABEL_52:
          if (*(v29 + 144) == 1)
          {
            v39 = *(v29 + 176);
            v40 = *(v29 + 136);
            if (v40 < v39)
            {
              goto LABEL_70;
            }

            v41 = *(v25 + 112);
            v42 = 0x7FFFFFFFFFFFFFFFLL;
            if (v41 != 0x7FFFFFFFFFFFFFFFLL)
            {
              if (v41 < 500000)
              {
                goto LABEL_70;
              }

              v42 = v41 - 500000;
            }

            if (v39 >= v38)
            {
              v43 = v38;
            }

            else
            {
              v43 = *(v29 + 176);
            }

            v44 = *(v29 + 168);
            if (v44 < v43)
            {
              v45 = *(v29 + 160);
              v46 = *(v29 + 152);
              while (*(v46 + 8 * (v45 & v44)) <= v42)
              {
                *(v29 + 168) = ++v44;
                if (v43 == v44)
                {
                  v47 = v25;
                  LODWORD(v44) = v43;
                  goto LABEL_68;
                }
              }
            }

            v47 = v25;
LABEL_68:
            webrtc::PacketArrivalTimeMap::AdjustToSize(a1 + 152, v39 - v44);
            v29 = a1;
            v25 = v47;
            if (*(a1 + 144))
            {
              v40 = *(a1 + 136);
LABEL_70:
              if (v38 >= v40)
              {
                goto LABEL_72;
              }
            }
          }

          *(v29 + 136) = v38;
          *(v29 + 144) = 1;
LABEL_72:
          if (*(v29 + 168) > v38 || *(v29 + 176) <= v38 || (*(*(v29 + 152) + 8 * (*(v29 + 160) & v38)) & 0x8000000000000000) != 0)
          {
            v48.var0 = *(v25 + 112);
            webrtc::PacketArrivalTimeMap::AddPacket((a1 + 152), v38, v48);
            v29 = a1;
            v49 = *(a1 + 168);
            if (*(a1 + 144) != 1 || *(a1 + 136) < v49)
            {
              *(a1 + 136) = v49;
              *(a1 + 144) = 1;
            }

            if (v13 && HIDWORD(v14))
            {
              v50 = v38 - HIDWORD(v14) + 1;
              webrtc::TransportSequenceNumberFeedbackGenenerator::MaybeBuildFeedbackPacket(&v52, a1, v14 & 1, v50, v38 + 1, 0);
              if (v52)
              {
                if (*(a1 + 168) <= v50)
                {
                  v51 = *(a1 + 176);
                  if (v51 <= v50)
                  {
                    *(a1 + 168) = v51;
                  }

                  else
                  {
                    *(a1 + 168) = v50;
                    webrtc::PacketArrivalTimeMap::AdjustToSize(a1 + 152, v51 - v50);
                  }
                }

                operator new();
              }

              v29 = a1;
            }
          }

          pthread_mutex_unlock((v29 + 48));
        }
      }
    }
  }
}

uint64_t webrtc::TransportSequenceNumberFeedbackGenenerator::Process(webrtc::TransportSequenceNumberFeedbackGenenerator *this, Timestamp a2)
{
  pthread_mutex_lock((this + 48));
  v4 = 0x7FFFFFFFFFFFFFFFLL;
  if (*(this + 192) == 1)
  {
    v5 = *(this + 23);
    v6 = *(this + 5);
    v7 = v5 == 0x8000000000000000 || v6 == 0x8000000000000000;
    v8 = v6 + v5;
    if (v7)
    {
      v8 = 0x8000000000000000;
    }

    if (v6 == 0x7FFFFFFFFFFFFFFFLL || v5 == 0x7FFFFFFFFFFFFFFFLL)
    {
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10 <= a2.var0)
    {
      *(this + 5) = a2;
      webrtc::TransportSequenceNumberFeedbackGenenerator::SendPeriodicFeedbacks(this);
      v4 = *(this + 23);
    }

    else if (a2.var0 == 0x8000000000000000 || v10 == 0x7FFFFFFFFFFFFFFFLL)
    {
      v4 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v4 = v10 - a2.var0;
    }
  }

  pthread_mutex_unlock((this + 48));
  return v4;
}

void *webrtc::TransportSequenceNumberFeedbackGenenerator::SendPeriodicFeedbacks(void *this)
{
  if (*(this + 144) == 1)
  {
    v1 = this[22];
    v2 = this[17];
    if (v2 < v1)
    {
      this = webrtc::TransportSequenceNumberFeedbackGenenerator::MaybeBuildFeedbackPacket(&v3, this, 1, v2, v1, 1);
      if (v3)
      {
        operator new();
      }
    }
  }

  return this;
}

uint64_t webrtc::TransportSequenceNumberFeedbackGenenerator::OnSendBandwidthEstimateChanged(uint64_t a1, uint64_t a2)
{
  v3 = llround(a2 * 0.05);
  if (v3 >= 2177)
  {
    v8 = 0x206CC800uLL / v3;
    v5 = v3 > 0x2A80;
    v4 = &v8;
    if (v5)
    {
    }
  }

  else
  {
  }

  v6 = *v4;
  pthread_mutex_lock((a1 + 48));
  *(a1 + 184) = v6;

  return pthread_mutex_unlock((a1 + 48));
}

void *webrtc::TransportSequenceNumberFeedbackGenenerator::MaybeBuildFeedbackPacket(void *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  v6 = *(a2 + 168);
  v7 = *(a2 + 176);
  if (v7 < v6)
  {
    __break(1u);
  }

  else
  {
    if (v7 >= a4)
    {
      v8 = a4;
    }

    else
    {
      v8 = *(a2 + 176);
    }

    if (v6 <= a4)
    {
      v9 = v8;
    }

    else
    {
      v9 = *(a2 + 168);
    }

    if (v7 >= a5)
    {
      v7 = a5;
    }

    if (v6 <= a5)
    {
      v10 = v7;
    }

    else
    {
      v10 = *(a2 + 168);
    }

    if (v9 >= v10)
    {
      v11 = a4;
    }

    else
    {
      v11 = a4;
      do
      {
        v12 = *(a2 + 160) & v9++;
      }

      while ((*(*(a2 + 152) + 8 * v12) & 0x8000000000000000) != 0);
      if (v9 - 1 < v10)
      {
        operator new();
      }
    }

    if (a6)
    {
      *(a2 + 136) = v11;
      *(a2 + 144) = 1;
    }

    *this = 0;
  }

  return this;
}

void webrtc::TransportChannelStats::~TransportChannelStats(void **this)
{
  if (*(this + 175) < 0)
  {
    operator delete(this[19]);
  }

  v2 = this[10];
  if (v2)
  {
    v3 = this[11];
    v4 = this[10];
    if (v3 != v2)
    {
      do
      {
        webrtc::Candidate::~Candidate(v3 - 64);
        webrtc::Candidate::~Candidate(v3 - 118);
        v3 -= 133;
      }

      while (v3 != v2);
      v4 = this[10];
    }

    this[11] = v2;
    operator delete(v4);
  }

  v5 = this[7];
  if (v5)
  {
    v6 = this[8];
    v7 = this[7];
    if (v6 != v5)
    {
      do
      {
        webrtc::Candidate::~Candidate(v6 - 58);
      }

      while (v6 != v5);
      v7 = this[7];
    }

    this[8] = v5;
    operator delete(v7);
  }
}

uint64_t webrtc::IceTransportStats::IceTransportStats(uint64_t a1, uint64_t a2)
{
  *a1 = 0;
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  v4 = *(a2 + 8);
  if (v4 != *a2)
  {
    if ((0x34F72C234F72C235 * ((v4 - *a2) >> 4)) < 0x8D3DCB08D3DCB1)
    {
      operator new();
    }

    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  *(a1 + 24) = 0;
  *(a1 + 32) = 0;
  *(a1 + 40) = 0;
  v5 = *(a2 + 24);
  v6 = *(a2 + 32);
  if (v6 != v5)
  {
    if ((0x133F84CFE133F84DLL * ((v6 - v5) >> 3)) < 0x3D980F6603D981)
    {
      operator new();
    }

    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  v7 = *(a2 + 48);
  v8 = *(a2 + 64);
  *(a1 + 76) = *(a2 + 76);
  *(a1 + 48) = v7;
  *(a1 + 64) = v8;
  if (*(a2 + 119) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 96), *(a2 + 96), *(a2 + 104));
  }

  else
  {
    v9 = *(a2 + 96);
    *(a1 + 112) = *(a2 + 112);
    *(a1 + 96) = v9;
  }

  *(a1 + 120) = *(a2 + 120);
  return a1;
}

void webrtc::TrendlineEstimator::TrendlineEstimator(uint64_t a1, uint64_t a2)
{
  *(a1 + 8) = 0;
  *(a1 + 12) = 0x700000007;
  *a1 = &unk_2882A1390;
  *(a1 + 24) = 0;
  *(a1 + 32) = 20;
  v3 = (a1 + 32);
  (*(*a2 + 16))(__p, a2, "WebRTC-BweWindowSizeInPackets", 29);
  v4 = 0;
  v5 = v28;
  if ((v28 & 0x80u) != 0)
  {
    v5 = __p[1];
  }

  if (v5 >= 7)
  {
    v6 = __p[0];
    if ((v28 & 0x80u) == 0)
    {
      v6 = __p;
    }

    v7 = *v6;
    v8 = *(v6 + 3);
    v4 = v7 == 1650552389 && v8 == 1684368482;
    if ((v28 & 0x80000000) == 0)
    {
LABEL_5:
      if (!v4)
      {
        goto LABEL_30;
      }

LABEL_17:
      (*(*a2 + 16))(__p, a2, "WebRTC-BweWindowSizeInPackets", 29);
      v26 = 0;
      if ((v28 & 0x80u) == 0)
      {
        v10 = __p;
      }

      else
      {
        v10 = __p[0];
      }

      if (sscanf(v10, "Enabled-%zu", &v26) == 1)
      {
        v11 = v26;
        if (v26 > 1)
        {
LABEL_27:
          if (v28 < 0)
          {
            operator delete(__p[0]);
          }

          *v3 = v11;
LABEL_30:
          operator new();
        }

        if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
        {
          webrtc::webrtc_logging_impl::Log("\r\t", v12, v13, v14, v15, v16, v17, v18, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/trendline_estimator.cc");
        }
      }

      if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
      {
        webrtc::webrtc_logging_impl::Log("\r\t", v19, v20, v21, v22, v23, v24, v25, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/trendline_estimator.cc");
      }

      v11 = 20;
      goto LABEL_27;
    }
  }

  else if ((v28 & 0x80000000) == 0)
  {
    goto LABEL_5;
  }

  operator delete(__p[0]);
  if (!v4)
  {
    goto LABEL_30;
  }

  goto LABEL_17;
}

void webrtc::TrendlineEstimator::~TrendlineEstimator(void **this)
{
  *this = &unk_2882A1390;
  std::deque<webrtc::RateUtilizationTracker::RateUsageUpdate>::~deque[abi:sn200100](this + 11);
}

{
  *this = &unk_2882A1390;
  std::deque<webrtc::RateUtilizationTracker::RateUsageUpdate>::~deque[abi:sn200100](this + 11);

  JUMPOUT(0x2743DA540);
}

uint64_t webrtc::TrendlineEstimator::Update(webrtc::TrendlineEstimator *this, __n128 a2, float64x2_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int a7)
{
  if (!a7)
  {
LABEL_73:
    result = *(this + 27);
    if (!result)
    {
      return result;
    }

    goto LABEL_74;
  }

  v8 = a3.f64[0];
  v9 = a2.n128_f64[0] - a3.f64[0];
  v11 = (this + 56);
  v10 = *(this + 14);
  if (v10 < 1000)
  {
    v12 = v10 + 1;
  }

  else
  {
    v12 = 1000;
  }

  *v11 = v12;
  v13 = *(this + 8);
  if (v13 == -1)
  {
    *(this + 8) = a5;
    v13 = a5;
  }

  v14 = *(this + 12);
  v15 = *(this + 13);
  v16 = *(this + 10);
  v17 = v9 + *(this + 9);
  v18 = *(this + 5);
  *(this + 9) = v17;
  *(this + 10) = v17 * (1.0 - v18) + v18 * v16;
  if (v15 == v14)
  {
    v19 = 0;
  }

  else
  {
    v19 = 170 * ((v15 - v14) >> 3) - 1;
  }

  v21 = *(this + 15);
  v20 = *(this + 16);
  if (v19 == v20 + v21)
  {
    if (v21 < 0xAA)
    {
      v24 = *(this + 14);
      v25 = *(this + 11);
      if (v15 - v14 < (v24 - v25))
      {
        operator new();
      }

      if (v24 == v25)
      {
        v26 = 1;
      }

      else
      {
        v26 = (v24 - v25) >> 2;
      }

      if (!(v26 >> 61))
      {
        operator new();
      }

LABEL_111:
      std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
    }

    *(this + 15) = v21 - 170;
    v95 = *v14;
    *(this + 12) = v14 + 8;
    v22 = a4;
    v23 = a5;
    std::__split_buffer<webrtc::BitrateProber::ProbeCluster *>::emplace_back<webrtc::BitrateProber::ProbeCluster *&>(this + 11, &v95);
    a4 = v22;
    a5 = v23;
    v21 = *(this + 15);
    v20 = *(this + 16);
    v14 = *(this + 12);
    v15 = *(this + 13);
  }

  if (v15 == v14)
  {
    goto LABEL_110;
  }

  v27 = v20 + v21;
  v28 = *&v14[8 * (v27 / 0xAA)];
  if (!v28)
  {
    goto LABEL_110;
  }

  v29 = v28 + 24 * (v27 % 0xAA);
  a3 = *(this + 72);
  *v29 = (a5 - v13);
  a2 = vextq_s8(a3, a3, 8uLL);
  *(v29 + 8) = a2;
  v30 = v20 + 1;
  *(this + 16) = v20 + 1;
  if (*(this + 8) == 1 && v20)
  {
    do
    {
      v30 = *(this + 16);
      if (v30 <= v20 || v30 <= v20 - 1)
      {
        goto LABEL_110;
      }

      v31 = v20 + *(this + 15);
      v32 = *(this + 12);
      v33 = *(v32 + 8 * (v31 / 0xAA)) + 24 * (v31 % 0xAA);
      v34 = *(v32 + 8 * ((v31 - 1) / 0xAA)) + 24 * ((v31 - 1) % 0xAA);
      if (*v33 >= *v34)
      {
        goto LABEL_29;
      }

      v35 = *(v33 + 16);
      a2 = *v33;
      v36 = *(v34 + 16);
      a3 = *v34;
      *v33 = *v34;
      *(v33 + 16) = v36;
      *v34 = a2;
      *(v34 + 16) = v35;
      --v20;
    }

    while (v20);
    v30 = *(this + 16);
  }

LABEL_29:
  v37 = *(this + 8);
  if (v30 > v37)
  {
    v38 = *(this + 12);
    v39 = *(this + 15);
    if (!*(v38 + ((((v39 * 0xC0C0C0C0C0C0C0C1) >> 64) >> 4) & 0xFFFFFFFFFFFFFF8)))
    {
      goto LABEL_110;
    }

    --v30;
    v40 = v39 + 1;
    *(this + 15) = v40;
    *(this + 16) = v30;
    if (v40 >= 0x154)
    {
      v41 = a5;
      v42 = a4;
      operator delete(*v38);
      a4 = v42;
      a5 = v41;
      *(this + 12) += 8;
      v30 = *(this + 16);
      *(this + 15) -= 170;
      v37 = *(this + 8);
    }
  }

  a2.n128_u64[0] = *(this + 23);
  *&a3.f64[0] = a2.n128_u64[0];
  if (v30 == v37)
  {
    v43 = *(this + 15);
    v44 = *(this + 12);
    v45 = (v44 + 8 * (v43 / 0xAA));
    a3 = 0uLL;
    if (*(this + 13) != v44)
    {
      v46 = *v45;
      v47 = &(*v45)[24 * (v43 % 0xAA)];
      v48 = *(v44 + 8 * ((v43 + v37) / 0xAA)) + 24 * ((v43 + v37) % 0xAA);
      if (v47 != v48)
      {
        v49 = *v45;
        v50 = &(*v45)[24 * (v43 % 0xAA)];
        v51 = v44 + 8 * (v43 / 0xAA);
        do
        {
          v52 = *v50;
          v50 += 24;
          v53 = v52;
          if (v50 - v49 == 4080)
          {
            v54 = *(v51 + 8);
            v51 += 8;
            v49 = v54;
            v50 = v54;
          }

          a3 = vaddq_f64(a3, v53);
        }

        while (v50 != v48);
        v55 = vdivq_f64(a3, vdupq_lane_s64(COERCE__INT64(v37), 0));
        a3 = 0uLL;
        v56 = v44 + 8 * (v43 / 0xAA);
        do
        {
          v58 = *v47;
          v47 += 24;
          v59 = v58;
          if (v47 - v46 == 4080)
          {
            v60 = *(v56 + 8);
            v56 += 8;
            v46 = v60;
            v47 = v60;
          }

          v57 = vsubq_f64(v59, v55);
          a3 = vmlaq_n_f64(a3, v57, v57.f64[0]);
        }

        while (v47 != v48);
      }
    }

    *&v61 = *&vdivq_f64(vdupq_laneq_s64(a3, 1), a3);
    if (a3.f64[0] == 0.0)
    {
      a3.f64[0] = *(this + 23);
    }

    else
    {
      a3.f64[0] = v61;
    }

    if (*(this + 9) == 1)
    {
      if (v37)
      {
        v62 = &(*v45)[24 * (v43 % 0xAA)];
        v63 = *v62;
        v64 = v62[2];
        v65 = *(this + 3);
        if (v65 < 2)
        {
          goto LABEL_55;
        }

        if (v37 - 1 > v65 - 2)
        {
          v66 = v65 - 1;
          v67 = v43 + 1;
          do
          {
            v68 = (*(v44 + 8 * (v67 / 0xAA)) + 24 * (v67 % 0xAA));
            if (v68[2] < v64)
            {
              v63 = *v68;
              v64 = v68[2];
            }

            ++v67;
            --v66;
          }

          while (v66);
LABEL_55:
          v69 = *(this + 4);
          v70 = v37 - v69;
          if (v37 > v37 - v69)
          {
            v71 = (*(v44 + 8 * ((v70 + v43) / 0xAA)) + 24 * ((v70 + v43) % 0xAA));
            v72 = *v71;
            v73 = v71[2];
            if (v70 + 1 < v37)
            {
              v74 = v69 - 1;
              v75 = v37 + v43 - v69 + 1;
              do
              {
                v76 = (*(v44 + 8 * (v75 / 0xAA)) + 24 * (v75 % 0xAA));
                if (v76[2] < v73)
                {
                  v72 = *v76;
                  v73 = v76[2];
                }

                ++v75;
                --v74;
              }

              while (v74);
            }

            v77 = v72 - v63;
            v78 = 0.0;
            if (v77 >= 1.0)
            {
              v78 = (v73 - v64) / v77 + *(this + 3);
            }

            if (a3.f64[0] > v78 && v77 >= 1.0 && a3.f64[0] >= 0.0)
            {
              a3.f64[0] = v78;
            }

            goto LABEL_71;
          }
        }
      }

LABEL_110:
      __break(1u);
      goto LABEL_111;
    }
  }

LABEL_71:
  if (*v11 <= 1)
  {
    *(this + 51) = 0;
    goto LABEL_73;
  }

  if (*v11 <= 0x3C)
  {
    v82 = this + 56;
  }

  else
  {
    v82 = "<";
  }

  v83 = *(this + 6) * (a3.f64[0] * *v82);
  *(this + 21) = v83;
  v84 = *(this + 20);
  if (v83 <= v84)
  {
    *(this + 24) = 0xBFF0000000000000;
    *(this + 50) = 0;
    if (v83 >= -v84)
    {
      *(this + 51) = 0;
      *(this + 23) = *&a3.f64[0];
      a2.n128_f64[0] = fabs(v83);
      a3.f64[0] = v84 + 15.0;
      if (a2.n128_f64[0] > v84 + 15.0)
      {
        goto LABEL_106;
      }

      goto LABEL_93;
    }

    *(this + 51) = 1;
  }

  else
  {
    v85 = *(this + 24);
    if (v85 == -1.0)
    {
      v86 = v8 * 0.5;
    }

    else
    {
      v86 = v85 + v8;
    }

    *(this + 24) = v86;
    v87 = *(this + 50);
    *(this + 50) = v87 + 1;
    v88 = v86 <= *(this + 19) || v87 < 1;
    if (!v88 && a2.n128_f64[0] <= a3.f64[0])
    {
      *(this + 24) = 0;
      *(this + 25) = 0x200000000;
      *(this + 23) = *&a3.f64[0];
      a2.n128_f64[0] = fabs(v83);
      a3.f64[0] = v84 + 15.0;
      if (a2.n128_f64[0] > v84 + 15.0)
      {
        goto LABEL_106;
      }

      goto LABEL_93;
    }
  }

  *(this + 23) = *&a3.f64[0];
  a2.n128_f64[0] = fabs(v83);
  a3.f64[0] = v84 + 15.0;
  if (a2.n128_f64[0] > v84 + 15.0)
  {
    goto LABEL_106;
  }

LABEL_93:
  v89 = *(this + 22);
  v90 = 136;
  if (a2.n128_f64[0] < v84)
  {
    v90 = 144;
  }

  v91 = *(this + v90);
  v92 = a5 - v89;
  if (a5 - v89 >= 100)
  {
    v92 = 100;
  }

  if (v89 == -1)
  {
    v93 = 0;
  }

  else
  {
    v93 = v92;
  }

  v94 = v84 + (a2.n128_f64[0] - v84) * v91 * v93;
  a3.f64[0] = 600.0;
  if (v94 < 600.0)
  {
    a3.f64[0] = v94;
  }

  if (v94 > 6.0)
  {
    a2.n128_f64[0] = a3.f64[0];
  }

  else
  {
    a2.n128_f64[0] = 6.0;
  }

  *(this + 20) = a2.n128_u64[0];
LABEL_106:
  *(this + 22) = a5;
  result = *(this + 27);
  if (result)
  {
LABEL_74:
    result = (*(*result + 16))(result, a4, a5, *(this + 51), a2, a3);
    *(this + 52) = result;
  }

  return result;
}

uint64_t webrtc::TrendlineEstimator::State(webrtc::TrendlineEstimator *this)
{
  v1 = 208;
  if (!*(this + 27))
  {
    v1 = 204;
  }

  return *(this + v1);
}

void webrtc::TurnPort::TurnPort(uint64_t a1, uint64_t *a2, uint64_t a3, __int128 *a4, __int128 *a5, int a6, void *a7, void *a8, uint64_t a9, uint64_t a10)
{
  v29[4] = *MEMORY[0x277D85DE8];
  v16 = webrtc::Port::Port(a1, a2, 3, 0, 0, 1);
  *v16 = &unk_2882A13C0;
  v16[29] = &unk_2882A1568;
  v17 = (v16 + 102);
  *(a1 + 816) = 0;
  *(v17 + 8) = 0u;
  *(a1 + 840) = &unk_28828CE50;
  *(a1 + 848) = 0u;
  *(a1 + 864) = 0;
  if (v17 != a4)
  {
    if (*(a4 + 23) < 0)
    {
      std::string::__assign_no_alias<true>(v17, *a4, *(a4 + 1));
    }

    else
    {
      v18 = *a4;
      *(v17 + 2) = *(a4 + 2);
      *v17 = v18;
    }
  }

  *(a1 + 848) = *(a4 + 8);
  *(a1 + 852) = *(a4 + 36);
  *(a1 + 872) = *(a4 + 28);
  *(a1 + 880) = *(a4 + 64);
  *(a1 + 876) = *(a4 + 15);
  *(a1 + 888) = *(a4 + 18);
  webrtc::TurnPort::ReconstructServerUrl((a1 + 896), a1);
  *(a1 + 920) = 0;
  *(a1 + 928) = 0;
  *(a1 + 944) = 0;
  *(a1 + 936) = 0;
  v19 = a7[1];
  if (v19 != *a7)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((v19 - *a7) >> 3) <= 0xAAAAAAAAAAAAAAALL)
    {
      operator new();
    }

    goto LABEL_17;
  }

  *(a1 + 968) = 0;
  *(a1 + 952) = 0u;
  v20 = a8[1];
  if (v20 != *a8)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((v20 - *a8) >> 3) <= 0xAAAAAAAAAAAAAAALL)
    {
      operator new();
    }

LABEL_17:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  *(a1 + 976) = a10;
  v21 = (a1 + 984);
  if (*(a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v21, *a5, *(a5 + 1));
    v23 = a9;
    v24 = (a1 + 1008);
    if ((*(a5 + 47) & 0x80000000) == 0)
    {
      goto LABEL_13;
    }
  }

  else
  {
    v22 = *a5;
    *(a1 + 1000) = *(a5 + 2);
    *&v21->__r_.__value_.__l.__data_ = v22;
    v23 = a9;
    v24 = (a1 + 1008);
    if ((*(a5 + 47) & 0x80000000) == 0)
    {
LABEL_13:
      v25 = *(a5 + 24);
      v24->__r_.__value_.__r.__words[2] = *(a5 + 5);
      *&v24->__r_.__value_.__l.__data_ = v25;
      goto LABEL_16;
    }
  }

  std::string::__init_copy_ctor_external(v24, *(a5 + 3), *(a5 + 4));
LABEL_16:
  *(a1 + 1040) = 0u;
  *(a1 + 1032) = a1 + 1040;
  *(a1 + 1056) = a3;
  *(a1 + 1072) = 0;
  *(a1 + 1080) = 0u;
  *(a1 + 1064) = a1 + 1072;
  *(a1 + 1096) = 0xFFFFFFFF00000000;
  v26 = a2[5];
  v29[0] = &unk_2882A16C8;
  v29[1] = a1;
  v29[3] = v29;
  *(a1 + 1104) = v26;
  *(a1 + 1120) = 0u;
  *(a1 + 1112) = a1 + 1120;
  *(a1 + 1160) = a1 + 1136;
  *(a1 + 1136) = &unk_2882A16C8;
  *(a1 + 1144) = a1;
  *(a1 + 1168) = 0u;
  *(a1 + 1184) = 0u;
  *(a1 + 1200) = 0u;
  *(a1 + 1216) = 0u;
  *(a1 + 1232) = 0;
  *(a1 + 1240) = 0x4000;
  *(a1 + 1248) = 0;
  *(a1 + 1256) = 0u;
  *(a1 + 1272) = 0;
  *(a1 + 1276) = a6;
  *(a1 + 1280) = 0;
  *(a1 + 1288) = v23;
  *(a1 + 1312) = 0;
  *(a1 + 1296) = 0u;
  operator new();
}

double webrtc::TurnPort::ReconstructServerUrl(std::string *this, uint64_t a2)
{
  v56 = 4;
  if (__src <= "turn" && __src + 4 > "turn")
  {
    goto LABEL_156;
  }

  strcpy(__src, "turn");
  v54 = 3;
  if (v53 <= "tcp" && v53 + 3 > "tcp")
  {
    goto LABEL_156;
  }

  LODWORD(v53[0]) = 7365492;
  v4 = *(a2 + 888);
  if ((v4 - 2) >= 2)
  {
    if (!v4)
    {
      qmemcpy(v53, "udp", 3);
    }

    v5 = 4;
  }

  else
  {
    v5 = 5;
    v56 = 5;
    strcpy(__src, "turns");
  }

  memset(&__dst, 0, sizeof(__dst));
  if (&__dst <= __src && (&__dst | v5) > __src)
  {
    goto LABEL_156;
  }

  memcpy(&__dst, __src, v5);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    __dst.__r_.__value_.__l.__size_ = v5;
    size = v5;
  }

  else
  {
    *(&__dst.__r_.__value_.__s + 23) = v5;
    size = __dst.__r_.__value_.__l.__size_;
  }

  p_dst = &__dst;
  *(&__dst | v5) = 0;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v8 = 22;
  }

  else
  {
    v8 = (__dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  }

  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }

  if (v8 == size)
  {
    std::string::__grow_by_and_replace(&__dst, v8, 1uLL, v8, v8, 0, 1uLL, ":");
  }

  else
  {
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      p_dst = __dst.__r_.__value_.__r.__words[0];
    }

    v9 = p_dst + size;
    if (p_dst + size <= ":" && v9 + 1 > ":")
    {
      goto LABEL_156;
    }

    *v9 = 58;
    v10 = size + 1;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      __dst.__r_.__value_.__l.__size_ = v10;
    }

    else
    {
      *(&__dst.__r_.__value_.__s + 23) = v10 & 0x7F;
    }

    p_dst->__r_.__value_.__s.__data_[v10] = 0;
  }

  webrtc::SocketAddress::HostAsURIString((a2 + 816), &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v13 = __p.__r_.__value_.__l.__size_;
  }

  if (!p_p && v13)
  {
    goto LABEL_156;
  }

  v14 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? 22 : (__dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  v15 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? HIBYTE(__dst.__r_.__value_.__r.__words[2]) : __dst.__r_.__value_.__l.__size_;
  if (v14 - v15 >= v13)
  {
    if (v13)
    {
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v16 = &__dst;
      }

      else
      {
        v16 = __dst.__r_.__value_.__r.__words[0];
      }

      if ((v13 & 0x8000000000000000) != 0)
      {
        goto LABEL_156;
      }

      v17 = v16 + v15;
      if ((v16 + v15) <= p_p && &v17[v13] > p_p)
      {
        goto LABEL_156;
      }

      v18 = v13;
      memmove(v17, p_p, v13);
      v19 = v15 + v18;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        __dst.__r_.__value_.__l.__size_ = v15 + v18;
      }

      else
      {
        *(&__dst.__r_.__value_.__s + 23) = v19 & 0x7F;
      }

      v16->__r_.__value_.__s.__data_[v19] = 0;
    }
  }

  else
  {
    std::string::__grow_by_and_replace(&__dst, v14, v15 + v13 - v14, v15, v15, 0, v13, p_p);
  }

  v20 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v21 = 22;
  }

  else
  {
    v21 = (__dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  }

  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    v20 = __dst.__r_.__value_.__l.__size_;
  }

  if (v21 == v20)
  {
    std::string::__grow_by_and_replace(&__dst, v21, 1uLL, v21, v21, 0, 1uLL, ":");
  }

  else
  {
    v22 = &__dst;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      v22 = __dst.__r_.__value_.__r.__words[0];
    }

    v23 = v22 + v20;
    if (v22 + v20 <= ":" && v23 + 1 > ":")
    {
      goto LABEL_156;
    }

    *v23 = 58;
    v24 = v20 + 1;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      __dst.__r_.__value_.__l.__size_ = v24;
    }

    else
    {
      *(&__dst.__r_.__value_.__s + 23) = v24 & 0x7F;
    }

    v22->__r_.__value_.__s.__data_[v24] = 0;
  }

  v25 = *(a2 + 872);
  v58 = 0;
  v59 = 0x1600000000000000;
  v57 = 0;
  v26 = absl::numbers_internal::FastIntToBuffer(v25, &v57, v11);
  v27 = v26 - &v57;
  if ((SHIBYTE(v59) & 0x8000000000000000) != 0)
  {
    if (v58 < v27)
    {
      goto LABEL_157;
    }

    v28 = v57;
    v58 = v26 - &v57;
  }

  else
  {
    if (v27 > SHIBYTE(v59))
    {
      goto LABEL_157;
    }

    HIBYTE(v59) = v26 - &v57;
    v28 = &v57;
  }

  *(v28 + v27) = 0;
  v29 = v59 >= 0 ? &v57 : v57;
  v30 = v59 >= 0 ? HIBYTE(v59) : v58;
  if (!v29 && v30)
  {
LABEL_156:
    __break(1u);
LABEL_157:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v31 = 22;
  }

  else
  {
    v31 = (__dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  }

  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v32 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v32 = __dst.__r_.__value_.__l.__size_;
  }

  if (v31 - v32 < v30)
  {
    std::string::__grow_by_and_replace(&__dst, v31, v32 + v30 - v31, v32, v32, 0, v30, v29);
    if ((SHIBYTE(v59) & 0x80000000) == 0)
    {
      goto LABEL_104;
    }

    goto LABEL_93;
  }

  if (!v30)
  {
LABEL_103:
    if ((SHIBYTE(v59) & 0x80000000) == 0)
    {
      goto LABEL_104;
    }

LABEL_93:
    operator delete(v57);
    goto LABEL_104;
  }

  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v33 = &__dst;
  }

  else
  {
    v33 = __dst.__r_.__value_.__r.__words[0];
  }

  if ((v30 & 0x8000000000000000) != 0)
  {
    goto LABEL_156;
  }

  v34 = v33 + v32;
  if (v33 + v32 <= v29 && &v34[v30] > v29)
  {
    goto LABEL_156;
  }

  v35 = v30;
  memmove(v34, v29, v30);
  v36 = v32 + v35;
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    *(&__dst.__r_.__value_.__s + 23) = v36 & 0x7F;
    v33->__r_.__value_.__s.__data_[v36] = 0;
    goto LABEL_103;
  }

  __dst.__r_.__value_.__l.__size_ = v32 + v35;
  v33->__r_.__value_.__s.__data_[v36] = 0;
  if (SHIBYTE(v59) < 0)
  {
    goto LABEL_93;
  }

LABEL_104:
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v37 = 22;
  }

  else
  {
    v37 = (__dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  }

  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v38 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v38 = __dst.__r_.__value_.__l.__size_;
  }

  if (v37 - v38 >= 0xB)
  {
    v39 = &__dst;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      v39 = __dst.__r_.__value_.__r.__words[0];
    }

    v40 = v39 + v38;
    if (v39 + v38 <= "?transport=" && v40 + 11 > "?transport=")
    {
      goto LABEL_156;
    }

    *(v40 + 7) = 1031041647;
    *v40 = *"?transport=";
    v41 = v38 + 11;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      __dst.__r_.__value_.__l.__size_ = v38 + 11;
    }

    else
    {
      *(&__dst.__r_.__value_.__s + 23) = v41 & 0x7F;
    }

    v39->__r_.__value_.__s.__data_[v41] = 0;
  }

  else
  {
    std::string::__grow_by_and_replace(&__dst, v37, v38 - v37 + 11, v38, v38, 0, 0xBuLL, "?transport=");
  }

  if (v54 >= 0)
  {
    v42 = v53;
  }

  else
  {
    v42 = v53[0];
  }

  if (v54 >= 0)
  {
    v43 = v54;
  }

  else
  {
    v43 = v53[1];
  }

  if (!v42 && v43)
  {
    goto LABEL_156;
  }

  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v44 = 22;
  }

  else
  {
    v44 = (__dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  }

  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v45 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v45 = __dst.__r_.__value_.__l.__size_;
  }

  if (v44 - v45 >= v43)
  {
    if (!v43)
    {
      goto LABEL_148;
    }

    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v47 = &__dst;
    }

    else
    {
      v47 = __dst.__r_.__value_.__r.__words[0];
    }

    if ((v43 & 0x8000000000000000) == 0)
    {
      v48 = v47 + v45;
      if (v47 + v45 > v42 || &v48[v43] <= v42)
      {
        v49 = v43;
        memmove(v48, v42, v43);
        v50 = v45 + v49;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          __dst.__r_.__value_.__l.__size_ = v45 + v49;
          v47->__r_.__value_.__s.__data_[v50] = 0;
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_149;
          }

LABEL_136:
          operator delete(__p.__r_.__value_.__l.__data_);
          result = *&__dst.__r_.__value_.__l.__data_;
          *this = __dst;
          if (v54 < 0)
          {
            goto LABEL_137;
          }

LABEL_150:
          if (v56 < 0)
          {
            goto LABEL_138;
          }

          return result;
        }

        *(&__dst.__r_.__value_.__s + 23) = v50 & 0x7F;
        v47->__r_.__value_.__s.__data_[v50] = 0;
LABEL_148:
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_149;
        }

        goto LABEL_136;
      }
    }

    goto LABEL_156;
  }

  std::string::__grow_by_and_replace(&__dst, v44, v45 + v43 - v44, v45, v45, 0, v43, v42);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    goto LABEL_136;
  }

LABEL_149:
  result = *&__dst.__r_.__value_.__l.__data_;
  *this = __dst;
  if ((v54 & 0x80000000) == 0)
  {
    goto LABEL_150;
  }

LABEL_137:
  operator delete(v53[0]);
  if (v56 < 0)
  {
LABEL_138:
    operator delete(__src[0]);
  }

  return result;
}

void webrtc::TurnPort::TurnPort(uint64_t a1, uint64_t *a2, __int16 a3, __int16 a4, __int128 *a5, __int128 *a6, int a7, void *a8, void *a9, uint64_t a10, uint64_t a11)
{
  v28[4] = *MEMORY[0x277D85DE8];
  v17 = webrtc::Port::Port(a1, a2, 3, a3, a4, 0);
  *v17 = &unk_2882A13C0;
  v17[29] = &unk_2882A1568;
  v18 = (v17 + 102);
  *(a1 + 816) = 0;
  *(v18 + 8) = 0u;
  *(a1 + 840) = &unk_28828CE50;
  *(a1 + 848) = 0u;
  *(a1 + 864) = 0;
  if (v18 != a5)
  {
    if (*(a5 + 23) < 0)
    {
      std::string::__assign_no_alias<true>(v18, *a5, *(a5 + 1));
    }

    else
    {
      v19 = *a5;
      *(v18 + 2) = *(a5 + 2);
      *v18 = v19;
    }
  }

  *(a1 + 848) = *(a5 + 8);
  *(a1 + 852) = *(a5 + 36);
  *(a1 + 872) = *(a5 + 28);
  *(a1 + 880) = *(a5 + 64);
  *(a1 + 876) = *(a5 + 15);
  *(a1 + 888) = *(a5 + 18);
  webrtc::TurnPort::ReconstructServerUrl((a1 + 896), a1);
  *(a1 + 920) = 0;
  *(a1 + 928) = 0;
  *(a1 + 944) = 0;
  *(a1 + 936) = 0;
  v20 = a8[1];
  if (v20 != *a8)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((v20 - *a8) >> 3) <= 0xAAAAAAAAAAAAAAALL)
    {
      operator new();
    }

    goto LABEL_17;
  }

  *(a1 + 968) = 0;
  *(a1 + 952) = 0u;
  v21 = a9[1];
  if (v21 != *a9)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((v21 - *a9) >> 3) <= 0xAAAAAAAAAAAAAAALL)
    {
      operator new();
    }

LABEL_17:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  *(a1 + 976) = a11;
  v22 = (a1 + 984);
  if (*(a6 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v22, *a6, *(a6 + 1));
    v24 = a10;
    v25 = (a1 + 1008);
    if ((*(a6 + 47) & 0x80000000) == 0)
    {
      goto LABEL_13;
    }
  }

  else
  {
    v23 = *a6;
    *(a1 + 1000) = *(a6 + 2);
    *&v22->__r_.__value_.__l.__data_ = v23;
    v24 = a10;
    v25 = (a1 + 1008);
    if ((*(a6 + 47) & 0x80000000) == 0)
    {
LABEL_13:
      v26 = *(a6 + 24);
      v25->__r_.__value_.__r.__words[2] = *(a6 + 5);
      *&v25->__r_.__value_.__l.__data_ = v26;
      goto LABEL_16;
    }
  }

  std::string::__init_copy_ctor_external(v25, *(a6 + 3), *(a6 + 4));
LABEL_16:
  *(a1 + 1040) = 0u;
  *(a1 + 1032) = a1 + 1040;
  *(a1 + 1056) = 0;
  *(a1 + 1072) = 0;
  *(a1 + 1080) = 0u;
  *(a1 + 1064) = a1 + 1072;
  *(a1 + 1096) = 0xFFFFFFFF00000000;
  v27 = a2[5];
  v28[0] = &unk_2882A1710;
  v28[1] = a1;
  v28[3] = v28;
  *(a1 + 1104) = v27;
  *(a1 + 1120) = 0u;
  *(a1 + 1112) = a1 + 1120;
  *(a1 + 1160) = a1 + 1136;
  *(a1 + 1136) = &unk_2882A1710;
  *(a1 + 1144) = a1;
  *(a1 + 1168) = 0u;
  *(a1 + 1184) = 0u;
  *(a1 + 1200) = 0u;
  *(a1 + 1216) = 0u;
  *(a1 + 1232) = 0;
  *(a1 + 1240) = 0x4000;
  *(a1 + 1248) = 0;
  *(a1 + 1256) = 0u;
  *(a1 + 1272) = 0;
  *(a1 + 1276) = a7;
  *(a1 + 1280) = 0;
  *(a1 + 1288) = v24;
  *(a1 + 1312) = 0;
  *(a1 + 1296) = 0u;
  operator new();
}

void webrtc::TurnPort::~TurnPort(webrtc::TurnPort *this)
{
  *this = &unk_2882A13C0;
  *(this + 29) = &unk_2882A1568;
  if (*(this + 318) == 2)
  {
    std::__tree<std::__value_type<std::string,std::unique_ptr<webrtc::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<webrtc::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<webrtc::StunRequest>>>>::destroy(this + 1112, *(this + 140));
    *(this + 139) = this + 1120;
    *(this + 70) = 0u;
    operator new();
  }

  v2 = *(this + 157);
  v3 = *(this + 156);
  while (v2 != v3)
  {
    v5 = *--v2;
    v4 = v5;
    *v2 = 0;
    if (v5)
    {
      (*(*v4 + 8))(v4);
    }
  }

  *(this + 157) = v3;
  v6 = *(this + 132);
  if (v6)
  {
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((v6 + 280), this);
  }

  if (((*(*this + 64))(this) & 1) == 0)
  {
    v7 = *(this + 132);
    if (v7)
    {
      (*(*v7 + 8))(v7);
    }
  }

  v8 = *(this + 165);
  *(v8 + 4) = 0;
  if (atomic_fetch_add(v8, 0xFFFFFFFF) == 1)
  {
    MEMORY[0x2743DA540]();
    if ((*(this + 1319) & 0x80000000) == 0)
    {
LABEL_14:
      v9 = *(this + 156);
      if (!v9)
      {
        goto LABEL_15;
      }

LABEL_34:
      v14 = *(this + 157);
      if (v14 == v9)
      {
        *(this + 157) = v9;
        operator delete(v9);
        if (*(this + 1239) < 0)
        {
          goto LABEL_41;
        }
      }

      else
      {
        do
        {
          v16 = *--v14;
          v15 = v16;
          *v14 = 0;
          if (v16)
          {
            (*(*v15 + 8))(v15);
          }
        }

        while (v14 != v9);
        v17 = *(this + 156);
        *(this + 157) = v9;
        operator delete(v17);
        if (*(this + 1239) < 0)
        {
          goto LABEL_41;
        }
      }

LABEL_16:
      if ((*(this + 1215) & 0x80000000) == 0)
      {
        goto LABEL_17;
      }

      goto LABEL_42;
    }
  }

  else if ((*(this + 1319) & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(*(this + 162));
  v9 = *(this + 156);
  if (v9)
  {
    goto LABEL_34;
  }

LABEL_15:
  if ((*(this + 1239) & 0x80000000) == 0)
  {
    goto LABEL_16;
  }

LABEL_41:
  operator delete(*(this + 152));
  if ((*(this + 1215) & 0x80000000) == 0)
  {
LABEL_17:
    if ((*(this + 1191) & 0x80000000) == 0)
    {
      goto LABEL_18;
    }

    goto LABEL_43;
  }

LABEL_42:
  operator delete(*(this + 149));
  if ((*(this + 1191) & 0x80000000) == 0)
  {
LABEL_18:
    v10 = *(this + 145);
    if (v10 != (this + 1136))
    {
      goto LABEL_19;
    }

    goto LABEL_44;
  }

LABEL_43:
  operator delete(*(this + 146));
  v10 = *(this + 145);
  if (v10 != (this + 1136))
  {
LABEL_19:
    if (v10)
    {
      (*(*v10 + 40))(v10);
    }

    std::__tree<std::__value_type<std::string,std::unique_ptr<webrtc::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<webrtc::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<webrtc::StunRequest>>>>::destroy(this + 1112, *(this + 140));
    v11 = *(this + 136);
    *(this + 136) = 0;
    if (v11)
    {
      goto LABEL_22;
    }

    goto LABEL_23;
  }

LABEL_44:
  (*(*v10 + 32))(v10);
  std::__tree<std::__value_type<std::string,std::unique_ptr<webrtc::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<webrtc::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<webrtc::StunRequest>>>>::destroy(this + 1112, *(this + 140));
  v11 = *(this + 136);
  *(this + 136) = 0;
  if (v11)
  {
LABEL_22:
    (*(*v11 + 8))(v11);
  }

LABEL_23:
  std::__tree<sigslot::_signal_base_interface *>::destroy(this + 1064, *(this + 134));
  std::__tree<webrtc::SocketAddress>::destroy(this + 1032, *(this + 130));
  if (*(this + 1031) < 0)
  {
    operator delete(*(this + 126));
    if ((*(this + 1007) & 0x80000000) == 0)
    {
LABEL_25:
      v12 = *(this + 119);
      if (!v12)
      {
        goto LABEL_26;
      }

LABEL_48:
      v18 = *(this + 120);
      if (v18 == v12)
      {
        *(this + 120) = v12;
        operator delete(v12);
        v13 = *(this + 116);
        if (v13)
        {
          goto LABEL_55;
        }
      }

      else
      {
        do
        {
          v19 = *(v18 - 1);
          v18 -= 3;
          if (v19 < 0)
          {
            operator delete(*v18);
          }
        }

        while (v18 != v12);
        v20 = *(this + 119);
        *(this + 120) = v12;
        operator delete(v20);
        v13 = *(this + 116);
        if (v13)
        {
          goto LABEL_55;
        }
      }

LABEL_27:
      if ((*(this + 919) & 0x80000000) == 0)
      {
        goto LABEL_28;
      }

LABEL_57:
      operator delete(*(this + 112));
      if ((*(this + 839) & 0x80000000) == 0)
      {
        goto LABEL_29;
      }

      goto LABEL_58;
    }
  }

  else if ((*(this + 1007) & 0x80000000) == 0)
  {
    goto LABEL_25;
  }

  operator delete(*(this + 123));
  v12 = *(this + 119);
  if (v12)
  {
    goto LABEL_48;
  }

LABEL_26:
  v13 = *(this + 116);
  if (!v13)
  {
    goto LABEL_27;
  }

LABEL_55:
  v21 = *(this + 117);
  if (v21 == v13)
  {
    *(this + 117) = v13;
    operator delete(v13);
    if (*(this + 919) < 0)
    {
      goto LABEL_57;
    }
  }

  else
  {
    do
    {
      v22 = *(v21 - 1);
      v21 -= 3;
      if (v22 < 0)
      {
        operator delete(*v21);
      }
    }

    while (v21 != v13);
    v23 = *(this + 116);
    *(this + 117) = v13;
    operator delete(v23);
    if (*(this + 919) < 0)
    {
      goto LABEL_57;
    }
  }

LABEL_28:
  if ((*(this + 839) & 0x80000000) == 0)
  {
    goto LABEL_29;
  }

LABEL_58:
  operator delete(*(this + 102));
LABEL_29:

  webrtc::Port::~Port(this);
}

{
  webrtc::TurnPort::~TurnPort(this);

  JUMPOUT(0x2743DA540);
}

void non-virtual thunk towebrtc::TurnPort::~TurnPort(webrtc::TurnPort *this)
{
  webrtc::TurnPort::~TurnPort((this - 232));
}

{
  webrtc::TurnPort::~TurnPort((this - 232));

  JUMPOUT(0x2743DA540);
}

void webrtc::TurnPort::set_realm(uint64_t a1, char *__src, size_t __len)
{
  if (__len)
  {
    v6 = a1 + 1168;
    v7 = *(a1 + 1191);
    if (v7 < 0)
    {
      v8 = *(a1 + 1168);
      if (__len != *(a1 + 1176))
      {
        goto LABEL_10;
      }
    }

    else
    {
      v8 = (a1 + 1168);
      if (__len != v7)
      {
LABEL_10:
        if (__len < 0x7FFFFFFFFFFFFFF8)
        {
          if (__len > 0x16)
          {
            operator new();
          }

          HIBYTE(v17) = __len;
          if (&__dst > __src || &__dst + __len <= __src)
          {
            memmove(&__dst, __src, __len);
            *(&__dst + __len) = 0;
            if (*(a1 + 1191) < 0)
            {
              operator delete(*v6);
            }

            *v6 = __dst;
            *(v6 + 16) = v17;
            webrtc::ComputeStunCredentialHash(a1 + 984, v6, (a1 + 1008));
          }

          __break(1u);
        }

        std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
      }
    }

    if (memcmp(__src, v8, __len))
    {
      goto LABEL_10;
    }
  }

  else if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
  {
    webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v9, v10, v11, v12, v13, v14, v15, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  }
}

uint64_t webrtc::TurnPort::GetTlsAlpnProtocols@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = *(this + 928);
  v3 = *(this + 936);
  if (v3 != v2)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((v3 - v2) >> 3) < 0xAAAAAAAAAAAAAABLL)
    {
      operator new();
    }

    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  return this;
}

uint64_t webrtc::TurnPort::GetTlsEllipticCurves@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = *(this + 952);
  v3 = *(this + 960);
  if (v3 != v2)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((v3 - v2) >> 3) < 0xAAAAAAAAAAAAAABLL)
    {
      operator new();
    }

    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  return this;
}

uint64_t webrtc::TurnPort::PrepareAddress(uint64_t this)
{
  v1 = this;
  if ((*(this + 1007) & 0x8000000000000000) != 0)
  {
    if (!*(this + 992))
    {
      goto LABEL_18;
    }
  }

  else if (!*(this + 1007))
  {
LABEL_18:
    if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)3>() & 1) == 0)
    {
      (*(*v1 + 176))(&v60, v1);
      webrtc::webrtc_logging_impl::Log("\r\n\t", v10, v11, v12, v13, v14, v15, v16, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (SHIBYTE(v63) < 0)
      {
        operator delete(v60);
      }
    }

    webrtc::TurnPort::OnAllocateError(v1);
  }

  if ((*(this + 1031) & 0x8000000000000000) != 0)
  {
    if (!*(this + 1016))
    {
      goto LABEL_18;
    }
  }

  else if (!*(this + 1031))
  {
    goto LABEL_18;
  }

  if (*(this + 872))
  {
    v2 = *(this + 872);
    if (v2 <= 0x3FF && v2 != 53 && v2 != 80 && v2 != 443)
    {
      if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)3>() & 1) == 0)
      {
        (*(*v1 + 176))(&v60, v1);
        webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v3, v4, v5, v6, v7, v8, v9, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
        if (SHIBYTE(v63) < 0)
        {
          operator delete(v60);
        }
      }

      webrtc::TurnPort::OnAllocateError(v1);
    }
  }

  else
  {
    *(this + 872) = 3478;
  }

  if (!*(this + 848) && (*(this + 880) & 1) == 0)
  {
    v17 = *(this + 839);
    if (v17 < 0)
    {
      v17 = *(this + 824);
    }

    if (v17)
    {
      if (!*(this + 1088))
      {
        if (!webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
        {
          (*(*v1 + 176))(&v60, v1);
          webrtc::SocketAddress::ToSensitiveString((v1 + 816), v58);
          webrtc::webrtc_logging_impl::Log("\r\n\t\n", v42, v43, v44, v45, v46, v47, v48, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
          if (SHIBYTE(v59) < 0)
          {
            operator delete(v58[0]);
          }

          if (SHIBYTE(v63) < 0)
          {
            operator delete(v60);
          }
        }

        v49 = (*(*v1 + 216))(v1);
        (*(*v49 + 40))(&v60);
        v50 = v60;
        v60 = 0;
        v51 = *(v1 + 1088);
        *(v1 + 1088) = v50;
        if (v51)
        {
          (*(*v51 + 8))(v51);
          v52 = v60;
          v60 = 0;
          if (v52)
          {
            (*(*v52 + 8))(v52);
          }
        }

        v53 = *(v1 + 1088);
        v54 = *((*(*v1 + 24))(v1) + 184);
        v60 = v1;
        v64 = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::TurnPort::ResolveTurnAddress(webrtc::SocketAddress const&)::$_0 &>;
        v63 = absl::internal_any_invocable::LocalManagerTrivial;
        (*(*v53 + 24))(v53, v1 + 816, v54, &v60);
        return (v63)(1, &v60, &v60);
      }

      return this;
    }
  }

  webrtc::Network::GetBestIP(*(this + 576), &v60);
  v18 = *(v1 + 848);
  if (v18 != v61 || v18 == 30 && ((v62 & 0xC0FF) == 33022) != ((*(v1 + 852) & 0xC0FFLL) == 33022))
  {
    if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)3>() & 1) == 0)
    {
      v58[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc";
      v58[1] = 3019;
      v59 = &v57;
      (*(*v1 + 176))(&__p, v1);
      v19 = (*(*v1 + 24))(v1);
      webrtc::Network::GetBestIP(v19, &v60);
      webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v20, v21, v22, v23, v24, v25, v26, v58[0]);
      if (v56 < 0)
      {
        operator delete(__p);
      }
    }

    v27 = v1;
    goto LABEL_50;
  }

  std::__tree<webrtc::SocketAddress>::__emplace_unique_key_args<webrtc::SocketAddress,webrtc::SocketAddress const&>(v1 + 1032, (v1 + 816));
  if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>() & 1) == 0)
  {
    (*(*v1 + 176))(&v60, v1);
    webrtc::SocketAddress::ToSensitiveNameAndAddressString((v1 + 816), v58);
    webrtc::webrtc_logging_impl::Log("\r\n\t\t\t\n", v28, v29, v30, v31, v32, v33, v34, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (SHIBYTE(v59) < 0)
    {
      operator delete(v58[0]);
    }

    if (SHIBYTE(v63) < 0)
    {
      operator delete(v60);
    }
  }

  this = webrtc::TurnPort::CreateTurnClientSocket(v1);
  if ((this & 1) == 0)
  {
    if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)3>() & 1) == 0)
    {
      (*(*v1 + 176))(&v60, v1);
      webrtc::webrtc_logging_impl::Log("\r\n\t", v35, v36, v37, v38, v39, v40, v41, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (SHIBYTE(v63) < 0)
      {
        operator delete(v60);
      }
    }

    v27 = v1;
LABEL_50:
    webrtc::TurnPort::OnAllocateError(v27);
  }

  if (!*(v1 + 888))
  {
    operator new();
  }

  return this;
}

void webrtc::TurnPort::OnAllocateError(void *a1)
{
  (*(*a1 + 208))(a1);
  v2 = a1[165];
  if (v2)
  {
    atomic_fetch_add_explicit(v2, 1u, memory_order_relaxed);
  }

  operator new();
}

uint64_t webrtc::TurnPort::CreateTurnClientSocket(webrtc::TurnPort *this)
{
  v47 = *MEMORY[0x277D85DE8];
  v2 = *(this + 222);
  if (v2)
  {
    if (v2 != 1)
    {
LABEL_3:
      if (v2 != 3)
      {
        goto LABEL_34;
      }

      if (*(this + 230) == 1)
      {
        v3 = 12;
      }

      else
      {
        v3 = 6;
      }

LABEL_10:
      v37 = 0;
      v36 = 0u;
      memset(v35, 0, sizeof(v35));
      v34 = v3;
      if (v35 != (this + 928))
      {
        std::vector<std::string>::__assign_with_size[abi:sn200100]<std::string*,std::string*>(v35, *(this + 116), *(this + 117), 0xAAAAAAAAAAAAAAABLL * ((*(this + 117) - *(this + 116)) >> 3));
      }

      if (&v35[3] != (this + 952))
      {
        std::vector<std::string>::__assign_with_size[abi:sn200100]<std::string*,std::string*>(&v35[3], *(this + 119), *(this + 120), 0xAAAAAAAAAAAAAAABLL * ((*(this + 120) - *(this + 119)) >> 3));
      }

      v37 = *(this + 122);
      v4 = (*(*this + 216))(this);
      v5 = (*(*this + 24))(this);
      webrtc::Network::GetBestIP(v5, v31);
      __p = 0;
      v39 = 0;
      v40 = 0;
      v41 = &unk_28828CE50;
      v46 = 0;
      v42 = v32;
      v43 = v33;
      v45 = 0;
      v44 = 0;
      *(this + 132) = (*(*v4 + 32))(v4, &__p, this + 816, &v34);
      if (SHIBYTE(v40) < 0)
      {
        operator delete(__p);
      }

      v6 = v35[3];
      if (v35[3])
      {
        v7 = v36;
        v8 = v35[3];
        if (v36 != v35[3])
        {
          do
          {
            v9 = *(v7 - 1);
            v7 -= 3;
            if (v9 < 0)
            {
              operator delete(*v7);
            }
          }

          while (v7 != v6);
          v8 = v35[3];
        }

        *&v36 = v6;
        operator delete(v8);
      }

      v10 = v35[0];
      if (v35[0])
      {
        v11 = v35[1];
        v12 = v35[0];
        if (v35[1] != v35[0])
        {
          do
          {
            v13 = *(v11 - 1);
            v11 -= 3;
            if (v13 < 0)
            {
              operator delete(*v11);
            }
          }

          while (v11 != v10);
          v12 = v35[0];
        }

        v35[1] = v10;
        goto LABEL_32;
      }

      goto LABEL_34;
    }

LABEL_9:
    v3 = 4;
    goto LABEL_10;
  }

  if ((*(*this + 64))(this))
  {
    v2 = *(this + 222);
    if (v2 != 1)
    {
      goto LABEL_3;
    }

    goto LABEL_9;
  }

  v14 = (*(*this + 216))(this);
  v15 = (*(*this + 24))(this);
  webrtc::Network::GetBestIP(v15, &v34);
  __p = 0;
  v39 = 0;
  v40 = 0;
  v41 = &unk_28828CE50;
  v46 = 0;
  v42 = v35[0];
  v43 = *(v35 + 4);
  v45 = 0;
  v44 = 0;
  *(this + 132) = (*(*v14 + 16))(v14, &__p, *(this + 292), *(this + 293));
  if (SHIBYTE(v40) < 0)
  {
    v12 = __p;
LABEL_32:
    operator delete(v12);
  }

LABEL_34:
  if (*(this + 132))
  {
    v16 = *(this + 133);
    if (v16 != (this + 1072))
    {
      do
      {
        (*(**(this + 132) + 72))(*(this + 132), *(v16 + 7), *(v16 + 8));
        v24 = *(v16 + 1);
        if (v24)
        {
          do
          {
            v25 = v24;
            v24 = *v24;
          }

          while (v24);
        }

        else
        {
          do
          {
            v25 = *(v16 + 2);
            v26 = *v25 == v16;
            v16 = v25;
          }

          while (!v26);
        }

        v16 = v25;
      }

      while (v25 != (this + 1072));
    }

    if (((*(*this + 64))(this) & 1) == 0)
    {
      v23 = *(this + 132);
      v28.n128_u64[0] = this;
      v30 = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::TurnPort::CreateTurnClientSocket(void)::$_0 &,webrtc::AsyncPacketSocket *,webrtc::ReceivedIpPacket const&>;
      v29 = absl::internal_any_invocable::LocalManagerTrivial;
      webrtc::AsyncPacketSocket::RegisterReceivedPacketCallback(v23, &v28, v17, v18, v19, v20, v21, v22);
      v29(1, &v28, &v28);
    }

    operator new();
  }

  *(this + 274) = -1;
  return 0;
}

void webrtc::TurnPort::OnSocketConnect(webrtc::TurnPort *this, webrtc::AsyncPacketSocket *a2)
{
  (*(*a2 + 16))(&v64, a2);
  v4 = (*(*this + 24))(this);
  memset(__p, 0, 24);
  memset(&__p[4], 0, 20);
  __p[3] = &unk_28828CE50;
  if (SHIBYTE(v65) < 0)
  {
    std::string::__assign_no_alias<true>(__p, v64, *(&v64 + 1));
  }

  else
  {
    *__p = v64;
    __p[2] = v65;
  }

  v5 = v66;
  LODWORD(__p[4]) = v66;
  *(&__p[4] + 4) = v67;
  v6 = v68;
  v61 = v68;
  v7 = v70;
  v63 = v70;
  v8 = v69;
  v62 = v69;
  v10 = *(v4 + 240);
  v9 = *(v4 + 248);
  memset(__dst, 0, 24);
  memset(&__dst[4], 0, 20);
  __dst[3] = &unk_28828CE50;
  if (SHIBYTE(__p[2]) < 0)
  {
    std::string::__assign_no_alias<true>(__dst, __p[0], __p[1]);
    v5 = __p[4];
    v6 = v61;
    v7 = v63;
    v8 = v62;
  }

  else
  {
    *__dst = *__p;
    __dst[2] = __p[2];
  }

  LODWORD(__dst[4]) = v5;
  *(&__dst[4] + 4) = *(&__p[4] + 4);
  v72 = v6;
  v74 = v7;
  v73 = v8;
  if (v10 == v9)
  {
    v14 = 1;
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
    {
      goto LABEL_45;
    }
  }

  else
  {
    if (v5 == 30)
    {
      v16 = v10 + 32;
      while (1)
      {
        if (*(v16 - 24) == 30)
        {
          v12 = *(&__dst[4] + 4) == *(v16 - 20) && *(&__dst[5] + 4) == *(v16 - 12);
          if (v12)
          {
            goto LABEL_43;
          }
        }

        else
        {
          v12 = 0;
        }

        v13 = v16 == v9;
        v16 += 32;
        if (v13)
        {
          goto LABEL_43;
        }
      }
    }

    if (v5 == 2)
    {
      v15 = v10 + 32;
      do
      {
        if (*(v15 - 24) == 2)
        {
          v12 = HIDWORD(__dst[4]) == *(v15 - 20);
          if (HIDWORD(__dst[4]) == *(v15 - 20))
          {
            break;
          }
        }

        else
        {
          v12 = 0;
        }

        v13 = v15 == v9;
        v15 += 32;
      }

      while (!v13);
    }

    else if (v5)
    {
      v12 = 0;
    }

    else
    {
      v11 = v10 + 32;
      do
      {
        v12 = *(v11 - 24) == 0;
        if (*(v11 - 24))
        {
          v13 = v11 == v9;
        }

        else
        {
          v13 = 1;
        }

        v11 += 32;
      }

      while (!v13);
    }

LABEL_43:
    v14 = !v12;
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
    {
LABEL_45:
      if (SHIBYTE(__p[2]) < 0)
      {
        operator delete(__p[0]);
        if (!v14)
        {
          goto LABEL_85;
        }
      }

      else if (!v14)
      {
        goto LABEL_85;
      }

      (*(*a2 + 16))(__dst, a2);
      IsLoopbackIP = webrtc::SocketAddress::IsLoopbackIP(__dst);
      if (SHIBYTE(__dst[2]) < 0)
      {
        v28 = IsLoopbackIP;
        operator delete(__dst[0]);
        if (v28)
        {
          goto LABEL_51;
        }
      }

      else if (IsLoopbackIP)
      {
LABEL_51:
        if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
        {
          goto LABEL_85;
        }

        __dst[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc";
        __dst[1] = 4010;
        __dst[2] = &v59;
        (*(*this + 176))(__p, this);
        webrtc::SocketAddress::ToSensitiveNameAndAddressString(&v64, &v54);
        v19 = (*(*this + 24))(this);
        webrtc::Network::ToString(v19, &v58);
        v27 = __dst[0];
LABEL_82:
        webrtc::webrtc_logging_impl::Log("\r\n\t\n\t\n\t", v20, v21, v22, v23, v24, v25, v26, v27);
        if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v58.__r_.__value_.__l.__data_);
          if ((SBYTE3(v57) & 0x80000000) == 0)
          {
LABEL_84:
            if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
            {
              goto LABEL_85;
            }

            goto LABEL_96;
          }
        }

        else if ((SBYTE3(v57) & 0x80000000) == 0)
        {
          goto LABEL_84;
        }

        operator delete(v54);
        if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
        {
          goto LABEL_85;
        }

LABEL_96:
        operator delete(__p[0]);
        *(this + 318) = 1;
        if (*(this + 212))
        {
          goto LABEL_108;
        }

        goto LABEL_86;
      }

      v29 = (*(*this + 24))(this);
      webrtc::Network::GetBestIP(v29, &v54);
      if (v55 == 2)
      {
        v34 = v56;
        v33 = webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>();
        if (!v34)
        {
          goto LABEL_67;
        }
      }

      else
      {
        if (v55 != 30)
        {
          if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
          {
            goto LABEL_76;
          }

          goto LABEL_73;
        }

        *(&__dst[1] + 4) = *MEMORY[0x277D85EE8];
        if (v56 == *(&__dst[1] + 4) && v57 == *(&__dst[2] + 4))
        {
          if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
          {
            goto LABEL_85;
          }

LABEL_81:
          __dst[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc";
          __dst[1] = 4058;
          __dst[2] = &v59;
          (*(*this + 176))(__p, this);
          webrtc::SocketAddress::ToSensitiveNameAndAddressString(&v64, &v54);
          v43 = (*(*this + 24))(this);
          webrtc::Network::ToString(v43, &v58);
          v27 = __dst[0];
          goto LABEL_82;
        }

        *(&__p[1] + 4) = webrtc::kV4MappedPrefix;
        v32 = v56 != webrtc::kV4MappedPrefix || v57 != *(&webrtc::kV4MappedPrefix + 1);
        v33 = webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>();
        if (!v32)
        {
LABEL_67:
          if (v33)
          {
LABEL_85:
            *(this + 318) = 1;
            if (*(this + 212))
            {
              goto LABEL_108;
            }

LABEL_86:
            if ((*(this + 880) & 1) == 0)
            {
              v44 = *(this + 839);
              if (v44 < 0)
              {
                v44 = *(this + 103);
              }

              if (v44)
              {
                (*(**(this + 132) + 24))(__dst);
                if ((this + 816) != __dst)
                {
                  if (*(this + 839) < 0)
                  {
                    if (__dst[2] >= 0)
                    {
                      v45 = __dst;
                    }

                    else
                    {
                      v45 = __dst[0];
                    }

                    if (__dst[2] >= 0)
                    {
                      v46 = HIBYTE(__dst[2]);
                    }

                    else
                    {
                      v46 = __dst[1];
                    }

                    std::string::__assign_no_alias<false>(this + 34, v45, v46);
                  }

                  else if ((__dst[2] & 0x8000000000000000) != 0)
                  {
                    std::string::__assign_no_alias<true>(this + 816, __dst[0], __dst[1]);
                  }

                  else
                  {
                    *(this + 51) = *__dst;
                    *(this + 104) = __dst[2];
                  }
                }

                *(this + 212) = __dst[4];
                *(this + 852) = *(&__dst[4] + 4);
                *(this + 436) = v72;
                *(this + 880) = v74;
                *(this + 219) = v73;
                if (SHIBYTE(__dst[2]) < 0)
                {
                  operator delete(__dst[0]);
                }
              }
            }

LABEL_108:
            if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
            {
              goto LABEL_111;
            }

            (*(*a2 + 24))(__dst, a2);
            webrtc::SocketAddress::ToSensitiveString(__dst, __p);
            webrtc::webrtc_logging_impl::Log("\r\t\n\t", v47, v48, v49, v50, v51, v52, v53, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
            if (SHIBYTE(__p[2]) < 0)
            {
              operator delete(__p[0]);
              if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
              {
                goto LABEL_111;
              }
            }

            else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
            {
              goto LABEL_111;
            }

            operator delete(__dst[0]);
LABEL_111:
            operator new();
          }

          goto LABEL_81;
        }
      }

      if (v33)
      {
LABEL_76:
        webrtc::TurnPort::OnAllocateError(this);
      }

LABEL_73:
      __dst[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc";
      __dst[1] = 4122;
      __dst[2] = &v59;
      (*(*this + 176))(__p, this);
      webrtc::SocketAddress::ToSensitiveNameAndAddressString(&v64, &v54);
      v35 = (*(*this + 24))(this);
      webrtc::Network::ToString(v35, &v58);
      webrtc::webrtc_logging_impl::Log("\r\n\t\n\t\n\t", v36, v37, v38, v39, v40, v41, v42, __dst[0]);
      if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v58.__r_.__value_.__l.__data_);
        if ((SBYTE3(v57) & 0x80000000) == 0)
        {
LABEL_75:
          if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
          {
            goto LABEL_76;
          }

LABEL_79:
          operator delete(__p[0]);
          goto LABEL_76;
        }
      }

      else if ((SBYTE3(v57) & 0x80000000) == 0)
      {
        goto LABEL_75;
      }

      operator delete(v54);
      if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
      {
        goto LABEL_76;
      }

      goto LABEL_79;
    }
  }

  operator delete(__dst[0]);
  goto LABEL_45;
}

uint64_t webrtc::TurnPort::CreateConnection(_DWORD *a1, uint64_t a2)
{
  v4 = *(a2 + 55);
  v5 = *(a2 + 40);
  if ((v4 & 0x80u) == 0)
  {
    v6 = a2 + 32;
  }

  else
  {
    v6 = *(a2 + 32);
  }

  if ((v4 & 0x80u) == 0)
  {
    v7 = v4;
  }

  else
  {
    v7 = v5;
  }

  if ((*(*a1 + 72))(a1, v6, v7) && (a1[318] - 3) >= 2)
  {
    v8 = *(a2 + 103);
    v9 = v8;
    if ((v8 & 0x80u) != 0)
    {
      v8 = *(a2 + 88);
    }

    if (v8 < 6 || (v9 >= 0 ? (v10 = a2 + 80) : (v10 = *(a2 + 80)), (v11 = v10 + v8, v12 = *(v11 - 6), v13 = *(v11 - 2), v12 == *".local") ? (v14 = v13 == *"al") : (v14 = 0), !v14))
    {
      v15 = (*(*a1 + 136))(a1);
      if (v15[1] != *v15)
      {
        v16 = 0;
        v17 = 0;
        do
        {
          v19 = (*(*a1 + 136))(a1);
          if (0x84BDA12F684BDA13 * ((v19[1] - *v19) >> 4) <= v17)
          {
            __break(1u);
            std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
          }

          v20 = *v19 + v16;
          if (*(v20 + 208) == 3 && *(v20 + 112) == *(a2 + 112))
          {
            operator new();
          }

          ++v17;
          v18 = (*(*a1 + 136))(a1);
          v16 += 432;
        }

        while (v17 < 0x84BDA12F684BDA13 * ((v18[1] - *v18) >> 4));
      }
    }
  }

  return 0;
}

uint64_t webrtc::TurnPort::SetOption(uint64_t a1, int a2, int a3)
{
  if (a2 == 5)
  {
    *(a1 + 1100) = a3;
  }

  v4 = *(a1 + 1056);
  if (v4)
  {
    v5 = *(*v4 + 72);

    return v5();
  }

  else
  {
    v7 = *(a1 + 1072);
    if (!v7)
    {
LABEL_14:
      operator new();
    }

    while (1)
    {
      while (1)
      {
        v8 = v7;
        v9 = *(v7 + 7);
        if (v9 <= a2)
        {
          break;
        }

        v7 = *v8;
        if (!*v8)
        {
          goto LABEL_14;
        }
      }

      if (v9 >= a2)
      {
        break;
      }

      v7 = v8[1];
      if (!v7)
      {
        goto LABEL_14;
      }
    }

    *(v8 + 8) = a3;
    return 0;
  }
}

uint64_t webrtc::TurnPort::GetOption(uint64_t a1, int a2, _DWORD *a3)
{
  v4 = *(a1 + 1056);
  if (v4)
  {
    return (*(*v4 + 64))();
  }

  v6 = *(a1 + 1072);
  if (!v6)
  {
    return 0xFFFFFFFFLL;
  }

  v7 = a1 + 1072;
  v8 = a1 + 1072;
  do
  {
    if (*(v6 + 28) >= a2)
    {
      v8 = v6;
    }

    v6 = *(v6 + 8 * (*(v6 + 28) < a2));
  }

  while (v6);
  if (v8 == v7 || *(v8 + 28) > a2)
  {
    return 0xFFFFFFFFLL;
  }

  result = 0;
  *a3 = *(v8 + 32);
  return result;
}

uint64_t webrtc::TurnPort::SendTo(webrtc::TurnPort *this, const void *a2, unint64_t a3, const webrtc::SocketAddress *a4, const webrtc::AsyncSocketPacketOptions *a5)
{
  v7 = *(this + 156);
  v8 = *(this + 157);
  if (v7 != v8)
  {
    while (!webrtc::SocketAddress::operator==(*v7 + 104, a4))
    {
      if (++v7 == v8)
      {
        v7 = v8;
        break;
      }
    }

    v8 = *(this + 157);
  }

  if (v7 == v8)
  {
    if (*(this + 318) == 2)
    {
LABEL_8:
      v11 = *(a5 + 3);
      v10 = *(a5 + 4);
      if (v10 != v11)
      {
        if (((v10 - v11) & 0x8000000000000000) == 0)
        {
          operator new();
        }

        std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
      }

      (*(*this + 128))(this);
      (*(*this + 24))(this);
      operator new[]();
    }
  }

  else if (*(this + 318) == 2)
  {
    goto LABEL_8;
  }

  *(this + 274) = 57;
  return 0xFFFFFFFFLL;
}

uint64_t webrtc::TurnPort::SendBindingErrorResponse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  result = (*(*a1 + 88))(a1, a3);
  if (result)
  {

    webrtc::Port::SendBindingErrorResponse(a1, a2, a3, a4, a5, a6);
  }

  return result;
}

uint64_t webrtc::TurnPort::HandleIncomingPacket(void *a1, uint64_t a2, char **a3)
{
  if (a1[132] != a2)
  {
    return 0;
  }

  v68 = v3;
  v69 = v4;
  if (!webrtc::SocketAddress::operator==(a3[4], (a1 + 102)))
  {
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
    {
      return 0;
    }

    (*(*a1 + 176))(v63, a1);
    webrtc::SocketAddress::ToSensitiveNameAndAddressString(a3[4], &v61);
    webrtc::SocketAddress::ToSensitiveNameAndAddressString((a1 + 102), &__p);
    webrtc::webrtc_logging_impl::Log("\r\n\t\n\t\n", v16, v17, v18, v19, v20, v21, v22, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (v60 < 0)
    {
      operator delete(__p);
      if ((v62 & 0x80000000) == 0)
      {
LABEL_11:
        if (SHIBYTE(v64) < 0)
        {
          goto LABEL_26;
        }

        return 0;
      }
    }

    else if ((v62 & 0x80000000) == 0)
    {
      goto LABEL_11;
    }

    operator delete(v61);
    if (SHIBYTE(v64) < 0)
    {
      goto LABEL_26;
    }

    return 0;
  }

  v8 = a3[1];
  if (v8 <= 3)
  {
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
    {
      return 0;
    }

    (*(*a1 + 176))(v63, a1);
    webrtc::webrtc_logging_impl::Log("\r\n\t", v9, v10, v11, v12, v13, v14, v15, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if ((SHIBYTE(v64) & 0x80000000) == 0)
    {
      return 0;
    }

    goto LABEL_26;
  }

  if (*(a1 + 318) == 4)
  {
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
    {
      return 0;
    }

    (*(*a1 + 176))(v63, a1);
    webrtc::webrtc_logging_impl::Log("\r\n\t", v23, v24, v25, v26, v27, v28, v29, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if ((SHIBYTE(v64) & 0x80000000) == 0)
    {
      return 0;
    }

    goto LABEL_26;
  }

  v30 = a3;
  v31 = *a3;
  if (v30[3])
  {
    v32 = v30[2];
  }

  else
  {
    v32 = -1;
  }

  v33 = *v31;
  v34 = __rev16(v33);
  if ((v34 & 0xC000) != 0x4000)
  {
    if (v33 == 5888)
    {
      webrtc::TurnPort::HandleDataIndication(a1, v31, v8, v32);
      return 1;
    }

    v39 = (*(*a1 + 64))(a1);
    if ((v34 & 0xFFFFFFEF) != 0x101 || v39 == 0)
    {
      webrtc::StunRequestManager::CheckResponse((a1 + 138), v31, v8);
      return 1;
    }

    v51 = webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)0>();
    if (v51)
    {
      return 0;
    }

    (*(*a1 + 176))(v63, a1);
    webrtc::webrtc_logging_impl::Log("\r\n\t", v52, v53, v54, v55, v56, v57, v58, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if ((SHIBYTE(v64) & 0x80000000) == 0)
    {
      return 0;
    }

LABEL_26:
    operator delete(v63[0]);
    return 0;
  }

  v35 = v8;
  v36 = __rev16(*(v31 + 1));
  if (v35 - 4 >= v36)
  {
    v37 = a1[156];
    v38 = a1[157];
    if (v37 != v38)
    {
      while (*(*v37 + 96) != v34)
      {
        if (++v37 == v38)
        {
          goto LABEL_47;
        }
      }
    }

    if (v37 != v38)
    {
      v41 = *v37;
      if (v41)
      {
        if (*(v31 + 1))
        {
          v42 = v31 + 4;
        }

        else
        {
          v42 = 0;
        }

        v63[0] = v42;
        v63[1] = v36;
        v64 = v32 & ~(v32 >> 63);
        v65 = v32 >= 0;
        v66 = v41 + 104;
        v67 = 0;
        v43 = (*(*a1 + 88))(a1);
        if (v43)
        {
          webrtc::Connection::OnReadPacket(v43, v63);
        }

        else
        {
          webrtc::Port::OnReadPacket(a1, v63, 0);
        }

        return 1;
      }
    }

LABEL_47:
    if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
    {
      goto LABEL_48;
    }
  }

  else if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
  {
LABEL_48:
    (*(*a1 + 176))(v63, a1);
    webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v44, v45, v46, v47, v48, v49, v50, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (SHIBYTE(v64) < 0)
    {
      operator delete(v63[0]);
    }
  }

  return 1;
}

void webrtc::TurnPort::HandleDataIndication(webrtc::TurnPort *this, const char *a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v46[0] = v6;
  v46[1] = a3;
  v46[2] = 0;
  v46[3] = a3;
  webrtc::StunMessage::StunMessage(&v43, 0, "0000000000000000", 0x10uLL);
  v43 = &unk_2882A0418;
  if (webrtc::StunMessage::Read(&v43, v46))
  {
    v7 = v44;
    if (v44 == v45)
    {
LABEL_9:
      if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
      {
        goto LABEL_20;
      }
    }

    else
    {
      v8 = v44;
      while (1)
      {
        v9 = *v8;
        if (*(*v8 + 8) == 18)
        {
          break;
        }

        if (++v8 == v45)
        {
          goto LABEL_9;
        }
      }

      do
      {
        v10 = *v7;
        if (*(*v7 + 8) == 19)
        {
          __p[0] = 0;
          __p[1] = 0;
          memset(v39, 0, sizeof(v39));
          v37 = 0;
          v38 = &unk_28828CE50;
          if (__p != (v9 + 16))
          {
            if (*(v9 + 39) < 0)
            {
              std::string::__assign_no_alias<true>(__p, *(v9 + 16), *(v9 + 24));
            }

            else
            {
              *__p = *(v9 + 16);
              v37 = *(v9 + 32);
            }
          }

          v18 = *(v9 + 48);
          *v39 = v18;
          *&v39[4] = *(v9 + 52);
          v40 = *(v9 + 72);
          v42 = *(v9 + 80);
          v41 = *(v9 + 76);
          for (i = *(this + 156); i != *(this + 157); ++i)
          {
            v23 = *i;
            if (*(*i + 136) == v18)
            {
              switch(v18)
              {
                case 2:
                  if (*(v23 + 140) == *&v39[4])
                  {
                    goto LABEL_43;
                  }

                  break;
                case 30:
                  v20 = *(v23 + 140);
                  v21 = *(v23 + 148);
                  if (v20 == *&v39[4] && v21 == *&v39[12])
                  {
                    goto LABEL_43;
                  }

                  break;
                case 0:
                  goto LABEL_43;
              }
            }
          }

          if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
          {
            (*(*this + 176))(v47, this);
            webrtc::SocketAddress::ToSensitiveString(__p, &v34);
            webrtc::webrtc_logging_impl::Log("\r\n\t\n", v24, v25, v26, v27, v28, v29, v30, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
            if (v35 < 0)
            {
              operator delete(v34);
            }

            if (SHIBYTE(v48) < 0)
            {
              operator delete(v47[0]);
            }
          }

LABEL_43:
          v31 = *(v10 + 16);
          v32 = *(v10 + 10);
          if (!*(v10 + 10))
          {
            v31 = 0;
          }

          v47[0] = v31;
          v47[1] = v32;
          v48 = a4 & ~(a4 >> 63);
          v49 = a4 >= 0;
          v50 = __p;
          v51 = 0;
          v33 = (*(*this + 88))(this, __p);
          if (v33)
          {
            webrtc::Connection::OnReadPacket(v33, v47);
          }

          else
          {
            webrtc::Port::OnReadPacket(this, v47, 0);
          }

          goto LABEL_18;
        }

        ++v7;
      }

      while (v7 != v45);
      if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
      {
        goto LABEL_20;
      }
    }
  }

  else if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
  {
    goto LABEL_20;
  }

  (*(*this + 176))(__p, this);
  webrtc::webrtc_logging_impl::Log("\r\n\t", v11, v12, v13, v14, v15, v16, v17, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
LABEL_18:
  if (SHIBYTE(v37) < 0)
  {
    operator delete(__p[0]);
  }

LABEL_20:
  webrtc::StunMessage::~StunMessage(&v43);
}

uint64_t webrtc::TurnPort::OnSentPacket(webrtc::TurnPort *this, webrtc::AsyncPacketSocket *a2, const webrtc::SentPacketInfo *a3)
{
  v4 = this + 192;
  result = *(this + 25);
  for (*(this + 27) = result; result != v4; result = *(this + 27))
  {
    v8 = *(result + 16);
    v7 = result + 16;
    *(this + 27) = *(v7 - 8);
    v8(v7, a3);
  }

  return result;
}

uint64_t webrtc::TurnPort::OnReadyToSend(uint64_t this, webrtc::AsyncPacketSocket *a2)
{
  if (*(this + 1272) == 2)
  {
    v2 = *(this + 696);
    v3 = (this + 704);
    if (v2 != (this + 704))
    {
      do
      {
        v4 = v2[13];
        this = *(v4 + 144);
        for (*(v4 + 160) = this; this != v4 + 136; this = *(v4 + 160))
        {
          v6 = *(this + 16);
          v5 = this + 16;
          *(v4 + 160) = *(v5 - 8);
          v6(v5, v4);
        }

        v7 = v2[1];
        if (v7)
        {
          do
          {
            v8 = v7;
            v7 = *v7;
          }

          while (v7);
        }

        else
        {
          do
          {
            v8 = v2[2];
            v9 = *v8 == v2;
            v2 = v8;
          }

          while (!v9);
        }

        v2 = v8;
      }

      while (v8 != v3);
    }
  }

  return this;
}

BOOL webrtc::TurnPort::SupportsProtocol(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  if (a3 != 3)
  {
    return 0;
  }

  return *a2 == webrtc::UDP_PROTOCOL_NAME && *(a2 + 2) == 112;
}

void webrtc::TurnPort::OnSendStunPacket(webrtc::TurnPort *this, const void *a2, uint64_t a3, webrtc::StunRequest *a4)
{
  v18 = (*(*this + 272))(this, a2, a3, a4);
  v19 = 0;
  v20 = -1;
  v21 = -1;
  v23 = 0;
  v24 = 0;
  v22 = 0;
  v25 = -1;
  v26 = -1;
  v27 = 0;
  v28 = 0;
  v34 = 0;
  v35 = 0;
  v33 = 0;
  v36 = 0;
  v29 = 5;
  v7 = (*(*this + 128))(this);
  if (v7 < 4)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 0;
  }

  v30 = v8;
  v31 = *((*(*this + 24))(this) + 286);
  v32 = 1;
  if (((*(**(this + 132) + 40))(*(this + 132), a2, a3, this + 816, &v18) & 0x80000000) != 0 && (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)3>() & 1) == 0)
  {
    (*(*this + 176))(&__p, this);
    (*(**(this + 132) + 80))(*(this + 132));
    webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v9, v10, v11, v12, v13, v14, v15, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (v17 < 0)
    {
      operator delete(__p);
    }
  }

  if (v22)
  {
    v23 = v22;
    operator delete(v22);
  }
}

void webrtc::TurnPort::ScheduleRefresh(webrtc::TurnPort *this, unsigned int a2)
{
  if (a2 > 0x77)
  {
    if (a2 >= 0xE11 && (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
    {
      (*(*this + 176))(__p, this);
      webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)4,unsigned int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)4,unsigned int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v10, v11, v12, v13, v14, v15, v16, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (v18 < 0)
      {
        operator delete(__p[0]);
      }
    }
  }

  else if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
  {
    (*(*this + 176))(__p, this);
    webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)4,unsigned int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)4,unsigned int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v3, v4, v5, v6, v7, v8, v9, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (v18 < 0)
    {
      operator delete(__p[0]);
    }
  }

  operator new();
}

void webrtc::TurnPort::UpdateNonce(webrtc::TurnPort *this, webrtc::StunMessage *a2)
{
  v3 = *(a2 + 1);
  v4 = *(a2 + 2);
  if (v3 == v4)
  {
LABEL_4:
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)3>())
    {
      return;
    }

    (*(*this + 176))(__p, this);
    webrtc::webrtc_logging_impl::Log("\r\n\t", v6, v7, v8, v9, v10, v11, v12, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if ((SHIBYTE(v33) & 0x80000000) == 0)
    {
      return;
    }

    goto LABEL_18;
  }

  while (1)
  {
    v5 = *v3;
    if (*(*v3 + 8) == 20)
    {
      break;
    }

    if (++v3 == v4)
    {
      goto LABEL_4;
    }
  }

  v13 = *(v5 + 10);
  if (*(v5 + 16))
  {
    v14 = 1;
  }

  else
  {
    v14 = v13 == 0;
  }

  if (!v14)
  {
    goto LABEL_36;
  }

  webrtc::TurnPort::set_realm(this, *(v5 + 16), v13);
  v16 = *(a2 + 1);
  v17 = *(a2 + 2);
  if (v16 == v17)
  {
LABEL_15:
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)3>())
    {
      return;
    }

    (*(*this + 176))(__p, this);
    webrtc::webrtc_logging_impl::Log("\r\n\t", v19, v20, v21, v22, v23, v24, v25, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if ((SHIBYTE(v33) & 0x80000000) == 0)
    {
      return;
    }

LABEL_18:
    operator delete(__p[0]);
    return;
  }

  while (1)
  {
    v18 = *v16;
    if (*(*v16 + 8) == 21)
    {
      break;
    }

    if (++v16 == v17)
    {
      goto LABEL_15;
    }
  }

  v26 = *(v18 + 16);
  v27 = *(v18 + 10);
  if (v26)
  {
    v28 = 1;
  }

  else
  {
    v28 = v27 == 0;
  }

  if (!v28)
  {
    goto LABEL_36;
  }

  if (v27 > 0x16)
  {
    operator new();
  }

  HIBYTE(v33) = *(v18 + 10);
  v29 = (__p + v27);
  if (__p <= v26 && v29 > v26)
  {
LABEL_36:
    __break(1u);
    return;
  }

  if (v27)
  {
    memmove(__p, v26, v27);
  }

  *v29 = 0;
  v31 = (this + 1192);
  if (*(this + 1215) < 0)
  {
    operator delete(*v31);
  }

  *v31 = *__p;
  *(this + 151) = v33;
}

uint64_t webrtc::TurnPort::HandleConnectionDestroyed(webrtc::TurnPort *this, webrtc::Connection *a2)
{
  result = (*(*a2 + 24))(a2);
  v5 = *(this + 156);
  v6 = *(this + 157);
  if (v5 != v6)
  {
    v7 = result;
    while (1)
    {
      result = webrtc::SocketAddress::operator==(*v5 + 104, v7 + 80);
      if (result)
      {
        break;
      }

      if (++v5 == v6)
      {
        v5 = v6;
        break;
      }
    }

    v6 = *(this + 157);
  }

  if (v5 == v6)
  {
    v8 = 0;
    v9 = MEMORY[0xB8];
    v10 = MEMORY[0xC0];
    v11 = MEMORY[0xB8];
    if (MEMORY[0xB8] == MEMORY[0xC0])
    {
      goto LABEL_15;
    }

LABEL_11:
    v11 = v9;
    while (*v11 != a2)
    {
      if (++v11 == v10)
      {
        goto LABEL_14;
      }
    }

    goto LABEL_15;
  }

  v8 = *v5;
  v9 = v8[23];
  v10 = v8[24];
  v11 = v9;
  if (v9 != v10)
  {
    goto LABEL_11;
  }

LABEL_15:
  while (v10 == v11)
  {
LABEL_14:
    __break(1u);
  }

  v12 = v10 - (v11 + 1);
  if (v10 != v11 + 1)
  {
    result = memmove(v11, v11 + 1, v10 - (v11 + 1));
    v9 = v8[23];
  }

  v8[24] = v11 + v12;
  if (v9 == (v11 + v12))
  {
    v13 = v8[26];
    if (v13)
    {
      atomic_fetch_add_explicit(v13, 1u, memory_order_relaxed);
      (*(*this + 208))(this);
      atomic_fetch_add_explicit(v13, 1u, memory_order_relaxed);
      operator new();
    }
  }

  return result;
}

void webrtc::TurnAllocateRequest::OnSent(webrtc::TurnAllocateRequest *this)
{
  if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
  {
    goto LABEL_16;
  }

  (*(**(this + 7) + 176))(&v20);
  v9 = *(this + 2);
  v10 = *(v9 + 63);
  if ((v10 & 0x8000000000000000) == 0)
  {
    v11 = (v9 + 40);
    v12 = 2 * v10;
    if ((2 * v10) < 0x7FFFFFFFFFFFFFF8)
    {
      goto LABEL_4;
    }

LABEL_20:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  v11 = *(v9 + 40);
  v10 = *(v9 + 48);
  v12 = 2 * v10;
  if ((2 * v10) >= 0x7FFFFFFFFFFFFFF8)
  {
    goto LABEL_20;
  }

LABEL_4:
  if (v12 >= 0x17)
  {
    operator new();
  }

  v19 = v12;
  if (v12)
  {
    bzero(&__p, v12);
  }

  *(&__p + v12) = 0;
  p_p = __p;
  if (v19 >= 0)
  {
    p_p = &__p;
  }

  if (v10)
  {
    v14 = p_p + 1;
    do
    {
      v15 = *v11++;
      v14 += 2;
      --v10;
    }

    while (v10);
  }

  webrtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (v19 < 0)
  {
    operator delete(__p);
    if (v21 < 0)
    {
      goto LABEL_22;
    }

LABEL_16:
    v16 = *(this + 8);
    *(this + 8) = v16 + 1;
    if (v16 < 8)
    {
      return;
    }

    goto LABEL_17;
  }

  if ((v21 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }

LABEL_22:
  operator delete(v20);
  v17 = *(this + 8);
  *(this + 8) = v17 + 1;
  if (v17 < 8)
  {
    return;
  }

LABEL_17:
  *(this + 36) = 1;
}

void webrtc::TurnAllocateRequest::OnResponse(webrtc::TurnAllocateRequest *this, webrtc::StunMessage *a2)
{
  if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
  {
    goto LABEL_23;
  }

  (*(**(this + 7) + 176))(&__p);
  v4 = *(this + 2);
  v5 = *(v4 + 63);
  if ((v5 & 0x8000000000000000) == 0)
  {
    v6 = (v4 + 40);
    v7 = 2 * v5;
    if ((2 * v5) < 0x7FFFFFFFFFFFFFF8)
    {
      goto LABEL_4;
    }

LABEL_17:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  v6 = *(v4 + 40);
  v5 = *(v4 + 48);
  v7 = 2 * v5;
  if ((2 * v5) >= 0x7FFFFFFFFFFFFFF8)
  {
    goto LABEL_17;
  }

LABEL_4:
  if (v7 >= 0x17)
  {
    operator new();
  }

  v39 = v7;
  if (v7)
  {
    bzero(&v38, v7);
  }

  *(&v38 + v7) = 0;
  v8 = &v38;
  if (v39 < 0)
  {
    v8 = v38;
  }

  if (v5)
  {
    v9 = v8 + 1;
    do
    {
      v10 = *v6++;
      v9 += 2;
      --v5;
    }

    while (v5);
  }

  if (webrtc::g_clock)
  {
    (*(*webrtc::g_clock + 16))(webrtc::g_clock);
  }

  else
  {
    if (!dword_28100D8E4)
    {
      mach_timebase_info(&webrtc::SystemTimeNanos(void)::timebase);
    }

    mach_absolute_time();
  }

  webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v11, v12, v13, v14, v15, v16, v17, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (v39 < 0)
  {
    operator delete(v38);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      goto LABEL_41;
    }

LABEL_23:
    v18 = *(a2 + 1);
    v19 = *(a2 + 2);
    if (v18 != v19)
    {
      goto LABEL_24;
    }

LABEL_27:
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
    {
      return;
    }

    goto LABEL_28;
  }

  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_23;
  }

LABEL_41:
  operator delete(__p.__r_.__value_.__l.__data_);
  v18 = *(a2 + 1);
  v19 = *(a2 + 2);
  if (v18 == v19)
  {
    goto LABEL_27;
  }

LABEL_24:
  v20 = v18;
  while (1)
  {
    v21 = *v20;
    if (*(*v20 + 8) == 32)
    {
      break;
    }

    if (++v20 == v19)
    {
      goto LABEL_27;
    }
  }

  v29 = v18;
  while (1)
  {
    v30 = *v29;
    if (*(*v29 + 8) == 22)
    {
      break;
    }

    if (++v29 == v19)
    {
      if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
      {
        return;
      }

      goto LABEL_28;
    }
  }

  do
  {
    v31 = *v18;
    if (*(*v18 + 8) == 13)
    {
      v32 = *(this + 7);
      *(v32 + 1272) = 2;
      memset(&__p, 0, sizeof(__p));
      memset(v42, 0, sizeof(v42));
      v41 = &unk_28828CE50;
      if (&__p != (v21 + 16))
      {
        if (*(v21 + 39) < 0)
        {
          std::string::__assign_no_alias<true>(&__p, *(v21 + 16), *(v21 + 24));
        }

        else
        {
          __p = *(v21 + 16);
        }
      }

      *v42 = *(v21 + 48);
      *&v42[4] = *(v21 + 52);
      v43 = *(v21 + 72);
      v45 = *(v21 + 80);
      v44 = *(v21 + 76);
      v33 = *(v32 + 888);
      v34 = strlen(*(&webrtc::PROTO_NAMES + v33));
      v35 = 2 * (v33 != 3);
      if (v33 == 1)
      {
        v35 = 1;
      }

      v36 = *(v32 + 919);
      if ((v36 & 0x8000000000000000) != 0)
      {
        v37 = *(v32 + 896);
        v36 = *(v32 + 904);
      }

      else
      {
        v37 = (v32 + 896);
      }

      webrtc::Port::AddAddress(v32, (v30 + 16), (v30 + 16), &__p, &webrtc::UDP_PROTOCOL_NAME, 3uLL, *(&webrtc::PROTO_NAMES + v33), v34, "", 0, 3, v35, *(v32 + 1276), v37, v36, 1u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      webrtc::TurnPort::ScheduleRefresh(*(this + 7), *(v31 + 12));
    }

    ++v18;
  }

  while (v18 != v19);
  if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
  {
    return;
  }

LABEL_28:
  (*(**(this + 7) + 176))(&__p);
  webrtc::webrtc_logging_impl::Log("\r\n\t", v22, v23, v24, v25, v26, v27, v28, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void webrtc::TurnAllocateRequest::OnErrorResponse(webrtc::TurnAllocateRequest *this, webrtc::StunMessage *a2)
{
  v4 = *(a2 + 1);
  v5 = *(a2 + 2);
  if (v4 == v5)
  {
LABEL_4:
    v6 = 600;
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
    {
      goto LABEL_28;
    }
  }

  else
  {
    while (*(*v4 + 8) != 9)
    {
      v4 += 8;
      if (v4 == v5)
      {
        goto LABEL_4;
      }
    }

    v6 = *(*v4 + 13) + 100 * *(*v4 + 12);
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
    {
      goto LABEL_28;
    }
  }

  (*(**(this + 7) + 176))(&__p);
  v7 = *(this + 2);
  v8 = *(v7 + 63);
  if (v8 < 0)
  {
    v9 = *(v7 + 40);
    v8 = *(v7 + 48);
    v10 = 2 * v8;
    if ((2 * v8) > 0x7FFFFFFFFFFFFFF7)
    {
      goto LABEL_97;
    }
  }

  else
  {
    v9 = (v7 + 40);
    v10 = 2 * v8;
    if ((2 * v8) > 0x7FFFFFFFFFFFFFF7)
    {
LABEL_97:
      std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
    }
  }

  if (v10 >= 0x17)
  {
    operator new();
  }

  v158 = v10;
  if (v10)
  {
    bzero(&v157, v10);
  }

  *(&v157 + v10) = 0;
  v11 = &v157;
  if (v158 < 0)
  {
    v11 = v157;
  }

  if (v8)
  {
    v12 = v11 + 1;
    do
    {
      v13 = *v9++;
      v12 += 2;
      --v8;
    }

    while (v8);
  }

  if (webrtc::g_clock)
  {
    (*(*webrtc::g_clock + 16))(webrtc::g_clock);
  }

  else
  {
    if (!dword_28100D8E4)
    {
      mach_timebase_info(&webrtc::SystemTimeNanos(void)::timebase);
    }

    mach_absolute_time();
  }

  webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v14, v15, v16, v17, v18, v19, v20, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (v158 < 0)
  {
    operator delete(v157);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      goto LABEL_50;
    }

LABEL_28:
    if (v6 != 300)
    {
      goto LABEL_29;
    }

LABEL_51:
    v39 = *(a2 + 1);
    v40 = *(a2 + 2);
    if (v39 == v40)
    {
      v42 = 0;
LABEL_65:
      if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
      {
LABEL_130:
        v90 = *(this + 7);
        if (v42)
        {
          if (*(v42 + 39) < 0)
          {
            v91 = *(this + 7);
            std::string::__init_copy_ctor_external(&__p, *(v42 + 16), *(v42 + 24));
            v90 = v91;
          }

          else
          {
            __p = *(v42 + 16);
          }
        }

        else
        {
          *(&__p.__r_.__value_.__s + 23) = 0;
          __p.__r_.__value_.__s.__data_[0] = 0;
        }

        webrtc::TurnPort::OnAllocateError(v90);
      }

      (*(**(this + 7) + 176))(&__p);
      goto LABEL_67;
    }

    v41 = *(a2 + 1);
    do
    {
      v42 = *v41;
      if (*(*v41 + 8) == 9)
      {
        goto LABEL_63;
      }

      ++v41;
    }

    while (v41 != v40);
    v42 = 0;
LABEL_63:
    while (1)
    {
      v46 = *v39;
      if (*(*v39 + 8) == 32803)
      {
        break;
      }

      if (++v39 == v40)
      {
        goto LABEL_65;
      }
    }

    v54 = *(this + 7);
    v55 = (v46 + 16);
    v56 = *(v54 + 1040);
    if (v56)
    {
      v57 = v54 + 1040;
      do
      {
        v58 = webrtc::SocketAddress::operator<((v56 + 32), (v46 + 16));
        if (v58)
        {
          v59 = 8;
        }

        else
        {
          v59 = 0;
        }

        if (!v58)
        {
          v57 = v56;
        }

        v56 = *(v56 + v59);
      }

      while (v56);
      if (v57 != v54 + 1040 && (webrtc::SocketAddress::operator<((v46 + 16), (v57 + 32)) & 1) == 0)
      {
        if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
        {
          goto LABEL_130;
        }

        (*(*v54 + 176))(&__p, v54);
        webrtc::SocketAddress::ToSensitiveNameAndAddressString((v46 + 16), &v157);
        webrtc::webrtc_logging_impl::Log("\r\n\t\n\t", v105, v106, v107, v108, v109, v110, v111, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
        if (v158 < 0)
        {
          operator delete(v157);
        }

        goto LABEL_68;
      }
    }

    webrtc::Network::GetBestIP(*(v54 + 576), &__p);
    v60 = *(v46 + 48);
    if (v60 != LODWORD(__p.__r_.__value_.__r.__words[1]) || v60 == 30 && ((WORD2(__p.__r_.__value_.__r.__words[1]) & 0xC0FF) == 33022) != ((*(v46 + 52) & 0xC0FFLL) == 33022))
    {
      if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
      {
        goto LABEL_130;
      }

LABEL_84:
      (*(*v54 + 176))(&__p, v54);
LABEL_67:
      webrtc::webrtc_logging_impl::Log("\r\n\t", v47, v48, v49, v50, v51, v52, v53, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
LABEL_68:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      goto LABEL_130;
    }

    if (webrtc::SocketAddress::IsLoopbackIP((v46 + 16)))
    {
      if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
      {
        goto LABEL_130;
      }

      goto LABEL_84;
    }

    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
    {
LABEL_141:
      v99 = (v54 + 816);
      v100 = *(v54 + 888);
      memset(&__p, 0, sizeof(__p));
      memset(v150, 0, sizeof(v150));
      v149 = &unk_28828CE50;
      if (&__p != v55)
      {
        if (*(v46 + 39) < 0)
        {
          std::string::__assign_no_alias<true>(&__p, *(v46 + 16), *(v46 + 24));
        }

        else
        {
          *&__p.__r_.__value_.__l.__data_ = *&v55->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = *(v46 + 32);
        }
      }

      *v150 = *(v46 + 48);
      *&v150[4] = *(v46 + 52);
      v151 = *(v46 + 72);
      v153 = *(v46 + 80);
      v152 = *(v46 + 76);
      v154 = v100;
      if (v99 != &__p)
      {
        if (*(v54 + 839) < 0)
        {
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_p = &__p;
          }

          else
          {
            p_p = __p.__r_.__value_.__r.__words[0];
          }

          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }

          std::string::__assign_no_alias<false>((v54 + 816), p_p, size);
        }

        else if ((*(&__p.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>((v54 + 816), __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }

        else
        {
          *&v99->__r_.__value_.__l.__data_ = *&__p.__r_.__value_.__l.__data_;
          *(v54 + 832) = *(&__p.__r_.__value_.__l + 2);
        }
      }

      *(v54 + 848) = *v150;
      *(v54 + 852) = *&v150[4];
      *(v54 + 872) = v151;
      *(v54 + 880) = v153;
      *(v54 + 876) = v152;
      *(v54 + 888) = v154;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      std::__tree<webrtc::SocketAddress>::__emplace_unique_key_args<webrtc::SocketAddress,webrtc::SocketAddress const&>(v54 + 1032, (v54 + 816));
      v117 = *(a2 + 1);
      v118 = *(a2 + 2);
      if (v117 == v118)
      {
        while (1)
        {
LABEL_197:
          if (v117 == v118)
          {
            goto LABEL_219;
          }

          v131 = *v117;
          if (*(*v117 + 8) == 21)
          {
            break;
          }

          ++v117;
        }

        if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>() & 1) == 0)
        {
          (*(**(this + 7) + 176))(&__p);
          webrtc::webrtc_logging_impl::Log("\r\n\t", v132, v133, v134, v135, v136, v137, v138, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }

        v139 = *(v131 + 16);
        v140 = *(v131 + 10);
        if (v139)
        {
          v141 = 1;
        }

        else
        {
          v141 = v140 == 0;
        }

        if (v141)
        {
          v142 = *(this + 7);
          if (v140 > 0x16)
          {
            operator new();
          }

          *(&__p.__r_.__value_.__s + 23) = v140;
          v143 = (&__p + v140);
          if (&__p > v139 || v143 <= v139)
          {
            if (v140)
            {
              memmove(&__p, v139, v140);
            }

            v143->__r_.__value_.__s.__data_[0] = 0;
            v145 = (v142 + 1192);
            if (*(v142 + 1215) < 0)
            {
              operator delete(*v145);
            }

            *v145 = *&__p.__r_.__value_.__l.__data_;
            *(v142 + 1208) = *(&__p.__r_.__value_.__l + 2);
LABEL_219:
            v146 = *(this + 7);
            (*(*v146 + 208))(v146);
            v147 = v146[165];
            if (v147)
            {
              atomic_fetch_add_explicit(v147, 1u, memory_order_relaxed);
            }

            operator new();
          }
        }
      }

      else
      {
        v119 = *(a2 + 1);
        while (1)
        {
          v120 = *v119;
          if (*(*v119 + 8) == 20)
          {
            break;
          }

          if (++v119 == v118)
          {
            goto LABEL_197;
          }
        }

        if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>() & 1) == 0)
        {
          (*(**(this + 7) + 176))(&__p);
          webrtc::webrtc_logging_impl::Log("\r\n\t", v121, v122, v123, v124, v125, v126, v127, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }

        v128 = *(v120 + 16);
        v129 = *(v120 + 10);
        if (v128)
        {
          v130 = 1;
        }

        else
        {
          v130 = v129 == 0;
        }

        if (v130)
        {
          webrtc::TurnPort::set_realm(*(this + 7), v128, v129);
          v117 = *(a2 + 1);
          v118 = *(a2 + 2);
          goto LABEL_197;
        }
      }

      goto LABEL_222;
    }

    (*(*v54 + 176))(&__p, v54);
    webrtc::SocketAddress::ToSensitiveNameAndAddressString((v54 + 816), &v157);
    webrtc::SocketAddress::ToSensitiveNameAndAddressString((v46 + 16), &v155);
    webrtc::webrtc_logging_impl::Log("\r\n\t\n\t\n\t", v92, v93, v94, v95, v96, v97, v98, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (v156 < 0)
    {
      operator delete(v155);
      if ((v158 & 0x80000000) == 0)
      {
LABEL_140:
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_141;
        }

LABEL_177:
        operator delete(__p.__r_.__value_.__l.__data_);
        goto LABEL_141;
      }
    }

    else if ((v158 & 0x80000000) == 0)
    {
      goto LABEL_140;
    }

    operator delete(v157);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_141;
    }

    goto LABEL_177;
  }

  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_28;
  }

LABEL_50:
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v6 == 300)
  {
    goto LABEL_51;
  }

LABEL_29:
  if (v6 == 437)
  {
    v33 = *(this + 7);
    (*(*v33 + 208))(v33);
    v34 = v33[165];
    if (v34)
    {
      atomic_fetch_add_explicit(v34, 1u, memory_order_relaxed);
    }

    operator new();
  }

  if (v6 != 401)
  {
    if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
    {
      (*(**(this + 7) + 176))(&__p);
      v35 = *(this + 2);
      v36 = *(v35 + 63);
      if (v36 < 0)
      {
        v37 = *(v35 + 40);
        v36 = *(v35 + 48);
        v38 = 2 * v36;
        if ((2 * v36) > 0x7FFFFFFFFFFFFFF7)
        {
          goto LABEL_97;
        }
      }

      else
      {
        v37 = (v35 + 40);
        v38 = 2 * v36;
        if ((2 * v36) > 0x7FFFFFFFFFFFFFF7)
        {
          goto LABEL_97;
        }
      }

      if (v38 >= 0x17)
      {
        operator new();
      }

      v158 = v38;
      if (v38)
      {
        bzero(&v157, v38);
      }

      *(&v157 + v38) = 0;
      v61 = &v157;
      if (v158 < 0)
      {
        v61 = v157;
      }

      if (v36)
      {
        v62 = v61 + 1;
        do
        {
          v63 = *v37++;
          v62 += 2;
          --v36;
        }

        while (v36);
      }

      if (webrtc::g_clock)
      {
        (*(*webrtc::g_clock + 16))(webrtc::g_clock);
      }

      else
      {
        if (!dword_28100D8E4)
        {
          mach_timebase_info(&webrtc::SystemTimeNanos(void)::timebase);
        }

        mach_absolute_time();
      }

      webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v64, v65, v66, v67, v68, v69, v70, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (v158 < 0)
      {
        operator delete(v157);
      }

      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    v71 = *(a2 + 1);
    v72 = *(a2 + 2);
    if (v71 == v72)
    {
LABEL_108:
      v74 = *(this + 7);
      *(&__p.__r_.__value_.__s + 23) = 0;
      __p.__r_.__value_.__s.__data_[0] = 0;
    }

    else
    {
      while (1)
      {
        v73 = *v71;
        if (*(*v71 + 8) == 9)
        {
          break;
        }

        if (++v71 == v72)
        {
          goto LABEL_108;
        }
      }

      v74 = *(this + 7);
      if (*(v73 + 39) < 0)
      {
        v88 = *(this + 7);
        std::string::__init_copy_ctor_external(&__p, *(v73 + 16), *(v73 + 24));
        v74 = v88;
      }

      else
      {
        __p = *(v73 + 16);
      }
    }

    webrtc::TurnPort::OnAllocateError(v74);
  }

  v21 = *(this + 7);
  if ((*(v21 + 1239) & 0x8000000000000000) != 0)
  {
    if (*(v21 + 1224))
    {
      goto LABEL_33;
    }
  }

  else if (*(v21 + 1239))
  {
LABEL_33:
    if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
    {
      (*(**(this + 7) + 176))(&__p);
      webrtc::webrtc_logging_impl::Log("\r\n\t", v22, v23, v24, v25, v26, v27, v28, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    v29 = *(a2 + 1);
    v30 = *(a2 + 2);
    if (v29 == v30)
    {
LABEL_39:
      v32 = *(this + 7);
      *(&__p.__r_.__value_.__s + 23) = 0;
      __p.__r_.__value_.__s.__data_[0] = 0;
    }

    else
    {
      while (1)
      {
        v31 = *v29;
        if (*(*v29 + 8) == 9)
        {
          break;
        }

        if (++v29 == v30)
        {
          goto LABEL_39;
        }
      }

      v32 = *(this + 7);
      if (*(v31 + 39) < 0)
      {
        v89 = *(this + 7);
        std::string::__init_copy_ctor_external(&__p, *(v31 + 16), *(v31 + 24));
        v32 = v89;
      }

      else
      {
        __p = *(v31 + 16);
      }
    }

    webrtc::TurnPort::OnAllocateError(v32);
  }

  v43 = *(a2 + 1);
  v44 = *(a2 + 2);
  if (v43 == v44)
  {
LABEL_61:
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
    {
      return;
    }

    goto LABEL_120;
  }

  while (1)
  {
    v45 = *v43;
    if (*(*v43 + 8) == 20)
    {
      break;
    }

    if (++v43 == v44)
    {
      goto LABEL_61;
    }
  }

  v75 = *(v45 + 16);
  v76 = *(v45 + 10);
  if (v75)
  {
    v77 = 1;
  }

  else
  {
    v77 = v76 == 0;
  }

  if (!v77)
  {
    goto LABEL_222;
  }

  webrtc::TurnPort::set_realm(v21, v75, v76);
  v78 = *(a2 + 1);
  v79 = *(a2 + 2);
  if (v78 != v79)
  {
    while (1)
    {
      v80 = *v78;
      if (*(*v78 + 8) == 21)
      {
        break;
      }

      if (++v78 == v79)
      {
        goto LABEL_119;
      }
    }

    v101 = *(v80 + 16);
    v102 = *(v80 + 10);
    if (v101)
    {
      v103 = 1;
    }

    else
    {
      v103 = v102 == 0;
    }

    if (v103)
    {
      v104 = *(this + 7);
      if (v102 > 0x16)
      {
        operator new();
      }

      *(&__p.__r_.__value_.__s + 23) = *(v80 + 10);
      v112 = (&__p + v102);
      if (&__p > v101 || v112 <= v101)
      {
        if (v102)
        {
          memmove(&__p, v101, v102);
        }

        v112->__r_.__value_.__s.__data_[0] = 0;
        v114 = (v104 + 1192);
        if (*(v104 + 1215) < 0)
        {
          operator delete(*v114);
        }

        *v114 = *&__p.__r_.__value_.__l.__data_;
        *(v104 + 1208) = *(&__p.__r_.__value_.__l + 2);
        operator new();
      }
    }

LABEL_222:
    __break(1u);
    return;
  }

LABEL_119:
  if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
  {
LABEL_120:
    (*(**(this + 7) + 176))(&__p);
    webrtc::webrtc_logging_impl::Log("\r\n\t", v81, v82, v83, v84, v85, v86, v87, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void webrtc::TurnAllocateRequest::OnTimeout(webrtc::TurnAllocateRequest *this)
{
  if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
  {
    goto LABEL_16;
  }

  (*(**(this + 7) + 176))(&v18);
  v9 = *(this + 2);
  v10 = *(v9 + 63);
  if (v10 < 0)
  {
    v11 = *(v9 + 40);
    v10 = *(v9 + 48);
    v12 = 2 * v10;
    if ((2 * v10) < 0x7FFFFFFFFFFFFFF8)
    {
      goto LABEL_4;
    }
  }

  else
  {
    v11 = (v9 + 40);
    v12 = 2 * v10;
    if ((2 * v10) < 0x7FFFFFFFFFFFFFF8)
    {
LABEL_4:
      if (v12 >= 0x17)
      {
        operator new();
      }

      v17 = v12;
      if (v12)
      {
        bzero(&__p, v12);
      }

      *(&__p + v12) = 0;
      p_p = __p;
      if (v17 >= 0)
      {
        p_p = &__p;
      }

      if (v10)
      {
        v14 = p_p + 1;
        do
        {
          v15 = *v11++;
          v14 += 2;
          --v10;
        }

        while (v10);
      }

      webrtc::webrtc_logging_impl::Log("\r\n\t\n\t", v2, v3, v4, v5, v6, v7, v8, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (v17 < 0)
      {
        operator delete(__p);
        if ((v19 & 0x80000000) == 0)
        {
          goto LABEL_16;
        }
      }

      else if ((v19 & 0x80000000) == 0)
      {
        goto LABEL_16;
      }

      operator delete(v18);
LABEL_16:
      webrtc::TurnPort::OnAllocateError(*(this + 7));
    }
  }

  std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
}

void webrtc::TurnRefreshRequest::OnSent(webrtc::TurnRefreshRequest *this)
{
  if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
  {
    goto LABEL_16;
  }

  (*(**(this + 7) + 176))(&v20);
  v9 = *(this + 2);
  v10 = *(v9 + 63);
  if ((v10 & 0x8000000000000000) == 0)
  {
    v11 = (v9 + 40);
    v12 = 2 * v10;
    if ((2 * v10) < 0x7FFFFFFFFFFFFFF8)
    {
      goto LABEL_4;
    }

LABEL_20:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  v11 = *(v9 + 40);
  v10 = *(v9 + 48);
  v12 = 2 * v10;
  if ((2 * v10) >= 0x7FFFFFFFFFFFFFF8)
  {
    goto LABEL_20;
  }

LABEL_4:
  if (v12 >= 0x17)
  {
    operator new();
  }

  v19 = v12;
  if (v12)
  {
    bzero(&__p, v12);
  }

  *(&__p + v12) = 0;
  p_p = __p;
  if (v19 >= 0)
  {
    p_p = &__p;
  }

  if (v10)
  {
    v14 = p_p + 1;
    do
    {
      v15 = *v11++;
      v14 += 2;
      --v10;
    }

    while (v10);
  }

  webrtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (v19 < 0)
  {
    operator delete(__p);
    if (v21 < 0)
    {
      goto LABEL_22;
    }

LABEL_16:
    v16 = *(this + 8);
    *(this + 8) = v16 + 1;
    if (v16 < 8)
    {
      return;
    }

    goto LABEL_17;
  }

  if ((v21 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }

LABEL_22:
  operator delete(v20);
  v17 = *(this + 8);
  *(this + 8) = v17 + 1;
  if (v17 < 8)
  {
    return;
  }

LABEL_17:
  *(this + 36) = 1;
}

void webrtc::TurnRefreshRequest::OnResponse(webrtc::TurnRefreshRequest *this, webrtc::StunMessage *a2)
{
  if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
  {
    goto LABEL_23;
  }

  (*(**(this + 7) + 176))(__p);
  v4 = *(this + 2);
  v5 = *(v4 + 63);
  if (v5 < 0)
  {
    v6 = *(v4 + 40);
    v5 = *(v4 + 48);
    v7 = 2 * v5;
    if ((2 * v5) < 0x7FFFFFFFFFFFFFF8)
    {
      goto LABEL_4;
    }

LABEL_17:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  v6 = (v4 + 40);
  v7 = 2 * v5;
  if ((2 * v5) >= 0x7FFFFFFFFFFFFFF8)
  {
    goto LABEL_17;
  }

LABEL_4:
  if (v7 >= 0x17)
  {
    operator new();
  }

  v31 = v7;
  if (v7)
  {
    bzero(&v30, v7);
  }

  *(&v30 + v7) = 0;
  v8 = &v30;
  if (v31 < 0)
  {
    v8 = v30;
  }

  if (v5)
  {
    v9 = v8 + 1;
    do
    {
      v10 = *v6++;
      v9 += 2;
      --v5;
    }

    while (v5);
  }

  if (webrtc::g_clock)
  {
    (*(*webrtc::g_clock + 16))(webrtc::g_clock);
  }

  else
  {
    if (!dword_28100D8E4)
    {
      mach_timebase_info(&webrtc::SystemTimeNanos(void)::timebase);
    }

    mach_absolute_time();
  }

  webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v11, v12, v13, v14, v15, v16, v17, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if ((v31 & 0x80000000) == 0)
  {
    if ((v33 & 0x80000000) == 0)
    {
      goto LABEL_23;
    }

LABEL_33:
    operator delete(__p[0]);
    v18 = *(a2 + 1);
    v19 = *(a2 + 2);
    if (v18 == v19)
    {
      goto LABEL_26;
    }

    goto LABEL_24;
  }

  operator delete(v30);
  if (v33 < 0)
  {
    goto LABEL_33;
  }

LABEL_23:
  v18 = *(a2 + 1);
  v19 = *(a2 + 2);
  if (v18 == v19)
  {
    goto LABEL_26;
  }

  do
  {
LABEL_24:
    if (*(*v18 + 8) == 13)
    {
      v27 = *(*v18 + 12);
      v28 = *(this + 7);
      if (v27)
      {
        webrtc::TurnPort::ScheduleRefresh(*(this + 7), v27);
      }

      (*(*v28 + 208))(*(this + 7));
      v29 = v28[165];
      if (v29)
      {
        atomic_fetch_add_explicit(v29, 1u, memory_order_relaxed);
      }

      operator new();
    }

    v18 += 8;
  }

  while (v18 != v19);
LABEL_26:
  if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>() & 1) == 0)
  {
    (*(**(this + 7) + 176))(__p);
    webrtc::webrtc_logging_impl::Log("\r\n\t", v20, v21, v22, v23, v24, v25, v26, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (v33 < 0)
    {
      operator delete(__p[0]);
    }
  }
}

void webrtc::TurnRefreshRequest::OnErrorResponse(webrtc::TurnRefreshRequest *this, webrtc::StunMessage *a2)
{
  v3 = *(a2 + 1);
  v4 = *(a2 + 2);
  if (v3 == v4)
  {
    goto LABEL_4;
  }

  while (*(*v3 + 8) != 9)
  {
    v3 += 8;
    if (v3 == v4)
    {
      goto LABEL_4;
    }
  }

  if (*(*v3 + 13) + 100 * *(*v3 + 12) != 438)
  {
LABEL_4:
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
    {
      goto LABEL_29;
    }

    v29[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc";
    v29[1] = 12594;
    v29[2] = &v26;
    (*(**(this + 7) + 176))(v24);
    v27 = v24;
    v28 = v29;
    v5 = *(this + 2);
    v6 = *(v5 + 63);
    if (v6 < 0)
    {
      v7 = *(v5 + 40);
      v6 = *(v5 + 48);
      v8 = 2 * v6;
      if ((2 * v6) < 0x7FFFFFFFFFFFFFF8)
      {
LABEL_7:
        if (v8 >= 0x17)
        {
          operator new();
        }

        v23 = v8;
        if (v8)
        {
          bzero(&__p, v8);
        }

        *(&__p + v8) = 0;
        p_p = &__p;
        if (v23 < 0)
        {
          p_p = __p;
        }

        if (v6)
        {
          v11 = p_p + 1;
          do
          {
            v12 = *v7++;
            v11 += 2;
            --v6;
          }

          while (v6);
        }

        if (webrtc::g_clock)
        {
          (*(*webrtc::g_clock + 16))(webrtc::g_clock);
        }

        else
        {
          if (!dword_28100D8E4)
          {
            mach_timebase_info(&webrtc::SystemTimeNanos(void)::timebase);
          }

          mach_absolute_time();
        }

        webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v13, v14, v15, v16, v17, v18, v19, *v28);
        if (v23 < 0)
        {
          operator delete(__p);
          if ((v25 & 0x80000000) == 0)
          {
            goto LABEL_29;
          }
        }

        else if ((v25 & 0x80000000) == 0)
        {
          goto LABEL_29;
        }

        operator delete(v24[0]);
LABEL_29:
        v20 = *(this + 7);
        (*(*v20 + 208))(v20);
        v21 = v20[165];
        if (v21)
        {
          atomic_fetch_add_explicit(v21, 1u, memory_order_relaxed);
        }

        operator new();
      }
    }

    else
    {
      v7 = (v5 + 40);
      v8 = 2 * v6;
      if ((2 * v6) < 0x7FFFFFFFFFFFFFF8)
      {
        goto LABEL_7;
      }
    }

    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  webrtc::TurnPort::UpdateNonce(*(this + 7), a2);
  if (v9)
  {
    operator new();
  }
}

void webrtc::TurnRefreshRequest::OnTimeout(webrtc::TurnRefreshRequest *this)
{
  if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
  {
    goto LABEL_16;
  }

  (*(**(this + 7) + 176))(&v20);
  v9 = *(this + 2);
  v10 = *(v9 + 63);
  if (v10 < 0)
  {
    v11 = *(v9 + 40);
    v10 = *(v9 + 48);
    v12 = 2 * v10;
    if ((2 * v10) < 0x7FFFFFFFFFFFFFF8)
    {
LABEL_4:
      if (v12 >= 0x17)
      {
        operator new();
      }

      v19 = v12;
      if (v12)
      {
        bzero(&__p, v12);
      }

      *(&__p + v12) = 0;
      p_p = __p;
      if (v19 >= 0)
      {
        p_p = &__p;
      }

      if (v10)
      {
        v14 = p_p + 1;
        do
        {
          v15 = *v11++;
          v14 += 2;
          --v10;
        }

        while (v10);
      }

      webrtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (v19 < 0)
      {
        operator delete(__p);
        if ((v21 & 0x80000000) == 0)
        {
          goto LABEL_16;
        }
      }

      else if ((v21 & 0x80000000) == 0)
      {
        goto LABEL_16;
      }

      operator delete(v20);
LABEL_16:
      v16 = *(this + 7);
      (*(*v16 + 208))(v16);
      v17 = v16[165];
      if (v17)
      {
        atomic_fetch_add_explicit(v17, 1u, memory_order_relaxed);
      }

      operator new();
    }
  }

  else
  {
    v11 = (v9 + 40);
    v12 = 2 * v10;
    if ((2 * v10) < 0x7FFFFFFFFFFFFFF8)
    {
      goto LABEL_4;
    }
  }

  std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
}

void webrtc::TurnCreatePermissionRequest::~TurnCreatePermissionRequest(webrtc::TurnCreatePermissionRequest *this)
{
  *this = &unk_2882A1618;
  v2 = *(this + 8);
  if (v2)
  {
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((v2 + 56), this);
  }

  if (*(this + 95) < 0)
  {
    operator delete(*(this + 9));
  }

  *this = &unk_2882A08C8;
  v3 = *(this + 5);
  *(v3 + 4) = 0;
  if (atomic_fetch_add(v3, 0xFFFFFFFF) == 1)
  {
    MEMORY[0x2743DA540]();
  }

  v4 = *(this + 2);
  *(this + 2) = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }
}

{
  *this = &unk_2882A1618;
  v2 = *(this + 8);
  if (v2)
  {
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((v2 + 56), this);
  }

  if (*(this + 95) < 0)
  {
    operator delete(*(this + 9));
  }

  *this = &unk_2882A08C8;
  v3 = *(this + 5);
  *(v3 + 4) = 0;
  if (atomic_fetch_add(v3, 0xFFFFFFFF) == 1)
  {
    MEMORY[0x2743DA540]();
  }

  v4 = *(this + 2);
  *(this + 2) = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  JUMPOUT(0x2743DA540);
}

void webrtc::TurnCreatePermissionRequest::OnSent(webrtc::TurnCreatePermissionRequest *this)
{
  if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
  {
    goto LABEL_16;
  }

  (*(**(this + 7) + 176))(&v20);
  v9 = *(this + 2);
  v10 = *(v9 + 63);
  if ((v10 & 0x8000000000000000) == 0)
  {
    v11 = (v9 + 40);
    v12 = 2 * v10;
    if ((2 * v10) < 0x7FFFFFFFFFFFFFF8)
    {
      goto LABEL_4;
    }

LABEL_20:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  v11 = *(v9 + 40);
  v10 = *(v9 + 48);
  v12 = 2 * v10;
  if ((2 * v10) >= 0x7FFFFFFFFFFFFFF8)
  {
    goto LABEL_20;
  }

LABEL_4:
  if (v12 >= 0x17)
  {
    operator new();
  }

  v19 = v12;
  if (v12)
  {
    bzero(&__p, v12);
  }

  *(&__p + v12) = 0;
  p_p = __p;
  if (v19 >= 0)
  {
    p_p = &__p;
  }

  if (v10)
  {
    v14 = p_p + 1;
    do
    {
      v15 = *v11++;
      v14 += 2;
      --v10;
    }

    while (v10);
  }

  webrtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (v19 < 0)
  {
    operator delete(__p);
    if (v21 < 0)
    {
      goto LABEL_22;
    }

LABEL_16:
    v16 = *(this + 8);
    *(this + 8) = v16 + 1;
    if (v16 < 8)
    {
      return;
    }

    goto LABEL_17;
  }

  if ((v21 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }

LABEL_22:
  operator delete(v20);
  v17 = *(this + 8);
  *(this + 8) = v17 + 1;
  if (v17 < 8)
  {
    return;
  }

LABEL_17:
  *(this + 36) = 1;
}

void webrtc::TurnCreatePermissionRequest::OnResponse(webrtc::TurnCreatePermissionRequest *this, webrtc::StunMessage *a2)
{
  if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
  {
    goto LABEL_23;
  }

  (*(**(this + 7) + 176))(v28);
  v3 = *(this + 2);
  v4 = *(v3 + 63);
  if ((v4 & 0x8000000000000000) == 0)
  {
    v5 = (v3 + 40);
    v6 = 2 * v4;
    if ((2 * v4) < 0x7FFFFFFFFFFFFFF8)
    {
      goto LABEL_4;
    }

LABEL_17:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  v5 = *(v3 + 40);
  v4 = *(v3 + 48);
  v6 = 2 * v4;
  if ((2 * v4) >= 0x7FFFFFFFFFFFFFF8)
  {
    goto LABEL_17;
  }

LABEL_4:
  if (v6 >= 0x17)
  {
    operator new();
  }

  v27 = v6;
  if (v6)
  {
    bzero(&__p, v6);
  }

  *(&__p + v6) = 0;
  p_p = &__p;
  if (v27 < 0)
  {
    p_p = __p;
  }

  if (v4)
  {
    v8 = p_p + 1;
    do
    {
      v9 = *v5++;
      v8 += 2;
      --v4;
    }

    while (v4);
  }

  if (webrtc::g_clock)
  {
    (*(*webrtc::g_clock + 16))(webrtc::g_clock);
  }

  else
  {
    if (!dword_28100D8E4)
    {
      mach_timebase_info(&webrtc::SystemTimeNanos(void)::timebase);
    }

    mach_absolute_time();
  }

  webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v10, v11, v12, v13, v14, v15, v16, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (v27 < 0)
  {
    operator delete(__p);
    if (v29 < 0)
    {
      goto LABEL_33;
    }

LABEL_23:
    v17 = *(this + 8);
    if (!v17)
    {
      return;
    }

    goto LABEL_24;
  }

  if ((v29 & 0x80000000) == 0)
  {
    goto LABEL_23;
  }

LABEL_33:
  operator delete(v28[0]);
  v17 = *(this + 8);
  if (!v17)
  {
    return;
  }

LABEL_24:
  if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)1>())
  {
    goto LABEL_27;
  }

  (*(**(v17 + 88) + 176))(v28);
  webrtc::SocketAddress::ToSensitiveString((v17 + 104), &__p);
  webrtc::webrtc_logging_impl::Log("\r\n\t\n\t", v18, v19, v20, v21, v22, v23, v24, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (v27 < 0)
  {
    operator delete(__p);
    if ((v29 & 0x80000000) == 0)
    {
LABEL_27:
      v25 = *(*(v17 + 88) + 1328);
      if (!v25)
      {
        goto LABEL_29;
      }

      goto LABEL_28;
    }
  }

  else if ((v29 & 0x80000000) == 0)
  {
    goto LABEL_27;
  }

  operator delete(v28[0]);
  v25 = *(*(v17 + 88) + 1328);
  if (v25)
  {
LABEL_28:
    (*(*v25 + 16))(v25, 0);
  }

LABEL_29:
  if (*(v17 + 176) != 2)
  {
    operator new();
  }
}

void webrtc::TurnCreatePermissionRequest::OnErrorResponse(webrtc::TurnCreatePermissionRequest *this, webrtc::StunMessage *a2)
{
  v4 = *(a2 + 1);
  v5 = *(a2 + 2);
  if (v4 == v5)
  {
LABEL_4:
    v6 = 600;
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
    {
      goto LABEL_28;
    }
  }

  else
  {
    while (*(*v4 + 8) != 9)
    {
      v4 += 8;
      if (v4 == v5)
      {
        goto LABEL_4;
      }
    }

    v6 = *(*v4 + 13) + 100 * *(*v4 + 12);
    if (webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)2>())
    {
      goto LABEL_28;
    }
  }

  v51.__r_.__value_.__r.__words[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc";
  v51.__r_.__value_.__l.__size_ = 13146;
  v51.__r_.__value_.__r.__words[2] = &v48;
  (*(**(this + 7) + 176))(v46);
  v49 = v46;
  v50 = &v51;
  v7 = *(this + 2);
  v8 = *(v7 + 63);
  if ((v8 & 0x8000000000000000) == 0)
  {
    v9 = (v7 + 40);
    v10 = 2 * v8;
    if ((2 * v8) < 0x7FFFFFFFFFFFFFF8)
    {
      goto LABEL_9;
    }

LABEL_22:
    std::vector<unsigned char>::__throw_length_error[abi:sn200100]();
  }

  v9 = *(v7 + 40);
  v8 = *(v7 + 48);
  v10 = 2 * v8;
  if ((2 * v8) >= 0x7FFFFFFFFFFFFFF8)
  {
    goto LABEL_22;
  }

LABEL_9:
  if (v10 >= 0x17)
  {
    operator new();
  }

  v45 = v10;
  if (v10)
  {
    bzero(&__p, v10);
  }

  *(&__p + v10) = 0;
  p_p = &__p;
  if (v45 < 0)
  {
    p_p = __p;
  }

  if (v8)
  {
    v12 = p_p + 1;
    do
    {
      v13 = *v9++;
      v12 += 2;
      --v8;
    }

    while (v8);
  }

  if (webrtc::g_clock)
  {
    (*(*webrtc::g_clock + 16))(webrtc::g_clock);
  }

  else
  {
    if (!dword_28100D8E4)
    {
      mach_timebase_info(&webrtc::SystemTimeNanos(void)::timebase);
    }

    mach_absolute_time();
  }

  webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)10,std::string const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v14, v15, v16, v17, v18, v19, v20, v50->__r_.__value_.__r.__words[0]);
  if (v45 < 0)
  {
    operator delete(__p);
    if (v47 < 0)
    {
      goto LABEL_48;
    }

LABEL_28:
    v21 = *(this + 8);
    if (!v21)
    {
      return;
    }

    goto LABEL_29;
  }

  if ((v47 & 0x80000000) == 0)
  {
    goto LABEL_28;
  }

LABEL_48:
  operator delete(v46[0]);
  v21 = *(this + 8);
  if (!v21)
  {
    return;
  }

LABEL_29:
  v22 = *(v21 + 88);
  if (v6 == 438)
  {
    webrtc::TurnPort::UpdateNonce(v22, a2);
    if (v23)
    {
      operator new();
    }
  }

  else
  {
    v24 = (*(*v22 + 88))(v22, v21 + 104);
    if (v24)
    {
      v25 = *(v24 + 248);
      if (v25 && *v25 == 1 && *(v24 + 256))
      {
        v26 = *(v24 + 2560);
        *(v24 + 2560) = 3;
        if (v26 != 3)
        {
          v27 = v24;
          v28 = webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)0>();
          v24 = v27;
          if ((v28 & 1) == 0)
          {
            webrtc::Connection::ToString(v27, &v51);
            webrtc::webrtc_logging_impl::Log("\r\n\t", v29, v30, v31, v32, v33, v34, v35, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/connection.cc");
            if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v51.__r_.__value_.__l.__data_);
            }

            v24 = v27;
          }
        }

        webrtc::Connection::Prune(v24);
      }

      if ((webrtc::LogMessage::IsNoop<(webrtc::LoggingSeverity)3>() & 1) == 0)
      {
        webrtc::webrtc_logging_impl::Log(webrtc::webrtc_logging_impl::LogStreamer<>::Call<webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>>(webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)13,webrtc::webrtc_logging_impl::LogMetadata>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)1,int>,webrtc::webrtc_logging_impl::Val<(webrtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v36, v37, v38, v39, v40, v41, v42, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      }
    }
  }

  v43 = *(*(v21 + 88) + 1328);
  if (v43)
  {
    (*(*v43 + 16))(v43, v6);
  }
}