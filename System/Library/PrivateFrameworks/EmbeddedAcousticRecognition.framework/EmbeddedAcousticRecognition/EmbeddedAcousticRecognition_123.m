void sub_1B5A56FF4(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 48));
  std::__list_imp<char *>::clear((v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::SetArcs(uint64_t a1, int a2)
{
  MutableState = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>>>::GetMutableState(*(a1 + 120), a2);
  fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>>>::SetArcs(*(a1 + 120), MutableState);
  v5 = *(MutableState + 80);
  v6 = *(MutableState + 88) - v5;
  if (v6)
  {
    v7 = 0xCCCCCCCCCCCCCCCDLL * (v6 >> 4);
    v8 = *(a1 + 68);
    if (v7 <= 1)
    {
      v7 = 1;
    }

    v9 = (v5 + 72);
    do
    {
      v11 = *v9;
      v9 += 20;
      v10 = v11;
      if (v11 >= v8)
      {
        v8 = v10 + 1;
        *(a1 + 68) = v10 + 1;
      }

      --v7;
    }

    while (v7);
  }

  result = fst::CacheBaseImpl<fst::CacheState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>,fst::DefaultCacheStore<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>::SetExpandedState(a1, a2);
  *(MutableState + 104) |= 0xAu;
  return result;
}

uint64_t fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::PushArc(uint64_t a1, int a2, uint64_t a3)
{
  MutableState = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>>>::GetMutableState(*(a1 + 120), a2);
  v5 = MutableState;
  v6 = MutableState[11];
  if (v6 >= MutableState[12])
  {
    result = std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::__emplace_back_slow_path<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const&>(MutableState + 10, a3);
  }

  else
  {
    std::allocator_traits<std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::construct[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const&,0>((MutableState + 10), v6, a3);
    result = v6 + 80;
    v5[11] = v6 + 80;
  }

  v5[11] = result;
  return result;
}

void fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>>>::SetArcs(uint64_t a1, uint64_t a2)
{
  fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::SetArcs(a2);
  if (*(a1 + 104) == 1 && (*(a2 + 104) & 4) != 0)
  {
    v4 = *(a2 + 88) - *(a2 + 80) + *(a1 + 112);
    *(a1 + 112) = v4;
    if (v4 > *(a1 + 96))
    {

      fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>>>::GC(a1, a2, 0, 0.666);
    }
  }
}

uint64_t std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::__emplace_back_slow_path<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const&>(uint64_t *a1, uint64_t a2)
{
  v2 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  v3 = v2 + 1;
  if (v2 + 1 > 0x333333333333333)
  {
    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  if (0x999999999999999ALL * ((a1[2] - *a1) >> 4) > v3)
  {
    v3 = 0x999999999999999ALL * ((a1[2] - *a1) >> 4);
  }

  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 4) >= 0x199999999999999)
  {
    v6 = 0x333333333333333;
  }

  else
  {
    v6 = v3;
  }

  v16 = a1;
  if (v6)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>(a1, v6);
  }

  v13 = 0;
  v14 = 80 * v2;
  std::allocator_traits<std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::construct[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const&,0>(a1, 80 * v2, a2);
  v15 = 80 * v2 + 80;
  v7 = a1[1];
  v8 = 80 * v2 + *a1 - v7;
  std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>*>(a1, *a1, v7, v8);
  v9 = *a1;
  *a1 = v8;
  v10 = a1[2];
  v12 = v15;
  *(a1 + 1) = v15;
  *&v15 = v9;
  *(&v15 + 1) = v10;
  v13 = v9;
  v14 = v9;
  std::__split_buffer<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>::~__split_buffer(&v13);
  return v12;
}

void sub_1B5A57374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

uint64_t fst::ArcMapFstImpl<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::NumInputEpsilons(uint64_t a1, int a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::ArcMapFstImpl<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  v4 = *(a1 + 120);
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return *(*v5 + 64);
}

uint64_t fst::ArcMapFstImpl<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::NumOutputEpsilons(uint64_t a1, int a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::ArcMapFstImpl<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  v4 = *(a1 + 120);
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return *(*v5 + 72);
}

unint64_t fst::TestProperties<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (FLAGS_fst_verify_properties == 1)
  {
    v6 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
    v7 = fst::ComputeProperties<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>(a1, a2, a3, 0);
    if (!fst::CompatProperties(v6, v7))
    {
      std::string::basic_string[abi:ne200100]<0>(__p, "FATAL");
      v8 = fst::LogMessage::LogMessage(&v14, __p);
      v9 = fst::cerr(v8);
      v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "TestProperties: stored Fst properties incorrect", 47);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, " (stored: props1, computed: props2)", 35);
      fst::LogMessage::~LogMessage(&v14);
      if (v13 < 0)
      {
        operator delete(__p[0]);
      }
    }

    return v7;
  }

  else
  {

    return fst::ComputeProperties<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>(a1, a2, a3, 1);
  }
}

void sub_1B5A5758C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

unint64_t fst::ComputeProperties<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  v7 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
  v8 = v7;
  if (!a4 || (v9 = v7 & 0x3FFFFFFF0000 | (2 * v7) & 0x2AAAAAAA0000 | (v7 >> 1) & 0x155555550000 | 7, (a2 & ~v9) != 0))
  {
    v8 = v7 & 7;
    v56 = v8;
    v10 = (*(*a1 + 16))(a1);
    if ((a2 & 0xF3C00000000) != 0 && v10)
    {
      v50 = 0;
      v51 = 0;
      v52[0] = 0;
      v52[1] = &v56;
      fst::DfsVisit<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::SccVisitor<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::AnyArcFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>(a1, &v50);
    }

    if ((a2 & 0xFFFFF0C3FFFFFFF8) != 0)
    {
      v37 = a3;
      v11 = a2 & 0xC0000;
      v12 = 0x10425A810000;
      if ((a2 & 0xC0000) != 0)
      {
        v12 = 0x10425A850000;
      }

      v13 = v8 | v12;
      v14 = a2 & 0x300000;
      if ((a2 & 0x300000) != 0)
      {
        v13 |= 0x100000uLL;
      }

      v56 = v13;
      memset(&v49, 0, sizeof(v49));
      memset(&v48, 0, sizeof(v48));
      v47 = 0;
      v15 = a1;
      (*(*a1 + 128))(a1, &v45);
      v39 = 0;
LABEL_12:
      if (v45)
      {
        if (!(*(*v45 + 16))(v45))
        {
          if (v45)
          {
            v16 = (*(*v45 + 24))();
LABEL_18:
            v17 = (*(*v15 + 40))(v15, v16);
            v18 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::NoWeight();
            LODWORD(v51) = *v18;
            std::list<int>::list(v52, (v18 + 2));
            v53 = v18[8];
            v54[0] = v54;
            v54[1] = v54;
            v54[2] = 0;
            v49.__end_ = v49.__begin_;
            v48.__end_ = v48.__begin_;
            if (v11)
            {
              std::vector<int>::reserve(&v49, v17);
            }

            if (v14)
            {
              std::vector<int>::reserve(&v48, v17);
            }

            v43 = 0;
            (*(*v15 + 136))(v15, v16, &v40);
            v19 = 1;
            while (1)
            {
              if (v40)
              {
                if ((*(*v40 + 24))(v40))
                {
                  if (v40)
                  {
                    (*(*v40 + 8))();
                    goto LABEL_65;
                  }

LABEL_63:
                  if (v42)
                  {
                    --*v42;
                  }

LABEL_65:
                  v15 = a1;
                  if (v11 && (std::__sort<std::__less<int,int> &,int *>(), v27 = v49.__end_ - v49.__begin_, v27 >= 2))
                  {
                    v28 = v27 - 1;
                    v29 = v49.__begin_ + 1;
                    while (*v29 != *(v29 - 1))
                    {
                      ++v29;
                      if (!--v28)
                      {
                        goto LABEL_70;
                      }
                    }

                    v56 = v56 & 0xFFFFFFFFFFF3FFFFLL | 0x80000;
                    if (!v14)
                    {
LABEL_79:
                      if (v39 >= 1)
                      {
                        v56 = v56 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000;
                      }

                      (*(*a1 + 32))(&v40, a1, v16);
                      v33 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero();
                      if (fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(&v40, v33))
                      {
                        if ((*(*a1 + 40))(a1, v16) != 1)
                        {
                          v56 = v56 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000;
                        }
                      }

                      else
                      {
                        v34 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::One();
                        if ((fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(&v40, v34) & 1) == 0)
                        {
                          v56 = v56 & 0xFFFFFFFCFFFFFFFFLL | 0x100000000;
                        }

                        ++v39;
                      }

                      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v44);
                      std::__list_imp<char *>::clear(v41);
                      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v54);
                      std::__list_imp<char *>::clear(v52);
                      if (v45)
                      {
                        (*(*v45 + 32))(v45);
                      }

                      else
                      {
                        ++v47;
                      }

                      goto LABEL_12;
                    }
                  }

                  else
                  {
LABEL_70:
                    if (!v14)
                    {
                      goto LABEL_79;
                    }
                  }

                  std::__sort<std::__less<int,int> &,int *>();
                  v30 = v48.__end_ - v48.__begin_;
                  if (v30 >= 2)
                  {
                    v31 = v30 - 1;
                    v32 = v48.__begin_ + 1;
                    while (*v32 != *(v32 - 1))
                    {
                      ++v32;
                      if (!--v31)
                      {
                        goto LABEL_79;
                      }
                    }

                    v56 = v56 & 0xFFFFFFFFFFCFFFFFLL | 0x200000;
                  }

                  goto LABEL_79;
                }

                if (v40)
                {
                  v20 = (*(*v40 + 32))();
                  goto LABEL_29;
                }
              }

              else if (v43 >= v41[1])
              {
                goto LABEL_63;
              }

              v20 = v41[0] + 80 * v43;
LABEL_29:
              v21 = *v20;
              v22 = *v20;
              if (*v20 != *(v20 + 4))
              {
                v56 = v56 & 0xFFFFFFFFFFFCFFFFLL | 0x20000;
                v22 = *(v20 + 4);
              }

              if (v21 | v22)
              {
                if (v21)
                {
                  if (!v22)
                  {
                    goto LABEL_39;
                  }

                  goto LABEL_35;
                }

                v23 = v56;
              }

              else
              {
                v23 = v56 & 0xFFFFFFFFFF3FFFFFLL | 0x400000;
              }

              v56 = v23 & 0xFFFFFFFFFCFFFFFFLL | 0x1000000;
              if (!v22)
              {
LABEL_39:
                v56 = v56 & 0xFFFFFFFFF3FFFFFFLL | 0x4000000;
                if (v19)
                {
                  goto LABEL_44;
                }

                goto LABEL_40;
              }

LABEL_35:
              if (v19)
              {
                goto LABEL_44;
              }

LABEL_40:
              if (v21 < v50)
              {
                v56 = v56 & 0xFFFFFFFFCFFFFFFFLL | 0x20000000;
              }

              if (v22 < SHIDWORD(v50))
              {
                v56 = v56 & 0xFFFFFFFF3FFFFFFFLL | 0x80000000;
              }

LABEL_44:
              v24 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::One();
              if ((fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(v20 + 8, v24) & 1) == 0)
              {
                v25 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero();
                if ((fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(v20 + 8, v25) & 1) == 0)
                {
                  v56 = v56 & 0xFFFFFFFCFFFFFFFFLL | 0x100000000;
                }
              }

              v26 = *(v20 + 72);
              if (v26 <= v16)
              {
                v56 = v56 & 0xFFFFFF3FFFFFFFFFLL | 0x8000000000;
              }

              if (v26 != v16 + 1)
              {
                v56 = v56 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000;
              }

              v50 = *v20;
              LODWORD(v51) = *(v20 + 8);
              if (&v50 == v20)
              {
                v53 = *(v20 + 40);
              }

              else
              {
                std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v52, *(v20 + 24), v20 + 16);
                v53 = *(v20 + 40);
                std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,void *>,std::__list_const_iterator<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,void *>>(v54, *(v20 + 56), v20 + 48);
                v26 = *(v20 + 72);
              }

              v55 = v26;
              if (v11)
              {
                std::vector<int>::push_back[abi:ne200100](&v49.__begin_, v20);
              }

              if (v14)
              {
                std::vector<int>::push_back[abi:ne200100](&v48.__begin_, (v20 + 4));
              }

              if (v40)
              {
                (*(*v40 + 40))(v40);
                v19 = 0;
              }

              else
              {
                v19 = 0;
                ++v43;
              }
            }
          }

LABEL_17:
          v16 = v47;
          goto LABEL_18;
        }

        if (v45)
        {
          (*(*v45 + 8))();
        }
      }

      else if (v47 < v46)
      {
        goto LABEL_17;
      }

      v35 = (*(*v15 + 24))(v15);
      a3 = v37;
      if (v35 != -1 && (*(*a1 + 24))(a1))
      {
        v56 = v56 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000;
      }

      if (v48.__begin_)
      {
        v48.__end_ = v48.__begin_;
        operator delete(v48.__begin_);
      }

      if (v49.__begin_)
      {
        v49.__end_ = v49.__begin_;
        operator delete(v49.__begin_);
      }

      v8 = v56;
    }

    v9 = v8 & 0x3FFFFFFF0000 | (2 * v8) & 0x2AAAAAAA0000 | (v8 >> 1) & 0x155555550000 | 7;
  }

  *a3 = v9;
  return v8;
}

void sub_1B5A57E2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, uint64_t a26, void *a27, uint64_t a28)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a27)
  {
    operator delete(a27);
  }

  _Unwind_Resume(exception_object);
}

void sub_1B5A586E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  v12 = va_arg(va1, void);
  v14 = va_arg(va1, void);
  v15 = va_arg(va1, void);
  v16 = va_arg(va1, void);
  v17 = va_arg(va1, void);
  v18 = va_arg(va1, void);
  v19 = va_arg(va1, void);
  v20 = va_arg(va1, void);
  fst::MemoryPool<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~MemoryPool(va);
  std::deque<fst::DfsState<fst::ArcTpl<fst::LatticeWeightTpl<float>,int>> *,std::allocator<fst::DfsState<fst::ArcTpl<fst::LatticeWeightTpl<float>,int>> *>>::~deque[abi:ne200100](va1);
  v11 = *(v9 - 112);
  if (v11)
  {
    *(v9 - 104) = v11;
    operator delete(v11);
  }

  _Unwind_Resume(a1);
}

void fst::SccVisitor<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::InitVisit(uint64_t a1, uint64_t a2)
{
  if (*a1)
  {
    *(*a1 + 8) = **a1;
  }

  v3 = *(a1 + 8);
  if (v3)
  {
    *(v3 + 8) = 0;
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    *(v4 + 8) = 0;
    *(a1 + 52) = 0;
    **(a1 + 24) = **(a1 + 24) & 0xFFFFF0C3FFFFFFFFLL | 0x52800000000;
    *(a1 + 32) = a2;
    v5 = (*(*a2 + 24))(a2);
    *(a1 + 44) = 0;
    *(a1 + 48) = 0;
    *(a1 + 40) = v5;
    operator new();
  }

  operator new();
}

uint64_t fst::CountStates<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>(uint64_t a1)
{
  if ((*(*a1 + 64))(a1, 1, 0))
  {
    v2 = *(*a1 + 160);

    return v2(a1);
  }

  v7 = 0;
  (*(*a1 + 128))(a1, &v5);
  v4 = 0;
  while (1)
  {
    while (!v5)
    {
      if (v7 >= v6)
      {
        return v4;
      }

      v4 = (v4 + 1);
LABEL_12:
      ++v7;
    }

    if ((*(*v5 + 16))(v5))
    {
      break;
    }

    v4 = (v4 + 1);
    if (!v5)
    {
      goto LABEL_12;
    }

    (*(*v5 + 32))();
  }

  if (v5)
  {
    (*(*v5 + 8))();
  }

  return v4;
}

void sub_1B5A58A4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    fst::CountStates<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>();
  }

  _Unwind_Resume(exception_object);
}

unint64_t fst::SccVisitor<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::FinishState(uint64_t a1, int a2, int a3)
{
  (*(**(a1 + 32) + 32))(&v22);
  v6 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero();
  v7 = fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(&v22, v6);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v24);
  result = std::__list_imp<char *>::clear(v23);
  if (!v7)
  {
    *(**(a1 + 16) + ((a2 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << a2;
  }

  v9 = **(a1 + 64);
  if (*(**(a1 + 56) + 4 * a2) != *(v9 + 4 * a2))
  {
    goto LABEL_16;
  }

  v10 = 0;
  v11 = *(a1 + 80);
  v12 = **(a1 + 16);
  v13 = (*(v11 + 8) - 4);
  v14 = v13;
  do
  {
    v15 = *v14--;
    v10 |= *(v12 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15;
  }

  while (v15 != a2);
  v16 = *a1;
  v17 = **(a1 + 72);
  while (1)
  {
    v18 = *v13;
    if (v16)
    {
      *(*v16 + 4 * v18) = *(a1 + 48);
    }

    result = v18 >> 6;
    v19 = 1 << v18;
    if ((v10 & 1) == 0)
    {
      break;
    }

    *(v12 + 8 * result) |= v19;
    *(v17 + 8 * result) &= ~v19;
    if (v18 == a2)
    {
      *(v11 + 8) = v13;
      goto LABEL_15;
    }

LABEL_13:
    --v13;
  }

  *(v17 + 8 * result) &= ~v19;
  if (v18 != a2)
  {
    goto LABEL_13;
  }

  *(v11 + 8) = v13;
  **(a1 + 24) = **(a1 + 24) & 0xFFFFF3FFFFFFFFFFLL | 0x80000000000;
LABEL_15:
  ++*(a1 + 48);
LABEL_16:
  if (a3 != -1)
  {
    v20 = **(a1 + 16);
    if ((*(v20 + ((a2 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a2))
    {
      *(v20 + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << a3;
    }

    v21 = *(v9 + 4 * a2);
    if (v21 < *(v9 + 4 * a3))
    {
      *(v9 + 4 * a3) = v21;
    }
  }

  return result;
}

void sub_1B5A58C80(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 40));
  std::__list_imp<char *>::clear((v1 + 8));
  _Unwind_Resume(a1);
}

void fst::MemoryPool<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~MemoryPool(quasar::Bitmap *a1)
{
  *a1 = &unk_1F2D407B8;
  fst::MemoryArena<fst::MemoryPool<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Link>::~MemoryArena(a1 + 1);
  quasar::Bitmap::~Bitmap(a1);

  JUMPOUT(0x1B8C85350);
}

{
  *a1 = &unk_1F2D407B8;
  fst::MemoryArena<fst::MemoryPool<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Link>::~MemoryArena(a1 + 1);

  quasar::Bitmap::~Bitmap(a1);
}

void fst::MemoryArena<fst::MemoryPool<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Link>::MemoryArena(void *a1, uint64_t a2)
{
  *a1 = &unk_1F2D407F8;
  a1[1] = 56 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_1B5A58E10(_Unwind_Exception *a1)
{
  std::__list_imp<char *>::clear(v2);
  quasar::Bitmap::~Bitmap(v1);
  _Unwind_Resume(a1);
}

void fst::MemoryArena<fst::MemoryPool<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Link>::~MemoryArena(void *a1)
{
  fst::MemoryArena<fst::MemoryPool<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Link>::~MemoryArena(a1);

  JUMPOUT(0x1B8C85350);
}

{
  *a1 = &unk_1F2D407F8;
  v2 = a1 + 3;
  v3 = a1[4];
  if (v3 != a1 + 3)
  {
    do
    {
      v4 = v3[2];
      if (v4)
      {
        MEMORY[0x1B8C85310](v4, 0x1000C8077774924);
      }

      v3 = v3[1];
    }

    while (v3 != v2);
  }

  std::__list_imp<char *>::clear(v2);

  quasar::Bitmap::~Bitmap(a1);
}

void *std::deque<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>> *,std::allocator<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>> *>>::push_back(void *result, void *a2)
{
  v3 = result;
  v4 = result[2];
  v5 = result[1];
  if (v4 == v5)
  {
    v6 = 0;
  }

  else
  {
    v6 = ((v4 - v5) << 6) - 1;
  }

  v7 = result[5];
  v8 = v7 + result[4];
  if (v6 == v8)
  {
    result = std::deque<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>> *,std::allocator<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>> *>>::__add_back_capacity(result);
    v5 = v3[1];
    v7 = v3[5];
    v8 = v3[4] + v7;
  }

  *(*(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  v3[5] = v7 + 1;
  return result;
}

void *std::deque<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>> *,std::allocator<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>> *>>::__add_back_capacity(void *a1)
{
  v1 = a1[4];
  v2 = v1 >= 0x200;
  v3 = v1 - 512;
  if (!v2)
  {
    v6 = a1[2];
    v7 = a1[3];
    v8 = v7 - *a1;
    if (v6 - a1[1] < v8)
    {
      if (v7 != v6)
      {
        operator new();
      }

      operator new();
    }

    if (v7 == *a1)
    {
      v9 = 1;
    }

    else
    {
      v9 = v8 >> 2;
    }

    v11 = a1;
    std::__allocate_at_least[abi:ne200100]<std::allocator<fst::DfsState<fst::ArcTpl<fst::LatticeWeightTpl<float>,int>> **>>(a1, v9);
  }

  a1[4] = v3;
  v4 = a1[1];
  *&v10 = *v4;
  a1[1] = v4 + 1;
  return std::__split_buffer<fst::DfsState<fst::ArcTpl<fst::LatticeWeightTpl<float>,int>> **,std::allocator<fst::DfsState<fst::ArcTpl<fst::LatticeWeightTpl<float>,int>> **>>::emplace_back<fst::DfsState<fst::ArcTpl<fst::LatticeWeightTpl<float>,int>> **&>(a1, &v10);
}

void sub_1B5A5911C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void fst::ArcBuffer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::SetFromFst<fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  (*(*a2 + 136))(a2, a3, &v26);
  if (!v26 && (a4 & 1) == 0)
  {
    v10 = v27 + 80 * v28;
    *(a1 + 16) = v27;
    *(a1 + 24) = v10;
    if (*a1)
    {
      free(*a1);
      *a1 = 0;
    }

    *(a1 + 8) = 0;
    return;
  }

  v11 = (*(*a2 + 40))(a2, a3);
  v12 = a5;
  if (!a4)
  {
    v12 = 0;
  }

  v13 = v11 + v12;
  if (*(a1 + 8) < (v11 + v12))
  {
    if (*a1)
    {
      free(*a1);
    }

    v25 = 0x4000;
    if (v13 > 0x4000)
    {
      v25 = v13;
    }

    *(a1 + 8) = v25;
    v15 = malloc_type_malloc(80 * v25, 0x1020040B5FA0AF2uLL);
    *a1 = v15;
    *(a1 + 16) = v15;
    v14 = v15;
  }

  else
  {
    v14 = *(a1 + 16);
    v15 = *a1;
  }

  *(a1 + 24) = &v14[20 * v13];
  v16 = v26;
  v17 = v27;
  v19 = v28;
  v18 = v29;
  if (v29)
  {
    ++*v29;
  }

  v20 = 0;
LABEL_13:
  v15 += 20;
  while (v16)
  {
    v21 = (*(*v16 + 24))(v16);
    v22 = *v16;
    if (v21)
    {
      (*(v22 + 8))(v16);
      return;
    }

    v23 = (*(v22 + 32))(v16);
LABEL_18:
    v24 = (v15 - 20);
    *v24 = *v23;
    *(v24 + 2) = *(v23 + 8);
    if (v15 - 20 == v23)
    {
      *(v15 - 10) = *(v23 + 40);
    }

    else
    {
      std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v15 - 8, *(v23 + 24), v23 + 16);
      *(v15 - 10) = *(v23 + 40);
      std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,void *>,std::__list_const_iterator<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,void *>>(v15 - 4, *(v23 + 56), v23 + 48);
    }

    *(v15 - 2) = *(v23 + 72);
    if (!v16)
    {
      ++v20;
      goto LABEL_13;
    }

    v15 += 20;
    (*(*v16 + 40))(v16);
  }

  v23 = v17 + 80 * v20;
  if (v20 < v19)
  {
    goto LABEL_18;
  }

  if (v18)
  {
    --*v18;
  }
}

void sub_1B5A59484(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  else if (v2)
  {
    --*v2;
  }

  _Unwind_Resume(exception_object);
}

void *fst::ImplToFst<fst::ArcMapFstImpl<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::ImplToFst(void *result, uint64_t a2, int a3)
{
  *result = &unk_1F2D40708;
  if (a3)
  {
    operator new();
  }

  v3 = *(a2 + 8);
  result[1] = v3;
  ++*(v3 + 56);
  return result;
}

void sub_1B5A597CC(_Unwind_Exception *a1)
{
  MEMORY[0x1B8C85350](v2, 0x10A0C407A9BBF1FLL);
  v4 = *(v1 + 72);
  if (v4)
  {
    operator delete(v4);
  }

  fst::FstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::~FstImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>::CopyStates(a1, a2);
    *(a1 + 56) = *(a1 + 40);
    *(a1 + 72) = *(a2 + 72);
    v4 = *(a2 + 76);
    *(a1 + 76) = v4;
    if (v4 == -1)
    {
      MutableState = 0;
    }

    else
    {
      MutableState = fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>::GetMutableState(a1, 0);
    }

    *(a1 + 80) = MutableState;
  }

  return a1;
}

void fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>::CopyStates(void *a1, uint64_t a2)
{
  fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>>::Clear(a1);
  std::vector<fst::VectorState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>> *,std::allocator<fst::VectorState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>> *>>::reserve(a1 + 1, (*(a2 + 16) - *(a2 + 8)) >> 3);
  v4 = *(a2 + 8);
  if (*(a2 + 16) != v4)
  {
    v5 = 0;
    do
    {
      if (*(v4 + 8 * v5))
      {
        operator new();
      }

      v7 = a1[2];
      v6 = a1[3];
      if (v7 >= v6)
      {
        v9 = a1[1];
        v10 = (v7 - v9) >> 3;
        if ((v10 + 1) >> 61)
        {
          std::vector<int>::__throw_length_error[abi:ne200100]();
        }

        v11 = v6 - v9;
        v12 = v11 >> 2;
        if (v11 >> 2 <= (v10 + 1))
        {
          v12 = v10 + 1;
        }

        if (v11 >= 0x7FFFFFFFFFFFFFF8)
        {
          v13 = 0x1FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v13 = v12;
        }

        if (v13)
        {
          std::__allocate_at_least[abi:ne200100]<std::allocator<kaldi::CuWorkspace *>>((a1 + 1), v13);
        }

        v14 = (8 * v10);
        *v14 = 0;
        v8 = 8 * v10 + 8;
        v15 = a1[1];
        v16 = a1[2] - v15;
        v17 = v14 - v16;
        memcpy(v14 - v16, v15, v16);
        v18 = a1[1];
        a1[1] = v17;
        a1[2] = v8;
        a1[3] = 0;
        if (v18)
        {
          operator delete(v18);
        }
      }

      else
      {
        *v7 = 0;
        v8 = (v7 + 1);
      }

      a1[2] = v8;
      ++v5;
      v4 = *(a2 + 8);
    }

    while (v5 < (*(a2 + 16) - v4) >> 3);
  }
}

uint64_t fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::CacheState(uint64_t a1, uint64_t a2)
{
  fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Final(a2, a1);
  v4 = *(a2 + 64);
  v5 = *(a2 + 80);
  v6 = *(a2 + 88);
  *(a1 + 80) = 0;
  *(a1 + 64) = v4;
  *(a1 + 88) = 0;
  *(a1 + 96) = 0;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::__init_with_size[abi:ne200100]<std::__wrap_iter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const*>,std::__wrap_iter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const*>>(a1 + 80, v5, v6, 0xCCCCCCCCCCCCCCCDLL * ((v6 - v5) >> 4));
  *(a1 + 104) = *(a2 + 104);
  return a1;
}

void sub_1B5A59A8C(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 40));
  std::__list_imp<char *>::clear((v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::__init_with_size[abi:ne200100]<std::__wrap_iter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const*>,std::__wrap_iter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const*>>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1B5A59B10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const*,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const*,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      std::allocator_traits<std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::construct[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4> const&,0>(a1, v4, v6);
      v6 += 80;
      v4 = v12 + 80;
      v12 += 80;
    }

    while (v6 != a3);
  }

  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>*>>::~__exception_guard_exceptions[abi:ne200100](v9);
  return v4;
}

uint64_t fst::StateIterator<fst::ArcMapFst<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::StateIterator(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 8);
  *a1 = &unk_1F2D40838;
  *(a1 + 8) = v3;
  v4 = *(v3 + 136);
  *(a1 + 32) = 0;
  (*(*v4 + 128))(v4, a1 + 16);
  *(a1 + 40) = 0;
  *(a1 + 44) = *(*(a1 + 8) + 156) == 2;
  fst::StateIterator<fst::ArcMapFst<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::CheckSuperfinal(a1);
  return a1;
}

void sub_1B5A59C70(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 16);
  if (v3)
  {
    fst::StateIterator<fst::ArcMapFst<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::RmWeightMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>::StateIterator(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t fst::StateIterator<fst::ArcMapFst<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::CheckSuperfinal(uint64_t result)
{
  v1 = *(result + 8);
  if (*(v1 + 156) == 1)
  {
    v2 = result;
    if ((*(result + 44) & 1) == 0)
    {
      result = *(result + 16);
      if (result)
      {
        result = (*(*result + 16))(result);
        if (result)
        {
          return result;
        }

        v1 = *(v2 + 8);
      }

      else if (*(v2 + 32) >= *(v2 + 24))
      {
        return result;
      }

      v3 = (*(**(v1 + 136) + 32))(*(v1 + 136), *(v2 + 40));
      v4 = 0;
      v5 = v3;
      v6 = -1;
      fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::operator()(&v4, &v7);
      if (v7)
      {
        *(v2 + 44) = 1;
      }

      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v9);
      return std::__list_imp<char *>::clear(v8);
    }
  }

  return result;
}

void *fst::StateIterator<fst::ArcMapFst<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~StateIterator(void *a1)
{
  *a1 = &unk_1F2D40838;
  v2 = a1[2];
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return a1;
}

void fst::StateIterator<fst::ArcMapFst<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~StateIterator(void *a1)
{
  *a1 = &unk_1F2D40838;
  v1 = a1[2];
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  JUMPOUT(0x1B8C85350);
}

uint64_t fst::StateIterator<fst::ArcMapFst<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Next(uint64_t a1)
{
  ++*(a1 + 40);
  result = *(a1 + 16);
  if (result)
  {
    result = (*(*result + 16))(result);
    if ((result & 1) == 0)
    {
      v3 = *(a1 + 16);
      if (v3)
      {
        (*(*v3 + 32))(v3);
LABEL_7:

        return fst::StateIterator<fst::ArcMapFst<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::CheckSuperfinal(a1);
      }

LABEL_6:
      ++*(a1 + 32);
      goto LABEL_7;
    }
  }

  else if (*(a1 + 32) < *(a1 + 24))
  {
    goto LABEL_6;
  }

  if (*(a1 + 44) == 1)
  {
    *(a1 + 44) = 0;
  }

  return result;
}

uint64_t fst::StateIterator<fst::ArcMapFst<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Reset(uint64_t a1)
{
  *(a1 + 40) = 0;
  v2 = *(a1 + 16);
  if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  else
  {
    *(a1 + 32) = 0;
  }

  *(a1 + 44) = *(*(a1 + 8) + 156) == 2;

  return fst::StateIterator<fst::ArcMapFst<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::CheckSuperfinal(a1);
}

uint64_t fst::ArcMapFstImpl<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::InitArcIterator(uint64_t a1, int a2, void *a3)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::ArcMapFstImpl<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  return fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::InitArcIterator(a1, a2, a3);
}

void *fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::DefaultDeterminizeFilter<fst::DefaultDeterminizeFilter<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>(void *a1, uint64_t a2, void *a3)
{
  *a1 = (*(*a2 + 88))(a2, 0);
  if (a3)
  {
    if (*a3)
    {
      (*(**a3 + 8))(*a3);
    }

    MEMORY[0x1B8C85350](a3, 0x20C4093837F09);
  }

  return a1;
}

void fst::DeterminizeFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::DeterminizeFst<fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>(void *a1, uint64_t a2)
{
  *a1 = &unk_1F2D408A0;
  a1[1] = 0;
  if (!(*(*a2 + 64))(a2, 0x10000, 1))
  {
    if (FLAGS_fst_error_fatal == 1)
    {
      std::string::basic_string[abi:ne200100]<0>(__p, "FATAL");
    }

    else
    {
      std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
    }

    v3 = fst::LogMessage::LogMessage(&v8, __p);
    v4 = fst::cerr(v3);
    v5 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v4, "DeterminizeFst:", 15);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v5, " distance to final states computed for acceptors only", 53);
    fst::LogMessage::~LogMessage(&v8);
    if (v7 < 0)
    {
      operator delete(__p[0]);
    }

    *(a1[1] + 8) |= 4uLL;
  }

  operator new();
}

void sub_1B5A5A29C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  fst::LogMessage::~LogMessage(&a18);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  fst::ImplToFst<fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~ImplToFst(v18);
  _Unwind_Resume(a1);
}

_DWORD *fst::ImplToFst<fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::SetImpl(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0)
  {
    ++*(a2 + 56);
  }

  result = *(a1 + 8);
  if (result)
  {
    v6 = result[14] - 1;
    result[14] = v6;
    if (!v6)
    {
      result = (*(*result + 8))(result);
    }
  }

  *(a1 + 8) = a2;
  return result;
}

void *fst::ImplToFst<fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~ImplToFst(void *a1)
{
  *a1 = &unk_1F2D40980;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2[14] - 1;
    v2[14] = v3;
    if (!v3)
    {
      (*(*v2 + 8))(v2);
    }
  }

  return a1;
}

void fst::DeterminizeFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::~DeterminizeFst(void *a1)
{
  fst::ImplToFst<fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~ImplToFst(a1);

  JUMPOUT(0x1B8C85350);
}

uint64_t fst::ImplToFst<fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Properties(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    v8 = 0;
    v5 = fst::TestProperties<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>(a1, a2, &v8);
    *(*(a1 + 8) + 8) = *(*(a1 + 8) + 8) & (~v8 | 4) | v8 & v5;
    return v5 & a2;
  }

  else
  {
    v7 = *(**(a1 + 8) + 32);

    return v7();
  }
}

void sub_1B5A5A8A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  fst::LogMessage::~LogMessage(&a18);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::~DeterminizeFstImplBase(v18);
  _Unwind_Resume(a1);
}

uint64_t fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::~DeterminizeFstImplBase(void *a1)
{
  *a1 = &unk_1F2D40AB8;
  v2 = a1[17];
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~CacheBaseImpl(a1);
}

void fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::~DeterminizeFsaImpl(void *a1)
{
  fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::~DeterminizeFsaImpl(a1);

  JUMPOUT(0x1B8C85350);
}

uint64_t fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::Properties(uint64_t a1, uint64_t a2)
{
  if ((a2 & 4) != 0 && (*(**(a1 + 136) + 64))(*(a1 + 136), 4, 0))
  {
    *(a1 + 8) |= 4uLL;
  }

  return *(a1 + 8) & a2;
}

void fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::Expand(uint64_t *a1, int a2)
{
  v9[0] = 0;
  v9[1] = 0;
  v8 = v9;
  fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::GetLabelMap(a1, a2, &v8);
  v4 = v8;
  if (v8 != v9)
  {
    do
    {
      fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::AddArc(a1, a2, (v4 + 5));
      v5 = v4[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = *v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          v6 = v4[2];
          v7 = *v6 == v4;
          v4 = v6;
        }

        while (!v7);
      }

      v4 = v6;
    }

    while (v6 != v9);
  }

  fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::SetArcs(a1, a2);
  std::__tree<std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>,std::__map_value_compare<int,std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>,std::less<int>,true>,std::allocator<std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>>>::destroy(&v8, v9[0]);
}

uint64_t fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::ComputeStart(uint64_t a1)
{
  v1 = (*(**(a1 + 136) + 24))(*(a1 + 136));
  if (v1 != -1)
  {
    v2 = v1;
    v3 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::One();
    v5 = *v3;
    std::list<int>::list(v6, (v3 + 2));
    v7 = v3[8];
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v8, (v3 + 10));
    fst::DeterminizeElement<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::DeterminizeElement(v9, v2, &v5);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v8);
    std::__list_imp<char *>::clear(v6);
    operator new();
  }

  return 0xFFFFFFFFLL;
}

void sub_1B5A5AEBC(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v2 + 40));
  std::__list_imp<char *>::clear(v1);
  _Unwind_Resume(a1);
}

void *fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::ComputeFinal@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  v5 = *(*(*(a1 + 184) + 88) + 8 * a2);
  v6 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero();
  *a3 = *v6;
  std::list<int>::list((a3 + 8), (v6 + 2));
  *(a3 + 32) = v6[8];
  result = std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a3 + 40), (v6 + 10));
  for (i = *v5; i; i = *i)
  {
    (*(**(a1 + 136) + 32))(&v32);
    fst::Times<int,fst::LogWeightTpl<float>>(i + 4, &v32, &v35);
    fst::Plus<int,fst::LogWeightTpl<float>>(a3, &v35, &v38);
    *a3 = v38;
    if (&v38 != a3)
    {
      std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a3 + 8), v40, &v39);
    }

    *(a3 + 32) = v41;
    std::list<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::__move_assign((a3 + 40), v42);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v42);
    std::__list_imp<char *>::clear(&v39);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v37);
    std::__list_imp<char *>::clear(v36);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v34);
    std::__list_imp<char *>::clear(v33);
    v26 = *a3;
    std::list<int>::list(v27, a3 + 8);
    v28 = *(a3 + 32);
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(&v29, a3 + 40);
    v38 = v26;
    std::list<int>::list(&v39, v27);
    v41 = v28;
    v42[0] = v42;
    v42[1] = v42;
    v43 = 0;
    v9 = v31;
    if (v31)
    {
      v11 = v29;
      v10 = v30;
      v12 = *(v29 + 8);
      v13 = *v30;
      *(v13 + 8) = v12;
      *v12 = v13;
      v14 = v42[0];
      *(v42[0] + 8) = v10;
      *v10 = v14;
      v42[0] = v11;
      *(v11 + 8) = v42;
      v43 = v9;
      v31 = 0;
    }

    *a3 = v38;
    if (&v38 != a3)
    {
      std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a3 + 8), v40, &v39);
    }

    *(a3 + 32) = v41;
    std::list<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::__move_assign((a3 + 40), v42);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v42);
    std::__list_imp<char *>::clear(&v39);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(&v29);
    result = std::__list_imp<char *>::clear(v27);
    v15 = *a3;
    if (*a3)
    {
      if (*(a3 + 24))
      {
        v16 = 0;
      }

      else
      {
        v16 = v15 == -2;
      }

      if (!v16 && *(a3 + 32) != -INFINITY)
      {
LABEL_16:
        if ((*(a3 + 56) + 1) >= 2)
        {
          v19 = v15 != -2 || *(a3 + 24) != 0 || v15 == 0;
          v20 = 1;
          v21 = (a3 + 48);
LABEL_27:
          v22 = *v21;
          while (1)
          {
            v23 = v20;
            if (v20)
            {
              v24 = a3;
              if (!v19)
              {
                goto LABEL_41;
              }
            }

            else
            {
              v24 = v22 + 16;
              if (v22 == a3 + 40)
              {
                goto LABEL_41;
              }
            }

            if (*v24)
            {
              if (*v24 == -2 && *(v24 + 24) == 0)
              {
                break;
              }
            }

            if (*(v24 + 32) == -INFINITY)
            {
              break;
            }

            v20 = 0;
            if ((v23 & 1) == 0)
            {
              v20 = 0;
              v21 = (v22 + 8);
              goto LABEL_27;
            }
          }

          *(a1 + 8) |= 4uLL;
        }
      }
    }

    else if (*(a3 + 32) != -INFINITY)
    {
      goto LABEL_16;
    }

LABEL_41:
    ;
  }

  return result;
}

void *fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::CompactHashBiTable(void *a1, size_t a2)
{
  a1[1] = a1;
  a1[2] = a1;
  std::unordered_set<int,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashFunc,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashEqual,std::allocator<int>>::unordered_set((a1 + 3), a2, a1 + 1, a1 + 2);
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 0;
  if (a2)
  {
    std::vector<fst::VectorState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>> *,std::allocator<fst::VectorState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>> *>>::reserve(a1 + 10, a2);
  }

  return a1;
}

void sub_1B5A5B32C(_Unwind_Exception *a1)
{
  v4 = *v2;
  if (*v2)
  {
    *(v1 + 88) = v4;
    operator delete(v4);
  }

  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(v1 + 24);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_set<int,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashFunc,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashEqual,std::allocator<int>>::unordered_set(uint64_t a1, size_t a2, void *a3, void *a4)
{
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *(a1 + 32) = *a3;
  *(a1 + 40) = 1065353216;
  *(a1 + 48) = *a4;
  std::__hash_table<int,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashFunc,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashEqual,std::allocator<int>>::__rehash<true>(a1, a2);
  return a1;
}

uint64_t fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::~DeterminizeFsaImpl(void *a1)
{
  *a1 = &unk_1F2D40A30;
  v2 = a1[22];
  if (v2)
  {
    if (*v2)
    {
      (*(**v2 + 8))(*v2);
    }

    MEMORY[0x1B8C85350](v2, 0x20C4093837F09);
  }

  v3 = a1[23];
  if (v3)
  {
    v4 = fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::~DefaultDeterminizeStateTable(v3);
    MEMORY[0x1B8C85350](v4, 0x10E0C400200E20DLL);
  }

  return fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::~DeterminizeFstImplBase(a1);
}

void sub_1B5A5B5F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  fst::LogMessage::~LogMessage(&a18);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::~DeterminizeFstImplBase(v18);
  _Unwind_Resume(a1);
}

void sub_1B5A5B780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~CacheBaseImpl(v15);
  _Unwind_Resume(a1);
}

uint64_t *fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::GetLabelMap(uint64_t *result, int a2, void *a3)
{
  v4 = result;
  v5 = **(*(result[23] + 88) + 8 * a2);
  if (v5)
  {
    while (1)
    {
      v6 = v5[2];
      v7 = *(v4 + 136);
      v23 = 0;
      (*(*v7 + 136))(v7, v6, v21);
      result = v21[0];
      if (!v21[0])
      {
        break;
      }

      v8 = (*(*v21[0] + 24))(v21[0]);
      result = v21[0];
      if (!v8)
      {
        if (v21[0])
        {
          v9 = (*(*v21[0] + 32))(v21[0]);
        }

        else
        {
LABEL_7:
          v9 = (v21[1] + 80 * v23);
        }

        v10 = v9[18];
        fst::Times<int,fst::LogWeightTpl<float>>(v5 + 4, v9 + 2, &v17);
        fst::DeterminizeElement<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::DeterminizeElement(v20, v10, &v17);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v19);
        std::__list_imp<char *>::clear(v18);
        fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::FilterArc(*(v4 + 176), v9, (v5 + 2), v20, a3);
      }

      if (!v21[0])
      {
        goto LABEL_11;
      }

      result = (*(*v21[0] + 8))(v21[0]);
LABEL_13:
      v5 = *v5;
      if (!v5)
      {
        goto LABEL_14;
      }
    }

    if (v23 < v21[2])
    {
      goto LABEL_7;
    }

LABEL_11:
    if (v22)
    {
      --*v22;
    }

    goto LABEL_13;
  }

LABEL_14:
  v13 = *a3;
  v11 = a3 + 1;
  v12 = v13;
  if (v13 != v11)
  {
    do
    {
      result = fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::NormArc(v4, (v12 + 5));
      v14 = v12[1];
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = *v14;
        }

        while (v14);
      }

      else
      {
        do
        {
          v15 = v12[2];
          v16 = *v15 == v12;
          v12 = v15;
        }

        while (!v16);
      }

      v12 = v15;
    }

    while (v15 != v11);
  }

  return result;
}

void sub_1B5A5BA0C(_Unwind_Exception *exception_object)
{
  v3 = *(v1 - 120);
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  else
  {
    v4 = *(v1 - 96);
    if (v4)
    {
      --*v4;
    }
  }

  _Unwind_Resume(exception_object);
}

void *fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::AddArc(uint64_t a1, int a2, uint64_t a3)
{
  v6 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::NoWeight();
  v11 = *v6;
  std::list<int>::list(v12, (v6 + 2));
  v7 = v6[8];
  v14[0] = v14;
  v14[1] = v14;
  v14[2] = 0;
  v10[0] = *a3;
  v10[1] = v10[0];
  v8 = *(a3 + 8);
  v13 = v7;
  v11 = v8;
  if (v10 == a3)
  {
    v13 = *(a3 + 40);
  }

  else
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v12, *(a3 + 24), a3 + 16);
    v13 = *(a3 + 40);
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,void *>,std::__list_const_iterator<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,void *>>(v14, *(a3 + 56), a3 + 48);
  }

  State = fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::FindState(a1, *(a3 + 72));
  fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::PushArc(a1, a2, v10);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v14);
  return std::__list_imp<char *>::clear(v12);
}

void sub_1B5A5BB80(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v1);
  std::__list_imp<char *>::clear((v2 + 16));
  _Unwind_Resume(a1);
}

void *fst::Times<int,fst::LogWeightTpl<float>>@<X0>(int *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  v11 = *a1;
  std::list<int>::list(v12, (a1 + 2));
  v13 = a1[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v14, (a1 + 10));
  v7 = *a2;
  std::list<int>::list(v8, (a2 + 2));
  v9 = a2[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v10, (a2 + 10));
  fst::Times<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>(&v11, &v7, &v15);
  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::GallicWeight(a3, &v15);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v17);
  std::__list_imp<char *>::clear(v16);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v10);
  std::__list_imp<char *>::clear(v8);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v14);
  return std::__list_imp<char *>::clear(v12);
}

void sub_1B5A5BC7C(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 40));
  std::__list_imp<char *>::clear((v1 + 8));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v2 + 40));
  std::__list_imp<char *>::clear((v2 + 8));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v3 + 40));
  std::__list_imp<char *>::clear((v3 + 8));
  _Unwind_Resume(a1);
}

uint64_t fst::DeterminizeElement<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::DeterminizeElement(uint64_t a1, int a2, _DWORD *a3)
{
  *a1 = a2;
  *(a1 + 8) = *a3;
  std::list<int>::list((a1 + 16), (a3 + 2));
  *(a1 + 40) = a3[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a1 + 48), (a3 + 10));
  return a1;
}

void fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::FilterArc(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v6 = a2;
  if (*(std::__tree<std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>,std::__map_value_compare<int,std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>,std::less<int>,true>,std::allocator<std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(a5, a2) + 10) == -1)
  {
    fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::DeterminizeArc(&v6, a2);
  }

  std::__forward_list_base<fst::DeterminizeElement<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::__create_node[abi:ne200100]<fst::DeterminizeElement<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>> const&>();
}

void sub_1B5A5BE3C(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 48));
  std::__list_imp<char *>::clear((v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t *fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::NormArc(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 72);
  result = std::forward_list<fst::DeterminizeElement<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>::sort[abi:ne200100](v4);
  v6 = *v4;
  if (*v4)
  {
    v7 = (a2 + 8);
    v8 = *v4;
    do
    {
      fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>::operator()(a1 + 168, a2 + 8, (v8 + 2), &v18);
      *v7 = v18;
      if (v7 != &v18)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a2 + 16), v20, &v19);
      }

      *(a2 + 40) = v21;
      std::list<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::__move_assign((a2 + 48), v22);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v22);
      result = std::__list_imp<char *>::clear(&v19);
      if (v6 == v8 || *(v8 + 2) != *(v6 + 2))
      {
        v16 = *v8;
        v6 = v8;
      }

      else
      {
        fst::Plus<int,fst::LogWeightTpl<float>>(v6 + 4, v8 + 4, &v18);
        *(v6 + 4) = v18;
        if (v6 + 2 != &v18)
        {
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v6 + 3, v20, &v19);
        }

        *(v6 + 12) = v21;
        std::list<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::__move_assign(v6 + 7, v22);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v22);
        std::__list_imp<char *>::clear(&v19);
        v9 = *(v6 + 4);
        if ((v9 != -2 || v6[5]) && *(v6 + 12) != -INFINITY && (v6[9] + 1) >= 2)
        {
          v10 = (v6 + 8);
          v11 = 1;
LABEL_14:
          v12 = *v10;
          while (1)
          {
            v13 = v11;
            if (v11)
            {
              v14 = v6 + 2;
              if (v9)
              {
                v14 = v6 + 2;
                if (v9 == -2)
                {
                  v14 = v6 + 2;
                  if (!v6[5])
                  {
                    goto LABEL_31;
                  }
                }
              }
            }

            else
            {
              v14 = v12 + 2;
              if (v12 == v6 + 7)
              {
                goto LABEL_31;
              }
            }

            if (*v14)
            {
              if (*v14 == -2 && v14[3] == 0)
              {
                break;
              }
            }

            if (*(v14 + 8) == -INFINITY)
            {
              break;
            }

            v11 = 0;
            if ((v13 & 1) == 0)
            {
              v11 = 0;
              v10 = (v12 + 1);
              goto LABEL_14;
            }
          }

          *(a1 + 8) |= 4uLL;
        }

LABEL_31:
        v16 = *v8;
        result = std::forward_list<fst::DeterminizeElement<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::erase_after(v4, v6);
      }

      v8 = v16;
    }

    while (v16);
    for (i = *v4; i; i = *i)
    {
      fst::Divide<int,fst::LogWeightTpl<float>>(i + 4, v7, 0, &v18);
      *(i + 4) = v18;
      if (i + 2 != &v18)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(i + 3, v20, &v19);
      }

      *(i + 12) = v21;
      std::list<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::__move_assign(i + 7, v22);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v22);
      std::__list_imp<char *>::clear(&v19);
      fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Quantize((i + 2), &v18, *(a1 + 144));
      *(i + 4) = v18;
      if (i + 2 != &v18)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(i + 3, v20, &v19);
      }

      *(i + 12) = v21;
      std::list<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::__move_assign(i + 7, v22);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v22);
      result = std::__list_imp<char *>::clear(&v19);
    }
  }

  return result;
}

void sub_1B5A5C14C(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 40));
  std::__list_imp<char *>::clear((v1 + 8));
  _Unwind_Resume(a1);
}

float fst::Times<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v4 = a1;
  v5 = *a1;
  if (*a1)
  {
    if (*(a1 + 24))
    {
      v6 = 0;
    }

    else
    {
      v6 = v5 == -2;
    }

    if (v6 || *(a1 + 32) == -INFINITY)
    {
      goto LABEL_10;
    }
  }

  else if (*(a1 + 32) == -INFINITY)
  {
    goto LABEL_10;
  }

  if ((*(a1 + 56) + 1) >= 2)
  {
    v13 = (a1 + 48);
    v16 = v5 != -2 || *(a1 + 24) != 0 || v5 == 0;
    v17 = 1;
LABEL_32:
    v18 = *v13;
    while (1)
    {
      v19 = v17;
      if (v17)
      {
        v20 = a1;
        if (!v16)
        {
          break;
        }
      }

      else
      {
        v20 = v18 + 16;
        if (v18 == a1 + 40)
        {
          break;
        }
      }

      if (*v20)
      {
        if (*v20 == -2 && *(v20 + 24) == 0)
        {
          goto LABEL_68;
        }
      }

      if (*(v20 + 32) == -INFINITY)
      {
        goto LABEL_68;
      }

      v17 = 0;
      if ((v19 & 1) == 0)
      {
        v17 = 0;
        v13 = (v18 + 8);
        goto LABEL_32;
      }
    }
  }

LABEL_10:
  v7 = *a2;
  if (*a2)
  {
    if (*(a2 + 24))
    {
      v8 = 0;
    }

    else
    {
      v8 = v7 == -2;
    }

    if (v8 || *(a2 + 32) == -INFINITY)
    {
      goto LABEL_19;
    }
  }

  else if (*(a2 + 32) == -INFINITY)
  {
    goto LABEL_19;
  }

  if ((*(a2 + 56) + 1) < 2)
  {
LABEL_19:
    v9 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::Zero();
    if ((fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(v4, v9) & 1) != 0 || (v10 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::Zero(), fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(a2, v10)))
    {
      v11 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::Zero();
      *a3 = *v11;
      std::list<int>::list((a3 + 8), (v11 + 2));
      *(a3 + 32) = v11[8];
      std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a3 + 40), (v11 + 10));
      return result;
    }

    v51 = v4 + 40;
    v33 = *(v4 + 48);
    v34 = *(a2 + 48);
    v35 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::NoWeight();
    *a3 = *v35;
    std::list<int>::list((a3 + 8), (v35 + 2));
    *(a3 + 32) = v35[8];
    *(a3 + 40) = a3 + 40;
    *(a3 + 48) = a3 + 40;
    v52 = v4;
    *(a3 + 56) = 0;
    v36 = v33;
    v37 = 1;
LABEL_71:
    v53 = v36;
    v54 = v36 + 16;
LABEL_72:
    v38 = v37;
    if (v37)
    {
      if (*v4)
      {
        if (*(v4 + 24))
        {
          v39 = 0;
        }

        else
        {
          v39 = *v4 == -2;
        }

        if (v39)
        {
          return result;
        }

        result = *(v4 + 32);
        if (result == -INFINITY)
        {
          return result;
        }
      }

      else
      {
        result = *(v4 + 32);
        if (result == -INFINITY)
        {
          return result;
        }
      }
    }

    else if (v36 == v51)
    {
      return result;
    }

    v40 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::NoWeight();
    LODWORD(v62) = *v40;
    std::list<int>::list(v63, (v40 + 2));
    v64 = v40[8];
    v65[0] = v65;
    v65[1] = v65;
    v65[2] = 0;
    if (v38)
    {
      v41 = v4;
    }

    else
    {
      v41 = v54;
    }

    v42 = 1;
    while (1)
    {
      v43 = v42;
      if (v42)
      {
        if (*a2)
        {
          if (*(a2 + 24))
          {
            v44 = 0;
          }

          else
          {
            v44 = *a2 == -2;
          }

          if (v44 || *(a2 + 32) == -INFINITY)
          {
LABEL_110:
            fst::Plus<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>(a3, &v62, &v56);
            *a3 = v56;
            v4 = v52;
            if (&v56 != a3)
            {
              std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a3 + 8), v57[1], v57);
            }

            *(a3 + 32) = v58;
            std::list<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::__move_assign((a3 + 40), v59);
            std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v59);
            std::__list_imp<char *>::clear(v57);
            v34 = *(a2 + 48);
            std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v65);
            std::__list_imp<char *>::clear(v63);
            v37 = 0;
            v36 = v53;
            if ((v38 & 1) == 0)
            {
              v37 = 0;
              v36 = *(v53 + 8);
              goto LABEL_71;
            }

            goto LABEL_72;
          }
        }

        else if (*(a2 + 32) == -INFINITY)
        {
          goto LABEL_110;
        }
      }

      else if (v34 == a2 + 40)
      {
        goto LABEL_110;
      }

      if (v42)
      {
        v45 = a2;
      }

      else
      {
        v45 = v34 + 16;
      }

      fst::Times<int,(fst::StringType)2>(v41, v45, &v56);
      v46 = *(v41 + 32);
      v47 = NAN;
      if (v46 != -INFINITY)
      {
        v48 = *(v45 + 32);
        v47 = NAN;
        if (v48 != -INFINITY)
        {
          v47 = INFINITY;
          v49 = v48 == INFINITY || v46 == INFINITY;
          v50 = v46 + v48;
          if (!v49)
          {
            v47 = v50;
          }
        }
      }

      fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::GallicWeight(v60, &v56, v47);
      std::__list_imp<char *>::clear(v57);
      fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::PushBack(&v62, v60, 1);
      std::__list_imp<char *>::clear(v61);
      v42 = 0;
      if ((v43 & 1) == 0)
      {
        v42 = 0;
        v34 = *(v34 + 8);
      }
    }
  }

  v22 = (a2 + 48);
  v25 = v7 != -2 || *(a2 + 24) != 0 || v7 == 0;
  v26 = 1;
LABEL_55:
  v27 = *v22;
  while (1)
  {
    v28 = v26;
    if (v26)
    {
      v29 = a2;
      if (!v25)
      {
        goto LABEL_19;
      }
    }

    else
    {
      v29 = v27 + 16;
      if (v27 == a2 + 40)
      {
        goto LABEL_19;
      }
    }

    if (*v29)
    {
      if (*v29 == -2 && *(v29 + 24) == 0)
      {
        break;
      }
    }

    if (*(v29 + 32) == -INFINITY)
    {
      break;
    }

    v26 = 0;
    if ((v28 & 1) == 0)
    {
      v26 = 0;
      v22 = (v27 + 8);
      goto LABEL_55;
    }
  }

LABEL_68:
  v32 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::NoWeight();
  *a3 = *v32;
  std::list<int>::list((a3 + 8), (v32 + 2));
  *(a3 + 32) = v32[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a3 + 40), (v32 + 10));
  return result;
}

uint64_t fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::NoWeight()
{
  {
    operator new();
  }

  return fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::NoWeight(void)::no_weight;
}

void sub_1B5A5C858(_Unwind_Exception *a1)
{
  std::__list_imp<char *>::clear((v3 + 8));
  std::__list_imp<char *>::clear((v2 + 8));
  MEMORY[0x1B8C85350](v1, 0x1020C404C081FCELL);
  _Unwind_Resume(a1);
}

uint64_t *fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::PushBack(uint64_t *result, uint64_t a2, int a3)
{
  v4 = result;
  v5 = *a2;
  if (*a2)
  {
    if (v5 == -2 && *(a2 + 24) == 0)
    {
      goto LABEL_8;
    }
  }

  v7 = *(a2 + 32);
  if (v7 >= -INFINITY && v7 <= -INFINITY)
  {
    goto LABEL_8;
  }

  if (*result != -2 || result[3])
  {
    v8 = *(result + 8);
    if (v8 < -INFINITY || v8 > -INFINITY)
    {
      if (a3)
      {
        v9 = result;
        if (result[7])
        {
          v9 = result[5] + 16;
        }

        if (!fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>::Compare::operator()(&v13, v9, a2))
        {
          fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>::Merge::operator()(v9, a2, &v10);
          *v9 = v10;
          if (v9 != &v10)
          {
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v9 + 8), v11[1], v11);
          }

          *(v9 + 32) = v12;
          return std::__list_imp<char *>::clear(v11);
        }
      }

      else if (!fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>::Compare::operator()(&v13, result, a2))
      {
        std::__list_imp<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::__create_node[abi:ne200100]<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2> const&>();
      }

LABEL_8:
      std::__list_imp<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::__create_node[abi:ne200100]<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2> const&>();
    }
  }

  *result = v5;
  if (result != a2)
  {
    result = std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(result + 1, *(a2 + 16), a2 + 8);
  }

  *(v4 + 8) = *(a2 + 32);
  return result;
}

void sub_1B5A5CA68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__list_imp<char *>::clear(va);
  _Unwind_Resume(a1);
}

float fst::Plus<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v6 = *a1;
  if (*a1)
  {
    if (*(a1 + 24))
    {
      v7 = 0;
    }

    else
    {
      v7 = v6 == -2;
    }

    if (v7 || *(a1 + 32) == -INFINITY)
    {
      goto LABEL_10;
    }
  }

  else if (*(a1 + 32) == -INFINITY)
  {
    goto LABEL_10;
  }

  if ((*(a1 + 56) + 1) >= 2)
  {
    v13 = (a1 + 48);
    v16 = v6 != -2 || *(a1 + 24) != 0 || v6 == 0;
    v17 = 1;
LABEL_33:
    v18 = *v13;
    while (1)
    {
      v19 = v17;
      if (v17)
      {
        v20 = a1;
        if (!v16)
        {
          break;
        }
      }

      else
      {
        v20 = v18 + 16;
        if (v18 == a1 + 40)
        {
          break;
        }
      }

      if (*v20)
      {
        if (*v20 == -2 && *(v20 + 24) == 0)
        {
          goto LABEL_69;
        }
      }

      if (*(v20 + 32) == -INFINITY)
      {
        goto LABEL_69;
      }

      v17 = 0;
      if ((v19 & 1) == 0)
      {
        v17 = 0;
        v13 = (v18 + 8);
        goto LABEL_33;
      }
    }
  }

LABEL_10:
  v8 = *a2;
  if (!*a2)
  {
    if (*(a2 + 32) == -INFINITY)
    {
      goto LABEL_19;
    }

    goto LABEL_18;
  }

  if (*(a2 + 24))
  {
    v9 = 0;
  }

  else
  {
    v9 = v8 == -2;
  }

  if (!v9 && *(a2 + 32) != -INFINITY)
  {
LABEL_18:
    if ((*(a2 + 56) + 1) < 2)
    {
      goto LABEL_19;
    }

    v22 = (a2 + 48);
    v25 = v8 != -2 || *(a2 + 24) != 0 || v8 == 0;
    v26 = 1;
LABEL_56:
    v27 = *v22;
    while (1)
    {
      v28 = v26;
      if (v26)
      {
        v29 = a2;
        if (!v25)
        {
          goto LABEL_19;
        }
      }

      else
      {
        v29 = v27 + 16;
        if (v27 == a2 + 40)
        {
          goto LABEL_19;
        }
      }

      if (*v29)
      {
        if (*v29 == -2 && *(v29 + 24) == 0)
        {
          break;
        }
      }

      if (*(v29 + 32) == -INFINITY)
      {
        break;
      }

      v26 = 0;
      if ((v28 & 1) == 0)
      {
        v26 = 0;
        v22 = (v27 + 8);
        goto LABEL_56;
      }
    }

LABEL_69:
    v31 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::NoWeight();
    *a3 = *v31;
    std::list<int>::list((a3 + 8), (v31 + 2));
    *(a3 + 32) = v31[8];
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a3 + 40), (v31 + 10));
    return result;
  }

LABEL_19:
  v10 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::Zero();
  if (fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(a1, v10))
  {
    *a3 = *a2;
    std::list<int>::list((a3 + 8), a2 + 8);
    *(a3 + 32) = *(a2 + 32);
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a3 + 40), a2 + 40);
  }

  else
  {
    v12 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::Zero();
    if (!fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(a2, v12))
    {
      v32 = *(a1 + 48);
      v49 = a2 + 40;
      v50 = a1 + 40;
      v33 = *(a2 + 48);
      v34 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::NoWeight();
      *a3 = *v34;
      std::list<int>::list((a3 + 8), (v34 + 2));
      *(a3 + 32) = v34[8];
      *(a3 + 40) = a3 + 40;
      *(a3 + 48) = a3 + 40;
      *(a3 + 56) = 0;
      v35 = 1;
      v36 = 1;
LABEL_74:
      if (*a1)
      {
        if (*(a1 + 24))
        {
          v37 = 0;
        }

        else
        {
          v37 = *a1 == -2;
        }

        if (!v37)
        {
          result = *(a1 + 32);
          if (result != -INFINITY)
          {
            while (1)
            {
LABEL_82:
              if (v35)
              {
                if (*a2)
                {
                  if (*(a2 + 24))
                  {
                    v38 = 0;
                  }

                  else
                  {
                    v38 = *a2 == -2;
                  }

                  if (v38)
                  {
                    goto LABEL_108;
                  }

                  result = *(a2 + 32);
                  if (result == -INFINITY)
                  {
                    goto LABEL_108;
                  }
                }

                else
                {
                  result = *(a2 + 32);
                  if (result == -INFINITY)
                  {
                    goto LABEL_108;
                  }
                }
              }

              else if (v33 == v49)
              {
                goto LABEL_108;
              }

              if (v36)
              {
                v39 = a1;
              }

              else
              {
                v39 = (v32 + 16);
              }

              v66 = *v39;
              std::list<int>::list(v67, (v39 + 2));
              v68 = v39[8];
              if (v35)
              {
                v40 = a2;
              }

              else
              {
                v40 = (v33 + 16);
              }

              v63 = *v40;
              std::list<int>::list(v64, (v40 + 2));
              v65 = v40[8];
              if (fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>::Compare::operator()(v69, &v66, &v63))
              {
                v60 = v66;
                std::list<int>::list(v61, v67);
                v62 = v68;
                fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::PushBack(a3, &v60, 1);
                std::__list_imp<char *>::clear(v61);
                if (v36)
                {
                  v36 = 0;
                }

                else
                {
                  v36 = 0;
                  v32 = *(v32 + 8);
                }
              }

              else
              {
                v57 = v63;
                std::list<int>::list(v58, v64);
                v59 = v65;
                fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::PushBack(a3, &v57, 1);
                std::__list_imp<char *>::clear(v58);
                if (v35)
                {
                  v35 = 0;
                }

                else
                {
                  v35 = 0;
                  v33 = *(v33 + 8);
                }
              }

              std::__list_imp<char *>::clear(v64);
              std::__list_imp<char *>::clear(v67);
              if (v36)
              {
                goto LABEL_74;
              }

              if (v32 == v50)
              {
                goto LABEL_108;
              }
            }
          }
        }
      }

      else
      {
        result = *(a1 + 32);
        if (result != -INFINITY)
        {
          goto LABEL_82;
        }
      }

      while (1)
      {
LABEL_108:
        v41 = v36;
        if (v36)
        {
          v42 = *a1;
          if (*a1)
          {
            if (*(a1 + 24))
            {
              v43 = 0;
            }

            else
            {
              v43 = v42 == -2;
            }

            if (v43 || (result = *(a1 + 32), v44 = a1, result >= -INFINITY) && result <= -INFINITY)
            {
              while (1)
              {
LABEL_122:
                v45 = v35;
                if (v35)
                {
                  v46 = *a2;
                  if (*a2)
                  {
                    if (*(a2 + 24))
                    {
                      v47 = 0;
                    }

                    else
                    {
                      v47 = v46 == -2;
                    }

                    if (v47)
                    {
                      return result;
                    }

                    result = *(a2 + 32);
                    v48 = a2;
                    if (result == -INFINITY)
                    {
                      return result;
                    }
                  }

                  else
                  {
                    result = *(a2 + 32);
                    v48 = a2;
                    if (result == -INFINITY)
                    {
                      return result;
                    }
                  }
                }

                else
                {
                  if (v33 == v49)
                  {
                    return result;
                  }

                  v46 = *(v33 + 16);
                  v48 = v33 + 16;
                }

                v51 = v46;
                std::list<int>::list(v52, v48 + 8);
                v53 = *(v48 + 32);
                fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::PushBack(a3, &v51, 1);
                std::__list_imp<char *>::clear(v52);
                v35 = 0;
                if ((v45 & 1) == 0)
                {
                  v35 = 0;
                  v33 = *(v33 + 8);
                }
              }
            }
          }

          else
          {
            result = *(a1 + 32);
            v44 = a1;
            if (result == -INFINITY)
            {
              goto LABEL_122;
            }
          }
        }

        else
        {
          if (v32 == v50)
          {
            goto LABEL_122;
          }

          v42 = *(v32 + 16);
          v44 = v32 + 16;
        }

        v54 = v42;
        std::list<int>::list(v55, v44 + 8);
        v56 = *(v44 + 32);
        fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::PushBack(a3, &v54, 1);
        std::__list_imp<char *>::clear(v55);
        v36 = 0;
        if ((v41 & 1) == 0)
        {
          v36 = 0;
          v32 = *(v32 + 8);
        }
      }
    }

    *a3 = *a1;
    std::list<int>::list((a3 + 8), a1 + 8);
    *(a3 + 32) = *(a1 + 32);
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a3 + 40), a1 + 40);
  }

  return result;
}

uint64_t fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::UnionWeight(uint64_t a1, _DWORD *a2)
{
  *a1 = *a2;
  std::list<int>::list((a1 + 8), (a2 + 2));
  *(a1 + 32) = a2[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a1 + 40), 1);
  return a1;
}

uint64_t fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>::Compare::operator()(uint64_t a1, int *a2, int *a3)
{
  v21 = *a2;
  std::list<int>::list(v22, (a2 + 2));
  v17 = *a3;
  std::list<int>::list(&v18, (a3 + 2));
  if (v21)
  {
    v4 = v23 + 1;
  }

  else
  {
    v4 = 0;
  }

  if (!v17 || v20 + 1 <= v4)
  {
    if (v17)
    {
      v6 = v20 + 1;
    }

    else
    {
      v6 = 0;
    }

    if (v21 && v23 + 1 > v6)
    {
LABEL_12:
      v5 = 0;
      goto LABEL_13;
    }

    v8 = v22[1];
    v9 = &v19;
    v10 = 1;
LABEL_15:
    v11 = *v9;
    while (1)
    {
      v12 = v10;
      if (v10)
      {
        if (!v21)
        {
          goto LABEL_12;
        }

        v13 = &v21;
      }

      else
      {
        v13 = (v8 + 2);
        if (v8 == v22)
        {
          goto LABEL_12;
        }
      }

      v14 = *v13;
      v15 = (v12 & 1) != 0 ? &v17 : (v11 + 16);
      v16 = *v15;
      if (v14 < v16)
      {
        break;
      }

      if (v14 > v16)
      {
        goto LABEL_12;
      }

      v10 = 0;
      if ((v12 & 1) == 0)
      {
        v10 = 0;
        v8 = v8[1];
        v9 = (v11 + 8);
        goto LABEL_15;
      }
    }
  }

  v5 = 1;
LABEL_13:
  std::__list_imp<char *>::clear(&v18);
  std::__list_imp<char *>::clear(v22);
  return v5;
}

void *fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>::Merge::operator()@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  v11 = *a1;
  std::list<int>::list(v12, a1 + 8);
  v6 = *(a1 + 32);
  v7 = *(a2 + 32);
  if (v6 != INFINITY)
  {
    if (v7 == INFINITY)
    {
      v7 = *(a1 + 32);
    }

    else if (v6 <= v7)
    {
      v9 = expf(-(v7 - v6));
      v7 = v6 - logf(v9 + 1.0);
    }

    else
    {
      v8 = expf(-(v6 - v7));
      v7 = v7 - logf(v8 + 1.0);
    }
  }

  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::GallicWeight(a3, &v11, v7);
  return std::__list_imp<char *>::clear(v12);
}

uint64_t *std::__tree<std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>,std::__map_value_compare<int,std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>,std::less<int>,true>,std::allocator<std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int *a2)
{
  v2 = *(a1 + 8);
  if (!v2)
  {
LABEL_8:
    std::__tree<std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>,std::__map_value_compare<int,std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>,std::less<int>,true>,std::allocator<std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>();
  }

  v3 = *a2;
  while (1)
  {
    while (1)
    {
      v4 = v2;
      v5 = *(v2 + 32);
      if (v3 >= v5)
      {
        break;
      }

      v2 = *v4;
      if (!*v4)
      {
        goto LABEL_8;
      }
    }

    if (v5 >= v3)
    {
      return v4;
    }

    v2 = v4[1];
    if (!v2)
    {
      goto LABEL_8;
    }
  }
}

void sub_1B5A5D60C(_Unwind_Exception *a1)
{
  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>>,void *>>>::operator()[abi:ne200100](v3, v2);
  _Unwind_Resume(a1);
}

void fst::DeterminizeArc<fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::DeterminizeArc(uint64_t a1, _DWORD *a2)
{
  *a1 = *a2;
  v3 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero();
  *(a1 + 8) = *v3;
  std::list<int>::list((a1 + 16), (v3 + 2));
  *(a1 + 40) = v3[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a1 + 48), (v3 + 10));
  operator new();
}

void sub_1B5A5D6AC(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 48));
  std::__list_imp<char *>::clear((v1 + 16));
  _Unwind_Resume(a1);
}

void sub_1B5A5D750(_Unwind_Exception *a1)
{
  std::__list_imp<char *>::clear(v1 + 3);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>::operator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v7 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::Zero();
  v38 = *v7;
  std::list<int>::list(v39, v7 + 8);
  v40 = *(v7 + 32);
  v8 = (a2 + 48);
  v9 = 1;
LABEL_2:
  v10 = *v8;
  v11 = *v8 + 16;
  while (1)
  {
    v12 = v9;
    if ((v9 & 1) == 0)
    {
      if (v10 == a2 + 40)
      {
        break;
      }

      v14 = v11;
      goto LABEL_13;
    }

    if (!*a2)
    {
      v15 = *(a2 + 32);
      if (v15 >= -INFINITY && v15 <= -INFINITY)
      {
        break;
      }

      goto LABEL_10;
    }

    v13 = !*(a2 + 24) && *a2 == -2;
    if (v13 || *(a2 + 32) == -INFINITY)
    {
      break;
    }

LABEL_10:
    v14 = a2;
LABEL_13:
    fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)2,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>::operator()(a1, &v38, v14, &v34);
    v38 = v34;
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v39, v36, &v35);
    v40 = v37;
    std::__list_imp<char *>::clear(&v35);
    v9 = 0;
    if ((v12 & 1) == 0)
    {
      v9 = 0;
      v8 = (v10 + 8);
      goto LABEL_2;
    }
  }

  v16 = (a3 + 48);
  v17 = 1;
  while (2)
  {
    v18 = *v16;
    v19 = *v16 + 16;
LABEL_19:
    v20 = v17;
    if ((v17 & 1) == 0)
    {
      if (v18 == a3 + 40)
      {
        goto LABEL_33;
      }

      v22 = v19;
      goto LABEL_29;
    }

    if (!*a3)
    {
      v23 = *(a3 + 32);
      if (v23 >= -INFINITY && v23 <= -INFINITY)
      {
        goto LABEL_33;
      }

LABEL_26:
      v22 = a3;
LABEL_29:
      fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)2,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>::operator()(a1, &v38, v22, &v34);
      v38 = v34;
      std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v39, v36, &v35);
      v40 = v37;
      std::__list_imp<char *>::clear(&v35);
      v17 = 0;
      if ((v20 & 1) == 0)
      {
        v17 = 0;
        v16 = (v18 + 8);
        continue;
      }

      goto LABEL_19;
    }

    break;
  }

  if (*(a3 + 24))
  {
    v21 = 0;
  }

  else
  {
    v21 = *a3 == -2;
  }

  if (!v21 && *(a3 + 32) != -INFINITY)
  {
    goto LABEL_26;
  }

LABEL_33:
  v24 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::Zero();
  if (v38)
  {
    v25 = v39[2] + 1;
  }

  else
  {
    v25 = 0;
  }

  if (*v24)
  {
    v26 = *(v24 + 24) + 1;
  }

  else
  {
    v26 = 0;
  }

  if (v25 != v26)
  {
    goto LABEL_49;
  }

  v27 = v39[1];
  v28 = (v24 + 16);
  for (i = 1; ; i = 0)
  {
    v30 = *v28;
    if (i)
    {
      if (!v38)
      {
        break;
      }

      if (v38 != *v24)
      {
        goto LABEL_49;
      }
    }

    if (v27 == v39)
    {
      break;
    }

    if (*(v27 + 16) != *(v30 + 16))
    {
      goto LABEL_49;
    }

    v27 = *(v27 + 8);
    v28 = (v30 + 8);
  }

  v34 = LODWORD(v40);
  v41 = *(v24 + 32);
  if (v40 == v41)
  {
    v31 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero();
    *a4 = *v31;
    std::list<int>::list((a4 + 8), (v31 + 2));
    *(a4 + 32) = v31[8];
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a4 + 40), (v31 + 10));
  }

  else
  {
LABEL_49:
    fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::GallicWeight(a4, &v38);
  }

  return std::__list_imp<char *>::clear(v39);
}

void sub_1B5A5DA70(_Unwind_Exception *a1)
{
  std::__list_imp<char *>::clear(v2);
  std::__list_imp<char *>::clear(v1);
  _Unwind_Resume(a1);
}

void *fst::Plus<int,fst::LogWeightTpl<float>>@<X0>(int *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  v11 = *a1;
  std::list<int>::list(v12, (a1 + 2));
  v13 = a1[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v14, (a1 + 10));
  v7 = *a2;
  std::list<int>::list(v8, (a2 + 2));
  v9 = a2[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v10, (a2 + 10));
  fst::Plus<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>(&v11, &v7, &v15);
  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::GallicWeight(a3, &v15);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v17);
  std::__list_imp<char *>::clear(v16);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v10);
  std::__list_imp<char *>::clear(v8);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v14);
  return std::__list_imp<char *>::clear(v12);
}

void sub_1B5A5DB94(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 40));
  std::__list_imp<char *>::clear((v1 + 8));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v2 + 40));
  std::__list_imp<char *>::clear((v2 + 8));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v3 + 40));
  std::__list_imp<char *>::clear((v3 + 8));
  _Unwind_Resume(a1);
}

void *fst::Divide<int,fst::LogWeightTpl<float>>@<X0>(int *a1@<X0>, int *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  v13 = *a1;
  std::list<int>::list(v14, (a1 + 2));
  v15 = a1[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v16, (a1 + 10));
  v9 = *a2;
  std::list<int>::list(v10, (a2 + 2));
  v11 = a2[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v12, (a2 + 10));
  fst::Divide<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>(&v13, &v9, a3, &v17);
  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::GallicWeight(a4, &v17);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v19);
  std::__list_imp<char *>::clear(v18);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v12);
  std::__list_imp<char *>::clear(v10);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v16);
  return std::__list_imp<char *>::clear(v14);
}

void sub_1B5A5DCE0(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 40));
  std::__list_imp<char *>::clear((v1 + 8));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v2 + 40));
  std::__list_imp<char *>::clear((v2 + 8));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v3 + 40));
  std::__list_imp<char *>::clear((v3 + 8));
  _Unwind_Resume(a1);
}

void *fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Quantize@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::Quantize(a1, &v5, a3);
  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::GallicWeight(a2, &v5);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v7);
  return std::__list_imp<char *>::clear(v6);
}

void sub_1B5A5DD8C(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 40));
  std::__list_imp<char *>::clear((v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::GallicWeight(uint64_t a1, int *a2)
{
  v5 = *a2;
  std::list<int>::list(v6, (a2 + 2));
  v7 = a2[8];
  fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::UnionWeight(a1, &v5);
  std::__list_imp<char *>::clear(v6);
  return a1;
}

float fst::Divide<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  v8 = *a1;
  if (*a1)
  {
    if (*(a1 + 24))
    {
      v9 = 0;
    }

    else
    {
      v9 = v8 == -2;
    }

    if (v9 || *(a1 + 32) == -INFINITY)
    {
      goto LABEL_10;
    }
  }

  else if (*(a1 + 32) == -INFINITY)
  {
    goto LABEL_10;
  }

  if ((*(a1 + 56) + 1) >= 2)
  {
    v16 = (a1 + 48);
    v19 = v8 != -2 || *(a1 + 24) != 0 || v8 == 0;
    v20 = 1;
LABEL_32:
    v21 = *v16;
    while (1)
    {
      v22 = v20;
      if (v20)
      {
        v23 = a1;
        if (!v19)
        {
          break;
        }
      }

      else
      {
        v23 = v21 + 16;
        if (v21 == a1 + 40)
        {
          break;
        }
      }

      if (*v23)
      {
        if (*v23 == -2 && *(v23 + 24) == 0)
        {
          goto LABEL_68;
        }
      }

      if (*(v23 + 32) == -INFINITY)
      {
        goto LABEL_68;
      }

      v20 = 0;
      if ((v22 & 1) == 0)
      {
        v20 = 0;
        v16 = (v21 + 8);
        goto LABEL_32;
      }
    }
  }

LABEL_10:
  v10 = *a2;
  if (*a2)
  {
    if (*(a2 + 24))
    {
      v11 = 0;
    }

    else
    {
      v11 = v10 == -2;
    }

    if (!v11 && *(a2 + 32) != -INFINITY)
    {
      goto LABEL_18;
    }
  }

  else if (*(a2 + 32) != -INFINITY)
  {
LABEL_18:
    if ((*(a2 + 56) + 1) < 2)
    {
      goto LABEL_19;
    }

    v25 = (a2 + 48);
    v28 = v10 != -2 || *(a2 + 24) != 0 || v10 == 0;
    v29 = 1;
LABEL_55:
    v30 = *v25;
    while (1)
    {
      v31 = v29;
      if (v29)
      {
        v32 = a2;
        if (!v28)
        {
          goto LABEL_19;
        }
      }

      else
      {
        v32 = v30 + 16;
        if (v30 == a2 + 40)
        {
          goto LABEL_19;
        }
      }

      if (*v32)
      {
        if (*v32 == -2 && *(v32 + 24) == 0)
        {
          break;
        }
      }

      if (*(v32 + 32) == -INFINITY)
      {
        break;
      }

      v29 = 0;
      if ((v31 & 1) == 0)
      {
        v29 = 0;
        v25 = (v30 + 8);
        goto LABEL_55;
      }
    }

LABEL_68:
    v34 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::NoWeight();
    *a4 = *v34;
    std::list<int>::list((a4 + 8), (v34 + 2));
    *(a4 + 32) = v34[8];
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a4 + 40), (v34 + 10));
    return result;
  }

LABEL_19:
  v12 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::Zero();
  if ((fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(a1, v12) & 1) != 0 || (v13 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::Zero(), fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(a2, v13)))
  {
    v14 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::Zero();
    *a4 = *v14;
    std::list<int>::list((a4 + 8), (v14 + 2));
    *(a4 + 32) = v14[8];
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a4 + 40), (v14 + 10));
    return result;
  }

  v35 = (a2 + 40);
  v36 = *a2 == -2 && !*(a2 + 24) || *(a2 + 32) == -INFINITY;
  v37 = *(a1 + 48);
  v38 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::NoWeight();
  *a4 = *v38;
  std::list<int>::list((a4 + 8), (v38 + 2));
  *(a4 + 32) = v38[8];
  *(a4 + 40) = a4 + 40;
  *(a4 + 48) = a4 + 40;
  *(a4 + 56) = 0;
  if (*a1)
  {
    if (*(a1 + 24))
    {
      v39 = 0;
    }

    else
    {
      v39 = *a1 == -2;
    }

    if (v39 || (result = *(a1 + 32), result == -INFINITY))
    {
LABEL_82:
      if (*a2)
      {
        if (*(a2 + 24))
        {
          v40 = 0;
        }

        else
        {
          v40 = *a2 == -2;
        }

        if (!v40)
        {
          result = *(a2 + 32);
          if (result != -INFINITY)
          {
LABEL_90:
            if (!*(a2 + 56))
            {
              for (i = 1; ; i = 0)
              {
                v47 = v37;
                v54 = v37 + 16;
                do
                {
                  v48 = i;
                  if (i)
                  {
                    if (*a1)
                    {
                      if (*(a1 + 24))
                      {
                        v49 = 0;
                      }

                      else
                      {
                        v49 = *a1 == -2;
                      }

                      if (v49)
                      {
                        return result;
                      }

                      result = *(a1 + 32);
                      v50 = a1;
                      if (result == -INFINITY)
                      {
                        return result;
                      }
                    }

                    else
                    {
                      result = *(a1 + 32);
                      v50 = a1;
                      if (result == -INFINITY)
                      {
                        return result;
                      }
                    }
                  }

                  else
                  {
                    v50 = v54;
                    if (v47 == a1 + 40)
                    {
                      return result;
                    }
                  }

                  if (v35 == *(a2 + 48))
                  {
                    v51 = a2;
                  }

                  else
                  {
                    v51 = *(a2 + 40) + 16;
                  }

                  fst::Divide<int,(fst::StringType)2>(v50, v51, a3, &v59);
                  v52 = *(v50 + 32);
                  v53 = NAN;
                  if (v52 != -INFINITY)
                  {
                    if ((*(v51 + 32) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
                    {
                      v53 = INFINITY;
                      if (v52 != INFINITY)
                      {
                        v53 = v52 - *(v51 + 32);
                      }
                    }

                    else
                    {
                      v53 = NAN;
                    }
                  }

                  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::GallicWeight(v55, &v59, v53);
                  std::__list_imp<char *>::clear(v60);
                  fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::PushBack(a4, v55, 1);
                  std::__list_imp<char *>::clear(v56);
                  i = 0;
                }

                while ((v48 & 1) != 0);
                v37 = *(v47 + 8);
              }
            }
          }
        }
      }

      else
      {
        result = *(a2 + 32);
        if (result != -INFINITY)
        {
          goto LABEL_90;
        }
      }

      v41 = fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::NoWeight();
      fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::operator=(a4, v41);
      return result;
    }
  }

  else
  {
    result = *(a1 + 32);
    if (result == -INFINITY)
    {
      goto LABEL_82;
    }
  }

  if (*(a1 + 56))
  {
    goto LABEL_82;
  }

  if (!v36)
  {
    v42 = *(a2 + 48);
    while (1)
    {
      v43 = a2;
      if (v35 != v42)
      {
        v43 = *v35 + 16;
      }

      fst::Divide<int,(fst::StringType)2>(a1, v43, a3, &v59);
      v44 = *(a1 + 32);
      v45 = NAN;
      if (v44 != -INFINITY)
      {
        if ((*(v43 + 32) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
        {
          v45 = INFINITY;
          if (v44 != INFINITY)
          {
            v45 = v44 - *(v43 + 32);
          }
        }

        else
        {
          v45 = NAN;
        }
      }

      fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::GallicWeight(v57, &v59, v45);
      std::__list_imp<char *>::clear(v60);
      fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::PushBack(a4, v57, 1);
      std::__list_imp<char *>::clear(v58);
      v42 = *(a2 + 48);
      if (v35 == v42)
      {
        break;
      }

      v35 = *v35;
    }
  }

  return result;
}

void sub_1B5A5E414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t *a10)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(a10);
  std::__list_imp<char *>::clear((v10 + 8));
  _Unwind_Resume(a1);
}

float *fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::Quantize@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  v6 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::NoWeight();
  *a2 = *v6;
  result = std::list<int>::list((a2 + 8), (v6 + 2));
  *(a2 + 32) = v6[8];
  *(a2 + 40) = a2 + 40;
  *(a2 + 48) = a2 + 40;
  *(a2 + 56) = 0;
  v8 = (a1 + 48);
  v9 = 1;
LABEL_2:
  v10 = *v8;
  v11 = *v8 + 16;
  while (1)
  {
    v12 = v9;
    if ((v9 & 1) == 0)
    {
      result = v11;
      if (v10 == a1 + 40)
      {
        return result;
      }

      goto LABEL_13;
    }

    if (*a1)
    {
      if (*a1 == -2 && *(a1 + 24) == 0)
      {
        return result;
      }
    }

    v14 = *(a1 + 32);
    result = a1;
    if (v14 >= -INFINITY && v14 <= -INFINITY)
    {
      return result;
    }

LABEL_13:
    fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::Quantize(result, v15, a3);
    fst::UnionWeight<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::LogWeightTpl<float>>>::PushBack(a2, v15, 1);
    result = std::__list_imp<char *>::clear(v16);
    v9 = 0;
    if ((v12 & 1) == 0)
    {
      v9 = 0;
      v8 = (v10 + 8);
      goto LABEL_2;
    }
  }
}

void sub_1B5A5E59C(_Unwind_Exception *a1)
{
  std::__list_imp<char *>::clear((v3 + 8));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v2);
  std::__list_imp<char *>::clear((v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::FindState(uint64_t a1, int **a2)
{
  State = fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::FindState(*(a1 + 184), a2);
  v5 = State;
  if (*(a1 + 152))
  {
    v6 = *(a1 + 160);
    if (State >= ((v6[1] - *v6) >> 6))
    {
      fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::ComputeDistance(a1, a2, &v8);
      std::vector<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::push_back[abi:ne200100](v6, &v8);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v10);
      std::__list_imp<char *>::clear(v9);
    }
  }

  return v5;
}

void sub_1B5A5E664(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 40));
  std::__list_imp<char *>::clear((v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::FindState(void *a1, void **a2)
{
  v6 = a2;
  v2 = (a1[12] - a1[11]) >> 3;
  Id = fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::FindId(a1 + 1, &v6, 1);
  if (Id != v2)
  {
    v4 = v6;
    if (v6)
    {
      std::__forward_list_base<fst::DeterminizeElement<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::clear(v6);
      MEMORY[0x1B8C85350](v4, 0x1020C405F07FB98);
    }
  }

  return Id;
}

uint64_t std::vector<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::push_back[abi:ne200100](uint64_t *a1, uint64_t a2)
{
  v3 = a1[1];
  if (v3 >= a1[2])
  {
    result = std::vector<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::__emplace_back_slow_path<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>(a1, a2);
  }

  else
  {
    std::vector<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::__construct_one_at_end[abi:ne200100]<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>(a1, a2);
    result = v3 + 64;
  }

  a1[1] = result;
  return result;
}

void *fst::DeterminizeFsaImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicCommonDivisor<int,fst::LogWeightTpl<float>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>>,fst::DefaultDeterminizeFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>>::ComputeDistance@<X0>(uint64_t a1@<X0>, int **a2@<X1>, uint64_t a3@<X8>)
{
  v6 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero();
  *a3 = *v6;
  std::list<int>::list((a3 + 8), (v6 + 2));
  *(a3 + 32) = v6[8];
  result = std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a3 + 40), (v6 + 10));
  for (i = *a2; i; i = *i)
  {
    v9 = i[2];
    v10 = **(a1 + 152);
    if (v9 >= (*(*(a1 + 152) + 8) - v10) >> 6)
    {
      v11 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero();
    }

    else
    {
      v11 = (v10 + (v9 << 6));
    }

    v19 = *v11;
    std::list<int>::list(v20, (v11 + 2));
    v21 = v11[8];
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v22, (v11 + 10));
    fst::Times<int,fst::LogWeightTpl<float>>(i + 4, &v19, &v12);
    fst::Plus<int,fst::LogWeightTpl<float>>(a3, &v12, &v15);
    *a3 = v15;
    if (&v15 != a3)
    {
      std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a3 + 8), v16[1], v16);
    }

    *(a3 + 32) = v17;
    std::list<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::__move_assign((a3 + 40), v18);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v18);
    std::__list_imp<char *>::clear(v16);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v14);
    std::__list_imp<char *>::clear(v13);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v22);
    result = std::__list_imp<char *>::clear(v20);
  }

  return result;
}

uint64_t fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::FindId(void *a1, void *a2, int a3)
{
  a1[13] = a2;
  v6 = std::__hash_table<int,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashFunc,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashEqual,std::allocator<int>>::find<int>(a1 + 3, &fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::kCurrentKey);
  if (v6)
  {
    return *(v6 + 4);
  }

  if (!a3)
  {
    return 0xFFFFFFFFLL;
  }

  v8 = a1[10];
  v9 = a1[11];
  v10 = a1[12];
  v11 = (v9 - v8) >> 3;
  v20 = v11;
  if (v9 >= v10)
  {
    if ((v11 + 1) >> 61)
    {
      std::vector<int>::__throw_length_error[abi:ne200100]();
    }

    v13 = v10 - v8;
    v14 = v13 >> 2;
    if (v13 >> 2 <= (v11 + 1))
    {
      v14 = v11 + 1;
    }

    if (v13 >= 0x7FFFFFFFFFFFFFF8)
    {
      v15 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v15 = v14;
    }

    if (v15)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<kaldi::CuWorkspace *>>((a1 + 10), v15);
    }

    *(8 * v11) = *a2;
    v12 = 8 * v11 + 8;
    v16 = a1[10];
    v17 = a1[11] - v16;
    v18 = (8 * v11 - v17);
    memcpy(v18, v16, v17);
    v19 = a1[10];
    a1[10] = v18;
    a1[11] = v12;
    a1[12] = 0;
    if (v19)
    {
      operator delete(v19);
    }
  }

  else
  {
    *v9 = *a2;
    v12 = (v9 + 1);
  }

  a1[11] = v12;
  std::__hash_table<int,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashFunc,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashEqual,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(a1 + 3, &v20);
  return v20;
}

void *std::vector<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::__construct_one_at_end[abi:ne200100]<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 8);
  *v4 = *a2;
  result = std::list<int>::list((v4 + 8), a2 + 8);
  *(v4 + 32) = *(a2 + 32);
  *(v4 + 40) = v4 + 40;
  *(v4 + 48) = v4 + 40;
  *(v4 + 56) = 0;
  v6 = *(a2 + 56);
  if (v6)
  {
    v8 = *(a2 + 40);
    v7 = *(a2 + 48);
    v9 = *(v8 + 8);
    v10 = *v7;
    *(v10 + 8) = v9;
    *v9 = v10;
    v11 = *(v4 + 40);
    *(v11 + 8) = v7;
    *v7 = v11;
    *(v4 + 40) = v8;
    *(v8 + 8) = v4 + 40;
    *(v4 + 56) = v6;
    *(a2 + 56) = 0;
  }

  *(a1 + 8) = v4 + 64;
  return result;
}

uint64_t std::vector<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::__emplace_back_slow_path<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>(uint64_t *a1, uint64_t a2)
{
  v2 = (a1[1] - *a1) >> 6;
  v3 = v2 + 1;
  if ((v2 + 1) >> 58)
  {
    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  v6 = a1[2] - *a1;
  if (v6 >> 5 > v3)
  {
    v3 = v6 >> 5;
  }

  if (v6 >= 0x7FFFFFFFFFFFFFC0)
  {
    v7 = 0x3FFFFFFFFFFFFFFLL;
  }

  else
  {
    v7 = v3;
  }

  v24 = a1;
  if (v7)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>>(a1, v7);
  }

  v8 = v2 << 6;
  v21 = 0;
  v22 = v8;
  v23 = v8;
  *v8 = *a2;
  std::list<int>::list((v8 + 8), a2 + 8);
  *(v8 + 32) = *(a2 + 32);
  *(v8 + 40) = v8 + 40;
  *(v8 + 48) = v8 + 40;
  *(v8 + 56) = 0;
  v9 = *(a2 + 56);
  if (v9)
  {
    v11 = *(a2 + 40);
    v10 = *(a2 + 48);
    v12 = *(v11 + 8);
    v13 = *v10;
    *(v13 + 8) = v12;
    *v12 = v13;
    v14 = *(v8 + 40);
    *(v14 + 8) = v10;
    *v10 = v14;
    *(v8 + 40) = v11;
    *(v11 + 8) = v8 + 40;
    *(v8 + 56) = v9;
    *(a2 + 56) = 0;
  }

  *&v23 = v23 + 64;
  v15 = a1[1];
  v16 = v22 + *a1 - v15;
  std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>,fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>*>(a1, *a1, v15, v16);
  v17 = *a1;
  *a1 = v16;
  v18 = a1[2];
  v20 = v23;
  *(a1 + 1) = v23;
  *&v23 = v17;
  *(&v23 + 1) = v18;
  v21 = v17;
  v22 = v17;
  std::__split_buffer<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::~__split_buffer(&v21);
  return v20;
}

void sub_1B5A5EC28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>,fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12 = a4;
  v13 = a4;
  v10[0] = a1;
  v10[1] = &v12;
  v10[2] = &v13;
  v11 = 0;
  if (a2 == a3)
  {
    v11 = 1;
  }

  else
  {
    v4 = a4;
    v6 = a2;
    v7 = a2 + 40;
    do
    {
      v8 = v7 - 40;
      *v4 = *(v7 - 40);
      std::list<int>::list((v4 + 8), v7 - 32);
      *(v4 + 32) = *(v7 - 8);
      std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((v4 + 40), v7);
      v4 = v13 + 64;
      v13 += 64;
      v7 += 64;
    }

    while (v8 + 64 != a3);
    v11 = 1;
    while (v6 != a3)
    {
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v6 + 40));
      std::__list_imp<char *>::clear((v6 + 8));
      v6 += 64;
    }
  }

  return std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>,fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>*>>::~__exception_guard_exceptions[abi:ne200100](v10);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>,fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>*>>::~__exception_guard_exceptions[abi:ne200100](uint64_t a1)
{
  if ((*(a1 + 24) & 1) == 0)
  {
    std::_AllocatorDestroyRangeReverse<std::allocator<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>,fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>*>::operator()[abi:ne200100](a1);
  }

  return a1;
}

uint64_t fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Start(uint64_t a1)
{
  if ((*(a1 + 60) & 1) == 0)
  {
    if ((*(*a1 + 32))(a1, 4))
    {
      *(a1 + 60) = 1;
    }

    else if ((*(a1 + 60) & 1) == 0)
    {
      v2 = (*(*a1 + 56))(a1);
      if (v2 != -1)
      {
        *(a1 + 64) = v2;
        *(a1 + 60) = 1;
        if (*(a1 + 68) <= v2)
        {
          *(a1 + 68) = v2 + 1;
        }
      }
    }
  }

  return *(a1 + 64);
}

void *fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Final@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasFinal(a1, a2) & 1) == 0)
  {
    (*(*a1 + 64))(&v11, a1, a2);
    v7 = v11;
    std::list<int>::list(v8, v12);
    v9 = v13;
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v10, v14);
    fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::SetFinal(a1, a2, &v7);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v10);
    std::__list_imp<char *>::clear(v8);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v14);
    std::__list_imp<char *>::clear(v12);
  }

  return fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Final(a1, a2, a3);
}

void sub_1B5A5EF28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v15 + 40));
  std::__list_imp<char *>::clear((v15 + 8));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(va);
  std::__list_imp<char *>::clear((v14 + 8));
  _Unwind_Resume(a1);
}

unint64_t fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::NumArcs(void *a1, uint64_t a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    (*(*a1 + 48))(a1, a2);
  }

  v4 = a1[15];
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return 0xCCCCCCCCCCCCCCCDLL * ((*(*v5 + 88) - *(*v5 + 80)) >> 4);
}

uint64_t fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::NumInputEpsilons(void *a1, uint64_t a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    (*(*a1 + 48))(a1, a2);
  }

  v4 = a1[15];
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return *(*v5 + 64);
}

uint64_t fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::NumOutputEpsilons(void *a1, uint64_t a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    (*(*a1 + 48))(a1, a2);
  }

  v4 = a1[15];
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return *(*v5 + 72);
}

void *fst::DeterminizeFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::DeterminizeFst(void *a1, uint64_t a2, int a3)
{
  *a1 = &unk_1F2D408A0;
  a1[1] = 0;
  v4 = *(a2 + 8);
  if (a3)
  {
    v5 = (*(*v4 + 40))(v4);
    v6 = a1[1];
    if (v6)
    {
      v7 = v6[14] - 1;
      v6[14] = v7;
      if (!v7)
      {
        (*(*v6 + 8))(v6);
      }
    }

    a1[1] = v5;
  }

  else
  {
    fst::ImplToFst<fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::SetImpl(a1, v4, 0);
  }

  return a1;
}

uint64_t fst::CacheStateIterator<fst::DeterminizeFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Done(uint64_t a1)
{
  v2 = *(a1 + 24);
  v3 = *(a1 + 16);
  if (v2 < *(v3 + 68))
  {
    return 0;
  }

  v5 = fst::CacheBaseImpl<fst::CacheState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>,fst::DefaultCacheStore<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>::MinUnexpandedState(v3);
  if (v5 >= *(*(a1 + 16) + 68))
  {
    return 1;
  }

  v6 = v5;
  do
  {
    fst::ArcIterator<fst::DeterminizeFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::ArcIterator(&v19, *(a1 + 8), v6);
    v7 = *(v19 + 80);
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((*(v19 + 88) - v7) >> 4);
    v9 = *(a1 + 16);
    v10 = v8 - v20;
    if (v8 > v20)
    {
      v11 = *(v9 + 68);
      v12 = (v7 + 80 * v20 + 72);
      do
      {
        v14 = *v12;
        v12 += 20;
        v13 = v14;
        if (v11 <= v14)
        {
          v11 = v13 + 1;
          *(v9 + 68) = v13 + 1;
        }

        --v10;
      }

      while (v10);
      v20 = v8;
    }

    fst::CacheBaseImpl<fst::CacheState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>,fst::DefaultCacheStore<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>::SetExpandedState(v9, v6);
    v15 = *(a1 + 24);
    v16 = *(a1 + 16);
    v17 = *(v16 + 68);
    --*(v19 + 108);
    v4 = v15 >= v17;
    if (v15 < v17)
    {
      break;
    }

    v6 = fst::CacheBaseImpl<fst::CacheState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>,fst::DefaultCacheStore<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>::MinUnexpandedState(v16);
  }

  while (v6 < *(*(a1 + 16) + 68));
  return v4;
}

uint64_t *fst::ArcIterator<fst::DeterminizeFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::ArcIterator(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a2 + 8);
  a1[1] = 0;
  MutableState = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>>>::GetMutableState(*(v6 + 120), a3);
  *a1 = MutableState;
  ++*(MutableState + 108);
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(*(a2 + 8), a3) & 1) == 0)
  {
    (*(**(a2 + 8) + 48))(*(a2 + 8), a3);
  }

  return a1;
}

uint64_t fst::DeterminizeFstImplBase<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::InitArcIterator(uint64_t a1, uint64_t a2, void *a3)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    (*(*a1 + 48))(a1, a2);
  }

  return fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::InitArcIterator(a1, a2, a3);
}

void fst::FactorWeightFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::~FactorWeightFst(void *a1)
{
  fst::ImplToFst<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~ImplToFst(a1);

  JUMPOUT(0x1B8C85350);
}

uint64_t fst::ImplToFst<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Properties(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    v8 = 0;
    v5 = fst::TestProperties<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>(a1, a2, &v8);
    *(*(a1 + 8) + 8) = *(*(a1 + 8) + 8) & (~v8 | 4) | v8 & v5;
    return v5 & a2;
  }

  else
  {
    v7 = *(**(a1 + 8) + 32);

    return v7();
  }
}

void sub_1B5A5FA18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  v21 = v19;
  v22 = (v19 - 5);
  v23 = *v21;
  if (*v21)
  {
    v18[30] = v23;
    operator delete(v23);
  }

  std::__hash_table<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,std::__unordered_map_hasher<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementKey,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,true>,std::__unordered_map_equal<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementKey,true>,std::allocator<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>>>::~__hash_table(v22);
  std::vector<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element>>::__destroy_vector::operator()[abi:ne200100](&__p);
  fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~CacheBaseImpl(v18);
  _Unwind_Resume(a1);
}

void fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::~FactorWeightFstImpl(uint64_t a1)
{
  fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::~FactorWeightFstImpl(a1);

  JUMPOUT(0x1B8C85350);
}

uint64_t fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Properties(uint64_t a1, uint64_t a2)
{
  if ((a2 & 4) != 0 && (*(**(a1 + 136) + 64))(*(a1 + 136), 4, 0))
  {
    *(a1 + 8) |= 4uLL;
  }

  return *(a1 + 8) & a2;
}

uint64_t fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::~FactorWeightFstImpl(uint64_t a1)
{
  *a1 = &unk_1F2D40CA0;
  v2 = *(a1 + 136);
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = *(a1 + 232);
  if (v3)
  {
    *(a1 + 240) = v3;
    operator delete(v3);
  }

  std::__hash_table<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,std::__unordered_map_hasher<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementKey,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,true>,std::__unordered_map_equal<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementKey,true>,std::allocator<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>>>::~__hash_table(a1 + 192);
  v5 = (a1 + 168);
  std::vector<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element>>::__destroy_vector::operator()[abi:ne200100](&v5);
  return fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~CacheBaseImpl(a1);
}

uint64_t fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Start(uint64_t a1)
{
  if ((*(a1 + 60) & 1) == 0)
  {
    if ((*(*a1 + 32))(a1, 4))
    {
      *(a1 + 60) = 1;
    }

    else if ((*(a1 + 60) & 1) == 0)
    {
      result = (*(**(a1 + 136) + 24))(*(a1 + 136));
      if (result == -1)
      {
        return result;
      }

      v3 = (*(**(a1 + 136) + 24))(*(a1 + 136));
      v4 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::One();
      v6 = *v4;
      std::list<int>::list(v7, (v4 + 2));
      v8 = v4[8];
      std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v9, (v4 + 10));
      fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element::Element(v10, v3, &v6);
      State = fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::FindState(a1, v10);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v12);
      std::__list_imp<char *>::clear(v11);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v9);
      std::__list_imp<char *>::clear(v7);
      *(a1 + 64) = State;
      *(a1 + 60) = 1;
      if (*(a1 + 68) <= State)
      {
        *(a1 + 68) = State + 1;
      }
    }
  }

  return *(a1 + 64);
}

void sub_1B5A5FD80(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 48));
  std::__list_imp<char *>::clear((v1 + 16));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v2 + 40));
  std::__list_imp<char *>::clear((v2 + 8));
  _Unwind_Resume(a1);
}

uint64_t fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::FindState(uint64_t a1, int *a2)
{
  if ((*(a1 + 148) & 2) != 0 || (v4 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::One(), !fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>((a2 + 2), v4)) || (v5 = *a2, *a2 == -1))
  {
    v12 = std::__hash_table<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,std::__unordered_map_hasher<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementKey,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,true>,std::__unordered_map_equal<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementKey,true>,std::allocator<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>>>::find<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element>((a1 + 192), a2);
    if (v12)
    {
      return *(v12 + 22);
    }

    else
    {
      v13 = *(a1 + 168);
      v14 = *(a1 + 176);
      std::vector<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>>::push_back[abi:ne200100](a1 + 168, a2);
      v15 = a2[2];
      v18[0] = *a2;
      v18[2] = v15;
      std::list<int>::list(v19, (a2 + 4));
      v20 = a2[10];
      std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v21, (a2 + 12));
      v16 = (v14 - v13) >> 3;
      v11 = (954437177 * v16);
      v22 = 954437177 * v16;
      std::__hash_table<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>,std::__unordered_map_hasher<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementKey,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,true>,std::__unordered_map_equal<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementKey,true>,std::allocator<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>>>::__emplace_unique_key_args<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::pair<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element const,int>>((a1 + 192), v18);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v21);
      std::__list_imp<char *>::clear(v19);
    }
  }

  else
  {
    v6 = v5;
    v7 = *(a1 + 232);
    if (v5 >= ((*(a1 + 240) - v7) >> 2))
    {
      do
      {
        std::vector<int>::push_back[abi:ne200100]((a1 + 232), &fst::kNoStateId);
        v7 = *(a1 + 232);
        v5 = *a2;
        v6 = *a2;
      }

      while (v6 >= (*(a1 + 240) - v7) >> 2);
    }

    if (*(v7 + 4 * v6) == -1)
    {
      v8 = *(a1 + 168);
      v9 = *(a1 + 176);
      v10 = a1 + 168;
      *(v7 + 4 * v6) = 954437177 * ((v9 - v8) >> 3);
      std::vector<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>>::push_back[abi:ne200100](v10, a2);
      v5 = *a2;
      v7 = *(v10 + 64);
    }

    return *(v7 + 4 * v5);
  }

  return v11;
}

void sub_1B5A5FF40(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 48));
  std::__list_imp<char *>::clear((v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element::Element(uint64_t a1, int a2, _DWORD *a3)
{
  *a1 = a2;
  *(a1 + 8) = *a3;
  std::list<int>::list((a1 + 16), (a3 + 2));
  *(a1 + 40) = a3[8];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a1 + 48), (a3 + 10));
  return a1;
}

uint64_t std::vector<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>>::push_back[abi:ne200100](uint64_t a1, _DWORD *a2)
{
  v3 = *(a1 + 8);
  if (v3 >= *(a1 + 16))
  {
    result = std::vector<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>>::__emplace_back_slow_path<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element const&>(a1, a2);
  }

  else
  {
    std::allocator_traits<std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>>::construct[abi:ne200100]<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element const&,0>(a1, *(a1 + 8), a2);
    result = v3 + 72;
    *(a1 + 8) = v3 + 72;
  }

  *(a1 + 8) = result;
  return result;
}

uint64_t std::vector<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>>::__emplace_back_slow_path<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element const&>(uint64_t a1, _DWORD *a2)
{
  v2 = 0x8E38E38E38E38E39 * ((*(a1 + 8) - *a1) >> 3);
  v3 = v2 + 1;
  if (v2 + 1 > 0x38E38E38E38E38ELL)
  {
    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  if (0x1C71C71C71C71C72 * ((*(a1 + 16) - *a1) >> 3) > v3)
  {
    v3 = 0x1C71C71C71C71C72 * ((*(a1 + 16) - *a1) >> 3);
  }

  if (0x8E38E38E38E38E39 * ((*(a1 + 16) - *a1) >> 3) >= 0x1C71C71C71C71C7)
  {
    v6 = 0x38E38E38E38E38ELL;
  }

  else
  {
    v6 = v3;
  }

  v16 = a1;
  if (v6)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element>>(a1, v6);
  }

  v13 = 0;
  v14 = 72 * v2;
  std::allocator_traits<std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>>::construct[abi:ne200100]<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element const&,0>(a1, 72 * v2, a2);
  v15 = 72 * v2 + 72;
  v7 = *(a1 + 8);
  v8 = 72 * v2 + *a1 - v7;
  std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element*>(a1, *a1, v7, v8);
  v9 = *a1;
  *a1 = v8;
  v10 = *(a1 + 16);
  v12 = v15;
  *(a1 + 8) = v15;
  *&v15 = v9;
  *(&v15 + 1) = v10;
  v13 = v9;
  v14 = v9;
  std::__split_buffer<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element> &>::~__split_buffer(&v13);
  return v12;
}

void sub_1B5A60164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element> &>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

void *std::allocator_traits<std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>>::construct[abi:ne200100]<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element const&,0>(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a2 = *a3;
  *(a2 + 8) = a3[2];
  std::list<int>::list((a2 + 16), (a3 + 4));
  *(a2 + 40) = a3[10];
  return std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list((a2 + 48), (a3 + 12));
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element*>(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 == a3)
  {
    v10 = 1;
  }

  else
  {
    v5 = a2;
    v7 = a2;
    do
    {
      std::allocator_traits<std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>>::construct[abi:ne200100]<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element const&,0>(a1, a4, v7);
      v7 += 9;
      a4 = v12 + 72;
      v12 += 72;
    }

    while (v7 != a3);
    v10 = 1;
    while (v5 != a3)
    {
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v5 + 6);
      std::__list_imp<char *>::clear(v5 + 2);
      v5 += 9;
    }
  }

  return std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element*>>::~__exception_guard_exceptions[abi:ne200100](v9);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element*>>::~__exception_guard_exceptions[abi:ne200100](uint64_t a1)
{
  if ((*(a1 + 24) & 1) == 0)
  {
    std::_AllocatorDestroyRangeReverse<std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element*>::operator()[abi:ne200100](a1);
  }

  return a1;
}

uint64_t *std::__hash_table<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>,std::__unordered_map_hasher<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementKey,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,true>,std::__unordered_map_equal<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementKey,true>,std::allocator<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>>>::__emplace_unique_key_args<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::pair<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element const,int>>(void *a1, int *a2)
{
  v4 = std::__unordered_map_hasher<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementKey,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,true>::operator()[abi:ne200100](a1, a2);
  v5 = v4;
  v6 = a1[1];
  if (!*&v6)
  {
    goto LABEL_19;
  }

  v7 = vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v6)
    {
      v9 = v4 % *&v6;
    }
  }

  else
  {
    v9 = (*&v6 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_19:
    std::__hash_table<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>,std::__unordered_map_hasher<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementKey,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,true>,std::__unordered_map_equal<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::ElementKey,true>,std::allocator<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element,int>>>::__construct_node_hash<std::pair<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element const,int>>();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= *&v6)
      {
        v12 %= *&v6;
      }
    }

    else
    {
      v12 &= *&v6 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_19;
    }

LABEL_18:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_19;
    }
  }

  if (*(v11 + 4) != *a2 || (fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>((v11 + 3), (a2 + 2)) & 1) == 0)
  {
    goto LABEL_18;
  }

  return v11;
}

void sub_1B5A60530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t *__p, uint64_t a11)
{
  if (__p)
  {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,void *>>>::operator()[abi:ne200100](&a11, __p);
  }

  _Unwind_Resume(exception_object);
}

void sub_1B5A60600(_Unwind_Exception *a1)
{
  std::__list_imp<char *>::clear(v2 + 4);
  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,void *>>>::operator()[abi:ne200100](v3, v2);
  _Unwind_Resume(a1);
}

void *fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Final@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasFinal(a1, a2) & 1) == 0)
  {
    v6 = (*(a1 + 168) + 72 * a2);
    if (*v6 == -1)
    {
      v26 = v6[2];
      std::list<int>::list(v27, (v6 + 4));
      v28 = v6[10];
      std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v29, (v6 + 12));
    }

    else
    {
      (*(**(a1 + 136) + 32))(&v20);
      fst::Times<int,fst::LogWeightTpl<float>>(v6 + 2, &v20, &v26);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v25);
      std::__list_imp<char *>::clear(&v21);
    }

    fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>::GallicFactor(&v20, &v26);
    if (*(a1 + 148) & 1) == 0 || (v24)
    {
      goto LABEL_12;
    }

    if (v22 == 1)
    {
      if (*v20 == -2 && !*(v20 + 24))
      {
        goto LABEL_12;
      }

      v7 = *(v20 + 32);
      if (v7 >= -INFINITY && v7 <= -INFINITY)
      {
        goto LABEL_12;
      }
    }

    else if (v23 == v21)
    {
LABEL_12:
      v16 = v26;
      v8 = v17;
      std::list<int>::list(v17, v27);
      v18 = v28;
      v9 = v19;
      std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v19, v29);
      fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::SetFinal(a1, a2, &v16);
LABEL_13:
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v9);
      std::__list_imp<char *>::clear(v8);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v29);
      std::__list_imp<char *>::clear(v27);
      return fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Final(a1, a2, a3);
    }

    v11 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero();
    v12 = *v11;
    v8 = v13;
    std::list<int>::list(v13, (v11 + 2));
    v14 = v11[8];
    v9 = v15;
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v15, (v11 + 10));
    fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::SetFinal(a1, a2, &v12);
    goto LABEL_13;
  }

  return fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Final(a1, a2, a3);
}

void sub_1B5A60850(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v2);
  std::__list_imp<char *>::clear(v1);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v3 - 88));
  std::__list_imp<char *>::clear((v3 - 120));
  _Unwind_Resume(a1);
}

unint64_t fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::NumArcs(uint64_t a1, int a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  v4 = *(a1 + 120);
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return 0xCCCCCCCCCCCCCCCDLL * ((*(*v5 + 88) - *(*v5 + 80)) >> 4);
}

void *fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Expand(uint64_t a1, int a2)
{
  v4 = (*(a1 + 168) + 72 * a2);
  v75 = *v4;
  v76 = v4[2];
  std::list<int>::list(v77, (v4 + 4));
  v78 = v4[10];
  std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v79, (v4 + 12));
  if (v75 == -1)
  {
    goto LABEL_36;
  }

  v5 = *(a1 + 136);
  v74 = 0;
  (*(*v5 + 136))(v5);
  while (1)
  {
    if (!v70)
    {
      if (v74 >= v72)
      {
        goto LABEL_34;
      }

LABEL_8:
      v6 = (v71 + 80 * v74);
      goto LABEL_9;
    }

    if ((*(*v70 + 24))(v70))
    {
      break;
    }

    if (!v70)
    {
      goto LABEL_8;
    }

    v6 = (*(*v70 + 32))(v70);
LABEL_9:
    fst::Times<int,fst::LogWeightTpl<float>>(&v76, v6 + 2, &v66);
    fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>::GallicFactor(&v61, &v66);
    if (*(a1 + 148) & 2) == 0 || (v65)
    {
      goto LABEL_11;
    }

    if (v63 == 1)
    {
      if (*v61 == -2 && !*(v61 + 24) || (v11 = *(v61 + 32), v11 >= -INFINITY) && v11 <= -INFINITY)
      {
LABEL_11:
        v7 = v6[18];
        v8 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::One();
        v57 = *v8;
        std::list<int>::list(v58, (v8 + 2));
        v59 = v8[8];
        std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v60, (v8 + 10));
        fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element::Element(&v44, v7, &v57);
        State = fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::FindState(a1, &v44);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v49);
        std::__list_imp<char *>::clear(v46);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v60);
        std::__list_imp<char *>::clear(v58);
        LODWORD(v8) = *v6;
        v10 = v6[1];
        v53 = v66;
        std::list<int>::list(v54, v67);
        v55 = v68;
        std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v56, v69);
        fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::GallicArc(&v44, v8, v10, &v53, State);
        fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::PushArc(a1, a2, &v44);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v49);
        std::__list_imp<char *>::clear(v46);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v56);
        std::__list_imp<char *>::clear(v54);
        goto LABEL_12;
      }
    }

    else if (v64 == v62)
    {
      goto LABEL_11;
    }

    if (v63)
    {
      if (*v61 == -2 && !*(v61 + 24) || *(v61 + 32) == -INFINITY)
      {
        goto LABEL_12;
      }
    }

    else
    {
LABEL_30:
      if (v64 == v62)
      {
        goto LABEL_12;
      }
    }

    fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Value(&v61, &v44);
    v12 = v6[18];
    fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Quantize(&v50, &v41, *(a1 + 144));
    fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element::Element(v38, v12, &v41);
    v13 = fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::FindState(a1, v38);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v40);
    std::__list_imp<char *>::clear(v39);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v43);
    std::__list_imp<char *>::clear(v42);
    v14 = *v6;
    v15 = v6[1];
    v34 = v44;
    std::list<int>::list(v35, &v45);
    v36 = v47;
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v37, &v48);
    fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::GallicArc(v38, v14, v15, &v34, v13);
    fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::PushArc(a1, a2, v38);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v40);
    std::__list_imp<char *>::clear(v39);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v37);
    std::__list_imp<char *>::clear(v35);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v52);
    std::__list_imp<char *>::clear(v51);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(&v48);
    std::__list_imp<char *>::clear(&v45);
    if (v63 == 1)
    {
      v63 = 0;
    }

    else
    {
      v64 = *(v64 + 8);
    }

    if ((v65 & 1) == 0)
    {
      goto LABEL_30;
    }

LABEL_12:
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v69);
    std::__list_imp<char *>::clear(v67);
    if (v70)
    {
      (*(*v70 + 40))(v70);
    }

    else
    {
      ++v74;
    }
  }

  if (v70)
  {
    (*(*v70 + 8))(v70);
  }

  else
  {
LABEL_34:
    if (v73)
    {
      --*v73;
    }
  }

LABEL_36:
  if (*(a1 + 148))
  {
    if (v75 == -1)
    {
      goto LABEL_42;
    }

    (*(**(a1 + 136) + 32))(&v44);
    v16 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero();
    v17 = fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(&v44, v16);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(&v48);
    std::__list_imp<char *>::clear(&v45);
    if (v17)
    {
      goto LABEL_39;
    }

    if (v75 == -1)
    {
LABEL_42:
      v66 = v76;
      std::list<int>::list(v67, v77);
      v68 = v78;
      std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v69, v79);
    }

    else
    {
      (*(**(a1 + 136) + 32))(&v44);
      fst::Times<int,fst::LogWeightTpl<float>>(&v76, &v44, &v66);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(&v48);
      std::__list_imp<char *>::clear(&v45);
    }

    v19 = *(a1 + 152);
    v20 = *(a1 + 156);
    fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>::GallicFactor(&v70, &v66);
    if ((v74 & 1) == 0)
    {
      v21 = v72;
      do
      {
        if (v21)
        {
          if (*v70)
          {
            if (*v70 == -2 && *(v70 + 24) == 0)
            {
              break;
            }
          }

          v23 = *(v70 + 32);
          if (v23 >= -INFINITY && v23 <= -INFINITY)
          {
            break;
          }
        }

        else if (v73 == v71)
        {
          break;
        }

        fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Value(&v70, &v44);
        fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Quantize(&v50, &v31, *(a1 + 144));
        fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Element::Element(v38, -1, &v31);
        v24 = fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::FindState(a1, v38);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v40);
        std::__list_imp<char *>::clear(v39);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v33);
        std::__list_imp<char *>::clear(v32);
        v27 = v44;
        std::list<int>::list(v28, &v45);
        v29 = v47;
        std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v30, &v48);
        fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::GallicArc(v38, v19, v20, &v27, v24);
        fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::PushArc(a1, a2, v38);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v40);
        std::__list_imp<char *>::clear(v39);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v30);
        std::__list_imp<char *>::clear(v28);
        v25 = *(a1 + 160);
        v26 = *(a1 + 161);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v52);
        std::__list_imp<char *>::clear(v51);
        std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(&v48);
        std::__list_imp<char *>::clear(&v45);
        if (v72 == 1)
        {
          LOBYTE(v72) = 0;
        }

        else
        {
          v73 = *(v73 + 8);
        }

        v21 = 0;
        v19 += v25;
        v20 += v26;
      }

      while ((v74 & 1) == 0);
    }

    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v69);
    std::__list_imp<char *>::clear(v67);
  }

LABEL_39:
  fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::SetArcs(a1, a2);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v79);
  return std::__list_imp<char *>::clear(v77);
}

void sub_1B5A610F4(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v1 + 40));
  std::__list_imp<char *>::clear((v1 + 8));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v2 + 48));
  std::__list_imp<char *>::clear((v2 + 16));
  _Unwind_Resume(a1);
}

void *fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (*(a1 + 16) == 1)
  {
    v3 = *a1;
  }

  else
  {
    v3 = (*(a1 + 24) + 16);
  }

  v43 = *v3;
  std::list<int>::list(v44, (v3 + 2));
  v45 = v3[8];
  v40 = v43;
  std::list<int>::list(v41, v44);
  v5 = v43 == 0.0 || (v44[2] + 1) < 2;
  v42 = v5;
  fst::StringFactor<int,(fst::StringType)2>::Value(&v40, &v27);
  v35 = v27;
  v36[0] = v36;
  v36[1] = v36;
  v37 = 0;
  v6 = v30;
  if (v30)
  {
    v8 = v28;
    v7 = v29;
    v9 = *(v28 + 8);
    v10 = *v29;
    *(v10 + 8) = v9;
    *v9 = v10;
    v11 = v36[0];
    *(v36[0] + 8) = v7;
    *v7 = v11;
    v36[0] = v8;
    *(v8 + 8) = v36;
    v37 = v6;
    v30 = 0;
  }

  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::GallicWeight(&v38, &v35, v45);
  std::__list_imp<char *>::clear(v36);
  std::__list_imp<char *>::clear(&v32);
  std::__list_imp<char *>::clear(&v28);
  fst::StringFactor<int,(fst::StringType)2>::Value(&v40, &v27);
  v22 = v31;
  v23[0] = v23;
  v23[1] = v23;
  v24 = 0;
  v12 = v34;
  if (v34)
  {
    v14 = v32;
    v13 = v33;
    v15 = *(v32 + 8);
    v16 = *v33;
    *(v16 + 8) = v15;
    *v15 = v16;
    v17 = v23[0];
    *(v23[0] + 8) = v13;
    *v13 = v17;
    v23[0] = v14;
    *(v14 + 8) = v23;
    v24 = v12;
    v34 = 0;
  }

  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>::GallicWeight(&v25, &v22, 0.0);
  std::__list_imp<char *>::clear(v23);
  std::__list_imp<char *>::clear(&v32);
  std::__list_imp<char *>::clear(&v28);
  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::GallicWeight(&v27, &v38);
  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::GallicWeight(&v19, &v25);
  std::pair<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>,fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::pair[abi:ne200100]<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>,fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>,0>(a2, &v27, &v19);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v21);
  std::__list_imp<char *>::clear(v20);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(&v32);
  std::__list_imp<char *>::clear(&v28);
  std::__list_imp<char *>::clear(v26);
  std::__list_imp<char *>::clear(v39);
  std::__list_imp<char *>::clear(v41);
  return std::__list_imp<char *>::clear(v44);
}

void sub_1B5A615A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v31 + 40));
  std::__list_imp<char *>::clear((v31 + 8));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(&a31);
  std::__list_imp<char *>::clear(&a27);
  std::__list_imp<char *>::clear(&a22);
  std::__list_imp<char *>::clear((v34 - 160));
  std::__list_imp<char *>::clear((v33 + 8));
  std::__list_imp<char *>::clear((v32 + 8));
  _Unwind_Resume(a1);
}

void sub_1B5A61634(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31)
{
  std::__list_imp<char *>::clear(v31);
  std::__list_imp<char *>::clear(&a31);
  JUMPOUT(0x1B5A61618);
}

uint64_t std::pair<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>,fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::pair[abi:ne200100]<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>,fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *a1 = *a2;
  std::list<int>::list((a1 + 8), a2 + 8);
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = a1 + 40;
  *(a1 + 48) = a1 + 40;
  *(a1 + 56) = 0;
  v6 = *(a2 + 56);
  if (v6)
  {
    v8 = *(a2 + 40);
    v7 = *(a2 + 48);
    v9 = *(v8 + 8);
    v10 = *v7;
    *(v10 + 8) = v9;
    *v9 = v10;
    v11 = *(a1 + 40);
    *(v11 + 8) = v7;
    *v7 = v11;
    *(a1 + 40) = v8;
    *(v8 + 8) = a1 + 40;
    *(a1 + 56) = v6;
    *(a2 + 56) = 0;
  }

  *(a1 + 64) = *a3;
  std::list<int>::list((a1 + 72), a3 + 8);
  *(a1 + 96) = *(a3 + 32);
  *(a1 + 104) = a1 + 104;
  *(a1 + 112) = a1 + 104;
  *(a1 + 120) = 0;
  v12 = *(a3 + 56);
  if (v12)
  {
    v14 = *(a3 + 40);
    v13 = *(a3 + 48);
    v15 = *(v14 + 8);
    v16 = *v13;
    *(v16 + 8) = v15;
    *v15 = v16;
    v17 = *(a1 + 104);
    *(v17 + 8) = v13;
    *v13 = v17;
    *(a1 + 104) = v14;
    *(v14 + 8) = a1 + 104;
    *(a1 + 120) = v12;
    *(a3 + 56) = 0;
  }

  return a1;
}

void sub_1B5A61750(_Unwind_Exception *a1)
{
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v2);
  std::__list_imp<char *>::clear((v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::NumInputEpsilons(uint64_t a1, int a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  v4 = *(a1 + 120);
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return *(*v5 + 64);
}

uint64_t fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::NumOutputEpsilons(uint64_t a1, int a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  v4 = *(a1 + 120);
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return *(*v5 + 72);
}

void *fst::ImplToFst<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::ImplToFst(void *result, uint64_t a2, int a3)
{
  *result = &unk_1F2D40CF0;
  if (a3)
  {
    operator new();
  }

  v3 = *(a2 + 8);
  result[1] = v3;
  ++*(v3 + 56);
  return result;
}

void sub_1B5A61A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  v19 = *v17;
  if (*v17)
  {
    v15[30] = v19;
    operator delete(v19);
  }

  std::__hash_table<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,std::__unordered_map_hasher<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementKey,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,true>,std::__unordered_map_equal<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementEqual,fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::ElementKey,true>,std::allocator<std::__hash_value_type<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,int>>>::~__hash_table(v16 + 24);
  __p = v16;
  std::vector<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element,std::allocator<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::TropicalWeightTpl<float>,(fst::GallicType)4>>::Element>>::__destroy_vector::operator()[abi:ne200100](&__p);
  fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~CacheBaseImpl(v15);
  _Unwind_Resume(a1);
}

uint64_t fst::CacheStateIterator<fst::FactorWeightFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>>::Done(uint64_t a1)
{
  v2 = *(a1 + 24);
  v3 = *(a1 + 16);
  if (v2 < *(v3 + 68))
  {
    return 0;
  }

  v5 = fst::CacheBaseImpl<fst::CacheState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>,fst::DefaultCacheStore<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>::MinUnexpandedState(v3);
  if (v5 >= *(*(a1 + 16) + 68))
  {
    return 1;
  }

  v6 = v5;
  do
  {
    fst::ArcIterator<fst::FactorWeightFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>>::ArcIterator(&v19, *(a1 + 8), v6);
    v7 = *(v19 + 80);
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((*(v19 + 88) - v7) >> 4);
    v9 = *(a1 + 16);
    v10 = v8 - v20;
    if (v8 > v20)
    {
      v11 = *(v9 + 68);
      v12 = (v7 + 80 * v20 + 72);
      do
      {
        v14 = *v12;
        v12 += 20;
        v13 = v14;
        if (v11 <= v14)
        {
          v11 = v13 + 1;
          *(v9 + 68) = v13 + 1;
        }

        --v10;
      }

      while (v10);
      v20 = v8;
    }

    fst::CacheBaseImpl<fst::CacheState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>,fst::DefaultCacheStore<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>::SetExpandedState(v9, v6);
    v15 = *(a1 + 24);
    v16 = *(a1 + 16);
    v17 = *(v16 + 68);
    --*(v19 + 108);
    v4 = v15 >= v17;
    if (v15 < v17)
    {
      break;
    }

    v6 = fst::CacheBaseImpl<fst::CacheState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>,fst::DefaultCacheStore<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>>::MinUnexpandedState(v16);
  }

  while (v6 < *(*(a1 + 16) + 68));
  return v4;
}

uint64_t *fst::ArcIterator<fst::FactorWeightFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>>::ArcIterator(uint64_t *a1, uint64_t a2, int a3)
{
  v6 = *(a2 + 8);
  a1[1] = 0;
  MutableState = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>>>>::GetMutableState(*(v6 + 120), a3);
  *a1 = MutableState;
  ++*(MutableState + 108);
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(*(a2 + 8), a3) & 1) == 0)
  {
    fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Expand(*(a2 + 8), a3);
  }

  return a1;
}

uint64_t fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::InitArcIterator(uint64_t a1, int a2, void *a3)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  return fst::CacheBaseImpl<fst::CacheState<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,std::allocator<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>,fst::DefaultCacheStore<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>>::InitArcIterator(a1, a2, a3);
}

void fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::~ArcMapFst(void *a1)
{
  fst::ImplToFst<fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>::~ImplToFst(a1);

  JUMPOUT(0x1B8C85350);
}

uint64_t fst::ImplToFst<fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>::Properties(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    v8 = 0;
    v5 = fst::TestProperties<fst::ArcTpl<fst::LogWeightTpl<float>,int>>(a1, a2, &v8);
    *(*(a1 + 8) + 8) = *(*(a1 + 8) + 8) & (~v8 | 4) | v8 & v5;
    return v5 & a2;
  }

  else
  {
    v7 = *(**(a1 + 8) + 32);

    return v7();
  }
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Init(uint64_t a1)
{
  std::string::basic_string[abi:ne200100]<0>(&__str, "map");
  std::string::operator=((a1 + 16), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
  }

  v2 = (*(**(a1 + 136) + 112))(*(a1 + 136));
  fst::FstImpl<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>::SetInputSymbols(a1, v2);
  v3 = *(a1 + 48);
  if (v3)
  {
    (*(*v3 + 8))(v3);
    *(a1 + 48) = 0;
  }

  result = (*(**(a1 + 136) + 24))(*(a1 + 136));
  if (result == -1)
  {
    *(a1 + 156) = 0;
    *(a1 + 8) = *(a1 + 8) & 4 | 0x156A5A950000;
  }

  else
  {
    *(a1 + 156) = 1;
    result = (*(**(a1 + 136) + 64))(*(a1 + 136), 0x3FFFFFFF0004, 0);
    if (*(*(a1 + 144) + 4))
    {
      v5 = result & 0x2EBC21080003 | 4;
    }

    else
    {
      v5 = result & 0x2EBC21080007;
    }

    *(a1 + 8) = *(a1 + 8) & 4 | v5;
    if (*(a1 + 156) == 2)
    {
      *(a1 + 160) = 0;
    }
  }

  return result;
}

void sub_1B5A6228C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::~ArcMapFstImpl(uint64_t a1)
{
  fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::~ArcMapFstImpl(a1);

  JUMPOUT(0x1B8C85350);
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Properties(uint64_t a1, uint64_t a2)
{
  if ((a2 & 4) != 0 && ((*(**(a1 + 136) + 64))(*(a1 + 136), 4, 0) || *(*(a1 + 144) + 4) == 1))
  {
    *(a1 + 8) |= 4uLL;
  }

  return *(a1 + 8) & a2;
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::~ArcMapFstImpl(uint64_t a1)
{
  *a1 = &unk_1F2D40F30;
  v2 = *(a1 + 136);
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  if (*(a1 + 152) == 1)
  {
    v3 = *(a1 + 144);
    if (v3)
    {
      MEMORY[0x1B8C85350](v3, 0x1000C4090D0E795);
    }
  }

  return fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::LogWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>::~CacheBaseImpl(a1);
}

void *fst::ImplToFst<fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>::~ImplToFst(void *a1)
{
  *a1 = &unk_1F2D40F80;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2[14] - 1;
    v2[14] = v3;
    if (!v3)
    {
      (*(*v2 + 8))(v2);
    }
  }

  return a1;
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Start(uint64_t a1)
{
  if ((*(a1 + 60) & 1) == 0)
  {
    if ((*(*a1 + 32))(a1, 4))
    {
      *(a1 + 60) = 1;
    }

    else if ((*(a1 + 60) & 1) == 0)
    {
      v2 = (*(**(a1 + 136) + 24))(*(a1 + 136));
      v3 = *(a1 + 160);
      if (v3 != -1 && v3 <= v2)
      {
        v5 = v2 + 1;
      }

      else
      {
        v5 = v2;
      }

      if (v5 >= *(a1 + 164))
      {
        *(a1 + 164) = v5 + 1;
      }

      *(a1 + 64) = v5;
      *(a1 + 60) = 1;
      if (*(a1 + 68) <= v5)
      {
        *(a1 + 68) = v5 + 1;
      }
    }
  }

  return *(a1 + 64);
}

float fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Final(uint64_t a1, int a2)
{
  if (fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>::HasFinal(a1, a2))
  {
    goto LABEL_21;
  }

  v4 = *(a1 + 156);
  if (v4 != 1)
  {
    if (v4 == 2)
    {
      if (*(a1 + 160) == a2)
      {
        v5 = 0.0;
      }

      else
      {
        v5 = INFINITY;
      }

      MutableState = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>>>::GetMutableState(*(a1 + 120), a2);
      *MutableState = v5;
      goto LABEL_20;
    }

    v7 = *(a1 + 144);
    (*(**(a1 + 136) + 32))(&v23);
    fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::GallicArc(__p, 0, 0, &v23, -1);
    v8 = fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::operator()(v7, __p);
    v10 = v9;
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v28);
    std::__list_imp<char *>::clear(v27);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v25);
    std::__list_imp<char *>::clear(v24);
    if (v8)
    {
      if (FLAGS_fst_error_fatal == 1)
      {
        std::string::basic_string[abi:ne200100]<0>(__p, "FATAL");
      }

      else
      {
        std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
      }

      v11 = fst::LogMessage::LogMessage(&v22, __p);
      v12 = fst::cerr(v11);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, "ArcMapFst: non-zero arc labels for superfinal arc", 49);
      fst::LogMessage::~LogMessage(&v22);
      if (SHIBYTE(v27[0]) < 0)
      {
        operator delete(__p[0]);
      }

      *(a1 + 8) |= 4uLL;
    }

    goto LABEL_19;
  }

  if (*(a1 + 160) == a2)
  {
    MutableState = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>>>::GetMutableState(*(a1 + 120), a2);
    *MutableState = 0;
  }

  else
  {
    v13 = *(a1 + 144);
    (*(**(a1 + 136) + 32))(&v19);
    fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::GallicArc(__p, 0, 0, &v19, -1);
    v14 = fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::operator()(v13, __p);
    v10 = v15;
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v28);
    std::__list_imp<char *>::clear(v27);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v21);
    std::__list_imp<char *>::clear(v20);
    if (!v14)
    {
LABEL_19:
      MutableState = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>>>::GetMutableState(*(a1 + 120), a2);
      *MutableState = v10;
      goto LABEL_20;
    }

    MutableState = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>>>::GetMutableState(*(a1 + 120), a2);
    *MutableState = 2139095040;
  }

LABEL_20:
  *(MutableState + 48) |= 9u;
LABEL_21:
  v16 = *(a1 + 120);
  if (*(v16 + 76) == a2)
  {
    v17 = v16 + 80;
  }

  else
  {
    v17 = *(v16 + 8) + 8 * a2 + 8;
  }

  return **v17;
}

void sub_1B5A62850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *__p, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  fst::LogMessage::~LogMessage(&a21);
  if (a35 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

unint64_t fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::operator()(int *a1, unsigned int *a2)
{
  if (a2[18] == -1 && (v4 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)4>::Zero(), fst::operator==<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>((a2 + 2), v4)))
  {
    v5 = 0;
    v6 = *a2;
  }

  else
  {
    v21 = -1;
    if (!fst::FromGallicMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>::Extract((a2 + 2), &v20, &v21) || (v6 = *a2, *a2 != a2[1]))
    {
      if (FLAGS_fst_error_fatal == 1)
      {
        std::string::basic_string[abi:ne200100]<0>(__p, "FATAL");
      }

      else
      {
        std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
      }

      v7 = fst::LogMessage::LogMessage(&v19, __p);
      v8 = fst::cerr(v7);
      v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, "FromGallicMapper: unrepresentable weight: ", 42);
      v10 = fst::operator<<<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,fst::GallicUnionWeightOptions<int,fst::TropicalWeightTpl<float>>>(v9, (a2 + 2));
      v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, " for arc with ilabel = ", 23);
      v12 = MEMORY[0x1B8C84C00](v11, *a2);
      v13 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, ", olabel = ", 11);
      v14 = MEMORY[0x1B8C84C00](v13, a2[1]);
      v15 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v14, ", nextstate = ", 14);
      MEMORY[0x1B8C84C00](v15, a2[18]);
      fst::LogMessage::~LogMessage(&v19);
      if (v18 < 0)
      {
        operator delete(__p[0]);
      }

      *(a1 + 4) = 1;
      v6 = *a2;
    }

    if (!v6 && v21 && a2[18] == -1)
    {
      v6 = *a1;
    }

    v5 = v21 << 32;
  }

  return v5 | v6;
}

void sub_1B5A62A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
  fst::LogMessage::~LogMessage(&a19);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::NumArcs(uint64_t a1, int a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  v4 = *(a1 + 120);
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return (*(*v5 + 32) - *(*v5 + 24)) >> 4;
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(uint64_t a1, int a2)
{
  v4 = *(a1 + 160);
  if (v4 == a2)
  {

    return fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>::SetArcs(a1, a2);
  }

  v6 = *(a1 + 136);
  v8 = v4 != -1 && v4 <= a2;
  v45 = 0;
  (*(*v6 + 136))(v6, (a2 - v8), &v41);
  while (1)
  {
    if (!v41)
    {
      if (v45 >= v43)
      {
        goto LABEL_30;
      }

      goto LABEL_17;
    }

    if ((*(*v41 + 24))(v41))
    {
      break;
    }

    if (v41)
    {
      v9 = (*(*v41 + 32))(v41);
      goto LABEL_18;
    }

LABEL_17:
    v9 = v42 + 80 * v45;
LABEL_18:
    v34 = *v9;
    v35 = *(v9 + 8);
    std::list<int>::list(v37, v9 + 16);
    v38 = *(v9 + 40);
    std::list<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)2>>::list(v39, v9 + 48);
    v10 = *(v9 + 72);
    v11 = *(a1 + 160);
    if (v11 != -1 && v11 <= v10)
    {
      ++v10;
    }

    if (v10 >= *(a1 + 164))
    {
      *(a1 + 164) = v10 + 1;
    }

    v40 = v10;
    *&v33 = fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::operator()(*(a1 + 144), &v34);
    *(&v33 + 1) = v13;
    MutableState = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>>>::GetMutableState(*(a1 + 120), a2);
    std::vector<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>::push_back[abi:ne200100](MutableState + 24, &v33);
    std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v39);
    std::__list_imp<char *>::clear(v37);
    if (v41)
    {
      (*(*v41 + 40))(v41);
    }

    else
    {
      ++v45;
    }
  }

  if (v41)
  {
    (*(*v41 + 8))(v41);
    goto LABEL_32;
  }

LABEL_30:
  if (v44)
  {
    --*v44;
  }

LABEL_32:
  if ((fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>::HasFinal(a1, a2) & 1) == 0 || (LODWORD(v34) = fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Final(a1, a2), LODWORD(v41) = 2139095040, *&v34 == INFINITY))
  {
    v15 = *(a1 + 156);
    if (v15 == 2)
    {
      v22 = *(a1 + 144);
      (*(**(a1 + 136) + 32))(&v27);
      fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::GallicArc(&v34, 0, 0, &v27, -1);
      v23 = fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::operator()(v22, &v34);
      v25 = v24;
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v39);
      std::__list_imp<char *>::clear(v37);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v29);
      std::__list_imp<char *>::clear(v28);
      if (HIDWORD(v23) || v23 || (*&v34 = v25, LODWORD(v41) = 2139095040, v25 != INFINITY))
      {
        v26 = *(a1 + 160);
        v34 = v23;
        v35 = v25;
        v36 = v26;
        v20 = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>>>::GetMutableState(*(a1 + 120), a2) + 24;
        v21 = &v34;
        goto LABEL_44;
      }
    }

    else if (v15 == 1)
    {
      v16 = *(a1 + 144);
      (*(**(a1 + 136) + 32))(&v30);
      fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::GallicArc(&v34, 0, 0, &v30, -1);
      v17 = fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::operator()(v16, &v34);
      v41 = v17;
      v42 = v18;
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v39);
      std::__list_imp<char *>::clear(v37);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v32);
      std::__list_imp<char *>::clear(v31);
      if (v17)
      {
        v19 = *(a1 + 160);
        if (v19 == -1)
        {
          v19 = *(a1 + 164);
          *(a1 + 160) = v19;
          *(a1 + 164) = v19 + 1;
        }

        HIDWORD(v42) = v19;
        v20 = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>>>::GetMutableState(*(a1 + 120), a2) + 24;
        v21 = &v41;
LABEL_44:
        std::vector<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>::push_back[abi:ne200100](v20, v21);
      }
    }
  }

  return fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>::SetArcs(a1, a2);
}

void sub_1B5A62F84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v3 + 48));
  std::__list_imp<char *>::clear((v3 + 16));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(va1);
  std::__list_imp<char *>::clear(va);
  _Unwind_Resume(a1);
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::NumInputEpsilons(uint64_t a1, int a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  v4 = *(a1 + 120);
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return *(*v5 + 8);
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::NumOutputEpsilons(uint64_t a1, int a2)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  v4 = *(a1 + 120);
  if (*(v4 + 76) == a2)
  {
    v5 = v4 + 80;
  }

  else
  {
    v5 = *(v4 + 8) + 8 * a2 + 8;
  }

  return *(*v5 + 16);
}

void *fst::ImplToFst<fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>::ImplToFst(void *result, uint64_t a2, int a3)
{
  *result = &unk_1F2D40F80;
  if (a3)
  {
    operator new();
  }

  v3 = *(a2 + 8);
  result[1] = v3;
  ++*(v3 + 56);
  return result;
}

uint64_t fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::StateIterator(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 8);
  *a1 = &unk_1F2D41030;
  *(a1 + 8) = v3;
  v4 = *(v3 + 136);
  *(a1 + 32) = 0;
  (*(*v4 + 128))(v4, a1 + 16);
  *(a1 + 40) = 0;
  *(a1 + 44) = *(*(a1 + 8) + 156) == 2;
  fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::CheckSuperfinal(a1);
  return a1;
}

void sub_1B5A632F0(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 16);
  if (v3)
  {
    fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::StateIterator(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::CheckSuperfinal(uint64_t result)
{
  v1 = *(result + 8);
  if (*(v1 + 156) == 1)
  {
    v2 = result;
    if ((*(result + 44) & 1) == 0)
    {
      result = *(result + 16);
      if (result)
      {
        result = (*(*result + 16))(result);
        if (result)
        {
          return result;
        }

        v1 = *(v2 + 8);
      }

      else if (*(v2 + 32) >= *(v2 + 24))
      {
        return result;
      }

      v3 = *(v1 + 144);
      (*(**(v1 + 136) + 32))(&v5);
      fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::GallicArc(v8, 0, 0, &v5, -1);
      v4 = fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>::operator()(v3, v8);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v10);
      std::__list_imp<char *>::clear(v9);
      std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(v7);
      result = std::__list_imp<char *>::clear(v6);
      if (v4)
      {
        *(v2 + 44) = 1;
      }
    }
  }

  return result;
}

void sub_1B5A63424(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear((v2 + 48));
  std::__list_imp<char *>::clear((v2 + 16));
  std::__list_imp<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::clear(va1);
  std::__list_imp<char *>::clear(va);
  _Unwind_Resume(a1);
}

void *fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~StateIterator(void *a1)
{
  *a1 = &unk_1F2D41030;
  v2 = a1[2];
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return a1;
}

void fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~StateIterator(void *a1)
{
  *a1 = &unk_1F2D41030;
  v1 = a1[2];
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  JUMPOUT(0x1B8C85350);
}

uint64_t fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Done(uint64_t a1)
{
  v2 = *(a1 + 16);
  if (!v2)
  {
    if (*(a1 + 32) >= *(a1 + 24))
    {
      goto LABEL_3;
    }

LABEL_5:
    v3 = 0;
    return v3 & 1;
  }

  if (((*(*v2 + 16))(v2) & 1) == 0)
  {
    goto LABEL_5;
  }

LABEL_3:
  v3 = *(a1 + 44) ^ 1;
  return v3 & 1;
}

uint64_t fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Next(uint64_t a1)
{
  ++*(a1 + 40);
  result = *(a1 + 16);
  if (result)
  {
    result = (*(*result + 16))(result);
    if ((result & 1) == 0)
    {
      v3 = *(a1 + 16);
      if (v3)
      {
        (*(*v3 + 32))(v3);
LABEL_7:

        return fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::CheckSuperfinal(a1);
      }

LABEL_6:
      ++*(a1 + 32);
      goto LABEL_7;
    }
  }

  else if (*(a1 + 32) < *(a1 + 24))
  {
    goto LABEL_6;
  }

  if (*(a1 + 44) == 1)
  {
    *(a1 + 44) = 0;
  }

  return result;
}

uint64_t fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::Reset(uint64_t a1)
{
  *(a1 + 40) = 0;
  v2 = *(a1 + 16);
  if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  else
  {
    *(a1 + 32) = 0;
  }

  *(a1 + 44) = *(*(a1 + 8) + 156) == 2;

  return fst::StateIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::CheckSuperfinal(a1);
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::InitArcIterator(uint64_t a1, int a2, void *a3)
{
  if ((fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>::HasArcs(a1, a2) & 1) == 0)
  {
    fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(a1, a2);
  }

  return fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>::InitArcIterator(a1, a2, a3);
}

void *fst::ImplToFst<fst::FactorWeightFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::GallicFactor<int,fst::LogWeightTpl<float>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~ImplToFst(void *a1)
{
  *a1 = &unk_1F2D40CF0;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2[14] - 1;
    v2[14] = v3;
    if (!v3)
    {
      (*(*v2 + 8))(v2);
    }
  }

  return a1;
}

void *fst::ImplToFst<fst::ArcMapFstImpl<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>,fst::Fst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::~ImplToFst(void *a1)
{
  *a1 = &unk_1F2D40708;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2[14] - 1;
    v2[14] = v3;
    if (!v3)
    {
      (*(*v2 + 8))(v2);
    }
  }

  return a1;
}

uint64_t fst::DeterminizeFstImpl<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4,fst::DefaultCommonDivisor<fst::LogWeightTpl<float>>,fst::DefaultDeterminizeFilter<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::DefaultDeterminizeStateTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::IntegerFilterState<signed char>>>::~DeterminizeFstImpl(void *a1)
{
  *a1 = &unk_1F2D404A8;
  v2 = a1[20];
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return fst::DeterminizeFstImplBase<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::~DeterminizeFstImplBase(a1);
}

uint64_t *fst::ArcIterator<fst::ArcMapFst<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>>::ArcIterator(uint64_t *a1, uint64_t a2, int a3)
{
  v6 = *(a2 + 8);
  a1[1] = 0;
  MutableState = fst::GCCacheStore<fst::FirstCacheStore<fst::VectorCacheStore<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>>>::GetMutableState(*(v6 + 120), a3);
  *a1 = MutableState;
  ++*(MutableState + 52);
  if ((fst::CacheBaseImpl<fst::CacheState<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,std::allocator<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>::HasArcs(*(a2 + 8), a3) & 1) == 0)
  {
    fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(*(a2 + 8), a3);
  }

  return a1;
}

void sub_1B5A63B40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void **a19)
{
  std::__list_imp<char *>::clear((v19 + 8));
  std::__list_imp<char *>::clear((v20 + 8));
  a19 = (v21 - 72);
  std::vector<fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>>::__destroy_vector::operator()[abi:ne200100](&a19);
  _Unwind_Resume(a1);
}

uint64_t fst::AcceptorMinimize<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(uint64_t a1)
{
  v8 = *MEMORY[0x1E69E9840];
  if ((*(*a1 + 64))(a1, 0x200010000, 1))
  {
    fst::Connect<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1);
  }

  if (FLAGS_fst_error_fatal == 1)
  {
    std::string::basic_string[abi:ne200100]<0>(__p, "FATAL");
  }

  else
  {
    std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
  }

  v2 = fst::LogMessage::LogMessage(&v5, __p);
  v3 = fst::cerr(v2);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v3, "FST is not an unweighted acceptor", 33);
  fst::LogMessage::~LogMessage(&v5);
  if (v7 < 0)
  {
    operator delete(__p[0]);
  }

  return (*(*a1 + 192))(a1, 4, 4);
}

void sub_1B5A63E80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t fst::ArcMap<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(*a2 + 224))(a2);
  v6 = (*(*a1 + 112))(a1);
  (*(*a2 + 280))(a2, v6);
  (*(*a2 + 288))(a2, 0);
  v7 = (*(*a1 + 64))(a1, 0x3FFFFFFF0004, 0);
  result = (*(*a1 + 24))(a1);
  if (result == -1)
  {
    if ((v7 & 4) != 0)
    {
      v18 = *(*a2 + 192);

      return v18(a2, 4, 4);
    }

    return result;
  }

  if ((*(*a1 + 64))(a1, 1, 0))
  {
    v9 = fst::CountStates<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1) != -1;
    (*(*a2 + 248))(a2, v9);
  }

  LODWORD(v24) = 0;
  (*(*a1 + 128))(a1, &v22);
  while (!v22)
  {
    if (v24 >= v23)
    {
      goto LABEL_14;
    }

LABEL_9:
    (*(*a2 + 200))(a2);
    if (v22)
    {
      (*(*v22 + 32))(v22);
    }

    else
    {
      LODWORD(v24) = v24 + 1;
    }
  }

  if (!(*(*v22 + 16))(v22))
  {
    goto LABEL_9;
  }

  if (v22)
  {
    (*(*v22 + 8))(v22);
  }

LABEL_14:
  v33 = 0;
  (*(*a1 + 128))(a1, &v31);
  LODWORD(v10) = -1;
  while (2)
  {
    if (!v31)
    {
      if (v33 >= v32)
      {
        goto LABEL_47;
      }

      goto LABEL_20;
    }

    if (!(*(*v31 + 16))(v31))
    {
      if (v31)
      {
        v11 = (*(*v31 + 24))(v31);
        goto LABEL_21;
      }

LABEL_20:
      v11 = v33;
LABEL_21:
      if (v11 == (*(*a1 + 24))(a1))
      {
        (*(*a2 + 176))(a2, v11);
      }

      v12 = (*(*a1 + 40))(a1, v11);
      (*(*a2 + 256))(a2, v11, v12);
      v26 = 0;
      (*(*a1 + 136))(a1, v11, &v22);
LABEL_24:
      if (v22)
      {
        if ((*(*v22 + 24))(v22))
        {
          if (v22)
          {
            (*(*v22 + 8))();
            goto LABEL_37;
          }

LABEL_35:
          if (v25)
          {
            --*v25;
          }

LABEL_37:
          (*(*a1 + 32))(&v19, a1, v11);
          v22 = 0;
          LODWORD(v23) = v19;
          std::list<int>::list(&v24, v20);
          v27 = v21;
          v28 = -1;
          v29 = fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>::operator()(a3, &v22);
          v30 = v15;
          std::__list_imp<char *>::clear(&v24);
          std::__list_imp<char *>::clear(v20);
          if (v29)
          {
            if (v10 == -1)
            {
              v10 = (*(*a2 + 200))(a2);
              (*(*a2 + 184))(a2, v10, 0.0);
            }

            HIDWORD(v30) = v10;
            (*(*a2 + 208))(a2, v11, &v29);
            (*(*a2 + 184))(a2, v11, INFINITY);
          }

          else
          {
            (*(*a2 + 184))(a2, v11, *&v30);
          }

          if (v31)
          {
            (*(*v31 + 32))(v31);
          }

          else
          {
            ++v33;
          }

          continue;
        }

        if (v22)
        {
          v13 = (*(*v22 + 32))();
          goto LABEL_30;
        }
      }

      else if (v26 >= v24)
      {
        goto LABEL_35;
      }

      v13 = (v23 + 56 * v26);
LABEL_30:
      v29 = fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>::operator()(a3, v13);
      v30 = v14;
      (*(*a2 + 208))(a2, v11, &v29);
      if (v22)
      {
        (*(*v22 + 40))(v22);
      }

      else
      {
        ++v26;
      }

      goto LABEL_24;
    }

    break;
  }

  if (v31)
  {
    (*(*v31 + 8))(v31);
  }

LABEL_47:
  v16 = (*(*a2 + 64))(a2, 0x3FFFFFFF0007, 0);
  v17 = v7 & 0x2EBC21080007;
  if (*(a3 + 72))
  {
    v17 = v7 & 0x2EBC21080003 | 4;
  }

  return (*(*a2 + 192))(a2, v17 | v16, 0x3FFFFFFF0007);
}

void sub_1B5A647E0(_Unwind_Exception *a1)
{
  std::__list_imp<char *>::clear((v2 + 16));
  std::__list_imp<char *>::clear((v1 + 8));
  v5 = *(v3 - 104);
  if (v5)
  {
    (*(*v5 + 8))(v5);
  }

  _Unwind_Resume(a1);
}

uint64_t fst::AcceptorMinimize<fst::ArcTpl<fst::LogWeightTpl<float>,int>>(uint64_t a1)
{
  v8 = *MEMORY[0x1E69E9840];
  if ((*(*a1 + 64))(a1, 0x200010000, 1))
  {
    fst::Connect<fst::ArcTpl<fst::LogWeightTpl<float>,int>>(a1);
  }

  if (FLAGS_fst_error_fatal == 1)
  {
    std::string::basic_string[abi:ne200100]<0>(__p, "FATAL");
  }

  else
  {
    std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
  }

  v2 = fst::LogMessage::LogMessage(&v7, __p);
  v3 = fst::cerr(v2);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v3, "FST is not an unweighted acceptor", 33);
  fst::LogMessage::~LogMessage(&v7);
  if (v6 < 0)
  {
    operator delete(__p[0]);
  }

  return (*(*a1 + 192))(a1, 4, 4);
}

void sub_1B5A64B78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t fst::ArcMap<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::QuantizeMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(uint64_t a1, float *a2)
{
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    v11 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
    if ((*(*a1 + 160))(a1) >= 1)
    {
      v5 = 0;
      do
      {
        (*(*a1 + 296))(a1, v5, &v24);
        while (!(*(*v24 + 24))(v24))
        {
          v6 = (*(*v24 + 32))(v24);
          fst::QuantizeMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()(a2, v6, &v29);
          (*(*v24 + 88))(v24, &v29);
          std::__list_imp<char *>::clear(v31);
          (*(*v24 + 40))(v24);
        }

        if (v24)
        {
          (*(*v24 + 8))();
        }

        (*(*a1 + 32))(&v21, a1, v5);
        v24 = 0;
        v25 = v21;
        std::list<int>::list(v26, v22);
        v27 = v23;
        v28 = -1;
        fst::QuantizeMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()(a2, &v24, &v29);
        std::__list_imp<char *>::clear(v26);
        std::__list_imp<char *>::clear(v22);
        if (!v29)
        {
          goto LABEL_20;
        }

        v7 = FLAGS_fst_error_fatal;
        if (FLAGS_fst_error_fatal == 1)
        {
          std::string::basic_string[abi:ne200100]<0>(v18, "FATAL");
          v8 = fst::LogMessage::LogMessage(&v20, v18);
        }

        else
        {
          std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
          v8 = fst::LogMessage::LogMessage(&v17, __p);
        }

        v9 = fst::cerr(v8);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "ArcMap: non-zero arc labels for superfinal arc", 46);
        if (v7)
        {
          fst::LogMessage::~LogMessage(&v20);
          if (v19 < 0)
          {
            v10 = v18[0];
LABEL_18:
            operator delete(v10);
          }
        }

        else
        {
          fst::LogMessage::~LogMessage(&v17);
          if (v16 < 0)
          {
            v10 = __p[0];
            goto LABEL_18;
          }
        }

        (*(*a1 + 192))(a1, 4, 4);
LABEL_20:
        v12 = v30;
        std::list<int>::list(v13, v31);
        v14 = v32;
        (*(*a1 + 184))(a1, v5, &v12);
        std::__list_imp<char *>::clear(v13);
        std::__list_imp<char *>::clear(v31);
        v5 = (v5 + 1);
      }

      while (v5 < (*(*a1 + 160))(a1));
    }

    return (*(*a1 + 192))(a1, v11 & 0x3FFCFFFF0007, 0x3FFFFFFF0007);
  }

  return result;
}

void sub_1B5A65040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, int a31, __int16 a32, char a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40)
{
  if (a20 < 0)
  {
    operator delete(__p);
  }

  std::__list_imp<char *>::clear((v40 + 16));
  _Unwind_Resume(a1);
}

void *fst::QuantizeMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()@<X0>(float *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  v3 = a2;
  fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>::Quantize(a2 + 2, &v10, *a1);
  v5 = *v3;
  v7 = v10;
  std::list<int>::list(v8, v11);
  v9 = v12;
  *&v3 = v3[12];
  *a3 = v5;
  *(a3 + 8) = v7;
  std::list<int>::list((a3 + 16), v8);
  *(a3 + 40) = v9;
  *(a3 + 48) = v3;
  std::__list_imp<char *>::clear(v8);
  return std::__list_imp<char *>::clear(v11);
}

void sub_1B5A651DC(_Unwind_Exception *a1)
{
  std::__list_imp<char *>::clear((v2 + 8));
  std::__list_imp<char *>::clear((v1 + 8));
  _Unwind_Resume(a1);
}

void fst::EncodeMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::EncodeMapper(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  operator new();
}

uint64_t fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::EncodeTable(uint64_t a1, int a2)
{
  *a1 = a2;
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *(a1 + 24) = 0;
  v4 = a2;
  v5 = a2 & 1;
  v6 = (a2 & 2) != 0;
  std::unordered_map<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const*,int,fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::TupleKey,fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::TupleEqual,std::allocator<std::pair<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const* const,int>>>::unordered_map(a1 + 32, 0x400uLL, &v4);
  *(a1 + 80) = 1;
  *(a1 + 88) = 0;
  *(a1 + 96) = 0;
  return a1;
}

void sub_1B5A652EC(_Unwind_Exception *exception_object)
{
  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(v1 + 16) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::unordered_map<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const*,int,fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::TupleKey,fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::TupleEqual,std::allocator<std::pair<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const* const,int>>>::unordered_map(uint64_t a1, size_t a2, int *a3)
{
  v4 = *a3;
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *(a1 + 32) = v4;
  *(a1 + 36) = v4 & 1;
  *(a1 + 37) = (v4 & 2) != 0;
  *(a1 + 40) = 1065353216;
  std::__hash_table<int,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashFunc,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashEqual,std::allocator<int>>::__rehash<true>(a1, a2);
  return a1;
}

uint64_t fst::ArcMap<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::EncodeMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(uint64_t a1, uint64_t a2)
{
  (*(*a1 + 280))(a1, 0);
  (*(*a1 + 288))(a1, 0);
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    v31 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
    if (*(a2 + 4) == 1 && (*a2 & 2) != 0)
    {
      v5 = (*(*a1 + 200))(a1);
      v7 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>::One();
      v62 = *v7;
      std::list<int>::list(v63, (v7 + 2));
      v64 = v7[8];
      (*(*a1 + 184))(a1, v5, &v62);
      std::__list_imp<char *>::clear(v63);
      v6 = 0;
    }

    else
    {
      LODWORD(v5) = -1;
      v6 = 1;
    }

    if ((*(*a1 + 160))(a1) >= 1)
    {
      v8 = 0;
      while (1)
      {
        (*(*a1 + 296))(a1, v8, &v53);
        while (!(*(*v53 + 24))(v53))
        {
          v9 = (*(*v53 + 32))(v53);
          fst::EncodeMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()(a2, v9, &v58);
          (*(*v53 + 88))(v53, &v58);
          std::__list_imp<char *>::clear(v60);
          (*(*v53 + 40))(v53);
        }

        if (v53)
        {
          (*(*v53 + 8))();
        }

        if (v6)
        {
          break;
        }

        if (v8 != v5)
        {
          (*(*a1 + 32))(&v38, a1, v8);
          v53 = 0;
          v54 = v38;
          std::list<int>::list(v55, v39);
          v56 = v40;
          v57 = -1;
          fst::EncodeMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()(a2, &v53, &v58);
          std::__list_imp<char *>::clear(v55);
          std::__list_imp<char *>::clear(v39);
          if (v58)
          {
            v13 = v59;
            goto LABEL_50;
          }

          v15 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>::Zero();
          v13 = v59;
          if (v59)
          {
            v16 = v60[2] + 1;
          }

          else
          {
            v16 = 0;
          }

          if (*v15)
          {
            v17 = *(v15 + 24) + 1;
          }

          else
          {
            v17 = 0;
          }

          if (v16 != v17)
          {
            goto LABEL_50;
          }

          v18 = v60[1];
          v19 = (v15 + 16);
          v20 = v59 && v59 == *v15;
          v21 = !v20;
          v22 = 1;
          v23 = !v21;
          while (1)
          {
            v24 = *v19;
            if ((v22 & 1) != 0 && !v23)
            {
              break;
            }

            if (v18 == v60)
            {
              goto LABEL_49;
            }

            if (*(v18 + 16) != *(v24 + 16))
            {
              goto LABEL_50;
            }

            v22 = 0;
            v18 = *(v18 + 8);
            v19 = (v24 + 8);
          }

          if (v59)
          {
            goto LABEL_50;
          }

LABEL_49:
          *&v53 = v61;
          v65 = *(v15 + 32);
          if (v61 != v65)
          {
LABEL_50:
            v26 = v58;
            v35 = v13;
            std::list<int>::list(v36, v60);
            v37 = v61;
            v53 = v26;
            v54 = v35;
            std::list<int>::list(v55, v36);
            v56 = v37;
            v57 = v5;
            (*(*a1 + 208))(a1, v8, &v53);
            std::__list_imp<char *>::clear(v55);
            std::__list_imp<char *>::clear(v36);
          }

          v27 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>::Zero();
          v32 = *v27;
          std::list<int>::list(v33, (v27 + 2));
          v34 = v27[8];
          (*(*a1 + 184))(a1, v8, &v32);
          v25 = v33;
LABEL_52:
          std::__list_imp<char *>::clear(v25);
          std::__list_imp<char *>::clear(v60);
        }

        v8 = (v8 + 1);
        if (v8 >= (*(*a1 + 160))(a1))
        {
          goto LABEL_54;
        }
      }

      (*(*a1 + 32))(&v50, a1, v8);
      v53 = 0;
      v54 = v50;
      std::list<int>::list(v55, v51);
      v56 = v52;
      v57 = -1;
      fst::EncodeMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()(a2, &v53, &v58);
      std::__list_imp<char *>::clear(v55);
      std::__list_imp<char *>::clear(v51);
      if (!v58)
      {
LABEL_47:
        v41 = v59;
        std::list<int>::list(v42, v60);
        v43 = v61;
        (*(*a1 + 184))(a1, v8, &v41);
        v25 = v42;
        goto LABEL_52;
      }

      v10 = FLAGS_fst_error_fatal;
      if (FLAGS_fst_error_fatal == 1)
      {
        std::string::basic_string[abi:ne200100]<0>(v47, "FATAL");
        v11 = fst::LogMessage::LogMessage(&v49, v47);
      }

      else
      {
        std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
        v11 = fst::LogMessage::LogMessage(&v46, __p);
      }

      v12 = fst::cerr(v11);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, "ArcMap: non-zero arc labels for superfinal arc", 46);
      if (v10)
      {
        fst::LogMessage::~LogMessage(&v49);
        if (v48 < 0)
        {
          v14 = v47[0];
LABEL_45:
          operator delete(v14);
        }
      }

      else
      {
        fst::LogMessage::~LogMessage(&v46);
        if (v45 < 0)
        {
          v14 = __p[0];
          goto LABEL_45;
        }
      }

      (*(*a1 + 192))(a1, 4, 4);
      goto LABEL_47;
    }

LABEL_54:
    v28 = 0x3FFF00000007;
    if ((*a2 & 1) == 0)
    {
      v28 = 0x3FFFFFFF0007;
    }

    if ((*a2 & 2) != 0)
    {
      v29 = 0x1D7C48100007;
      if (*(a2 + 4) == 1)
      {
        v29 = 0x2EBC84200007;
      }

      v28 &= v29;
    }

    if (*(a2 + 16))
    {
      v30 = v31 | 4;
    }

    else
    {
      v30 = v31;
    }

    return (*(*a1 + 192))(a1, v28 & v30, 0x3FFFFFFF0007);
  }

  return result;
}

void *fst::EncodeMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()@<X0>(int *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  v6 = a2[12];
  if (a1[1] != 1)
  {
    if (v6 != -1 && *a2)
    {
      v11 = *a1;
      if ((*a1 & 1) != 0 && *a2 != a2[1])
      {
        if (FLAGS_fst_error_fatal == 1)
        {
          std::string::basic_string[abi:ne200100]<0>(v62, "FATAL");
        }

        else
        {
          std::string::basic_string[abi:ne200100]<0>(v62, "ERROR");
        }

        v12 = fst::LogMessage::LogMessage(&v64, v62);
        v13 = fst::cerr(v12);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v13, "EncodeMapper: Label-encoded arc has different input and output labels", 69);
        fst::LogMessage::~LogMessage(&v64);
        if (v63 < 0)
        {
          operator delete(v62[0]);
        }

        *(a1 + 16) = 1;
        v11 = *a1;
      }

      if ((v11 & 2) != 0)
      {
        v26 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>::One();
        v27 = a2[2];
        v28 = v27 ? *(a2 + 4) + 1 : 0;
        v29 = *v26 ? *(v26 + 24) + 1 : 0;
        if (v28 != v29)
        {
          goto LABEL_63;
        }

        v30 = (a2 + 6);
        v31 = (v26 + 16);
        v32 = v27 && v27 == *v26;
        v33 = !v32;
        v34 = 1;
        v35 = !v33;
        while (1)
        {
          v36 = *v30;
          v37 = *v31;
          if ((v34 & 1) != 0 && !v35)
          {
            break;
          }

          if (v36 == a2 + 4)
          {
            goto LABEL_62;
          }

          if (*(v36 + 16) != *(v37 + 16))
          {
            goto LABEL_63;
          }

          v34 = 0;
          v30 = (v36 + 8);
          v31 = (v37 + 8);
        }

        if (v27)
        {
          goto LABEL_63;
        }

LABEL_62:
        LODWORD(__p[0]) = a2[10];
        LODWORD(v56[0]) = *(v26 + 32);
        if (*__p != *v56)
        {
LABEL_63:
          if (FLAGS_fst_error_fatal == 1)
          {
            std::string::basic_string[abi:ne200100]<0>(__p, "FATAL");
          }

          else
          {
            std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
          }

          v38 = fst::LogMessage::LogMessage(&v61, __p);
          v39 = fst::cerr(v38);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v39, "EncodeMapper: Weight-encoded arc has non-trivial weight", 55);
          fst::LogMessage::~LogMessage(&v61);
          if (v60 < 0)
          {
            operator delete(__p[0]);
          }

          *(a1 + 16) = 1;
        }
      }

      v40 = fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Decode(*(a1 + 1), *a2);
      if (v40)
      {
        v41 = *v40;
        if (*a1)
        {
          v42 = v40;
        }

        else
        {
          v42 = a2;
        }

        v43 = v42[1];
        if ((*a1 & 2) != 0)
        {
          v44 = v40;
        }

        else
        {
          v44 = a2;
        }

        v50 = v44[2];
        std::list<int>::list(v51, (v44 + 4));
        v52 = v44[10];
        v45 = a2[12];
        *a3 = v41;
        *(a3 + 4) = v43;
        *(a3 + 8) = v50;
        std::list<int>::list((a3 + 16), v51);
        *(a3 + 40) = v52;
        *(a3 + 48) = v45;
        v16 = v51;
      }

      else
      {
        if (FLAGS_fst_error_fatal == 1)
        {
          std::string::basic_string[abi:ne200100]<0>(v56, "FATAL");
        }

        else
        {
          std::string::basic_string[abi:ne200100]<0>(v56, "ERROR");
        }

        v46 = fst::LogMessage::LogMessage(&v58, v56);
        v47 = fst::cerr(v46);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v47, "EncodeMapper: decode failed", 27);
        fst::LogMessage::~LogMessage(&v58);
        if (v57 < 0)
        {
          operator delete(v56[0]);
        }

        *(a1 + 16) = 1;
        v48 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>::NoWeight();
        v53 = *v48;
        std::list<int>::list(v54, (v48 + 2));
        v55 = v48[8];
        v49 = a2[12];
        *a3 = -1;
        *(a3 + 8) = v53;
        std::list<int>::list((a3 + 16), v54);
        *(a3 + 40) = v55;
        *(a3 + 48) = v49;
        v16 = v54;
      }

      return std::__list_imp<char *>::clear(v16);
    }

    *a3 = *a2;
    v14 = a2[2];
    goto LABEL_20;
  }

  if (v6 == -1)
  {
    if ((*a1 & 2) != 0)
    {
      v18 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>::Zero();
      v14 = a2[2];
      if (v14)
      {
        v19 = *(a2 + 4) + 1;
      }

      else
      {
        v19 = 0;
      }

      if (*v18)
      {
        v20 = *(v18 + 24) + 1;
      }

      else
      {
        v20 = 0;
      }

      if (v19 != v20)
      {
        goto LABEL_3;
      }

      v21 = (a2 + 6);
      v22 = (v18 + 16);
      for (i = 1; ; i = 0)
      {
        v24 = *v21;
        v25 = *v22;
        if (i)
        {
          if (!v14)
          {
            break;
          }

          if (v14 != *v18)
          {
            goto LABEL_3;
          }
        }

        if (v24 == a2 + 4)
        {
          break;
        }

        if (*(v24 + 16) != *(v25 + 16))
        {
          goto LABEL_3;
        }

        v21 = (v24 + 8);
        v22 = (v25 + 8);
      }

      LODWORD(v62[0]) = a2[10];
      LODWORD(__p[0]) = *(v18 + 32);
      if (*v62 != *__p)
      {
        goto LABEL_3;
      }
    }

    else
    {
      v14 = a2[2];
    }

    *a3 = *a2;
LABEL_20:
    *(a3 + 8) = v14;
    result = std::list<int>::list((a3 + 16), (a2 + 4));
    *(a3 + 40) = a2[10];
    *(a3 + 48) = a2[12];
    return result;
  }

LABEL_3:
  v7 = fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Encode(*(a1 + 1), a2);
  v8 = v7;
  if (*a1)
  {
    v9 = v7;
  }

  else
  {
    v9 = a2[1];
  }

  if ((*a1 & 2) != 0)
  {
    v10 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>::One();
  }

  else
  {
    v10 = (a2 + 2);
  }

  v65 = *v10;
  std::list<int>::list(v66, (v10 + 2));
  v67 = v10[8];
  v15 = a2[12];
  *a3 = v8;
  *(a3 + 4) = v9;
  *(a3 + 8) = v65;
  std::list<int>::list((a3 + 16), v66);
  *(a3 + 40) = v67;
  *(a3 + 48) = v15;
  v16 = v66;
  return std::__list_imp<char *>::clear(v16);
}

void sub_1B5A661B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  fst::LogMessage::~LogMessage(&a29);
  if (a25 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Encode(uint64_t a1, int *a2)
{
  v3 = *a2;
  v4 = ((*a1 << 31) >> 31) & a2[1];
  if ((*a1 & 2) != 0)
  {
    v5 = a2 + 2;
  }

  else
  {
    v5 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>::One();
  }

  v9 = *v5;
  std::list<int>::list(v10, (v5 + 2));
  v11 = v5[8];
  v12[0] = v3;
  v12[1] = v4;
  v12[2] = v9;
  std::list<int>::list(v13, v10);
  v14 = v11;
  std::__list_imp<char *>::clear(v10);
  v15 = v12;
  v6 = std::__hash_table<std::__hash_value_type<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const*,int>,std::__unordered_map_hasher<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const*,std::__hash_value_type<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const*,int>,fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::TupleKey,fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::TupleEqual,false>,std::__unordered_map_equal<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const*,std::__hash_value_type<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const*,int>,fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::TupleEqual,fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::TupleKey,true>,std::allocator<std::__hash_value_type<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const*,int>>>::find<fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::Tuple const*>((a1 + 32), &v15);
  if (!v6)
  {
    operator new();
  }

  v7 = *(v6 + 6);
  std::__list_imp<char *>::clear(v13);
  return v7;
}

uint64_t fst::EncodeTable<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Decode(uint64_t a1, uint64_t a2)
{
  if (a2 >= 1)
  {
    v3 = *(a1 + 8);
    if (a2 <= ((*(a1 + 16) - v3) >> 3))
    {
      return *(v3 + 8 * a2 - 8);
    }
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
  v4 = fst::LogMessage::LogMessage(&v10, __p);
  v5 = fst::cerr(v4);
  v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v5, "EncodeTable::Decode: unknown decode key: ", 41);
  MEMORY[0x1B8C84C00](v6, a2);
  fst::LogMessage::~LogMessage(&v10);
  if (v9 < 0)
  {
    operator delete(__p[0]);
  }

  return 0;
}

void sub_1B5A6655C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void fst::Connect<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(uint64_t a1)
{
  memset(v4, 0, sizeof(v4));
  v2 = 0;
  memset(v3, 0, sizeof(v3));
  v1[0] = 0;
  v1[1] = v4;
  v1[2] = v3;
  v1[3] = &v2;
  fst::DfsVisit<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::SccVisitor<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::AnyArcFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a1, v1);
}

void sub_1B5A666DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  v14 = *(v12 - 80);
  if (v14)
  {
    operator delete(v14);
  }

  v15 = *(v11 + 24);
  if (v15)
  {
    operator delete(v15);
  }

  _Unwind_Resume(exception_object);
}

void fst::ArcSort<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(uint64_t a1)
{
  v3 = a1;
  v4 = &v6;
  memset(v5, 0, sizeof(v5));
  v1[0] = a1;
  v1[1] = &v6;
  memset(v2, 0, sizeof(v2));
  fst::StateMap<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ArcSortMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>(a1, v1);
  v7 = v2;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::__destroy_vector::operator()[abi:ne200100](&v7);
  v7 = v5;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::__destroy_vector::operator()[abi:ne200100](&v7);
}

void sub_1B5A66790(_Unwind_Exception *a1)
{
  v4 = v1;
  *(v3 - 40) = v2;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::__destroy_vector::operator()[abi:ne200100]((v3 - 40));
  *(v3 - 40) = v4;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::__destroy_vector::operator()[abi:ne200100]((v3 - 40));
  _Unwind_Resume(a1);
}

void fst::MergeStates<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(void *a1, uint64_t a2)
{
  std::vector<int>::vector[abi:ne200100](&__p, ((a1[5] - a1[4]) >> 3));
  v5 = a1[4];
  v4 = a1[5];
  v6 = v4 - v5;
  if (((v4 - v5) >> 3))
  {
    v7 = 0;
    v8 = (v6 >> 3);
    v9 = __p;
    if (v8 <= 1)
    {
      v8 = 1;
    }

    do
    {
      *v9++ = **(v5 + (v7 >> 29));
      v7 += 0x100000000;
      --v8;
    }

    while (v8);
  }

  if ((v6 & 0x7FFFFFFF8) != 0)
  {
    v10 = 0;
    do
    {
      v11 = *(v5 + 8 * v10);
      if (v11)
      {
        do
        {
          v12 = *v11;
          (*(*a2 + 296))(a2, *v11, &v21);
          while (!(*(*v21 + 24))(v21))
          {
            v13 = (*(*v21 + 32))(v21);
            v16 = *v13;
            v17 = *(v13 + 8);
            std::list<int>::list(v18, v13 + 16);
            v14 = *(v13 + 48);
            v19 = *(v13 + 40);
            v20 = v14;
            v20 = *(__p + *(a1[10] + 4 * v14));
            if (v12 == *(__p + v10))
            {
              (*(*v21 + 88))(v21, &v16);
            }

            else
            {
              (*(*a2 + 208))(a2);
            }

            std::__list_imp<char *>::clear(v18);
            (*(*v21 + 40))(v21);
          }

          if (v21)
          {
            (*(*v21 + 8))(v21);
          }

          v11 = *(v11 + 1);
        }

        while (v11);
        v5 = a1[4];
        v4 = a1[5];
      }

      ++v10;
    }

    while (v10 < ((v4 - v5) >> 3));
  }

  v15 = (*(*a2 + 24))(a2);
  (*(*a2 + 176))(a2, *(__p + *(a1[10] + 4 * v15)));
  fst::Connect<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a2);
}

void sub_1B5A66AA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t fst::StateMap<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ArcSortMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>(uint64_t a1, uint64_t *a2)
{
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    v5 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
    v6 = (*(**a2 + 24))();
    (*(*a1 + 176))(a1, v6);
    if ((*(*a1 + 160))(a1) >= 1)
    {
      v7 = 0;
      do
      {
        fst::ArcSortMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>::SetState(a2, v7);
        (*(*a1 + 240))(a1, v7);
        for (i = a2[5]; ; a2[5] = i)
        {
          v9 = a2[2];
          if (i >= 0x6DB6DB6DB6DB6DB7 * ((a2[3] - v9) >> 3))
          {
            break;
          }

          (*(*a1 + 208))(a1, v7, v9 + 56 * i);
          i = a2[5] + 1;
        }

        (*(**a2 + 32))(&v10);
        (*(*a1 + 184))(a1, v7, &v10);
        std::__list_imp<char *>::clear(v11);
        v7 = (v7 + 1);
      }

      while (v7 < (*(*a1 + 160))(a1));
    }

    return (*(*a1 + 192))(a1, v5 & 0x3FFF0FFF0007 | (((v5 >> 16) & 1) << 30) | 0x10000000, 0x3FFFFFFF0007);
  }

  return result;
}

void *fst::ArcSortMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>::SetState(uint64_t *a1, uint64_t a2)
{
  v4 = a1 + 2;
  v5 = a1[2];
  a1[5] = 0;
  v6 = a1[3];
  if (v6 != v5)
  {
    do
    {
      v7 = v6 - 56;
      std::__list_imp<char *>::clear((v6 - 40));
      v6 = v7;
    }

    while (v7 != v5);
  }

  a1[3] = v5;
  v8 = (*(**a1 + 40))(*a1, a2);
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::reserve(v4, v8);
  v9 = *a1;
  v18 = 0;
  (*(*v9 + 136))(v9, a2, v16);
  while (1)
  {
    if (!v16[0])
    {
      if (v18 >= v16[2])
      {
        goto LABEL_15;
      }

LABEL_9:
      v10 = v16[1] + 56 * v18;
      goto LABEL_10;
    }

    if ((*(*v16[0] + 24))(v16[0]))
    {
      break;
    }

    if (!v16[0])
    {
      goto LABEL_9;
    }

    v10 = (*(*v16[0] + 32))();
LABEL_10:
    std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::push_back[abi:ne200100](v4, v10);
    if (v16[0])
    {
      (*(*v16[0] + 40))(v16[0]);
    }

    else
    {
      ++v18;
    }
  }

  if (v16[0])
  {
    (*(*v16[0] + 8))();
    goto LABEL_17;
  }

LABEL_15:
  if (v17)
  {
    --*v17;
  }

LABEL_17:
  v11 = a1[2];
  v12 = a1[3];
  v13 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (v12 - v11));
  if (v12 == v11)
  {
    v14 = 0;
  }

  else
  {
    v14 = v13;
  }

  return std::__introsort<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,false>(v11, v12, v16, v14, 1);
}

void sub_1B5A67014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    fst::Reverse<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>();
  }

  else
  {
    fst::ComposeFstImpl<fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::SequenceComposeFilter<fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>,fst::GenericComposeStateTable<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::IntegerFilterState<signed char>,fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::CompactHashStateTable<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::ComposeHash<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>>>>>::OrderedExpand<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>(&a10);
  }

  _Unwind_Resume(a1);
}

void *std::__introsort<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,false>(void *result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  v8 = result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (1)
  {
    v8 = v9;
    v11 = v10;
    v12 = a2 - v9;
    v13 = 0x6DB6DB6DB6DB6DB7 * ((a2 - v9) >> 3);
    if (v13 > 2)
    {
      switch(v13)
      {
        case 3uLL:
          return std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v9, v9 + 56, (a2 - 7));
        case 4uLL:
          return std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v9, v9 + 56, v9 + 112, (a2 - 7));
        case 5uLL:
          return std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v9, v9 + 56, v9 + 112, v9 + 168, (a2 - 7));
      }
    }

    else
    {
      if (v13 < 2)
      {
        return result;
      }

      if (v13 == 2)
      {
        v24 = *(a2 - 7);
        v23 = a2 - 7;
        v42 = v24;
        v43 = *(v23 + 2);
        std::list<int>::list(v44, (v23 + 2));
        v45 = *(v23 + 10);
        v46 = *(v23 + 12);
        v37 = *v9;
        v38 = *(v9 + 8);
        std::list<int>::list(v39, v9 + 16);
        v25 = *(v9 + 48);
        v40 = *(v9 + 40);
        v41 = v25;
        v26 = v42;
        v27 = v37;
        std::__list_imp<char *>::clear(v39);
        result = std::__list_imp<char *>::clear(v44);
        if (v26 < v27)
        {
          return std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(v9, v23);
        }

        return result;
      }
    }

    if (v12 <= 1343)
    {
      if (a5)
      {
        return std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v9, a2);
      }

      else
      {
        return std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v9, a2);
      }
    }

    if (v11 == 1)
    {
      break;
    }

    v14 = v13 >> 1;
    v15 = (v8 + 56 * (v13 >> 1));
    if (v12 < 0x1C01)
    {
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v15, v8, (a2 - 7));
      if (a5)
      {
        goto LABEL_19;
      }
    }

    else
    {
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v8, v15, (a2 - 7));
      v16 = 56 * v14;
      v17 = 56 * v14 + v8 - 56;
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v8 + 56, v17, (a2 - 14));
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v8 + 112, v8 + 56 + v16, (a2 - 21));
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v17, v15, v8 + 56 + v16);
      std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(v8, v15);
      if (a5)
      {
        goto LABEL_19;
      }
    }

    v32 = *(v8 - 56);
    v33 = *(v8 - 48);
    std::list<int>::list(v34, v8 - 40);
    v35 = *(v8 - 16);
    v36 = *(v8 - 8);
    v28 = *v8;
    std::list<int>::list(v29, v8 + 16);
    v18 = *(v8 + 48);
    v30 = *(v8 + 40);
    v31 = v18;
    v19 = v32;
    std::__list_imp<char *>::clear(v29);
    std::__list_imp<char *>::clear(v34);
    if (v19 >= v28)
    {
      result = std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0> *,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &>(v8, a2);
      v9 = result;
LABEL_23:
      a5 = 0;
      a4 = -v11;
      goto LABEL_3;
    }

LABEL_19:
    v20 = std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0> *,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &>(v8, a2);
    if ((v21 & 1) == 0)
    {
      goto LABEL_22;
    }

    v22 = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v8, v20);
    v9 = v20 + 56;
    result = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v20 + 56, a2);
    if (result)
    {
      a4 = -v11;
      a2 = v20;
      if (v22)
      {
        return result;
      }

      goto LABEL_2;
    }

    v10 = v11 + 1;
    if ((v22 & 1) == 0)
    {
LABEL_22:
      result = std::__introsort<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,false>(v8, v20, a3, -v11, a5 & 1);
      v9 = v20 + 56;
      goto LABEL_23;
    }
  }

  if (v9 != a2)
  {
    return std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v9, a2, a2, a3);
  }

  return result;
}

uint64_t std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v68 = *a2;
  v69 = *(a2 + 8);
  std::list<int>::list(v70, a2 + 16);
  v6 = *(a2 + 48);
  v71 = *(a2 + 40);
  v72 = v6;
  v63 = *a1;
  v64 = *(a1 + 8);
  std::list<int>::list(v65, a1 + 16);
  v7 = *(a1 + 48);
  v66 = *(a1 + 40);
  v67 = v7;
  v8 = v68;
  std::__list_imp<char *>::clear(v65);
  std::__list_imp<char *>::clear(v70);
  if (v8 < v63)
  {
    v38 = *a3;
    v39 = *(a3 + 8);
    std::list<int>::list(v40, a3 + 16);
    v9 = *(a3 + 48);
    v41 = *(a3 + 40);
    v42 = v9;
    v33 = *a2;
    v34 = *(a2 + 8);
    std::list<int>::list(v35, a2 + 16);
    v10 = *(a2 + 48);
    v36 = *(a2 + 40);
    v37 = v10;
    v11 = v38;
    std::__list_imp<char *>::clear(v35);
    std::__list_imp<char *>::clear(v40);
    v12 = a1;
    if (v11 < v33)
    {
LABEL_5:
      v16 = a3;
LABEL_9:
      std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(v12, v16);
      return 1;
    }

    std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1, a2);
    v28 = *a3;
    v29 = *(a3 + 8);
    std::list<int>::list(v30, a3 + 16);
    v13 = *(a3 + 48);
    v31 = *(a3 + 40);
    v32 = v13;
    v24 = *a2;
    std::list<int>::list(v25, a2 + 16);
    v14 = *(a2 + 48);
    v26 = *(a2 + 40);
    v27 = v14;
    v15 = v28;
    std::__list_imp<char *>::clear(v25);
    std::__list_imp<char *>::clear(v30);
    if (v15 < v24)
    {
      v12 = a2;
      goto LABEL_5;
    }

    return 1;
  }

  v58 = *a3;
  v59 = *(a3 + 8);
  std::list<int>::list(v60, a3 + 16);
  v17 = *(a3 + 48);
  v61 = *(a3 + 40);
  v62 = v17;
  v53 = *a2;
  v54 = *(a2 + 8);
  std::list<int>::list(v55, a2 + 16);
  v18 = *(a2 + 48);
  v56 = *(a2 + 40);
  v57 = v18;
  v19 = v58;
  std::__list_imp<char *>::clear(v55);
  std::__list_imp<char *>::clear(v60);
  if (v19 < v53)
  {
    std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a2, a3);
    v48 = *a2;
    v49 = *(a2 + 8);
    std::list<int>::list(v50, a2 + 16);
    v20 = *(a2 + 48);
    v51 = *(a2 + 40);
    v52 = v20;
    v43 = *a1;
    v44 = *(a1 + 8);
    std::list<int>::list(v45, a1 + 16);
    v21 = *(a1 + 48);
    v46 = *(a1 + 40);
    v47 = v21;
    v22 = v48;
    std::__list_imp<char *>::clear(v45);
    std::__list_imp<char *>::clear(v50);
    if (v22 < v43)
    {
      v12 = a1;
      v16 = a2;
      goto LABEL_9;
    }

    return 1;
  }

  return 0;
}

void *std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, a2, a3);
  v42 = *a4;
  v43 = *(a4 + 8);
  std::list<int>::list(v44, a4 + 16);
  v8 = *(a4 + 48);
  v45 = *(a4 + 40);
  v46 = v8;
  v37 = *a3;
  v38 = *(a3 + 8);
  std::list<int>::list(v39, a3 + 16);
  v9 = *(a3 + 48);
  v40 = *(a3 + 40);
  v41 = v9;
  v10 = v42;
  std::__list_imp<char *>::clear(v39);
  result = std::__list_imp<char *>::clear(v44);
  if (v10 < v37)
  {
    std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a3, a4);
    v32 = *a3;
    v33 = *(a3 + 8);
    std::list<int>::list(v34, a3 + 16);
    v12 = *(a3 + 48);
    v35 = *(a3 + 40);
    v36 = v12;
    v27 = *a2;
    v28 = *(a2 + 8);
    std::list<int>::list(v29, a2 + 16);
    v13 = *(a2 + 48);
    v30 = *(a2 + 40);
    v31 = v13;
    v14 = v32;
    std::__list_imp<char *>::clear(v29);
    result = std::__list_imp<char *>::clear(v34);
    if (v14 < v27)
    {
      std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a2, a3);
      v22 = *a2;
      v23 = *(a2 + 8);
      std::list<int>::list(v24, a2 + 16);
      v15 = *(a2 + 48);
      v25 = *(a2 + 40);
      v26 = v15;
      v18 = *a1;
      std::list<int>::list(v19, a1 + 16);
      v16 = *(a1 + 48);
      v20 = *(a1 + 40);
      v21 = v16;
      v17 = v22;
      std::__list_imp<char *>::clear(v19);
      result = std::__list_imp<char *>::clear(v24);
      if (v17 < v18)
      {
        return std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1, a2);
      }
    }
  }

  return result;
}

void *std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, a2, a3, a4);
  v57 = *a5;
  v58 = *(a5 + 8);
  std::list<int>::list(v59, a5 + 16);
  v10 = *(a5 + 48);
  v60 = *(a5 + 40);
  v61 = v10;
  v52 = *a4;
  v53 = *(a4 + 8);
  std::list<int>::list(v54, a4 + 16);
  v11 = *(a4 + 48);
  v55 = *(a4 + 40);
  v56 = v11;
  v12 = v57;
  std::__list_imp<char *>::clear(v54);
  result = std::__list_imp<char *>::clear(v59);
  if (v12 < v52)
  {
    std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a4, a5);
    v47 = *a4;
    v48 = *(a4 + 8);
    std::list<int>::list(v49, a4 + 16);
    v14 = *(a4 + 48);
    v50 = *(a4 + 40);
    v51 = v14;
    v42 = *a3;
    v43 = *(a3 + 8);
    std::list<int>::list(v44, a3 + 16);
    v15 = *(a3 + 48);
    v45 = *(a3 + 40);
    v46 = v15;
    v16 = v47;
    std::__list_imp<char *>::clear(v44);
    result = std::__list_imp<char *>::clear(v49);
    if (v16 < v42)
    {
      std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a3, a4);
      v37 = *a3;
      v38 = *(a3 + 8);
      std::list<int>::list(v39, a3 + 16);
      v17 = *(a3 + 48);
      v40 = *(a3 + 40);
      v41 = v17;
      v32 = *a2;
      v33 = *(a2 + 8);
      std::list<int>::list(v34, a2 + 16);
      v18 = *(a2 + 48);
      v35 = *(a2 + 40);
      v36 = v18;
      v19 = v37;
      std::__list_imp<char *>::clear(v34);
      result = std::__list_imp<char *>::clear(v39);
      if (v19 < v32)
      {
        std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a2, a3);
        v27 = *a2;
        v28 = *(a2 + 8);
        std::list<int>::list(v29, a2 + 16);
        v20 = *(a2 + 48);
        v30 = *(a2 + 40);
        v31 = v20;
        v23 = *a1;
        std::list<int>::list(v24, a1 + 16);
        v21 = *(a1 + 48);
        v25 = *(a1 + 40);
        v26 = v21;
        v22 = v27;
        std::__list_imp<char *>::clear(v24);
        result = std::__list_imp<char *>::clear(v29);
        if (v22 < v23)
        {
          return std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1, a2);
        }
      }
    }
  }

  return result;
}

void *std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(void *result, void *a2)
{
  if (result != a2)
  {
    v2 = result;
    v3 = result + 7;
    if (result + 7 != a2)
    {
      v4 = 0;
      v5 = result;
      do
      {
        v6 = v3;
        v38 = v5[7];
        v39 = *(v5 + 16);
        std::list<int>::list(v40, (v5 + 9));
        v7 = *(v5 + 26);
        v41 = *(v5 + 24);
        v42 = v7;
        v33 = *v5;
        v34 = *(v5 + 2);
        std::list<int>::list(v35, (v5 + 2));
        v8 = *(v5 + 12);
        v36 = *(v5 + 10);
        v37 = v8;
        v9 = v38;
        v10 = v33;
        std::__list_imp<char *>::clear(v35);
        result = std::__list_imp<char *>::clear(v40);
        if (v9 < v10)
        {
          v28 = *v6;
          v29 = *(v5 + 16);
          std::list<int>::list(v30, (v5 + 9));
          v11 = *(v5 + 26);
          v31 = *(v5 + 24);
          v32 = v11;
          v12 = v4;
          while (1)
          {
            v13 = v2 + v12;
            *(v13 + 7) = *(v2 + v12);
            *(v13 + 16) = *(v2 + v12 + 8);
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v2 + v12 + 72), *(v2 + v12 + 24), v2 + v12 + 16);
            *(v13 + 24) = *(v13 + 10);
            *(v13 + 26) = *(v13 + 12);
            if (!v12)
            {
              break;
            }

            v23 = v28;
            v24 = v29;
            std::list<int>::list(v25, v30);
            v26 = v31;
            v27 = v32;
            v19 = *(v2 + v12 - 56);
            std::list<int>::list(v20, v2 + v12 - 40);
            v14 = *(v2 + v12 - 8);
            v21 = *(v2 + v12 - 16);
            v22 = v14;
            v15 = v23;
            std::__list_imp<char *>::clear(v20);
            std::__list_imp<char *>::clear(v25);
            v12 -= 56;
            if (v15 >= v19)
            {
              v16 = v2 + v12 + 56;
              goto LABEL_10;
            }
          }

          v16 = v2;
LABEL_10:
          *v16 = v28;
          *(v16 + 8) = v29;
          if (v16 != &v28)
          {
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v16 + 16), v30[1], v30);
          }

          v17 = v32;
          *(v16 + 40) = v31;
          *(v16 + 48) = v17;
          result = std::__list_imp<char *>::clear(v30);
        }

        v3 = v6 + 7;
        v4 += 56;
        v5 = v6;
      }

      while (v6 + 7 != a2);
    }
  }

  return result;
}

void *std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(void *result, void *a2)
{
  if (result != a2)
  {
    v2 = result;
    v3 = result + 7;
    if (result + 7 != a2)
    {
      v4 = 0;
      v5 = result;
      do
      {
        v6 = v3;
        v38 = v5[7];
        v39 = *(v5 + 16);
        std::list<int>::list(v40, (v5 + 9));
        v7 = *(v5 + 26);
        v41 = *(v5 + 24);
        v42 = v7;
        v33 = *v5;
        v34 = *(v5 + 2);
        std::list<int>::list(v35, (v5 + 2));
        v8 = *(v5 + 12);
        v36 = *(v5 + 10);
        v37 = v8;
        v9 = v38;
        v10 = v33;
        std::__list_imp<char *>::clear(v35);
        result = std::__list_imp<char *>::clear(v40);
        if (v9 < v10)
        {
          v28 = *v6;
          v29 = *(v5 + 16);
          std::list<int>::list(v30, (v5 + 9));
          v11 = *(v5 + 26);
          v31 = *(v5 + 24);
          v32 = v11;
          v12 = v4;
          do
          {
            v13 = v2 + v12;
            *(v13 + 7) = *(v2 + v12);
            *(v13 + 16) = *(v2 + v12 + 8);
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v2 + v12 + 72), *(v2 + v12 + 24), v2 + v12 + 16);
            *(v13 + 24) = *(v13 + 10);
            *(v13 + 26) = *(v13 + 12);
            v23 = v28;
            v24 = v29;
            std::list<int>::list(v25, v30);
            v26 = v31;
            v27 = v32;
            v19 = *(v2 + v12 - 56);
            std::list<int>::list(v20, v2 + v12 - 40);
            v14 = *(v2 + v12 - 8);
            v21 = *(v2 + v12 - 16);
            v22 = v14;
            v15 = v23;
            std::__list_imp<char *>::clear(v20);
            std::__list_imp<char *>::clear(v25);
            v12 -= 56;
          }

          while (v15 < v19);
          v16 = v2 + v12;
          *(v16 + 7) = v28;
          *(v16 + 16) = v29;
          if (v16 + 56 != &v28)
          {
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v16 + 9, v30[1], v30);
          }

          v17 = v32;
          *(v16 + 24) = v31;
          *(v16 + 26) = v17;
          result = std::__list_imp<char *>::clear(v30);
        }

        v3 = v6 + 7;
        v4 += 56;
        v5 = v6;
      }

      while (v6 + 7 != a2);
    }
  }

  return result;
}

unint64_t std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0> *,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &>(uint64_t *a1, uint64_t *a2)
{
  v3 = a1;
  v83 = *a1;
  v84 = *(a1 + 2);
  std::list<int>::list(v85, (a1 + 2));
  v4 = *(v3 + 12);
  v86 = *(v3 + 10);
  v87 = v4;
  v78 = v83;
  v79 = v84;
  std::list<int>::list(v80, v85);
  v81 = v86;
  v82 = v87;
  v73 = *(a2 - 7);
  v74 = *(a2 - 12);
  std::list<int>::list(v75, (a2 - 5));
  v5 = *(a2 - 2);
  v76 = *(a2 - 4);
  v77 = v5;
  v6 = v78;
  std::__list_imp<char *>::clear(v75);
  std::__list_imp<char *>::clear(v80);
  v23 = v3;
  if (v6 >= v73)
  {
    v10 = (v3 + 7);
    do
    {
      v7 = v10;
      if (v10 >= a2)
      {
        break;
      }

      v58 = v83;
      v59 = v84;
      std::list<int>::list(v60, v85);
      v61 = v86;
      v62 = v87;
      v53 = *v7;
      v54 = *(v7 + 8);
      std::list<int>::list(v55, v7 + 16);
      v11 = *(v7 + 48);
      v56 = *(v7 + 40);
      v57 = v11;
      v12 = v58;
      std::__list_imp<char *>::clear(v55);
      std::__list_imp<char *>::clear(v60);
      v10 = v7 + 56;
    }

    while (v12 >= v53);
  }

  else
  {
    do
    {
      v68 = v83;
      v69 = v84;
      std::list<int>::list(v70, v85);
      v71 = v86;
      v72 = v87;
      v63 = v3[7];
      v64 = *(v3 + 16);
      std::list<int>::list(v65, (v3 + 9));
      v7 = (v3 + 7);
      v8 = *(v3 + 26);
      v66 = *(v3 + 24);
      v67 = v8;
      v9 = v68;
      std::__list_imp<char *>::clear(v65);
      std::__list_imp<char *>::clear(v70);
      v3 += 7;
    }

    while (v9 >= v63);
  }

  if (v7 >= a2)
  {
    v13 = a2;
  }

  else
  {
    do
    {
      v48 = v83;
      v49 = v84;
      std::list<int>::list(v50, v85);
      v51 = v86;
      v52 = v87;
      v43 = *(a2 - 7);
      v44 = *(a2 - 12);
      std::list<int>::list(v45, (a2 - 5));
      v13 = a2 - 7;
      v14 = *(a2 - 2);
      v46 = *(a2 - 4);
      v47 = v14;
      v15 = v48;
      std::__list_imp<char *>::clear(v45);
      std::__list_imp<char *>::clear(v50);
      a2 -= 7;
    }

    while (v15 < v43);
  }

  while (v7 < v13)
  {
    std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(v7, v13);
    v16 = v7;
    do
    {
      v38 = v83;
      v39 = v84;
      std::list<int>::list(v40, v85);
      v41 = v86;
      v42 = v87;
      v33 = *(v16 + 56);
      v34 = *(v16 + 64);
      std::list<int>::list(v35, v16 + 72);
      v7 = v16 + 56;
      v17 = *(v16 + 104);
      v36 = *(v16 + 96);
      v37 = v17;
      v18 = v38;
      v19 = v33;
      std::__list_imp<char *>::clear(v35);
      std::__list_imp<char *>::clear(v40);
      v16 += 56;
    }

    while (v18 >= v19);
    v20 = v13;
    do
    {
      v28 = v83;
      v29 = v84;
      std::list<int>::list(v30, v85);
      v31 = v86;
      v32 = v87;
      v24 = *(v20 - 7);
      std::list<int>::list(v25, (v20 - 5));
      v13 = v20 - 7;
      v26 = *(v20 - 4);
      v27 = *(v20 - 2);
      v21 = v28;
      std::__list_imp<char *>::clear(v25);
      std::__list_imp<char *>::clear(v30);
      v20 -= 7;
    }

    while (v21 < v24);
  }

  if ((v7 - 56) != v23)
  {
    *v23 = *(v7 - 56);
    *(v23 + 2) = *(v7 - 48);
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v23 + 2, *(v7 - 32), v7 - 40);
    *(v23 + 10) = *(v7 - 16);
    *(v23 + 12) = *(v7 - 8);
  }

  *(v7 - 56) = v83;
  *(v7 - 48) = v84;
  if ((v7 - 56) != &v83)
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v7 - 40), v85[1], v85);
  }

  *(v7 - 16) = v86;
  *(v7 - 8) = v87;
  std::__list_imp<char *>::clear(v85);
  return v7;
}

void sub_1B5A685E0(_Unwind_Exception *a1)
{
  std::__list_imp<char *>::clear((v1 + 16));
  std::__list_imp<char *>::clear((v2 + 16));
  _Unwind_Resume(a1);
}

unint64_t std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0> *,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &>(uint64_t *a1, unint64_t a2)
{
  v76 = *a1;
  v77 = *(a1 + 2);
  std::list<int>::list(v78, (a1 + 2));
  v4 = 0;
  v26 = a1;
  v5 = *(a1 + 12);
  v79 = *(a1 + 10);
  v80 = v5;
  do
  {
    v71 = a1[v4 + 7];
    v72 = a1[v4 + 8];
    std::list<int>::list(v73, &a1[v4 + 9]);
    v6 = a1[v4 + 13];
    v74 = a1[v4 + 12];
    v75 = v6;
    v66 = v76;
    v67 = v77;
    std::list<int>::list(v68, v78);
    v69 = v79;
    v70 = v80;
    v7 = v71;
    std::__list_imp<char *>::clear(v68);
    std::__list_imp<char *>::clear(v73);
    v4 += 7;
  }

  while (v7 < v66);
  v8 = &a1[v4];
  if (v4 == 7)
  {
    while (v8 < a2)
    {
      v9 = a2 - 56;
      v61 = *(a2 - 56);
      v62 = *(a2 - 48);
      std::list<int>::list(v63, a2 - 40);
      v13 = *(a2 - 8);
      v64 = *(a2 - 16);
      v65 = v13;
      v56 = v76;
      v57 = v77;
      std::list<int>::list(v58, v78);
      v59 = v79;
      v60 = v80;
      v14 = v61;
      std::__list_imp<char *>::clear(v58);
      std::__list_imp<char *>::clear(v63);
      a2 -= 56;
      if (v14 < v56)
      {
        goto LABEL_11;
      }
    }

    v9 = a2;
  }

  else
  {
    v9 = a2;
    do
    {
      v10 = *(v9 - 56);
      v9 -= 56;
      v51 = v10;
      v52 = *(v9 + 8);
      std::list<int>::list(v53, v9 + 16);
      v11 = *(a2 - 8);
      v54 = *(a2 - 16);
      v55 = v11;
      v46 = v76;
      v47 = v77;
      std::list<int>::list(v48, v78);
      v49 = v79;
      v50 = v80;
      v12 = v51;
      std::__list_imp<char *>::clear(v48);
      std::__list_imp<char *>::clear(v53);
      a2 = v9;
    }

    while (v12 >= v46);
  }

LABEL_11:
  if (v8 >= v9)
  {
    v15 = &v26[v4];
  }

  else
  {
    v15 = &v26[v4];
    v16 = v9;
    do
    {
      std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(v15, v16);
      v17 = v15;
      do
      {
        v18 = *(v15 + 56);
        v15 += 56;
        v41 = v18;
        v42 = *(v15 + 8);
        std::list<int>::list(v43, v15 + 16);
        v19 = *(v17 + 104);
        v44 = *(v17 + 96);
        v45 = v19;
        v36 = v76;
        v37 = v77;
        std::list<int>::list(v38, v78);
        v39 = v79;
        v40 = v80;
        v20 = v41;
        v21 = v36;
        std::__list_imp<char *>::clear(v38);
        std::__list_imp<char *>::clear(v43);
        v17 = v15;
      }

      while (v20 < v21);
      v22 = v16;
      do
      {
        v23 = *(v16 - 56);
        v16 -= 56;
        v31 = v23;
        v32 = *(v16 + 8);
        std::list<int>::list(v33, v16 + 16);
        v34 = *(v22 - 16);
        v35 = *(v22 - 8);
        v27 = v76;
        std::list<int>::list(v28, v78);
        v29 = v79;
        v30 = v80;
        v24 = v31;
        std::__list_imp<char *>::clear(v28);
        std::__list_imp<char *>::clear(v33);
        v22 = v16;
      }

      while (v24 >= v27);
    }

    while (v15 < v16);
  }

  if ((v15 - 56) != v26)
  {
    *v26 = *(v15 - 56);
    *(v26 + 2) = *(v15 - 48);
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v26 + 2, *(v15 - 32), v15 - 40);
    *(v26 + 10) = *(v15 - 16);
    *(v26 + 12) = *(v15 - 8);
  }

  *(v15 - 56) = v76;
  *(v15 - 48) = v77;
  if ((v15 - 56) != &v76)
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v15 - 40), v78[1], v78);
  }

  *(v15 - 16) = v79;
  *(v15 - 8) = v80;
  std::__list_imp<char *>::clear(v78);
  return v15 - 56;
}

uint64_t std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(uint64_t a1, uint64_t a2)
{
  v3 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 3);
  if (v3 > 2)
  {
    switch(v3)
    {
      case 3:
        std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, a1 + 56, a2 - 56);
        return 1;
      case 4:
        std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, a1 + 56, a1 + 112, a2 - 56);
        return 1;
      case 5:
        std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, a1 + 56, a1 + 112, a1 + 168, a2 - 56);
        return 1;
    }
  }

  else
  {
    if (v3 < 2)
    {
      return 1;
    }

    if (v3 == 2)
    {
      v4 = (a2 - 56);
      v55 = *(a2 - 56);
      v56 = *(a2 - 48);
      std::list<int>::list(v57, a2 - 40);
      v5 = *(a2 - 8);
      v58 = *(a2 - 16);
      v59 = v5;
      v50 = *a1;
      v51 = *(a1 + 8);
      std::list<int>::list(v52, a1 + 16);
      v6 = *(a1 + 48);
      v53 = *(a1 + 40);
      v54 = v6;
      v7 = v55;
      std::__list_imp<char *>::clear(v52);
      std::__list_imp<char *>::clear(v57);
      if (v7 < v50)
      {
        std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1, v4);
      }

      return 1;
    }
  }

  v8 = a1 + 112;
  std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, a1 + 56, a1 + 112);
  v9 = a1 + 168;
  if (a1 + 168 != a2)
  {
    v10 = 0;
    v24 = 0;
    do
    {
      v45 = *v9;
      v46 = *(v9 + 8);
      std::list<int>::list(v47, v9 + 16);
      v11 = *(v9 + 48);
      v48 = *(v9 + 40);
      v49 = v11;
      v40 = *v8;
      v41 = *(v8 + 8);
      std::list<int>::list(v42, v8 + 16);
      v12 = *(v8 + 48);
      v43 = *(v8 + 40);
      v44 = v12;
      v13 = v45;
      v14 = v40;
      std::__list_imp<char *>::clear(v42);
      std::__list_imp<char *>::clear(v47);
      if (v13 < v14)
      {
        v35 = *v9;
        v36 = *(v9 + 8);
        std::list<int>::list(v37, v9 + 16);
        v15 = *(v9 + 48);
        v38 = *(v9 + 40);
        v39 = v15;
        v16 = v10;
        while (1)
        {
          v17 = a1 + v16;
          *(v17 + 168) = *(a1 + v16 + 112);
          *(v17 + 176) = *(a1 + v16 + 120);
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a1 + v16 + 184), *(a1 + v16 + 136), a1 + 128 + v16);
          *(v17 + 208) = *(v17 + 152);
          *(v17 + 216) = *(v17 + 160);
          if (v16 == -112)
          {
            break;
          }

          v30 = v35;
          v31 = v36;
          std::list<int>::list(v32, v37);
          v33 = v38;
          v34 = v39;
          v26 = *(a1 + v16 + 56);
          std::list<int>::list(v27, a1 + v16 + 72);
          v18 = *(a1 + v16 + 104);
          v28 = *(a1 + v16 + 96);
          v29 = v18;
          v19 = v30;
          std::__list_imp<char *>::clear(v27);
          std::__list_imp<char *>::clear(v32);
          v16 -= 56;
          if (v19 >= v26)
          {
            v20 = a1 + v16 + 168;
            goto LABEL_20;
          }
        }

        v20 = a1;
LABEL_20:
        *v20 = v35;
        *(v20 + 8) = v36;
        if (v20 != &v35)
        {
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v20 + 16), v37[1], v37);
        }

        v21 = v39;
        *(v20 + 40) = v38;
        *(v20 + 48) = v21;
        if (v24 == 7)
        {
          v22 = v9 + 56 == a2;
          std::__list_imp<char *>::clear(v37);
          return v22;
        }

        ++v24;
        std::__list_imp<char *>::clear(v37);
      }

      v8 = v9;
      v10 += 56;
      v9 += 56;
    }

    while (v9 != a2);
  }

  return 1;
}

void *std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(uint64_t *a1, uint64_t *a2)
{
  v7 = *a1;
  v8 = *(a1 + 2);
  std::list<int>::list(v9, (a1 + 2));
  v4 = *(a1 + 12);
  v10 = *(a1 + 10);
  v11 = v4;
  *a1 = *a2;
  *(a1 + 2) = *(a2 + 2);
  if (a1 != a2)
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(a1 + 2, a2[3], (a2 + 2));
  }

  *(a1 + 10) = *(a2 + 10);
  *(a1 + 12) = *(a2 + 12);
  *a2 = v7;
  *(a2 + 2) = v8;
  if (&v7 != a2)
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(a2 + 2, v9[1], v9);
  }

  v5 = v11;
  *(a2 + 10) = v10;
  *(a2 + 12) = v5;
  return std::__list_imp<char *>::clear(v9);
}

uint64_t std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 != a2)
  {
    v6 = a2;
    v8 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 3);
    v19 = a2 - a1;
    if (a2 - a1 >= 57)
    {
      v9 = (v8 - 2) >> 1;
      v10 = v9 + 1;
      v11 = &a1[7 * v9];
      do
      {
        std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(a1, a4, v8, v11);
        v11 -= 7;
        --v10;
      }

      while (v10);
    }

    v12 = v6;
    if (v6 != a3)
    {
      v12 = v6;
      do
      {
        v24 = *v12;
        v25 = *(v12 + 8);
        std::list<int>::list(v26, v12 + 16);
        v13 = *(v12 + 48);
        v27 = *(v12 + 40);
        v28 = v13;
        v20 = *a1;
        std::list<int>::list(v21, (a1 + 2));
        v14 = *(a1 + 12);
        v22 = *(a1 + 10);
        v23 = v14;
        v15 = v24;
        std::__list_imp<char *>::clear(v21);
        std::__list_imp<char *>::clear(v26);
        if (v15 < v20)
        {
          std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(v12, a1);
          std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(a1, a4, v8, a1);
        }

        v12 += 56;
      }

      while (v12 != a3);
    }

    if (v19 >= 57)
    {
      v16 = 0x6DB6DB6DB6DB6DB7 * (v19 >> 3);
      do
      {
        std::__pop_heap[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(a1, v6, a4, v16);
        v6 -= 56;
      }

      while (v16-- > 2);
    }

    return v12;
  }

  return a3;
}

void *std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(void *result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v4 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = a4;
    v6 = result;
    v28 = v4 >> 1;
    if ((v4 >> 1) >= 0x6DB6DB6DB6DB6DB7 * (a4 - result))
    {
      v8 = (0xDB6DB6DB6DB6DB6ELL * (a4 - result)) | 1;
      v9 = &result[7 * v8];
      v10 = 0xDB6DB6DB6DB6DB6ELL * (a4 - result) + 2;
      if (v10 < a3)
      {
        v68 = *v9;
        v69 = *(v9 + 2);
        std::list<int>::list(v70, (v9 + 2));
        v11 = *(v9 + 12);
        v71 = *(v9 + 10);
        v72 = v11;
        v63 = v9[7];
        v64 = *(v9 + 16);
        std::list<int>::list(v65, (v9 + 9));
        v12 = *(v9 + 26);
        v66 = *(v9 + 24);
        v67 = v12;
        v13 = v68;
        std::__list_imp<char *>::clear(v65);
        std::__list_imp<char *>::clear(v70);
        v14 = 56;
        if (v13 >= v63)
        {
          v14 = 0;
        }

        v9 = (v9 + v14);
        if (v13 < v63)
        {
          v8 = v10;
        }
      }

      v58 = *v9;
      v59 = *(v9 + 2);
      std::list<int>::list(v60, (v9 + 2));
      v15 = *(v9 + 12);
      v61 = *(v9 + 10);
      v62 = v15;
      v53 = *v5;
      v54 = *(v5 + 2);
      std::list<int>::list(v55, (v5 + 2));
      v16 = *(v5 + 12);
      v56 = *(v5 + 10);
      v57 = v16;
      v17 = v58;
      std::__list_imp<char *>::clear(v55);
      result = std::__list_imp<char *>::clear(v60);
      if (v17 >= v53)
      {
        v48 = *v5;
        v49 = *(v5 + 2);
        std::list<int>::list(v50, (v5 + 2));
        v18 = *(v5 + 12);
        v51 = *(v5 + 10);
        v52 = v18;
        do
        {
          v19 = v9;
          *v5 = *v9;
          *(v5 + 2) = *(v9 + 2);
          if (v5 != v9)
          {
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v5 + 2, v9[3], (v9 + 2));
          }

          *(v5 + 10) = *(v9 + 10);
          *(v5 + 12) = *(v9 + 12);
          if (v28 < v8)
          {
            break;
          }

          v20 = (2 * v8) | 1;
          v9 = &v6[7 * v20];
          v8 = 2 * v8 + 2;
          if (v8 >= a3)
          {
            v8 = v20;
          }

          else
          {
            v43 = *v9;
            v44 = *(v9 + 2);
            std::list<int>::list(v45, (v9 + 2));
            v21 = *(v9 + 12);
            v46 = *(v9 + 10);
            v47 = v21;
            v38 = v9[7];
            v39 = *(v9 + 16);
            std::list<int>::list(v40, (v9 + 9));
            v22 = *(v9 + 26);
            v41 = *(v9 + 24);
            v42 = v22;
            v23 = v43;
            v24 = v38;
            std::__list_imp<char *>::clear(v40);
            std::__list_imp<char *>::clear(v45);
            v25 = 56;
            if (v23 >= v24)
            {
              v25 = 0;
            }

            v9 = (v9 + v25);
            if (v23 >= v24)
            {
              v8 = v20;
            }
          }

          v33 = *v9;
          v34 = *(v9 + 2);
          std::list<int>::list(v35, (v9 + 2));
          v26 = *(v9 + 12);
          v36 = *(v9 + 10);
          v37 = v26;
          v29 = v48;
          std::list<int>::list(v30, v50);
          v31 = v51;
          v32 = v52;
          v27 = v33;
          std::__list_imp<char *>::clear(v30);
          std::__list_imp<char *>::clear(v35);
          v5 = v19;
        }

        while (v27 >= v29);
        *v19 = v48;
        *(v19 + 2) = v49;
        if (v19 != &v48)
        {
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v19 + 2, v50[1], v50);
        }

        *(v19 + 10) = v51;
        *(v19 + 12) = v52;
        return std::__list_imp<char *>::clear(v50);
      }
    }
  }

  return result;
}

void *std::__pop_heap[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    v7 = result;
    v12 = *result;
    v13 = *(result + 2);
    std::list<int>::list(&v14, (result + 2));
    v8 = *(v7 + 48);
    v16 = *(v7 + 40);
    v17 = v8;
    v9 = std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v7, a3, a4);
    v10 = v9;
    if (v9 == a2 - 56)
    {
      *v9 = v12;
      *(v9 + 8) = v13;
      if (v9 != &v12)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v9 + 16), v15, &v14);
      }

      *(v10 + 40) = v16;
      *(v10 + 48) = v17;
    }

    else
    {
      *v9 = *(a2 - 56);
      *(v9 + 8) = *(a2 - 48);
      std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v9 + 16), *(a2 - 32), a2 - 40);
      *(v10 + 40) = *(a2 - 16);
      *(v10 + 48) = *(a2 - 8);
      *(a2 - 56) = v12;
      *(a2 - 48) = v13;
      if ((a2 - 56) != &v12)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a2 - 40), v15, &v14);
      }

      v11 = v17;
      *(a2 - 16) = v16;
      *(a2 - 8) = v11;
      std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v7, v10 + 56, a3, 0x6DB6DB6DB6DB6DB7 * ((v10 + 56 - v7) >> 3));
    }

    return std::__list_imp<char *>::clear(&v14);
  }

  return result;
}

uint64_t std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v6 = (a3 - 2) / 2;
  do
  {
    v7 = a1 + 56 * v5;
    v8 = v7 + 56;
    v9 = (2 * v5) | 1;
    v5 = 2 * v5 + 2;
    if (v5 >= a3)
    {
      v5 = v9;
    }

    else
    {
      v17 = *(v7 + 56);
      v18 = *(v7 + 64);
      std::list<int>::list(v19, v7 + 72);
      v20 = *(v7 + 96);
      v21 = *(v7 + 104);
      v10 = v7 + 112;
      v13 = *(v7 + 112);
      std::list<int>::list(v14, v7 + 128);
      v15 = *(v7 + 152);
      v16 = *(v7 + 160);
      v11 = v17;
      std::__list_imp<char *>::clear(v14);
      std::__list_imp<char *>::clear(v19);
      if (v11 >= v13)
      {
        v5 = v9;
      }

      else
      {
        v8 = v10;
      }
    }

    *a1 = *v8;
    *(a1 + 8) = *(v8 + 8);
    if (a1 != v8)
    {
      std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a1 + 16), *(v8 + 24), v8 + 16);
    }

    *(a1 + 40) = *(v8 + 40);
    *(a1 + 48) = *(v8 + 48);
    a1 = v8;
  }

  while (v5 <= v6);
  return v8;
}

void sub_1B5A698E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::__list_imp<char *>::clear(va);
  _Unwind_Resume(a1);
}

void *std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = &result[7 * (v4 >> 1)];
    v37 = *v8;
    v38 = *(v8 + 2);
    std::list<int>::list(v39, (v8 + 2));
    v9 = *(v8 + 12);
    v40 = *(v8 + 10);
    v41 = v9;
    v10 = (a2 - 56);
    v32 = *(a2 - 56);
    v33 = *(a2 - 48);
    std::list<int>::list(v34, a2 - 40);
    v11 = *(a2 - 8);
    v35 = *(a2 - 16);
    v36 = v11;
    v12 = v37;
    std::__list_imp<char *>::clear(v34);
    result = std::__list_imp<char *>::clear(v39);
    if (v12 < v32)
    {
      v27 = *(a2 - 56);
      v28 = *(a2 - 48);
      std::list<int>::list(v29, a2 - 40);
      v13 = *(a2 - 8);
      v30 = *(a2 - 16);
      v31 = v13;
      do
      {
        v14 = v8;
        *v10 = *v8;
        *(v10 + 2) = *(v8 + 2);
        if (v10 != v8)
        {
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v10 + 2, v8[3], (v8 + 2));
        }

        *(v10 + 10) = *(v8 + 10);
        *(v10 + 12) = *(v8 + 12);
        if (!v7)
        {
          break;
        }

        v7 = (v7 - 1) >> 1;
        v8 = &v6[7 * v7];
        v22 = *v8;
        v23 = *(v8 + 2);
        std::list<int>::list(v24, (v8 + 2));
        v15 = *(v8 + 12);
        v25 = *(v8 + 10);
        v26 = v15;
        v18 = v27;
        std::list<int>::list(v19, v29);
        v20 = v30;
        v21 = v31;
        v16 = v22;
        std::__list_imp<char *>::clear(v19);
        std::__list_imp<char *>::clear(v24);
        v10 = v14;
      }

      while (v16 < v18);
      *v14 = v27;
      *(v14 + 2) = v28;
      if (v14 != &v27)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v14 + 2, v29[1], v29);
      }

      v17 = v31;
      *(v14 + 10) = v30;
      *(v14 + 12) = v17;
      return std::__list_imp<char *>::clear(v29);
    }
  }

  return result;
}

void sub_1B5A69B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__list_imp<char *>::clear(va);
  _Unwind_Resume(a1);
}

uint64_t fst::AcyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::AcyclicMinimizer(uint64_t a1, void *a2)
{
  v4 = (*(*a2 + 64))(a2, 0x40000, 1) == 0;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 72) = 0u;
  *(a1 + 88) = 0u;
  *(a1 + 104) = 0u;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = v4;
  if (!(*(*a2 + 64))(a2, 0x40000, 1))
  {
    FstCheck(0, "Weight::Properties() & kIdempotent", "../libquasar/libkaldi/tools/openfst/src/include/fst/minimize.h", 317);
  }

  fst::AcyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Initialize(a1, a2);
  fst::AcyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Refine(a1, a2);
  return a1;
}

void fst::AcyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Initialize(uint64_t a1, uint64_t a2)
{
  fst::DfsVisit<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::AcyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::HeightVisitor,fst::AnyArcFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a2);
  fst::Partition<int>::Initialize(a1, 0);
  fst::Partition<int>::AllocateClasses(a1, 1);
}

void sub_1B5A69D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void fst::AcyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Refine(void *a1, void *a2)
{
  v2 = a1[5] - a1[4];
  if ((v2 >> 3))
  {
    v5 = 0;
    v6 = (v2 >> 3);
    if (v6 <= 1)
    {
      v7 = 1;
    }

    else
    {
      v7 = v6;
    }

    do
    {
      v17[0] = 0;
      v17[1] = 0;
      v17[2] = a2;
      v17[3] = a1;
      v18 = 7;
      v16 = v17;
      v8 = *(a1[4] + 8 * v5);
      v15 = *v8;
      v19 = &v15;
      *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&v16, &v15) + 32) = v5;
      for (i = *(v8 + 8); i; i = *(i + 8))
      {
        v15 = *i;
        v10 = std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::find<int>(&v16, &v15);
        if (v17 == v10)
        {
          v11 = fst::Partition<int>::AddClass(a1);
        }

        else
        {
          v11 = *(v10 + 32);
        }

        v19 = &v15;
        *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&v16, &v15) + 32) = v11;
      }

      v12 = *(a1[4] + 8 * v5);
      while (v12)
      {
        v15 = *v12;
        v13 = *(a1[10] + 4 * v15);
        v19 = &v15;
        v14 = *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&v16, &v15) + 32);
        v12 = *(v12 + 8);
        if (v13 != v14)
        {
          fst::Partition<int>::Move(a1, v15, v14);
        }
      }

      std::__tree<int>::destroy(&v16, v17[0]);
      ++v5;
    }

    while (v5 != v7);
  }
}

uint64_t fst::DfsVisit<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::AcyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::HeightVisitor,fst::AnyArcFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(uint64_t a1)
{
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    memset(&v6, 0, sizeof(v6));
    v4 = 0u;
    v5 = 0u;
    v3 = 0u;
    fst::MemoryPool<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>::MemoryPool(v2, 64);
  }

  return result;
}

void sub_1B5A6A6B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  v12 = va_arg(va1, void);
  v14 = va_arg(va1, void);
  v15 = va_arg(va1, void);
  v16 = va_arg(va1, void);
  v17 = va_arg(va1, void);
  v18 = va_arg(va1, void);
  v19 = va_arg(va1, void);
  v20 = va_arg(va1, void);
  fst::MemoryPool<fst::DfsState<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>::~MemoryPool(va);
  std::deque<fst::DfsState<fst::ArcTpl<fst::LatticeWeightTpl<float>,int>> *,std::allocator<fst::DfsState<fst::ArcTpl<fst::LatticeWeightTpl<float>,int>> *>>::~deque[abi:ne200100](va1);
  v11 = *(v9 - 112);
  if (v11)
  {
    *(v9 - 104) = v11;
    operator delete(v11);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(uint64_t a1, unsigned int *a2)
{
  v2 = *std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::__find_equal<int>(a1, &v4, a2);
  if (!v2)
  {
    operator new();
  }

  return v2;
}

uint64_t *std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::__find_equal<int>(uint64_t a1, void *a2, unsigned int *a3)
{
  v5 = (a1 + 8);
  v4 = *(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v8 = v4;
        if (!fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()((a1 + 24), *a3, *(v4 + 7)))
        {
          break;
        }

        v4 = *v8;
        v5 = v8;
        if (!*v8)
        {
          goto LABEL_9;
        }
      }

      if (!fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()((a1 + 24), *(v8 + 7), *a3))
      {
        break;
      }

      v5 = v8 + 1;
      v4 = v8[1];
    }

    while (v4);
  }

  else
  {
    v8 = (a1 + 8);
  }

LABEL_9:
  *a2 = v8;
  return v5;
}

uint64_t fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()(void *a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a1 + 4);
  if (v6)
  {
    (*(**a1 + 32))(&v30);
    v16 = 0;
    v17 = v32;
    if (v30)
    {
      v18 = v30;
      while (1)
      {
        v16 ^= v18;
        if (v17 == &v31)
        {
          break;
        }

        v18 = *(v17 + 16) ^ (2 * v16);
        v17 = *(v17 + 8);
      }
    }

    v19 = v34 ^ __ROR8__(v16, 59);
    std::__list_imp<char *>::clear(&v31);
    (*(**a1 + 32))(&v30);
    v20 = 0;
    v21 = v32;
    if (v30)
    {
      v22 = v30;
      while (1)
      {
        v20 ^= v22;
        if (v21 == &v31)
        {
          break;
        }

        v22 = *(v21 + 16) ^ (2 * v20);
        v21 = *(v21 + 8);
      }
    }

    v23 = v34 ^ __ROR8__(v20, 59);
    std::__list_imp<char *>::clear(&v31);
    if (v19 < v23)
    {
      return 1;
    }

    if (v19 <= v23 && (a1[2] & 2) != 0)
    {
      goto LABEL_3;
    }

    return 0;
  }

  if ((v6 & 2) == 0)
  {
    return 0;
  }

LABEL_3:
  v7 = (*(**a1 + 40))(*a1, a2);
  if (v7 < (*(**a1 + 40))(*a1, a3))
  {
    return 1;
  }

  v8 = (*(**a1 + 40))(*a1, a2);
  if (v8 > (*(**a1 + 40))(*a1, a3) || (a1[2] & 4) == 0)
  {
    return 0;
  }

  v9 = *a1;
  v34 = 0;
  (*(*v9 + 136))(v9, a2, &v30);
  v10 = *a1;
  v29 = 0;
  (*(*v10 + 136))(v10, a3, v27);
  while (1)
  {
    if (v30)
    {
      if ((*(*v30 + 24))(v30))
      {
        goto LABEL_46;
      }
    }

    else if (v34 >= v32)
    {
      goto LABEL_46;
    }

    if (v27[0])
    {
      if ((*(*v27[0] + 24))(v27[0]))
      {
        goto LABEL_46;
      }
    }

    else if (v29 >= v27[2])
    {
LABEL_46:
      v24 = 0;
      v25 = 1;
      goto LABEL_49;
    }

    if (v30)
    {
      v11 = (*(*v30 + 32))(v30);
    }

    else
    {
      v11 = (v31 + 56 * v34);
    }

    if (v27[0])
    {
      v12 = (*(*v27[0] + 32))(v27[0]);
    }

    else
    {
      v12 = (v27[1] + 56 * v29);
    }

    if (*v11 < *v12)
    {
      goto LABEL_47;
    }

    if (*v11 > *v12)
    {
      break;
    }

    v13 = *(a1[1] + 80);
    v14 = *(v13 + 4 * v11[12]);
    v15 = *(v13 + 4 * v12[12]);
    if (v14 < v15)
    {
LABEL_47:
      v25 = 0;
      v24 = 1;
      goto LABEL_49;
    }

    if (v14 > v15)
    {
      break;
    }

    if (v30)
    {
      (*(*v30 + 40))(v30);
    }

    else
    {
      ++v34;
    }

    if (v27[0])
    {
      (*(*v27[0] + 40))(v27[0]);
    }

    else
    {
      ++v29;
    }
  }

  v25 = 0;
  v24 = 0;
LABEL_49:
  if (v27[0])
  {
    (*(*v27[0] + 8))(v27[0]);
  }

  else if (v28)
  {
    --*v28;
  }

  if (v30)
  {
    (*(*v30 + 8))(v30);
  }

  else if (v33)
  {
    --*v33;
  }

  if (v25)
  {
    return 0;
  }

  return v24;
}

void sub_1B5A6ADA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, _DWORD *a17)
{
  if (a14)
  {
    (*(*a14 + 8))(a14);
  }

  else if (a17)
  {
    --*a17;
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::find<int>(uint64_t a1, unsigned int *a2)
{
  v2 = a1 + 8;
  v3 = *(a1 + 8);
  if (!v3)
  {
    return v2;
  }

  v6 = a1 + 8;
  do
  {
    v7 = fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()((a1 + 24), *(v3 + 28), *a2);
    if (v7)
    {
      v8 = 8;
    }

    else
    {
      v8 = 0;
    }

    if (!v7)
    {
      v6 = v3;
    }

    v3 = *(v3 + v8);
  }

  while (v3);
  if (v6 == v2 || fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::operator()((a1 + 24), *a2, *(v6 + 28)))
  {
    return v2;
  }

  return v6;
}

void fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::CyclicMinimizer(uint64_t a1, uint64_t a2)
{
  v3 = (*(*a2 + 64))(a2, 0x40000, 1);
  *(a1 + 200) = 0u;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 72) = 0u;
  *(a1 + 88) = 0u;
  *(a1 + 104) = 0u;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = v3 == 0;
  *(a1 + 192) = 2;
  *(a1 + 196) = 0;
  *(a1 + 216) = 0u;
  *(a1 + 232) = 0u;
  *(a1 + 184) = &unk_1F2CFB7B0;
  fst::VectorFst<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::VectorState<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,std::allocator<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>>::VectorFst();
}

void sub_1B5A6B004(_Unwind_Exception *a1)
{
  std::deque<int>::~deque[abi:ne200100](v2);
  fst::Partition<int>::~Partition(v1);
  _Unwind_Resume(a1);
}

void fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::Initialize(uint64_t a1, uint64_t a2)
{
  fst::Reverse<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a2, (a1 + 248), 1);
  fst::ArcSort<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>(a1 + 248);
  fst::Partition<int>::Initialize(a1, (((*(*(a1 + 256) + 72) - *(*(a1 + 256) + 64)) << 29) - 0x100000000) >> 32);
  fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::PrePartition(a1, a2);
  operator new();
}

uint64_t fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::Compute(uint64_t result)
{
  v1 = *(result + 240);
  if (v1)
  {
    v2 = result;
    do
    {
      v3 = *(*(v2[26] + ((v2[29] >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v2[29] & 0x3FFLL));
      ++v2[29];
      v2[30] = v1 - 1;
      std::deque<int>::__maybe_remove_front_spare[abi:ne200100]((v2 + 25), 1);
      result = fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::Split(v2, v3);
      v1 = v2[30];
    }

    while (v1);
  }

  return result;
}

void fst::ArcSort<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>(uint64_t a1)
{
  v3 = a1;
  v4 = &v6;
  memset(v5, 0, sizeof(v5));
  v1[0] = a1;
  v1[1] = &v6;
  memset(v2, 0, sizeof(v2));
  fst::StateMap<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::ArcSortMapper<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>>(a1, v1);
  v7 = v2;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::__destroy_vector::operator()[abi:ne200100](&v7);
  v7 = v5;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::__destroy_vector::operator()[abi:ne200100](&v7);
}

void sub_1B5A6B1A4(_Unwind_Exception *a1)
{
  v4 = v1;
  *(v3 - 40) = v2;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::__destroy_vector::operator()[abi:ne200100]((v3 - 40));
  *(v3 - 40) = v4;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::__destroy_vector::operator()[abi:ne200100]((v3 - 40));
  _Unwind_Resume(a1);
}

void fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::PrePartition(uint64_t a1, uint64_t a2)
{
  if (FLAGS_v >= 5)
  {
    std::string::basic_string[abi:ne200100]<0>(&__p, "INFO");
    v4 = fst::LogMessage::LogMessage(&v33, &__p);
    v5 = fst::cerr(v4);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v5, "PrePartition", 12);
    fst::LogMessage::~LogMessage(&v33);
    if (SHIBYTE(v38) < 0)
    {
      operator delete(__p);
    }
  }

  v38 = 0;
  v39 = a2;
  v40 = a1;
  v41 = 1;
  __p = &v37;
  v37 = 0;
  v35 = 0;
  (*(*a2 + 128))(a2, &v33);
  v6 = fst::Partition<int>::AddClass(a1);
  if (v33)
  {
    v7 = (*(*v33 + 24))(v33);
  }

  else
  {
    v7 = v35;
  }

  v8 = *(*(a1 + 8) + 8 * v7);
  v9 = *(a1 + 32);
  v10 = *(v9 + 8 * v6);
  if (v10)
  {
    *(v10 + 16) = v8;
    v10 = *(v9 + 8 * v6);
  }

  *(v8 + 8) = v10;
  *(v8 + 16) = 0;
  *(v9 + 8 * v6) = v8;
  *(*(a1 + 80) + 4 * v7) = v6;
  ++*(*(a1 + 104) + 4 * v6);
  if (v33)
  {
    v11 = (*(*v33 + 24))(v33);
  }

  else
  {
    v11 = v35;
  }

  v32 = v11;
  v30[0] = &v32;
  *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&__p, &v32) + 32) = v6;
  LODWORD(v30[0]) = v6;
  std::deque<int>::push_front((a1 + 200), v30);
  v12 = v33;
  if (v33)
  {
    goto LABEL_28;
  }

  ++v35;
  while (v33)
  {
    if ((*(*v33 + 16))(v33))
    {
      goto LABEL_30;
    }

    if (!v33)
    {
      goto LABEL_19;
    }

    v13 = (*(*v33 + 24))(v33);
LABEL_20:
    v32 = v13;
    v14 = std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::find<int>(&__p, &v32);
    if (&v37 == v14)
    {
      v21 = fst::Partition<int>::AddClass(a1);
      v22 = v21;
      v23 = v32;
      v24 = *(*(a1 + 8) + 8 * v32);
      v25 = *(a1 + 32);
      v26 = *(v25 + 8 * v21);
      if (v26)
      {
        *(v26 + 16) = v24;
        v26 = *(v25 + 8 * v21);
      }

      *(v24 + 8) = v26;
      *(v24 + 16) = 0;
      *(v25 + 8 * v21) = v24;
      *(*(a1 + 80) + 4 * v23) = v21;
      ++*(*(a1 + 104) + 4 * v21);
      v30[0] = &v32;
      *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&__p, &v32) + 32) = v21;
      LODWORD(v30[0]) = v22;
      std::deque<int>::push_front((a1 + 200), v30);
    }

    else
    {
      v15 = v32;
      v16 = *(v14 + 32);
      v17 = *(*(a1 + 8) + 8 * v32);
      v18 = *(a1 + 32);
      v19 = *(v18 + 8 * v16);
      if (v19)
      {
        *(v19 + 16) = v17;
        v19 = *(v18 + 8 * v16);
      }

      *(v17 + 8) = v19;
      *(v17 + 16) = 0;
      *(v18 + 8 * v16) = v17;
      *(*(a1 + 80) + 4 * v15) = v16;
      ++*(*(a1 + 104) + 4 * v16);
      v20 = *(v14 + 32);
      v30[0] = &v32;
      *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&__p, &v32) + 32) = v20;
    }

    v12 = v33;
    if (v33)
    {
LABEL_28:
      (*(*v33 + 32))(v12);
    }

    else
    {
      ++v35;
    }
  }

  if (v35 < v34)
  {
LABEL_19:
    v13 = v35;
    goto LABEL_20;
  }

LABEL_30:
  if (FLAGS_v >= 5)
  {
    std::string::basic_string[abi:ne200100]<0>(v30, "INFO");
    v27 = fst::LogMessage::LogMessage(&v32, v30);
    v28 = fst::cerr(v27);
    v29 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v28, "Initial Partition: ", 19);
    MEMORY[0x1B8C84C00](v29, (*(a1 + 40) - *(a1 + 32)) >> 3);
    fst::LogMessage::~LogMessage(&v32);
    if (v31 < 0)
    {
      operator delete(v30[0]);
    }
  }

  if (v33)
  {
    (*(*v33 + 8))(v33);
  }

  std::__tree<int>::destroy(&__p, v37);
}

void sub_1B5A6B634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21, int a22, __int16 a23, char a24, char a25)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (a17)
  {
    (*(*a17 + 8))(a17);
  }

  std::__tree<int>::destroy(&a20, a21);
  _Unwind_Resume(a1);
}

uint64_t fst::StateMap<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::ArcSortMapper<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>>(uint64_t a1, uint64_t *a2)
{
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    v5 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
    v6 = (*(**a2 + 24))();
    (*(*a1 + 176))(a1, v6);
    if ((*(*a1 + 160))(a1) >= 1)
    {
      v7 = 0;
      do
      {
        fst::ArcSortMapper<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>::SetState(a2, v7);
        (*(*a1 + 240))(a1, v7);
        for (i = a2[5]; ; a2[5] = i)
        {
          v9 = a2[2];
          if (i >= 0x6DB6DB6DB6DB6DB7 * ((a2[3] - v9) >> 3))
          {
            break;
          }

          (*(*a1 + 208))(a1, v7, v9 + 56 * i);
          i = a2[5] + 1;
        }

        (*(**a2 + 32))(&v10);
        (*(*a1 + 184))(a1, v7, &v10);
        std::__list_imp<char *>::clear(v11);
        v7 = (v7 + 1);
      }

      while (v7 < (*(*a1 + 160))(a1));
    }

    return (*(*a1 + 192))(a1, v5 & 0x3FFF0FFF0007 | (((v5 >> 16) & 1) << 30) | 0x10000000, 0x3FFFFFFF0007);
  }

  return result;
}

void *fst::ArcSortMapper<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>::SetState(uint64_t *a1, uint64_t a2)
{
  v4 = a1 + 2;
  v5 = a1[2];
  a1[5] = 0;
  v6 = a1[3];
  if (v6 != v5)
  {
    do
    {
      v7 = v6 - 56;
      std::__list_imp<char *>::clear((v6 - 40));
      v6 = v7;
    }

    while (v7 != v5);
  }

  a1[3] = v5;
  v8 = (*(**a1 + 40))(*a1, a2);
  std::vector<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>::reserve(v4, v8);
  v9 = *a1;
  v18 = 0;
  (*(*v9 + 136))(v9, a2, v16);
  while (1)
  {
    if (!v16[0])
    {
      if (v18 >= v16[2])
      {
        goto LABEL_15;
      }

LABEL_9:
      v10 = v16[1] + 56 * v18;
      goto LABEL_10;
    }

    if ((*(*v16[0] + 24))(v16[0]))
    {
      break;
    }

    if (!v16[0])
    {
      goto LABEL_9;
    }

    v10 = (*(*v16[0] + 32))();
LABEL_10:
    std::vector<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>::push_back[abi:ne200100](v4, v10);
    if (v16[0])
    {
      (*(*v16[0] + 40))(v16[0]);
    }

    else
    {
      ++v18;
    }
  }

  if (v16[0])
  {
    (*(*v16[0] + 8))();
    goto LABEL_17;
  }

LABEL_15:
  if (v17)
  {
    --*v17;
  }

LABEL_17:
  v11 = a1[2];
  v12 = a1[3];
  v13 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (v12 - v11));
  if (v12 == v11)
  {
    v14 = 0;
  }

  else
  {
    v14 = v13;
  }

  return std::__introsort<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,false>(v11, v12, v16, v14, 1);
}

void sub_1B5A6BBE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    fst::ArcSortMapper<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>::SetState();
  }

  else
  {
    fst::ComposeFstImpl<fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::SequenceComposeFilter<fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>,fst::GenericComposeStateTable<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::IntegerFilterState<signed char>,fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::CompactHashStateTable<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::ComposeHash<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>>>>>::OrderedExpand<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>(&a10);
  }

  _Unwind_Resume(a1);
}

void *std::__introsort<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,false>(void *result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  v8 = result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (1)
  {
    v8 = v9;
    v11 = v10;
    v12 = a2 - v9;
    v13 = 0x6DB6DB6DB6DB6DB7 * ((a2 - v9) >> 3);
    if (v13 > 2)
    {
      switch(v13)
      {
        case 3uLL:
          return std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(v9, v9 + 56, (a2 - 7));
        case 4uLL:
          return std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(v9, v9 + 56, v9 + 112, (a2 - 7));
        case 5uLL:
          return std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(v9, v9 + 56, v9 + 112, v9 + 168, (a2 - 7));
      }
    }

    else
    {
      if (v13 < 2)
      {
        return result;
      }

      if (v13 == 2)
      {
        v24 = *(a2 - 7);
        v23 = a2 - 7;
        v42 = v24;
        v43 = *(v23 + 2);
        std::list<int>::list(v44, (v23 + 2));
        v45 = *(v23 + 10);
        v46 = *(v23 + 12);
        v37 = *v9;
        v38 = *(v9 + 8);
        std::list<int>::list(v39, v9 + 16);
        v25 = *(v9 + 48);
        v40 = *(v9 + 40);
        v41 = v25;
        v26 = v42;
        v27 = v37;
        std::__list_imp<char *>::clear(v39);
        result = std::__list_imp<char *>::clear(v44);
        if (v26 < v27)
        {
          return std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(v9, v23);
        }

        return result;
      }
    }

    if (v12 <= 1343)
    {
      if (a5)
      {
        return std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(v9, a2);
      }

      else
      {
        return std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(v9, a2);
      }
    }

    if (v11 == 1)
    {
      break;
    }

    v14 = v13 >> 1;
    v15 = (v8 + 56 * (v13 >> 1));
    if (v12 < 0x1C01)
    {
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(v15, v8, (a2 - 7));
      if (a5)
      {
        goto LABEL_19;
      }
    }

    else
    {
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(v8, v15, (a2 - 7));
      v16 = 56 * v14;
      v17 = 56 * v14 + v8 - 56;
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(v8 + 56, v17, (a2 - 14));
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(v8 + 112, v8 + 56 + v16, (a2 - 21));
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(v17, v15, v8 + 56 + v16);
      std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(v8, v15);
      if (a5)
      {
        goto LABEL_19;
      }
    }

    v32 = *(v8 - 56);
    v33 = *(v8 - 48);
    std::list<int>::list(v34, v8 - 40);
    v35 = *(v8 - 16);
    v36 = *(v8 - 8);
    v28 = *v8;
    std::list<int>::list(v29, v8 + 16);
    v18 = *(v8 + 48);
    v30 = *(v8 + 40);
    v31 = v18;
    v19 = v32;
    std::__list_imp<char *>::clear(v29);
    std::__list_imp<char *>::clear(v34);
    if (v19 >= v28)
    {
      result = std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> *,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &>(v8, a2);
      v9 = result;
LABEL_23:
      a5 = 0;
      a4 = -v11;
      goto LABEL_3;
    }

LABEL_19:
    v20 = std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> *,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &>(v8, a2);
    if ((v21 & 1) == 0)
    {
      goto LABEL_22;
    }

    v22 = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(v8, v20);
    v9 = v20 + 56;
    result = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(v20 + 56, a2);
    if (result)
    {
      a4 = -v11;
      a2 = v20;
      if (v22)
      {
        return result;
      }

      goto LABEL_2;
    }

    v10 = v11 + 1;
    if ((v22 & 1) == 0)
    {
LABEL_22:
      result = std::__introsort<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,false>(v8, v20, a3, -v11, a5 & 1);
      v9 = v20 + 56;
      goto LABEL_23;
    }
  }

  if (v9 != a2)
  {
    return std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(v9, a2, a2, a3);
  }

  return result;
}

uint64_t std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v68 = *a2;
  v69 = *(a2 + 8);
  std::list<int>::list(v70, a2 + 16);
  v6 = *(a2 + 48);
  v71 = *(a2 + 40);
  v72 = v6;
  v63 = *a1;
  v64 = *(a1 + 8);
  std::list<int>::list(v65, a1 + 16);
  v7 = *(a1 + 48);
  v66 = *(a1 + 40);
  v67 = v7;
  v8 = v68;
  std::__list_imp<char *>::clear(v65);
  std::__list_imp<char *>::clear(v70);
  if (v8 < v63)
  {
    v38 = *a3;
    v39 = *(a3 + 8);
    std::list<int>::list(v40, a3 + 16);
    v9 = *(a3 + 48);
    v41 = *(a3 + 40);
    v42 = v9;
    v33 = *a2;
    v34 = *(a2 + 8);
    std::list<int>::list(v35, a2 + 16);
    v10 = *(a2 + 48);
    v36 = *(a2 + 40);
    v37 = v10;
    v11 = v38;
    std::__list_imp<char *>::clear(v35);
    std::__list_imp<char *>::clear(v40);
    v12 = a1;
    if (v11 < v33)
    {
LABEL_5:
      v16 = a3;
LABEL_9:
      std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(v12, v16);
      return 1;
    }

    std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a1, a2);
    v28 = *a3;
    v29 = *(a3 + 8);
    std::list<int>::list(v30, a3 + 16);
    v13 = *(a3 + 48);
    v31 = *(a3 + 40);
    v32 = v13;
    v24 = *a2;
    std::list<int>::list(v25, a2 + 16);
    v14 = *(a2 + 48);
    v26 = *(a2 + 40);
    v27 = v14;
    v15 = v28;
    std::__list_imp<char *>::clear(v25);
    std::__list_imp<char *>::clear(v30);
    if (v15 < v24)
    {
      v12 = a2;
      goto LABEL_5;
    }

    return 1;
  }

  v58 = *a3;
  v59 = *(a3 + 8);
  std::list<int>::list(v60, a3 + 16);
  v17 = *(a3 + 48);
  v61 = *(a3 + 40);
  v62 = v17;
  v53 = *a2;
  v54 = *(a2 + 8);
  std::list<int>::list(v55, a2 + 16);
  v18 = *(a2 + 48);
  v56 = *(a2 + 40);
  v57 = v18;
  v19 = v58;
  std::__list_imp<char *>::clear(v55);
  std::__list_imp<char *>::clear(v60);
  if (v19 < v53)
  {
    std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a2, a3);
    v48 = *a2;
    v49 = *(a2 + 8);
    std::list<int>::list(v50, a2 + 16);
    v20 = *(a2 + 48);
    v51 = *(a2 + 40);
    v52 = v20;
    v43 = *a1;
    v44 = *(a1 + 8);
    std::list<int>::list(v45, a1 + 16);
    v21 = *(a1 + 48);
    v46 = *(a1 + 40);
    v47 = v21;
    v22 = v48;
    std::__list_imp<char *>::clear(v45);
    std::__list_imp<char *>::clear(v50);
    if (v22 < v43)
    {
      v12 = a1;
      v16 = a2;
      goto LABEL_9;
    }

    return 1;
  }

  return 0;
}

void *std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(a1, a2, a3);
  v42 = *a4;
  v43 = *(a4 + 8);
  std::list<int>::list(v44, a4 + 16);
  v8 = *(a4 + 48);
  v45 = *(a4 + 40);
  v46 = v8;
  v37 = *a3;
  v38 = *(a3 + 8);
  std::list<int>::list(v39, a3 + 16);
  v9 = *(a3 + 48);
  v40 = *(a3 + 40);
  v41 = v9;
  v10 = v42;
  std::__list_imp<char *>::clear(v39);
  result = std::__list_imp<char *>::clear(v44);
  if (v10 < v37)
  {
    std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a3, a4);
    v32 = *a3;
    v33 = *(a3 + 8);
    std::list<int>::list(v34, a3 + 16);
    v12 = *(a3 + 48);
    v35 = *(a3 + 40);
    v36 = v12;
    v27 = *a2;
    v28 = *(a2 + 8);
    std::list<int>::list(v29, a2 + 16);
    v13 = *(a2 + 48);
    v30 = *(a2 + 40);
    v31 = v13;
    v14 = v32;
    std::__list_imp<char *>::clear(v29);
    result = std::__list_imp<char *>::clear(v34);
    if (v14 < v27)
    {
      std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a2, a3);
      v22 = *a2;
      v23 = *(a2 + 8);
      std::list<int>::list(v24, a2 + 16);
      v15 = *(a2 + 48);
      v25 = *(a2 + 40);
      v26 = v15;
      v18 = *a1;
      std::list<int>::list(v19, a1 + 16);
      v16 = *(a1 + 48);
      v20 = *(a1 + 40);
      v21 = v16;
      v17 = v22;
      std::__list_imp<char *>::clear(v19);
      result = std::__list_imp<char *>::clear(v24);
      if (v17 < v18)
      {
        return std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a1, a2);
      }
    }
  }

  return result;
}

void *std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(a1, a2, a3, a4);
  v57 = *a5;
  v58 = *(a5 + 8);
  std::list<int>::list(v59, a5 + 16);
  v10 = *(a5 + 48);
  v60 = *(a5 + 40);
  v61 = v10;
  v52 = *a4;
  v53 = *(a4 + 8);
  std::list<int>::list(v54, a4 + 16);
  v11 = *(a4 + 48);
  v55 = *(a4 + 40);
  v56 = v11;
  v12 = v57;
  std::__list_imp<char *>::clear(v54);
  result = std::__list_imp<char *>::clear(v59);
  if (v12 < v52)
  {
    std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a4, a5);
    v47 = *a4;
    v48 = *(a4 + 8);
    std::list<int>::list(v49, a4 + 16);
    v14 = *(a4 + 48);
    v50 = *(a4 + 40);
    v51 = v14;
    v42 = *a3;
    v43 = *(a3 + 8);
    std::list<int>::list(v44, a3 + 16);
    v15 = *(a3 + 48);
    v45 = *(a3 + 40);
    v46 = v15;
    v16 = v47;
    std::__list_imp<char *>::clear(v44);
    result = std::__list_imp<char *>::clear(v49);
    if (v16 < v42)
    {
      std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a3, a4);
      v37 = *a3;
      v38 = *(a3 + 8);
      std::list<int>::list(v39, a3 + 16);
      v17 = *(a3 + 48);
      v40 = *(a3 + 40);
      v41 = v17;
      v32 = *a2;
      v33 = *(a2 + 8);
      std::list<int>::list(v34, a2 + 16);
      v18 = *(a2 + 48);
      v35 = *(a2 + 40);
      v36 = v18;
      v19 = v37;
      std::__list_imp<char *>::clear(v34);
      result = std::__list_imp<char *>::clear(v39);
      if (v19 < v32)
      {
        std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a2, a3);
        v27 = *a2;
        v28 = *(a2 + 8);
        std::list<int>::list(v29, a2 + 16);
        v20 = *(a2 + 48);
        v30 = *(a2 + 40);
        v31 = v20;
        v23 = *a1;
        std::list<int>::list(v24, a1 + 16);
        v21 = *(a1 + 48);
        v25 = *(a1 + 40);
        v26 = v21;
        v22 = v27;
        std::__list_imp<char *>::clear(v24);
        result = std::__list_imp<char *>::clear(v29);
        if (v22 < v23)
        {
          return std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a1, a2);
        }
      }
    }
  }

  return result;
}

void *std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(void *result, void *a2)
{
  if (result != a2)
  {
    v2 = result;
    v3 = result + 7;
    if (result + 7 != a2)
    {
      v4 = 0;
      v5 = result;
      do
      {
        v6 = v3;
        v38 = v5[7];
        v39 = *(v5 + 16);
        std::list<int>::list(v40, (v5 + 9));
        v7 = *(v5 + 26);
        v41 = *(v5 + 24);
        v42 = v7;
        v33 = *v5;
        v34 = *(v5 + 2);
        std::list<int>::list(v35, (v5 + 2));
        v8 = *(v5 + 12);
        v36 = *(v5 + 10);
        v37 = v8;
        v9 = v38;
        v10 = v33;
        std::__list_imp<char *>::clear(v35);
        result = std::__list_imp<char *>::clear(v40);
        if (v9 < v10)
        {
          v28 = *v6;
          v29 = *(v5 + 16);
          std::list<int>::list(v30, (v5 + 9));
          v11 = *(v5 + 26);
          v31 = *(v5 + 24);
          v32 = v11;
          v12 = v4;
          while (1)
          {
            v13 = v2 + v12;
            *(v13 + 7) = *(v2 + v12);
            *(v13 + 16) = *(v2 + v12 + 8);
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v2 + v12 + 72), *(v2 + v12 + 24), v2 + v12 + 16);
            *(v13 + 24) = *(v13 + 10);
            *(v13 + 26) = *(v13 + 12);
            if (!v12)
            {
              break;
            }

            v23 = v28;
            v24 = v29;
            std::list<int>::list(v25, v30);
            v26 = v31;
            v27 = v32;
            v19 = *(v2 + v12 - 56);
            std::list<int>::list(v20, v2 + v12 - 40);
            v14 = *(v2 + v12 - 8);
            v21 = *(v2 + v12 - 16);
            v22 = v14;
            v15 = v23;
            std::__list_imp<char *>::clear(v20);
            std::__list_imp<char *>::clear(v25);
            v12 -= 56;
            if (v15 >= v19)
            {
              v16 = v2 + v12 + 56;
              goto LABEL_10;
            }
          }

          v16 = v2;
LABEL_10:
          *v16 = v28;
          *(v16 + 8) = v29;
          if (v16 != &v28)
          {
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v16 + 16), v30[1], v30);
          }

          v17 = v32;
          *(v16 + 40) = v31;
          *(v16 + 48) = v17;
          result = std::__list_imp<char *>::clear(v30);
        }

        v3 = v6 + 7;
        v4 += 56;
        v5 = v6;
      }

      while (v6 + 7 != a2);
    }
  }

  return result;
}

void *std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(void *result, void *a2)
{
  if (result != a2)
  {
    v2 = result;
    v3 = result + 7;
    if (result + 7 != a2)
    {
      v4 = 0;
      v5 = result;
      do
      {
        v6 = v3;
        v38 = v5[7];
        v39 = *(v5 + 16);
        std::list<int>::list(v40, (v5 + 9));
        v7 = *(v5 + 26);
        v41 = *(v5 + 24);
        v42 = v7;
        v33 = *v5;
        v34 = *(v5 + 2);
        std::list<int>::list(v35, (v5 + 2));
        v8 = *(v5 + 12);
        v36 = *(v5 + 10);
        v37 = v8;
        v9 = v38;
        v10 = v33;
        std::__list_imp<char *>::clear(v35);
        result = std::__list_imp<char *>::clear(v40);
        if (v9 < v10)
        {
          v28 = *v6;
          v29 = *(v5 + 16);
          std::list<int>::list(v30, (v5 + 9));
          v11 = *(v5 + 26);
          v31 = *(v5 + 24);
          v32 = v11;
          v12 = v4;
          do
          {
            v13 = v2 + v12;
            *(v13 + 7) = *(v2 + v12);
            *(v13 + 16) = *(v2 + v12 + 8);
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v2 + v12 + 72), *(v2 + v12 + 24), v2 + v12 + 16);
            *(v13 + 24) = *(v13 + 10);
            *(v13 + 26) = *(v13 + 12);
            v23 = v28;
            v24 = v29;
            std::list<int>::list(v25, v30);
            v26 = v31;
            v27 = v32;
            v19 = *(v2 + v12 - 56);
            std::list<int>::list(v20, v2 + v12 - 40);
            v14 = *(v2 + v12 - 8);
            v21 = *(v2 + v12 - 16);
            v22 = v14;
            v15 = v23;
            std::__list_imp<char *>::clear(v20);
            std::__list_imp<char *>::clear(v25);
            v12 -= 56;
          }

          while (v15 < v19);
          v16 = v2 + v12;
          *(v16 + 7) = v28;
          *(v16 + 16) = v29;
          if (v16 + 56 != &v28)
          {
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v16 + 9, v30[1], v30);
          }

          v17 = v32;
          *(v16 + 24) = v31;
          *(v16 + 26) = v17;
          result = std::__list_imp<char *>::clear(v30);
        }

        v3 = v6 + 7;
        v4 += 56;
        v5 = v6;
      }

      while (v6 + 7 != a2);
    }
  }

  return result;
}

unint64_t std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> *,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &>(uint64_t *a1, uint64_t *a2)
{
  v3 = a1;
  v83 = *a1;
  v84 = *(a1 + 2);
  std::list<int>::list(v85, (a1 + 2));
  v4 = *(v3 + 12);
  v86 = *(v3 + 10);
  v87 = v4;
  v78 = v83;
  v79 = v84;
  std::list<int>::list(v80, v85);
  v81 = v86;
  v82 = v87;
  v73 = *(a2 - 7);
  v74 = *(a2 - 12);
  std::list<int>::list(v75, (a2 - 5));
  v5 = *(a2 - 2);
  v76 = *(a2 - 4);
  v77 = v5;
  v6 = v78;
  std::__list_imp<char *>::clear(v75);
  std::__list_imp<char *>::clear(v80);
  v23 = v3;
  if (v6 >= v73)
  {
    v10 = (v3 + 7);
    do
    {
      v7 = v10;
      if (v10 >= a2)
      {
        break;
      }

      v58 = v83;
      v59 = v84;
      std::list<int>::list(v60, v85);
      v61 = v86;
      v62 = v87;
      v53 = *v7;
      v54 = *(v7 + 8);
      std::list<int>::list(v55, v7 + 16);
      v11 = *(v7 + 48);
      v56 = *(v7 + 40);
      v57 = v11;
      v12 = v58;
      std::__list_imp<char *>::clear(v55);
      std::__list_imp<char *>::clear(v60);
      v10 = v7 + 56;
    }

    while (v12 >= v53);
  }

  else
  {
    do
    {
      v68 = v83;
      v69 = v84;
      std::list<int>::list(v70, v85);
      v71 = v86;
      v72 = v87;
      v63 = v3[7];
      v64 = *(v3 + 16);
      std::list<int>::list(v65, (v3 + 9));
      v7 = (v3 + 7);
      v8 = *(v3 + 26);
      v66 = *(v3 + 24);
      v67 = v8;
      v9 = v68;
      std::__list_imp<char *>::clear(v65);
      std::__list_imp<char *>::clear(v70);
      v3 += 7;
    }

    while (v9 >= v63);
  }

  if (v7 >= a2)
  {
    v13 = a2;
  }

  else
  {
    do
    {
      v48 = v83;
      v49 = v84;
      std::list<int>::list(v50, v85);
      v51 = v86;
      v52 = v87;
      v43 = *(a2 - 7);
      v44 = *(a2 - 12);
      std::list<int>::list(v45, (a2 - 5));
      v13 = a2 - 7;
      v14 = *(a2 - 2);
      v46 = *(a2 - 4);
      v47 = v14;
      v15 = v48;
      std::__list_imp<char *>::clear(v45);
      std::__list_imp<char *>::clear(v50);
      a2 -= 7;
    }

    while (v15 < v43);
  }

  while (v7 < v13)
  {
    std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(v7, v13);
    v16 = v7;
    do
    {
      v38 = v83;
      v39 = v84;
      std::list<int>::list(v40, v85);
      v41 = v86;
      v42 = v87;
      v33 = *(v16 + 56);
      v34 = *(v16 + 64);
      std::list<int>::list(v35, v16 + 72);
      v7 = v16 + 56;
      v17 = *(v16 + 104);
      v36 = *(v16 + 96);
      v37 = v17;
      v18 = v38;
      v19 = v33;
      std::__list_imp<char *>::clear(v35);
      std::__list_imp<char *>::clear(v40);
      v16 += 56;
    }

    while (v18 >= v19);
    v20 = v13;
    do
    {
      v28 = v83;
      v29 = v84;
      std::list<int>::list(v30, v85);
      v31 = v86;
      v32 = v87;
      v24 = *(v20 - 7);
      std::list<int>::list(v25, (v20 - 5));
      v13 = v20 - 7;
      v26 = *(v20 - 4);
      v27 = *(v20 - 2);
      v21 = v28;
      std::__list_imp<char *>::clear(v25);
      std::__list_imp<char *>::clear(v30);
      v20 -= 7;
    }

    while (v21 < v24);
  }

  if ((v7 - 56) != v23)
  {
    *v23 = *(v7 - 56);
    *(v23 + 2) = *(v7 - 48);
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v23 + 2, *(v7 - 32), v7 - 40);
    *(v23 + 10) = *(v7 - 16);
    *(v23 + 12) = *(v7 - 8);
  }

  *(v7 - 56) = v83;
  *(v7 - 48) = v84;
  if ((v7 - 56) != &v83)
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v7 - 40), v85[1], v85);
  }

  *(v7 - 16) = v86;
  *(v7 - 8) = v87;
  std::__list_imp<char *>::clear(v85);
  return v7;
}

void sub_1B5A6D1B4(_Unwind_Exception *a1)
{
  std::__list_imp<char *>::clear((v1 + 16));
  std::__list_imp<char *>::clear((v2 + 16));
  _Unwind_Resume(a1);
}

unint64_t std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>> *,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &>(uint64_t *a1, unint64_t a2)
{
  v76 = *a1;
  v77 = *(a1 + 2);
  std::list<int>::list(v78, (a1 + 2));
  v4 = 0;
  v26 = a1;
  v5 = *(a1 + 12);
  v79 = *(a1 + 10);
  v80 = v5;
  do
  {
    v71 = a1[v4 + 7];
    v72 = a1[v4 + 8];
    std::list<int>::list(v73, &a1[v4 + 9]);
    v6 = a1[v4 + 13];
    v74 = a1[v4 + 12];
    v75 = v6;
    v66 = v76;
    v67 = v77;
    std::list<int>::list(v68, v78);
    v69 = v79;
    v70 = v80;
    v7 = v71;
    std::__list_imp<char *>::clear(v68);
    std::__list_imp<char *>::clear(v73);
    v4 += 7;
  }

  while (v7 < v66);
  v8 = &a1[v4];
  if (v4 == 7)
  {
    while (v8 < a2)
    {
      v9 = a2 - 56;
      v61 = *(a2 - 56);
      v62 = *(a2 - 48);
      std::list<int>::list(v63, a2 - 40);
      v13 = *(a2 - 8);
      v64 = *(a2 - 16);
      v65 = v13;
      v56 = v76;
      v57 = v77;
      std::list<int>::list(v58, v78);
      v59 = v79;
      v60 = v80;
      v14 = v61;
      std::__list_imp<char *>::clear(v58);
      std::__list_imp<char *>::clear(v63);
      a2 -= 56;
      if (v14 < v56)
      {
        goto LABEL_11;
      }
    }

    v9 = a2;
  }

  else
  {
    v9 = a2;
    do
    {
      v10 = *(v9 - 56);
      v9 -= 56;
      v51 = v10;
      v52 = *(v9 + 8);
      std::list<int>::list(v53, v9 + 16);
      v11 = *(a2 - 8);
      v54 = *(a2 - 16);
      v55 = v11;
      v46 = v76;
      v47 = v77;
      std::list<int>::list(v48, v78);
      v49 = v79;
      v50 = v80;
      v12 = v51;
      std::__list_imp<char *>::clear(v48);
      std::__list_imp<char *>::clear(v53);
      a2 = v9;
    }

    while (v12 >= v46);
  }

LABEL_11:
  if (v8 >= v9)
  {
    v15 = &v26[v4];
  }

  else
  {
    v15 = &v26[v4];
    v16 = v9;
    do
    {
      std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(v15, v16);
      v17 = v15;
      do
      {
        v18 = *(v15 + 56);
        v15 += 56;
        v41 = v18;
        v42 = *(v15 + 8);
        std::list<int>::list(v43, v15 + 16);
        v19 = *(v17 + 104);
        v44 = *(v17 + 96);
        v45 = v19;
        v36 = v76;
        v37 = v77;
        std::list<int>::list(v38, v78);
        v39 = v79;
        v40 = v80;
        v20 = v41;
        v21 = v36;
        std::__list_imp<char *>::clear(v38);
        std::__list_imp<char *>::clear(v43);
        v17 = v15;
      }

      while (v20 < v21);
      v22 = v16;
      do
      {
        v23 = *(v16 - 56);
        v16 -= 56;
        v31 = v23;
        v32 = *(v16 + 8);
        std::list<int>::list(v33, v16 + 16);
        v34 = *(v22 - 16);
        v35 = *(v22 - 8);
        v27 = v76;
        std::list<int>::list(v28, v78);
        v29 = v79;
        v30 = v80;
        v24 = v31;
        std::__list_imp<char *>::clear(v28);
        std::__list_imp<char *>::clear(v33);
        v22 = v16;
      }

      while (v24 >= v27);
    }

    while (v15 < v16);
  }

  if ((v15 - 56) != v26)
  {
    *v26 = *(v15 - 56);
    *(v26 + 2) = *(v15 - 48);
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v26 + 2, *(v15 - 32), v15 - 40);
    *(v26 + 10) = *(v15 - 16);
    *(v26 + 12) = *(v15 - 8);
  }

  *(v15 - 56) = v76;
  *(v15 - 48) = v77;
  if ((v15 - 56) != &v76)
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v15 - 40), v78[1], v78);
  }

  *(v15 - 16) = v79;
  *(v15 - 8) = v80;
  std::__list_imp<char *>::clear(v78);
  return v15 - 56;
}

uint64_t std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(uint64_t a1, uint64_t a2)
{
  v3 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 3);
  if (v3 > 2)
  {
    switch(v3)
    {
      case 3:
        std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(a1, a1 + 56, a2 - 56);
        return 1;
      case 4:
        std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(a1, a1 + 56, a1 + 112, a2 - 56);
        return 1;
      case 5:
        std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(a1, a1 + 56, a1 + 112, a1 + 168, a2 - 56);
        return 1;
    }
  }

  else
  {
    if (v3 < 2)
    {
      return 1;
    }

    if (v3 == 2)
    {
      v4 = (a2 - 56);
      v55 = *(a2 - 56);
      v56 = *(a2 - 48);
      std::list<int>::list(v57, a2 - 40);
      v5 = *(a2 - 8);
      v58 = *(a2 - 16);
      v59 = v5;
      v50 = *a1;
      v51 = *(a1 + 8);
      std::list<int>::list(v52, a1 + 16);
      v6 = *(a1 + 48);
      v53 = *(a1 + 40);
      v54 = v6;
      v7 = v55;
      std::__list_imp<char *>::clear(v52);
      std::__list_imp<char *>::clear(v57);
      if (v7 < v50)
      {
        std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a1, v4);
      }

      return 1;
    }
  }

  v8 = a1 + 112;
  std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,0>(a1, a1 + 56, a1 + 112);
  v9 = a1 + 168;
  if (a1 + 168 != a2)
  {
    v10 = 0;
    v24 = 0;
    do
    {
      v45 = *v9;
      v46 = *(v9 + 8);
      std::list<int>::list(v47, v9 + 16);
      v11 = *(v9 + 48);
      v48 = *(v9 + 40);
      v49 = v11;
      v40 = *v8;
      v41 = *(v8 + 8);
      std::list<int>::list(v42, v8 + 16);
      v12 = *(v8 + 48);
      v43 = *(v8 + 40);
      v44 = v12;
      v13 = v45;
      v14 = v40;
      std::__list_imp<char *>::clear(v42);
      std::__list_imp<char *>::clear(v47);
      if (v13 < v14)
      {
        v35 = *v9;
        v36 = *(v9 + 8);
        std::list<int>::list(v37, v9 + 16);
        v15 = *(v9 + 48);
        v38 = *(v9 + 40);
        v39 = v15;
        v16 = v10;
        while (1)
        {
          v17 = a1 + v16;
          *(v17 + 168) = *(a1 + v16 + 112);
          *(v17 + 176) = *(a1 + v16 + 120);
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a1 + v16 + 184), *(a1 + v16 + 136), a1 + 128 + v16);
          *(v17 + 208) = *(v17 + 152);
          *(v17 + 216) = *(v17 + 160);
          if (v16 == -112)
          {
            break;
          }

          v30 = v35;
          v31 = v36;
          std::list<int>::list(v32, v37);
          v33 = v38;
          v34 = v39;
          v26 = *(a1 + v16 + 56);
          std::list<int>::list(v27, a1 + v16 + 72);
          v18 = *(a1 + v16 + 104);
          v28 = *(a1 + v16 + 96);
          v29 = v18;
          v19 = v30;
          std::__list_imp<char *>::clear(v27);
          std::__list_imp<char *>::clear(v32);
          v16 -= 56;
          if (v19 >= v26)
          {
            v20 = a1 + v16 + 168;
            goto LABEL_20;
          }
        }

        v20 = a1;
LABEL_20:
        *v20 = v35;
        *(v20 + 8) = v36;
        if (v20 != &v35)
        {
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v20 + 16), v37[1], v37);
        }

        v21 = v39;
        *(v20 + 40) = v38;
        *(v20 + 48) = v21;
        if (v24 == 7)
        {
          v22 = v9 + 56 == a2;
          std::__list_imp<char *>::clear(v37);
          return v22;
        }

        ++v24;
        std::__list_imp<char *>::clear(v37);
      }

      v8 = v9;
      v10 += 56;
      v9 += 56;
    }

    while (v9 != a2);
  }

  return 1;
}

void *std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(uint64_t *a1, uint64_t *a2)
{
  v7 = *a1;
  v8 = *(a1 + 2);
  std::list<int>::list(v9, (a1 + 2));
  v4 = *(a1 + 12);
  v10 = *(a1 + 10);
  v11 = v4;
  *a1 = *a2;
  *(a1 + 2) = *(a2 + 2);
  if (a1 != a2)
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(a1 + 2, a2[3], (a2 + 2));
  }

  *(a1 + 10) = *(a2 + 10);
  *(a1 + 12) = *(a2 + 12);
  *a2 = v7;
  *(a2 + 2) = v8;
  if (&v7 != a2)
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(a2 + 2, v9[1], v9);
  }

  v5 = v11;
  *(a2 + 10) = v10;
  *(a2 + 12) = v5;
  return std::__list_imp<char *>::clear(v9);
}

uint64_t std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 != a2)
  {
    v6 = a2;
    v8 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 3);
    v19 = a2 - a1;
    if (a2 - a1 >= 57)
    {
      v9 = (v8 - 2) >> 1;
      v10 = v9 + 1;
      v11 = &a1[7 * v9];
      do
      {
        std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(a1, a4, v8, v11);
        v11 -= 7;
        --v10;
      }

      while (v10);
    }

    v12 = v6;
    if (v6 != a3)
    {
      v12 = v6;
      do
      {
        v24 = *v12;
        v25 = *(v12 + 8);
        std::list<int>::list(v26, v12 + 16);
        v13 = *(v12 + 48);
        v27 = *(v12 + 40);
        v28 = v13;
        v20 = *a1;
        std::list<int>::list(v21, (a1 + 2));
        v14 = *(a1 + 12);
        v22 = *(a1 + 10);
        v23 = v14;
        v15 = v24;
        std::__list_imp<char *>::clear(v21);
        std::__list_imp<char *>::clear(v26);
        if (v15 < v20)
        {
          std::swap[abi:ne200100]<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(v12, a1);
          std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(a1, a4, v8, a1);
        }

        v12 += 56;
      }

      while (v12 != a3);
    }

    if (v19 >= 57)
    {
      v16 = 0x6DB6DB6DB6DB6DB7 * (v19 >> 3);
      do
      {
        std::__pop_heap[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(a1, v6, a4, v16);
        v6 -= 56;
      }

      while (v16-- > 2);
    }

    return v12;
  }

  return a3;
}

void *std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(void *result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v4 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = a4;
    v6 = result;
    v28 = v4 >> 1;
    if ((v4 >> 1) >= 0x6DB6DB6DB6DB6DB7 * (a4 - result))
    {
      v8 = (0xDB6DB6DB6DB6DB6ELL * (a4 - result)) | 1;
      v9 = &result[7 * v8];
      v10 = 0xDB6DB6DB6DB6DB6ELL * (a4 - result) + 2;
      if (v10 < a3)
      {
        v68 = *v9;
        v69 = *(v9 + 2);
        std::list<int>::list(v70, (v9 + 2));
        v11 = *(v9 + 12);
        v71 = *(v9 + 10);
        v72 = v11;
        v63 = v9[7];
        v64 = *(v9 + 16);
        std::list<int>::list(v65, (v9 + 9));
        v12 = *(v9 + 26);
        v66 = *(v9 + 24);
        v67 = v12;
        v13 = v68;
        std::__list_imp<char *>::clear(v65);
        std::__list_imp<char *>::clear(v70);
        v14 = 56;
        if (v13 >= v63)
        {
          v14 = 0;
        }

        v9 = (v9 + v14);
        if (v13 < v63)
        {
          v8 = v10;
        }
      }

      v58 = *v9;
      v59 = *(v9 + 2);
      std::list<int>::list(v60, (v9 + 2));
      v15 = *(v9 + 12);
      v61 = *(v9 + 10);
      v62 = v15;
      v53 = *v5;
      v54 = *(v5 + 2);
      std::list<int>::list(v55, (v5 + 2));
      v16 = *(v5 + 12);
      v56 = *(v5 + 10);
      v57 = v16;
      v17 = v58;
      std::__list_imp<char *>::clear(v55);
      result = std::__list_imp<char *>::clear(v60);
      if (v17 >= v53)
      {
        v48 = *v5;
        v49 = *(v5 + 2);
        std::list<int>::list(v50, (v5 + 2));
        v18 = *(v5 + 12);
        v51 = *(v5 + 10);
        v52 = v18;
        do
        {
          v19 = v9;
          *v5 = *v9;
          *(v5 + 2) = *(v9 + 2);
          if (v5 != v9)
          {
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v5 + 2, v9[3], (v9 + 2));
          }

          *(v5 + 10) = *(v9 + 10);
          *(v5 + 12) = *(v9 + 12);
          if (v28 < v8)
          {
            break;
          }

          v20 = (2 * v8) | 1;
          v9 = &v6[7 * v20];
          v8 = 2 * v8 + 2;
          if (v8 >= a3)
          {
            v8 = v20;
          }

          else
          {
            v43 = *v9;
            v44 = *(v9 + 2);
            std::list<int>::list(v45, (v9 + 2));
            v21 = *(v9 + 12);
            v46 = *(v9 + 10);
            v47 = v21;
            v38 = v9[7];
            v39 = *(v9 + 16);
            std::list<int>::list(v40, (v9 + 9));
            v22 = *(v9 + 26);
            v41 = *(v9 + 24);
            v42 = v22;
            v23 = v43;
            v24 = v38;
            std::__list_imp<char *>::clear(v40);
            std::__list_imp<char *>::clear(v45);
            v25 = 56;
            if (v23 >= v24)
            {
              v25 = 0;
            }

            v9 = (v9 + v25);
            if (v23 >= v24)
            {
              v8 = v20;
            }
          }

          v33 = *v9;
          v34 = *(v9 + 2);
          std::list<int>::list(v35, (v9 + 2));
          v26 = *(v9 + 12);
          v36 = *(v9 + 10);
          v37 = v26;
          v29 = v48;
          std::list<int>::list(v30, v50);
          v31 = v51;
          v32 = v52;
          v27 = v33;
          std::__list_imp<char *>::clear(v30);
          std::__list_imp<char *>::clear(v35);
          v5 = v19;
        }

        while (v27 >= v29);
        *v19 = v48;
        *(v19 + 2) = v49;
        if (v19 != &v48)
        {
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v19 + 2, v50[1], v50);
        }

        *(v19 + 10) = v51;
        *(v19 + 12) = v52;
        return std::__list_imp<char *>::clear(v50);
      }
    }
  }

  return result;
}

void *std::__pop_heap[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    v7 = result;
    v12 = *result;
    v13 = *(result + 2);
    std::list<int>::list(&v14, (result + 2));
    v8 = *(v7 + 48);
    v16 = *(v7 + 40);
    v17 = v8;
    v9 = std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(v7, a3, a4);
    v10 = v9;
    if (v9 == a2 - 56)
    {
      *v9 = v12;
      *(v9 + 8) = v13;
      if (v9 != &v12)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v9 + 16), v15, &v14);
      }

      *(v10 + 40) = v16;
      *(v10 + 48) = v17;
    }

    else
    {
      *v9 = *(a2 - 56);
      *(v9 + 8) = *(a2 - 48);
      std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v9 + 16), *(a2 - 32), a2 - 40);
      *(v10 + 40) = *(a2 - 16);
      *(v10 + 48) = *(a2 - 8);
      *(a2 - 56) = v12;
      *(a2 - 48) = v13;
      if ((a2 - 56) != &v12)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a2 - 40), v15, &v14);
      }

      v11 = v17;
      *(a2 - 16) = v16;
      *(a2 - 8) = v11;
      std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(v7, v10 + 56, a3, 0x6DB6DB6DB6DB6DB7 * ((v10 + 56 - v7) >> 3));
    }

    return std::__list_imp<char *>::clear(&v14);
  }

  return result;
}

uint64_t std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v6 = (a3 - 2) / 2;
  do
  {
    v7 = a1 + 56 * v5;
    v8 = v7 + 56;
    v9 = (2 * v5) | 1;
    v5 = 2 * v5 + 2;
    if (v5 >= a3)
    {
      v5 = v9;
    }

    else
    {
      v17 = *(v7 + 56);
      v18 = *(v7 + 64);
      std::list<int>::list(v19, v7 + 72);
      v20 = *(v7 + 96);
      v21 = *(v7 + 104);
      v10 = v7 + 112;
      v13 = *(v7 + 112);
      std::list<int>::list(v14, v7 + 128);
      v15 = *(v7 + 152);
      v16 = *(v7 + 160);
      v11 = v17;
      std::__list_imp<char *>::clear(v14);
      std::__list_imp<char *>::clear(v19);
      if (v11 >= v13)
      {
        v5 = v9;
      }

      else
      {
        v8 = v10;
      }
    }

    *a1 = *v8;
    *(a1 + 8) = *(v8 + 8);
    if (a1 != v8)
    {
      std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a1 + 16), *(v8 + 24), v8 + 16);
    }

    *(a1 + 40) = *(v8 + 40);
    *(a1 + 48) = *(v8 + 48);
    a1 = v8;
  }

  while (v5 <= v6);
  return v8;
}

void sub_1B5A6E4B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::__list_imp<char *>::clear(va);
  _Unwind_Resume(a1);
}

void *std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>> &,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>*>(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = &result[7 * (v4 >> 1)];
    v37 = *v8;
    v38 = *(v8 + 2);
    std::list<int>::list(v39, (v8 + 2));
    v9 = *(v8 + 12);
    v40 = *(v8 + 10);
    v41 = v9;
    v10 = (a2 - 56);
    v32 = *(a2 - 56);
    v33 = *(a2 - 48);
    std::list<int>::list(v34, a2 - 40);
    v11 = *(a2 - 8);
    v35 = *(a2 - 16);
    v36 = v11;
    v12 = v37;
    std::__list_imp<char *>::clear(v34);
    result = std::__list_imp<char *>::clear(v39);
    if (v12 < v32)
    {
      v27 = *(a2 - 56);
      v28 = *(a2 - 48);
      std::list<int>::list(v29, a2 - 40);
      v13 = *(a2 - 8);
      v30 = *(a2 - 16);
      v31 = v13;
      do
      {
        v14 = v8;
        *v10 = *v8;
        *(v10 + 2) = *(v8 + 2);
        if (v10 != v8)
        {
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v10 + 2, v8[3], (v8 + 2));
        }

        *(v10 + 10) = *(v8 + 10);
        *(v10 + 12) = *(v8 + 12);
        if (!v7)
        {
          break;
        }

        v7 = (v7 - 1) >> 1;
        v8 = &v6[7 * v7];
        v22 = *v8;
        v23 = *(v8 + 2);
        std::list<int>::list(v24, (v8 + 2));
        v15 = *(v8 + 12);
        v25 = *(v8 + 10);
        v26 = v15;
        v18 = v27;
        std::list<int>::list(v19, v29);
        v20 = v30;
        v21 = v31;
        v16 = v22;
        std::__list_imp<char *>::clear(v19);
        std::__list_imp<char *>::clear(v24);
        v10 = v14;
      }

      while (v16 < v18);
      *v14 = v27;
      *(v14 + 2) = v28;
      if (v14 != &v27)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v14 + 2, v29[1], v29);
      }

      v17 = v31;
      *(v14 + 10) = v30;
      *(v14 + 12) = v17;
      return std::__list_imp<char *>::clear(v29);
    }
  }

  return result;
}

void sub_1B5A6E700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__list_imp<char *>::clear(va);
  _Unwind_Resume(a1);
}

uint64_t fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::Split(void *a1, int a2)
{
  for (i = *(a1[4] + 8 * a2); i; i = *(i + 1))
  {
    if (*(*(*(a1[32] + 64) + 8 * (*i + 1)) + 64) != *(*(*(a1[32] + 64) + 8 * (*i + 1)) + 56))
    {
      operator new();
    }
  }

  v4 = a1[33];
  v5 = *v4;
  v6 = (v4 + 8);
  v7 = *(v4 + 8);
  if (*v4 != v7)
  {
    v8 = -1;
    while (1)
    {
      v9 = *v5;
      v36 = *(v4 + 24);
      v10 = (v7 - v5) >> 3;
      if (v10 >= 2)
      {
        v11 = *v5;
        v12 = std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::ArcIterCompare &,std::__wrap_iter<fst::ArcIterator<fst::Fst<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>> **>>(v5, &v36, v10);
        v13 = (v7 - 8);
        if ((v7 - 8) == v12)
        {
          *v12 = v11;
        }

        else
        {
          *v12 = *v13;
          *v13 = v11;
          std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::ArcIterCompare &,std::__wrap_iter<fst::ArcIterator<fst::Fst<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>> **>>(v5, (v12 + 1), &v36, v12 + 1 - v5);
        }
      }

      *v6 -= 8;
      if (!*v9)
      {
        break;
      }

      v14 = (*(**v9 + 24))(*v9);
      v15 = *v9;
      if ((v14 & 1) == 0)
      {
        if (v15)
        {
          v17 = (*(*v15 + 32))(v15);
          if (*v9)
          {
            v18 = (*(**v9 + 32))(*v9);
            goto LABEL_24;
          }
        }

        else
        {
LABEL_22:
          v17 = (v9[1] + 56 * v9[4]);
        }

        v18 = v9[1] + 56 * v9[4];
LABEL_24:
        v19 = *(v18 + 48);
        v20 = *v17;
        if (v8 != *v17)
        {
          fst::Partition<int>::FinalizeSplit<fst::LifoQueue<int>>(a1, (a1 + 23));
        }

        if (*(a1[13] + 4 * *(a1[10] + 4 * (v19 - 1))) >= 2u)
        {
          fst::Partition<int>::SplitOn(a1, v19 - 1);
        }

        if (*v9)
        {
          (*(**v9 + 40))(*v9);
          if (*v9)
          {
            if ((*(**v9 + 24))(*v9))
            {
              if (*v9)
              {
                (*(**v9 + 8))(*v9);
                goto LABEL_39;
              }

LABEL_37:
              v25 = v9[3];
              if (v25)
              {
                --*v25;
              }

LABEL_39:
              MEMORY[0x1B8C85350](v9, 0x1070C401ACC3EEFLL);
LABEL_51:
              v8 = v20;
              goto LABEL_52;
            }

LABEL_35:
            v21 = a1[33];
            v23 = *(v21 + 8);
            v22 = *(v21 + 16);
            if (v23 >= v22)
            {
              v26 = (v23 - *v21) >> 3;
              if ((v26 + 1) >> 61)
              {
                std::vector<int>::__throw_length_error[abi:ne200100]();
              }

              v27 = v22 - *v21;
              v28 = v27 >> 2;
              if (v27 >> 2 <= (v26 + 1))
              {
                v28 = v26 + 1;
              }

              if (v27 >= 0x7FFFFFFFFFFFFFF8)
              {
                v29 = 0x1FFFFFFFFFFFFFFFLL;
              }

              else
              {
                v29 = v28;
              }

              if (v29)
              {
                std::__allocate_at_least[abi:ne200100]<std::allocator<kaldi::CuWorkspace *>>(a1[33], v29);
              }

              v30 = (8 * v26);
              *v30 = v9;
              v24 = 8 * v26 + 8;
              v31 = *(v21 + 8) - *v21;
              v32 = v30 - v31;
              memcpy(v30 - v31, *v21, v31);
              v33 = *v21;
              *v21 = v32;
              *(v21 + 8) = v24;
              *(v21 + 16) = 0;
              if (v33)
              {
                operator delete(v33);
              }
            }

            else
            {
              *v23 = v9;
              v24 = (v23 + 1);
            }

            *(v21 + 8) = v24;
            v34 = *v21;
            v36 = *(v21 + 24);
            std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::ArcIterCompare &,std::__wrap_iter<fst::ArcIterator<fst::Fst<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>> **>>(v34, v24, &v36, (v24 - v34) >> 3);
            goto LABEL_51;
          }
        }

        else
        {
          ++v9[4];
        }

        if (v9[4] >= v9[2])
        {
          goto LABEL_37;
        }

        goto LABEL_35;
      }

      if (!v15)
      {
        goto LABEL_16;
      }

      (*(*v15 + 8))(v15);
LABEL_18:
      MEMORY[0x1B8C85350](v9, 0x1070C401ACC3EEFLL);
LABEL_52:
      v4 = a1[33];
      v5 = *v4;
      v6 = (v4 + 8);
      v7 = *(v4 + 8);
      if (*v4 == v7)
      {
        return fst::Partition<int>::FinalizeSplit<fst::LifoQueue<int>>(a1, (a1 + 23));
      }
    }

    if (v9[4] < v9[2])
    {
      goto LABEL_22;
    }

LABEL_16:
    v16 = v9[3];
    if (v16)
    {
      --*v16;
    }

    goto LABEL_18;
  }

  return fst::Partition<int>::FinalizeSplit<fst::LifoQueue<int>>(a1, (a1 + 23));
}

BOOL std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::ArcIterCompare &,std::__wrap_iter<fst::ArcIterator<fst::Fst<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>> **>>(_BOOL8 result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = (result + 8 * (v4 >> 1));
    v9 = (a2 - 8);
    result = fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::ArcIterCompare::operator()(a3, *v8, *(a2 - 8));
    if (result)
    {
      v10 = *v9;
      do
      {
        v11 = v8;
        *v9 = *v8;
        if (!v7)
        {
          break;
        }

        v7 = (v7 - 1) >> 1;
        v8 = (v6 + 8 * v7);
        result = fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::ArcIterCompare::operator()(a3, *v8, v10);
        v9 = v11;
      }

      while (result);
      *v11 = v10;
    }
  }

  return result;
}

BOOL fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::ArcIterCompare::operator()(uint64_t a1, void *a2, void *a3)
{
  if (*a2)
  {
    v4 = (*(**a2 + 32))(*a2);
  }

  else
  {
    v4 = (a2[1] + 56 * a2[4]);
  }

  if (*a3)
  {
    v5 = (*(**a3 + 32))(*a3);
  }

  else
  {
    v5 = (a3[1] + 56 * a3[4]);
  }

  return *v4 > *v5;
}

void **std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::ArcIterCompare &,std::__wrap_iter<fst::ArcIterator<fst::Fst<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>> **>>(void *a1, uint64_t a2, uint64_t a3)
{
  v6 = 0;
  v7 = (a3 - 2) / 2;
  do
  {
    v8 = &a1[v6 + 1];
    v9 = (2 * v6) | 1;
    v10 = 2 * v6 + 2;
    if (v10 < a3)
    {
      v11 = fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::ArcIterCompare::operator()(a2, *v8, a1[v6 + 2]);
      if (v11)
      {
        v12 = 8;
      }

      else
      {
        v12 = 0;
      }

      v8 = (v8 + v12);
      if (v11)
      {
        v9 = v10;
      }
    }

    *a1 = *v8;
    a1 = v8;
    v6 = v9;
  }

  while (v9 <= v7);
  return v8;
}

void *fst::CyclicMinimizer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::LifoQueue<int>>::~CyclicMinimizer(void *a1)
{
  v2 = a1[33];
  if (v2)
  {
    v3 = *v2;
    if (*v2)
    {
      *(v2 + 8) = v3;
      operator delete(v3);
    }

    MEMORY[0x1B8C85350](v2, 0xE0C40DD5D8FE3);
  }

  fst::ImplToFst<fst::VectorFstImpl<fst::VectorState<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,std::allocator<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>>,fst::MutableFst<fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>>::~ImplToFst(a1 + 31);
  std::deque<int>::~deque[abi:ne200100](a1 + 25);

  return fst::Partition<int>::~Partition(a1);
}

uint64_t fst::StateMap<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(uint64_t a1, uint64_t *a2)
{
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    v5 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
    v6 = (*(**a2 + 24))();
    (*(*a1 + 176))(a1, v6);
    if ((*(*a1 + 160))(a1) >= 1)
    {
      v7 = 0;
      do
      {
        fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::SetState(a2, v7);
        (*(*a1 + 240))(a1, v7);
        for (i = a2[5]; ; a2[5] = i)
        {
          v9 = a2[2];
          if (i >= 0x6DB6DB6DB6DB6DB7 * ((a2[3] - v9) >> 3))
          {
            break;
          }

          (*(*a1 + 208))(a1, v7, v9 + 56 * i);
          i = a2[5] + 1;
        }

        (*(**a2 + 32))(&v10);
        (*(*a1 + 184))(a1, v7, &v10);
        std::__list_imp<char *>::clear(v11);
        v7 = (v7 + 1);
      }

      while (v7 < (*(*a1 + 160))(a1));
    }

    return (*(*a1 + 192))(a1, v5 & 0xA6A0A950007, 0x3FFFFFFF0007);
  }

  return result;
}

uint64_t *fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::SetState(uint64_t *a1, uint64_t a2)
{
  v4 = a1 + 2;
  v5 = a1[2];
  a1[5] = 0;
  v6 = a1[3];
  if (v6 != v5)
  {
    do
    {
      v7 = v6 - 56;
      std::__list_imp<char *>::clear((v6 - 40));
      v6 = v7;
    }

    while (v7 != v5);
  }

  a1[3] = v5;
  v8 = (*(**a1 + 40))(*a1, a2);
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::reserve(v4, v8);
  v9 = *a1;
  v19 = 0;
  (*(*v9 + 136))(v9, a2, v17);
  while (1)
  {
    if (!v17[0])
    {
      if (v19 >= v17[2])
      {
        goto LABEL_15;
      }

LABEL_9:
      v10 = v17[1] + 56 * v19;
      goto LABEL_10;
    }

    if ((*(*v17[0] + 24))(v17[0]))
    {
      break;
    }

    if (!v17[0])
    {
      goto LABEL_9;
    }

    v10 = (*(*v17[0] + 32))();
LABEL_10:
    std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::push_back[abi:ne200100](v4, v10);
    if (v17[0])
    {
      (*(*v17[0] + 40))(v17[0]);
    }

    else
    {
      ++v19;
    }
  }

  if (v17[0])
  {
    (*(*v17[0] + 8))();
    goto LABEL_17;
  }

LABEL_15:
  if (v18)
  {
    --*v18;
  }

LABEL_17:
  v11 = a1[2];
  v12 = a1[3];
  v13 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (v12 - v11));
  if (v12 == v11)
  {
    v14 = 0;
  }

  else
  {
    v14 = v13;
  }

  std::__introsort<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,false>(v11, v12, v17, v14, 1);
  v15 = std::__unique[abi:ne200100]<std::_ClassicAlgPolicy,std::__wrap_iter<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0> *>,std::__wrap_iter<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0> *>,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::Equal &>(a1[2], a1[3], v17);
  return std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::resize(v4, 0x6DB6DB6DB6DB6DB7 * ((v15 - a1[2]) >> 3));
}

void sub_1B5A6F40C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    fst::Reverse<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::ReverseArc<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>();
  }

  else
  {
    fst::ComposeFstImpl<fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::SequenceComposeFilter<fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>,fst::GenericComposeStateTable<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::IntegerFilterState<signed char>,fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::CompactHashStateTable<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::ComposeHash<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>>>>>::OrderedExpand<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>(&a10);
  }

  _Unwind_Resume(a1);
}

uint64_t *std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::resize(uint64_t *result, unint64_t a2)
{
  v2 = result;
  v3 = result[1];
  v4 = 0x6DB6DB6DB6DB6DB7 * ((v3 - *result) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {

    return std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::__append(result, v6);
  }

  else if (!v5)
  {
    v7 = *result + 56 * a2;
    if (v3 != v7)
    {
      do
      {
        v8 = v3 - 56;
        result = std::__list_imp<char *>::clear((v3 - 40));
        v3 = v8;
      }

      while (v8 != v7);
    }

    v2[1] = v7;
  }

  return result;
}

void *std::__introsort<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,false>(void *result, void *a2, uint64_t a3, uint64_t a4, char a5)
{
  v8 = result;
  v9 = 0x6DB6DB6DB6DB6DB7;
LABEL_2:
  v31 = (a2 - 7);
  v10 = v8;
LABEL_3:
  v11 = 1 - a4;
  while (1)
  {
    v8 = v10;
    v12 = v11;
    v13 = a2 - v10;
    v14 = ((a2 - v10) >> 3) * v9;
    if (v14 <= 2)
    {
      if (v14 < 2)
      {
        return result;
      }

      if (v14 == 2)
      {
        v28 = *(a2 - 14);
        if (v28 < *v10 || v28 <= *v10 && ((v29 = *(a2 - 13), v30 = *(v10 + 4), v29 < v30) || v29 <= v30 && *(a2 - 2) < *(v10 + 48)))
        {

          return std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(v10, a2 - 7);
        }

        return result;
      }

      goto LABEL_11;
    }

    if (v14 == 3)
    {
      break;
    }

    if (v14 == 4)
    {

      return std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v10, v10 + 56, v10 + 112, v31);
    }

    if (v14 == 5)
    {

      return std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v10, v10 + 56, v10 + 112, v10 + 168, v31);
    }

LABEL_11:
    if (v13 <= 1343)
    {
      if (a5)
      {

        return std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v10, a2);
      }

      else
      {

        return std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v10, a2);
      }
    }

    if (v12 == 1)
    {
      if (v10 != a2)
      {

        return std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v10, a2, a2, a3);
      }

      return result;
    }

    v15 = v14 >> 1;
    v16 = (v10 + 56 * (v14 >> 1));
    if (v13 < 0x1C01)
    {
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v16, v10, v31);
      if (a5)
      {
        goto LABEL_22;
      }
    }

    else
    {
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v10, v16, v31);
      v17 = v10 + 56;
      v18 = v9;
      v19 = 56 * v15;
      v20 = (56 * v15 + v8 - 56);
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>((v8 + 56), v20, (a2 - 14));
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>((v8 + 112), (v17 + v19), (a2 - 21));
      v21 = v17 + v19;
      v9 = v18;
      std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v20, v16, v21);
      std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(v8, v16);
      if (a5)
      {
        goto LABEL_22;
      }
    }

    v22 = *(v8 - 56);
    if (v22 >= *v8)
    {
      if (v22 > *v8 || (v23 = *(v8 - 52), v24 = *(v8 + 4), v23 >= v24) && (v23 > v24 || *(v8 - 8) >= *(v8 + 48)))
      {
        result = std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0> *,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &>(v8, a2);
        v10 = result;
        goto LABEL_27;
      }
    }

LABEL_22:
    v25 = std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0> *,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &>(v8, a2);
    if ((v26 & 1) == 0)
    {
      goto LABEL_25;
    }

    v27 = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v8, v25);
    v10 = (v25 + 14);
    result = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>((v25 + 14), a2);
    if (result)
    {
      a4 = -v12;
      a2 = v25;
      if (v27)
      {
        return result;
      }

      goto LABEL_2;
    }

    v11 = v12 + 1;
    if ((v27 & 1) == 0)
    {
LABEL_25:
      result = std::__introsort<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,false>(v8, v25, a3, -v12, a5 & 1);
      v10 = (v25 + 14);
LABEL_27:
      a5 = 0;
      a4 = -v12;
      goto LABEL_3;
    }
  }

  return std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(v10, (v10 + 56), v31);
}

uint64_t std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  v5 = a1;
  v6 = *a2;
  if (*a2 < *a1 || v6 <= *a1 && ((v9 = *(a2 + 1), v10 = *(a1 + 1), v9 < v10) || v9 <= v10 && *(a2 + 12) < *(a1 + 12)))
  {
    if (*a3 >= v6)
    {
      if (*a3 > v6 || (v11 = *(a3 + 4), v12 = *(a2 + 1), v11 >= v12) && (v11 > v12 || *(a3 + 48) >= *(a2 + 12)))
      {
        std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1, a2);
        if (*a3 >= *a2)
        {
          if (*a3 > *a2)
          {
            return 1;
          }

          v15 = *(a3 + 4);
          v16 = *(a2 + 1);
          if (v15 >= v16 && (v15 > v16 || *(a3 + 48) >= *(a2 + 12)))
          {
            return 1;
          }
        }

        a1 = a2;
      }
    }

    v7 = a3;
LABEL_12:
    std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1, v7);
    return 1;
  }

  if (*a3 < v6 || *a3 <= v6 && ((v17 = *(a3 + 4), v18 = *(a2 + 1), v17 < v18) || v17 <= v18 && *(a3 + 48) < *(a2 + 12)))
  {
    std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a2, a3);
    if (*a2 >= *v5)
    {
      if (*a2 > *v5)
      {
        return 1;
      }

      v13 = *(a2 + 1);
      v14 = *(v5 + 1);
      if (v13 >= v14 && (v13 > v14 || *(a2 + 12) >= *(v5 + 12)))
      {
        return 1;
      }
    }

    a1 = v5;
    v7 = a2;
    goto LABEL_12;
  }

  return 0;
}

void *std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result = std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, a2, a3);
  if (*a4 < *a3 || *a4 <= *a3 && ((v9 = *(a4 + 4), v10 = *(a3 + 4), v9 < v10) || v9 <= v10 && *(a4 + 48) < *(a3 + 48)))
  {
    result = std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a3, a4);
    if (*a3 < *a2 || *a3 <= *a2 && ((v11 = *(a3 + 4), v12 = *(a2 + 4), v11 < v12) || v11 <= v12 && *(a3 + 48) < *(a2 + 48)))
    {
      result = std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a2, a3);
      if (*a2 < *a1 || *a2 <= *a1 && ((v13 = *(a2 + 4), v14 = *(a1 + 4), v13 < v14) || v13 <= v14 && *(a2 + 48) < *(a1 + 48)))
      {

        return std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1, a2);
      }
    }
  }

  return result;
}

void *std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  result = std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, a2, a3, a4);
  if (*a5 < *a4 || *a5 <= *a4 && ((v11 = *(a5 + 4), v12 = *(a4 + 4), v11 < v12) || v11 <= v12 && *(a5 + 48) < *(a4 + 48)))
  {
    result = std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a4, a5);
    if (*a4 < *a3 || *a4 <= *a3 && ((v13 = *(a4 + 4), v14 = *(a3 + 4), v13 < v14) || v13 <= v14 && *(a4 + 48) < *(a3 + 48)))
    {
      result = std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a3, a4);
      if (*a3 < *a2 || *a3 <= *a2 && ((v15 = *(a3 + 4), v16 = *(a2 + 4), v15 < v16) || v15 <= v16 && *(a3 + 48) < *(a2 + 48)))
      {
        result = std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a2, a3);
        if (*a2 < *a1 || *a2 <= *a1 && ((v17 = *(a2 + 4), v18 = *(a1 + 4), v17 < v18) || v17 <= v18 && *(a2 + 48) < *(a1 + 48)))
        {

          return std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1, a2);
        }
      }
    }
  }

  return result;
}

void *std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(void *result, void *a2)
{
  if (result != a2)
  {
    v3 = result;
    v4 = result + 7;
    if (result + 7 != a2)
    {
      v5 = 0;
      v6 = result;
      do
      {
        v7 = v6;
        v6 = v4;
        v8 = v7[14];
        if (v8 < *v7 || v8 <= *v7 && ((v14 = v7[15], v15 = v7[1], v14 < v15) || v14 <= v15 && v7[26] < v7[12]))
        {
          v18 = *v6;
          v19 = v7[16];
          std::list<int>::list(v20, (v7 + 18));
          v9 = v7[26];
          v21 = v7[24];
          v22 = v9;
          for (i = v5; ; i -= 56)
          {
            v11 = &v3[i];
            *(v11 + 7) = *&v3[i];
            *(v11 + 16) = *&v3[i + 8];
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(&v3[i + 72], *&v3[i + 24], &v3[i + 16]);
            *(v11 + 24) = *(v11 + 10);
            *(v11 + 26) = *(v11 + 12);
            if (!i)
            {
              v16 = v3;
              goto LABEL_20;
            }

            v12 = *&v3[i - 56];
            if (v18 >= v12)
            {
              if (v18 > v12)
              {
                break;
              }

              v13 = *&v3[i - 52];
              if (SHIDWORD(v18) >= v13 && (SHIDWORD(v18) > v13 || v22 >= *&v3[i - 8]))
              {
                break;
              }
            }
          }

          v16 = &v3[i];
LABEL_20:
          *v16 = v18;
          *(v16 + 2) = v19;
          if (v16 != &v18)
          {
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v16 + 2, v20[1], v20);
          }

          v17 = v22;
          *(v16 + 10) = v21;
          *(v16 + 12) = v17;
          result = std::__list_imp<char *>::clear(v20);
        }

        v4 = v6 + 7;
        v5 += 56;
      }

      while (v6 + 7 != a2);
    }
  }

  return result;
}

void *std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(void *result, void *a2)
{
  if (result != a2)
  {
    v3 = result;
    v4 = result + 7;
    if (result + 7 != a2)
    {
      v5 = 0;
      v6 = result;
      do
      {
        v7 = v6;
        v6 = v4;
        v8 = v7[14];
        if (v8 < *v7 || v8 <= *v7 && ((v16 = v7[15], v17 = v7[1], v16 < v17) || v16 <= v17 && v7[26] < v7[12]))
        {
          v18 = *v6;
          v19 = v7[16];
          std::list<int>::list(v20, (v7 + 18));
          v9 = v7[26];
          v21 = v7[24];
          v22 = v9;
          for (i = v5; ; i -= 56)
          {
            v11 = v3 + i;
            *(v11 + 7) = *(v3 + i);
            *(v11 + 16) = *(v3 + i + 8);
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v3 + i + 72), *(v3 + i + 24), v3 + i + 16);
            *(v11 + 24) = *(v11 + 10);
            *(v11 + 26) = *(v11 + 12);
            v12 = *(v3 + i - 56);
            if (v18 >= v12)
            {
              if (v18 > v12)
              {
                break;
              }

              v13 = *(v3 + i - 52);
              if (SHIDWORD(v18) >= v13 && (SHIDWORD(v18) > v13 || v22 >= *(v3 + i - 8)))
              {
                break;
              }
            }
          }

          v14 = v3 + i;
          *v14 = v18;
          *(v14 + 2) = v19;
          if (v14 != &v18)
          {
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v14 + 2, v20[1], v20);
          }

          v15 = v22;
          *(v14 + 10) = v21;
          *(v14 + 12) = v15;
          result = std::__list_imp<char *>::clear(v20);
        }

        v4 = v6 + 7;
        v5 += 56;
      }

      while (v6 + 7 != a2);
    }
  }

  return result;
}

unint64_t std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0> *,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &>(uint64_t *a1, unint64_t a2)
{
  v22 = *a1;
  v23 = *(a1 + 2);
  std::list<int>::list(v24, (a1 + 2));
  v4 = *(a1 + 12);
  v25 = *(a1 + 10);
  v26 = v4;
  v5 = *(a2 - 56);
  if (v22 < v5 || v22 <= v5 && ((v21 = *(a2 - 52), SHIDWORD(v22) < v21) || SHIDWORD(v22) <= v21 && v4 < *(a2 - 8)))
  {
    i = (a1 + 7);
    v6 = *(a1 + 14);
    if (v22 >= v6)
    {
      do
      {
        if (v22 <= v6)
        {
          v8 = *(i + 4);
          if (SHIDWORD(v22) < v8 || SHIDWORD(v22) <= v8 && v4 < *(i + 48))
          {
            break;
          }
        }

        v9 = *(i + 56);
        i += 56;
        v6 = v9;
      }

      while (v22 >= v9);
    }
  }

  else
  {
    for (i = (a1 + 7); i < a2; i += 56)
    {
      if (v22 < *i)
      {
        break;
      }

      if (v22 <= *i)
      {
        v10 = *(i + 4);
        if (SHIDWORD(v22) < v10 || SHIDWORD(v22) <= v10 && v4 < *(i + 48))
        {
          break;
        }
      }
    }
  }

  if (i < a2)
  {
    for (a2 -= 56; ; a2 -= 56)
    {
      if (v22 >= v5)
      {
        if (v22 > v5)
        {
          break;
        }

        v11 = *(a2 + 4);
        if (SHIDWORD(v22) >= v11 && (SHIDWORD(v22) > v11 || v4 >= *(a2 + 48)))
        {
          break;
        }
      }

      v12 = *(a2 - 56);
      v5 = v12;
    }
  }

  while (i < a2)
  {
    std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(i, a2);
    v14 = *(i + 56);
    i += 56;
    for (j = v14; v22 >= j; j = v16)
    {
      if (v22 <= j)
      {
        v15 = *(i + 4);
        if (SHIDWORD(v22) < v15 || SHIDWORD(v22) <= v15 && v26 < *(i + 48))
        {
          break;
        }
      }

      v16 = *(i + 56);
      i += 56;
    }

    do
    {
      do
      {
        v17 = *(a2 - 56);
        a2 -= 56;
        v18 = v22 <= v17;
      }

      while (v22 < v17);
      if (!v18)
      {
        break;
      }

      v19 = *(a2 + 4);
    }

    while (SHIDWORD(v22) < v19 || SHIDWORD(v22) <= v19 && v26 < *(a2 + 48));
  }

  if ((i - 56) != a1)
  {
    *a1 = *(i - 56);
    *(a1 + 2) = *(i - 48);
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(a1 + 2, *(i - 32), i - 40);
    *(a1 + 10) = *(i - 16);
    *(a1 + 12) = *(i - 8);
  }

  *(i - 56) = v22;
  *(i - 48) = v23;
  if ((i - 56) != &v22)
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((i - 40), v24[1], v24);
  }

  *(i - 16) = v25;
  *(i - 8) = v26;
  std::__list_imp<char *>::clear(v24);
  return i;
}

unint64_t std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0> *,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &>(uint64_t *a1, unint64_t a2)
{
  v23 = *a1;
  v24 = *(a1 + 2);
  std::list<int>::list(v25, (a1 + 2));
  v4 = 0;
  v5 = *(a1 + 12);
  v26 = *(a1 + 10);
  v27 = v5;
  while (1)
  {
    v6 = a1[v4 + 7];
    if (v6 >= v23)
    {
      if (v6 > v23)
      {
        break;
      }

      v7 = HIDWORD(a1[v4 + 7]);
      if (v7 >= SHIDWORD(v23) && (v7 > SHIDWORD(v23) || SLODWORD(a1[v4 + 13]) >= v5))
      {
        break;
      }
    }

    v4 += 7;
  }

  v8 = &a1[v4 + 7];
  if (v4 * 8)
  {
    while (1)
    {
      v10 = *(a2 - 56);
      a2 -= 56;
      v9 = v10;
      if (v10 < v23)
      {
        break;
      }

      if (v9 <= v23)
      {
        v11 = *(a2 + 4);
        if (v11 < SHIDWORD(v23) || v11 <= SHIDWORD(v23) && *(a2 + 48) < v5)
        {
          break;
        }
      }
    }
  }

  else
  {
LABEL_25:
    if (v8 < a2)
    {
      do
      {
        v13 = *(a2 - 56);
        a2 -= 56;
        v12 = v13;
        if (v13 < v23)
        {
          break;
        }

        if (v12 > v23)
        {
          goto LABEL_25;
        }

        v14 = *(a2 + 4);
        if (v14 < SHIDWORD(v23))
        {
          break;
        }

        if (v14 > SHIDWORD(v23))
        {
          goto LABEL_25;
        }
      }

      while (*(a2 + 48) >= v5 && v8 < a2);
    }
  }

  v16 = v8;
  if (v8 < a2)
  {
    v17 = a2;
    do
    {
      std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(v16, v17);
      for (v16 += 56; ; v16 += 56)
      {
        if (*v16 >= v23)
        {
          if (*v16 > v23)
          {
            break;
          }

          v18 = *(v16 + 4);
          if (v18 >= SHIDWORD(v23) && (v18 > SHIDWORD(v23) || *(v16 + 48) >= v27))
          {
            break;
          }
        }
      }

      while (1)
      {
        v20 = *(v17 - 56);
        v17 -= 56;
        v19 = v20;
        if (v20 < v23)
        {
          break;
        }

        if (v19 <= v23)
        {
          v21 = *(v17 + 4);
          if (v21 < SHIDWORD(v23) || v21 <= SHIDWORD(v23) && *(v17 + 48) < v27)
          {
            break;
          }
        }
      }
    }

    while (v16 < v17);
  }

  if ((v16 - 56) != a1)
  {
    *a1 = *(v16 - 56);
    *(a1 + 2) = *(v16 - 48);
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(a1 + 2, *(v16 - 32), v16 - 40);
    *(a1 + 10) = *(v16 - 16);
    *(a1 + 12) = *(v16 - 8);
  }

  *(v16 - 56) = v23;
  *(v16 - 48) = v24;
  if ((v16 - 56) != &v23)
  {
    std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v16 - 40), v25[1], v25);
  }

  *(v16 - 16) = v26;
  *(v16 - 8) = v27;
  std::__list_imp<char *>::clear(v25);
  return v16 - 56;
}

uint64_t std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(uint64_t a1, _DWORD *a2)
{
  v4 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 3);
  if (v4 > 2)
  {
    switch(v4)
    {
      case 3:
        std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, (a1 + 56), (a2 - 14));
        return 1;
      case 4:
        std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, a1 + 56, a1 + 112, (a2 - 14));
        return 1;
      case 5:
        std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, a1 + 56, a1 + 112, a1 + 168, (a2 - 14));
        return 1;
    }
  }

  else
  {
    if (v4 < 2)
    {
      return 1;
    }

    if (v4 == 2)
    {
      v5 = (a2 - 14);
      v6 = *(a2 - 14);
      if (v6 < *a1 || v6 <= *a1 && ((v22 = *(a2 - 13), v23 = *(a1 + 4), v22 < v23) || v22 <= v23 && *(a2 - 2) < *(a1 + 48)))
      {
        std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(a1, v5);
      }

      return 1;
    }
  }

  v7 = (a1 + 112);
  std::__sort3[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,0>(a1, (a1 + 56), a1 + 112);
  v8 = (a1 + 168);
  if ((a1 + 168) != a2)
  {
    v9 = 0;
    v10 = 0;
    do
    {
      if (*v8 < *v7 || *v8 <= *v7 && ((v16 = v8[1], v17 = v7[1], v16 < v17) || v16 <= v17 && v8[12] < v7[12]))
      {
        v24 = *v8;
        v25 = v8[2];
        std::list<int>::list(v26, (v8 + 4));
        v11 = v8[12];
        v27 = v8[10];
        v28 = v11;
        for (i = v9; ; i -= 56)
        {
          v13 = a1 + i;
          *(v13 + 168) = *(a1 + i + 112);
          *(v13 + 176) = *(a1 + i + 120);
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a1 + i + 184), *(a1 + i + 136), a1 + 128 + i);
          *(v13 + 208) = *(v13 + 152);
          *(v13 + 216) = *(v13 + 160);
          if (i == -112)
          {
            v18 = a1;
            goto LABEL_29;
          }

          v14 = *(a1 + i + 56);
          if (v24 >= v14)
          {
            if (v24 > v14)
            {
              break;
            }

            v15 = *(a1 + i + 60);
            if (SHIDWORD(v24) >= v15 && (SHIDWORD(v24) > v15 || v28 >= *(a1 + i + 104)))
            {
              break;
            }
          }
        }

        v18 = a1 + i + 112;
LABEL_29:
        *v18 = v24;
        *(v18 + 8) = v25;
        if (v18 != &v24)
        {
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((v18 + 16), v26[1], v26);
        }

        v19 = v28;
        *(v18 + 40) = v27;
        *(v18 + 48) = v19;
        if (++v10 == 8)
        {
          v20 = v8 + 14 == a2;
          std::__list_imp<char *>::clear(v26);
          return v20;
        }

        std::__list_imp<char *>::clear(v26);
      }

      v7 = v8;
      v9 += 56;
      v8 += 14;
    }

    while (v8 != a2);
  }

  return 1;
}

uint64_t std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 != a2)
  {
    v6 = a2;
    v8 = a2 - a1;
    v9 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 3);
    if (a2 - a1 >= 57)
    {
      v10 = (v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = (a1 + 56 * v10);
      do
      {
        std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(a1, a4, v9, v12);
        v12 -= 7;
        --v11;
      }

      while (v11);
    }

    v13 = v6;
    if (v6 != a3)
    {
      v13 = v6;
      do
      {
        if (*v13 < *a1 || *v13 <= *a1 && ((v14 = *(v13 + 4), v15 = *(a1 + 4), v14 < v15) || v14 <= v15 && *(v13 + 48) < *(a1 + 48)))
        {
          std::swap[abi:ne200100]<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(v13, a1);
          std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(a1, a4, v9, a1);
        }

        v13 += 56;
      }

      while (v13 != a3);
    }

    if (v8 >= 57)
    {
      v16 = 0x6DB6DB6DB6DB6DB7 * (v8 >> 3);
      do
      {
        std::__pop_heap[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(a1, v6, a4, v16);
        v6 -= 56;
      }

      while (v16-- > 2);
    }

    return v13;
  }

  return a3;
}

void *std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(void *result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v4 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = a4;
    v6 = result;
    v7 = v4 >> 1;
    if ((v4 >> 1) >= 0x6DB6DB6DB6DB6DB7 * (a4 - result))
    {
      v9 = (0xDB6DB6DB6DB6DB6ELL * (a4 - result)) | 1;
      v10 = &result[7 * v9];
      if ((0xDB6DB6DB6DB6DB6ELL * (a4 - result) + 2) < a3)
      {
        v11 = *(v10 + 14);
        if (*v10 < v11 || *v10 <= v11 && ((v22 = *(v10 + 1), v23 = *(v10 + 15), v22 < v23) || v22 <= v23 && *(v10 + 12) < *(v10 + 26)))
        {
          v10 += 7;
          v9 = 0xDB6DB6DB6DB6DB6ELL * (a4 - result) + 2;
        }
      }

      if (*v10 >= *a4)
      {
        if (*v10 > *a4 || (v20 = *(v10 + 1), v21 = *(a4 + 1), v20 >= v21) && (v20 > v21 || *(v10 + 12) >= *(a4 + 12)))
        {
          v24 = *a4;
          v25 = *(a4 + 2);
          std::list<int>::list(v26, (a4 + 2));
          v12 = *(v5 + 12);
          v27 = *(v5 + 10);
          v28 = v12;
          while (1)
          {
            v13 = v10;
            *v5 = *v10;
            *(v5 + 2) = *(v10 + 2);
            if (v5 != v10)
            {
              std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v5 + 2, v10[3], (v10 + 2));
            }

            *(v5 + 10) = *(v10 + 10);
            *(v5 + 12) = *(v10 + 12);
            if (v7 < v9)
            {
              break;
            }

            v14 = 2 * v9;
            v9 = (2 * v9) | 1;
            v10 = &v6[7 * v9];
            v15 = v14 + 2;
            if (v15 < a3)
            {
              v16 = *(v10 + 14);
              if (*v10 < v16 || *v10 <= v16 && ((v18 = *(v10 + 1), v19 = *(v10 + 15), v18 < v19) || v18 <= v19 && *(v10 + 12) < *(v10 + 26)))
              {
                v10 += 7;
                v9 = v15;
              }
            }

            if (*v10 < v24)
            {
              break;
            }

            v5 = v13;
            if (*v10 <= v24)
            {
              v17 = *(v10 + 1);
              if (v17 < SHIDWORD(v24))
              {
                break;
              }

              v5 = v13;
              if (v17 <= SHIDWORD(v24))
              {
                v5 = v13;
                if (*(v10 + 12) < v28)
                {
                  break;
                }
              }
            }
          }

          *v13 = v24;
          *(v13 + 2) = v25;
          if (v13 != &v24)
          {
            std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v13 + 2, v26[1], v26);
          }

          *(v13 + 10) = v27;
          *(v13 + 12) = v28;
          return std::__list_imp<char *>::clear(v26);
        }
      }
    }
  }

  return result;
}

void *std::__pop_heap[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    v7 = result;
    v12 = *result;
    v13 = *(result + 2);
    std::list<int>::list(&v14, (result + 2));
    v8 = *(v7 + 12);
    v16 = *(v7 + 10);
    v17 = v8;
    v9 = std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>*>(v7, a3, a4);
    v10 = v9;
    if (v9 == (a2 - 56))
    {
      *v9 = v12;
      *(v9 + 2) = v13;
      if (v9 != &v12)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v9 + 2, v15, &v14);
      }

      *(v10 + 10) = v16;
      *(v10 + 12) = v17;
    }

    else
    {
      *v9 = *(a2 - 56);
      *(v9 + 2) = *(a2 - 48);
      std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v9 + 2, *(a2 - 32), a2 - 40);
      *(v10 + 10) = *(a2 - 16);
      *(v10 + 12) = *(a2 - 8);
      *(a2 - 56) = v12;
      *(a2 - 48) = v13;
      if ((a2 - 56) != &v12)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>((a2 - 40), v15, &v14);
      }

      v11 = v17;
      *(a2 - 16) = v16;
      *(a2 - 8) = v11;
      std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(v7, (v10 + 7), a3, 0x6DB6DB6DB6DB6DB7 * (v10 + 7 - v7));
    }

    return std::__list_imp<char *>::clear(&v14);
  }

  return result;
}

void *std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::Compare &,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = &result[7 * (v4 >> 1)];
    v10 = (a2 - 56);
    v9 = *(a2 - 56);
    if (*v8 < v9 || *v8 <= v9 && ((v15 = *(v8 + 1), v16 = *(a2 - 52), v15 < v16) || v15 <= v16 && *(v8 + 12) < *(a2 - 8)))
    {
      v17 = *(a2 - 56);
      v18 = *(a2 - 48);
      std::list<int>::list(v19, a2 - 40);
      v11 = *(a2 - 8);
      v20 = *(a2 - 16);
      v21 = v11;
      while (1)
      {
        v12 = v8;
        *v10 = *v8;
        *(v10 + 2) = *(v8 + 2);
        if (v10 != v8)
        {
          std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v10 + 2, v8[3], (v8 + 2));
        }

        *(v10 + 10) = *(v8 + 10);
        *(v10 + 12) = *(v8 + 12);
        if (!v7)
        {
          break;
        }

        v7 = (v7 - 1) >> 1;
        v8 = &v6[7 * v7];
        v10 = v12;
        if (*v8 >= v17)
        {
          if (*v8 > v17)
          {
            break;
          }

          v13 = *(v8 + 1);
          v10 = v12;
          if (v13 >= SHIDWORD(v17))
          {
            if (v13 > SHIDWORD(v17))
            {
              break;
            }

            v10 = v12;
            if (*(v8 + 12) >= v21)
            {
              break;
            }
          }
        }
      }

      *v12 = v17;
      *(v12 + 2) = v18;
      if (v12 != &v17)
      {
        std::list<int>::__assign_with_sentinel[abi:ne200100]<std::__list_const_iterator<int,void *>,std::__list_const_iterator<int,void *>>(v12 + 2, v19[1], v19);
      }

      v14 = v21;
      *(v12 + 10) = v20;
      *(v12 + 12) = v14;
      return std::__list_imp<char *>::clear(v19);
    }
  }

  return result;
}

uint64_t *std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>::__append(uint64_t *result, unint64_t a2)
{
  v3 = result;
  v5 = result[1];
  v4 = result[2];
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      v10 = v5 + 56 * a2;
      v11 = 56 * a2;
      v12 = (v5 + 16);
      do
      {
        *v12 = v12;
        v12[1] = v12;
        v12[2] = 0;
        *(v12 - 2) = 0;
        v12 += 7;
        v11 -= 56;
      }

      while (v11);
    }

    else
    {
      v10 = result[1];
    }

    result[1] = v10;
  }

  else
  {
    v6 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *result) >> 3);
    v7 = v6 + a2;
    if (v6 + a2 > 0x492492492492492)
    {
      std::vector<int>::__throw_length_error[abi:ne200100]();
    }

    v8 = 0x6DB6DB6DB6DB6DB7 * ((v4 - *result) >> 3);
    if (2 * v8 > v7)
    {
      v7 = 2 * v8;
    }

    if (v8 >= 0x249249249249249)
    {
      v9 = 0x492492492492492;
    }

    else
    {
      v9 = v7;
    }

    v23 = result;
    if (v9)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>>(result, v9);
    }

    v13 = 56 * v6;
    v20 = 0;
    v21 = 56 * v6;
    *(&v22 + 1) = 0;
    v14 = 56 * a2;
    v15 = (56 * v6 + 16);
    do
    {
      *v15 = v15;
      v15[1] = v15;
      v15[2] = 0;
      *(v15 - 2) = 0;
      v15 += 7;
      v14 -= 56;
    }

    while (v14);
    *&v22 = v13 + 56 * a2;
    v16 = result[1];
    v17 = v13 + *result - v16;
    std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>*>(result, *result, v16, v17);
    v18 = *v3;
    *v3 = v17;
    v19 = v3[2];
    *(v3 + 1) = v22;
    *&v22 = v18;
    *(&v22 + 1) = v19;
    v20 = v18;
    v21 = v18;
    return std::__split_buffer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::~__split_buffer(&v20);
  }

  return result;
}

void sub_1B5A71228(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

void fst::RmFinalEpsilon<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>(uint64_t a1)
{
  memset(v4, 0, sizeof(v4));
  memset(v3, 0, sizeof(v3));
  v2 = 0;
  v1[0] = 0;
  v1[1] = v4;
  v1[2] = v3;
  v1[3] = &v2;
  fst::DfsVisit<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>,fst::SccVisitor<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>,fst::AnyArcFilter<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>>>(a1, v1);
}

void sub_1B5A71C6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37, uint64_t a38, uint64_t a39, void **a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45)
{
  a40 = &a37;
  std::vector<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::__destroy_vector::operator()[abi:ne200100](&a40);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(&a45);
  v47 = *(v45 - 200);
  if (v47)
  {
    operator delete(v47);
  }

  v48 = *(v45 - 176);
  if (v48)
  {
    operator delete(v48);
  }

  _Unwind_Resume(a1);
}

void *fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>::GallicToNewSymbolsMapper(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(a1 + 1) = 0u;
  *(a1 + 3) = 0u;
  *(a1 + 10) = 1065353216;
  *(a1 + 12) = 0;
  a1[7] = (*(*a2 + 120))(a2);
  a1[8] = 0;
  *(a1 + 72) = 0;
  (*(**a1 + 224))();
  *(a1 + 13) = (*(**a1 + 200))();
  (*(**a1 + 176))();
  (*(**a1 + 184))(*a1, *(a1 + 13), 0.0);
  v3 = a1[7];
  if (v3)
  {
    v4 = (*(*v3 + 48))(v3);
    v5 = v4;
    if (*(v4 + 23) >= 0)
    {
      v6 = *(v4 + 23);
    }

    else
    {
      v6 = *(v4 + 8);
    }

    v7 = v10;
    std::string::basic_string[abi:ne200100](v10, v6 + 12);
    if (v11 < 0)
    {
      v7 = v10[0];
    }

    if (v6)
    {
      if (v5[23] >= 0)
      {
        v8 = v5;
      }

      else
      {
        v8 = *v5;
      }

      memmove(v7, v8, v6);
    }

    strcpy(v7 + v6, "_from_gallic");
    operator new();
  }

  (*(**a1 + 280))(*a1, 0);
  return a1;
}

void sub_1B5A721A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (a20 < 0)
  {
    operator delete(a15);
  }

  std::__hash_table<std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>,std::__unordered_map_hasher<fst::StringWeight<int,(fst::StringType)0>,std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>,fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>::StringKey,std::equal_to<fst::StringWeight<int,(fst::StringType)0>>,true>,std::__unordered_map_equal<fst::StringWeight<int,(fst::StringType)0>,std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>,std::equal_to<fst::StringWeight<int,(fst::StringType)0>>,fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>::StringKey,true>,std::allocator<std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)0>::operator()(uint64_t *a1, int *a2)
{
  v45[2] = *MEMORY[0x1E69E9840];
  if (a2[12] != -1)
  {
    v4 = *(a2 + 2);
LABEL_19:
    v42 = v4;
    std::list<int>::list(v43, (a2 + 4));
    v15 = 0;
    if (v42 == 0.0 || v44 == -1)
    {
LABEL_71:
      v14 = *a2;
      if (*a2 == a2[1])
      {
LABEL_78:
        std::__list_imp<char *>::clear(v43);
        v13 = v15 << 32;
        return v13 | v14;
      }

LABEL_72:
      if (FLAGS_fst_error_fatal == 1)
      {
        std::string::basic_string[abi:ne200100]<0>(&__p, "FATAL");
      }

      else
      {
        std::string::basic_string[abi:ne200100]<0>(&__p, "ERROR");
      }

      v35 = fst::LogMessage::LogMessage(&v39, &__p);
      v36 = fst::cerr(v35);
      v37 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v36, "GallicToNewSymbolMapper: unrepresentable weight: ", 49);
      MEMORY[0x1B8C84C00](v37, v15);
      fst::LogMessage::~LogMessage(&v39);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      *(a1 + 72) = 1;
      v14 = *a2;
      goto LABEL_78;
    }

    v16 = std::__hash_table<std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>,std::__unordered_map_hasher<fst::StringWeight<int,(fst::StringType)0>,std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>,fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>::StringKey,std::equal_to<fst::StringWeight<int,(fst::StringType)0>>,true>,std::__unordered_map_equal<fst::StringWeight<int,(fst::StringType)0>,std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>,std::equal_to<fst::StringWeight<int,(fst::StringType)0>>,fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>::StringKey,true>,std::allocator<std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>>>::find<fst::StringWeight<int,(fst::StringType)0>>(a1 + 1, &v42);
    if (v16)
    {
      v15 = *(v16 + 12);
      goto LABEL_70;
    }

    v15 = *(a1 + 12) + 1;
    *(a1 + 12) = v15;
    *&__p.__r_.__value_.__l.__data_ = v42;
    std::list<int>::list(&__p.__r_.__value_.__l.__size_, v43);
    v41 = v15;
    std::__hash_table<std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>,std::__unordered_map_hasher<fst::StringWeight<int,(fst::StringType)0>,std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>,fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>::StringKey,std::equal_to<fst::StringWeight<int,(fst::StringType)0>>,true>,std::__unordered_map_equal<fst::StringWeight<int,(fst::StringType)0>,std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>,std::equal_to<fst::StringWeight<int,(fst::StringType)0>>,fst::GallicToNewSymbolsMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)0>::StringKey,true>,std::allocator<std::__hash_value_type<fst::StringWeight<int,(fst::StringType)0>,int>>>::__emplace_unique_key_args<fst::StringWeight<int,(fst::StringType)0>,std::pair<fst::StringWeight<int,(fst::StringType)0> const,int>>(a1 + 1, &__p);
    std::__list_imp<char *>::clear(&__p.__r_.__value_.__l.__size_);
    v17 = v43[1];
    memset(&__p, 0, sizeof(__p));
    if (v42 == 0.0)
    {
LABEL_66:
      v34 = a1[8];
      if (v34)
      {
        (*(*v34 + 24))(v34, &__p, v15);
      }

      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

LABEL_70:
      if (v15 > 0xFFFFFFFD)
      {
        goto LABEL_72;
      }

      goto LABEL_71;
    }

    v18 = 0;
    v19 = *(a1 + 13);
    v20 = 1;
    while (1)
    {
      if (v18 >= v44 + 1)
      {
        goto LABEL_66;
      }

      v21 = v18 == v44 ? *(a1 + 13) : (*(**a1 + 200))();
      v22 = *a1;
      v23 = (v20 & 1) != 0 ? &v42 : (v17 + 16);
      v24 = *v23;
      v25 = v18 ? 0 : v15;
      LODWORD(v39.__r_.__value_.__l.__data_) = v25;
      *(v39.__r_.__value_.__r.__words + 4) = v24;
      HIDWORD(v39.__r_.__value_.__r.__words[1]) = v21;
      (*(*v22 + 208))(v22, v19, &v39);
      if (a1[8])
      {
        if (v18)
        {
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }

          std::string::basic_string[abi:ne200100](&v39, size + 1);
          if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            v27 = &v39;
          }

          else
          {
            v27 = v39.__r_.__value_.__r.__words[0];
          }

          if (size)
          {
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              p_p = &__p;
            }

            else
            {
              p_p = __p.__r_.__value_.__r.__words[0];
            }

            memmove(v27, p_p, size);
          }

          *(&v27->__r_.__value_.__l.__data_ + size) = 95;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
          }

          __p = v39;
        }

        (*(*a1[7] + 88))(&v39);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v29 = &__p;
        }

        else
        {
          v29 = __p.__r_.__value_.__r.__words[0];
        }

        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v30 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v30 = __p.__r_.__value_.__l.__size_;
        }

        v31 = std::string::insert(&v39, 0, v29, v30);
        v32 = v31->__r_.__value_.__r.__words[0];
        v45[0] = v31->__r_.__value_.__l.__size_;
        *(v45 + 7) = *(&v31->__r_.__value_.__r.__words[1] + 7);
        v33 = HIBYTE(v31->__r_.__value_.__r.__words[2]);
        v31->__r_.__value_.__l.__size_ = 0;
        v31->__r_.__value_.__r.__words[2] = 0;
        v31->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }

        __p.__r_.__value_.__r.__words[0] = v32;
        __p.__r_.__value_.__l.__size_ = v45[0];
        *(&__p.__r_.__value_.__r.__words[1] + 7) = *(v45 + 7);
        *(&__p.__r_.__value_.__s + 23) = v33;
        if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
        {
          break;
        }
      }

      if ((v20 & 1) == 0)
      {
        goto LABEL_61;
      }

LABEL_62:
      v20 = 0;
      ++v18;
      v19 = v21;
      if (v42 == 0.0)
      {
        goto LABEL_66;
      }
    }

    operator delete(v39.__r_.__value_.__l.__data_);
    if (v20)
    {
      goto LABEL_62;
    }

LABEL_61:
    v17 = *(v17 + 8);
    goto LABEL_62;
  }

  v5 = fst::GallicWeight<int,fst::LogWeightTpl<float>,(fst::GallicType)0>::Zero();
  v4 = *(a2 + 2);
  if (v4 == 0.0)
  {
    v6 = 0;
  }

  else
  {
    v6 = *(a2 + 4) + 1;
  }

  if (*v5)
  {
    v7 = *(v5 + 24) + 1;
  }

  else
  {
    v7 = 0;
  }

  if (v6 != v7)
  {
    goto LABEL_19;
  }

  v8 = (a2 + 6);
  v9 = (v5 + 16);
  for (i = 1; ; i = 0)
  {
    v11 = *v8;
    v12 = *v9;
    if (i)
    {
      if (v4 == 0.0)
      {
        break;
      }

      if (LODWORD(v4) != *v5)
      {
        goto LABEL_19;
      }
    }

    if (v11 == a2 + 4)
    {
      break;
    }

    if (*(v11 + 16) != *(v12 + 16))
    {
      goto LABEL_19;
    }

    v8 = (v11 + 8);
    v9 = (v12 + 8);
  }

  LODWORD(__p.__r_.__value_.__l.__data_) = a2[10];
  v42 = *(v5 + 32);
  if (*&__p.__r_.__value_.__l.__data_ != v42)
  {
    goto LABEL_19;
  }

  v13 = 0;
  v14 = *a2;
  return v13 | v14;
}

void sub_1B5A72714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27)
{
  if (a23 < 0)
  {
    operator delete(__p);
  }

  std::__list_imp<char *>::clear(&a27);
  _Unwind_Resume(a1);
}

uint64_t fst::ArcMap<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::QuantizeMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::ArcTpl<fst::LogWeightTpl<float>,int>>>(uint64_t a1, float *a2)
{
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    v5 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
    if ((*(*a1 + 160))(a1) >= 1)
    {
      v6 = 0;
      do
      {
        (*(*a1 + 296))(a1, v6, &v12);
        while (!(*(*v12 + 24))(v12))
        {
          v7 = (*(*v12 + 32))(v12);
          v8 = *(v7 + 8);
          if ((LODWORD(v8) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
          {
            v8 = *a2 * floorf((v8 / *a2) + 0.5);
          }

          v9 = *(v7 + 12);
          v11[0] = *v7;
          v11[1] = LODWORD(v8) | (v9 << 32);
          (*(*v12 + 88))(v12, v11);
          (*(*v12 + 40))(v12);
        }

        if (v12)
        {
          (*(*v12 + 8))();
        }

        v10.n128_f32[0] = (*(*a1 + 32))(a1, v6);
        if ((v10.n128_u32[0] & 0x7FFFFFFF) <= 0x7F7FFFFF)
        {
          v10.n128_f32[0] = *a2 * floorf((v10.n128_f32[0] / *a2) + 0.5);
        }

        (*(*a1 + 184))(a1, v6, v10);
        v6 = (v6 + 1);
      }

      while (v6 < (*(*a1 + 160))(a1));
    }

    return (*(*a1 + 192))(a1, v5 & 0x3FFCFFFF0007, 0x3FFFFFFF0007);
  }

  return result;
}

void sub_1B5A72AD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
  {
    (*(*a12 + 8))(a12);
  }

  _Unwind_Resume(exception_object);
}

void fst::EncodeMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::EncodeMapper(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  operator new();
}

uint64_t fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::EncodeTable(uint64_t a1, int a2)
{
  *a1 = a2;
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *(a1 + 24) = 0;
  v4 = a2;
  v5 = a2 & 1;
  v6 = (a2 & 2) != 0;
  std::unordered_map<fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::Tuple const*,int,fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::TupleKey,fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::TupleEqual,std::allocator<std::pair<fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::Tuple const* const,int>>>::unordered_map(a1 + 32, 0x400uLL, &v4);
  *(a1 + 80) = 1;
  *(a1 + 88) = 0;
  *(a1 + 96) = 0;
  return a1;
}

void sub_1B5A72BFC(_Unwind_Exception *exception_object)
{
  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(v1 + 16) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::unordered_map<fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::Tuple const*,int,fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::TupleKey,fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::TupleEqual,std::allocator<std::pair<fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::Tuple const* const,int>>>::unordered_map(uint64_t a1, size_t a2, int *a3)
{
  v4 = *a3;
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *(a1 + 32) = v4;
  *(a1 + 36) = v4 & 1;
  *(a1 + 37) = (v4 & 2) != 0;
  *(a1 + 40) = 1065353216;
  std::__hash_table<int,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashFunc,fst::CompactHashBiTable<int,fst::DeterminizeStateTuple<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>> *,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleKey,fst::DefaultDeterminizeStateTable<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,fst::IntegerFilterState<signed char>>::StateTupleEqual,(fst::HSType)0>::HashEqual,std::allocator<int>>::__rehash<true>(a1, a2);
  return a1;
}

uint64_t fst::ArcMap<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::EncodeMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>(uint64_t a1, uint64_t a2)
{
  (*(*a1 + 280))(a1, 0);
  (*(*a1 + 288))(a1, 0);
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    v25 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
    if (*(a2 + 4) == 1 && (*a2 & 2) != 0)
    {
      v5 = (*(*a1 + 200))(a1);
      (*(*a1 + 184))(a1, v5, 0.0);
      v6 = 0;
    }

    else
    {
      LODWORD(v5) = -1;
      v6 = 1;
    }

    if ((*(*a1 + 160))(a1) >= 1)
    {
      v7 = 0;
      while (1)
      {
        (*(*a1 + 296))(a1, v7, &v34);
        while (!(*(*v34 + 24))(v34))
        {
          v8 = (*(*v34 + 32))(v34);
          v32 = fst::EncodeMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::operator()(a2, v8);
          v33 = v9;
          (*(*v34 + 88))(v34, &v32);
          (*(*v34 + 40))(v34);
        }

        if (v34)
        {
          (*(*v34 + 8))();
        }

        if (v6)
        {
          break;
        }

        if (v7 != v5)
        {
          *&v18 = (*(*a1 + 32))(a1, v7);
          v32 = 0;
          v33 = v18 | 0xFFFFFFFF00000000;
          v19 = fst::EncodeMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::operator()(a2, &v32);
          if (HIDWORD(v19) || v19 || (*&v32 = v20, LODWORD(v34) = 2139095040, v20 != INFINITY))
          {
            v32 = v19;
            v33 = __PAIR64__(v5, LODWORD(v20));
            (*(*a1 + 208))(a1, v7, &v32);
            v12.n128_u32[0] = 2139095040;
          }

          else
          {
            v12.n128_u32[0] = 2139095040;
          }

          goto LABEL_31;
        }

LABEL_32:
        v7 = (v7 + 1);
        if (v7 >= (*(*a1 + 160))(a1))
        {
          goto LABEL_35;
        }
      }

      *&v10 = (*(*a1 + 32))(a1, v7);
      v32 = 0;
      v33 = v10 | 0xFFFFFFFF00000000;
      v11 = fst::EncodeMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::operator()(a2, &v32);
      v14 = v13;
      if (!v11)
      {
LABEL_30:
        v12.n128_u32[0] = v14;
LABEL_31:
        (*(*a1 + 184))(a1, v7, v12);
        goto LABEL_32;
      }

      v15 = FLAGS_fst_error_fatal;
      if (FLAGS_fst_error_fatal == 1)
      {
        std::string::basic_string[abi:ne200100]<0>(v29, "FATAL");
        v16 = fst::LogMessage::LogMessage(&v31, v29);
      }

      else
      {
        std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
        v16 = fst::LogMessage::LogMessage(&v28, __p);
      }

      v17 = fst::cerr(v16);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v17, "ArcMap: non-zero arc labels for superfinal arc", 46);
      if (v15)
      {
        fst::LogMessage::~LogMessage(&v31);
        if (v30 < 0)
        {
          v21 = v29[0];
LABEL_28:
          operator delete(v21);
        }
      }

      else
      {
        fst::LogMessage::~LogMessage(&v28);
        if (v27 < 0)
        {
          v21 = __p[0];
          goto LABEL_28;
        }
      }

      (*(*a1 + 192))(a1, 4, 4);
      goto LABEL_30;
    }

LABEL_35:
    v22 = 0x3FFF00000007;
    if ((*a2 & 1) == 0)
    {
      v22 = 0x3FFFFFFF0007;
    }

    if ((*a2 & 2) != 0)
    {
      v23 = 0x1D7C48100007;
      if (*(a2 + 4) == 1)
      {
        v23 = 0x2EBC84200007;
      }

      v22 &= v23;
    }

    if (*(a2 + 16))
    {
      v24 = v25 | 4;
    }

    else
    {
      v24 = v25;
    }

    return (*(*a1 + 192))(a1, v22 & v24, 0x3FFFFFFF0007);
  }

  return result;
}

void sub_1B5A73248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32)
{
  fst::LogMessage::~LogMessage(&a29);
  if (a25 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

unint64_t fst::EncodeMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::operator()(int *a1, unsigned int *a2)
{
  v4 = a2[3];
  if (a1[1] == 1)
  {
    if (v4 == -1)
    {
      if ((*a1 & 2) == 0 || (LODWORD(__p[0]) = a2[2], LODWORD(v21[0]) = 2139095040, *__p == INFINITY))
      {
LABEL_14:
        v5 = *a2;
        v6 = a2[1];
        return v5 | (v6 << 32);
      }
    }

    v5 = fst::EncodeTable<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>::Encode(*(a1 + 1), a2);
    LODWORD(v6) = a2[1];
    if (*a1)
    {
      v6 = v5;
    }

    else
    {
      v6 = v6;
    }
  }

  else
  {
    if (v4 == -1 || !*a2)
    {
      goto LABEL_14;
    }

    v7 = *a1;
    if ((*a1 & 1) != 0 && *a2 != a2[1])
    {
      if (FLAGS_fst_error_fatal == 1)
      {
        std::string::basic_string[abi:ne200100]<0>(__p, "FATAL");
      }

      else
      {
        std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
      }

      v8 = fst::LogMessage::LogMessage(&v26, __p);
      v9 = fst::cerr(v8);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "EncodeMapper: Label-encoded arc has different input and output labels", 69);
      fst::LogMessage::~LogMessage(&v26);
      if (v25 < 0)
      {
        operator delete(__p[0]);
      }

      *(a1 + 16) = 1;
      v7 = *a1;
    }

    if ((v7 & 2) != 0)
    {
      LODWORD(v21[0]) = a2[2];
      LODWORD(v18[0]) = 0;
      if (*v21 != 0.0)
      {
        if (FLAGS_fst_error_fatal == 1)
        {
          std::string::basic_string[abi:ne200100]<0>(v21, "FATAL");
        }

        else
        {
          std::string::basic_string[abi:ne200100]<0>(v21, "ERROR");
        }

        v10 = fst::LogMessage::LogMessage(&v23, v21);
        v11 = fst::cerr(v10);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, "EncodeMapper: Weight-encoded arc has non-trivial weight", 55);
        fst::LogMessage::~LogMessage(&v23);
        if (v22 < 0)
        {
          operator delete(v21[0]);
        }

        *(a1 + 16) = 1;
      }
    }

    v12 = fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::Decode(*(a1 + 1), *a2);
    if (v12)
    {
      v13 = v12;
      v5 = *v12;
      if (*a1)
      {
        v14 = v13;
      }

      else
      {
        v14 = a2;
      }

      v6 = v14[1];
    }

    else
    {
      if (FLAGS_fst_error_fatal == 1)
      {
        std::string::basic_string[abi:ne200100]<0>(v18, "FATAL");
      }

      else
      {
        std::string::basic_string[abi:ne200100]<0>(v18, "ERROR");
      }

      v16 = fst::LogMessage::LogMessage(&v20, v18);
      v17 = fst::cerr(v16);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v17, "EncodeMapper: decode failed", 27);
      fst::LogMessage::~LogMessage(&v20);
      if (v19 < 0)
      {
        operator delete(v18[0]);
      }

      *(a1 + 16) = 1;
      v5 = -1;
      v6 = 0xFFFFFFFFLL;
    }
  }

  return v5 | (v6 << 32);
}

void sub_1B5A735C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, uint64_t a30, int a31, __int16 a32, char a33, char a34)
{
  fst::LogMessage::~LogMessage(&a28);
  if (a24 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t fst::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::Decode(uint64_t a1, uint64_t a2)
{
  if (a2 >= 1)
  {
    v3 = *(a1 + 8);
    if (a2 <= ((*(a1 + 16) - v3) >> 3))
    {
      return *(v3 + 8 * a2 - 8);
    }
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "ERROR");
  v4 = fst::LogMessage::LogMessage(&v10, __p);
  v5 = fst::cerr(v4);
  v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v5, "EncodeTable::Decode: unknown decode key: ", 41);
  MEMORY[0x1B8C84C00](v6, a2);
  fst::LogMessage::~LogMessage(&v10);
  if (v9 < 0)
  {
    operator delete(__p[0]);
  }

  return 0;
}

void sub_1B5A73704(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void fst::MergeStates<fst::ArcTpl<fst::LogWeightTpl<float>,int>>(void *a1, uint64_t a2)
{
  std::vector<int>::vector[abi:ne200100](&__p, ((a1[5] - a1[4]) >> 3));
  v5 = a1[4];
  v4 = a1[5];
  v6 = v4 - v5;
  if (((v4 - v5) >> 3))
  {
    v7 = 0;
    v8 = (v6 >> 3);
    v9 = __p;
    if (v8 <= 1)
    {
      v8 = 1;
    }

    do
    {
      *v9++ = **(v5 + (v7 >> 29));
      v7 += 0x100000000;
      --v8;
    }

    while (v8);
  }

  if ((v6 & 0x7FFFFFFF8) != 0)
  {
    v10 = 0;
    do
    {
      v11 = *(v5 + 8 * v10);
      if (v11)
      {
        do
        {
          v12 = *v11;
          (*(*a2 + 296))(a2, *v11, &v15);
          while (!(*(*v15 + 24))(v15))
          {
            v14 = *(*(*v15 + 32))(v15);
            HIDWORD(v14) = *(__p + *(a1[10] + 4 * SHIDWORD(v14)));
            if (v12 == *(__p + v10))
            {
              (*(*v15 + 88))(v15, &v14);
            }

            else
            {
              (*(*a2 + 208))(a2);
            }

            (*(*v15 + 40))(v15);
          }

          if (v15)
          {
            (*(*v15 + 8))(v15);
          }

          v11 = *(v11 + 1);
        }

        while (v11);
        v5 = a1[4];
        v4 = a1[5];
      }

      ++v10;
    }

    while (v10 < ((v4 - v5) >> 3));
  }

  v13 = (*(*a2 + 24))(a2);
  (*(*a2 + 176))(a2, *(__p + *(a1[10] + 4 * v13)));
  fst::Connect<fst::ArcTpl<fst::LogWeightTpl<float>,int>>(a2);
}

void sub_1B5A739E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t fst::AcyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::AcyclicMinimizer(uint64_t a1, void *a2)
{
  v4 = (*(*a2 + 64))(a2, 0x40000, 1) == 0;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 72) = 0u;
  *(a1 + 88) = 0u;
  *(a1 + 104) = 0u;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = v4;
  if (!(*(*a2 + 64))(a2, 0x40000, 1))
  {
    FstCheck(0, "Weight::Properties() & kIdempotent", "../libquasar/libkaldi/tools/openfst/src/include/fst/minimize.h", 317);
  }

  fst::AcyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::Initialize(a1, a2);
  fst::AcyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::Refine(a1, a2);
  return a1;
}

void fst::AcyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::Initialize(uint64_t a1, uint64_t a2)
{
  fst::DfsVisit<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::AcyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::HeightVisitor,fst::AnyArcFilter<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>(a2);
  fst::Partition<int>::Initialize(a1, 0);
  fst::Partition<int>::AllocateClasses(a1, 1);
}

void sub_1B5A73C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void fst::AcyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::Refine(void *a1, void *a2)
{
  v2 = a1[5] - a1[4];
  if ((v2 >> 3))
  {
    v5 = 0;
    v6 = (v2 >> 3);
    if (v6 <= 1)
    {
      v7 = 1;
    }

    else
    {
      v7 = v6;
    }

    do
    {
      v17[0] = 0;
      v17[1] = 0;
      v17[2] = a2;
      v17[3] = a1;
      v18 = 7;
      v16 = v17;
      v8 = *(a1[4] + 8 * v5);
      v15 = *v8;
      v19 = &v15;
      *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&v16, &v15) + 32) = v5;
      for (i = *(v8 + 8); i; i = *(i + 8))
      {
        v15 = *i;
        v10 = std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::find<int>(&v16, &v15);
        if (v17 == v10)
        {
          v11 = fst::Partition<int>::AddClass(a1);
        }

        else
        {
          v11 = *(v10 + 32);
        }

        v19 = &v15;
        *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&v16, &v15) + 32) = v11;
      }

      v12 = *(a1[4] + 8 * v5);
      while (v12)
      {
        v15 = *v12;
        v13 = *(a1[10] + 4 * v15);
        v19 = &v15;
        v14 = *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&v16, &v15) + 32);
        v12 = *(v12 + 8);
        if (v13 != v14)
        {
          fst::Partition<int>::Move(a1, v15, v14);
        }
      }

      std::__tree<int>::destroy(&v16, v17[0]);
      ++v5;
    }

    while (v5 != v7);
  }
}

uint64_t fst::DfsVisit<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::AcyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::HeightVisitor,fst::AnyArcFilter<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>(uint64_t a1)
{
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    memset(&v6, 0, sizeof(v6));
    v4 = 0u;
    v5 = 0u;
    v3 = 0u;
    fst::MemoryPool<fst::DfsState<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>::MemoryPool(v2, 64);
  }

  return result;
}

void sub_1B5A74580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  v10 = va_arg(va1, void);
  v12 = va_arg(va1, void);
  v13 = va_arg(va1, void);
  v14 = va_arg(va1, void);
  v15 = va_arg(va1, void);
  v16 = va_arg(va1, void);
  v17 = va_arg(va1, void);
  v18 = va_arg(va1, void);
  fst::MemoryPool<fst::DfsState<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>::~MemoryPool(va);
  std::deque<fst::DfsState<fst::ArcTpl<fst::LatticeWeightTpl<float>,int>> *,std::allocator<fst::DfsState<fst::ArcTpl<fst::LatticeWeightTpl<float>,int>> *>>::~deque[abi:ne200100](va1);
  v9 = *(v7 - 112);
  if (v9)
  {
    *(v7 - 104) = v9;
    operator delete(v9);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(uint64_t a1, unsigned int *a2)
{
  v2 = *std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::__find_equal<int>(a1, &v4, a2);
  if (!v2)
  {
    operator new();
  }

  return v2;
}

uint64_t *std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::__find_equal<int>(uint64_t a1, void *a2, unsigned int *a3)
{
  v5 = (a1 + 8);
  v4 = *(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v8 = v4;
        if (!fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::operator()((a1 + 24), *a3, *(v4 + 7)))
        {
          break;
        }

        v4 = *v8;
        v5 = v8;
        if (!*v8)
        {
          goto LABEL_9;
        }
      }

      if (!fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::operator()((a1 + 24), *(v8 + 7), *a3))
      {
        break;
      }

      v5 = v8 + 1;
      v4 = v8[1];
    }

    while (v4);
  }

  else
  {
    v8 = (a1 + 8);
  }

LABEL_9:
  *a2 = v8;
  return v5;
}

uint64_t fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::operator()(void *a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a1 + 4);
  if (v6)
  {
    v16 = (*(**a1 + 32))();
    v17 = (*(**a1 + 32))(*a1, a3);
    if (LODWORD(v16) < LODWORD(v17))
    {
      return 1;
    }

    if (LODWORD(v16) <= LODWORD(v17) && (a1[2] & 2) != 0)
    {
      goto LABEL_3;
    }

    return 0;
  }

  if ((v6 & 2) == 0)
  {
    return 0;
  }

LABEL_3:
  v7 = (*(**a1 + 40))(*a1, a2);
  if (v7 < (*(**a1 + 40))(*a1, a3))
  {
    return 1;
  }

  v8 = (*(**a1 + 40))(*a1, a2);
  if (v8 > (*(**a1 + 40))(*a1, a3) || (a1[2] & 4) == 0)
  {
    return 0;
  }

  v9 = *a1;
  v26 = 0;
  (*(*v9 + 136))(v9, a2, v24);
  v10 = *a1;
  v23 = 0;
  (*(*v10 + 136))(v10, a3, v21);
  while (1)
  {
    if (v24[0])
    {
      if ((*(*v24[0] + 24))(v24[0]))
      {
        goto LABEL_36;
      }
    }

    else if (v26 >= v24[2])
    {
      goto LABEL_36;
    }

    if (v21[0])
    {
      if ((*(*v21[0] + 24))(v21[0]))
      {
        goto LABEL_36;
      }
    }

    else if (v23 >= v21[2])
    {
LABEL_36:
      v18 = 0;
      v19 = 1;
      goto LABEL_39;
    }

    if (v24[0])
    {
      v11 = (*(*v24[0] + 32))(v24[0]);
    }

    else
    {
      v11 = (v24[1] + 16 * v26);
    }

    if (v21[0])
    {
      v12 = (*(*v21[0] + 32))(v21[0]);
    }

    else
    {
      v12 = (v21[1] + 16 * v23);
    }

    if (*v11 < *v12)
    {
      goto LABEL_37;
    }

    if (*v11 > *v12)
    {
      break;
    }

    v13 = *(a1[1] + 80);
    v14 = *(v13 + 4 * v11[3]);
    v15 = *(v13 + 4 * v12[3]);
    if (v14 < v15)
    {
LABEL_37:
      v19 = 0;
      v18 = 1;
      goto LABEL_39;
    }

    if (v14 > v15)
    {
      break;
    }

    if (v24[0])
    {
      (*(*v24[0] + 40))(v24[0]);
    }

    else
    {
      ++v26;
    }

    if (v21[0])
    {
      (*(*v21[0] + 40))(v21[0]);
    }

    else
    {
      ++v23;
    }
  }

  v19 = 0;
  v18 = 0;
LABEL_39:
  if (v21[0])
  {
    (*(*v21[0] + 8))(v21[0]);
  }

  else if (v22)
  {
    --*v22;
  }

  if (v24[0])
  {
    (*(*v24[0] + 8))(v24[0]);
  }

  else if (v25)
  {
    --*v25;
  }

  if (v19)
  {
    return 0;
  }

  return v18;
}

void sub_1B5A74BB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, _DWORD *a17)
{
  if (a14)
  {
    (*(*a14 + 8))(a14);
  }

  else if (a17)
  {
    --*a17;
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::find<int>(uint64_t a1, unsigned int *a2)
{
  v2 = a1 + 8;
  v3 = *(a1 + 8);
  if (!v3)
  {
    return v2;
  }

  v6 = a1 + 8;
  do
  {
    v7 = fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::operator()((a1 + 24), *(v3 + 28), *a2);
    if (v7)
    {
      v8 = 8;
    }

    else
    {
      v8 = 0;
    }

    if (!v7)
    {
      v6 = v3;
    }

    v3 = *(v3 + v8);
  }

  while (v3);
  if (v6 == v2 || fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::operator()((a1 + 24), *a2, *(v6 + 28)))
  {
    return v2;
  }

  return v6;
}

void fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::CyclicMinimizer(uint64_t a1, uint64_t a2)
{
  v3 = (*(*a2 + 64))(a2, 0x40000, 1);
  *(a1 + 200) = 0u;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 72) = 0u;
  *(a1 + 88) = 0u;
  *(a1 + 104) = 0u;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = v3 == 0;
  *(a1 + 192) = 2;
  *(a1 + 196) = 0;
  *(a1 + 216) = 0u;
  *(a1 + 232) = 0u;
  *(a1 + 184) = &unk_1F2CFB7B0;
  fst::VectorFst<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::VectorState<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>>::VectorFst();
}

void sub_1B5A74E14(_Unwind_Exception *a1)
{
  std::deque<int>::~deque[abi:ne200100](v2);
  fst::Partition<int>::~Partition(v1);
  _Unwind_Resume(a1);
}

void fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::Initialize(uint64_t a1, uint64_t a2)
{
  fst::Reverse<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>(a2, (a1 + 248), 1);
  fst::ArcSort<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::ILabelCompare<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>(a1 + 248);
  fst::Partition<int>::Initialize(a1, (((*(*(a1 + 256) + 72) - *(*(a1 + 256) + 64)) << 29) - 0x100000000) >> 32);
  fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::PrePartition(a1, a2);
  operator new();
}

uint64_t fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::Compute(uint64_t result)
{
  v1 = *(result + 240);
  if (v1)
  {
    v2 = result;
    do
    {
      v3 = *(*(v2[26] + ((v2[29] >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v2[29] & 0x3FFLL));
      ++v2[29];
      v2[30] = v1 - 1;
      std::deque<int>::__maybe_remove_front_spare[abi:ne200100]((v2 + 25), 1);
      result = fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::Split(v2, v3);
      v1 = v2[30];
    }

    while (v1);
  }

  return result;
}

void fst::ArcSort<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::ILabelCompare<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>(uint64_t a1)
{
  v1[0] = a1;
  v1[1] = &v4;
  *__p = 0u;
  v3 = 0u;
  fst::StateMap<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::ArcSortMapper<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::ILabelCompare<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>>(a1, v1);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1B5A74F90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::PrePartition(uint64_t a1, uint64_t a2)
{
  if (FLAGS_v >= 5)
  {
    std::string::basic_string[abi:ne200100]<0>(&__p, "INFO");
    v4 = fst::LogMessage::LogMessage(&v33, &__p);
    v5 = fst::cerr(v4);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v5, "PrePartition", 12);
    fst::LogMessage::~LogMessage(&v33);
    if (SHIBYTE(v38) < 0)
    {
      operator delete(__p);
    }
  }

  v38 = 0;
  v39 = a2;
  v40 = a1;
  v41 = 1;
  __p = &v37;
  v37 = 0;
  v35 = 0;
  (*(*a2 + 128))(a2, &v33);
  v6 = fst::Partition<int>::AddClass(a1);
  if (v33)
  {
    v7 = (*(*v33 + 24))(v33);
  }

  else
  {
    v7 = v35;
  }

  v8 = *(*(a1 + 8) + 8 * v7);
  v9 = *(a1 + 32);
  v10 = *(v9 + 8 * v6);
  if (v10)
  {
    *(v10 + 16) = v8;
    v10 = *(v9 + 8 * v6);
  }

  *(v8 + 8) = v10;
  *(v8 + 16) = 0;
  *(v9 + 8 * v6) = v8;
  *(*(a1 + 80) + 4 * v7) = v6;
  ++*(*(a1 + 104) + 4 * v6);
  if (v33)
  {
    v11 = (*(*v33 + 24))(v33);
  }

  else
  {
    v11 = v35;
  }

  v32 = v11;
  v30[0] = &v32;
  *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&__p, &v32) + 32) = v6;
  LODWORD(v30[0]) = v6;
  std::deque<int>::push_front((a1 + 200), v30);
  v12 = v33;
  if (v33)
  {
    goto LABEL_28;
  }

  ++v35;
  while (v33)
  {
    if ((*(*v33 + 16))(v33))
    {
      goto LABEL_30;
    }

    if (!v33)
    {
      goto LABEL_19;
    }

    v13 = (*(*v33 + 24))(v33);
LABEL_20:
    v32 = v13;
    v14 = std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::find<int>(&__p, &v32);
    if (&v37 == v14)
    {
      v21 = fst::Partition<int>::AddClass(a1);
      v22 = v21;
      v23 = v32;
      v24 = *(*(a1 + 8) + 8 * v32);
      v25 = *(a1 + 32);
      v26 = *(v25 + 8 * v21);
      if (v26)
      {
        *(v26 + 16) = v24;
        v26 = *(v25 + 8 * v21);
      }

      *(v24 + 8) = v26;
      *(v24 + 16) = 0;
      *(v25 + 8 * v21) = v24;
      *(*(a1 + 80) + 4 * v23) = v21;
      ++*(*(a1 + 104) + 4 * v21);
      v30[0] = &v32;
      *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&__p, &v32) + 32) = v21;
      LODWORD(v30[0]) = v22;
      std::deque<int>::push_front((a1 + 200), v30);
    }

    else
    {
      v15 = v32;
      v16 = *(v14 + 32);
      v17 = *(*(a1 + 8) + 8 * v32);
      v18 = *(a1 + 32);
      v19 = *(v18 + 8 * v16);
      if (v19)
      {
        *(v19 + 16) = v17;
        v19 = *(v18 + 8 * v16);
      }

      *(v17 + 8) = v19;
      *(v17 + 16) = 0;
      *(v18 + 8 * v16) = v17;
      *(*(a1 + 80) + 4 * v15) = v16;
      ++*(*(a1 + 104) + 4 * v16);
      v20 = *(v14 + 32);
      v30[0] = &v32;
      *(std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,fst::StateComparator<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,false>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(&__p, &v32) + 32) = v20;
    }

    v12 = v33;
    if (v33)
    {
LABEL_28:
      (*(*v33 + 32))(v12);
    }

    else
    {
      ++v35;
    }
  }

  if (v35 < v34)
  {
LABEL_19:
    v13 = v35;
    goto LABEL_20;
  }

LABEL_30:
  if (FLAGS_v >= 5)
  {
    std::string::basic_string[abi:ne200100]<0>(v30, "INFO");
    v27 = fst::LogMessage::LogMessage(&v32, v30);
    v28 = fst::cerr(v27);
    v29 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v28, "Initial Partition: ", 19);
    MEMORY[0x1B8C84C00](v29, (*(a1 + 40) - *(a1 + 32)) >> 3);
    fst::LogMessage::~LogMessage(&v32);
    if (v31 < 0)
    {
      operator delete(v30[0]);
    }
  }

  if (v33)
  {
    (*(*v33 + 8))(v33);
  }

  std::__tree<int>::destroy(&__p, v37);
}

void sub_1B5A75414(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21, int a22, __int16 a23, char a24, char a25)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (a17)
  {
    (*(*a17 + 8))(a17);
  }

  std::__tree<int>::destroy(&a20, a21);
  _Unwind_Resume(a1);
}

uint64_t fst::StateMap<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::ArcSortMapper<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::ILabelCompare<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>>(uint64_t a1, void *a2)
{
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    v5 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
    v6 = (*(**a2 + 24))();
    (*(*a1 + 176))(a1, v6);
    if ((*(*a1 + 160))(a1) >= 1)
    {
      v7 = 0;
      do
      {
        v8 = fst::ArcSortMapper<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::ILabelCompare<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>::SetState(a2, v7);
        (*(*a1 + 240))(a1, v7, v8);
        for (i = a2[5]; ; a2[5] = i)
        {
          v10 = a2[2];
          if (i >= (a2[3] - v10) >> 4)
          {
            break;
          }

          (*(*a1 + 208))(a1, v7, v10 + 16 * i);
          i = a2[5] + 1;
        }

        (*(**a2 + 32))(*a2, v7);
        (*(*a1 + 184))(a1, v7);
        v7 = (v7 + 1);
      }

      while (v7 < (*(*a1 + 160))(a1));
    }

    v11 = *(*a1 + 192);

    return v11(a1, v5 & 0x3FFF0FFF0007 | (((v5 >> 16) & 1) << 30) | 0x10000000, 0x3FFFFFFF0007);
  }

  return result;
}

double fst::ArcSortMapper<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::ILabelCompare<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>::SetState(void *a1, uint64_t a2)
{
  a1[5] = 0;
  v4 = a1 + 2;
  a1[3] = a1[2];
  v5 = (*(**a1 + 40))(*a1);
  std::vector<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>::reserve(v4, v5);
  v6 = *a1;
  v16 = 0;
  (*(*v6 + 136))(v6, a2, v14);
  while (1)
  {
    if (!v14[0])
    {
      if (v16 >= v14[2])
      {
        goto LABEL_13;
      }

LABEL_7:
      v8 = (v14[1] + 16 * v16);
      goto LABEL_8;
    }

    if ((*(*v14[0] + 24))(v14[0]))
    {
      break;
    }

    if (!v14[0])
    {
      goto LABEL_7;
    }

    v8 = (*(*v14[0] + 32))();
LABEL_8:
    std::vector<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>::push_back[abi:ne200100](v4, v8);
    if (v14[0])
    {
      (*(*v14[0] + 40))(v14[0]);
    }

    else
    {
      ++v16;
    }
  }

  if (v14[0])
  {
    (*(*v14[0] + 8))();
    goto LABEL_15;
  }

LABEL_13:
  if (v15)
  {
    --*v15;
  }

LABEL_15:
  v9 = a1[2];
  v10 = a1[3];
  v11 = 126 - 2 * __clz(v10 - v9);
  if (v10 == v9)
  {
    v12 = 0;
  }

  else
  {
    v12 = v11;
  }

  *&result = std::__introsort<std::_ClassicAlgPolicy,fst::ILabelCompare<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>> &,fst::ArcTpl<fst::TropicalWeightTpl<float>,int>*,false>(v9, v10, v14, v12, 1, v7).n128_u64[0];
  return result;
}

void sub_1B5A75940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    fst::ArcSortMapper<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::ILabelCompare<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>::SetState();
  }

  else
  {
    fst::ComposeFstImpl<fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::SequenceComposeFilter<fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>,fst::GenericComposeStateTable<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::IntegerFilterState<signed char>,fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::CompactHashStateTable<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::ComposeHash<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>>>>>::OrderedExpand<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>(&a10);
  }

  _Unwind_Resume(a1);
}

uint64_t fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::Split(void *a1, int a2)
{
  for (i = *(a1[4] + 8 * a2); i; i = *(i + 1))
  {
    if (*(*(*(a1[32] + 64) + 8 * (*i + 1)) + 32) != *(*(*(a1[32] + 64) + 8 * (*i + 1)) + 24))
    {
      operator new();
    }
  }

  v4 = a1[33];
  v5 = *v4;
  v6 = (v4 + 8);
  v7 = *(v4 + 8);
  if (*v4 != v7)
  {
    v8 = -1;
    while (1)
    {
      v9 = *v5;
      v36 = *(v4 + 24);
      v10 = (v7 - v5) >> 3;
      if (v10 >= 2)
      {
        v11 = *v5;
        v12 = std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::ArcIterCompare &,std::__wrap_iter<fst::ArcIterator<fst::Fst<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>> **>>(v5, &v36, v10);
        v13 = (v7 - 8);
        if ((v7 - 8) == v12)
        {
          *v12 = v11;
        }

        else
        {
          *v12 = *v13;
          *v13 = v11;
          std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::ArcIterCompare &,std::__wrap_iter<fst::ArcIterator<fst::Fst<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>> **>>(v5, (v12 + 1), &v36, v12 + 1 - v5);
        }
      }

      *v6 -= 8;
      if (!*v9)
      {
        break;
      }

      v14 = (*(**v9 + 24))(*v9);
      v15 = *v9;
      if ((v14 & 1) == 0)
      {
        if (v15)
        {
          v17 = (*(*v15 + 32))(v15);
          if (*v9)
          {
            v18 = (*(**v9 + 32))(*v9);
            goto LABEL_24;
          }
        }

        else
        {
LABEL_22:
          v17 = (v9[1] + 16 * v9[4]);
        }

        v18 = v9[1] + 16 * v9[4];
LABEL_24:
        v19 = *(v18 + 12);
        v20 = *v17;
        if (v8 != *v17)
        {
          fst::Partition<int>::FinalizeSplit<fst::LifoQueue<int>>(a1, (a1 + 23));
        }

        if (*(a1[13] + 4 * *(a1[10] + 4 * (v19 - 1))) >= 2u)
        {
          fst::Partition<int>::SplitOn(a1, v19 - 1);
        }

        if (*v9)
        {
          (*(**v9 + 40))(*v9);
          if (*v9)
          {
            if ((*(**v9 + 24))(*v9))
            {
              if (*v9)
              {
                (*(**v9 + 8))(*v9);
                goto LABEL_39;
              }

LABEL_37:
              v25 = v9[3];
              if (v25)
              {
                --*v25;
              }

LABEL_39:
              MEMORY[0x1B8C85350](v9, 0x1070C401ACC3EEFLL);
LABEL_51:
              v8 = v20;
              goto LABEL_52;
            }

LABEL_35:
            v21 = a1[33];
            v23 = *(v21 + 8);
            v22 = *(v21 + 16);
            if (v23 >= v22)
            {
              v26 = (v23 - *v21) >> 3;
              if ((v26 + 1) >> 61)
              {
                std::vector<int>::__throw_length_error[abi:ne200100]();
              }

              v27 = v22 - *v21;
              v28 = v27 >> 2;
              if (v27 >> 2 <= (v26 + 1))
              {
                v28 = v26 + 1;
              }

              if (v27 >= 0x7FFFFFFFFFFFFFF8)
              {
                v29 = 0x1FFFFFFFFFFFFFFFLL;
              }

              else
              {
                v29 = v28;
              }

              if (v29)
              {
                std::__allocate_at_least[abi:ne200100]<std::allocator<kaldi::CuWorkspace *>>(a1[33], v29);
              }

              v30 = (8 * v26);
              *v30 = v9;
              v24 = 8 * v26 + 8;
              v31 = *(v21 + 8) - *v21;
              v32 = v30 - v31;
              memcpy(v30 - v31, *v21, v31);
              v33 = *v21;
              *v21 = v32;
              *(v21 + 8) = v24;
              *(v21 + 16) = 0;
              if (v33)
              {
                operator delete(v33);
              }
            }

            else
            {
              *v23 = v9;
              v24 = (v23 + 1);
            }

            *(v21 + 8) = v24;
            v34 = *v21;
            v36 = *(v21 + 24);
            std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::ArcIterCompare &,std::__wrap_iter<fst::ArcIterator<fst::Fst<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>> **>>(v34, v24, &v36, (v24 - v34) >> 3);
            goto LABEL_51;
          }
        }

        else
        {
          ++v9[4];
        }

        if (v9[4] >= v9[2])
        {
          goto LABEL_37;
        }

        goto LABEL_35;
      }

      if (!v15)
      {
        goto LABEL_16;
      }

      (*(*v15 + 8))(v15);
LABEL_18:
      MEMORY[0x1B8C85350](v9, 0x1070C401ACC3EEFLL);
LABEL_52:
      v4 = a1[33];
      v5 = *v4;
      v6 = (v4 + 8);
      v7 = *(v4 + 8);
      if (*v4 == v7)
      {
        return fst::Partition<int>::FinalizeSplit<fst::LifoQueue<int>>(a1, (a1 + 23));
      }
    }

    if (v9[4] < v9[2])
    {
      goto LABEL_22;
    }

LABEL_16:
    v16 = v9[3];
    if (v16)
    {
      --*v16;
    }

    goto LABEL_18;
  }

  return fst::Partition<int>::FinalizeSplit<fst::LifoQueue<int>>(a1, (a1 + 23));
}

BOOL std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::ArcIterCompare &,std::__wrap_iter<fst::ArcIterator<fst::Fst<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>> **>>(_BOOL8 result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = (result + 8 * (v4 >> 1));
    v9 = (a2 - 8);
    result = fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::ArcIterCompare::operator()(a3, *v8, *(a2 - 8));
    if (result)
    {
      v10 = *v9;
      do
      {
        v11 = v8;
        *v9 = *v8;
        if (!v7)
        {
          break;
        }

        v7 = (v7 - 1) >> 1;
        v8 = (v6 + 8 * v7);
        result = fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::ArcIterCompare::operator()(a3, *v8, v10);
        v9 = v11;
      }

      while (result);
      *v11 = v10;
    }
  }

  return result;
}

BOOL fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::ArcIterCompare::operator()(uint64_t a1, void *a2, void *a3)
{
  if (*a2)
  {
    v4 = (*(**a2 + 32))(*a2);
  }

  else
  {
    v4 = (a2[1] + 16 * a2[4]);
  }

  if (*a3)
  {
    v5 = (*(**a3 + 32))(*a3);
  }

  else
  {
    v5 = (a3[1] + 16 * a3[4]);
  }

  return *v4 > *v5;
}

void **std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::ArcIterCompare &,std::__wrap_iter<fst::ArcIterator<fst::Fst<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>> **>>(void *a1, uint64_t a2, uint64_t a3)
{
  v6 = 0;
  v7 = (a3 - 2) / 2;
  do
  {
    v8 = &a1[v6 + 1];
    v9 = (2 * v6) | 1;
    v10 = 2 * v6 + 2;
    if (v10 < a3)
    {
      v11 = fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::ArcIterCompare::operator()(a2, *v8, a1[v6 + 2]);
      if (v11)
      {
        v12 = 8;
      }

      else
      {
        v12 = 0;
      }

      v8 = (v8 + v12);
      if (v11)
      {
        v9 = v10;
      }
    }

    *a1 = *v8;
    a1 = v8;
    v6 = v9;
  }

  while (v9 <= v7);
  return v8;
}

void *fst::CyclicMinimizer<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::LifoQueue<int>>::~CyclicMinimizer(void *a1)
{
  v2 = a1[33];
  if (v2)
  {
    v3 = *v2;
    if (*v2)
    {
      *(v2 + 8) = v3;
      operator delete(v3);
    }

    MEMORY[0x1B8C85350](v2, 0xE0C40DD5D8FE3);
  }

  fst::ImplToFst<fst::VectorFstImpl<fst::VectorState<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>>,fst::MutableFst<fst::ReverseArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>>::~ImplToFst(a1 + 31);
  std::deque<int>::~deque[abi:ne200100](a1 + 25);

  return fst::Partition<int>::~Partition(a1);
}

uint64_t fst::StateMap<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::ArcUniqueMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>(uint64_t a1, uint64_t *a2)
{
  result = (*(*a1 + 24))(a1);
  if (result != -1)
  {
    v5 = (*(*a1 + 64))(a1, 0x3FFFFFFF0007, 0);
    v6 = (*(**a2 + 24))();
    (*(*a1 + 176))(a1, v6);
    if ((*(*a1 + 160))(a1) >= 1)
    {
      v7 = 0;
      do
      {
        fst::ArcUniqueMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::SetState(a2, v7);
        (*(*a1 + 240))(a1, v7);
        for (i = a2[5]; ; a2[5] = i)
        {
          v9 = a2[2];
          if (i >= (a2[3] - v9) >> 4)
          {
            break;
          }

          (*(*a1 + 208))(a1, v7, v9 + 16 * i);
          i = a2[5] + 1;
        }

        (*(**a2 + 32))(*a2, v7);
        (*(*a1 + 184))(a1, v7);
        v7 = (v7 + 1);
      }

      while (v7 < (*(*a1 + 160))(a1));
    }

    v10 = *(*a1 + 192);

    return v10(a1, v5 & 0xA6A0A950007, 0x3FFFFFFF0007);
  }

  return result;
}

void fst::ArcUniqueMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>>::SetState(uint64_t *a1, uint64_t a2)
{
  a1[5] = 0;
  v4 = a1 + 2;
  a1[3] = a1[2];
  v5 = (*(**a1 + 40))(*a1);
  std::vector<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>::reserve(v4, v5);
  v6 = *a1;
  v15 = 0;
  (*(*v6 + 136))(v6, a2, v13);
  while (1)
  {
    if (!v13[0])
    {
      if (v15 >= v13[2])
      {
        goto LABEL_13;
      }

LABEL_7:
      v7 = (v13[1] + 16 * v15);
      goto LABEL_8;
    }

    if ((*(*v13[0] + 24))(v13[0]))
    {
      break;
    }

    if (!v13[0])
    {
      goto LABEL_7;
    }

    v7 = (*(*v13[0] + 32))();
LABEL_8:
    std::vector<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>::push_back[abi:ne200100](v4, v7);
    if (v13[0])
    {
      (*(*v13[0] + 40))(v13[0]);
    }

    else
    {
      ++v15;
    }
  }

  if (v13[0])
  {
    (*(*v13[0] + 8))();
    goto LABEL_15;
  }

LABEL_13:
  if (v14)
  {
    --*v14;
  }

LABEL_15:
  v8 = a1[2];
  v9 = a1[3];
  v10 = 126 - 2 * __clz((v9 - v8) >> 4);
  if (v9 == v8)
  {
    v11 = 0;
  }

  else
  {
    v11 = v10;
  }

  std::__introsort<std::_ClassicAlgPolicy,fst::ArcUniqueMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>::Compare &,fst::ArcTpl<fst::TropicalWeightTpl<float>,int>*,false>(v8, v9, v13, v11, 1);
  v12 = std::__unique[abi:ne200100]<std::_ClassicAlgPolicy,std::__wrap_iter<fst::ArcTpl<fst::TropicalWeightTpl<float>,int> *>,std::__wrap_iter<fst::ArcTpl<fst::TropicalWeightTpl<float>,int> *>,fst::ArcUniqueMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>::Equal &>(a1[2], a1[3], v13);
  std::vector<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>::resize(v4, (v12 - a1[2]) >> 4);
}

void sub_1B5A765A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    fst::ArcSortMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::OLabelCompare<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>::SetState();
  }

  else
  {
    fst::ComposeFstImpl<fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::SequenceComposeFilter<fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>,fst::GenericComposeStateTable<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::IntegerFilterState<signed char>,fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::CompactHashStateTable<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::ComposeHash<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>>>>>::OrderedExpand<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>(&a10);
  }

  _Unwind_Resume(a1);
}

void fst::RmFinalEpsilon<fst::ArcTpl<fst::LogWeightTpl<float>,int>>(uint64_t a1)
{
  memset(v4, 0, sizeof(v4));
  memset(v3, 0, sizeof(v3));
  v2 = 0;
  v1[0] = 0;
  v1[1] = v4;
  v1[2] = v3;
  v1[3] = &v2;
  fst::DfsVisit<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::SccVisitor<fst::ArcTpl<fst::LogWeightTpl<float>,int>>,fst::AnyArcFilter<fst::ArcTpl<fst::LogWeightTpl<float>,int>>>(a1, v1);
}

void sub_1B5A76DF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, char a21)
{
  if (__p)
  {
    operator delete(__p);
  }

  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(&a21);
  v23 = *(v21 - 144);
  if (v23)
  {
    operator delete(v23);
  }

  v24 = *(v21 - 120);
  if (v24)
  {
    operator delete(v24);
  }

  _Unwind_Resume(a1);
}

uint64_t std::vector<PathData>::__init_with_size[abi:ne200100]<PathData*,PathData*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<PathData>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1B5A76FDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<PathData>::__vallocate[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 59))
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<PathData>>(a1, a2);
  }

  std::vector<int>::__throw_length_error[abi:ne200100]();
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<PathData>,PathData*,PathData*,PathData*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      *(v4 + 8) = 0;
      *(v4 + 16) = 0;
      std::vector<int>::__init_with_size[abi:ne200100]<int *,int *>(v4, *v6, *(v6 + 8), (*(v6 + 8) - *v6) >> 2);
      *(v4 + 24) = *(v6 + 24);
      v6 += 32;
      v4 = v11 + 32;
      v11 += 32;
    }

    while (v6 != a3);
  }

  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<PathData>,PathData*>>::~__exception_guard_exceptions[abi:ne200100](v8);
  return v4;
}

uint64_t std::vector<WordPron>::__construct_one_at_end[abi:ne200100]<WordPron const&>(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 8);
  *v4 = 0;
  *(v4 + 8) = 0;
  *(v4 + 16) = 0;
  result = std::vector<std::string>::__init_with_size[abi:ne200100]<std::string*,std::string*>(v4, *a2, *(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((*(a2 + 8) - *a2) >> 3));
  *(v4 + 24) = *(a2 + 24);
  *(a1 + 8) = v4 + 32;
  return result;
}

uint64_t std::vector<WordPron>::__emplace_back_slow_path<WordPron const&>(uint64_t a1, uint64_t a2)
{
  v2 = (*(a1 + 8) - *a1) >> 5;
  v3 = v2 + 1;
  if ((v2 + 1) >> 59)
  {
    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  v6 = *(a1 + 16) - *a1;
  if (v6 >> 4 > v3)
  {
    v3 = v6 >> 4;
  }

  if (v6 >= 0x7FFFFFFFFFFFFFE0)
  {
    v7 = 0x7FFFFFFFFFFFFFFLL;
  }

  else
  {
    v7 = v3;
  }

  v18 = a1;
  if (v7)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<quasar::TextTokenizer::TokenString>>(a1, v7);
  }

  v8 = 32 * v2;
  v15 = 0;
  v16 = v8;
  v17 = v8;
  *v8 = 0;
  *(v8 + 8) = 0;
  *(v8 + 16) = 0;
  std::vector<std::string>::__init_with_size[abi:ne200100]<std::string*,std::string*>(v8, *a2, *(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((*(a2 + 8) - *a2) >> 3));
  *(v8 + 24) = *(a2 + 24);
  *&v17 = v17 + 32;
  v9 = *(a1 + 8);
  v10 = v16 + *a1 - v9;
  std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<WordPron>,WordPron*>(a1, *a1, v9, v10);
  v11 = *a1;
  *a1 = v10;
  v12 = *(a1 + 16);
  v14 = v17;
  *(a1 + 8) = v17;
  *&v17 = v11;
  *(&v17 + 1) = v12;
  v15 = v11;
  v16 = v11;
  std::__split_buffer<WordPron>::~__split_buffer(&v15);
  return v14;
}

void sub_1B5A77288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<WordPron>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<WordPron>,WordPron*>(uint64_t a1, void **a2, void **a3, uint64_t a4)
{
  v11 = a4;
  v10 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  if (a2 == a3)
  {
    v9 = 1;
  }

  else
  {
    v5 = a2;
    v6 = a2;
    do
    {
      *a4 = 0;
      *(a4 + 8) = 0;
      *(a4 + 16) = 0;
      *a4 = *v6;
      *(a4 + 16) = v6[2];
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      *(a4 + 24) = *(v6 + 6);
      v6 += 4;
      a4 += 32;
    }

    while (v6 != a3);
    v11 = a4;
    v9 = 1;
    while (v5 != a3)
    {
      v12 = v5;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v12);
      v5 += 4;
    }
  }

  return std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<WordPron>,WordPron*>>::~__exception_guard_exceptions[abi:ne200100](v8);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<WordPron>,WordPron*>>::~__exception_guard_exceptions[abi:ne200100](uint64_t a1)
{
  if ((*(a1 + 24) & 1) == 0)
  {
    std::_AllocatorDestroyRangeReverse<std::allocator<WordPron>,WordPron*>::operator()[abi:ne200100](a1);
  }

  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<WordPron>,WordPron*>::operator()[abi:ne200100](uint64_t a1)
{
  v1 = **(a1 + 16);
  v2 = **(a1 + 8);
  while (v1 != v2)
  {
    v1 -= 4;
    v3 = v1;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v3);
  }
}

void **std::__split_buffer<WordPron>::~__split_buffer(void **a1)
{
  std::__split_buffer<WordPron>::clear[abi:ne200100](a1);
  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::__split_buffer<WordPron>::clear[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 8);
  for (i = *(a1 + 16); i != v2; i = *(a1 + 16))
  {
    v4 = (i - 32);
    *(a1 + 16) = v4;
    v5 = v4;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v5);
  }
}

uint64_t quasar::InputHammerOptions::options@<X0>(quasar::InputHammerOptions *this@<X0>, void *a2@<X8>)
{
  v4 = *MEMORY[0x1E69E9840];
  v3[0] = this + 16;
  v3[1] = this + 176;
  v3[2] = this + 336;
  v3[3] = this + 496;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  return std::vector<quasar::OptionValueBase *>::__init_with_size[abi:ne200100]<quasar::OptionValueBase * const*,quasar::OptionValueBase * const*>(a2, v3, &v4, 4uLL);
}

uint64_t quasar::InputHammerBlock::init(quasar::InputHammerBlock *this)
{
  quasar::OptionValue<std::string>::value(this + 3);

  return kaldi::quasar::InputHammer::ReadRaw(this + 648);
}

uint64_t virtual thunk toquasar::InputHammerBlock::init(quasar::InputHammerBlock *this)
{
  v1 = this + *(*this - 88);
  quasar::OptionValue<std::string>::value(v1 + 3);

  return kaldi::quasar::InputHammer::ReadRaw((v1 + 648));
}

void quasar::InputHammerBlock::process(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (*a3 == *(a3 + 8))
  {
    v13 = a1 + *(*a1 - 24);

    quasar::ProcessingBlock::send(v13, a3, 0);
  }

  else
  {
    quasar::TranslationPhraseInternal::convertTokensToString(v52, *a3);
    memset(&v51, 0, sizeof(v51));
    v5 = quasar::OptionValue<std::string>::value(a1 + 43);
    kaldi::quasar::InputHammer::FilterTags((a1 + 81), v52, &v51, v5);
    v48 = 0;
    v49 = 0;
    v50 = 0;
    kaldi::SplitStringToVector(&v51, " ", 1, &v48);
    quasar::TranslationPhraseInternal::TranslationPhraseInternal(v31);
    v6 = v48;
    for (i = v49; v6 != i; ++v6)
    {
      v21 = 0;
      v22 = 0;
      v23 = 0;
      memset(&v19, 0, sizeof(v19));
      v20 = 0;
      v24 = 3212836864;
      v25 = -1;
      v26 = 0u;
      v27 = 0u;
      __p = 0u;
      v29 = 0;
      v30 = -1;
      std::string::operator=(&v19, v6);
      LOBYTE(v20) = 1;
      v8 = v43;
      if (v43 >= v44)
      {
        v9 = std::vector<quasar::TranslationTokenInternal>::__emplace_back_slow_path<quasar::TranslationTokenInternal const&>(&v42, &v19);
      }

      else
      {
        quasar::TranslationTokenInternal::TranslationTokenInternal(v43, &v19);
        v9 = (v8 + 136);
      }

      v43 = v9;
      if (__p)
      {
        *(&__p + 1) = __p;
        operator delete(__p);
      }

      if (SBYTE7(v27) < 0)
      {
        operator delete(v26);
      }

      if (v21)
      {
        v22 = v21;
        operator delete(v21);
      }

      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v19.__r_.__value_.__l.__data_);
      }
    }

    if (v42 != v43)
    {
      v43[-5].__r_.__value_.__s.__data_[8] = 0;
    }

    quasar::PTree::PTree(&v19);
    if ((*quasar::OptionValue<BOOL>::value(a1 + 63) & 1) == 0)
    {
      v10 = quasar::MetaInfo::get((*a3 + 256));
      LODWORD(v19.__r_.__value_.__l.__data_) = *v10;
      std::string::operator=(&v19.__r_.__value_.__r.__words[1], (v10 + 8));
      if (&v19 != v10)
      {
        std::vector<std::pair<std::string,quasar::PTree>>::__assign_with_size[abi:ne200100]<std::pair<std::string,quasar::PTree>*,std::pair<std::string,quasar::PTree>*>(&v21, *(v10 + 32), *(v10 + 40), 0x2E8BA2E8BA2E8BA3 * ((*(v10 + 40) - *(v10 + 32)) >> 3));
      }

      LOBYTE(v24) = *(v10 + 56);
    }

    std::string::basic_string[abi:ne200100]<0>(v17, "prefilter input");
    quasar::PTree::PTree(&v14, v52);
    quasar::PTree::putChild(&v19, v17, &v14, 1);
    quasar::PTree::~PTree(&v14);
    if (v18 < 0)
    {
      operator delete(v17[0]);
    }

    quasar::MetaInfo::replace(&v47, &v19);
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v11 = std::vector<quasar::TranslationPhraseInternal>::__emplace_back_slow_path<quasar::TranslationPhraseInternal const&>(&v14, v31);
    v12 = *a1;
    v15 = v11;
    quasar::ProcessingBlock::send(a1 + *(v12 - 24), &v14, 0);
    v17[0] = &v14;
    std::vector<quasar::TranslationPhraseInternal>::__destroy_vector::operator()[abi:ne200100](v17);
    quasar::PTree::~PTree(&v19);
    quasar::MetaInfo::~MetaInfo(&v47);
    if (v46 < 0)
    {
      operator delete(v45);
    }

    v19.__r_.__value_.__r.__words[0] = &v42;
    std::vector<quasar::TranslationTokenInternal>::__destroy_vector::operator()[abi:ne200100](&v19);
    v19.__r_.__value_.__r.__words[0] = &v41;
    std::vector<quasar::TranslationPhrase::SegmentInfo>::__destroy_vector::operator()[abi:ne200100](&v19);
    if (v39)
    {
      v40 = v39;
      operator delete(v39);
    }

    if (v38[24] == 1)
    {
      v19.__r_.__value_.__r.__words[0] = v38;
      std::vector<quasar::AlternativeSelectionSpan>::__destroy_vector::operator()[abi:ne200100](&v19);
    }

    if (v37 == 1 && v36 < 0)
    {
      operator delete(v35);
    }

    if (v34 < 0)
    {
      operator delete(v33);
    }

    v19.__r_.__value_.__r.__words[0] = &v32;
    std::vector<quasar::TranslationToken>::__destroy_vector::operator()[abi:ne200100](&v19);
    v31[0] = &v48;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](v31);
    if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v51.__r_.__value_.__l.__data_);
    }

    if (v53 < 0)
    {
      operator delete(v52[0]);
    }
  }
}

void sub_1B5A782B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42)
{
  quasar::PTree::~PTree(&a11);
  if (a24 < 0)
  {
    operator delete(__p);
  }

  quasar::PTree::~PTree(&a25);
  quasar::TranslationPhraseInternal::~TranslationPhraseInternal(&a42);
  a42 = v42 - 168;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&a42);
  if (*(v42 - 121) < 0)
  {
    operator delete(*(v42 - 144));
  }

  if (*(v42 - 97) < 0)
  {
    operator delete(*(v42 - 120));
  }

  _Unwind_Resume(a1);
}

void quasar::ConfiguredProcessingBlock<quasar::InputHammerOptions>::setContextProvider(uint64_t a1, uint64_t *a2)
{
  v3 = (*(*a1 + 8))(a1);
  (**v3)(&v10);
  v4 = v10;
  v5 = v11;
  if (v10 != v11)
  {
    do
    {
      v6 = *v4;
      v7 = a2[1];
      v8 = *a2;
      v9 = v7;
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      quasar::OptionValueBase::setContextProvider(v6, &v8);
      if (v9)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v9);
      }

      ++v4;
    }

    while (v4 != v5);
    v4 = v10;
  }

  if (v4)
  {
    v11 = v4;
    operator delete(v4);
  }
}

void sub_1B5A7847C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13)
{
  if (a11)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a11);
  }

  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void quasar::InputHammerBlock::~InputHammerBlock(quasar::InputHammerBlock *this)
{
  *this = off_1F2D410C8;
  v2 = (this + 760);
  *(this + 95) = &unk_1F2D41170;
  v3 = (this + 728);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v3);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table(this + 688);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(this + 648);
  *this = &unk_1F2D41208;
  *(this + 95) = off_1F2D41290;
  quasar::InputHammerOptions::~InputHammerOptions((this + 8));
  quasar::ProcessingBlock::~ProcessingBlock(v2);
}

{
  *this = off_1F2D410C8;
  v2 = (this + 760);
  *(this + 95) = &unk_1F2D41170;
  v3 = (this + 728);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v3);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table(this + 688);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(this + 648);
  *this = &unk_1F2D41208;
  *(this + 95) = off_1F2D41290;
  quasar::InputHammerOptions::~InputHammerOptions((this + 8));
  quasar::ProcessingBlock::~ProcessingBlock(v2);
  MEMORY[0x1B8C85350](this, 0x10F3C404F3F1B56);
}

void virtual thunk toquasar::InputHammerBlock::~InputHammerBlock(quasar::InputHammerBlock *this)
{
  v1 = this + *(*this - 24);
  *v1 = off_1F2D410C8;
  *(v1 + 95) = &unk_1F2D41170;
  v2 = (v1 + 728);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v2);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table((v1 + 688));
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((v1 + 648));
  *v1 = &unk_1F2D41208;
  *(v1 + 95) = off_1F2D41290;
  quasar::InputHammerOptions::~InputHammerOptions((v1 + 8));
  quasar::ProcessingBlock::~ProcessingBlock(v1 + 95);
}

{
  v1 = this + *(*this - 24);
  *v1 = off_1F2D410C8;
  *(v1 + 95) = &unk_1F2D41170;
  v2 = (v1 + 728);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v2);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table((v1 + 688));
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((v1 + 648));
  *v1 = &unk_1F2D41208;
  *(v1 + 95) = off_1F2D41290;
  quasar::InputHammerOptions::~InputHammerOptions((v1 + 8));
  quasar::ProcessingBlock::~ProcessingBlock(v1 + 95);
  MEMORY[0x1B8C85350](v1, 0x10F3C404F3F1B56);
}

void quasar::InputHammerOptions::~InputHammerOptions(quasar::InputHammerOptions *this)
{
  *this = &unk_1F2D41088;
  *(this + 62) = &unk_1F2CFCE10;
  std::__tree<std::string>::destroy(this + 616, *(this + 78));
  *(this + 62) = &unk_1F2D08890;
  v2 = *(this + 74);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  if (*(this + 575) < 0)
  {
    operator delete(*(this + 69));
  }

  if (*(this + 551) < 0)
  {
    operator delete(*(this + 66));
  }

  if (*(this + 527) < 0)
  {
    operator delete(*(this + 63));
  }

  *(this + 42) = &unk_1F2CFAFC8;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(this + 472, *(this + 60));
  if (*(this + 463) < 0)
  {
    operator delete(*(this + 55));
  }

  *(this + 42) = &unk_1F2D08890;
  v3 = *(this + 54);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  if (*(this + 415) < 0)
  {
    operator delete(*(this + 49));
  }

  if (*(this + 391) < 0)
  {
    operator delete(*(this + 46));
  }

  if (*(this + 367) < 0)
  {
    operator delete(*(this + 43));
  }

  *(this + 22) = &unk_1F2CFAFC8;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(this + 312, *(this + 40));
  if (*(this + 303) < 0)
  {
    operator delete(*(this + 35));
  }

  *(this + 22) = &unk_1F2D08890;
  v4 = *(this + 34);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  if (*(this + 255) < 0)
  {
    operator delete(*(this + 29));
  }

  if (*(this + 231) < 0)
  {
    operator delete(*(this + 26));
  }

  if (*(this + 207) < 0)
  {
    operator delete(*(this + 23));
  }

  *(this + 2) = &unk_1F2CFAFC8;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(this + 152, *(this + 20));
  if (*(this + 143) < 0)
  {
    operator delete(*(this + 15));
  }

  *(this + 2) = &unk_1F2D08890;
  v5 = *(this + 14);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v5);
  }

  if (*(this + 95) < 0)
  {
    operator delete(*(this + 9));
  }

  if (*(this + 71) < 0)
  {
    operator delete(*(this + 6));
  }

  if (*(this + 47) < 0)
  {
    operator delete(*(this + 3));
  }
}

void quasar::G2Embedding::G2Embedding(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v12 = a2[1];
  v15[0] = *a2;
  v15[1] = v12;
  if (v12)
  {
    atomic_fetch_add_explicit((v12 + 8), 1uLL, memory_order_relaxed);
  }

  v14[0] = 0;
  v14[1] = 0;
  std::string::basic_string[abi:ne200100]<0>(__p, "");
  quasar::QuasarG2PBase::QuasarG2PBase(a1, v15, v14, a4, a5, a6, a7);
}

void sub_1B5A790EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30, char a31)
{
  if (*(v32 - 129) < 0)
  {
    operator delete(*(v32 - 152));
  }

  if (*(v32 - 105) < 0)
  {
    operator delete(*(v32 - 128));
  }

  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&__p);
  locale = v31[47].__locale_;
  if (locale)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](locale);
  }

  std::unique_ptr<quasar::SentencePieceModule>::reset[abi:ne200100](&v31[45].__locale_, 0);
  quasar::QuasarG2PBase::~QuasarG2PBase(v31);
  _Unwind_Resume(a1);
}

void sub_1B5A7928C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a24 < 0)
  {
    operator delete(__p);
  }

  v25 = *(v24 - 96);
  if (v25)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v25);
  }

  v26 = *(v24 - 80);
  if (v26)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v26);
  }

  JUMPOUT(0x1B5A7927CLL);
}

void quasar::G2Embedding::normalizeToken(uint64_t a1@<X1>, std::string *a2@<X8>)
{
  if (*(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *a1, *(a1 + 8));
  }

  else
  {
    *&a2->__r_.__value_.__l.__data_ = *a1;
    a2->__r_.__value_.__r.__words[2] = *(a1 + 16);
  }
}

void quasar::G2Embedding::convertPhonemePronsToAllProns()
{
  memset(v0, 0, sizeof(v0));
  kaldi::KaldiWarnMessage::KaldiWarnMessage(v0);
  std::operator<<[abi:ne200100]<std::char_traits<char>>(v0, "Unimplemented");
  quasar::QuasarExceptionMessage::~QuasarExceptionMessage(v0);
}

uint64_t quasar::G2Embedding::FillMask(uint64_t a1, void *a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  v11 = *a2;
  v12 = (*(**a2 + 176))(*a2);
  result = (*(*v11 + 184))(v11, (v12 - 1));
  if (a3 == -1)
  {
    a3 = result;
  }

  if (a6)
  {
    if (a3 >= 1)
    {
      do
      {
        result = (*(**a2 + 96))(*a2, a4, a5);
        a5 = (a5 + 1);
        --a3;
      }

      while (a3);
    }
  }

  else if (a3 >= 1)
  {
    v14 = result;
    v15 = result - a3;
    do
    {
      result = (*(**a2 + 96))(*a2, a4, (a5 + v15++));
    }

    while (v15 < v14);
  }

  return result;
}

void quasar::G2Embedding::doG2P(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  v11 = *MEMORY[0x1E69E9840];
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v10, *a2, *(a2 + 8));
  }

  else
  {
    v10 = *a2;
  }

  memset(v8, 0, sizeof(v8));
  std::vector<std::string>::__init_with_size[abi:ne200100]<std::string const*,std::string const*>(v8, &v10, &v11, 1uLL);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }

  (*(*a1 + 24))(&v10, a1, v8, a3);
  v7 = v10.__r_.__value_.__r.__words[0];
  if (v10.__r_.__value_.__l.__size_ == v10.__r_.__value_.__r.__words[0])
  {
    std::vector<int>::__throw_out_of_range[abi:ne200100]();
  }

  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  std::vector<quasar::PronChoice>::__init_with_size[abi:ne200100]<quasar::PronChoice*,quasar::PronChoice*>(a4, *v7, v7[1], 0xCCCCCCCCCCCCCCCDLL * ((v7[1] - *v7) >> 3));
  v9 = &v10;
  std::vector<std::vector<quasar::PronChoice>>::__destroy_vector::operator()[abi:ne200100](&v9);
  v10.__r_.__value_.__r.__words[0] = v8;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v10);
}

void quasar::G2Embedding::Encode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v13[4] = *MEMORY[0x1E69E9840];
  v5 = *(a1 + 368);
  if (v5)
  {
    if (v6)
    {
      v7 = *(a1 + 376);
      if (v7)
      {
        atomic_fetch_add_explicit((v7 + 8), 1uLL, memory_order_relaxed);
      }
    }
  }

  else
  {
    v6 = 0;
  }

  v12[0] = *(a1 + 384);
  v12[1] = a3;
  memset(__p, 0, 24);
  std::vector<long long>::__init_with_size[abi:ne200100]<long long const*,long long const*>(__p, v12, v13, 2uLL);
  kaldi::CuMatrix<float>::CuMatrix(v12, *(a1 + 384), a3, 0, 0, 0);
  memset(__src, 0, sizeof(__src));
  ComputeEngine = kaldi::quasar::CEInferenceNet::GetComputeEngine(v6);
  (*(**ComputeEngine + 64))(&v11);
  __p[7] = __src;
  std::__allocate_at_least[abi:ne200100]<std::allocator<kaldi::CuWorkspace *>>(__src, 1uLL);
}

void sub_1B5A799D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t *a20, char a21)
{
  v23 = a20;
  a20 = 0;
  if (v23)
  {
    kaldi::quasar::TransducerAutoRegressiveDecodable::GatherOutputsBatch(v23);
  }

  a20 = &a9;
  std::vector<std::unique_ptr<kaldi::quasar::ComputeEngineBufferItf>>::__destroy_vector::operator()[abi:ne200100](&a20);
  kaldi::CuMatrix<float>::~CuMatrix(&a21);
  if (__p)
  {
    a13 = __p;
    operator delete(__p);
  }

  if (v21)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v21);
  }

  _Unwind_Resume(a1);
}

void quasar::G2Embedding::batchDoG2P(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  v15 = *MEMORY[0x1E69E9840];
  quasar::G2Embedding::batchGetRawEmbeddings(a1, a2, &v11);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<std::vector<quasar::PronChoice>>::resize(a3, (v12 - v11) >> 5);
  if (*(a1 + 392))
  {
    v5 = 7;
  }

  else
  {
    v5 = 6;
  }

  v7 = v11;
  v6 = v12;
  if (v12 != v11)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    do
    {
      if (*(v7 + v8 + 16) >= 1)
      {
        quasar::PronChoice::PronChoice(v13, v5, 0.0);
        std::vector<quasar::PronChoice>::__assign_with_size[abi:ne200100]<quasar::PronChoice const*,quasar::PronChoice const*>((*a3 + v9), v13, &v15, 1uLL);
        if (v14 < 0)
        {
          operator delete(v13[1]);
        }

        v7 = v11;
        v6 = v12;
      }

      ++v10;
      v9 += 24;
      v8 += 32;
    }

    while (v10 < (v6 - v7) >> 5);
  }

  v13[0] = &v11;
  std::vector<kaldi::CuVector<float>>::__destroy_vector::operator()[abi:ne200100](v13);
}

void sub_1B5A79B84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  std::vector<std::vector<quasar::PronChoice>>::__destroy_vector::operator()[abi:ne200100](&a13);
  a13 = &a10;
  std::vector<kaldi::CuVector<float>>::__destroy_vector::operator()[abi:ne200100](&a13);
  _Unwind_Resume(a1);
}

void quasar::G2Embedding::batchGetRawEmbeddings(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<kaldi::CuVector<float>>::resize(a3, 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  v6 = *(a1 + 368);
  if (v6)
  {
    if (v7)
    {
      v8 = *(a1 + 376);
      if (v8)
      {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v9 = (*(*v7 + 48))(v7);
      v44 = 0;
      v45 = 0;
      v46 = 0;
      __src = 0;
      v42 = 0;
      v43 = 0;
      v10 = *a2;
      if (a2[1] != *a2)
      {
        v11 = v9;
        v32 = v8;
        v12 = 0;
        v13 = v9;
        do
        {
          __p = 0;
          v39 = 0;
          v40 = 0;
          if (quasar::SentencePieceModule::encode(*(a1 + 360), (v10 + 24 * v12), &__p))
          {
            std::vector<std::vector<int>>::push_back[abi:ne200100](&v44, &__p);
            if (v11 <= 0)
            {
              v14 = (v39 - __p) >> 2;
              if (v14 <= v13)
              {
                v13 = v13;
              }

              else
              {
                v13 = v14;
              }
            }

            v15 = v42;
            if (v42 >= v43)
            {
              v17 = __src;
              v18 = v42 - __src;
              v19 = (v42 - __src) >> 2;
              v20 = v19 + 1;
              if ((v19 + 1) >> 62)
              {
                std::vector<int>::__throw_length_error[abi:ne200100]();
              }

              v21 = v43 - __src;
              if ((v43 - __src) >> 1 > v20)
              {
                v20 = v21 >> 1;
              }

              v22 = v21 >= 0x7FFFFFFFFFFFFFFCLL;
              v23 = 0x3FFFFFFFFFFFFFFFLL;
              if (!v22)
              {
                v23 = v20;
              }

              if (v23)
              {
                std::__allocate_at_least[abi:ne200100]<std::allocator<int>>(&__src, v23);
              }

              *(4 * v19) = v12;
              v16 = 4 * v19 + 4;
              memcpy(0, v17, v18);
              v24 = __src;
              __src = 0;
              v42 = v16;
              v43 = 0;
              if (v24)
              {
                operator delete(v24);
              }
            }

            else
            {
              *v42 = v12;
              v16 = (v15 + 4);
            }

            v42 = v16;
          }

          if (0xAAAAAAAAAAAAAAABLL * ((v45 - v44) >> 3) == *(a1 + 384) || v44 != v45 && 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3) - 1 == v12)
          {
            quasar::G2Embedding::Encode(a1, &v44, v13);
            v26 = v44;
            v25 = v45;
            if (v45 != v44)
            {
              v27 = 0;
              do
              {
                v28 = *(__src + v27);
                v33[0] = &unk_1F2CFCA48;
                v33[1] = v34[1] + 4 * v36 * v27;
                v33[3] = v37;
                v33[2] = v35;
                kaldi::CuVector<float>::operator=(*a3 + 32 * v28, v33);
                ++v27;
                v26 = v44;
                v25 = v45;
              }

              while (0xAAAAAAAAAAAAAAABLL * ((v45 - v44) >> 3) > v27);
            }

            if (v25 != v26)
            {
              v29 = v25;
              do
              {
                v31 = *(v29 - 24);
                v29 -= 24;
                v30 = v31;
                if (v31)
                {
                  *(v25 - 16) = v30;
                  operator delete(v30);
                }

                v25 = v29;
              }

              while (v29 != v26);
            }

            v45 = v26;
            v42 = __src;
            kaldi::CuMatrix<float>::~CuMatrix(v34);
            v13 = v11;
          }

          if (__p)
          {
            v39 = __p;
            operator delete(__p);
          }

          ++v12;
          v10 = *a2;
        }

        while (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3) > v12);
        v8 = v32;
        if (__src)
        {
          v42 = __src;
          operator delete(__src);
        }
      }

      v34[0] = &v44;
      std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne200100](v34);
      if (v8)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v8);
      }
    }
  }
}

void sub_1B5A79F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, uint64_t a23, void *a24, uint64_t a25)
{
  if (v25)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v25);
  }

  std::vector<kaldi::CuVector<float>>::__destroy_vector::operator()[abi:ne200100](&a15);
  _Unwind_Resume(a1);
}

void quasar::G2Embedding::computeEmbeddings(quasar::G2Embedding *this, quasar::WordPronCache *a2)
{
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v67 = 0;
  v68 = 0;
  v66 = &v67;
  v4 = *(this + 50);
  v5 = *(this + 51);
  if (v4 != v5)
  {
    v6 = 0;
    v33 = a2 + 56;
    while (1)
    {
      if (v33 != std::__tree<std::__value_type<std::string,double>,std::__map_value_compare<std::string,std::__value_type<std::string,double>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,double>>>::find<std::string>(a2 + 48, v4))
      {
        if (quasar::gLogLevel >= 5)
        {
          v64 = 0u;
          v65 = 0u;
          v62 = 0u;
          v63 = 0u;
          v60 = 0u;
          v61 = 0u;
          v58 = 0u;
          v59 = 0u;
          v56 = 0u;
          v57 = 0u;
          v54 = 0u;
          v55 = 0u;
          v52 = 0u;
          v53 = 0u;
          *__p = 0u;
          v51 = 0u;
          *v49 = 0u;
          kaldi::KaldiWarnMessage::KaldiWarnMessage(v49);
          v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v49, "Supported template: ", 20);
          v8 = *(v4 + 23);
          if (v8 >= 0)
          {
            v9 = v4;
          }

          else
          {
            v9 = *v4;
          }

          if (v8 >= 0)
          {
            v10 = *(v4 + 23);
          }

          else
          {
            v10 = v4[1];
          }

          v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v7, v9, v10);
          v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, ", num orths: ", 13);
          v13 = std::map<std::string,std::shared_ptr<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>::at(a2 + 48, v4);
          MEMORY[0x1B8C84C30](v12, *(v13 + 16));
          quasar::QuasarDebugMessage::~QuasarDebugMessage(v49);
        }

        v14 = std::map<std::string,std::shared_ptr<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>::at(a2 + 48, v4);
        v16 = v14 + 1;
        v15 = *v14;
        if (*v14 != v14 + 1)
        {
          break;
        }
      }

LABEL_67:
      v4 += 3;
      if (v4 == v5)
      {
        goto LABEL_68;
      }
    }

    while (1)
    {
      if (v6 >= *(this + 97))
      {
        goto LABEL_67;
      }

      quasar::LmeDataFactoryBase::PronSet::PronSet(v40);
      if (*(v15 + 55) < 0)
      {
        std::string::__init_copy_ctor_external(&v48, v15[4], v15[5]);
      }

      else
      {
        v48 = *(v15 + 4);
      }

      if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
      {
        if (!v48.__r_.__value_.__l.__size_)
        {
LABEL_34:
          if (quasar::gLogLevel >= 4)
          {
            v64 = 0u;
            v65 = 0u;
            v62 = 0u;
            v63 = 0u;
            v60 = 0u;
            v61 = 0u;
            v58 = 0u;
            v59 = 0u;
            v56 = 0u;
            v57 = 0u;
            v54 = 0u;
            v55 = 0u;
            v52 = 0u;
            v53 = 0u;
            *__p = 0u;
            v51 = 0u;
            *v49 = 0u;
            kaldi::KaldiWarnMessage::KaldiWarnMessage(v49);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v49, "Sanitization returned empty string", 34);
            quasar::QuasarInfoMessage::~QuasarInfoMessage(v49);
          }

          goto LABEL_49;
        }

        std::string::__init_copy_ctor_external(&v47, v48.__r_.__value_.__l.__data_, v48.__r_.__value_.__l.__size_);
      }

      else
      {
        if (!*(&v48.__r_.__value_.__s + 23))
        {
          goto LABEL_34;
        }

        v47 = v48;
      }

      std::string::basic_string[abi:ne200100]<0>(v45, "");
      quasar::LmeDataFactoryBase::Word::Word(v49, &v47, v45, 1, v40);
      v17 = quasar::WordPronCache::lookupWord(a2, v49, 3, v40);
      std::__tree<std::__value_type<std::pair<quasar::PronType,std::string>,float>,std::__map_value_compare<std::pair<quasar::PronType,std::string>,std::__value_type<std::pair<quasar::PronType,std::string>,float>,std::less<std::pair<quasar::PronType,std::string>>,true>,std::allocator<std::__value_type<std::pair<quasar::PronType,std::string>,float>>>::destroy(&v52 + 8, v53);
      if (SHIBYTE(v51) < 0)
      {
        operator delete(__p[1]);
      }

      if (SHIBYTE(__p[0]) < 0)
      {
        operator delete(v49[0]);
      }

      if (v46 < 0)
      {
        operator delete(v45[0]);
      }

      if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v47.__r_.__value_.__l.__data_);
        if (v17)
        {
LABEL_30:
          if (!quasar::LmeDataFactoryBase::PronSet::empty(v40))
          {
            if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
            {
              std::string::__init_copy_ctor_external(&v44, v48.__r_.__value_.__l.__data_, v48.__r_.__value_.__l.__size_);
            }

            else
            {
              v44 = v48;
            }

            std::string::basic_string[abi:ne200100]<0>(v42, "");
            quasar::LmeDataFactoryBase::Word::Word(v49, &v44, v42, 1, v40);
            std::__tree<quasar::LmeDataFactoryBase::Word,quasar::LmeDataFactoryBase::WordOrthoComparator,std::allocator<quasar::LmeDataFactoryBase::Word>>::__emplace_unique_key_args<quasar::LmeDataFactoryBase::Word,quasar::LmeDataFactoryBase::Word>(&v66, v49);
            std::__tree<std::__value_type<std::pair<quasar::PronType,std::string>,float>,std::__map_value_compare<std::pair<quasar::PronType,std::string>,std::__value_type<std::pair<quasar::PronType,std::string>,float>,std::less<std::pair<quasar::PronType,std::string>>,true>,std::allocator<std::__value_type<std::pair<quasar::PronType,std::string>,float>>>::destroy(&v52 + 8, v53);
            if (SHIBYTE(v51) < 0)
            {
              operator delete(__p[1]);
            }

            if (SHIBYTE(__p[0]) < 0)
            {
              operator delete(v49[0]);
            }

            if (v43 < 0)
            {
              operator delete(v42[0]);
            }

            if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v44.__r_.__value_.__l.__data_);
            }

            goto LABEL_48;
          }

          v18 = v70;
          if (v70 < v71)
          {
            if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
            {
LABEL_45:
              std::string::__init_copy_ctor_external(v70, v48.__r_.__value_.__l.__data_, v48.__r_.__value_.__l.__size_);
              goto LABEL_46;
            }

LABEL_40:
            v19 = *&v48.__r_.__value_.__l.__data_;
            v18->__r_.__value_.__r.__words[2] = v48.__r_.__value_.__r.__words[2];
            *&v18->__r_.__value_.__l.__data_ = v19;
LABEL_46:
            v20 = v18 + 1;
            goto LABEL_47;
          }

          goto LABEL_41;
        }
      }

      else if (v17)
      {
        goto LABEL_30;
      }

      v18 = v70;
      if (v70 < v71)
      {
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
        {
          goto LABEL_45;
        }

        goto LABEL_40;
      }

LABEL_41:
      v20 = std::vector<std::string>::__emplace_back_slow_path<std::string&>(&v69, &v48);
LABEL_47:
      v70 = v20;
LABEL_48:
      ++v6;
LABEL_49:
      if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v48.__r_.__value_.__l.__data_);
      }

      std::__tree<std::__value_type<std::pair<quasar::PronType,std::string>,float>,std::__map_value_compare<std::pair<quasar::PronType,std::string>,std::__value_type<std::pair<quasar::PronType,std::string>,float>,std::less<std::pair<quasar::PronType,std::string>>,true>,std::allocator<std::__value_type<std::pair<quasar::PronType,std::string>,float>>>::destroy(v40, *&v40[1]);
      v21 = v15[1];
      if (v21)
      {
        do
        {
          v22 = v21;
          v21 = *v21;
        }

        while (v21);
      }

      else
      {
        do
        {
          v22 = v15[2];
          v23 = *v22 == v15;
          v15 = v22;
        }

        while (!v23);
      }

      v15 = v22;
      if (v22 == v16)
      {
        goto LABEL_67;
      }
    }
  }

LABEL_68:
  if (quasar::gLogLevel > 3)
  {
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    *__p = 0u;
    v51 = 0u;
    *v49 = 0u;
    kaldi::KaldiWarnMessage::KaldiWarnMessage(v49);
    v24 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v49, "Number of embeddings to be computed: ", 37);
    MEMORY[0x1B8C84C30](v24, 0xAAAAAAAAAAAAAAABLL * ((v70 - v69) >> 3));
    quasar::QuasarInfoMessage::~QuasarInfoMessage(v49);
  }

  if (v69 != v70)
  {
    quasar::PronGuessStats::PronGuessStats(v40);
    v39 = 0;
    quasar::G2Embedding::batchGetEmbeddings(this, &v69, v40, &v39, &v48);
    v25 = v69;
    v26 = v70;
    if (v70 != v69)
    {
      v27 = 0;
      for (i = 0; 0xAAAAAAAAAAAAAAABLL * ((v26 - v25) >> 3) > i; ++i)
      {
        v29 = &v25[v27];
        v30 = SHIBYTE(v25[v27].__r_.__value_.__r.__words[2]);
        if (v30 < 0)
        {
          if (v29->__r_.__value_.__l.__size_)
          {
LABEL_77:
            if (*(v48.__r_.__value_.__r.__words[0] + v27 * 24 + 8) != *(v48.__r_.__value_.__r.__words[0] + v27 * 24))
            {
              if ((v30 & 0x80000000) != 0)
              {
                std::string::__init_copy_ctor_external(&v38, v25[v27].__r_.__value_.__l.__data_, v25[v27].__r_.__value_.__l.__size_);
              }

              else
              {
                v31 = *&v29->__r_.__value_.__l.__data_;
                v38.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
                *&v38.__r_.__value_.__l.__data_ = v31;
              }

              std::string::basic_string[abi:ne200100]<0>(v36, "");
              quasar::LmeDataFactoryBase::PronSet::PronSet(v34, v48.__r_.__value_.__r.__words[0] + v27 * 24);
              quasar::LmeDataFactoryBase::Word::Word(v49, &v38, v36, 1, v34);
              std::__tree<quasar::LmeDataFactoryBase::Word,quasar::LmeDataFactoryBase::WordOrthoComparator,std::allocator<quasar::LmeDataFactoryBase::Word>>::__emplace_unique_key_args<quasar::LmeDataFactoryBase::Word,quasar::LmeDataFactoryBase::Word>(&v66, v49);
              std::__tree<std::__value_type<std::pair<quasar::PronType,std::string>,float>,std::__map_value_compare<std::pair<quasar::PronType,std::string>,std::__value_type<std::pair<quasar::PronType,std::string>,float>,std::less<std::pair<quasar::PronType,std::string>>,true>,std::allocator<std::__value_type<std::pair<quasar::PronType,std::string>,float>>>::destroy(&v52 + 8, v53);
              if (SHIBYTE(v51) < 0)
              {
                operator delete(__p[1]);
              }

              if (SHIBYTE(__p[0]) < 0)
              {
                operator delete(v49[0]);
              }

              std::__tree<std::__value_type<std::pair<quasar::PronType,std::string>,float>,std::__map_value_compare<std::pair<quasar::PronType,std::string>,std::__value_type<std::pair<quasar::PronType,std::string>,float>,std::less<std::pair<quasar::PronType,std::string>>,true>,std::allocator<std::__value_type<std::pair<quasar::PronType,std::string>,float>>>::destroy(v34, v35);
              if (v37 < 0)
              {
                operator delete(v36[0]);
              }

              if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v38.__r_.__value_.__l.__data_);
              }

              v25 = v69;
              v26 = v70;
            }
          }
        }

        else if (*(&v25[v27].__r_.__value_.__s + 23))
        {
          goto LABEL_77;
        }

        ++v27;
      }
    }

    v49[0] = &v48;
    std::vector<std::vector<quasar::PronChoice>>::__destroy_vector::operator()[abi:ne200100](v49);
    std::__tree<std::string>::destroy(v41, v41[1]);
  }

  if (quasar::gLogLevel >= 4)
  {
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    *__p = 0u;
    v51 = 0u;
    *v49 = 0u;
    kaldi::KaldiWarnMessage::KaldiWarnMessage(v49);
    v32 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v49, "Updated cache size: ", 20);
    MEMORY[0x1B8C84C30](v32, v68);
    quasar::QuasarInfoMessage::~QuasarInfoMessage(v49);
  }

  quasar::WordPronCache::setPronCache(a2);
}

void sub_1B5A7A70C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *a30, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, uint64_t a35, void *a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, void *__p, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47)
{
  std::__tree<quasar::LmeDataFactoryBase::Word,quasar::LmeDataFactoryBase::WordOrthoComparator,std::allocator<quasar::LmeDataFactoryBase::Word>>::destroy(v47 - 136, *(v47 - 128));
  a47 = v47 - 112;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&a47);
  _Unwind_Resume(a1);
}

void quasar::G2Embedding::batchGetEmbeddings(void *a1@<X0>, uint64_t *a2@<X1>, int32x2_t *a3@<X2>, _BYTE *a4@<X3>, void *a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  std::vector<std::vector<quasar::PronChoice>>::resize(a5, 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v80[0] = 0;
  v80[1] = 0;
  v78[1] = 0;
  v79 = v80;
  v77 = v78;
  v78[0] = 0;
  v47 = a4;
  std::vector<BOOL>::vector(&v76, 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  memset(&v75, 0, sizeof(v75));
  v74 = 0;
  LODWORD(v50) = 0;
  v10 = *a2;
  if (a2[1] != *a2)
  {
    v11 = 0;
    do
    {
      std::string::operator=(&v75, (v10 + 24 * v11));
      v12 = (*a5 + 24 * v50);
      v72 = 0;
      v73 = 0;
      v13 = quasar::G2P::lookupHumanReadableProns(a1, &v75, v12, a3, &v72, &v74 + 1, &v74, 2);
      if (v73)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v73);
      }

      if (v13 != -1)
      {
        v14 = v50 >> 6;
        v15 = 1 << v50;
        v16 = v74 == 1 ? v76[v14] | v15 : v76[v14] & ~v15;
        v76[v14] = v16;
        if (HIBYTE(v74) == 1)
        {
          if (v80 == std::__tree<std::__value_type<std::string,double>,std::__map_value_compare<std::string,std::__value_type<std::string,double>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,double>>>::find<std::string>(&v79, &v75.__r_.__value_.__l.__data_))
          {
            v18 = v81;
            v19 = v82;
            *&v69[0] = &v50;
            *(std::__tree<std::__value_type<int,float>,std::__map_value_compare<int,std::__value_type<int,float>,std::less<int>,true>,std::allocator<std::__value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v77, &v50) + 8) = -1431655765 * ((v19 - v18) >> 3);
            v20 = v81;
            v21 = v82;
            *&v69[0] = &v75;
            *(std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(&v79, &v75.__r_.__value_.__l.__data_) + 56) = -1431655765 * ((v21 - v20) >> 3);
            std::vector<std::string>::push_back[abi:ne200100](&v81, &v75);
          }

          else
          {
            *&v69[0] = &v75;
            v17 = *(std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(&v79, &v75.__r_.__value_.__l.__data_) + 56);
            *&v69[0] = &v50;
            *(std::__tree<std::__value_type<int,float>,std::__map_value_compare<int,std::__value_type<int,float>,std::less<int>,true>,std::allocator<std::__value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v77, &v50) + 8) = v17;
          }
        }
      }

      v11 = v50 + 1;
      LODWORD(v50) = v50 + 1;
      v10 = *a2;
    }

    while (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3) > v11);
  }

  v70 = 1;
  kaldi::Timer::Reset(v69, v9);
  v71 = 0;
  if (v82 != v81)
  {
    v67 = 0uLL;
    v68 = 0;
    (*(*a1 + 24))(&v50, a1, &v81, 2);
    std::vector<std::vector<quasar::PronChoice>>::__vdeallocate(&v67);
    v67 = v50;
    v68 = v51;
    *&v51 = 0;
    v50 = 0uLL;
    v84[0] = &v50;
    std::vector<std::vector<quasar::PronChoice>>::__destroy_vector::operator()[abi:ne200100](v84);
    v23 = *(&v67 + 1);
    for (i = v67; i != v23; i += 3)
    {
      v24 = *i;
      v25 = i[1];
      while (v24 != v25)
      {
        if ((quasar::pronTypeMatchesPronRequest(*v24, 2) & 1) == 0)
        {
          kaldi::KaldiWarnMessage::KaldiWarnMessage(&v50);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v50, "pronTypeMatchesPronRequest(pronChoice.type, PronRequest::kEmbedding)", 68);
          kaldi::KaldiErrorMessage::~KaldiErrorMessage(&v50);
        }

        v24 += 10;
      }
    }

    *v47 = 1;
    v49 = 0;
    if (a2[1] != *a2)
    {
      LODWORD(v26) = 0;
      do
      {
        v27 = v78[0];
        if (!v78[0])
        {
          goto LABEL_45;
        }

        v28 = v78;
        do
        {
          if (*(v27 + 7) >= v26)
          {
            v28 = v27;
          }

          v27 = v27[*(v27 + 7) < v26];
        }

        while (v27);
        if (v28 == v78 || v26 < *(v28 + 7))
        {
          goto LABEL_45;
        }

        v84[0] = &v49;
        v30 = *(std::__tree<std::__value_type<int,float>,std::__map_value_compare<int,std::__value_type<int,float>,std::less<int>,true>,std::allocator<std::__value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v77, &v49) + 8);
        v31 = (v67 + 24 * v30);
        v32 = *v31;
        v33 = v31[1];
        if (*v31 == v33)
        {
          if (quasar::gLogLevel >= 4)
          {
            v65 = 0u;
            v66 = 0u;
            v63 = 0u;
            v64 = 0u;
            v61 = 0u;
            v62 = 0u;
            v59 = 0u;
            v60 = 0u;
            v58 = 0u;
            v56 = 0u;
            v57 = 0u;
            v54 = 0u;
            v55 = 0u;
            v52 = 0u;
            v53 = 0u;
            v50 = 0u;
            v51 = 0u;
            kaldi::KaldiWarnMessage::KaldiWarnMessage(&v50);
            v42 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v50, "Failed to generated pronunciations for word=", 44);
            v43 = v81 + 24 * v30;
            v44 = *(v43 + 23);
            if (v44 >= 0)
            {
              v45 = v81 + 24 * v30;
            }

            else
            {
              v45 = *v43;
            }

            if (v44 >= 0)
            {
              v46 = *(v43 + 23);
            }

            else
            {
              v46 = *(v43 + 8);
            }

            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v42, v45, v46);
            quasar::QuasarInfoMessage::~QuasarInfoMessage(&v50);
          }

          ++a3[2].i32[1];
          if (*(a1[1] + 8) != 1)
          {
            goto LABEL_45;
          }

          v50 = 0uLL;
          *&v51 = 0;
          updated = quasar::G2P::updateCache(a1, v81 + 24 * v30, &v50);
          v84[0] = &v50;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](v84);
          v41 = 0;
        }

        else
        {
          Seconds = kaldi::Timer::GetSeconds(5, v29);
          v35 = v69[0];
          kaldi::Timer::Reset(v69, v36);
          v37 = (*a5 + 24 * v49);
          if (v37 != v31)
          {
            std::vector<quasar::PronChoice>::__assign_with_size[abi:ne200100]<quasar::PronChoice*,quasar::PronChoice*>(v37, *v31, v31[1], 0xCCCCCCCCCCCCCCCDLL * ((v31[1] - *v31) >> 3));
          }

          quasar::PronGuessStats::addRecord(a3, v81 + 24 * v30, 3, ((Seconds - v35) * 1000000.0));
          v38 = v81;
          quasar::fromPronChoices(v31, &v50);
          updated = quasar::G2P::updateCache(a1, v38 + 24 * v30, &v50);
          v84[0] = &v50;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](v84);
          v41 = ((kaldi::Timer::GetSeconds(5, v40) - v69[0]) * 1000000.0);
        }

        quasar::G2P::updateCacheSetStats(a1, v81 + 24 * v30, v41, updated, v32 == v33, a3);
LABEL_45:
        v26 = ++v49;
      }

      while (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3) > v26);
    }

    *&v50 = &v67;
    std::vector<std::vector<quasar::PronChoice>>::__destroy_vector::operator()[abi:ne200100](&v50);
  }

  if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v75.__r_.__value_.__l.__data_);
  }

  if (v76)
  {
    operator delete(v76);
  }

  std::__tree<int>::destroy(&v77, v78[0]);
  std::__tree<std::string>::destroy(&v79, v80[0]);
  *&v50 = &v81;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v50);
}

void quasar::G2Embedding::~G2Embedding(std::locale *this)
{
  this->__locale_ = &unk_1F2D41340;
  v3 = this + 50;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v3);
  locale = this[47].__locale_;
  if (locale)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](locale);
  }

  std::unique_ptr<quasar::SentencePieceModule>::reset[abi:ne200100](&this[45].__locale_, 0);
  quasar::QuasarG2PBase::~QuasarG2PBase(this);
}

{
  this->__locale_ = &unk_1F2D41340;
  v3 = this + 50;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v3);
  locale = this[47].__locale_;
  if (locale)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](locale);
  }

  std::unique_ptr<quasar::SentencePieceModule>::reset[abi:ne200100](&this[45].__locale_, 0);
  quasar::QuasarG2PBase::~QuasarG2PBase(this);
  MEMORY[0x1B8C85350]();
}

void std::vector<quasar::PronChoice>::__assign_with_size[abi:ne200100]<quasar::PronChoice const*,quasar::PronChoice const*>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v6 = a2;
  v8 = *a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) < a4)
  {
    std::vector<quasar::PronChoice>::__vdeallocate(a1);
    if (a4 <= 0x666666666666666)
    {
      v9 = 0x999999999999999ALL * ((a1[2] - *a1) >> 3);
      if (v9 <= a4)
      {
        v9 = a4;
      }

      if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) >= 0x333333333333333)
      {
        v10 = 0x666666666666666;
      }

      else
      {
        v10 = v9;
      }

      std::vector<quasar::PronChoice>::__vallocate[abi:ne200100](a1, v10);
    }

    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  v11 = a1[1];
  if (0xCCCCCCCCCCCCCCCDLL * ((v11 - v8) >> 3) >= a4)
  {
    if (a2 != a3)
    {
      do
      {
        *v8 = *v6;
        std::string::operator=((v8 + 8), (v6 + 8));
        *(v8 + 32) = *(v6 + 32);
        v8 += 40;
        v6 += 40;
      }

      while (v6 != a3);
      v11 = a1[1];
    }

    while (v11 != v8)
    {
      if (*(v11 - 9) < 0)
      {
        operator delete(*(v11 - 4));
      }

      v11 -= 5;
    }

    a1[1] = v8;
  }

  else
  {
    v12 = v11 + a2 - v8;
    if (v11 != v8)
    {
      do
      {
        *v8 = *v6;
        std::string::operator=((v8 + 8), (v6 + 8));
        *(v8 + 32) = *(v6 + 32);
        v6 += 40;
        v8 += 40;
      }

      while (v6 != v12);
      v11 = a1[1];
    }

    a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<quasar::PronChoice>,quasar::PronChoice const*,quasar::PronChoice const*,quasar::PronChoice*>(a1, v12, a3, v11);
  }
}

_DWORD *std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<quasar::PronChoice>,quasar::PronChoice const*,quasar::PronChoice const*,quasar::PronChoice*>(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      quasar::PronChoice::PronChoice(v4, v6);
      v6 += 40;
      v4 = v11 + 10;
      v11 += 10;
    }

    while (v6 != a3);
  }

  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<quasar::PronChoice>,quasar::PronChoice*>>::~__exception_guard_exceptions[abi:ne200100](v8);
  return v4;
}

void std::vector<std::vector<quasar::PronChoice>>::__vdeallocate(void ***a1)
{
  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        v5 = v3;
        std::vector<quasar::PronChoice>::__destroy_vector::operator()[abi:ne200100](&v5);
      }

      while (v3 != v1);
      v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t quasar::rescoring::GetParam@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X3>, std::string *a5@<X8>)
{
  v6[4] = *MEMORY[0x1E69E9840];
  v6[0] = &unk_1F2D413B8;
  v6[3] = v6;
  quasar::rescoring::GetParam<std::string>(a1, a2, a3, a4, a5);
  return std::__function::__value_func<std::string ()(std::string const&)>::~__value_func[abi:ne200100](v6);
}

void sub_1B5A7B4B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<std::string ()(std::string const&)>::~__value_func[abi:ne200100](va);
  _Unwind_Resume(a1);
}

void quasar::rescoring::GetParam<std::string>(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X3>, std::string *a5@<X8>)
{
  v9 = *(a3 + 23);
  if ((v9 & 0x8000000000000000) == 0)
  {
    if (*(a3 + 23))
    {
      v10 = a3;
      goto LABEL_6;
    }

LABEL_9:
    std::operator+<char>();
    goto LABEL_10;
  }

  v9 = a3[1];
  if (!v9)
  {
    goto LABEL_9;
  }

  v10 = *a3;
LABEL_6:
  if (v9[v10 - 1] != 46)
  {
    goto LABEL_9;
  }

  if (*(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *a4, *(a4 + 8));
  }

  else
  {
    __p = *a4;
  }

LABEL_10:
  std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(a3, &__p.__r_.__value_.__l.__data_, v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (*(a1 + 24) != 1)
  {
    quasar::SystemConfig::hasParam(a2, v11);
  }

  if (*(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a5, *a1, *(a1 + 8));
  }

  else
  {
    *&a5->__r_.__value_.__l.__data_ = *a1;
    a5->__r_.__value_.__r.__words[2] = *(a1 + 16);
  }

  if (v12 < 0)
  {
    operator delete(v11[0]);
  }
}

void sub_1B5A7B654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void quasar::rescoring::LoadQsrTextSymbolTableFromSystemConfig(quasar::SystemConfig *a1, void *a2)
{
  quasar::SystemConfig::SystemConfig(v7, a1, 1, 0);
  std::string::basic_string[abi:ne200100]<0>(&v5, "");
  v3 = *(a2 + 23);
  if (v3 < 0)
  {
    v3 = a2[1];
    if (!v3)
    {
      goto LABEL_9;
    }

    v4 = *a2;
  }

  else
  {
    if (!*(a2 + 23))
    {
      goto LABEL_9;
    }

    v4 = a2;
  }

  if (v4[v3 - 1] == 46)
  {
    if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v8, v5.__r_.__value_.__l.__data_, v5.__r_.__value_.__l.__size_);
    }

    else
    {
      v8 = v5;
    }

LABEL_10:
    std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(a2, &v8.__r_.__value_.__l.__data_, &__p);
    if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v8.__r_.__value_.__l.__data_);
    }

    quasar::SystemConfig::setPrefix(v7, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v5.__r_.__value_.__l.__data_);
    }

    operator new();
  }

LABEL_9:
  std::operator+<char>();
  goto LABEL_10;
}

void sub_1B5A7B86C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char a22)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  quasar::SystemConfig::~SystemConfig(&a22);
  _Unwind_Resume(a1);
}

void quasar::rescoring::RescorerConfig::RescorerConfig(uint64_t a1, const quasar::SystemConfig *a2, uint64_t a3, char a4, char a5)
{
  v36[4] = *MEMORY[0x1E69E9840];
  *a1 = a5;
  v8 = (a1 + 32);
  std::optional<std::string>::value_or[abi:ne200100]<char const* const&>(a3, &quasar::rescoring::RescorerConfig::DEFAULT_ROOT, (a1 + 8));
  LOBYTE(v16[0]) = 0;
  v18 = 0;
  std::string::basic_string[abi:ne200100]<0>(&v22, "decoder-chain-name");
  std::string::basic_string[abi:ne200100]<0>(&__p, "siri");
  quasar::rescoring::GetParam(v16, a2, (a1 + 8), &v22, v8);
  if (v28 < 0)
  {
    operator delete(__p);
  }

  if (v24 < 0)
  {
    operator delete(v22);
  }

  if (v18 == 1 && v17 < 0)
  {
    operator delete(v16[0]);
  }

  LOBYTE(v16[0]) = 0;
  v18 = 0;
  std::string::basic_string[abi:ne200100]<0>(&v22, "oov-replacement-token");
  std::string::basic_string[abi:ne200100]<0>(&__p, "<unk>");
  quasar::rescoring::GetParam(v16, a2, (a1 + 8), &v22, (a1 + 56));
  if (v28 < 0)
  {
    operator delete(__p);
  }

  if (v24 < 0)
  {
    operator delete(v22);
  }

  if (v18 == 1 && v17 < 0)
  {
    operator delete(v16[0]);
  }

  LOBYTE(v22) = 0;
  BYTE4(v22) = 0;
  std::string::basic_string[abi:ne200100]<0>(v16, "log-zero-probability-replacement");
  v36[0] = &unk_1F2D41448;
  v36[3] = v36;
  v9 = quasar::rescoring::GetParam<float>(&v22, a2, (a1 + 8), v16);
  std::__function::__value_func<float ()(std::string const&)>::~__value_func[abi:ne200100](v36);
  if (v17 < 0)
  {
    operator delete(v16[0]);
  }

  *(a1 + 80) = v9;
  LOBYTE(v22) = 0;
  LOBYTE(v23) = 0;
  std::string::basic_string[abi:ne200100]<0>(v16, "oov-log-probability-replacement");
  LOBYTE(__p) = 0;
  BYTE4(__p) = 0;
  v35[0] = &unk_1F2D414D8;
  v35[3] = v35;
  v10 = quasar::rescoring::GetParam<std::optional<float>>(&v22, a2, (a1 + 8), v16);
  *(a1 + 84) = v10;
  *(a1 + 88) = BYTE4(v10);
  std::__function::__value_func<std::optional<float> ()(std::string const&)>::~__value_func[abi:ne200100](v35);
  if (v17 < 0)
  {
    operator delete(v16[0]);
  }

  LOBYTE(v16[0]) = 0;
  v21 = 0;
  std::string::basic_string[abi:ne200100]<0>(&__p, "default-adapter-model-file");
  LOBYTE(v22) = 0;
  v26 = 0;
  v34[0] = &unk_1F2D41568;
  v34[3] = v34;
  quasar::rescoring::GetParam<std::optional<quasar::filesystem::Path>>(v16, a2, (a1 + 8), &__p, a1 + 96);
  std::__function::__value_func<std::optional<quasar::filesystem::Path> ()(std::string const&)>::~__value_func[abi:ne200100](v34);
  if (v26 == 1)
  {
    v22 = &unk_1F2CFAA28;
    if (v25 < 0)
    {
      operator delete(v23);
    }
  }

  if (v28 < 0)
  {
    operator delete(__p);
  }

  if (v21 == 1 && v20 == 1)
  {
    v16[0] = &unk_1F2CFAA28;
    if (v19 < 0)
    {
      operator delete(v16[1]);
    }
  }

  LOWORD(v22) = 0;
  std::string::basic_string[abi:ne200100]<0>(v16, "use-null-op-adapter-model-by-default");
  LOBYTE(__p) = 0;
  v33[0] = &unk_1F2D415F8;
  v33[1] = quasar::PTree::toBool;
  v33[3] = v33;
  v11 = quasar::rescoring::GetParam<BOOL>(&v22, a2, (a1 + 8), v16);
  std::__function::__value_func<BOOL ()(std::string const&)>::~__value_func[abi:ne200100](v33);
  if (v17 < 0)
  {
    operator delete(v16[0]);
  }

  *(a1 + 136) = v11;
  LOWORD(v22) = 0;
  std::string::basic_string[abi:ne200100]<0>(v16, "compute-pre-itn-lm-features");
  LOBYTE(__p) = 1;
  v32[0] = &unk_1F2D415F8;
  v32[1] = quasar::PTree::toBool;
  v32[3] = v32;
  v12 = quasar::rescoring::GetParam<BOOL>(&v22, a2, (a1 + 8), v16);
  std::__function::__value_func<BOOL ()(std::string const&)>::~__value_func[abi:ne200100](v32);
  if (v17 < 0)
  {
    operator delete(v16[0]);
  }

  *(a1 + 137) = v12;
  LOWORD(v22) = 0;
  std::string::basic_string[abi:ne200100]<0>(v16, "compute-retokenized-post-itn-lm-features");
  LOBYTE(__p) = 1;
  v31[0] = &unk_1F2D415F8;
  v31[1] = quasar::PTree::toBool;
  v31[3] = v31;
  v13 = quasar::rescoring::GetParam<BOOL>(&v22, a2, (a1 + 8), v16);
  std::__function::__value_func<BOOL ()(std::string const&)>::~__value_func[abi:ne200100](v31);
  if (v17 < 0)
  {
    operator delete(v16[0]);
  }

  *(a1 + 138) = v13;
  LOWORD(v22) = 0;
  std::string::basic_string[abi:ne200100]<0>(v16, "extract-pre-itn-tokens-by-retrofitting");
  LOBYTE(__p) = 0;
  v30[0] = &unk_1F2D415F8;
  v30[1] = quasar::PTree::toBool;
  v30[3] = v30;
  v14 = quasar::rescoring::GetParam<BOOL>(&v22, a2, (a1 + 8), v16);
  std::__function::__value_func<BOOL ()(std::string const&)>::~__value_func[abi:ne200100](v30);
  if (v17 < 0)
  {
    operator delete(v16[0]);
  }

  *(a1 + 139) = v14;
  LOBYTE(v22) = 0;
  BYTE4(v22) = 0;
  std::string::basic_string[abi:ne200100]<0>(v16, "num-entry-sources");
  LODWORD(__p) = 1;
  v29[0] = &unk_1F2D41698;
  v29[3] = v29;
  v15 = quasar::rescoring::GetParam<int>(&v22, a2, (a1 + 8), v16);
  std::__function::__value_func<int ()(std::string const&)>::~__value_func[abi:ne200100](v29);
  if (v17 < 0)
  {
    operator delete(v16[0]);
  }

  *(a1 + 140) = v15;
  quasar::SystemConfig::SystemConfig((a1 + 144), a2, a4 != 1, 0);
  quasar::rescoring::LoadQsrTextSymbolTableFromSystemConfig((a1 + 144), (a1 + 8));
}

void sub_1B5A7C254(_Unwind_Exception *a1)
{
  std::__tree<int>::destroy(v1 + 1736, *(v1 + 1744));
  v4 = *(v1 + 1728);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  v5 = *(v1 + 1712);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v5);
  }

  quasar::SystemConfig::~SystemConfig((v1 + 144));
  std::optional<quasar::filesystem::Path>::~optional(v1 + 96);
  if (*(v1 + 79) < 0)
  {
    operator delete(*(v1 + 56));
  }

  if (*(v1 + 55) < 0)
  {
    operator delete(*v2);
  }

  if (*(v1 + 31) < 0)
  {
    operator delete(*(v1 + 8));
  }

  _Unwind_Resume(a1);
}

void std::optional<std::string>::value_or[abi:ne200100]<char const* const&>(uint64_t a1@<X0>, char **a2@<X1>, std::string *a3@<X8>)
{
  if (*(a1 + 24) == 1)
  {
    if (*(a1 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(a3, *a1, *(a1 + 8));
    }

    else
    {
      *&a3->__r_.__value_.__l.__data_ = *a1;
      a3->__r_.__value_.__r.__words[2] = *(a1 + 16);
    }
  }

  else
  {
    std::string::basic_string[abi:ne200100]<0>(a3, *a2);
  }
}

float quasar::rescoring::GetParam<float>(uint64_t a1, uint64_t a2, char **a3, uint64_t a4)
{
  v7 = *(a3 + 23);
  if ((v7 & 0x8000000000000000) == 0)
  {
    if (*(a3 + 23))
    {
      v8 = a3;
      goto LABEL_6;
    }

LABEL_9:
    std::operator+<char>();
    goto LABEL_10;
  }

  v7 = a3[1];
  if (!v7)
  {
    goto LABEL_9;
  }

  v8 = *a3;
LABEL_6:
  if (v7[v8 - 1] != 46)
  {
    goto LABEL_9;
  }

  if (*(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *a4, *(a4 + 8));
  }

  else
  {
    __p = *a4;
  }

LABEL_10:
  std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(a3, &__p.__r_.__value_.__l.__data_, v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (*(a1 + 4) != 1)
  {
    quasar::SystemConfig::hasParam(a2, v11);
  }

  v9 = *a1;
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  return v9;
}

void sub_1B5A7C67C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

unint64_t quasar::rescoring::GetParam<std::optional<float>>(unsigned int *a1, uint64_t a2, char **a3, uint64_t a4)
{
  v7 = *(a3 + 23);
  if ((v7 & 0x8000000000000000) == 0)
  {
    if (*(a3 + 23))
    {
      v8 = a3;
      goto LABEL_6;
    }

LABEL_9:
    std::operator+<char>();
    goto LABEL_10;
  }

  v7 = a3[1];
  if (!v7)
  {
    goto LABEL_9;
  }

  v8 = *a3;
LABEL_6:
  if (v7[v8 - 1] != 46)
  {
    goto LABEL_9;
  }

  if (*(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *a4, *(a4 + 8));
  }

  else
  {
    __p = *a4;
  }

LABEL_10:
  std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(a3, &__p.__r_.__value_.__l.__data_, v12);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (*(a1 + 8) != 1)
  {
    quasar::SystemConfig::hasParam(a2, v12);
  }

  v9 = *a1 | (*(a1 + 4) << 32);
  v10 = *(a1 + 5) | (*(a1 + 7) << 16);
  if (v13 < 0)
  {
    operator delete(v12[0]);
  }

  return v9 & 0xFFFFFFFFFFLL | (v10 << 40);
}

void sub_1B5A7C80C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void quasar::rescoring::GetParam<std::optional<quasar::filesystem::Path>>(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  v9 = *(a3 + 23);
  if ((v9 & 0x8000000000000000) == 0)
  {
    if (*(a3 + 23))
    {
      v10 = a3;
      goto LABEL_6;
    }

LABEL_9:
    std::operator+<char>();
    goto LABEL_10;
  }

  v9 = a3[1];
  if (!v9)
  {
    goto LABEL_9;
  }

  v10 = *a3;
LABEL_6:
  if (v9[v10 - 1] != 46)
  {
    goto LABEL_9;
  }

  if (*(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *a4, *(a4 + 8));
  }

  else
  {
    __p = *a4;
  }

LABEL_10:
  std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(a3, &__p.__r_.__value_.__l.__data_, v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if ((*(a1 + 40) & 1) == 0)
  {
    quasar::SystemConfig::hasParam(a2, v11);
  }

  std::__optional_copy_base<quasar::filesystem::Path,false>::__optional_copy_base[abi:ne200100](a5, a1);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }
}

void sub_1B5A7C9A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::optional<quasar::filesystem::Path>::~optional(uint64_t a1)
{
  if (*(a1 + 32) == 1)
  {
    *a1 = &unk_1F2CFAA28;
    if (*(a1 + 31) < 0)
    {
      operator delete(*(a1 + 8));
    }
  }

  return a1;
}

uint64_t quasar::rescoring::GetParam<BOOL>(char *a1, uint64_t a2, char **a3, uint64_t a4)
{
  v7 = *(a3 + 23);
  if ((v7 & 0x8000000000000000) == 0)
  {
    if (*(a3 + 23))
    {
      v8 = a3;
      goto LABEL_6;
    }

LABEL_9:
    std::operator+<char>();
    goto LABEL_10;
  }

  v7 = a3[1];
  if (!v7)
  {
    goto LABEL_9;
  }

  v8 = *a3;
LABEL_6:
  if (v7[v8 - 1] != 46)
  {
    goto LABEL_9;
  }

  if (*(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *a4, *(a4 + 8));
  }

  else
  {
    __p = *a4;
  }

LABEL_10:
  std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(a3, &__p.__r_.__value_.__l.__data_, v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (a1[1] != 1)
  {
    quasar::SystemConfig::hasParam(a2, v11);
  }

  v9 = *a1;
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  return v9 & 1;
}

void sub_1B5A7CB90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t quasar::rescoring::GetParam<int>(unsigned int *a1, uint64_t a2, char **a3, uint64_t a4)
{
  v7 = *(a3 + 23);
  if ((v7 & 0x8000000000000000) == 0)
  {
    if (*(a3 + 23))
    {
      v8 = a3;
      goto LABEL_6;
    }

LABEL_9:
    std::operator+<char>();
    goto LABEL_10;
  }

  v7 = a3[1];
  if (!v7)
  {
    goto LABEL_9;
  }

  v8 = *a3;
LABEL_6:
  if (v7[v8 - 1] != 46)
  {
    goto LABEL_9;
  }

  if (*(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *a4, *(a4 + 8));
  }

  else
  {
    __p = *a4;
  }

LABEL_10:
  std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(a3, &__p.__r_.__value_.__l.__data_, v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (*(a1 + 4) != 1)
  {
    quasar::SystemConfig::hasParam(a2, v11);
  }

  v9 = *a1;
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  return v9;
}

void sub_1B5A7CD24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void *quasar::rescoring::RescorerConfig::loadLmRescoringDecoder@<X0>(void *this@<X0>, char a2@<W1>, void *a3@<X8>)
{
  v3 = this;
  if ((a2 & 1) != 0 || this[215])
  {
    v5 = this + 1;
    std::string::basic_string[abi:ne200100]<0>(&v29, "lm-rescore");
    v6 = *(v3 + 31);
    if (v6 < 0)
    {
      v6 = *(v3 + 16);
      if (!v6)
      {
        goto LABEL_11;
      }

      v7 = *v5;
    }

    else
    {
      if (!*(v3 + 31))
      {
        goto LABEL_11;
      }

      v7 = v3 + 8;
    }

    if (*(v7 + v6 - 1) == 46)
    {
      if (SHIBYTE(v30) < 0)
      {
        std::string::__init_copy_ctor_external(__p, v29, *(&v29 + 1));
      }

      else
      {
        *__p = v29;
        *&v13 = v30;
      }

LABEL_12:
      std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>((v3 + 8), __p, v31);
      if (SBYTE7(v13) < 0)
      {
        operator delete(__p[0]);
      }

      if (SHIBYTE(v30) < 0)
      {
        operator delete(v29);
      }

      if (quasar::gLogLevel >= 4)
      {
        v27 = 0u;
        v28 = 0u;
        v25 = 0u;
        v26 = 0u;
        v23 = 0u;
        v24 = 0u;
        v21 = 0u;
        v22 = 0u;
        v19 = 0u;
        v20 = 0u;
        v17 = 0u;
        v18 = 0u;
        v15 = 0u;
        v16 = 0u;
        v13 = 0u;
        v14 = 0u;
        *__p = 0u;
        kaldi::KaldiWarnMessage::KaldiWarnMessage(__p);
        v8 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(__p, "Looking for LM rescoring configuration at root ", 47);
        if ((v32 & 0x80u) == 0)
        {
          v9 = v31;
        }

        else
        {
          v9 = v31[0];
        }

        if ((v32 & 0x80u) == 0)
        {
          v10 = v32;
        }

        else
        {
          v10 = v31[1];
        }

        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, v9, v10);
        quasar::QuasarInfoMessage::~QuasarInfoMessage(__p);
      }

      quasar::SystemConfig::getPtreeOptional(v3 + 144, v31);
    }

LABEL_11:
    std::operator+<char>();
    goto LABEL_12;
  }

  v11 = this[216];
  *a3 = 0;
  a3[1] = v11;
  if (v11)
  {
    atomic_fetch_add_explicit((v11 + 8), 1uLL, memory_order_relaxed);
  }

  return this;
}

void sub_1B5A7D180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, quasar::SpeechRecognizerModelLoader *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  __p = (v23 - 120);
  std::vector<std::shared_ptr<quasar::LmeContainer>>::__destroy_vector::operator()[abi:ne200100](&__p);
  std::unique_ptr<quasar::SpeechRecognizerModelLoader>::~unique_ptr[abi:ne200100](&a10);
  if (v22)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v22);
  }

  if (*(v23 - 73) < 0)
  {
    operator delete(*(v23 - 96));
  }

  _Unwind_Resume(a1);
}

void quasar::rescoring::GetParam<std::set<int>>(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  v9 = *(a3 + 23);
  if ((v9 & 0x8000000000000000) == 0)
  {
    if (*(a3 + 23))
    {
      v10 = a3;
      goto LABEL_6;
    }

LABEL_9:
    std::operator+<char>();
    goto LABEL_10;
  }

  v9 = a3[1];
  if (!v9)
  {
    goto LABEL_9;
  }

  v10 = *a3;
LABEL_6:
  if (v9[v10 - 1] != 46)
  {
    goto LABEL_9;
  }

  if (*(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *a4, *(a4 + 8));
  }

  else
  {
    __p = *a4;
  }

LABEL_10:
  std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(a3, &__p.__r_.__value_.__l.__data_, v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if ((*(a1 + 24) & 1) == 0)
  {
    quasar::SystemConfig::hasParam(a2, v11);
  }

  std::set<int>::set[abi:ne200100](a5, a1);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }
}

void sub_1B5A7D43C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t quasar::rescoring::RescorerConfig::RescorerConfig(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  if (*(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 8), *(a2 + 8), *(a2 + 16));
  }

  else
  {
    v4 = *(a2 + 8);
    *(a1 + 24) = *(a2 + 24);
    *(a1 + 8) = v4;
  }

  if (*(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 32), *(a2 + 32), *(a2 + 40));
  }

  else
  {
    v5 = *(a2 + 32);
    *(a1 + 48) = *(a2 + 48);
    *(a1 + 32) = v5;
  }

  if (*(a2 + 79) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 56), *(a2 + 56), *(a2 + 64));
  }

  else
  {
    v6 = *(a2 + 56);
    *(a1 + 72) = *(a2 + 72);
    *(a1 + 56) = v6;
  }

  *(a1 + 80) = *(a2 + 80);
  *(a1 + 84) = *(a2 + 84);
  std::__optional_copy_base<quasar::filesystem::Path,false>::__optional_copy_base[abi:ne200100](a1 + 96, a2 + 96);
  v7 = *(a2 + 140);
  *(a1 + 136) = *(a2 + 136);
  *(a1 + 140) = v7;
  quasar::SystemConfig::SystemConfig((a1 + 144), (a2 + 144), 1, 1);
  *(a1 + 1704) = *(a2 + 1704);
  v8 = *(a2 + 1712);
  *(a1 + 1712) = v8;
  if (v8)
  {
    atomic_fetch_add_explicit((v8 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 1720) = *(a2 + 1720);
  v9 = *(a2 + 1728);
  *(a1 + 1728) = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((v9 + 8), 1uLL, memory_order_relaxed);
  }

  std::set<int>::set[abi:ne200100]((a1 + 1736), a2 + 1736);
  *(a1 + 1760) = *(a2 + 1760);
  *(a1 + 1768) = *(a2 + 1768);
  return a1;
}

void sub_1B5A7D5B8(_Unwind_Exception *exception_object)
{
  if (*(v1 + 55) < 0)
  {
    operator delete(*(v1 + 32));
  }

  if (*(v1 + 31) < 0)
  {
    operator delete(*v2);
  }

  _Unwind_Resume(exception_object);
}

void sub_1B5A7DC1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, void *__p, uint64_t a57, int a58, __int16 a59, char a60, char a61)
{
  quasar::QuasarInfoMessage::~QuasarInfoMessage(&a15);
  std::__tree<std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>>>::destroy(v61 - 136, *(v61 - 128));
  v63 = *(v61 - 104);
  if (v63)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v63);
  }

  _Unwind_Resume(a1);
}

uint64_t quasar::rescoring::RescorerConfig::loadTokenizer@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  if (*(this + 138) & 1) != 0 || (*(this + 139))
  {
    quasar::tennessee::TennesseeTokenizer::createTennesseeTokenizer(this + 144);
  }

  *a2 = 0;
  return this;
}

uint64_t std::optional<std::optional<quasar::filesystem::Path>>::~optional(uint64_t a1)
{
  if (*(a1 + 40) == 1 && *(a1 + 32) == 1)
  {
    *a1 = &unk_1F2CFAA28;
    if (*(a1 + 31) < 0)
    {
      operator delete(*(a1 + 8));
    }
  }

  return a1;
}

uint64_t std::__optional_copy_base<quasar::filesystem::Path,false>::__optional_copy_base[abi:ne200100](uint64_t a1, uint64_t a2)
{
  *a1 = 0;
  *(a1 + 32) = 0;
  if (*(a2 + 32) == 1)
  {
    std::__construct_at[abi:ne200100]<quasar::filesystem::Path,quasar::filesystem::Path const&,quasar::filesystem::Path*>(a1, a2);
    *(a1 + 32) = 1;
  }

  return a1;
}

void *std::__construct_at[abi:ne200100]<quasar::filesystem::Path,quasar::filesystem::Path const&,quasar::filesystem::Path*>(void *a1, uint64_t a2)
{
  *a1 = &unk_1F2CFAA28;
  v3 = (a1 + 1);
  if (*(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(a2 + 8), *(a2 + 16));
  }

  else
  {
    v4 = *(a2 + 8);
    v3->__r_.__value_.__r.__words[2] = *(a2 + 24);
    *&v3->__r_.__value_.__l.__data_ = v4;
  }

  return a1;
}

void std::__function::__func<quasar::rescoring::GetParam(std::optional<std::string> const&,quasar::SystemConfig const&,std::string const&,std::string const&,std::string const&)::$_0,std::allocator<quasar::rescoring::GetParam(std::optional<std::string> const&,quasar::SystemConfig const&,std::string const&,std::string const&,std::string const&)::$_0>,std::string ()(std::string const&)>::operator()(uint64_t a1@<X1>, std::string *a2@<X8>)
{
  if (*(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *a1, *(a1 + 8));
  }

  else
  {
    *&a2->__r_.__value_.__l.__data_ = *a1;
    a2->__r_.__value_.__r.__words[2] = *(a1 + 16);
  }
}

uint64_t std::__function::__func<quasar::rescoring::GetParam(std::optional<std::string> const&,quasar::SystemConfig const&,std::string const&,std::string const&,std::string const&)::$_0,std::allocator<quasar::rescoring::GetParam(std::optional<std::string> const&,quasar::SystemConfig const&,std::string const&,std::string const&,std::string const&)::$_0>,std::string ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__value_func<std::string ()(std::string const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t std::__function::__func<quasar::rescoring::RescorerConfig::RescorerConfig(quasar::SystemConfig const&,std::optional<std::string> const&,BOOL,BOOL)::$_0,std::allocator<quasar::rescoring::RescorerConfig::RescorerConfig(quasar::SystemConfig const&,std::optional<std::string> const&,BOOL,BOOL)::$_0>,float ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__value_func<float ()(std::string const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t std::__function::__value_func<std::optional<float> ()(std::string const&)>::operator()[abi:ne200100](uint64_t a1)
{
  v1 = *(a1 + 24);
  if (!v1)
  {
    std::__throw_bad_function_call[abi:ne200100]();
  }

  return (*(*v1 + 48))(v1) & 0xFFFFFFFFFFLL;
}

uint64_t std::__function::__func<quasar::rescoring::RescorerConfig::RescorerConfig(quasar::SystemConfig const&,std::optional<std::string> const&,BOOL,BOOL)::$_1,std::allocator<quasar::rescoring::RescorerConfig::RescorerConfig(quasar::SystemConfig const&,std::optional<std::string> const&,BOOL,BOOL)::$_1>,std::optional<float> ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__value_func<std::optional<float> ()(std::string const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void std::__function::__func<quasar::rescoring::RescorerConfig::RescorerConfig(quasar::SystemConfig const&,std::optional<std::string> const&,BOOL,BOOL)::$_2,std::allocator<quasar::rescoring::RescorerConfig::RescorerConfig(quasar::SystemConfig const&,std::optional<std::string> const&,BOOL,BOOL)::$_2>,std::optional<quasar::filesystem::Path> ()(std::string const&)>::operator()(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  quasar::filesystem::Path::Path(&v5, a1);
  *a2 = &unk_1F2CFAA28;
  v3 = (a2 + 8);
  if (SHIBYTE(v7) < 0)
  {
    std::string::__init_copy_ctor_external(v3, __p[0], __p[1]);
    v4 = SHIBYTE(v7);
    *(a2 + 32) = 1;
    v5 = &unk_1F2CFAA28;
    if (v4 < 0)
    {
      operator delete(__p[0]);
    }
  }

  else
  {
    *&v3->__r_.__value_.__l.__data_ = *__p;
    *(a2 + 24) = v7;
    *(a2 + 32) = 1;
  }
}

void sub_1B5A7E53C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<quasar::rescoring::RescorerConfig::RescorerConfig(quasar::SystemConfig const&,std::optional<std::string> const&,BOOL,BOOL)::$_2,std::allocator<quasar::rescoring::RescorerConfig::RescorerConfig(quasar::SystemConfig const&,std::optional<std::string> const&,BOOL,BOOL)::$_2>,std::optional<quasar::filesystem::Path> ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__value_func<std::optional<quasar::filesystem::Path> ()(std::string const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t std::__function::__func<BOOL (*)(std::string),std::allocator<BOOL (*)(std::string)>,BOOL ()(std::string const&)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2D415F8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<BOOL (*)(std::string),std::allocator<BOOL (*)(std::string)>,BOOL ()(std::string const&)>::operator()(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *a2, *(a2 + 8));
  }

  else
  {
    __p = *a2;
  }

  v3 = v2(&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  return v3;
}

void sub_1B5A7E754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<BOOL (*)(std::string),std::allocator<BOOL (*)(std::string)>,BOOL ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__func<quasar::rescoring::RescorerConfig::RescorerConfig(quasar::SystemConfig const&,std::optional<std::string> const&,BOOL,BOOL)::$_3,std::allocator<quasar::rescoring::RescorerConfig::RescorerConfig(quasar::SystemConfig const&,std::optional<std::string> const&,BOOL,BOOL)::$_3>,int ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__value_func<int ()(std::string const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t std::__function::__func<std::set<int> (*)(std::string const&),std::allocator<std::set<int> (*)(std::string const&)>,std::set<int> ()(std::string const&)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2D41728;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::set<int> (*)(std::string const&),std::allocator<std::set<int> (*)(std::string const&)>,std::set<int> ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__value_func<std::set<int> ()(std::string const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t std::__tree<std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<quasar::rescoring::AdapterModel>>(uint64_t a1, const void **a2)
{
  v2 = *std::__tree<std::__value_type<std::string,std::wstring>,std::__map_value_compare<std::string,std::__value_type<std::string,std::wstring>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::wstring>>>::__find_equal<std::string>(a1, &v4, a2);
  if (!v2)
  {
    std::__tree<std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>>>::__construct_node<std::string const&,std::unique_ptr<quasar::rescoring::AdapterModel>>();
  }

  return v2;
}

uint64_t std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::unique_ptr<quasar::rescoring::AdapterModel>>,void *>>>>::~unique_ptr[abi:ne200100](uint64_t a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(a1 + 16) == 1)
    {
      std::__destroy_at[abi:ne200100]<std::pair<std::string const,std::unique_ptr<quasar::rescoring::AdapterModel>>,0>(v2 + 32);
    }

    operator delete(v2);
  }

  return a1;
}

void *std::__shared_ptr_emplace<quasar::rescoring::Featurizer>::__shared_ptr_emplace[abi:ne200100]<quasar::rescoring::RescorerConfig const*,std::allocator<quasar::rescoring::Featurizer>,0>(void *a1, const quasar::rescoring::RescorerConfig **a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2D417D8;
  quasar::rescoring::Featurizer::Featurizer((a1 + 3), *a2);
  return a1;
}

void std::__shared_ptr_emplace<quasar::rescoring::Featurizer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D417D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void *std::__shared_ptr_emplace<quasar::SpeechRecognizerConfig>::__shared_ptr_emplace[abi:ne200100]<quasar::SystemConfig const&,quasar::DecoderOptions,std::allocator<quasar::SpeechRecognizerConfig>,0>(void *a1, const quasar::SystemConfig *a2, const quasar::DecoderOptions *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2D07788;
  quasar::SpeechRecognizerConfig::SpeechRecognizerConfig((a1 + 3), a2, a3);
  return a1;
}

uint64_t quasar::CommandTransform::char32Converter(quasar::CommandTransform *this)
{
  {
    operator new();
  }

  return quasar::CommandTransform::char32Converter(void)::converter;
}

void sub_1B5A7EEE0(_Unwind_Exception *a1)
{
  MEMORY[0x1B8C85350](v1, 0x1032C4095874D8CLL);
  _Unwind_Resume(a1);
}

void quasar::CommandTransform::getCommandTransform(uint64_t a1)
{
  v1 = MEMORY[0x1EEE9AC00](a1);
  v24 = *MEMORY[0x1E69E9840];
  switch(v1)
  {
    case 1:
      *(&v6 + 1) = 1;
      LODWORD(v7) = 3;
      *&v6 = &unk_1F2D41828;
      *(&v7 + 1) = v2;
      operator new();
    case 2:
      *(&v6 + 1) = 0x300000002;
      LODWORD(v7) = 3;
      *&v6 = &unk_1F2D41878;
      operator new();
    case 3:
      *(&v6 + 1) = 3;
      LODWORD(v7) = 3;
      *&v6 = &unk_1F2D41850;
      *(&v7 + 1) = v2;
      operator new();
    case 4:
      *(&v6 + 1) = 4;
      LODWORD(v7) = 4;
      *&v6 = &unk_1F2D41AF8;
      operator new();
    case 5:
      *(&v6 + 1) = 5;
      LODWORD(v7) = 3;
      *&v6 = &unk_1F2D418A0;
      *(&v7 + 1) = v2;
      operator new();
    case 6:
      *(&v6 + 1) = 0x700000006;
      LODWORD(v7) = 3;
      *&v6 = &unk_1F2D418F0;
      operator new();
    case 7:
      *(&v6 + 1) = 7;
      LODWORD(v7) = 3;
      *&v6 = &unk_1F2D418C8;
      *(&v7 + 1) = v2;
      *&v8 = v3;
      v23 = 1;
      operator new();
    case 8:
      *(&v6 + 1) = 8;
      LODWORD(v7) = 4;
      *&v6 = &unk_1F2D41A08;
      BYTE4(v7) = 1;
      operator new();
    case 9:
      *(&v6 + 1) = 9;
      LODWORD(v7) = 4;
      *&v6 = &unk_1F2D41A30;
      BYTE4(v7) = 1;
      operator new();
    case 10:
      *(&v6 + 1) = 10;
      LODWORD(v7) = 4;
      *&v6 = &unk_1F2D41AA8;
      operator new();
    case 11:
      *(&v6 + 1) = 11;
      LODWORD(v7) = 3;
      *&v6 = &unk_1F2D41918;
      *(&v7 + 1) = v2;
      operator new();
    case 12:
      *(&v6 + 1) = 0xD0000000CLL;
      LODWORD(v7) = 3;
      *&v6 = &unk_1F2D41968;
      operator new();
    case 13:
      *(&v6 + 1) = 13;
      LODWORD(v7) = 3;
      *&v6 = &unk_1F2D41940;
      *(&v7 + 1) = v2;
      operator new();
    case 14:
      *(&v6 + 1) = 14;
      LODWORD(v7) = 2;
      *&v6 = &unk_1F2D41990;
      operator new();
    case 15:
      *(&v6 + 1) = 0x100000000FLL;
      LODWORD(v7) = 1;
      *&v6 = &unk_1F2D419E0;
      operator new();
    case 16:
      *(&v6 + 1) = 16;
      LODWORD(v7) = 1;
      *&v6 = &unk_1F2D419B8;
      operator new();
    case 17:
      *(&v6 + 1) = 17;
      LODWORD(v7) = 4;
      *&v6 = &unk_1F2D41A58;
      BYTE4(v7) = 1;
      operator new();
    case 18:
      *(&v6 + 1) = 18;
      LODWORD(v7) = 4;
      *&v6 = &unk_1F2D41AD0;
      operator new();
    case 19:
      *(&v6 + 1) = 19;
      LODWORD(v7) = 4;
      *&v6 = &unk_1F2D41A80;
      operator new();
    default:
      v4 = v1;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      v13 = 0u;
      v14 = 0u;
      v11 = 0u;
      v12 = 0u;
      v9 = 0u;
      v10 = 0u;
      v7 = 0u;
      v8 = 0u;
      v6 = 0u;
      kaldi::KaldiWarnMessage::KaldiWarnMessage(&v6);
      v5 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v6, "Unrecognized commandId=", 23);
      MEMORY[0x1B8C84C00](v5, v4);
      quasar::QuasarExceptionMessage::~QuasarExceptionMessage(&v6);
  }
}

void sub_1B5A7FC4C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

void quasar::CommandTransform::initStringToCommandMap(void *a1)
{
  std::string::basic_string[abi:ne200100]<0>(__p, "\\all-caps");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 1;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\all-caps-on");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 3;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\all-caps-off");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 2;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\cap");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 5;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\spelling-cap");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 5;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\caps-on");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 7;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\caps-off");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 6;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\no-caps");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 11;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\no-caps-on");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 13;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\no-caps-off");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 12;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\no-space");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 14;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\no-space-on");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 16;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\no-space-off");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 15;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\new-line");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 8;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\new-paragraph");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 9;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, ".\\period-paragraph");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 17;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\tab-key");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 19;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\no-break-space");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 10;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\spelling-no-break-space");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 10;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\space-bar");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 18;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\backslash");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 4;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "\\spelling-backslash");
  v4 = __p;
  *(std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 10) = 4;
  if (v3 < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_1B5A80354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t quasar::CommandTransform::firstCharIsLetter(uint64_t a1)
{
  v2 = quasar::CommandTransform::char32Converter(a1);
  v3 = *(a1 + 23);
  if (v3 >= 0)
  {
    v4 = a1;
  }

  else
  {
    v4 = *a1;
  }

  if (v3 >= 0)
  {
    v5 = *(a1 + 23);
  }

  else
  {
    v5 = *(a1 + 8);
  }

  std::wstring_convert<std::codecvt_utf8<char32_t,1114111ul,(std::codecvt_mode)0>,char32_t,std::allocator<char32_t>,std::allocator<char>>::from_bytes(v2, v4, (v4 + v5), __p);
  if (v10 < 0)
  {
    if (!__p[1])
    {
      goto LABEL_14;
    }

    v6 = __p[0];
  }

  else
  {
    if (!v10)
    {
      goto LABEL_14;
    }

    v6 = __p;
  }

  if (u_isalpha(*v6))
  {
    v7 = 1;
    goto LABEL_15;
  }

LABEL_14:
  v7 = 0;
LABEL_15:
  if (v10 < 0)
  {
    operator delete(__p[0]);
  }

  return v7;
}

void sub_1B5A80460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t quasar::AllCapsCommandTransform::apply(uint64_t a1, void *a2, int a3)
{
  v40[2] = *MEMORY[0x1E69E9840];
  v4 = *a2 + 224 * a3;
  v5 = *(v4 + 23);
  if (v5 < 0)
  {
    v6 = *v4;
    v5 = *(v4 + 8);
    if (v5)
    {
      goto LABEL_3;
    }

LABEL_13:
    v11 = -1;
    goto LABEL_14;
  }

  v6 = (*a2 + 224 * a3);
  if (!*(v4 + 23))
  {
    goto LABEL_13;
  }

LABEL_3:
  v7 = &v6[v5];
  v8 = v6;
LABEL_4:
  v9 = 0;
  while (*v8 != asc_1B5C04E78[v9])
  {
    if (++v9 == 4)
    {
      if (++v8 != v7)
      {
        goto LABEL_4;
      }

      v8 = v7;
      break;
    }
  }

  v10 = v8 - v6;
  if (v8 == v7)
  {
    v11 = -1;
  }

  else
  {
    v11 = v10;
  }

LABEL_14:
  std::string::basic_string(&v38, (*a2 + 224 * a3), 0, v11, v21);
  v37 = 0;
  ucasemap_utf8ToUpper();
  if (v37 >= 1)
  {
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v22 = 0u;
    memset(v21, 0, sizeof(v21));
    kaldi::KaldiWarnMessage::KaldiWarnMessage(v21);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v21, "ucasemap_utf8ToUpper failed", 27);
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(v21);
  }

  if (v11 == -1)
  {
    std::string::basic_string[abi:ne200100]<0>(v21, (a1 + 32));
    if (*(v4 + 23) < 0)
    {
      operator delete(*v4);
    }

    v18 = *v21;
    *(v4 + 16) = *&v21[16];
    *v4 = v18;
  }

  else
  {
    std::string::basic_string[abi:ne200100]<0>(v21, (a1 + 32));
    std::string::basic_string(&v20, v4, v11, 0xFFFFFFFFFFFFFFFFLL, &v39);
    if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v12 = &v20;
    }

    else
    {
      v12 = v20.__r_.__value_.__r.__words[0];
    }

    if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(v20.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = v20.__r_.__value_.__l.__size_;
    }

    v14 = std::string::append(v21, v12, size);
    v15 = v14->__r_.__value_.__r.__words[0];
    v40[0] = v14->__r_.__value_.__l.__size_;
    *(v40 + 7) = *(&v14->__r_.__value_.__r.__words[1] + 7);
    v16 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (*(v4 + 23) < 0)
    {
      operator delete(*v4);
    }

    v17 = v40[0];
    *v4 = v15;
    *(v4 + 8) = v17;
    *(v4 + 15) = *(v40 + 7);
    *(v4 + 23) = v16;
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v20.__r_.__value_.__l.__data_);
    }

    if ((v21[23] & 0x80000000) != 0)
    {
      operator delete(*v21);
    }
  }

  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v38.__r_.__value_.__l.__data_);
  }

  return 1;
}

void sub_1B5A80704(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a2)
  {
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t quasar::AllCapsOnCommandTransform::apply(uint64_t a1, void *a2, int a3)
{
  v4 = *a2 + 224 * a3;
  v9 = 0;
  ucasemap_utf8ToUpper();
  std::string::basic_string[abi:ne200100]<0>(&v7, (a1 + 32));
  if (*(v4 + 23) < 0)
  {
    operator delete(*v4);
  }

  v5 = v7;
  *(v4 + 16) = v8;
  *v4 = v5;
  return 0;
}

uint64_t quasar::CapsOnCommandTransform::apply(uint64_t a1, void *a2, int a3)
{
  v4 = *a2 + 224 * a3;
  if ((*(a1 + 5040) & 1) != 0 || !std::__hash_table<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>>>::find<std::string>(*(a1 + 32), (*a2 + 224 * a3)))
  {
    *(a1 + 5040) = 0;
    if (quasar::CommandTransform::firstCharIsLetter(v4))
    {
      v9 = 0;
      ucasemap_utf8ToTitle();
      std::string::basic_string[abi:ne200100]<0>(&v7, (a1 + 40));
      if (*(v4 + 23) < 0)
      {
        operator delete(*v4);
      }

      v5 = v7;
      *(v4 + 16) = v8;
      *v4 = v5;
    }
  }

  else
  {
    *(a1 + 5040) = 0;
  }

  return 0;
}

uint64_t quasar::NoCapsCommandTransform::apply(uint64_t a1, void *a2, int a3)
{
  v40[2] = *MEMORY[0x1E69E9840];
  v4 = *a2 + 224 * a3;
  v5 = *(v4 + 23);
  if (v5 < 0)
  {
    v6 = *v4;
    v5 = *(v4 + 8);
    if (v5)
    {
      goto LABEL_3;
    }

LABEL_13:
    v11 = -1;
    goto LABEL_14;
  }

  v6 = (*a2 + 224 * a3);
  if (!*(v4 + 23))
  {
    goto LABEL_13;
  }

LABEL_3:
  v7 = &v6[v5];
  v8 = v6;
LABEL_4:
  v9 = 0;
  while (*v8 != asc_1B5C04E78[v9])
  {
    if (++v9 == 4)
    {
      if (++v8 != v7)
      {
        goto LABEL_4;
      }

      v8 = v7;
      break;
    }
  }

  v10 = v8 - v6;
  if (v8 == v7)
  {
    v11 = -1;
  }

  else
  {
    v11 = v10;
  }

LABEL_14:
  std::string::basic_string(&v38, (*a2 + 224 * a3), 0, v11, v21);
  v37 = 0;
  ucasemap_utf8ToLower();
  if (v37 >= 1)
  {
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v22 = 0u;
    memset(v21, 0, sizeof(v21));
    kaldi::KaldiWarnMessage::KaldiWarnMessage(v21);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v21, "ucasemap_utf8ToTitle failed", 27);
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(v21);
  }

  if (v11 == -1)
  {
    std::string::basic_string[abi:ne200100]<0>(v21, (a1 + 32));
    if (*(v4 + 23) < 0)
    {
      operator delete(*v4);
    }

    v18 = *v21;
    *(v4 + 16) = *&v21[16];
    *v4 = v18;
  }

  else
  {
    std::string::basic_string[abi:ne200100]<0>(v21, (a1 + 32));
    std::string::basic_string(&v20, v4, v11, 0xFFFFFFFFFFFFFFFFLL, &v39);
    if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v12 = &v20;
    }

    else
    {
      v12 = v20.__r_.__value_.__r.__words[0];
    }

    if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(v20.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = v20.__r_.__value_.__l.__size_;
    }

    v14 = std::string::append(v21, v12, size);
    v15 = v14->__r_.__value_.__r.__words[0];
    v40[0] = v14->__r_.__value_.__l.__size_;
    *(v40 + 7) = *(&v14->__r_.__value_.__r.__words[1] + 7);
    v16 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (*(v4 + 23) < 0)
    {
      operator delete(*v4);
    }

    v17 = v40[0];
    *v4 = v15;
    *(v4 + 8) = v17;
    *(v4 + 15) = *(v40 + 7);
    *(v4 + 23) = v16;
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v20.__r_.__value_.__l.__data_);
    }

    if ((v21[23] & 0x80000000) != 0)
    {
      operator delete(*v21);
    }
  }

  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v38.__r_.__value_.__l.__data_);
  }

  return 1;
}

void sub_1B5A80C6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a2)
  {
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t quasar::NoCapsOnCommandTransform::apply(uint64_t a1, void *a2, int a3)
{
  v4 = *a2 + 224 * a3;
  v9 = 0;
  ucasemap_utf8ToLower();
  std::string::basic_string[abi:ne200100]<0>(&v7, (a1 + 32));
  if (*(v4 + 23) < 0)
  {
    operator delete(*v4);
  }

  v5 = v7;
  *(v4 + 16) = v8;
  *v4 = v5;
  return 0;
}

uint64_t quasar::NoSpaceCommandTransform::apply(uint64_t a1, void *a2, uint64_t a3, unsigned int a4)
{
  if ((a4 & 0x80000000) == 0)
  {
    *(*a2 + 224 * a4 + 44) = 0;
  }

  return 1;
}

uint64_t quasar::NoSpaceOnCommandTransform::apply(uint64_t a1, void *a2, int a3)
{
  v5 = *a2 + 224 * a3;
  while (2)
  {
    v6 = *(v5 + 23);
    if (v6 < 0)
    {
      v7 = *v5;
      v6 = *(v5 + 8);
      if (!v6)
      {
        break;
      }
    }

    else
    {
      v7 = v5;
      if (!*(v5 + 23))
      {
        break;
      }
    }

    v8 = (v7 + v6);
    v9 = v7;
LABEL_7:
    v10 = 0;
    while (*v9 != asc_1B5C04E78[v10])
    {
      if (++v10 == 4)
      {
        if (++v9 != v8)
        {
          goto LABEL_7;
        }

        goto LABEL_15;
      }
    }

    if (v9 != v8 && &v9[-v7] != -1)
    {
      std::string::erase(v5, &v9[-v7], 1uLL);
      continue;
    }

    break;
  }

LABEL_15:
  *(*a2 + 224 * a3 + 44) = 0;
  return 0;
}

uint64_t quasar::NoSpaceOffCommandTransform::apply(uint64_t a1, void *a2, uint64_t a3, unsigned int a4, void *a5)
{
  if ((a4 & 0x80000000) == 0)
  {
    *(*a2 + 224 * a4 + 44) = *(*a5 + 224 * a4 + 44);
  }

  return 1;
}

uint64_t quasar::NewLineCommandTransform::apply(uint64_t a1, uint64_t *a2, int a3, unsigned int a4)
{
  v4 = *a2;
  if (*(a1 + 20) == 1)
  {
    if ((a4 & 0x80000000) == 0)
    {
      *(v4 + 224 * a4 + 44) = 0;
    }

    *(v4 + 224 * a3 + 44) = 0;
    MEMORY[0x1B8C84820]();
    result = 0;
    *(a1 + 20) = 0;
  }

  else
  {
    quasar::InverseTextNormalizer::capitalizeFirstLetter(v4 + 224 * a3);
    return 1;
  }

  return result;
}

uint64_t quasar::NewParagraphCommandTransform::apply(uint64_t a1, uint64_t *a2, int a3, unsigned int a4)
{
  v4 = *a2;
  if (*(a1 + 20) == 1)
  {
    if ((a4 & 0x80000000) == 0)
    {
      *(v4 + 224 * a4 + 44) = 0;
    }

    *(v4 + 224 * a3 + 44) = 0;
    MEMORY[0x1B8C84820]();
    result = 0;
    *(a1 + 20) = 0;
  }

  else
  {
    quasar::InverseTextNormalizer::capitalizeFirstLetter(v4 + 224 * a3);
    return 1;
  }

  return result;
}

uint64_t quasar::PeriodParagraphCommandTransform::apply(uint64_t a1, uint64_t *a2, int a3, unsigned int a4)
{
  v4 = *a2;
  if (*(a1 + 20) == 1)
  {
    if ((a4 & 0x80000000) == 0)
    {
      *(v4 + 224 * a4 + 44) = 0;
    }

    *(v4 + 224 * a3 + 44) = 0;
    MEMORY[0x1B8C84820]();
    result = 0;
    *(a1 + 20) = 0;
  }

  else
  {
    quasar::InverseTextNormalizer::capitalizeFirstLetter(v4 + 224 * a3);
    return 1;
  }

  return result;
}

uint64_t quasar::TabKeyCommandTransform::apply(uint64_t a1, uint64_t *a2, int a3, unsigned int a4)
{
  v4 = *a2;
  if ((a4 & 0x80000000) == 0)
  {
    *(v4 + 224 * a4 + 44) = 0;
  }

  *(v4 + 224 * a3 + 44) = 0;
  MEMORY[0x1B8C84820]();
  return 1;
}

uint64_t quasar::NoBreakSpaceCommandTransform::apply(uint64_t a1, uint64_t *a2, int a3, unsigned int a4)
{
  v4 = *a2;
  if ((a4 & 0x80000000) == 0)
  {
    *(v4 + 224 * a4 + 44) = 0;
  }

  *(v4 + 224 * a3 + 44) = 0;
  MEMORY[0x1B8C84820]();
  return 1;
}

uint64_t quasar::SpaceBarCommandTransform::apply(uint64_t a1, void *a2, int a3)
{
  *(*a2 + 224 * a3 + 44) = 0;
  MEMORY[0x1B8C84820]();
  if (0x6DB6DB6DB6DB6DB7 * ((a2[1] - *a2) >> 5) - 1 > a3)
  {
    v5 = *a2 + 224 * a3;
    if (a3)
    {
      *(v5 - 180) = 1;
    }

    else
    {
      MEMORY[0x1B8C84820](v5, " ");
    }
  }

  return 1;
}

uint64_t quasar::BackslashCommandTransform::apply(uint64_t a1, uint64_t *a2, int a3, unsigned int a4)
{
  v4 = *a2;
  if ((a4 & 0x80000000) == 0)
  {
    *(v4 + 224 * a4 + 44) = 0;
  }

  *(v4 + 224 * a3 + 44) = 0;
  MEMORY[0x1B8C84820]();
  return 1;
}

void std::__shared_ptr_emplace<quasar::AllCapsCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D41CF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::AllCapsOnCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D41D48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::AllCapsOffCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D41D98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::CapCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D41DE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::CapsOnCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D41E38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::CapsOffCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D41E88;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::NoCapsCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D41ED8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::NoCapsOnCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D41F28;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::NoCapsOffCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D41F78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::NoSpaceCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D41FC8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::NoSpaceOnCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D42018;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::NoSpaceOffCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D42068;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::NewLineCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D420B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::NewParagraphCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D42108;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::PeriodParagraphCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D42158;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::TabKeyCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D421A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::NoBreakSpaceCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D421F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::SpaceBarCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D42248;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void std::__shared_ptr_emplace<quasar::BackslashCommandTransform>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2D42298;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C85350);
}

void quasar::SentencePieceModule::SentencePieceModule(uint64_t a1, const void **a2, uint64_t a3, int a4)
{
  *a1 = a4 == 1;
  v7 = (a1 + 32);
  std::string::basic_string[abi:ne200100]<0>((a1 + 8), "");
  std::string::basic_string[abi:ne200100]<0>(v7, "");
  std::string::basic_string[abi:ne200100]<0>((a1 + 56), "");
  *(a1 + 84) = 0;
  *(a1 + 80) = 0x10000;
  *(a1 + 88) = 0u;
  *(a1 + 104) = 0u;
  *(a1 + 120) = 1065353216;
  *(a1 + 128) = 0;
  *(a1 + 130) = 0;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = 1065353216;
  std::string::basic_string[abi:ne200100]<0>((a1 + 184), "");
  *(a1 + 208) = 0u;
  *(a1 + 224) = 0u;
  *(a1 + 240) = 1065353216;
  if (*(a3 + 23) >= 0)
  {
    v8 = *(a3 + 23);
  }

  else
  {
    v8 = *(a3 + 8);
  }

  p_p = &__p;
  std::string::basic_string[abi:ne200100](&__p, v8 + 1);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if (v8)
  {
    if (*(a3 + 23) >= 0)
    {
      v10 = a3;
    }

    else
    {
      v10 = *a3;
    }

    memmove(p_p, v10, v8);
  }

  *(&p_p->__r_.__value_.__l.__data_ + v8) = 46;
  quasar::SystemConfig::setPrefix(a2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "bpe-model-file");
  std::string::basic_string[abi:ne200100]<0>(v11, "SentencePiece model file");
  quasar::SystemConfig::Register<std::string>(a2, &__p.__r_.__value_.__l.__data_, a1 + 8, v11, 0, 252, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "e2e-model-unit-file");
  std::string::basic_string[abi:ne200100]<0>(v11, "Units text file. One unit per line. First column contains the unit, written as a string.");
  quasar::SystemConfig::Register<std::string>(a2, &__p.__r_.__value_.__l.__data_, v7, v11, 1, 252, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "remove-all-tags");
  std::string::basic_string[abi:ne200100]<0>(v11, "Preprocessing: Clean tags associated with words. Example: I\\pronoun -> I.");
  quasar::SystemConfig::Register<BOOL>(a2, &__p.__r_.__value_.__l.__data_, a1 + 82, v11, 0, 258, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "split-compound-words");
  std::string::basic_string[abi:ne200100]<0>(v11, "Preprocessing: Split compound words into individual words, compound words are defined as multiple words concatenated by underscore symbol (_). Example: never_mind -> never mind.");
  quasar::SystemConfig::Register<BOOL>(a2, &__p.__r_.__value_.__l.__data_, a1 + 83, v11, 0, 258, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "preserve-existing-compounds");
  std::string::basic_string[abi:ne200100]<0>(v11, "Preprocessing: Whether to preserve compound words that exist in the units file, if set to true, the compound word won't be split. Example: If New_York is a unit, 'New_York' will not be split into 'New York'");
  quasar::SystemConfig::Register<BOOL>(a2, &__p.__r_.__value_.__l.__data_, a1 + 84, v11, 0, 258, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "remap-dict");
  std::string::basic_string[abi:ne200100]<0>(v11, "Preprocessing: A 1-to-1 dictionary of substitutions for SentencePiece input pieces. Example: {foo: bar} will map every 'foo' piece to 'bar'. ");
  quasar::SystemConfig::Register<std::unordered_map<std::string,std::string>>(a2, &__p.__r_.__value_.__l.__data_, a1 + 88, v11, 0, 258, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "add-bos");
  std::string::basic_string[abi:ne200100]<0>(v11, "Add BOS <s> to the input sequence. ");
  quasar::SystemConfig::Register<BOOL>(a2, &__p.__r_.__value_.__l.__data_, a1 + 128, v11, 0, 258, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "add-eos");
  std::string::basic_string[abi:ne200100]<0>(v11, "Add EOS </s> to the input sequence. ");
  quasar::SystemConfig::Register<BOOL>(a2, &__p.__r_.__value_.__l.__data_, a1 + 129, v11, 0, 258, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "reverse");
  std::string::basic_string[abi:ne200100]<0>(v11, "Reverse the input sequence. ");
  quasar::SystemConfig::Register<BOOL>(a2, &__p.__r_.__value_.__l.__data_, a1 + 130, v11, 0, 258, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "user-defined-symbols");
  std::string::basic_string[abi:ne200100]<0>(v11, "Some user defined symbols that can be bypassed splitting");
  quasar::SystemConfig::Register<std::string>(a2, &__p.__r_.__value_.__l.__data_, a1 + 56, v11, 0, 258, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:ne200100]<0>(&__p, "separate-start-symbol-and-non-cjk");
  std::string::basic_string[abi:ne200100]<0>(v11, "If true, will split the wordpiece start symbol and the first non cjk characters.");
  quasar::SystemConfig::Register<BOOL>(a2, &__p.__r_.__value_.__l.__data_, a1 + 81, v11, 0, 258, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  if (v12 < 0)
  {
    operator delete(v11[0]);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  quasar::SystemConfig::readPtree(a2, a3);
}

void sub_1B5A824EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t *a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  if (a24 < 0)
  {
    operator delete(a19);
  }

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v27);
  if (*(v24 + 207) < 0)
  {
    operator delete(*(v26 + 100));
  }

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v26 + 60);
  v29 = *a11;
  *a11 = 0;
  if (v29)
  {
    (*(*v29 + 8))(v29);
  }

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(a12);
  if (*(v24 + 79) < 0)
  {
    operator delete(*(v24 + 56));
  }

  if (*(v24 + 55) < 0)
  {
    operator delete(*v25);
  }

  if (*(v24 + 31) < 0)
  {
    operator delete(*(v24 + 8));
  }

  _Unwind_Resume(a1);
}

void quasar::SystemConfig::Register<std::unordered_map<std::string,std::string>>(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, int a9)
{
  quasar::SystemConfig::Register(a1, a2, a3);
  quasar::result_handler::Range::Range(&v21, a6, a7);
  v15 = (a1 + 824);
  std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>((a1 + 824), a2, __p);
  v22 = __p;
  v16 = std::__tree<std::__value_type<std::string,quasar::SystemConfig::Version>,std::__map_value_compare<std::string,std::__value_type<std::string,quasar::SystemConfig::Version>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,quasar::SystemConfig::Version>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1 + 1480, __p);
  *(v16 + 56) = v21;
  if (v20 < 0)
  {
    operator delete(__p[0]);
  }

  quasar::result_handler::Range::Range(&v21, a8, a9);
  std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>((a1 + 824), a2, __p);
  v22 = __p;
  v17 = std::__tree<std::__value_type<std::string,quasar::SystemConfig::Version>,std::__map_value_compare<std::string,std::__value_type<std::string,quasar::SystemConfig::Version>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,quasar::SystemConfig::Version>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1 + 1504, __p);
  *(v17 + 56) = v21;
  if (v20 < 0)
  {
    operator delete(__p[0]);
    if (!a5)
    {
      return;
    }
  }

  else if (!a5)
  {
    return;
  }

  __p[0] = (a1 + 824);
  v18 = std::__tree<std::__value_type<std::string,std::set<std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 1528, (a1 + 824));
  std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(v15, a2, __p);
  std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>(v18 + 56, __p);
  if (v20 < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_1B5A827C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t quasar::SentencePieceModule::init(quasar::SentencePieceModule *this)
{
  v65[20] = *MEMORY[0x1E69E9840];
  if (quasar::gLogLevel >= 5)
  {
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v59 = 0u;
    v60 = 0u;
    v57 = 0u;
    v58 = 0u;
    v55 = 0u;
    v56 = 0u;
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    kaldi::KaldiWarnMessage::KaldiWarnMessage(&v48);
    v2 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v48, "Initializing SentencePieceModule:", 33);
    v3 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v2, " removeAllTags=", 15);
    v4 = MEMORY[0x1B8C84BD0](v3, *(this + 82));
    v5 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v4, " splitCompoundWords=", 20);
    v6 = MEMORY[0x1B8C84BD0](v5, *(this + 83));
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, " preserveExistingCompounds=", 27);
    v8 = MEMORY[0x1B8C84BD0](v7, *(this + 84));
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, " remapDictSize=", 15);
    v10 = MEMORY[0x1B8C84C30](v9, *(this + 14));
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, " requiresBpeModelFile=", 22);
    MEMORY[0x1B8C84BD0](v11, *this);
    quasar::QuasarDebugMessage::~QuasarDebugMessage(&v48);
  }

  if (*this)
  {
    goto LABEL_6;
  }

  if ((*(this + 31) & 0x8000000000000000) != 0)
  {
    if (!*(this + 2))
    {
      goto LABEL_30;
    }

LABEL_6:
    operator new();
  }

  if (*(this + 31))
  {
    goto LABEL_6;
  }

LABEL_30:
  if (quasar::gLogLevel >= 5)
  {
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v59 = 0u;
    v60 = 0u;
    v57 = 0u;
    v58 = 0u;
    v55 = 0u;
    v56 = 0u;
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    kaldi::KaldiWarnMessage::KaldiWarnMessage(&v48);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v48, "Sentence piece model is not provided. Will split text into characters.", 70);
    quasar::QuasarDebugMessage::~QuasarDebugMessage(&v48);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, ",");
  quasar::splitAndTrimNoEmpty((this + 56), __p, &v48);
  if (SBYTE7(v31) < 0)
  {
    operator delete(__p[0]);
  }

  v13 = *(&v48 + 1);
  for (i = v48; i != v13; i += 3)
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(this + 26, i);
  }

  __p[0] = &v48;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](__p);
  std::ifstream::basic_ifstream(&v48);
  v14 = v48;
  if ((*(&v50 + *(v48 - 24)) & 5) != 0)
  {
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    *__p = 0u;
    kaldi::KaldiWarnMessage::KaldiWarnMessage(__p);
    v22 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(__p, "Failed to open e2eModelUnitFile: ", 33);
    v23 = *(this + 55);
    if (v23 >= 0)
    {
      v24 = this + 32;
    }

    else
    {
      v24 = *(this + 4);
    }

    if (v23 >= 0)
    {
      v25 = *(this + 55);
    }

    else
    {
      v25 = *(this + 5);
    }

    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v22, v24, v25);
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(__p);
  }

  __p[0] = 0;
  __p[1] = 0;
  v15 = MEMORY[0x1E69E5318];
  *&v31 = 0;
  while (1)
  {
    std::ios_base::getloc((&v48 + *(v14 - 24)));
    v16 = std::locale::use_facet(&v28, v15);
    v17 = (v16->__vftable[2].~facet_0)(v16, 10);
    std::locale::~locale(&v28);
    v18 = std::getline[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(&v48, __p, v17);
    if ((*(v18 + *(*v18 - 24) + 32) & 5) != 0)
    {
      break;
    }

    std::string::basic_string[abi:ne200100]<0>(v26, " ");
    quasar::splitAndTrimNoEmpty(__p, v26, &v28);
    if (v27 < 0)
    {
      operator delete(v26[0]);
    }

    if (v28.__locale_ != v29)
    {
      if (0xAAAAAAAAAAAAAAABLL * ((v29 - v28.__locale_) >> 3) < 2)
      {
        v19 = -1;
      }

      else
      {
        v19 = std::stoi(v28.__locale_ + 1, 0, 10);
      }

      locale = v28.__locale_;
      *(std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(this + 18, v28.__locale_) + 10) = v19;
    }

    v26[0] = &v28;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](v26);
    v14 = v48;
  }

  if (SBYTE7(v31) < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(__p, "");
  v20 = std::__hash_table<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>>>::find<std::string>(this + 18, __p);
  if (SBYTE7(v31) < 0)
  {
    operator delete(__p[0]);
  }

  if (v20)
  {
    kaldi::KaldiWarnMessage::KaldiWarnMessage(__p);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(__p, "isOov()", 9);
    kaldi::KaldiErrorMessage::~KaldiErrorMessage(__p);
  }

  *&v48 = *MEMORY[0x1E69E54C8];
  *(&v48 + *(v48 - 24)) = *(MEMORY[0x1E69E54C8] + 24);
  MEMORY[0x1B8C84A00](&v49);
  std::istream::~istream();
  return MEMORY[0x1B8C85200](v65);
}

void sub_1B5A83108(void *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  JUMPOUT(0x1B5A83138);
}

void quasar::SentencePieceModule::~SentencePieceModule(void **this)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((this + 26));
  if (*(this + 207) < 0)
  {
    operator delete(this[23]);
  }

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((this + 18));
  v2 = this[17];
  this[17] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((this + 11));
  if (*(this + 79) < 0)
  {
    operator delete(this[7]);
  }

  if (*(this + 55) < 0)
  {
    operator delete(this[4]);
  }

  if (*(this + 31) < 0)
  {
    operator delete(this[1]);
  }
}

void quasar::SentencePieceModule::preprocess(uint64_t a1, const std::string *a2)
{
  memset(v30, 0, sizeof(v30));
  std::string::basic_string[abi:ne200100]<0>(&__p, " ");
  quasar::splitAndTrimNoEmpty(a2, &__p, &v28);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v4 = v28;
  v5 = v29;
  while (v4 != v5)
  {
    if (*(v4 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&__p, *v4, v4[1]);
    }

    else
    {
      v6 = *v4;
      __p.__r_.__value_.__r.__words[2] = v4[2];
      *&__p.__r_.__value_.__l.__data_ = v6;
    }

    size = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x8000000000000000) != 0)
    {
      if (__p.__r_.__value_.__l.__size_ != 14)
      {
        if (*(a1 + 82) == 1)
        {
          size = __p.__r_.__value_.__l.__size_;
LABEL_23:
          v12 = __p.__r_.__value_.__r.__words[0];
          goto LABEL_24;
        }

LABEL_36:
        memset(&v26, 0, sizeof(v26));
        if (*(a1 + 83) != 1 || *(a1 + 84) == 1 && std::__hash_table<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>>>::find<std::string>((a1 + 144), &__p.__r_.__value_.__l.__data_))
        {
          std::vector<std::string>::push_back[abi:ne200100](&v26, &__p);
        }

        else
        {
          std::string::basic_string[abi:ne200100]<0>(v23, "_");
          quasar::splitAndTrimNoEmpty(&__p, v23, &v25);
          std::vector<std::string>::__vdeallocate(&v26);
          v26 = v25;
          memset(&v25, 0, sizeof(v25));
          v31 = &v25;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v31);
          if (v24 < 0)
          {
            operator delete(v23[0]);
          }
        }

        v17 = v26.__r_.__value_.__l.__size_;
        for (i = v26.__r_.__value_.__r.__words[0]; i != v17; i += 24)
        {
          if (*(i + 23) < 0)
          {
            std::string::__init_copy_ctor_external(&v25, *i, *(i + 8));
          }

          else
          {
            v19 = *i;
            v25.__r_.__value_.__r.__words[2] = *(i + 16);
            *&v25.__r_.__value_.__l.__data_ = v19;
          }

          v20 = std::__hash_table<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>>>::find<std::string>((a1 + 88), &v25.__r_.__value_.__l.__data_);
          if (v20)
          {
            std::string::operator=(&v25, (v20 + 5));
          }

          v21 = HIBYTE(v25.__r_.__value_.__r.__words[2]);
          v22 = HIBYTE(v25.__r_.__value_.__r.__words[2]);
          if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          {
            v21 = v25.__r_.__value_.__l.__size_;
          }

          if (v21)
          {
            std::vector<std::string>::push_back[abi:ne200100](v30, &v25);
            v22 = HIBYTE(v25.__r_.__value_.__r.__words[2]);
          }

          if (v22 < 0)
          {
            operator delete(v25.__r_.__value_.__l.__data_);
          }
        }

        v25.__r_.__value_.__r.__words[0] = &v26;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v25);
        LOBYTE(size) = *(&__p.__r_.__value_.__s + 23);
        goto LABEL_57;
      }

      p_p = __p.__r_.__value_.__r.__words[0];
    }

    else
    {
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 14)
      {
        if (*(a1 + 82) == 1)
        {
          goto LABEL_20;
        }

        goto LABEL_36;
      }

      p_p = &__p;
    }

    v9 = p_p->__r_.__value_.__r.__words[0];
    v10 = *(p_p->__r_.__value_.__r.__words + 6);
    if (v9 != 0x5F4E454B4F50533CLL || v10 != 0x3E4553494F4E5F4ELL)
    {
      if (*(a1 + 82))
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          size = __p.__r_.__value_.__l.__size_;
          goto LABEL_23;
        }

LABEL_20:
        v12 = &__p;
LABEL_24:
        v13 = v12 + size;
        if (size >= 1)
        {
          v14 = v12;
          do
          {
            v15 = memchr(v14, 92, size);
            if (!v15)
            {
              break;
            }

            if (*v15 == 92)
            {
              goto LABEL_30;
            }

            v14 = (v15 + 1);
            size = v13 - v14;
          }

          while (v13 - v14 > 0);
        }

        v15 = v13;
LABEL_30:
        if (v15 == v13)
        {
          v16 = -1;
        }

        else
        {
          v16 = v15 - v12;
        }

        std::string::basic_string(&v26, &__p, 0, v16, &v25);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }

        __p = v26;
      }

      goto LABEL_36;
    }

LABEL_57:
    if ((size & 0x80) != 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    v4 += 3;
  }

  __p.__r_.__value_.__r.__words[0] = &v28;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&__p);
  v28 = " ";
  v29 = 1;
  quasar::join<std::vector<std::string>>(v30, &v28);
  v28 = v30;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v28);
}

void sub_1B5A83568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, char a34)
{
  __p = (v34 - 120);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&__p);
  _Unwind_Resume(a1);
}

void quasar::SentencePieceModule::encode(uint64_t a1@<X0>, const std::string *a2@<X1>, _BYTE *a3@<X8>)
{
  v16 = *MEMORY[0x1E69E9840];
  quasar::SentencePieceModule::preprocess(a1, a2);
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(v15.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = v15.__r_.__value_.__l.__size_;
  }

  if (size)
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v6 = *(a1 + 136);
    if (!v6)
    {
      std::string::basic_string[abi:ne200100]<0>(__p, " ");
      quasar::splitAndTrimNoEmpty(&v15, __p, &v11);
      if (v10 < 0)
      {
        operator delete(__p[0]);
      }

      operator new();
    }

    (*(*v6 + 104))(__p);
    if (__p[0])
    {
      std::string::basic_string[abi:ne200100]<0>(a3, "");
      sentencepiece::util::Status::~Status(__p);
    }

    else
    {
      sentencepiece::util::Status::~Status(__p);
      v7 = v13;
      v8 = v12;
      if (v12 != v13)
      {
        while (std::__hash_table<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>>>::find<std::string>((a1 + 144), v8))
        {
          v8 += 3;
          if (v8 == v7)
          {
            __p[0] = " ";
            __p[1] = 1;
            quasar::join<std::vector<std::string>>(&v12, __p);
            goto LABEL_17;
          }
        }
      }

      std::string::basic_string[abi:ne200100]<0>(a3, "");
    }

LABEL_17:
    __p[0] = &v12;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](__p);
  }

  else
  {
    std::string::basic_string[abi:ne200100]<0>(a3, "");
  }

  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
}

void sub_1B5A83BF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (v23 < 0)
  {
    operator delete(v22[34]);
  }

  std::wstring_convert<std::codecvt_utf8<char32_t,1114111ul,(std::codecvt_mode)0>,char32_t,std::allocator<char32_t>,std::allocator<char>>::~wstring_convert(&v27);
  v22[0] = &v24;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](v22);
  v22[0] = v25;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](v22);
  if (v26 < 0)
  {
    operator delete(v25[4]);
  }

  _Unwind_Resume(a1);
}

uint64_t quasar::SentencePieceModule::encode(uint64_t a1, const std::string *a2, void *a3)
{
  quasar::SentencePieceModule::preprocess(a1, a2);
  if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(v29.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = v29.__r_.__value_.__l.__size_;
  }

  if (!size)
  {
    v7 = 0;
    a3[1] = *a3;
    goto LABEL_40;
  }

  v6 = *(a1 + 136);
  if (v6)
  {
    (*(*v6 + 112))(&v28);
    if (v28.__r_.__value_.__r.__words[0] || *a3 == a3[1])
    {
      sentencepiece::util::Status::~Status(&v28);
      v7 = 0;
    }

    else
    {
      sentencepiece::util::Status::~Status(&v28);
      v7 = 1;
    }

    goto LABEL_40;
  }

  quasar::SentencePieceModule::encode(a1, &v29, &v28);
  v8 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    v8 = v28.__r_.__value_.__l.__size_;
  }

  if (!v8)
  {
    v7 = 0;
    if ((*(&v28.__r_.__value_.__s + 23) & 0x80) == 0)
    {
      goto LABEL_40;
    }

    goto LABEL_39;
  }

  std::string::basic_string[abi:ne200100]<0>(__p, " ");
  quasar::splitAndTrimNoEmpty(&v28, __p, &v26);
  if (v25 < 0)
  {
    operator delete(__p[0]);
  }

  v9 = v26;
  v10 = v27;
  if (v26 == v27)
  {
LABEL_32:
    v7 = 1;
  }

  else
  {
    while (std::__hash_table<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>>>::find<std::string>((a1 + 144), v9))
    {
      v11 = std::__hash_table<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>>>::find<std::string>((a1 + 144), v9);
      if (!v11)
      {
        goto LABEL_43;
      }

      if ((v11[5] & 0x80000000) != 0)
      {
        break;
      }

      v12 = std::__hash_table<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>>>::find<std::string>((a1 + 144), v9);
      if (!v12)
      {
LABEL_43:
        std::__throw_out_of_range[abi:ne200100]("unordered_map::at: key not found");
      }

      v14 = a3[1];
      v13 = a3[2];
      if (v14 >= v13)
      {
        v16 = *a3;
        v17 = v14 - *a3;
        v18 = (v17 >> 2) + 1;
        if (v18 >> 62)
        {
          std::vector<int>::__throw_length_error[abi:ne200100]();
        }

        v19 = v13 - v16;
        if (v19 >> 1 > v18)
        {
          v18 = v19 >> 1;
        }

        if (v19 >= 0x7FFFFFFFFFFFFFFCLL)
        {
          v20 = 0x3FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v20 = v18;
        }

        if (v20)
        {
          std::__allocate_at_least[abi:ne200100]<std::allocator<int>>(a3, v20);
        }

        v21 = (4 * (v17 >> 2));
        *v21 = *(v12 + 10);
        v15 = v21 + 1;
        memcpy(0, v16, v17);
        v22 = *a3;
        *a3 = 0;
        a3[1] = v15;
        a3[2] = 0;
        if (v22)
        {
          operator delete(v22);
        }
      }

      else
      {
        *v14 = *(v12 + 10);
        v15 = v14 + 1;
      }

      a3[1] = v15;
      v9 += 3;
      if (v9 == v10)
      {
        goto LABEL_32;
      }
    }

    v7 = 0;
  }

  __p[0] = &v26;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](__p);
  if ((*(&v28.__r_.__value_.__s + 23) & 0x80) != 0)
  {
LABEL_39:
    operator delete(v28.__r_.__value_.__l.__data_);
  }

LABEL_40:
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v29.__r_.__value_.__l.__data_);
  }

  return v7;
}

void sub_1B5A83FEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (a23 < 0)
  {
    operator delete(a18);
  }

  if (a29 < 0)
  {
    operator delete(a24);
  }

  _Unwind_Resume(exception_object);
}

void quasar::tennessee::nashville::LoadNormalizationCollationFromArchive<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>>(quasar::tennessee::archive::ImmutableArchive *a1)
{
  std::__fs::filesystem::path::path[abi:ne200100]<char [14],void>(&v3, "wordlist");
  std::__fs::filesystem::path::path[abi:ne200100]<char [14],void>(&v2.__pn_, "collation.bin");
  std::__fs::filesystem::operator/[abi:ne200100](&v2, &v3, &__p);
  quasar::tennessee::archive::ImmutableArchive::GetAsByteBuffer(a1, &__p);
}

void sub_1B5A84190(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  v31 = *(v29 - 64);
  *(v29 - 72) = v27;
  *(v29 - 64) = 0;
  if (v31)
  {
    std::default_delete<quasar::PhonesetMapping>::operator()[abi:ne200100](v28 + 8, v31);
  }

  _Unwind_Resume(exception_object);
}

void *quasar::tennessee::unique_string_flatbuf_ptr<quasar::tennessee::flatbuf::UnicodeCodePointMappings>::~unique_string_flatbuf_ptr(void *a1)
{
  *a1 = &unk_1F2D42418;
  v4 = a1[1];
  v2 = a1 + 1;
  v3 = v4;
  *v2 = 0;
  if (v4)
  {
    std::default_delete<quasar::PhonesetMapping>::operator()[abi:ne200100](v2, v3);
  }

  return a1;
}

void quasar::tennessee::nashville::LoadLexiconFromArchive<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>>(quasar::tennessee::nashville *a1)
{
  quasar::tennessee::nashville::LoadMetadataFromArchive(a1, &v3);
  quasar::tennessee::nashville::LoadStringDataFromArchive(a1, &v2);
  quasar::tennessee::CreateDefaultCollation<std::string_view,true>();
}

void sub_1B5A84640(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35)
{
  if (a10)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::internal::VmemFileImmutableSortedArrayFlatbufferVectorImpl<long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>>,0>();
  }

  if (a30 < 0)
  {
    operator delete(__p);
  }

  if (a18 < 0)
  {
    operator delete(a13);
  }

  if (a24 < 0)
  {
    operator delete(a19);
  }

  if (a11)
  {
    (*(*a11 + 8))(a11);
  }

  v38 = *v35;
  *v35 = 0;
  if (v38)
  {
    (*(*v38 + 8))(v38);
  }

  if (a31)
  {
    (*(*a31 + 8))(a31);
  }

  if (a32)
  {
    (*(*a32 + 8))(a32);
  }

  if (a33)
  {
    (*(*a33 + 8))(a33);
  }

  if (a35)
  {
    (*(*a35 + 8))(a35);
  }

  v39 = *(v36 - 80);
  *(v36 - 88) = &unk_1F2D42468;
  *(v36 - 80) = 0;
  if (v39)
  {
    (*(*v39 + 8))(v39);
  }

  _Unwind_Resume(exception_object);
}

void quasar::tennessee::nashville::LoadMetadataFromArchive(quasar::tennessee::nashville *this@<X0>, void *a2@<X8>)
{
  std::__fs::filesystem::path::path[abi:ne200100]<char [14],void>(&v6, "wordlist");
  std::__fs::filesystem::path::path[abi:ne200100]<char [14],void>(&__p, "metadata.bin");
  std::__fs::filesystem::operator/[abi:ne200100](&__p, &v6, &v7);
  quasar::tennessee::nashville::LoadObjectFromArchive<quasar::tennessee::nashville::flatbuf::Metadata>(this, a2);
  if (SHIBYTE(v7.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v7.__pn_.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
}

void sub_1B5A84970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (*(v21 - 17) < 0)
  {
    operator delete(*(v21 - 40));
  }

  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a21 < 0)
  {
    operator delete(a16);
  }

  _Unwind_Resume(exception_object);
}

void quasar::tennessee::nashville::LoadStringDataFromArchive(uint64_t a1@<X0>, void *a2@<X8>)
{
  std::__fs::filesystem::path::path[abi:ne200100]<char [14],void>(&v5, "wordlist");
  std::__fs::filesystem::path::path[abi:ne200100]<char [14],void>(&v4.__pn_, "string_data.bin");
  std::__fs::filesystem::operator/[abi:ne200100](&v4, &v5, &__p);
  quasar::tennessee::nashville::LoadObjectFromArchive<quasar::tennessee::nashville::flatbuf::StringData>(a1, a2);
  if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__pn_.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v4.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v4.__pn_.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v5.__r_.__value_.__l.__data_);
  }
}

void sub_1B5A84A70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);
  }

  if (a15 < 0)
  {
    operator delete(a10);
  }

  if (a21 < 0)
  {
    operator delete(a16);
  }

  _Unwind_Resume(exception_object);
}

void quasar::tennessee::nashville::LoadTokenInfosFromArchive(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__fs::filesystem::path::path[abi:ne200100]<char [14],void>(&v7, "wordlist");
  std::__fs::filesystem::path::path[abi:ne200100]<char [14],void>(&v6.__pn_, "token_infos.bin");
  std::__fs::filesystem::operator/[abi:ne200100](&v6, &v7, &__p);
  (*(*a1 + 24))(&v9, a1, &__p, a3, 0);
  quasar::tennessee::generic_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(&v10, &v9, 4);
  v10 = &unk_1F2D42498;
  v5 = v9;
  v9 = 0;
  if (v5)
  {
    (*(*v5 + 8))(v5);
  }

  if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__pn_.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v6.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v6.__pn_.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v7.__r_.__value_.__l.__data_);
  }

  quasar::tennessee::nashville::CreateDefaultTokenInfoCollation();
}

void sub_1B5A84C9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27, uint64_t a28)
{
  if (a16)
  {
    quasar::tennessee::nashville::LoadTokenInfosFromArchive();
  }

  v30 = *(v28 - 64);
  *(v28 - 72) = &unk_1F2D424E0;
  *(v28 - 64) = 0;
  if (v30)
  {
    (*(*v30 + 8))(v30);
  }

  _Unwind_Resume(exception_object);
}

void sub_1B5A84F24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (a9)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData>,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::IterableCollation<std::string_view,wchar_t>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>,0>();
  }

  std::make_unique[abi:ne200100]<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData>,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::IterableCollation<std::string_view,wchar_t>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>,0>(&a10);
  v20 = *(v19 - 80);
  v21 = a17;
  a16 = &unk_1F2D42468;
  a17 = 0;
  if (v21)
  {
    (*(*v21 + 8))(v21);
  }

  MEMORY[0x1B8C85350](v18, v17);
  _Unwind_Resume(v20);
}

void sub_1B5A851E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a10)
  {
    quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load();
  }

  quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(&a11);
  v17 = *(v16 - 48);
  v18 = a16;
  a16 = 0;
  if (v18)
  {
    (*(*v18 + 8))(v18);
  }

  _Unwind_Resume(v17);
}

void quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>::Initialize(void *a1)
{
  if (!(*(*a1 + 24))(a1))
  {
    quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(a1);
  }

  memset(v2, 0, sizeof(v2));
  quasar::QuasarExceptionMessage::QuasarExceptionMessage(v2);
  quasar::QuasarExceptionMessage::~QuasarExceptionMessage(v2);
}

{
  quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>::Initialize(a1);
}

void *quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData>::~unique_vmem_file_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D42438;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return a1;
}

void *quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata>::~unique_vmem_file_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D42468;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return a1;
}

void sub_1B5A85644(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    quasar::tennessee::nashville::LoadLexiconFromArchive<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>>();
  }

  _Unwind_Resume(exception_object);
}

void quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void *a1)
{
  v23 = *MEMORY[0x1E69E9840];
  if (!(*(*a1 + 24))(a1))
  {
    v2 = (*(*a1 + 72))(a1);
    v3 = (*(*v2 + 16))(v2);
    *&v6 = &unk_1F2D26F70;
    *(&v6 + 1) = v3;
    *(&v7 + 1) = &v6;
    std::__function::__value_func<BOOL ()(std::string_view const&,std::string_view const&)>::operator=[abi:ne200100]((a1 + 8), &v6);
    std::__function::__value_func<BOOL ()(std::string_view const&,std::string_view const&)>::~__value_func[abi:ne200100](&v6);
    if (!a1[3])
    {
      v4 = (*(*a1 + 72))(a1);
      (*(*v4 + 32))(&v5);
      (*(*a1 + 56))(a1);
      (*(*a1 + 56))(a1);
      (*(*a1 + 64))(a1);
      std::make_unique[abi:ne200100]<quasar::tennessee::DirectSortedIndex<long long,std::string_view>,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,long long,unsigned long long,quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void)::{lambda(long long)#1},quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void)::{lambda(std::string_view)#1},0>();
    }

    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v12 = 0u;
    v10 = 0u;
    v11 = 0u;
    v8 = 0u;
    v9 = 0u;
    v6 = 0u;
    v7 = 0u;
    quasar::QuasarExceptionMessage::QuasarExceptionMessage(&v6);
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(&v6);
  }

  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v12 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  quasar::QuasarExceptionMessage::QuasarExceptionMessage(&v6);
  quasar::QuasarExceptionMessage::~QuasarExceptionMessage(&v6);
}

void sub_1B5A8597C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14)
  {
    (*(*a14 + 8))(a14);
  }

  _Unwind_Resume(exception_object);
}

void quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Create(uint64_t a1, uint64_t a2)
{
  v2[15] = *MEMORY[0x1E69E9840];
  (*(**a2 + 32))(v2);
  quasar::tennessee::CreateReorderingCollation<std::string_view>();
}

void sub_1B5A85CD0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, _Unwind_Exception *exception_object, uint64_t a18, char a19)
{
  if (a10)
  {
    quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load();
  }

  quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Create(&a11);
  v19 = exception_object;
  v20 = a12;
  a12 = 0;
  if (v20)
  {
    std::default_delete<std::vector<long long>>::operator()[abi:ne200100](&a12, v20);
  }

  v21 = a14;
  a14 = 0;
  if (v21)
  {
    (*(*v21 + 8))(v21);
  }

  _Unwind_Resume(v19);
}

uint64_t quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>::GetNormalizationCollationIndex(void *a1)
{
  if (((*(*a1 + 24))(a1) & 1) == 0)
  {
    memset(v3, 0, sizeof(v3));
    quasar::QuasarExceptionMessage::QuasarExceptionMessage(v3);
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(v3);
  }

  return a1[24];
}

const char *quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor::operator()(int a1, uint64_t *lpsrc, unint64_t a3)
{
  v5 = *lpsrc;
  if ((*(v5 + 56))(lpsrc) > a3 || (v7 = (*(*lpsrc + 56))(lpsrc), (*(*lpsrc + 64))(lpsrc) + v7 <= a3))
  {
    if (quasar::gLogLevel >= 2)
    {
      memset(v14, 0, sizeof(v14));
      kaldi::KaldiWarnMessage::KaldiWarnMessage(v14);
      v10 = MEMORY[0x1B8C84C60](v14, a3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, " is out of bounds.", 18);
      quasar::QuasarWarnMessage::~QuasarWarnMessage(v14);
    }

    return "";
  }

  else
  {
    v8 = *((*(*lpsrc + 88))(lpsrc, a3) + 4);
    v9 = (*(*lpsrc + 56))(lpsrc);
    if (v9 + (*(*lpsrc + 64))(lpsrc) - 1 != a3)
    {
      (*(*lpsrc + 88))(lpsrc, a3 + 1);
    }

    v12 = (v6 - *v6);
    if (*v12 < 5u)
    {
      v13 = 0;
    }

    else
    {
      v13 = v12[2];
      if (v13)
      {
        v13 += v6 + *(v6 + v13);
      }
    }

    return (v13 + v8 + 4);
  }
}

void sub_1B5A8628C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100](va);
  if (a4)
  {
    quasar::tennessee::nashville::CreateDefaultTokenInfoCollation();
  }

  MEMORY[0x1B8C85350](v4, 0x10E1C4061027E81);
  if (a3)
  {
    (*(*a3 + 8))(a3);
  }

  _Unwind_Resume(a1);
}

void sub_1B5A863E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100](va);
  if (a4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a4);
  }

  MEMORY[0x1B8C85350](v4, v5);
  _Unwind_Resume(a1);
}

quasar::tennessee::memory_mapping::VirtualMemoryFile *quasar::tennessee::nashville::LoadObjectFromArchive<quasar::tennessee::nashville::flatbuf::Metadata>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  (*(*a1 + 24))(&v4);
  quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(a2, &v4, 0);
  *a2 = &unk_1F2D427A0;
  result = v4;
  v4 = 0;
  if (result)
  {
    return (*(*result + 8))(result);
  }

  return result;
}

void sub_1B5A864BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::internal::VmemFileImmutableSortedArrayFlatbufferVectorImpl<long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>>,0>();
  }

  _Unwind_Resume(exception_object);
}

quasar::tennessee::memory_mapping::VirtualMemoryFile *quasar::tennessee::nashville::LoadObjectFromArchive<quasar::tennessee::nashville::flatbuf::StringData>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  (*(*a1 + 24))(&v4);
  quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(a2, &v4, 0);
  *a2 = &unk_1F2D427D8;
  result = v4;
  v4 = 0;
  if (result)
  {
    return (*(*result + 8))(result);
  }

  return result;
}

void sub_1B5A86588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::internal::VmemFileImmutableSortedArrayFlatbufferVectorImpl<long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>>,0>();
  }

  _Unwind_Resume(exception_object);
}

void sub_1B5A866C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a10)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::internal::VmemFileImmutableSortedArrayFlatbufferVectorImpl<long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>>,0>();
  }

  if (a14)
  {
    (*(*a14 + 8))(a14);
  }

  MEMORY[0x1B8C85350](v15, v14);
  _Unwind_Resume(a1);
}

void *quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>>::~unique_vmem_file_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D424E0;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return a1;
}

void quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>::~GenericNashvilleLexicon(void *a1)
{
  quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>::~GenericNashvilleLexicon(a1);

  JUMPOUT(0x1B8C85350);
}

uint64_t quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Find(uint64_t a1, const char *a2)
{
  quasar::tennessee::DecodeBytesToString<char>(a2, __p);
  v3 = v8;
  if ((v8 & 0x80u) == 0)
  {
    v4 = __p;
  }

  else
  {
    v4 = __p[0];
  }

  if ((v8 & 0x80u) != 0)
  {
    v3 = __p[1];
  }

  v9[0] = v4;
  v9[1] = v3;
  v5 = (*(*a1 + 40))(a1, v9);
  if (v8 < 0)
  {
    operator delete(__p[0]);
  }

  return v5;
}

void sub_1B5A86880(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Find(uint64_t a1, uint64_t a2)
{
  v31[4] = *MEMORY[0x1E69E9840];
  v27[0] = &unk_1F2D42DC8;
  v27[1] = a1;
  v27[3] = v27;
  v30 = (*(*a1 + 56))(a1);
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v24, v27);
  quasar::tennessee::internal::CreateIterator<long long,std::string_view,boost::iterators::counting_iterator<long long,boost::use_default,boost::use_default>>(&v30, v24, &v25);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v24);
  v4 = (*(*a1 + 56))(a1);
  v30 = (*(*a1 + 64))(a1) + v4;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v21, v27);
  quasar::tennessee::internal::CreateIterator<long long,std::string_view,boost::iterators::counting_iterator<long long,boost::use_default,boost::use_default>>(&v30, v21, &v22);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v21);
  v17 = v25;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v18, v26);
  v15 = v22;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v16, v23);
  std::__function::__value_func<BOOL ()(std::string_view const&,std::string_view const&)>::__value_func[abi:ne200100](v14, a1 + 64);
  v30 = v17;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v31, v18);
  v28 = v15;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v29, v16);
  std::__lower_bound[abi:ne200100]<std::_ClassicAlgPolicy,quasar::tennessee::internal::Iterator<long long,std::string_view,boost::iterators::counting_iterator<long long,boost::use_default,boost::use_default>>,quasar::tennessee::internal::Iterator<long long,std::string_view,boost::iterators::counting_iterator<long long,boost::use_default,boost::use_default>>,std::string_view,std::__identity,std::function<BOOL ()(std::string_view const&,std::string_view const&)>>(&v30, &v28, a2, v14, &v19);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v29);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v31);
  std::__function::__value_func<BOOL ()(std::string_view const&,std::string_view const&)>::~__value_func[abi:ne200100](v14);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v16);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v18);
  if (v19 != v22 && (v5 = std::function<std::string_view ()(long long)>::operator()(v20, v19), v6 = *(a2 + 8), v7 == v6) && !memcmp(v5, *a2, v6))
  {
    v12 = v25;
    std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v13, v26);
    v10 = v19;
    std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v11, v20);
    v8 = std::distance[abi:ne200100]<quasar::tennessee::internal::Iterator<long long,std::string_view,boost::iterators::counting_iterator<long long,boost::use_default,boost::use_default>>>(&v12, &v10);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v11);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v13);
  }

  else
  {
    v8 = -1;
  }

  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v20);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v23);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v26);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v27);
  return v8;
}

void sub_1B5A86B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45)
{
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v46 + 8);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v47 + 8);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v45 + 8);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&a45);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v48 - 232);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v48 - 200);
  _Unwind_Resume(a1);
}

uint64_t quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::GetData(uint64_t a1, uint64_t a2)
{
  quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::VerifyTokenIdBounds(a1, a2);
  v3 = *(**(a1 + 16) + 16);

  return v3();
}

void quasar::tennessee::unique_string_flatbuf_ptr<quasar::tennessee::flatbuf::UnicodeCodePointMappings>::~unique_string_flatbuf_ptr(void *a1)
{
  *a1 = &unk_1F2D42418;
  v3 = a1[1];
  v1 = a1 + 1;
  v2 = v3;
  *v1 = 0;
  if (v3)
  {
    std::default_delete<quasar::PhonesetMapping>::operator()[abi:ne200100](v1, v2);
  }

  JUMPOUT(0x1B8C85350);
}

void *quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::flatbuf::UnicodeCodePointMappings,std::string,std::unique_ptr<std::string>>::~generic_flatbuf_ptr(void *a1)
{
  *a1 = &unk_1F2D42418;
  v4 = a1[1];
  v2 = a1 + 1;
  v3 = v4;
  *v2 = 0;
  if (v4)
  {
    std::default_delete<quasar::PhonesetMapping>::operator()[abi:ne200100](v2, v3);
  }

  return a1;
}

void quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::flatbuf::UnicodeCodePointMappings,std::string,std::unique_ptr<std::string>>::~generic_flatbuf_ptr(void *a1)
{
  *a1 = &unk_1F2D42418;
  v3 = a1[1];
  v1 = a1 + 1;
  v2 = v3;
  *v1 = 0;
  if (v3)
  {
    std::default_delete<quasar::PhonesetMapping>::operator()[abi:ne200100](v1, v2);
  }

  JUMPOUT(0x1B8C85350);
}

void *quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::~generic_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D42438;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return a1;
}

void quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::~generic_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D42438;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  JUMPOUT(0x1B8C85350);
}

void *quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::~generic_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D42468;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return a1;
}

void quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::~generic_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D42468;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  JUMPOUT(0x1B8C85350);
}

uint64_t quasar::tennessee::generic_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(uint64_t a1, quasar::tennessee::memory_mapping::VirtualMemoryFile **a2, int a3)
{
  v4 = *a2;
  *a2 = 0;
  *a1 = &unk_1F2D424E0;
  *(a1 + 8) = v4;
  *(a1 + 16) = a3;
  if (!a3)
  {
    *(a1 + 24) = 0;
LABEL_9:
    v10 = quasar::tennessee::memory_mapping::VirtualMemoryFile::Data(v4);
    goto LABEL_10;
  }

  v5 = quasar::tennessee::memory_mapping::VirtualMemoryFile::Data(v4);
  v6 = (v5 + *v5);
  v7 = *(a1 + 16);
  *(a1 + 24) = v6;
  if (!v7)
  {
    v4 = *(a1 + 8);
    goto LABEL_9;
  }

  v8 = (v6 - *v6);
  if (*v8 > v7)
  {
    v9 = *(v8 + v7);
    if (v9)
    {
      v10 = (v6 + v9);
LABEL_10:
      v11 = v10 + *v10;
      goto LABEL_11;
    }
  }

  v11 = 0;
LABEL_11:
  *(a1 + 32) = v11;
  return a1;
}

void sub_1B5A870BC(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 8);
  *(v1 + 8) = 0;
  if (v3)
  {
    quasar::tennessee::generic_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(v3);
  }

  _Unwind_Resume(exception_object);
}

void quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>>::~unique_vmem_file_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D424E0;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  JUMPOUT(0x1B8C85350);
}

void *quasar::tennessee::generic_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::~generic_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D424E0;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return a1;
}

void quasar::tennessee::generic_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::~generic_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D424E0;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  JUMPOUT(0x1B8C85350);
}

void *quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>::~GenericNashvilleLexicon(void *a1)
{
  *a1 = &unk_1F2D42360;
  v2 = a1[24];
  a1[24] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = a1[23];
  a1[23] = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  v4 = a1[22];
  a1[22] = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  v5 = a1[18];
  a1[17] = &unk_1F2D42438;
  a1[18] = 0;
  if (v5)
  {
    (*(*v5 + 8))(v5);
  }

  v6 = a1[13];
  a1[12] = &unk_1F2D42468;
  a1[13] = 0;
  if (v6)
  {
    (*(*v6 + 8))(v6);
  }

  *a1 = &unk_1F2D42500;
  std::__function::__value_func<BOOL ()(std::string_view const&,std::string_view const&)>::~__value_func[abi:ne200100]((a1 + 8));
  std::__function::__value_func<std::string_view ()(quasar::tennessee::GenericLexicon<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view> const*,long long)>::~__value_func[abi:ne200100]((a1 + 4));
  v7 = a1[3];
  a1[3] = 0;
  if (v7)
  {
    (*(*v7 + 8))(v7);
  }

  v8 = a1[2];
  a1[2] = 0;
  if (v8)
  {
    (*(*v8 + 8))(v8);
  }

  return a1;
}

void *quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::~GenericLexiconImpl(void *a1)
{
  *a1 = &unk_1F2D42500;
  std::__function::__value_func<BOOL ()(std::string_view const&,std::string_view const&)>::~__value_func[abi:ne200100]((a1 + 8));
  std::__function::__value_func<std::string_view ()(quasar::tennessee::GenericLexicon<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view> const*,long long)>::~__value_func[abi:ne200100]((a1 + 4));
  v2 = a1[3];
  a1[3] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = a1[2];
  a1[2] = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  return a1;
}

uint64_t std::__function::__value_func<std::string_view ()(quasar::tennessee::GenericLexicon<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view> const*,long long)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t quasar::tennessee::IterableCollation<quasar::tennessee::basic_string_ptr<char>,unsigned char>::IterableCollation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10 = *MEMORY[0x1E69E9840];
  *a1 = &unk_1F2D42570;
  *(a1 + 8) = *a2;
  *a2 = 0;
  *(a2 + 8) = 0;
  std::__function::__value_func<unsigned char ()(char const*&)>::__value_func[abi:ne200100](a1 + 24, a3);
  v5 = *(a1 + 8);
  std::__function::__value_func<unsigned char ()(char const*&)>::__value_func[abi:ne200100](v9, a3);
  *(a1 + 56) = &unk_1F2D425D0;
  *(a1 + 64) = v5;
  std::__function::__value_func<unsigned char ()(char const*&)>::__value_func[abi:ne200100](a1 + 72, v9);
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100](v9);
  v6 = *(a1 + 8);
  std::__function::__value_func<unsigned char ()(char const*&)>::__value_func[abi:ne200100](v8, a3);
  *(a1 + 104) = &unk_1F2D42620;
  *(a1 + 112) = v6;
  std::__function::__value_func<unsigned char ()(char const*&)>::__value_func[abi:ne200100](a1 + 120, v8);
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100](v8);
  return a1;
}

void sub_1B5A876BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100](va);
  *v4 = v3;
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100](v2 + 72);
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100](v2 + 24);
  v6 = *(v2 + 16);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v6);
  }

  _Unwind_Resume(a1);
}

void *quasar::tennessee::IterableCollation<quasar::tennessee::basic_string_ptr<char>,unsigned char>::ComparatorImpl<false>::~ComparatorImpl(void *a1)
{
  *a1 = &unk_1F2D425D0;
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100]((a1 + 2));
  return a1;
}

void *quasar::tennessee::IterableCollation<quasar::tennessee::basic_string_ptr<char>,unsigned char>::~IterableCollation(void *a1)
{
  *a1 = &unk_1F2D42570;
  a1[13] = &unk_1F2D42620;
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100]((a1 + 15));
  a1[7] = &unk_1F2D425D0;
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100]((a1 + 9));
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100]((a1 + 3));
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  return a1;
}

void quasar::tennessee::IterableCollation<quasar::tennessee::basic_string_ptr<char>,unsigned char>::~IterableCollation(void *a1)
{
  *a1 = &unk_1F2D42570;
  a1[13] = &unk_1F2D42620;
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100]((a1 + 15));
  a1[7] = &unk_1F2D425D0;
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100]((a1 + 9));
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100]((a1 + 3));
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  JUMPOUT(0x1B8C85350);
}

void quasar::tennessee::IterableCollation<quasar::tennessee::basic_string_ptr<char>,unsigned char>::ComparatorImpl<false>::~ComparatorImpl(void *a1)
{
  *a1 = &unk_1F2D425D0;
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100]((a1 + 2));

  JUMPOUT(0x1B8C85350);
}

void *quasar::tennessee::IterableCollation<quasar::tennessee::basic_string_ptr<char>,unsigned char>::ComparatorImpl<true>::~ComparatorImpl(void *a1)
{
  *a1 = &unk_1F2D42620;
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100]((a1 + 2));
  return a1;
}

void quasar::tennessee::IterableCollation<quasar::tennessee::basic_string_ptr<char>,unsigned char>::ComparatorImpl<true>::~ComparatorImpl(void *a1)
{
  *a1 = &unk_1F2D42620;
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100]((a1 + 2));

  JUMPOUT(0x1B8C85350);
}

void sub_1B5A87AF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<unsigned char ()(char const*&)>::~__value_func[abi:ne200100](va);
  if (a4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a4);
  }

  MEMORY[0x1B8C85350](v5, v4);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<quasar::tennessee::nashville::CreateDefaultTokenInfoCollation(quasar::tennessee::nashville::flatbuf::StringData const&)::$_0,std::allocator<quasar::tennessee::nashville::CreateDefaultTokenInfoCollation(quasar::tennessee::nashville::flatbuf::StringData const&)::$_0>,quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2D42660;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<quasar::tennessee::nashville::CreateDefaultTokenInfoCollation(quasar::tennessee::nashville::flatbuf::StringData const&)::$_0,std::allocator<quasar::tennessee::nashville::CreateDefaultTokenInfoCollation(quasar::tennessee::nashville::flatbuf::StringData const&)::$_0>,quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void *quasar::tennessee::IndirectCollation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::basic_string_ptr<char>,quasar::tennessee::basic_string_ptr<char>>::IndirectCollation(void *a1, uint64_t *a2, uint64_t a3)
{
  v4 = *a2;
  *a2 = 0;
  *a1 = &unk_1F2D426F0;
  a1[1] = v4;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::__value_func[abi:ne200100]((a1 + 2), a3);
  v5 = (*(*a1[1] + 16))(a1[1]);
  a1[6] = &unk_1F2D42750;
  a1[7] = v5;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::__value_func[abi:ne200100]((a1 + 8), (a1 + 2));
  v6 = (*(*a1[1] + 24))(a1[1]);
  a1[12] = &unk_1F2D42750;
  a1[13] = v6;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::__value_func[abi:ne200100]((a1 + 14), (a1 + 2));
  if (!a1[1])
  {
    memset(v8, 0, sizeof(v8));
    kaldi::KaldiWarnMessage::KaldiWarnMessage(v8);
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(v8);
  }

  return a1;
}

void sub_1B5A87DA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *v13 = a10;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100](v10 + 112);
  *v12 = v11;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100](v10 + 64);
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100](v10 + 16);
  v15 = *(v10 + 8);
  *(v10 + 8) = 0;
  if (v15)
  {
    (*(*v15 + 8))(v15);
  }

  _Unwind_Resume(a1);
}

void *quasar::tennessee::IndirectCollation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::basic_string_ptr<char>,quasar::tennessee::basic_string_ptr<char>>::ComparatorImpl::~ComparatorImpl(void *a1)
{
  *a1 = &unk_1F2D42750;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100]((a1 + 2));
  return a1;
}

void *quasar::tennessee::IndirectCollation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::basic_string_ptr<char>,quasar::tennessee::basic_string_ptr<char>>::~IndirectCollation(void *a1)
{
  *a1 = &unk_1F2D426F0;
  a1[12] = &unk_1F2D42750;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100]((a1 + 14));
  a1[6] = &unk_1F2D42750;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100]((a1 + 8));
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100]((a1 + 2));
  v2 = a1[1];
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return a1;
}

void quasar::tennessee::IndirectCollation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::basic_string_ptr<char>,quasar::tennessee::basic_string_ptr<char>>::~IndirectCollation(void *a1)
{
  *a1 = &unk_1F2D426F0;
  a1[12] = &unk_1F2D42750;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100]((a1 + 14));
  a1[6] = &unk_1F2D42750;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100]((a1 + 8));
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100]((a1 + 2));
  v2 = a1[1];
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  JUMPOUT(0x1B8C85350);
}

void sub_1B5A88114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    quasar::tennessee::nashville::CreateDefaultTokenInfoCollation();
  }

  MEMORY[0x1B8C85350](v10, 0x10E1C4061027E81);
  if (a9)
  {
    (*(*a9 + 8))(a9);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::__value_func[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

void quasar::tennessee::IndirectCollation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::basic_string_ptr<char>,quasar::tennessee::basic_string_ptr<char>>::ComparatorImpl::~ComparatorImpl(void *a1)
{
  *a1 = &unk_1F2D42750;
  std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100]((a1 + 2));

  JUMPOUT(0x1B8C85350);
}

uint64_t quasar::tennessee::IndirectCollation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::basic_string_ptr<char>,quasar::tennessee::basic_string_ptr<char>>::ComparatorImpl::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a1 + 40);
  if (!v4 || (v6 = *(a1 + 8), v10 = (*(*v4 + 48))(v4), (v7 = *(a1 + 40)) == 0))
  {
    std::__throw_bad_function_call[abi:ne200100]();
  }

  v9 = (*(*v7 + 48))(v7, a3);
  return (*(*v6 + 16))(v6, &v10, &v9);
}

uint64_t std::__function::__value_func<quasar::tennessee::basic_string_ptr<char> ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(uint64_t a1, quasar::tennessee::memory_mapping::VirtualMemoryFile **a2, int a3)
{
  v4 = *a2;
  *a2 = 0;
  *a1 = &unk_1F2D42468;
  *(a1 + 8) = v4;
  *(a1 + 16) = a3;
  if (!a3)
  {
    *(a1 + 24) = 0;
LABEL_9:
    v10 = quasar::tennessee::memory_mapping::VirtualMemoryFile::Data(v4);
    goto LABEL_10;
  }

  v5 = quasar::tennessee::memory_mapping::VirtualMemoryFile::Data(v4);
  v6 = (v5 + *v5);
  v7 = *(a1 + 16);
  *(a1 + 24) = v6;
  if (!v7)
  {
    v4 = *(a1 + 8);
    goto LABEL_9;
  }

  v8 = (v6 - *v6);
  if (*v8 > v7)
  {
    v9 = *(v8 + v7);
    if (v9)
    {
      v10 = (v6 + v9);
LABEL_10:
      v11 = v10 + *v10;
      goto LABEL_11;
    }
  }

  v11 = 0;
LABEL_11:
  *(a1 + 32) = v11;
  return a1;
}

void sub_1B5A8847C(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 8);
  *(v1 + 8) = 0;
  if (v3)
  {
    quasar::tennessee::generic_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(v3);
  }

  _Unwind_Resume(exception_object);
}

void quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata>::~unique_vmem_file_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D42468;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  JUMPOUT(0x1B8C85350);
}

uint64_t quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(uint64_t a1, quasar::tennessee::memory_mapping::VirtualMemoryFile **a2, int a3)
{
  v4 = *a2;
  *a2 = 0;
  *a1 = &unk_1F2D42438;
  *(a1 + 8) = v4;
  *(a1 + 16) = a3;
  if (!a3)
  {
    *(a1 + 24) = 0;
LABEL_9:
    v10 = quasar::tennessee::memory_mapping::VirtualMemoryFile::Data(v4);
    goto LABEL_10;
  }

  v5 = quasar::tennessee::memory_mapping::VirtualMemoryFile::Data(v4);
  v6 = (v5 + *v5);
  v7 = *(a1 + 16);
  *(a1 + 24) = v6;
  if (!v7)
  {
    v4 = *(a1 + 8);
    goto LABEL_9;
  }

  v8 = (v6 - *v6);
  if (*v8 > v7)
  {
    v9 = *(v8 + v7);
    if (v9)
    {
      v10 = (v6 + v9);
LABEL_10:
      v11 = v10 + *v10;
      goto LABEL_11;
    }
  }

  v11 = 0;
LABEL_11:
  *(a1 + 32) = v11;
  return a1;
}

void sub_1B5A885D4(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 8);
  *(v1 + 8) = 0;
  if (v3)
  {
    quasar::tennessee::generic_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(v3);
  }

  _Unwind_Resume(exception_object);
}

void quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData>::~unique_vmem_file_flatbuf_ptr(void *a1)
{
  v2 = a1[1];
  *a1 = &unk_1F2D42438;
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  JUMPOUT(0x1B8C85350);
}

void *quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>>::unique_vmem_file_flatbuf_ptr(void *a1, uint64_t a2)
{
  v4 = *(a2 + 8);
  *(a2 + 8) = 0;
  v7 = v4;
  quasar::tennessee::generic_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(a1, &v7, *(a2 + 16));
  *a1 = &unk_1F2D42498;
  v5 = v7;
  v7 = 0;
  if (v5)
  {
    (*(*v5 + 8))(v5);
  }

  *(a2 + 24) = 0;
  *(a2 + 32) = 0;
  return a1;
}

void sub_1B5A88714(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::internal::VmemFileImmutableSortedArrayFlatbufferVectorImpl<long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>>,0>();
  }

  _Unwind_Resume(exception_object);
}

void *quasar::tennessee::internal::ImmutableSortedArrayFlatbufferVectorImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>>>::ImmutableSortedArrayFlatbufferVectorImpl(void *a1, uint64_t *a2, uint64_t a3)
{
  v4 = *a2;
  *a2 = 0;
  *a1 = &unk_1F2D428A8;
  a1[1] = v4;
  quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>>::unique_vmem_file_flatbuf_ptr(a1 + 2, a3);
  quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>::CheckSorted(a1);
  return a1;
}

void sub_1B5A887B4(_Unwind_Exception *exception_object)
{
  v4 = v1[3];
  v1[2] = &unk_1F2D424E0;
  v1[3] = 0;
  if (v4)
  {
    quasar::tennessee::generic_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(v4);
  }

  v5 = v1[1];
  *v1 = v2;
  v1[1] = 0;
  if (v5)
  {
    (*(*v5 + 8))(v5);
  }

  _Unwind_Resume(exception_object);
}

void *quasar::tennessee::internal::VmemFileImmutableSortedArrayFlatbufferVectorImpl<quasar::tennessee::nashville::flatbuf::TokenInfo>::~VmemFileImmutableSortedArrayFlatbufferVectorImpl(void *a1)
{
  *a1 = &unk_1F2D428A8;
  v2 = a1[3];
  a1[2] = &unk_1F2D424E0;
  a1[3] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = a1[1];
  *a1 = &unk_1F2D42900;
  a1[1] = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  return a1;
}

void quasar::tennessee::internal::VmemFileImmutableSortedArrayFlatbufferVectorImpl<quasar::tennessee::nashville::flatbuf::TokenInfo>::~VmemFileImmutableSortedArrayFlatbufferVectorImpl(void *a1)
{
  *a1 = &unk_1F2D428A8;
  v2 = a1[3];
  a1[2] = &unk_1F2D424E0;
  a1[3] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = a1[1];
  *a1 = &unk_1F2D42900;
  a1[1] = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  JUMPOUT(0x1B8C85350);
}

uint64_t quasar::tennessee::internal::ImmutableSortedArrayFlatbufferVectorImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>>>::at(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2))
  {
    v8 = v3;
    v9 = v2;
    v10 = v4;
    v11 = v5;
    memset(v7, 0, sizeof(v7));
    quasar::QuasarExceptionMessage::QuasarExceptionMessage(v7);
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(v7);
  }

  return *(a1 + 48) + 8 * a2 + 4;
}

uint64_t quasar::tennessee::internal::ImmutableSortedArrayFlatbufferVectorImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>>>::data()
{
  if (quasar::gLogLevel >= -1)
  {
    memset(v1, 0, sizeof(v1));
    kaldi::KaldiWarnMessage::KaldiWarnMessage(v1);
    std::operator<<[abi:ne200100]<std::char_traits<char>>(v1, "Unable to access contiguous data array for non-scalar types.");
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(v1);
  }

  return 0;
}

uint64_t quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>::CheckSorted(void *a1)
{
  result = quasar::tennessee::ShouldCheckSorted(0);
  if (result)
  {
    v3 = a1[1];
    v4 = (*(*a1 + 40))(a1);
    v6 = v5;
    v7 = (*(*a1 + 48))(a1);
    result = quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>::IsSorted<quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>::Iterator>(v3, v4, v6, v7, v8);
    if ((result & 1) == 0)
    {
      memset(v9, 0, sizeof(v9));
      kaldi::KaldiWarnMessage::KaldiWarnMessage(v9);
      std::operator<<[abi:ne200100]<std::char_traits<char>>(v9, "Input container is not sorted.");
      quasar::QuasarExceptionMessage::~QuasarExceptionMessage(v9);
    }
  }

  return result;
}

void *quasar::tennessee::internal::ImmutableSortedArrayFlatbufferVectorImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>>>::~ImmutableSortedArrayFlatbufferVectorImpl(void *a1)
{
  *a1 = &unk_1F2D428A8;
  v2 = a1[3];
  a1[2] = &unk_1F2D424E0;
  a1[3] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = a1[1];
  *a1 = &unk_1F2D42900;
  a1[1] = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  return a1;
}

void quasar::tennessee::internal::ImmutableSortedArrayFlatbufferVectorImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<quasar::tennessee::nashville::flatbuf::TokenInfo const*>>>::~ImmutableSortedArrayFlatbufferVectorImpl(void *a1)
{
  *a1 = &unk_1F2D428A8;
  v2 = a1[3];
  a1[2] = &unk_1F2D424E0;
  a1[3] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = a1[1];
  *a1 = &unk_1F2D42900;
  a1[1] = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  JUMPOUT(0x1B8C85350);
}

uint64_t quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>::IsSorted<quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>::Iterator>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v21[4] = *MEMORY[0x1E69E9840];
  if (a2 == a4 && a3 == a5)
  {
    return 1;
  }

  v10 = (*(*a1 + 16))(a1);
  v21[0] = &unk_1F2D42958;
  v21[1] = v10;
  v21[3] = v21;
  v11 = std::__is_sorted_until[abi:ne200100]<std::function<BOOL ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&,quasar::tennessee::nashville::flatbuf::TokenInfo const&)> &,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>::Iterator>(a2, a3, a4, a5, v21);
  v13 = v12;
  std::__function::__value_func<BOOL ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&,quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100](v21);
  v15 = v11 != a4 || v13 != a5;
  if (v15 && quasar::gLogLevel >= 2)
  {
    memset(v20, 0, sizeof(v20));
    kaldi::KaldiWarnMessage::KaldiWarnMessage(v20);
    v17 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v20, "Element at position ", 20);
    v18 = MEMORY[0x1B8C84C30](v17, v13 - a3);
    v19 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v18, " ", 1);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v19, "is smaller than preceding element.", 34);
    quasar::QuasarWarnMessage::~QuasarWarnMessage(v20);
  }

  return !v15;
}

uint64_t std::__is_sorted_until[abi:ne200100]<std::function<BOOL ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&,quasar::tennessee::nashville::flatbuf::TokenInfo const&)> &,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>::Iterator>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1 != a3 || a2 != a4)
  {
    v9 = a2 + 1;
    do
    {
      if (a1 == a3 && a4 == v9)
      {
        break;
      }

      v10 = (*(*a1 + 16))(a1, v9);
      v11 = (*(*a1 + 16))(a1, v9 - 1);
      v12 = *(a5 + 24);
      if (!v12)
      {
        std::__throw_bad_function_call[abi:ne200100]();
      }

      ++v9;
    }

    while (!(*(*v12 + 48))(v12, v10, v11));
  }

  return a1;
}

uint64_t std::__function::__func<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>::GetLessThanComparator(void)::{lambda(quasar::tennessee::nashville::flatbuf::TokenInfo const&,quasar::tennessee::nashville::flatbuf::TokenInfo const&)#1},std::allocator<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>::GetLessThanComparator(void)::{lambda(quasar::tennessee::nashville::flatbuf::TokenInfo const&,quasar::tennessee::nashville::flatbuf::TokenInfo const&)#1}>,BOOL ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&,quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2D42958;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>::GetLessThanComparator(void)::{lambda(quasar::tennessee::nashville::flatbuf::TokenInfo const&,quasar::tennessee::nashville::flatbuf::TokenInfo const&)#1},std::allocator<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>::GetLessThanComparator(void)::{lambda(quasar::tennessee::nashville::flatbuf::TokenInfo const&,quasar::tennessee::nashville::flatbuf::TokenInfo const&)#1}>,BOOL ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&,quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__value_func<BOOL ()(quasar::tennessee::nashville::flatbuf::TokenInfo const&,quasar::tennessee::nashville::flatbuf::TokenInfo const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void *quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata>::unique_vmem_file_flatbuf_ptr(void *a1, uint64_t a2)
{
  v4 = *(a2 + 8);
  *(a2 + 8) = 0;
  v7 = v4;
  quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(a1, &v7, *(a2 + 16));
  *a1 = &unk_1F2D427A0;
  v5 = v7;
  v7 = 0;
  if (v5)
  {
    (*(*v5 + 8))(v5);
  }

  *(a2 + 24) = 0;
  *(a2 + 32) = 0;
  return a1;
}

void sub_1B5A89390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::internal::VmemFileImmutableSortedArrayFlatbufferVectorImpl<long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>>,0>();
  }

  _Unwind_Resume(exception_object);
}

void *quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData>::unique_vmem_file_flatbuf_ptr(void *a1, uint64_t a2)
{
  v4 = *(a2 + 8);
  *(a2 + 8) = 0;
  v7 = v4;
  quasar::tennessee::generic_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData,quasar::tennessee::memory_mapping::VirtualMemoryFile,std::unique_ptr<quasar::tennessee::memory_mapping::VirtualMemoryFile>>::generic_flatbuf_ptr(a1, &v7, *(a2 + 16));
  *a1 = &unk_1F2D427D8;
  v5 = v7;
  v7 = 0;
  if (v5)
  {
    (*(*v5 + 8))(v5);
  }

  *(a2 + 24) = 0;
  *(a2 + 32) = 0;
  return a1;
}

void sub_1B5A89444(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::internal::VmemFileImmutableSortedArrayFlatbufferVectorImpl<long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<flatbuffers_2_0_6::Vector<long long>>,0>();
  }

  _Unwind_Resume(exception_object);
}

void *quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>::GenericNashvilleLexicon<std::unique_ptr<quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>>(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v35 = *MEMORY[0x1E69E9840];
  v11 = *a6;
  *a6 = 0;
  v33 = v11;
  memset(v34, 0, sizeof(v34));
  quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::GenericLexiconImpl(a1, &v33, v34);
  std::__function::__value_func<std::string_view ()(quasar::tennessee::GenericLexicon<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view> const*,long long)>::~__value_func[abi:ne200100](v34);
  v12 = v33;
  v33 = 0;
  if (v12)
  {
    (*(*v12 + 8))(v12);
  }

  *a1 = &unk_1F2D42360;
  quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata>::unique_vmem_file_flatbuf_ptr(a1 + 12, a2);
  quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData>::unique_vmem_file_flatbuf_ptr(a1 + 17, a3);
  v13 = *a4;
  *a4 = 0;
  a1[22] = v13;
  v14 = *a5;
  *a5 = 0;
  a1[23] = v14;
  a1[24] = 0;
  if (!v13)
  {
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v16 = 0u;
    kaldi::KaldiWarnMessage::KaldiWarnMessage(&v16);
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(&v16);
  }

  if (!v14)
  {
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v16 = 0u;
    kaldi::KaldiWarnMessage::KaldiWarnMessage(&v16);
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(&v16);
  }

  return a1;
}

void sub_1B5A89610(_Unwind_Exception *a1)
{
  v3 = v1[24];
  v1[24] = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  v4 = v1[23];
  v1[23] = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  v5 = v1[22];
  v1[22] = 0;
  if (v5)
  {
    (*(*v5 + 8))(v5);
  }

  v6 = v1[18];
  v1[17] = &unk_1F2D42438;
  v1[18] = 0;
  if (v6)
  {
    (*(*v6 + 8))(v6);
  }

  v7 = v1[13];
  v1[12] = &unk_1F2D42468;
  v1[13] = 0;
  if (v7)
  {
    (*(*v7 + 8))(v7);
  }

  quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::~GenericLexiconImpl(v1);
  _Unwind_Resume(a1);
}

void sub_1B5A89758()
{
  std::__function::__value_func<std::string_view ()(quasar::tennessee::GenericLexicon<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view> const*,long long)>::~__value_func[abi:ne200100](v0 - 112);
  v1 = *(v0 - 120);
  *(v0 - 120) = 0;
  if (v1)
  {
    quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>::GenericNashvilleLexicon<std::unique_ptr<quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>>();
  }

  JUMPOUT(0x1B5A89750);
}

uint64_t quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::GenericLexiconImpl(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  *a1 = &unk_1F2D42500;
  *(a1 + 8) = 0;
  v4 = *a2;
  *a2 = 0;
  *(a1 + 16) = v4;
  *(a1 + 24) = 0;
  std::__function::__value_func<std::string_view ()(quasar::tennessee::GenericLexicon<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view> const*,long long)>::__value_func[abi:ne200100](a1 + 32, a3);
  *(a1 + 88) = 0;
  return a1;
}

void sub_1B5A897F0(_Unwind_Exception *a1)
{
  v4 = *(v1 + 24);
  *(v1 + 24) = 0;
  if (v4)
  {
    quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::GenericLexiconImpl(v4);
  }

  quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::GenericLexiconImpl(v2);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<std::string_view ()(quasar::tennessee::GenericLexicon<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view> const*,long long)>::__value_func[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

void sub_1B5A899B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100](va);
  if (a2)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData>,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::IterableCollation<std::string_view,wchar_t>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>,0>();
  }

  MEMORY[0x1B8C85350](v2, v3);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::Lexicon<std::string_view>::TokenId,quasar::tennessee::CollationInterfaceTypeHelper<quasar::tennessee::Lexicon<std::string_view>::TokenId>::type>> quasar::tennessee::CreateReorderingCollation<std::string_view>(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Lexicon<std::string_view>::CollationType,std::default_delete<quasar::tennessee::Lexicon<std::string_view>::CollationType>>)::{lambda(long long const&)#1},std::allocator<std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::Lexicon<std::string_view>::TokenId,quasar::tennessee::CollationInterfaceTypeHelper<quasar::tennessee::Lexicon<std::string_view>::TokenId>::type>> quasar::tennessee::CreateReorderingCollation<std::string_view>(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Lexicon<std::string_view>::CollationType,std::default_delete<quasar::tennessee::Lexicon<std::string_view>::CollationType>>)::{lambda(long long const&)#1}>,std::string_view ()(long long const&)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2D429E8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::Lexicon<std::string_view>::TokenId,quasar::tennessee::CollationInterfaceTypeHelper<quasar::tennessee::Lexicon<std::string_view>::TokenId>::type>> quasar::tennessee::CreateReorderingCollation<std::string_view>(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Lexicon<std::string_view>::CollationType,std::default_delete<quasar::tennessee::Lexicon<std::string_view>::CollationType>>)::{lambda(long long const&)#1},std::allocator<std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::Lexicon<std::string_view>::TokenId,quasar::tennessee::CollationInterfaceTypeHelper<quasar::tennessee::Lexicon<std::string_view>::TokenId>::type>> quasar::tennessee::CreateReorderingCollation<std::string_view>(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Lexicon<std::string_view>::CollationType,std::default_delete<quasar::tennessee::Lexicon<std::string_view>::CollationType>>)::{lambda(long long const&)#1}>,std::string_view ()(long long const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void *quasar::tennessee::IndirectCollation<long long,std::string_view,std::string_view>::IndirectCollation(void *a1, uint64_t *a2, uint64_t a3)
{
  v4 = *a2;
  *a2 = 0;
  *a1 = &unk_1F2D42A78;
  a1[1] = v4;
  std::__function::__value_func<std::string_view ()(long long const&)>::__value_func[abi:ne200100]((a1 + 2), a3);
  v5 = (*(*a1[1] + 16))(a1[1]);
  a1[6] = &unk_1F2D42AC8;
  a1[7] = v5;
  std::__function::__value_func<std::string_view ()(long long const&)>::__value_func[abi:ne200100]((a1 + 8), (a1 + 2));
  v6 = (*(*a1[1] + 24))(a1[1]);
  a1[12] = &unk_1F2D42AC8;
  a1[13] = v6;
  std::__function::__value_func<std::string_view ()(long long const&)>::__value_func[abi:ne200100]((a1 + 14), (a1 + 2));
  if (!a1[1])
  {
    memset(v8, 0, sizeof(v8));
    kaldi::KaldiWarnMessage::KaldiWarnMessage(v8);
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(v8);
  }

  return a1;
}

void sub_1B5A89C5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *v13 = a10;
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100](v10 + 112);
  *v12 = v11;
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100](v10 + 64);
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100](v10 + 16);
  v15 = *(v10 + 8);
  *(v10 + 8) = 0;
  if (v15)
  {
    (*(*v15 + 8))(v15);
  }

  _Unwind_Resume(a1);
}

void *quasar::tennessee::IndirectCollation<long long,std::string_view,std::string_view>::ComparatorImpl::~ComparatorImpl(void *a1)
{
  *a1 = &unk_1F2D42AC8;
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100]((a1 + 2));
  return a1;
}

void *quasar::tennessee::IndirectCollation<long long,std::string_view,std::string_view>::~IndirectCollation(void *a1)
{
  *a1 = &unk_1F2D42A78;
  a1[12] = &unk_1F2D42AC8;
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100]((a1 + 14));
  a1[6] = &unk_1F2D42AC8;
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100]((a1 + 8));
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100]((a1 + 2));
  v2 = a1[1];
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  return a1;
}

void quasar::tennessee::IndirectCollation<long long,std::string_view,std::string_view>::~IndirectCollation(void *a1)
{
  *a1 = &unk_1F2D42A78;
  a1[12] = &unk_1F2D42AC8;
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100]((a1 + 14));
  a1[6] = &unk_1F2D42AC8;
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100]((a1 + 8));
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100]((a1 + 2));
  v2 = a1[1];
  a1[1] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  JUMPOUT(0x1B8C85350);
}

void sub_1B5A89FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData>,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::IterableCollation<std::string_view,wchar_t>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>,0>();
  }

  MEMORY[0x1B8C85350](v10, 0x10E1C4061027E81);
  if (a9)
  {
    (*(*a9 + 8))(a9);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<std::string_view ()(long long const&)>::__value_func[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

void quasar::tennessee::IndirectCollation<long long,std::string_view,std::string_view>::ComparatorImpl::~ComparatorImpl(void *a1)
{
  *a1 = &unk_1F2D42AC8;
  std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100]((a1 + 2));

  JUMPOUT(0x1B8C85350);
}

uint64_t quasar::tennessee::IndirectCollation<long long,std::string_view,std::string_view>::ComparatorImpl::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a1 + 40);
  if (!v4 || (v6 = *(a1 + 8), v12[0] = (*(*v4 + 48))(v4), v12[1] = v7, (v8 = *(a1 + 40)) == 0))
  {
    std::__throw_bad_function_call[abi:ne200100]();
  }

  v11[0] = (*(*v8 + 48))(v8, a3);
  v11[1] = v9;
  return (*(*v6 + 16))(v6, v12, v11);
}

uint64_t std::__function::__value_func<std::string_view ()(long long const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void sub_1B5A8A40C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, void);
  va_copy(va2, va1);
  v8 = va_arg(va2, void);
  v10 = va_arg(va2, void);
  v11 = va_arg(va2, void);
  v12 = va_arg(va2, void);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](va1);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](va2);
  if (a3)
  {
    quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load();
  }

  std::make_unique[abi:ne200100]<quasar::tennessee::IndirectSortedIndex<long long,std::string_view>,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>,quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(long long)#1},quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(std::string_view)#1},0>(va);
  MEMORY[0x1B8C85350](v4, v3);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(long long)#1},std::allocator<quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(long long)#1}>,std::string_view ()(long long)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2D42B08;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(long long)#1},std::allocator<quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(long long)#1}>,std::string_view ()(long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__func<quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(std::string_view)#1},std::allocator<quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(std::string_view)#1}>,long long ()(std::string_view)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2D42B88;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(std::string_view)#1},std::allocator<quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(std::string_view)#1}>,long long ()(std::string_view)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void *quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::IndirectSortedIndex(void *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  v15 = *MEMORY[0x1E69E9840];
  v8 = *a2;
  *a2 = 0;
  v12 = v8;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v14, a4);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v13, a5);
  quasar::tennessee::SortedIndex<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>::SortedIndex(a1, &v12, v14, v13);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v13);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v14);
  v9 = v12;
  v12 = 0;
  if (v9)
  {
    (*(*v9 + 8))(v9);
  }

  *a1 = &unk_1F2D42C08;
  v10 = *a3;
  *a3 = 0;
  a1[10] = v10;
  return a1;
}

void sub_1B5A8A7A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  v5 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](va);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](va1);
  if (a2)
  {
    (*(*a2 + 8))(a2);
  }

  _Unwind_Resume(a1);
}

void *quasar::tennessee::SortedIndex<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>::SortedIndex(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  v6 = *a2;
  *a2 = 0;
  *a1 = &unk_1F2D42C68;
  a1[1] = v6;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100]((a1 + 2), a3);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100]((a1 + 6), a4);
  return a1;
}

void sub_1B5A8A88C(_Unwind_Exception *a1)
{
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100]((v1 + 2));
  v4 = v1[1];
  *v1 = v2;
  v1[1] = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  _Unwind_Resume(a1);
}

void *quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::~IndirectSortedIndex(void *a1)
{
  *a1 = &unk_1F2D42C08;
  v2 = a1[10];
  a1[10] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  *a1 = &unk_1F2D42C68;
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100]((a1 + 6));
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100]((a1 + 2));
  v3 = a1[1];
  *a1 = &unk_1F2D27110;
  a1[1] = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  return a1;
}

void quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::~IndirectSortedIndex(void *a1)
{
  *a1 = &unk_1F2D42C08;
  v2 = a1[10];
  a1[10] = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  *a1 = &unk_1F2D42C68;
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100]((a1 + 6));
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100]((a1 + 2));
  v3 = a1[1];
  *a1 = &unk_1F2D27110;
  a1[1] = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  JUMPOUT(0x1B8C85350);
}

uint64_t quasar::tennessee::SortedIndex<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>::FindExactMatches(void **a1, __int128 *a2, void *a3)
{
  v35 = *MEMORY[0x1E69E9840];
  v6 = ((*a1)[8])(a1);
  v8 = v7;
  v9 = ((*a1)[9])(a1);
  v11 = v10;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v28, (a1 + 2));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v27, (a1 + 6));
  v12 = (*(*a1[1] + 16))(a1[1]);
  quasar::tennessee::internal::FindMatches<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(v6, v8, v9, v11, v28, v27, v12, a2, &v29, 1);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v27);
  result = std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v28);
  if (v34 == 1)
  {
    v24 = v29;
    std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v25, v30);
    std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v26, v31);
    v21 = v31[2];
    std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v22, v32);
    std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v23, v33);
    v14 = a3[1];
    v18 = v24;
    std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v19, v25);
    std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v20, v26);
    v15 = v21;
    std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v16, v22);
    std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v17, v23);
    std::vector<long long>::insert[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,0>(a3, v14, &v18, &v15);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v17);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v16);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v20);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v19);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v23);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v22);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v26);
    result = std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v25);
    if (v34)
    {
      std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v33);
      std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v32);
      std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v31);
      return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v30);
    }
  }

  return result;
}

void sub_1B5A8AD48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, char a60)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v63 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v63 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v62 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v62 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v61 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v61 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v60 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v60 + 16);
  std::optional<std::tuple<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,BOOL>>::~optional(&a60);
  _Unwind_Resume(a1);
}

uint64_t quasar::tennessee::SortedIndex<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>::FindPrefixMatches(void **a1, __int128 *a2, void *a3)
{
  v29 = *MEMORY[0x1E69E9840];
  v6 = ((*a1)[8])(a1);
  v8 = v7;
  v9 = ((*a1)[9])(a1);
  v11 = v10;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v22, (a1 + 2));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v21, (a1 + 6));
  v12 = (*(*a1[1] + 24))(a1[1]);
  quasar::tennessee::internal::FindMatches<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(v6, v8, v9, v11, v22, v21, v12, a2, &v23, 1);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v21);
  result = std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v22);
  if (v28 == 1)
  {
    v14 = a3[1];
    v18 = v23;
    std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v19, v24);
    std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v20, v25);
    v15 = v25[2];
    std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v16, v26);
    std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v17, v27);
    std::vector<long long>::insert[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,0>(a3, v14, &v18, &v15);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v17);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v16);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v20);
    result = std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v19);
    if (v28)
    {
      std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v27);
      std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v26);
      std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v25);
      return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v24);
    }
  }

  return result;
}

void sub_1B5A8B024(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, char a40)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v41 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v41 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v40 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v40 + 16);
  std::optional<std::tuple<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,BOOL>>::~optional(&a40);
  _Unwind_Resume(a1);
}

uint64_t quasar::tennessee::SortedIndex<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>::IsPrefix(void **a1, __int128 *a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v4 = ((*a1)[8])(a1);
  v6 = v5;
  v7 = ((*a1)[9])(a1);
  v9 = v8;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v14, (a1 + 2));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v13, (a1 + 6));
  v10 = (*(*a1[1] + 24))(a1[1]);
  quasar::tennessee::internal::FindMatches<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(v4, v6, v7, v9, v14, v13, v10, a2, v15, 0);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v13);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v14);
  v11 = v20;
  if (v20 == 1)
  {
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&v19);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&v18);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&v17);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&v16);
  }

  return v11;
}

void sub_1B5A8B220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](va);
  _Unwind_Resume(a1);
}

uint64_t quasar::tennessee::internal::FindMatches<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, __int128 *a8@<X7>, _BYTE *a9@<X8>, char a10)
{
  v53[4] = *MEMORY[0x1E69E9840];
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v49, a5);
  quasar::tennessee::internal::CreateIterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>(a1, a2, v49, &v50);
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v46, a5);
  quasar::tennessee::internal::CreateIterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>(a3, a4, v46, &v47);
  *&v37 = a7;
  LOBYTE(v28[0]) = 0;
  v29 = v50;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v30, v51);
  v43 = v47;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v44, v48);
  std::__lower_bound[abi:ne200100]<std::_ClassicAlgPolicy,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>,std::string_view,std::__identity,std::optional<std::tuple<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,BOOL>> quasar::tennessee::internal::FindMatches<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::SortedIndex<long long,std::string_view,std::vector<long long>::const_iterator>::EntryIdToEntryFn,quasar::tennessee::SortedIndex<long long,std::string_view,std::vector<long long>::const_iterator>::EntryToEntryIdFn,quasar::tennessee::Comparator<std::string_view,quasar::tennessee::CollationInterfaceTypeHelper<std::string_view>::type> const&,std::string_view const&,BOOL)::{lambda(std::string_view,std::string_view)#1}>(&v29, &v43, a8, &v37, &v52);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v44);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v30);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v46);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v51);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v49);
  if (v52 == __PAIR128__(a4, a3) || (v18 = (*(*v52 + 16))(), *&v29 = std::function<std::string_view ()(long long)>::operator()(v53, *v18), *(&v29 + 1) = v19, (*(*a7 + 16))(a7, &v29, a8)))
  {
    *a9 = 0;
    a9[168] = 0;
  }

  else
  {
    v41 = v52;
    std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v42, v53);
    std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v40, a6);
    quasar::tennessee::internal::CreateIterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>(&v41, v40, &v43);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v40);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v42);
    quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator+(&v43, 1, &v37);
    if (a10)
    {
      while (1)
      {
        v29 = v37;
        std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v30, v38);
        if (v29 == a3 && *(&v29 + 1) == a4)
        {
          break;
        }

        v22 = quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator*(&v37);
        v28[0] = std::function<std::string_view ()(long long)>::operator()(a5, v22);
        v28[1] = v23;
        v24 = (*(*a7 + 16))(a7, v28, a8);
        std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v30);
        if (v24)
        {
          goto LABEL_13;
        }

        quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator++(&v37, &v34);
        std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&v36);
        std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&v35);
      }

      std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v30);
    }

LABEL_13:
    v29 = v37;
    std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v30, v38);
    v26 = v29 == a3 && *(&v29 + 1) == a4;
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v30);
    LOBYTE(v28[0]) = v26;
    _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJN6quasar9tennessee8internal8IteratorINS_17basic_string_viewIcNS_11char_traitsIcEEEExNS6_IxSA_NS4_20ImmutableSortedArrayIxNS4_9CollationIxxEENS_10unique_ptrISD_NS_14default_deleteISD_EEEEE8IteratorEEEEESL_bEEC2B8ne200100IJLm0ELm1ELm2EEJSL_SL_bEJEJEJRSL_SO_RKbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSS_IJDpT2_EEEDpOT3_(&v29, &v43, &v37, v28);
    *(std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,BOOL>::__tuple_impl(a9, &v29) + 168) = 1;
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&v33);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&v32);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&v31);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v30);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&v39);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v38);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&v45);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v44);
  }

  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v53);
}

void sub_1B5A8B660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, uint64_t a60, uint64_t a61, uint64_t a62, uint64_t a63)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&a51);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&a47);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&a71);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&a67);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v71);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<long long>::insert[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,0>(void *a1, uint64_t *a2, __int128 *a3, __int128 *a4)
{
  v22[5] = *MEMORY[0x1E69E9840];
  v20 = *a3;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v21, (a3 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v22, (a3 + 3));
  v17 = *a4;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v18, (a4 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v19, (a4 + 3));
  v14 = *a3;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v15, (a3 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v16, (a3 + 3));
  v11 = *a4;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v12, (a4 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v13, (a4 + 3));
  v8 = std::distance[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(&v14, &v11);
  v9 = std::vector<long long>::__insert_with_size[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(a1, a2, &v20, &v17, v8);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v13);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v12);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v16);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v15);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v19);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v18);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v22);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v21);
  return v9;
}

void sub_1B5A8B8E0(_Unwind_Exception *a1)
{
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v1 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v4 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v4 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v3 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v3 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v2 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v2 + 16);
  _Unwind_Resume(a1);
}

uint64_t std::optional<std::tuple<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,BOOL>>::~optional(uint64_t a1)
{
  if (*(a1 + 168) == 1)
  {
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](a1 + 128);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](a1 + 96);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](a1 + 48);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](a1 + 16);
  }

  return a1;
}

uint64_t quasar::tennessee::internal::CreateIterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  v9 = *MEMORY[0x1E69E9840];
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v8, a3);
  *a4 = a1;
  a4[1] = a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100]((a4 + 2), v8);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v8);
}

void sub_1B5A8BA44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](va);
  _Unwind_Resume(a1);
}

uint64_t quasar::tennessee::internal::CreateIterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>@<X0>(__int128 *a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  v8[5] = *MEMORY[0x1E69E9840];
  v7 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v8, (a1 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v6, a2);
  quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::Iterator(a3, &v7, v6);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v6);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v8);
}

void sub_1B5A8BB08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&a9);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v9 + 16);
  _Unwind_Resume(a1);
}

uint64_t quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator+@<X0>(uint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  v8[4] = *MEMORY[0x1E69E9840];
  quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>::operator+(a1, a2, &v7);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v6, (a1 + 6));
  quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::Iterator(a3, &v7, v6);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v6);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v8);
}

void sub_1B5A8BBC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  v5 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](va);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](va1);
  _Unwind_Resume(a1);
}

uint64_t quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator*(void *a1)
{
  v2 = (*(**a1 + 16))(*a1, a1[1]);
  v4 = std::function<std::string_view ()(long long)>::operator()((a1 + 2), *v2);

  return std::function<long long ()(std::string_view)>::operator()((a1 + 6), v4, v3);
}

uint64_t quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator++@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  v5[5] = *MEMORY[0x1E69E9840];
  ++*(a1 + 8);
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v5, a1 + 16);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v5);
  *a2 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100]((a2 + 1), a1 + 16);
  return std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100]((a2 + 3), a1 + 48);
}

uint64_t std::__lower_bound[abi:ne200100]<std::_ClassicAlgPolicy,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>,std::string_view,std::__identity,std::optional<std::tuple<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,BOOL>> quasar::tennessee::internal::FindMatches<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::SortedIndex<long long,std::string_view,std::vector<long long>::const_iterator>::EntryIdToEntryFn,quasar::tennessee::SortedIndex<long long,std::string_view,std::vector<long long>::const_iterator>::EntryToEntryIdFn,quasar::tennessee::Comparator<std::string_view,quasar::tennessee::CollationInterfaceTypeHelper<std::string_view>::type> const&,std::string_view const&,BOOL)::{lambda(std::string_view,std::string_view)#1}>@<X0>(__int128 *a1@<X0>, __int128 *a2@<X1>, __int128 *a3@<X2>, void *a4@<X3>, __int128 *a5@<X8>)
{
  v17[5] = *MEMORY[0x1E69E9840];
  v16 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v17, (a1 + 1));
  v14 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v15, (a2 + 1));
  v10 = std::_IterOps<std::_ClassicAlgPolicy>::distance[abi:ne200100]<quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>(&v16, &v14);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v15);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v17);
  v12 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v13, (a1 + 1));
  std::__lower_bound_bisecting[abi:ne200100]<std::_ClassicAlgPolicy,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>,std::string_view,std::__identity,std::optional<std::tuple<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,BOOL>> quasar::tennessee::internal::FindMatches<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::SortedIndex<long long,std::string_view,std::vector<long long>::const_iterator>::EntryIdToEntryFn,quasar::tennessee::SortedIndex<long long,std::string_view,std::vector<long long>::const_iterator>::EntryToEntryIdFn,quasar::tennessee::Comparator<std::string_view,quasar::tennessee::CollationInterfaceTypeHelper<std::string_view>::type> const&,std::string_view const&,BOOL)::{lambda(std::string_view,std::string_view)#1}>(&v12, a3, v10, a4, a5);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v13);
}

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::distance[abi:ne200100]<quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>(__int128 *a1, __int128 *a2)
{
  v15[5] = *MEMORY[0x1E69E9840];
  v8 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v9, (a1 + 1));
  v6 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v7, (a2 + 1));
  v12 = v8;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v13, v9);
  v10 = v6;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v11, v7);
  v14 = v12;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v15, v13);
  v3 = *(&v14 + 1);
  v4 = *(&v10 + 1);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v15);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v11);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v13);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v7);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v9);
  return v4 - v3;
}

void sub_1B5A8BF98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](va);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v17 + 16);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v16 + 16);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v15 + 16);
  _Unwind_Resume(a1);
}

uint64_t std::__lower_bound_bisecting[abi:ne200100]<std::_ClassicAlgPolicy,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>,std::string_view,std::__identity,std::optional<std::tuple<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,BOOL>> quasar::tennessee::internal::FindMatches<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator,quasar::tennessee::SortedIndex<long long,std::string_view,std::vector<long long>::const_iterator>::EntryIdToEntryFn,quasar::tennessee::SortedIndex<long long,std::string_view,std::vector<long long>::const_iterator>::EntryToEntryIdFn,quasar::tennessee::Comparator<std::string_view,quasar::tennessee::CollationInterfaceTypeHelper<std::string_view>::type> const&,std::string_view const&,BOOL)::{lambda(std::string_view,std::string_view)#1}>@<X0>(__int128 *a1@<X0>, __int128 *a2@<X1>, unint64_t a3@<X2>, void *a4@<X3>, __int128 *a5@<X8>)
{
  v18[5] = *MEMORY[0x1E69E9840];
  if (a3)
  {
    v8 = a3;
    do
    {
      v15 = *a1;
      std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v16, (a1 + 1));
      v10 = v8 >> 1;
      *(&v15 + 1) += (v8 >> 1);
      v17 = v15;
      std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v18, v16);
      std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v18);
      v11 = (*(*v15 + 16))(v15, *(&v15 + 1));
      *&v17 = std::function<std::string_view ()(long long)>::operator()(v16, *v11);
      *(&v17 + 1) = v12;
      v14 = *a2;
      if (((*(**a4 + 16))(*a4, &v17, &v14) & 0x80000000) != 0)
      {
        ++*(&v15 + 1);
        v17 = v15;
        std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v18, v16);
        *a1 = v17;
        std::__function::__value_func<std::string_view ()(long long)>::operator=[abi:ne200100]((a1 + 1), v18);
        std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v18);
        v10 = v8 + ~v10;
      }

      std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v16);
      v8 = v10;
    }

    while (v10);
  }

  *a5 = *a1;
  return std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100]((a5 + 1), (a1 + 1));
}

void sub_1B5A8C18C(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

_OWORD *quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::Iterator(_OWORD *a1, _OWORD *a2, uint64_t a3)
{
  *a1 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100]((a1 + 1), (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100]((a1 + 3), a3);
  return a1;
}

uint64_t quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>::operator+@<X0>(uint64_t *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  v9 = *MEMORY[0x1E69E9840];
  v5 = *a1;
  v6 = a1[1];
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v8, (a1 + 2));
  *a3 = v5;
  a3[1] = v6 + a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100]((a3 + 2), v8);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v8);
}

void sub_1B5A8C2A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](va);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJN6quasar9tennessee8internal8IteratorINS_17basic_string_viewIcNS_11char_traitsIcEEEExNS6_IxSA_NS4_20ImmutableSortedArrayIxNS4_9CollationIxxEENS_10unique_ptrISD_NS_14default_deleteISD_EEEEE8IteratorEEEEESL_bEEC2B8ne200100IJLm0ELm1ELm2EEJSL_SL_bEJEJEJRSL_SO_RKbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSS_IJDpT2_EEEDpOT3_(uint64_t a1, _OWORD *a2, _OWORD *a3, _BYTE *a4)
{
  *a1 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](a1 + 16, (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](a1 + 48, (a2 + 3));
  *(a1 + 80) = *a3;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](a1 + 96, (a3 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](a1 + 128, (a3 + 3));
  *(a1 + 160) = *a4;
  return a1;
}

void sub_1B5A8C338(_Unwind_Exception *a1)
{
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v1 + 96);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v1 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v1 + 16);
  _Unwind_Resume(a1);
}

uint64_t std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,BOOL>::__tuple_impl(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](a1 + 16, a2 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](a1 + 48, a2 + 48);
  *(a1 + 80) = *(a2 + 80);
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](a1 + 96, a2 + 96);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](a1 + 128, a2 + 128);
  *(a1 + 160) = *(a2 + 160);
  return a1;
}

uint64_t *std::vector<long long>::__insert_with_size[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(void *a1, uint64_t *__src, __int128 *a3, __int128 *a4, uint64_t a5)
{
  v5 = __src;
  v61[4] = *MEMORY[0x1E69E9840];
  if (a5 >= 1)
  {
    v10 = a1[1];
    v9 = a1[2];
    if (a5 <= (v9 - v10) >> 3)
    {
      v17 = v10 - __src;
      if (a5 <= (v10 - __src) >> 3)
      {
        v24 = &__src[a5];
        v25 = &v10[-8 * a5];
        v26 = a1[1];
        while (v25 < v10)
        {
          v27 = *v25;
          v25 += 8;
          *v26++ = v27;
        }

        a1[1] = v26;
        if (v10 != v24)
        {
          memmove(&__src[a5], __src, v10 - v24);
        }

        v40 = *a3;
        std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v41, (a3 + 1));
        std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v42, (a3 + 3));
        std::copy_n[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long,long long *,0>(&v40, a5, v5);
        std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v42);
        v28 = v41;
      }

      else
      {
        v55 = *a3;
        std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v56, (a3 + 1));
        std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v57, (a3 + 3));
        std::__advance[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(&v55, v17 >> 3);
        v58 = v55;
        std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](&v59, v56);
        std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v61, v57);
        std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v57);
        std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v56);
        v52 = v58;
        std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v53, &v59);
        std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v54, v61);
        v49 = *a4;
        std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v50, (a4 + 1));
        std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v51, (a4 + 3));
        std::vector<long long>::__construct_at_end<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(a1, &v52, &v49);
        std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v51);
        std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v50);
        std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v54);
        std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v53);
        if (v17 >> 3 >= 1)
        {
          v19 = &v5[a5];
          v20 = a1[1];
          v21 = &v20[-a5];
          v22 = v20;
          while (v21 < v10)
          {
            v23 = *v21;
            v21 += 8;
            *v22++ = v23;
          }

          a1[1] = v22;
          if (v20 != v19)
          {
            memmove(&v5[a5], v5, v20 - v19);
          }

          v46 = *a3;
          std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v47, (a3 + 1));
          std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v48, (a3 + 3));
          v43 = v58;
          std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v44, &v59);
          std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v45, v61);
          std::copy[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>(&v46, &v43, v5);
          std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v45);
          std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v44);
          std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v48);
          std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v47);
        }

        std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v61);
        v28 = &v59;
      }

      std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v28);
    }

    else
    {
      v11 = *a1;
      v12 = a5 + (&v10[-*a1] >> 3);
      if (v12 >> 61)
      {
        std::vector<int>::__throw_length_error[abi:ne200100]();
      }

      v13 = __src - v11;
      v14 = v9 - v11;
      if (v14 >> 2 > v12)
      {
        v12 = v14 >> 2;
      }

      if (v14 >= 0x7FFFFFFFFFFFFFF8)
      {
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v15 = v12;
      }

      v16 = v13 >> 3;
      v60 = a1;
      if (v15)
      {
        std::__allocate_at_least[abi:ne200100]<std::allocator<unsigned long>>(a1, v15);
      }

      *&v58 = 0;
      *(&v58 + 1) = 8 * v16;
      v59 = (8 * v16);
      v37 = *a3;
      std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v38, (a3 + 1));
      std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v39, (a3 + 3));
      std::__split_buffer<long long>::__construct_at_end_with_size<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(&v58, &v37, a5);
      std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v39);
      std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v38);
      v29 = *(&v58 + 1);
      memcpy(v59, v5, a1[1] - v5);
      v30 = *a1;
      v31 = *(&v58 + 1);
      *&v59 = v59 + a1[1] - v5;
      a1[1] = v5;
      v32 = v5 - v30;
      v33 = (v31 - (v5 - v30));
      memcpy(v33, v30, v32);
      v34 = *a1;
      *a1 = v33;
      v35 = a1[2];
      *(a1 + 1) = v59;
      *&v59 = v34;
      *(&v59 + 1) = v35;
      *&v58 = v34;
      *(&v58 + 1) = v34;
      if (v34)
      {
        operator delete(v34);
      }

      return v29;
    }
  }

  return v5;
}

void sub_1B5A8C7E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v11 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v11 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v10 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v10 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v12);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](a10);
  _Unwind_Resume(a1);
}

void sub_1B5A8C8B0()
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v0 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v0 + 16);
  v3 = *(v1 - 168);
  v2 = *(v1 - 160);
  if (v2 != v3)
  {
    *(v1 - 160) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }

  v4 = *(v1 - 176);
  if (v4)
  {
    operator delete(v4);
  }

  JUMPOUT(0x1B5A8C8A8);
}

uint64_t std::distance[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(__int128 *a1, __int128 *a2)
{
  v16[5] = *MEMORY[0x1E69E9840];
  v9 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v10, (a1 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v11, (a1 + 3));
  v6 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v7, (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v8, (a2 + 3));
  v12 = v9;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v13, v10);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v14, v11);
  v15 = v12;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v16, v13);
  v4 = *(&v15 + 1);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v14);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v13);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v8);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v7);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v11);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v10);
  return *(&v6 + 1) - v4;
}

void sub_1B5A8CA34(_Unwind_Exception *a1)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v3 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v3 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v1 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v1 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v2 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v2 + 16);
  _Unwind_Resume(a1);
}

uint64_t std::vector<long long>::__construct_at_end<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(uint64_t a1, __int128 *a2, __int128 *a3)
{
  v14[5] = *MEMORY[0x1E69E9840];
  v6 = *(a1 + 8);
  v12 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v13, (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v14, (a2 + 3));
  v9 = *a3;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v10, (a3 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v11, (a3 + 3));
  v7 = std::__uninitialized_allocator_copy[abi:ne200100]<std::allocator<long long>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>(a1, &v12, &v9, v6);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v11);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v10);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v14);
  result = std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v13);
  *(a1 + 8) = v7;
  return result;
}

void sub_1B5A8CB90(_Unwind_Exception *a1)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v3 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v3 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v4 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v4 + 16);
  *(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::copy[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>(__int128 *a1, __int128 *a2, uint64_t *a3)
{
  v16[5] = *MEMORY[0x1E69E9840];
  v11 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v12, (a1 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v13, (a1 + 3));
  v8 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v9, (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v10, (a2 + 3));
  std::__copy[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>(&v11, &v8, a3, v14);
  v6 = v16[4];
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v16);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&v15);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v10);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v9);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v13);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v12);
  return v6;
}

void sub_1B5A8CCC4(_Unwind_Exception *a1)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v1 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v1 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v2 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v2 + 16);
  _Unwind_Resume(a1);
}

uint64_t std::copy_n[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long,long long *,0>(uint64_t *a1, int a2, uint64_t *a3)
{
  v13[5] = *MEMORY[0x1E69E9840];
  v11 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v12, (a1 + 2));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v13, (a1 + 6));
  quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator+(a1, a2, &v8);
  v6 = std::copy[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>(&v11, &v8, a3);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](&v10);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&v9);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v13);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v12);
  return v6;
}

void sub_1B5A8CDE4(_Unwind_Exception *a1)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v1 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v1 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v2 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v2 + 16);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<long long>::__construct_at_end_with_size<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(uint64_t result, void *a2, uint64_t a3)
{
  v3 = result;
  v10[4] = *MEMORY[0x1E69E9840];
  v4 = *(result + 16);
  if (a3)
  {
    v6 = 8 * a3;
    v7 = &v4[a3];
    do
    {
      *v4 = quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator*(a2);
      quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator++(a2, &v8);
      std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v10);
      result = std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&v9);
      ++v4;
      v6 -= 8;
    }

    while (v6);
    v4 = v7;
  }

  *(v3 + 16) = v4;
  return result;
}

uint64_t std::__advance[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(uint64_t a1, int a2)
{
  v5[4] = *MEMORY[0x1E69E9840];
  quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator+=(a1, a2, &v3);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v5);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&v4);
}

uint64_t quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator+=@<X0>(uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  v6[5] = *MEMORY[0x1E69E9840];
  *(a1 + 8) += a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v6, a1 + 16);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v6);
  *a3 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100]((a3 + 1), a1 + 16);
  return std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100]((a3 + 3), a1 + 48);
}

uint64_t *std::__uninitialized_allocator_copy[abi:ne200100]<std::allocator<long long>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t *a4)
{
  v26[4] = *MEMORY[0x1E69E9840];
  v19 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v20, (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v21, (a2 + 3));
  v16 = *a3;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v17, (a3 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v18, (a3 + 3));
  std::__unwrap_range[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(&v19, &v16, &v22);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v18);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v17);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v21);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v20);
  v13 = v22;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v14, v23);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v15, v24);
  v10 = v24[2];
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v11, v25);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v12, v26);
  v8 = std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<long long>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>(a1, &v13, &v10, a4);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v12);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v11);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v15);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v14);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v26);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v25);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v24);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v23);
  return v8;
}

void sub_1B5A8D1C8(_Unwind_Exception *a1)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v2 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v2 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v1 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v1 + 16);
  std::pair<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>::~pair(v3 - 232);
  _Unwind_Resume(a1);
}

uint64_t std::__unwrap_range[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>@<X0>(__int128 *a1@<X0>, __int128 *a2@<X1>, _OWORD *a3@<X8>)
{
  v21[5] = *MEMORY[0x1E69E9840];
  v13 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v14, (a1 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v15, (a1 + 3));
  v19 = v13;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v20, v14);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v21, v15);
  v16 = v19;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v17, v20);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v18, v21);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v21);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v20);
  v7 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v8, (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v9, (a2 + 3));
  v19 = v7;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v20, v8);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v21, v9);
  v10 = v19;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v11, v20);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v12, v21);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v21);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v20);
  *a3 = v16;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100]((a3 + 1), v17);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100]((a3 + 3), v18);
  a3[5] = v10;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100]((a3 + 6), v11);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100]((a3 + 8), v12);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v12);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v11);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v9);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v8);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v18);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v17);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v15);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v14);
}

void sub_1B5A8D410(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v2 + 16);
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t *std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<long long>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>(uint64_t a1, void *a2, void *a3, uint64_t *a4)
{
  for (v12[4] = *MEMORY[0x1E69E9840]; *a2 != *a3 || a2[1] != a3[1]; ++a4)
  {
    *a4 = quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator*(a2);
    quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator++(a2, &v10);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v12);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&v11);
  }

  return a4;
}

uint64_t std::pair<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>::~pair(uint64_t a1)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](a1 + 128);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](a1 + 96);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](a1 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](a1 + 16);
  return a1;
}

uint64_t std::__copy[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>@<X0>(__int128 *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  v14[5] = *MEMORY[0x1E69E9840];
  v12 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v13, (a1 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v14, (a1 + 3));
  v9 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v10, (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v11, (a2 + 3));
  std::__copy_move_unwrap_iters[abi:ne200100]<std::__copy_impl,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *,0>(&v12, &v9, a3, a4);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v11);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v10);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v14);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v13);
}

void sub_1B5A8D644(_Unwind_Exception *a1)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v1 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v1 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v2 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v2 + 16);
  _Unwind_Resume(a1);
}

uint64_t std::__copy_move_unwrap_iters[abi:ne200100]<std::__copy_impl,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *,0>@<X0>(__int128 *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  v38[4] = *MEMORY[0x1E69E9840];
  v31 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v32, (a1 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v33, (a1 + 3));
  v28 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v29, (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v30, (a2 + 3));
  std::__unwrap_range[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(&v31, &v28, &v34);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v30);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v29);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v33);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v32);
  v22 = v34;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v23, v35);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v24, v36);
  v19 = v36[2];
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v20, v37);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v21, v38);
  std::__copy_impl::operator()[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>(&v22, &v19, a3, &v25);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v21);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v20);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v24);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v23);
  v13 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v14, (a1 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v15, (a1 + 3));
  v10 = v25;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v11, v26);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v12, v27);
  std::__rewrap_range[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>(&v13, &v10, &v16);
  v8 = v27[4];
  *a4 = v16;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](a4 + 16, v17);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](a4 + 48, v18);
  *(a4 + 80) = v8;
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v18);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v17);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v12);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v11);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v15);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v14);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v27);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v26);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v38);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v37);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v36);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v35);
}

void sub_1B5A8D8D8(_Unwind_Exception *a1)
{
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v2 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v2 + 16);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v1 + 48);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v1 + 16);
  std::pair<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>::~pair(v3 - 248);
  _Unwind_Resume(a1);
}

uint64_t std::__copy_impl::operator()[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,long long *>@<X0>(void *a1@<X1>, void *a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X8>)
{
  v13[4] = *MEMORY[0x1E69E9840];
  while (*a1 != *a2 || a1[1] != a2[1])
  {
    *a3++ = quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator*(a1);
    quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>::operator++(a1, &v11);
    std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v13);
    std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](&v12);
  }

  *a4 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](a4 + 16, (a1 + 2));
  result = std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](a4 + 48, (a1 + 6));
  *(a4 + 80) = a3;
  return result;
}

uint64_t std::__rewrap_range[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>>@<X0>(__int128 *a1@<X0>, __int128 *a2@<X1>, _OWORD *a3@<X8>)
{
  v12[5] = *MEMORY[0x1E69E9840];
  v10 = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v11, (a1 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v12, (a1 + 3));
  v7 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v8, (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v9, (a2 + 3));
  std::__rewrap_iter[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,std::__unwrap_iter_impl<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,false>>(&v10, &v7, a3);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v9);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v8);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v12);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v11);
}

uint64_t std::__rewrap_iter[abi:ne200100]<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,std::__unwrap_iter_impl<quasar::tennessee::internal::Iterator<std::string_view,long long,quasar::tennessee::internal::Iterator<long long,std::string_view,quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>::Iterator>>,false>>@<X0>(_OWORD *a1@<X0>, __int128 *a2@<X1>, _OWORD *a3@<X8>)
{
  v11[5] = *MEMORY[0x1E69E9840];
  v9[2] = *a1;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v10, (a1 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v11, (a1 + 3));
  v7 = *a2;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100](v8, (a2 + 1));
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100](v9, (a2 + 3));
  *a3 = v7;
  std::__function::__value_func<std::string_view ()(long long)>::__value_func[abi:ne200100]((a3 + 1), v8);
  std::__function::__value_func<long long ()(std::string_view)>::__value_func[abi:ne200100]((a3 + 3), v9);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v9);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v8);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](v11);
  return std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](v10);
}

void sub_1B5A8DD4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  std::__function::__value_func<long long ()(std::string_view)>::~__value_func[abi:ne200100](va);
  std::__function::__value_func<std::string_view ()(long long)>::~__value_func[abi:ne200100](va1);
  if (a2)
  {
    std::make_unique[abi:ne200100]<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData>,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::IterableCollation<std::string_view,wchar_t>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>,0>();
  }

  MEMORY[0x1B8C85350](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void)::{lambda(long long)#1},std::allocator<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void)::{lambda(long long)#1}>,std::string_view ()(long long)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2D42CC8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void)::{lambda(long long)#1},std::allocator<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void)::{lambda(long long)#1}>,std::string_view ()(long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__func<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void)::{lambda(std::string_view)#1},std::allocator<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void)::{lambda(std::string_view)#1}>,long long ()(std::string_view)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2D42D48;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void)::{lambda(std::string_view)#1},std::allocator<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Initialize(void)::{lambda(std::string_view)#1}>,long long ()(std::string_view)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__func<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Find(std::string_view const&)::{lambda(long long)#1},std::allocator<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Find(std::string_view const&)::{lambda(long long)#1}>,std::string_view ()(long long)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2D42DC8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Find(std::string_view const&)::{lambda(long long)#1},std::allocator<quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::Find(std::string_view const&)::{lambda(long long)#1}>,std::string_view ()(long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::VerifyTokenIdBounds(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
  {
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    v9 = 0u;
    v10 = 0u;
    v7 = 0u;
    v8 = 0u;
    v6 = 0u;
    quasar::QuasarExceptionMessage::QuasarExceptionMessage(&v6);
    goto LABEL_5;
  }

  result = (*(**(a1 + 16) + 32))(*(a1 + 16));
  if (result <= a2)
  {
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    v9 = 0u;
    v10 = 0u;
    v7 = 0u;
    v8 = 0u;
    v6 = 0u;
    kaldi::KaldiWarnMessage::KaldiWarnMessage(&v6);
    v4 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v6, "Token ", 6);
    v5 = MEMORY[0x1B8C84C60](v4, a2);
    std::operator<<[abi:ne200100]<std::char_traits<char>>(v5, " exceeds the bounds.");
LABEL_5:
    quasar::QuasarExceptionMessage::~QuasarExceptionMessage(&v6);
  }

  return result;
}

uint64_t OUTLINED_FUNCTION_1_3(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  return result;
}

uint64_t OUTLINED_FUNCTION_2_4(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  return result;
}

void kaldi::nnet1::SimplerSimpleRecurrentUnit::SimplerSimpleRecurrentUnit(kaldi::nnet1::SimplerSimpleRecurrentUnit *this, const kaldi::nnet1::SimplerSimpleRecurrentUnit *a2)
{
  *(this + 7) = *(a2 + *(*a2 - 40) + 8);
  *(this + 32) = 0;
  *(this + 10) = 0;
  *(this + 11) = 0;
  *(this + 9) = 0;
  *(this + 15) = 0;
  *(this + 16) = 0;
  *(this + 17) = &unk_1F2D27A18;
  *(this + 36) = 1;
  *(this + 6) = &unk_1F2D42FC8;
  *this = &unk_1F2D42E78;
  *(this + 12) = &unk_1F2D43098;
  *(this + 13) = &unk_1F2D43118;
  *(this + 14) = 0;
  *(this + 1) = 0;
  *(this + 4) = 0;
  *(this + 5) = 0;
  *(this + 2) = &unk_1F2D3AC18;
  *(this + 3) = 0;
  operator new();
}

void sub_1B5A8E3A8(_Unwind_Exception *a1)
{
  kaldi::CuVector<float>::~CuVector(v6);
  std::unique_ptr<kaldi::nnet1::Nnet>::reset[abi:ne200100](v5, 0);
  kaldi::nnet1::HistoricalComponent::~HistoricalComponent(v4);
  quasar::Bitmap::~Bitmap(v3);
  quasar::Bitmap::~Bitmap(v2);
  kaldi::nnet1::Component::~Component(v1);
  _Unwind_Resume(a1);
}

uint64_t kaldi::nnet1::SimplerSimpleRecurrentUnit::PropagateFnc(uint64_t **a1, int32x2_t *a2, int *a3, uint64_t a4)
{
  v8 = a2[2].u32[1];
  if (kaldi::g_kaldi_verbose_level >= 3)
  {
    kaldi::KaldiVlogMessage::KaldiVlogMessage(v22, 3);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v22, "Running forward propagation for batch size = ", 45);
    v10 = MEMORY[0x1B8C84C00](v9, v8);
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, ", which contains ", 17);
    v12 = MEMORY[0x1B8C84C00](v11, 1);
    v13 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, " frames each from ", 18);
    v14 = MEMORY[0x1B8C84C00](v13, v8);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v14, " utterances.", 12);
    kaldi::KaldiVlogMessage::~KaldiVlogMessage(v22);
  }

  ((*a1)[18])(a1);
  v15 = &(*(a1 + *(*a1 - 8) + 8))[6 * a4];
  if (!v15[2].i32[1])
  {
    v16 = ((*a1)[9])(a1);
    kaldi::CuMatrix<float>::Resize(v15, v8, v16, 0, 0);
    kaldi::CuMatrixBase<float>::CopyRowsFromVec(v15, (a1 + 2));
  }

  memset(&v22[1], 0, 32);
  v22[0].__locale_ = &unk_1F2D0EE38;
  v23 = 0;
  kaldi::nnet1::Nnet::Propagate<kaldi::CuSubMatrix<float>>(a1[1], a2, v22, a4);
  kaldi::CuMatrix<float>::CuMatrix(v21, v8, *(a1 + *(*a1 - 5) + 12), 1, 0, 0);
  v19[2].i32[0] = *(a1 + *(*a1 - 5) + 12);
  *(&v19[2] + 4) = *(&v22[2].__locale_ + 4);
  v19[3].i32[1] = HIDWORD(v22[3].__locale_);
  v19[4] = v22[4].__locale_;
  v19[0] = &unk_1F2CFA908;
  v19[1] = v22[1].__locale_;
  kaldi::CuMatrixBase<float>::Sigmoid(v21, v19);
  v19[0] = &unk_1F2CFA908;
  memset(&v19[1], 0, 32);
  quasar::Bitmap::~Bitmap(v19);
  LODWORD(v20[2]) = *(a1 + *(*a1 - 5) + 12);
  *(&v20[2] + 4) = *(&v22[2].__locale_ + 4);
  HIDWORD(v20[3]) = HIDWORD(v22[3].__locale_) - LODWORD(v20[2]);
  v20[4] = v22[4];
  v20[0] = &unk_1F2CFA908;
  v20[1] = v22[1].__locale_ + 4 * SLODWORD(v20[2]);
  kaldi::CuMatrix<float>::CuMatrix(v19, v8, SLODWORD(v20[2]), 1, 0, 0);
  v17.i32[0] = 1.0;
  kaldi::CuMatrixBase<float>::Set(v19, v17);
  kaldi::CuMatrixBase<float>::AddMat(v19, v21, 111, -1.0, 1.0);
  kaldi::CuMatrixBase<float>::MulElements(v19, v20);
  kaldi::CuMatrixBase<float>::MulElements(v15, v21);
  kaldi::CuMatrixBase<float>::AddMat(v15, v19, 111, 1.0, 1.0);
  kaldi::CuMatrixBase<float>::CopyFromMat<float>(a3, v15, 111);
  kaldi::CuMatrix<float>::~CuMatrix(v19);
  v20[0] = &unk_1F2CFA908;
  memset(&v20[1], 0, 32);
  quasar::Bitmap::~Bitmap(v20);
  kaldi::CuMatrix<float>::~CuMatrix(v21);
  return kaldi::CuMatrix<float>::~CuMatrix(v22);
}

void sub_1B5A8E7AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
  *(v26 + 8) = 0u;
  *(v26 + 24) = 0u;
  quasar::Bitmap::~Bitmap(&a15);
  kaldi::CuMatrix<float>::~CuMatrix(&a20);
  kaldi::CuMatrix<float>::~CuMatrix(&a26);
  _Unwind_Resume(a1);
}

void kaldi::nnet1::SimplerSimpleRecurrentUnit::ReadData(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (kaldi::g_kaldi_verbose_level >= 2)
  {
    kaldi::KaldiVlogMessage::KaldiVlogMessage(&v23, 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v23, "Reading SimplerSimpleRecurrentUnit component", 44);
    kaldi::KaldiVlogMessage::~KaldiVlogMessage(&v23);
  }

  __p = 0;
  v21 = 0;
  v22 = 0;
  while (1)
  {
    if (kaldi::Peek(a2, a3) != 60)
    {
      goto LABEL_42;
    }

    kaldi::ReadToken(a2, a3, &__p);
    if (SHIBYTE(v22) < 0)
    {
      break;
    }

    if (HIBYTE(v22) != 5)
    {
      if (HIBYTE(v22) != 16)
      {
        goto LABEL_50;
      }

      if (__p != 0x72547475706E493CLL || v21 != 0x3E6D726F66736E61)
      {
        goto LABEL_50;
      }

LABEL_13:
      operator new();
    }

    p_p = &__p;
LABEL_23:
    v9 = *p_p;
    v10 = p_p[4];
    if (v9 != 811557692 || v10 != 62)
    {
      goto LABEL_29;
    }

    kaldi::CuVector<float>::Read(a1 + 16, a2, a3);
  }

  if (v21 == 5)
  {
    p_p = __p;
    goto LABEL_23;
  }

  if (v21 == 16 && *__p == 0x72547475706E493CLL && *(__p + 1) == 0x3E6D726F66736E61)
  {
    goto LABEL_13;
  }

LABEL_29:
  if ((v22 & 0x8000000000000000) == 0 || v21 != 29 || (*__p == 0x656C706D69532F3CLL ? (v12 = *(__p + 1) == 0x52656C706D695372) : (v12 = 0), v12 ? (v13 = *(__p + 2) == 0x746E657272756365) : (v13 = 0), v13 ? (v14 = *(__p + 21) == 0x3E74696E55746E65) : (v14 = 0), !v14))
  {
LABEL_50:
    kaldi::KaldiWarnMessage::KaldiWarnMessage(&v23);
    v17 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v23, "Unrecognized token ", 19);
    if (v22 >= 0)
    {
      v18 = &__p;
    }

    else
    {
      v18 = __p;
    }

    if (v22 >= 0)
    {
      v19 = HIBYTE(v22);
    }

    else
    {
      v19 = v21;
    }

    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v17, v18, v19);
    kaldi::KaldiErrorMessage::~KaldiErrorMessage(&v23);
  }

LABEL_42:
  if (kaldi::g_kaldi_verbose_level >= 2)
  {
    kaldi::KaldiVlogMessage::KaldiVlogMessage(&v23, 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v23, "done", 4);
    kaldi::KaldiVlogMessage::~KaldiVlogMessage(&v23);
  }

  kaldi::nnet1::Nnet::GetHistoricalComponents(*(a1 + 8), &v23);
  locale = v23.__locale_;
  v16 = v24;
  if (v23.__locale_)
  {
    v24 = v23.__locale_;
    operator delete(v23.__locale_);
  }

  if (locale != v16)
  {
    kaldi::KaldiWarnMessage::KaldiWarnMessage(&v23);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v23, "Another recurrent neural networks are not supported inside SSRU component.", 74);
    kaldi::KaldiErrorMessage::~KaldiErrorMessage(&v23);
  }

  kaldi::nnet1::Nnet::OutputDim(*(a1 + 8));
  kaldi::nnet1::Nnet::InputDim(*(a1 + 8));
  if (SHIBYTE(v22) < 0)
  {
    operator delete(__p);
  }
}

void sub_1B5A8EDA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void *kaldi::nnet1::SimplerSimpleRecurrentUnit::WriteData(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  kaldi::WriteToken(a2, a3, "<InputTransform>");
  kaldi::nnet1::Nnet::Write(*(a1 + 8), a2, a3, a4);
  kaldi::WriteToken(a2, a3, "<c_0>");
  kaldi::CuVectorBase<float>::Write(a1 + 16, a2, a3);

  return kaldi::WriteToken(a2, a3, "</SimplerSimpleRecurrentUnit>");
}

uint64_t kaldi::nnet1::SimplerSimpleRecurrentUnit::ResetHistoryState(uint64_t *a1, void *a2, uint64_t a3)
{
  (*(*a1 + 144))(a1);
  v6 = a2[1];
  v7 = *a1;
  *(*(a1 + *(*a1 - 64) + 8) + 32) = a3;
  if (v6)
  {
    for (i = 0; i != v6; ++i)
    {
      if (((*(*a2 + ((i >> 3) & 0x1FFFFFFFFFFFFFF8)) >> i) & 1) == 0)
      {
        kaldi::KaldiWarnMessage::KaldiWarnMessage(&v10);
        std::operator<<[abi:ne200100]<std::char_traits<char>>(&v10, "ResetHistoryState for SimplerSimpleRecurrentUnit makes only sense if all utterances get reset at the same time");
        kaldi::KaldiErrorMessage::~KaldiErrorMessage(&v10);
      }
    }
  }

  v12 = 0u;
  v11 = 0u;
  v10 = &unk_1F2D0EE38;
  v13 = 0;
  kaldi::CuMatrix<float>::operator=(*(a1 + *(v7 - 64) + 8), &v10);
  return kaldi::CuMatrix<float>::~CuMatrix(&v10);
}

uint64_t kaldi::nnet1::SimplerSimpleRecurrentUnit::ResetHistoryState(kaldi::nnet1::SimplerSimpleRecurrentUnit *this)
{
  v2 = *this;
  v3 = this + *(*this - 64);
  v5 = *(v3 + 1);
  v4 = *(v3 + 2);
  if (v4 != v5)
  {
    v6 = v4 - 6;
    v7 = v4 - 6;
    v8 = v4 - 6;
    do
    {
      v9 = *v8;
      v8 -= 6;
      (*(v9 + 16))(v7);
      v6 -= 6;
      v10 = v7 == v5;
      v7 = v8;
    }

    while (!v10);
    v2 = *this;
  }

  *(v3 + 2) = v5;
  v11 = *(v2 + 144);

  return v11(this);
}

int *kaldi::nnet1::SimplerSimpleRecurrentUnit::GetHistoryState(void *a1, int32x2_t *a2)
{
  v4 = *(a1 + *(*a1 - 64) + 8);
  kaldi::CuMatrix<float>::Resize(a2, *(v4 + 20), *(v4 + 16), 0, 0);
  v5 = *(a1 + *(*a1 - 64) + 8);

  return kaldi::CuMatrixBase<float>::CopyFromMat<float>(a2, v5, 111);
}

void *kaldi::nnet1::SimplerSimpleRecurrentUnit::GetHistoryState(uint64_t a1, void *a2, int a3)
{
  v6 = (*(*a1 + 72))(a1);
  kaldi::CuVector<float>::Resize(a2, v6, 0);
  v7 = *(a1 + *(*a1 - 64) + 8);
  if (*(v7 + 20) < 1)
  {

    return kaldi::CuVectorBase<float>::CopyFromVec(a2, a1 + 16);
  }

  else
  {
    v8 = *(v7 + 8) + 4 * *(v7 + 24) * a3;
    v9 = *(v7 + 16);
    v10 = *(v7 + 32);
    v12[1] = v8;
    v12[0] = &unk_1F2CFCA48;
    v12[2] = v9;
    v12[3] = v10;
    return kaldi::CuVectorBase<float>::CopyFromVec(a2, v12);
  }
}

int *kaldi::nnet1::SimplerSimpleRecurrentUnit::SetHistoryState(uint64_t a1, uint64_t a2)
{
  (*(*a1 + 144))(a1);
  kaldi::CuMatrix<float>::Resize(*(a1 + *(*a1 - 64) + 8), *(a2 + 20), *(a2 + 16), 0, 0);
  v4 = *(a1 + *(*a1 - 64) + 8);

  return kaldi::CuMatrixBase<float>::CopyFromMat<float>(v4, a2, 111);
}

void kaldi::nnet1::SimplerSimpleRecurrentUnit::SetHistoryState(uint64_t a1, uint64_t a2, int a3)
{
  (*(*a1 + 144))(a1);
  (*(*a1 + 72))(a1);
  v6 = *(a2 + 16);
  v7 = a1 + *(*a1 - 64);
  v8 = *(v7 + 8);
  if (v6 < 1)
  {

    kaldi::CuMatrix<float>::Resize(v8, 0, 0, 0, 0);
  }

  else
  {
    kaldi::CuMatrix<float>::Resize(v8, *(v7 + 40), v6, 2, 0);
    v9 = *(a1 + *(*a1 - 64) + 8);
    v10 = *(v9 + 8) + 4 * *(v9 + 24) * a3;
    v11 = *(v9 + 16);
    v12 = *(v9 + 32);
    v13[1] = v10;
    v13[0] = &unk_1F2CFCA48;
    v13[2] = v11;
    v13[3] = v12;
    kaldi::CuVectorBase<float>::CopyFromVec(v13, a2);
  }
}

void kaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit(kaldi::nnet1::SimplerSimpleRecurrentUnit *this)
{
  kaldi::nnet1::HistoricalComponent::~HistoricalComponent((v2 + 104));
  quasar::Bitmap::~Bitmap((this + 96));
  quasar::Bitmap::~Bitmap(this);
  kaldi::nnet1::Component::~Component((this + 48));
}

{
  kaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit(this);

  JUMPOUT(0x1B8C85350);
}

void kaldi::nnet1::SimplerSimpleRecurrentUnit::BackpropagateFnc()
{
  kaldi::KaldiWarnMessage::KaldiWarnMessage(v0);
  std::operator<<[abi:ne200100]<std::char_traits<char>>(v0, "Unimplemented");
  kaldi::KaldiErrorMessage::~KaldiErrorMessage(v0);
}

void virtual thunk tokaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit(kaldi::nnet1::SimplerSimpleRecurrentUnit *this)
{
  kaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit((this + *(*this - 24)));
}

{
  kaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit((this + *(*this - 24)));

  JUMPOUT(0x1B8C85350);
}

void virtual thunk tokaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit(void *a1)
{
  kaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit((a1 + *(*a1 - 24)));
}

{
  kaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit((a1 + *(*a1 - 24)));

  JUMPOUT(0x1B8C85350);
}

{
  kaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit((a1 + *(*a1 - 24)));
}

{
  kaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit((a1 + *(*a1 - 24)));

  JUMPOUT(0x1B8C85350);
}

void kaldi::nnet1::SimplerSimpleRecurrentUnit::~SimplerSimpleRecurrentUnit(kaldi::nnet1::SimplerSimpleRecurrentUnit *this, uint64_t *a2)
{
  v3 = *a2;
  *this = *a2;
  *(this + *(v3 - 40)) = a2[1];
  *(this + *(*this - 48)) = a2[2];
  *(this + *(*this - 56)) = a2[3];
  *(this + *(*this - 64)) = a2[4];
  kaldi::CuVector<float>::~CuVector(this + 2);
  std::unique_ptr<kaldi::nnet1::Nnet>::reset[abi:ne200100](this + 1, 0);
}

uint64_t __swift_instantiateConcreteTypeFromMangledNameV2(uint64_t *a1)
{
  result = *a1;
  if (!result)
  {
    result = swift_getTypeByMangledNameInContext2();
    *a1 = result;
  }

  return result;
}

uint64_t sub_1B5A91CB4()
{
  v4 = MEMORY[0x1E69E7CD0];
  v1 = *(v0 + OBJC_IVAR____EAREntityTagger_nlTagger);
  v2 = sub_1B5AD6634();
  [v1 setString_];

  sub_1B5AD6714();
  return v4;
}

void sub_1B5A91DA4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    v4 = *(a4 + OBJC_IVAR____EAREntityTagger_supportedTags);
    v20 = a1;
    v18[2] = &v20;
    v5 = MEMORY[0x1EEE9AC00](a1);
    if (sub_1B5A9365C(sub_1B5A954CC, v18, v4))
    {
      v6 = sub_1B5AD66B4();
      v7 = MEMORY[0x1B8C83C50](v6);
      v9 = v8;

      v10 = sub_1B5AD6664();
      v12 = v11;
      v13 = type metadata accessor for _EARExtractedEntity();
      v14 = objc_allocWithZone(v13);
      v15 = &v14[OBJC_IVAR____EARExtractedEntity_entityContent];
      *v15 = v7;
      v15[1] = v9;
      v16 = &v14[OBJC_IVAR____EARExtractedEntity_tagName];
      *v16 = v10;
      v16[1] = v12;
      v19.receiver = v14;
      v19.super_class = v13;
      v17 = objc_msgSendSuper2(&v19, sel_init);
      sub_1B5A93704(&v20, v17);
    }

    else
    {
    }
  }
}

id sub_1B5A91F14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9 = objc_allocWithZone(v4);
  v10 = &v9[OBJC_IVAR____EARExtractedEntity_entityContent];
  *v10 = a1;
  *(v10 + 1) = a2;
  v11 = &v9[OBJC_IVAR____EARExtractedEntity_tagName];
  *v11 = a3;
  *(v11 + 1) = a4;
  v13.receiver = v9;
  v13.super_class = v4;
  return objc_msgSendSuper2(&v13, sel_init);
}

uint64_t sub_1B5A92060()
{
  v1 = (*((*MEMORY[0x1E69E7D40] & *v0) + 0x68))();
  sub_1B5A920F0(v1);
  v3 = v2;

  v4 = sub_1B5A94ED4(v3);

  return v4;
}

void sub_1B5A920F0(uint64_t a1)
{
  v30 = a1 & 0xC000000000000001;
  if ((a1 & 0xC000000000000001) != 0)
  {
    v2 = sub_1B5AD67D4();
  }

  else
  {
    v2 = *(a1 + 16);
  }

  if (v2)
  {
    v36 = MEMORY[0x1E69E7CC0];
    sub_1B5A94B20(0, v2 & ~(v2 >> 63), 0);
    v3 = v36;
    if (v30)
    {
      v4 = sub_1B5AD6784();
    }

    else
    {
      v4 = sub_1B5AD6764();
      v5 = *(a1 + 36);
    }

    v33 = v4;
    v34 = v5;
    v35 = v30 != 0;
    if ((v2 & 0x8000000000000000) == 0)
    {
      v6 = 0;
      v29 = v2;
      while (v6 < v2)
      {
        if (__OFADD__(v6++, 1))
        {
          goto LABEL_36;
        }

        v9 = v33;
        v10 = v35;
        v31 = v34;
        sub_1B5A94CDC(v33, v34, v35, a1);
        v12 = v11;
        v13 = *&v11[OBJC_IVAR____EARExtractedEntity_entityContent];
        v14 = *&v11[OBJC_IVAR____EARExtractedEntity_entityContent + 8];

        v36 = v3;
        v16 = *(v3 + 16);
        v15 = *(v3 + 24);
        if (v16 >= v15 >> 1)
        {
          sub_1B5A94B20((v15 > 1), v16 + 1, 1);
          v3 = v36;
        }

        *(v3 + 16) = v16 + 1;
        v17 = v3 + 16 * v16;
        *(v17 + 32) = v13;
        *(v17 + 40) = v14;
        if (v30)
        {
          if (!v10)
          {
            goto LABEL_41;
          }

          v18 = v3;
          if (sub_1B5AD67A4())
          {
            swift_isUniquelyReferenced_nonNull_native();
          }

          v2 = v29;
          __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909548);
          v7 = sub_1B5AD6704();
          sub_1B5AD6814();
          v7(v32, 0);
        }

        else
        {
          if (v10)
          {
            goto LABEL_42;
          }

          if ((v9 & 0x8000000000000000) != 0)
          {
            goto LABEL_37;
          }

          v18 = v3;
          v19 = 1 << *(a1 + 32);
          if (v9 >= v19)
          {
            goto LABEL_37;
          }

          v20 = v9 >> 6;
          v21 = *(a1 + 56 + 8 * (v9 >> 6));
          if (((v21 >> v9) & 1) == 0)
          {
            goto LABEL_38;
          }

          if (*(a1 + 36) != v31)
          {
            goto LABEL_39;
          }

          v22 = v21 & (-2 << (v9 & 0x3F));
          if (v22)
          {
            v19 = __clz(__rbit64(v22)) | v9 & 0x7FFFFFFFFFFFFFC0;
            v2 = v29;
          }

          else
          {
            v23 = v20 << 6;
            v24 = v20 + 1;
            v25 = (a1 + 64 + 8 * v20);
            v2 = v29;
            while (v24 < (v19 + 63) >> 6)
            {
              v27 = *v25++;
              v26 = v27;
              v23 += 64;
              ++v24;
              if (v27)
              {
                sub_1B5A954BC(v9, v31, 0);
                v19 = __clz(__rbit64(v26)) + v23;
                goto LABEL_32;
              }
            }

            sub_1B5A954BC(v9, v31, 0);
          }

LABEL_32:
          v28 = *(a1 + 36);
          v33 = v19;
          v34 = v28;
          v35 = 0;
        }

        v3 = v18;
        if (v6 == v2)
        {
          sub_1B5A954BC(v33, v34, v35);
          return;
        }
      }

      __break(1u);
LABEL_36:
      __break(1u);
LABEL_37:
      __break(1u);
LABEL_38:
      __break(1u);
LABEL_39:
      __break(1u);
    }

    __break(1u);
LABEL_41:
    __break(1u);
LABEL_42:
    __break(1u);
  }
}

uint64_t sub_1B5A92544(uint64_t a1)
{
  v2 = MEMORY[0x1E69E7CD0];
  v10 = MEMORY[0x1E69E7CD0];
  v3 = *(a1 + 16);
  if (v3)
  {
    v4 = *((*MEMORY[0x1E69E7D40] & *v1) + 0x70);
    v5 = (a1 + 40);
    do
    {
      v6 = *(v5 - 1);
      v7 = *v5;

      v8 = v4(v6, v7);

      sub_1B5A92614(v8);
      v5 += 2;
      --v3;
    }

    while (v3);
    return v10;
  }

  return v2;
}

uint64_t sub_1B5A92614(uint64_t result)
{
  v1 = result;
  v2 = 0;
  v3 = result + 56;
  v4 = 1 << *(result + 32);
  v5 = -1;
  if (v4 < 64)
  {
    v5 = ~(-1 << v4);
  }

  v6 = v5 & *(result + 56);
  v7 = (v4 + 63) >> 6;
  if (v6)
  {
    while (1)
    {
      v8 = v2;
LABEL_9:
      v9 = __clz(__rbit64(v6));
      v6 &= v6 - 1;
      v10 = (*(v1 + 48) + ((v8 << 10) | (16 * v9)));
      v11 = *v10;
      v12 = v10[1];

      sub_1B5A93914(&v13, v11, v12);

      if (!v6)
      {
        goto LABEL_5;
      }
    }
  }

  while (1)
  {
LABEL_5:
    v8 = v2 + 1;
    if (__OFADD__(v2, 1))
    {
      __break(1u);
      return result;
    }

    if (v8 >= v7)
    {
      break;
    }

    v6 = *(v3 + 8 * v8);
    ++v2;
    if (v6)
    {
      v2 = v8;
      goto LABEL_9;
    }
  }
}

id sub_1B5A927AC()
{
  v1 = objc_allocWithZone(v0);

  return [v1 init];
}

id sub_1B5A927E0()
{
  v1 = OBJC_IVAR____EAREntityTagger_nlTagger;
  __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909480);
  v2 = swift_allocObject();
  *(v2 + 16) = xmmword_1B5B3CC10;
  v3 = *MEMORY[0x1E69779D8];
  *(v2 + 32) = *MEMORY[0x1E69779D8];
  v4 = objc_allocWithZone(MEMORY[0x1E6977A78]);
  type metadata accessor for NLTagScheme(0);
  v5 = v3;
  v6 = sub_1B5AD66C4();

  v7 = [v4 initWithTagSchemes_];

  *&v0[v1] = v7;
  *&v0[OBJC_IVAR____EAREntityTagger_tagOptions] = 22;
  v8 = OBJC_IVAR____EAREntityTagger_supportedTags;
  __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909490);
  v9 = swift_allocObject();
  *(v9 + 16) = xmmword_1B5B3CC20;
  v10 = *MEMORY[0x1E6977968];
  v11 = *MEMORY[0x1E6977990];
  *(v9 + 32) = *MEMORY[0x1E6977968];
  *(v9 + 40) = v11;
  v12 = *MEMORY[0x1E69779A0];
  *(v9 + 48) = *MEMORY[0x1E69779A0];
  *&v0[v8] = v9;
  v17.receiver = v0;
  v17.super_class = type metadata accessor for _EAREntityTagger();
  v13 = v10;
  v14 = v11;
  v15 = v12;
  return objc_msgSendSuper2(&v17, sel_init);
}

uint64_t sub_1B5A929E4()
{
  v1 = *(v0 + OBJC_IVAR____EARExtractedEntity_entityContent);

  return v1;
}

id sub_1B5A92A2C()
{

  v0 = sub_1B5AD6634();

  return v0;
}

uint64_t sub_1B5A92A88()
{
  v1 = *(v0 + OBJC_IVAR____EARExtractedEntity_tagName);

  return v1;
}

id sub_1B5A92AC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5 = &v4[OBJC_IVAR____EARExtractedEntity_entityContent];
  *v5 = a1;
  *(v5 + 1) = a2;
  v6 = &v4[OBJC_IVAR____EARExtractedEntity_tagName];
  *v6 = a3;
  *(v6 + 1) = a4;
  v8.receiver = v4;
  v8.super_class = type metadata accessor for _EARExtractedEntity();
  return objc_msgSendSuper2(&v8, sel_init);
}

uint64_t sub_1B5A92B9C(uint64_t a1)
{
  sub_1B5A94FB4(a1, v7);
  if (!v8)
  {
    sub_1B5A95024(v7);
    goto LABEL_14;
  }

  type metadata accessor for _EARExtractedEntity();
  if ((swift_dynamicCast() & 1) == 0)
  {
LABEL_14:
    v4 = 0;
    return v4 & 1;
  }

  v2 = *(v1 + OBJC_IVAR____EARExtractedEntity_entityContent) == *&v6[OBJC_IVAR____EARExtractedEntity_entityContent] && *(v1 + OBJC_IVAR____EARExtractedEntity_entityContent + 8) == *&v6[OBJC_IVAR____EARExtractedEntity_entityContent + 8];
  if (!v2 && (sub_1B5AD6874() & 1) == 0)
  {

    goto LABEL_14;
  }

  if (*(v1 + OBJC_IVAR____EARExtractedEntity_tagName) == *&v6[OBJC_IVAR____EARExtractedEntity_tagName] && *(v1 + OBJC_IVAR____EARExtractedEntity_tagName + 8) == *&v6[OBJC_IVAR____EARExtractedEntity_tagName + 8])
  {

    v4 = 1;
  }

  else
  {
    v4 = sub_1B5AD6874();
  }

  return v4 & 1;
}

uint64_t sub_1B5A92DDC()
{
  v1 = v0;
  sub_1B5AD6854();
  MEMORY[0x1B8C83C70](0xD000000000000023, 0x80000001B5C6DDD0);
  MEMORY[0x1B8C83C70](*(v1 + OBJC_IVAR____EARExtractedEntity_entityContent), *(v1 + OBJC_IVAR____EARExtractedEntity_entityContent + 8));
  MEMORY[0x1B8C83C70](0x6D614E676174202CLL, 0xEB00000000203A65);
  MEMORY[0x1B8C83C70](*(v1 + OBJC_IVAR____EARExtractedEntity_tagName), *(v1 + OBJC_IVAR____EARExtractedEntity_tagName + 8));
  MEMORY[0x1B8C83C70](41, 0xE100000000000000);
  return 0;
}

id sub_1B5A92F20(uint64_t (*a1)(void))
{
  v3.receiver = v1;
  v3.super_class = a1();
  return objc_msgSendSuper2(&v3, sel_dealloc);
}

BOOL sub_1B5A92FF0(void *a1, uint64_t *a2)
{
  v3 = *a2;
  v4 = *v2 & *a2;
  if (v4 != *a2)
  {
    *v2 |= v3;
  }

  *a1 = v3;
  return v4 != v3;
}

void *sub_1B5A93020@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  v3 = *v2 & *result;
  if (v3)
  {
    *v2 &= ~*result;
  }

  *a2 = v3;
  *(a2 + 8) = v3 == 0;
  return result;
}

uint64_t *sub_1B5A9304C@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  v3 = *result;
  v4 = *v2;
  *v2 |= *result;
  v5 = v4 & v3;
  *a2 = v5;
  *(a2 + 8) = v5 == 0;
  return result;
}

uint64_t sub_1B5A93124(uint64_t a1, id *a2)
{
  result = sub_1B5AD6644();
  *a2 = 0;
  return result;
}

uint64_t sub_1B5A9319C(uint64_t a1, id *a2)
{
  v3 = sub_1B5AD6654();
  *a2 = 0;
  return v3 & 1;
}

uint64_t sub_1B5A9321C@<X0>(uint64_t *a1@<X8>)
{
  sub_1B5AD6664();
  v2 = sub_1B5AD6634();

  *a1 = v2;
  return result;
}

uint64_t sub_1B5A93274@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  v3 = sub_1B5A95484(a1);

  *a2 = v3;
  return result;
}

uint64_t sub_1B5A932E4@<X0>(uint64_t *a1@<X8>)
{
  v2 = sub_1B5AD6634();

  *a1 = v2;
  return result;
}

uint64_t sub_1B5A9332C(uint64_t a1)
{
  v2 = sub_1B5A951DC(&qword_1EB909528, 255, type metadata accessor for NLTagScheme);
  v3 = sub_1B5A951DC(&qword_1EB909530, 255, type metadata accessor for NLTagScheme);
  v4 = MEMORY[0x1E69E6168];

  return MEMORY[0x1EEE6ABA0](a1, v2, v3, v4);
}

void *sub_1B5A933F0@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  *a2 = *result;
  *(a2 + 8) = 0;
  return result;
}

uint64_t sub_1B5A9340C(uint64_t a1)
{
  v2 = sub_1B5A951DC(&qword_1EB909518, 255, type metadata accessor for NLTag);
  v3 = sub_1B5A951DC(&qword_1EB909520, 255, type metadata accessor for NLTag);
  v4 = MEMORY[0x1E69E6168];

  return MEMORY[0x1EEE6ABA0](a1, v2, v3, v4);
}

uint64_t sub_1B5A934D0()
{
  v0 = sub_1B5AD6664();
  v1 = MEMORY[0x1B8C83C80](v0);

  return v1;
}

uint64_t sub_1B5A9350C()
{
  sub_1B5AD6664();
  sub_1B5AD6684();
}

uint64_t sub_1B5A93560()
{
  sub_1B5AD6664();
  sub_1B5AD6894();
  sub_1B5AD6684();
  v0 = sub_1B5AD68A4();

  return v0;
}

uint64_t sub_1B5A935D4()
{
  v0 = sub_1B5AD6664();
  v2 = v1;
  if (v0 == sub_1B5AD6664() && v2 == v3)
  {
    v5 = 1;
  }

  else
  {
    v5 = sub_1B5AD6874();
  }

  return v5 & 1;
}

uint64_t sub_1B5A9365C(uint64_t (*a1)(id *), uint64_t a2, uint64_t a3)
{
  v4 = *(a3 + 16);
  if (v4)
  {
    v6 = (a3 + 32);
    v7 = v4 - 1;
    do
    {
      v12 = *v6;
      v8 = v12;
      v9 = a1(&v12);

      if (v3)
      {
        break;
      }

      v10 = v7-- == 0;
      ++v6;
    }

    while (((v9 | v10) & 1) == 0);
  }

  else
  {
    LOBYTE(v9) = 0;
  }

  return v9 & 1;
}

uint64_t sub_1B5A93704(void *a1, void *a2)
{
  v3 = v2;
  v6 = *v2;
  if ((*v2 & 0xC000000000000001) != 0)
  {
    if (v6 < 0)
    {
      v7 = *v2;
    }

    else
    {
      v7 = v6 & 0xFFFFFFFFFFFFFF8;
    }

    v8 = a2;

    v9 = sub_1B5AD67E4();

    if (v9)
    {

      type metadata accessor for _EARExtractedEntity();
      swift_dynamicCast();
      result = 0;
      *a1 = v22;
      return result;
    }

    result = sub_1B5AD67D4();
    if (__OFADD__(result, 1))
    {
      __break(1u);
      return result;
    }

    v19 = sub_1B5A93A64(v7, result + 1);
    if (*(v19 + 24) <= *(v19 + 16))
    {
      sub_1B5A93C40();
    }

    v18 = v8;
    sub_1B5A940C8(v18, v19);

    *v3 = v19;
    goto LABEL_16;
  }

  type metadata accessor for _EARExtractedEntity();
  v11 = sub_1B5AD6724();
  v12 = -1 << *(v6 + 32);
  v13 = v11 & ~v12;
  if (((*(v6 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13) & 1) == 0)
  {
LABEL_11:
    isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    v23 = *v3;
    v18 = a2;
    sub_1B5A9414C(v18, v13, isUniquelyReferenced_nonNull_native);
    *v3 = v23;
LABEL_16:
    *a1 = v18;
    return 1;
  }

  v14 = ~v12;
  while (1)
  {
    v15 = *(*(v6 + 48) + 8 * v13);
    v16 = sub_1B5AD6734();

    if (v16)
    {
      break;
    }

    v13 = (v13 + 1) & v14;
    if (((*(v6 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13) & 1) == 0)
    {
      goto LABEL_11;
    }
  }

  v20 = *(*(v6 + 48) + 8 * v13);
  *a1 = v20;
  v21 = v20;
  return 0;
}

uint64_t sub_1B5A93914(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v7 = *v3;
  sub_1B5AD6894();
  sub_1B5AD6684();
  v8 = sub_1B5AD68A4();
  v9 = -1 << *(v7 + 32);
  v10 = v8 & ~v9;
  if ((*(v7 + 56 + ((v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10))
  {
    v11 = ~v9;
    while (1)
    {
      v12 = (*(v7 + 48) + 16 * v10);
      v13 = *v12 == a2 && v12[1] == a3;
      if (v13 || (sub_1B5AD6874() & 1) != 0)
      {
        break;
      }

      v10 = (v10 + 1) & v11;
      if (((*(v7 + 56 + ((v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10) & 1) == 0)
      {
        goto LABEL_9;
      }
    }

    v16 = (*(v7 + 48) + 16 * v10);
    v17 = v16[1];
    *a1 = *v16;
    a1[1] = v17;

    return 0;
  }

  else
  {
LABEL_9:
    isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    v18 = *v3;

    sub_1B5A942A8(a2, a3, v10, isUniquelyReferenced_nonNull_native);
    *v3 = v18;
    *a1 = a2;
    a1[1] = a3;
    return 1;
  }
}

uint64_t sub_1B5A93A64(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909558);
    v2 = sub_1B5AD6844();
    v14 = v2;
    sub_1B5AD6794();
    if (sub_1B5AD6804())
    {
      type metadata accessor for _EARExtractedEntity();
      do
      {
        swift_dynamicCast();
        if (*(v2 + 24) <= *(v2 + 16))
        {
          sub_1B5A93C40();
        }

        v2 = v14;
        result = sub_1B5AD6724();
        v4 = v14 + 56;
        v5 = -1 << *(v14 + 32);
        v6 = result & ~v5;
        v7 = v6 >> 6;
        if (((-1 << v6) & ~*(v14 + 56 + 8 * (v6 >> 6))) != 0)
        {
          v8 = __clz(__rbit64((-1 << v6) & ~*(v14 + 56 + 8 * (v6 >> 6)))) | v6 & 0x7FFFFFFFFFFFFFC0;
        }

        else
        {
          v9 = 0;
          v10 = (63 - v5) >> 6;
          do
          {
            if (++v7 == v10 && (v9 & 1) != 0)
            {
              __break(1u);
              return result;
            }

            v11 = v7 == v10;
            if (v7 == v10)
            {
              v7 = 0;
            }

            v9 |= v11;
            v12 = *(v4 + 8 * v7);
          }

          while (v12 == -1);
          v8 = __clz(__rbit64(~v12)) + (v7 << 6);
        }

        *(v4 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v8;
        *(*(v14 + 48) + 8 * v8) = v13;
        ++*(v14 + 16);
      }

      while (sub_1B5AD6804());
    }
  }

  else
  {
    swift_unknownObjectRelease();
    return MEMORY[0x1E69E7CD0];
  }

  return v2;
}

uint64_t sub_1B5A93C40()
{
  v1 = v0;
  v2 = *v0;
  __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909558);
  result = sub_1B5AD6834();
  v4 = result;
  if (*(v2 + 16))
  {
    v5 = 0;
    v6 = (v2 + 56);
    v7 = 1 << *(v2 + 32);
    if (v7 < 64)
    {
      v8 = ~(-1 << v7);
    }

    else
    {
      v8 = -1;
    }

    v9 = v8 & *(v2 + 56);
    v10 = (v7 + 63) >> 6;
    v11 = result + 56;
    while (v9)
    {
      v13 = __clz(__rbit64(v9));
      v9 &= v9 - 1;
LABEL_15:
      v16 = *(*(v2 + 48) + 8 * (v13 | (v5 << 6)));
      result = sub_1B5AD6724();
      v17 = -1 << *(v4 + 32);
      v18 = result & ~v17;
      v19 = v18 >> 6;
      if (((-1 << v18) & ~*(v11 + 8 * (v18 >> 6))) == 0)
      {
        v20 = 0;
        v21 = (63 - v17) >> 6;
        while (++v19 != v21 || (v20 & 1) == 0)
        {
          v22 = v19 == v21;
          if (v19 == v21)
          {
            v19 = 0;
          }

          v20 |= v22;
          v23 = *(v11 + 8 * v19);
          if (v23 != -1)
          {
            v12 = __clz(__rbit64(~v23)) + (v19 << 6);
            goto LABEL_7;
          }
        }

LABEL_30:
        __break(1u);
        return result;
      }

      v12 = __clz(__rbit64((-1 << v18) & ~*(v11 + 8 * (v18 >> 6)))) | v18 & 0x7FFFFFFFFFFFFFC0;
LABEL_7:
      *(v11 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v12;
      *(*(v4 + 48) + 8 * v12) = v16;
      ++*(v4 + 16);
    }

    v14 = v5;
    while (1)
    {
      v5 = v14 + 1;
      if (__OFADD__(v14, 1))
      {
        __break(1u);
        goto LABEL_30;
      }

      if (v5 >= v10)
      {
        break;
      }

      v15 = v6[v5];
      ++v14;
      if (v15)
      {
        v13 = __clz(__rbit64(v15));
        v9 = (v15 - 1) & v15;
        goto LABEL_15;
      }
    }

    v24 = 1 << *(v2 + 32);
    if (v24 >= 64)
    {
      bzero((v2 + 56), ((v24 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
    }

    else
    {
      *v6 = -1 << v24;
    }

    *(v2 + 16) = 0;
  }

  *v1 = v4;
  return result;
}

uint64_t sub_1B5A93E68()
{
  v1 = v0;
  v2 = *v0;
  __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909540);
  result = sub_1B5AD6834();
  v4 = result;
  if (*(v2 + 16))
  {
    v5 = 0;
    v6 = (v2 + 56);
    v7 = 1 << *(v2 + 32);
    if (v7 < 64)
    {
      v8 = ~(-1 << v7);
    }

    else
    {
      v8 = -1;
    }

    v9 = v8 & *(v2 + 56);
    v10 = (v7 + 63) >> 6;
    v11 = result + 56;
    while (v9)
    {
      v14 = __clz(__rbit64(v9));
      v9 &= v9 - 1;
LABEL_15:
      v17 = (*(v2 + 48) + 16 * (v14 | (v5 << 6)));
      v18 = *v17;
      v19 = v17[1];
      sub_1B5AD6894();
      sub_1B5AD6684();
      result = sub_1B5AD68A4();
      v20 = -1 << *(v4 + 32);
      v21 = result & ~v20;
      v22 = v21 >> 6;
      if (((-1 << v21) & ~*(v11 + 8 * (v21 >> 6))) == 0)
      {
        v23 = 0;
        v24 = (63 - v20) >> 6;
        while (++v22 != v24 || (v23 & 1) == 0)
        {
          v25 = v22 == v24;
          if (v22 == v24)
          {
            v22 = 0;
          }

          v23 |= v25;
          v26 = *(v11 + 8 * v22);
          if (v26 != -1)
          {
            v12 = __clz(__rbit64(~v26)) + (v22 << 6);
            goto LABEL_7;
          }
        }

LABEL_30:
        __break(1u);
        return result;
      }

      v12 = __clz(__rbit64((-1 << v21) & ~*(v11 + 8 * (v21 >> 6)))) | v21 & 0x7FFFFFFFFFFFFFC0;
LABEL_7:
      *(v11 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v12;
      v13 = (*(v4 + 48) + 16 * v12);
      *v13 = v18;
      v13[1] = v19;
      ++*(v4 + 16);
    }

    v15 = v5;
    while (1)
    {
      v5 = v15 + 1;
      if (__OFADD__(v15, 1))
      {
        __break(1u);
        goto LABEL_30;
      }

      if (v5 >= v10)
      {
        break;
      }

      v16 = v6[v5];
      ++v15;
      if (v16)
      {
        v14 = __clz(__rbit64(v16));
        v9 = (v16 - 1) & v16;
        goto LABEL_15;
      }
    }

    v27 = 1 << *(v2 + 32);
    if (v27 >= 64)
    {
      bzero((v2 + 56), ((v27 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
    }

    else
    {
      *v6 = -1 << v27;
    }

    v1 = v0;
    *(v2 + 16) = 0;
  }

  *v1 = v4;
  return result;
}

unint64_t sub_1B5A940C8(uint64_t a1, uint64_t a2)
{
  sub_1B5AD6724();
  result = sub_1B5AD6774();
  *(a2 + 56 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << result;
  *(*(a2 + 48) + 8 * result) = a1;
  ++*(a2 + 16);
  return result;
}

void sub_1B5A9414C(uint64_t a1, unint64_t a2, char a3)
{
  v6 = *(*v3 + 16);
  v7 = *(*v3 + 24);
  if (v7 > v6 && (a3 & 1) != 0)
  {
    goto LABEL_12;
  }

  if (a3)
  {
    sub_1B5A93C40();
  }

  else
  {
    if (v7 > v6)
    {
      sub_1B5A94428();
      goto LABEL_12;
    }

    sub_1B5A946D4();
  }

  v8 = *v3;
  v9 = sub_1B5AD6724();
  v10 = -1 << *(v8 + 32);
  a2 = v9 & ~v10;
  if ((*(v8 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
  {
    v11 = ~v10;
    type metadata accessor for _EARExtractedEntity();
    do
    {
      v12 = *(*(v8 + 48) + 8 * a2);
      v13 = sub_1B5AD6734();

      if (v13)
      {
        goto LABEL_15;
      }

      a2 = (a2 + 1) & v11;
    }

    while (((*(v8 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) != 0);
  }

LABEL_12:
  v14 = *v3;
  *(*v3 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  *(*(v14 + 48) + 8 * a2) = a1;
  v15 = *(v14 + 16);
  v16 = __OFADD__(v15, 1);
  v17 = v15 + 1;
  if (!v16)
  {
    *(v14 + 16) = v17;
    return;
  }

  __break(1u);
LABEL_15:
  sub_1B5AD6884();
  __break(1u);
}

uint64_t sub_1B5A942A8(uint64_t result, uint64_t a2, unint64_t a3, char a4)
{
  v7 = result;
  v8 = *(*v4 + 16);
  v9 = *(*v4 + 24);
  if (v9 > v8 && (a4 & 1) != 0)
  {
    goto LABEL_16;
  }

  if (a4)
  {
    sub_1B5A93E68();
  }

  else
  {
    if (v9 > v8)
    {
      result = sub_1B5A94578();
      goto LABEL_16;
    }

    sub_1B5A948E8();
  }

  v10 = *v4;
  sub_1B5AD6894();
  sub_1B5AD6684();
  result = sub_1B5AD68A4();
  v11 = -1 << *(v10 + 32);
  a3 = result & ~v11;
  if ((*(v10 + 56 + ((a3 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a3))
  {
    v12 = ~v11;
    do
    {
      v13 = (*(v10 + 48) + 16 * a3);
      if (*v13 == v7 && v13[1] == a2)
      {
        goto LABEL_19;
      }

      result = sub_1B5AD6874();
      if (result)
      {
        goto LABEL_19;
      }

      a3 = (a3 + 1) & v12;
    }

    while (((*(v10 + 56 + ((a3 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a3) & 1) != 0);
  }

LABEL_16:
  v15 = *v4;
  *(*v4 + 8 * (a3 >> 6) + 56) |= 1 << a3;
  v16 = (*(v15 + 48) + 16 * a3);
  *v16 = v7;
  v16[1] = a2;
  v17 = *(v15 + 16);
  v18 = __OFADD__(v17, 1);
  v19 = v17 + 1;
  if (!v18)
  {
    *(v15 + 16) = v19;
    return result;
  }

  __break(1u);
LABEL_19:
  result = sub_1B5AD6884();
  __break(1u);
  return result;
}

id sub_1B5A94428()
{
  v1 = v0;
  __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909558);
  v2 = *v0;
  v3 = sub_1B5AD6824();
  v4 = v3;
  if (*(v2 + 16))
  {
    result = (v3 + 56);
    v6 = ((1 << *(v4 + 32)) + 63) >> 6;
    if (v4 != v2 || result >= v2 + 56 + 8 * v6)
    {
      result = memmove(result, (v2 + 56), 8 * v6);
    }

    v8 = 0;
    *(v4 + 16) = *(v2 + 16);
    v9 = 1 << *(v2 + 32);
    v10 = *(v2 + 56);
    v11 = -1;
    if (v9 < 64)
    {
      v11 = ~(-1 << v9);
    }

    v12 = v11 & v10;
    v13 = (v9 + 63) >> 6;
    if ((v11 & v10) != 0)
    {
      do
      {
        v14 = __clz(__rbit64(v12));
        v12 &= v12 - 1;
LABEL_17:
        v17 = v14 | (v8 << 6);
        v18 = *(*(v2 + 48) + 8 * v17);
        *(*(v4 + 48) + 8 * v17) = v18;
        result = v18;
      }

      while (v12);
    }

    v15 = v8;
    while (1)
    {
      v8 = v15 + 1;
      if (__OFADD__(v15, 1))
      {
        break;
      }

      if (v8 >= v13)
      {
        goto LABEL_19;
      }

      v16 = *(v2 + 56 + 8 * v8);
      ++v15;
      if (v16)
      {
        v14 = __clz(__rbit64(v16));
        v12 = (v16 - 1) & v16;
        goto LABEL_17;
      }
    }

    __break(1u);
  }

  else
  {
LABEL_19:

    *v1 = v4;
  }

  return result;
}

void *sub_1B5A94578()
{
  v1 = v0;
  __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909540);
  v2 = *v0;
  v3 = sub_1B5AD6824();
  v4 = v3;
  if (*(v2 + 16))
  {
    result = (v3 + 56);
    v6 = ((1 << *(v4 + 32)) + 63) >> 6;
    if (v4 != v2 || result >= v2 + 56 + 8 * v6)
    {
      result = memmove(result, (v2 + 56), 8 * v6);
    }

    v8 = 0;
    *(v4 + 16) = *(v2 + 16);
    v9 = 1 << *(v2 + 32);
    v10 = *(v2 + 56);
    v11 = -1;
    if (v9 < 64)
    {
      v11 = ~(-1 << v9);
    }

    v12 = v11 & v10;
    v13 = (v9 + 63) >> 6;
    if ((v11 & v10) != 0)
    {
      do
      {
        v14 = __clz(__rbit64(v12));
        v12 &= v12 - 1;
LABEL_17:
        v17 = 16 * (v14 | (v8 << 6));
        v18 = (*(v2 + 48) + v17);
        v19 = v18[1];
        v20 = (*(v4 + 48) + v17);
        *v20 = *v18;
        v20[1] = v19;
      }

      while (v12);
    }

    v15 = v8;
    while (1)
    {
      v8 = v15 + 1;
      if (__OFADD__(v15, 1))
      {
        break;
      }

      if (v8 >= v13)
      {
        goto LABEL_19;
      }

      v16 = *(v2 + 56 + 8 * v8);
      ++v15;
      if (v16)
      {
        v14 = __clz(__rbit64(v16));
        v12 = (v16 - 1) & v16;
        goto LABEL_17;
      }
    }

    __break(1u);
  }

  else
  {
LABEL_19:

    *v1 = v4;
  }

  return result;
}

uint64_t sub_1B5A946D4()
{
  v1 = v0;
  v2 = *v0;
  __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909558);
  result = sub_1B5AD6834();
  v4 = result;
  if (*(v2 + 16))
  {
    v23 = v0;
    v5 = 0;
    v6 = 1 << *(v2 + 32);
    if (v6 < 64)
    {
      v7 = ~(-1 << v6);
    }

    else
    {
      v7 = -1;
    }

    v8 = v7 & *(v2 + 56);
    v9 = (v6 + 63) >> 6;
    v10 = result + 56;
    while (v8)
    {
      v12 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
LABEL_15:
      v15 = *(*(v2 + 48) + 8 * (v12 | (v5 << 6)));
      result = sub_1B5AD6724();
      v16 = -1 << *(v4 + 32);
      v17 = result & ~v16;
      v18 = v17 >> 6;
      if (((-1 << v17) & ~*(v10 + 8 * (v17 >> 6))) == 0)
      {
        v19 = 0;
        v20 = (63 - v16) >> 6;
        while (++v18 != v20 || (v19 & 1) == 0)
        {
          v21 = v18 == v20;
          if (v18 == v20)
          {
            v18 = 0;
          }

          v19 |= v21;
          v22 = *(v10 + 8 * v18);
          if (v22 != -1)
          {
            v11 = __clz(__rbit64(~v22)) + (v18 << 6);
            goto LABEL_7;
          }
        }

        goto LABEL_28;
      }

      v11 = __clz(__rbit64((-1 << v17) & ~*(v10 + 8 * (v17 >> 6)))) | v17 & 0x7FFFFFFFFFFFFFC0;
LABEL_7:
      *(v10 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v11;
      *(*(v4 + 48) + 8 * v11) = v15;
      ++*(v4 + 16);
    }

    v13 = v5;
    while (1)
    {
      v5 = v13 + 1;
      if (__OFADD__(v13, 1))
      {
        break;
      }

      if (v5 >= v9)
      {

        v1 = v23;
        goto LABEL_26;
      }

      v14 = *(v2 + 56 + 8 * v5);
      ++v13;
      if (v14)
      {
        v12 = __clz(__rbit64(v14));
        v8 = (v14 - 1) & v14;
        goto LABEL_15;
      }
    }

    __break(1u);
LABEL_28:
    __break(1u);
  }

  else
  {

LABEL_26:
    *v1 = v4;
  }

  return result;
}

uint64_t sub_1B5A948E8()
{
  v1 = v0;
  v2 = *v0;
  __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909540);
  result = sub_1B5AD6834();
  v4 = result;
  if (*(v2 + 16))
  {
    v5 = 0;
    v6 = 1 << *(v2 + 32);
    if (v6 < 64)
    {
      v7 = ~(-1 << v6);
    }

    else
    {
      v7 = -1;
    }

    v8 = v7 & *(v2 + 56);
    v9 = (v6 + 63) >> 6;
    v10 = result + 56;
    while (v8)
    {
      v13 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
LABEL_15:
      v16 = (*(v2 + 48) + 16 * (v13 | (v5 << 6)));
      v17 = *v16;
      v18 = v16[1];
      sub_1B5AD6894();

      sub_1B5AD6684();
      result = sub_1B5AD68A4();
      v19 = -1 << *(v4 + 32);
      v20 = result & ~v19;
      v21 = v20 >> 6;
      if (((-1 << v20) & ~*(v10 + 8 * (v20 >> 6))) == 0)
      {
        v22 = 0;
        v23 = (63 - v19) >> 6;
        while (++v21 != v23 || (v22 & 1) == 0)
        {
          v24 = v21 == v23;
          if (v21 == v23)
          {
            v21 = 0;
          }

          v22 |= v24;
          v25 = *(v10 + 8 * v21);
          if (v25 != -1)
          {
            v11 = __clz(__rbit64(~v25)) + (v21 << 6);
            goto LABEL_7;
          }
        }

        goto LABEL_28;
      }

      v11 = __clz(__rbit64((-1 << v20) & ~*(v10 + 8 * (v20 >> 6)))) | v20 & 0x7FFFFFFFFFFFFFC0;
LABEL_7:
      *(v10 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v11;
      v12 = (*(v4 + 48) + 16 * v11);
      *v12 = v17;
      v12[1] = v18;
      ++*(v4 + 16);
    }

    v14 = v5;
    while (1)
    {
      v5 = v14 + 1;
      if (__OFADD__(v14, 1))
      {
        break;
      }

      if (v5 >= v9)
      {

        v1 = v0;
        goto LABEL_26;
      }

      v15 = *(v2 + 56 + 8 * v5);
      ++v14;
      if (v15)
      {
        v13 = __clz(__rbit64(v15));
        v8 = (v15 - 1) & v15;
        goto LABEL_15;
      }
    }

    __break(1u);
LABEL_28:
    __break(1u);
  }

  else
  {

LABEL_26:
    *v1 = v4;
  }

  return result;
}

char *sub_1B5A94B20(char *a1, int64_t a2, char a3)
{
  result = sub_1B5A94B40(a1, a2, a3, *v3);
  *v3 = result;
  return result;
}

char *sub_1B5A94B40(char *result, int64_t a2, char a3, char *a4)
{
  v5 = result;
  if (a3)
  {
    v6 = *(a4 + 3);
    v7 = v6 >> 1;
    if ((v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }

      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      {
        v7 = a2;
      }
    }
  }

  else
  {
    v7 = a2;
  }

  v8 = *(a4 + 2);
  if (v7 <= v8)
  {
    v9 = *(a4 + 2);
  }

  else
  {
    v9 = v7;
  }

  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB909550);
    v10 = swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    v12 = v11 - 32;
    if (v11 < 32)
    {
      v12 = v11 - 17;
    }

    *(v10 + 2) = v8;
    *(v10 + 3) = 2 * (v12 >> 4);
  }

  else
  {
    v10 = MEMORY[0x1E69E7CC0];
  }

  v13 = v10 + 32;
  v14 = a4 + 32;
  if (v5)
  {
    if (v10 != a4 || v13 >= &v14[16 * v8])
    {
      memmove(v13, v14, 16 * v8);
    }

    *(a4 + 2) = 0;
  }

  else
  {
    swift_arrayInitWithCopy();
  }

  return v10;
}

uint64_t sub_1B5A94C4C()
{
  v0 = sub_1B5AD6664();
  v2 = v1;
  if (v0 == sub_1B5AD6664() && v2 == v3)
  {
    v5 = 1;
  }

  else
  {
    v5 = sub_1B5AD6874();
  }

  return v5 & 1;
}

void sub_1B5A94CDC(unint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  v6 = a1;
  if ((a4 & 0xC000000000000001) != 0)
  {
    if (a3)
    {
      if (a4 < 0)
      {
        v7 = a4;
      }

      else
      {
        v7 = a4 & 0xFFFFFFFFFFFFFF8;
      }

      MEMORY[0x1B8C83DD0](a1, a2, v7);
      type metadata accessor for _EARExtractedEntity();
      swift_dynamicCast();
      return;
    }

LABEL_26:
    __break(1u);
    return;
  }

  if (a3)
  {
    type metadata accessor for _EARExtractedEntity();
    if (sub_1B5AD67B4() != *(a4 + 36))
    {
      __break(1u);
LABEL_24:
      __break(1u);
      goto LABEL_25;
    }

    sub_1B5AD67C4();
    swift_dynamicCast();
    v4 = v15;
    v8 = sub_1B5AD6724();
    v9 = -1 << *(a4 + 32);
    v6 = v8 & ~v9;
    if ((*(a4 + 56 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6))
    {
      v10 = ~v9;
      do
      {
        v11 = *(*(a4 + 48) + 8 * v6);
        v12 = sub_1B5AD6734();

        if (v12)
        {
          goto LABEL_19;
        }

        v6 = (v6 + 1) & v10;
      }

      while (((*(a4 + 56 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }

    __break(1u);
  }

  if ((v6 & 0x8000000000000000) != 0 || 1 << *(a4 + 32) <= v6)
  {
    goto LABEL_24;
  }

  if (((*(a4 + 8 * (v6 >> 6) + 56) >> v6) & 1) == 0)
  {
LABEL_25:
    __break(1u);
    goto LABEL_26;
  }

  if (*(a4 + 36) != a2)
  {
    __break(1u);
LABEL_19:
  }

  v13 = *(*(a4 + 48) + 8 * v6);

  v14 = v13;
}

uint64_t sub_1B5A94ED4(uint64_t a1)
{
  v2 = *(a1 + 16);
  result = MEMORY[0x1B8C83CD0](v2, MEMORY[0x1E69E6158], MEMORY[0x1E69E6168]);
  v8 = result;
  if (v2)
  {
    v4 = (a1 + 40);
    do
    {
      v6 = *(v4 - 1);
      v5 = *v4;

      sub_1B5A93914(&v7, v6, v5);

      v4 += 2;
      --v2;
    }

    while (v2);
    return v8;
  }

  return result;
}

uint64_t sub_1B5A94FB4(uint64_t a1, uint64_t a2)
{
  v4 = __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB9094B8);
  (*(*(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_1B5A95024(uint64_t a1)
{
  v2 = __swift_instantiateConcreteTypeFromMangledNameV2(&qword_1EB9094B8);
  (*(*(v2 - 8) + 8))(a1, v2);
  return a1;
}

void sub_1B5A950F8(uint64_t a1, unint64_t *a2)
{
  if (!*a2)
  {
    ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v4)
    {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }
}

uint64_t sub_1B5A951DC(unint64_t *a1, uint64_t a2, void (*a3)(uint64_t))
{
  result = *a1;
  if (!result)
  {
    a3(a2);
    result = swift_getWitnessTable();
    atomic_store(result, a1);
  }

  return result;
}

uint64_t sub_1B5A95484(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (!v1)
  {
    return 0;
  }

  result = 0;
  v4 = (a1 + 32);
  do
  {
    v6 = *v4++;
    v5 = v6;
    if ((v6 & ~result) == 0)
    {
      v5 = 0;
    }

    result |= v5;
    --v1;
  }

  while (v1);
  return result;
}

uint64_t sub_1B5A954BC(uint64_t a1, uint64_t a2, char a3)
{
  if (a3)
  {
  }

  return result;
}

uint64_t marisa::Agent::set_query(uint64_t this, uint64_t a2)
{
  v2 = *(this + 40);
  if (v2)
  {
    *(v2 + 108) = 0;
  }

  *(this + 16) = a2;
  return this;
}

void marisa::Exception::~Exception(std::exception *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x1B8C85350);
}

void marisa::grimoire::vector::BitVector::~BitVector(marisa::grimoire::vector::BitVector *this)
{
  v2 = *(this + 20);
  if (v2)
  {
    MEMORY[0x1B8C85310](v2, 0x1000C8077774924);
  }

  v3 = *(this + 14);
  if (v3)
  {
    MEMORY[0x1B8C85310](v3, 0x1000C8077774924);
  }

  v4 = *(this + 8);
  if (v4)
  {
    MEMORY[0x1B8C85310](v4, 0x1000C8077774924);
  }

  if (*this)
  {
    MEMORY[0x1B8C85310](*this, 0x1000C8077774924);
  }
}

void marisa::grimoire::trie::LoudsTrie::build(marisa::grimoire::trie::LoudsTrie *this, marisa::Keyset *a2, unsigned int a3)
{
  v5 = 3;
  v6 = 0x100000000200;
  v7 = 0x20000;
  marisa::grimoire::trie::Config::parse_(&v5, a3);
  v8[0] = v5;
  v8[1] = v6;
  v9 = v7;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(&v5);
  marisa::grimoire::trie::LoudsTrie::build_(&v5, a2, v8);
  marisa::grimoire::trie::LoudsTrie::swap(this, &v5);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie(&v5);
}

void sub_1B5A95688(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie(va);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_(marisa::grimoire::trie::LoudsTrie *this, marisa::Keyset *a2, const marisa::grimoire::trie::Config *a3)
{
  memset(v30, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::resize(v30, *(a2 + 11));
  if (*(a2 + 11))
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = *(&v30[0] + 1) + v6;
      v9 = *(*(a2 + 6) + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v7;
      v10 = *(v9 + 8);
      *v8 = *v9;
      *(v8 + 8) = v10;
      *(v8 + 12) = *(v9 + 12);
      ++v7;
      v6 += 24;
    }

    while (v7 < *(a2 + 11));
  }

  v28 = 0u;
  memset(v29, 0, 25);
  marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::Key>(this, v30, &v28, a3, 1);
  memset(v27, 0, 41);
  marisa::grimoire::vector::Vector<std::pair<unsigned int,unsigned int>>::resize(v27, v29[1]);
  v11 = *(&v27[1] + 1);
  if (*(&v27[1] + 1))
  {
    v12 = 0;
    v13 = *(&v28 + 1);
    v14 = (*(&v27[0] + 1) + 4);
    do
    {
      *(v14 - 1) = *(v13 + 4 * v12);
      *v14 = v12++;
      v14 += 2;
    }

    while (v11 != v12);
  }

  v15 = v28;
  v28 = 0u;
  memset(v29, 0, 25);
  if (v15)
  {
    MEMORY[0x1B8C85310](v15, 0x1000C8077774924);
    v11 = *(&v27[1] + 1);
  }

  v16 = 126 - 2 * __clz(v11);
  if (v11)
  {
    v17 = v16;
  }

  else
  {
    v17 = 0;
  }

  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>(*(&v27[0] + 1), (*(&v27[0] + 1) + 8 * v11), &v31, v17, 1);
  if (*(&v27[1] + 1))
  {
    v18 = 0;
    v19 = 0;
    do
    {
      for (i = *(&v27[0] + 1); ; i = *(&v27[0] + 1))
      {
        v21 = *(i + 8 * v18);
        if (v19 >= v21)
        {
          break;
        }

        marisa::grimoire::vector::BitVector::push_back(this + 26, 0);
        ++v19;
      }

      if (v19 == v21)
      {
        marisa::grimoire::vector::BitVector::push_back(this + 26, 1);
        ++v19;
      }

      ++v18;
    }

    while (v18 < *(&v27[1] + 1));
  }

  else
  {
    v19 = 0;
  }

  while (v19 < *(this + 81))
  {
    marisa::grimoire::vector::BitVector::push_back(this + 26, 0);
    ++v19;
  }

  marisa::grimoire::vector::BitVector::push_back(this + 26, 0);
  marisa::grimoire::vector::BitVector::build((this + 208), 0, 1);
  if (*(a2 + 11))
  {
    v22 = 0;
    v23 = 0;
    do
    {
      v24 = *(*(&v27[0] + 1) + v22 + 4);
      v25 = *(*(a2 + 6) + ((v24 >> 5) & 0x7FFFFF8));
      *(v25 + 16 * v24 + 12) = marisa::grimoire::vector::BitVector::rank1((this + 208), *(*(&v27[0] + 1) + v22));
      ++v23;
      v22 += 8;
    }

    while (v23 < *(a2 + 11));
  }

  if (*&v27[0])
  {
    MEMORY[0x1B8C85310](*&v27[0], 0x1000C8077774924);
  }

  if (v28)
  {
    MEMORY[0x1B8C85310](v28, 0x1000C8077774924);
  }

  result = *&v30[0];
  if (*&v30[0])
  {
    return MEMORY[0x1B8C85310](*&v30[0], 0x1000C8077774924);
  }

  return result;
}

void sub_1B5A95940(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
  if (a15)
  {
    MEMORY[0x1B8C85310](a15, v21);
  }

  if (a21)
  {
    MEMORY[0x1B8C85310](a21, v21);
  }

  _Unwind_Resume(exception_object);
}

unint64_t marisa::grimoire::trie::LoudsTrie::reverse_lookup(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  v3 = *(a2 + 2);
  if (v3 >= *(this + 33))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x300000049;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:73: MARISA_BOUND_ERROR: agent.query().id() >= size()";
  }

  v5 = *(a2 + 5);
  *(v5 + 24) = 0;
  v6 = *(v5 + 32);
  if (v6 <= 0x1F)
  {
    if (v6 <= 0x10)
    {
      v7 = 32;
    }

    else
    {
      v7 = 2 * v6;
    }

    marisa::grimoire::vector::Vector<char>::realloc(v5, v7);
    v3 = *(a2 + 2);
  }

  *(v5 + 108) = 0;
  result = marisa::grimoire::vector::BitVector::select1((this + 208), v3);
  *(v5 + 96) = result;
  if (!result)
  {
    goto LABEL_31;
  }

  while (1)
  {
    if ((*(*(this + 54) + ((result >> 3) & 0x1FFFFFF8)) >> result))
    {
      v9 = *(v5 + 24);
      v10 = *(*(this + 80) + result);
      v11 = marisa::grimoire::vector::BitVector::rank1((this + 416), result);
      v12 = *(this + 90);
      v13 = v12 * v11;
      v14 = (v12 * v11) & 0x3F;
      v15 = v14 + v12;
      v16 = (*(this + 86) + 8 * ((v12 * v11) >> 6));
      v17 = *v16;
      if (v15 > 0x40)
      {
        v18 = ((2 * v16[1]) << ~v13) | (v17 >> v13);
      }

      else
      {
        v18 = v17 >> v14;
      }

      v19 = v10 | ((*(this + 182) & v18) << 8);
      v20 = *(this + 125);
      if (v20)
      {
        result = marisa::grimoire::trie::LoudsTrie::restore_(v20, a2, v19);
      }

      else
      {
        result = marisa::grimoire::trie::Tail::restore(this + 93, a2, v19);
      }

      v21 = *(v5 + 24);
      if (v9 != v21)
      {
        v22 = *(v5 + 8);
        v23 = (v22 + v21 - 1);
        if (v23 > v22 + v9)
        {
          v24 = v22 + v9 + 1;
          do
          {
            v25 = *(v24 - 1);
            *(v24 - 1) = *v23;
            *v23-- = v25;
            v26 = v24++ >= v23;
          }

          while (!v26);
        }
      }
    }

    else
    {
      v36 = *(*(this + 80) + result);
      result = marisa::grimoire::vector::Vector<char>::push_back(v5, &v36);
    }

    v27 = *(v5 + 96);
    if (*(this + 133) >= v27)
    {
      break;
    }

    result = marisa::grimoire::vector::BitVector::select1(this, v27) + ~*(v5 + 96);
    *(v5 + 96) = result;
  }

  v28 = *(v5 + 8);
  v29 = *(v5 + 24);
  v30 = (v28 + v29 - 1);
  if (v29)
  {
    v31 = v30 > v28;
  }

  else
  {
    v31 = 0;
  }

  if (v31)
  {
    v32 = v28 + 1;
    do
    {
      v33 = *(v32 - 1);
      *(v32 - 1) = *v30;
      *v30-- = v33;
      v26 = v32++ >= v30;
    }

    while (!v26);
LABEL_31:
    v28 = *(v5 + 8);
    v29 = *(v5 + 24);
  }

  *(a2 + 3) = v28;
  v34 = *(a2 + 2);
  *(a2 + 8) = v29;
  *(a2 + 9) = v34;
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<char>::push_back(uint64_t *result, _BYTE *a2)
{
  v3 = result;
  v4 = result[3];
  v5 = result[4];
  v6 = v4 + 1;
  if (v5 < (v4 + 1))
  {
    v7 = 2 * v5;
    if (v5 < 0)
    {
      v7 = -1;
    }

    if (v5 <= v6 >> 1)
    {
      v8 = v6;
    }

    else
    {
      v8 = v7;
    }

    result = marisa::grimoire::vector::Vector<char>::realloc(result, v8);
    v4 = v3[3];
  }

  *(v3[1] + v4) = *a2;
  ++v3[3];
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::common_prefix_search(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  v4 = *(a2 + 5);
  v5 = v4[27];
  if (v5 == 1)
  {
LABEL_5:
    while (*(a2 + 1) > v4[25] && (marisa::grimoire::trie::LoudsTrie::find_child(this, a2) & 1) != 0)
    {
      v7 = v4[24];
      if ((*(*(this + 28) + ((v7 >> 3) & 0x1FFFFFF8)) >> v7))
      {
        v8 = v4[25];
        *(a2 + 3) = *a2;
        *(a2 + 8) = v8;
        v9 = (this + 208);
        goto LABEL_11;
      }
    }

    result = 0;
    v4[27] = 3;
  }

  else if (v5 == 3)
  {
    return 0;
  }

  else
  {
    *(v4 + 12) = 0;
    v4[27] = 1;
    if ((**(this + 28) & 1) == 0)
    {
      goto LABEL_5;
    }

    *(a2 + 3) = *a2;
    *(a2 + 8) = 0;
    v9 = (this + 208);
    v7 = 0;
LABEL_11:
    *(a2 + 9) = marisa::grimoire::vector::BitVector::rank1(v9, v7);
    return 1;
  }

  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::predictive_search(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  v4 = *(a2 + 5);
  v5 = *(v4 + 108);
  if (v5 == 2)
  {
    do
    {
      while (1)
      {
LABEL_10:
        v10 = *(v4 + 104);
        if (*(v4 + 72) == v10)
        {
          v11 = *(v4 + 56) + 20 * v10;
          *v30 = xmmword_1B5B34CF0;
          *&v30[16] = -1;
          v12 = marisa::grimoire::vector::BitVector::select0(this, *(v11 - 20));
          *&v30[4] = v12 + 1;
          *v30 = v12 - *(v11 - 20);
          marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::push_back((v4 + 48), v30);
          LODWORD(v10) = *(v4 + 104);
        }

        v13 = (*(v4 + 56) + 20 * v10);
        v14 = v13[1];
        v15 = *(*(this + 2) + ((v14 >> 3) & 0x1FFFFFF8));
        v13[1] = v14 + 1;
        if ((v15 >> v14))
        {
          break;
        }

        if (v10 == 1)
        {
LABEL_7:
          result = 0;
          *(v4 + 108) = 4;
          return result;
        }

        ++*(v13 - 5);
        marisa::grimoire::vector::Vector<char>::resize(v4, *(v13 - 8));
        --*(v4 + 104);
      }

      *(v4 + 104) = v10 + 1;
      v16 = *v13;
      if ((*(*(this + 54) + ((v16 >> 3) & 0x1FFFFFF8)) >> v16))
      {
        v17 = v13[3];
        if (v17 == -1)
        {
          v18 = marisa::grimoire::vector::BitVector::rank1((this + 416), v16);
          v16 = *v13;
        }

        else
        {
          v18 = v17 + 1;
        }

        v13[3] = v18;
        v19 = *(this + 90);
        v20 = v19 * v18;
        v21 = (v20 & 0x3F) + v19;
        v22 = (*(this + 86) + 8 * (v20 >> 6));
        v23 = *v22;
        if (v21 > 0x40)
        {
          v24 = ((2 * v22[1]) << ~v20) | (v23 >> v20);
        }

        else
        {
          v24 = v23 >> (v20 & 0x3F);
        }

        v25 = *(*(this + 80) + v16) | ((*(this + 182) & v24) << 8);
        v26 = *(this + 125);
        if (v26)
        {
          marisa::grimoire::trie::LoudsTrie::restore_(v26, a2, v25);
        }

        else
        {
          marisa::grimoire::trie::Tail::restore(this + 93, a2, v25);
        }
      }

      else
      {
        v30[0] = *(*(this + 80) + v16);
        marisa::grimoire::vector::Vector<char>::push_back(v4, v30);
      }

      v27 = *(v4 + 24);
      v13[2] = v27;
      v28 = *v13;
    }

    while (((*(*(this + 28) + ((v28 >> 3) & 0x1FFFFFF8)) >> v28) & 1) == 0);
    v29 = v13[4];
    if (v29 == -1)
    {
      v9 = marisa::grimoire::vector::BitVector::rank1((this + 208), v28);
      v27 = *(v4 + 24);
    }

    else
    {
      v9 = v29 + 1;
    }

    v13[4] = v9;
    *(a2 + 3) = *(v4 + 8);
    *(a2 + 8) = v27;
  }

  else
  {
    if (v5 == 4)
    {
      return 0;
    }

    marisa::grimoire::trie::State::predictive_search_init(*(a2 + 5));
    while (*(a2 + 1) > *(v4 + 100))
    {
      if ((marisa::grimoire::trie::LoudsTrie::predictive_find_child(this, a2) & 1) == 0)
      {
        goto LABEL_7;
      }
    }

    *&v30[12] = -1;
    *v30 = *(v4 + 96);
    *&v30[8] = *(v4 + 24);
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::push_back((v4 + 48), v30);
    *(v4 + 104) = 1;
    v7 = *(v4 + 96);
    if (((*(*(this + 28) + ((v7 >> 3) & 0x1FFFFFF8)) >> v7) & 1) == 0)
    {
      goto LABEL_10;
    }

    v8 = *(v4 + 24);
    *(a2 + 3) = *(v4 + 8);
    *(a2 + 8) = v8;
    v9 = marisa::grimoire::vector::BitVector::rank1((this + 208), v7);
  }

  *(a2 + 9) = v9;
  return 1;
}

double marisa::grimoire::trie::State::predictive_search_init(marisa::grimoire::trie::State *this)
{
  *(this + 3) = 0;
  v2 = *(this + 4);
  if (v2 <= 0x3F)
  {
    if (v2 <= 0x20)
    {
      v3 = 64;
    }

    else
    {
      v3 = 2 * v2;
    }

    marisa::grimoire::vector::Vector<char>::realloc(this, v3);
  }

  marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::resize(this + 6, 0);
  v4 = *(this + 10);
  if (v4 <= 3)
  {
    if (v4 == 3)
    {
      v5 = 6;
    }

    else
    {
      v5 = 4;
    }

    marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc(this + 6, v5);
  }

  result = 0.0;
  *(this + 6) = xmmword_1B5B3D2D0;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::predictive_find_child(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  v4 = *(a2 + 5);
  v5 = *(v4 + 96);
  v6 = (*(*a2 + *(v4 + 100)) ^ (32 * v5) ^ v5) & *(this + 132);
  v7 = (*(this + 128) + 12 * v6);
  if (v5 != *v7)
  {
    v9 = marisa::grimoire::vector::BitVector::select0(this, v5);
    v10 = *(this + 2);
    if ((*(v10 + (((v9 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 + 1)))
    {
      v11 = v9 - *(v4 + 96);
      *(v4 + 96) = v11;
      v12 = v9 + 2;
      v13 = 0xFFFFFFFFLL;
      while (1)
      {
        v14 = v11;
        if ((*(*(this + 54) + ((v11 >> 3) & 0x1FFFFFF8)) >> v11))
        {
          if (v13 == 0xFFFFFFFFLL)
          {
            v13 = marisa::grimoire::vector::BitVector::rank1((this + 416), v11);
            v14 = *(v4 + 96);
          }

          else
          {
            ++v13;
          }

          v15 = *(v4 + 100);
          v16 = *(this + 90);
          v17 = v16 * v13;
          v18 = (v16 * v13) & 0x3F;
          v19 = v18 + v16;
          v20 = (*(this + 86) + 8 * ((v16 * v13) >> 6));
          v21 = *v20;
          if (v19 > 0x40)
          {
            v22 = ((2 * v20[1]) << ~v17) | (v21 >> v17);
          }

          else
          {
            v22 = v21 >> v18;
          }

          v23 = *(*(this + 80) + v14) | ((*(this + 182) & v22) << 8);
          v24 = *(this + 125);
          if (v24)
          {
            if (marisa::grimoire::trie::LoudsTrie::prefix_match_(v24, a2, v23))
            {
              return 1;
            }
          }

          else if (marisa::grimoire::trie::Tail::prefix_match((this + 744), a2, v23))
          {
            return 1;
          }

          if (*(v4 + 100) != v15)
          {
            return 0;
          }

          v11 = *(v4 + 96);
          v10 = *(this + 2);
        }

        else if (*(*(this + 80) + v11) == *(*a2 + *(v4 + 100)))
        {
          v28 = *(*(this + 80) + v11);
          marisa::grimoire::vector::Vector<char>::push_back(v4, &v28);
          ++*(v4 + 100);
          return 1;
        }

        *(v4 + 96) = ++v11;
        v25 = *(v10 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v12;
        ++v12;
        if ((v25 & 1) == 0)
        {
          return 0;
        }
      }
    }

    return 0;
  }

  v8 = v7[2];
  if (v8 > 0xFFFFFEFF)
  {
    v29 = v7[2];
    marisa::grimoire::vector::Vector<char>::push_back(v4, &v29);
    ++*(v4 + 100);
    goto LABEL_25;
  }

  v26 = *(this + 125);
  if (v26)
  {
    if (marisa::grimoire::trie::LoudsTrie::prefix_match_(v26, a2, v8))
    {
      goto LABEL_25;
    }

    return 0;
  }

  if (!marisa::grimoire::trie::Tail::prefix_match((this + 744), a2, v8))
  {
    return 0;
  }

LABEL_25:
  *(v4 + 96) = *(*(this + 128) + 12 * v6 + 4);
  return 1;
}

__n128 marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::push_back(uint64_t *a1, __n128 *a2)
{
  v4 = a1[3];
  v5 = a1[4];
  v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    v7 = 2 * v5;
    if (v5 > 0x666666666666666)
    {
      v7 = 0xCCCCCCCCCCCCCCCLL;
    }

    if (v5 <= v6 >> 1)
    {
      v8 = v6;
    }

    else
    {
      v8 = v7;
    }

    marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc(a1, v8);
    v4 = a1[3];
  }

  v9 = (a1[1] + 20 * v4);
  result = *a2;
  v9[1].n128_u32[0] = a2[1].n128_u32[0];
  *v9 = result;
  ++a1[3];
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<char>::resize(uint64_t *result, size_t a2)
{
  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 < 0)
    {
      v5 = -1;
    }

    if (v4 > a2 >> 1)
    {
      a2 = v5;
    }

    result = marisa::grimoire::vector::Vector<char>::realloc(result, a2);
  }

  v3[3] = v2;
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::resize(uint64_t *result, unint64_t a2)
{
  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 > 0x555555555555555)
    {
      v5 = 0xAAAAAAAAAAAAAAALL;
    }

    if (v4 > a2 >> 1)
    {
      a2 = v5;
    }

    result = marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::realloc(result, a2);
  }

  v6 = v3[3];
  v7 = v2 - v6;
  if (v2 > v6)
  {
    v8 = 24 * v6;
    do
    {
      v9 = v3[1] + v8;
      *v9 = 0;
      *(v9 + 8) = 0;
      *(v9 + 16) = 0;
      v8 += 24;
      --v7;
    }

    while (v7);
  }

  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::Key>(a1, a2, a3, a4, a5);
  memset(v18, 0, 41);
  if (a2[3])
  {
    marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::Key>(a1, a2, v18, a4, a5);
  }

  v9 = *(a1 + 1000);
  if (v9)
  {
    v10 = v9[268] + 1;
    v11 = v9[271] | v9[272];
    v19 = 3;
    v20 = 0x100000000200;
    v21 = 0x20000;
    marisa::grimoire::trie::Config::parse_(&v19, v10 | v11);
  }

  else
  {
    if (*(a1 + 840))
    {
      v12 = 0x2000;
    }

    else
    {
      v12 = 4096;
    }

    v13 = *(a4 + 16) | *(a4 + 8) | v12;
    v19 = 3;
    v20 = 0x100000000200;
    v21 = 0x20000;
    marisa::grimoire::trie::Config::parse_(&v19, v13 | 1);
  }

  *(a1 + 1072) = v19;
  *(a1 + 1080) = v20;
  *(a1 + 1088) = v21;
  marisa::grimoire::vector::BitVector::build((a1 + 416), 0, 0);
  if (*(&v18[1] + 1))
  {
    v14 = 0;
    v15 = 0;
    do
    {
      do
      {
        v16 = *(*(a1 + 432) + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15;
        ++v15;
      }

      while ((v16 & 1) == 0);
      *(*(a1 + 632) + v15 - 1) = *(*(&v18[0] + 1) + 4 * v14);
      *(*(&v18[0] + 1) + 4 * v14++) >>= 8;
    }

    while (v14 < *(&v18[1] + 1));
  }

  marisa::grimoire::vector::FlatVector::build((a1 + 672), v18);
  marisa::grimoire::trie::LoudsTrie::fill_cache(a1);
  result = *&v18[0];
  if (*&v18[0])
  {
    return MEMORY[0x1B8C85310](*&v18[0], 0x1000C8077774924);
  }

  return result;
}

void sub_1B5A96674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
  {
    MEMORY[0x1B8C85310](a9, 0x1000C8077774924);
  }

  _Unwind_Resume(exception_object);
}

void marisa::grimoire::vector::Vector<std::pair<unsigned int,unsigned int>>::resize(uint64_t *a1, unint64_t a2)
{
  v2 = a2;
  v4 = a1[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 >> 60)
    {
      v5 = 0x1FFFFFFFFFFFFFFFLL;
    }

    if (v4 > a2 >> 1)
    {
      a2 = v5;
    }

    marisa::grimoire::vector::Vector<unsigned long long>::realloc(a1, a2);
  }

  v6 = a1[3];
  if (v2 > v6)
  {
    bzero((a1[1] + 8 * v6), 8 * (v2 - v6));
  }

  a1[3] = v2;
}

uint64_t *marisa::grimoire::vector::BitVector::push_back(uint64_t *this, int a2)
{
  v2 = this[6];
  if (v2 == 0xFFFFFFFF)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h";
    exception[2] = 0x700000034;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h:52: MARISA_SIZE_ERROR: size_ == MARISA_UINT32_MAX";
  }

  v4 = this;
  v5 = this[3];
  if (v2 == v5 << 6)
  {
    v7 = 0;
    this = marisa::grimoire::vector::Vector<unsigned long long>::resize(this, v5 + 1, &v7);
    v2 = v4[6];
  }

  if (a2)
  {
    *(v4[1] + ((v2 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v2;
    ++v4[7];
  }

  v4[6] = v2 + 1;
  return this;
}

uint64_t marisa::grimoire::vector::BitVector::build(marisa::grimoire::vector::BitVector *this, int a2, int a3)
{
  memset(v8, 0, 41);
  v11 = 0u;
  memset(v12, 0, sizeof(v12));
  v13 = 0u;
  memset(v14, 0, sizeof(v14));
  v8[3] = 0u;
  v9 = 0u;
  memset(v10, 0, sizeof(v10));
  marisa::grimoire::vector::BitVector::build_index(v8, this, a2, a3);
  marisa::grimoire::vector::Vector<unsigned long long>::shrink(this);
  v4 = v8[0];
  v8[0] = *this;
  *this = v4;
  v5 = *&v8[1];
  *&v8[1] = *(this + 2);
  *(this + 2) = v5;
  v6 = *(&v8[1] + 8);
  *(&v8[1] + 8) = *(this + 24);
  *(this + 24) = v6;
  LOBYTE(v5) = BYTE8(v8[2]);
  BYTE8(v8[2]) = *(this + 40);
  *(this + 40) = v5;
  marisa::grimoire::vector::BitVector::swap(this, v8);
  if (v13)
  {
    MEMORY[0x1B8C85310](v13, 0x1000C8077774924);
  }

  if (v11)
  {
    MEMORY[0x1B8C85310](v11, 0x1000C8077774924);
  }

  if (v9)
  {
    MEMORY[0x1B8C85310](v9, 0x1000C8077774924);
  }

  result = *&v8[0];
  if (*&v8[0])
  {
    return MEMORY[0x1B8C85310](*&v8[0], 0x1000C8077774924);
  }

  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  if (*a4 == a5)
  {
    v26 = 0u;
    memset(v27, 0, sizeof(v27));
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::resize(&v26, a2[3]);
    v9 = a2[3];
    if (v9)
    {
      v10 = (*(&v26 + 1) + 8);
      v11 = (a2[1] + 8);
      do
      {
        v12 = *(v11 - 1);
        v13 = *v11;
        v11 += 6;
        *(v10 - 1) = v12 + v13 - 1;
        *v10 = v13;
        v10 += 4;
        --v9;
      }

      while (v9);
    }

    marisa::grimoire::trie::Tail::build((a1 + 744), &v26, a3, *(a4 + 12));
    result = v26;
    if (v26)
    {
      return MEMORY[0x1B8C85310]();
    }
  }

  else
  {
    v26 = 0u;
    memset(v27, 0, sizeof(v27));
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::resize(&v26, a2[3]);
    if (a2[3])
    {
      v16 = 0;
      v17 = 0;
      do
      {
        v18 = *(&v26 + 1) + v16;
        v19 = a2[1] + v16;
        v20 = *(v19 + 8);
        *v18 = *v19 + v20;
        *(v18 + 8) = v20;
        *(v18 + 12) = *(v19 + 12);
        ++v17;
        v16 += 24;
      }

      while (v17 < a2[3]);
    }

    v21 = *a2;
    *a2 = 0u;
    *(a2 + 1) = 0u;
    *(a2 + 25) = 0u;
    if (v21)
    {
      MEMORY[0x1B8C85310](v21, 0x1000C8077774924);
    }

    v22 = operator new(0x470uLL, MEMORY[0x1E69E5398]);
    v23 = v22;
    if (v22)
    {
      marisa::grimoire::trie::LoudsTrie::LoudsTrie(v22);
    }

    v24 = (a1 + 1000);
    marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset(v24, v23);
    if (!*v24)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &unk_1F2D43298;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x8000001C3;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:451: MARISA_MEMORY_ERROR: next_trie_.get() == NULL";
    }

    marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::ReverseKey>(*v24, &v26, a3, a4, a5 + 1);
    result = v26;
    if (v26)
    {
      return MEMORY[0x1B8C85310]();
    }
  }

  return result;
}

void sub_1B5A96B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  MEMORY[0x1B8C85330](v9, MEMORY[0x1E69E5398]);
  if (a9)
  {
    MEMORY[0x1B8C85310]();
  }

  _Unwind_Resume(a1);
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::resize(uint64_t *result, unint64_t a2)
{
  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 >> 59)
    {
      v5 = 0xFFFFFFFFFFFFFFFLL;
    }

    if (v4 > a2 >> 1)
    {
      a2 = v5;
    }

    result = marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::realloc(result, a2);
  }

  v6 = v3[3];
  v7 = v2 - v6;
  if (v2 > v6)
  {
    v8 = 16 * v6;
    do
    {
      v9 = (v3[1] + v8);
      *v9 = 0;
      v9[1] = 0;
      v8 += 16;
      --v7;
    }

    while (v7);
  }

  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::ReverseKey>(a1, a2, a3, a4, a5);
  memset(v18, 0, 41);
  if (*(a2 + 24))
  {
    marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::ReverseKey>(a1, a2, v18, a4, a5);
  }

  v9 = *(a1 + 1000);
  if (v9)
  {
    v10 = v9[268] + 1;
    v11 = v9[271] | v9[272];
    v19 = 3;
    v20 = 0x100000000200;
    v21 = 0x20000;
    marisa::grimoire::trie::Config::parse_(&v19, v10 | v11);
  }

  else
  {
    if (*(a1 + 840))
    {
      v12 = 0x2000;
    }

    else
    {
      v12 = 4096;
    }

    v13 = *(a4 + 16) | *(a4 + 8) | v12;
    v19 = 3;
    v20 = 0x100000000200;
    v21 = 0x20000;
    marisa::grimoire::trie::Config::parse_(&v19, v13 | 1);
  }

  *(a1 + 1072) = v19;
  *(a1 + 1080) = v20;
  *(a1 + 1088) = v21;
  marisa::grimoire::vector::BitVector::build((a1 + 416), 0, 0);
  if (*(&v18[1] + 1))
  {
    v14 = 0;
    v15 = 0;
    do
    {
      do
      {
        v16 = *(*(a1 + 432) + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15;
        ++v15;
      }

      while ((v16 & 1) == 0);
      *(*(a1 + 632) + v15 - 1) = *(*(&v18[0] + 1) + 4 * v14);
      *(*(&v18[0] + 1) + 4 * v14++) >>= 8;
    }

    while (v14 < *(&v18[1] + 1));
  }

  marisa::grimoire::vector::FlatVector::build((a1 + 672), v18);
  marisa::grimoire::trie::LoudsTrie::fill_cache(a1);
  result = *&v18[0];
  if (*&v18[0])
  {
    return MEMORY[0x1B8C85310](*&v18[0], 0x1000C8077774924);
  }

  return result;
}

void sub_1B5A96DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
  {
    MEMORY[0x1B8C85310](a9, 0x1000C8077774924);
  }

  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  if (*a4 == a5)
  {
    memset(v19, 0, 41);
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::resize(v19, *(a2 + 24));
    v9 = *(a2 + 24);
    if (v9)
    {
      v10 = (*(&v19[0] + 1) + 8);
      v11 = (*(a2 + 8) + 8);
      do
      {
        v12 = *(v11 - 1);
        v13 = *v11;
        v11 += 6;
        *(v10 - 1) = v12 - 1;
        *v10 = v13;
        v10 += 4;
        --v9;
      }

      while (v9);
    }

    marisa::grimoire::trie::Tail::build((a1 + 744), v19, a3, *(a4 + 12));
    result = *&v19[0];
    if (*&v19[0])
    {
      return MEMORY[0x1B8C85310](*&v19[0], 0x1000C8077774924);
    }
  }

  else
  {
    v15 = operator new(0x470uLL, MEMORY[0x1E69E5398]);
    v16 = v15;
    if (v15)
    {
      marisa::grimoire::trie::LoudsTrie::LoudsTrie(v15);
    }

    v17 = (a1 + 1000);
    marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset(v17, v16);
    if (!*v17)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &unk_1F2D43298;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x8000001D4;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:468: MARISA_MEMORY_ERROR: next_trie_.get() == NULL";
    }

    return marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::ReverseKey>();
  }

  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize(uint64_t *result, unint64_t a2)
{
  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 > 0xAAAAAAAAAAAAAAALL)
    {
      v5 = 0x1555555555555555;
    }

    if (v4 > a2 >> 1)
    {
      a2 = v5;
    }

    result = marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::realloc(result, a2);
  }

  v6 = v3[3];
  v7 = v2 - v6;
  if (v2 > v6)
  {
    v8 = 12 * v6;
    do
    {
      v9 = v3[1] + v8;
      *v9 = 0;
      *(v9 + 8) = 0x800000;
      v8 += 12;
      --v7;
    }

    while (v7);
  }

  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::fill_cache(uint64_t this)
{
  v1 = *(this + 1032);
  if (v1)
  {
    v2 = this;
    v3 = 0;
    for (i = 0; i < v1; ++i)
    {
      v5 = *(v2 + 1016) + v3;
      v6 = *(v5 + 4);
      if (v6)
      {
        *(v5 + 8) = *(*(v2 + 632) + v6);
        v7 = *(v2 + 1016);
        if ((*(*(v2 + 432) + ((v6 >> 3) & 0x1FFFFFF8)) >> v6))
        {
          this = marisa::grimoire::vector::BitVector::rank1((v2 + 416), v6);
          v8 = *(v2 + 720);
          v9 = v8 * this;
          v10 = (v8 * this) & 0x3F;
          v11 = v10 + v8;
          v12 = (*(v2 + 688) + 8 * ((v8 * this) >> 6));
          v13 = *v12;
          if (v11 > 0x40)
          {
            v14 = ((2 * v12[1]) << ~v9) | (v13 >> v9);
          }

          else
          {
            v14 = v13 >> v10;
          }

          v15 = (*(v2 + 728) & v14) << 8;
        }

        else
        {
          v15 = -256;
        }

        *(v7 + v3 + 8) = *(v7 + v3 + 8) | v15;
        v1 = *(v2 + 1032);
      }

      else
      {
        *v5 = -1;
      }

      v3 += 12;
    }
  }

  return this;
}

uint64_t *marisa::grimoire::trie::LoudsTrie::restore_(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2, unint64_t a3)
{
  v6 = *(a2 + 5);
  while (1)
  {
    while (1)
    {
      v7 = *(this + 132) & a3;
      v8 = *(this + 128) + 12 * v7;
      if (a3 != *(v8 + 4))
      {
        break;
      }

      v9 = *(v8 + 8);
      if (v9 <= 0xFFFFFEFF)
      {
        v20 = *(this + 125);
        if (v20)
        {
          result = marisa::grimoire::trie::LoudsTrie::restore_(v20, a2, v9);
        }

        else
        {
          result = marisa::grimoire::trie::Tail::restore(this + 93, a2, v9);
        }
      }

      else
      {
        v24 = *(v8 + 8);
        result = marisa::grimoire::vector::Vector<char>::push_back(v6, &v24);
      }

      a3 = *(*(this + 128) + 12 * v7);
      if (!a3)
      {
        return result;
      }
    }

    if ((*(*(this + 54) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3))
    {
      v11 = *(*(this + 80) + a3);
      v12 = marisa::grimoire::vector::BitVector::rank1((this + 416), a3);
      v13 = *(this + 90);
      v14 = v13 * v12;
      v15 = (v13 * v12) & 0x3F;
      v16 = v15 + v13;
      v17 = (*(this + 86) + 8 * ((v13 * v12) >> 6));
      v18 = *v17;
      v19 = v16 > 0x40 ? ((2 * v17[1]) << ~v14) | (v18 >> v14) : v18 >> v15;
      v21 = v11 | ((*(this + 182) & v19) << 8);
      v22 = *(this + 125);
      result = v22 ? marisa::grimoire::trie::LoudsTrie::restore_(v22, a2, v21) : marisa::grimoire::trie::Tail::restore(this + 93, a2, v21);
    }

    else
    {
      v23 = *(*(this + 80) + a3);
      result = marisa::grimoire::vector::Vector<char>::push_back(v6, &v23);
    }

    if (a3 <= *(this + 133))
    {
      break;
    }

    a3 = marisa::grimoire::vector::BitVector::select1(this, a3) + ~a3;
  }

  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::prefix_match_(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2, unint64_t a3)
{
  v6 = *(a2 + 5);
  while (1)
  {
    v7 = *(this + 132) & a3;
    v8 = *(this + 128) + 12 * v7;
    if (a3 != *(v8 + 4))
    {
      v10 = *(*(this + 80) + a3);
      if ((*(*(this + 54) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3))
      {
        v11 = marisa::grimoire::vector::BitVector::rank1((this + 416), a3);
        v12 = *(this + 90);
        v13 = v12 * v11;
        v14 = (v12 * v11) & 0x3F;
        v15 = v14 + v12;
        v16 = (*(this + 86) + 8 * ((v12 * v11) >> 6));
        v17 = *v16;
        if (v15 > 0x40)
        {
          v18 = ((2 * v16[1]) << ~v13) | (v17 >> v13);
        }

        else
        {
          v18 = v17 >> v14;
        }

        v20 = v10 | ((*(this + 182) & v18) << 8);
        v21 = *(this + 125);
        if (v21)
        {
          if ((marisa::grimoire::trie::LoudsTrie::prefix_match_(v21, a2, v20) & 1) == 0)
          {
            return 0;
          }
        }

        else if (!marisa::grimoire::trie::Tail::prefix_match((this + 744), a2, v20))
        {
          return 0;
        }
      }

      else
      {
        if (v10 != *(*a2 + *(v6 + 100)))
        {
          return 0;
        }

        v23 = *(*(this + 80) + a3);
        marisa::grimoire::vector::Vector<char>::push_back(v6, &v23);
        ++*(v6 + 100);
      }

      if (a3 <= *(this + 133))
      {
        return 1;
      }

      a3 = marisa::grimoire::vector::BitVector::select1(this, a3) + ~a3;
      goto LABEL_23;
    }

    v9 = *(v8 + 8);
    if (v9 > 0xFFFFFEFF)
    {
      if (*(*a2 + *(v6 + 100)) != v9)
      {
        return 0;
      }

      v24 = *(v8 + 8);
      marisa::grimoire::vector::Vector<char>::push_back(v6, &v24);
      ++*(v6 + 100);
      goto LABEL_22;
    }

    v19 = *(this + 125);
    if (!v19)
    {
      break;
    }

    if ((marisa::grimoire::trie::LoudsTrie::prefix_match_(v19, a2, v9) & 1) == 0)
    {
      return 0;
    }

LABEL_22:
    a3 = *(*(this + 128) + 12 * v7);
    if (!a3)
    {
      return 1;
    }

LABEL_23:
    if (*(a2 + 1) <= *(v6 + 100))
    {
      marisa::grimoire::trie::LoudsTrie::restore_(this, a2, a3);
      return 1;
    }
  }

  if (marisa::grimoire::trie::Tail::prefix_match((this + 744), a2, v9))
  {
    goto LABEL_22;
  }

  return 0;
}

void marisa::grimoire::trie::Tail::~Tail(marisa::grimoire::trie::Tail *this)
{
  v2 = *(this + 26);
  if (v2)
  {
    MEMORY[0x1B8C85310](v2, 0x1000C8077774924);
  }

  v3 = *(this + 20);
  if (v3)
  {
    MEMORY[0x1B8C85310](v3, 0x1000C8077774924);
  }

  v4 = *(this + 14);
  if (v4)
  {
    MEMORY[0x1B8C85310](v4, 0x1000C8077774924);
  }

  v5 = *(this + 6);
  if (v5)
  {
    MEMORY[0x1B8C85310](v5, 0x1000C8077774924);
  }

  if (*this)
  {
    MEMORY[0x1B8C85310](*this, 0x1000C8077774924);
  }
}

_BYTE *marisa::grimoire::vector::Vector<char>::realloc(uint64_t *a1, size_t __sz)
{
  result = operator new[](__sz, MEMORY[0x1E69E5398]);
  v5 = a1[3];
  if (v5)
  {
    v6 = a1[1];
    v7 = result;
    do
    {
      v8 = *v6++;
      *v7++ = v8;
      --v5;
    }

    while (v5);
  }

  v9 = *a1;
  *a1 = result;
  a1[1] = result;
  a1[2] = result;
  a1[4] = __sz;
  if (v9)
  {

    JUMPOUT(0x1B8C85310);
  }

  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::resize(uint64_t *result, unint64_t a2)
{
  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 > 0x666666666666666)
    {
      v5 = 0xCCCCCCCCCCCCCCCLL;
    }

    if (v4 > a2 >> 1)
    {
      a2 = v5;
    }

    result = marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc(result, a2);
  }

  v6 = v3[3];
  v7 = v2 - v6;
  if (v2 > v6)
  {
    v8 = (v3[1] + 20 * v6 + 16);
    do
    {
      *(v8 - 1) = xmmword_1B5B34CF0;
      *v8 = -1;
      v8 += 5;
      --v7;
    }

    while (v7);
  }

  v3[3] = v2;
  return result;
}

_DWORD *marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc(uint64_t *a1, uint64_t a2)
{
  result = operator new[](20 * a2, MEMORY[0x1E69E5398]);
  v5 = a1[3];
  if (v5)
  {
    v6 = a1[1];
    v7 = result;
    do
    {
      v8 = *v6;
      v7[4] = *(v6 + 4);
      *v7 = v8;
      v7 += 5;
      v6 = (v6 + 20);
      --v5;
    }

    while (v5);
  }

  v9 = *a1;
  *a1 = result;
  a1[1] = result;
  a1[2] = result;
  a1[4] = a2;
  if (v9)
  {

    JUMPOUT(0x1B8C85310);
  }

  return result;
}

uint64_t *marisa::grimoire::vector::Vector<unsigned long long>::resize(uint64_t *result, unint64_t a2, uint64_t *a3)
{
  v4 = a2;
  v5 = result;
  v6 = result[4];
  if (v6 < a2)
  {
    v7 = 2 * v6;
    if (v6 >> 60)
    {
      v7 = 0x1FFFFFFFFFFFFFFFLL;
    }

    if (v6 > a2 >> 1)
    {
      a2 = v7;
    }

    result = marisa::grimoire::vector::Vector<unsigned long long>::realloc(result, a2);
  }

  v8 = v5[3];
  v9 = v4 - v8;
  if (v4 > v8)
  {
    v10 = 0;
    v11 = *a3;
    v12 = vdupq_n_s64(v9 - 1);
    v13 = v5[1] + 8 * v8;
    do
    {
      v14 = vmovn_s64(vcgeq_u64(v12, vorrq_s8(vdupq_n_s64(v10), xmmword_1B5AE0060)));
      if (v14.i8[0])
      {
        *(v13 + 8 * v10) = v11;
      }

      if (v14.i8[4])
      {
        *(v13 + 8 * v10 + 8) = v11;
      }

      v10 += 2;
    }

    while (((v9 + 1) & 0xFFFFFFFFFFFFFFFELL) != v10);
  }

  v5[3] = v4;
  return result;
}

void *marisa::grimoire::vector::Vector<unsigned long long>::realloc(uint64_t *a1, uint64_t a2)
{
  result = operator new[](8 * a2, MEMORY[0x1E69E5398]);
  v5 = a1[3];
  if (v5)
  {
    v6 = a1[1];
    v7 = result;
    do
    {
      v8 = *v6++;
      *v7++ = v8;
      --v5;
    }

    while (v5);
  }

  v9 = *a1;
  *a1 = result;
  a1[1] = result;
  a1[2] = result;
  a1[4] = a2;
  if (v9)
  {

    JUMPOUT(0x1B8C85310);
  }

  return result;
}

void *marisa::grimoire::vector::Vector<unsigned long long>::shrink(void *result)
{
  if (*(result + 40) == 1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0x100000064;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:100: MARISA_STATE_ERROR: fixed_";
  }

  v2 = result[3];
  if (v2 != result[4])
  {

    return marisa::grimoire::vector::Vector<unsigned long long>::realloc(result, v2);
  }

  return result;
}

uint64_t *marisa::grimoire::vector::Vector<unsigned long long>::resize(uint64_t *result, unint64_t a2)
{
  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 >> 60)
    {
      v5 = 0x1FFFFFFFFFFFFFFFLL;
    }

    if (v4 > a2 >> 1)
    {
      a2 = v5;
    }

    result = marisa::grimoire::vector::Vector<unsigned long long>::realloc(result, a2);
  }

  v3[3] = v2;
  return result;
}

void marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::resize(uint64_t *a1, unint64_t a2)
{
  v2 = a2;
  v4 = a1[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 > 0xAAAAAAAAAAAAAAALL)
    {
      v5 = 0x1555555555555555;
    }

    if (v4 > a2 >> 1)
    {
      a2 = v5;
    }

    marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::realloc(a1, a2);
  }

  v6 = a1[3];
  if (v2 > v6)
  {
    bzero((a1[1] + 12 * v6), 12 * (v2 - v6));
  }

  a1[3] = v2;
}

_DWORD *marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::realloc(uint64_t *a1, uint64_t a2)
{
  result = operator new[](12 * a2, MEMORY[0x1E69E5398]);
  v5 = a1[3];
  if (v5)
  {
    v6 = a1[1];
    v7 = result;
    do
    {
      v8 = *v6;
      v7[2] = *(v6 + 2);
      *v7 = v8;
      v7 += 3;
      v6 = (v6 + 12);
      --v5;
    }

    while (v5);
  }

  v9 = *a1;
  *a1 = result;
  a1[1] = result;
  a1[2] = result;
  a1[4] = a2;
  if (v9)
  {

    JUMPOUT(0x1B8C85310);
  }

  return result;
}

uint64_t *marisa::grimoire::vector::Vector<unsigned int>::resize(uint64_t *result, unint64_t a2)
{
  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 >> 61)
    {
      v5 = 0x3FFFFFFFFFFFFFFFLL;
    }

    if (v4 > a2 >> 1)
    {
      a2 = v5;
    }

    result = marisa::grimoire::vector::Vector<unsigned int>::realloc(result, a2);
  }

  v3[3] = v2;
  return result;
}

_DWORD *marisa::grimoire::vector::Vector<unsigned int>::realloc(uint64_t *a1, uint64_t a2)
{
  result = operator new[](4 * a2, MEMORY[0x1E69E5398]);
  v5 = a1[3];
  if (v5)
  {
    v6 = a1[1];
    v7 = result;
    do
    {
      v8 = *v6++;
      *v7++ = v8;
      --v5;
    }

    while (v5);
  }

  v9 = *a1;
  *a1 = result;
  a1[1] = result;
  a1[2] = result;
  a1[4] = a2;
  if (v9)
  {

    JUMPOUT(0x1B8C85310);
  }

  return result;
}

char *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::realloc(uint64_t *a1, uint64_t a2)
{
  result = operator new[](24 * a2, MEMORY[0x1E69E5398]);
  v5 = a1[3];
  if (v5)
  {
    v6 = result + 16;
    v7 = (a1[1] + 16);
    do
    {
      *(v6 - 2) = *(v7 - 2);
      *(v6 - 2) = *(v7 - 2);
      *(v6 - 1) = *(v7 - 1);
      v8 = *v7;
      v7 += 6;
      *v6 = v8;
      v6 += 6;
      --v5;
    }

    while (v5);
  }

  v9 = *a1;
  *a1 = result;
  a1[1] = result;
  a1[2] = result;
  a1[4] = a2;
  if (v9)
  {

    JUMPOUT(0x1B8C85310);
  }

  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::Key>(uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  v10 = *(a2 + 24);
  v11 = *(a2 + 8);
  if (v10)
  {
    v12 = 0;
    v13 = vdupq_n_s64(v10 - 1);
    v14 = xmmword_1B5AE0050;
    v15 = xmmword_1B5AE0060;
    v16 = (v11 + 64);
    v17 = vdupq_n_s64(4uLL);
    do
    {
      v18 = vmovn_s64(vcgeq_u64(v13, v15));
      if (vuzp1_s16(v18, *v13.i8).u8[0])
      {
        *(v16 - 12) = v12;
      }

      if (vuzp1_s16(v18, *&v13).i8[2])
      {
        *(v16 - 6) = v12 + 1;
      }

      if (vuzp1_s16(*&v13, vmovn_s64(vcgeq_u64(v13, *&v14))).i32[1])
      {
        *v16 = v12 + 2;
        v16[6] = v12 + 3;
      }

      v12 += 4;
      v14 = vaddq_s64(v14, v17);
      v15 = vaddq_s64(v15, v17);
      v16 += 24;
    }

    while (((v10 + 3) & 0xFFFFFFFFFFFFFFFCLL) != v12);
  }

  v19 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v11, v11 + 24 * v10, 0);
  v20 = 256;
  if (a5 != 1)
  {
    v20 = 1;
  }

  do
  {
    v21 = v20;
    v20 *= 2;
  }

  while (v21 < v19 / *(a4 + 8));
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize(a1 + 126, v21);
  a1[132] = v21 - 1;
  marisa::grimoire::vector::BitVector::push_back(a1, 1);
  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  LOBYTE(v71[0]) = 0;
  marisa::grimoire::vector::Vector<char>::push_back(a1 + 78, v71);
  marisa::grimoire::vector::BitVector::push_back(a1 + 52, 0);
  v61 = a3;
  v62 = a5;
  memset(v71, 0, 41);
  v70 = 0u;
  memset(v69, 0, sizeof(v69));
  v67 = 0u;
  memset(v68, 0, 25);
  v65.n128_u64[0] = *(a2 + 24) << 32;
  v65.n128_u32[2] = 0;
  std::deque<marisa::grimoire::trie::Range>::push_back(v69, &v65);
  v22 = *(&v70 + 1);
  if (*(&v70 + 1))
  {
    v63 = a4;
    do
    {
      v23 = a1[58];
      v24 = (*(*(&v69[0] + 1) + 8 * (v70 / 0x155)) + 12 * (v70 % 0x155));
      v25 = *v24;
      v26 = v24[1];
      v27 = v24[2];
      *&v70 = v70 + 1;
      *(&v70 + 1) = v22 - 1;
      if (v70 >= 0x2AA)
      {
        operator delete(**(&v69[0] + 1));
        *(&v69[0] + 1) += 8;
        *&v70 = v70 - 341;
      }

      v28 = v23 - v22;
      if (v25 < v26)
      {
        while (1)
        {
          v29 = *(a2 + 8) + 24 * v25;
          if (*(v29 + 8) != v27)
          {
            break;
          }

          *(v29 + 12) = v28;
          v25 = (v25 + 1);
          if (v26 == v25)
          {
            goto LABEL_51;
          }
        }
      }

      if (v25 != v26)
      {
        v30 = v67;
        v67 = 0u;
        memset(v68, 0, 25);
        if (v30)
        {
          MEMORY[0x1B8C85310](v30, 0x1000C8077774924);
        }

        v31 = *(a2 + 8);
        v32 = *(v31 + 24 * v25 + 12);
        v33 = v25 + 1;
        if (v25 + 1 < v26)
        {
          v64 = v23;
          v34 = v32;
          v35 = 24 * v25;
          v36 = (v25 << 32) + 0x100000000;
          do
          {
            if (*(*(v31 + v35) + v27) != *(*(v31 + v35 + 24) + v27))
            {
              *&v37 = v34;
              v65.n128_u64[0] = v36 + v25;
              v65.n128_u64[1] = v27 | (v37 << 32);
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back(&v67, &v65);
              v31 = *(a2 + 8);
              v34 = 0.0;
              LODWORD(v25) = v33;
            }

            v34 = v34 + *(v31 + v35 + 36);
            ++v33;
            v35 += 24;
            v36 += 0x100000000;
          }

          while (v26 != v33);
          v32 = v34;
          a4 = v63;
          v23 = v64;
        }

        v65.n128_u32[0] = v25;
        v65.n128_u32[1] = v26;
        v65.n128_u64[1] = v27 | (LODWORD(v32) << 32);
        v38 = marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back(&v67, &v65);
        if (*(a4 + 16) == 0x20000)
        {
          std::__stable_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *,std::greater<marisa::grimoire::trie::WeightedRange>>(*(&v67 + 1), (*(&v67 + 1) + 16 * v68[1]), &v65, v38);
        }

        v39 = v68[1];
        if (v23 == v22)
        {
          a1[133] = v68[1];
        }

        if (v39)
        {
          v40 = 0;
          do
          {
            v41 = (*(&v67 + 1) + 16 * v40);
            v42 = *(v41 + 2);
            v43 = *(a2 + 8) + 24 * *v41;
            v44 = *(v43 + 8);
            v45 = v42 + 1;
            if (v42 + 1 >= v44)
            {
              v46 = *(v41 + 2);
              LODWORD(v44) = v42 + 1;
            }

            else
            {
              v46 = v44 - 1;
              v47 = *(v41 + 2);
              do
              {
                v48 = v47;
                v47 = v45;
                v49 = (*(a2 + 8) + 24 * *v41);
                v50 = *v41;
                while (++v50 < *(v41 + 1))
                {
                  v51 = *v49;
                  v52 = v49[3];
                  v49 += 3;
                  if (*(v51 + v47) != *(v52 + v47))
                  {
                    v46 = v48;
                    LODWORD(v44) = v47;
                    goto LABEL_45;
                  }
                }

                v45 = v47 + 1;
              }

              while (v47 + 1 != v44);
            }

LABEL_45:
            v53 = v41[3];
            v54 = a1[127] + 12 * (((32 * v28) ^ v28 ^ *(*v43 + v42)) & a1[132]);
            if (*(v54 + 8) < v53)
            {
              v55 = a1[81];
              *v54 = v28;
              *(v54 + 4) = v55;
              *(v54 + 8) = v53;
              v42 = *(v41 + 2);
            }

            if (v46 == v42)
            {
              v65.n128_u8[0] = *(*(*(a2 + 8) + 24 * *v41) + v46);
              marisa::grimoire::vector::Vector<char>::push_back(a1 + 78, &v65);
              marisa::grimoire::vector::BitVector::push_back(a1 + 52, 0);
            }

            else
            {
              v65.n128_u8[0] = 0;
              marisa::grimoire::vector::Vector<char>::push_back(a1 + 78, &v65);
              marisa::grimoire::vector::BitVector::push_back(a1 + 52, 1);
              v65 = 0uLL;
              v66 = 0;
              v56 = *(v41 + 2);
              v65.n128_u64[0] = *(*(a2 + 8) + 24 * *v41) + v56;
              v65.n128_u64[1] = (v44 - v56);
              v65.n128_f32[3] = v41[3];
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::push_back(v71, &v65);
            }

            *(v41 + 2) = v44;
            std::deque<marisa::grimoire::trie::Range>::push_back(v69, v41);
            marisa::grimoire::vector::BitVector::push_back(a1, 1);
            ++v40;
          }

          while (v40 < v68[1]);
        }
      }

LABEL_51:
      marisa::grimoire::vector::BitVector::push_back(a1, 0);
      v22 = *(&v70 + 1);
    }

    while (*(&v70 + 1));
  }

  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  marisa::grimoire::vector::BitVector::build(a1, v62 == 1, 1);
  marisa::grimoire::vector::Vector<unsigned char>::shrink(a1 + 624);
  marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::Key>(a1, a2, v61);
  v57 = *a2;
  *a2 = v71[0];
  v71[0] = v57;
  v58 = *(a2 + 16);
  *(a2 + 16) = *&v71[1];
  *&v71[1] = v58;
  v59 = *(a2 + 24);
  *(a2 + 24) = *(&v71[1] + 8);
  *(&v71[1] + 8) = v59;
  LOBYTE(v58) = *(a2 + 40);
  *(a2 + 40) = BYTE8(v71[2]);
  BYTE8(v71[2]) = v58;
  if (v67)
  {
    MEMORY[0x1B8C85310](v67, 0x1000C8077774924);
  }

  std::deque<std::pair<int,std::pair<int,int>>>::~deque[abi:ne200100](v69);
  result = *&v71[0];
  if (*&v71[0])
  {
    return MEMORY[0x1B8C85310](*&v71[0], 0x1000C8077774924);
  }

  return result;
}

void sub_1B5A98308(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  if (a11)
  {
    MEMORY[0x1B8C85310](a11, 0x1000C8077774924);
  }

  std::deque<std::pair<int,std::pair<int,int>>>::~deque[abi:ne200100](va);
  v19 = *(v16 - 144);
  if (v19)
  {
    MEMORY[0x1B8C85310](v19, 0x1000C8077774924);
  }

  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x8000001ACLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:428: MARISA_MEMORY_ERROR: std::bad_alloc";
  }

  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::vector::FlatVector::build(__int128 *a1, uint64_t a2)
{
  memset(v9, 0, 41);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  marisa::grimoire::vector::FlatVector::build_(v9, a2);
  v3 = *a1;
  *a1 = v9[0];
  v9[0] = v3;
  v4 = *(a1 + 2);
  *(a1 + 2) = *&v9[1];
  *&v9[1] = v4;
  v5 = *(a1 + 24);
  *(a1 + 24) = *(&v9[1] + 8);
  *(&v9[1] + 8) = v5;
  LOBYTE(v4) = *(a1 + 40);
  *(a1 + 40) = BYTE8(v9[2]);
  BYTE8(v9[2]) = v4;
  v6 = *(a1 + 6);
  *(a1 + 6) = v10;
  v10 = v6;
  LODWORD(v6) = *(a1 + 14);
  *(a1 + 14) = v11;
  v11 = v6;
  v7 = *(a1 + 8);
  *(a1 + 8) = v12;
  result = v3;
  v12 = v7;
  if (v3)
  {
    return MEMORY[0x1B8C85310](v3, 0x1000C8077774924);
  }

  return result;
}

void sub_1B5A984E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
  {
    MEMORY[0x1B8C85310](a9, 0x1000C8077774924);
  }

  _Unwind_Resume(exception_object);
}

__n128 marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back(uint64_t *a1, __n128 *a2)
{
  v4 = a1[3];
  v5 = a1[4];
  v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    v7 = 2 * v5;
    if (v5 >> 59)
    {
      v7 = 0xFFFFFFFFFFFFFFFLL;
    }

    if (v5 <= v6 >> 1)
    {
      v8 = v6;
    }

    else
    {
      v8 = v7;
    }

    marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::realloc(a1, v8);
    v4 = a1[3];
  }

  result = *a2;
  *(a1[1] + 16 * v4) = *a2;
  ++a1[3];
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::push_back(uint64_t *result, uint64_t a2)
{
  v3 = result;
  v4 = result[3];
  v5 = result[4];
  v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    v7 = 2 * v5;
    if (v5 > 0x555555555555555)
    {
      v7 = 0xAAAAAAAAAAAAAAALL;
    }

    if (v5 <= v6 >> 1)
    {
      v8 = v6;
    }

    else
    {
      v8 = v7;
    }

    result = marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::realloc(result, v8);
    v4 = v3[3];
  }

  v9 = v3[1] + 24 * v4;
  *v9 = *a2;
  *(v9 + 8) = *(a2 + 8);
  *(v9 + 12) = *(a2 + 12);
  *(v9 + 16) = *(a2 + 16);
  ++v3[3];
  return result;
}

_BYTE *marisa::grimoire::vector::Vector<unsigned char>::shrink(_BYTE *result)
{
  if (result[40] == 1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0x100000064;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:100: MARISA_STATE_ERROR: fixed_";
  }

  v2 = *(result + 3);
  if (v2 != *(result + 4))
  {

    return marisa::grimoire::vector::Vector<char>::realloc(result, v2);
  }

  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t a2, __int128 *a3)
{
  memset(v13, 0, 41);
  marisa::grimoire::vector::Vector<unsigned int>::resize(v13, *(a2 + 24));
  v5 = *(a2 + 24);
  if (v5)
  {
    v6 = *(&v13[0] + 1);
    v7 = (*(a2 + 16) + 16);
    do
    {
      *(v6 + 4 * *v7) = *(v7 - 1);
      v7 += 6;
      --v5;
    }

    while (v5);
  }

  else
  {
    v6 = *(&v13[0] + 1);
  }

  v8 = *a3;
  v9 = *&v13[1];
  *a3 = *&v13[0];
  *(a3 + 1) = v6;
  v13[0] = v8;
  v10 = *(a3 + 2);
  *(a3 + 2) = v9;
  *&v13[1] = v10;
  v11 = *(a3 + 24);
  *(a3 + 24) = *(&v13[1] + 8);
  *(&v13[1] + 8) = v11;
  LOBYTE(v10) = *(a3 + 40);
  *(a3 + 40) = BYTE8(v13[2]);
  result = v8;
  BYTE8(v13[2]) = v10;
  if (v8)
  {
    return MEMORY[0x1B8C85310](v8, 0x1000C8077774924);
  }

  return result;
}

void sub_1B5A98784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
  {
    MEMORY[0x1B8C85310](a9, 0x1000C8077774924);
  }

  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  v4 = a2;
  v5 = a1;
  v6 = a2 - a1;
  if ((a2 - a1) < 241)
  {
    v7 = 0;
    goto LABEL_64;
  }

  v7 = 0;
  v8 = a1;
  v9 = a1;
  do
  {
    v10 = marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Key>(v9, v9 + 24 * (v6 / 0x30uLL), v4 - 24, a3);
    v11 = v10;
    v12 = v9;
    v5 = v4;
    v13 = v9;
    v14 = v4;
    while (v12 < v5)
    {
      v15 = *(v12 + 8);
      v16 = a3 >= v15 ? -1 : *(*v12 + a3);
      if (v16 > v10)
      {
        break;
      }

      if (v16 == v10)
      {
        v17 = *v12;
        *v12 = *v13;
        *(v12 + 8) = *(v13 + 8);
        v18 = *(v12 + 12);
        *(v12 + 12) = *(v13 + 12);
        *(v12 + 16) = *(v13 + 16);
        *v13 = v17;
        *(v13 + 8) = v15;
        *(v13 + 12) = v18;
        v13 += 24;
      }

LABEL_11:
      v12 += 24;
    }

    if (v12 < v5)
    {
      v19 = v5 - 24;
      do
      {
        v5 = v19;
        v20 = *(v19 + 8);
        if (a3 >= v20)
        {
          v21 = -1;
        }

        else
        {
          v21 = *(*v5 + a3);
        }

        if (v21 < v10)
        {
          break;
        }

        if (v21 == v10)
        {
          v22 = *(v14 - 24);
          v14 -= 24;
          v23 = *v5;
          *v5 = v22;
          *(v5 + 8) = *(v14 + 8);
          v24 = *(v5 + 12);
          *(v5 + 12) = *(v14 + 12);
          *(v5 + 16) = *(v14 + 16);
          *v14 = v23;
          *(v14 + 8) = v20;
          *(v14 + 12) = v24;
        }

        v19 = v5 - 24;
      }

      while (v12 < v5);
    }

    if (v12 < v5)
    {
      v25 = *v12;
      v26 = *(v12 + 16);
      *v12 = *v5;
      v27 = *(v12 + 8);
      *(v12 + 8) = *(v5 + 8);
      *(v12 + 12) = *(v5 + 12);
      *(v12 + 16) = *(v5 + 16);
      *v5 = v25;
      *(v5 + 8) = v27;
      *(v5 + 16) = v26;
      goto LABEL_11;
    }

    if (v13 > v9)
    {
      v28 = 0;
      do
      {
        v29 = v13 + v28;
        v30 = v12 + v28;
        v31 = *(v13 + v28 - 24);
        v32 = *(v13 + v28 - 8);
        *(v29 - 24) = *(v12 + v28 - 24);
        v33 = *(v13 + v28 - 16);
        *(v29 - 16) = *(v12 + v28 - 16);
        *(v29 - 12) = *(v12 + v28 - 12);
        *(v29 - 8) = *(v12 + v28 - 8);
        *(v30 - 24) = v31;
        *(v30 - 16) = v33;
        *(v30 - 8) = v32;
        v28 -= 24;
      }

      while (v13 + v28 > v9);
      v12 += v28;
    }

    while (v14 < v4)
    {
      v34 = *v14;
      v35 = *(v14 + 16);
      *v14 = *v5;
      v36 = *(v14 + 8);
      *(v14 + 8) = *(v5 + 8);
      *(v14 + 12) = *(v5 + 12);
      *(v14 + 16) = *(v5 + 16);
      *v5 = v34;
      *(v5 + 8) = v36;
      *(v5 + 16) = v35;
      v14 += 24;
      v5 += 24;
    }

    v37 = v12 - v8;
    v38 = v5 - v12;
    if (v37 <= (v5 - v12))
    {
      v39 = v4 - v5;
      if ((v4 - v5) <= v38)
      {
        if (v37 == 24)
        {
          ++v7;
        }

        else if (v37 >= 25)
        {
          v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v9, v12, a3);
        }

        if (v39 == 24)
        {
          ++v7;
        }

        else if (v39 >= 25)
        {
          v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v5, v4, a3);
        }

        if (v38 == 24)
        {
          ++v7;
        }

        else if (v38 >= 25)
        {
          if (v11 == -1)
          {
            ++v7;
            v4 = v5;
            goto LABEL_60;
          }

          ++a3;
        }

        v4 = v5;
        v5 = v12;
        goto LABEL_60;
      }
    }

    if (v38 == 24)
    {
      goto LABEL_32;
    }

    if (v38 >= 25)
    {
      if (v10 == -1)
      {
LABEL_32:
        ++v7;
      }

      else
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v12, v5, a3 + 1);
      }
    }

    v40 = v4 - v5;
    if (v37 >= (v4 - v5))
    {
      if (v40 == 24)
      {
        ++v7;
      }

      else if (v40 >= 25)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v5, v4, a3);
      }

      v4 = v12;
      v5 = v9;
    }

    else if (v37 == 24)
    {
      ++v7;
    }

    else if (v37 >= 25)
    {
      v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v9, v12, a3);
    }

LABEL_60:
    v6 = v4 - v5;
    v8 = v5;
    v9 = v5;
  }

  while ((v4 - v5) > 240);
LABEL_64:
  if (v6 >= 25)
  {
    v7 += marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Key *>(v5, v4, a3);
  }

  return v7;
}

uint64_t marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(a1 + 8) <= a4)
  {
    v4 = -1;
  }

  else
  {
    v4 = *(*a1 + a4);
  }

  if (*(a2 + 8) <= a4)
  {
    v5 = -1;
  }

  else
  {
    v5 = *(*a2 + a4);
  }

  if (*(a3 + 8) <= a4)
  {
    v6 = -1;
  }

  else
  {
    v6 = *(*a3 + a4);
  }

  if (v4 <= v5)
  {
    v7 = v5;
  }

  else
  {
    v7 = v4;
  }

  if (v4 >= v5)
  {
    v4 = v5;
  }

  if (v4 <= v6)
  {
    v4 = v6;
  }

  if (v7 >= v6)
  {
    return v4;
  }

  else
  {
    return v7;
  }
}

uint64_t marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Key *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  v3 = a1 + 24;
  if (a1 + 24 >= a2)
  {
    return 1;
  }

  v7 = 1;
  do
  {
    v8 = v3;
    if (v3 <= a1)
    {
      v15 = 0;
    }

    else
    {
      while (1)
      {
        v9 = v8 - 24;
        v10 = marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Key>(v8 - 24, v8, a3);
        if (v10 < 1)
        {
          break;
        }

        v11 = *(v8 - 24);
        v12 = *(v8 - 8);
        *(v8 - 24) = *v8;
        v13 = *(v8 + 8);
        *(v8 - 8) = *(v8 + 16);
        *v8 = v11;
        v14 = *(v8 - 16);
        *(v8 - 16) = v13;
        *(v8 + 8) = v14;
        *(v8 + 16) = v12;
        v8 -= 24;
        if (v9 <= a1)
        {
          v10 = 1;
          break;
        }
      }

      v15 = v10 != 0;
    }

    v7 += v15;
    v3 += 24;
  }

  while (v3 < a2);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  v3 = *(a1 + 8);
  v4 = *(a2 + 8);
  v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4)
    {
      v12 = -1;
    }

    else
    {
      v12 = 1;
    }

    if (v3 == v4)
    {
      return 0;
    }

    else
    {
      return v12;
    }
  }

  else
  {
    v6 = v4 - a3;
    v7 = (*a1 + a3);
    v8 = (*a2 + a3);
    while (v6)
    {
      v9 = *v7;
      v10 = *v8;
      result = (v9 - v10);
      if (v9 != v10)
      {
        return result;
      }

      --v6;
      ++v7;
      ++v8;
      if (!--v5)
      {
        goto LABEL_6;
      }
    }

    return 1;
  }
}

void *std::deque<marisa::grimoire::trie::Range>::push_back(void *result, uint64_t *a2)
{
  v3 = result;
  v4 = result[2];
  v5 = result[1];
  v6 = 341 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5)
  {
    v6 = 0;
  }

  v7 = result[5] + result[4];
  if (v6 == v7)
  {
    result = std::deque<marisa::grimoire::trie::Range>::__add_back_capacity(result);
    v5 = v3[1];
    v7 = v3[5] + v3[4];
  }

  v8 = *(v5 + 8 * (v7 / 0x155)) + 12 * (v7 % 0x155);
  v9 = *a2;
  *(v8 + 8) = *(a2 + 2);
  *v8 = v9;
  ++v3[5];
  return result;
}

void *std::deque<marisa::grimoire::trie::Range>::__add_back_capacity(void *a1)
{
  v1 = a1[4];
  v2 = v1 >= 0x155;
  v3 = v1 - 341;
  if (!v2)
  {
    v6 = a1[2];
    v7 = a1[3];
    v8 = v7 - *a1;
    if (v6 - a1[1] < v8)
    {
      if (v7 != v6)
      {
        operator new();
      }

      operator new();
    }

    if (v7 == *a1)
    {
      v9 = 1;
    }

    else
    {
      v9 = v8 >> 2;
    }

    v11 = a1;
    std::__allocate_at_least[abi:ne200100]<std::allocator<kaldi::CuWorkspace *>>(a1, v9);
  }

  a1[4] = v3;
  v4 = a1[1];
  *&v10 = *v4;
  a1[1] = v4 + 1;
  return std::__split_buffer<std::vector<std::unique_ptr<kaldi::quasar::ComputeEngineBufferItf>> *,std::allocator<std::vector<std::unique_ptr<kaldi::quasar::ComputeEngineBufferItf>> *>>::emplace_back<std::vector<std::unique_ptr<kaldi::quasar::ComputeEngineBufferItf>> *&>(a1, &v10);
}

void sub_1B5A98FBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

_OWORD *marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::realloc(uint64_t *a1, uint64_t a2)
{
  result = operator new[](16 * a2, MEMORY[0x1E69E5398]);
  v5 = a1[3];
  if (v5)
  {
    v6 = a1[1];
    v7 = result;
    do
    {
      v8 = *v6++;
      *v7++ = v8;
      --v5;
    }

    while (v5);
  }

  v9 = *a1;
  *a1 = result;
  a1[1] = result;
  a1[2] = result;
  a1[4] = a2;
  if (v9)
  {

    JUMPOUT(0x1B8C85310);
  }

  return result;
}

void std::__stable_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *,std::greater<marisa::grimoire::trie::WeightedRange>>(__n128 *a1, __n128 *a2, uint64_t a3, __n128 a4)
{
  v7 = a2 - a1;
  if (v7 < 129)
  {
    v13 = 0;
    v9 = 0;
  }

  else
  {
    v8 = MEMORY[0x1E69E5398];
    v9 = a2 - a1;
    while (1)
    {
      v10 = operator new(16 * v9, v8);
      if (v10)
      {
        break;
      }

      v11 = v9 >> 1;
      v12 = v9 > 1;
      v9 >>= 1;
      if (!v12)
      {
        v13 = 0;
        v9 = v11;
        goto LABEL_8;
      }
    }

    v13 = v10;
  }

LABEL_8:
  std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, a2, a3, v7, v13, v9, a4);
  if (v13)
  {

    operator delete(v13);
  }
}

void sub_1B5A99184(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    operator delete(v1);
  }

  _Unwind_Resume(exception_object);
}

double std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, uint64_t a3, unint64_t a4, __n128 *a5, uint64_t a6, __n128 a7)
{
  if (a4 >= 2)
  {
    if (a4 == 2)
    {
      a7.n128_u32[0] = a2[-1].n128_u32[3];
      if (a7.n128_f32[0] > a1->n128_f32[3])
      {
        a7 = *a1;
        *a1 = a2[-1];
        a2[-1] = a7;
      }
    }

    else if (a4 > 128)
    {
      v13 = a4 >> 1;
      v14 = &a1[a4 >> 1];
      v15 = a4 >> 1;
      if (a4 <= a6)
      {
        v17.n128_f64[0] = std::__stable_sort_move<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, v14, a3, v15, a5, a7);
        v18.n128_f64[0] = std::__stable_sort_move<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), &a5[v13], v17);

        a7.n128_f64[0] = std::__merge_move_assign[abi:ne200100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*>(a5, &a5[v13], &a5[v13], &a5[a4], a1, v18);
      }

      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, v14, a3, v15, a5, a6);
        std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), a5, a6);

        a7.n128_u64[0] = std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, &a1[a4 >> 1], a2, a3, a4 >> 1, a4 - (a4 >> 1), a5, a6, v16).n128_u64[0];
      }
    }

    else
    {

      std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, a2);
    }
  }

  return a7.n128_f64[0];
}

uint64_t std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    v2 = result + 16;
    if (result + 16 != a2)
    {
      v3 = 0;
      v4 = result;
      do
      {
        v5 = *(v4 + 28);
        v6 = *(v4 + 12);
        v4 = v2;
        if (v5 > v6)
        {
          v10 = *v2;
          v11 = *(v2 + 8);
          v7 = v3;
          while (1)
          {
            *(result + v7 + 16) = *(result + v7);
            if (!v7)
            {
              break;
            }

            v8 = *(result + v7 - 4);
            v7 -= 16;
            if (v5 <= v8)
            {
              v9 = result + v7 + 16;
              goto LABEL_10;
            }
          }

          v9 = result;
LABEL_10:
          *v9 = v10;
          *(v9 + 8) = v11;
          *(v9 + 12) = v5;
        }

        v2 = v4 + 16;
        v3 += 16;
      }

      while (v4 + 16 != a2);
    }
  }

  return result;
}

double std::__stable_sort_move<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, uint64_t a3, unint64_t a4, __n128 *a5, __n128 a6)
{
  if (a4)
  {
    if (a4 == 2)
    {
      v10 = a2 - 1;
      if (a2[-1].n128_f32[3] <= a1->n128_f32[3])
      {
        *a5 = *a1;
        a6 = *v10;
      }

      else
      {
        *a5 = *v10;
        a6 = *a1;
      }

      a5[1] = a6;
    }

    else if (a4 == 1)
    {
      a6 = *a1;
      *a5 = *a1;
    }

    else if (a4 > 8)
    {
      std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, &a1[a4 >> 1], a3, a4 >> 1, a5, a4 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), &a5[a4 >> 1], a4 - (a4 >> 1));

      a6.n128_f64[0] = std::__merge_move_assign[abi:ne200100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*>(a1, &a1[a4 >> 1], &a1[a4 >> 1], a2, a5, v12);
    }

    else
    {

      a6.n128_u64[0] = std::__insertion_sort_move[abi:ne200100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, a2, a5).n128_u64[0];
    }
  }

  return a6.n128_f64[0];
}

double std::__merge_move_assign[abi:ne200100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, __n128 a6)
{
  while (a1 != a2)
  {
    if (a3 == a4)
    {
      while (a1 != a2)
      {
        v9 = *a1++;
        a6.n128_u64[0] = v9.n128_u64[0];
        *a5++ = v9;
      }

      return a6.n128_f64[0];
    }

    if (a3->n128_f32[3] <= a1->n128_f32[3])
    {
      v7 = *a1++;
      a6 = v7;
    }

    else
    {
      v6 = *a3++;
      a6 = v6;
    }

    *a5++ = a6;
  }

  while (a3 != a4)
  {
    v8 = *a3++;
    a6.n128_u64[0] = v8.n128_u64[0];
    *a5++ = v8;
  }

  return a6.n128_f64[0];
}

__n128 std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 result)
{
  if (a6)
  {
    v10 = a6;
    while (v10 > a8 && a5 > a8)
    {
      if (!a5)
      {
        return result;
      }

      v12 = 0;
      result.n128_u32[0] = a2->n128_u32[3];
      v13 = -a5;
      while (1)
      {
        v14 = &a1[v12];
        if (result.n128_f32[0] > a1[v12].n128_f32[3])
        {
          break;
        }

        ++v12;
        if (__CFADD__(v13++, 1))
        {
          return result;
        }
      }

      v16 = -v13;
      v39 = a3;
      v40 = a8;
      if (-v13 >= v10)
      {
        if (v13 == -1)
        {
          v43 = a1[v12];
          a1[v12] = *a2;
          result = v43;
          *a2 = v43;
          return result;
        }

        v26 = v16 / 2;
        v20 = &a1[v16 / 2 + v12];
        if (a3 == a2)
        {
          v18 = a2;
        }

        else
        {
          v27 = a3 - a2;
          v18 = a2;
          do
          {
            v28 = v27 >> 1;
            v29 = &v18[v27 >> 1];
            v30 = v29->n128_f32[3];
            v31 = v29 + 1;
            v27 += ~(v27 >> 1);
            if (v30 > v20->n128_f32[3])
            {
              v18 = v31;
            }

            else
            {
              v27 = v28;
            }
          }

          while (v27);
        }

        v17 = v18 - a2;
      }

      else
      {
        v17 = v10 / 2;
        v18 = &a2[v10 / 2];
        if (v14 == a2)
        {
          v25 = &a1[v12];
          v20 = &a1[v12];
        }

        else
        {
          v19 = (a2 - a1 - v12 * 16) >> 4;
          v20 = &a1[v12];
          do
          {
            v21 = v19 >> 1;
            v22 = &v20[v19 >> 1];
            v23 = v22->n128_f32[3];
            v24 = v22 + 1;
            v19 += ~(v19 >> 1);
            if (v18->n128_f32[3] > v23)
            {
              v19 = v21;
            }

            else
            {
              v20 = v24;
            }
          }

          while (v19);
          v25 = v20;
        }

        v26 = (v25 - a1 - v12 * 16) >> 4;
      }

      a5 = -(v26 + v13);
      v32 = v10 - v17;
      v33 = v17;
      v34 = std::__rotate[abi:ne200100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *,marisa::grimoire::trie::WeightedRange *>(v20, a2, v18);
      v35 = v33;
      v36 = v34;
      if (v26 + v35 >= v10 - (v26 + v35) - v13)
      {
        v38 = v35;
        std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(v34, v18, v39, a4, a5, v32, a7, v40);
        v18 = v20;
        v32 = v38;
        a5 = v26;
        a8 = v40;
        a3 = v36;
      }

      else
      {
        v37 = v26;
        a8 = v40;
        std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(v14, v20, v34, a4, v37, v35, a7, v40);
        v14 = v36;
        a3 = v39;
      }

      v10 = v32;
      a1 = v14;
      a2 = v18;
      if (!v32)
      {
        return result;
      }
    }

    result.n128_u64[0] = std::__buffered_inplace_merge[abi:ne200100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, a2, a3, a4, a5, v10, a7, result).n128_u64[0];
  }

  return result;
}

__n128 std::__insertion_sort_move[abi:ne200100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, __n128 *a3)
{
  if (a1 != a2)
  {
    result = *a1;
    *a3 = *a1;
    v4 = a1 + 1;
    if (&a1[1] != a2)
    {
      v5 = 0;
      v6 = a3;
      do
      {
        v7 = a1;
        v8 = v6;
        a1 = v4;
        v9 = ++v6;
        if (v7[1].n128_f32[3] > v8->n128_f32[3])
        {
          *v6 = *v8;
          v9 = a3;
          if (v8 != a3)
          {
            v10 = v5;
            while (1)
            {
              v9 = (a3 + v10);
              if (v7[1].n128_f32[3] <= *(&a3->n128_f32[-1] + v10))
              {
                break;
              }

              *v9 = v9[-1];
              v10 -= 16;
              if (!v10)
              {
                v9 = a3;
                break;
              }
            }
          }
        }

        result = *a1;
        *v9 = *a1;
        v4 = a1 + 1;
        v5 += 16;
      }

      while (&a1[1] != a2);
    }
  }

  return result;
}

__n128 std::__buffered_inplace_merge[abi:ne200100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, __n128 *a3, int a4, uint64_t a5, uint64_t a6, uint64_t __src, __n128 result)
{
  if (a5 <= a6)
  {
    if (a1 != a2)
    {
      v14 = -__src;
      v15 = __src;
      v16 = a1;
      do
      {
        v17 = *v16++;
        *v15 = v17;
        v15 += 4;
        v14 -= 16;
      }

      while (v16 != a2);
      while (a2 != a3)
      {
        if (a2->n128_f32[3] <= *(__src + 12))
        {
          v19 = *__src;
          __src += 16;
          result = v19;
        }

        else
        {
          v18 = *a2++;
          result = v18;
        }

        *a1++ = result;
        if (v15 == __src)
        {
          return result;
        }
      }

      memmove(a1, __src, -(__src + v14));
    }
  }

  else if (a2 != a3)
  {
    v8 = 0;
    do
    {
      result = a2[v8];
      *(__src + v8 * 16) = result;
      ++v8;
    }

    while (&a2[v8] != a3);
    v9 = (__src + v8 * 16);
    while (a2 != a1)
    {
      v10 = v9[-1].n128_f32[3];
      v11 = a2[-1].n128_f32[3];
      v12 = v10 <= v11;
      if (v10 <= v11)
      {
        v13 = v9 - 1;
      }

      else
      {
        v13 = a2 - 1;
      }

      result = *v13;
      a3[-1] = *v13;
      --a3;
      if (v12)
      {
        --v9;
      }

      else
      {
        --a2;
      }

      if (v9 == __src)
      {
        return result;
      }
    }

    if (v9 != __src)
    {
      v20 = 0xFFFFFFFFFFFFFFFLL;
      do
      {
        result = v9[-1];
        a3[v20--] = result;
        --v9;
      }

      while (v9 != __src);
    }
  }

  return result;
}

char *std::__rotate[abi:ne200100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *,marisa::grimoire::trie::WeightedRange *>(char *__src, char *a2, char *a3)
{
  v4 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }

    else if (__src + 16 == a2)
    {
      v9 = *__src;
      v6 = a3 - a2;
      memmove(__src, __src + 16, a3 - a2);
      v4 = &__src[v6];
      *v4 = v9;
    }

    else if (a2 + 16 == a3)
    {
      v4 = __src + 16;
      v10 = *(a3 - 1);
      v7 = a3 - 16 - __src;
      if (a3 - 16 != __src)
      {
        memmove(__src + 16, __src, v7);
      }

      *__src = v10;
    }

    else
    {
      return std::__rotate_gcd[abi:ne200100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *>(__src, a2, a3);
    }
  }

  return v4;
}

char *std::__rotate_gcd[abi:ne200100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *>(char *a1, char *a2, char *a3)
{
  v3 = a2 - a1;
  v4 = (a2 - a1) >> 4;
  v5 = a3 - a2;
  if (v4 == (a3 - a2) >> 4)
  {
    if (a1 != a2 && a2 != a3)
    {
      v6 = a2 + 16;
      v7 = a1 + 16;
      do
      {
        v8 = *(v7 - 1);
        *(v7 - 1) = *(v6 - 1);
        *(v6 - 1) = v8;
        if (v7 == a2)
        {
          break;
        }

        v7 += 16;
        v9 = v6 == a3;
        v6 += 16;
      }

      while (!v9);
    }
  }

  else
  {
    v10 = v5 >> 4;
    v11 = (a2 - a1) >> 4;
    do
    {
      v12 = v11;
      v11 = v10;
      v10 = v12 % v10;
    }

    while (v10);
    v13 = &a1[16 * v11];
    do
    {
      v14 = *(v13 - 1);
      v13 -= 16;
      v15 = &v13[v3];
      v16 = v13;
      do
      {
        v17 = v16;
        v16 = v15;
        *v17 = *v15;
        v18 = __OFSUB__(v4, (a3 - v15) >> 4);
        v20 = v4 - ((a3 - v15) >> 4);
        v19 = (v20 < 0) ^ v18;
        v15 = &a1[16 * v20];
        if (v19)
        {
          v15 = v16 + v3;
        }
      }

      while (v15 != v13);
      *v16 = v14;
    }

    while (v13 != a1);
    return &a1[v5];
  }

  return a2;
}

uint64_t marisa::grimoire::vector::FlatVector::build_(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 24);
  if (v4)
  {
    v5 = 0;
    v6 = *(a2 + 16);
    v7 = *(a2 + 24);
    do
    {
      v9 = *v6++;
      v8 = v9;
      if (v9 > v5)
      {
        v5 = v8;
      }

      --v7;
    }

    while (v7);
    v10 = 32 - __clz(v5);
    if (v5)
    {
      v11 = v10;
    }

    else
    {
      v11 = 0;
    }
  }

  else
  {
    v11 = 0;
  }

  v12 = v4 != 0;
  v13 = (v11 * v4 + 63) >> 6;
  if (v11)
  {
    v14 = v13;
  }

  else
  {
    v14 = v12;
  }

  result = marisa::grimoire::vector::Vector<unsigned long long>::resize(a1, v14);
  if (v14)
  {
    *(*(a1 + 8) + 8 * *(a1 + 24) - 8) = 0;
  }

  *(a1 + 48) = v11;
  if (v11)
  {
    *(a1 + 56) = 0xFFFFFFFF >> -v11;
  }

  v16 = *(a2 + 24);
  *(a1 + 64) = v16;
  if (v16)
  {
    v17 = 0;
    do
    {
      result = marisa::grimoire::vector::FlatVector::set(a1, v17, *(*(a2 + 16) + 4 * v17));
      ++v17;
    }

    while (v17 < *(a2 + 24));
  }

  return result;
}

uint64_t marisa::grimoire::vector::FlatVector::set(uint64_t this, uint64_t a2, int a3)
{
  v3 = *(this + 48);
  v4 = (v3 * a2) & 0x3F;
  v5 = *(this + 56);
  v6 = (*(this + 8) + 8 * ((v3 * a2) >> 6));
  v7 = v5 & a3;
  *v6 = *v6 & ~(v5 << (v3 * a2)) | (v7 << (v3 * a2));
  if ((v4 + v3) >= 0x41)
  {
    v6[1] = v6[1] & ~(v5 >> -v4) | (v7 >> -v4);
  }

  return this;
}

unsigned int *std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>(unsigned int *result, unsigned int *a2, uint64_t a3, uint64_t a4, char a5)
{
  v8 = result;
LABEL_2:
  v9 = a2 - 1;
  v10 = v8;
LABEL_3:
  v11 = 1 - a4;
  while (1)
  {
    v8 = v10;
    v12 = v11;
    v13 = (a2 - v10) >> 3;
    if (v13 <= 2)
    {
      if (v13 < 2)
      {
        return result;
      }

      if (v13 == 2)
      {
        v88 = *(a2 - 2);
        v89 = *v10;
        if (v88 < *v10 || v89 >= v88 && *(a2 - 1) < v10[1])
        {
          *v10 = v88;
          *(a2 - 2) = v89;
          v90 = v10[1];
          v10[1] = *(a2 - 1);
          *(a2 - 1) = v90;
        }

        return result;
      }

      goto LABEL_11;
    }

    if (v13 == 3)
    {
      v91 = v10[2];
      v92 = *v10;
      if (v91 >= *v10 && (v92 < v91 || v10[3] >= v10[1]))
      {
        v106 = *(a2 - 2);
        if (v106 >= v91 && (v91 < v106 || *(a2 - 1) >= v10[3]))
        {
          return result;
        }

        v10[2] = v106;
        *(a2 - 2) = v91;
        v9 = v10 + 3;
        v107 = v10[3];
        v10[3] = *(a2 - 1);
        *(a2 - 1) = v107;
        v108 = v10[2];
        v109 = *v10;
        if (v108 >= *v10 && (v109 < v108 || v10[3] >= v10[1]))
        {
          return result;
        }

        *v10 = v108;
        v10[2] = v109;
        v94 = v10 + 1;
LABEL_201:
        v113 = *v94;
        *v94 = *v9;
        *v9 = v113;
        return result;
      }

      v93 = *(a2 - 2);
      if (v93 < v91)
      {
LABEL_156:
        *v10 = v93;
        v94 = v10 + 1;
        *(a2 - 2) = v92;
        goto LABEL_201;
      }

      if (v91 >= v93)
      {
        v110 = v10[3];
        if (*(a2 - 1) < v110)
        {
          goto LABEL_156;
        }
      }

      else
      {
        v110 = v10[3];
      }

      v111 = v10[1];
      v10[3] = v111;
      *v10 = v91;
      v10[1] = v110;
      v10[2] = v92;
      v112 = *(a2 - 2);
      if (v112 >= v92 && (v92 < v112 || *(a2 - 1) >= v111))
      {
        return result;
      }

      v10[2] = v112;
      *(a2 - 2) = v92;
      v94 = v10 + 3;
      goto LABEL_201;
    }

    if (v13 == 4)
    {

      return std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,0>(v10, v10 + 2, v10 + 4, a2 - 2);
    }

    if (v13 == 5)
    {
      break;
    }

LABEL_11:
    if (v13 <= 23)
    {
      if (a5)
      {

        return std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v10, a2);
      }

      else
      {

        return std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v10, a2);
      }
    }

    if (v11 == 1)
    {
      if (v10 != a2)
      {

        return std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,std::pair<unsigned int,unsigned int> *>(v10, a2, a2, a3);
      }

      return result;
    }

    v14 = &v10[2 * (v13 >> 1)];
    v15 = v14;
    if (v13 >= 0x81)
    {
      v16 = *v14;
      v17 = *v10;
      if (*v14 >= *v10 && (v17 < v16 || v14[1] >= v10[1]))
      {
        v24 = *(a2 - 2);
        if (v24 >= v16 && (v16 < v24 || *(a2 - 1) >= v14[1]) || (*v14 = v24, *(a2 - 2) = v16, v25 = v14 + 1, v26 = v14[1], v14[1] = *(a2 - 1), *(a2 - 1) = v26, v27 = *v14, v28 = *v10, *v14 >= *v10) && (v28 < v27 || *v25 >= v10[1]))
        {
LABEL_45:
          v39 = v14 - 2;
          v40 = *(v14 - 2);
          v41 = v10[2];
          if (v40 >= v41 && (v41 < v40 || *(v14 - 1) >= v10[3]))
          {
            v44 = *(a2 - 4);
            if (v44 >= v40 && (v40 < v44 || *(a2 - 3) >= *(v14 - 1)) || (*v39 = v44, *(a2 - 4) = v40, v45 = v14 - 1, v46 = *(v14 - 1), *(v14 - 1) = *(a2 - 3), *(a2 - 3) = v46, v47 = *v39, v48 = v10[2], *v39 >= v48) && (v48 < v47 || *v45 >= v10[3]))
            {
LABEL_67:
              v57 = v14[2];
              v55 = v14 + 2;
              v56 = v57;
              v58 = v10[4];
              if (v57 >= v58 && (v58 < v56 || v55[1] >= v10[5]))
              {
                v61 = *(a2 - 6);
                if (v61 >= v56 && (v56 < v61 || *(a2 - 5) >= v55[1]) || (*v55 = v61, *(a2 - 6) = v56, v62 = v55 + 1, v63 = v55[1], v55[1] = *(a2 - 5), *(a2 - 5) = v63, v64 = *v55, v65 = v10[4], *v55 >= v65) && (v65 < v64 || *v62 >= v10[5]))
                {
LABEL_85:
                  v70 = *v15;
                  v71 = *v39;
                  if (*v15 >= *v39 && (v71 < v70 || v15[1] >= v39[1]))
                  {
                    v75 = *v55;
                    if (*v55 >= v70)
                    {
                      if (v70 < v75)
                      {
                        goto LABEL_104;
                      }

                      v77 = v55[1];
                      v76 = v15[1];
                      if (v77 >= v76)
                      {
                        goto LABEL_104;
                      }
                    }

                    else
                    {
                      v76 = v15[1];
                      v77 = v55[1];
                    }

                    *v15 = v75;
                    v15[1] = v77;
                    v78 = (v15 + 1);
                    *v55 = v70;
                    v55[1] = v76;
                    if (v75 >= v71 && (v71 < v75 || v77 >= v39[1]))
                    {
                      v70 = v75;
                      goto LABEL_104;
                    }

                    *v39 = v75;
                    v73 = (v39 + 1);
                    *v15 = v71;
LABEL_103:
                    v81 = *v73;
                    *v73 = *v78;
                    *v78 = v81;
                    v70 = *v15;
LABEL_104:
                    v82 = *v10;
                    *v10 = v70;
                    v23 = v10 + 1;
                    *v15 = v82;
                    v30 = v15 + 1;
                    goto LABEL_105;
                  }

                  v72 = *v55;
                  if (*v55 < v70)
                  {
                    goto LABEL_87;
                  }

                  if (v70 >= v72)
                  {
                    v79 = v15[1];
                    if (v55[1] < v79)
                    {
LABEL_87:
                      *v39 = v72;
                      v73 = (v39 + 1);
                      *v55 = v71;
                      v74 = (v55 + 1);
LABEL_102:
                      v78 = v74;
                      goto LABEL_103;
                    }
                  }

                  else
                  {
                    v79 = v15[1];
                  }

                  *v15 = v71;
                  v80 = v39[1];
                  v15[1] = v80;
                  *v39 = v70;
                  v39[1] = v79;
                  if (v72 >= v71 && (v71 < v72 || v55[1] >= v80))
                  {
                    v70 = v71;
                    goto LABEL_104;
                  }

                  *v15 = v72;
                  *v55 = v71;
                  v74 = (v55 + 1);
                  v73 = (v15 + 1);
                  goto LABEL_102;
                }

                v10[4] = v64;
                *v55 = v65;
                v60 = v10 + 5;
LABEL_84:
                v69 = *v60;
                *v60 = *v62;
                *v62 = v69;
                goto LABEL_85;
              }

              v59 = *(a2 - 6);
              if (v59 < v56)
              {
                goto LABEL_69;
              }

              if (v56 >= v59)
              {
                v66 = v55[1];
                if (*(a2 - 5) < v66)
                {
LABEL_69:
                  v10[4] = v59;
                  *(a2 - 6) = v58;
                  v60 = v10 + 5;
LABEL_83:
                  v62 = a2 - 5;
                  goto LABEL_84;
                }
              }

              else
              {
                v66 = v55[1];
              }

              v67 = v10[5];
              v10[4] = v56;
              v10[5] = v66;
              *v55 = v58;
              v55[1] = v67;
              v60 = v55 + 1;
              v68 = *(a2 - 6);
              if (v68 >= v58 && (v58 < v68 || *(a2 - 5) >= v67))
              {
                goto LABEL_85;
              }

              *v55 = v68;
              *(a2 - 6) = v58;
              goto LABEL_83;
            }

            v10[2] = v47;
            *v39 = v48;
            v43 = v10 + 3;
LABEL_66:
            v54 = *v43;
            *v43 = *v45;
            *v45 = v54;
            goto LABEL_67;
          }

          v42 = *(a2 - 4);
          if (v42 < v40)
          {
            goto LABEL_47;
          }

          if (v40 >= v42)
          {
            v49 = *(v14 - 1);
            if (*(a2 - 3) < v49)
            {
LABEL_47:
              v10[2] = v42;
              *(a2 - 4) = v41;
              v43 = v10 + 3;
LABEL_65:
              v45 = a2 - 3;
              goto LABEL_66;
            }
          }

          else
          {
            v49 = *(v14 - 1);
          }

          v52 = v10[3];
          v10[2] = v40;
          v10[3] = v49;
          *v39 = v41;
          *(v14 - 1) = v52;
          v43 = v14 - 1;
          v53 = *(a2 - 4);
          if (v53 >= v41 && (v41 < v53 || *(a2 - 3) >= v52))
          {
            goto LABEL_67;
          }

          *v39 = v53;
          *(a2 - 4) = v41;
          goto LABEL_65;
        }

        *v10 = v27;
        v19 = v10 + 1;
        *v14 = v28;
LABEL_44:
        v38 = *v19;
        *v19 = *v25;
        *v25 = v38;
        goto LABEL_45;
      }

      v18 = *(a2 - 2);
      if (v18 < v16)
      {
        goto LABEL_16;
      }

      if (v16 >= v18)
      {
        v34 = v14[1];
        if (*(a2 - 1) < v34)
        {
LABEL_16:
          *v10 = v18;
          v19 = v10 + 1;
LABEL_43:
          *(a2 - 2) = v17;
          v25 = a2 - 1;
          goto LABEL_44;
        }
      }

      else
      {
        v34 = v14[1];
      }

      v36 = v10[1];
      *v10 = v16;
      v10[1] = v34;
      *v14 = v17;
      v14[1] = v36;
      v19 = v14 + 1;
      v37 = *(a2 - 2);
      if (v37 >= v17 && (v17 < v37 || *(a2 - 1) >= v36))
      {
        goto LABEL_45;
      }

      *v14 = v37;
      goto LABEL_43;
    }

    v20 = *v10;
    v21 = *v14;
    if (*v10 < *v15 || v21 >= v20 && v10[1] < v15[1])
    {
      v22 = *(a2 - 2);
      if (v22 < v20)
      {
        goto LABEL_19;
      }

      if (v20 >= v22)
      {
        v35 = v10[1];
        if (*(a2 - 1) >= v35)
        {
          goto LABEL_59;
        }

LABEL_19:
        *v15 = v22;
        *(a2 - 2) = v21;
        v23 = v15 + 1;
      }

      else
      {
        v35 = v10[1];
LABEL_59:
        v50 = v15[1];
        *v15 = v20;
        v15[1] = v35;
        *v10 = v21;
        v10[1] = v50;
        v23 = v10 + 1;
        v51 = *(a2 - 2);
        if (v51 >= v21 && (v21 < v51 || *(a2 - 1) >= v50))
        {
          goto LABEL_106;
        }

        *v10 = v51;
        *(a2 - 2) = v21;
      }

      v30 = a2 - 1;
LABEL_105:
      v83 = *v23;
      *v23 = *v30;
      *v30 = v83;
      goto LABEL_106;
    }

    v29 = *(a2 - 2);
    if (v29 < v20 || v20 >= v29 && *(a2 - 1) < v10[1])
    {
      *v10 = v29;
      *(a2 - 2) = v20;
      v30 = v10 + 1;
      v31 = v10[1];
      v10[1] = *(a2 - 1);
      *(a2 - 1) = v31;
      v32 = *v10;
      v33 = *v15;
      if (*v10 < *v15 || v33 >= v32 && *v30 < v15[1])
      {
        *v15 = v32;
        *v10 = v33;
        v23 = v15 + 1;
        goto LABEL_105;
      }
    }

LABEL_106:
    if ((a5 & 1) == 0)
    {
      v84 = *(v10 - 2);
      if (v84 >= *v10 && (*v10 < v84 || *(v10 - 1) >= v10[1]))
      {
        result = std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(v10, a2);
        v10 = result;
        goto LABEL_146;
      }
    }

    v85 = std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(v10, a2);
    if ((v86 & 1) == 0)
    {
      goto LABEL_144;
    }

    v87 = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v10, v85);
    v10 = v85 + 2;
    result = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v85 + 2, a2);
    if (result)
    {
      a4 = -v12;
      a2 = v85;
      if (v87)
      {
        return result;
      }

      goto LABEL_2;
    }

    v11 = v12 + 1;
    if (!v87)
    {
LABEL_144:
      result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>(v8, v85, a3, -v12, a5 & 1);
      v10 = v85 + 2;
LABEL_146:
      a5 = 0;
      a4 = -v12;
      goto LABEL_3;
    }
  }

  result = std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,0>(v10, v10 + 2, v10 + 4, v10 + 6);
  v95 = *(a2 - 2);
  v96 = v10[6];
  if (v95 < v96 || v96 >= v95 && *(a2 - 1) < v10[7])
  {
    v10[6] = v95;
    *(a2 - 2) = v96;
    v97 = v10[7];
    v10[7] = *(a2 - 1);
    *(a2 - 1) = v97;
    v98 = v10[6];
    v99 = v10[4];
    if (v98 >= v99)
    {
      if (v99 < v98)
      {
        return result;
      }

      v101 = v10[7];
      v100 = v10[5];
      if (v101 >= v100)
      {
        return result;
      }
    }

    else
    {
      v100 = v10[5];
      v101 = v10[7];
    }

    v10[4] = v98;
    v10[5] = v101;
    v10[6] = v99;
    v10[7] = v100;
    v102 = v10[2];
    if (v98 >= v102)
    {
      if (v102 < v98)
      {
        return result;
      }

      v103 = v10[3];
      if (v101 >= v103)
      {
        return result;
      }
    }

    else
    {
      v103 = v10[3];
    }

    v10[2] = v98;
    v10[3] = v101;
    v10[4] = v102;
    v10[5] = v103;
    v104 = *v10;
    if (v98 >= *v10)
    {
      if (v104 < v98)
      {
        return result;
      }

      v105 = v10[1];
      if (v101 >= v105)
      {
        return result;
      }
    }

    else
    {
      v105 = v10[1];
    }

    *v10 = v98;
    v10[1] = v101;
    v10[2] = v104;
    v10[3] = v105;
  }

  return result;
}

unsigned int *std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,0>(unsigned int *result, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  v4 = *a2;
  v5 = *result;
  if (*a2 < *result || v5 >= v4 && a2[1] < result[1])
  {
    v6 = *a3;
    if (*a3 < v4 || v4 >= v6 && a3[1] < a2[1])
    {
      *result = v6;
      v7 = (result + 1);
    }

    else
    {
      *result = v4;
      *a2 = v5;
      v7 = (a2 + 1);
      v13 = result[1];
      result[1] = a2[1];
      a2[1] = v13;
      v14 = *a3;
      v5 = *a2;
      if (*a3 >= *a2 && (v5 < v14 || a3[1] >= v13))
      {
        goto LABEL_15;
      }

      *a2 = v14;
    }

    *a3 = v5;
    v10 = (a3 + 1);
    goto LABEL_14;
  }

  v8 = *a3;
  if (*a3 < v4 || v4 >= v8 && a3[1] < a2[1])
  {
    *a2 = v8;
    *a3 = v4;
    v10 = (a2 + 1);
    v9 = a2[1];
    a2[1] = a3[1];
    a3[1] = v9;
    v11 = *a2;
    v12 = *result;
    if (*a2 < *result || v12 >= v11 && *v10 < result[1])
    {
      *result = v11;
      v7 = (result + 1);
      *a2 = v12;
LABEL_14:
      v15 = *v7;
      *v7 = *v10;
      *v10 = v15;
    }
  }

LABEL_15:
  v16 = *a4;
  v17 = *a3;
  if (*a4 < *a3 || v17 >= v16 && a4[1] < a3[1])
  {
    *a3 = v16;
    *a4 = v17;
    v18 = a3[1];
    a3[1] = a4[1];
    a4[1] = v18;
    v19 = *a3;
    v20 = *a2;
    if (*a3 < *a2 || v20 >= v19 && a3[1] < a2[1])
    {
      *a2 = v19;
      *a3 = v20;
      v21 = a2[1];
      a2[1] = a3[1];
      a3[1] = v21;
      v22 = *a2;
      v23 = *result;
      if (*a2 < *result || v23 >= v22 && a2[1] < result[1])
      {
        *result = v22;
        *a2 = v23;
        v24 = result[1];
        result[1] = a2[1];
        a2[1] = v24;
      }
    }
  }

  return result;
}

unsigned int *std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *result, unsigned int *a2)
{
  if (result != a2)
  {
    v2 = result + 2;
    if (result + 2 != a2)
    {
      v3 = 0;
      v4 = result;
      do
      {
        v5 = v4;
        v4 = v2;
        v6 = v5[2];
        v7 = *v5;
        if (v6 < *v5 || v7 >= v6 && v5[3] < v5[1])
        {
          v9 = v5[2];
          v8 = v5[3];
          v10 = v5[1];
          v5[2] = v7;
          v4[1] = v10;
          v11 = result;
          if (v5 != result)
          {
            v12 = v3;
            do
            {
              v13 = *(result + v12 - 8);
              if (v13 <= v9)
              {
                if (v13 < v9)
                {
                  v11 = v5;
                  goto LABEL_17;
                }

                v11 = (result + v12);
                v14 = *(result + v12 - 4);
                if (v14 <= v8)
                {
                  goto LABEL_17;
                }
              }

              else
              {
                v14 = *(result + v12 - 4);
              }

              v5 -= 2;
              v15 = (result + v12);
              *v15 = v13;
              v15[1] = v14;
              v12 -= 8;
            }

            while (v12);
            v11 = result;
          }

LABEL_17:
          *v11 = v9;
          v11[1] = v8;
        }

        v2 = v4 + 2;
        v3 += 8;
      }

      while (v4 + 2 != a2);
    }
  }

  return result;
}

unsigned int *std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *result, unsigned int *a2)
{
  if (result != a2)
  {
    v2 = result + 2;
    if (result + 2 != a2)
    {
      v3 = result + 1;
      do
      {
        v4 = result;
        result = v2;
        v5 = v4[2];
        v6 = *v4;
        if (v5 < *v4 || v6 >= v5 && v4[3] < v4[1])
        {
          v7 = *result;
          v8 = result[1];
          for (i = v3; ; i -= 2)
          {
            v10 = *i;
            i[1] = v6;
            i[2] = v10;
            v6 = *(i - 3);
            if (v6 <= v7 && (v6 < v7 || *(i - 2) <= v8))
            {
              break;
            }
          }

          *(i - 1) = v7;
          *i = v8;
        }

        v2 = result + 2;
        v3 += 2;
      }

      while (result + 2 != a2);
    }
  }

  return result;
}

unsigned int *std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(unsigned int *a1, unsigned int *a2)
{
  v3 = *a1;
  v2 = a1[1];
  v4 = *(a2 - 2);
  if (v4 > *a1 || v4 >= v3 && *(a2 - 1) > v2)
  {
    i = a1;
    do
    {
      v7 = i[2];
      i += 2;
      v6 = v7;
    }

    while (v7 <= v3 && (v6 < v3 || i[1] <= v2));
  }

  else
  {
      ;
    }
  }

  if (i < a2)
  {
    for (a2 -= 2; v4 > v3 || v4 >= v3 && a2[1] > v2; a2 -= 2)
    {
      v8 = *(a2 - 2);
      v4 = v8;
    }
  }

  if (i < a2)
  {
    v9 = *i;
    v10 = *a2;
    do
    {
      *i = v10;
      *a2 = v9;
      v11 = i[1];
      i[1] = a2[1];
      a2[1] = v11;
      do
      {
        v12 = i[2];
        i += 2;
        v9 = v12;
      }

      while (v12 <= v3 && (v9 < v3 || i[1] <= v2));
      do
      {
        do
        {
          v13 = *(a2 - 2);
          a2 -= 2;
          v10 = v13;
          v14 = v13 >= v3;
        }

        while (v13 > v3);
      }

      while (v14 && a2[1] > v2);
    }

    while (i < a2);
  }

  if (i - 2 != a1)
  {
    *a1 = *(i - 2);
    a1[1] = *(i - 1);
  }

  *(i - 2) = v3;
  *(i - 1) = v2;
  return i;
}

unsigned int *std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(unsigned int *a1, unsigned int *a2)
{
  v2 = 0;
  v3 = *a1;
  v4 = a1[1];
  while (1)
  {
    v5 = a1[v2 + 2];
    if (v5 >= v3 && (v5 > v3 || a1[v2 + 3] >= v4))
    {
      break;
    }

    v2 += 2;
  }

  v6 = &a1[v2 + 2];
  if (v2 * 4)
  {
    do
    {
      v8 = *(a2 - 2);
      a2 -= 2;
      v7 = v8;
    }

    while (v8 >= v3 && (v7 > v3 || a2[1] >= v4));
  }

  else
  {
LABEL_19:
    if (v6 < a2)
    {
      do
      {
        v10 = *(a2 - 2);
        a2 -= 2;
        v9 = v10;
        if (v10 < v3)
        {
          break;
        }

        if (v9 > v3)
        {
          goto LABEL_19;
        }
      }

      while (a2[1] >= v4 && v6 < a2);
    }
  }

  if (v6 >= a2)
  {
    v13 = v6;
  }

  else
  {
    v12 = *a2;
    v13 = v6;
    v14 = a2;
    do
    {
      *v13 = v12;
      *v14 = v5;
      v15 = v13[1];
      v13[1] = v14[1];
      v14[1] = v15;
      do
      {
        do
        {
          v16 = v13[2];
          v13 += 2;
          v5 = v16;
          v17 = v16 > v3;
        }

        while (v16 < v3);
      }

      while (!v17 && v13[1] < v4);
      do
      {
        v18 = *(v14 - 2);
        v14 -= 2;
        v12 = v18;
      }

      while (v18 >= v3 && (v12 > v3 || v14[1] >= v4));
    }

    while (v13 < v14);
  }

  if (v13 - 2 != a1)
  {
    *a1 = *(v13 - 2);
    a1[1] = *(v13 - 1);
  }

  *(v13 - 2) = v3;
  *(v13 - 1) = v4;
  return v13 - 2;
}

BOOL std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2)
{
  v4 = (a2 - a1) >> 3;
  if (v4 > 2)
  {
    if (v4 != 3)
    {
      if (v4 == 4)
      {
        std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,0>(a1, a1 + 2, a1 + 4, a2 - 2);
        return 1;
      }

      if (v4 != 5)
      {
        goto LABEL_20;
      }

      std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,0>(a1, a1 + 2, a1 + 4, a1 + 6);
      v8 = *(a2 - 2);
      v9 = a1[6];
      if (v8 >= v9 && (v9 < v8 || *(a2 - 1) >= a1[7]))
      {
        return 1;
      }

      a1[6] = v8;
      *(a2 - 2) = v9;
      v10 = a1[7];
      a1[7] = *(a2 - 1);
      *(a2 - 1) = v10;
      v11 = a1[6];
      v12 = a1[4];
      if (v11 >= v12)
      {
        if (v12 < v11)
        {
          return 1;
        }

        v14 = a1[7];
        v13 = a1[5];
        if (v14 >= v13)
        {
          return 1;
        }
      }

      else
      {
        v13 = a1[5];
        v14 = a1[7];
      }

      a1[4] = v11;
      a1[5] = v14;
      a1[6] = v12;
      a1[7] = v13;
      v15 = a1[2];
      if (v11 >= v15)
      {
        if (v15 < v11)
        {
          return 1;
        }

        v16 = a1[3];
        if (v14 >= v16)
        {
          return 1;
        }
      }

      else
      {
        v16 = a1[3];
      }

      a1[2] = v11;
      a1[3] = v14;
      a1[4] = v15;
      a1[5] = v16;
      v17 = *a1;
      if (v11 >= *a1)
      {
        if (v17 < v11)
        {
          return 1;
        }

        v18 = a1[1];
        if (v14 >= v18)
        {
          return 1;
        }
      }

      else
      {
        v18 = a1[1];
      }

      *a1 = v11;
      a1[1] = v14;
      result = 1;
      a1[2] = v17;
      a1[3] = v18;
      return result;
    }

    v20 = a1[2];
    v21 = *a1;
    if (v20 >= *a1 && (v21 < v20 || a1[3] >= a1[1]))
    {
      v30 = *(a2 - 2);
      if (v30 >= v20 && (v20 < v30 || *(a2 - 1) >= a1[3]))
      {
        return 1;
      }

      a1[2] = v30;
      *(a2 - 2) = v20;
      v24 = a1 + 3;
      v31 = a1[3];
      a1[3] = *(a2 - 1);
      *(a2 - 1) = v31;
      v32 = a1[2];
      v33 = *a1;
      if (v32 >= *a1 && (v33 < v32 || a1[3] >= a1[1]))
      {
        return 1;
      }

      *a1 = v32;
      a1[2] = v33;
      v23 = a1 + 1;
      goto LABEL_60;
    }

    v22 = *(a2 - 2);
    if (v22 < v20)
    {
LABEL_19:
      *a1 = v22;
      v23 = a1 + 1;
      *(a2 - 2) = v21;
      v24 = a2 - 1;
      goto LABEL_60;
    }

    if (v20 >= v22)
    {
      v38 = a1[3];
      if (*(a2 - 1) < v38)
      {
        goto LABEL_19;
      }
    }

    else
    {
      v38 = a1[3];
    }

    v40 = a1[1];
    a1[3] = v40;
    *a1 = v20;
    a1[1] = v38;
    a1[2] = v21;
    v41 = *(a2 - 2);
    if (v41 >= v21 && (v21 < v41 || *(a2 - 1) >= v40))
    {
      return 1;
    }

    a1[2] = v41;
    *(a2 - 2) = v21;
    v24 = a2 - 1;
    v23 = a1 + 3;
LABEL_60:
    v42 = *v23;
    *v23 = *v24;
    *v24 = v42;
    return 1;
  }

  if (v4 < 2)
  {
    return 1;
  }

  if (v4 == 2)
  {
    v5 = *(a2 - 2);
    v6 = *a1;
    if (v5 < *a1 || v6 >= v5 && *(a2 - 1) < a1[1])
    {
      *a1 = v5;
      *(a2 - 2) = v6;
      v7 = a1[1];
      a1[1] = *(a2 - 1);
      *(a2 - 1) = v7;
    }

    return 1;
  }

LABEL_20:
  v25 = a1 + 4;
  v26 = a1[2];
  v27 = *a1;
  if (v26 < *a1 || v27 >= v26 && a1[3] < a1[1])
  {
    v28 = *v25;
    if (*v25 < v26)
    {
LABEL_22:
      *a1 = v28;
      a1[4] = v27;
      v29 = (a1 + 1);
LABEL_64:
      v37 = (a1 + 5);
      goto LABEL_65;
    }

    if (v26 >= v28)
    {
      v39 = a1[3];
      if (a1[5] < v39)
      {
        goto LABEL_22;
      }
    }

    else
    {
      v39 = a1[3];
    }

    v43 = a1[1];
    a1[3] = v43;
    v29 = (a1 + 3);
    *a1 = v26;
    a1[1] = v39;
    a1[2] = v27;
    if (v28 >= v27 && (v27 < v28 || a1[5] >= v43))
    {
      goto LABEL_66;
    }

    a1[2] = v28;
    a1[4] = v27;
    goto LABEL_64;
  }

  v34 = *v25;
  if (*v25 < v26)
  {
    v35 = a1[3];
    v36 = a1[5];
LABEL_33:
    a1[3] = v36;
    v37 = (a1 + 3);
    a1[2] = v34;
    a1[4] = v26;
    a1[5] = v35;
    if (v34 >= v27 && (v27 < v34 || v36 >= a1[1]))
    {
      goto LABEL_66;
    }

    *a1 = v34;
    a1[2] = v27;
    v29 = (a1 + 1);
LABEL_65:
    v44 = *v29;
    *v29 = *v37;
    *v37 = v44;
    goto LABEL_66;
  }

  if (v26 >= v34)
  {
    v36 = a1[5];
    v35 = a1[3];
    if (v36 < v35)
    {
      goto LABEL_33;
    }
  }

LABEL_66:
  v45 = a1 + 6;
  if (a1 + 6 == a2)
  {
    return 1;
  }

  v46 = 0;
  v47 = 0;
  while (2)
  {
    v48 = *v25;
    if (*v45 >= *v25 && (v48 < *v45 || v45[1] >= v25[1]))
    {
      goto LABEL_81;
    }

    v49 = *v45;
    v50 = v45[1];
    *v45 = v48;
    v45[1] = v25[1];
    v51 = v46;
    while (1)
    {
      v52 = a1 + v51;
      v53 = *(a1 + v51 + 8);
      if (v53 <= v49)
      {
        break;
      }

      v54 = *(v52 + 3);
LABEL_74:
      *(v52 + 4) = v53;
      *(a1 + v51 + 20) = v54;
      v51 -= 8;
      if (v51 == -16)
      {
        v55 = a1;
        goto LABEL_80;
      }
    }

    if (v53 >= v49)
    {
      v54 = *(a1 + v51 + 12);
      if (v54 > v50)
      {
        goto LABEL_74;
      }
    }

    v55 = (a1 + v51 + 16);
LABEL_80:
    *v55 = v49;
    v55[1] = v50;
    if (++v47 != 8)
    {
LABEL_81:
      v25 = v45;
      v46 += 8;
      v45 += 2;
      if (v45 == a2)
      {
        return 1;
      }

      continue;
    }

    return v45 + 2 == a2;
  }
}

unsigned int *std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    v8 = (a2 - a1) >> 3;
    if (v8 >= 2)
    {
      v9 = (v8 - 2) >> 1;
      v10 = v9 + 1;
      v11 = &a1[2 * v9];
      do
      {
        std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a4, v8, v11);
        v11 -= 2;
        --v10;
      }

      while (v10);
    }

    v12 = a2;
    if (a2 != a3)
    {
      v12 = a2;
      do
      {
        v13 = *v12;
        v14 = *a1;
        if (*v12 < *a1 || v14 >= v13 && v12[1] < a1[1])
        {
          *v12 = v14;
          *a1 = v13;
          v15 = v12[1];
          v12[1] = a1[1];
          a1[1] = v15;
          std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a4, v8, a1);
        }

        v12 += 2;
      }

      while (v12 != a3);
    }

    if (v8 >= 2)
    {
      v16 = a2 - 2;
      do
      {
        v18 = *a1;
        v17 = a1[1];
        v19 = std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a4, v8);
        if (v16 == v19)
        {
          *v19 = v18;
          v19[1] = v17;
        }

        else
        {
          *v19 = *v16;
          v19[1] = v16[1];
          *v16 = v18;
          v16[1] = v17;
          std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, (v19 + 2), a4, ((v19 + 2) - a1) >> 3);
        }

        v16 -= 2;
      }

      while (v8-- > 2);
    }

    return v12;
  }

  return a3;
}

uint64_t std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(uint64_t result, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  if (a3 >= 2)
  {
    v4 = a4 - result;
    v5 = (a3 - 2) >> 1;
    if (v5 >= (a4 - result) >> 3)
    {
      v6 = v4 >> 2;
      v7 = (v4 >> 2) + 1;
      v8 = (result + 8 * v7);
      v9 = v6 + 2;
      if (v9 < a3)
      {
        v10 = v8[2];
        if (*v8 < v10 || v10 >= *v8 && v8[1] < v8[3])
        {
          v8 += 2;
          v7 = v9;
        }
      }

      v11 = *v8;
      if (*v8 >= *a4 && (*a4 < v11 || v8[1] >= a4[1]))
      {
        v12 = *a4;
        v13 = a4[1];
        *a4 = v11;
        a4[1] = v8[1];
        if (v5 >= v7)
        {
          while (1)
          {
            v15 = 2 * v7;
            v7 = (2 * v7) | 1;
            v14 = (result + 8 * v7);
            v16 = v15 + 2;
            if (v16 < a3)
            {
              v17 = v14[2];
              if (*v14 < v17 || v17 >= *v14 && v14[1] < v14[3])
              {
                v14 += 2;
                v7 = v16;
              }
            }

            v18 = *v14;
            if (*v14 < v12 || v18 <= v12 && v14[1] < v13)
            {
              break;
            }

            *v8 = v18;
            v8[1] = v14[1];
            v8 = v14;
            if (v5 < v7)
            {
              goto LABEL_13;
            }
          }
        }

        v14 = v8;
LABEL_13:
        *v14 = v12;
        v14[1] = v13;
      }
    }
  }

  return result;
}

_DWORD *std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(_DWORD *result, uint64_t a2, uint64_t a3)
{
  v3 = 0;
  do
  {
    v4 = result;
    v5 = &result[2 * v3];
    result = v5 + 2;
    v6 = 2 * v3;
    v3 = (2 * v3) | 1;
    v7 = v6 + 2;
    if (v7 < a3)
    {
      v8 = v5[4];
      v9 = v5[2];
      if (v9 < v8 || v8 >= v9 && v5[3] < v5[5])
      {
        result = v5 + 4;
        v3 = v7;
      }
    }

    *v4 = *result;
    v4[1] = result[1];
  }

  while (v3 <= (a3 - 2) / 2);
  return result;
}

uint64_t std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v5 = v4 >> 1;
    v6 = (result + 8 * (v4 >> 1));
    v7 = *v6;
    v8 = *(a2 - 8);
    if (*v6 < v8 || v8 >= v7 && v6[1] < *(a2 - 4))
    {
      v9 = *(a2 - 8);
      v10 = *(a2 - 4);
      *(a2 - 8) = v7;
      *(a2 - 4) = v6[1];
      if (v4 >= 2)
      {
        while (1)
        {
          v12 = v5 - 1;
          v5 = (v5 - 1) >> 1;
          v11 = (result + 8 * v5);
          v13 = *v11;
          if (*v11 >= v9)
          {
            if (v13 > v9)
            {
              break;
            }

            v14 = v11[1];
            if (v14 >= v10)
            {
              break;
            }
          }

          else
          {
            v14 = v11[1];
          }

          *v6 = v13;
          v6[1] = v14;
          v6 = (result + 8 * v5);
          if (v12 <= 1)
          {
            goto LABEL_10;
          }
        }
      }

      v11 = v6;
LABEL_10:
      *v11 = v9;
      v11[1] = v10;
    }
  }

  return result;
}

char *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::realloc(uint64_t *a1, uint64_t a2)
{
  result = operator new[](16 * a2, MEMORY[0x1E69E5398]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (a1[1] + 8);
    v7 = result + 8;
    do
    {
      *(v7 - 1) = *(v6 - 1);
      v8 = *v6;
      v6 += 2;
      *v7 = v8;
      v7 += 2;
      --v5;
    }

    while (v5);
  }

  v9 = *a1;
  *a1 = result;
  a1[1] = result;
  a1[2] = result;
  a1[4] = a2;
  if (v9)
  {

    JUMPOUT(0x1B8C85310);
  }

  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::ReverseKey>(uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  v8 = *(a2 + 24);
  v9 = *(a2 + 8);
  if (v8)
  {
    v10 = 0;
    v11 = vdupq_n_s64(v8 - 1);
    v12 = xmmword_1B5AE0050;
    v13 = xmmword_1B5AE0060;
    v14 = (v9 + 64);
    v15 = vdupq_n_s64(4uLL);
    do
    {
      v16 = vmovn_s64(vcgeq_u64(v11, v13));
      if (vuzp1_s16(v16, *v11.i8).u8[0])
      {
        *(v14 - 12) = v10;
      }

      if (vuzp1_s16(v16, *&v11).i8[2])
      {
        *(v14 - 6) = v10 + 1;
      }

      if (vuzp1_s16(*&v11, vmovn_s64(vcgeq_u64(v11, *&v12))).i32[1])
      {
        *v14 = v10 + 2;
        v14[6] = v10 + 3;
      }

      v10 += 4;
      v12 = vaddq_s64(v12, v15);
      v13 = vaddq_s64(v13, v15);
      v14 += 24;
    }

    while (((v8 + 3) & 0xFFFFFFFFFFFFFFFCLL) != v10);
  }

  v17 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v9, v9 + 24 * v8, 0);
  v18 = 256;
  if (a5 != 1)
  {
    v18 = 1;
  }

  do
  {
    v19 = v18;
    v18 *= 2;
  }

  while (v19 < v17 / *(a4 + 8));
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize(a1 + 126, v19);
  a1[132] = v19 - 1;
  marisa::grimoire::vector::BitVector::push_back(a1, 1);
  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  LOBYTE(v71[0]) = 0;
  marisa::grimoire::vector::Vector<char>::push_back(a1 + 78, v71);
  marisa::grimoire::vector::BitVector::push_back(a1 + 52, 0);
  memset(v71, 0, 41);
  v70 = 0u;
  memset(v69, 0, sizeof(v69));
  v67 = 0u;
  memset(v68, 0, 25);
  v65.n128_u64[0] = *(a2 + 24) << 32;
  v65.n128_u32[2] = 0;
  std::deque<marisa::grimoire::trie::Range>::push_back(v69, &v65);
  v20 = *(&v70 + 1);
  if (*(&v70 + 1))
  {
    v62 = a4;
    do
    {
      v21 = a1[58];
      v22 = (*(*(&v69[0] + 1) + 8 * (v70 / 0x155)) + 12 * (v70 % 0x155));
      v23 = *v22;
      v24 = v22[1];
      v25 = v22[2];
      *&v70 = v70 + 1;
      *(&v70 + 1) = v20 - 1;
      if (v70 >= 0x2AA)
      {
        operator delete(**(&v69[0] + 1));
        *(&v69[0] + 1) += 8;
        *&v70 = v70 - 341;
      }

      v64 = v21;
      v26 = v21 - v20;
      if (v23 < v24)
      {
        while (1)
        {
          v27 = *(a2 + 8) + 24 * v23;
          if (*(v27 + 8) != v25)
          {
            break;
          }

          *(v27 + 12) = v26;
          v23 = (v23 + 1);
          if (v24 == v23)
          {
            goto LABEL_51;
          }
        }
      }

      if (v23 != v24)
      {
        v28 = v67;
        v67 = 0u;
        memset(v68, 0, 25);
        if (v28)
        {
          MEMORY[0x1B8C85310](v28, 0x1000C8077774924);
        }

        v29 = *(a2 + 8);
        v30 = *(v29 + 24 * v23 + 12);
        v31 = v23 + 1;
        if (v23 + 1 < v24)
        {
          v63 = v20;
          v32 = v30;
          v33 = 24 * v23;
          v34 = (v23 << 32) + 0x100000000;
          do
          {
            if (*(*(v29 + v33) - v25 - 1) != *(*(v29 + v33 + 24) - v25 - 1))
            {
              *&v35 = v32;
              v65.n128_u64[0] = v34 + v23;
              v65.n128_u64[1] = v25 | (v35 << 32);
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back(&v67, &v65);
              v29 = *(a2 + 8);
              v32 = 0.0;
              LODWORD(v23) = v31;
            }

            v32 = v32 + *(v29 + v33 + 36);
            ++v31;
            v33 += 24;
            v34 += 0x100000000;
          }

          while (v24 != v31);
          v30 = v32;
          a4 = v62;
          v20 = v63;
        }

        v65.n128_u32[0] = v23;
        v65.n128_u32[1] = v24;
        v65.n128_u64[1] = v25 | (LODWORD(v30) << 32);
        v36 = marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back(&v67, &v65);
        if (*(a4 + 16) == 0x20000)
        {
          std::__stable_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *,std::greater<marisa::grimoire::trie::WeightedRange>>(*(&v67 + 1), (*(&v67 + 1) + 16 * v68[1]), &v65, v36);
        }

        v37 = v68[1];
        if (v64 == v20)
        {
          a1[133] = v68[1];
        }

        if (v37)
        {
          v38 = 0;
          do
          {
            v39 = (*(&v67 + 1) + 16 * v38);
            v40 = *(v39 + 2);
            v41 = *(a2 + 8);
            v42 = *(v41 + 24 * *v39 + 8);
            v43 = v40 + 1;
            if (v40 + 1 >= v42)
            {
              v44 = *(v39 + 2);
              LODWORD(v42) = v40 + 1;
            }

            else
            {
              v44 = v42 - 1;
              v45 = (v41 + 24 * *v39);
              v46 = *(v39 + 2);
              do
              {
                v47 = v46;
                v46 = v43;
                v48 = v45;
                v49 = *v39;
                while (++v49 < *(v39 + 1))
                {
                  v50 = *v48;
                  v51 = v48[3];
                  v48 += 3;
                  if (*(v50 + ~v47 - 1) != *(v51 + ~v47 - 1))
                  {
                    v44 = v47;
                    LODWORD(v42) = v43;
                    goto LABEL_45;
                  }
                }

                ++v43;
              }

              while (v46 + 1 != v42);
            }

LABEL_45:
            v52 = a1[81];
            v53 = v39[3];
            v54 = a1[127] + 12 * (a1[132] & v52);
            if (*(v54 + 8) < v53)
            {
              *v54 = v26;
              *(v54 + 4) = v52;
              *(v54 + 8) = v53;
              v40 = *(v39 + 2);
            }

            if (v44 == v40)
            {
              v65.n128_u8[0] = *(~v44 + *(*(a2 + 8) + 24 * *v39));
              marisa::grimoire::vector::Vector<char>::push_back(a1 + 78, &v65);
              marisa::grimoire::vector::BitVector::push_back(a1 + 52, 0);
            }

            else
            {
              v65.n128_u8[0] = 0;
              marisa::grimoire::vector::Vector<char>::push_back(a1 + 78, &v65);
              marisa::grimoire::vector::BitVector::push_back(a1 + 52, 1);
              v65 = 0uLL;
              v66 = 0;
              v55 = *(v39 + 2);
              v65.n128_u64[0] = *(*(a2 + 8) + 24 * *v39) - v55;
              v65.n128_u64[1] = (v42 - v55);
              v65.n128_f32[3] = v39[3];
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::push_back(v71, &v65);
            }

            *(v39 + 2) = v42;
            std::deque<marisa::grimoire::trie::Range>::push_back(v69, v39);
            marisa::grimoire::vector::BitVector::push_back(a1, 1);
            ++v38;
          }

          while (v38 < v68[1]);
        }
      }

LABEL_51:
      marisa::grimoire::vector::BitVector::push_back(a1, 0);
      v20 = *(&v70 + 1);
    }

    while (*(&v70 + 1));
  }

  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  marisa::grimoire::vector::BitVector::build(a1, a5 == 1, 1);
  marisa::grimoire::vector::Vector<unsigned char>::shrink(a1 + 624);
  marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::ReverseKey>(a1, a2, a3);
  v56 = *a2;
  *a2 = v71[0];
  v71[0] = v56;
  v57 = *(a2 + 16);
  *(a2 + 16) = *&v71[1];
  *&v71[1] = v57;
  v58 = *(a2 + 24);
  *(a2 + 24) = *(&v71[1] + 8);
  *(&v71[1] + 8) = v58;
  LOBYTE(v57) = *(a2 + 40);
  *(a2 + 40) = BYTE8(v71[2]);
  BYTE8(v71[2]) = v57;
  if (v67)
  {
    MEMORY[0x1B8C85310](v67, 0x1000C8077774924);
  }

  std::deque<std::pair<int,std::pair<int,int>>>::~deque[abi:ne200100](v69);
  result = *&v71[0];
  if (*&v71[0])
  {
    return MEMORY[0x1B8C85310](*&v71[0], 0x1000C8077774924);
  }

  return result;
}

void sub_1B5A9BE28(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  if (a11)
  {
    MEMORY[0x1B8C85310](a11, 0x1000C8077774924);
  }

  std::deque<std::pair<int,std::pair<int,int>>>::~deque[abi:ne200100](va);
  v19 = *(v16 - 144);
  if (v19)
  {
    MEMORY[0x1B8C85310](v19, 0x1000C8077774924);
  }

  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x8000001ACLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:428: MARISA_MEMORY_ERROR: std::bad_alloc";
  }

  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, __int128 *a3)
{
  memset(v13, 0, 41);
  marisa::grimoire::vector::Vector<unsigned int>::resize(v13, *(a2 + 24));
  v5 = *(a2 + 24);
  if (v5)
  {
    v6 = *(&v13[0] + 1);
    v7 = (*(a2 + 16) + 16);
    do
    {
      *(v6 + 4 * *v7) = *(v7 - 1);
      v7 += 6;
      --v5;
    }

    while (v5);
  }

  else
  {
    v6 = *(&v13[0] + 1);
  }

  v8 = *a3;
  v9 = *&v13[1];
  *a3 = *&v13[0];
  *(a3 + 1) = v6;
  v13[0] = v8;
  v10 = *(a3 + 2);
  *(a3 + 2) = v9;
  *&v13[1] = v10;
  v11 = *(a3 + 24);
  *(a3 + 24) = *(&v13[1] + 8);
  *(&v13[1] + 8) = v11;
  LOBYTE(v10) = *(a3 + 40);
  *(a3 + 40) = BYTE8(v13[2]);
  result = v8;
  BYTE8(v13[2]) = v10;
  if (v8)
  {
    return MEMORY[0x1B8C85310](v8, 0x1000C8077774924);
  }

  return result;
}

void sub_1B5A9C000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
  {
    MEMORY[0x1B8C85310](a9, 0x1000C8077774924);
  }

  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  v4 = a2;
  v5 = a1;
  v6 = a2 - a1;
  if ((a2 - a1) < 241)
  {
    v7 = 0;
    goto LABEL_64;
  }

  v7 = 0;
  v8 = a1;
  v9 = a1;
  do
  {
    v10 = marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::ReverseKey>(v9, v9 + 24 * (v6 / 0x30uLL), v4 - 24, a3);
    v11 = v10;
    v12 = v9;
    v5 = v4;
    v13 = v9;
    v14 = v4;
    while (v12 < v5)
    {
      v15 = *(v12 + 8);
      v16 = a3 >= v15 ? -1 : *(*v12 - a3 - 1);
      if (v16 > v10)
      {
        break;
      }

      if (v16 == v10)
      {
        v17 = *v12;
        *v12 = *v13;
        *(v12 + 8) = *(v13 + 8);
        v18 = *(v12 + 12);
        *(v12 + 12) = *(v13 + 12);
        *(v12 + 16) = *(v13 + 16);
        *v13 = v17;
        *(v13 + 8) = v15;
        *(v13 + 12) = v18;
        v13 += 24;
      }

LABEL_11:
      v12 += 24;
    }

    if (v12 < v5)
    {
      v19 = v5 - 24;
      do
      {
        v5 = v19;
        v20 = *(v19 + 8);
        if (a3 >= v20)
        {
          v21 = -1;
        }

        else
        {
          v21 = *(*v5 - a3 - 1);
        }

        if (v21 < v10)
        {
          break;
        }

        if (v21 == v10)
        {
          v22 = *(v14 - 24);
          v14 -= 24;
          v23 = *v5;
          *v5 = v22;
          *(v5 + 8) = *(v14 + 8);
          v24 = *(v5 + 12);
          *(v5 + 12) = *(v14 + 12);
          *(v5 + 16) = *(v14 + 16);
          *v14 = v23;
          *(v14 + 8) = v20;
          *(v14 + 12) = v24;
        }

        v19 = v5 - 24;
      }

      while (v12 < v5);
    }

    if (v12 < v5)
    {
      v25 = *v12;
      v26 = *(v12 + 16);
      *v12 = *v5;
      v27 = *(v12 + 8);
      *(v12 + 8) = *(v5 + 8);
      *(v12 + 12) = *(v5 + 12);
      *(v12 + 16) = *(v5 + 16);
      *v5 = v25;
      *(v5 + 8) = v27;
      *(v5 + 16) = v26;
      goto LABEL_11;
    }

    if (v13 > v9)
    {
      v28 = 0;
      do
      {
        v29 = v13 + v28;
        v30 = v12 + v28;
        v31 = *(v13 + v28 - 24);
        v32 = *(v13 + v28 - 8);
        *(v29 - 24) = *(v12 + v28 - 24);
        v33 = *(v13 + v28 - 16);
        *(v29 - 16) = *(v12 + v28 - 16);
        *(v29 - 12) = *(v12 + v28 - 12);
        *(v29 - 8) = *(v12 + v28 - 8);
        *(v30 - 24) = v31;
        *(v30 - 16) = v33;
        *(v30 - 8) = v32;
        v28 -= 24;
      }

      while (v13 + v28 > v9);
      v12 += v28;
    }

    while (v14 < v4)
    {
      v34 = *v14;
      v35 = *(v14 + 16);
      *v14 = *v5;
      v36 = *(v14 + 8);
      *(v14 + 8) = *(v5 + 8);
      *(v14 + 12) = *(v5 + 12);
      *(v14 + 16) = *(v5 + 16);
      *v5 = v34;
      *(v5 + 8) = v36;
      *(v5 + 16) = v35;
      v14 += 24;
      v5 += 24;
    }

    v37 = v12 - v8;
    v38 = v5 - v12;
    if (v37 <= (v5 - v12))
    {
      v39 = v4 - v5;
      if ((v4 - v5) <= v38)
      {
        if (v37 == 24)
        {
          ++v7;
        }

        else if (v37 >= 25)
        {
          v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v9, v12, a3);
        }

        if (v39 == 24)
        {
          ++v7;
        }

        else if (v39 >= 25)
        {
          v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v5, v4, a3);
        }

        if (v38 == 24)
        {
          ++v7;
        }

        else if (v38 >= 25)
        {
          if (v11 == -1)
          {
            ++v7;
            v4 = v5;
            goto LABEL_60;
          }

          ++a3;
        }

        v4 = v5;
        v5 = v12;
        goto LABEL_60;
      }
    }

    if (v38 == 24)
    {
      goto LABEL_32;
    }

    if (v38 >= 25)
    {
      if (v10 == -1)
      {
LABEL_32:
        ++v7;
      }

      else
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v12, v5, a3 + 1);
      }
    }

    v40 = v4 - v5;
    if (v37 >= (v4 - v5))
    {
      if (v40 == 24)
      {
        ++v7;
      }

      else if (v40 >= 25)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v5, v4, a3);
      }

      v4 = v12;
      v5 = v9;
    }

    else if (v37 == 24)
    {
      ++v7;
    }

    else if (v37 >= 25)
    {
      v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v9, v12, a3);
    }

LABEL_60:
    v6 = v4 - v5;
    v8 = v5;
    v9 = v5;
  }

  while ((v4 - v5) > 240);
LABEL_64:
  if (v6 >= 25)
  {
    v7 += marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::ReverseKey *>(v5, v4, a3);
  }

  return v7;
}

uint64_t marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(a1 + 8) <= a4)
  {
    v4 = -1;
  }

  else
  {
    v4 = *(~a4 + *a1);
  }

  if (*(a2 + 8) <= a4)
  {
    v5 = -1;
  }

  else
  {
    v5 = *(~a4 + *a2);
  }

  if (*(a3 + 8) <= a4)
  {
    v6 = -1;
  }

  else
  {
    v6 = *(~a4 + *a3);
  }

  if (v4 <= v5)
  {
    v7 = v5;
  }

  else
  {
    v7 = v4;
  }

  if (v4 >= v5)
  {
    v4 = v5;
  }

  if (v4 <= v6)
  {
    v4 = v6;
  }

  if (v7 >= v6)
  {
    return v4;
  }

  else
  {
    return v7;
  }
}

uint64_t marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::ReverseKey *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  v3 = a1 + 24;
  if (a1 + 24 >= a2)
  {
    return 1;
  }

  v7 = 1;
  do
  {
    v8 = v3;
    if (v3 <= a1)
    {
      v15 = 0;
    }

    else
    {
      while (1)
      {
        v9 = v8 - 24;
        v10 = marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::ReverseKey>(v8 - 24, v8, a3);
        if (v10 < 1)
        {
          break;
        }

        v11 = *(v8 - 24);
        v12 = *(v8 - 8);
        *(v8 - 24) = *v8;
        v13 = *(v8 + 8);
        *(v8 - 8) = *(v8 + 16);
        *v8 = v11;
        v14 = *(v8 - 16);
        *(v8 - 16) = v13;
        *(v8 + 8) = v14;
        *(v8 + 16) = v12;
        v8 -= 24;
        if (v9 <= a1)
        {
          v10 = 1;
          break;
        }
      }

      v15 = v10 != 0;
    }

    v7 += v15;
    v3 += 24;
  }

  while (v3 < a2);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  v3 = *(a1 + 8);
  v4 = *(a2 + 8);
  v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4)
    {
      v12 = -1;
    }

    else
    {
      v12 = 1;
    }

    if (v3 == v4)
    {
      return 0;
    }

    else
    {
      return v12;
    }
  }

  else
  {
    v6 = v4 - a3;
    v7 = (*a2 + ~a3);
    v8 = (*a1 + ~a3);
    while (v6)
    {
      v9 = *v8;
      v10 = *v7;
      result = (v9 - v10);
      if (v9 != v10)
      {
        return result;
      }

      --v6;
      --v7;
      --v8;
      if (!--v5)
      {
        goto LABEL_6;
      }
    }

    return 1;
  }
}

char *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::realloc(uint64_t *a1, uint64_t a2)
{
  result = operator new[](12 * a2, MEMORY[0x1E69E5398]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (a1[1] + 8);
    v7 = result + 8;
    do
    {
      *(v7 - 1) = *(v6 - 1);
      v8 = *v6;
      v6 += 3;
      *v7 = v8;
      v7 += 3;
      --v5;
    }

    while (v5);
  }

  v9 = *a1;
  *a1 = result;
  a1[1] = result;
  a1[2] = result;
  a1[4] = a2;
  if (v9)
  {

    JUMPOUT(0x1B8C85310);
  }

  return result;
}

uint64_t marisa::grimoire::trie::Tail::build(__int128 *a1, uint64_t a2, __int128 *a3, int a4)
{
  if (!a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
    exception[2] = 0x20000000DLL;
    v17 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:13: MARISA_NULL_ERROR: offsets == NULL";
    goto LABEL_28;
  }

  if (a4 == 0x2000)
  {
    goto LABEL_15;
  }

  if (a4 != 4096)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
    exception[2] = 0x500000024;
    v17 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:36: MARISA_CODE_ERROR: undefined tail mode";
LABEL_28:
    exception[3] = v17;
  }

  v5 = *(a2 + 24);
  if (v5)
  {
    v6 = 0;
    a4 = 4096;
    while (1)
    {
      v7 = *(a2 + 8) + 16 * v6;
      v8 = *(v7 + 8);
      if (v8)
      {
        break;
      }

LABEL_11:
      if (++v6 == v5)
      {
        goto LABEL_15;
      }
    }

    v9 = *v7;
    v10 = -v8;
    while (*(v9 + 1 + v10))
    {
      if (__CFADD__(v10++, 1))
      {
        goto LABEL_11;
      }
    }

    a4 = 0x2000;
  }

  else
  {
    a4 = 4096;
  }

LABEL_15:
  memset(v18, 0, 41);
  memset(v19, 0, 41);
  v22 = 0u;
  memset(v23, 0, sizeof(v23));
  v24 = 0u;
  memset(v25, 0, sizeof(v25));
  v19[3] = 0u;
  v20 = 0u;
  memset(v21, 0, sizeof(v21));
  marisa::grimoire::trie::Tail::build_(v18, a2, a3, a4);
  v12 = *a1;
  *a1 = v18[0];
  v18[0] = v12;
  v13 = *(a1 + 2);
  *(a1 + 2) = *&v18[1];
  *&v18[1] = v13;
  v14 = *(a1 + 24);
  *(a1 + 24) = *(&v18[1] + 8);
  *(&v18[1] + 8) = v14;
  LOBYTE(v13) = *(a1 + 40);
  *(a1 + 40) = BYTE8(v18[2]);
  BYTE8(v18[2]) = v13;
  marisa::grimoire::vector::BitVector::swap((a1 + 3), v19);
  if (v24)
  {
    MEMORY[0x1B8C85310](v24, 0x1000C8077774924);
  }

  if (v22)
  {
    MEMORY[0x1B8C85310](v22, 0x1000C8077774924);
  }

  if (v20)
  {
    MEMORY[0x1B8C85310](v20, 0x1000C8077774924);
  }

  if (*&v19[0])
  {
    MEMORY[0x1B8C85310](*&v19[0], 0x1000C8077774924);
  }

  result = *&v18[0];
  if (*&v18[0])
  {
    return MEMORY[0x1B8C85310](*&v18[0], 0x1000C8077774924);
  }

  return result;
}

uint64_t marisa::grimoire::trie::Tail::build_(uint64_t a1, uint64_t a2, __int128 *a3, int a4)
{
  v8 = *(a2 + 24);
  v9 = *(a2 + 8);
  if (v8)
  {
    v10 = 0;
    v11 = vdupq_n_s64(v8 - 1);
    v12 = xmmword_1B5AE0050;
    v13 = xmmword_1B5AE0060;
    v14 = (v9 + 44);
    v15 = vdupq_n_s64(4uLL);
    do
    {
      v16 = vmovn_s64(vcgeq_u64(v11, v13));
      if (vuzp1_s16(v16, *v11.i8).u8[0])
      {
        *(v14 - 8) = v10;
      }

      if (vuzp1_s16(v16, *&v11).i8[2])
      {
        *(v14 - 4) = v10 + 1;
      }

      if (vuzp1_s16(*&v11, vmovn_s64(vcgeq_u64(v11, *&v12))).i32[1])
      {
        *v14 = v10 + 2;
        v14[4] = v10 + 3;
      }

      v10 += 4;
      v12 = vaddq_s64(v12, v15);
      v13 = vaddq_s64(v13, v15);
      v14 += 16;
    }

    while (((v8 + 3) & 0xFFFFFFFFFFFFFFFCLL) != v10);
  }

  marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v9, v9 + 16 * v8, 0);
  memset(v37, 0, 41);
  v17 = *(a2 + 24);
  LODWORD(v36[0]) = 0;
  marisa::grimoire::vector::Vector<unsigned int>::resize(v37, v17, v36);
  v36[0] = 0;
  v36[1] = 0;
  v18 = *(a2 + 24);
  if (v18)
  {
    v19 = v36;
    do
    {
      --v18;
      v20 = *(a2 + 8) + 16 * v18;
      v21 = *(v20 + 8);
      if (!v21)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        *exception = &unk_1F2D43298;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
        exception[2] = 0x4000000AALL;
        exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:170: MARISA_RANGE_ERROR: current.length() == 0";
      }

      v22 = 0;
      v23 = 0;
      v24 = *(v19 + 2);
      while (v24 != v23)
      {
        if (*(*v19 + v22) != *(*v20 + v22))
        {
          goto LABEL_19;
        }

        ++v23;
        --v22;
        if (v21 == v23)
        {
          goto LABEL_20;
        }
      }

      v23 = *(v19 + 2);
LABEL_19:
      if (v23 != v21)
      {
        v25 = *(&v37[0] + 1);
        goto LABEL_23;
      }

LABEL_20:
      v25 = *(&v37[0] + 1);
      if (v24)
      {
        *(*(&v37[0] + 1) + 4 * *(v20 + 12)) = v24 - v21 + *(*(&v37[0] + 1) + 4 * *(v19 + 3));
        goto LABEL_35;
      }

LABEL_23:
      *(v25 + 4 * *(v20 + 12)) = *(a1 + 24);
      v26 = *(v20 + 8);
      if (v26)
      {
        for (i = 0; i < v26; ++i)
        {
          v35 = *(*v20 - v26 + i + 1);
          marisa::grimoire::vector::Vector<char>::push_back(a1, &v35);
          v26 = *(v20 + 8);
        }

        if (a4 != 4096)
        {
          if (v26 >= 2)
          {
            v28 = 1;
            do
            {
              marisa::grimoire::vector::BitVector::push_back((a1 + 48), 0);
              ++v28;
            }

            while (v28 < *(v20 + 8));
          }

LABEL_33:
          marisa::grimoire::vector::BitVector::push_back((a1 + 48), 1);
          goto LABEL_34;
        }
      }

      else if (a4 != 4096)
      {
        goto LABEL_33;
      }

      v35 = 0;
      marisa::grimoire::vector::Vector<char>::push_back(a1, &v35);
LABEL_34:
      if (*(a1 + 28))
      {
        v34 = __cxa_allocate_exception(0x20uLL);
        *v34 = &unk_1F2D43298;
        v34[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
        v34[2] = 0x7000000C0;
        v34[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:192: MARISA_SIZE_ERROR: buf_.size() > MARISA_UINT32_MAX";
      }

LABEL_35:
      v19 = v20;
    }

    while (v18);
  }

  marisa::grimoire::vector::Vector<unsigned char>::shrink(a1);
  v29 = *a3;
  *a3 = v37[0];
  v37[0] = v29;
  v30 = *(a3 + 2);
  *(a3 + 2) = *&v37[1];
  *&v37[1] = v30;
  v31 = *(a3 + 24);
  *(a3 + 24) = *(&v37[1] + 8);
  *(&v37[1] + 8) = v31;
  LOBYTE(v30) = *(a3 + 40);
  *(a3 + 40) = BYTE8(v37[2]);
  result = v29;
  BYTE8(v37[2]) = v30;
  if (v29)
  {
    return MEMORY[0x1B8C85310](v29, 0x1000C8077774924);
  }

  return result;
}

void sub_1B5A9CC94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
  {
    MEMORY[0x1B8C85310](a13, 0x1000C8077774924);
  }

  _Unwind_Resume(exception_object);
}

uint64_t *marisa::grimoire::trie::Tail::restore(uint64_t *this, marisa::Agent *a2, unint64_t a3)
{
  v3 = a3;
  v4 = this;
  v5 = *(a2 + 5);
  if (this[12])
  {
    do
    {
      this = marisa::grimoire::vector::Vector<char>::push_back(v5, (v4[2] + v3));
      v6 = *(v4[8] + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v3;
      ++v3;
    }

    while ((v6 & 1) == 0);
  }

  else
  {
    v7 = (this[2] + a3);
    if (*v7)
    {
      do
      {
        this = marisa::grimoire::vector::Vector<char>::push_back(v5, v7);
      }

      while (*++v7);
    }
  }

  return this;
}

BOOL marisa::grimoire::trie::Tail::prefix_match(marisa::grimoire::trie::Tail *this, marisa::Agent *a2, unint64_t a3)
{
  v3 = a3;
  v6 = *(a2 + 5);
  if (*(this + 12))
  {
    v7 = *(v6 + 100);
    while (1)
    {
      v8 = *(this + 2);
      v9 = *(v8 + v3);
      v10 = *(*a2 + v7);
      v11 = v9 == v10;
      if (v9 != v10)
      {
        break;
      }

      marisa::grimoire::vector::Vector<char>::push_back(v6, (v8 + v3));
      v7 = *(v6 + 100) + 1;
      *(v6 + 100) = v7;
      if ((*(*(this + 8) + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v3))
      {
        break;
      }

      ++v3;
      if (*(a2 + 1) <= v7)
      {
        do
        {
          marisa::grimoire::vector::Vector<char>::push_back(v6, (*(this + 2) + v3));
          v12 = *(*(this + 8) + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v3;
          ++v3;
        }

        while ((v12 & 1) == 0);
        return 1;
      }
    }
  }

  else
  {
    v15 = *(this + 2) + a3;
    v13 = (v15 - *(v6 + 100));
    v14 = *v15;
    LODWORD(v15) = *(v6 + 100);
    while (1)
    {
      v16 = *(*a2 + v15);
      v11 = v14 == v16;
      if (v14 != v16)
      {
        break;
      }

      marisa::grimoire::vector::Vector<char>::push_back(v6, &v13[v15]);
      v15 = (*(v6 + 100) + 1);
      *(v6 + 100) = v15;
      v14 = v13[v15];
      if (!v13[v15])
      {
        break;
      }

      if (*(a2 + 1) <= v15)
      {
        v17 = &v13[v15];
        do
        {
          marisa::grimoire::vector::Vector<char>::push_back(v6, v17);
        }

        while (*++v17);
        return 1;
      }
    }
  }

  return v11;
}

uint64_t *marisa::grimoire::vector::Vector<unsigned int>::resize(uint64_t *result, unint64_t a2, int *a3)
{
  v4 = a2;
  v5 = result;
  v6 = result[4];
  if (v6 < a2)
  {
    v7 = 2 * v6;
    if (v6 >> 61)
    {
      v7 = 0x3FFFFFFFFFFFFFFFLL;
    }

    if (v6 > a2 >> 1)
    {
      a2 = v7;
    }

    result = marisa::grimoire::vector::Vector<unsigned int>::realloc(result, a2);
  }

  v8 = v5[3];
  v9 = v4 - v8;
  if (v4 > v8)
  {
    v10 = 0;
    v11 = *a3;
    v12 = vdupq_n_s64(v9 - 1);
    v13 = (v5[1] + 4 * v8 + 8);
    do
    {
      v14 = vdupq_n_s64(v10);
      v15 = vmovn_s64(vcgeq_u64(v12, vorrq_s8(v14, xmmword_1B5AE0060)));
      if (vuzp1_s16(v15, *v12.i8).u8[0])
      {
        *(v13 - 2) = v11;
      }

      if (vuzp1_s16(v15, *&v12).i8[2])
      {
        *(v13 - 1) = v11;
      }

      if (vuzp1_s16(*&v12, vmovn_s64(vcgeq_u64(v12, vorrq_s8(v14, xmmword_1B5AE0050)))).i32[1])
      {
        *v13 = v11;
        v13[1] = v11;
      }

      v10 += 4;
      v13 += 4;
    }

    while (((v9 + 3) & 0xFFFFFFFFFFFFFFFCLL) != v10);
  }

  v5[3] = v4;
  return result;
}

uint64_t marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  v4 = a2;
  v5 = a1;
  v6 = (a2 - a1) >> 4;
  if (v6 < 11)
  {
    v53 = 0;
    goto LABEL_77;
  }

  v53 = 0;
  v7 = a1;
  v8 = a1;
  do
  {
    v9 = marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Entry>(v8, v8 + 16 * (v6 >> 1), v4 - 16, a3);
    v10 = v9;
    v11 = v8;
    v5 = v4;
    v12 = v8;
    v13 = v4;
    while (v11 < v5)
    {
      v14 = *(v11 + 8);
      v15 = a3 >= v14 ? -1 : *(*v11 - a3);
      if (v15 > v9)
      {
        break;
      }

      if (v15 == v9)
      {
        v16 = *v11;
        v17 = *(v11 + 12);
        *v11 = *v12;
        *(v11 + 8) = *(v12 + 8);
        *v12 = v16;
        *(v12 + 8) = v14;
        *(v12 + 12) = v17;
        v12 += 16;
      }

LABEL_11:
      v11 += 16;
    }

    if (v11 < v5)
    {
      v18 = v5 - 16;
      do
      {
        v5 = v18;
        v19 = *(v18 + 8);
        if (a3 >= v19)
        {
          v20 = -1;
        }

        else
        {
          v20 = *(*v5 - a3);
        }

        if (v20 < v9)
        {
          break;
        }

        if (v20 == v9)
        {
          v21 = *(v13 - 16);
          v13 -= 16;
          v22 = *v5;
          v23 = *(v5 + 12);
          *v5 = v21;
          *(v5 + 8) = *(v13 + 8);
          *v13 = v22;
          *(v13 + 8) = v19;
          *(v13 + 12) = v23;
        }

        v18 = v5 - 16;
      }

      while (v11 < v5);
    }

    if (v11 < v5)
    {
      v24 = *v11;
      *v11 = *v5;
      v25 = *(v5 + 8);
      *v5 = v24;
      v26 = *(v11 + 8);
      *(v11 + 8) = v25;
      *(v5 + 8) = v26;
      goto LABEL_11;
    }

    while (v12 > v8)
    {
      v28 = *(v12 - 16);
      v12 -= 16;
      v27 = v28;
      v29 = *(v11 - 16);
      v11 -= 16;
      *v12 = v29;
      v30 = *(v11 + 8);
      *v11 = v27;
      v31 = *(v12 + 8);
      *(v12 + 8) = v30;
      *(v11 + 8) = v31;
    }

    while (v13 < v4)
    {
      v32 = *v13;
      *v13 = *v5;
      v33 = *(v5 + 8);
      *v5 = v32;
      v34 = *(v13 + 8);
      *(v13 + 8) = v33;
      *(v5 + 8) = v34;
      v13 += 16;
      v5 += 16;
    }

    v35 = v11 - v7;
    v36 = (v11 - v7) >> 4;
    v37 = v5 - v11;
    v38 = (v5 - v11) >> 4;
    if (v36 <= v38)
    {
      v39 = (v4 - v5) >> 4;
      if (v39 <= v38)
      {
        if (v35 == 16)
        {
          v42 = v53 + 1;
        }

        else
        {
          if (v36 < 2)
          {
LABEL_52:
            if (v4 - v5 == 16)
            {
              v44 = v53 + 1;
            }

            else
            {
              v44 = v53;
              if (v39 >= 2)
              {
                v45 = v4;
                v46 = v38;
                v47 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v5, v45, a3);
                v38 = v46;
                v44 = v47 + v53;
              }
            }

            if (v37 == 16)
            {
              v53 = v44 + 1;
              v4 = v5;
              v5 = v11;
            }

            else
            {
              if (v10 == -1)
              {
                v48 = v44 + 1;
              }

              else
              {
                v48 = v44;
              }

              if (v10 == -1)
              {
                v49 = a3;
              }

              else
              {
                v49 = a3 + 1;
              }

              if (v10 == -1)
              {
                v50 = v5;
              }

              else
              {
                v50 = v11;
              }

              if (v38 >= 2)
              {
                v44 = v48;
              }

              v53 = v44;
              if (v38 >= 2)
              {
                a3 = v49;
              }

              v4 = v5;
              if (v38 >= 2)
              {
                v5 = v50;
              }

              else
              {
                v5 = v11;
              }
            }

            goto LABEL_74;
          }

          v43 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v8, v11, a3);
          v39 = (v4 - v5) >> 4;
          v38 = (v5 - v11) >> 4;
          v42 = v43 + v53;
        }

        v53 = v42;
        goto LABEL_52;
      }
    }

    if (v37 == 16)
    {
      v40 = v53;
      goto LABEL_32;
    }

    v40 = v53;
    if (v38 >= 2)
    {
      if (v9 == -1)
      {
LABEL_32:
        ++v40;
      }

      else
      {
        v40 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v11, v5, a3 + 1) + v53;
      }
    }

    v41 = v4 - v5;
    if (v36 >= (v4 - v5) >> 4)
    {
      if (v41 == 16)
      {
        ++v40;
      }

      else if (v41 >> 4 >= 2)
      {
        v40 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v5, v4, a3);
      }

      v53 = v40;
      v4 = v11;
      v5 = v8;
    }

    else
    {
      if (v35 == 16)
      {
        ++v40;
      }

      else if (v36 >= 2)
      {
        v40 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v8, v11, a3);
      }

      v53 = v40;
    }

LABEL_74:
    v6 = (v4 - v5) >> 4;
    v7 = v5;
    v8 = v5;
  }

  while (v6 > 10);
LABEL_77:
  if (v6 < 2)
  {
    return v53;
  }

  else
  {
    return marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Entry *>(v5, v4, a3) + v53;
  }
}

uint64_t marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Entry>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(a1 + 8) <= a4)
  {
    v4 = -1;
  }

  else
  {
    v4 = *(*a1 - a4);
  }

  if (*(a2 + 8) <= a4)
  {
    v5 = -1;
  }

  else
  {
    v5 = *(*a2 - a4);
  }

  if (*(a3 + 8) <= a4)
  {
    v6 = -1;
  }

  else
  {
    v6 = *(*a3 - a4);
  }

  if (v4 <= v5)
  {
    v7 = v5;
  }

  else
  {
    v7 = v4;
  }

  if (v4 >= v5)
  {
    v4 = v5;
  }

  if (v4 <= v6)
  {
    v4 = v6;
  }

  if (v7 >= v6)
  {
    return v4;
  }

  else
  {
    return v7;
  }
}

uint64_t marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Entry *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  v3 = (a1 + 16);
  if (a1 + 16 >= a2)
  {
    return 1;
  }

  v7 = 1;
  do
  {
    v8 = v3;
    if (v3 <= a1)
    {
      v14 = 0;
    }

    else
    {
      while (1)
      {
        v9 = v8 - 2;
        v10 = marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Entry>((v8 - 2), v8, a3);
        if (v10 < 1)
        {
          break;
        }

        v11 = *(v8 - 2);
        *(v8 - 2) = *v8;
        v12 = v8[1];
        *v8 = v11;
        v13 = *(v8 - 1);
        *(v8 - 1) = v12;
        v8[1] = v13;
        v8 -= 2;
        if (v9 <= a1)
        {
          v10 = 1;
          break;
        }
      }

      v14 = v10 != 0;
    }

    v7 += v14;
    v3 += 2;
  }

  while (v3 < a2);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Entry>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  v3 = *(a1 + 8);
  v4 = *(a2 + 8);
  v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4)
    {
      v12 = -1;
    }

    else
    {
      v12 = 1;
    }

    if (v3 == v4)
    {
      return 0;
    }

    else
    {
      return v12;
    }
  }

  else
  {
    v6 = v4 - a3;
    v7 = (*a2 - a3);
    v8 = (*a1 - a3);
    while (v6)
    {
      v9 = *v8;
      v10 = *v7;
      result = (v9 - v10);
      if (v9 != v10)
      {
        return result;
      }

      --v6;
      --v7;
      --v8;
      if (!--v5)
      {
        goto LABEL_6;
      }
    }

    return 1;
  }
}

void marisa::grimoire::vector::BitVector::build_index(marisa::grimoire::vector::BitVector *this, const marisa::grimoire::vector::BitVector *a2, int a3, int a4)
{
  v8 = *(a2 + 6);
  if ((v8 & 0x1FF) != 0)
  {
    v9 = (v8 >> 9) + 1;
  }

  else
  {
    v9 = v8 >> 9;
  }

  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::resize(this + 8, v9 + 1);
  v10 = *(a2 + 6);
  if (!v10)
  {
    v12 = 0;
    goto LABEL_56;
  }

  v11 = 0;
  v12 = 0;
  for (i = 0; i < v10; ++i)
  {
    if ((i & 0x3F) != 0)
    {
      goto LABEL_24;
    }

    v14 = (i >> 6) & 7;
    v15 = *(this + 9) + 12 * (i >> 9);
    if (v14 <= 3)
    {
      if (((i >> 6) & 7) > 1)
      {
        if (v14 == 2)
        {
          v16 = *(v15 + 4) & 0xFFFF807F | ((v12 - *v15) << 7);
        }

        else
        {
          v16 = *(v15 + 4) & 0xFF807FFF | ((v12 - *v15) << 15);
        }
      }

      else
      {
        if (!v14)
        {
          *v15 = v12;
          goto LABEL_24;
        }

        v16 = *(v15 + 4) & 0xFFFFFF80 | (v12 - *v15) & 0x7F;
      }

      goto LABEL_21;
    }

    if (((i >> 6) & 7) > 5)
    {
      if (v14 == 6)
      {
        v17 = *(v15 + 8) & 0xFFFC01FF | (((v12 - *v15) & 0x1FF) << 9);
      }

      else
      {
        v17 = *(v15 + 8) & 0xF803FFFF | (((v12 - *v15) & 0x1FF) << 18);
      }
    }

    else
    {
      if (v14 == 4)
      {
        v16 = *(v15 + 4) & 0x7FFFFF | ((v12 - *v15) << 23);
LABEL_21:
        *(v15 + 4) = v16;
        goto LABEL_24;
      }

      v17 = *(v15 + 8) & 0xFFFFFE00 | (v12 - *v15) & 0x1FF;
    }

    *(v15 + 8) = v17;
LABEL_24:
    if ((*(*(a2 + 2) + 8 * (i >> 6)) >> (i & 0x3F)))
    {
      if (a4 && (v12 & 0x1FF) == 0)
      {
        v34 = i;
        marisa::grimoire::vector::Vector<unsigned int>::push_back(this + 20, &v34);
      }

      ++v12;
    }

    else
    {
      if (a3 && (v11 & 0x1FF) == 0)
      {
        v34 = i;
        marisa::grimoire::vector::Vector<unsigned int>::push_back(this + 14, &v34);
      }

      ++v11;
    }

    v10 = *(a2 + 6);
  }

  if ((v10 & 0x1FF) != 0)
  {
    v18 = (v10 - 1) >> 9;
    v19 = ((v10 - 1) >> 6) & 7;
    if (v19 <= 3)
    {
      if ((((v10 - 1) >> 6) & 7) > 1)
      {
        if (v19 == 2)
        {
          v20 = *(this + 9);
          v24 = (v20 + 12 * v18);
          v25 = v24[1];
          v22 = v12 - *v24;
          goto LABEL_49;
        }

        v20 = *(this + 9);
        v32 = (v20 + 12 * v18);
        v29 = v32[1];
        v22 = v12 - *v32;
      }

      else
      {
        if (v19)
        {
          v20 = *(this + 9);
          v28 = (v20 + 12 * v18);
          v23 = v28[1];
          v22 = v12 - *v28;
        }

        else
        {
          v20 = *(this + 9);
          v21 = (v20 + 12 * v18);
          v22 = v12 - *v21;
          v23 = v21[1] & 0xFFFFFF80 | v22 & 0x7F;
          v21[1] = v23;
        }

        v25 = v23 & 0xFFFF807F | (v22 << 7);
        *(v20 + 12 * v18 + 4) = v25;
LABEL_49:
        v29 = v25 & 0xFF807FFF | (v22 << 15);
        *(v20 + 12 * v18 + 4) = v29;
      }

      *(v20 + 12 * v18 + 4) = v29 & 0x7FFFFF | (v22 << 23);
LABEL_53:
      v33 = v20 + 12 * v18;
      v31 = *(v33 + 8) & 0xFFFFFE00 | v22 & 0x1FF;
      *(v33 + 8) = v31;
      goto LABEL_54;
    }

    if ((((v10 - 1) >> 6) & 7) > 5)
    {
      if (v19 != 7)
      {
        v20 = *(this + 9);
        v26 = (v20 + 12 * v18);
        v27 = v26[2];
        v22 = v12 - *v26;
        goto LABEL_55;
      }
    }

    else
    {
      if (v19 == 4)
      {
        v20 = *(this + 9);
        v22 = v12 - *(v20 + 12 * v18);
        goto LABEL_53;
      }

      v20 = *(this + 9);
      v30 = (v20 + 12 * v18);
      v31 = v30[2];
      v22 = v12 - *v30;
LABEL_54:
      v27 = v31 & 0xFFFC01FF | ((v22 & 0x1FF) << 9);
      *(v20 + 12 * v18 + 8) = v27;
LABEL_55:
      *(v20 + 12 * v18 + 8) = v27 & 0xF803FFFF | ((v22 & 0x1FF) << 18);
    }
  }

LABEL_56:
  *(this + 6) = v10;
  *(this + 7) = *(a2 + 7);
  *(*(this + 9) + 12 * *(this + 11) - 12) = v12;
  if (a3)
  {
    v34 = *(a2 + 6);
    marisa::grimoire::vector::Vector<unsigned int>::push_back(this + 14, &v34);
    marisa::grimoire::vector::Vector<unsigned int>::shrink(this + 28);
  }

  if (a4)
  {
    v34 = *(a2 + 6);
    marisa::grimoire::vector::Vector<unsigned int>::push_back(this + 20, &v34);
    marisa::grimoire::vector::Vector<unsigned int>::shrink(this + 40);
  }
}

uint64_t *marisa::grimoire::vector::Vector<unsigned int>::push_back(uint64_t *result, _DWORD *a2)
{
  v3 = result;
  v4 = result[3];
  v5 = result[4];
  v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    v7 = 2 * v5;
    if (v5 >> 61)
    {
      v7 = 0x3FFFFFFFFFFFFFFFLL;
    }

    if (v5 <= v6 >> 1)
    {
      v8 = v6;
    }

    else
    {
      v8 = v7;
    }

    result = marisa::grimoire::vector::Vector<unsigned int>::realloc(result, v8);
    v4 = v3[3];
    v6 = v4 + 1;
  }

  *(v3[1] + 4 * v4) = *a2;
  v3[3] = v6;
  return result;
}

_DWORD *marisa::grimoire::vector::Vector<unsigned int>::shrink(_DWORD *result)
{
  if (*(result + 40) == 1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/vector/vector.h";
    exception[2] = 0x100000064;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/vector/vector.h:100: MARISA_STATE_ERROR: fixed_";
  }

  v2 = *(result + 3);
  if (v2 != *(result + 4))
  {

    return marisa::grimoire::vector::Vector<unsigned int>::realloc(result, v2);
  }

  return result;
}

double marisa::Keyset::Keyset(marisa::Keyset *this)
{
  *(this + 12) = 0;
  result = 0.0;
  *(this + 4) = 0u;
  *(this + 5) = 0u;
  *(this + 2) = 0u;
  *(this + 3) = 0u;
  *this = 0u;
  *(this + 1) = 0u;
  return result;
}

size_t marisa::Keyset::reserve(size_t *this, size_t __sz)
{
  if (this[7] == this[11] >> 8)
  {
    marisa::Keyset::append_key_block(this);
  }

  if (__sz < 0x401)
  {
    v5 = this[10];
    if (v5 < __sz)
    {
      marisa::Keyset::append_base_block(this);
      v5 = this[10];
    }

    result = this[9];
    this[9] = result + __sz;
    this[10] = v5 - __sz;
  }

  else
  {
    marisa::Keyset::append_extra_block(this, __sz);
    return *(this[3] + 8 * this[4] - 8);
  }

  return result;
}

uint64_t marisa::Keyset::append_key_block(marisa::Keyset *this)
{
  v2 = *(this + 7);
  if (v2 == *(this + 8))
  {
    if (v2)
    {
      v3 = 2 * v2;
    }

    else
    {
      v3 = 1;
    }

    v4 = v3 >> 61 != 0;
    if (8 * v3 >= 0xFFFFFFFFFFFFFFF0)
    {
      v4 = 1;
    }

    if (v4)
    {
      v5 = -1;
    }

    else
    {
      v5 = 8 * v3 + 16;
    }

    v6 = operator new[](v5, MEMORY[0x1E69E5398]);
    if (!v6)
    {
      v20 = 0;
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &unk_1F2D43298;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      exception[2] = 0x8000000A9;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:169: MARISA_MEMORY_ERROR: new_blocks.get() == NULL";
    }

    *v6 = 8;
    v6[1] = v3;
    v7 = (v6 + 2);
    if (v3)
    {
      bzero(v6 + 2, 8 * v3);
    }

    v20 = v7;
    if (v2)
    {
      for (i = 0; i != v2; ++i)
      {
        v9 = *(this + 6);
        v10 = v20;
        v11 = *(v9 + 8 * i);
        *(v9 + 8 * i) = *(v20 + 8 * i);
        *(v10 + 8 * i) = v11;
      }

      v7 = v20;
    }

    v12 = *(this + 6);
    *(this + 6) = v7;
    v20 = v12;
    *(this + 8) = v3;
    marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array(&v20);
  }

  v13 = operator new[](0x1000uLL, MEMORY[0x1E69E5398]);
  if (!v13)
  {
    v18 = __cxa_allocate_exception(0x20uLL);
    *v18 = &unk_1F2D43298;
    v18[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    v18[2] = 0x8000000B1;
    v18[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:177: MARISA_MEMORY_ERROR: new_block.get() == NULL";
  }

  v14 = v13;
  bzero(v13, 0x1000uLL);
  v16 = *(this + 6);
  v15 = *(this + 7);
  *(this + 7) = v15 + 1;
  result = *(v16 + 8 * v15);
  *(v16 + 8 * v15) = v14;
  if (result)
  {
    return MEMORY[0x1B8C85310](result, 0x1050C80717B85FCLL);
  }

  return result;
}

void sub_1B5A9DC8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array(va);
  _Unwind_Resume(a1);
}

double marisa::Keyset::push_back(marisa::Keyset *this, const char *a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    exception[2] = 0x200000032;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:50: MARISA_NULL_ERROR: str == NULL";
  }

  v3 = 0;
    ;
  }

  *&result = marisa::Keyset::push_back(this, a2, v3 - 1, 1.0).u64[0];
  return result;
}

int64x2_t marisa::Keyset::push_back(marisa::Keyset *this, const char *a2, size_t __sz, float a4)
{
  v6 = a2;
  if (!a2 && __sz)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    exception[2] = 0x20000003DLL;
    v16 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:61: MARISA_NULL_ERROR: (ptr == NULL) && (length != 0)";
    goto LABEL_10;
  }

  if (HIDWORD(__sz))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    exception[2] = 0x70000003ELL;
    v16 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:62: MARISA_SIZE_ERROR: length > MARISA_UINT32_MAX";
LABEL_10:
    exception[3] = v16;
  }

  v8 = marisa::Keyset::reserve(this, __sz);
  if (__sz)
  {
    v9 = v8;
    v10 = __sz;
    do
    {
      v11 = *v6++;
      *v9++ = v11;
      --v10;
    }

    while (v10);
  }

  v12 = *(*(this + 6) + ((*(this + 11) >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * *(this + 11);
  *v12 = v8;
  *(v12 + 8) = __sz;
  *(v12 + 12) = a4;
  v13.i64[0] = vdupq_n_s64(1uLL).u64[0];
  v13.i64[1] = __sz;
  result = vaddq_s64(*(this + 88), v13);
  *(this + 88) = result;
  return result;
}

void *marisa::Keyset::append_extra_block(marisa::Keyset *this, size_t __sz)
{
  v4 = *(this + 4);
  if (v4 == *(this + 5))
  {
    if (v4)
    {
      v5 = 2 * v4;
    }

    else
    {
      v5 = 1;
    }

    v6 = v5 >> 61 != 0;
    if (8 * v5 >= 0xFFFFFFFFFFFFFFF0)
    {
      v6 = 1;
    }

    if (v6)
    {
      v7 = -1;
    }

    else
    {
      v7 = 8 * v5 + 16;
    }

    v8 = operator new[](v7, MEMORY[0x1E69E5398]);
    if (!v8)
    {
      v21 = 0;
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &unk_1F2D43298;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      exception[2] = 0x800000097;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:151: MARISA_MEMORY_ERROR: new_blocks.get() == NULL";
    }

    *v8 = 8;
    v8[1] = v5;
    v9 = (v8 + 2);
    if (v5)
    {
      bzero(v8 + 2, 8 * v5);
    }

    v21 = v9;
    if (v4)
    {
      for (i = 0; i != v4; ++i)
      {
        v11 = *(this + 3);
        v12 = v21;
        v13 = *(v11 + 8 * i);
        *(v11 + 8 * i) = *(v21 + 8 * i);
        *(v12 + 8 * i) = v13;
      }

      v9 = v21;
    }

    v14 = *(this + 3);
    *(this + 3) = v9;
    v21 = v14;
    *(this + 5) = v5;
    marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(&v21);
  }

  result = operator new[](__sz, MEMORY[0x1E69E5398]);
  if (!result)
  {
    v19 = __cxa_allocate_exception(0x20uLL);
    *v19 = &unk_1F2D43298;
    v19[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    v19[2] = 0x80000009FLL;
    v19[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:159: MARISA_MEMORY_ERROR: new_block.get() == NULL";
  }

  v17 = *(this + 3);
  v16 = *(this + 4);
  *(this + 4) = v16 + 1;
  v18 = *(v17 + 8 * v16);
  *(v17 + 8 * v16) = result;
  if (v18)
  {
    return MEMORY[0x1B8C85310](v18, 0x1000C8077774924);
  }

  return result;
}

void sub_1B5A9E084(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(va);
  _Unwind_Resume(a1);
}

uint64_t *marisa::Keyset::append_base_block(uint64_t *this)
{
  v1 = this;
  v2 = this[1];
  if (v2 == this[2])
  {
    if (v2)
    {
      v3 = 2 * v2;
    }

    else
    {
      v3 = 1;
    }

    v4 = v3 >> 61 != 0;
    if (8 * v3 >= 0xFFFFFFFFFFFFFFF0)
    {
      v4 = 1;
    }

    if (v4)
    {
      v5 = -1;
    }

    else
    {
      v5 = 8 * v3 + 16;
    }

    v6 = operator new[](v5, MEMORY[0x1E69E5398]);
    if (!v6)
    {
      v16 = 0;
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &unk_1F2D43298;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      exception[2] = 0x800000081;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:129: MARISA_MEMORY_ERROR: new_blocks.get() == NULL";
    }

    *v6 = 8;
    v6[1] = v3;
    v7 = (v6 + 2);
    if (v3)
    {
      bzero(v6 + 2, 8 * v3);
    }

    v16 = v7;
    if (v2)
    {
      for (i = 0; i != v2; ++i)
      {
        v9 = v16;
        v10 = *(*v1 + 8 * i);
        *(*v1 + 8 * i) = *(v16 + 8 * i);
        *(v9 + 8 * i) = v10;
      }

      v7 = v16;
    }

    v11 = *v1;
    *v1 = v7;
    v16 = v11;
    v1[2] = v3;
    this = marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(&v16);
    v2 = v1[1];
  }

  v12 = *v1;
  v13 = *(*v1 + 8 * v2);
  if (!v13)
  {
    this = operator new[](0x1000uLL, MEMORY[0x1E69E5398]);
    if (!this)
    {
      v15 = __cxa_allocate_exception(0x20uLL);
      *v15 = &unk_1F2D43298;
      v15[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      v15[2] = 0x80000008ALL;
      v15[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:138: MARISA_MEMORY_ERROR: new_block.get() == NULL";
    }

    *(v12 + 8 * v2) = this;
    v13 = *(*v1 + 8 * v2);
  }

  v1[1] = v2 + 1;
  v1[9] = v13;
  v1[10] = 4096;
  return this;
}

void sub_1B5A9E288(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(va);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::build(marisa::grimoire::trie::LoudsTrie **this, marisa::Keyset *a2, unsigned int a3)
{
  v6 = operator new(0x470uLL, MEMORY[0x1E69E5398]);
  if (!v6)
  {
    v11 = 0;
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &unk_1F2D43298;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x80000000ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:14: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }

  v7 = v6;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v6);
  v11 = v7;
  marisa::grimoire::trie::LoudsTrie::build(v7, a2, a3);
  v8 = *this;
  *this = v7;
  v11 = v8;
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::reverse_lookup(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  result = *this;
  if (result)
  {
    if (!*(a2 + 5))
    {
      marisa::Agent::init_state(a2);
      result = *this;
    }

    return marisa::grimoire::trie::LoudsTrie::reverse_lookup(result, a2);
  }

  return result;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::common_prefix_search(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  result = *this;
  if (result)
  {
    if (!*(a2 + 5))
    {
      marisa::Agent::init_state(a2);
      result = *this;
    }

    return marisa::grimoire::trie::LoudsTrie::common_prefix_search(result, a2);
  }

  return result;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::predictive_search(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  result = *this;
  if (result)
  {
    if (!*(a2 + 5))
    {
      marisa::Agent::init_state(a2);
      result = *this;
    }

    return marisa::grimoire::trie::LoudsTrie::predictive_search(result, a2);
  }

  return result;
}

google::protobuf::internal::LazyString *google::protobuf::internal::LazyString::Init(google::protobuf::internal::LazyString *this)
{
  {
    google::protobuf::internal::LazyString::Init();
  }

  std::mutex::lock(&google::protobuf::internal::LazyString::Init(void)const::mu);
  explicit = atomic_load_explicit(this + 3, memory_order_acquire);
  if (!explicit)
  {
    std::string::basic_string[abi:ne200100](this, *this, *(this + 1));
    atomic_store(this, this + 3);
    explicit = this;
  }

  std::mutex::unlock(&google::protobuf::internal::LazyString::Init(void)const::mu);
  return explicit;
}

void google::protobuf::internal::ArenaStringPtr::Set(std::string **a1, uint64_t a2, uint64_t a3, google::protobuf::internal::ArenaImpl *this)
{
  if (*a1 != a2)
  {

    JUMPOUT(0x1B8C84830);
  }

  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
    google::protobuf::internal::ArenaStringPtr::Set(this, a2, a3);
  }

  AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(this, 0x18uLL, google::protobuf::internal::arena_destruct_object<std::string>);
  v8 = AlignedAndAddCleanup;
  if (*(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(AlignedAndAddCleanup, *a3, *(a3 + 8));
  }

  else
  {
    v9 = *a3;
    AlignedAndAddCleanup->__r_.__value_.__r.__words[2] = *(a3 + 16);
    *&AlignedAndAddCleanup->__r_.__value_.__l.__data_ = v9;
  }

  *a1 = v8;
}

void google::protobuf::internal::ArenaStringPtr::Set(uint64_t *a1, uint64_t a2, uint64_t a3, google::protobuf::internal::ArenaImpl *this)
{
  v5 = *a1;
  if (*a1 == a2)
  {
    if (!this)
    {
      operator new();
    }

    if (*(this + 24))
    {
      v10 = this;
      google::protobuf::internal::ArenaStringPtr::Set(this, a2, a3);
      this = v10;
    }

    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(this, 0x18uLL, google::protobuf::internal::arena_destruct_object<std::string>);
    v9 = *(a3 + 16);
    *AlignedAndAddCleanup = *a3;
    AlignedAndAddCleanup[2] = v9;
    *(a3 + 8) = 0;
    *(a3 + 16) = 0;
    *a3 = 0;
    *a1 = AlignedAndAddCleanup;
  }

  else
  {
    if (*(v5 + 23) < 0)
    {
      operator delete(*v5);
    }

    v6 = *a3;
    *(v5 + 16) = *(a3 + 16);
    *v5 = v6;
    *(a3 + 23) = 0;
    *a3 = 0;
  }
}

void google::protobuf::internal::ArenaStringPtr::Set(std::string **a1, uint64_t a2, google::protobuf::internal::ArenaImpl *this)
{
  google::protobuf::internal::ArenaStringPtr::Set(a1, &google::protobuf::internal::fixed_address_empty_string, a2, this);
}

{
  google::protobuf::internal::ArenaStringPtr::Set(a1, 0, a2, this);
}

uint64_t *google::protobuf::internal::ArenaStringPtr::Mutable(void *a1, google::protobuf::internal::ArenaImpl *a2, uint64_t a3)
{
  if (*a1 == &google::protobuf::internal::fixed_address_empty_string)
  {
    return google::protobuf::internal::ArenaStringPtr::MutableSlow<>(a1, a2, a3);
  }

  else
  {
    return *a1;
  }
}

void *google::protobuf::internal::ArenaStringPtr::MutableSlow<>(void *a1, google::protobuf::internal::ArenaImpl *this, uint64_t a3)
{
  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
    google::protobuf::internal::ArenaStringPtr::Set(this, this, a3);
  }

  result = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(this, 0x18uLL, google::protobuf::internal::arena_destruct_object<std::string>);
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  *a1 = result;
  return result;
}

std::string *google::protobuf::internal::ArenaStringPtr::Mutable(std::string **this, atomic_ullong *a2, google::protobuf::Arena *a3)
{
  if (*this)
  {
    return *this;
  }

  else
  {
    return google::protobuf::internal::ArenaStringPtr::MutableSlow<google::protobuf::internal::LazyString>(this, a3, a2);
  }
}

std::string *google::protobuf::internal::ArenaStringPtr::MutableSlow<google::protobuf::internal::LazyString>(std::string **a1, google::protobuf::internal::ArenaImpl *this, atomic_ullong *a3)
{
  explicit = atomic_load_explicit(a3 + 3, memory_order_acquire);
  if (explicit)
  {
    if (this)
    {
      goto LABEL_3;
    }

LABEL_8:
    operator new();
  }

  explicit = google::protobuf::internal::LazyString::Init(a3);
  if (!this)
  {
    goto LABEL_8;
  }

LABEL_3:
  if (*(this + 24))
  {
    google::protobuf::internal::ArenaStringPtr::Set(this, this, a3);
  }

  AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(this, 0x18uLL, google::protobuf::internal::arena_destruct_object<std::string>);
  v7 = AlignedAndAddCleanup;
  if (*(explicit + 23) < 0)
  {
    std::string::__init_copy_ctor_external(AlignedAndAddCleanup, *explicit, *(explicit + 1));
  }

  else
  {
    v8 = *explicit;
    AlignedAndAddCleanup->__r_.__value_.__r.__words[2] = *(explicit + 2);
    *&AlignedAndAddCleanup->__r_.__value_.__l.__data_ = v8;
  }

  *a1 = v7;
  return v7;
}

std::string *google::protobuf::internal::ArenaStringPtr::ClearToDefault(std::string *result, atomic_ullong *this)
{
  v2 = result->__r_.__value_.__r.__words[0];
  if (result->__r_.__value_.__r.__words[0])
  {
    explicit = atomic_load_explicit(this + 3, memory_order_acquire);
    if (!explicit)
    {
      explicit = google::protobuf::internal::LazyString::Init(this);
    }

    return std::string::operator=(v2, explicit);
  }

  return result;
}

void google::protobuf::internal::arena_destruct_object<std::string>(uint64_t a1)
{
  if (*(a1 + 23) < 0)
  {
    operator delete(*a1);
  }
}

void google::protobuf::internal::LazyString::Init()
{
  {
    __cxa_atexit(google::protobuf::internal::WrappedMutex::~WrappedMutex, &google::protobuf::internal::LazyString::Init(void)const::mu, &dword_1B501D000);
  }
}

sentencepiece::bpe::Model *sentencepiece::bpe::Model::Model(sentencepiece::bpe::Model *this, const sentencepiece::ModelProto *a2)
{
  v4 = sentencepiece::ModelInterface::ModelInterface(this);
  *v4 = &unk_1F2D432C0;
  *(v4 + 1) = a2;
  sentencepiece::ModelInterface::InitializePieces(v4);
  return this;
}

sentencepiece::ModelInterface *sentencepiece::ModelInterface::ModelInterface(sentencepiece::ModelInterface *this)
{
  *this = &unk_1F2D43B60;
  *(this + 8) = 0u;
  *(this + 24) = 0u;
  *(this + 40) = 0u;
  *(this + 14) = 1065353216;
  *(this + 4) = 0u;
  *(this + 5) = 0u;
  *(this + 24) = 1065353216;
  *(this + 13) = 0;
  marisa::Trie::Trie(this + 14);
  return this;
}

void sub_1B5A9EB58(_Unwind_Exception *a1)
{
  v3 = v2;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(v3);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(v1 + 24);
  v5 = *(v1 + 16);
  *(v1 + 16) = 0;
  if (v5)
  {
    std::default_delete<sentencepiece::normalizer::PrefixMatcher>::operator()[abi:ne200100](v1 + 16, v5);
  }

  _Unwind_Resume(a1);
}

void sentencepiece::bpe::Model::~Model(sentencepiece::bpe::Model *this)
{
  sentencepiece::ModelInterface::~ModelInterface(this);

  JUMPOUT(0x1B8C85350);
}

void sentencepiece::bpe::Model::SampleEncode(uint64_t *a1@<X0>, _BYTE *a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>, float a5@<S0>)
{
  v70 = *MEMORY[0x1E69E9840];
  (*(*a1 + 16))(v56);
  if (*&v56[0])
  {
    sentencepiece::util::Status::~Status(v56);
LABEL_3:
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    return;
  }

  sentencepiece::util::Status::~Status(v56);
  if (!a3)
  {
    goto LABEL_3;
  }

  v64 = 0;
  v65 = 0;
  v66 = 0;
  __p = 0;
  v61 = 0uLL;
  if (a3 >> 59)
  {
    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  std::__split_buffer<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::Symbol,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::Symbol> &>::__split_buffer(v56, a3, 0, &__p);
  v10 = (*(&v56[0] + 1) - (v61 - __p));
  memcpy(v10, __p, v61 - __p);
  v11 = __p;
  v12 = *(&v61 + 1);
  __p = v10;
  v61 = v56[1];
  *&v56[1] = v11;
  *(&v56[1] + 1) = v12;
  *&v56[0] = v11;
  *(&v56[0] + 1) = v11;
  if (v11)
  {
    operator delete(v11);
  }

  memset(v58, 0, sizeof(v58));
  v59 = 1065353216;
  memset(v56 + 8, 0, 40);
  v57 = 256;
  v55[0] = a1;
  v55[1] = v56;
  v55[2] = &__p;
  v55[3] = &v64;
  v55[4] = v58;
  *&v56[0] = &unk_1F2D433C0;
  v13 = 1;
  do
  {
    v63 = 0uLL;
    v14 = sentencepiece::normalizer::PrefixMatcher::PrefixMatch(a1[2], a2, a3, &v62 + 8);
    *&v63 = a2;
    *(&v63 + 1) = v14;
    a3 -= v14;
    if (a3)
    {
      v15 = v13;
    }

    else
    {
      v15 = -1;
    }

    LODWORD(v62) = v13 - 2;
    DWORD1(v62) = v15;
    v16 = v61;
    if (v61 >= *(&v61 + 1))
    {
      v19 = (v61 - __p) >> 5;
      v20 = v19 + 1;
      if ((v19 + 1) >> 59)
      {
        std::vector<int>::__throw_length_error[abi:ne200100]();
      }

      v21 = *(&v61 + 1) - __p;
      if ((*(&v61 + 1) - __p) >> 4 > v20)
      {
        v20 = v21 >> 4;
      }

      if (v21 >= 0x7FFFFFFFFFFFFFE0)
      {
        v22 = 0x7FFFFFFFFFFFFFFLL;
      }

      else
      {
        v22 = v20;
      }

      std::__split_buffer<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::Symbol,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::Symbol> &>::__split_buffer(&v67, v22, v19, &__p);
      v23 = v69;
      v24 = v63;
      *v69 = v62;
      *(v23 + 16) = v24;
      *&v69 = v69 + 32;
      v25 = &v68[-(v61 - __p)];
      memcpy(v25, __p, v61 - __p);
      v26 = __p;
      v27 = *(&v61 + 1);
      __p = v25;
      v28 = v69;
      v61 = v69;
      *&v69 = v26;
      *(&v69 + 1) = v27;
      v67 = v26;
      v68 = v26;
      if (v26)
      {
        v54 = v28;
        operator delete(v26);
        v28 = v54;
      }

      v18 = v28;
    }

    else
    {
      v17 = v63;
      *v61 = v62;
      *(v16 + 16) = v17;
      v18 = (v16 + 32);
    }

    a2 += v14;
    *&v61 = v18;
    ++v13;
  }

  while (a3);
  if (__p != v18)
  {
    if ((v18 - __p) >= 0x21)
    {
      v29 = 1;
      do
      {
        sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)const::$_1::operator()(v55, v29 - 1, v29);
        ++v29;
      }

      while (v29 < (v61 - __p) >> 5);
    }

    v30 = v64;
    v31 = v65;
    if (v64 == v65)
    {
LABEL_55:
      *(&v63 + 1) = 0;
      operator new();
    }

    RandomGenerator = 0;
    while (1)
    {
      v33 = *v30;
      v34 = (v31 - v30) >> 3;
      if (v34 >= 2)
      {
        v35 = 0;
        v36 = v30;
        do
        {
          v37 = v36;
          v36 = (v36 + 8 * v35 + 8);
          v38 = 2 * v35;
          v35 = (2 * v35) | 1;
          v39 = v38 + 2;
          if (v39 < v34)
          {
            v40 = *(v36 + 1);
            v41 = *(*v36 + 8);
            v42 = *(v40 + 8);
            if (v41 < v42 || v41 == v42 && **v36 > *v40)
            {
              v36 = (v36 + 8);
              v35 = v39;
            }
          }

          *v37 = *v36;
        }

        while (v35 <= ((v34 - 2) >> 1));
        v43 = (v31 - 8);
        if (v36 == v43)
        {
          *v36 = v33;
        }

        else
        {
          *v36 = *v43;
          *v43 = v33;
          v30 = std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPairComparator &,std::__wrap_iter<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair **>>(v30, v36 + 8, ((v36 + 8) - v30) >> 3);
        }
      }

      v65 = (v65 - 8);
      v44 = *v33;
      v45 = *v33;
      v46 = __p;
      v47 = *(__p + 4 * v45 + 3);
      if (!v47)
      {
        goto LABEL_54;
      }

      v48 = v33[1];
      v49 = *(__p + 4 * v48 + 3);
      if (!v49 || v49 + v47 != *(v33 + 2))
      {
        goto LABEL_54;
      }

      if (a5 > 0.0)
      {
        if (a5 >= 1.0)
        {
          goto LABEL_54;
        }

        if (!RandomGenerator)
        {
          RandomGenerator = sentencepiece::random::GetRandomGenerator(v30);
        }

        v50 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(RandomGenerator);
        if ((v50 + std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(RandomGenerator) * 4294967300.0) * 5.42101086e-20 < a5)
        {
          goto LABEL_54;
        }

        v46 = __p;
        v44 = *v33;
        v48 = v33[1];
        v45 = *v33;
      }

      v51 = &v46[8 * v45];
      v52 = &v46[8 * v48];
      *(v51 + 3) += *(v52 + 3);
      v53 = *(v52 + 1);
      *(v51 + 1) = v53;
      if ((v53 & 0x80000000) == 0)
      {
        v46[8 * v53] = v44;
      }

      *(v52 + 2) = "";
      *(v52 + 3) = 0;
      sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)const::$_1::operator()(v55, *(__p + 8 * v45), v44);
      sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)const::$_1::operator()(v55, *v33, *(__p + 8 * *v33 + 1));
LABEL_54:
      v30 = v64;
      v31 = v65;
      if (v64 == v65)
      {
        goto LABEL_55;
      }
    }
  }

  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  sentencepiece::model::FreeList<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair>::~FreeList(v56);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(v58);
  if (__p)
  {
    *&v61 = __p;
    operator delete(__p);
  }

  if (v64)
  {
    v65 = v64;
    operator delete(v64);
  }
}

void sub_1B5A9F298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *__p, uint64_t a31, uint64_t a32, char a33)
{
  std::__function::__value_func<void ()(absl::string_view,std::vector<std::pair<absl::string_view,int>> *)>::~__value_func[abi:ne200100](&a33);
  sentencepiece::model::FreeList<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair>::~FreeList(&a18);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(&a25);
  if (__p)
  {
    a31 = __p;
    operator delete(__p);
  }

  v35 = *(v33 - 208);
  if (v35)
  {
    *(v33 - 200) = v35;
    operator delete(v35);
  }

  _Unwind_Resume(a1);
}

double sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)const::$_1::operator()(uint64_t a1, int a2, int a3)
{
  if (a2 != -1)
  {
    v35 = v3;
    v36 = v4;
    if (a3 != -1)
    {
      v8 = a2;
      v9 = **(a1 + 16);
      v10 = v9 + 32 * a2;
      if ((*(v10 + 8) & 1) == 0)
      {
        v11 = a3;
        v12 = v9 + 32 * a3;
        if ((*(v12 + 8) & 1) == 0)
        {
          v13 = *a1;
          v14 = *(v10 + 16);
          v15 = *(v12 + 24) + *(v10 + 24);
          v32 = v14;
          v33 = v15;
          v16 = std::__hash_table<std::__hash_value_type<absl::string_view,int>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,int>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,int>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,int>>>::find<absl::string_view>(v13 + 3, &v32);
          if (v16)
          {
            v18 = v16;
            v19 = *(a1 + 8);
            v20 = v19[5];
            v21 = v19[6];
            v22 = v19[4];
            if (v22 >= v21)
            {
              v22 = 0;
              ++v20;
              v19[4] = 0;
              v19[5] = v20;
            }

            v23 = v19[1];
            if (v20 == (v19[2] - v23) >> 3)
            {
              is_mul_ok(v21, 0x18uLL);
              operator new[]();
            }

            v24 = *(v23 + 8 * v20) + 24 * v22;
            v19[4] = v22 + 1;
            v31 = v24;
            *v24 = a2;
            *(v24 + 4) = a3;
            *(v24 + 8) = (*(*v13 + 152))(v13, *(v16 + 8));
            *(v24 + 16) = v33;
            v25 = *(a1 + 24);
            std::vector<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair *,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair *>>::push_back[abi:ne200100](v25, &v31);
            std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPairComparator &,std::__wrap_iter<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair **>>(*v25, v25[1], (v25[1] - *v25) >> 3);
            if (*(*(*(v13[1] + 64) + 8 * *(v18 + 8) + 8) + 60) == 5)
            {
              v26 = **(a1 + 16);
              v29 = *(v26 + 32 * v8 + 16);
              v30 = *(v26 + 32 * v11 + 16);
              v27 = *(a1 + 32);
              v34 = &v32;
              v28 = std::__hash_table<std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>>>::__emplace_unique_key_args<absl::string_view,std::piecewise_construct_t const&,std::tuple<absl::string_view const&>,std::tuple<>>(v27, &v32);
              result = *&v29;
              *(v28 + 2) = v29;
              *(v28 + 3) = v30;
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t std::function<void ()(absl::string_view,std::vector<std::pair<absl::string_view,int>> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v7[0] = a2;
  v7[1] = a3;
  v6 = a4;
  v4 = *(a1 + 24);
  if (!v4)
  {
    std::__throw_bad_function_call[abi:ne200100]();
  }

  return (*(*v4 + 48))(v4, v7, &v6);
}

void *sentencepiece::model::FreeList<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair>::~FreeList(void *a1)
{
  *a1 = &unk_1F2D433C0;
  v2 = a1[1];
  v3 = a1[2];
  if (v2 != v3)
  {
    do
    {
      if (*v2)
      {
        MEMORY[0x1B8C85310](*v2, 0x1000C801E56706BLL);
      }

      ++v2;
    }

    while (v2 != v3);
    v2 = a1[1];
  }

  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  return a1;
}

void sentencepiece::ModelInterface::NBestEncode(sentencepiece::logging *a1@<X0>, void *a2@<X8>)
{
  if (sentencepiece::logging::GetMinLogLevel(a1) <= 2)
  {
    v10 = 0;
    v3 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "model_interface.h", 17);
    v4 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v3, "(", 1);
    v5 = MEMORY[0x1B8C84C00](v4, 100);
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v5, ") ", 2);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, "LOG(", 4);
    v8 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v7, "ERROR", 5);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, ") ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "Not implemented.", 16);
    sentencepiece::error::Die::~Die(&v10);
  }

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

void sentencepiece::ModelInterface::SampleEncodeAndScore(sentencepiece::logging *a1@<X0>, void *a2@<X8>)
{
  v14 = *MEMORY[0x1E69E9840];
  if (sentencepiece::logging::GetMinLogLevel(a1) <= 2)
  {
    LOBYTE(__p) = 0;
    v3 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "model_interface.h", 17);
    v4 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v3, "(", 1);
    v5 = MEMORY[0x1B8C84C00](v4, 121);
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v5, ") ", 2);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, "LOG(", 4);
    v8 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v7, "ERROR", 5);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, ") ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "Not implemented.", 16);
    sentencepiece::error::Die::~Die(&__p);
  }

  __p = 0;
  v11 = 0;
  v13 = 0;
  v12 = 0;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__init_with_size[abi:ne200100]<std::pair<std::vector<std::pair<absl::string_view,int>>,float> const*,std::pair<std::vector<std::pair<absl::string_view,int>>,float> const*>(a2, &__p, &v14, 1uLL);
  if (__p)
  {
    v11 = __p;
    operator delete(__p);
  }
}

void sub_1B5A9F880(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

double sentencepiece::ModelInterface::CalculateEntropy(sentencepiece::logging *a1)
{
  if (sentencepiece::logging::GetMinLogLevel(a1) <= 2)
  {
    v9 = 0;
    v1 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "model_interface.h", 17);
    v2 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v1, "(", 1);
    v3 = MEMORY[0x1B8C84C00](v2, 130);
    v4 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v3, ") ", 2);
    v5 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v4, "LOG(", 4);
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v5, "ERROR", 5);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, ") ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v7, "Not implemented.", 16);
    sentencepiece::error::Die::~Die(&v9);
  }

  return 0.0;
}

uint64_t sentencepiece::ModelInterface::GetPieceSize(sentencepiece::ModelInterface *this)
{
  v1 = *(this + 1);
  if (v1)
  {
    return *(v1 + 56);
  }

  else
  {
    return 0;
  }
}

uint64_t sentencepiece::ModelInterface::ByteFallbackEnabled(sentencepiece::ModelInterface *this)
{
  v1 = *(this + 1);
  if (v1)
  {
    v1 = v1[9];
    if (!v1)
    {
      v1 = &sentencepiece::_TrainerSpec_default_instance_;
    }

    LOBYTE(v1) = *(v1 + 239);
  }

  return v1 & 1;
}

BOOL sentencepiece::ModelInterface::VerifyOutputsEquivalent(int a1, void *__s1, size_t a3, void *__s2, uint64_t a5)
{
  if (a3 != a5)
  {
    return 0;
  }

  result = 1;
  if (a3)
  {
    if (__s1 != __s2)
    {
      return memcmp(__s1, __s2, a3) == 0;
    }
  }

  return result;
}

void std::default_delete<sentencepiece::normalizer::PrefixMatcher>::operator()[abi:ne200100](uint64_t a1, uint64_t *a2)
{
  if (a2)
  {
    v2 = *a2;
    *a2 = 0;
    if (v2)
    {
      (*(*v2 + 8))(v2);
    }

    JUMPOUT(0x1B8C85350);
  }
}

void *std::__hash_table<std::__hash_value_type<absl::string_view,int>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,int>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,int>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,int>>>::find<absl::string_view>(void *a1, char **a2)
{
  v4 = a2[1];
  if (v4)
  {
    v5 = *a2;
    v6 = 5381;
    do
    {
      v7 = *v5++;
      v6 = 33 * v6 + v7;
      --v4;
    }

    while (v4);
  }

  else
  {
    v6 = 5381;
  }

  v8 = a1[1];
  if (!*&v8)
  {
    return 0;
  }

  v9 = vcnt_s8(v8);
  v9.i16[0] = vaddlv_u8(v9);
  v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    v11 = v6;
    if (v6 >= *&v8)
    {
      v11 = v6 % *&v8;
    }
  }

  else
  {
    v11 = (*&v8 - 1) & v6;
  }

  v12 = *(*a1 + 8 * v11);
  if (!v12)
  {
    return 0;
  }

  v13 = *v12;
  if (*v12)
  {
    do
    {
      v14 = v13[1];
      if (v6 == v14)
      {
        if (std::equal_to<absl::string_view>::operator()[abi:ne200100](a1, (v13 + 2), a2))
        {
          return v13;
        }
      }

      else
      {
        if (v10 > 1)
        {
          if (v14 >= *&v8)
          {
            v14 %= *&v8;
          }
        }

        else
        {
          v14 &= *&v8 - 1;
        }

        if (v14 != v11)
        {
          return 0;
        }
      }

      v13 = *v13;
    }

    while (v13);
  }

  return v13;
}

BOOL std::equal_to<absl::string_view>::operator()[abi:ne200100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a2 + 8);
  if (v4 != *(a3 + 8))
  {
    return 0;
  }

  v5 = *a2;
  v6 = *a3;
  if (v4)
  {
    v7 = v5 == v6;
  }

  else
  {
    v7 = 1;
  }

  return v7 || memcmp(v5, v6, v4) == 0;
}

void std::vector<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair *,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair *>>::push_back[abi:ne200100](uint64_t a1, void *a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (v4 >= v3)
  {
    v6 = *a1;
    v7 = v4 - *a1;
    v8 = (v7 >> 3) + 1;
    if (v8 >> 61)
    {
      std::vector<int>::__throw_length_error[abi:ne200100]();
    }

    v9 = v3 - v6;
    if (v9 >> 2 > v8)
    {
      v8 = v9 >> 2;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFF8)
    {
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      if (!(v10 >> 61))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    v11 = (8 * (v7 >> 3));
    *v11 = *a2;
    v5 = v11 + 1;
    memcpy(0, v6, v7);
    *a1 = 0;
    *(a1 + 8) = v5;
    *(a1 + 16) = 0;
    if (v6)
    {
      operator delete(v6);
    }
  }

  else
  {
    *v4 = *a2;
    v5 = v4 + 1;
  }

  *(a1 + 8) = v5;
}

uint64_t std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPairComparator &,std::__wrap_iter<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair **>>(uint64_t result, uint64_t a2, uint64_t a3)
{
  v3 = a3 - 2;
  if (a3 >= 2)
  {
    v4 = v3 >> 1;
    v5 = (result + 8 * (v3 >> 1));
    v6 = *v5;
    v7 = *(a2 - 8);
    v8 = *(*v5 + 8);
    v9 = *(v7 + 8);
    if (v8 < v9 || v8 == v9 && *v6 > *v7)
    {
      *(a2 - 8) = v6;
      if (v3 >= 2)
      {
        v10 = (result + 8 * (v3 >> 1));
        while (1)
        {
          v11 = v4 - 1;
          v4 = (v4 - 1) >> 1;
          v5 = (result + 8 * v4);
          v12 = *v5;
          v13 = *(*v5 + 8);
          if (v13 >= v9 && (v13 != v9 || *v12 <= *v7))
          {
            break;
          }

          *v10 = v12;
          v10 = (result + 8 * v4);
          if (v11 <= 1)
          {
            goto LABEL_13;
          }
        }

        v5 = v10;
      }

LABEL_13:
      *v5 = v7;
    }
  }

  return result;
}

void *std::__hash_table<std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>>>::__emplace_unique_key_args<absl::string_view,std::piecewise_construct_t const&,std::tuple<absl::string_view const&>,std::tuple<>>(void *a1, char **a2)
{
  v4 = a2[1];
  if (v4)
  {
    v5 = *a2;
    v6 = 5381;
    do
    {
      v7 = *v5++;
      v6 = 33 * v6 + v7;
      --v4;
    }

    while (v4);
  }

  else
  {
    v6 = 5381;
  }

  v8 = a1[1];
  if (!*&v8)
  {
    goto LABEL_23;
  }

  v9 = vcnt_s8(v8);
  v9.i16[0] = vaddlv_u8(v9);
  v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    v11 = v6;
    if (v6 >= *&v8)
    {
      v11 = v6 % *&v8;
    }
  }

  else
  {
    v11 = (*&v8 - 1) & v6;
  }

  v12 = *(*a1 + 8 * v11);
  if (!v12 || (v13 = *v12) == 0)
  {
LABEL_23:
    operator new();
  }

  while (1)
  {
    v14 = v13[1];
    if (v14 == v6)
    {
      break;
    }

    if (v10 > 1)
    {
      if (v14 >= *&v8)
      {
        v14 %= *&v8;
      }
    }

    else
    {
      v14 &= *&v8 - 1;
    }

    if (v14 != v11)
    {
      goto LABEL_23;
    }

LABEL_22:
    v13 = *v13;
    if (!v13)
    {
      goto LABEL_23;
    }
  }

  if (!std::equal_to<absl::string_view>::operator()[abi:ne200100](a1, (v13 + 2), a2))
  {
    goto LABEL_22;
  }

  return v13;
}

void sentencepiece::error::Die::~Die(sentencepiece::error::Die *this)
{
  std::ios_base::getloc((MEMORY[0x1E69E5300] + *(*MEMORY[0x1E69E5300] - 24)));
  v2 = std::locale::use_facet(&v4, MEMORY[0x1E69E5318]);
  (v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  v3 = std::ostream::flush();
  if (*this == 1)
  {
    sentencepiece::error::Abort(v3);
  }
}

uint64_t std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__init_with_size[abi:ne200100]<std::pair<std::vector<std::pair<absl::string_view,int>>,float> const*,std::pair<std::vector<std::pair<absl::string_view,int>>,float> const*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<quasar::TextTokenizer::TokenString>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1B5AA0240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>,std::pair<std::vector<std::pair<absl::string_view,int>>,float> const*,std::pair<std::vector<std::pair<absl::string_view,int>>,float> const*,std::pair<std::vector<std::pair<absl::string_view,int>>,float>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      *(v4 + 8) = 0;
      *(v4 + 16) = 0;
      std::vector<std::pair<absl::string_view,int>>::__init_with_size[abi:ne200100]<std::pair<absl::string_view,int>*,std::pair<absl::string_view,int>*>(v4, *v6, *(v6 + 8), 0xAAAAAAAAAAAAAAABLL * ((*(v6 + 8) - *v6) >> 3));
      *(v4 + 24) = *(v6 + 24);
      v6 += 32;
      v4 = v11 + 32;
      v11 += 32;
    }

    while (v6 != a3);
  }

  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>,std::pair<std::vector<std::pair<absl::string_view,int>>,float>*>>::~__exception_guard_exceptions[abi:ne200100](v8);
  return v4;
}

uint64_t std::vector<std::pair<absl::string_view,int>>::__init_with_size[abi:ne200100]<std::pair<absl::string_view,int>*,std::pair<absl::string_view,int>*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<std::pair<absl::string_view,int>>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1B5AA038C(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<absl::string_view,int>>::__vallocate[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (a2 < 0xAAAAAAAAAAAAAABLL)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(a1, a2);
  }

  std::vector<int>::__throw_length_error[abi:ne200100]();
}

void std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(uint64_t a1, unint64_t a2)
{
  if (a2 < 0xAAAAAAAAAAAAAABLL)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>,std::pair<std::vector<std::pair<absl::string_view,int>>,float>*>>::~__exception_guard_exceptions[abi:ne200100](uint64_t a1)
{
  if ((*(a1 + 24) & 1) == 0)
  {
    std::_AllocatorDestroyRangeReverse<std::allocator<fst::IntervalSet<int>>,fst::IntervalSet<int>*>::operator()[abi:ne200100](a1);
  }

  return a1;
}

void *std::__split_buffer<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::Symbol,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::Symbol> &>::__split_buffer(void *result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  result[3] = 0;
  result[4] = a4;
  if (a2)
  {
    if (!(a2 >> 59))
    {
      operator new();
    }

    std::__throw_bad_array_new_length[abi:ne200100]();
  }

  *result = 0;
  result[1] = 32 * a3;
  result[2] = 32 * a3;
  result[3] = 0;
  return result;
}

void sentencepiece::model::FreeList<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair>::~FreeList(void *a1)
{
  sentencepiece::model::FreeList<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair>::~FreeList(a1);

  JUMPOUT(0x1B8C85350);
}

uint64_t std::__function::__value_func<void ()(absl::string_view,std::vector<std::pair<absl::string_view,int>> *)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

__n128 std::__function::__func<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::$_0,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::$_0>,void ()(absl::string_view,std::vector<std::pair<absl::string_view,int>> *)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2D433F0;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void std::__function::__func<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::$_0,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::$_0>,void ()(absl::string_view,std::vector<std::pair<absl::string_view,int>> *)>::operator()(uint64_t a1, void *a2, uint64_t *a3)
{
  v4 = a2[1];
  v5 = *a3;
  *&v22 = *a2;
  *(&v22 + 1) = v4;
  v6 = *(a1 + 8);
  v7 = (*(*v6 + 128))(v6, v22, v4);
  v8 = v7;
  if (v7 != -1 && *(*(*(v6[1] + 64) + 8 * v7 + 8) + 60) == 5 && (v9 = std::__hash_table<std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>>>::find<absl::string_view>(*(a1 + 24), &v22)) != 0)
  {
    v10 = v9;
    std::function<void ()(absl::string_view,std::vector<std::pair<absl::string_view,int>> *)>::operator()(*(a1 + 16), v10[4], v10[5], v5);
    std::function<void ()(absl::string_view,std::vector<std::pair<absl::string_view,int>> *)>::operator()(*(a1 + 16), v10[6], v10[7], v5);
  }

  else
  {
    v12 = *(v5 + 8);
    v11 = *(v5 + 16);
    if (v12 >= v11)
    {
      v14 = 0xAAAAAAAAAAAAAAABLL * ((v12 - *v5) >> 3);
      v15 = v14 + 1;
      if (v14 + 1 > 0xAAAAAAAAAAAAAAALL)
      {
        std::vector<int>::__throw_length_error[abi:ne200100]();
      }

      v16 = 0xAAAAAAAAAAAAAAABLL * ((v11 - *v5) >> 3);
      if (2 * v16 > v15)
      {
        v15 = 2 * v16;
      }

      if (v16 >= 0x555555555555555)
      {
        v17 = 0xAAAAAAAAAAAAAAALL;
      }

      else
      {
        v17 = v15;
      }

      if (v17)
      {
        std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(v5, v17);
      }

      v18 = 24 * v14;
      *v18 = v22;
      *(v18 + 16) = v8;
      v13 = 24 * v14 + 24;
      v19 = *(v5 + 8) - *v5;
      v20 = v18 - v19;
      memcpy((v18 - v19), *v5, v19);
      v21 = *v5;
      *v5 = v20;
      *(v5 + 8) = v13;
      *(v5 + 16) = 0;
      if (v21)
      {
        operator delete(v21);
      }
    }

    else
    {
      *v12 = v22;
      *(v12 + 16) = v8;
      v13 = v12 + 24;
    }

    *(v5 + 8) = v13;
  }
}

uint64_t std::__function::__func<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::$_0,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::$_0>,void ()(absl::string_view,std::vector<std::pair<absl::string_view,int>> *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void *std::__hash_table<std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,std::pair<absl::string_view,absl::string_view>>>>::find<absl::string_view>(void *a1, char **a2)
{
  v4 = a2[1];
  if (v4)
  {
    v5 = *a2;
    v6 = 5381;
    do
    {
      v7 = *v5++;
      v6 = 33 * v6 + v7;
      --v4;
    }

    while (v4);
  }

  else
  {
    v6 = 5381;
  }

  v8 = a1[1];
  if (!*&v8)
  {
    return 0;
  }

  v9 = vcnt_s8(v8);
  v9.i16[0] = vaddlv_u8(v9);
  v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    v11 = v6;
    if (v6 >= *&v8)
    {
      v11 = v6 % *&v8;
    }
  }

  else
  {
    v11 = (*&v8 - 1) & v6;
  }

  v12 = *(*a1 + 8 * v11);
  if (!v12)
  {
    return 0;
  }

  v13 = *v12;
  if (*v12)
  {
    do
    {
      v14 = v13[1];
      if (v14 == v6)
      {
        if (std::equal_to<absl::string_view>::operator()[abi:ne200100](a1, (v13 + 2), a2))
        {
          return v13;
        }
      }

      else
      {
        if (v10 > 1)
        {
          if (v14 >= *&v8)
          {
            v14 %= *&v8;
          }
        }

        else
        {
          v14 &= *&v8 - 1;
        }

        if (v14 != v11)
        {
          return 0;
        }
      }

      v13 = *v13;
    }

    while (v13);
  }

  return v13;
}

void *std::__function::__value_func<void ()(absl::string_view,std::vector<std::pair<absl::string_view,int>> *)>::swap[abi:ne200100](void *result, void *a2)
{
  v5[3] = *MEMORY[0x1E69E9840];
  if (a2 != result)
  {
    v3 = result;
    result = result[3];
    v4 = a2[3];
    if (result == v3)
    {
      if (v4 == a2)
      {
        (*(*result + 24))(result, v5);
        (*(*v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(*a2[3] + 24))(a2[3], v3);
        (*(*a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(v5[0] + 24))(v5, a2);
        result = (*(v5[0] + 32))(v5);
      }

      else
      {
        (*(*result + 24))(result, a2);
        result = (*(*v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v4 == a2)
    {
      (*(*v4 + 24))(a2[3], v3);
      result = (*(*a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      v3[3] = v4;
      a2[3] = result;
    }
  }

  return result;
}

void sub_1B5AA0BD0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
  {
    _Unwind_Resume(a1);
  }

  __clang_call_terminate(a1);
}

void InitDefaultsscc_info_NBestSentencePieceText_sentencepiece_2eproto(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  google::protobuf::internal::VerifyVersion(0x2DFD70, 0x2DFD70, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/builtin_pb/sentencepiece.pb.cc", a4);
  sentencepiece::NBestSentencePieceText::NBestSentencePieceText(&sentencepiece::_NBestSentencePieceText_default_instance_, 0);

  google::protobuf::internal::OnShutdownRun(google::protobuf::internal::DestroyMessage, &sentencepiece::_NBestSentencePieceText_default_instance_, v4);
}

void InitDefaultsscc_info_SentencePieceText_sentencepiece_2eproto(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  google::protobuf::internal::VerifyVersion(0x2DFD70, 0x2DFD70, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/builtin_pb/sentencepiece.pb.cc", a4);
  sentencepiece::SentencePieceText::SentencePieceText(&sentencepiece::_SentencePieceText_default_instance_, 0);

  google::protobuf::internal::OnShutdownRun(google::protobuf::internal::DestroyMessage, &sentencepiece::_SentencePieceText_default_instance_, v4);
}

void InitDefaultsscc_info_SentencePieceText_SentencePiece_sentencepiece_2eproto(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  google::protobuf::internal::VerifyVersion(0x2DFD70, 0x2DFD70, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/builtin_pb/sentencepiece.pb.cc", a4);
  sentencepiece::SentencePieceText_SentencePiece::SentencePieceText_SentencePiece(&sentencepiece::_SentencePieceText_SentencePiece_default_instance_, 0);

  google::protobuf::internal::OnShutdownRun(google::protobuf::internal::DestroyMessage, &sentencepiece::_SentencePieceText_SentencePiece_default_instance_, v4);
}

uint64_t sentencepiece::SentencePieceText_SentencePiece::SentencePieceText_SentencePiece(uint64_t a1, uint64_t a2)
{
  *a1 = &unk_1F2D43480;
  *(a1 + 8) = a2;
  google::protobuf::internal::ExtensionSet::ExtensionSet(a1 + 16, a2);
  *(a1 + 40) = 0;
  if (atomic_load_explicit(scc_info_SentencePieceText_SentencePiece_sentencepiece_2eproto, memory_order_acquire))
  {
    google::protobuf::internal::InitSCCImpl(scc_info_SentencePieceText_SentencePiece_sentencepiece_2eproto);
  }

  *(a1 + 48) = &google::protobuf::internal::fixed_address_empty_string;
  *(a1 + 56) = &google::protobuf::internal::fixed_address_empty_string;
  *(a1 + 64) = 0;
  *(a1 + 72) = 0;
  return a1;
}

void sentencepiece::SentencePieceText_SentencePiece::~SentencePieceText_SentencePiece(sentencepiece::SentencePieceText_SentencePiece *this)
{
  v2 = *(this + 6);
  if (v2 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v2 + 23) < 0)
    {
      operator delete(*v2);
    }

    MEMORY[0x1B8C85350](v2, 0x1012C40EC159624);
  }

  v3 = *(this + 7);
  if (v3 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v3 + 23) < 0)
    {
      operator delete(*v3);
    }

    MEMORY[0x1B8C85350](v3, 0x1012C40EC159624);
  }

  google::protobuf::internal::InternalMetadata::Delete<std::string>(this + 1);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((this + 16));
}

{
  sentencepiece::SentencePieceText_SentencePiece::~SentencePieceText_SentencePiece(this);

  JUMPOUT(0x1B8C85350);
}

uint64_t *google::protobuf::internal::InternalMetadata::Delete<std::string>(uint64_t *result)
{
  v1 = *result;
  if (*result)
  {
    v2 = v1 & 0xFFFFFFFFFFFFFFFELL;
    if (!*(v1 & 0xFFFFFFFFFFFFFFFELL) && v2 != 0)
    {
      if (*(v2 + 31) < 0)
      {
        operator delete(*(v2 + 8));
      }

      JUMPOUT(0x1B8C85350);
    }
  }

  return result;
}

unsigned __int8 *sentencepiece::SentencePieceText_SentencePiece::Clear(sentencepiece::SentencePieceText_SentencePiece *this)
{
  result = google::protobuf::internal::ExtensionSet::Clear(this + 16);
  v3 = *(this + 10);
  if ((v3 & 3) != 0)
  {
    if (v3)
    {
      v4 = *(this + 6) & 0xFFFFFFFFFFFFFFFELL;
      if (*(v4 + 23) < 0)
      {
        **v4 = 0;
        *(v4 + 8) = 0;
        if ((v3 & 2) == 0)
        {
          goto LABEL_11;
        }

        goto LABEL_6;
      }

      *v4 = 0;
      *(v4 + 23) = 0;
    }

    if ((v3 & 2) == 0)
    {
      goto LABEL_11;
    }

LABEL_6:
    v5 = *(this + 7) & 0xFFFFFFFFFFFFFFFELL;
    if (*(v5 + 23) < 0)
    {
      **v5 = 0;
      *(v5 + 8) = 0;
    }

    else
    {
      *v5 = 0;
      *(v5 + 23) = 0;
    }
  }

LABEL_11:
  if ((v3 & 0x1C) != 0)
  {
    *(this + 18) = 0;
    *(this + 8) = 0;
  }

  *(this + 10) = 0;
  v6 = *(this + 1);
  if (v6)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if (*(v7 + 31) < 0)
    {
      **(v7 + 8) = 0;
      *(v7 + 16) = 0;
    }

    else
    {
      *(v7 + 8) = 0;
      *(v7 + 31) = 0;
    }
  }

  return result;
}

google::protobuf::internal *sentencepiece::SentencePieceText_SentencePiece::_InternalParse(uint64_t a1, google::protobuf::internal *a2, int32x2_t *this)
{
  v36 = a2;
  v5 = 0;
  if ((google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v36, this[11].i32[1]) & 1) == 0)
  {
    while (1)
    {
      v7 = (v36 + 1);
      v8 = *v36;
      if ((*v36 & 0x80000000) == 0)
      {
        goto LABEL_6;
      }

      v9 = v8 + (*v7 << 7);
      v8 = v9 - 128;
      if ((*v7 & 0x80000000) == 0)
      {
        break;
      }

      TagFallback = google::protobuf::internal::ReadTagFallback(v36, (v9 - 128));
      v36 = TagFallback;
      if (!TagFallback)
      {
        goto LABEL_62;
      }

      v7 = TagFallback;
      v8 = v27;
LABEL_7:
      v10 = v8 >> 3;
      if (v8 >> 3 <= 2)
      {
        if (v10 == 1)
        {
          if (v8 == 10)
          {
            *(a1 + 40) |= 1u;
            v18 = *(a1 + 8);
            if (v18)
            {
              v18 = *(v18 & 0xFFFFFFFFFFFFFFFELL);
            }

            v19 = (a1 + 48);
LABEL_39:
            v23 = google::protobuf::internal::ArenaStringPtr::Mutable(v19, v18, v7);
            v24 = google::protobuf::internal::InlineGreedyStringParser(v23, v36, this);
LABEL_40:
            v36 = v24;
            if (!v24)
            {
              goto LABEL_62;
            }

            goto LABEL_41;
          }

LABEL_43:
          if (v8)
          {
            v25 = (v8 & 7) == 4;
          }

          else
          {
            v25 = 1;
          }

          if (v25)
          {
            this[10].i32[0] = v8 - 1;
            goto LABEL_2;
          }

          if (v8 < 0x640)
          {
            v28 = *(a1 + 8);
            if (v28)
            {
              v29 = ((v28 & 0xFFFFFFFFFFFFFFFELL) + 8);
            }

            else
            {
              v29 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>((a1 + 8));
              v7 = v36;
            }

            v24 = google::protobuf::internal::UnknownFieldParse(v8, v29, v7, this);
          }

          else
          {
            v24 = google::protobuf::internal::ExtensionSet::ParseField((a1 + 16), v8, v7, &sentencepiece::_SentencePieceText_SentencePiece_default_instance_, (a1 + 8), this);
          }

          goto LABEL_40;
        }

        if (v10 != 2 || v8 != 16)
        {
          goto LABEL_43;
        }

        v5 |= 4u;
        v15 = (v7 + 1);
        LODWORD(v16) = *v7;
        if ((*v7 & 0x80000000) == 0)
        {
          goto LABEL_25;
        }

        v17 = *v15;
        v16 = (v16 + (v17 << 7) - 128);
        if ((v17 & 0x80000000) == 0)
        {
          v15 = (v7 + 2);
LABEL_25:
          v36 = v15;
          *(a1 + 64) = v16;
          goto LABEL_41;
        }

        v34 = google::protobuf::internal::VarintParseSlow32(v7, v16);
        v36 = v34;
        *(a1 + 64) = v35;
        if (!v34)
        {
LABEL_62:
          v36 = 0;
          goto LABEL_2;
        }
      }

      else
      {
        if (v10 == 3)
        {
          if (v8 == 26)
          {
            *(a1 + 40) |= 2u;
            v18 = *(a1 + 8);
            if (v18)
            {
              v18 = *(v18 & 0xFFFFFFFFFFFFFFFELL);
            }

            v19 = (a1 + 56);
            goto LABEL_39;
          }

          goto LABEL_43;
        }

        if (v10 == 4)
        {
          if (v8 != 32)
          {
            goto LABEL_43;
          }

          v5 |= 8u;
          v20 = (v7 + 1);
          LODWORD(v21) = *v7;
          if ((*v7 & 0x80000000) == 0)
          {
            goto LABEL_34;
          }

          v22 = *v20;
          v21 = (v21 + (v22 << 7) - 128);
          if ((v22 & 0x80000000) == 0)
          {
            v20 = (v7 + 2);
LABEL_34:
            v36 = v20;
            *(a1 + 68) = v21;
            goto LABEL_41;
          }

          v30 = google::protobuf::internal::VarintParseSlow32(v7, v21);
          v36 = v30;
          *(a1 + 68) = v31;
          if (!v30)
          {
            goto LABEL_62;
          }
        }

        else
        {
          if (v10 != 5 || v8 != 40)
          {
            goto LABEL_43;
          }

          v5 |= 0x10u;
          v11 = (v7 + 1);
          LODWORD(v12) = *v7;
          if ((*v7 & 0x80000000) == 0)
          {
            goto LABEL_15;
          }

          v13 = *v11;
          v12 = (v12 + (v13 << 7) - 128);
          if ((v13 & 0x80000000) == 0)
          {
            v11 = (v7 + 2);
LABEL_15:
            v36 = v11;
            *(a1 + 72) = v12;
            goto LABEL_41;
          }

          v32 = google::protobuf::internal::VarintParseSlow32(v7, v12);
          v36 = v32;
          *(a1 + 72) = v33;
          if (!v32)
          {
            goto LABEL_62;
          }
        }
      }

LABEL_41:
      if (google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v36, this[11].i32[1]))
      {
        goto LABEL_2;
      }
    }

    v7 = (v36 + 2);
LABEL_6:
    v36 = v7;
    goto LABEL_7;
  }

LABEL_2:
  *(a1 + 40) |= v5;
  return v36;
}

unsigned __int8 *sentencepiece::SentencePieceText_SentencePiece::_InternalSerialize(sentencepiece::SentencePieceText_SentencePiece *this, unsigned __int8 *a2, google::protobuf::io::EpsCopyOutputStream *a3)
{
  v4 = a2;
  v6 = *(this + 10);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 4) == 0)
    {
      goto LABEL_3;
    }

LABEL_11:
    if (*a3 <= v4)
    {
      v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, v4);
    }

    v8 = *(this + 16);
    *v4 = 16;
    if (v8 > 0x7F)
    {
      v4[1] = v8 | 0x80;
      v10 = v8 >> 7;
      if (v8 >> 14)
      {
        v4 += 3;
        do
        {
          *(v4 - 1) = v10 | 0x80;
          v13 = v10 >> 7;
          ++v4;
          v14 = v10 >> 14;
          v10 >>= 7;
        }

        while (v14);
        *(v4 - 1) = v13;
        if ((v6 & 2) != 0)
        {
          goto LABEL_27;
        }
      }

      else
      {
        v4[2] = v10;
        v4 += 3;
        if ((v6 & 2) != 0)
        {
          goto LABEL_27;
        }
      }
    }

    else
    {
      v4[1] = v8;
      v4 += 2;
      if ((v6 & 2) != 0)
      {
        goto LABEL_27;
      }
    }

LABEL_4:
    if ((v6 & 8) == 0)
    {
      goto LABEL_5;
    }

    goto LABEL_28;
  }

  v4 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 1, (*(this + 6) & 0xFFFFFFFFFFFFFFFELL), a2);
  if ((v6 & 4) != 0)
  {
    goto LABEL_11;
  }

LABEL_3:
  if ((v6 & 2) == 0)
  {
    goto LABEL_4;
  }

LABEL_27:
  v4 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 3, (*(this + 7) & 0xFFFFFFFFFFFFFFFELL), v4);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0)
    {
      goto LABEL_39;
    }

    goto LABEL_6;
  }

LABEL_28:
  if (*a3 <= v4)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, v4);
  }

  v15 = *(this + 17);
  *v4 = 32;
  if (v15 > 0x7F)
  {
    v4[1] = v15 | 0x80;
    v16 = v15 >> 7;
    if (v15 >> 14)
    {
      v4 += 3;
      do
      {
        *(v4 - 1) = v16 | 0x80;
        v17 = v16 >> 7;
        ++v4;
        v18 = v16 >> 14;
        v16 >>= 7;
      }

      while (v18);
      *(v4 - 1) = v17;
      if ((v6 & 0x10) == 0)
      {
        goto LABEL_39;
      }
    }

    else
    {
      v4[2] = v16;
      v4 += 3;
      if ((v6 & 0x10) == 0)
      {
        goto LABEL_39;
      }
    }
  }

  else
  {
    v4[1] = v15;
    v4 += 2;
    if ((v6 & 0x10) == 0)
    {
      goto LABEL_39;
    }
  }

LABEL_6:
  if (*a3 <= v4)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, v4);
  }

  v7 = *(this + 18);
  *v4 = 40;
  if (v7 > 0x7F)
  {
    v4[1] = v7 | 0x80;
    v9 = v7 >> 7;
    if (v7 >> 14)
    {
      v4 += 3;
      do
      {
        *(v4 - 1) = v9 | 0x80;
        v11 = v9 >> 7;
        ++v4;
        v12 = v9 >> 14;
        v9 >>= 7;
      }

      while (v12);
      *(v4 - 1) = v11;
    }

    else
    {
      v4[2] = v9;
      v4 += 3;
    }
  }

  else
  {
    v4[1] = v7;
    v4 += 2;
  }

LABEL_39:
  v19 = google::protobuf::internal::ExtensionSet::_InternalSerialize((this + 16), 200, 0x20000000, v4, a3);
  v20 = v19;
  v21 = *(this + 1);
  if ((v21 & 1) == 0)
  {
    return v20;
  }

  v23 = v21 & 0xFFFFFFFFFFFFFFFELL;
  v24 = *(v23 + 31);
  if (v24 < 0)
  {
    v25 = *(v23 + 8);
    v24 = *(v23 + 16);
  }

  else
  {
    v25 = (v23 + 8);
  }

  if (*a3 - v19 >= v24)
  {
    v26 = v24;
    memcpy(v19, v25, v24);
    v20 += v26;
    return v20;
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(a3, v25, v24, v19);
}

unsigned __int8 *google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(google::protobuf::io::EpsCopyOutputStream *a1, int a2, const void **a3, unsigned __int8 *a4)
{
  v4 = *(a3 + 23);
  if ((v4 & 0x8000000000000000) == 0 || (v4 = a3[1], v4 <= 127))
  {
    v5 = *a1;
    v6 = 8 * a2;
    if ((8 * a2) >= 0x80)
    {
      v8 = 2;
      v9 = 3;
      v10 = 4;
      if (v6 >> 28)
      {
        v10 = 5;
      }

      if (v6 >= 0x200000)
      {
        v9 = v10;
      }

      if (v6 >= 0x4000)
      {
        v8 = v9;
      }

      if ((v5 + ~&a4[v8] + 16) >= v4)
      {
        *a4 = v6 | 0x82;
        v11 = v6 >> 7;
        if (v6 >> 14)
        {
          v7 = a4 + 2;
          do
          {
            *(v7 - 1) = v11 | 0x80;
            v12 = v11 >> 7;
            ++v7;
            v13 = v11 >> 14;
            v11 >>= 7;
          }

          while (v13);
          *(v7 - 1) = v12;
        }

        else
        {
          a4[1] = v11;
          v7 = a4 + 2;
        }

LABEL_18:
        *v7 = v4;
        v14 = (v7 + 1);
        if (*(a3 + 23) >= 0)
        {
          v15 = a3;
        }

        else
        {
          v15 = *a3;
        }

        memcpy(v14, v15, v4);
        return &v14[v4];
      }
    }

    else if (v5 - a4 + 14 >= v4)
    {
      *a4 = v6 | 2;
      v7 = a4 + 1;
      goto LABEL_18;
    }
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliasedOutline(a1, a2, a3, a4);
}

uint64_t sentencepiece::SentencePieceText_SentencePiece::ByteSizeLong(sentencepiece::SentencePieceText_SentencePiece *this)
{
  result = google::protobuf::internal::ExtensionSet::ByteSize((this + 16));
  v3 = *(this + 10);
  if ((v3 & 0x1F) == 0)
  {
    goto LABEL_8;
  }

  if (v3)
  {
    v5 = *(this + 6) & 0xFFFFFFFFFFFFFFFELL;
    v6 = *(v5 + 23);
    v7 = *(v5 + 8);
    if ((v6 & 0x80u) == 0)
    {
      v7 = v6;
    }

    result += v7 + ((9 * (__clz(v7 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v3 & 2) == 0)
    {
LABEL_4:
      if ((v3 & 4) == 0)
      {
        goto LABEL_5;
      }

LABEL_16:
      result += ((9 * (__clz(*(this + 16) | 1) ^ 0x1F) + 73) >> 6) + 1;
      if ((v3 & 8) == 0)
      {
LABEL_6:
        if ((v3 & 0x10) == 0)
        {
          goto LABEL_8;
        }

        goto LABEL_7;
      }

      goto LABEL_17;
    }
  }

  else if ((v3 & 2) == 0)
  {
    goto LABEL_4;
  }

  v8 = *(this + 7) & 0xFFFFFFFFFFFFFFFELL;
  v9 = *(v8 + 23);
  v10 = *(v8 + 8);
  if ((v9 & 0x80u) == 0)
  {
    v10 = v9;
  }

  result += v10 + ((9 * (__clz(v10 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v3 & 4) != 0)
  {
    goto LABEL_16;
  }

LABEL_5:
  if ((v3 & 8) == 0)
  {
    goto LABEL_6;
  }

LABEL_17:
  result += ((9 * (__clz(*(this + 17) | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v3 & 0x10) != 0)
  {
LABEL_7:
    result += ((9 * (__clz(*(this + 18) | 1) ^ 0x1F) + 73) >> 6) + 1;
  }

LABEL_8:
  v4 = *(this + 1);
  if (v4)
  {
    v11 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v12 = *((v4 & 0xFFFFFFFFFFFFFFFELL) + 31);
    if (v12 < 0)
    {
      v12 = *(v11 + 16);
    }

    result += v12;
  }

  *(this + 11) = result;
  return result;
}

void sentencepiece::SentencePieceText_SentencePiece::MergeFrom(sentencepiece::SentencePieceText_SentencePiece *this, const sentencepiece::SentencePieceText_SentencePiece *a2)
{
  google::protobuf::internal::ExtensionSet::MergeFrom((this + 16), (a2 + 16));
  v4 = *(a2 + 1);
  if (v4)
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v6 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 8;
    v7 = *(this + 1);
    if (v7)
    {
      v8 = ((v7 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }

    else
    {
      v8 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(this + 1);
    }

    v9 = *(v5 + 31);
    if (v9 >= 0)
    {
      v10 = v6;
    }

    else
    {
      v10 = *(v5 + 8);
    }

    if (v9 >= 0)
    {
      v11 = *(v5 + 31);
    }

    else
    {
      v11 = *(v5 + 16);
    }

    std::string::append(v8, v10, v11);
  }

  v12 = *(a2 + 10);
  if ((v12 & 0x1F) != 0)
  {
    if (v12)
    {
      v13 = *(a2 + 6);
      *(this + 10) |= 1u;
      v14 = *(this + 1);
      if (v14)
      {
        v14 = *(v14 & 0xFFFFFFFFFFFFFFFELL);
      }

      google::protobuf::internal::ArenaStringPtr::Set(this + 6, v13 & 0xFFFFFFFFFFFFFFFELL, v14);
      if ((v12 & 2) == 0)
      {
LABEL_14:
        if ((v12 & 4) == 0)
        {
          goto LABEL_15;
        }

        goto LABEL_26;
      }
    }

    else if ((v12 & 2) == 0)
    {
      goto LABEL_14;
    }

    v15 = *(a2 + 7);
    *(this + 10) |= 2u;
    v16 = *(this + 1);
    if (v16)
    {
      v16 = *(v16 & 0xFFFFFFFFFFFFFFFELL);
    }

    google::protobuf::internal::ArenaStringPtr::Set(this + 7, v15 & 0xFFFFFFFFFFFFFFFELL, v16);
    if ((v12 & 4) == 0)
    {
LABEL_15:
      if ((v12 & 8) == 0)
      {
        goto LABEL_16;
      }

      goto LABEL_27;
    }

LABEL_26:
    *(this + 16) = *(a2 + 16);
    if ((v12 & 8) == 0)
    {
LABEL_16:
      if ((v12 & 0x10) == 0)
      {
LABEL_18:
        *(this + 10) |= v12;
        return;
      }

LABEL_17:
      *(this + 18) = *(a2 + 18);
      goto LABEL_18;
    }

LABEL_27:
    *(this + 17) = *(a2 + 17);
    if ((v12 & 0x10) == 0)
    {
      goto LABEL_18;
    }

    goto LABEL_17;
  }
}

unint64_t *sentencepiece::SentencePieceText_SentencePiece::InternalSwap(sentencepiece::SentencePieceText_SentencePiece *this, sentencepiece::SentencePieceText_SentencePiece *a2)
{
  google::protobuf::internal::ExtensionSet::Swap((this + 16), (a2 + 16));
  v5 = (this + 8);
  v4 = *(this + 1);
  result = (a2 + 8);
  v7 = *(a2 + 1);
  if (v4)
  {
    if ((v7 & 1) == 0)
    {
      v8 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(result);
      v4 = *v5;
      if (*v5)
      {
        goto LABEL_6;
      }

LABEL_10:
      result = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(this + 1);
      goto LABEL_7;
    }
  }

  else if ((v7 & 1) == 0)
  {
    goto LABEL_8;
  }

  v8 = ((v7 & 0xFFFFFFFFFFFFFFFELL) + 8);
  if ((v4 & 1) == 0)
  {
    goto LABEL_10;
  }

LABEL_6:
  result = ((v4 & 0xFFFFFFFFFFFFFFFELL) + 8);
LABEL_7:
  v9 = result[2];
  v10 = *result;
  v11 = *(v8 + 2);
  *result = *v8;
  result[2] = v11;
  *v8 = v10;
  *(v8 + 2) = v9;
LABEL_8:
  v12 = *(this + 10);
  *(this + 10) = *(a2 + 10);
  *(a2 + 10) = v12;
  v13 = *(this + 6);
  *(this + 6) = *(a2 + 6);
  *(a2 + 6) = v13;
  v14 = *(this + 7);
  *(this + 7) = *(a2 + 7);
  *(a2 + 7) = v14;
  v15 = *(this + 8);
  *(this + 8) = *(a2 + 8);
  *(a2 + 8) = v15;
  LODWORD(v15) = *(this + 18);
  *(this + 18) = *(a2 + 18);
  *(a2 + 18) = v15;
  return result;
}

uint64_t sentencepiece::SentencePieceText::SentencePieceText(uint64_t a1, uint64_t a2)
{
  *a1 = &unk_1F2D43500;
  *(a1 + 8) = a2;
  google::protobuf::internal::ExtensionSet::ExtensionSet(a1 + 16, a2);
  *(a1 + 48) = a2;
  *(a1 + 40) = 0;
  *(a1 + 56) = 0;
  *(a1 + 64) = 0;
  if (atomic_load_explicit(scc_info_SentencePieceText_sentencepiece_2eproto, memory_order_acquire))
  {
    google::protobuf::internal::InitSCCImpl(scc_info_SentencePieceText_sentencepiece_2eproto);
  }

  *(a1 + 72) = &google::protobuf::internal::fixed_address_empty_string;
  *(a1 + 80) = 0;
  return a1;
}

void sub_1B5AA1B28(_Unwind_Exception *a1)
{
  google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::SentencePieceText_SentencePiece>::TypeHandler>(v2);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((v1 + 16));
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceText::~SentencePieceText(sentencepiece::SentencePieceText *this)
{
  v2 = *(this + 9);
  if (v2 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v2 + 23) < 0)
    {
      operator delete(*v2);
    }

    MEMORY[0x1B8C85350](v2, 0x1012C40EC159624);
  }

  google::protobuf::internal::InternalMetadata::Delete<std::string>(this + 1);
  google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::SentencePieceText_SentencePiece>::TypeHandler>(this + 6);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((this + 16));
}

{
  sentencepiece::SentencePieceText::~SentencePieceText(this);

  JUMPOUT(0x1B8C85350);
}

unsigned __int8 *sentencepiece::SentencePieceText::Clear(sentencepiece::SentencePieceText *this)
{
  result = google::protobuf::internal::ExtensionSet::Clear(this + 16);
  v3 = *(this + 14);
  if (v3 >= 1)
  {
    v4 = (*(this + 8) + 8);
    do
    {
      v5 = *v4++;
      result = sentencepiece::SentencePieceText_SentencePiece::Clear(v5);
      --v3;
    }

    while (v3);
    *(this + 14) = 0;
  }

  if (*(this + 40))
  {
    v6 = *(this + 9) & 0xFFFFFFFFFFFFFFFELL;
    if (*(v6 + 23) < 0)
    {
      **v6 = 0;
      *(v6 + 8) = 0;
    }

    else
    {
      *v6 = 0;
      *(v6 + 23) = 0;
    }
  }

  *(this + 20) = 0;
  *(this + 10) = 0;
  v7 = *(this + 1);
  if (v7)
  {
    v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    if (*(v8 + 31) < 0)
    {
      **(v8 + 8) = 0;
      *(v8 + 16) = 0;
    }

    else
    {
      *(v8 + 8) = 0;
      *(v8 + 31) = 0;
    }
  }

  return result;
}

google::protobuf::internal *sentencepiece::SentencePieceText::_InternalParse(uint64_t a1, google::protobuf::internal *a2, int32x2_t *this)
{
  v28 = a2;
  v5 = 0;
  if ((google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v28, this[11].i32[1]) & 1) == 0)
  {
    while (1)
    {
      v7 = (v28 + 1);
      v8 = *v28;
      if ((*v28 & 0x80000000) == 0)
      {
        goto LABEL_6;
      }

      v9 = v8 + (*v7 << 7);
      v8 = v9 - 128;
      if ((*v7 & 0x80000000) == 0)
      {
        break;
      }

      TagFallback = google::protobuf::internal::ReadTagFallback(v28, (v9 - 128));
      v28 = TagFallback;
      if (!TagFallback)
      {
        goto LABEL_48;
      }

      v7 = TagFallback;
      v8 = v25;
LABEL_7:
      v10 = v8 >> 3;
      if (v8 >> 3 == 3)
      {
        if (v8 == 29)
        {
          v5 |= 2u;
          *(a1 + 80) = *v7;
          v28 = (v7 + 4);
          goto LABEL_44;
        }

        goto LABEL_13;
      }

      if (v10 == 2)
      {
        if (v8 == 18)
        {
          v14 = (v7 - 1);
          while (1)
          {
            v15 = (v14 + 1);
            v28 = (v14 + 1);
            v16 = *(a1 + 64);
            if (!v16)
            {
              break;
            }

            v21 = *(a1 + 56);
            v17 = *v16;
            if (v21 < *v16)
            {
              *(a1 + 56) = v21 + 1;
              v18 = *&v16[2 * v21 + 2];
              goto LABEL_27;
            }

            if (v17 == *(a1 + 60))
            {
              goto LABEL_23;
            }

LABEL_24:
            *v16 = v17 + 1;
            v18 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText_SentencePiece>(*(a1 + 48));
            v19 = *(a1 + 56);
            v20 = *(a1 + 64) + 8 * v19;
            *(a1 + 56) = v19 + 1;
            *(v20 + 8) = v18;
            v15 = v28;
LABEL_27:
            v14 = google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::SentencePieceText_SentencePiece>(this, v18, v15);
            v28 = v14;
            if (!v14)
            {
              goto LABEL_48;
            }

            if (*this <= v14 || *v14 != 18)
            {
              goto LABEL_44;
            }
          }

          v17 = *(a1 + 60);
LABEL_23:
          google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a1 + 48), v17 + 1);
          v16 = *(a1 + 64);
          v17 = *v16;
          goto LABEL_24;
        }

LABEL_13:
        if (v8)
        {
          v12 = (v8 & 7) == 4;
        }

        else
        {
          v12 = 1;
        }

        if (v12)
        {
          this[10].i32[0] = v8 - 1;
          goto LABEL_2;
        }

        if (v8 < 0x640)
        {
          v26 = *(a1 + 8);
          if (v26)
          {
            v27 = ((v26 & 0xFFFFFFFFFFFFFFFELL) + 8);
          }

          else
          {
            v27 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>((a1 + 8));
            v7 = v28;
          }

          v13 = google::protobuf::internal::UnknownFieldParse(v8, v27, v7, this);
        }

        else
        {
          v13 = google::protobuf::internal::ExtensionSet::ParseField((a1 + 16), v8, v7, &sentencepiece::_SentencePieceText_default_instance_, (a1 + 8), this);
        }

        goto LABEL_43;
      }

      if (v10 != 1 || v8 != 10)
      {
        goto LABEL_13;
      }

      *(a1 + 40) |= 1u;
      v22 = *(a1 + 8);
      if (v22)
      {
        v22 = *(v22 & 0xFFFFFFFFFFFFFFFELL);
      }

      v23 = google::protobuf::internal::ArenaStringPtr::Mutable((a1 + 72), v22, v7);
      v13 = google::protobuf::internal::InlineGreedyStringParser(v23, v28, this);
LABEL_43:
      v28 = v13;
      if (!v13)
      {
LABEL_48:
        v28 = 0;
        goto LABEL_2;
      }

LABEL_44:
      if (google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v28, this[11].i32[1]))
      {
        goto LABEL_2;
      }
    }

    v7 = (v28 + 2);
LABEL_6:
    v28 = v7;
    goto LABEL_7;
  }

LABEL_2:
  *(a1 + 40) |= v5;
  return v28;
}

unsigned __int8 *sentencepiece::SentencePieceText::_InternalSerialize(sentencepiece::SentencePieceText *this, unsigned __int8 *a2, google::protobuf::io::EpsCopyOutputStream *a3)
{
  v4 = a2;
  v6 = *(this + 10);
  if (v6)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 1, (*(this + 9) & 0xFFFFFFFFFFFFFFFELL), a2);
  }

  v7 = *(this + 14);
  if (v7)
  {
    for (i = 0; i != v7; ++i)
    {
      if (*a3 <= v4)
      {
        v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, v4);
      }

      v9 = *(*(this + 8) + 8 * i + 8);
      *v4 = 18;
      v10 = *(v9 + 11);
      if (v10 > 0x7F)
      {
        v4[1] = v10 | 0x80;
        v12 = v10 >> 7;
        if (v10 >> 14)
        {
          v11 = v4 + 3;
          do
          {
            *(v11 - 1) = v12 | 0x80;
            v13 = v12 >> 7;
            ++v11;
            v14 = v12 >> 14;
            v12 >>= 7;
          }

          while (v14);
          *(v11 - 1) = v13;
        }

        else
        {
          v4[2] = v12;
          v11 = v4 + 3;
        }
      }

      else
      {
        v4[1] = v10;
        v11 = v4 + 2;
      }

      v4 = sentencepiece::SentencePieceText_SentencePiece::_InternalSerialize(v9, v11, a3);
    }
  }

  if ((v6 & 2) != 0)
  {
    if (*a3 <= v4)
    {
      v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, v4);
    }

    v15 = *(this + 20);
    *v4 = 29;
    *(v4 + 1) = v15;
    v4 += 5;
  }

  v16 = google::protobuf::internal::ExtensionSet::_InternalSerialize((this + 16), 200, 0x20000000, v4, a3);
  v17 = v16;
  v18 = *(this + 1);
  if ((v18 & 1) == 0)
  {
    return v17;
  }

  v20 = v18 & 0xFFFFFFFFFFFFFFFELL;
  v21 = *(v20 + 31);
  if (v21 < 0)
  {
    v22 = *(v20 + 8);
    v21 = *(v20 + 16);
  }

  else
  {
    v22 = (v20 + 8);
  }

  if (*a3 - v16 >= v21)
  {
    v23 = v21;
    memcpy(v16, v22, v21);
    v17 += v23;
    return v17;
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(a3, v22, v21, v16);
}

uint64_t sentencepiece::SentencePieceText::ByteSizeLong(sentencepiece::SentencePieceText *this)
{
  v2 = google::protobuf::internal::ExtensionSet::ByteSize((this + 16));
  v3 = *(this + 14);
  v4 = v2 + v3;
  v5 = *(this + 8);
  if (v5)
  {
    v6 = (v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  if (v3)
  {
    v7 = 8 * v3;
    do
    {
      v8 = *v6++;
      v9 = sentencepiece::SentencePieceText_SentencePiece::ByteSizeLong(v8);
      v4 += v9 + ((9 * (__clz(v9 | 1) ^ 0x1F) + 73) >> 6);
      v7 -= 8;
    }

    while (v7);
  }

  v10 = *(this + 10);
  if ((v10 & 3) != 0)
  {
    if (v10)
    {
      v11 = *(this + 9) & 0xFFFFFFFFFFFFFFFELL;
      v12 = *(v11 + 23);
      v13 = *(v11 + 8);
      if ((v12 & 0x80u) == 0)
      {
        v13 = v12;
      }

      v4 += v13 + ((9 * (__clz(v13 | 1) ^ 0x1F) + 73) >> 6) + 1;
    }

    if ((v10 & 2) != 0)
    {
      v4 += 5;
    }
  }

  v14 = *(this + 1);
  if (v14)
  {
    v16 = v14 & 0xFFFFFFFFFFFFFFFELL;
    v17 = *((v14 & 0xFFFFFFFFFFFFFFFELL) + 31);
    if (v17 < 0)
    {
      v17 = *(v16 + 16);
    }

    v4 += v17;
  }

  *(this + 11) = v4;
  return v4;
}

void sentencepiece::SentencePieceText::MergeFrom(sentencepiece::SentencePieceText *this, const sentencepiece::SentencePieceText *a2)
{
  google::protobuf::internal::ExtensionSet::MergeFrom((this + 16), (a2 + 16));
  v4 = *(a2 + 1);
  if (v4)
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v6 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 8;
    v7 = *(this + 1);
    if (v7)
    {
      v8 = ((v7 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }

    else
    {
      v8 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(this + 1);
    }

    v9 = *(v5 + 31);
    if (v9 >= 0)
    {
      v10 = v6;
    }

    else
    {
      v10 = *(v5 + 8);
    }

    if (v9 >= 0)
    {
      v11 = *(v5 + 31);
    }

    else
    {
      v11 = *(v5 + 16);
    }

    std::string::append(v8, v10, v11);
  }

  v12 = *(a2 + 14);
  if (v12)
  {
    v13 = *(a2 + 8);
    v14 = google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend((this + 48), *(a2 + 14));
    google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<sentencepiece::SentencePieceText_SentencePiece>::TypeHandler>(this + 6, v14, (v13 + 8), v12, **(this + 8) - *(this + 14));
    v15 = *(this + 14) + v12;
    *(this + 14) = v15;
    v16 = *(this + 8);
    if (*v16 < v15)
    {
      *v16 = v15;
    }
  }

  v17 = *(a2 + 10);
  if ((v17 & 3) != 0)
  {
    if (v17)
    {
      v18 = *(a2 + 9);
      *(this + 10) |= 1u;
      v19 = *(this + 1);
      if (v19)
      {
        v19 = *(v19 & 0xFFFFFFFFFFFFFFFELL);
      }

      google::protobuf::internal::ArenaStringPtr::Set(this + 9, v18 & 0xFFFFFFFFFFFFFFFELL, v19);
    }

    if ((v17 & 2) != 0)
    {
      *(this + 20) = *(a2 + 20);
    }

    *(this + 10) |= v17;
  }
}

BOOL sentencepiece::SentencePieceText::IsInitialized(sentencepiece::SentencePieceText *this)
{
  if (!google::protobuf::internal::ExtensionSet::IsInitialized((this + 16)))
  {
    return 0;
  }

  v2 = *(this + 14);
  do
  {
    v3 = v2 < 1;
    if (v2 < 1)
    {
      break;
    }

    v4 = v2 - 1;
    IsInitialized = google::protobuf::internal::ExtensionSet::IsInitialized((*(*(this + 8) + 8 * v2) + 16));
    v2 = v4;
  }

  while ((IsInitialized & 1) != 0);
  return v3;
}

uint64_t sentencepiece::NBestSentencePieceText::NBestSentencePieceText(uint64_t a1, uint64_t a2)
{
  *a1 = &unk_1F2D43580;
  *(a1 + 8) = a2;
  *(a1 + 16) = a2;
  *(a1 + 24) = 0;
  *(a1 + 32) = 0;
  *(a1 + 40) = 0;
  if (atomic_load_explicit(scc_info_NBestSentencePieceText_sentencepiece_2eproto, memory_order_acquire))
  {
    google::protobuf::internal::InitSCCImpl(scc_info_NBestSentencePieceText_sentencepiece_2eproto);
  }

  return a1;
}

void sentencepiece::NBestSentencePieceText::~NBestSentencePieceText(sentencepiece::NBestSentencePieceText *this)
{
  google::protobuf::internal::InternalMetadata::Delete<std::string>(this + 1);
  google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::SentencePieceText>::TypeHandler>(this + 2);
}

{
  sentencepiece::NBestSentencePieceText::~NBestSentencePieceText(this);

  JUMPOUT(0x1B8C85350);
}

unsigned __int8 *sentencepiece::NBestSentencePieceText::Clear(unsigned __int8 *this)
{
  v1 = this;
  v2 = *(this + 6);
  if (v2 >= 1)
  {
    v3 = (*(this + 4) + 8);
    do
    {
      v4 = *v3++;
      this = sentencepiece::SentencePieceText::Clear(v4);
      --v2;
    }

    while (v2);
    *(v1 + 24) = 0;
  }

  v5 = *(v1 + 8);
  if (v5)
  {
    v6 = v5 & 0xFFFFFFFFFFFFFFFELL;
    if (*(v6 + 31) < 0)
    {
      **(v6 + 8) = 0;
      *(v6 + 16) = 0;
    }

    else
    {
      *(v6 + 8) = 0;
      *(v6 + 31) = 0;
    }
  }

  return this;
}

google::protobuf::internal *sentencepiece::NBestSentencePieceText::_InternalParse(uint64_t a1, google::protobuf::internal *a2, int32x2_t *this)
{
  v22 = a2;
  if ((google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v22, this[11].i32[1]) & 1) == 0)
  {
    while (1)
    {
      v5 = (v22 + 1);
      v6 = *v22;
      if ((*v22 & 0x80000000) == 0)
      {
        goto LABEL_5;
      }

      v7 = v6 + (*v5 << 7);
      v6 = v7 - 128;
      if ((*v5 & 0x80000000) == 0)
      {
        break;
      }

      TagFallback = google::protobuf::internal::ReadTagFallback(v22, (v7 - 128));
      v22 = TagFallback;
      if (!TagFallback)
      {
        return 0;
      }

      v5 = TagFallback;
      v6 = v20;
LABEL_6:
      if (v6 == 10)
      {
        v11 = (v5 - 1);
        while (1)
        {
          v12 = (v11 + 1);
          v22 = (v11 + 1);
          v13 = *(a1 + 32);
          if (!v13)
          {
            break;
          }

          v18 = *(a1 + 24);
          v14 = *v13;
          if (v18 < *v13)
          {
            *(a1 + 24) = v18 + 1;
            v15 = *&v13[2 * v18 + 2];
            goto LABEL_23;
          }

          if (v14 == *(a1 + 28))
          {
            goto LABEL_19;
          }

LABEL_20:
          *v13 = v14 + 1;
          v15 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText>(*(a1 + 16));
          v16 = *(a1 + 24);
          v17 = *(a1 + 32) + 8 * v16;
          *(a1 + 24) = v16 + 1;
          *(v17 + 8) = v15;
          v12 = v22;
LABEL_23:
          v11 = google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::SentencePieceText>(this, v15, v12);
          v22 = v11;
          if (!v11)
          {
            return 0;
          }

          if (*this <= v11 || *v11 != 10)
          {
            goto LABEL_14;
          }
        }

        v14 = *(a1 + 28);
LABEL_19:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a1 + 16), v14 + 1);
        v13 = *(a1 + 32);
        v14 = *v13;
        goto LABEL_20;
      }

      if (v6)
      {
        v8 = (v6 & 7) == 4;
      }

      else
      {
        v8 = 1;
      }

      if (v8)
      {
        this[10].i32[0] = v6 - 1;
        return v22;
      }

      v9 = *(a1 + 8);
      if (v9)
      {
        v10 = ((v9 & 0xFFFFFFFFFFFFFFFELL) + 8);
      }

      else
      {
        v10 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>((a1 + 8));
        v5 = v22;
      }

      v22 = google::protobuf::internal::UnknownFieldParse(v6, v10, v5, this);
      if (!v22)
      {
        return 0;
      }

LABEL_14:
      if (google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v22, this[11].i32[1]))
      {
        return v22;
      }
    }

    v5 = (v22 + 2);
LABEL_5:
    v22 = v5;
    goto LABEL_6;
  }

  return v22;
}

unsigned __int8 *sentencepiece::NBestSentencePieceText::_InternalSerialize(sentencepiece::NBestSentencePieceText *this, unsigned __int8 *__dst, google::protobuf::io::EpsCopyOutputStream *a3)
{
  v6 = *(this + 6);
  if (v6)
  {
    for (i = 0; i != v6; ++i)
    {
      if (*a3 <= __dst)
      {
        __dst = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, __dst);
      }

      v8 = *(*(this + 4) + 8 * i + 8);
      *__dst = 10;
      v9 = *(v8 + 11);
      if (v9 > 0x7F)
      {
        __dst[1] = v9 | 0x80;
        v11 = v9 >> 7;
        if (v9 >> 14)
        {
          v10 = __dst + 3;
          do
          {
            *(v10 - 1) = v11 | 0x80;
            v12 = v11 >> 7;
            ++v10;
            v13 = v11 >> 14;
            v11 >>= 7;
          }

          while (v13);
          *(v10 - 1) = v12;
        }

        else
        {
          __dst[2] = v11;
          v10 = __dst + 3;
        }
      }

      else
      {
        __dst[1] = v9;
        v10 = __dst + 2;
      }

      __dst = sentencepiece::SentencePieceText::_InternalSerialize(v8, v10, a3);
    }
  }

  v14 = *(this + 1);
  if ((v14 & 1) == 0)
  {
    return __dst;
  }

  v16 = v14 & 0xFFFFFFFFFFFFFFFELL;
  v17 = *(v16 + 31);
  if (v17 < 0)
  {
    v18 = *(v16 + 8);
    v17 = *(v16 + 16);
  }

  else
  {
    v18 = (v16 + 8);
  }

  if (*a3 - __dst >= v17)
  {
    v19 = v17;
    memcpy(__dst, v18, v17);
    __dst += v19;
    return __dst;
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(a3, v18, v17, __dst);
}

uint64_t sentencepiece::NBestSentencePieceText::ByteSizeLong(sentencepiece::NBestSentencePieceText *this)
{
  v2 = *(this + 6);
  v3 = *(this + 4);
  if (v3)
  {
    v4 = (v3 + 8);
  }

  else
  {
    v4 = 0;
  }

  if (v2)
  {
    v5 = 8 * v2;
    do
    {
      v6 = *v4++;
      v7 = sentencepiece::SentencePieceText::ByteSizeLong(v6);
      v2 += v7 + ((9 * (__clz(v7 | 1) ^ 0x1F) + 73) >> 6);
      v5 -= 8;
    }

    while (v5);
  }

  else
  {
    v2 = 0;
  }

  v8 = *(this + 1);
  if (v8)
  {
    v10 = v8 & 0xFFFFFFFFFFFFFFFELL;
    v11 = *((v8 & 0xFFFFFFFFFFFFFFFELL) + 31);
    if (v11 < 0)
    {
      v11 = *(v10 + 16);
    }

    v2 += v11;
  }

  *(this + 10) = v2;
  return v2;
}

void sentencepiece::NBestSentencePieceText::MergeFrom(sentencepiece::NBestSentencePieceText *this, const sentencepiece::NBestSentencePieceText *a2)
{
  v4 = *(a2 + 1);
  if (v4)
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v6 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 8;
    v7 = *(this + 1);
    if (v7)
    {
      v8 = ((v7 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }

    else
    {
      v8 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(this + 1);
    }

    v9 = *(v5 + 31);
    if (v9 >= 0)
    {
      v10 = v6;
    }

    else
    {
      v10 = *(v5 + 8);
    }

    if (v9 >= 0)
    {
      v11 = *(v5 + 31);
    }

    else
    {
      v11 = *(v5 + 16);
    }

    std::string::append(v8, v10, v11);
  }

  v12 = *(a2 + 6);
  if (v12)
  {
    v13 = *(a2 + 4);
    v14 = google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend((this + 16), v12);
    google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<sentencepiece::SentencePieceText>::TypeHandler>(this + 2, v14, (v13 + 8), v12, **(this + 4) - *(this + 6));
    v15 = *(this + 6) + v12;
    *(this + 6) = v15;
    v16 = *(this + 4);
    if (*v16 < v15)
    {
      *v16 = v15;
    }
  }
}

BOOL sentencepiece::NBestSentencePieceText::IsInitialized(sentencepiece::NBestSentencePieceText *this)
{
  v2 = *(this + 6);
  do
  {
    v3 = v2;
    if (v2 < 1)
    {
      break;
    }

    v4 = v2 - 1;
    IsInitialized = sentencepiece::SentencePieceText::IsInitialized(*(*(this + 4) + 8 * v2));
    v2 = v4;
  }

  while (IsInitialized);
  return v3 < 1;
}

uint64_t google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText_SentencePiece>(google::protobuf::Arena *this)
{
  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
  }

  AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(this, 0x50uLL);
  sentencepiece::SentencePieceText_SentencePiece::SentencePieceText_SentencePiece(AlignedNoHook, this);
  return AlignedNoHook;
}

uint64_t google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText>(google::protobuf::Arena *this)
{
  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
  }

  AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(this, 0x58uLL);
  sentencepiece::SentencePieceText::SentencePieceText(AlignedNoHook, this);
  return AlignedNoHook;
}

uint64_t google::protobuf::Arena::CreateMaybeMessage<sentencepiece::NBestSentencePieceText>(google::protobuf::Arena *this)
{
  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
  }

  AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(this, 0x30uLL);
  sentencepiece::NBestSentencePieceText::NBestSentencePieceText(AlignedNoHook, this);
  return AlignedNoHook;
}

uint64_t google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(google::protobuf::internal::EpsCopyInputStream *this, const char **a2, int a3)
{
  if (*a2 >= *this)
  {
    v6 = *a2 - *(this + 2);
    if (*(this + 7) == v6)
    {
      if (v6 >= 1 && !*(this + 2))
      {
        *a2 = 0;
      }

      v3 = 1;
    }

    else
    {
      *a2 = google::protobuf::internal::EpsCopyInputStream::DoneFallback(this, v6, a3);
    }
  }

  else
  {
    v3 = 0;
  }

  return v3 & 1;
}

char *google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(unint64_t *a1)
{
  v2 = *a1;
  if ((*a1 & 1) == 0)
  {
    if (v2)
    {
      goto LABEL_3;
    }

LABEL_7:
    operator new();
  }

  v2 = *(v2 & 0xFFFFFFFFFFFFFFFELL);
  if (!v2)
  {
    goto LABEL_7;
  }

LABEL_3:
  if (*(v2 + 24))
  {
  }

  AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v2, 0x20uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::internal::InternalMetadata::Container<std::string>>);
  *AlignedAndAddCleanup = 0u;
  *(AlignedAndAddCleanup + 16) = 0u;
  *a1 = AlignedAndAddCleanup | 1;
  *AlignedAndAddCleanup = v2;
  return (AlignedAndAddCleanup + 8);
}

void google::protobuf::internal::arena_destruct_object<google::protobuf::internal::InternalMetadata::Container<std::string>>(uint64_t a1)
{
  if (*(a1 + 31) < 0)
  {
    operator delete(*(a1 + 8));
  }
}

void google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::SentencePieceText_SentencePiece>::TypeHandler>(void *a1)
{
  v2 = a1[2];
  if (v2 && !*a1)
  {
    v3 = v2 + 1;
    v4 = *v2;
    if (v4 >= 1)
    {
      do
      {
        if (*v3)
        {
          sentencepiece::SentencePieceText_SentencePiece::~SentencePieceText_SentencePiece(*v3);
          MEMORY[0x1B8C85350]();
        }

        ++v3;
        --v4;
      }

      while (v4);
      v2 = a1[2];
    }

    operator delete(v2);
  }

  a1[2] = 0;
}

void google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<sentencepiece::SentencePieceText_SentencePiece>::TypeHandler>(google::protobuf::Arena **a1, sentencepiece::SentencePieceText_SentencePiece **a2, sentencepiece::SentencePieceText_SentencePiece **a3, unsigned int a4, unsigned int a5)
{
  if (a5 >= a4)
  {
    v10 = a4;
  }

  else
  {
    v10 = a5;
  }

  if (v10 >= 1)
  {
    v11 = a3;
    v12 = a2;
    do
    {
      v14 = *v11++;
      v13 = v14;
      v15 = *v12++;
      google::protobuf::internal::GenericTypeHandler<sentencepiece::SentencePieceText_SentencePiece>::Merge(v13, v15);
      --v10;
    }

    while (v10);
  }

  v16 = __OFSUB__(a4, a5);
  v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    v18 = *a1;
    v19 = &a3[a5];
    v20 = &a2[a5];
    do
    {
      v21 = *v19++;
      v22 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText_SentencePiece>(v18);
      google::protobuf::internal::GenericTypeHandler<sentencepiece::SentencePieceText_SentencePiece>::Merge(v21, v22);
      *v20++ = v22;
      --v17;
    }

    while (v17);
  }
}

void google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::SentencePieceText>::TypeHandler>(void *a1)
{
  v2 = a1[2];
  if (v2 && !*a1)
  {
    v3 = v2 + 1;
    v4 = *v2;
    if (v4 >= 1)
    {
      do
      {
        if (*v3)
        {
          sentencepiece::SentencePieceText::~SentencePieceText(*v3);
          MEMORY[0x1B8C85350]();
        }

        ++v3;
        --v4;
      }

      while (v4);
      v2 = a1[2];
    }

    operator delete(v2);
  }

  a1[2] = 0;
}

void google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<sentencepiece::SentencePieceText>::TypeHandler>(google::protobuf::Arena **a1, sentencepiece::SentencePieceText **a2, sentencepiece::SentencePieceText **a3, unsigned int a4, unsigned int a5)
{
  if (a5 >= a4)
  {
    v10 = a4;
  }

  else
  {
    v10 = a5;
  }

  if (v10 >= 1)
  {
    v11 = a3;
    v12 = a2;
    do
    {
      v14 = *v11++;
      v13 = v14;
      v15 = *v12++;
      google::protobuf::internal::GenericTypeHandler<sentencepiece::SentencePieceText>::Merge(v13, v15);
      --v10;
    }

    while (v10);
  }

  v16 = __OFSUB__(a4, a5);
  v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    v18 = *a1;
    v19 = &a3[a5];
    v20 = &a2[a5];
    do
    {
      v21 = *v19++;
      v22 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText>(v18);
      google::protobuf::internal::GenericTypeHandler<sentencepiece::SentencePieceText>::Merge(v21, v22);
      *v20++ = v22;
      --v17;
    }

    while (v17);
  }
}

void InitDefaultsscc_info_ModelProto_sentencepiece_5fmodel_2eproto(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  google::protobuf::internal::VerifyVersion(0x2DFD70, 0x2DFD70, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/builtin_pb/sentencepiece_model.pb.cc", a4);
  sentencepiece::ModelProto::ModelProto(&sentencepiece::_ModelProto_default_instance_, 0);

  google::protobuf::internal::OnShutdownRun(google::protobuf::internal::DestroyMessage, &sentencepiece::_ModelProto_default_instance_, v4);
}

void InitDefaultsscc_info_ModelProto_SentencePiece_sentencepiece_5fmodel_2eproto(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  google::protobuf::internal::VerifyVersion(0x2DFD70, 0x2DFD70, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/builtin_pb/sentencepiece_model.pb.cc", a4);
  sentencepiece::ModelProto_SentencePiece::ModelProto_SentencePiece(sentencepiece::_ModelProto_SentencePiece_default_instance_, 0);

  google::protobuf::internal::OnShutdownRun(google::protobuf::internal::DestroyMessage, sentencepiece::_ModelProto_SentencePiece_default_instance_, v4);
}

void InitDefaultsscc_info_NormalizerSpec_sentencepiece_5fmodel_2eproto(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  google::protobuf::internal::VerifyVersion(0x2DFD70, 0x2DFD70, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/builtin_pb/sentencepiece_model.pb.cc", a4);
  sentencepiece::NormalizerSpec::NormalizerSpec(&sentencepiece::_NormalizerSpec_default_instance_, 0);

  google::protobuf::internal::OnShutdownRun(google::protobuf::internal::DestroyMessage, &sentencepiece::_NormalizerSpec_default_instance_, v4);
}

void InitDefaultsscc_info_SelfTestData_sentencepiece_5fmodel_2eproto(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  google::protobuf::internal::VerifyVersion(0x2DFD70, 0x2DFD70, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/builtin_pb/sentencepiece_model.pb.cc", a4);
  sentencepiece::SelfTestData::SelfTestData(&sentencepiece::_SelfTestData_default_instance_, 0);

  google::protobuf::internal::OnShutdownRun(google::protobuf::internal::DestroyMessage, &sentencepiece::_SelfTestData_default_instance_, v4);
}

void InitDefaultsscc_info_SelfTestData_Sample_sentencepiece_5fmodel_2eproto(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  google::protobuf::internal::VerifyVersion(0x2DFD70, 0x2DFD70, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/builtin_pb/sentencepiece_model.pb.cc", a4);
  sentencepiece::SelfTestData_Sample::SelfTestData_Sample(sentencepiece::_SelfTestData_Sample_default_instance_, 0);

  google::protobuf::internal::OnShutdownRun(google::protobuf::internal::DestroyMessage, sentencepiece::_SelfTestData_Sample_default_instance_, v4);
}

void InitDefaultsscc_info_TrainerSpec_sentencepiece_5fmodel_2eproto(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  google::protobuf::internal::VerifyVersion(0x2DFD70, 0x2DFD70, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/builtin_pb/sentencepiece_model.pb.cc", a4);
  sentencepiece::TrainerSpec::TrainerSpec(&sentencepiece::_TrainerSpec_default_instance_, 0);

  google::protobuf::internal::OnShutdownRun(google::protobuf::internal::DestroyMessage, &sentencepiece::_TrainerSpec_default_instance_, v4);
}

uint64_t sentencepiece::TrainerSpec::TrainerSpec(uint64_t a1, uint64_t a2)
{
  *a1 = &unk_1F2D43670;
  *(a1 + 8) = a2;
  google::protobuf::internal::ExtensionSet::ExtensionSet(a1 + 16, a2);
  *(a1 + 128) = a2;
  *(a1 + 40) = 0;
  *(a1 + 56) = a2;
  *(a1 + 48) = 0;
  *(a1 + 64) = 0;
  *(a1 + 72) = 0;
  *(a1 + 80) = a2;
  *(a1 + 88) = 0;
  *(a1 + 96) = 0;
  *(a1 + 104) = a2;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0;
  *(a1 + 136) = 0;
  *(a1 + 144) = 0;
  if (atomic_load_explicit(scc_info_TrainerSpec_sentencepiece_5fmodel_2eproto, memory_order_acquire))
  {
    google::protobuf::internal::InitSCCImpl(scc_info_TrainerSpec_sentencepiece_5fmodel_2eproto);
  }

  *(a1 + 152) = &google::protobuf::internal::fixed_address_empty_string;
  *(a1 + 160) = &google::protobuf::internal::fixed_address_empty_string;
  *(a1 + 168) = &google::protobuf::internal::fixed_address_empty_string;
  *(a1 + 176) = 0u;
  *(a1 + 192) = 0u;
  *(a1 + 208) = 0u;
  *(a1 + 224) = 0u;
  *(a1 + 238) = 0;
  *(a1 + 248) = 0x1F4000000001;
  *(a1 + 256) = 0xF42403F7FDF3BLL;
  *(a1 + 264) = 1061158912;
  *(a1 + 268) = xmmword_1B5B3DE80;
  *(a1 + 284) = 16843009;
  *(a1 + 288) = 257;
  *(a1 + 292) = 1;
  *(a1 + 296) = 0xFFFFFFFF00000002;
  return a1;
}

void sub_1B5AA34C8(_Unwind_Exception *a1)
{
  google::protobuf::RepeatedPtrField<std::string>::~RepeatedPtrField(v3);
  google::protobuf::RepeatedPtrField<std::string>::~RepeatedPtrField(v5);
  google::protobuf::RepeatedPtrField<std::string>::~RepeatedPtrField(v4);
  google::protobuf::RepeatedPtrField<std::string>::~RepeatedPtrField(v2);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((v1 + 16));
  _Unwind_Resume(a1);
}

void sentencepiece::TrainerSpec::~TrainerSpec(sentencepiece::TrainerSpec *this)
{
  sentencepiece::TrainerSpec::SharedDtor(this);
  google::protobuf::internal::InternalMetadata::Delete<std::string>(this + 1);
  google::protobuf::RepeatedPtrField<std::string>::~RepeatedPtrField(this + 16);
  google::protobuf::RepeatedPtrField<std::string>::~RepeatedPtrField(this + 13);
  google::protobuf::RepeatedPtrField<std::string>::~RepeatedPtrField(this + 10);
  google::protobuf::RepeatedPtrField<std::string>::~RepeatedPtrField(this + 7);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((this + 16));
}

{
  sentencepiece::TrainerSpec::~TrainerSpec(this);

  JUMPOUT(0x1B8C85350);
}

void *sentencepiece::TrainerSpec::SharedDtor(void *this)
{
  v1 = this;
  v2 = this[19];
  if (v2 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v2 + 23) < 0)
    {
      operator delete(*v2);
    }

    this = MEMORY[0x1B8C85350](v2, 0x1012C40EC159624);
  }

  v3 = v1[20];
  if (v3 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v3 + 23) < 0)
    {
      operator delete(*v3);
    }

    this = MEMORY[0x1B8C85350](v3, 0x1012C40EC159624);
  }

  v4 = v1[21];
  if (v4 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v4 + 23) < 0)
    {
      operator delete(*v4);
    }

    this = MEMORY[0x1B8C85350](v4, 0x1012C40EC159624);
  }

  v5 = v1[22];
  if (v5)
  {
    if (*(v5 + 23) < 0)
    {
      operator delete(*v5);
    }

    this = MEMORY[0x1B8C85350](v5, 0x1012C40EC159624);
  }

  v6 = v1[23];
  if (v6)
  {
    if (*(v6 + 23) < 0)
    {
      operator delete(*v6);
    }

    this = MEMORY[0x1B8C85350](v6, 0x1012C40EC159624);
  }

  v7 = v1[24];
  if (v7)
  {
    if (*(v7 + 23) < 0)
    {
      operator delete(*v7);
    }

    this = MEMORY[0x1B8C85350](v7, 0x1012C40EC159624);
  }

  v8 = v1[25];
  if (v8)
  {
    if (*(v8 + 23) < 0)
    {
      operator delete(*v8);
    }

    this = MEMORY[0x1B8C85350](v8, 0x1012C40EC159624);
  }

  v9 = v1[26];
  if (v9)
  {
    if (*(v9 + 23) < 0)
    {
      operator delete(*v9);
    }

    JUMPOUT(0x1B8C85350);
  }

  return this;
}

uint64_t sentencepiece::TrainerSpec::Clear(sentencepiece::TrainerSpec *this)
{
  google::protobuf::internal::ExtensionSet::Clear(this + 16);
  google::protobuf::internal::RepeatedPtrFieldBase::Clear<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(this + 56);
  google::protobuf::internal::RepeatedPtrFieldBase::Clear<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(this + 80);
  google::protobuf::internal::RepeatedPtrFieldBase::Clear<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(this + 104);
  result = google::protobuf::internal::RepeatedPtrFieldBase::Clear<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(this + 128);
  v3 = *(this + 10);
  if (v3)
  {
    if ((v3 & 1) == 0)
    {
      if ((v3 & 2) == 0)
      {
        goto LABEL_4;
      }

LABEL_15:
      v5 = *(this + 20) & 0xFFFFFFFFFFFFFFFELL;
      if (*(v5 + 23) < 0)
      {
        **v5 = 0;
        *(v5 + 8) = 0;
        if ((v3 & 4) != 0)
        {
          goto LABEL_19;
        }
      }

      else
      {
        *v5 = 0;
        *(v5 + 23) = 0;
        if ((v3 & 4) != 0)
        {
          goto LABEL_19;
        }
      }

LABEL_5:
      if ((v3 & 8) == 0)
      {
        goto LABEL_6;
      }

LABEL_23:
      result = google::protobuf::internal::ArenaStringPtr::ClearToDefault((this + 176), &sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_unk_surface_);
      if ((v3 & 0x10) == 0)
      {
LABEL_7:
        if ((v3 & 0x20) == 0)
        {
          goto LABEL_8;
        }

        goto LABEL_25;
      }

LABEL_24:
      result = google::protobuf::internal::ArenaStringPtr::ClearToDefault((this + 184), &sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_unk_piece_);
      if ((v3 & 0x20) == 0)
      {
LABEL_8:
        if ((v3 & 0x40) == 0)
        {
          goto LABEL_9;
        }

        goto LABEL_26;
      }

LABEL_25:
      result = google::protobuf::internal::ArenaStringPtr::ClearToDefault(this + 8, &sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_bos_piece_);
      if ((v3 & 0x40) == 0)
      {
LABEL_9:
        if ((v3 & 0x80) == 0)
        {
          goto LABEL_28;
        }

LABEL_27:
        result = google::protobuf::internal::ArenaStringPtr::ClearToDefault((this + 208), &sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_pad_piece_);
        goto LABEL_28;
      }

LABEL_26:
      result = google::protobuf::internal::ArenaStringPtr::ClearToDefault((this + 200), &sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_eos_piece_);
      if ((v3 & 0x80) == 0)
      {
        goto LABEL_28;
      }

      goto LABEL_27;
    }

    v4 = *(this + 19) & 0xFFFFFFFFFFFFFFFELL;
    if (*(v4 + 23) < 0)
    {
      **v4 = 0;
      *(v4 + 8) = 0;
      if ((v3 & 2) != 0)
      {
        goto LABEL_15;
      }
    }

    else
    {
      *v4 = 0;
      *(v4 + 23) = 0;
      if ((v3 & 2) != 0)
      {
        goto LABEL_15;
      }
    }

LABEL_4:
    if ((v3 & 4) == 0)
    {
      goto LABEL_5;
    }

LABEL_19:
    v6 = *(this + 21) & 0xFFFFFFFFFFFFFFFELL;
    if (*(v6 + 23) < 0)
    {
      **v6 = 0;
      *(v6 + 8) = 0;
      if ((v3 & 8) != 0)
      {
        goto LABEL_23;
      }
    }

    else
    {
      *v6 = 0;
      *(v6 + 23) = 0;
      if ((v3 & 8) != 0)
      {
        goto LABEL_23;
      }
    }

LABEL_6:
    if ((v3 & 0x10) == 0)
    {
      goto LABEL_7;
    }

    goto LABEL_24;
  }

LABEL_28:
  if ((v3 & 0xFF00) != 0)
  {
    *(this + 27) = 0;
    *(this + 28) = 0;
    *(this + 29) = 0;
  }

  if ((v3 & 0xFF0000) != 0)
  {
    *(this + 122) = 0;
    *(this + 60) = 0;
    *(this + 31) = 0x1F4000000001;
    *(this + 32) = 0xF42403F7FDF3BLL;
    *(this + 66) = 1061158912;
  }

  if (HIBYTE(v3))
  {
    *(this + 268) = xmmword_1B5B3DE80;
    *(this + 71) = 16843009;
  }

  if ((*(this + 44) & 0x1F) != 0)
  {
    *(this + 144) = 257;
    *(this + 73) = 1;
    *(this + 37) = 0xFFFFFFFF00000002;
  }

  *(this + 5) = 0;
  v7 = *(this + 1);
  if (v7)
  {
    v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    if (*(v8 + 31) < 0)
    {
      **(v8 + 8) = 0;
      *(v8 + 16) = 0;
    }

    else
    {
      *(v8 + 8) = 0;
      *(v8 + 31) = 0;
    }
  }

  return result;
}

unsigned __int8 *sentencepiece::TrainerSpec::_InternalSerialize(sentencepiece::TrainerSpec *this, unsigned __int8 *a2, google::protobuf::io::EpsCopyOutputStream *a3)
{
  v6 = *(this + 16);
  if (v6 >= 1)
  {
    v7 = 8;
    do
    {
      v8 = *(*(this + 9) + v7);
      v9 = *(v8 + 23);
      if (v9 < 0 && (v9 = v8[1], v9 > 127) || *a3 - a2 + 14 < v9)
      {
        a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringOutline(a3, 1, v8, a2);
      }

      else
      {
        *a2 = 10;
        a2[1] = v9;
        if (*(v8 + 23) < 0)
        {
          v8 = *v8;
        }

        v10 = a2 + 2;
        memcpy(a2 + 2, v8, v9);
        a2 = &v10[v9];
      }

      v7 += 8;
      --v6;
    }

    while (v6);
  }

  v11 = *(this + 10);
  if (v11)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 2, (*(this + 19) & 0xFFFFFFFFFFFFFFFELL), a2);
    if ((v11 & 0x80000) == 0)
    {
LABEL_14:
      if ((v11 & 0x100000) == 0)
      {
        goto LABEL_36;
      }

      goto LABEL_15;
    }
  }

  else if ((v11 & 0x80000) == 0)
  {
    goto LABEL_14;
  }

  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v13 = *(this + 62);
  *a2 = 24;
  if (v13 > 0x7F)
  {
    a2[1] = v13 | 0x80;
    v15 = v13 >> 7;
    if (v13 >> 14)
    {
      a2 += 3;
      do
      {
        *(a2 - 1) = v15 | 0x80;
        v18 = v15 >> 7;
        ++a2;
        v19 = v15 >> 14;
        v15 >>= 7;
      }

      while (v19);
      *(a2 - 1) = v18;
      if ((v11 & 0x100000) == 0)
      {
        goto LABEL_36;
      }
    }

    else
    {
      a2[2] = v15;
      a2 += 3;
      if ((v11 & 0x100000) == 0)
      {
        goto LABEL_36;
      }
    }
  }

  else
  {
    a2[1] = v13;
    a2 += 2;
    if ((v11 & 0x100000) == 0)
    {
      goto LABEL_36;
    }
  }

LABEL_15:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v12 = *(this + 63);
  *a2 = 32;
  if (v12 > 0x7F)
  {
    a2[1] = v12 | 0x80;
    v14 = v12 >> 7;
    if (v12 >> 14)
    {
      a2 += 3;
      do
      {
        *(a2 - 1) = v14 | 0x80;
        v16 = v14 >> 7;
        ++a2;
        v17 = v14 >> 14;
        v14 >>= 7;
      }

      while (v17);
      *(a2 - 1) = v16;
    }

    else
    {
      a2[2] = v14;
      a2 += 3;
    }
  }

  else
  {
    a2[1] = v12;
    a2 += 2;
  }

LABEL_36:
  v20 = *(this + 22);
  if (v20 >= 1)
  {
    v21 = 8;
    do
    {
      v22 = *(*(this + 12) + v21);
      v23 = *(v22 + 23);
      if (v23 < 0 && (v23 = v22[1], v23 > 127) || *a3 - a2 + 14 < v23)
      {
        a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringOutline(a3, 5, v22, a2);
      }

      else
      {
        *a2 = 42;
        a2[1] = v23;
        if (*(v22 + 23) < 0)
        {
          v22 = *v22;
        }

        v24 = a2 + 2;
        memcpy(a2 + 2, v22, v23);
        a2 = &v24[v23];
      }

      v21 += 8;
      --v20;
    }

    while (v20);
  }

  if ((v11 & 0x100) != 0)
  {
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v25 = *(this + 54);
    *a2 = 48;
    if (v25 > 0x7F)
    {
      a2[1] = v25 | 0x80;
      v26 = v25 >> 7;
      if (v25 >> 14)
      {
        a2 += 3;
        do
        {
          *(a2 - 1) = v26 | 0x80;
          v27 = v26 >> 7;
          ++a2;
          v28 = v26 >> 14;
          v26 >>= 7;
        }

        while (v28);
        *(a2 - 1) = v27;
        if ((v11 & 2) != 0)
        {
          goto LABEL_78;
        }
      }

      else
      {
        a2[2] = v26;
        a2 += 3;
        if ((v11 & 2) != 0)
        {
          goto LABEL_78;
        }
      }
    }

    else
    {
      a2[1] = v25;
      a2 += 2;
      if ((v11 & 2) != 0)
      {
        goto LABEL_78;
      }
    }

LABEL_49:
    if ((v11 & 0x200000) == 0)
    {
      goto LABEL_50;
    }

    goto LABEL_79;
  }

  if ((v11 & 2) == 0)
  {
    goto LABEL_49;
  }

LABEL_78:
  a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 7, (*(this + 20) & 0xFFFFFFFFFFFFFFFELL), a2);
  if ((v11 & 0x200000) == 0)
  {
LABEL_50:
    if ((v11 & 0x400) == 0)
    {
      goto LABEL_51;
    }

    goto LABEL_82;
  }

LABEL_79:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v29 = *(this + 64);
  *a2 = 85;
  *(a2 + 1) = v29;
  a2 += 5;
  if ((v11 & 0x400) == 0)
  {
LABEL_51:
    if ((v11 & 0x200) == 0)
    {
      goto LABEL_52;
    }

LABEL_93:
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v34 = *(this + 55);
    *a2 = 96;
    if (v34 > 0x7F)
    {
      a2[1] = v34 | 0x80;
      v35 = v34 >> 7;
      if (v34 >> 14)
      {
        a2 += 3;
        do
        {
          *(a2 - 1) = v35 | 0x80;
          v36 = v35 >> 7;
          ++a2;
          v37 = v35 >> 14;
          v35 >>= 7;
        }

        while (v37);
        *(a2 - 1) = v36;
        if ((v11 & 0x800) != 0)
        {
          goto LABEL_104;
        }
      }

      else
      {
        a2[2] = v35;
        a2 += 3;
        if ((v11 & 0x800) != 0)
        {
          goto LABEL_104;
        }
      }
    }

    else
    {
      a2[1] = v34;
      a2 += 2;
      if ((v11 & 0x800) != 0)
      {
        goto LABEL_104;
      }
    }

LABEL_53:
    if ((v11 & 0x400000) == 0)
    {
      goto LABEL_54;
    }

LABEL_115:
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v42 = *(this + 65);
    *a2 = 112;
    if (v42 > 0x7F)
    {
      a2[1] = v42 | 0x80;
      v43 = v42 >> 7;
      if (v42 >> 14)
      {
        a2 += 3;
        do
        {
          *(a2 - 1) = v43 | 0x80;
          v44 = v43 >> 7;
          ++a2;
          v45 = v43 >> 14;
          v43 >>= 7;
        }

        while (v45);
        *(a2 - 1) = v44;
        if ((v11 & 0x800000) != 0)
        {
          goto LABEL_126;
        }
      }

      else
      {
        a2[2] = v43;
        a2 += 3;
        if ((v11 & 0x800000) != 0)
        {
          goto LABEL_126;
        }
      }
    }

    else
    {
      a2[1] = v42;
      a2 += 2;
      if ((v11 & 0x800000) != 0)
      {
        goto LABEL_126;
      }
    }

LABEL_55:
    if ((v11 & 0x1000000) == 0)
    {
      goto LABEL_56;
    }

LABEL_129:
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v47 = *(this + 67);
    *a2 = 384;
    if (v47 > 0x7F)
    {
      a2[2] = v47 | 0x80;
      v48 = v47 >> 7;
      if (v47 >> 14)
      {
        a2 += 4;
        do
        {
          *(a2 - 1) = v48 | 0x80;
          v49 = v48 >> 7;
          ++a2;
          v50 = v48 >> 14;
          v48 >>= 7;
        }

        while (v50);
        *(a2 - 1) = v49;
        if ((v11 & 0x2000000) != 0)
        {
          goto LABEL_140;
        }
      }

      else
      {
        a2[3] = v48;
        a2 += 4;
        if ((v11 & 0x2000000) != 0)
        {
          goto LABEL_140;
        }
      }
    }

    else
    {
      a2[2] = v47;
      a2 += 3;
      if ((v11 & 0x2000000) != 0)
      {
        goto LABEL_140;
      }
    }

LABEL_57:
    if ((v11 & 0x4000000) == 0)
    {
      goto LABEL_58;
    }

LABEL_151:
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v55 = *(this + 69);
    *a2 = 400;
    if (v55 > 0x7F)
    {
      a2[2] = v55 | 0x80;
      v56 = v55 >> 7;
      if (v55 >> 14)
      {
        a2 += 4;
        do
        {
          *(a2 - 1) = v56 | 0x80;
          v57 = v56 >> 7;
          ++a2;
          v58 = v56 >> 14;
          v56 >>= 7;
        }

        while (v58);
        *(a2 - 1) = v57;
        if ((v11 & 0x10000000) != 0)
        {
          goto LABEL_162;
        }
      }

      else
      {
        a2[3] = v56;
        a2 += 4;
        if ((v11 & 0x10000000) != 0)
        {
          goto LABEL_162;
        }
      }
    }

    else
    {
      a2[2] = v55;
      a2 += 3;
      if ((v11 & 0x10000000) != 0)
      {
        goto LABEL_162;
      }
    }

LABEL_59:
    if ((v11 & 0x8000000) == 0)
    {
      goto LABEL_60;
    }

LABEL_165:
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v60 = *(this + 70);
    *a2 = 416;
    if (v60 > 0x7F)
    {
      a2[2] = v60 | 0x80;
      v61 = v60 >> 7;
      if (v60 >> 14)
      {
        a2 += 4;
        do
        {
          *(a2 - 1) = v61 | 0x80;
          v62 = v61 >> 7;
          ++a2;
          v63 = v61 >> 14;
          v61 >>= 7;
        }

        while (v63);
        *(a2 - 1) = v62;
        if ((v11 & 0x20000000) != 0)
        {
          goto LABEL_176;
        }
      }

      else
      {
        a2[3] = v61;
        a2 += 4;
        if ((v11 & 0x20000000) != 0)
        {
          goto LABEL_176;
        }
      }
    }

    else
    {
      a2[2] = v60;
      a2 += 3;
      if ((v11 & 0x20000000) != 0)
      {
        goto LABEL_176;
      }
    }

LABEL_61:
    if ((v11 & 0x80000000) == 0)
    {
      goto LABEL_62;
    }

    goto LABEL_179;
  }

LABEL_82:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v30 = *(this + 28);
  *a2 = 88;
  if (v30 > 0x7F)
  {
    a2[1] = v30 | 0x80;
    v31 = v30 >> 7;
    if (v30 >> 14)
    {
      a2 += 3;
      do
      {
        *(a2 - 1) = v31 | 0x80;
        v32 = v31 >> 7;
        ++a2;
        v33 = v31 >> 14;
        v31 >>= 7;
      }

      while (v33);
      *(a2 - 1) = v32;
      if ((v11 & 0x200) != 0)
      {
        goto LABEL_93;
      }
    }

    else
    {
      a2[2] = v31;
      a2 += 3;
      if ((v11 & 0x200) != 0)
      {
        goto LABEL_93;
      }
    }
  }

  else
  {
    a2[1] = v30;
    a2 += 2;
    if ((v11 & 0x200) != 0)
    {
      goto LABEL_93;
    }
  }

LABEL_52:
  if ((v11 & 0x800) == 0)
  {
    goto LABEL_53;
  }

LABEL_104:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v38 = *(this + 58);
  *a2 = 104;
  if (v38 > 0x7F)
  {
    a2[1] = v38 | 0x80;
    v39 = v38 >> 7;
    if (v38 >> 14)
    {
      a2 += 3;
      do
      {
        *(a2 - 1) = v39 | 0x80;
        v40 = v39 >> 7;
        ++a2;
        v41 = v39 >> 14;
        v39 >>= 7;
      }

      while (v41);
      *(a2 - 1) = v40;
      if ((v11 & 0x400000) != 0)
      {
        goto LABEL_115;
      }
    }

    else
    {
      a2[2] = v39;
      a2 += 3;
      if ((v11 & 0x400000) != 0)
      {
        goto LABEL_115;
      }
    }
  }

  else
  {
    a2[1] = v38;
    a2 += 2;
    if ((v11 & 0x400000) != 0)
    {
      goto LABEL_115;
    }
  }

LABEL_54:
  if ((v11 & 0x800000) == 0)
  {
    goto LABEL_55;
  }

LABEL_126:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v46 = *(this + 66);
  *a2 = 125;
  *(a2 + 1) = v46;
  a2 += 5;
  if ((v11 & 0x1000000) != 0)
  {
    goto LABEL_129;
  }

LABEL_56:
  if ((v11 & 0x2000000) == 0)
  {
    goto LABEL_57;
  }

LABEL_140:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v51 = *(this + 68);
  *a2 = 392;
  if (v51 > 0x7F)
  {
    a2[2] = v51 | 0x80;
    v52 = v51 >> 7;
    if (v51 >> 14)
    {
      a2 += 4;
      do
      {
        *(a2 - 1) = v52 | 0x80;
        v53 = v52 >> 7;
        ++a2;
        v54 = v52 >> 14;
        v52 >>= 7;
      }

      while (v54);
      *(a2 - 1) = v53;
      if ((v11 & 0x4000000) != 0)
      {
        goto LABEL_151;
      }
    }

    else
    {
      a2[3] = v52;
      a2 += 4;
      if ((v11 & 0x4000000) != 0)
      {
        goto LABEL_151;
      }
    }
  }

  else
  {
    a2[2] = v51;
    a2 += 3;
    if ((v11 & 0x4000000) != 0)
    {
      goto LABEL_151;
    }
  }

LABEL_58:
  if ((v11 & 0x10000000) == 0)
  {
    goto LABEL_59;
  }

LABEL_162:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v59 = *(this + 284);
  *a2 = 408;
  a2[2] = v59;
  a2 += 3;
  if ((v11 & 0x8000000) != 0)
  {
    goto LABEL_165;
  }

LABEL_60:
  if ((v11 & 0x20000000) == 0)
  {
    goto LABEL_61;
  }

LABEL_176:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v64 = *(this + 285);
  *a2 = 424;
  a2[2] = v64;
  a2 += 3;
  if ((v11 & 0x80000000) == 0)
  {
LABEL_62:
    if ((v11 & 0x40000000) == 0)
    {
      goto LABEL_63;
    }

    goto LABEL_182;
  }

LABEL_179:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v65 = *(this + 287);
  *a2 = 432;
  a2[2] = v65;
  a2 += 3;
  if ((v11 & 0x40000000) == 0)
  {
LABEL_63:
    if ((v11 & 0x1000) == 0)
    {
      goto LABEL_64;
    }

    goto LABEL_185;
  }

LABEL_182:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v66 = *(this + 286);
  *a2 = 440;
  a2[2] = v66;
  a2 += 3;
  if ((v11 & 0x1000) == 0)
  {
LABEL_64:
    if ((v11 & 0x4000) == 0)
    {
      goto LABEL_65;
    }

    goto LABEL_188;
  }

LABEL_185:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v67 = *(this + 236);
  *a2 = 448;
  a2[2] = v67;
  a2 += 3;
  if ((v11 & 0x4000) == 0)
  {
LABEL_65:
    if ((v11 & 0x2000) == 0)
    {
      goto LABEL_194;
    }

    goto LABEL_191;
  }

LABEL_188:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v68 = *(this + 238);
  *a2 = 456;
  a2[2] = v68;
  a2 += 3;
  if ((v11 & 0x2000) != 0)
  {
LABEL_191:
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v69 = *(this + 237);
    *a2 = 464;
    a2[2] = v69;
    a2 += 3;
  }

LABEL_194:
  v70 = *(this + 28);
  if (v70 >= 1)
  {
    v71 = 8;
    do
    {
      v72 = *(*(this + 15) + v71);
      v73 = *(v72 + 23);
      if (v73 < 0 && (v73 = v72[1], v73 > 127) || *a3 - a2 + 13 < v73)
      {
        a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringOutline(a3, 30, v72, a2);
      }

      else
      {
        *a2 = 498;
        a2[2] = v73;
        if (*(v72 + 23) < 0)
        {
          v72 = *v72;
        }

        v74 = a2 + 3;
        memcpy(a2 + 3, v72, v73);
        a2 = &v74[v73];
      }

      v71 += 8;
      --v70;
    }

    while (v70);
  }

  v75 = *(this + 34);
  if (v75 >= 1)
  {
    v76 = 8;
    do
    {
      v77 = *(*(this + 18) + v76);
      v78 = *(v77 + 23);
      if (v78 < 0 && (v78 = v77[1], v78 > 127) || *a3 - a2 + 13 < v78)
      {
        a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringOutline(a3, 31, v77, a2);
      }

      else
      {
        *a2 = 506;
        a2[2] = v78;
        if (*(v77 + 23) < 0)
        {
          v77 = *v77;
        }

        v79 = a2 + 3;
        memcpy(a2 + 3, v77, v78);
        a2 = &v79[v78];
      }

      v76 += 8;
      --v75;
    }

    while (v75);
  }

  v80 = *(this + 11);
  if (v80)
  {
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v81 = *(this + 288);
    *a2 = 640;
    a2[2] = v81;
    a2 += 3;
  }

  if ((v80 & 2) != 0)
  {
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v82 = *(this + 289);
    *a2 = 648;
    a2[2] = v82;
    a2 += 3;
  }

  v83 = *(this + 10);
  if ((v83 & 0x20000) != 0)
  {
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v84 = *(this + 244);
    *a2 = 656;
    a2[2] = v84;
    a2 += 3;
    if ((v83 & 0x8000) == 0)
    {
LABEL_226:
      if ((v83 & 4) == 0)
      {
        goto LABEL_227;
      }

      goto LABEL_235;
    }
  }

  else if ((v83 & 0x8000) == 0)
  {
    goto LABEL_226;
  }

  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v85 = *(this + 239);
  *a2 = 664;
  a2[2] = v85;
  a2 += 3;
  if ((v83 & 4) == 0)
  {
LABEL_227:
    if ((v83 & 0x10000) == 0)
    {
      goto LABEL_245;
    }

    goto LABEL_236;
  }

LABEL_235:
  a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 36, (*(this + 21) & 0xFFFFFFFFFFFFFFFELL), a2);
  if ((v83 & 0x10000) == 0)
  {
    goto LABEL_245;
  }

LABEL_236:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v86 = *(this + 60);
  *a2 = 704;
  if (v86 > 0x7F)
  {
    a2[2] = v86 | 0x80;
    v87 = v86 >> 7;
    if (v86 >> 14)
    {
      a2 += 4;
      do
      {
        *(a2 - 1) = v87 | 0x80;
        v88 = v87 >> 7;
        ++a2;
        v89 = v87 >> 14;
        v87 >>= 7;
      }

      while (v89);
      *(a2 - 1) = v88;
    }

    else
    {
      a2[3] = v87;
      a2 += 4;
    }
  }

  else
  {
    a2[2] = v86;
    a2 += 3;
  }

LABEL_245:
  v90 = *(this + 11);
  if ((v90 & 4) != 0)
  {
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v92 = *(this + 73);
    *a2 = 712;
    if (v92 > 0x7F)
    {
      a2[2] = v92 | 0x80;
      v94 = v92 >> 7;
      if (v92 >> 14)
      {
        a2 += 4;
        do
        {
          *(a2 - 1) = v94 | 0x80;
          v97 = v94 >> 7;
          ++a2;
          v98 = v94 >> 14;
          v94 >>= 7;
        }

        while (v98);
        *(a2 - 1) = v97;
        if ((v90 & 8) != 0)
        {
          goto LABEL_268;
        }
      }

      else
      {
        a2[3] = v94;
        a2 += 4;
        if ((v90 & 8) != 0)
        {
          goto LABEL_268;
        }
      }
    }

    else
    {
      a2[2] = v92;
      a2 += 3;
      if ((v90 & 8) != 0)
      {
        goto LABEL_268;
      }
    }

LABEL_247:
    if ((v90 & 0x10) == 0)
    {
      goto LABEL_279;
    }

    goto LABEL_248;
  }

  if ((v90 & 8) == 0)
  {
    goto LABEL_247;
  }

LABEL_268:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v99 = *(this + 74);
  *a2 = 720;
  if (v99 > 0x7F)
  {
    a2[2] = v99 | 0x80;
    v100 = v99 >> 7;
    if (v99 >> 14)
    {
      a2 += 4;
      do
      {
        *(a2 - 1) = v100 | 0x80;
        v101 = v100 >> 7;
        ++a2;
        v102 = v100 >> 14;
        v100 >>= 7;
      }

      while (v102);
      *(a2 - 1) = v101;
      if ((v90 & 0x10) == 0)
      {
        goto LABEL_279;
      }
    }

    else
    {
      a2[3] = v100;
      a2 += 4;
      if ((v90 & 0x10) == 0)
      {
        goto LABEL_279;
      }
    }
  }

  else
  {
    a2[2] = v99;
    a2 += 3;
    if ((v90 & 0x10) == 0)
    {
      goto LABEL_279;
    }
  }

LABEL_248:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v91 = *(this + 75);
  *a2 = 728;
  if (v91 > 0x7F)
  {
    a2[2] = v91 | 0x80;
    v93 = v91 >> 7;
    if (v91 >> 14)
    {
      a2 += 4;
      do
      {
        *(a2 - 1) = v93 | 0x80;
        v95 = v93 >> 7;
        ++a2;
        v96 = v93 >> 14;
        v93 >>= 7;
      }

      while (v96);
      *(a2 - 1) = v95;
    }

    else
    {
      a2[3] = v93;
      a2 += 4;
    }
  }

  else
  {
    a2[2] = v91;
    a2 += 3;
  }

LABEL_279:
  v103 = *(this + 10);
  if ((v103 & 8) != 0)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 44, (*(this + 22) & 0xFFFFFFFFFFFFFFFELL), a2);
    if ((v103 & 0x10) == 0)
    {
LABEL_281:
      if ((v103 & 0x20) == 0)
      {
        goto LABEL_282;
      }

      goto LABEL_288;
    }
  }

  else if ((v103 & 0x10) == 0)
  {
    goto LABEL_281;
  }

  a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 45, (*(this + 23) & 0xFFFFFFFFFFFFFFFELL), a2);
  if ((v103 & 0x20) == 0)
  {
LABEL_282:
    if ((v103 & 0x40) == 0)
    {
      goto LABEL_283;
    }

    goto LABEL_289;
  }

LABEL_288:
  a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 46, (*(this + 24) & 0xFFFFFFFFFFFFFFFELL), a2);
  if ((v103 & 0x40) == 0)
  {
LABEL_283:
    if ((v103 & 0x80) == 0)
    {
      goto LABEL_284;
    }

    goto LABEL_290;
  }

LABEL_289:
  a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 47, (*(this + 25) & 0xFFFFFFFFFFFFFFFELL), a2);
  if ((v103 & 0x80) == 0)
  {
LABEL_284:
    if ((v103 & 0x40000) == 0)
    {
      goto LABEL_294;
    }

    goto LABEL_291;
  }

LABEL_290:
  a2 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 48, (*(this + 26) & 0xFFFFFFFFFFFFFFFELL), a2);
  if ((v103 & 0x40000) == 0)
  {
    goto LABEL_294;
  }

LABEL_291:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v104 = *(this + 245);
  *a2 = 904;
  a2[2] = v104;
  a2 += 3;
LABEL_294:
  v105 = google::protobuf::internal::ExtensionSet::_InternalSerialize((this + 16), 200, 0x20000000, a2, a3);
  v106 = v105;
  v107 = *(this + 1);
  if ((v107 & 1) == 0)
  {
    return v106;
  }

  v109 = v107 & 0xFFFFFFFFFFFFFFFELL;
  v110 = *(v109 + 31);
  if (v110 < 0)
  {
    v111 = *(v109 + 8);
    v110 = *(v109 + 16);
  }

  else
  {
    v111 = (v109 + 8);
  }

  if (*a3 - v105 >= v110)
  {
    v112 = v110;
    memcpy(v105, v111, v110);
    v106 += v112;
    return v106;
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(a3, v111, v110, v105);
}

uint64_t sentencepiece::TrainerSpec::ByteSizeLong(sentencepiece::TrainerSpec *this)
{
  v2 = google::protobuf::internal::ExtensionSet::ByteSize((this + 16));
  v3 = *(this + 16);
  v4 = v2 + v3;
  if (v3 >= 1)
  {
    v5 = (*(this + 9) + 8);
    do
    {
      v6 = *v5++;
      v7 = *(v6 + 23);
      v8 = *(v6 + 8);
      if ((v7 & 0x80u) == 0)
      {
        v8 = v7;
      }

      v4 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6);
      --v3;
    }

    while (v3);
  }

  v9 = *(this + 22);
  v10 = v4 + v9;
  if (v9 >= 1)
  {
    v11 = (*(this + 12) + 8);
    do
    {
      v12 = *v11++;
      v13 = *(v12 + 23);
      v14 = *(v12 + 8);
      if ((v13 & 0x80u) == 0)
      {
        v14 = v13;
      }

      v10 += v14 + ((9 * (__clz(v14 | 1) ^ 0x1F) + 73) >> 6);
      --v9;
    }

    while (v9);
  }

  v15 = *(this + 28);
  v16 = v10 + 2 * v15;
  if (v15 >= 1)
  {
    v17 = (*(this + 15) + 8);
    do
    {
      v18 = *v17++;
      v19 = *(v18 + 23);
      v20 = *(v18 + 8);
      if ((v19 & 0x80u) == 0)
      {
        v20 = v19;
      }

      v16 += v20 + ((9 * (__clz(v20 | 1) ^ 0x1F) + 73) >> 6);
      --v15;
    }

    while (v15);
  }

  v21 = *(this + 34);
  result = v16 + 2 * v21;
  if (v21 >= 1)
  {
    v23 = (*(this + 18) + 8);
    do
    {
      v24 = *v23++;
      v25 = *(v24 + 23);
      v26 = *(v24 + 8);
      if ((v25 & 0x80u) == 0)
      {
        v26 = v25;
      }

      result += v26 + ((9 * (__clz(v26 | 1) ^ 0x1F) + 73) >> 6);
      --v21;
    }

    while (v21);
  }

  v27 = *(this + 10);
  if (!v27)
  {
    goto LABEL_33;
  }

  if (v27)
  {
    v58 = *(this + 19) & 0xFFFFFFFFFFFFFFFELL;
    v59 = *(v58 + 23);
    v60 = *(v58 + 8);
    if ((v59 & 0x80u) == 0)
    {
      v60 = v59;
    }

    result += v60 + ((9 * (__clz(v60 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v27 & 2) == 0)
    {
LABEL_24:
      if ((v27 & 4) == 0)
      {
        goto LABEL_25;
      }

      goto LABEL_120;
    }
  }

  else if ((v27 & 2) == 0)
  {
    goto LABEL_24;
  }

  v61 = *(this + 20) & 0xFFFFFFFFFFFFFFFELL;
  v62 = *(v61 + 23);
  v63 = *(v61 + 8);
  if ((v62 & 0x80u) == 0)
  {
    v63 = v62;
  }

  result += v63 + ((9 * (__clz(v63 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v27 & 4) == 0)
  {
LABEL_25:
    if ((v27 & 8) == 0)
    {
      goto LABEL_26;
    }

    goto LABEL_123;
  }

LABEL_120:
  v64 = *(this + 21) & 0xFFFFFFFFFFFFFFFELL;
  v65 = *(v64 + 23);
  v66 = *(v64 + 8);
  if ((v65 & 0x80u) == 0)
  {
    v66 = v65;
  }

  result += v66 + ((9 * (__clz(v66 | 1) ^ 0x1F) + 73) >> 6) + 2;
  if ((v27 & 8) == 0)
  {
LABEL_26:
    if ((v27 & 0x10) == 0)
    {
      goto LABEL_27;
    }

    goto LABEL_126;
  }

LABEL_123:
  v67 = *(this + 22) & 0xFFFFFFFFFFFFFFFELL;
  v68 = *(v67 + 23);
  v69 = *(v67 + 8);
  if ((v68 & 0x80u) == 0)
  {
    v69 = v68;
  }

  result += v69 + ((9 * (__clz(v69 | 1) ^ 0x1F) + 73) >> 6) + 2;
  if ((v27 & 0x10) == 0)
  {
LABEL_27:
    if ((v27 & 0x20) == 0)
    {
      goto LABEL_28;
    }

LABEL_129:
    v73 = *(this + 24) & 0xFFFFFFFFFFFFFFFELL;
    v74 = *(v73 + 23);
    v75 = *(v73 + 8);
    if ((v74 & 0x80u) == 0)
    {
      v75 = v74;
    }

    result += v75 + ((9 * (__clz(v75 | 1) ^ 0x1F) + 73) >> 6) + 2;
    if ((v27 & 0x40) == 0)
    {
LABEL_29:
      if ((v27 & 0x80) == 0)
      {
        goto LABEL_33;
      }

      goto LABEL_30;
    }

    goto LABEL_132;
  }

LABEL_126:
  v70 = *(this + 23) & 0xFFFFFFFFFFFFFFFELL;
  v71 = *(v70 + 23);
  v72 = *(v70 + 8);
  if ((v71 & 0x80u) == 0)
  {
    v72 = v71;
  }

  result += v72 + ((9 * (__clz(v72 | 1) ^ 0x1F) + 73) >> 6) + 2;
  if ((v27 & 0x20) != 0)
  {
    goto LABEL_129;
  }

LABEL_28:
  if ((v27 & 0x40) == 0)
  {
    goto LABEL_29;
  }

LABEL_132:
  v76 = *(this + 25) & 0xFFFFFFFFFFFFFFFELL;
  v77 = *(v76 + 23);
  v78 = *(v76 + 8);
  if ((v77 & 0x80u) == 0)
  {
    v78 = v77;
  }

  result += v78 + ((9 * (__clz(v78 | 1) ^ 0x1F) + 73) >> 6) + 2;
  if ((v27 & 0x80) != 0)
  {
LABEL_30:
    v28 = *(this + 26) & 0xFFFFFFFFFFFFFFFELL;
    v29 = *(v28 + 23);
    v30 = *(v28 + 8);
    if ((v29 & 0x80u) == 0)
    {
      v30 = v29;
    }

    result += v30 + ((9 * (__clz(v30 | 1) ^ 0x1F) + 73) >> 6) + 2;
  }

LABEL_33:
  if ((v27 & 0xFF00) == 0)
  {
    goto LABEL_51;
  }

  if ((v27 & 0x100) != 0)
  {
    v79 = *(this + 54);
    v80 = ((9 * (__clz(v79 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if (v79 >= 0)
    {
      v81 = v80;
    }

    else
    {
      v81 = 11;
    }

    result += v81;
    if ((v27 & 0x200) == 0)
    {
LABEL_36:
      if ((v27 & 0x400) == 0)
      {
        goto LABEL_37;
      }

LABEL_144:
      result += ((9 * (__clz(*(this + 28) | 1) ^ 0x3F) + 73) >> 6) + 1;
      if ((v27 & 0x800) != 0)
      {
        goto LABEL_38;
      }

      goto LABEL_42;
    }
  }

  else if ((v27 & 0x200) == 0)
  {
    goto LABEL_36;
  }

  v82 = *(this + 55);
  v83 = ((9 * (__clz(v82 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if (v82 >= 0)
  {
    v84 = v83;
  }

  else
  {
    v84 = 11;
  }

  result += v84;
  if ((v27 & 0x400) != 0)
  {
    goto LABEL_144;
  }

LABEL_37:
  if ((v27 & 0x800) != 0)
  {
LABEL_38:
    v31 = *(this + 58);
    v32 = ((9 * (__clz(v31 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if (v31 >= 0)
    {
      v33 = v32;
    }

    else
    {
      v33 = 11;
    }

    result += v33;
  }

LABEL_42:
  v34 = result + 3;
  if ((v27 & 0x1000) == 0)
  {
    v34 = result;
  }

  if ((v27 & 0x2000) != 0)
  {
    v34 += 3;
  }

  if ((v27 & 0x4000) != 0)
  {
    v34 += 3;
  }

  if ((v27 & 0x8000) != 0)
  {
    result = v34 + 3;
  }

  else
  {
    result = v34;
  }

LABEL_51:
  if ((v27 & 0xFF0000) != 0)
  {
    if ((v27 & 0x10000) != 0)
    {
      v35 = *(this + 60);
      v36 = ((9 * (__clz(v35 | 1) ^ 0x1F) + 73) >> 6) + 2;
      if (v35 >= 0)
      {
        v37 = v36;
      }

      else
      {
        v37 = 12;
      }

      result += v37;
    }

    v38 = result + 3;
    if ((v27 & 0x20000) == 0)
    {
      v38 = result;
    }

    if ((v27 & 0x40000) != 0)
    {
      v38 += 3;
    }

    if ((v27 & 0x80000) != 0)
    {
      v39 = *(this + 62);
      v40 = ((9 * (__clz(v39 | 1) ^ 0x1F) + 73) >> 6) + 1;
      if (v39 >= 0)
      {
        v41 = v40;
      }

      else
      {
        v41 = 11;
      }

      v38 += v41;
    }

    if ((v27 & 0x100000) != 0)
    {
      v42 = *(this + 63);
      v43 = ((9 * (__clz(v42 | 1) ^ 0x1F) + 73) >> 6) + 1;
      if (v42 >= 0)
      {
        v44 = v43;
      }

      else
      {
        v44 = 11;
      }

      v38 += v44;
    }

    if ((v27 & 0x200000) != 0)
    {
      v38 += 5;
    }

    if ((v27 & 0x400000) != 0)
    {
      v45 = *(this + 65);
      v46 = ((9 * (__clz(v45 | 1) ^ 0x1F) + 73) >> 6) + 1;
      if (v45 >= 0)
      {
        v47 = v46;
      }

      else
      {
        v47 = 11;
      }

      v38 += v47;
    }

    if ((v27 & 0x800000) != 0)
    {
      result = v38 + 5;
    }

    else
    {
      result = v38;
    }
  }

  if (HIBYTE(v27))
  {
    if ((v27 & 0x1000000) != 0)
    {
      v91 = *(this + 67);
      v92 = ((9 * (__clz(v91 | 1) ^ 0x1F) + 73) >> 6) + 2;
      if (v91 >= 0)
      {
        v93 = v92;
      }

      else
      {
        v93 = 12;
      }

      result += v93;
      if ((v27 & 0x2000000) == 0)
      {
LABEL_84:
        if ((v27 & 0x4000000) == 0)
        {
          goto LABEL_85;
        }

        goto LABEL_163;
      }
    }

    else if ((v27 & 0x2000000) == 0)
    {
      goto LABEL_84;
    }

    v94 = *(this + 68);
    v95 = ((9 * (__clz(v94 | 1) ^ 0x1F) + 73) >> 6) + 2;
    if (v94 >= 0)
    {
      v96 = v95;
    }

    else
    {
      v96 = 12;
    }

    result += v96;
    if ((v27 & 0x4000000) == 0)
    {
LABEL_85:
      if ((v27 & 0x8000000) == 0)
      {
LABEL_90:
        v51 = result + 3;
        if ((v27 & 0x10000000) == 0)
        {
          v51 = result;
        }

        if ((v27 & 0x20000000) != 0)
        {
          v51 += 3;
        }

        if ((v27 & 0x40000000) != 0)
        {
          v51 += 3;
        }

        if (v27 >= 0)
        {
          result = v51;
        }

        else
        {
          result = v51 + 3;
        }

        goto LABEL_99;
      }

LABEL_86:
      v48 = *(this + 70);
      v49 = ((9 * (__clz(v48 | 1) ^ 0x1F) + 73) >> 6) + 2;
      if (v48 >= 0)
      {
        v50 = v49;
      }

      else
      {
        v50 = 12;
      }

      result += v50;
      goto LABEL_90;
    }

LABEL_163:
    v97 = *(this + 69);
    v98 = ((9 * (__clz(v97 | 1) ^ 0x1F) + 73) >> 6) + 2;
    if (v97 >= 0)
    {
      v99 = v98;
    }

    else
    {
      v99 = 12;
    }

    result += v99;
    if ((v27 & 0x8000000) == 0)
    {
      goto LABEL_90;
    }

    goto LABEL_86;
  }

LABEL_99:
  v52 = *(this + 11);
  if ((v52 & 0x1F) == 0)
  {
    goto LABEL_112;
  }

  v53 = result + 3;
  if ((v52 & 1) == 0)
  {
    v53 = result;
  }

  if ((v52 & 2) != 0)
  {
    result = v53 + 3;
  }

  else
  {
    result = v53;
  }

  if ((v52 & 4) != 0)
  {
    v85 = *(this + 73);
    v86 = ((9 * (__clz(v85 | 1) ^ 0x1F) + 73) >> 6) + 2;
    if (v85 >= 0)
    {
      v87 = v86;
    }

    else
    {
      v87 = 12;
    }

    result += v87;
    if ((v52 & 8) == 0)
    {
LABEL_107:
      if ((v52 & 0x10) == 0)
      {
        goto LABEL_112;
      }

      goto LABEL_108;
    }
  }

  else if ((v52 & 8) == 0)
  {
    goto LABEL_107;
  }

  v88 = *(this + 74);
  v89 = ((9 * (__clz(v88 | 1) ^ 0x1F) + 73) >> 6) + 2;
  if (v88 >= 0)
  {
    v90 = v89;
  }

  else
  {
    v90 = 12;
  }

  result += v90;
  if ((v52 & 0x10) != 0)
  {
LABEL_108:
    v54 = *(this + 75);
    v55 = ((9 * (__clz(v54 | 1) ^ 0x1F) + 73) >> 6) + 2;
    if (v54 >= 0)
    {
      v56 = v55;
    }

    else
    {
      v56 = 12;
    }

    result += v56;
  }

LABEL_112:
  v57 = *(this + 1);
  if (v57)
  {
    v100 = v57 & 0xFFFFFFFFFFFFFFFELL;
    v101 = *((v57 & 0xFFFFFFFFFFFFFFFELL) + 31);
    if (v101 < 0)
    {
      v101 = *(v100 + 16);
    }

    result += v101;
  }

  *(this + 12) = result;
  return result;
}

void sentencepiece::TrainerSpec::MergeFrom(sentencepiece::TrainerSpec *this, const sentencepiece::TrainerSpec *a2)
{
  google::protobuf::internal::ExtensionSet::MergeFrom((this + 16), (a2 + 16));
  v4 = *(a2 + 1);
  if (v4)
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v6 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 8;
    v7 = *(this + 1);
    if (v7)
    {
      v8 = ((v7 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }

    else
    {
      v8 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(this + 1);
    }

    v9 = *(v5 + 31);
    if (v9 >= 0)
    {
      v10 = v6;
    }

    else
    {
      v10 = *(v5 + 8);
    }

    if (v9 >= 0)
    {
      v11 = *(v5 + 31);
    }

    else
    {
      v11 = *(v5 + 16);
    }

    std::string::append(v8, v10, v11);
  }

  v12 = *(a2 + 16);
  if (v12)
  {
    v13 = *(a2 + 9);
    v14 = google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend((this + 56), *(a2 + 16));
    google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>((this + 56), v14, (v13 + 8), v12, **(this + 9) - *(this + 16));
    v15 = *(this + 16) + v12;
    *(this + 16) = v15;
    v16 = *(this + 9);
    if (*v16 < v15)
    {
      *v16 = v15;
    }
  }

  v17 = *(a2 + 22);
  if (v17)
  {
    v18 = *(a2 + 12);
    v19 = google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend((this + 80), *(a2 + 22));
    google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>((this + 80), v19, (v18 + 8), v17, **(this + 12) - *(this + 22));
    v20 = *(this + 22) + v17;
    *(this + 22) = v20;
    v21 = *(this + 12);
    if (*v21 < v20)
    {
      *v21 = v20;
    }
  }

  v22 = *(a2 + 28);
  if (v22)
  {
    v23 = *(a2 + 15);
    v24 = google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend((this + 104), *(a2 + 28));
    google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>((this + 104), v24, (v23 + 8), v22, **(this + 15) - *(this + 28));
    v25 = *(this + 28) + v22;
    *(this + 28) = v25;
    v26 = *(this + 15);
    if (*v26 < v25)
    {
      *v26 = v25;
    }
  }

  v27 = *(a2 + 34);
  if (v27)
  {
    v28 = *(a2 + 18);
    v29 = google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend((this + 128), *(a2 + 34));
    google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>((this + 128), v29, (v28 + 8), v27, **(this + 18) - *(this + 34));
    v30 = *(this + 34) + v27;
    *(this + 34) = v30;
    v31 = *(this + 18);
    if (*v31 < v30)
    {
      *v31 = v30;
    }
  }

  v32 = *(a2 + 10);
  if (!v32)
  {
    goto LABEL_57;
  }

  if (v32)
  {
    v33 = *(a2 + 19);
    *(this + 10) |= 1u;
    v34 = *(this + 1);
    if (v34)
    {
      v34 = *(v34 & 0xFFFFFFFFFFFFFFFELL);
    }

    google::protobuf::internal::ArenaStringPtr::Set(this + 19, v33 & 0xFFFFFFFFFFFFFFFELL, v34);
    if ((v32 & 2) == 0)
    {
LABEL_26:
      if ((v32 & 4) == 0)
      {
        goto LABEL_27;
      }

      goto LABEL_39;
    }
  }

  else if ((v32 & 2) == 0)
  {
    goto LABEL_26;
  }

  v35 = *(a2 + 20);
  *(this + 10) |= 2u;
  v36 = *(this + 1);
  if (v36)
  {
    v36 = *(v36 & 0xFFFFFFFFFFFFFFFELL);
  }

  google::protobuf::internal::ArenaStringPtr::Set(this + 20, v35 & 0xFFFFFFFFFFFFFFFELL, v36);
  if ((v32 & 4) == 0)
  {
LABEL_27:
    if ((v32 & 8) == 0)
    {
      goto LABEL_28;
    }

    goto LABEL_42;
  }

LABEL_39:
  v37 = *(a2 + 21);
  *(this + 10) |= 4u;
  v38 = *(this + 1);
  if (v38)
  {
    v38 = *(v38 & 0xFFFFFFFFFFFFFFFELL);
  }

  google::protobuf::internal::ArenaStringPtr::Set(this + 21, v37 & 0xFFFFFFFFFFFFFFFELL, v38);
  if ((v32 & 8) == 0)
  {
LABEL_28:
    if ((v32 & 0x10) == 0)
    {
      goto LABEL_29;
    }

    goto LABEL_45;
  }

LABEL_42:
  v39 = *(a2 + 22);
  *(this + 10) |= 8u;
  v40 = *(this + 1);
  if (v40)
  {
    v40 = *(v40 & 0xFFFFFFFFFFFFFFFELL);
  }

  google::protobuf::internal::ArenaStringPtr::Set(this + 22, v39 & 0xFFFFFFFFFFFFFFFELL, v40);
  if ((v32 & 0x10) == 0)
  {
LABEL_29:
    if ((v32 & 0x20) == 0)
    {
      goto LABEL_30;
    }

LABEL_48:
    v43 = *(a2 + 24);
    *(this + 10) |= 0x20u;
    v44 = *(this + 1);
    if (v44)
    {
      v44 = *(v44 & 0xFFFFFFFFFFFFFFFELL);
    }

    google::protobuf::internal::ArenaStringPtr::Set(this + 24, v43 & 0xFFFFFFFFFFFFFFFELL, v44);
    if ((v32 & 0x40) == 0)
    {
LABEL_31:
      if ((v32 & 0x80) == 0)
      {
        goto LABEL_57;
      }

      goto LABEL_54;
    }

    goto LABEL_51;
  }

LABEL_45:
  v41 = *(a2 + 23);
  *(this + 10) |= 0x10u;
  v42 = *(this + 1);
  if (v42)
  {
    v42 = *(v42 & 0xFFFFFFFFFFFFFFFELL);
  }

  google::protobuf::internal::ArenaStringPtr::Set(this + 23, v41 & 0xFFFFFFFFFFFFFFFELL, v42);
  if ((v32 & 0x20) != 0)
  {
    goto LABEL_48;
  }

LABEL_30:
  if ((v32 & 0x40) == 0)
  {
    goto LABEL_31;
  }

LABEL_51:
  v45 = *(a2 + 25);
  *(this + 10) |= 0x40u;
  v46 = *(this + 1);
  if (v46)
  {
    v46 = *(v46 & 0xFFFFFFFFFFFFFFFELL);
  }

  google::protobuf::internal::ArenaStringPtr::Set(this + 25, v45 & 0xFFFFFFFFFFFFFFFELL, v46);
  if ((v32 & 0x80) != 0)
  {
LABEL_54:
    v47 = *(a2 + 26);
    *(this + 10) |= 0x80u;
    v48 = *(this + 1);
    if (v48)
    {
      v48 = *(v48 & 0xFFFFFFFFFFFFFFFELL);
    }

    google::protobuf::internal::ArenaStringPtr::Set(this + 26, v47 & 0xFFFFFFFFFFFFFFFELL, v48);
  }

LABEL_57:
  if ((v32 & 0xFF00) == 0)
  {
    goto LABEL_68;
  }

  if ((v32 & 0x100) != 0)
  {
    *(this + 54) = *(a2 + 54);
    if ((v32 & 0x200) == 0)
    {
LABEL_60:
      if ((v32 & 0x400) == 0)
      {
        goto LABEL_61;
      }

      goto LABEL_100;
    }
  }

  else if ((v32 & 0x200) == 0)
  {
    goto LABEL_60;
  }

  *(this + 55) = *(a2 + 55);
  if ((v32 & 0x400) == 0)
  {
LABEL_61:
    if ((v32 & 0x800) == 0)
    {
      goto LABEL_62;
    }

    goto LABEL_101;
  }

LABEL_100:
  *(this + 28) = *(a2 + 28);
  if ((v32 & 0x800) == 0)
  {
LABEL_62:
    if ((v32 & 0x1000) == 0)
    {
      goto LABEL_63;
    }

    goto LABEL_102;
  }

LABEL_101:
  *(this + 58) = *(a2 + 58);
  if ((v32 & 0x1000) == 0)
  {
LABEL_63:
    if ((v32 & 0x2000) == 0)
    {
      goto LABEL_64;
    }

    goto LABEL_103;
  }

LABEL_102:
  *(this + 236) = *(a2 + 236);
  if ((v32 & 0x2000) == 0)
  {
LABEL_64:
    if ((v32 & 0x4000) == 0)
    {
      goto LABEL_65;
    }

LABEL_104:
    *(this + 238) = *(a2 + 238);
    if ((v32 & 0x8000) == 0)
    {
      goto LABEL_67;
    }

    goto LABEL_66;
  }

LABEL_103:
  *(this + 237) = *(a2 + 237);
  if ((v32 & 0x4000) != 0)
  {
    goto LABEL_104;
  }

LABEL_65:
  if ((v32 & 0x8000) != 0)
  {
LABEL_66:
    *(this + 239) = *(a2 + 239);
  }

LABEL_67:
  *(this + 10) |= v32;
LABEL_68:
  if ((v32 & 0xFF0000) == 0)
  {
    goto LABEL_79;
  }

  if ((v32 & 0x10000) != 0)
  {
    *(this + 60) = *(a2 + 60);
    if ((v32 & 0x20000) == 0)
    {
LABEL_71:
      if ((v32 & 0x40000) == 0)
      {
        goto LABEL_72;
      }

      goto LABEL_108;
    }
  }

  else if ((v32 & 0x20000) == 0)
  {
    goto LABEL_71;
  }

  *(this + 244) = *(a2 + 244);
  if ((v32 & 0x40000) == 0)
  {
LABEL_72:
    if ((v32 & 0x80000) == 0)
    {
      goto LABEL_73;
    }

    goto LABEL_109;
  }

LABEL_108:
  *(this + 245) = *(a2 + 245);
  if ((v32 & 0x80000) == 0)
  {
LABEL_73:
    if ((v32 & 0x100000) == 0)
    {
      goto LABEL_74;
    }

    goto LABEL_110;
  }

LABEL_109:
  *(this + 62) = *(a2 + 62);
  if ((v32 & 0x100000) == 0)
  {
LABEL_74:
    if ((v32 & 0x200000) == 0)
    {
      goto LABEL_75;
    }

    goto LABEL_111;
  }

LABEL_110:
  *(this + 63) = *(a2 + 63);
  if ((v32 & 0x200000) == 0)
  {
LABEL_75:
    if ((v32 & 0x400000) == 0)
    {
      goto LABEL_76;
    }

LABEL_112:
    *(this + 65) = *(a2 + 65);
    if ((v32 & 0x800000) == 0)
    {
      goto LABEL_78;
    }

    goto LABEL_77;
  }

LABEL_111:
  *(this + 64) = *(a2 + 64);
  if ((v32 & 0x400000) != 0)
  {
    goto LABEL_112;
  }

LABEL_76:
  if ((v32 & 0x800000) != 0)
  {
LABEL_77:
    *(this + 66) = *(a2 + 66);
  }

LABEL_78:
  *(this + 10) |= v32;
LABEL_79:
  if (!HIBYTE(v32))
  {
    goto LABEL_89;
  }

  if ((v32 & 0x1000000) != 0)
  {
    *(this + 67) = *(a2 + 67);
    if ((v32 & 0x2000000) == 0)
    {
LABEL_82:
      if ((v32 & 0x4000000) == 0)
      {
        goto LABEL_83;
      }

      goto LABEL_121;
    }
  }

  else if ((v32 & 0x2000000) == 0)
  {
    goto LABEL_82;
  }

  *(this + 68) = *(a2 + 68);
  if ((v32 & 0x4000000) == 0)
  {
LABEL_83:
    if ((v32 & 0x8000000) == 0)
    {
      goto LABEL_84;
    }

    goto LABEL_122;
  }

LABEL_121:
  *(this + 69) = *(a2 + 69);
  if ((v32 & 0x8000000) == 0)
  {
LABEL_84:
    if ((v32 & 0x10000000) == 0)
    {
      goto LABEL_85;
    }

    goto LABEL_123;
  }

LABEL_122:
  *(this + 70) = *(a2 + 70);
  if ((v32 & 0x10000000) == 0)
  {
LABEL_85:
    if ((v32 & 0x20000000) == 0)
    {
      goto LABEL_86;
    }

    goto LABEL_124;
  }

LABEL_123:
  *(this + 284) = *(a2 + 284);
  if ((v32 & 0x20000000) == 0)
  {
LABEL_86:
    if ((v32 & 0x40000000) == 0)
    {
      goto LABEL_87;
    }

LABEL_125:
    *(this + 286) = *(a2 + 286);
    if ((v32 & 0x80000000) == 0)
    {
      goto LABEL_88;
    }

LABEL_126:
    *(this + 287) = *(a2 + 287);
    goto LABEL_88;
  }

LABEL_124:
  *(this + 285) = *(a2 + 285);
  if ((v32 & 0x40000000) != 0)
  {
    goto LABEL_125;
  }

LABEL_87:
  if ((v32 & 0x80000000) != 0)
  {
    goto LABEL_126;
  }

LABEL_88:
  *(this + 10) |= v32;
LABEL_89:
  v49 = *(a2 + 11);
  if ((v49 & 0x1F) == 0)
  {
    return;
  }

  if (v49)
  {
    *(this + 288) = *(a2 + 288);
    if ((v49 & 2) == 0)
    {
LABEL_92:
      if ((v49 & 4) == 0)
      {
        goto LABEL_93;
      }

      goto LABEL_116;
    }
  }

  else if ((v49 & 2) == 0)
  {
    goto LABEL_92;
  }

  *(this + 289) = *(a2 + 289);
  if ((v49 & 4) == 0)
  {
LABEL_93:
    if ((v49 & 8) == 0)
    {
      goto LABEL_94;
    }

LABEL_117:
    *(this + 74) = *(a2 + 74);
    if ((v49 & 0x10) == 0)
    {
      goto LABEL_96;
    }

    goto LABEL_95;
  }

LABEL_116:
  *(this + 73) = *(a2 + 73);
  if ((v49 & 8) != 0)
  {
    goto LABEL_117;
  }

LABEL_94:
  if ((v49 & 0x10) != 0)
  {
LABEL_95:
    *(this + 75) = *(a2 + 75);
  }

LABEL_96:
  *(this + 11) |= v49;
}

uint64_t sentencepiece::NormalizerSpec::NormalizerSpec(uint64_t a1, uint64_t a2)
{
  *a1 = &unk_1F2D436F0;
  *(a1 + 8) = a2;
  google::protobuf::internal::ExtensionSet::ExtensionSet(a1 + 16, a2);
  *(a1 + 40) = 0;
  if (atomic_load_explicit(scc_info_NormalizerSpec_sentencepiece_5fmodel_2eproto, memory_order_acquire))
  {
    google::protobuf::internal::InitSCCImpl(scc_info_NormalizerSpec_sentencepiece_5fmodel_2eproto);
  }

  *(a1 + 48) = &google::protobuf::internal::fixed_address_empty_string;
  *(a1 + 56) = &google::protobuf::internal::fixed_address_empty_string;
  *(a1 + 64) = &google::protobuf::internal::fixed_address_empty_string;
  *(a1 + 72) = 257;
  *(a1 + 74) = 1;
  return a1;
}

void sentencepiece::NormalizerSpec::~NormalizerSpec(sentencepiece::NormalizerSpec *this)
{
  v2 = *(this + 6);
  if (v2 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v2 + 23) < 0)
    {
      operator delete(*v2);
    }

    MEMORY[0x1B8C85350](v2, 0x1012C40EC159624);
  }

  v3 = *(this + 7);
  if (v3 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v3 + 23) < 0)
    {
      operator delete(*v3);
    }

    MEMORY[0x1B8C85350](v3, 0x1012C40EC159624);
  }

  v4 = *(this + 8);
  if (v4 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v4 + 23) < 0)
    {
      operator delete(*v4);
    }

    MEMORY[0x1B8C85350](v4, 0x1012C40EC159624);
  }

  google::protobuf::internal::InternalMetadata::Delete<std::string>(this + 1);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((this + 16));
}

{
  sentencepiece::NormalizerSpec::~NormalizerSpec(this);

  JUMPOUT(0x1B8C85350);
}

unsigned __int8 *sentencepiece::NormalizerSpec::Clear(sentencepiece::NormalizerSpec *this)
{
  result = google::protobuf::internal::ExtensionSet::Clear(this + 16);
  v3 = *(this + 10);
  if ((v3 & 0x3F) != 0)
  {
    if ((v3 & 1) == 0)
    {
      if ((v3 & 2) == 0)
      {
        goto LABEL_4;
      }

LABEL_10:
      v5 = *(this + 7) & 0xFFFFFFFFFFFFFFFELL;
      if (*(v5 + 23) < 0)
      {
        **v5 = 0;
        *(v5 + 8) = 0;
        if ((v3 & 4) == 0)
        {
LABEL_17:
          *(this + 36) = 257;
          *(this + 74) = 1;
          goto LABEL_18;
        }
      }

      else
      {
        *v5 = 0;
        *(v5 + 23) = 0;
        if ((v3 & 4) == 0)
        {
          goto LABEL_17;
        }
      }

LABEL_14:
      v6 = *(this + 8) & 0xFFFFFFFFFFFFFFFELL;
      if (*(v6 + 23) < 0)
      {
        **v6 = 0;
        *(v6 + 8) = 0;
      }

      else
      {
        *v6 = 0;
        *(v6 + 23) = 0;
      }

      goto LABEL_17;
    }

    v4 = *(this + 6) & 0xFFFFFFFFFFFFFFFELL;
    if (*(v4 + 23) < 0)
    {
      **v4 = 0;
      *(v4 + 8) = 0;
      if ((v3 & 2) != 0)
      {
        goto LABEL_10;
      }
    }

    else
    {
      *v4 = 0;
      *(v4 + 23) = 0;
      if ((v3 & 2) != 0)
      {
        goto LABEL_10;
      }
    }

LABEL_4:
    if ((v3 & 4) == 0)
    {
      goto LABEL_17;
    }

    goto LABEL_14;
  }

LABEL_18:
  *(this + 10) = 0;
  v7 = *(this + 1);
  if (v7)
  {
    v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    if (*(v8 + 31) < 0)
    {
      **(v8 + 8) = 0;
      *(v8 + 16) = 0;
    }

    else
    {
      *(v8 + 8) = 0;
      *(v8 + 31) = 0;
    }
  }

  return result;
}

google::protobuf::internal *sentencepiece::NormalizerSpec::_InternalParse(uint64_t a1, google::protobuf::internal *a2, int32x2_t *this)
{
  v36 = a2;
  v5 = 0;
  if ((google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v36, this[11].i32[1]) & 1) == 0)
  {
    while (1)
    {
      v7 = (v36 + 1);
      v8 = *v36;
      if ((*v36 & 0x80000000) == 0)
      {
        goto LABEL_6;
      }

      v9 = v8 + (*v7 << 7);
      v8 = v9 - 128;
      if ((*v7 & 0x80000000) == 0)
      {
        break;
      }

      TagFallback = google::protobuf::internal::ReadTagFallback(v36, (v9 - 128));
      v36 = TagFallback;
      if (!TagFallback)
      {
        goto LABEL_67;
      }

      v7 = TagFallback;
      v8 = v27;
LABEL_7:
      v10 = v8 >> 3;
      if (v8 >> 3 > 3)
      {
        if (v10 == 4)
        {
          if (v8 != 32)
          {
            goto LABEL_48;
          }

          v5 |= 0x10u;
          v18 = (v7 + 1);
          v17 = *v7;
          if ((v17 & 0x8000000000000000) == 0)
          {
            goto LABEL_34;
          }

          v19 = *v18;
          v17 = (v19 << 7) + v17 - 128;
          if ((v19 & 0x80000000) == 0)
          {
            v18 = (v7 + 2);
LABEL_34:
            v36 = v18;
            *(a1 + 73) = v17 != 0;
            goto LABEL_41;
          }

          v30 = google::protobuf::internal::VarintParseSlow64(v7, v17);
          v36 = v30;
          *(a1 + 73) = v31 != 0;
          if (!v30)
          {
            goto LABEL_67;
          }
        }

        else
        {
          if (v10 != 5)
          {
            if (v10 == 6 && v8 == 50)
            {
              *(a1 + 40) |= 4u;
              v15 = *(a1 + 8);
              if (v15)
              {
                v15 = *(v15 & 0xFFFFFFFFFFFFFFFELL);
              }

              v16 = (a1 + 64);
LABEL_39:
              v20 = google::protobuf::internal::ArenaStringPtr::Mutable(v16, v15, v7);
              v21 = google::protobuf::internal::InlineGreedyStringParser(v20, v36, this);
LABEL_40:
              v36 = v21;
              if (!v21)
              {
                goto LABEL_67;
              }

              goto LABEL_41;
            }

LABEL_48:
            if (v8)
            {
              v25 = (v8 & 7) == 4;
            }

            else
            {
              v25 = 1;
            }

            if (v25)
            {
              this[10].i32[0] = v8 - 1;
              goto LABEL_2;
            }

            if (v8 < 0x640)
            {
              v28 = *(a1 + 8);
              if (v28)
              {
                v29 = ((v28 & 0xFFFFFFFFFFFFFFFELL) + 8);
              }

              else
              {
                v29 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>((a1 + 8));
                v7 = v36;
              }

              v21 = google::protobuf::internal::UnknownFieldParse(v8, v29, v7, this);
            }

            else
            {
              v21 = google::protobuf::internal::ExtensionSet::ParseField((a1 + 16), v8, v7, &sentencepiece::_NormalizerSpec_default_instance_, (a1 + 8), this);
            }

            goto LABEL_40;
          }

          if (v8 != 40)
          {
            goto LABEL_48;
          }

          v5 |= 0x20u;
          v23 = (v7 + 1);
          v22 = *v7;
          if ((v22 & 0x8000000000000000) == 0)
          {
            goto LABEL_47;
          }

          v24 = *v23;
          v22 = (v24 << 7) + v22 - 128;
          if ((v24 & 0x80000000) == 0)
          {
            v23 = (v7 + 2);
LABEL_47:
            v36 = v23;
            *(a1 + 74) = v22 != 0;
            goto LABEL_41;
          }

          v34 = google::protobuf::internal::VarintParseSlow64(v7, v22);
          v36 = v34;
          *(a1 + 74) = v35 != 0;
          if (!v34)
          {
LABEL_67:
            v36 = 0;
            goto LABEL_2;
          }
        }
      }

      else
      {
        if (v10 == 1)
        {
          if (v8 == 10)
          {
            *(a1 + 40) |= 1u;
            v15 = *(a1 + 8);
            if (v15)
            {
              v15 = *(v15 & 0xFFFFFFFFFFFFFFFELL);
            }

            v16 = (a1 + 48);
            goto LABEL_39;
          }

          goto LABEL_48;
        }

        if (v10 == 2)
        {
          if (v8 == 18)
          {
            *(a1 + 40) |= 2u;
            v15 = *(a1 + 8);
            if (v15)
            {
              v15 = *(v15 & 0xFFFFFFFFFFFFFFFELL);
            }

            v16 = (a1 + 56);
            goto LABEL_39;
          }

          goto LABEL_48;
        }

        if (v10 != 3 || v8 != 24)
        {
          goto LABEL_48;
        }

        v5 |= 8u;
        v13 = (v7 + 1);
        v12 = *v7;
        if ((v12 & 0x8000000000000000) == 0)
        {
          goto LABEL_18;
        }

        v14 = *v13;
        v12 = (v14 << 7) + v12 - 128;
        if ((v14 & 0x80000000) == 0)
        {
          v13 = (v7 + 2);
LABEL_18:
          v36 = v13;
          *(a1 + 72) = v12 != 0;
          goto LABEL_41;
        }

        v32 = google::protobuf::internal::VarintParseSlow64(v7, v12);
        v36 = v32;
        *(a1 + 72) = v33 != 0;
        if (!v32)
        {
          goto LABEL_67;
        }
      }

LABEL_41:
      if (google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v36, this[11].i32[1]))
      {
        goto LABEL_2;
      }
    }

    v7 = (v36 + 2);
LABEL_6:
    v36 = v7;
    goto LABEL_7;
  }

LABEL_2:
  *(a1 + 40) |= v5;
  return v36;
}

unsigned __int8 *sentencepiece::NormalizerSpec::_InternalSerialize(sentencepiece::NormalizerSpec *this, unsigned __int8 *a2, google::protobuf::io::EpsCopyOutputStream *a3)
{
  v4 = a2;
  v6 = *(this + 10);
  if (v6)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 1, (*(this + 6) & 0xFFFFFFFFFFFFFFFELL), a2);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 8) == 0)
      {
        goto LABEL_4;
      }

      goto LABEL_12;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  v4 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 2, (*(this + 7) & 0xFFFFFFFFFFFFFFFELL), v4);
  if ((v6 & 8) == 0)
  {
LABEL_4:
    if ((v6 & 0x10) == 0)
    {
      goto LABEL_5;
    }

    goto LABEL_15;
  }

LABEL_12:
  if (*a3 <= v4)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, v4);
  }

  v11 = *(this + 72);
  *v4 = 24;
  v4[1] = v11;
  v4 += 2;
  if ((v6 & 0x10) == 0)
  {
LABEL_5:
    if ((v6 & 0x20) == 0)
    {
      goto LABEL_6;
    }

    goto LABEL_18;
  }

LABEL_15:
  if (*a3 <= v4)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, v4);
  }

  v12 = *(this + 73);
  *v4 = 32;
  v4[1] = v12;
  v4 += 2;
  if ((v6 & 0x20) == 0)
  {
LABEL_6:
    if ((v6 & 4) == 0)
    {
      goto LABEL_8;
    }

    goto LABEL_7;
  }

LABEL_18:
  if (*a3 <= v4)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, v4);
  }

  v13 = *(this + 74);
  *v4 = 40;
  v4[1] = v13;
  v4 += 2;
  if ((v6 & 4) != 0)
  {
LABEL_7:
    v4 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 6, (*(this + 8) & 0xFFFFFFFFFFFFFFFELL), v4);
  }

LABEL_8:
  v7 = google::protobuf::internal::ExtensionSet::_InternalSerialize((this + 16), 200, 0x20000000, v4, a3);
  v8 = v7;
  v9 = *(this + 1);
  if ((v9 & 1) == 0)
  {
    return v8;
  }

  v14 = v9 & 0xFFFFFFFFFFFFFFFELL;
  v15 = *(v14 + 31);
  if (v15 < 0)
  {
    v16 = *(v14 + 8);
    v15 = *(v14 + 16);
  }

  else
  {
    v16 = (v14 + 8);
  }

  if (*a3 - v7 >= v15)
  {
    v17 = v15;
    memcpy(v7, v16, v15);
    v8 += v17;
    return v8;
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(a3, v16, v15, v7);
}

uint64_t sentencepiece::NormalizerSpec::ByteSizeLong(sentencepiece::NormalizerSpec *this)
{
  result = google::protobuf::internal::ExtensionSet::ByteSize((this + 16));
  v3 = *(this + 10);
  if ((v3 & 0x3F) != 0)
  {
    if (v3)
    {
      v8 = *(this + 6) & 0xFFFFFFFFFFFFFFFELL;
      v9 = *(v8 + 23);
      v10 = *(v8 + 8);
      if ((v9 & 0x80u) == 0)
      {
        v10 = v9;
      }

      result += v10 + ((9 * (__clz(v10 | 1) ^ 0x1F) + 73) >> 6) + 1;
      if ((v3 & 2) == 0)
      {
LABEL_4:
        if ((v3 & 4) == 0)
        {
LABEL_8:
          result += ((v3 >> 3) & 2) + ((v3 >> 2) & 2) + ((v3 >> 4) & 2);
          goto LABEL_9;
        }

LABEL_5:
        v4 = *(this + 8) & 0xFFFFFFFFFFFFFFFELL;
        v5 = *(v4 + 23);
        v6 = *(v4 + 8);
        if ((v5 & 0x80u) == 0)
        {
          v6 = v5;
        }

        result += v6 + ((9 * (__clz(v6 | 1) ^ 0x1F) + 73) >> 6) + 1;
        goto LABEL_8;
      }
    }

    else if ((v3 & 2) == 0)
    {
      goto LABEL_4;
    }

    v11 = *(this + 7) & 0xFFFFFFFFFFFFFFFELL;
    v12 = *(v11 + 23);
    v13 = *(v11 + 8);
    if ((v12 & 0x80u) == 0)
    {
      v13 = v12;
    }

    result += v13 + ((9 * (__clz(v13 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v3 & 4) == 0)
    {
      goto LABEL_8;
    }

    goto LABEL_5;
  }

LABEL_9:
  v7 = *(this + 1);
  if (v7)
  {
    v14 = v7 & 0xFFFFFFFFFFFFFFFELL;
    v15 = *((v7 & 0xFFFFFFFFFFFFFFFELL) + 31);
    if (v15 < 0)
    {
      v15 = *(v14 + 16);
    }

    result += v15;
  }

  *(this + 11) = result;
  return result;
}

void sentencepiece::NormalizerSpec::MergeFrom(sentencepiece::NormalizerSpec *this, const sentencepiece::NormalizerSpec *a2)
{
  google::protobuf::internal::ExtensionSet::MergeFrom((this + 16), (a2 + 16));
  v4 = *(a2 + 1);
  if (v4)
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v6 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 8;
    v7 = *(this + 1);
    if (v7)
    {
      v8 = ((v7 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }

    else
    {
      v8 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(this + 1);
    }

    v9 = *(v5 + 31);
    if (v9 >= 0)
    {
      v10 = v6;
    }

    else
    {
      v10 = *(v5 + 8);
    }

    if (v9 >= 0)
    {
      v11 = *(v5 + 31);
    }

    else
    {
      v11 = *(v5 + 16);
    }

    std::string::append(v8, v10, v11);
  }

  v12 = *(a2 + 10);
  if ((v12 & 0x3F) != 0)
  {
    if (v12)
    {
      v13 = *(a2 + 6);
      *(this + 10) |= 1u;
      v14 = *(this + 1);
      if (v14)
      {
        v14 = *(v14 & 0xFFFFFFFFFFFFFFFELL);
      }

      google::protobuf::internal::ArenaStringPtr::Set(this + 6, v13 & 0xFFFFFFFFFFFFFFFELL, v14);
      if ((v12 & 2) == 0)
      {
LABEL_14:
        if ((v12 & 4) == 0)
        {
          goto LABEL_15;
        }

        goto LABEL_27;
      }
    }

    else if ((v12 & 2) == 0)
    {
      goto LABEL_14;
    }

    v15 = *(a2 + 7);
    *(this + 10) |= 2u;
    v16 = *(this + 1);
    if (v16)
    {
      v16 = *(v16 & 0xFFFFFFFFFFFFFFFELL);
    }

    google::protobuf::internal::ArenaStringPtr::Set(this + 7, v15 & 0xFFFFFFFFFFFFFFFELL, v16);
    if ((v12 & 4) == 0)
    {
LABEL_15:
      if ((v12 & 8) == 0)
      {
        goto LABEL_16;
      }

      goto LABEL_30;
    }

LABEL_27:
    v17 = *(a2 + 8);
    *(this + 10) |= 4u;
    v18 = *(this + 1);
    if (v18)
    {
      v18 = *(v18 & 0xFFFFFFFFFFFFFFFELL);
    }

    google::protobuf::internal::ArenaStringPtr::Set(this + 8, v17 & 0xFFFFFFFFFFFFFFFELL, v18);
    if ((v12 & 8) == 0)
    {
LABEL_16:
      if ((v12 & 0x10) == 0)
      {
        goto LABEL_17;
      }

      goto LABEL_31;
    }

LABEL_30:
    *(this + 72) = *(a2 + 72);
    if ((v12 & 0x10) == 0)
    {
LABEL_17:
      if ((v12 & 0x20) == 0)
      {
LABEL_19:
        *(this + 10) |= v12;
        return;
      }

LABEL_18:
      *(this + 74) = *(a2 + 74);
      goto LABEL_19;
    }

LABEL_31:
    *(this + 73) = *(a2 + 73);
    if ((v12 & 0x20) == 0)
    {
      goto LABEL_19;
    }

    goto LABEL_18;
  }
}

void *sentencepiece::SelfTestData_Sample::SelfTestData_Sample(void *a1, uint64_t a2)
{
  *a1 = &unk_1F2D43770;
  a1[1] = a2;
  a1[2] = 0;
  if (atomic_load_explicit(scc_info_SelfTestData_Sample_sentencepiece_5fmodel_2eproto, memory_order_acquire))
  {
    google::protobuf::internal::InitSCCImpl(scc_info_SelfTestData_Sample_sentencepiece_5fmodel_2eproto);
  }

  a1[3] = &google::protobuf::internal::fixed_address_empty_string;
  a1[4] = &google::protobuf::internal::fixed_address_empty_string;
  return a1;
}

void sentencepiece::SelfTestData_Sample::~SelfTestData_Sample(sentencepiece::SelfTestData_Sample *this)
{
  v2 = *(this + 3);
  if (v2 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v2 + 23) < 0)
    {
      operator delete(*v2);
    }

    MEMORY[0x1B8C85350](v2, 0x1012C40EC159624);
  }

  v3 = *(this + 4);
  if (v3 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v3 + 23) < 0)
    {
      operator delete(*v3);
    }

    MEMORY[0x1B8C85350](v3, 0x1012C40EC159624);
  }

  google::protobuf::internal::InternalMetadata::Delete<std::string>(this + 1);
}

{
  sentencepiece::SelfTestData_Sample::~SelfTestData_Sample(this);

  JUMPOUT(0x1B8C85350);
}

uint64_t sentencepiece::SelfTestData_Sample::Clear(uint64_t this)
{
  v1 = *(this + 16);
  if ((v1 & 3) != 0)
  {
    if (v1)
    {
      v2 = *(this + 24) & 0xFFFFFFFFFFFFFFFELL;
      if (*(v2 + 23) < 0)
      {
        **v2 = 0;
        *(v2 + 8) = 0;
        if ((v1 & 2) == 0)
        {
          goto LABEL_11;
        }

        goto LABEL_6;
      }

      *v2 = 0;
      *(v2 + 23) = 0;
    }

    if ((v1 & 2) == 0)
    {
      goto LABEL_11;
    }

LABEL_6:
    v3 = *(this + 32) & 0xFFFFFFFFFFFFFFFELL;
    if (*(v3 + 23) < 0)
    {
      **v3 = 0;
      *(v3 + 8) = 0;
    }

    else
    {
      *v3 = 0;
      *(v3 + 23) = 0;
    }
  }

LABEL_11:
  *(this + 16) = 0;
  v4 = *(this + 8);
  if (v4)
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    if (*(v5 + 31) < 0)
    {
      **(v5 + 8) = 0;
      *(v5 + 16) = 0;
    }

    else
    {
      *(v5 + 8) = 0;
      *(v5 + 31) = 0;
    }
  }

  return this;
}

google::protobuf::internal *sentencepiece::SelfTestData_Sample::_InternalParse(uint64_t a1, google::protobuf::internal *a2, int32x2_t *this)
{
  v20 = a2;
  for (i = this[11].i32[1]; (google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v20, i) & 1) == 0; i = this[11].i32[1])
  {
    v6 = (v20 + 1);
    v7 = *v20;
    if ((*v20 & 0x80000000) == 0)
    {
      goto LABEL_6;
    }

    v8 = v7 + (*v6 << 7);
    v7 = v8 - 128;
    if ((*v6 & 0x80000000) == 0)
    {
      v6 = (v20 + 2);
LABEL_6:
      v20 = v6;
      goto LABEL_7;
    }

    TagFallback = google::protobuf::internal::ReadTagFallback(v20, (v8 - 128));
    v20 = TagFallback;
    if (!TagFallback)
    {
      return 0;
    }

    v6 = TagFallback;
    v7 = v18;
LABEL_7:
    if (v7 >> 3 == 2)
    {
      if (v7 == 18)
      {
        *(a1 + 16) |= 2u;
        v14 = *(a1 + 8);
        if (v14)
        {
          v14 = *(v14 & 0xFFFFFFFFFFFFFFFELL);
        }

        v15 = (a1 + 32);
        goto LABEL_26;
      }
    }

    else if (v7 >> 3 == 1 && v7 == 10)
    {
      *(a1 + 16) |= 1u;
      v14 = *(a1 + 8);
      if (v14)
      {
        v14 = *(v14 & 0xFFFFFFFFFFFFFFFELL);
      }

      v15 = (a1 + 24);
LABEL_26:
      v16 = google::protobuf::internal::ArenaStringPtr::Mutable(v15, v14, v6);
      v13 = google::protobuf::internal::InlineGreedyStringParser(v16, v20, this);
      goto LABEL_27;
    }

    if (v7)
    {
      v10 = (v7 & 7) == 4;
    }

    else
    {
      v10 = 1;
    }

    if (v10)
    {
      this[10].i32[0] = v7 - 1;
      return v20;
    }

    v11 = *(a1 + 8);
    if (v11)
    {
      v12 = ((v11 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }

    else
    {
      v12 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>((a1 + 8));
      v6 = v20;
    }

    v13 = google::protobuf::internal::UnknownFieldParse(v7, v12, v6, this);
LABEL_27:
    v20 = v13;
    if (!v13)
    {
      return 0;
    }
  }

  return v20;
}

unsigned __int8 *sentencepiece::SelfTestData_Sample::_InternalSerialize(sentencepiece::SelfTestData_Sample *this, unsigned __int8 *a2, google::protobuf::io::EpsCopyOutputStream *a3)
{
  v4 = a2;
  v6 = *(this + 4);
  if (v6)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 1, (*(this + 3) & 0xFFFFFFFFFFFFFFFELL), a2);
  }

  if ((v6 & 2) != 0)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 2, (*(this + 4) & 0xFFFFFFFFFFFFFFFELL), v4);
  }

  v7 = *(this + 1);
  if ((v7 & 1) == 0)
  {
    return v4;
  }

  v9 = v7 & 0xFFFFFFFFFFFFFFFELL;
  v10 = *(v9 + 31);
  if (v10 < 0)
  {
    v11 = *(v9 + 8);
    v10 = *(v9 + 16);
  }

  else
  {
    v11 = (v9 + 8);
  }

  if (*a3 - v4 >= v10)
  {
    v12 = v10;
    memcpy(v4, v11, v10);
    v4 += v12;
    return v4;
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(a3, v11, v10, v4);
}

uint64_t sentencepiece::SelfTestData_Sample::ByteSizeLong(sentencepiece::SelfTestData_Sample *this)
{
  v1 = *(this + 4);
  if ((v1 & 3) == 0)
  {
    v2 = 0;
    goto LABEL_12;
  }

  if ((v1 & 1) == 0)
  {
    v2 = 0;
    if ((v1 & 2) == 0)
    {
      goto LABEL_12;
    }

    goto LABEL_9;
  }

  v3 = *(this + 3) & 0xFFFFFFFFFFFFFFFELL;
  v4 = *(v3 + 23);
  v5 = *(v3 + 8);
  if ((v4 & 0x80u) == 0)
  {
    v5 = v4;
  }

  v2 = v5 + ((9 * (__clz(v5 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v1 & 2) != 0)
  {
LABEL_9:
    v6 = *(this + 4) & 0xFFFFFFFFFFFFFFFELL;
    v7 = *(v6 + 23);
    v8 = *(v6 + 8);
    if ((v7 & 0x80u) == 0)
    {
      v8 = v7;
    }

    v2 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6) + 1;
  }

LABEL_12:
  v9 = *(this + 1);
  if (v9)
  {
    v11 = v9 & 0xFFFFFFFFFFFFFFFELL;
    v12 = *((v9 & 0xFFFFFFFFFFFFFFFELL) + 31);
    if (v12 < 0)
    {
      v12 = *(v11 + 16);
    }

    v2 += v12;
  }

  *(this + 5) = v2;
  return v2;
}

void sentencepiece::SelfTestData_Sample::MergeFrom(sentencepiece::SelfTestData_Sample *this, const sentencepiece::SelfTestData_Sample *a2)
{
  v4 = *(a2 + 1);
  if (v4)
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v6 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 8;
    v7 = *(this + 1);
    if (v7)
    {
      v8 = ((v7 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }

    else
    {
      v8 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(this + 1);
    }

    v9 = *(v5 + 31);
    if (v9 >= 0)
    {
      v10 = v6;
    }

    else
    {
      v10 = *(v5 + 8);
    }

    if (v9 >= 0)
    {
      v11 = *(v5 + 31);
    }

    else
    {
      v11 = *(v5 + 16);
    }

    std::string::append(v8, v10, v11);
  }

  v12 = *(a2 + 4);
  if ((v12 & 3) != 0)
  {
    if (v12)
    {
      v13 = *(a2 + 3);
      *(this + 4) |= 1u;
      v14 = *(this + 1);
      if (v14)
      {
        v14 = *(v14 & 0xFFFFFFFFFFFFFFFELL);
      }

      google::protobuf::internal::ArenaStringPtr::Set(this + 3, v13 & 0xFFFFFFFFFFFFFFFELL, v14);
    }

    if ((v12 & 2) != 0)
    {
      v15 = *(a2 + 4);
      *(this + 4) |= 2u;
      v16 = *(this + 1);
      if (v16)
      {
        v16 = *(v16 & 0xFFFFFFFFFFFFFFFELL);
      }

      google::protobuf::internal::ArenaStringPtr::Set(this + 4, v15 & 0xFFFFFFFFFFFFFFFELL, v16);
    }
  }
}

uint64_t sentencepiece::SelfTestData::SelfTestData(uint64_t a1, uint64_t a2)
{
  *a1 = &unk_1F2D437F0;
  *(a1 + 8) = a2;
  google::protobuf::internal::ExtensionSet::ExtensionSet(a1 + 16, a2);
  *(a1 + 40) = a2;
  *(a1 + 48) = 0;
  *(a1 + 56) = 0;
  *(a1 + 64) = 0;
  if (atomic_load_explicit(scc_info_SelfTestData_sentencepiece_5fmodel_2eproto, memory_order_acquire))
  {
    google::protobuf::internal::InitSCCImpl(scc_info_SelfTestData_sentencepiece_5fmodel_2eproto);
  }

  return a1;
}

void sub_1B5AA6944(_Unwind_Exception *a1)
{
  google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::SelfTestData_Sample>::TypeHandler>(v2);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((v1 + 16));
  _Unwind_Resume(a1);
}

void sentencepiece::SelfTestData::~SelfTestData(sentencepiece::SelfTestData *this)
{
  google::protobuf::internal::InternalMetadata::Delete<std::string>(this + 1);
  google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::SelfTestData_Sample>::TypeHandler>(this + 5);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((this + 16));
}

{
  sentencepiece::SelfTestData::~SelfTestData(this);

  JUMPOUT(0x1B8C85350);
}

uint64_t sentencepiece::SelfTestData::Clear(sentencepiece::SelfTestData *this)
{
  result = google::protobuf::internal::ExtensionSet::Clear(this + 16);
  v3 = *(this + 12);
  if (v3 >= 1)
  {
    v4 = (*(this + 7) + 8);
    do
    {
      v5 = *v4++;
      result = sentencepiece::SelfTestData_Sample::Clear(v5);
      --v3;
    }

    while (v3);
    *(this + 12) = 0;
  }

  v6 = *(this + 1);
  if (v6)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if (*(v7 + 31) < 0)
    {
      **(v7 + 8) = 0;
      *(v7 + 16) = 0;
    }

    else
    {
      *(v7 + 8) = 0;
      *(v7 + 31) = 0;
    }
  }

  return result;
}

google::protobuf::internal *sentencepiece::SelfTestData::_InternalParse(uint64_t a1, google::protobuf::internal *a2, int32x2_t *this)
{
  v23 = a2;
  if ((google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v23, this[11].i32[1]) & 1) == 0)
  {
    while (1)
    {
      v5 = (v23 + 1);
      v6 = *v23;
      if ((*v23 & 0x80000000) == 0)
      {
        goto LABEL_5;
      }

      v7 = v6 + (*v5 << 7);
      v6 = v7 - 128;
      if ((*v5 & 0x80000000) == 0)
      {
        break;
      }

      TagFallback = google::protobuf::internal::ReadTagFallback(v23, (v7 - 128));
      v23 = TagFallback;
      if (!TagFallback)
      {
        return 0;
      }

      v5 = TagFallback;
      v6 = v21;
LABEL_6:
      if (v6 == 10)
      {
        v10 = (v5 - 1);
        while (1)
        {
          v11 = (v10 + 1);
          v23 = (v10 + 1);
          v12 = *(a1 + 56);
          if (!v12)
          {
            break;
          }

          v17 = *(a1 + 48);
          v13 = *v12;
          if (v17 < *v12)
          {
            *(a1 + 48) = v17 + 1;
            v14 = *&v12[2 * v17 + 2];
            goto LABEL_20;
          }

          if (v13 == *(a1 + 52))
          {
            goto LABEL_16;
          }

LABEL_17:
          *v12 = v13 + 1;
          v14 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SelfTestData_Sample>(*(a1 + 40));
          v15 = *(a1 + 48);
          v16 = *(a1 + 56) + 8 * v15;
          *(a1 + 48) = v15 + 1;
          *(v16 + 8) = v14;
          v11 = v23;
LABEL_20:
          v10 = google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::SelfTestData_Sample>(this, v14, v11);
          v23 = v10;
          if (!v10)
          {
            return 0;
          }

          if (*this <= v10 || *v10 != 10)
          {
            goto LABEL_30;
          }
        }

        v13 = *(a1 + 52);
LABEL_16:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a1 + 40), v13 + 1);
        v12 = *(a1 + 56);
        v13 = *v12;
        goto LABEL_17;
      }

      if (v6)
      {
        v8 = (v6 & 7) == 4;
      }

      else
      {
        v8 = 1;
      }

      if (v8)
      {
        this[10].i32[0] = v6 - 1;
        return v23;
      }

      if (v6 < 0x640)
      {
        v18 = *(a1 + 8);
        if (v18)
        {
          v19 = ((v18 & 0xFFFFFFFFFFFFFFFELL) + 8);
        }

        else
        {
          v19 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>((a1 + 8));
          v5 = v23;
        }

        v9 = google::protobuf::internal::UnknownFieldParse(v6, v19, v5, this);
      }

      else
      {
        v9 = google::protobuf::internal::ExtensionSet::ParseField((a1 + 16), v6, v5, &sentencepiece::_SelfTestData_default_instance_, (a1 + 8), this);
      }

      v23 = v9;
      if (!v9)
      {
        return 0;
      }

LABEL_30:
      if (google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v23, this[11].i32[1]))
      {
        return v23;
      }
    }

    v5 = (v23 + 2);
LABEL_5:
    v23 = v5;
    goto LABEL_6;
  }

  return v23;
}

unsigned __int8 *sentencepiece::SelfTestData::_InternalSerialize(sentencepiece::SelfTestData *this, unsigned __int8 *a2, google::protobuf::io::EpsCopyOutputStream *a3)
{
  v6 = *(this + 12);
  if (v6)
  {
    for (i = 0; i != v6; ++i)
    {
      if (*a3 <= a2)
      {
        a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
      }

      v8 = *(*(this + 7) + 8 * i + 8);
      *a2 = 10;
      v9 = *(v8 + 5);
      if (v9 > 0x7F)
      {
        a2[1] = v9 | 0x80;
        v11 = v9 >> 7;
        if (v9 >> 14)
        {
          v10 = a2 + 3;
          do
          {
            *(v10 - 1) = v11 | 0x80;
            v12 = v11 >> 7;
            ++v10;
            v13 = v11 >> 14;
            v11 >>= 7;
          }

          while (v13);
          *(v10 - 1) = v12;
        }

        else
        {
          a2[2] = v11;
          v10 = a2 + 3;
        }
      }

      else
      {
        a2[1] = v9;
        v10 = a2 + 2;
      }

      a2 = sentencepiece::SelfTestData_Sample::_InternalSerialize(v8, v10, a3);
    }
  }

  v14 = google::protobuf::internal::ExtensionSet::_InternalSerialize((this + 16), 200, 0x20000000, a2, a3);
  v15 = v14;
  v16 = *(this + 1);
  if ((v16 & 1) == 0)
  {
    return v15;
  }

  v18 = v16 & 0xFFFFFFFFFFFFFFFELL;
  v19 = *(v18 + 31);
  if (v19 < 0)
  {
    v20 = *(v18 + 8);
    v19 = *(v18 + 16);
  }

  else
  {
    v20 = (v18 + 8);
  }

  if (*a3 - v14 >= v19)
  {
    v21 = v19;
    memcpy(v14, v20, v19);
    v15 += v21;
    return v15;
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(a3, v20, v19, v14);
}

uint64_t sentencepiece::SelfTestData::ByteSizeLong(sentencepiece::SelfTestData *this)
{
  v2 = google::protobuf::internal::ExtensionSet::ByteSize((this + 16));
  v3 = *(this + 12);
  v4 = v2 + v3;
  v5 = *(this + 7);
  if (v5)
  {
    v6 = (v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  if (v3)
  {
    v7 = 8 * v3;
    do
    {
      v8 = *v6++;
      v9 = sentencepiece::SelfTestData_Sample::ByteSizeLong(v8);
      v4 += v9 + ((9 * (__clz(v9 | 1) ^ 0x1F) + 73) >> 6);
      v7 -= 8;
    }

    while (v7);
  }

  v10 = *(this + 1);
  if (v10)
  {
    v12 = v10 & 0xFFFFFFFFFFFFFFFELL;
    v13 = *((v10 & 0xFFFFFFFFFFFFFFFELL) + 31);
    if (v13 < 0)
    {
      v13 = *(v12 + 16);
    }

    v4 += v13;
  }

  *(this + 16) = v4;
  return v4;
}

void sentencepiece::SelfTestData::MergeFrom(sentencepiece::SelfTestData *this, const sentencepiece::SelfTestData *a2)
{
  google::protobuf::internal::ExtensionSet::MergeFrom((this + 16), (a2 + 16));
  v4 = *(a2 + 1);
  if (v4)
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v6 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 8;
    v7 = *(this + 1);
    if (v7)
    {
      v8 = ((v7 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }

    else
    {
      v8 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(this + 1);
    }

    v9 = *(v5 + 31);
    if (v9 >= 0)
    {
      v10 = v6;
    }

    else
    {
      v10 = *(v5 + 8);
    }

    if (v9 >= 0)
    {
      v11 = *(v5 + 31);
    }

    else
    {
      v11 = *(v5 + 16);
    }

    std::string::append(v8, v10, v11);
  }

  v12 = *(a2 + 12);
  if (v12)
  {
    v13 = *(a2 + 7);
    v14 = google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend((this + 40), v12);
    google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<sentencepiece::SelfTestData_Sample>::TypeHandler>(this + 5, v14, (v13 + 8), v12, **(this + 7) - *(this + 12));
    v15 = *(this + 12) + v12;
    *(this + 12) = v15;
    v16 = *(this + 7);
    if (*v16 < v15)
    {
      *v16 = v15;
    }
  }
}

void *sentencepiece::ModelProto_SentencePiece::ModelProto_SentencePiece(void *a1, uint64_t a2)
{
  *a1 = &unk_1F2D43870;
  a1[1] = a2;
  google::protobuf::internal::ExtensionSet::ExtensionSet((a1 + 2), a2);
  a1[5] = 0;
  if (atomic_load_explicit(scc_info_ModelProto_SentencePiece_sentencepiece_5fmodel_2eproto, memory_order_acquire))
  {
    google::protobuf::internal::InitSCCImpl(scc_info_ModelProto_SentencePiece_sentencepiece_5fmodel_2eproto);
  }

  a1[6] = &google::protobuf::internal::fixed_address_empty_string;
  a1[7] = 0x100000000;
  return a1;
}

void sentencepiece::ModelProto_SentencePiece::~ModelProto_SentencePiece(sentencepiece::ModelProto_SentencePiece *this)
{
  v2 = *(this + 6);
  if (v2 != &google::protobuf::internal::fixed_address_empty_string)
  {
    if (*(v2 + 23) < 0)
    {
      operator delete(*v2);
    }

    MEMORY[0x1B8C85350](v2, 0x1012C40EC159624);
  }

  google::protobuf::internal::InternalMetadata::Delete<std::string>(this + 1);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((this + 16));
}

{
  sentencepiece::ModelProto_SentencePiece::~ModelProto_SentencePiece(this);

  JUMPOUT(0x1B8C85350);
}

unsigned __int8 *sentencepiece::ModelProto_SentencePiece::Clear(sentencepiece::ModelProto_SentencePiece *this)
{
  result = google::protobuf::internal::ExtensionSet::Clear(this + 16);
  v3 = *(this + 10);
  if (v3)
  {
    v4 = *(this + 6) & 0xFFFFFFFFFFFFFFFELL;
    if (*(v4 + 23) < 0)
    {
      **v4 = 0;
      *(v4 + 8) = 0;
    }

    else
    {
      *v4 = 0;
      *(v4 + 23) = 0;
    }
  }

  if ((v3 & 6) != 0)
  {
    *(this + 7) = 0x100000000;
  }

  *(this + 10) = 0;
  v5 = *(this + 1);
  if (v5)
  {
    v6 = v5 & 0xFFFFFFFFFFFFFFFELL;
    if (*(v6 + 31) < 0)
    {
      **(v6 + 8) = 0;
      *(v6 + 16) = 0;
    }

    else
    {
      *(v6 + 8) = 0;
      *(v6 + 31) = 0;
    }
  }

  return result;
}

google::protobuf::internal *sentencepiece::ModelProto_SentencePiece::_InternalParse(uint64_t a1, google::protobuf::internal *a2, int32x2_t *this)
{
  v23 = a2;
  v5 = 0;
  if ((google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v23, this[11].i32[1]) & 1) == 0)
  {
    while (1)
    {
      v7 = (v23 + 1);
      v8 = *v23;
      if ((*v23 & 0x80000000) == 0)
      {
        goto LABEL_6;
      }

      v9 = v8 + (*v7 << 7);
      v8 = v9 - 128;
      if ((*v7 & 0x80000000) == 0)
      {
        break;
      }

      TagFallback = google::protobuf::internal::ReadTagFallback(v23, (v9 - 128));
      v23 = TagFallback;
      if (!TagFallback)
      {
        goto LABEL_44;
      }

      v7 = TagFallback;
      v8 = v20;
LABEL_7:
      v10 = v8 >> 3;
      if (v8 >> 3 == 3)
      {
        if (v8 == 24)
        {
          v15 = (v7 + 1);
          v14 = *v7;
          if ((v14 & 0x8000000000000000) == 0)
          {
            goto LABEL_25;
          }

          v16 = *v15;
          v14 = (v16 << 7) + v14 - 128;
          if (v16 < 0)
          {
            v23 = google::protobuf::internal::VarintParseSlow64(v7, v14);
            if (!v23)
            {
LABEL_44:
              v23 = 0;
              goto LABEL_2;
            }
          }

          else
          {
            v15 = (v7 + 2);
LABEL_25:
            v23 = v15;
          }

          if ((v14 - 1) > 5)
          {
            sentencepiece::ModelProto_SentencePiece::_InternalParse((a1 + 8), v14);
          }

          else
          {
            *(a1 + 40) |= 4u;
            *(a1 + 60) = v14;
          }

          goto LABEL_37;
        }
      }

      else if (v10 == 2)
      {
        if (v8 == 21)
        {
          v5 |= 2u;
          *(a1 + 56) = *v7;
          v23 = (v7 + 4);
          goto LABEL_37;
        }
      }

      else if (v10 == 1 && v8 == 10)
      {
        *(a1 + 40) |= 1u;
        v17 = *(a1 + 8);
        if (v17)
        {
          v17 = *(v17 & 0xFFFFFFFFFFFFFFFELL);
        }

        v18 = google::protobuf::internal::ArenaStringPtr::Mutable((a1 + 48), v17, v7);
        v13 = google::protobuf::internal::InlineGreedyStringParser(v18, v23, this);
        goto LABEL_36;
      }

      if (v8)
      {
        v12 = (v8 & 7) == 4;
      }

      else
      {
        v12 = 1;
      }

      if (v12)
      {
        this[10].i32[0] = v8 - 1;
        goto LABEL_2;
      }

      if (v8 < 0x640)
      {
        v21 = *(a1 + 8);
        if (v21)
        {
          v22 = ((v21 & 0xFFFFFFFFFFFFFFFELL) + 8);
        }

        else
        {
          v22 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>((a1 + 8));
          v7 = v23;
        }

        v13 = google::protobuf::internal::UnknownFieldParse(v8, v22, v7, this);
      }

      else
      {
        v13 = google::protobuf::internal::ExtensionSet::ParseField((a1 + 16), v8, v7, sentencepiece::_ModelProto_SentencePiece_default_instance_, (a1 + 8), this);
      }

LABEL_36:
      v23 = v13;
      if (!v13)
      {
        goto LABEL_44;
      }

LABEL_37:
      if (google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v23, this[11].i32[1]))
      {
        goto LABEL_2;
      }
    }

    v7 = (v23 + 2);
LABEL_6:
    v23 = v7;
    goto LABEL_7;
  }

LABEL_2:
  *(a1 + 40) |= v5;
  return v23;
}

unsigned __int8 *sentencepiece::ModelProto_SentencePiece::_InternalSerialize(sentencepiece::ModelProto_SentencePiece *this, unsigned __int8 *a2, google::protobuf::io::EpsCopyOutputStream *a3)
{
  v4 = a2;
  v6 = *(this + 10);
  if (v6)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliased(a3, 1, (*(this + 6) & 0xFFFFFFFFFFFFFFFELL), a2);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
      {
        goto LABEL_18;
      }

      goto LABEL_9;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  if (*a3 <= v4)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, v4);
  }

  v7 = *(this + 14);
  *v4 = 21;
  *(v4 + 1) = v7;
  v4 += 5;
  if ((v6 & 4) != 0)
  {
LABEL_9:
    if (*a3 <= v4)
    {
      v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, v4);
    }

    v8 = *(this + 15);
    *v4 = 24;
    if (v8 > 0x7F)
    {
      v4[1] = v8 | 0x80;
      v9 = v8 >> 7;
      if (v8 >> 14)
      {
        v4 += 3;
        do
        {
          *(v4 - 1) = v9 | 0x80;
          v10 = v9 >> 7;
          ++v4;
          v11 = v9 >> 14;
          v9 >>= 7;
        }

        while (v11);
        *(v4 - 1) = v10;
      }

      else
      {
        v4[2] = v9;
        v4 += 3;
      }
    }

    else
    {
      v4[1] = v8;
      v4 += 2;
    }
  }

LABEL_18:
  v12 = google::protobuf::internal::ExtensionSet::_InternalSerialize((this + 16), 200, 0x20000000, v4, a3);
  v13 = v12;
  v14 = *(this + 1);
  if ((v14 & 1) == 0)
  {
    return v13;
  }

  v16 = v14 & 0xFFFFFFFFFFFFFFFELL;
  v17 = *(v16 + 31);
  if (v17 < 0)
  {
    v18 = *(v16 + 8);
    v17 = *(v16 + 16);
  }

  else
  {
    v18 = (v16 + 8);
  }

  if (*a3 - v12 >= v17)
  {
    v19 = v17;
    memcpy(v12, v18, v17);
    v13 += v19;
    return v13;
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(a3, v18, v17, v12);
}

uint64_t sentencepiece::ModelProto_SentencePiece::ByteSizeLong(sentencepiece::ModelProto_SentencePiece *this)
{
  result = google::protobuf::internal::ExtensionSet::ByteSize((this + 16));
  v3 = *(this + 10);
  if ((v3 & 7) != 0)
  {
    if (v3)
    {
      v4 = *(this + 6) & 0xFFFFFFFFFFFFFFFELL;
      v5 = *(v4 + 23);
      v6 = *(v4 + 8);
      if ((v5 & 0x80u) == 0)
      {
        v6 = v5;
      }

      result += v6 + ((9 * (__clz(v6 | 1) ^ 0x1F) + 73) >> 6) + 1;
    }

    if ((v3 & 2) != 0)
    {
      result += 5;
    }

    if ((v3 & 4) != 0)
    {
      v7 = *(this + 15);
      if (v7 < 0)
      {
        v8 = 11;
      }

      else
      {
        v8 = ((9 * (__clz(v7 | 1) ^ 0x1F) + 73) >> 6) + 1;
      }

      result += v8;
    }
  }

  v9 = *(this + 1);
  if (v9)
  {
    v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
    v11 = *((v9 & 0xFFFFFFFFFFFFFFFELL) + 31);
    if (v11 < 0)
    {
      v11 = *(v10 + 16);
    }

    result += v11;
  }

  *(this + 11) = result;
  return result;
}

void sentencepiece::ModelProto_SentencePiece::MergeFrom(sentencepiece::ModelProto_SentencePiece *this, const sentencepiece::ModelProto_SentencePiece *a2)
{
  google::protobuf::internal::ExtensionSet::MergeFrom((this + 16), (a2 + 16));
  v4 = *(a2 + 1);
  if (v4)
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v6 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 8;
    v7 = *(this + 1);
    if (v7)
    {
      v8 = ((v7 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }

    else
    {
      v8 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(this + 1);
    }

    v9 = *(v5 + 31);
    if (v9 >= 0)
    {
      v10 = v6;
    }

    else
    {
      v10 = *(v5 + 8);
    }

    if (v9 >= 0)
    {
      v11 = *(v5 + 31);
    }

    else
    {
      v11 = *(v5 + 16);
    }

    std::string::append(v8, v10, v11);
  }

  v12 = *(a2 + 10);
  if ((v12 & 7) != 0)
  {
    if (v12)
    {
      v13 = *(a2 + 6);
      *(this + 10) |= 1u;
      v14 = *(this + 1);
      if (v14)
      {
        v14 = *(v14 & 0xFFFFFFFFFFFFFFFELL);
      }

      google::protobuf::internal::ArenaStringPtr::Set(this + 6, v13 & 0xFFFFFFFFFFFFFFFELL, v14);
      if ((v12 & 2) == 0)
      {
LABEL_14:
        if ((v12 & 4) == 0)
        {
LABEL_16:
          *(this + 10) |= v12;
          return;
        }

LABEL_15:
        *(this + 15) = *(a2 + 15);
        goto LABEL_16;
      }
    }

    else if ((v12 & 2) == 0)
    {
      goto LABEL_14;
    }

    *(this + 14) = *(a2 + 14);
    if ((v12 & 4) == 0)
    {
      goto LABEL_16;
    }

    goto LABEL_15;
  }
}

uint64_t sentencepiece::ModelProto::ModelProto(uint64_t a1, uint64_t a2)
{
  *a1 = &unk_1F2D438F0;
  *(a1 + 8) = a2;
  google::protobuf::internal::ExtensionSet::ExtensionSet(a1 + 16, a2);
  *(a1 + 48) = a2;
  *(a1 + 40) = 0;
  *(a1 + 56) = 0;
  *(a1 + 64) = 0;
  if (atomic_load_explicit(scc_info_ModelProto_sentencepiece_5fmodel_2eproto, memory_order_acquire))
  {
    google::protobuf::internal::InitSCCImpl(scc_info_ModelProto_sentencepiece_5fmodel_2eproto);
  }

  *(a1 + 88) = 0u;
  *(a1 + 72) = 0u;
  return a1;
}

void sub_1B5AA77BC(_Unwind_Exception *a1)
{
  google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::ModelProto_SentencePiece>::TypeHandler>(v2);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((v1 + 16));
  _Unwind_Resume(a1);
}

void sentencepiece::ModelProto::~ModelProto(sentencepiece::ModelProto *this)
{
  sentencepiece::ModelProto::SharedDtor(this);
  google::protobuf::internal::InternalMetadata::Delete<std::string>(this + 1);
  google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::ModelProto_SentencePiece>::TypeHandler>(this + 6);
  google::protobuf::internal::ExtensionSet::~ExtensionSet((this + 16));
}

{
  sentencepiece::ModelProto::~ModelProto(this);

  JUMPOUT(0x1B8C85350);
}

void *sentencepiece::ModelProto::SharedDtor(void *this)
{
  if (this != &sentencepiece::_ModelProto_default_instance_)
  {
    v1 = this;
    v2 = this[9];
    if (v2)
    {
      sentencepiece::TrainerSpec::~TrainerSpec(v2);
      MEMORY[0x1B8C85350]();
    }

    v3 = v1[10];
    if (v3)
    {
      sentencepiece::NormalizerSpec::~NormalizerSpec(v3);
      MEMORY[0x1B8C85350]();
    }

    v4 = v1[11];
    if (v4)
    {
      sentencepiece::SelfTestData::~SelfTestData(v4);
      MEMORY[0x1B8C85350]();
    }

    this = v1[12];
    if (this)
    {
      sentencepiece::NormalizerSpec::~NormalizerSpec(this);

      JUMPOUT(0x1B8C85350);
    }
  }

  return this;
}

unsigned __int8 *sentencepiece::ModelProto::Clear(sentencepiece::ModelProto *this)
{
  result = google::protobuf::internal::ExtensionSet::Clear(this + 16);
  v3 = *(this + 14);
  if (v3 >= 1)
  {
    v4 = (*(this + 8) + 8);
    do
    {
      v5 = *v4++;
      result = sentencepiece::ModelProto_SentencePiece::Clear(v5);
      --v3;
    }

    while (v3);
    *(this + 14) = 0;
  }

  v6 = *(this + 10);
  if ((v6 & 0xF) == 0)
  {
    goto LABEL_11;
  }

  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0)
    {
      goto LABEL_8;
    }

LABEL_15:
    result = sentencepiece::NormalizerSpec::Clear(*(this + 10));
    if ((v6 & 4) == 0)
    {
LABEL_9:
      if ((v6 & 8) == 0)
      {
        goto LABEL_11;
      }

      goto LABEL_10;
    }

    goto LABEL_16;
  }

  result = sentencepiece::TrainerSpec::Clear(*(this + 9));
  if ((v6 & 2) != 0)
  {
    goto LABEL_15;
  }

LABEL_8:
  if ((v6 & 4) == 0)
  {
    goto LABEL_9;
  }

LABEL_16:
  result = sentencepiece::SelfTestData::Clear(*(this + 11));
  if ((v6 & 8) != 0)
  {
LABEL_10:
    result = sentencepiece::NormalizerSpec::Clear(*(this + 12));
  }

LABEL_11:
  *(this + 10) = 0;
  v7 = *(this + 1);
  if (v7)
  {
    v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    if (*(v8 + 31) < 0)
    {
      **(v8 + 8) = 0;
      *(v8 + 16) = 0;
    }

    else
    {
      *(v8 + 8) = 0;
      *(v8 + 31) = 0;
    }
  }

  return result;
}

google::protobuf::internal *sentencepiece::ModelProto::_InternalParse(uint64_t a1, google::protobuf::internal *a2, int32x2_t *this)
{
  v32 = a2;
  if ((google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v32, this[11].i32[1]) & 1) == 0)
  {
    while (1)
    {
      v6 = (v32 + 1);
      v7 = *v32;
      if ((*v32 & 0x80000000) == 0)
      {
        goto LABEL_6;
      }

      v8 = v7 + (*v6 << 7);
      v7 = v8 - 128;
      if ((*v6 & 0x80000000) == 0)
      {
        break;
      }

      TagFallback = google::protobuf::internal::ReadTagFallback(v32, (v8 - 128));
      v32 = TagFallback;
      if (!TagFallback)
      {
        return 0;
      }

      v6 = TagFallback;
      v7 = v29;
LABEL_7:
      v9 = v7 >> 3;
      if (v7 >> 3 > 2)
      {
        if (v9 == 3)
        {
          if (v7 == 26)
          {
            *(a1 + 40) |= 2u;
            v10 = *(a1 + 80);
            if (!v10)
            {
              v16 = *(a1 + 8);
              if (v16)
              {
                v16 = *(v16 & 0xFFFFFFFFFFFFFFFELL);
              }

              v10 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::NormalizerSpec>(v16);
              *(a1 + 80) = v10;
LABEL_32:
              v6 = v32;
            }

LABEL_33:
            v15 = google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::NormalizerSpec>(this, v10, v6);
            goto LABEL_65;
          }
        }

        else if (v9 == 4)
        {
          if (v7 == 34)
          {
            *(a1 + 40) |= 4u;
            v17 = *(a1 + 88);
            if (!v17)
            {
              v18 = *(a1 + 8);
              if (v18)
              {
                v18 = *(v18 & 0xFFFFFFFFFFFFFFFELL);
              }

              v17 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SelfTestData>(v18);
              *(a1 + 88) = v17;
              v6 = v32;
            }

            v15 = google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::SelfTestData>(this, v17, v6);
            goto LABEL_65;
          }
        }

        else if (v9 == 5 && v7 == 42)
        {
          *(a1 + 40) |= 8u;
          v10 = *(a1 + 96);
          if (!v10)
          {
            v11 = *(a1 + 8);
            if (v11)
            {
              v11 = *(v11 & 0xFFFFFFFFFFFFFFFELL);
            }

            v10 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::NormalizerSpec>(v11);
            *(a1 + 96) = v10;
            goto LABEL_32;
          }

          goto LABEL_33;
        }

        goto LABEL_54;
      }

      if (v9 == 1)
      {
        if (v7 != 10)
        {
          goto LABEL_54;
        }

        v19 = (v6 - 1);
        while (2)
        {
          v20 = (v19 + 1);
          v32 = (v19 + 1);
          v21 = *(a1 + 64);
          if (!v21)
          {
            v22 = *(a1 + 60);
            goto LABEL_44;
          }

          v26 = *(a1 + 56);
          v22 = *v21;
          if (v26 >= *v21)
          {
            if (v22 == *(a1 + 60))
            {
LABEL_44:
              google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a1 + 48), v22 + 1);
              v21 = *(a1 + 64);
              v22 = *v21;
            }

            *v21 = v22 + 1;
            v23 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::ModelProto_SentencePiece>(*(a1 + 48));
            v24 = *(a1 + 56);
            v25 = *(a1 + 64) + 8 * v24;
            *(a1 + 56) = v24 + 1;
            *(v25 + 8) = v23;
            v20 = v32;
          }

          else
          {
            *(a1 + 56) = v26 + 1;
            v23 = *&v21[2 * v26 + 2];
          }

          v19 = google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::ModelProto_SentencePiece>(this, v23, v20);
          v32 = v19;
          if (!v19)
          {
            return 0;
          }

          if (*this <= v19 || *v19 != 10)
          {
            goto LABEL_66;
          }

          continue;
        }
      }

      if (v9 == 2 && v7 == 18)
      {
        *(a1 + 40) |= 1u;
        v13 = *(a1 + 72);
        if (!v13)
        {
          v14 = *(a1 + 8);
          if (v14)
          {
            v14 = *(v14 & 0xFFFFFFFFFFFFFFFELL);
          }

          v13 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::TrainerSpec>(v14);
          *(a1 + 72) = v13;
          v6 = v32;
        }

        google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::TrainerSpec>(this, v13, v6);
        goto LABEL_65;
      }

LABEL_54:
      if (v7)
      {
        v27 = (v7 & 7) == 4;
      }

      else
      {
        v27 = 1;
      }

      if (v27)
      {
        this[10].i32[0] = v7 - 1;
        return v32;
      }

      if (v7 < 0x640)
      {
        v30 = *(a1 + 8);
        if (v30)
        {
          v31 = ((v30 & 0xFFFFFFFFFFFFFFFELL) + 8);
        }

        else
        {
          v31 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>((a1 + 8));
          v6 = v32;
        }

        v15 = google::protobuf::internal::UnknownFieldParse(v7, v31, v6, this);
      }

      else
      {
        v15 = google::protobuf::internal::ExtensionSet::ParseField((a1 + 16), v7, v6, &sentencepiece::_ModelProto_default_instance_, (a1 + 8), this);
      }

LABEL_65:
      v32 = v15;
      if (!v15)
      {
        return 0;
      }

LABEL_66:
      if (google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v32, this[11].i32[1]))
      {
        return v32;
      }
    }

    v6 = (v32 + 2);
LABEL_6:
    v32 = v6;
    goto LABEL_7;
  }

  return v32;
}

unsigned __int8 *sentencepiece::ModelProto::_InternalSerialize(sentencepiece::ModelProto *this, unsigned __int8 *a2, google::protobuf::io::EpsCopyOutputStream *a3)
{
  v6 = *(this + 14);
  if (v6)
  {
    for (i = 0; i != v6; ++i)
    {
      if (*a3 <= a2)
      {
        a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
      }

      v8 = *(*(this + 8) + 8 * i + 8);
      *a2 = 10;
      v9 = *(v8 + 11);
      if (v9 > 0x7F)
      {
        a2[1] = v9 | 0x80;
        v11 = v9 >> 7;
        if (v9 >> 14)
        {
          v10 = a2 + 3;
          do
          {
            *(v10 - 1) = v11 | 0x80;
            v12 = v11 >> 7;
            ++v10;
            v13 = v11 >> 14;
            v11 >>= 7;
          }

          while (v13);
          *(v10 - 1) = v12;
        }

        else
        {
          a2[2] = v11;
          v10 = a2 + 3;
        }
      }

      else
      {
        a2[1] = v9;
        v10 = a2 + 2;
      }

      a2 = sentencepiece::ModelProto_SentencePiece::_InternalSerialize(v8, v10, a3);
    }
  }

  v14 = *(this + 10);
  if (v14)
  {
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v15 = *(this + 9);
    *a2 = 18;
    v16 = *(v15 + 12);
    if (v16 > 0x7F)
    {
      a2[1] = v16 | 0x80;
      v18 = v16 >> 7;
      if (v16 >> 14)
      {
        v17 = a2 + 3;
        do
        {
          *(v17 - 1) = v18 | 0x80;
          v19 = v18 >> 7;
          ++v17;
          v20 = v18 >> 14;
          v18 >>= 7;
        }

        while (v20);
        *(v17 - 1) = v19;
      }

      else
      {
        a2[2] = v18;
        v17 = a2 + 3;
      }
    }

    else
    {
      a2[1] = v16;
      v17 = a2 + 2;
    }

    a2 = sentencepiece::TrainerSpec::_InternalSerialize(v15, v17, a3);
    if ((v14 & 2) == 0)
    {
LABEL_15:
      if ((v14 & 4) == 0)
      {
        goto LABEL_16;
      }

      goto LABEL_38;
    }
  }

  else if ((v14 & 2) == 0)
  {
    goto LABEL_15;
  }

  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v21 = *(this + 10);
  *a2 = 26;
  v22 = *(v21 + 11);
  if (v22 > 0x7F)
  {
    a2[1] = v22 | 0x80;
    v24 = v22 >> 7;
    if (v22 >> 14)
    {
      v23 = a2 + 3;
      do
      {
        *(v23 - 1) = v24 | 0x80;
        v25 = v24 >> 7;
        ++v23;
        v26 = v24 >> 14;
        v24 >>= 7;
      }

      while (v26);
      *(v23 - 1) = v25;
    }

    else
    {
      a2[2] = v24;
      v23 = a2 + 3;
    }
  }

  else
  {
    a2[1] = v22;
    v23 = a2 + 2;
  }

  a2 = sentencepiece::NormalizerSpec::_InternalSerialize(v21, v23, a3);
  if ((v14 & 4) == 0)
  {
LABEL_16:
    if ((v14 & 8) == 0)
    {
      goto LABEL_58;
    }

    goto LABEL_48;
  }

LABEL_38:
  if (*a3 <= a2)
  {
    a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
  }

  v27 = *(this + 11);
  *a2 = 34;
  v28 = *(v27 + 16);
  if (v28 > 0x7F)
  {
    a2[1] = v28 | 0x80;
    v30 = v28 >> 7;
    if (v28 >> 14)
    {
      v29 = a2 + 3;
      do
      {
        *(v29 - 1) = v30 | 0x80;
        v31 = v30 >> 7;
        ++v29;
        v32 = v30 >> 14;
        v30 >>= 7;
      }

      while (v32);
      *(v29 - 1) = v31;
    }

    else
    {
      a2[2] = v30;
      v29 = a2 + 3;
    }
  }

  else
  {
    a2[1] = v28;
    v29 = a2 + 2;
  }

  a2 = sentencepiece::SelfTestData::_InternalSerialize(v27, v29, a3);
  if ((v14 & 8) != 0)
  {
LABEL_48:
    if (*a3 <= a2)
    {
      a2 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a3, a2);
    }

    v33 = *(this + 12);
    *a2 = 42;
    v34 = *(v33 + 11);
    if (v34 > 0x7F)
    {
      a2[1] = v34 | 0x80;
      v36 = v34 >> 7;
      if (v34 >> 14)
      {
        v35 = a2 + 3;
        do
        {
          *(v35 - 1) = v36 | 0x80;
          v37 = v36 >> 7;
          ++v35;
          v38 = v36 >> 14;
          v36 >>= 7;
        }

        while (v38);
        *(v35 - 1) = v37;
      }

      else
      {
        a2[2] = v36;
        v35 = a2 + 3;
      }
    }

    else
    {
      a2[1] = v34;
      v35 = a2 + 2;
    }

    a2 = sentencepiece::NormalizerSpec::_InternalSerialize(v33, v35, a3);
  }

LABEL_58:
  v39 = google::protobuf::internal::ExtensionSet::_InternalSerialize((this + 16), 200, 0x20000000, a2, a3);
  v40 = v39;
  v41 = *(this + 1);
  if ((v41 & 1) == 0)
  {
    return v40;
  }

  v43 = v41 & 0xFFFFFFFFFFFFFFFELL;
  v44 = *(v43 + 31);
  if (v44 < 0)
  {
    v45 = *(v43 + 8);
    v44 = *(v43 + 16);
  }

  else
  {
    v45 = (v43 + 8);
  }

  if (*a3 - v39 >= v44)
  {
    v46 = v44;
    memcpy(v39, v45, v44);
    v40 += v46;
    return v40;
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(a3, v45, v44, v39);
}

uint64_t sentencepiece::ModelProto::ByteSizeLong(sentencepiece::ModelProto *this)
{
  v2 = google::protobuf::internal::ExtensionSet::ByteSize((this + 16));
  v3 = *(this + 14);
  v4 = v2 + v3;
  v5 = *(this + 8);
  if (v5)
  {
    v6 = (v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  if (v3)
  {
    v7 = 8 * v3;
    do
    {
      v8 = *v6++;
      v9 = sentencepiece::ModelProto_SentencePiece::ByteSizeLong(v8);
      v4 += v9 + ((9 * (__clz(v9 | 1) ^ 0x1F) + 73) >> 6);
      v7 -= 8;
    }

    while (v7);
  }

  v10 = *(this + 10);
  if ((v10 & 0xF) == 0)
  {
    goto LABEL_13;
  }

  if ((v10 & 1) == 0)
  {
    if ((v10 & 2) == 0)
    {
      goto LABEL_10;
    }

LABEL_16:
    v15 = sentencepiece::NormalizerSpec::ByteSizeLong(*(this + 10));
    v4 += v15 + ((9 * (__clz(v15 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v10 & 4) == 0)
    {
LABEL_11:
      if ((v10 & 8) == 0)
      {
        goto LABEL_13;
      }

      goto LABEL_12;
    }

    goto LABEL_17;
  }

  v14 = sentencepiece::TrainerSpec::ByteSizeLong(*(this + 9));
  v4 += v14 + ((9 * (__clz(v14 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v10 & 2) != 0)
  {
    goto LABEL_16;
  }

LABEL_10:
  if ((v10 & 4) == 0)
  {
    goto LABEL_11;
  }

LABEL_17:
  v16 = sentencepiece::SelfTestData::ByteSizeLong(*(this + 11));
  v4 += v16 + ((9 * (__clz(v16 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v10 & 8) != 0)
  {
LABEL_12:
    v11 = sentencepiece::NormalizerSpec::ByteSizeLong(*(this + 12));
    v4 += v11 + ((9 * (__clz(v11 | 1) ^ 0x1F) + 73) >> 6) + 1;
  }

LABEL_13:
  v12 = *(this + 1);
  if (v12)
  {
    v17 = v12 & 0xFFFFFFFFFFFFFFFELL;
    v18 = *((v12 & 0xFFFFFFFFFFFFFFFELL) + 31);
    if (v18 < 0)
    {
      v18 = *(v17 + 16);
    }

    v4 += v18;
  }

  *(this + 11) = v4;
  return v4;
}

void sentencepiece::ModelProto::MergeFrom(sentencepiece::ModelProto *this, const sentencepiece::ModelProto *a2)
{
  google::protobuf::internal::ExtensionSet::MergeFrom((this + 16), (a2 + 16));
  v4 = *(a2 + 1);
  if (v4)
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v6 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 8;
    v7 = *(this + 1);
    if (v7)
    {
      v8 = ((v7 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }

    else
    {
      v8 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(this + 1);
    }

    v9 = *(v5 + 31);
    if (v9 >= 0)
    {
      v10 = v6;
    }

    else
    {
      v10 = *(v5 + 8);
    }

    if (v9 >= 0)
    {
      v11 = *(v5 + 31);
    }

    else
    {
      v11 = *(v5 + 16);
    }

    std::string::append(v8, v10, v11);
  }

  v12 = *(a2 + 14);
  if (v12)
  {
    v13 = *(a2 + 8);
    v14 = google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend((this + 48), *(a2 + 14));
    google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<sentencepiece::ModelProto_SentencePiece>::TypeHandler>(this + 6, v14, (v13 + 8), v12, **(this + 8) - *(this + 14));
    v15 = *(this + 14) + v12;
    *(this + 14) = v15;
    v16 = *(this + 8);
    if (*v16 < v15)
    {
      *v16 = v15;
    }
  }

  v17 = *(a2 + 10);
  if ((v17 & 0xF) != 0)
  {
    if (v17)
    {
      *(this + 10) |= 1u;
      v18 = *(this + 9);
      if (!v18)
      {
        v19 = *(this + 1);
        if (v19)
        {
          v19 = *(v19 & 0xFFFFFFFFFFFFFFFELL);
        }

        v18 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::TrainerSpec>(v19);
        *(this + 9) = v18;
      }

      if (*(a2 + 9))
      {
        v20 = *(a2 + 9);
      }

      else
      {
        v20 = &sentencepiece::_TrainerSpec_default_instance_;
      }

      sentencepiece::TrainerSpec::MergeFrom(v18, v20);
    }

    if ((v17 & 2) != 0)
    {
      *(this + 10) |= 2u;
      v21 = *(this + 10);
      if (!v21)
      {
        v22 = *(this + 1);
        if (v22)
        {
          v22 = *(v22 & 0xFFFFFFFFFFFFFFFELL);
        }

        v21 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::NormalizerSpec>(v22);
        *(this + 10) = v21;
      }

      if (*(a2 + 10))
      {
        v23 = *(a2 + 10);
      }

      else
      {
        v23 = &sentencepiece::_NormalizerSpec_default_instance_;
      }

      sentencepiece::NormalizerSpec::MergeFrom(v21, v23);
      if ((v17 & 4) == 0)
      {
LABEL_26:
        if ((v17 & 8) == 0)
        {
          return;
        }

        goto LABEL_44;
      }
    }

    else if ((v17 & 4) == 0)
    {
      goto LABEL_26;
    }

    *(this + 10) |= 4u;
    v24 = *(this + 11);
    if (!v24)
    {
      v25 = *(this + 1);
      if (v25)
      {
        v25 = *(v25 & 0xFFFFFFFFFFFFFFFELL);
      }

      v24 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SelfTestData>(v25);
      *(this + 11) = v24;
    }

    if (*(a2 + 11))
    {
      v26 = *(a2 + 11);
    }

    else
    {
      v26 = &sentencepiece::_SelfTestData_default_instance_;
    }

    sentencepiece::SelfTestData::MergeFrom(v24, v26);
    if ((v17 & 8) != 0)
    {
LABEL_44:
      *(this + 10) |= 8u;
      v27 = *(this + 12);
      if (!v27)
      {
        v28 = *(this + 1);
        if (v28)
        {
          v28 = *(v28 & 0xFFFFFFFFFFFFFFFELL);
        }

        v27 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::NormalizerSpec>(v28);
        *(this + 12) = v27;
      }

      if (*(a2 + 12))
      {
        v29 = *(a2 + 12);
      }

      else
      {
        v29 = &sentencepiece::_NormalizerSpec_default_instance_;
      }

      sentencepiece::NormalizerSpec::MergeFrom(v27, v29);
    }
  }
}

void sentencepiece::ModelProto::CopyFrom(sentencepiece::ModelProto *this, const sentencepiece::ModelProto *a2)
{
  if (a2 != this)
  {
    sentencepiece::ModelProto::Clear(this);

    sentencepiece::ModelProto::MergeFrom(this, a2);
  }
}

uint64_t sentencepiece::ModelProto::IsInitialized(sentencepiece::ModelProto *this)
{
  result = google::protobuf::internal::ExtensionSet::IsInitialized((this + 16));
  if (result)
  {
    v3 = *(this + 14);
    while (v3 >= 1)
    {
      v4 = v3 - 1;
      IsInitialized = google::protobuf::internal::ExtensionSet::IsInitialized((*(*(this + 8) + 8 * v3) + 16));
      v3 = v4;
      if ((IsInitialized & 1) == 0)
      {
        return 0;
      }
    }

    v6 = *(this + 10);
    if (v6)
    {
      result = google::protobuf::internal::ExtensionSet::IsInitialized((*(this + 9) + 16));
      if (!result)
      {
        return result;
      }

      v6 = *(this + 10);
    }

    if ((v6 & 2) != 0)
    {
      result = google::protobuf::internal::ExtensionSet::IsInitialized((*(this + 10) + 16));
      if (!result)
      {
        return result;
      }

      v6 = *(this + 10);
    }

    if ((v6 & 4) != 0)
    {
      result = google::protobuf::internal::ExtensionSet::IsInitialized((*(this + 11) + 16));
      if (!result)
      {
        return result;
      }

      v6 = *(this + 10);
    }

    if ((v6 & 8) == 0)
    {
      return 1;
    }

    result = google::protobuf::internal::ExtensionSet::IsInitialized((*(this + 12) + 16));
    if (result)
    {
      return 1;
    }
  }

  return result;
}

uint64_t google::protobuf::Arena::CreateMaybeMessage<sentencepiece::TrainerSpec>(google::protobuf::Arena *this)
{
  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
  }

  AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(this, 0x130uLL);
  sentencepiece::TrainerSpec::TrainerSpec(AlignedNoHook, this);
  return AlignedNoHook;
}

uint64_t google::protobuf::Arena::CreateMaybeMessage<sentencepiece::NormalizerSpec>(google::protobuf::Arena *this)
{
  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
  }

  AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(this, 0x50uLL);
  sentencepiece::NormalizerSpec::NormalizerSpec(AlignedNoHook, this);
  return AlignedNoHook;
}

void *google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SelfTestData_Sample>(google::protobuf::Arena *this)
{
  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
  }

  AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(this, 0x28uLL);
  sentencepiece::SelfTestData_Sample::SelfTestData_Sample(AlignedNoHook, this);
  return AlignedNoHook;
}

uint64_t google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SelfTestData>(google::protobuf::Arena *this)
{
  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
  }

  AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(this, 0x48uLL);
  sentencepiece::SelfTestData::SelfTestData(AlignedNoHook, this);
  return AlignedNoHook;
}

void *google::protobuf::Arena::CreateMaybeMessage<sentencepiece::ModelProto_SentencePiece>(google::protobuf::Arena *this)
{
  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
  }

  AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(this, 0x40uLL);
  sentencepiece::ModelProto_SentencePiece::ModelProto_SentencePiece(AlignedNoHook, this);
  return AlignedNoHook;
}

uint64_t google::protobuf::Arena::CreateMaybeMessage<sentencepiece::ModelProto>(google::protobuf::Arena *this)
{
  if (!this)
  {
    operator new();
  }

  if (*(this + 24))
  {
  }

  AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(this, 0x68uLL);
  sentencepiece::ModelProto::ModelProto(AlignedNoHook, this);
  return AlignedNoHook;
}

uint64_t google::protobuf::internal::RepeatedPtrFieldBase::Clear<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(uint64_t result)
{
  v1 = *(result + 8);
  if (v1 >= 1)
  {
    v2 = *(result + 16) + 8;
    do
    {
      v3 = *v2;
      if (*(*v2 + 23) < 0)
      {
        **v3 = 0;
        *(v3 + 8) = 0;
      }

      else
      {
        *v3 = 0;
        *(v3 + 23) = 0;
      }

      v2 += 8;
      --v1;
    }

    while (v1);
    *(result + 8) = 0;
  }

  return result;
}

std::string *google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(std::string *result, std::string **a2, const std::string **a3, unsigned int a4, unsigned int a5)
{
  v9 = result;
  if (a5 >= a4)
  {
    v10 = a4;
  }

  else
  {
    v10 = a5;
  }

  if (v10 >= 1)
  {
    v11 = a3;
    v12 = a2;
    do
    {
      v14 = *v11++;
      v13 = v14;
      v15 = *v12++;
      result = std::string::operator=(v15, v13);
      --v10;
    }

    while (v10);
  }

  v16 = __OFSUB__(a4, a5);
  v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    v18 = v9->__words[0];
    v19 = &a3[a5];
    v20 = &a2[a5];
    do
    {
      v21 = *v19;
      if (!v18)
      {
        operator new();
      }

      if (*(v18 + 24))
      {
        google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(v18 + 32);
      }

      AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v18, 0x18uLL, google::protobuf::internal::arena_destruct_object<std::string>);
      AlignedAndAddCleanup->__r_.__value_.__r.__words[0] = 0;
      AlignedAndAddCleanup->__r_.__value_.__l.__size_ = 0;
      AlignedAndAddCleanup->__r_.__value_.__r.__words[2] = 0;
      result = std::string::operator=(AlignedAndAddCleanup, v21);
      *v20++ = AlignedAndAddCleanup;
      ++v19;
      --v17;
    }

    while (v17);
  }

  return result;
}

void google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::SelfTestData_Sample>::TypeHandler>(void *a1)
{
  v2 = a1[2];
  if (v2 && !*a1)
  {
    v3 = v2 + 1;
    v4 = *v2;
    if (v4 >= 1)
    {
      do
      {
        if (*v3)
        {
          sentencepiece::SelfTestData_Sample::~SelfTestData_Sample(*v3);
          MEMORY[0x1B8C85350]();
        }

        ++v3;
        --v4;
      }

      while (v4);
      v2 = a1[2];
    }

    operator delete(v2);
  }

  a1[2] = 0;
}

void google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<sentencepiece::SelfTestData_Sample>::TypeHandler>(google::protobuf::Arena **a1, sentencepiece::SelfTestData_Sample **a2, sentencepiece::SelfTestData_Sample **a3, unsigned int a4, unsigned int a5)
{
  if (a5 >= a4)
  {
    v10 = a4;
  }

  else
  {
    v10 = a5;
  }

  if (v10 >= 1)
  {
    v11 = a3;
    v12 = a2;
    do
    {
      v14 = *v11++;
      v13 = v14;
      v15 = *v12++;
      google::protobuf::internal::GenericTypeHandler<sentencepiece::SelfTestData_Sample>::Merge(v13, v15);
      --v10;
    }

    while (v10);
  }

  v16 = __OFSUB__(a4, a5);
  v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    v18 = *a1;
    v19 = &a3[a5];
    v20 = &a2[a5];
    do
    {
      v21 = *v19++;
      v22 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SelfTestData_Sample>(v18);
      google::protobuf::internal::GenericTypeHandler<sentencepiece::SelfTestData_Sample>::Merge(v21, v22);
      *v20++ = v22;
      --v17;
    }

    while (v17);
  }
}

void google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<sentencepiece::ModelProto_SentencePiece>::TypeHandler>(void *a1)
{
  v2 = a1[2];
  if (v2 && !*a1)
  {
    v3 = v2 + 1;
    v4 = *v2;
    if (v4 >= 1)
    {
      do
      {
        if (*v3)
        {
          sentencepiece::ModelProto_SentencePiece::~ModelProto_SentencePiece(*v3);
          MEMORY[0x1B8C85350]();
        }

        ++v3;
        --v4;
      }

      while (v4);
      v2 = a1[2];
    }

    operator delete(v2);
  }

  a1[2] = 0;
}

void google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<sentencepiece::ModelProto_SentencePiece>::TypeHandler>(google::protobuf::Arena **a1, sentencepiece::ModelProto_SentencePiece **a2, sentencepiece::ModelProto_SentencePiece **a3, unsigned int a4, unsigned int a5)
{
  if (a5 >= a4)
  {
    v10 = a4;
  }

  else
  {
    v10 = a5;
  }

  if (v10 >= 1)
  {
    v11 = a3;
    v12 = a2;
    do
    {
      v14 = *v11++;
      v13 = v14;
      v15 = *v12++;
      google::protobuf::internal::GenericTypeHandler<sentencepiece::ModelProto_SentencePiece>::Merge(v13, v15);
      --v10;
    }

    while (v10);
  }

  v16 = __OFSUB__(a4, a5);
  v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    v18 = *a1;
    v19 = &a3[a5];
    v20 = &a2[a5];
    do
    {
      v21 = *v19++;
      v22 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::ModelProto_SentencePiece>(v18);
      google::protobuf::internal::GenericTypeHandler<sentencepiece::ModelProto_SentencePiece>::Merge(v21, v22);
      *v20++ = v22;
      --v17;
    }

    while (v17);
  }
}

void *OUTLINED_FUNCTION_15(void *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

void OUTLINED_FUNCTION_17()
{

  operator new();
}

void *OUTLINED_FUNCTION_18(uint64_t a1, uint64_t a2, void (*a3)(void *))
{

  return google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v3, 0x18uLL, a3);
}

void sentencepiece::ModelProto_SentencePiece::_InternalParse(unint64_t *a1, unint64_t a2)
{
  if (*a1)
  {
    v3 = ((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  }

  else
  {
    v3 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(a1);
  }

  google::protobuf::internal::WriteVarint(3, a2, v3);
}

sentencepiece::character::Model *sentencepiece::character::Model::Model(sentencepiece::character::Model *this, const sentencepiece::ModelProto *a2)
{
  v4 = sentencepiece::ModelInterface::ModelInterface(this);
  *v4 = &unk_1F2D43A00;
  *(v4 + 1) = a2;
  sentencepiece::ModelInterface::InitializePieces(v4);
  return this;
}

void sentencepiece::character::Model::~Model(sentencepiece::character::Model *this)
{
  sentencepiece::ModelInterface::~ModelInterface(this);

  JUMPOUT(0x1B8C85350);
}

void sentencepiece::character::Model::Encode(uint64_t *a1@<X0>, _BYTE *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  (*(*a1 + 16))(&v21);
  if (v21)
  {
    sentencepiece::util::Status::~Status(&v21);
LABEL_3:
    *a4 = 0;
    *(a4 + 8) = 0;
    *(a4 + 16) = 0;
    return;
  }

  sentencepiece::util::Status::~Status(&v21);
  if (!a3)
  {
    goto LABEL_3;
  }

  *a4 = 0;
  *(a4 + 8) = 0;
  *(a4 + 16) = 0;
  do
  {
    v8 = sentencepiece::normalizer::PrefixMatcher::PrefixMatch(a1[2], a2, a3, 0);
    v9 = (*(*a1 + 128))(a1, a2, v8);
    v11 = *(a4 + 8);
    v10 = *(a4 + 16);
    if (v11 >= v10)
    {
      v13 = 0xAAAAAAAAAAAAAAABLL * ((v11 - *a4) >> 3);
      v14 = v13 + 1;
      if (v13 + 1 > 0xAAAAAAAAAAAAAAALL)
      {
        std::vector<int>::__throw_length_error[abi:ne200100]();
      }

      v15 = 0xAAAAAAAAAAAAAAABLL * ((v10 - *a4) >> 3);
      if (2 * v15 > v14)
      {
        v14 = 2 * v15;
      }

      if (v15 >= 0x555555555555555)
      {
        v16 = 0xAAAAAAAAAAAAAAALL;
      }

      else
      {
        v16 = v14;
      }

      if (v16)
      {
        std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(a4, v16);
      }

      v17 = 24 * v13;
      *v17 = a2;
      *(v17 + 8) = v8;
      *(v17 + 16) = v9;
      v12 = 24 * v13 + 24;
      v18 = *(a4 + 8) - *a4;
      v19 = v17 - v18;
      memcpy((v17 - v18), *a4, v18);
      v20 = *a4;
      *a4 = v19;
      *(a4 + 8) = v12;
      *(a4 + 16) = 0;
      if (v20)
      {
        operator delete(v20);
      }
    }

    else
    {
      *v11 = a2;
      *(v11 + 8) = v8;
      v12 = v11 + 24;
      *(v11 + 16) = v9;
    }

    *(a4 + 8) = v12;
    a2 += v8;
    a3 -= v8;
  }

  while (a3);
}

void sub_1B5AA9368(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::ModelInterface::SampleEncode(sentencepiece::logging *a1@<X0>, void *a2@<X8>)
{
  if (sentencepiece::logging::GetMinLogLevel(a1) <= 2)
  {
    v10 = 0;
    v3 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "model_interface.h", 17);
    v4 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v3, "(", 1);
    v5 = MEMORY[0x1B8C84C00](v4, 106);
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v5, ") ", 2);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, "LOG(", 4);
    v8 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v7, "ERROR", 5);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, ") ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "Not implemented.", 16);
    sentencepiece::error::Die::~Die(&v10);
  }

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

void sentencepiece::error::Abort(sentencepiece::error *this)
{
  if (!sentencepiece::error::gTestCounter)
  {
    v1 = std::operator<<[abi:ne200100]<std::char_traits<char>>(MEMORY[0x1E69E5300], "Program terminated with an unrecoverable error.");
    std::endl[abi:ne200100]<char,std::char_traits<char>>(v1);
    exit(-1);
  }

  sentencepiece::error::gTestCounter = 2;
}

void sentencepiece::util::Status::~Status(sentencepiece::util::Status *this)
{
  v1 = *this;
  *this = 0;
  if (v1)
  {
    std::default_delete<sentencepiece::util::Status::Rep>::operator()[abi:ne200100](this, v1);
  }
}

void sentencepiece::util::Status::Status()
{
  operator new();
}

{
  operator new();
}

void sub_1B5AA9548(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  *v1 = 0;
  if (v3)
  {
    std::default_delete<sentencepiece::util::Status::Rep>::operator()[abi:ne200100](v1, v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1B5AA95D0(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  *v1 = 0;
  if (v3)
  {
    std::default_delete<sentencepiece::util::Status::Rep>::operator()[abi:ne200100](v1, v3);
  }

  _Unwind_Resume(exception_object);
}

void *sentencepiece::util::Status::Status(void *this, const sentencepiece::util::Status *a2)
{
  if (*a2)
  {
    operator new();
  }

  *this = 0;
  return this;
}

void sentencepiece::util::Status::operator=(uint64_t *a1, void *a2)
{
  v3 = *a1;
  if (*a1 != *a2)
  {
    if (*a2)
    {
      operator new();
    }

    *a1 = 0;
    if (v3)
    {

      std::default_delete<sentencepiece::util::Status::Rep>::operator()[abi:ne200100](a1, v3);
    }
  }
}

const char *sentencepiece::util::Status::error_message(sentencepiece::util::Status *this)
{
  v1 = *this;
  if (!*this)
  {
    return "";
  }

  result = (v1 + 8);
  if (*(v1 + 31) < 0)
  {
    return *result;
  }

  return result;
}

uint64_t sentencepiece::util::Status::code(sentencepiece::util::Status *this)
{
  if (*this)
  {
    return **this;
  }

  else
  {
    return 0;
  }
}

std::string *sentencepiece::util::Status::ToString@<X0>(sentencepiece::util::Status *this@<X0>, std::string *a2@<X8>)
{
  v3 = *this;
  if (*this)
  {
    a2->__r_.__value_.__r.__words[0] = 0;
    a2->__r_.__value_.__l.__size_ = 0;
    a2->__r_.__value_.__r.__words[2] = 0;
    v5 = *v3 - 1;
    if (v5 < 0x10)
    {
      MEMORY[0x1B8C84820](a2, (&off_1E7C1C610)[v5]);
    }

    std::string::append(a2, ": ");
    v6 = *(*this + 31);
    if (v6 >= 0)
    {
      v7 = (*this + 8);
    }

    else
    {
      v7 = *(*this + 8);
    }

    if (v6 >= 0)
    {
      v8 = *(*this + 31);
    }

    else
    {
      v8 = *(*this + 16);
    }

    return std::string::append(a2, v7, v8);
  }

  else
  {

    return std::string::basic_string[abi:ne200100]<0>(a2, "OK");
  }
}

void sub_1B5AA9880(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

void std::default_delete<sentencepiece::util::Status::Rep>::operator()[abi:ne200100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(a2 + 31) < 0)
    {
      operator delete(*(a2 + 8));
    }

    JUMPOUT(0x1B8C85350);
  }
}

void *sentencepiece::filesystem::PosixReadableFile::PosixReadableFile(void *a1, const char *a2, uint64_t a3)
{
  *a1 = &unk_1F2D43B00;
  v6 = a1 + 1;
  marisa::Trie::Trie(a1 + 1);
  if (a3)
  {
    operator new();
  }

  v7 = MEMORY[0x1E69E52F0];
  a1[2] = MEMORY[0x1E69E52F0];
  if ((*(v7 + *(*v7 - 24) + 32) & 5) != 0)
  {
    v15 = 5;
    std::ostringstream::basic_ostringstream[abi:ne200100](&v16);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, "", 1);
    v8 = strlen(a2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, a2, v8);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, ": ", 3);
    v9 = __error();
    sentencepiece::util::StrError(*v9);
    if ((v14 & 0x80u) == 0)
    {
      v10 = __p;
    }

    else
    {
      v10 = __p[0];
    }

    if ((v14 & 0x80u) == 0)
    {
      v11 = v14;
    }

    else
    {
      v11 = __p[1];
    }

    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, v10, v11);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v15, &v21);
    sentencepiece::util::Status::operator=(v6, &v21);
    sentencepiece::util::Status::~Status(&v21);
    if (v14 < 0)
    {
      operator delete(__p[0]);
    }

    v16 = *MEMORY[0x1E69E54E8];
    *(&v16 + *(v16 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
    v17 = MEMORY[0x1E69E5548] + 16;
    if (v19 < 0)
    {
      operator delete(v18[7].__locale_);
    }

    v17 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v18);
    std::ostream::~ostream();
    MEMORY[0x1B8C85200](&v20);
  }

  return a1;
}

void sub_1B5AA9C50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15)
{
  sentencepiece::util::Status::~Status((v16 - 56));
  if (a14 < 0)
  {
    operator delete(__p);
  }

  sentencepiece::util::StatusBuilder::~StatusBuilder(&a15);
  sentencepiece::util::Status::~Status(v15);
  _Unwind_Resume(a1);
}

void sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  v3 = *a1;
  std::stringbuf::str();
  sentencepiece::util::Status::Status(a2, v3, &__p);
  if (v5 < 0)
  {
    operator delete(__p);
  }
}

void sub_1B5AA9D1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::util::StatusBuilder::~StatusBuilder(std::locale *this)
{
  v2 = MEMORY[0x1E69E54E8];
  v3 = *MEMORY[0x1E69E54E8];
  this[1].__locale_ = *MEMORY[0x1E69E54E8];
  *(this + *(v3 - 24) + 8) = v2[3];
  this[2].__locale_ = (MEMORY[0x1E69E5548] + 16);
  if (SHIBYTE(this[12].__locale_) < 0)
  {
    operator delete(this[10].__locale_);
  }

  this[2].__locale_ = (MEMORY[0x1E69E5538] + 16);
  std::locale::~locale(this + 3);
  std::ostream::~ostream();
  MEMORY[0x1B8C85200](&this[15]);
}

void sentencepiece::filesystem::PosixReadableFile::~PosixReadableFile(sentencepiece::filesystem::PosixReadableFile *this)
{
  sentencepiece::filesystem::PosixReadableFile::~PosixReadableFile(this);

  JUMPOUT(0x1B8C85350);
}

{
  *this = &unk_1F2D43B00;
  v2 = *(this + 2);
  if (v2 != MEMORY[0x1E69E52F0] && v2 != 0)
  {
    (*(*v2 + 8))(v2);
  }

  sentencepiece::util::Status::~Status((this + 8));
}

BOOL sentencepiece::filesystem::PosixReadableFile::ReadLine(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 16);
  std::ios_base::getloc((v3 + *(*v3 - 24)));
  v4 = std::locale::use_facet(&v8, MEMORY[0x1E69E5318]);
  v5 = (v4->__vftable[2].~facet_0)(v4, 10);
  std::locale::~locale(&v8);
  v6 = std::getline[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(v3, a2, v5);
  return (*(v6 + *(*v6 - 24) + 32) & 5) == 0;
}

BOOL sentencepiece::filesystem::PosixReadableFile::ReadAll(sentencepiece::logging *a1, uint64_t a2)
{
  v2 = *(a1 + 2);
  v3 = MEMORY[0x1E69E52F0];
  if (v2 == MEMORY[0x1E69E52F0])
  {
    if (sentencepiece::logging::GetMinLogLevel(a1) <= 2)
    {
      v12 = 0;
      v4 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "filesystem.cc", 13);
      v5 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v4, "(", 1);
      v6 = MEMORY[0x1B8C84C00](v5, 55);
      v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, ") ", 2);
      v8 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v7, "LOG(", 4);
      v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, "ERROR", 5);
      v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, ") ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, "ReadAll is not supported for stdin.", 35);
      sentencepiece::error::Die::~Die(&v12);
    }
  }

  else
  {
    std::string::__assign_with_sentinel[abi:ne200100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(a2, *(v2 + *(*v2 - 24) + 40), 0);
  }

  return v2 != v3;
}

void std::string::__assign_with_sentinel[abi:ne200100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(uint64_t a1, void *a2, void *a3)
{
  std::string::__init_with_sentinel[abi:ne200100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(&__p, a2, a3);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  MEMORY[0x1B8C84830](a1, p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1B5AAA18C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::ModelFactory::Create(sentencepiece::ModelFactory *this@<X0>, void *a2@<X8>)
{
  if (*(this + 9))
  {
    v4 = *(this + 9);
  }

  else
  {
    v4 = &sentencepiece::_TrainerSpec_default_instance_;
  }

  v5 = v4[62];
  if (v5 > 2)
  {
    if (v5 == 3)
    {
      absl::make_unique<sentencepiece::word::Model,sentencepiece::ModelProto const&>();
    }

    if (v5 == 4)
    {
      absl::make_unique<sentencepiece::character::Model,sentencepiece::ModelProto const&>();
    }
  }

  else
  {
    if (v5 == 1)
    {
      absl::make_unique<sentencepiece::unigram::Model,sentencepiece::ModelProto const&>();
    }

    if (v5 == 2)
    {
      absl::make_unique<sentencepiece::bpe::Model,sentencepiece::ModelProto const&>();
    }
  }

  if (sentencepiece::logging::GetMinLogLevel(this) <= 2)
  {
    LOBYTE(v14) = 0;
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "model_factory.cc", 16);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, "(", 1);
    v8 = MEMORY[0x1B8C84C00](v7, 43);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, ") ", 2);
    v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "LOG(", 4);
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, "ERROR", 5);
    v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, ") ", 2);
    v13 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, "Unknown model_type: ", 20);
    MEMORY[0x1B8C84C00](v13, v4[62]);
    sentencepiece::error::Die::~Die(&v14);
  }

  *a2 = 0;
}

void sub_1B5AAA2EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::error::Die::~Die(va);
  _Unwind_Resume(a1);
}

void sentencepiece::ModelInterface::~ModelInterface(sentencepiece::ModelInterface *this)
{
  *this = &unk_1F2D43B60;
  v2 = this + 24;
  sentencepiece::util::Status::~Status((this + 112));
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(this + 64);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(v2);
  v3 = *(this + 2);
  *(this + 2) = 0;
  if (v3)
  {
    std::default_delete<sentencepiece::normalizer::PrefixMatcher>::operator()[abi:ne200100](this + 16, v3);
  }
}

char *sentencepiece::ModelInterface::unk_piece(sentencepiece::ModelInterface *this)
{
  v2 = *(*(this + 1) + 72);
  if (!v2)
  {
    v2 = &sentencepiece::_TrainerSpec_default_instance_;
  }

  v3 = v2[23];
  if (v3)
  {
    explicit = v3 & 0xFFFFFFFFFFFFFFFELL;
  }

  else
  {
    explicit = atomic_load_explicit(&qword_1EB907FB0, memory_order_acquire);
    if (!explicit)
    {
      explicit = google::protobuf::internal::LazyString::Init(&sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_unk_piece_);
    }
  }

  if ((*(explicit + 23) & 0x8000000000000000) != 0)
  {
    if (*(explicit + 8))
    {
      goto LABEL_9;
    }

    return "<unk>";
  }

  if (!*(explicit + 23))
  {
    return "<unk>";
  }

LABEL_9:
  v5 = *(*(this + 1) + 72);
  if (!v5)
  {
    v5 = &sentencepiece::_TrainerSpec_default_instance_;
  }

  v6 = v5[23];
  if (v6)
  {
    result = (v6 & 0xFFFFFFFFFFFFFFFELL);
  }

  else
  {
    result = atomic_load_explicit(&qword_1EB907FB0, memory_order_acquire);
    if (!result)
    {
      result = google::protobuf::internal::LazyString::Init(&sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_unk_piece_);
    }
  }

  if (result[23] < 0)
  {
    return *result;
  }

  return result;
}

char *sentencepiece::ModelInterface::bos_piece(sentencepiece::ModelInterface *this)
{
  v2 = *(*(this + 1) + 72);
  if (!v2)
  {
    v2 = &sentencepiece::_TrainerSpec_default_instance_;
  }

  v3 = v2[24];
  if (v3)
  {
    explicit = v3 & 0xFFFFFFFFFFFFFFFELL;
  }

  else
  {
    explicit = atomic_load_explicit(&qword_1EB908010, memory_order_acquire);
    if (!explicit)
    {
      explicit = google::protobuf::internal::LazyString::Init(&sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_bos_piece_);
    }
  }

  if ((*(explicit + 23) & 0x8000000000000000) != 0)
  {
    if (*(explicit + 8))
    {
      goto LABEL_9;
    }

    return "<s>";
  }

  if (!*(explicit + 23))
  {
    return "<s>";
  }

LABEL_9:
  v5 = *(*(this + 1) + 72);
  if (!v5)
  {
    v5 = &sentencepiece::_TrainerSpec_default_instance_;
  }

  v6 = v5[24];
  if (v6)
  {
    result = (v6 & 0xFFFFFFFFFFFFFFFELL);
  }

  else
  {
    result = atomic_load_explicit(&qword_1EB908010, memory_order_acquire);
    if (!result)
    {
      result = google::protobuf::internal::LazyString::Init(&sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_bos_piece_);
    }
  }

  if (result[23] < 0)
  {
    return *result;
  }

  return result;
}

char *sentencepiece::ModelInterface::eos_piece(sentencepiece::ModelInterface *this)
{
  v2 = *(*(this + 1) + 72);
  if (!v2)
  {
    v2 = &sentencepiece::_TrainerSpec_default_instance_;
  }

  v3 = v2[25];
  if (v3)
  {
    explicit = v3 & 0xFFFFFFFFFFFFFFFELL;
  }

  else
  {
    explicit = atomic_load_explicit(&qword_1EB907FF0, memory_order_acquire);
    if (!explicit)
    {
      explicit = google::protobuf::internal::LazyString::Init(&sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_eos_piece_);
    }
  }

  if ((*(explicit + 23) & 0x8000000000000000) != 0)
  {
    if (*(explicit + 8))
    {
      goto LABEL_9;
    }

    return "</s>";
  }

  if (!*(explicit + 23))
  {
    return "</s>";
  }

LABEL_9:
  v5 = *(*(this + 1) + 72);
  if (!v5)
  {
    v5 = &sentencepiece::_TrainerSpec_default_instance_;
  }

  v6 = v5[25];
  if (v6)
  {
    result = (v6 & 0xFFFFFFFFFFFFFFFELL);
  }

  else
  {
    result = atomic_load_explicit(&qword_1EB907FF0, memory_order_acquire);
    if (!result)
    {
      result = google::protobuf::internal::LazyString::Init(&sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_eos_piece_);
    }
  }

  if (result[23] < 0)
  {
    return *result;
  }

  return result;
}

char *sentencepiece::ModelInterface::pad_piece(sentencepiece::ModelInterface *this)
{
  v2 = *(*(this + 1) + 72);
  if (!v2)
  {
    v2 = &sentencepiece::_TrainerSpec_default_instance_;
  }

  v3 = v2[26];
  if (v3)
  {
    explicit = v3 & 0xFFFFFFFFFFFFFFFELL;
  }

  else
  {
    explicit = atomic_load_explicit(&qword_1EB907FD0, memory_order_acquire);
    if (!explicit)
    {
      explicit = google::protobuf::internal::LazyString::Init(&sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_pad_piece_);
    }
  }

  if ((*(explicit + 23) & 0x8000000000000000) != 0)
  {
    if (*(explicit + 8))
    {
      goto LABEL_9;
    }

    return "<pad>";
  }

  if (!*(explicit + 23))
  {
    return "<pad>";
  }

LABEL_9:
  v5 = *(*(this + 1) + 72);
  if (!v5)
  {
    v5 = &sentencepiece::_TrainerSpec_default_instance_;
  }

  v6 = v5[26];
  if (v6)
  {
    result = (v6 & 0xFFFFFFFFFFFFFFFELL);
  }

  else
  {
    result = atomic_load_explicit(&qword_1EB907FD0, memory_order_acquire);
    if (!result)
    {
      result = google::protobuf::internal::LazyString::Init(&sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_pad_piece_);
    }
  }

  if (result[23] < 0)
  {
    return *result;
  }

  return result;
}

uint64_t sentencepiece::ModelInterface::PieceToId(uint64_t a1, char *a2, char *a3)
{
  v8[0] = a2;
  v8[1] = a3;
  v4 = std::__hash_table<std::__hash_value_type<absl::string_view,int>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,int>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,int>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,int>>>::find<absl::string_view>((a1 + 64), v8);
  if (v4)
  {
    v5 = (v4 + 4);
  }

  else
  {
    v6 = std::__hash_table<std::__hash_value_type<absl::string_view,int>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,int>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,int>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,int>>>::find<absl::string_view>((a1 + 24), v8);
    v5 = (v6 + 4);
    if (!v6)
    {
      v5 = (a1 + 104);
    }
  }

  return *v5;
}

void sentencepiece::ModelInterface::InitializePieces(sentencepiece::ModelInterface *this)
{
  v2 = this + 24;
  std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::clear(this + 3);
  std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::clear(this + 8);
  *(this + 26) = -1;
  v42[0] = 0;
  v42[1] = 0;
  v41 = v42;
  LOBYTE(v43[0]) = 0;
  std::vector<BOOL>::vector(&__p, 256);
  v3 = *(this + 1);
  if (*(v3 + 56) < 1)
  {
LABEL_38:
    if (*(this + 26) == -1)
    {
      sentencepiece::util::Status::Status(v43, 13, "unk is not defined.");
      sentencepiece::util::Status::operator=(this + 14, v43);
    }

    else
    {
      v25 = *(v3 + 72);
      if (!v25)
      {
        v25 = &sentencepiece::_TrainerSpec_default_instance_;
      }

      if (v25[239] != 1 || (v43[0] = __p, LODWORD(v43[1]) = 0, std::__find_BOOL[abi:ne200100]<false,std::vector<BOOL>,false>(v43, v40, &v37), v37.__r_.__value_.__l.__data_ == __p + 8 * (v40 >> 6)) && LODWORD(v37.__r_.__value_.__r.__words[1]) == (v40 & 0x3F))
      {
        absl::make_unique<sentencepiece::normalizer::PrefixMatcher,std::set<absl::string_view> &>();
      }

      sentencepiece::util::Status::operator=(this + 14, v43);
    }

LABEL_64:
    sentencepiece::util::Status::~Status(v43);
  }

  else
  {
    v4 = 0;
    while (1)
    {
      v5 = *(*(v3 + 64) + 8 * v4 + 8);
      v6 = (*(v5 + 48) & 0xFFFFFFFFFFFFFFFELL);
      v7 = *(v6 + 23);
      if ((v7 & 0x8000000000000000) != 0)
      {
        if (!v6[1])
        {
LABEL_46:
          sentencepiece::util::Status::Status(v43, 13, "piece must not be empty.");
          sentencepiece::util::Status::operator=(this + 14, v43);
          goto LABEL_64;
        }
      }

      else if (!*(v6 + 23))
      {
        goto LABEL_46;
      }

      v8 = *(v5 + 60);
      v9 = v8 > 5;
      v10 = (1 << v8) & 0x32;
      if (v9 || v10 == 0)
      {
        v12 = (this + 64);
      }

      else
      {
        v12 = v2;
      }

      v13 = v6[1];
      if ((v7 & 0x80000000) != 0)
      {
        v6 = *v6;
        v7 = v13;
      }

      v43[0] = v6;
      v43[1] = v7;
      LODWORD(v44) = v4;
      std::__hash_table<std::__hash_value_type<absl::string_view,int>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,int>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,int>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,int>>>::__emplace_unique_key_args<absl::string_view,std::pair<absl::string_view const,int> const&>(v12, v43);
      if ((v14 & 1) == 0)
      {
        break;
      }

      v15 = *(v5 + 60);
      if (v15 == 4)
      {
        v16 = (*(v5 + 48) & 0xFFFFFFFFFFFFFFFELL);
        v17 = *(v16 + 23);
        v18 = v16[1];
        if (v17 < 0)
        {
          v16 = *v16;
        }

        if (v17 < 0)
        {
          v17 = v18;
        }

        v43[0] = v16;
        v43[1] = v17;
        std::__tree<absl::string_view>::__emplace_unique_key_args<absl::string_view,absl::string_view>(&v41, v43);
        v15 = *(v5 + 60);
      }

      if (v15 == 6)
      {
        v19 = *(*(this + 1) + 72);
        if (!v19)
        {
          v19 = &sentencepiece::_TrainerSpec_default_instance_;
        }

        if ((v19[239] & 1) == 0)
        {
          std::operator+<char>();
          v33 = *&v32->__r_.__value_.__l.__data_;
          v44 = v32->__r_.__value_.__r.__words[2];
          *v43 = v33;
          v32->__r_.__value_.__l.__size_ = 0;
          v32->__r_.__value_.__r.__words[2] = 0;
          v32->__r_.__value_.__r.__words[0] = 0;
          if (v44 >= 0)
          {
            v34 = v43;
          }

          else
          {
            v34 = v43[0];
          }

LABEL_74:
          sentencepiece::util::Status::Status(&v38, 13, v34);
          sentencepiece::util::Status::operator=(this + 14, &v38);
          sentencepiece::util::Status::~Status(&v38);
          if (SHIBYTE(v44) < 0)
          {
            operator delete(v43[0]);
          }

          if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
          {
            v31 = v37.__r_.__value_.__r.__words[0];
            goto LABEL_78;
          }

          goto LABEL_65;
        }

        v20 = *(v5 + 48) & 0xFFFFFFFFFFFFFFFELL;
        v21 = *(v20 + 23);
        if (v21 >= 0)
        {
          v22 = (*(v5 + 48) & 0xFFFFFFFFFFFFFFFELL);
        }

        else
        {
          v22 = *v20;
        }

        if (v21 >= 0)
        {
          v23 = *(v20 + 23);
        }

        else
        {
          v23 = *(v20 + 8);
        }

        v24 = sentencepiece::PieceToByte(v22, v23);
        if ((v24 & 0x80000000) != 0)
        {
          std::operator+<char>();
          v35 = std::string::append(&v37, " is invalid.");
          v36 = *&v35->__r_.__value_.__l.__data_;
          v44 = v35->__r_.__value_.__r.__words[2];
          *v43 = v36;
          v35->__r_.__value_.__l.__size_ = 0;
          v35->__r_.__value_.__r.__words[2] = 0;
          v35->__r_.__value_.__r.__words[0] = 0;
          if (v44 >= 0)
          {
            v34 = v43;
          }

          else
          {
            v34 = v43[0];
          }

          goto LABEL_74;
        }

        *(__p + ((v24 >> 3) & 0x1FFFFFF8)) |= 1 << v24;
      }

      else if (v15 == 2)
      {
        if ((*(this + 26) & 0x80000000) == 0)
        {
          sentencepiece::util::Status::Status(v43, 13, "unk is already defined.");
          sentencepiece::util::Status::operator=(this + 14, v43);
          goto LABEL_64;
        }

        *(this + 26) = v4;
      }

      ++v4;
      v3 = *(this + 1);
      if (v4 >= *(v3 + 56))
      {
        goto LABEL_38;
      }
    }

    v26 = *(v5 + 48) & 0xFFFFFFFFFFFFFFFELL;
    if (*(v26 + 23) >= 0)
    {
      v27 = *(v26 + 23);
    }

    else
    {
      v27 = *(v26 + 8);
    }

    v28 = v43;
    std::string::basic_string[abi:ne200100](v43, v27 + 20);
    if (v44 < 0)
    {
      v28 = v43[0];
    }

    if (v27)
    {
      if (*(v26 + 23) >= 0)
      {
        v29 = v26;
      }

      else
      {
        v29 = *v26;
      }

      memmove(v28, v29, v27);
    }

    strcpy(v28 + v27, " is already defined.");
    if (v44 >= 0)
    {
      v30 = v43;
    }

    else
    {
      v30 = v43[0];
    }

    sentencepiece::util::Status::Status(&v37, 13, v30);
    sentencepiece::util::Status::operator=(this + 14, &v37);
    sentencepiece::util::Status::~Status(&v37);
    if (SHIBYTE(v44) < 0)
    {
      v31 = v43[0];
LABEL_78:
      operator delete(v31);
    }
  }

LABEL_65:
  if (__p)
  {
    operator delete(__p);
  }

  std::__tree<int>::destroy(&v41, v42[0]);
}

void sub_1B5AAAE64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, uint64_t a18, char a19, void *a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  sentencepiece::util::Status::~Status(&a15);
  if (a27 < 0)
  {
    operator delete(__p);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  if (a16)
  {
    operator delete(a16);
  }

  std::__tree<int>::destroy(&a19, a20);
  _Unwind_Resume(a1);
}

uint64_t sentencepiece::PieceToByte(void *__src, size_t __len)
{
  {
    sentencepiece::PieceToByte(absl::string_view)::$_0::operator()();
  }

  v4 = sentencepiece::PieceToByte(absl::string_view)::kMap;
  if (__src)
  {
    std::string::basic_string[abi:ne200100](__p, __src, __len);
  }

  else
  {
    __p[0] = 0;
    __p[1] = 0;
    v9 = 0;
  }

  v5 = std::__hash_table<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::variant<kaldi::quasar::ShortlistDataInManyFiles::NotLoadedShortListDataOnDisk,std::shared_ptr<kaldi::quasar::ShortlistDataOnDisk>>>>>::find<std::string>(v4, __p);
  v6 = v5;
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
    if (v6)
    {
      return *(v6 + 40);
    }
  }

  else if (v5)
  {
    return *(v6 + 40);
  }

  return 0xFFFFFFFFLL;
}

void sentencepiece::SplitIntoWords(char *__s1@<X0>, uint64_t a2@<X1>, char a3@<W2>, int a4@<W3>, const void **a5@<X8>)
{
  v8 = &__s1[a2];
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  if ((a3 & 1) == 0)
  {
    if (a2 < 1)
    {
      return;
    }

    v9 = 0;
    v10 = 0;
    v11 = __s1;
    while (1)
    {
      v12 = asc_1B5C6FEAB[*v11 >> 4];
      if (v8 - v11 < v12)
      {
        v12 = v8 - v11;
      }

      v13 = v12;
      if (v12 == 3)
      {
        v14 = v11 == "" || memcmp(v11, "", 3uLL) == 0;
        if (v11 == __s1)
        {
          goto LABEL_19;
        }

        if ((v10 & a4 & 1) == 0 && ((v14 ^ 1) & 1) == 0)
        {
          v14 = 1;
LABEL_19:
          v15 = a5[2];
          if (v9 >= v15)
          {
            v16 = *a5;
            v17 = v9 - *a5;
            v18 = v17 >> 4;
            v19 = (v17 >> 4) + 1;
            if (v19 >> 60)
            {
              std::vector<int>::__throw_length_error[abi:ne200100]();
            }

            v20 = v15 - v16;
            if (v20 >> 3 > v19)
            {
              v19 = v20 >> 3;
            }

            v21 = v20 >= 0x7FFFFFFFFFFFFFF0;
            v22 = 0xFFFFFFFFFFFFFFFLL;
            if (!v21)
            {
              v22 = v19;
            }

            if (v22)
            {
              std::__allocate_at_least[abi:ne200100]<std::allocator<std::string_view>>(a5, v22);
            }

            v23 = (16 * v18);
            *v23 = v11;
            v23[1] = 0;
            v9 = (16 * v18 + 16);
            memcpy(0, v16, v17);
            v24 = *a5;
            *a5 = 0;
            a5[1] = v9;
            a5[2] = 0;
            if (v24)
            {
              operator delete(v24);
            }
          }

          else
          {
            *v9 = v11;
            v9[1] = 0;
            v9 += 2;
          }

          a5[1] = v9;
          goto LABEL_33;
        }

        if (v10)
        {
          v14 &= v10;
          goto LABEL_33;
        }
      }

      else if (v11 == __s1)
      {
        v14 = 0;
        goto LABEL_19;
      }

      v14 = 0;
LABEL_33:
      *(v9 - 1) += v13;
      v11 += v13;
      v10 = v14;
      if (v11 >= v8)
      {
        return;
      }
    }
  }

  if (a2 >= 1)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<std::string_view>>(a5, 1uLL);
  }
}

void sub_1B5AAB4F0(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1B5AAB618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

const void **std::__hash_table<std::__hash_value_type<std::string,unsigned char>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned char>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned char>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned char>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(void *a1, const void **a2)
{
  v4 = std::__string_hash<char>::operator()[abi:ne200100](a1, a2);
  v5 = v4;
  v6 = a1[1];
  if (!*&v6)
  {
    goto LABEL_18;
  }

  v7 = vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v6)
    {
      v9 = v4 % *&v6;
    }
  }

  else
  {
    v9 = (*&v6 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= *&v6)
      {
        v12 %= *&v6;
      }
    }

    else
    {
      v12 &= *&v6 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_18;
    }

LABEL_17:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_18;
    }
  }

  if (!std::equal_to<std::string>::operator()[abi:ne200100](a1, v11 + 2, a2))
  {
    goto LABEL_17;
  }

  return v11;
}

void *std::__hash_table<std::__hash_value_type<absl::string_view,int>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,int>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,int>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,int>>>::__emplace_unique_key_args<absl::string_view,std::pair<absl::string_view const,int> const&>(void *a1, char **a2)
{
  v4 = a2[1];
  if (v4)
  {
    v5 = *a2;
    v6 = 5381;
    do
    {
      v7 = *v5++;
      v6 = 33 * v6 + v7;
      --v4;
    }

    while (v4);
  }

  else
  {
    v6 = 5381;
  }

  v8 = a1[1];
  if (!*&v8)
  {
    goto LABEL_23;
  }

  v9 = vcnt_s8(v8);
  v9.i16[0] = vaddlv_u8(v9);
  v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    v11 = v6;
    if (v6 >= *&v8)
    {
      v11 = v6 % *&v8;
    }
  }

  else
  {
    v11 = (*&v8 - 1) & v6;
  }

  v12 = *(*a1 + 8 * v11);
  if (!v12 || (v13 = *v12) == 0)
  {
LABEL_23:
    operator new();
  }

  while (1)
  {
    v14 = v13[1];
    if (v14 == v6)
    {
      break;
    }

    if (v10 > 1)
    {
      if (v14 >= *&v8)
      {
        v14 %= *&v8;
      }
    }

    else
    {
      v14 &= *&v8 - 1;
    }

    if (v14 != v11)
    {
      goto LABEL_23;
    }

LABEL_22:
    v13 = *v13;
    if (!v13)
    {
      goto LABEL_23;
    }
  }

  if (!std::equal_to<absl::string_view>::operator()[abi:ne200100](a1, (v13 + 2), a2))
  {
    goto LABEL_22;
  }

  return v13;
}

uint64_t std::__tree<absl::string_view>::__emplace_unique_key_args<absl::string_view,absl::string_view>(uint64_t a1, uint64_t a2)
{
  v2 = *std::__tree<absl::string_view>::__find_equal<absl::string_view>(a1, &v4, a2);
  if (!v2)
  {
    operator new();
  }

  return v2;
}

void *std::__tree<absl::string_view>::__find_equal<absl::string_view>(uint64_t a1, void *a2, uint64_t a3)
{
  v5 = (a1 + 8);
  v4 = *(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v8 = v4;
        if (!std::less<absl::string_view>::operator()[abi:ne200100](a1, a3, (v4 + 4)))
        {
          break;
        }

        v4 = *v8;
        v5 = v8;
        if (!*v8)
        {
          goto LABEL_9;
        }
      }

      if (!std::less<absl::string_view>::operator()[abi:ne200100](a1, (v8 + 4), a3))
      {
        break;
      }

      v5 = v8 + 1;
      v4 = v8[1];
    }

    while (v4);
  }

  else
  {
    v8 = (a1 + 8);
  }

LABEL_9:
  *a2 = v8;
  return v5;
}

BOOL std::less<absl::string_view>::operator()[abi:ne200100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a2 + 8);
  v5 = *(a3 + 8);
  if (v5 >= v4)
  {
    v6 = *(a2 + 8);
  }

  else
  {
    v6 = *(a3 + 8);
  }

  if (!v6)
  {
    return v4 < v5;
  }

  v7 = memcmp(*a2, *a3, v6);
  if (v7 < 0)
  {
    return 1;
  }

  return !v7 && v4 < v5;
}

uint64_t std::__find_BOOL[abi:ne200100]<false,std::vector<BOOL>,false>@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v3 = *(result + 8);
  v4 = *result;
  if (!v3)
  {
    goto LABEL_9;
  }

  v5 = (64 - v3);
  if (v5 >= a2)
  {
    v6 = a2;
  }

  else
  {
    v6 = (64 - v3);
  }

  if (((0xFFFFFFFFFFFFFFFFLL >> (64 - v3 - v6)) & (-1 << v3) & ~*v4) != 0)
  {
    v7 = __rbit64((0xFFFFFFFFFFFFFFFFLL >> (64 - v3 - v6)) & (-1 << v3) & ~*v4);
LABEL_17:
    *a3 = v4;
    *(a3 + 8) = __clz(v7);
    return result;
  }

  if (v5 < a2)
  {
    a2 -= v6;
    *result = ++v4;
LABEL_9:
    if (a2 < 0x40)
    {
LABEL_12:
      if (!a2 || (v8 = (0xFFFFFFFFFFFFFFFFLL >> -a2) & ~*v4) == 0)
      {
        *a3 = v4;
        *(a3 + 8) = a2;
        return result;
      }
    }

    else
    {
      while (*v4 == -1)
      {
        *result = ++v4;
        a2 -= 64;
        if (a2 <= 0x3F)
        {
          goto LABEL_12;
        }
      }

      v8 = ~*v4;
    }

    v7 = __rbit64(v8);
    goto LABEL_17;
  }

  *a3 = &v4[(v3 + a2) >> 6];
  *(a3 + 8) = (v3 + a2) & 0x3F;
  return result;
}

uint64_t absl::StrFormatV@<X0>(absl *this@<X0>, va_list a2@<X1>, uint64_t a3@<X8>)
{
  v6 = vsnprintf(0, 0, this, a2);
  *a3 = 0;
  *(a3 + 8) = 0;
  *(a3 + 16) = 0;
  std::string::resize(a3, v6, 0);
  v7 = *(a3 + 23);
  if ((v7 & 0x80u) == 0)
  {
    v8 = a3;
  }

  else
  {
    v8 = *a3;
  }

  if ((v7 & 0x80u) != 0)
  {
    v7 = *(a3 + 8);
  }

  return vsnprintf(v8, v7 + 1, this, a2);
}

void sub_1B5AABE28(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

sentencepiece::normalizer::Normalizer *sentencepiece::normalizer::Normalizer::Normalizer(sentencepiece::normalizer::Normalizer *this, const sentencepiece::NormalizerSpec *a2, const sentencepiece::TrainerSpec *a3)
{
  *(this + 1) = 0;
  *this = &unk_1F2D43C58;
  *(this + 2) = 0;
  *(this + 3) = a2;
  *(this + 4) = 0;
  *(this + 40) = *(a3 + 236);
  marisa::Trie::Trie(this + 6);
  sentencepiece::normalizer::Normalizer::Init(this);
  return this;
}

void sub_1B5AABEE0(_Unwind_Exception *a1)
{
  sentencepiece::util::Status::~Status((v1 + 48));
  v4 = *v2;
  *v2 = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  _Unwind_Resume(a1);
}

void sentencepiece::normalizer::Normalizer::Init(sentencepiece::normalizer::Normalizer *this)
{
  v1 = *(*(this + 3) + 56) & 0xFFFFFFFFFFFFFFFELL;
  v2 = *(v1 + 23);
  if (v2 >= 0)
  {
    v3 = *(v1 + 23);
  }

  else
  {
    v3 = *(v1 + 8);
  }

  if (v3)
  {
    if (v2 >= 0)
    {
      v5 = (*(*(this + 3) + 56) & 0xFFFFFFFFFFFFFFFELL);
    }

    else
    {
      v5 = *v1;
    }

    v15[0] = 0;
    v15[1] = 0;
    v14[0] = 0;
    v14[1] = 0;
    sentencepiece::normalizer::Normalizer::DecodePrecompiledCharsMap(v5, v3, v15, v14, &v13);
    sentencepiece::util::Status::operator=(this + 6, &v13);
    sentencepiece::util::Status::~Status(&v13);
    if (!*(this + 6))
    {
      operator new();
    }
  }

  else if (sentencepiece::logging::GetMinLogLevel(this) <= 0)
  {
    LOBYTE(v15[0]) = 0;
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "normalizer.cc", 13);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, "(", 1);
    v8 = MEMORY[0x1B8C84C00](v7, 51);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, ") ", 2);
    v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "LOG(", 4);
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, "INFO", 4);
    v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, ") ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, "precompiled_charsmap is empty. use identity normalization.", 58);
    sentencepiece::error::Die::~Die(v15);
  }
}

void sub_1B5AAC104(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::Status::~Status(va);
  _Unwind_Resume(a1);
}

sentencepiece::normalizer::Normalizer *sentencepiece::normalizer::Normalizer::Normalizer(sentencepiece::normalizer::Normalizer *this, const sentencepiece::NormalizerSpec *a2)
{
  *this = &unk_1F2D43C58;
  *(this + 1) = 0;
  *(this + 2) = 0;
  *(this + 3) = a2;
  *(this + 4) = 0;
  *(this + 40) = 0;
  marisa::Trie::Trie(this + 6);
  sentencepiece::normalizer::Normalizer::Init(this);
  return this;
}

void sub_1B5AAC198(_Unwind_Exception *a1)
{
  sentencepiece::util::Status::~Status((v1 + 48));
  v4 = *v2;
  *v2 = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  _Unwind_Resume(a1);
}

void sentencepiece::normalizer::Normalizer::~Normalizer(sentencepiece::normalizer::Normalizer *this)
{
  *this = &unk_1F2D43C58;
  sentencepiece::util::Status::~Status((this + 48));
  v2 = *(this + 1);
  *(this + 1) = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }
}

{
  sentencepiece::normalizer::Normalizer::~Normalizer(this);

  JUMPOUT(0x1B8C85350);
}

void *sentencepiece::normalizer::Normalizer::DecodePrecompiledCharsMap@<X0>(unsigned int *a1@<X0>, unint64_t a2@<X1>, void *a3@<X2>, void *a4@<X3>, void *a5@<X8>)
{
  v13 = 0;
  if (a2 > 4)
  {
    v14 = &v13;
    sentencepiece::error::CheckNotNull<unsigned int *&>("util.h", 105, "'result' Must be non NULL", &v14);
    *v14 = *a1;
    v11 = v13;
    v12 = a2 - v13;
    if (a2 <= v13)
    {
      return sentencepiece::util::Status::Status(a5, 13, "Trie data size exceeds the input blob size.");
    }

    else
    {
      *a3 = a1 + 1;
      a3[1] = v11;
      *a4 = a1 + v11 + 4;
      a4[1] = v12 - 4;
      return marisa::Trie::Trie(a5);
    }
  }

  else
  {

    return sentencepiece::util::Status::Status(a5, 13, "Blob for normalization rule is broken.");
  }
}

void *sentencepiece::normalizer::Normalizer::Normalize@<X0>(uint64_t a1@<X0>, sentencepiece::string_util *a2@<X1>, unint64_t a3@<X2>, std::string *a4@<X3>, const void **a5@<X4>, sentencepiece::util::Status *a6@<X8>)
{
  v8 = a3;
  a5[1] = *a5;
  if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0)
  {
    *a4->__r_.__value_.__l.__data_ = 0;
    a4->__r_.__value_.__l.__size_ = 0;
    if (!a3)
    {
LABEL_12:

      return marisa::Trie::Trie(a6);
    }
  }

  else
  {
    a4->__r_.__value_.__s.__data_[0] = 0;
    *(&a4->__r_.__value_.__s + 23) = 0;
    if (!a3)
    {
      goto LABEL_12;
    }
  }

  result = (*(*a1 + 24))(a1);
  if (*a6)
  {
    return result;
  }

  sentencepiece::util::Status::~Status(a6);
  if (*(*(a1 + 24) + 73) == 1)
  {
    LODWORD(v14) = 0;
    while (1)
    {
      sentencepiece::normalizer::Normalizer::NormalizePrefix(a2, a1, v8, v13, &v46);
      if (v47 != 1 || v46 != " " && *v46 != 32)
      {
        break;
      }

      a2 = (a2 + v48);
      LODWORD(v14) = v48 + v14;
      v8 -= v48;
      if (!v8)
      {
        goto LABEL_12;
      }
    }

    v45 = a6;
  }

  else
  {
    v45 = a6;
    LODWORD(v14) = 0;
  }

  std::string::reserve(a4, 3 * v8);
  std::vector<std::pair<int,int>>::reserve(a5, 3 * v8);
  if ((*(a1 + 40) & 1) == 0)
  {
    v16 = *(a1 + 24);
    if (*(v16 + 72) == 1)
    {
      if (*(v16 + 74) == 1)
      {
        v17 = 3;
        std::string::append(a4, "", 3uLL);
        do
        {
          v46 = v14;
          std::vector<long long>::push_back[abi:ne200100](a5, &v46);
          --v17;
        }

        while (v17);
      }

      else
      {
        std::string::append(a4, " ");
        v46 = v14;
        std::vector<long long>::push_back[abi:ne200100](a5, &v46);
      }
    }
  }

  v18 = *(*(a1 + 24) + 73);
  do
  {
    sentencepiece::normalizer::Normalizer::NormalizePrefix(a2, a1, v8, v15, &v46);
    v19 = v46;
    v20 = v47;
    if (v18)
    {
      if (!v47)
      {
        goto LABEL_41;
      }

      while (*v19 == 32)
      {
        ++v19;
        if (!--v20)
        {
          goto LABEL_41;
        }
      }
    }

    else if (!v47)
    {
      v18 = 0;
      goto LABEL_41;
    }

    v21 = 0;
    do
    {
      v22 = v19[v21];
      if (*(*(a1 + 24) + 74) == 1 && v22 == 32)
      {
        std::string::append(a4, "", 3uLL);
        v23 = 3;
        do
        {
          v52[0] = v14;
          std::vector<long long>::push_back[abi:ne200100](a5, v52);
          --v23;
        }

        while (v23);
      }

      else
      {
        std::string::push_back(a4, v22);
        v52[0] = v14;
        std::vector<long long>::push_back[abi:ne200100](a5, v52);
      }

      ++v21;
    }

    while (v21 != v20);
    v18 = v19[v20 - 1] == 32;
LABEL_41:
    LODWORD(v14) = v48 + v14;
    a2 = (a2 + v48);
    v24 = *(a1 + 24);
    v18 &= *(v24 + 73);
    v8 -= v48;
  }

  while (v8);
  if (!*(v24 + 73))
  {
    goto LABEL_70;
  }

  v25 = *(v24 + 74) ? 3 : 1;
  v26 = *(v24 + 74) ? "" : " ";
  v27 = SHIBYTE(a4->__r_.__value_.__r.__words[2]);
  size = a4->__r_.__value_.__l.__size_;
  v29 = (v27 & 0x80000000) == 0 ? SHIBYTE(a4->__r_.__value_.__r.__words[2]) : a4->__r_.__value_.__l.__size_;
  v30 = v29 >= v25;
  v31 = v29 - v25;
  if (!v30)
  {
    goto LABEL_70;
  }

  v32 = a4->__r_.__value_.__r.__words[0];
  if ((v27 & 0x80000000) == 0)
  {
    v32 = a4;
  }

  if (!memcmp(v32 + v31, v26, v25))
  {
    v33 = v27 >> 63;
    while (1)
    {
      v34 = (v33 & 1) != 0 ? size : v27;
      v35 = v34 - v25;
      if (v35 < 0)
      {
        break;
      }

      v36 = v35 & 0x7FFFFFFF;
      v14 = *(*a5 + v36);
      std::string::resize(a4, v36, 0);
      std::vector<double>::resize(a5, v36);
      v27 = SHIBYTE(a4->__r_.__value_.__r.__words[2]);
      size = a4->__r_.__value_.__l.__size_;
      if ((v27 & 0x80000000) == 0)
      {
        v37 = SHIBYTE(a4->__r_.__value_.__r.__words[2]);
      }

      else
      {
        v37 = a4->__r_.__value_.__l.__size_;
      }

      v30 = v37 >= v25;
      v38 = v37 - v25;
      if (v30)
      {
        v33 = v27 >> 63;
        v39 = a4->__r_.__value_.__r.__words[0];
        if ((v27 & 0x80000000) == 0)
        {
          v39 = a4;
        }

        if (!memcmp(v39 + v38, v26, v25))
        {
          continue;
        }
      }

      goto LABEL_70;
    }

    LODWORD(v46) = 13;
    v44 = std::ostringstream::basic_ostringstream[abi:ne200100](&v47);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v44, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/normalizer.cc", 110);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v47, "(", 1);
    MEMORY[0x1B8C84C00](&v47, 174);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v47, ") [", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v47, "(length) >= (0)", 15);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v47, "] ", 2);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v46, v45);
LABEL_82:
    v47 = *MEMORY[0x1E69E54E8];
    *(&v47 + *(v47 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
    v48 = MEMORY[0x1E69E5548] + 16;
    if (v50 < 0)
    {
      operator delete(v49[7].__locale_);
    }

    v48 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v49);
    std::ostream::~ostream();
    return MEMORY[0x1B8C85200](&v51);
  }

  else
  {
LABEL_70:
    if (*(a1 + 40) == 1)
    {
      v40 = *(a1 + 24);
      if (*(v40 + 72) == 1)
      {
        if (*(v40 + 74) == 1)
        {
          v41 = 3;
          std::string::append(a4, "", 3uLL);
          do
          {
            v46 = v14;
            std::vector<long long>::push_back[abi:ne200100](a5, &v46);
            --v41;
          }

          while (v41);
        }

        else
        {
          std::string::append(a4, " ");
          v46 = v14;
          std::vector<long long>::push_back[abi:ne200100](a5, &v46);
        }
      }
    }

    v46 = v14;
    std::vector<long long>::push_back[abi:ne200100](a5, &v46);
    v42 = SHIBYTE(a4->__r_.__value_.__r.__words[2]);
    if ((v42 & 0x8000000000000000) != 0)
    {
      v42 = a4->__r_.__value_.__l.__size_;
    }

    if ((a5[1] - *a5) >> 3 != v42 + 1)
    {
      LODWORD(v46) = 13;
      v43 = std::ostringstream::basic_ostringstream[abi:ne200100](&v47);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v43, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/normalizer.cc", 110);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v47, "(", 1);
      MEMORY[0x1B8C84C00](&v47, 186);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v47, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v47, "(norm_to_orig->size()) == (normalized->size() + 1)", 50);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v47, "] ", 2);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v46, v45);
      goto LABEL_82;
    }

    return marisa::Trie::Trie(v45);
  }
}

void sub_1B5AACA8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sentencepiece::util::StatusBuilder::~StatusBuilder(va);
  _Unwind_Resume(a1);
}

uint64_t sentencepiece::normalizer::Normalizer::NormalizePrefix@<X0>(sentencepiece::string_util *this@<X1>, uint64_t result@<X0>, unint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  v30[63] = *MEMORY[0x1E69E9840];
  if (a3)
  {
    v7 = this;
    v8 = result;
    v9 = *(result + 32);
    if (v9 && (v29[0] = 0, result = sentencepiece::normalizer::PrefixMatcher::PrefixMatch(v9, this, a3, v29), v29[0] == 1))
    {
      v10 = result;
      if (a3 < result)
      {
        v10 = a3;
      }

      *a5 = v7;
      *(a5 + 8) = v10;
      *(a5 + 16) = result;
    }

    else
    {
      v11 = *(v8 + 8);
      if (!v11)
      {
        goto LABEL_25;
      }

      v12 = 0;
      v13 = 0;
      v14 = *(v11 + 16);
      v15 = (*v14 >> 10 << ((*v14 >> 6) & 8));
      do
      {
        v16 = v7[v12];
        v17 = v15 ^ v16;
        v18 = v14[v17];
        if ((v18 & 0x800000FF) != v16)
        {
          break;
        }

        v15 = v17 ^ (v18 >> 10 << ((v18 >> 6) & 8));
        if ((v18 & 0x100) != 0)
        {
          if (v13 <= 0x1F)
          {
            v19 = &v29[16 * v13];
            *v19 = v14[v15] & 0x7FFFFFFF;
            *(v19 + 1) = v12 + 1;
          }

          ++v13;
        }

        ++v12;
      }

      while (a3 != v12);
      if (!v13)
      {
        goto LABEL_25;
      }

      v20 = 0;
      v21 = 0;
      v22 = v30;
      v23 = v30;
      do
      {
        v25 = *v23;
        v23 += 2;
        v24 = v25;
        if (!v20 || v24 > v20)
        {
          v21 = *(v22 - 2);
          v20 = v24;
        }

        v22 = v23;
        --v13;
      }

      while (v13);
      if (v20)
      {
        v26 = *(v8 + 16);
        if (v26)
        {
          v7 = (v26 + v21);
          result = strlen(v7);
        }

        else
        {
          result = 0;
          v7 = 0;
        }
      }

      else
      {
LABEL_25:
        *v29 = 0;
        v27 = sentencepiece::string_util::DecodeUTF8(v7, &v7[a3], v29, a4);
        v28 = v27 != 65533;
        if (v27 == 65533)
        {
          result = 3;
        }

        else
        {
          result = *v29;
        }

        if (*v29 == 3)
        {
          v28 = 1;
        }

        if (v28)
        {
          LODWORD(v20) = *v29;
        }

        else
        {
          LODWORD(v20) = 1;
        }

        if (!v28)
        {
          v7 = &sentencepiece::normalizer::Normalizer::NormalizePrefix(absl::string_view)const::kReplacementChar;
        }
      }

      *a5 = v7;
      *(a5 + 8) = result;
      *(a5 + 16) = v20;
    }
  }

  else
  {
    *a5 = 0;
    *(a5 + 8) = 0;
    *(a5 + 16) = 0;
  }

  return result;
}

void sentencepiece::normalizer::Normalizer::Normalize(uint64_t a1@<X0>, void *a2@<X8>)
{
  __p = 0;
  v4 = 0;
  v5 = 0;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  (*(*a1 + 32))(&v2);
  quasar::Bitmap::~Bitmap(&v2);
  sentencepiece::util::Status::~Status(&v2);
  if (__p)
  {
    v4 = __p;
    operator delete(__p);
  }
}

void sub_1B5AACD3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  sentencepiece::util::Status::~Status(&a9);
  if (*(v11 + 23) < 0)
  {
    operator delete(*v11);
  }

  if (__p)
  {
    a11 = __p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sentencepiece::normalizer::PrefixMatcher::PrefixMatch(uint64_t a1, _BYTE *a2, uint64_t a3, BOOL *a4)
{
  v24[127] = *MEMORY[0x1E69E9840];
  if (!*a1)
  {
    if (a4)
    {
      *a4 = 0;
    }

    goto LABEL_33;
  }

  v4 = *(*a1 + 16);
  v5 = (*v4 >> 10 << ((*v4 >> 6) & 8));
  if (a3)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = a2[v6];
      v9 = v5 ^ v8;
      v10 = v4[v9];
      if ((v10 & 0x800000FF) != v8)
      {
        break;
      }

      v5 = v9 ^ (v10 >> 10 << ((v10 >> 6) & 8));
      if ((v10 & 0x100) != 0)
      {
        if (v7 <= 0x3F)
        {
          v11 = &v23[16 * v7];
          *v11 = v4[v5] & 0x7FFFFFFF;
          *(v11 + 1) = v6 + 1;
        }

        ++v7;
      }

      ++v6;
    }

    while (a3 != v6);
  }

  else
  {
    v12 = *a2;
    if (*a2)
    {
      v7 = 0;
      v13 = 1;
      do
      {
        v14 = v5 ^ v12;
        v15 = v4[v14];
        if ((v15 & 0x800000FF) != v12)
        {
          break;
        }

        v5 = v14 ^ (v15 >> 10 << ((v15 >> 6) & 8));
        if ((v15 & 0x100) != 0)
        {
          if (v7 <= 0x3F)
          {
            v16 = &v23[16 * v7];
            *v16 = v4[v5] & 0x7FFFFFFF;
            *(v16 + 1) = v13;
          }

          ++v7;
        }

        v12 = a2[v13++];
      }

      while (v12);
    }

    else
    {
      LODWORD(v7) = 0;
    }
  }

  if (a4)
  {
    *a4 = v7 > 0;
  }

  if (!v7)
  {
LABEL_33:
    v22 = asc_1B5C6FEAB[*a2 >> 4];
    if (v22 >= a3)
    {
      return a3;
    }

    else
    {
      return v22;
    }
  }

  if (v7 < 1)
  {
    return 0;
  }

  LODWORD(result) = 0;
  v18 = v7 & 0x7FFFFFFF;
  v19 = v24;
  do
  {
    v21 = *v19;
    v19 += 4;
    v20 = v21;
    if (result <= v21)
    {
      result = v20;
    }

    else
    {
      result = result;
    }

    --v18;
  }

  while (v18);
  return result;
}

void *sentencepiece::normalizer::PrefixMatcher::PrefixMatcher(void *result, void *a2)
{
  *result = 0;
  v3 = a2[2];
  if (v3)
  {
    memset(__p, 0, sizeof(__p));
    std::vector<wchar_t const*>::reserve(__p, v3);
    v6 = *a2;
    v4 = a2 + 1;
    v5 = v6;
    if (v6 != v4)
    {
      do
      {
        v10 = v5[4];
        std::vector<char const*>::push_back[abi:ne200100](__p, &v10);
        v7 = v5[1];
        if (v7)
        {
          do
          {
            v8 = v7;
            v7 = *v7;
          }

          while (v7);
        }

        else
        {
          do
          {
            v8 = v5[2];
            v9 = *v8 == v5;
            v5 = v8;
          }

          while (!v9);
        }

        v5 = v8;
      }

      while (v8 != v4);
    }

    operator new();
  }

  return result;
}

void sub_1B5AAD104(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    operator delete(__p);
  }

  v13 = *v11;
  *v11 = 0;
  if (v13)
  {
    (*(*v13 + 8))(v13);
  }

  _Unwind_Resume(exception_object);
}

void Darts::DoubleArrayImpl<void,void,int,void>::build(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, void (*a6)(unint64_t, uint64_t))
{
  v12[0] = a2;
  v12[1] = a3;
  v12[2] = a4;
  v12[3] = a5;
  v6 = a6;
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0;
  Darts::Details::DoubleArrayBuilder::build<int>(&v6, v12);
}

void *Darts::DoubleArrayImpl<void,void,int,void>::~DoubleArrayImpl(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2D43CA8;
  v2 = a1[3];
  if (v2)
  {
    MEMORY[0x1B8C85310](v2, 0x1000C8052888210);
    a1[3] = 0;
  }

  return a1;
}

void Darts::DoubleArrayImpl<void,void,int,void>::~DoubleArrayImpl(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2D43CA8;
  v2 = a1[3];
  if (v2)
  {
    MEMORY[0x1B8C85310](v2, 0x1000C8052888210);
    a1[3] = 0;
  }

  JUMPOUT(0x1B8C85350);
}

void *sentencepiece::error::CheckNotNull<unsigned int *&>(const char *a1, uint64_t a2, const char *a3, void *a4)
{
  if (!*a4)
  {
    v8 = strlen(a1);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], a1, v8);
    v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "(", 1);
    v11 = MEMORY[0x1B8C84C00](v10, a2);
    v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, ") ", 2);
    v13 = strlen(a3);
    v14 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, a3, v13);
    sentencepiece::error::Abort(v14);
  }

  return a4;
}

void Darts::Details::DoubleArrayBuilder::build<int>(void (**a1)(unint64_t, uint64_t), unint64_t *a2)
{
  if (a2[3])
  {
    v3 = 0;
    memset(v2, 0, sizeof(v2));
    Darts::Details::DoubleArrayBuilder::build_dawg<int>(a1, a2, v2);
  }

  Darts::Details::DoubleArrayBuilder::build_from_keyset<int>(a1, a2);
}

uint64_t *Darts::Details::AutoPool<unsigned char>::~AutoPool(uint64_t *a1)
{
  Darts::Details::AutoPool<unsigned char>::clear(a1);
  if (*a1)
  {
    MEMORY[0x1B8C85310](*a1, 0x1000C8077774924);
    *a1 = 0;
  }

  return a1;
}

uint64_t Darts::Details::AutoPool<unsigned char>::clear(uint64_t *a1)
{
  Darts::Details::AutoPool<unsigned char>::resize(a1, 0);
  result = *a1;
  if (*a1)
  {
    result = MEMORY[0x1B8C85310](result, 0x1000C8077774924);
    *a1 = 0;
  }

  a1[1] = 0;
  a1[2] = 0;
  return result;
}

uint64_t Darts::Details::AutoPool<unsigned char>::resize(uint64_t result, unint64_t a2)
{
  v2 = *(result + 8);
  if (v2 > a2)
  {
    *(result + 8) = a2;
    v2 = a2;
  }

  if (*(result + 16) < a2)
  {
    Darts::Details::AutoPool<unsigned char>::resize_buf(result, a2);
  }

  if (v2 < a2)
  {
    *(result + 8) = a2;
  }

  return result;
}

void Darts::Details::AutoPool<unsigned char>::resize_buf(uint64_t a1, unint64_t a2)
{
  if (a2 < 2 * *(a1 + 16))
  {
    v2 = 1;
    do
    {
      v3 = v2;
      v2 *= 2;
    }

    while (v3 < a2);
  }

  operator new[]();
}

void Darts::Details::Exception::~Exception(std::exception *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x1B8C85350);
}

const char *Darts::Details::Exception::what(Darts::Details::Exception *this)
{
  if (*(this + 1))
  {
    return *(this + 1);
  }

  else
  {
    return "";
  }
}

uint64_t *Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::~AutoPool(uint64_t *a1)
{
  Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::clear(a1);
  if (*a1)
  {
    MEMORY[0x1B8C85310](*a1, 0x1000C8077774924);
    *a1 = 0;
  }

  return a1;
}

uint64_t Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::clear(uint64_t *a1)
{
  Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize(a1, 0);
  result = *a1;
  if (*a1)
  {
    result = MEMORY[0x1B8C85310](result, 0x1000C8077774924);
    *a1 = 0;
  }

  a1[1] = 0;
  a1[2] = 0;
  return result;
}

void Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize(void *a1, unint64_t a2)
{
  v4 = a1[1];
  if (v4 > a2)
  {
    a1[1] = a2;
    v4 = a2;
  }

  if (a1[2] < a2)
  {
    Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize_buf(a1, a2);
  }

  if (a2 > v4)
  {
    bzero((*a1 + 4 * v4), 4 * (a2 - v4));
    a1[1] = a2;
  }
}

void Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize_buf(uint64_t a1, unint64_t a2)
{
  if (a2 < 2 * *(a1 + 16))
  {
    v2 = 1;
    do
    {
      v3 = v2;
      v2 *= 2;
    }

    while (v3 < a2);
  }

  operator new[]();
}

void Darts::Details::DoubleArrayBuilder::build_dawg<int>(void (**a1)(unint64_t, uint64_t), unint64_t *a2, Darts::Details::DawgBuilder *this)
{
  Darts::Details::DawgBuilder::init(this);
  if (*a2)
  {
    v6 = 0;
    do
    {
      v7 = a2[2];
      v8 = *(a2[1] + 8 * v6);
      if (v7)
      {
        v9 = *(v7 + 8 * v6);
      }

      else
      {
          ;
        }

        v9 = v7 - 1;
      }

      v11 = a2[3];
      if (v11)
      {
        v12 = *(v11 + 4 * v6);
      }

      else
      {
        v12 = v6;
      }

      Darts::Details::DawgBuilder::insert(this, v8, v9, v12);
      ++v6;
      if (*a1)
      {
        (*a1)(v6, *a2 + 1);
      }
    }

    while (v6 < *a2);
  }

  Darts::Details::DawgBuilder::flush(this, 0);
  v13 = *this;
  v14 = *(*this + 8);
  v15 = **this;
  if (v14)
  {
    if (*(v13 + 9))
    {
      v16 = 2;
    }

    else
    {
      v16 = 0;
    }

    v17 = v16 | (4 * v15);
  }

  else
  {
    v17 = 2 * v15;
  }

  **(this + 3) = v17 | *(v13 + 10);
  **(this + 6) = v14;
  Darts::Details::AutoPool<Darts::Details::DawgNode>::clear(this);
  Darts::Details::AutoPool<unsigned int>::clear(this + 15);
  Darts::Details::AutoPool<unsigned int>::clear(this + 18);
  Darts::Details::AutoPool<unsigned int>::clear(this + 21);

  Darts::Details::BitVector::build((this + 72));
}

void Darts::Details::DoubleArrayBuilder::build_from_dawg(Darts::Details::DoubleArrayBuilder *this, const Darts::Details::DawgBuilder *a2)
{
  v2 = *(a2 + 4);
  v3 = 1;
  do
  {
    v4 = v3;
    v3 *= 2;
  }

  while (v4 < v2);
  if (*(this + 3) < v4)
  {
    Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize_buf(this + 8, v4);
  }

  operator new[]();
}

void Darts::Details::DoubleArrayBuilder::build_from_keyset<int>(uint64_t a1, unint64_t *a2)
{
  v2 = *a2;
  v3 = 1;
  do
  {
    v4 = v3;
    v3 *= 2;
  }

  while (v4 < v2);
  if (*(a1 + 24) < v4)
  {
    Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize_buf(a1 + 8, v4);
  }

  operator new[]();
}

uint64_t *Darts::Details::AutoStack<unsigned int>::~AutoStack(uint64_t *a1)
{
  Darts::Details::AutoPool<unsigned int>::clear(a1);

  return Darts::Details::AutoPool<unsigned int>::~AutoPool(a1);
}

uint64_t Darts::Details::AutoPool<unsigned int>::clear(uint64_t *a1)
{
  Darts::Details::AutoPool<unsigned int>::resize(a1, 0);
  result = *a1;
  if (*a1)
  {
    result = MEMORY[0x1B8C85310](result, 0x1000C8077774924);
    *a1 = 0;
  }

  a1[1] = 0;
  a1[2] = 0;
  return result;
}

uint64_t Darts::Details::AutoPool<unsigned int>::resize(uint64_t result, unint64_t a2)
{
  v2 = *(result + 8);
  if (v2 > a2)
  {
    *(result + 8) = a2;
    v2 = a2;
  }

  if (*(result + 16) < a2)
  {
    Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize_buf(result, a2);
  }

  if (v2 < a2)
  {
    *(result + 8) = a2;
  }

  return result;
}

uint64_t *Darts::Details::AutoPool<unsigned int>::~AutoPool(uint64_t *a1)
{
  Darts::Details::AutoPool<unsigned int>::clear(a1);
  if (*a1)
  {
    MEMORY[0x1B8C85310](*a1, 0x1000C8077774924);
    *a1 = 0;
  }

  return a1;
}

void Darts::Details::BitVector::~BitVector(Darts::Details::BitVector *this)
{
  Darts::Details::BitVector::clear(this);
  v2 = *(this + 3);
  if (v2)
  {
    MEMORY[0x1B8C85310](v2, 0x1000C8052888210);
    *(this + 3) = 0;
  }

  Darts::Details::AutoPool<unsigned int>::~AutoPool(this);
}

uint64_t Darts::Details::BitVector::clear(Darts::Details::BitVector *this)
{
  Darts::Details::AutoPool<unsigned int>::clear(this);
  result = *(this + 3);
  if (result)
  {
    result = MEMORY[0x1B8C85310](result, 0x1000C8052888210);
    *(this + 3) = 0;
  }

  return result;
}

uint64_t *Darts::Details::AutoPool<Darts::Details::DawgNode>::~AutoPool(uint64_t *a1)
{
  Darts::Details::AutoPool<Darts::Details::DawgNode>::clear(a1);
  if (*a1)
  {
    MEMORY[0x1B8C85310](*a1, 0x1000C8077774924);
    *a1 = 0;
  }

  return a1;
}

uint64_t Darts::Details::AutoPool<Darts::Details::DawgNode>::clear(uint64_t *a1)
{
  Darts::Details::AutoPool<Darts::Details::DawgNode>::resize(a1, 0);
  result = *a1;
  if (*a1)
  {
    result = MEMORY[0x1B8C85310](result, 0x1000C8077774924);
    *a1 = 0;
  }

  a1[1] = 0;
  a1[2] = 0;
  return result;
}

void *Darts::Details::AutoPool<Darts::Details::DawgNode>::resize(void *result, unint64_t a2)
{
  v2 = result[1];
  if (v2 > a2)
  {
    result[1] = a2;
    v2 = a2;
  }

  if (result[2] < a2)
  {
    Darts::Details::AutoPool<Darts::Details::DawgNode>::resize_buf(result, a2);
  }

  for (; v2 < a2; v2 = result[1])
  {
    result[1] = v2 + 1;
    v3 = *result + 12 * v2;
    *(v3 + 7) = 0;
    *v3 = 0;
  }

  return result;
}

void Darts::Details::AutoPool<Darts::Details::DawgNode>::resize_buf(uint64_t a1, unint64_t a2)
{
  if (a2 < 2 * *(a1 + 16))
  {
    v2 = 1;
    do
    {
      v3 = v2;
      v2 *= 2;
    }

    while (v3 < a2);
  }

  operator new[]();
}

void *Darts::Details::DawgBuilder::init(Darts::Details::DawgBuilder *this)
{
  v7 = 0;
  Darts::Details::AutoPool<unsigned int>::resize(this + 15, 0x400uLL, &v7);
  v2 = *(this + 22);
  if (v2)
  {
    v3 = *this + 12 * *(*(this + 21) + 4 * v2 - 4);
    *(v3 + 7) = 0;
    *v3 = 0;
    --*(this + 22);
  }

  else
  {
    Darts::Details::AutoPool<Darts::Details::DawgNode>::append(this);
  }

  Darts::Details::BitVector::append(this + 9);
  Darts::Details::AutoPool<Darts::Details::DawgUnit>::append(this + 3);
  v4 = *(this + 7);
  if (v4 == *(this + 8))
  {
    Darts::Details::AutoPool<unsigned char>::resize_buf(this + 48, v4 + 1);
  }

  *(this + 7) = v4 + 1;
  *(this + 24) = 1;
  *(*this + 8) = -1;
  v6 = 0;
  return Darts::Details::AutoPool<unsigned int>::append(this + 18, &v6);
}

void *Darts::Details::DawgBuilder::insert(void *this, const char *a2, unint64_t a3, int a4)
{
  if (a4 < 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    v24 = "../libsentencepiece/third_party/darts_clone/darts.h:1141: exception: failed to insert key: negative value";
    goto LABEL_25;
  }

  if (!a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    v24 = "../libsentencepiece/third_party/darts_clone/darts.h:1143: exception: failed to insert key: zero-length key";
LABEL_25:
    *exception = &unk_1F2D43CF0;
    exception[1] = v24;
  }

  v7 = this;
  v8 = 0;
  v9 = 0;
  v10 = *this;
  while (1)
  {
    v11 = *(v10 + 12 * v8);
    if (!v11)
    {
      goto LABEL_12;
    }

    v12 = a2[v9];
    if (v9 < a3 && !a2[v9])
    {
      exception = __cxa_allocate_exception(0x10uLL);
      v24 = "../libsentencepiece/third_party/darts_clone/darts.h:1157: exception: failed to insert key: invalid null character";
      goto LABEL_25;
    }

    v13 = v10 + 12 * v11;
    v14 = *(v13 + 8);
    if (v12 < v14)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      v24 = "../libsentencepiece/third_party/darts_clone/darts.h:1162: exception: failed to insert key: wrong key order";
      goto LABEL_25;
    }

    if (v12 > v14)
    {
      break;
    }

    ++v9;
    v8 = *(v10 + 12 * v8);
    if (v9 > a3)
    {
      return this;
    }
  }

  *(v13 + 10) = 1;
  this = Darts::Details::DawgBuilder::flush(this, v11);
LABEL_12:
  while (v9 <= a3)
  {
    if (v9 >= a3)
    {
      v15 = 0;
    }

    else
    {
      v15 = a2[v9];
    }

    v16 = v7[22];
    if (v16)
    {
      v17 = *(v7[21] + 4 * v16 - 4);
      v18 = *v7 + 12 * v17;
      *(v18 + 7) = 0;
      *v18 = 0;
      --v7[22];
    }

    else
    {
      v17 = *(v7 + 2);
      Darts::Details::AutoPool<Darts::Details::DawgNode>::append(v7);
    }

    v25 = v17;
    v19 = *v7;
    v20 = (*v7 + 12 * v8);
    v21 = *v20;
    if (!*v20)
    {
      *(v19 + 12 * v17 + 9) = 1;
    }

    *(v19 + 12 * v17 + 4) = v21;
    v22 = v25;
    *(v19 + 12 * v25 + 8) = v15;
    *v20 = v22;
    this = Darts::Details::AutoPool<unsigned int>::append(v7 + 18, &v25);
    v8 = v25;
    ++v9;
  }

  *(*v7 + 12 * v8) = a4;
  return this;
}

void *Darts::Details::AutoPool<unsigned int>::resize(void *result, unint64_t a2, int *a3)
{
  v3 = result[1];
  if (v3 > a2)
  {
    result[1] = a2;
    v3 = a2;
  }

  if (result[2] < a2)
  {
    Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize_buf(result, a2);
  }

  v4 = a2 - v3;
  if (a2 > v3)
  {
    v5 = 0;
    v6 = *a3;
    v7 = vdupq_n_s64(v4 - 1);
    v8 = (*result + 4 * v3 + 8);
    do
    {
      v9 = vdupq_n_s64(v5);
      v10 = vmovn_s64(vcgeq_u64(v7, vorrq_s8(v9, xmmword_1B5AE0060)));
      if (vuzp1_s16(v10, *v7.i8).u8[0])
      {
        *(v8 - 2) = v6;
      }

      if (vuzp1_s16(v10, *&v7).i8[2])
      {
        *(v8 - 1) = v6;
      }

      if (vuzp1_s16(*&v7, vmovn_s64(vcgeq_u64(v7, vorrq_s8(v9, xmmword_1B5AE0050)))).i32[1])
      {
        *v8 = v6;
        v8[1] = v6;
      }

      v5 += 4;
      v8 += 4;
    }

    while (((v4 + 3) & 0xFFFFFFFFFFFFFFFCLL) != v5);
    result[1] = a2;
  }

  return result;
}

void *Darts::Details::AutoPool<Darts::Details::DawgNode>::append(void *result)
{
  v1 = result[1];
  if (v1 == result[2])
  {
    Darts::Details::AutoPool<Darts::Details::DawgNode>::resize_buf(result, v1 + 1);
  }

  result[1] = v1 + 1;
  v2 = *result + 12 * v1;
  *(v2 + 7) = 0;
  *v2 = 0;
  return result;
}

void *Darts::Details::BitVector::append(void *this)
{
  v1 = this;
  v2 = this[5];
  if ((v2 & 0x1F) == 0)
  {
    v3 = 0;
    this = Darts::Details::AutoPool<unsigned int>::append(this, &v3);
    v2 = v1[5];
  }

  v1[5] = v2 + 1;
  return this;
}

void *Darts::Details::AutoPool<Darts::Details::DawgUnit>::append(void *result)
{
  v1 = result[1];
  if (v1 == result[2])
  {
    Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize_buf(result, v1 + 1);
  }

  result[1] = v1 + 1;
  *(*result + 4 * v1) = 0;
  return result;
}

void *Darts::Details::AutoPool<unsigned int>::append(void *result, _DWORD *a2)
{
  v2 = result[1];
  if (v2 == result[2])
  {
    Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize_buf(result, v2 + 1);
  }

  result[1] = v2 + 1;
  *(*result + 4 * v2) = *a2;
  return result;
}

uint64_t Darts::Details::DawgBuilder::flush(uint64_t this, int a2)
{
  v2 = this;
  v3 = *(this + 152);
  v4 = *(*(this + 144) + 4 * v3 - 4);
  if (v4 != a2)
  {
    while (1)
    {
      *(v2 + 152) = v3 - 1;
      v6 = *(v2 + 128);
      if (*(v2 + 192) >= v6 - (v6 >> 2))
      {
        v7 = 2 * v6;
        Darts::Details::AutoPool<unsigned int>::clear((v2 + 120));
        v34 = 0;
        Darts::Details::AutoPool<unsigned int>::resize((v2 + 120), v7, &v34);
        v8 = *(v2 + 32);
        if (v8 >= 2)
        {
          v9 = *(v2 + 48);
          for (i = 1; i != v8; ++i)
          {
            if (!*(v9 + i) || (*(*(v2 + 24) + 4 * i) & 2) != 0)
            {
              v11 = 0;
              if (i)
              {
                v12 = i;
                do
                {
                  v13 = *(*(v2 + 24) + 4 * v12);
                  v14 = (v13 ^ ~(*(v9 + v12) << 24)) + (v13 << 15);
                  v15 = 2057 * ((5 * (v14 ^ (v14 >> 12))) ^ ((5 * (v14 ^ (v14 >> 12))) >> 4));
                  v11 ^= HIWORD(v15) ^ v15;
                  v16 = __CFADD__(v12++, 1);
                }

                while (!v16 && (v13 & 1) != 0);
              }

              v17 = *(v2 + 120);
              do
              {
                v18 = v11 % *(v2 + 128);
                v11 = v18 + 1;
              }

              while (*(v17 + 4 * v18));
              *(v17 + 4 * v18) = i;
            }
          }
        }
      }

      v19 = 0;
      if (v4)
      {
        v20 = v4;
        do
        {
          ++v19;
          v20 = *(*v2 + 12 * v20 + 4);
        }

        while (v20);
      }

      v33 = 0;
      this = Darts::Details::DawgBuilder::find_node(v2, v4, &v33);
      if (this)
      {
        v21 = this;
        *(*(v2 + 72) + 4 * (this >> 5)) |= 1 << this;
        if (v4)
        {
          goto LABEL_21;
        }

        goto LABEL_22;
      }

      if (!v19)
      {
        break;
      }

      do
      {
        Darts::Details::BitVector::append((v2 + 72));
        this = Darts::Details::AutoPool<Darts::Details::DawgUnit>::append((v2 + 24));
        v24 = *(v2 + 56);
        if (v24 == *(v2 + 64))
        {
          Darts::Details::AutoPool<unsigned char>::resize_buf(v2 + 48, v24 + 1);
        }

        *(v2 + 56) = v24 + 1;
        --v19;
      }

      while (v19);
      v25 = *(v2 + 112) - 1;
      if (v4)
      {
        goto LABEL_31;
      }

LABEL_39:
      v21 = v25 + 1;
      *(*(v2 + 120) + 4 * v33) = v25 + 1;
      ++*(v2 + 192);
      if (v4)
      {
        do
        {
LABEL_21:
          v22 = *(*v2 + 12 * v4 + 4);
          v35 = v4;
          this = Darts::Details::AutoPool<unsigned int>::append((v2 + 168), &v35);
          v4 = v22;
        }

        while (v22);
      }

LABEL_22:
      v3 = *(v2 + 152);
      v23 = *(v2 + 144) + 4 * v3;
      *(*v2 + 12 * *(v23 - 4)) = v21;
      v4 = *(v23 - 4);
      if (v4 == a2)
      {
        goto LABEL_2;
      }
    }

    v25 = 0;
    if (!v4)
    {
      goto LABEL_39;
    }

LABEL_31:
    v26 = *v2;
    v27 = v4;
    do
    {
      v28 = (v26 + 12 * v27);
      v29 = *(v28 + 8);
      v30 = *v28;
      if (v29)
      {
        if (*(v28 + 9))
        {
          v31 = 2;
        }

        else
        {
          v31 = 0;
        }

        v32 = v31 | (4 * v30);
      }

      else
      {
        v32 = 2 * v30;
      }

      *(*(v2 + 24) + 4 * v25) = v32 | *(v28 + 10);
      *(*(v2 + 48) + v25--) = v29;
      v26 = *v2;
      v27 = *(*v2 + 12 * v27 + 4);
    }

    while (v27);
    goto LABEL_39;
  }

LABEL_2:
  *(v2 + 152) = v3 - 1;
  return this;
}

uint64_t Darts::Details::DawgBuilder::find_node(Darts::Details::DawgBuilder *this, unsigned int a2, unsigned int *a3)
{
  v3 = a2;
  if (a2)
  {
    LODWORD(v4) = 0;
    v5 = a2;
    do
    {
      v6 = *this + 12 * v5;
      v7 = *v6;
      if (*(v6 + 8))
      {
        if (*(v6 + 9))
        {
          v8 = 2;
        }

        else
        {
          v8 = 0;
        }

        v9 = v8 | (4 * v7);
      }

      else
      {
        v9 = 2 * v7;
      }

      v10 = ((v9 | *(v6 + 10)) ^ ~(*(v6 + 8) << 24)) + ((v9 | *(v6 + 10)) << 15);
      v11 = 2057 * ((5 * (v10 ^ (v10 >> 12))) ^ ((5 * (v10 ^ (v10 >> 12))) >> 4));
      v4 = v4 ^ HIWORD(v11) ^ v11;
      v5 = *(v6 + 4);
    }

    while (v5);
  }

  else
  {
    v4 = 0;
  }

  v13 = *(this + 15);
  v12 = *(this + 16);
  v14 = v4 % v12;
  *a3 = v4 % v12;
  v15 = *(v13 + 4 * (v4 % v12));
  if (v15)
  {
    v16 = *this;
    v17 = *this + 12 * a2;
    v18 = *(this + 3);
    do
    {
      v19 = *(v17 + 4);
      v20 = v15;
      if (v19)
      {
        v20 = v15;
        while ((*(v18 + 4 * v20) & 1) != 0)
        {
          ++v20;
          LODWORD(v19) = *(v16 + 12 * v19 + 4);
          if (!v19)
          {
            goto LABEL_18;
          }
        }
      }

      else
      {
LABEL_18:
        if ((*(v18 + 4 * v20) & 1) == 0)
        {
          if (!v3)
          {
            return v15;
          }

          v21 = v3;
          while (1)
          {
            v22 = (v16 + 12 * v21);
            v23 = *v22;
            if (*(v22 + 8))
            {
              v24 = *(v22 + 9) ? 2 : 0;
              v25 = v24 | (4 * v23);
            }

            else
            {
              v25 = 2 * v23;
            }

            if ((v25 | *(v22 + 10)) != *(v18 + 4 * v20) || *(v22 + 8) != *(*(this + 6) + v20))
            {
              break;
            }

            v21 = v22[1];
            --v20;
            if (!v21)
            {
              return v15;
            }
          }
        }
      }

      v14 = (v14 + 1) % v12;
      *a3 = v14;
      v15 = *(v13 + 4 * v14);
    }

    while (v15);
  }

  return v15;
}

unsigned int *Darts::Details::DoubleArrayBuilderUnit::set_offset(unsigned int *this, unsigned int a2)
{
  if (a2 >> 29)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = &unk_1F2D43CF0;
    exception[1] = "../libsentencepiece/third_party/darts_clone/darts.h:1380: exception: failed to modify unit: too large offset";
  }

  v2 = (4 * a2) | 0x200;
  if (a2 < 0x200000)
  {
    v2 = a2 << 10;
  }

  *this = *this & 0x800001FF | v2;
  return this;
}

unsigned int *Darts::Details::DoubleArrayBuilder::build_from_dawg(Darts::Details::DoubleArrayBuilder *this, const Darts::Details::DawgBuilder *a2, unsigned int a3, unsigned int a4)
{
  v8 = (a2 + 72);
  v9 = *(*(a2 + 3) + 4 * a3);
  v10 = v9 >> 2;
  v11 = v9 >> 7;
  v12 = 1 << (v9 >> 2);
  if ((v12 & *(*(a2 + 9) + 4 * (v9 >> 7))) != 0 && (v13 = *(*(this + 8) + 4 * (Darts::Details::BitVector::rank((a2 + 72), v10) - 1))) != 0 && ((v14 = v13 ^ a4, ((v13 ^ a4) & 0x1FE00000) != 0) ? (v15 = (v13 ^ a4) == 0) : (v15 = 1), v15))
  {
    if (*(*(a2 + 6) + v10))
    {
      v16 = *(this + 1);
      v17 = a4;
    }

    else
    {
      v17 = a4;
      v16 = *(this + 1);
      *(v16 + 4 * a4) |= 0x100u;
    }

    return Darts::Details::DoubleArrayBuilderUnit::set_offset((v16 + 4 * v17), v14);
  }

  else
  {
    result = Darts::Details::DoubleArrayBuilder::arrange_from_dawg(this, a2, a3, a4);
    v19 = result;
    if ((*(*(a2 + 9) + 4 * v11) & v12) != 0)
    {
      result = Darts::Details::BitVector::rank(v8, v10);
      *(*(this + 8) + 4 * (result - 1)) = v19;
    }

    do
    {
      if (*(*(a2 + 6) + v10))
      {
        result = Darts::Details::DoubleArrayBuilder::build_from_dawg(this, a2, v10, v19 ^ *(*(a2 + 6) + v10));
      }

      if (v10 == -1)
      {
        break;
      }

      v20 = *(*(a2 + 3) + 4 * v10);
      LODWORD(v10) = v10 + 1;
    }

    while ((v20 & 1) != 0);
  }

  return result;
}

void Darts::Details::DoubleArrayBuilder::expand_units(Darts::Details::DoubleArrayBuilder *this)
{
  v2 = *(this + 2);
  v3 = (v2 + 256);
  v4 = (v2 >> 8) - 16;
  if (v4 >= 0xFFFFFFEF)
  {
    Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize(this + 1, (v2 + 256));
  }

  else
  {
    v5 = 0;
    v6 = v4 << 8;
    v7 = *(this + 4);
    v8 = (3072 * ((v2 >> 8) & 0xF)) | 9;
    while (*(v7 + v8) == 1)
    {
      --v5;
      v8 += 12;
      if (v5 == -256)
      {
        v9 = 0;
        goto LABEL_8;
      }
    }

    v9 = v6 - v5;
LABEL_8:
    v10 = 3072 * ((v2 >> 8) & 0xF);
    v11 = 256;
    do
    {
      if ((*(v7 + v10 + 8) & 1) == 0)
      {
        if (*(this + 2) <= v6)
        {
          Darts::Details::DoubleArrayBuilder::expand_units(this);
          v7 = *(this + 4);
        }

        v12 = (v7 + v10);
        v13 = *(v7 + v10 + 4);
        if (v6 == *(this + 18))
        {
          *(this + 18) = v13;
          if (v6 == v13)
          {
            *(this + 18) = *(this + 2);
          }
        }

        v14 = *v12;
        *(v7 + 12 * (*v12 & 0xFFF) + 4) = v13;
        *(v7 + 12 * (v12[1] & 0xFFF)) = v14;
        *(v12 + 8) = 1;
        *(*(this + 1) + 4 * v6) = v9 ^ v6;
      }

      ++v6;
      v10 += 12;
      --v11;
    }

    while (v11);
    Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::resize(this + 1, (v2 + 256));
    v15 = v2;
    if (v2 < v3)
    {
      v16 = *(this + 4);
      do
      {
        *(v16 + 12 * (v15++ & 0xFFF) + 8) = 0;
      }

      while (v3 != v15);
    }
  }

  v17 = *(this + 4);
  if (v2 + 1 < v3)
  {
    v18 = 255;
    v19 = v2;
    do
    {
      *(v17 + 12 * (v19 & 0xFFF) + 4) = v19 + 1;
      *(v17 + 12 * ((v19 + 1) & 0xFFF)) = v19;
      ++v19;
      --v18;
    }

    while (v18);
  }

  v20 = 12 * (v2 & 0xFFF);
  *(v17 + v20) = v2 + 255;
  v21 = *(this + 18);
  v22 = 12 * (v21 & 0xFFF);
  v23 = *(v17 + v22);
  *(v17 + v20) = v23;
  *(v17 + 12 * ((v2 + 255) & 0xFFF) + 4) = v21;
  *(v17 + 12 * (v23 & 0xFFF) + 4) = v2;
  *(v17 + v22) = v2 + 255;
}

uint64_t Darts::Details::DoubleArrayBuilder::arrange_from_dawg(Darts::Details::DoubleArrayBuilder *this, const Darts::Details::DawgBuilder *a2, unsigned int a3, unsigned int a4)
{
  Darts::Details::AutoPool<unsigned char>::resize(this + 40, 0);
  v8 = *(*(a2 + 3) + 4 * a3);
  if (v8 >= 4)
  {
    v9 = v8 >> 2;
    do
    {
      v38 = *(*(a2 + 6) + v9);
      Darts::Details::AutoPool<unsigned char>::append(this + 5, &v38);
      v10 = *(*(a2 + 3) + 4 * v9);
      v12 = __CFADD__(v9++, 1);
    }

    while ((v10 & 1) != 0 && !v12);
  }

  v13 = *(this + 18);
  v14 = *(this + 2);
  if (v14 > v13)
  {
    v16 = *(this + 4);
    v15 = *(this + 5);
    v19 = *v15;
    v17 = v15 + 1;
    v18 = v19;
    v20 = *(this + 18);
    do
    {
      v21 = v20 ^ v18;
      if ((*(v16 + 12 * ((v20 ^ v18) & 0xFFF) + 9) & 1) == 0 && (!((v20 ^ v18) ^ a4) || ((v21 ^ a4) & 0x1FE00000) == 0))
      {
        v22 = *(this + 6);
        if (v22 < 2)
        {
          goto LABEL_21;
        }

        v23 = v22 - 1;
        v24 = v17;
        while (1)
        {
          v25 = *v24++;
          if (*(v16 + 12 * ((v20 ^ v18) & 0xFFF ^ v25) + 8) == 1)
          {
            break;
          }

          if (!--v23)
          {
            goto LABEL_21;
          }
        }
      }

      v20 = *(v16 + 12 * (v20 & 0xFFF) + 4);
    }

    while (v20 != v13);
  }

  v21 = a4 | v14;
LABEL_21:
  Darts::Details::DoubleArrayBuilderUnit::set_offset((*(this + 1) + 4 * a4), v21 ^ a4);
  if (*(this + 6))
  {
    v26 = 0;
    v27 = *(*(a2 + 3) + 4 * a3) >> 2;
    do
    {
      v28 = v21 ^ *(*(this + 5) + v26);
      if (*(this + 2) <= v28)
      {
        Darts::Details::DoubleArrayBuilder::expand_units(this);
      }

      if (*(this + 18) == v28)
      {
        v29 = v28 & 0xFFF;
        v30 = *(this + 4);
        v31 = *(v30 + 12 * (v28 & 0xFFF) + 4);
        *(this + 18) = v31;
        if (v31 == v28)
        {
          *(this + 18) = *(this + 2);
        }
      }

      else
      {
        v30 = *(this + 4);
        v29 = v28 & 0xFFF;
      }

      v32 = v30 + 12 * v29;
      v33 = *(v32 + 4);
      v34 = v30 + 12 * (*v32 & 0xFFF);
      *(v30 + 12 * (v33 & 0xFFF)) = *v32;
      *(v34 + 4) = v33;
      *(v32 + 8) = 1;
      v35 = *(this + 1);
      if (*(*(a2 + 6) + v27))
      {
        *(v35 + 4 * v28) = *(*(this + 5) + v26);
        v36 = *(*(a2 + 3) + 4 * v27);
      }

      else
      {
        *(v35 + 4 * a4) |= 0x100u;
        v36 = *(*(a2 + 3) + 4 * v27);
        *(v35 + 4 * v28) = (v36 >> 1) | 0x80000000;
      }

      v27 = ((v36 << 31) >> 31) & (v27 + 1);
      ++v26;
    }

    while (v26 < *(this + 6));
  }

  else
  {
    v30 = *(this + 4);
  }

  *(v30 + 12 * (v21 & 0xFFF) + 9) = 1;
  return v21;
}

uint64_t Darts::Details::BitVector::rank(Darts::Details::BitVector *this, unint64_t a2)
{
  v2 = (a2 >> 3) & 0x1FFFFFFFFFFFFFFCLL;
  v3 = *(*(this + 3) + v2);
  LODWORD(v2) = *(*this + v2) & (0xFFFFFFFF >> ~a2);
  LODWORD(v2) = ((((((v2 >> 1) & 0x55555555) + (v2 & 0x55555555)) >> 2) & 0x33333333) + ((((v2 >> 1) & 0x55555555) + (v2 & 0x55555555)) & 0x33333333) + (((((((v2 >> 1) & 0x55555555) + (v2 & 0x55555555)) >> 2) & 0x33333333) + ((((v2 >> 1) & 0x55555555) + (v2 & 0x55555555)) & 0x33333333)) >> 4)) & 0xF0F0F0F;
  return ((v2 + BYTE1(v2) + ((v2 + (v2 >> 8)) >> 16)) & 0x3Fu) + v3;
}

void *Darts::Details::AutoPool<unsigned char>::append(void *result, _BYTE *a2)
{
  v2 = result[1];
  if (v2 == result[2])
  {
    Darts::Details::AutoPool<unsigned char>::resize_buf(result, v2 + 1);
  }

  result[1] = v2 + 1;
  *(*result + v2) = *a2;
  return result;
}

void Darts::Details::DawgBuilder::~DawgBuilder(Darts::Details::DawgBuilder *this)
{
  Darts::Details::AutoPool<Darts::Details::DawgNode>::clear(this);
  Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::clear(this + 3);
  Darts::Details::AutoPool<unsigned char>::clear(this + 6);
  Darts::Details::BitVector::clear((this + 72));
  Darts::Details::AutoPool<unsigned int>::clear(this + 15);
  Darts::Details::AutoPool<unsigned int>::clear(this + 18);
  Darts::Details::AutoPool<unsigned int>::clear(this + 21);
  *(this + 24) = 0;
  Darts::Details::AutoStack<unsigned int>::~AutoStack(this + 21);
  Darts::Details::AutoStack<unsigned int>::~AutoStack(this + 18);
  Darts::Details::AutoPool<unsigned int>::~AutoPool(this + 15);
  Darts::Details::BitVector::~BitVector((this + 72));
  Darts::Details::AutoPool<unsigned char>::~AutoPool(this + 6);
  Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::~AutoPool(this + 3);

  Darts::Details::AutoPool<Darts::Details::DawgNode>::~AutoPool(this);
}

uint64_t Darts::Details::DoubleArrayBuilder::build_from_keyset<int>(uint64_t a1, void *a2, unint64_t a3, unint64_t a4, unint64_t a5, unsigned int a6)
{
  while (1)
  {
    result = Darts::Details::DoubleArrayBuilder::arrange_from_keyset<int>(a1, a2, a3, a4, a5, a6);
    v12 = result;
    if (a3 < a4)
    {
      v13 = a2[2];
      while (v13 && *(v13 + 8 * a3) <= a5 || !*(*(a2[1] + 8 * a3) + a5))
      {
        if (a4 == ++a3)
        {
          return result;
        }
      }
    }

    if (a3 == a4)
    {
      break;
    }

    v14 = a2[2];
    if (v14 && *(v14 + 8 * a3) <= a5)
    {
      v15 = 0;
    }

    else
    {
      v15 = *(*(a2[1] + 8 * a3) + a5);
    }

    v16 = a3 + 1;
    if (a3 + 1 < a4)
    {
      do
      {
        if (v14 && *(v14 + 8 * v16) <= a5)
        {
          v17 = 0;
        }

        else
        {
          v17 = *(*(a2[1] + 8 * v16) + a5);
        }

        if (v17 != v15)
        {
          Darts::Details::DoubleArrayBuilder::build_from_keyset<int>(a1, a2, a3, v16, a5 + 1, v12 ^ v15);
          v14 = a2[2];
          if (v14 && *(v14 + 8 * v16) <= a5)
          {
            v15 = 0;
          }

          else
          {
            v15 = *(*(a2[1] + 8 * v16) + a5);
          }

          a3 = v16;
        }

        ++v16;
      }

      while (a4 != v16);
    }

    a6 = v12 ^ v15;
    ++a5;
  }

  return result;
}

uint64_t Darts::Details::DoubleArrayBuilder::arrange_from_keyset<int>(uint64_t a1, void *a2, unint64_t a3, unint64_t a4, unint64_t a5, unsigned int a6)
{
  Darts::Details::AutoPool<unsigned char>::resize(a1 + 40, 0);
  if (a3 < a4)
  {
    v12 = -1;
    while (1)
    {
      v13 = a2[2];
      if (v13)
      {
        if (*(v13 + 8 * a3) > a5)
        {
          v44 = *(*(a2[1] + 8 * a3) + a5);
          if (!v44)
          {
            exception = __cxa_allocate_exception(0x10uLL);
            v43 = "../libsentencepiece/third_party/darts_clone/darts.h:1726: exception: failed to build double-array: invalid null character";
            goto LABEL_57;
          }

          goto LABEL_20;
        }

        v44 = 0;
      }

      else
      {
        v44 = *(*(a2[1] + 8 * a3) + a5);
        if (v44)
        {
          goto LABEL_20;
        }
      }

      v14 = a2[3];
      if (v14)
      {
        if ((*(v14 + 4 * a3) & 0x80000000) != 0)
        {
          goto LABEL_56;
        }
      }

      else if ((a3 & 0x80000000) != 0)
      {
LABEL_56:
        exception = __cxa_allocate_exception(0x10uLL);
        v43 = "../libsentencepiece/third_party/darts_clone/darts.h:1728: exception: failed to build double-array: negative value";
LABEL_57:
        *exception = &unk_1F2D43CF0;
        exception[1] = v43;
      }

      if (v12 == -1)
      {
        if (v14)
        {
          v12 = *(v14 + 4 * a3);
        }

        else
        {
          v12 = a3;
        }
      }

      if (*a1)
      {
        (*a1)(a3 + 1, *a2 + 1);
      }

LABEL_20:
      v15 = *(a1 + 48);
      if (!v15)
      {
        goto LABEL_24;
      }

      v16 = *(*(a1 + 40) + v15 - 1);
      if (v44 != v16)
      {
        if (v44 < v16)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          v43 = "../libsentencepiece/third_party/darts_clone/darts.h:1743: exception: failed to build double-array: wrong key order";
          goto LABEL_57;
        }

LABEL_24:
        Darts::Details::AutoPool<unsigned char>::append((a1 + 40), &v44);
      }

      if (a4 == ++a3)
      {
        v17 = v12 | 0x80000000;
        goto LABEL_28;
      }
    }
  }

  v17 = -1;
LABEL_28:
  v18 = *(a1 + 72);
  v19 = *(a1 + 16);
  if (v19 > v18)
  {
    v21 = *(a1 + 32);
    v20 = *(a1 + 40);
    v24 = *v20;
    v22 = v20 + 1;
    v23 = v24;
    v25 = *(a1 + 72);
    do
    {
      v26 = v25 ^ v23;
      if ((*(v21 + 12 * ((v25 ^ v23) & 0xFFF) + 9) & 1) == 0 && (!((v25 ^ v23) ^ a6) || ((v26 ^ a6) & 0x1FE00000) == 0))
      {
        v27 = *(a1 + 48);
        if (v27 < 2)
        {
          goto LABEL_41;
        }

        v28 = v27 - 1;
        v29 = v22;
        while (1)
        {
          v30 = *v29++;
          if (*(v21 + 12 * ((v25 ^ v23) & 0xFFF ^ v30) + 8) == 1)
          {
            break;
          }

          if (!--v28)
          {
            goto LABEL_41;
          }
        }
      }

      v25 = *(v21 + 12 * (v25 & 0xFFF) + 4);
    }

    while (v25 != v18);
  }

  v26 = a6 | v19;
LABEL_41:
  Darts::Details::DoubleArrayBuilderUnit::set_offset((*(a1 + 8) + 4 * a6), v26 ^ a6);
  if (*(a1 + 48))
  {
    v31 = 0;
    v32 = *(a1 + 40);
    do
    {
      v33 = v26 ^ *(v32 + v31);
      if (*(a1 + 16) <= v33)
      {
        Darts::Details::DoubleArrayBuilder::expand_units(a1);
      }

      if (*(a1 + 72) == v33)
      {
        v34 = v33 & 0xFFF;
        v35 = *(a1 + 32);
        v36 = *(v35 + 12 * (v33 & 0xFFF) + 4);
        *(a1 + 72) = v36;
        if (v36 == v33)
        {
          *(a1 + 72) = *(a1 + 16);
        }
      }

      else
      {
        v35 = *(a1 + 32);
        v34 = v33 & 0xFFF;
      }

      v37 = v35 + 12 * v34;
      v38 = *(v37 + 4);
      v39 = v35 + 12 * (*v37 & 0xFFF);
      *(v35 + 12 * (v38 & 0xFFF)) = *v37;
      *(v39 + 4) = v38;
      *(v37 + 8) = 1;
      v32 = *(a1 + 40);
      v40 = *(a1 + 8);
      if (*(v32 + v31))
      {
        *(v40 + 4 * v33) = *(v32 + v31);
      }

      else
      {
        *(v40 + 4 * a6) |= 0x100u;
        *(v40 + 4 * v33) = v17;
      }

      ++v31;
    }

    while (v31 < *(a1 + 48));
  }

  else
  {
    v35 = *(a1 + 32);
  }

  *(v35 + 12 * (v26 & 0xFFF) + 9) = 1;
  return v26;
}

void Darts::Details::DoubleArrayBuilder::~DoubleArrayBuilder(Darts::Details::DoubleArrayBuilder *this)
{
  Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::clear(this + 1);
  v2 = *(this + 4);
  if (v2)
  {
    MEMORY[0x1B8C85310](v2, 0x1000C80CBA68D63);
    *(this + 4) = 0;
  }

  Darts::Details::AutoPool<unsigned char>::clear(this + 5);
  v3 = *(this + 8);
  if (v3)
  {
    MEMORY[0x1B8C85310](v3, 0x1000C8052888210);
    *(this + 8) = 0;
  }

  *(this + 18) = 0;
  Darts::Details::AutoPool<unsigned char>::~AutoPool(this + 5);
  v4 = *(this + 4);
  if (v4)
  {
    MEMORY[0x1B8C85310](v4, 0x1000C80CBA68D63);
    *(this + 4) = 0;
  }

  Darts::Details::AutoPool<Darts::Details::DoubleArrayBuilderUnit>::~AutoPool(this + 1);
}

double sentencepiece::SentencePieceProcessor::SentencePieceProcessor(sentencepiece::SentencePieceProcessor *this)
{
  *this = &unk_1F2D43D18;
  result = 0.0;
  *(this + 8) = 0u;
  *(this + 24) = 0u;
  *(this + 40) = 0u;
  *(this + 56) = 0u;
  *(this + 72) = 0u;
  return result;
}

void sentencepiece::SentencePieceProcessor::~SentencePieceProcessor(sentencepiece::SentencePieceProcessor *this)
{
  *this = &unk_1F2D43D18;
  v2 = *(this + 8);
  if (v2)
  {
    *(this + 9) = v2;
    operator delete(v2);
  }

  v3 = *(this + 5);
  if (v3)
  {
    *(this + 6) = v3;
    operator delete(v3);
  }

  std::unique_ptr<sentencepiece::ModelProto>::reset[abi:ne200100](this + 4, 0);
  v4 = *(this + 3);
  *(this + 3) = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  v5 = *(this + 2);
  *(this + 2) = 0;
  if (v5)
  {
    (*(*v5 + 8))(v5);
  }

  v6 = *(this + 1);
  *(this + 1) = 0;
  if (v6)
  {
    (*(*v6 + 8))(v6);
  }
}

{
  sentencepiece::SentencePieceProcessor::~SentencePieceProcessor(this);

  JUMPOUT(0x1B8C85350);
}

void sub_1B5AAFFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, sentencepiece::ModelProto *a9, sentencepiece::ModelProto *a10)
{
  std::unique_ptr<sentencepiece::ModelProto>::reset[abi:ne200100](&a9, 0);
  std::unique_ptr<sentencepiece::ModelProto>::reset[abi:ne200100](&a10, 0);
  _Unwind_Resume(a1);
}

uint64_t sentencepiece::io::LoadModelProto@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (a1)
  {
    sentencepiece::filesystem::NewReadableFile();
  }

  return sentencepiece::util::Status::Status(a2, 5, "model file path should not be empty.");
}

void sub_1B5AB03D0(_Unwind_Exception *exception_object)
{
  if (*(v1 - 41) < 0)
  {
    operator delete(*(v1 - 64));
  }

  v3 = *(v1 - 40);
  *(v1 - 40) = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::SentencePieceProcessor::LoadOrDie(uint64_t a1)
{
  (*(*a1 + 16))(&v11);
  if (v11)
  {
    v10 = 1;
    v1 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "sentencepiece_processor.cc", 26);
    v2 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v1, "(", 1);
    v3 = MEMORY[0x1B8C84C00](v2, 62);
    v4 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v3, ") [", 3);
    v5 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v4, "_status.ok()", 12);
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v5, "] ", 2);
    sentencepiece::util::Status::ToString(&v11, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      p_p = &__p;
    }

    else
    {
      p_p = __p.__r_.__value_.__r.__words[0];
    }

    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = __p.__r_.__value_.__l.__size_;
    }

    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    sentencepiece::error::Die::~Die(&v10);
  }

  sentencepiece::util::Status::~Status(&v11);
}

void sub_1B5AB0558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  sentencepiece::error::Die::~Die((v15 - 25));
  sentencepiece::util::Status::~Status((v15 - 24));
  _Unwind_Resume(a1);
}

void sub_1B5AB0654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, sentencepiece::ModelProto *a9, sentencepiece::ModelProto *a10)
{
  std::unique_ptr<sentencepiece::ModelProto>::reset[abi:ne200100](&a9, 0);
  std::unique_ptr<sentencepiece::ModelProto>::reset[abi:ne200100](&a10, 0);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::Load(uint64_t a1, sentencepiece::ModelProto **a2)
{
  v3 = *a2;
  *a2 = 0;
  std::unique_ptr<sentencepiece::ModelProto>::reset[abi:ne200100]((a1 + 32), v3);
  sentencepiece::ModelFactory::Create(*(a1 + 32), &v7);
  first = v7.__first_;
  v7.__first_ = 0;
  v5 = *(a1 + 8);
  *(a1 + 8) = first;
  if (v5)
  {
    (*(*v5 + 8))(v5);
    v6 = v7.__first_;
    v7.__first_ = 0;
    if (v6)
    {
      (*(v6->__r_.__value_.__r.__words[0] + 8))(v6);
    }
  }

  absl::make_unique<sentencepiece::normalizer::Normalizer,sentencepiece::NormalizerSpec const&,sentencepiece::TrainerSpec const&>();
}

void sub_1B5AB1114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char **a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char *a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, char a28)
{
  sentencepiece::error::Die::~Die(&a28);
  a16 = &a22;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&a16);
  a22 = &a25;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&a22);
  _Unwind_Resume(a1);
}

void absl::StrCat<char [2],std::string,char [2],std::string>(void *__src@<X0>, size_t __len@<X1>, char *a3@<X2>, void **a4@<X3>, char *a5@<X4>, void **a6@<X5>, std::string *a7@<X8>)
{
  std::string::basic_string[abi:ne200100](&__dst, __src, __len);
  v12 = strlen(a3);
  absl::StrCat<std::string,char [2],std::string>(a3, v12, a4, a5, a6, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v15 = std::string::append(&__dst, p_p, size);
  *a7 = *v15;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_1B5AB1364(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (a20 < 0)
  {
    operator delete(a15);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::SentencePieceProcessor::ParseExtraOptions(sentencepiece::ModelInterface **a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, sentencepiece::util::Status *a5@<X8>)
{
  v34[20] = *MEMORY[0x1E69E9840];
  *(a4 + 8) = *a4;
  if (a3)
  {
    (*(*a1 + 7))(a1);
    if (!*a5)
    {
      sentencepiece::util::Status::~Status(a5);
      {
        v30[1] = xmmword_1E7C1C6B0;
        v30[2] = *&off_1E7C1C6C0;
        v31 = 0;
        v29 = xmmword_1E7C1C690;
        v30[0] = unk_1E7C1C6A0;
        std::map<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>::map[abi:ne200100](&sentencepiece::SentencePieceProcessor::ParseExtraOptions(absl::string_view,std::vector<sentencepiece::SentencePieceProcessor::ExtraOption> *)const::extra_option_map, &v29, 3);
        __cxa_atexit(std::map<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>::~map[abi:ne200100], &sentencepiece::SentencePieceProcessor::ParseExtraOptions(absl::string_view,std::vector<sentencepiece::SentencePieceProcessor::ExtraOption> *)const::extra_option_map, &dword_1B501D000);
      }

      absl::internal::Splitter::Splitter(&v27, a2, a3, ":", 1, 0);
      v10 = v27;
      v11 = v28;
      if (v27 == v28)
      {
LABEL_19:
        if (v10)
        {
          v28 = v10;
          operator delete(v10);
        }

        marisa::Trie::Trie(a5);
      }

      else
      {
        while (1)
        {
          v12 = std::__tree<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::__map_value_compare<absl::string_view,std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::less<absl::string_view>,true>,std::allocator<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>>>::find<absl::string_view>(&sentencepiece::SentencePieceProcessor::ParseExtraOptions(absl::string_view,std::vector<sentencepiece::SentencePieceProcessor::ExtraOption> *)const::extra_option_map, v10);
          v13 = v12;
          if (v12 == &unk_1EB909598)
          {
            break;
          }

          std::vector<int>::push_back[abi:ne200100](a4, (v12 + 48));
          v14 = *(v13 + 48);
          if (v14 == 1)
          {
            v15 = sentencepiece::ModelInterface::bos_piece(a1[1]);
            v16 = v15;
            if (v15)
            {
              v17 = strlen(v15);
            }

            else
            {
              v17 = 0;
            }

            v18 = (*(*a1 + 44))(a1, v16, v17);
            if ((*(*a1 + 47))(a1, v18))
            {
              LODWORD(v29) = 13;
              std::ostringstream::basic_ostringstream[abi:ne200100](&v29 + 1);
              std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
              std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "(", 1);
              MEMORY[0x1B8C84C00](&v29 + 8, 843);
              std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, ") [", 3);
              std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "!IsUnknown(PieceToId(absl::string_view(model_->bos_piece().data())))", 68);
              std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "] ", 2);
              v23 = sentencepiece::ModelInterface::bos_piece(a1[1]);
              absl::operator<<(&v29 + 1, v23, v24);
              sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v29, a5);
              goto LABEL_30;
            }

            v14 = *(v13 + 48);
          }

          if (v14 == 2)
          {
            v19 = sentencepiece::ModelInterface::eos_piece(a1[1]);
            v20 = v19;
            v21 = v19 ? strlen(v19) : 0;
            v22 = (*(*a1 + 44))(a1, v20, v21);
            if ((*(*a1 + 47))(a1, v22))
            {
              LODWORD(v29) = 13;
              std::ostringstream::basic_ostringstream[abi:ne200100](&v29 + 1);
              std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
              std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "(", 1);
              MEMORY[0x1B8C84C00](&v29 + 8, 848);
              std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, ") [", 3);
              std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "!IsUnknown(PieceToId(absl::string_view(model_->eos_piece().data())))", 68);
              std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "] ", 2);
              v25 = sentencepiece::ModelInterface::eos_piece(a1[1]);
              absl::operator<<(&v29 + 1, v25, v26);
              sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v29, a5);
LABEL_30:
              *(&v29 + 1) = *MEMORY[0x1E69E54E8];
              *(&v29 + *(*(&v29 + 1) - 24) + 8) = *(MEMORY[0x1E69E54E8] + 24);
              *&v30[0] = MEMORY[0x1E69E5548] + 16;
              if (v33 < 0)
              {
                operator delete(__p);
              }

              goto LABEL_32;
            }
          }

          v10 += 2;
          if (v10 == v11)
          {
            v10 = v27;
            goto LABEL_19;
          }
        }

        LODWORD(v29) = 13;
        std::ostringstream::basic_ostringstream[abi:ne200100](&v29 + 1);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "(", 1);
        MEMORY[0x1B8C84C00](&v29 + 8, 837);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, ") [", 3);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "it != extra_option_map.end()", 28);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "] ", 2);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, "option ", 8);
        absl::operator<<(&v29 + 1, *v10, v10[1]);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v29 + 1, " is not available.", 19);
        sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v29, a5);
        *(&v29 + 1) = *MEMORY[0x1E69E54E8];
        *(&v29 + *(*(&v29 + 1) - 24) + 8) = *(MEMORY[0x1E69E54E8] + 24);
        *&v30[0] = MEMORY[0x1E69E5548] + 16;
        if (v33 < 0)
        {
          operator delete(__p);
        }

LABEL_32:
        *&v30[0] = MEMORY[0x1E69E5538] + 16;
        std::locale::~locale(v30 + 1);
        std::ostream::~ostream();
        MEMORY[0x1B8C85200](v34);
        if (v27)
        {
          v28 = v27;
          operator delete(v27);
        }
      }
    }
  }

  else
  {

    marisa::Trie::Trie(a5);
  }
}

void *sentencepiece::SentencePieceProcessor::status@<X0>(sentencepiece::SentencePieceProcessor *this@<X0>, sentencepiece::util::Status *a2@<X8>)
{
  v4 = *(this + 1);
  if (v4)
  {
    if (*(this + 2))
    {
      result = (*(*v4 + 16))(v4);
      if (!*a2)
      {
        sentencepiece::util::Status::~Status(a2);
        result = (*(**(this + 2) + 24))(*(this + 2));
        if (!*a2)
        {
          sentencepiece::util::Status::~Status(a2);

          return marisa::Trie::Trie(v6);
        }
      }

      return result;
    }

    v9 = 13;
    v8 = std::ostringstream::basic_ostringstream[abi:ne200100](&v10);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "(", 1);
    MEMORY[0x1B8C84C00](&v10, 141);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, ") [", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "normalizer_", 11);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "] ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "Normalizer is not initialized.", 30);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v9, a2);
  }

  else
  {
    v9 = 13;
    v7 = std::ostringstream::basic_ostringstream[abi:ne200100](&v10);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v7, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "(", 1);
    MEMORY[0x1B8C84C00](&v10, 140);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, ") [", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "model_", 6);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "] ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "Model is not initialized.", 25);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v9, a2);
  }

  v10 = *MEMORY[0x1E69E54E8];
  *(&v10 + *(v10 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v11 = MEMORY[0x1E69E5548] + 16;
  if (v13 < 0)
  {
    operator delete(v12[7].__locale_);
  }

  v11 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v12);
  std::ostream::~ostream();
  return MEMORY[0x1B8C85200](&v14);
}

void sentencepiece::SentencePieceProcessor::SetVocabulary(void *a1@<X0>, const void ***a2@<X1>, sentencepiece::util::Status *a3@<X8>)
{
  (*(*a1 + 56))(a1);
  if (!*a3)
  {
    sentencepiece::util::Status::~Status(a3);
    v6 = *(a1[4] + 72);
    if (!v6)
    {
      v6 = &sentencepiece::_TrainerSpec_default_instance_;
    }

    if ((v6[62] - 1) >= 2)
    {
      LODWORD(v15) = 13;
      v14 = std::ostringstream::basic_ostringstream[abi:ne200100](&v16);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v14, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, "(", 1);
      MEMORY[0x1B8C84C00](&v16, 153);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, "type == TrainerSpec::UNIGRAM || type == TrainerSpec::BPE", 56);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, "Vocabulary constraint is only enabled in subword units.", 55);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v15, a3);
      v16 = *MEMORY[0x1E69E54E8];
      *(&v16 + *(v16 - 3)) = *(MEMORY[0x1E69E54E8] + 24);
      v17 = MEMORY[0x1E69E5548] + 16;
      if (v19 < 0)
      {
        operator delete(v18[7].__locale_);
      }

      v17 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(v18);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](&v20);
    }

    else
    {
      std::set<std::string>::set[abi:ne200100]<std::__wrap_iter<std::string const*>>(&v15, *a2, a2[1]);
      v7 = a1[4];
      if (*(v7 + 56) >= 1)
      {
        v8 = 0;
        do
        {
          v9 = *(*(v7 + 64) + 8 * v8 + 8);
          if ((*(v9 + 60) - 2) >= 3)
          {
            if (&v16 == std::__tree<std::__value_type<std::string,double>,std::__map_value_compare<std::string,std::__value_type<std::string,double>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,double>>>::find<std::string>(&v15, (*(v9 + 48) & 0xFFFFFFFFFFFFFFFELL)))
            {
              v11 = *(v9 + 48) & 0xFFFFFFFFFFFFFFFELL;
              v12 = *(v11 + 23);
              if (v12 < 0)
              {
                v13 = *v11;
                v12 = *(v11 + 8);
              }

              else
              {
                v13 = (*(v9 + 48) & 0xFFFFFFFFFFFFFFFELL);
              }

              if (v12 == asc_1B5C6FEAB[*v13 >> 4])
              {
                v10 = 1;
              }

              else
              {
                v10 = 5;
              }
            }

            else
            {
              v10 = 1;
            }

            *(v9 + 40) |= 4u;
            *(v9 + 60) = v10;
          }

          ++v8;
          v7 = a1[4];
        }

        while (v8 < *(v7 + 56));
      }

      marisa::Trie::Trie(a3);
      std::__tree<std::string>::destroy(&v15, v16);
    }
  }
}

void *sentencepiece::SentencePieceProcessor::ResetVocabulary@<X0>(sentencepiece::SentencePieceProcessor *this@<X0>, sentencepiece::util::Status *a2@<X8>)
{
  result = (*(*this + 56))(this);
  if (!*a2)
  {
    sentencepiece::util::Status::~Status(a2);
    v5 = *(this + 4);
    v6 = *(v5 + 64);
    if (v6)
    {
      v7 = (v6 + 8);
    }

    else
    {
      v7 = 0;
    }

    v8 = *(v5 + 56);
    if (v8)
    {
      v9 = 8 * v8;
      do
      {
        v10 = *v7;
        if (*(*v7 + 60) == 5)
        {
          *(v10 + 40) |= 4u;
          *(v10 + 60) = 1;
        }

        ++v7;
        v9 -= 8;
      }

      while (v9);
    }

    return marisa::Trie::Trie(a2);
  }

  return result;
}

void sub_1B5AB2998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  __p = (v10 - 176);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&__p);
  __p = (v10 - 152);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&__p);
  if (*(v10 - 105) < 0)
  {
    operator delete(*(v10 - 128));
  }

  v12 = *(v10 - 104);
  *(v10 - 104) = 0;
  if (v12)
  {
    (*(*v12 + 8))(v12);
  }

  _Unwind_Resume(a1);
}

BOOL absl::SimpleAtoi<int>(const char *a1, uint64_t a2, uint64_t a3)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne200100](v11);
  v5 = strlen(a1);
  v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v12, a1, v5);
  if ((*(v6 + *(*v6 - 24) + 32) & 5) != 0)
  {
    v7 = 0;
  }

  else
  {
    v8 = MEMORY[0x1B8C84AE0](v11, a3);
    v7 = (*(v8 + *(*v8 - 24) + 32) & 5) == 0;
  }

  v11[0] = *MEMORY[0x1E69E54D8];
  v9 = *(MEMORY[0x1E69E54D8] + 72);
  *(v11 + *(v11[0] - 24)) = *(MEMORY[0x1E69E54D8] + 64);
  v12 = v9;
  v13 = MEMORY[0x1E69E5548] + 16;
  if (v15 < 0)
  {
    operator delete(v14[7].__locale_);
  }

  v13 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v14);
  std::iostream::~basic_iostream();
  MEMORY[0x1B8C85200](&v16);
  return v7;
}

void sub_1B5AB2C7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::Encode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, sentencepiece::util::Status *a5@<X8>)
{
  (*(*a1 + 56))(a1);
  if (!*a5)
  {
    sentencepiece::util::Status::~Status(a5);
    if (a4)
    {
      std::vector<std::string>::clear[abi:ne200100](a4);
      sentencepiece::SentencePieceText::SentencePieceText(&v15, 0);
      (*(*a1 + 184))(a1, a2, a3, &v15);
      if (!*a5)
      {
        sentencepiece::util::Status::~Status(a5);
        if (v20)
        {
          v10 = v20 + 8;
        }

        else
        {
          v10 = 0;
        }

        if (v19)
        {
          v11 = *(a4 + 8);
          v12 = 8 * v19;
          do
          {
            v13 = *(*v10 + 48);
            if (v11 >= *(a4 + 16))
            {
              v11 = std::vector<std::string>::__emplace_back_slow_path<std::string const&>(a4, (v13 & 0xFFFFFFFFFFFFFFFELL));
            }

            else
            {
              std::vector<std::string>::__construct_one_at_end[abi:ne200100]<std::string const&>(a4, (v13 & 0xFFFFFFFFFFFFFFFELL));
              ++v11;
            }

            *(a4 + 8) = v11;
            v10 += 8;
            v12 -= 8;
          }

          while (v12);
        }

        marisa::Trie::Trie(a5);
      }

      sentencepiece::SentencePieceText::~SentencePieceText(&v15);
    }

    else
    {
      v15 = 13;
      v14 = std::ostringstream::basic_ostringstream[abi:ne200100](&v16);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v14, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, "(", 1);
      MEMORY[0x1B8C84C00](&v16, 226);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, "pieces", 6);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v16, "output container is null", 24);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v15, a5);
      v16 = *MEMORY[0x1E69E54E8];
      *(&v16 + *(v16 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
      v17 = MEMORY[0x1E69E5548] + 16;
      if (v22 < 0)
      {
        operator delete(__p);
      }

      v17 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(&v18);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](&v23);
    }
  }
}

void sentencepiece::SentencePieceProcessor::Encode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, sentencepiece::util::Status *a5@<X8>)
{
  (*(*a1 + 56))(a1);
  if (!*a5)
  {
    sentencepiece::util::Status::~Status(a5);
    if (a4)
    {
      a4[1] = *a4;
      sentencepiece::SentencePieceText::SentencePieceText(&v23, 0);
      (*(*a1 + 184))(a1, a2, a3, &v23);
      if (!*a5)
      {
        sentencepiece::util::Status::~Status(a5);
        if (v28)
        {
          v10 = v28 + 8;
        }

        else
        {
          v10 = 0;
        }

        if (v27)
        {
          v11 = a4[1];
          v12 = 8 * v27;
          do
          {
            v13 = *(*v10 + 64);
            v14 = a4[2];
            if (v11 >= v14)
            {
              v15 = *a4;
              v16 = v11 - *a4;
              v17 = v16 >> 2;
              v18 = (v16 >> 2) + 1;
              if (v18 >> 62)
              {
                std::vector<int>::__throw_length_error[abi:ne200100]();
              }

              v19 = v14 - v15;
              if (v19 >> 1 > v18)
              {
                v18 = v19 >> 1;
              }

              if (v19 >= 0x7FFFFFFFFFFFFFFCLL)
              {
                v20 = 0x3FFFFFFFFFFFFFFFLL;
              }

              else
              {
                v20 = v18;
              }

              if (v20)
              {
                std::__allocate_at_least[abi:ne200100]<std::allocator<int>>(a4, v20);
              }

              *(4 * v17) = v13;
              v11 = (4 * v17 + 4);
              memcpy(0, v15, v16);
              v21 = *a4;
              *a4 = 0;
              a4[1] = v11;
              a4[2] = 0;
              if (v21)
              {
                operator delete(v21);
              }
            }

            else
            {
              *v11++ = v13;
            }

            a4[1] = v11;
            v10 += 8;
            v12 -= 8;
          }

          while (v12);
        }

        marisa::Trie::Trie(a5);
      }

      sentencepiece::SentencePieceText::~SentencePieceText(&v23);
    }

    else
    {
      v23 = 13;
      v22 = std::ostringstream::basic_ostringstream[abi:ne200100](&v24);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v22, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v24, "(", 1);
      MEMORY[0x1B8C84C00](&v24, 239);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v24, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v24, "ids", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v24, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v24, "output container is null", 24);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v23, a5);
      v24 = *MEMORY[0x1E69E54E8];
      *(&v24 + *(v24 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
      v25 = MEMORY[0x1E69E5548] + 16;
      if (v30 < 0)
      {
        operator delete(__p);
      }

      v25 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(&v26);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](&v31);
    }
  }
}

void sub_1B5AB3338(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::StatusBuilder::~StatusBuilder(va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::Decode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, sentencepiece::util::Status *a4@<X8>)
{
  (*(*a1 + 56))(a1);
  if (!*a4)
  {
    sentencepiece::util::Status::~Status(a4);
    if (a3)
    {
      if (*(a3 + 23) < 0)
      {
        **a3 = 0;
        *(a3 + 8) = 0;
      }

      else
      {
        *a3 = 0;
        *(a3 + 23) = 0;
      }

      sentencepiece::SentencePieceText::SentencePieceText(&v9, 0);
      (*(*a1 + 224))(a1, a2, &v9);
      if (!*a4)
      {
        sentencepiece::util::Status::~Status(a4);
        std::string::operator=(a3, (v12[6].__locale_ & 0xFFFFFFFFFFFFFFFELL));
        marisa::Trie::Trie(a4);
      }

      sentencepiece::SentencePieceText::~SentencePieceText(&v9);
    }

    else
    {
      v9 = 13;
      v8 = std::ostringstream::basic_ostringstream[abi:ne200100](&v10);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "(", 1);
      MEMORY[0x1B8C84C00](&v10, 252);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "detokenized", 11);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "output container is null", 24);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v9, a4);
      v10 = *MEMORY[0x1E69E54E8];
      *(&v10 + *(v10 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
      v11 = MEMORY[0x1E69E5548] + 16;
      if (v13 < 0)
      {
        operator delete(v12[7].__locale_);
      }

      v11 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(v12);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](&v14);
    }
  }
}

{
  (*(*a1 + 56))(a1);
  if (!*a4)
  {
    sentencepiece::util::Status::~Status(a4);
    if (a3)
    {
      if (*(a3 + 23) < 0)
      {
        **a3 = 0;
        *(a3 + 8) = 0;
      }

      else
      {
        *a3 = 0;
        *(a3 + 23) = 0;
      }

      sentencepiece::SentencePieceText::SentencePieceText(&v9, 0);
      (*(*a1 + 232))(a1, a2, &v9);
      if (!*a4)
      {
        sentencepiece::util::Status::~Status(a4);
        std::string::operator=(a3, (v12[6].__locale_ & 0xFFFFFFFFFFFFFFFELL));
        marisa::Trie::Trie(a4);
      }

      sentencepiece::SentencePieceText::~SentencePieceText(&v9);
    }

    else
    {
      v9 = 13;
      v8 = std::ostringstream::basic_ostringstream[abi:ne200100](&v10);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "(", 1);
      MEMORY[0x1B8C84C00](&v10, 263);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "detokenized", 11);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v10, "output container is null", 24);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v9, a4);
      v10 = *MEMORY[0x1E69E54E8];
      *(&v10 + *(v10 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
      v11 = MEMORY[0x1E69E5548] + 16;
      if (v13 < 0)
      {
        operator delete(v12[7].__locale_);
      }

      v11 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(v12);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](&v14);
    }
  }
}

void sentencepiece::SentencePieceProcessor::NBestEncode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void ***a5@<X4>, sentencepiece::util::Status *a6@<X8>)
{
  (*(*a1 + 56))(a1);
  if (!*a6)
  {
    sentencepiece::util::Status::~Status(a6);
    if (a5)
    {
      v12 = *a5;
      v13 = a5[1];
      while (v13 != v12)
      {
        v13 -= 3;
        v30 = v13;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v30);
      }

      a5[1] = v12;
      sentencepiece::NBestSentencePieceText::NBestSentencePieceText(&v30, 0);
      (*(*a1 + 192))(a1, a2, a3, a4, &v30);
      if (!*a6)
      {
        sentencepiece::util::Status::~Status(a6);
        if (v34)
        {
          v14 = (v34 + 8);
        }

        else
        {
          v14 = 0;
        }

        if (LODWORD(v33.__locale_))
        {
          v15 = &v14[SLODWORD(v33.__locale_)];
          do
          {
            v16 = *v14;
            v27 = 0;
            v28 = 0;
            v29 = 0;
            v17 = *(v16 + 64);
            if (v17)
            {
              v18 = v17 + 8;
            }

            else
            {
              v18 = 0;
            }

            v19 = *(v16 + 56);
            if (v19)
            {
              v20 = 0;
              v21 = 8 * v19;
              do
              {
                v22 = *(*v18 + 48) & 0xFFFFFFFFFFFFFFFELL;
                if (v20 >= v29)
                {
                  v20 = std::vector<std::string>::__emplace_back_slow_path<std::string const&>(&v27, v22);
                }

                else
                {
                  if (*(v22 + 23) < 0)
                  {
                    std::string::__init_copy_ctor_external(v20, *v22, *(v22 + 8));
                  }

                  else
                  {
                    v23 = *v22;
                    v20->__r_.__value_.__r.__words[2] = *(v22 + 16);
                    *&v20->__r_.__value_.__l.__data_ = v23;
                  }

                  ++v20;
                }

                v28 = v20;
                v18 += 8;
                v21 -= 8;
              }

              while (v21);
            }

            v24 = a5[1];
            if (v24 >= a5[2])
            {
              v25 = std::vector<std::vector<std::string>>::__emplace_back_slow_path<std::vector<std::string>&>(a5, &v27);
            }

            else
            {
              std::vector<std::vector<std::string>>::__construct_one_at_end[abi:ne200100]<std::vector<std::string>&>(a5, &v27);
              v25 = (v24 + 3);
            }

            a5[1] = v25;
            v38 = &v27;
            std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v38);
            ++v14;
          }

          while (v14 != v15);
        }

        marisa::Trie::Trie(a6);
      }

      sentencepiece::NBestSentencePieceText::~NBestSentencePieceText(&v30);
    }

    else
    {
      LODWORD(v30) = 13;
      v26 = std::ostringstream::basic_ostringstream[abi:ne200100](&v31);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v26, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v31, "(", 1);
      MEMORY[0x1B8C84C00](&v31, 275);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v31, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v31, "pieces", 6);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v31, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v31, "output container is null", 24);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v30, a6);
      v31 = *MEMORY[0x1E69E54E8];
      *(&v31 + *(v31 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
      v32 = MEMORY[0x1E69E5548] + 16;
      if (v36 < 0)
      {
        operator delete(__p);
      }

      v32 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(&v33);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](&v37);
    }
  }
}

void sub_1B5AB3CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sentencepiece::util::StatusBuilder::~StatusBuilder(va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::NBestEncode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, sentencepiece::util::Status *a6@<X8>)
{
  (*(*a1 + 56))(a1);
  if (!*a6)
  {
    sentencepiece::util::Status::~Status(a6);
    if (a5)
    {
      std::vector<std::vector<int>>::clear[abi:ne200100](a5);
      sentencepiece::NBestSentencePieceText::NBestSentencePieceText(&v37, 0);
      (*(*a1 + 192))(a1, a2, a3, a4, &v37);
      if (!*a6)
      {
        sentencepiece::util::Status::~Status(a6);
        if (v41)
        {
          v12 = (v41 + 8);
        }

        else
        {
          v12 = 0;
        }

        if (LODWORD(v40.__locale_))
        {
          v33 = &v12[SLODWORD(v40.__locale_)];
          do
          {
            v13 = *v12;
            __src = 0;
            v35 = 0;
            v36 = 0;
            v14 = *(v13 + 64);
            if (v14)
            {
              v15 = v14 + 8;
            }

            else
            {
              v15 = 0;
            }

            v16 = *(v13 + 56);
            if (v16)
            {
              v17 = 0;
              v18 = 8 * v16;
              do
              {
                v19 = *(*v15 + 64);
                if (v17 >= v36)
                {
                  v20 = __src;
                  v21 = v17 - __src;
                  v22 = (v17 - __src) >> 2;
                  v23 = v22 + 1;
                  if ((v22 + 1) >> 62)
                  {
                    std::vector<int>::__throw_length_error[abi:ne200100]();
                  }

                  v24 = v36 - __src;
                  if ((v36 - __src) >> 1 > v23)
                  {
                    v23 = v24 >> 1;
                  }

                  if (v24 >= 0x7FFFFFFFFFFFFFFCLL)
                  {
                    v25 = 0x3FFFFFFFFFFFFFFFLL;
                  }

                  else
                  {
                    v25 = v23;
                  }

                  if (v25)
                  {
                    std::__allocate_at_least[abi:ne200100]<std::allocator<int>>(&__src, v25);
                  }

                  v26 = (v17 - __src) >> 2;
                  v27 = (4 * v22);
                  v28 = (4 * v22 - 4 * v26);
                  *v27 = v19;
                  v17 = (v27 + 1);
                  memcpy(v28, v20, v21);
                  v29 = __src;
                  __src = v28;
                  v35 = v17;
                  v36 = 0;
                  if (v29)
                  {
                    operator delete(v29);
                  }
                }

                else
                {
                  *v17 = v19;
                  v17 += 4;
                }

                v35 = v17;
                v15 += 8;
                v18 -= 8;
              }

              while (v18);
            }

            v30 = a5[1];
            if (v30 >= a5[2])
            {
              v31 = std::vector<std::vector<int>>::__emplace_back_slow_path<std::vector<int>&>(a5, &__src);
            }

            else
            {
              std::vector<std::vector<int>>::__construct_one_at_end[abi:ne200100]<std::vector<int>&>(a5, &__src);
              v31 = v30 + 24;
            }

            a5[1] = v31;
            if (__src)
            {
              v35 = __src;
              operator delete(__src);
            }

            ++v12;
          }

          while (v12 != v33);
        }

        marisa::Trie::Trie(a6);
      }

      sentencepiece::NBestSentencePieceText::~NBestSentencePieceText(&v37);
    }

    else
    {
      v37 = 13;
      v32 = std::ostringstream::basic_ostringstream[abi:ne200100](&v38);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v32, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v38, "(", 1);
      MEMORY[0x1B8C84C00](&v38, 293);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v38, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v38, "ids", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v38, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v38, "output container is null", 24);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v37, a6);
      v38 = *MEMORY[0x1E69E54E8];
      *(&v38 + *(v38 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
      v39 = MEMORY[0x1E69E5548] + 16;
      if (v43 < 0)
      {
        operator delete(__p);
      }

      v39 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(&v40);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](&v44);
    }
  }
}

void sentencepiece::SentencePieceProcessor::SampleEncode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, sentencepiece::util::Status *a6@<X8>, float a7@<S0>)
{
  (*(*a1 + 56))(a1);
  if (!*a6)
  {
    sentencepiece::util::Status::~Status(a6);
    if (a5)
    {
      std::vector<std::string>::clear[abi:ne200100](a5);
      sentencepiece::SentencePieceText::SentencePieceText(&v19, 0);
      (*(*a1 + 200))(a1, a2, a3, a4, &v19, a7);
      if (!*a6)
      {
        sentencepiece::util::Status::~Status(a6);
        if (v24)
        {
          v14 = v24 + 8;
        }

        else
        {
          v14 = 0;
        }

        if (v23)
        {
          v15 = *(a5 + 8);
          v16 = 8 * v23;
          do
          {
            v17 = *(*v14 + 48);
            if (v15 >= *(a5 + 16))
            {
              v15 = std::vector<std::string>::__emplace_back_slow_path<std::string const&>(a5, (v17 & 0xFFFFFFFFFFFFFFFELL));
            }

            else
            {
              std::vector<std::string>::__construct_one_at_end[abi:ne200100]<std::string const&>(a5, (v17 & 0xFFFFFFFFFFFFFFFELL));
              ++v15;
            }

            *(a5 + 8) = v15;
            v14 += 8;
            v16 -= 8;
          }

          while (v16);
        }

        marisa::Trie::Trie(a6);
      }

      sentencepiece::SentencePieceText::~SentencePieceText(&v19);
    }

    else
    {
      v19 = 13;
      v18 = std::ostringstream::basic_ostringstream[abi:ne200100](&v20);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v18, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v20, "(", 1);
      MEMORY[0x1B8C84C00](&v20, 311);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v20, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v20, "pieces", 6);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v20, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v20, "output container is null", 24);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v19, a6);
      v20 = *MEMORY[0x1E69E54E8];
      *(&v20 + *(v20 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
      v21 = MEMORY[0x1E69E5548] + 16;
      if (v26 < 0)
      {
        operator delete(__p);
      }

      v21 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(&v22);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](&v27);
    }
  }
}

void sentencepiece::SentencePieceProcessor::SampleEncode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X4>, sentencepiece::util::Status *a6@<X8>, float a7@<S0>)
{
  (*(*a1 + 56))(a1);
  if (!*a6)
  {
    sentencepiece::util::Status::~Status(a6);
    if (a5)
    {
      a5[1] = *a5;
      sentencepiece::SentencePieceText::SentencePieceText(&v27, 0);
      (*(*a1 + 200))(a1, a2, a3, a4, &v27, a7);
      if (!*a6)
      {
        sentencepiece::util::Status::~Status(a6);
        if (v32)
        {
          v14 = v32 + 8;
        }

        else
        {
          v14 = 0;
        }

        if (v31)
        {
          v15 = a5[1];
          v16 = 8 * v31;
          do
          {
            v17 = *(*v14 + 64);
            v18 = a5[2];
            if (v15 >= v18)
            {
              v19 = *a5;
              v20 = v15 - *a5;
              v21 = v20 >> 2;
              v22 = (v20 >> 2) + 1;
              if (v22 >> 62)
              {
                std::vector<int>::__throw_length_error[abi:ne200100]();
              }

              v23 = v18 - v19;
              if (v23 >> 1 > v22)
              {
                v22 = v23 >> 1;
              }

              if (v23 >= 0x7FFFFFFFFFFFFFFCLL)
              {
                v24 = 0x3FFFFFFFFFFFFFFFLL;
              }

              else
              {
                v24 = v22;
              }

              if (v24)
              {
                std::__allocate_at_least[abi:ne200100]<std::allocator<int>>(a5, v24);
              }

              *(4 * v21) = v17;
              v15 = (4 * v21 + 4);
              memcpy(0, v19, v20);
              v25 = *a5;
              *a5 = 0;
              a5[1] = v15;
              a5[2] = 0;
              if (v25)
              {
                operator delete(v25);
              }
            }

            else
            {
              *v15++ = v17;
            }

            a5[1] = v15;
            v14 += 8;
            v16 -= 8;
          }

          while (v16);
        }

        marisa::Trie::Trie(a6);
      }

      sentencepiece::SentencePieceText::~SentencePieceText(&v27);
    }

    else
    {
      v27 = 13;
      v26 = std::ostringstream::basic_ostringstream[abi:ne200100](&v28);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v26, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v28, "(", 1);
      MEMORY[0x1B8C84C00](&v28, 325);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v28, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v28, "ids", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v28, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v28, "output container is null", 24);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v27, a6);
      v28 = *MEMORY[0x1E69E54E8];
      *(&v28 + *(v28 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
      v29 = MEMORY[0x1E69E5548] + 16;
      if (v34 < 0)
      {
        operator delete(__p);
      }

      v29 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(&v30);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](&v35);
    }
  }
}

void sub_1B5AB485C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::StatusBuilder::~StatusBuilder(va);
  _Unwind_Resume(a1);
}

void *sentencepiece::SentencePieceProcessor::PopulateSentencePieceText@<X0>(void **a1@<X0>, char *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X4>, uint64_t *a5@<X5>, unsigned __int8 ***a6@<X6>, uint64_t a7@<X7>, sentencepiece::util::Status *a8@<X8>)
{
  v10 = *a6;
  v86 = a6[1];
  if (*a6 != v86)
  {
    v11 = 0;
    v12 = 0;
    while (1)
    {
      v13 = v10[1];
      if (!v13)
      {
        LODWORD(__p[0]) = 13;
        v76 = std::ostringstream::basic_ostringstream[abi:ne200100](&__p[1]);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v76, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(", 1);
        MEMORY[0x1B8C84C00](&__p[1], 346);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], ") [", 3);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "!w.empty()", 10);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "] ", 2);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "Empty piece is not allowed.", 27);
        sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(__p, a8);
        goto LABEL_128;
      }

      v14 = *v10;
      v15 = *(v10 + 4);
      v88 = ((*a1)[47])(a1, v15);
      if (!((*a1)[48])(a1, v15))
      {
        break;
      }

      v16 = *(a7 + 64);
      if (!v16)
      {
        v18 = *(a7 + 60);
        goto LABEL_54;
      }

      v17 = *(a7 + 56);
      v18 = *v16;
      if (v17 >= *v16)
      {
        if (v18 == *(a7 + 60))
        {
LABEL_54:
          google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a7 + 48), v18 + 1);
          v16 = *(a7 + 64);
          v18 = *v16;
        }

        *v16 = v18 + 1;
        v19 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText_SentencePiece>(*(a7 + 48));
        v45 = *(a7 + 56);
        v46 = *(a7 + 64) + 8 * v45;
        *(a7 + 56) = v45 + 1;
        *(v46 + 8) = v19;
        goto LABEL_56;
      }

      *(a7 + 56) = v17 + 1;
      v19 = *&v16[2 * v17 + 2];
LABEL_56:
      *(v19 + 40) |= 1u;
      std::string::basic_string[abi:ne200100](__p, v14, v13);
      v47 = *(v19 + 8);
      if (v47)
      {
        v47 = *(v47 & 0xFFFFFFFFFFFFFFFELL);
      }

      google::protobuf::internal::ArenaStringPtr::Set((v19 + 48), __p, v47);
      if (SHIBYTE(v93) < 0)
      {
        operator delete(__p[0]);
      }

      v48 = *(v19 + 40);
      *(v19 + 64) = v15;
      v24 = *(*a5 + 8 * v11);
      *(v19 + 68) = v24;
      *(v19 + 40) = v48 | 0x1C;
LABEL_81:
      *(v19 + 72) = v24;
      v22 = v11;
LABEL_82:
      v10 += 3;
      v12 = v88;
      if (v10 == v86)
      {
        goto LABEL_114;
      }
    }

    v20 = *a5;
    v21 = a5[1] - *a5;
    if (v11 >= v21 >> 3)
    {
      LODWORD(__p[0]) = 13;
      v77 = std::ostringstream::basic_ostringstream[abi:ne200100](&__p[1]);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v77, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(", 1);
      MEMORY[0x1B8C84C00](&__p[1], 360);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(begin) < (norm_to_orig.size())", 31);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "] ", 2);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(__p, a8);
      goto LABEL_128;
    }

    v22 = v13 + v11;
    if (v13 + v11 >= v21 >> 3)
    {
      LODWORD(__p[0]) = 13;
      v78 = std::ostringstream::basic_ostringstream[abi:ne200100](&__p[1]);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v78, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(", 1);
      MEMORY[0x1B8C84C00](&__p[1], 361);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(end) < (norm_to_orig.size())", 29);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "] ", 2);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(__p, a8);
      goto LABEL_128;
    }

    v23 = *(v20 + 8 * v11);
    if (a3 < v23)
    {
      LODWORD(__p[0]) = 13;
      v79 = std::ostringstream::basic_ostringstream[abi:ne200100](&__p[1]);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v79, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(", 1);
      MEMORY[0x1B8C84C00](&__p[1], 364);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(orig_begin) <= (input.size())", 30);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "] ", 2);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(__p, a8);
      goto LABEL_128;
    }

    v24 = *(v20 + 8 * v22);
    if (v24 > a3)
    {
      LODWORD(__p[0]) = 13;
      v80 = std::ostringstream::basic_ostringstream[abi:ne200100](&__p[1]);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v80, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(", 1);
      MEMORY[0x1B8C84C00](&__p[1], 365);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(orig_end) <= (input.size())", 28);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "] ", 2);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(__p, a8);
      goto LABEL_128;
    }

    if (v24 < v23)
    {
      LODWORD(__p[0]) = 13;
      v81 = std::ostringstream::basic_ostringstream[abi:ne200100](&__p[1]);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v81, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(", 1);
      MEMORY[0x1B8C84C00](&__p[1], 366);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(orig_begin) <= (orig_end)", 26);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "] ", 2);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(__p, a8);
      goto LABEL_128;
    }

    if (a3 - v23 >= v24 - v23)
    {
      v25 = v24 - v23;
    }

    else
    {
      v25 = a3 - v23;
    }

    __len = v25;
    __src = &a2[v23];
    if (v88)
    {
      if ((*(*a1[1] + 200))(a1[1]))
      {
        while (1)
        {
          v27 = *v14++;
          v26 = v27;
          v28 = *(a7 + 64);
          if (!v28)
          {
            break;
          }

          v29 = *(a7 + 56);
          v30 = *v28;
          if (v29 >= *v28)
          {
            if (v30 == *(a7 + 60))
            {
LABEL_23:
              google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a7 + 48), v30 + 1);
              v28 = *(a7 + 64);
              v30 = *v28;
            }

            *v28 = v30 + 1;
            v31 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText_SentencePiece>(*(a7 + 48));
            v32 = *(a7 + 56);
            v33 = *(a7 + 64) + 8 * v32;
            *(a7 + 56) = v32 + 1;
            *(v33 + 8) = v31;
            goto LABEL_25;
          }

          *(a7 + 56) = v29 + 1;
          v31 = *&v28[2 * v29 + 2];
LABEL_25:
          sentencepiece::ByteToPiece(v26, &__dst);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_dst = &__dst;
          }

          else
          {
            p_dst = __dst.__r_.__value_.__r.__words[0];
          }

          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __dst.__r_.__value_.__l.__size_;
          }

          v36 = (*(*a1[1] + 128))(a1[1], p_dst, size);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            v37 = &__dst;
          }

          else
          {
            v37 = __dst.__r_.__value_.__r.__words[0];
          }

          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            v38 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          }

          else
          {
            v38 = __dst.__r_.__value_.__l.__size_;
          }

          *(v31 + 40) |= 1u;
          std::string::basic_string[abi:ne200100](__p, v37, v38);
          v39 = *(v31 + 8);
          if (v39)
          {
            v39 = *(v39 & 0xFFFFFFFFFFFFFFFELL);
          }

          google::protobuf::internal::ArenaStringPtr::Set((v31 + 48), __p, v39);
          if (SHIBYTE(v93) < 0)
          {
            operator delete(__p[0]);
          }

          v40 = *(v31 + 40);
          *(v31 + 40) = v40 | 4;
          *(v31 + 64) = v36;
          if (v13 == 1)
          {
            *(v31 + 40) = v40 | 6;
            std::string::basic_string[abi:ne200100](__p, __src, __len);
            v41 = *(v31 + 8);
            if (v41)
            {
              v41 = *(v41 & 0xFFFFFFFFFFFFFFFELL);
            }

            google::protobuf::internal::ArenaStringPtr::Set((v31 + 56), __p, v41);
            if (SHIBYTE(v93) < 0)
            {
              operator delete(__p[0]);
            }

            v42 = *(v31 + 40);
            *(v31 + 68) = v23;
            v43 = v42 | 0x18;
            v44 = v24;
          }

          else
          {
            *(v31 + 68) = v23;
            v43 = v40 | 0x1C;
            v44 = v23;
          }

          *(v31 + 40) = v43;
          *(v31 + 72) = v44;
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }

          if (!--v13)
          {
            v11 = v22;
            goto LABEL_82;
          }
        }

        v30 = *(a7 + 60);
        goto LABEL_23;
      }

      if (v12)
      {
        v19 = *(*(a7 + 64) + 8 * *(a7 + 56));
        v49 = *(v19 + 48);
        if (v14)
        {
          std::string::basic_string[abi:ne200100](&__dst, v14, v13);
        }

        else
        {
          memset(&__dst, 0, sizeof(__dst));
        }

        v60 = *((v49 & 0xFFFFFFFFFFFFFFFELL) + 23);
        if (v60 >= 0)
        {
          v61 = (v49 & 0xFFFFFFFFFFFFFFFELL);
        }

        else
        {
          v61 = *(v49 & 0xFFFFFFFFFFFFFFFELL);
        }

        if (v60 >= 0)
        {
          v62 = *((v49 & 0xFFFFFFFFFFFFFFFELL) + 23);
        }

        else
        {
          v62 = *((v49 & 0xFFFFFFFFFFFFFFFELL) + 8);
        }

        v63 = std::string::insert(&__dst, 0, v61, v62);
        v64 = *&v63->__r_.__value_.__l.__data_;
        v93 = v63->__r_.__value_.__r.__words[2];
        *__p = v64;
        v63->__r_.__value_.__l.__size_ = 0;
        v63->__r_.__value_.__r.__words[2] = 0;
        v63->__r_.__value_.__r.__words[0] = 0;
        *(v19 + 40) |= 1u;
        v65 = *(v19 + 8);
        if (v65)
        {
          v65 = *(v65 & 0xFFFFFFFFFFFFFFFELL);
        }

        google::protobuf::internal::ArenaStringPtr::Set((v19 + 48), __p, v65);
        if (SHIBYTE(v93) < 0)
        {
          operator delete(__p[0]);
        }

        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }

        v66 = *(v19 + 56);
        if (__src)
        {
          std::string::basic_string[abi:ne200100](&__dst, __src, __len);
        }

        else
        {
          memset(&__dst, 0, sizeof(__dst));
        }

        v67 = *((v66 & 0xFFFFFFFFFFFFFFFELL) + 23);
        if (v67 >= 0)
        {
          v68 = (v66 & 0xFFFFFFFFFFFFFFFELL);
        }

        else
        {
          v68 = *(v66 & 0xFFFFFFFFFFFFFFFELL);
        }

        if (v67 >= 0)
        {
          v69 = *((v66 & 0xFFFFFFFFFFFFFFFELL) + 23);
        }

        else
        {
          v69 = *((v66 & 0xFFFFFFFFFFFFFFFELL) + 8);
        }

        v70 = std::string::insert(&__dst, 0, v68, v69);
        v71 = *&v70->__r_.__value_.__l.__data_;
        v93 = v70->__r_.__value_.__r.__words[2];
        *__p = v71;
        v70->__r_.__value_.__l.__size_ = 0;
        v70->__r_.__value_.__r.__words[2] = 0;
        v70->__r_.__value_.__r.__words[0] = 0;
        *(v19 + 40) |= 2u;
        v72 = *(v19 + 8);
        if (v72)
        {
          v72 = *(v72 & 0xFFFFFFFFFFFFFFFELL);
        }

        google::protobuf::internal::ArenaStringPtr::Set((v19 + 56), __p, v72);
        if (SHIBYTE(v93) < 0)
        {
          operator delete(__p[0]);
        }

        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }

        v59 = *(v19 + 40) | 0x10;
LABEL_80:
        *(v19 + 40) = v59;
        v11 = v22;
        goto LABEL_81;
      }
    }

    v50 = *(a7 + 64);
    if (v50)
    {
      v51 = *(a7 + 56);
      v52 = *v50;
      if (v51 < *v50)
      {
        *(a7 + 56) = v51 + 1;
        v19 = *&v50[2 * v51 + 2];
LABEL_71:
        *(v19 + 40) |= 1u;
        std::string::basic_string[abi:ne200100](__p, v14, v13);
        v55 = *(v19 + 8);
        if (v55)
        {
          v55 = *(v55 & 0xFFFFFFFFFFFFFFFELL);
        }

        google::protobuf::internal::ArenaStringPtr::Set((v19 + 48), __p, v55);
        if (SHIBYTE(v93) < 0)
        {
          operator delete(__p[0]);
        }

        v56 = *(v19 + 40);
        *(v19 + 64) = v15;
        *(v19 + 40) = v56 | 6;
        std::string::basic_string[abi:ne200100](__p, __src, __len);
        v57 = *(v19 + 8);
        if (v57)
        {
          v57 = *(v57 & 0xFFFFFFFFFFFFFFFELL);
        }

        google::protobuf::internal::ArenaStringPtr::Set((v19 + 56), __p, v57);
        if (SHIBYTE(v93) < 0)
        {
          operator delete(__p[0]);
        }

        v58 = *(v19 + 40);
        *(v19 + 68) = v23;
        v59 = v58 | 0x18;
        goto LABEL_80;
      }

      if (v52 != *(a7 + 60))
      {
LABEL_70:
        *v50 = v52 + 1;
        v19 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText_SentencePiece>(*(a7 + 48));
        v53 = *(a7 + 56);
        v54 = *(a7 + 64) + 8 * v53;
        *(a7 + 56) = v53 + 1;
        *(v54 + 8) = v19;
        goto LABEL_71;
      }
    }

    else
    {
      v52 = *(a7 + 60);
    }

    google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a7 + 48), v52 + 1);
    v50 = *(a7 + 64);
    v52 = *v50;
    goto LABEL_70;
  }

  v22 = 0;
LABEL_114:
  if (v22 == a4)
  {
    result = sentencepiece::SentencePieceProcessor::ApplyExtraOptions(a1, a1 + 5, a7, a8);
    if (!*a8)
    {
      sentencepiece::util::Status::~Status(a8);
      *(a7 + 40) |= 1u;
      std::string::basic_string[abi:ne200100](__p, a2, a3);
      v74 = *(a7 + 8);
      if (v74)
      {
        v74 = *(v74 & 0xFFFFFFFFFFFFFFFELL);
      }

      google::protobuf::internal::ArenaStringPtr::Set((a7 + 72), __p, v74);
      if (SHIBYTE(v93) < 0)
      {
        operator delete(__p[0]);
      }

      return marisa::Trie::Trie(a8);
    }

    return result;
  }

  LODWORD(__p[0]) = 13;
  v75 = std::ostringstream::basic_ostringstream[abi:ne200100](&__p[1]);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v75, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(", 1);
  MEMORY[0x1B8C84C00](&__p[1], 417);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], ") [", 3);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "(consumed) == (normalized.size())", 33);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "] ", 2);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&__p[1], "all normalized characters are not consumed.", 43);
  sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(__p, a8);
LABEL_128:
  __p[1] = *MEMORY[0x1E69E54E8];
  *(&__p[1] + *(__p[1] - 3)) = *(MEMORY[0x1E69E54E8] + 24);
  v93 = MEMORY[0x1E69E5548] + 16;
  if (v95 < 0)
  {
    operator delete(v94[7].__locale_);
  }

  v93 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v94);
  std::ostream::~ostream();
  return MEMORY[0x1B8C85200](&v96);
}

void sub_1B5AB5584(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a29 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void *sentencepiece::SentencePieceProcessor::ApplyExtraOptions@<X0>(sentencepiece::ModelInterface **a1@<X0>, int **a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  v5 = *a2;
  v6 = a2[1];
  if (*a2 == v6)
  {
    return marisa::Trie::Trie(a4);
  }

  while (1)
  {
    v9 = *v5;
    if (*v5 == 2)
    {
      v21 = *(a3 + 64);
      if (v21)
      {
        v22 = *(a3 + 56);
        v23 = *v21;
        if (v22 < *v21)
        {
          *(a3 + 56) = v22 + 1;
          v24 = *&v21[2 * v22 + 2];
LABEL_37:
          v40 = sentencepiece::ModelInterface::eos_piece(a1[1]);
          v41 = v40;
          if (v40)
          {
            v42 = strlen(v40);
          }

          else
          {
            v42 = 0;
          }

          v43 = (*(*a1 + 44))(a1, v41, v42);
          *(v24 + 40) |= 4u;
          *(v24 + 64) = v43;
          v44 = sentencepiece::ModelInterface::eos_piece(a1[1]);
          sentencepiece::ModelInterface::eos_piece(a1[1]);
          *(v24 + 40) |= 1u;
          std::string::basic_string[abi:ne200100](__p, v44, v45);
          v46 = *(v24 + 8);
          if (v46)
          {
            v46 = *(v46 & 0xFFFFFFFFFFFFFFFELL);
          }

          google::protobuf::internal::ArenaStringPtr::Set((v24 + 48), __p, v46);
          goto LABEL_43;
        }

        if (v23 != *(a3 + 60))
        {
LABEL_36:
          *v21 = v23 + 1;
          v24 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText_SentencePiece>(*(a3 + 48));
          v38 = *(a3 + 56);
          v39 = *(a3 + 64) + 8 * v38;
          *(a3 + 56) = v38 + 1;
          *(v39 + 8) = v24;
          goto LABEL_37;
        }
      }

      else
      {
        v23 = *(a3 + 60);
      }

      google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a3 + 48), v23 + 1);
      v21 = *(a3 + 64);
      v23 = *v21;
      goto LABEL_36;
    }

    if (v9 == 1)
    {
      v17 = *(a3 + 64);
      if (v17)
      {
        v18 = *(a3 + 56);
        v19 = *v17;
        if (v18 < *v17)
        {
          v20 = v18 + 1;
          *(a3 + 56) = v18 + 1;
LABEL_25:
          if (v20 >= 2)
          {
            v28 = v20 + 1;
            v29 = 8 * v20 - 8;
            do
            {
              *(*(a3 + 64) + v29) = vextq_s8(*(*(a3 + 64) + v29), *(*(a3 + 64) + v29), 8uLL);
              --v28;
              v29 -= 8;
            }

            while (v28 > 2);
          }

          v30 = *(*(a3 + 64) + 8);
          v31 = sentencepiece::ModelInterface::bos_piece(a1[1]);
          v32 = v31;
          if (v31)
          {
            v33 = strlen(v31);
          }

          else
          {
            v33 = 0;
          }

          v34 = (*(*a1 + 44))(a1, v32, v33);
          *(v30 + 40) |= 4u;
          *(v30 + 64) = v34;
          v35 = sentencepiece::ModelInterface::bos_piece(a1[1]);
          sentencepiece::ModelInterface::bos_piece(a1[1]);
          *(v30 + 40) |= 1u;
          std::string::basic_string[abi:ne200100](__p, v35, v36);
          v37 = *(v30 + 8);
          if (v37)
          {
            v37 = *(v37 & 0xFFFFFFFFFFFFFFFELL);
          }

          google::protobuf::internal::ArenaStringPtr::Set((v30 + 48), __p, v37);
LABEL_43:
          if (v49 < 0)
          {
            operator delete(__p[0]);
          }

          goto LABEL_45;
        }

        if (v19 != *(a3 + 60))
        {
LABEL_24:
          *v17 = v19 + 1;
          v25 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText_SentencePiece>(*(a3 + 48));
          v26 = *(a3 + 56);
          v27 = *(a3 + 64) + 8 * v26;
          v20 = v26 + 1;
          *(a3 + 56) = v20;
          *(v27 + 8) = v25;
          goto LABEL_25;
        }
      }

      else
      {
        v19 = *(a3 + 60);
      }

      google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a3 + 48), v19 + 1);
      v17 = *(a3 + 64);
      v19 = *v17;
      goto LABEL_24;
    }

    if (v9)
    {
      return sentencepiece::util::Status::Status(a4, 13, "unknown extra_option type.");
    }

    v10 = *(a3 + 64);
    if (v10)
    {
      v11 = v10 + 8;
    }

    else
    {
      v11 = 0;
    }

    v12 = *(a3 + 56);
    if (v12)
    {
      v13 = (v11 + 8 * v12 - 8);
      if (v13 > v11)
      {
        v14 = v11 + 8;
        do
        {
          v15 = *v13--;
          sentencepiece::swap(*(v14 - 8), v15, a3);
          v16 = v14 >= v13;
          v14 += 8;
        }

        while (!v16);
      }
    }

LABEL_45:
    if (++v5 == v6)
    {
      return marisa::Trie::Trie(a4);
    }
  }
}

void sub_1B5AB59D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::SentencePieceProcessor::Encode(void **a1@<X0>, char *a2@<X1>, size_t a3@<X2>, sentencepiece::SentencePieceText *a4@<X3>, sentencepiece::util::Status *a5@<X8>)
{
  ((*a1)[7])(a1);
  if (!*a5)
  {
    sentencepiece::util::Status::~Status(a5);
    if (a4)
    {
      sentencepiece::SentencePieceText::Clear(a4);
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      (*(*a1[2] + 32))(a1[2], a2, a3, &v17, &v14);
      if (!*a5)
      {
        sentencepiece::util::Status::~Status(a5);
        (*(*a1[1] + 56))(__p);
        if (v19 >= 0)
        {
          v10 = SHIBYTE(v19);
        }

        else
        {
          v10 = v18;
        }

        sentencepiece::SentencePieceProcessor::PopulateSentencePieceText(a1, a2, a3, v10, &v14, __p, a4, a5);
        if (!*a5)
        {
          sentencepiece::util::Status::~Status(a5);
          marisa::Trie::Trie(v11);
        }

        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
      }

      if (v14)
      {
        v15 = v14;
        operator delete(v14);
      }

      if (SHIBYTE(v19) < 0)
      {
        operator delete(v17);
      }
    }

    else
    {
      LODWORD(v17) = 13;
      v12 = std::ostringstream::basic_ostringstream[abi:ne200100](&v18);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v18, "(", 1);
      MEMORY[0x1B8C84C00](&v18, 429);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v18, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v18, "spt", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v18, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v18, "output proto is null", 20);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v17, a5);
      v18 = *MEMORY[0x1E69E54E8];
      *(&v18 + *(v18 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
      v19 = MEMORY[0x1E69E5548] + 16;
      if (v21 < 0)
      {
        operator delete(v20[7].__locale_);
      }

      v19 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(v20);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](&v22);
    }
  }
}

void sub_1B5AB5D48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a20 < 0)
  {
    operator delete(a15);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::SentencePieceProcessor::NBestEncode(void **a1@<X0>, char *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X4>, sentencepiece::util::Status *a5@<X8>)
{
  ((*a1)[7])(a1);
  if (*a5)
  {
    return;
  }

  sentencepiece::util::Status::~Status(a5);
  if (a4)
  {
    sentencepiece::NBestSentencePieceText::Clear(a4);
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    (*(*a1[2] + 32))(a1[2], a2, a3, &v26, &v23);
    if (!*a5)
    {
      sentencepiece::util::Status::~Status(a5);
      if ((*(*a1[1] + 104))(a1[1]))
      {
        (*(*a1[1] + 64))(&v21);
        v10 = v21;
        v11 = v22;
        if (v21 != v22)
        {
          while (1)
          {
            v12 = *(a4 + 32);
            if (!v12)
            {
              break;
            }

            v13 = *(a4 + 24);
            v14 = *v12;
            if (v13 >= *v12)
            {
              if (v14 == *(a4 + 28))
              {
LABEL_12:
                google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a4 + 16), v14 + 1);
                v12 = *(a4 + 32);
                v14 = *v12;
              }

              *v12 = v14 + 1;
              v15 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText>(*(a4 + 16));
              v16 = *(a4 + 24);
              v17 = *(a4 + 32) + 8 * v16;
              *(a4 + 24) = v16 + 1;
              *(v17 + 8) = v15;
              goto LABEL_14;
            }

            *(a4 + 24) = v13 + 1;
            v15 = *&v12[2 * v13 + 2];
LABEL_14:
            v18 = *(v10 + 24);
            *(v15 + 40) |= 2u;
            *(v15 + 80) = v18;
            if (v28 >= 0)
            {
              v19 = SHIBYTE(v28);
            }

            else
            {
              v19 = v27;
            }

            sentencepiece::SentencePieceProcessor::PopulateSentencePieceText(a1, a2, a3, v19, &v23, v10, v15, a5);
            if (*a5)
            {
              goto LABEL_29;
            }

            sentencepiece::util::Status::~Status(a5);
            v10 += 32;
            if (v10 == v11)
            {
              marisa::Trie::Trie(a5);
              goto LABEL_29;
            }
          }

          v14 = *(a4 + 28);
          goto LABEL_12;
        }

        LODWORD(v29) = 13;
        std::ostringstream::basic_ostringstream[abi:ne200100](&v30);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "(", 1);
        MEMORY[0x1B8C84C00](&v30, 455);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, ") [", 3);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "!nbests.empty()", 15);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "] ", 2);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "NBestEncode returns empty result.", 33);
        sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v29, a5);
        v30 = *MEMORY[0x1E69E54E8];
        *(&v30 + *(v30 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
        v31 = MEMORY[0x1E69E5548] + 16;
        if (v34 < 0)
        {
          operator delete(__p);
        }

        v31 = MEMORY[0x1E69E5538] + 16;
        std::locale::~locale(v32);
        std::ostream::~ostream();
        MEMORY[0x1B8C85200](v35);
LABEL_29:
        v29 = &v21;
        std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&v29);
      }

      else
      {
        LODWORD(v29) = 13;
        std::ostringstream::basic_ostringstream[abi:ne200100](&v30);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "(", 1);
        MEMORY[0x1B8C84C00](&v30, 451);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, ") [", 3);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "model_->IsNBestEncodeAvailable()", 32);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "] ", 2);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "NBestEncode is not available for the current model.", 51);
        sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v29, a5);
        v30 = *MEMORY[0x1E69E54E8];
        *(&v30 + *(v30 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
        v31 = MEMORY[0x1E69E5548] + 16;
        if (v34 < 0)
        {
          operator delete(__p);
        }

        v31 = MEMORY[0x1E69E5538] + 16;
        std::locale::~locale(v32);
        std::ostream::~ostream();
        MEMORY[0x1B8C85200](v35);
      }
    }

    if (v23)
    {
      v24 = v23;
      operator delete(v23);
    }

    if (SHIBYTE(v28) < 0)
    {
      operator delete(v26);
    }
  }

  else
  {
    LODWORD(v29) = 13;
    v20 = std::ostringstream::basic_ostringstream[abi:ne200100](&v30);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v20, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "(", 1);
    MEMORY[0x1B8C84C00](&v30, 445);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, ") [", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "nbest_spt", 9);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "] ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v30, "output proto is null", 20);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v29, a5);
    v30 = *MEMORY[0x1E69E54E8];
    *(&v30 + *(v30 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
    v31 = MEMORY[0x1E69E5548] + 16;
    if (v34 < 0)
    {
      operator delete(__p);
    }

    v31 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v32);
    std::ostream::~ostream();
    MEMORY[0x1B8C85200](v35);
  }
}

void sub_1B5AB6538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char *a22)
{
  a22 = &a10;
  std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&a22);
  if (__p)
  {
    a14 = __p;
    operator delete(__p);
  }

  if (a21 < 0)
  {
    operator delete(a16);
  }

  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::SampleEncode(void **a1@<X0>, char *a2@<X1>, size_t a3@<X2>, int a4@<W3>, sentencepiece::SentencePieceText *a5@<X4>, sentencepiece::util::Status *a6@<X8>, float a7@<S0>)
{
  ((*a1)[7])(a1);
  if (*a6)
  {
    return;
  }

  sentencepiece::util::Status::~Status(a6);
  if (a5)
  {
    sentencepiece::SentencePieceText::Clear(a5);
    if (a4 < 513)
    {
      v36 = 0;
      v37 = 0;
      v38 = 0;
      __p = 0;
      v34 = 0;
      v35 = 0;
      (*(*a1[2] + 32))(a1[2], a2, a3, &v36, &__p);
      if (*a6)
      {
LABEL_5:
        if (__p)
        {
          v34 = __p;
          operator delete(__p);
        }

        if (SHIBYTE(v38) < 0)
        {
          operator delete(v36);
        }

        return;
      }

      sentencepiece::util::Status::~Status(a6);
      v16 = (*(*a1[1] + 104))(a1[1]);
      if (a4 >= 0)
      {
        v17 = v16;
      }

      else
      {
        v17 = 0;
      }

      if (v17)
      {
        if (a4 > 1)
        {
          (*(*a1[1] + 64))(&v31);
          if (v31 == v32)
          {
            LODWORD(v39) = 13;
            std::ostringstream::basic_ostringstream[abi:ne200100](&v40);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "(", 1);
            MEMORY[0x1B8C84C00](&v40, 490);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, ") [", 3);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "!nbests.empty()", 15);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "] ", 2);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "NBestEncode returns empty result.", 33);
            sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v39, a6);
            sentencepiece::util::StatusBuilder::~StatusBuilder(&v39);
          }

          else
          {
            LODWORD(v29) = 0;
            v19 = std::vector<float>::vector[abi:ne200100](&v39, (v32 - v31) >> 5);
            if (v32 != v31)
            {
              v20 = v39;
              if (((v32 - v31) >> 5) <= 1)
              {
                v21 = 1;
              }

              else
              {
                v21 = (v32 - v31) >> 5;
              }

              v22 = (v31 + 24);
              do
              {
                v23 = *v22;
                v22 += 8;
                *v20++ = expf(v23 * a7);
                --v21;
              }

              while (v21);
            }

            RandomGenerator = sentencepiece::random::GetRandomGenerator(v19);
            std::discrete_distribution<int>::param_type::param_type[abi:ne200100]<std::__wrap_iter<float *>>(&v29, v39, v40);
            v25 = HIBYTE(v38);
            v26 = v37;
            v27 = std::discrete_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(&v29, RandomGenerator, &v29);
            if ((v25 & 0x80u) == 0)
            {
              v28 = v25;
            }

            else
            {
              v28 = v26;
            }

            sentencepiece::SentencePieceProcessor::PopulateSentencePieceText(a1, a2, a3, v28, &__p, (v31 + 32 * v27), a5, a6);
            if (!*a6)
            {
              sentencepiece::util::Status::~Status(a6);
              if (v29)
              {
                v30 = v29;
                operator delete(v29);
              }

              if (v39)
              {
                v40 = v39;
                operator delete(v39);
              }

              v39 = &v31;
              std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&v39);
LABEL_55:
              marisa::Trie::Trie(a6);
              goto LABEL_5;
            }

            if (v29)
            {
              v30 = v29;
              operator delete(v29);
            }

            if (v39)
            {
              v40 = v39;
              operator delete(v39);
            }
          }

          v39 = &v31;
          std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&v39);
          goto LABEL_5;
        }

        (*(*a1[1] + 56))(&v39);
        if (v38 >= 0)
        {
          v18 = SHIBYTE(v38);
        }

        else
        {
          v18 = v37;
        }
      }

      else
      {
        if (((*(*a1[1] + 96))(a1[1]) & 1) == 0)
        {
          LODWORD(v39) = 13;
          std::ostringstream::basic_ostringstream[abi:ne200100](&v40);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "(", 1);
          MEMORY[0x1B8C84C00](&v40, 479);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, ") [", 3);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "model_->IsSampleEncodeAvailable()", 33);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "] ", 2);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "SampleEncode is not available for the current model.", 52);
          sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v39, a6);
          sentencepiece::util::StatusBuilder::~StatusBuilder(&v39);
          goto LABEL_5;
        }

        (*(*a1[1] + 72))(&v39, a7);
        if (v38 >= 0)
        {
          v18 = SHIBYTE(v38);
        }

        else
        {
          v18 = v37;
        }
      }

      sentencepiece::SentencePieceProcessor::PopulateSentencePieceText(a1, a2, a3, v18, &__p, &v39, a5, a6);
      if (*a6)
      {
        if (v39)
        {
          v40 = v39;
          operator delete(v39);
        }

        goto LABEL_5;
      }

      sentencepiece::util::Status::~Status(a6);
      if (v39)
      {
        v40 = v39;
        operator delete(v39);
      }

      goto LABEL_55;
    }

    LODWORD(v39) = 13;
    v15 = std::ostringstream::basic_ostringstream[abi:ne200100](&v40);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v15, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "(", 1);
    MEMORY[0x1B8C84C00](&v40, 472);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, ") [", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "(nbest_size) <= (512)", 21);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "] ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "nbest_size must be nbest_size <= 512", 36);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v39, a6);
  }

  else
  {
    LODWORD(v39) = 13;
    v14 = std::ostringstream::basic_ostringstream[abi:ne200100](&v40);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v14, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "(", 1);
    MEMORY[0x1B8C84C00](&v40, 470);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, ") [", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "spt", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "] ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "output proto is null", 20);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v39, a6);
  }

  v40 = *MEMORY[0x1E69E54E8];
  *(&v40 + *(v40 - 3)) = *(MEMORY[0x1E69E54E8] + 24);
  v41 = MEMORY[0x1E69E5548] + 16;
  if (v43 < 0)
  {
    operator delete(v42[7].__locale_);
  }

  v41 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v42);
  std::ostream::~ostream();
  MEMORY[0x1B8C85200](&v44);
}

void sub_1B5AB6DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, char *a24, uint64_t a25)
{
  a24 = &a12;
  std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&a24);
  if (__p)
  {
    a16 = __p;
    operator delete(__p);
  }

  if (a23 < 0)
  {
    operator delete(a18);
  }

  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::SampleEncodeAndScore(void **a1@<X0>, char *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X6>, sentencepiece::util::Status *a5@<X8>, float a6@<S0>)
{
  if ((*(*a1[1] + 112))(a1[1]))
  {
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    (*(*a1[2] + 32))(a1[2], a2, a3, &v28, &v25);
    if (!*a5)
    {
      sentencepiece::util::Status::~Status(a5);
      (*(*a1[1] + 80))(&v23, a6);
      v12 = v23;
      v13 = v24;
      if (v23 != v24)
      {
        while (1)
        {
          v14 = *(a4 + 32);
          if (!v14)
          {
            break;
          }

          v15 = *(a4 + 24);
          v16 = *v14;
          if (v15 >= *v14)
          {
            if (v16 == *(a4 + 28))
            {
LABEL_9:
              google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a4 + 16), v16 + 1);
              v14 = *(a4 + 32);
              v16 = *v14;
            }

            *v14 = v16 + 1;
            v17 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText>(*(a4 + 16));
            v18 = *(a4 + 24);
            v19 = *(a4 + 32) + 8 * v18;
            *(a4 + 24) = v18 + 1;
            *(v19 + 8) = v17;
            goto LABEL_11;
          }

          *(a4 + 24) = v15 + 1;
          v17 = *&v14[2 * v15 + 2];
LABEL_11:
          v20 = *(v12 + 24);
          *(v17 + 40) |= 2u;
          *(v17 + 80) = v20;
          if (v30 >= 0)
          {
            v21 = SHIBYTE(v30);
          }

          else
          {
            v21 = v29;
          }

          sentencepiece::SentencePieceProcessor::PopulateSentencePieceText(a1, a2, a3, v21, &v25, v12, v17, a5);
          if (*a5)
          {
            goto LABEL_23;
          }

          sentencepiece::util::Status::~Status(a5);
          v12 += 32;
          if (v12 == v13)
          {
            marisa::Trie::Trie(a5);
            goto LABEL_23;
          }
        }

        v16 = *(a4 + 28);
        goto LABEL_9;
      }

      LODWORD(v31) = 13;
      std::ostringstream::basic_ostringstream[abi:ne200100](&v32);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, "(", 1);
      MEMORY[0x1B8C84C00](&v32, 517);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, ") [", 3);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, "!results.empty()", 16);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, "] ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, "SampleEncodeAndScore returns empty result.", 42);
      sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v31, a5);
      v32 = *MEMORY[0x1E69E54E8];
      *(&v32 + *(v32 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
      v33 = MEMORY[0x1E69E5548] + 16;
      if (v36 < 0)
      {
        operator delete(__p);
      }

      v33 = MEMORY[0x1E69E5538] + 16;
      std::locale::~locale(v34);
      std::ostream::~ostream();
      MEMORY[0x1B8C85200](v37);
LABEL_23:
      v31 = &v23;
      std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&v31);
    }

    if (v25)
    {
      v26 = v25;
      operator delete(v25);
    }

    if (SHIBYTE(v30) < 0)
    {
      operator delete(v28);
    }
  }

  else
  {
    LODWORD(v31) = 13;
    v22 = std::ostringstream::basic_ostringstream[abi:ne200100](&v32);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v22, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, "(", 1);
    MEMORY[0x1B8C84C00](&v32, 509);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, ") [", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, "model_->IsSampleEncodeAndScoreAvailable()", 41);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, "] ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v32, "SampleEncodeAndScore is not available for the current model.", 60);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v31, a5);
    v32 = *MEMORY[0x1E69E54E8];
    *(&v32 + *(v32 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
    v33 = MEMORY[0x1E69E5548] + 16;
    if (v36 < 0)
    {
      operator delete(__p);
    }

    v33 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v34);
    std::ostream::~ostream();
    MEMORY[0x1B8C85200](v37);
  }
}

void sub_1B5AB7490(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char *a22)
{
  a22 = &a10;
  std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&a22);
  if (__p)
  {
    a14 = __p;
    operator delete(__p);
  }

  if (a21 < 0)
  {
    operator delete(a16);
  }

  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::CalculateEntropy(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, float *a4@<X3>, sentencepiece::util::Status *a5@<X8>, float a6@<S0>)
{
  if ((*(**(a1 + 8) + 120))(*(a1 + 8)))
  {
    v18 = 0;
    v19 = 0;
    v20 = 0;
    __p = 0;
    v16 = 0;
    v17 = 0;
    (*(**(a1 + 16) + 32))(*(a1 + 16), a2, a3, &v18, &__p);
    if (!*a5)
    {
      sentencepiece::util::Status::~Status(a5);
      if (v20 >= 0)
      {
        v12 = &v18;
      }

      else
      {
        v12 = v18;
      }

      if (v20 >= 0)
      {
        v13 = SHIBYTE(v20);
      }

      else
      {
        v13 = v19;
      }

      *a4 = (*(**(a1 + 8) + 88))(*(a1 + 8), v12, v13, a6);
      marisa::Trie::Trie(a5);
    }

    if (__p)
    {
      v16 = __p;
      operator delete(__p);
    }

    if (SHIBYTE(v20) < 0)
    {
      operator delete(v18);
    }
  }

  else
  {
    LODWORD(v18) = 13;
    v14 = std::ostringstream::basic_ostringstream[abi:ne200100](&v19);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v14, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v19, "(", 1);
    MEMORY[0x1B8C84C00](&v19, 533);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v19, ") [", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v19, "model_->IsCalculateEntropyAvailable()", 37);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v19, "] ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v19, "CalculateEntropy is not available for the current model.", 56);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v18, a5);
    v19 = *MEMORY[0x1E69E54E8];
    *(&v19 + *(v19 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
    v20 = MEMORY[0x1E69E5548] + 16;
    if (v22 < 0)
    {
      operator delete(v21[7].__locale_);
    }

    v20 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v21);
    std::ostream::~ostream();
    MEMORY[0x1B8C85200](&v23);
  }
}

void sub_1B5AB77FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a18 < 0)
  {
    operator delete(a13);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::SentencePieceProcessor::Decode(void *a1@<X0>, uint64_t *a2@<X1>, sentencepiece::SentencePieceText *a3@<X2>, sentencepiece::util::Status *a4@<X8>)
{
  v68[19] = *MEMORY[0x1E69E9840];
  v58 = a3;
  (*(*a1 + 56))(a4);
  if (*a4)
  {
    return;
  }

  sentencepiece::util::Status::~Status(a4);
  if (a3)
  {
    sentencepiece::SentencePieceText::Clear(a3);
    v8 = a1[4];
    if (!v8)
    {
      goto LABEL_8;
    }

    v9 = *(v8 + 72);
    if (!v9)
    {
      v9 = &sentencepiece::_TrainerSpec_default_instance_;
    }

    if ((v9[5] & 8) != 0)
    {
      v11 = v9[22];
      if (v11)
      {
        explicit = (v11 & 0xFFFFFFFFFFFFFFFELL);
      }

      else
      {
        explicit = atomic_load_explicit(&qword_1EB909578, memory_order_acquire);
        if (!explicit)
        {
          explicit = google::protobuf::internal::LazyString::Init(&sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_unk_surface_);
        }
      }

      if (explicit[23] < 0)
      {
        explicit = *explicit;
      }
    }

    else
    {
LABEL_8:
    }

    v12 = *a2;
    v13 = a2[1];
    while (v12 != v13)
    {
      v14 = v58;
      v15 = *(v58 + 8);
      if (!v15)
      {
        v17 = *(v58 + 15);
LABEL_25:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v58 + 12, v17 + 1);
        v15 = *(v58 + 8);
        v17 = *v15;
        goto LABEL_26;
      }

      v16 = *(v58 + 14);
      v17 = *v15;
      if (v16 < *v15)
      {
        *(v58 + 14) = v16 + 1;
        v18 = *&v15[2 * v16 + 2];
        goto LABEL_27;
      }

      if (v17 == *(v58 + 15))
      {
        goto LABEL_25;
      }

LABEL_26:
      *v15 = v17 + 1;
      v18 = google::protobuf::Arena::CreateMaybeMessage<sentencepiece::SentencePieceText_SentencePiece>(*(v14 + 48));
      v19 = *(v14 + 56);
      v20 = *(v14 + 64) + 8 * v19;
      *(v14 + 56) = v19 + 1;
      *(v20 + 8) = v18;
LABEL_27:
      *(v18 + 40) |= 1u;
      v21 = *(v18 + 8);
      if (v21)
      {
        v21 = *(v21 & 0xFFFFFFFFFFFFFFFELL);
      }

      google::protobuf::internal::ArenaStringPtr::Set((v18 + 48), v12, v21);
      v22 = *(v12 + 23);
      if (v22 >= 0)
      {
        v23 = v12;
      }

      else
      {
        v23 = *v12;
      }

      if (v22 >= 0)
      {
        v24 = *(v12 + 23);
      }

      else
      {
        v24 = *(v12 + 8);
      }

      v25 = (*(*a1 + 352))(a1, v23, v24);
      *(v18 + 40) |= 4u;
      *(v18 + 64) = v25;
      v12 += 24;
    }

    v26 = v58;
    sentencepiece::SentencePieceProcessor::ApplyExtraOptions(a1, a1 + 8, v58, a4);
    if (*a4)
    {
      return;
    }

    sentencepiece::util::Status::~Status(a4);
    *(v58 + 10) |= 1u;
    v28 = *(v26 + 8);
    if (v28)
    {
      v28 = *(v28 & 0xFFFFFFFFFFFFFFFELL);
    }

    v56[1] = &v57;
    v57 = google::protobuf::internal::ArenaStringPtr::Mutable((v26 + 72), v28, v27);
    v55[0] = &v58;
    v55[1] = v56;
    v56[0] = &v58;
    LODWORD(v29) = *(v26 + 56);
    if (v29 >= 1)
    {
      v30 = 0;
      v31 = 0;
      while (1)
      {
        v32 = *(*(v26 + 64) + 8 * v30 + 8);
        if (!(*(*a1 + 400))(a1, *(v32 + 64)))
        {
          break;
        }

        ++v30;
LABEL_87:
        v26 = v58;
        v29 = *(v58 + 14);
        if (v30 >= v29)
        {
          goto LABEL_101;
        }
      }

      sentencepiece::SentencePieceProcessor::Decode(std::vector<std::string> const&,sentencepiece::SentencePieceText *)const::$_2::operator()(v55, v31, v30, a4);
      if (*a4)
      {
        return;
      }

      sentencepiece::util::Status::~Status(a4);
      v33 = *(v32 + 48) & 0xFFFFFFFFFFFFFFFELL;
      v34 = *(v33 + 23);
      if (v34 >= 0)
      {
        v35 = (*(v32 + 48) & 0xFFFFFFFFFFFFFFFELL);
      }

      else
      {
        v35 = *v33;
      }

      if (v34 >= 0)
      {
        v36 = *(v33 + 23);
      }

      else
      {
        v36 = *(v33 + 8);
      }

      v37 = *(v57 + 23);
      if (v37 < 0)
      {
        v37 = v57[1];
      }

      v38 = *(v32 + 64);
      if ((*(*a1 + 384))(a1, v38))
      {
        std::string::basic_string[abi:ne200100]<0>(&v52, "");
LABEL_78:
        if (v54 >= 0)
        {
          v45 = &v52;
        }

        else
        {
          v45 = v52;
        }

        if (v54 >= 0)
        {
          v46 = SHIBYTE(v54);
        }

        else
        {
          v46 = v53;
        }

        sentencepiece::SentencePieceProcessor::Decode(std::vector<std::string> const&,sentencepiece::SentencePieceText *)const::$_1::operator()(v56, v30, v45, v46);
        if (SHIBYTE(v54) < 0)
        {
          operator delete(v52);
        }

        v31 = ++v30;
        goto LABEL_87;
      }

      if ((*(*a1 + 376))(a1, v38))
      {
        v39 = (*(*a1 + 360))(a1, v38);
        v40 = v39[23];
        v41 = *(v39 + 1);
        if (v40 < 0)
        {
          v39 = *v39;
        }

        if (v40 < 0)
        {
          v40 = v41;
        }

        if (v40 == v36 && (v36 ? (v42 = v35 == v39) : (v42 = 1), v42 || !memcmp(v39, v35, v36)))
        {
          std::string::basic_string[abi:ne200100]<0>(&v52, explicit);
        }

        else if (v35)
        {
          std::string::basic_string[abi:ne200100](&v52, v35, v36);
        }

        else
        {
          v52 = 0;
          v53 = 0;
          v54 = 0;
        }

        goto LABEL_78;
      }

      if (v37)
      {
LABEL_68:
        *(&v62 + 1) = 3;
        v63 = " ";
        v64.__locale_ = 1;
        v60 = 0;
        v61 = 0;
        v59 = 0;
        std::vector<std::pair<absl::string_view,absl::string_view>>::__init_with_size[abi:ne200100]<std::pair<absl::string_view,absl::string_view> const*,std::pair<absl::string_view,absl::string_view> const*>(&v59, &v62, &v65, 1uLL);
        absl::StrReplaceAll(v35, v36, &v59, &v52);
        if (v59)
        {
          v60 = v59;
          operator delete(v59);
        }

        goto LABEL_78;
      }

      v43 = a1[4];
      if (!v43)
      {
        goto LABEL_74;
      }

      v44 = *(v43 + 80);
      if (!v44)
      {
        v44 = &sentencepiece::_NormalizerSpec_default_instance_;
      }

      if ((v44[72] & 1) == 0)
      {
        if (v44[73] != 1 || v36 <= 2)
        {
          goto LABEL_68;
        }
      }

      else
      {
LABEL_74:
        if (v36 < 3)
        {
          goto LABEL_68;
        }
      }

      if (*v35 == 38626 && v35[2] == 129)
      {
        v35 += 3;
        v36 -= 3;
      }

      goto LABEL_68;
    }

    v31 = 0;
LABEL_101:
    sentencepiece::SentencePieceProcessor::Decode(std::vector<std::string> const&,sentencepiece::SentencePieceText *)const::$_2::operator()(v55, v31, v29, a4);
    if (!*a4)
    {
      sentencepiece::util::Status::~Status(a4);
      v49 = a1[3];
      if (v49)
      {
        (*(*v49 + 40))(&v62);
        v50 = v57;
        if (*(v57 + 23) < 0)
        {
          operator delete(*v57);
        }

        v51 = v62;
        v50[2] = v63;
        *v50 = v51;
      }

      marisa::Trie::Trie(a4);
    }
  }

  else
  {
    LODWORD(v62) = 13;
    std::ostringstream::basic_ostringstream[abi:ne200100](&v62 + 1);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v62 + 1, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v62 + 1, "(", 1);
    MEMORY[0x1B8C84C00](&v62 + 8, 545);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v62 + 1, ") [", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v62 + 1, "spt", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v62 + 1, "] ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v62 + 1, "output proto is null", 20);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v62, a4);
    *(&v62 + 1) = *MEMORY[0x1E69E54E8];
    *(&v62 + *(*(&v62 + 1) - 24) + 8) = *(MEMORY[0x1E69E54E8] + 24);
    v63 = (MEMORY[0x1E69E5548] + 16);
    if (v67 < 0)
    {
      operator delete(__p);
    }

    v63 = (MEMORY[0x1E69E5538] + 16);
    std::locale::~locale(&v64);
    std::ostream::~ostream();
    MEMORY[0x1B8C85200](v68);
  }
}

void sub_1B5AB8058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, uint64_t a23, char a24)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::SentencePieceProcessor::Decode(std::vector<std::string> const&,sentencepiece::SentencePieceText *)const::$_2::operator()(void **a1@<X0>, int a2@<W1>, int a3@<W2>, marisa::Trie *a4@<X8>)
{
  v5 = a3 - a2;
  if (a3 <= a2)
  {

    marisa::Trie::Trie(a4);
  }

  else
  {
    memset(&v40, 0, sizeof(v40));
    v9 = 8 * a2 + 8;
    do
    {
      v10 = *(*(*(**a1 + 64) + v9) + 48) & 0xFFFFFFFFFFFFFFFELL;
      v11 = *(v10 + 23);
      if (v11 >= 0)
      {
        v12 = (*(*(*(**a1 + 64) + v9) + 48) & 0xFFFFFFFFFFFFFFFELL);
      }

      else
      {
        v12 = *v10;
      }

      if (v11 >= 0)
      {
        v13 = *(v10 + 23);
      }

      else
      {
        v13 = *(v10 + 8);
      }

      v14 = sentencepiece::PieceToByte(v12, v13);
      if (v14 < 0)
      {
        v34 = 13;
        std::ostringstream::basic_ostringstream[abi:ne200100](&v35);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "(", 1);
        MEMORY[0x1B8C84C00](&v35, 604);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, ") [", 3);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "(0) <= (byte)", 13);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "] ", 2);
        sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v34, a4);
        goto LABEL_53;
      }

      std::string::append(&v40, 1uLL, v14);
      v9 += 8;
      --v5;
    }

    while (v5);
    v31 = a3;
    v32 = a4;
    if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v16 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v16 = v40.__r_.__value_.__r.__words[1];
    }

    if (v16 >= 1)
    {
      v17 = 0;
      while (1)
      {
        *v33 = 0;
        size = SHIBYTE(v40.__r_.__value_.__r.__words[2]);
        v19 = v40.__r_.__value_.__r.__words[0];
        if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v19 = &v40;
        }

        if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          size = v40.__r_.__value_.__l.__size_;
        }

        if (sentencepiece::string_util::DecodeUTF8((v19 + v17), v19 + size, v33, v15) != 65533)
        {
          break;
        }

        v20 = *v33;
        v21 = v17 + a2;
        if (*v33 != 1)
        {
          if (*v33 != 3)
          {
            v34 = 13;
            std::ostringstream::basic_ostringstream[abi:ne200100](&v35);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "(", 1);
            MEMORY[0x1B8C84C00](&v35, 623);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, ") [", 3);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "(consumed) == (1)", 17);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "] ", 2);
            sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v34, v32);
            goto LABEL_53;
          }

          goto LABEL_25;
        }

        LODWORD(v20) = *v33;
LABEL_43:
        v17 += v20;
        if (v17 >= v16)
        {
          goto LABEL_50;
        }
      }

      v21 = v17 + a2;
      v20 = *v33;
LABEL_25:
      v22 = SHIBYTE(v40.__r_.__value_.__r.__words[2]);
      v23 = v40.__r_.__value_.__r.__words[0];
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v23 = &v40;
      }

      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        v22 = v40.__r_.__value_.__l.__size_;
      }

      v24 = v22 - v17;
      if (v24 >= v20)
      {
        v25 = v20;
      }

      else
      {
        v25 = v24;
      }

      if (v20)
      {
        v26 = 0;
        v27 = v23 + v17;
        do
        {
          v28 = v20 - 1;
          if (v26 == v28)
          {
            v29 = v27;
          }

          else
          {
            v29 = "";
          }

          if (v26 == v28)
          {
            v30 = v25;
          }

          else
          {
            v30 = 0;
          }

          sentencepiece::SentencePieceProcessor::Decode(std::vector<std::string> const&,sentencepiece::SentencePieceText *)const::$_1::operator()(a1[1], v21, v29, v30);
          ++v26;
          v20 = *v33;
          ++v21;
        }

        while (*v33 > v26);
      }

      goto LABEL_43;
    }

    v17 = 0;
LABEL_50:
    if (v17 + a2 == v31)
    {
      marisa::Trie::Trie(v32);
      goto LABEL_56;
    }

    v34 = 13;
    std::ostringstream::basic_ostringstream[abi:ne200100](&v35);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/src/sentencepiece_processor.cc", 123);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "(", 1);
    MEMORY[0x1B8C84C00](&v35, 641);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, ") [", 3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "(token_index_begin + offset) == (token_index_end)", 49);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v35, "] ", 2);
    sentencepiece::util::StatusBuilder::operator sentencepiece::util::Status(&v34, v32);
LABEL_53:
    v35 = *MEMORY[0x1E69E54E8];
    *(&v35 + *(v35 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
    v36 = MEMORY[0x1E69E5548] + 16;
    if (v38 < 0)
    {
      operator delete(v37[7].__locale_);
    }

    v36 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v37);
    std::ostream::~ostream();
    MEMORY[0x1B8C85200](&v39);
LABEL_56:
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1B5AB85BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (*(v13 - 89) < 0)
  {
    operator delete(*(v13 - 112));
  }

  _Unwind_Resume(exception_object);
}

std::string *sentencepiece::SentencePieceProcessor::Decode(std::vector<std::string> const&,sentencepiece::SentencePieceText *)const::$_1::operator()(void *a1, int a2, void *__src, size_t __len)
{
  v7 = *(*(**a1 + 64) + 8 * a2 + 8);
  if (__src)
  {
    std::string::basic_string[abi:ne200100](__p, __src, __len);
  }

  else
  {
    __p[0] = 0;
    __p[1] = 0;
    v16 = 0;
  }

  *(v7 + 40) |= 2u;
  v8 = *(v7 + 8);
  if (v8)
  {
    v8 = *(v8 & 0xFFFFFFFFFFFFFFFELL);
  }

  google::protobuf::internal::ArenaStringPtr::Set((v7 + 56), __p, v8);
  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  v9 = a1[1];
  v10 = *v9;
  v11 = *(*v9 + 23);
  if (v11 < 0)
  {
    v11 = *(v10 + 8);
  }

  v12 = *(v7 + 40);
  *(v7 + 40) = v12 | 8;
  *(v7 + 68) = v11;
  v13 = *(v10 + 23);
  if (v13 < 0)
  {
    v13 = *(v10 + 8);
  }

  *(v7 + 40) = v12 | 0x18;
  *(v7 + 72) = v13 + __len;
  return std::string::append(v10, __src, __len);
}

void sub_1B5AB870C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::SentencePieceProcessor::Decode(uint64_t a1@<X0>, signed int **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  memset(&v18, 0, sizeof(v18));
  v8 = (*(*a1 + 344))(a1);
  std::vector<std::string>::reserve(&v18, a2[1] - *a2);
  v9 = *a2;
  v10 = a2[1];
  while (1)
  {
    if (v9 == v10)
    {
      (*(*a1 + 224))(a1, &v18, a3);
      goto LABEL_15;
    }

    v11 = *v9;
    v17 = v11;
    if (v11 < 0 || v11 >= v8)
    {
      break;
    }

    v12 = (*(*a1 + 360))(a1);
    end = v18.__end_;
    if (v18.__end_ >= v18.__end_cap_.__value_)
    {
      v15 = std::vector<std::string>::__emplace_back_slow_path<std::string const&>(&v18, v12);
    }

    else
    {
      if (*(v12 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v18.__end_, *v12, *(v12 + 8));
      }

      else
      {
        v14 = *v12;
        v18.__end_->__r_.__value_.__r.__words[2] = *(v12 + 16);
        *&end->__r_.__value_.__l.__data_ = v14;
      }

      v15 = end + 1;
    }

    v18.__end_ = v15;
    ++v9;
  }

  absl::StrCat<int>("Invalid id: ", 0xCuLL, &v17, &__p);
  sentencepiece::util::Status::Status(a4, 11, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

LABEL_15:
  __p.__r_.__value_.__r.__words[0] = &v18;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&__p);
}

void sub_1B5AB88E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  __p = &a17;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&__p);
  _Unwind_Resume(a1);
}

void absl::StrCat<int>(void *__src@<X0>, size_t __len@<X1>, unsigned int *a3@<X2>, std::string *a4@<X8>)
{
  std::string::basic_string[abi:ne200100](&__dst, __src, __len);
  absl::StrCat(*a3);
  if ((v10 & 0x80u) == 0)
  {
    v6 = __p;
  }

  else
  {
    v6 = __p[0];
  }

  if ((v10 & 0x80u) == 0)
  {
    v7 = v10;
  }

  else
  {
    v7 = __p[1];
  }

  v8 = std::string::append(&__dst, v6, v7);
  *a4 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (v10 < 0)
  {
    operator delete(__p[0]);
  }

  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_1B5AB89D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (a20 < 0)
  {
    operator delete(a15);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::SentencePieceProcessor::EncodeAsSerializedProto(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  sentencepiece::SentencePieceText::SentencePieceText(v10, 0);
  (*(*a1 + 184))(&v9, a1, a2, a3, v10);
  v8 = v9;
  sentencepiece::util::Status::~Status(&v9);
  if (v8)
  {
    std::string::basic_string[abi:ne200100]<0>(a4, "");
  }

  else
  {
    google::protobuf::MessageLite::SerializeAsString(v10, a4);
  }

  sentencepiece::SentencePieceText::~SentencePieceText(v10);
}

void sub_1B5AB8AC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::SentencePieceText::~SentencePieceText(va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::SampleEncodeAsSerializedProto(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>, float a6@<S0>)
{
  sentencepiece::SentencePieceText::SentencePieceText(v14, 0);
  (*(*a1 + 200))(&v13, a1, a2, a3, a4, v14, a6);
  v12 = v13;
  sentencepiece::util::Status::~Status(&v13);
  if (v12)
  {
    std::string::basic_string[abi:ne200100]<0>(a5, "");
  }

  else
  {
    google::protobuf::MessageLite::SerializeAsString(v14, a5);
  }

  sentencepiece::SentencePieceText::~SentencePieceText(v14);
}

void sub_1B5AB8BB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::SentencePieceText::~SentencePieceText(va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::NBestEncodeAsSerializedProto(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  sentencepiece::NBestSentencePieceText::NBestSentencePieceText(v12, 0);
  (*(*a1 + 192))(&v11, a1, a2, a3, a4, v12);
  v10 = v11;
  sentencepiece::util::Status::~Status(&v11);
  if (v10)
  {
    std::string::basic_string[abi:ne200100]<0>(a5, "");
  }

  else
  {
    google::protobuf::MessageLite::SerializeAsString(v12, a5);
  }

  sentencepiece::NBestSentencePieceText::~NBestSentencePieceText(v12);
}

void sub_1B5AB8C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sentencepiece::NBestSentencePieceText::~NBestSentencePieceText(va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::DecodePiecesAsSerializedProto(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  sentencepiece::SentencePieceText::SentencePieceText(v8, 0);
  (*(*a1 + 224))(&v7, a1, a2, v8);
  v6 = v7;
  sentencepiece::util::Status::~Status(&v7);
  if (v6)
  {
    std::string::basic_string[abi:ne200100]<0>(a3, "");
  }

  else
  {
    google::protobuf::MessageLite::SerializeAsString(v8, a3);
  }

  sentencepiece::SentencePieceText::~SentencePieceText(v8);
}

void sub_1B5AB8D58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::SentencePieceText::~SentencePieceText(va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::DecodeIdsAsSerializedProto(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  sentencepiece::SentencePieceText::SentencePieceText(v8, 0);
  (*(*a1 + 232))(&v7, a1, a2, v8);
  v6 = v7;
  sentencepiece::util::Status::~Status(&v7);
  if (v6)
  {
    std::string::basic_string[abi:ne200100]<0>(a3, "");
  }

  else
  {
    google::protobuf::MessageLite::SerializeAsString(v8, a3);
  }

  sentencepiece::SentencePieceText::~SentencePieceText(v8);
}

void sub_1B5AB8E20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::SentencePieceText::~SentencePieceText(va);
  _Unwind_Resume(a1);
}

uint64_t sentencepiece::SentencePieceProcessor::GetPieceSize(sentencepiece::SentencePieceProcessor *this)
{
  (*(*this + 56))(&v17);
  v2 = v17;
  sentencepiece::util::Status::~Status(&v17);
  if (!v2)
  {
    return (*(**(this + 1) + 144))(*(this + 1));
  }

  if (sentencepiece::logging::GetMinLogLevel(v3) <= 2)
  {
    v16 = 0;
    v4 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "sentencepiece_processor.cc", 26);
    v5 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v4, "(", 1);
    v6 = MEMORY[0x1B8C84C00](v5, 721);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, ") ", 2);
    v8 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v7, "LOG(", 4);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, "ERROR", 5);
    v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, ") ", 2);
    (*(*this + 56))(&v17, this);
    v11 = sentencepiece::util::Status::error_message(&v17);
    v12 = strlen(v11);
    v13 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, v11, v12);
    v14 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v13, "\nReturns default value ", 23);
    MEMORY[0x1B8C84C00](v14, 0);
    sentencepiece::util::Status::~Status(&v17);
    sentencepiece::error::Die::~Die(&v16);
  }

  return 0;
}

uint64_t sentencepiece::SentencePieceProcessor::PieceToId(void **a1, uint64_t a2, uint64_t a3)
{
  ((*a1)[7])(&v21);
  v6 = v21;
  sentencepiece::util::Status::~Status(&v21);
  if (!v6)
  {
    return (*(*a1[1] + 128))(a1[1], a2, a3);
  }

  if (sentencepiece::logging::GetMinLogLevel(v7) <= 2)
  {
    v20 = 0;
    v8 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "sentencepiece_processor.cc", 26);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, "(", 1);
    v10 = MEMORY[0x1B8C84C00](v9, 726);
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, ") ", 2);
    v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, "LOG(", 4);
    v13 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, "ERROR", 5);
    v14 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v13, ") ", 2);
    ((*a1)[7])(&v21, a1);
    v15 = sentencepiece::util::Status::error_message(&v21);
    v16 = strlen(v15);
    v17 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v14, v15, v16);
    v18 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v17, "\nReturns default value ", 23);
    MEMORY[0x1B8C84C00](v18, 0);
    sentencepiece::util::Status::~Status(&v21);
    sentencepiece::error::Die::~Die(&v20);
  }

  return 0;
}

uint64_t sentencepiece::SentencePieceProcessor::IdToPiece(sentencepiece::SentencePieceProcessor *this, uint64_t a2)
{
  {
    operator new();
  }

  (*(*this + 56))(&v22, this);
  v4 = v22;
  sentencepiece::util::Status::~Status(&v22);
  if (!v4)
  {
    return (*(**(this + 1) + 136))(*(this + 1), a2);
  }

  if (sentencepiece::logging::GetMinLogLevel(v5) <= 2)
  {
    v21 = 0;
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "sentencepiece_processor.cc", 26);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, "(", 1);
    v8 = MEMORY[0x1B8C84C00](v7, 732);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, ") ", 2);
    v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "LOG(", 4);
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, "ERROR", 5);
    v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, ") ", 2);
    (*(*this + 56))(&v22, this);
    v13 = sentencepiece::util::Status::error_message(&v22);
    v14 = strlen(v13);
    v15 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, v13, v14);
    v16 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v15, "\nReturns default value ", 23);
    v17 = *(sentencepiece::SentencePieceProcessor::IdToPiece(int)const::kEmptyString + 23);
    if (v17 >= 0)
    {
      v18 = sentencepiece::SentencePieceProcessor::IdToPiece(int)const::kEmptyString;
    }

    else
    {
      v18 = *sentencepiece::SentencePieceProcessor::IdToPiece(int)const::kEmptyString;
    }

    if (v17 >= 0)
    {
      v19 = *(sentencepiece::SentencePieceProcessor::IdToPiece(int)const::kEmptyString + 23);
    }

    else
    {
      v19 = *(sentencepiece::SentencePieceProcessor::IdToPiece(int)const::kEmptyString + 8);
    }

    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v16, v18, v19);
    sentencepiece::util::Status::~Status(&v22);
    sentencepiece::error::Die::~Die(&v21);
  }

  return sentencepiece::SentencePieceProcessor::IdToPiece(int)const::kEmptyString;
}

float sentencepiece::SentencePieceProcessor::GetScore(sentencepiece::SentencePieceProcessor *this, uint64_t a2)
{
  (*(*this + 56))(&v20);
  v4 = v20;
  sentencepiece::util::Status::~Status(&v20);
  if (!v4)
  {
    return (*(**(this + 1) + 152))(*(this + 1), a2);
  }

  v6 = 0.0;
  if (sentencepiece::logging::GetMinLogLevel(v5) <= 2)
  {
    v19 = 0;
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "sentencepiece_processor.cc", 26);
    v8 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v7, "(", 1);
    v9 = MEMORY[0x1B8C84C00](v8, 737);
    v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, ") ", 2);
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, "LOG(", 4);
    v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, "ERROR", 5);
    v13 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, ") ", 2);
    (*(*this + 56))(&v20, this);
    v14 = sentencepiece::util::Status::error_message(&v20);
    v15 = strlen(v14);
    v16 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v13, v14, v15);
    v17 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v16, "\nReturns default value ", 23);
    MEMORY[0x1B8C84BE0](v17, 0.0);
    sentencepiece::util::Status::~Status(&v20);
    sentencepiece::error::Die::~Die(&v19);
  }

  return v6;
}

uint64_t sentencepiece::SentencePieceProcessor::IsControl(sentencepiece::SentencePieceProcessor *this, uint64_t a2)
{
  (*(*this + 56))(&v19);
  v4 = v19;
  sentencepiece::util::Status::~Status(&v19);
  if (!v4)
  {
    return (*(**(this + 1) + 168))(*(this + 1), a2);
  }

  if (sentencepiece::logging::GetMinLogLevel(v5) <= 2)
  {
    v18 = 0;
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "sentencepiece_processor.cc", 26);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, "(", 1);
    v8 = MEMORY[0x1B8C84C00](v7, 742);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, ") ", 2);
    v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "LOG(", 4);
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, "ERROR", 5);
    v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, ") ", 2);
    (*(*this + 56))(&v19, this);
    v13 = sentencepiece::util::Status::error_message(&v19);
    v14 = strlen(v13);
    v15 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, v13, v14);
    v16 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v15, "\nReturns default value ", 23);
    MEMORY[0x1B8C84C00](v16, 0);
    sentencepiece::util::Status::~Status(&v19);
    sentencepiece::error::Die::~Die(&v18);
  }

  return 0;
}

uint64_t sentencepiece::SentencePieceProcessor::IsUnknown(sentencepiece::SentencePieceProcessor *this, uint64_t a2)
{
  (*(*this + 56))(&v19);
  v4 = v19;
  sentencepiece::util::Status::~Status(&v19);
  if (!v4)
  {
    return (*(**(this + 1) + 160))(*(this + 1), a2);
  }

  if (sentencepiece::logging::GetMinLogLevel(v5) <= 2)
  {
    v18 = 0;
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "sentencepiece_processor.cc", 26);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, "(", 1);
    v8 = MEMORY[0x1B8C84C00](v7, 747);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, ") ", 2);
    v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "LOG(", 4);
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, "ERROR", 5);
    v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, ") ", 2);
    (*(*this + 56))(&v19, this);
    v13 = sentencepiece::util::Status::error_message(&v19);
    v14 = strlen(v13);
    v15 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, v13, v14);
    v16 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v15, "\nReturns default value ", 23);
    MEMORY[0x1B8C84C00](v16, 0);
    sentencepiece::util::Status::~Status(&v19);
    sentencepiece::error::Die::~Die(&v18);
  }

  return 0;
}

uint64_t sentencepiece::SentencePieceProcessor::IsUnused(sentencepiece::SentencePieceProcessor *this, uint64_t a2)
{
  (*(*this + 56))(&v19);
  v4 = v19;
  sentencepiece::util::Status::~Status(&v19);
  if (!v4)
  {
    return (*(**(this + 1) + 176))(*(this + 1), a2);
  }

  if (sentencepiece::logging::GetMinLogLevel(v5) <= 2)
  {
    v18 = 0;
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "sentencepiece_processor.cc", 26);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, "(", 1);
    v8 = MEMORY[0x1B8C84C00](v7, 752);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, ") ", 2);
    v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "LOG(", 4);
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, "ERROR", 5);
    v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, ") ", 2);
    (*(*this + 56))(&v19, this);
    v13 = sentencepiece::util::Status::error_message(&v19);
    v14 = strlen(v13);
    v15 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, v13, v14);
    v16 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v15, "\nReturns default value ", 23);
    MEMORY[0x1B8C84BD0](v16, 0);
    sentencepiece::util::Status::~Status(&v19);
    sentencepiece::error::Die::~Die(&v18);
  }

  return 0;
}

uint64_t sentencepiece::SentencePieceProcessor::IsByte(sentencepiece::SentencePieceProcessor *this, uint64_t a2)
{
  (*(*this + 56))(&v19);
  v4 = v19;
  sentencepiece::util::Status::~Status(&v19);
  if (!v4)
  {
    return (*(**(this + 1) + 192))(*(this + 1), a2);
  }

  if (sentencepiece::logging::GetMinLogLevel(v5) <= 2)
  {
    v18 = 0;
    v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "sentencepiece_processor.cc", 26);
    v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, "(", 1);
    v8 = MEMORY[0x1B8C84C00](v7, 757);
    v9 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, ") ", 2);
    v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v9, "LOG(", 4);
    v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, "ERROR", 5);
    v12 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v11, ") ", 2);
    (*(*this + 56))(&v19, this);
    v13 = sentencepiece::util::Status::error_message(&v19);
    v14 = strlen(v13);
    v15 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, v13, v14);
    v16 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v15, "\nReturns default value ", 23);
    MEMORY[0x1B8C84BD0](v16, 0);
    sentencepiece::util::Status::~Status(&v19);
    sentencepiece::error::Die::~Die(&v18);
  }

  return 0;
}

uint64_t sentencepiece::SentencePieceProcessor::unk_id(sentencepiece::ModelInterface **this)
{
  v2 = sentencepiece::ModelInterface::unk_piece(this[1]);
  v3 = v2;
  if (v2)
  {
    v4 = strlen(v2);
  }

  else
  {
    v4 = 0;
  }

  v5 = (*(*this + 44))(this, v3, v4);
  if ((*(*this + 47))(this, v5))
  {
    return v5;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sentencepiece::SentencePieceProcessor::bos_id(sentencepiece::ModelInterface **this)
{
  v2 = sentencepiece::ModelInterface::bos_piece(this[1]);
  v3 = v2;
  if (v2)
  {
    v4 = strlen(v2);
  }

  else
  {
    v4 = 0;
  }

  v5 = (*(*this + 44))(this, v3, v4);
  if ((*(*this + 48))(this, v5))
  {
    return v5;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sentencepiece::SentencePieceProcessor::eos_id(sentencepiece::ModelInterface **this)
{
  v2 = sentencepiece::ModelInterface::eos_piece(this[1]);
  v3 = v2;
  if (v2)
  {
    v4 = strlen(v2);
  }

  else
  {
    v4 = 0;
  }

  v5 = (*(*this + 44))(this, v3, v4);
  if ((*(*this + 48))(this, v5))
  {
    return v5;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sentencepiece::SentencePieceProcessor::pad_id(sentencepiece::ModelInterface **this)
{
  v2 = sentencepiece::ModelInterface::pad_piece(this[1]);
  v3 = v2;
  if (v2)
  {
    v4 = strlen(v2);
  }

  else
  {
    v4 = 0;
  }

  v5 = (*(*this + 44))(this, v3, v4);
  if ((*(*this + 48))(this, v5))
  {
    return v5;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }
}

void sentencepiece::SentencePieceProcessor::EncodeAsPieces(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  (*(*a1 + 104))(&v2);
  quasar::Bitmap::~Bitmap(&v2);
  sentencepiece::util::Status::~Status(&v2);
}

void sub_1B5ABA074(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::Status::~Status(va);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::EncodeAsIds(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  (*(*a1 + 112))(&v2);
  quasar::Bitmap::~Bitmap(&v2);
  sentencepiece::util::Status::~Status(&v2);
}

void sub_1B5ABA108(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::Status::~Status(va);
  v4 = *v2;
  if (*v2)
  {
    *(v2 + 8) = v4;
    operator delete(v4);
  }

  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::NBestEncodeAsPieces(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  (*(*a1 + 152))(&v2);
  quasar::Bitmap::~Bitmap(&v2);
  sentencepiece::util::Status::~Status(&v2);
}

void sub_1B5ABA1A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::Status::~Status(va);
  std::vector<std::vector<std::string>>::__destroy_vector::operator()[abi:ne200100](va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::NBestEncodeAsIds(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  (*(*a1 + 160))(&v2);
  quasar::Bitmap::~Bitmap(&v2);
  sentencepiece::util::Status::~Status(&v2);
}

void sub_1B5ABA234(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::Status::~Status(va);
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne200100](va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::SampleEncodeAsPieces(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  (*(*a1 + 168))(&v2);
  quasar::Bitmap::~Bitmap(&v2);
  sentencepiece::util::Status::~Status(&v2);
}

void sub_1B5ABA2C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::Status::~Status(va);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](va);
  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::SampleEncodeAsIds(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  (*(*a1 + 176))(&v2);
  quasar::Bitmap::~Bitmap(&v2);
  sentencepiece::util::Status::~Status(&v2);
}

void sub_1B5ABA35C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::Status::~Status(va);
  v4 = *v2;
  if (*v2)
  {
    *(v2 + 8) = v4;
    operator delete(v4);
  }

  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::DecodePieces(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  (*(*a1 + 120))(&v2);
  quasar::Bitmap::~Bitmap(&v2);
  sentencepiece::util::Status::~Status(&v2);
}

void sub_1B5ABA3F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::Status::~Status(va);
  if (*(v2 + 23) < 0)
  {
    operator delete(*v2);
  }

  _Unwind_Resume(a1);
}

void sentencepiece::SentencePieceProcessor::DecodeIds(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  (*(*a1 + 128))(&v2);
  quasar::Bitmap::~Bitmap(&v2);
  sentencepiece::util::Status::~Status(&v2);
}

void sub_1B5ABA48C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::util::Status::~Status(va);
  if (*(v2 + 23) < 0)
  {
    operator delete(*v2);
  }

  _Unwind_Resume(a1);
}

void *absl::internal::Splitter::Splitter(void *a1, uint64_t a2, unint64_t a3, unsigned __int8 *a4, uint64_t a5, int a6)
{
  v17 = a2;
  v18 = a3;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  first_of = absl::string_view::find_first_of(&v17, a4, a5, 0);
  if (first_of == -1)
  {
    v12 = 0;
  }

  else
  {
    v11 = first_of;
    v12 = 0;
    do
    {
      v13 = v11 - v12;
      v14 = v11 >= v12;
      if (!a6)
      {
        v14 = v11 > v12;
      }

      if (v14)
      {
        if (v18 - v12 < v13)
        {
          v13 = v18 - v12;
        }

        *&v16 = v17 + v12;
        *(&v16 + 1) = v13;
        std::vector<std::string_view>::push_back[abi:ne200100](a1, &v16);
      }

      v12 = v11 + 1;
      v11 = absl::string_view::find_first_of(&v17, a4, a5, v11 + 1);
    }

    while (v11 != -1);
  }

  if (v18 > v12)
  {
    *&v16 = v17 + v12;
    *(&v16 + 1) = v18 - v12;
    std::vector<std::string_view>::push_back[abi:ne200100](a1, &v16);
  }

  return a1;
}

void sub_1B5ABA5C0(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void absl::StrReplaceAll(void *__src@<X0>, size_t __len@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  std::string::basic_string[abi:ne200100](&__dst, __src, __len);
  *a4 = 0;
  *(a4 + 8) = 0;
  *(a4 + 16) = 0;
  v6 = *a3;
  v7 = a3[1];
  while (v6 != v7)
  {
    if (*(a4 + 23) < 0)
    {
      **a4 = 0;
      *(a4 + 8) = 0;
    }

    else
    {
      *a4 = 0;
      *(a4 + 23) = 0;
    }

    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      p_dst = &__dst;
    }

    else
    {
      p_dst = __dst.__r_.__value_.__r.__words[0];
    }

    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = __dst.__r_.__value_.__l.__size_;
    }

    v10 = *v6;
    v11 = *(v6 + 8);
    v12 = *(v6 + 16);
    v13 = *(v6 + 24);
    v18 = p_dst;
    v19 = size;
    if (v11)
    {
      v14 = absl::string_view::find(&v18, v10, v11, 0);
      if (v14 == -1)
      {
        v16 = 0;
      }

      else
      {
        v15 = v14;
        v16 = 0;
        do
        {
          std::string::append(a4, v18 + v16, v15 - v16);
          std::string::append(a4, v12, v13);
          v16 = v15 + v11;
          v15 = absl::string_view::find(&v18, v10, v11, v15 + v11);
        }

        while (v15 != -1);
      }

      std::string::append(a4, v18 + v16, v19 - v16);
    }

    else
    {
      std::string::append(a4, p_dst, size);
    }

    std::string::operator=(&__dst, a4);
    v6 += 32;
  }

  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_1B5ABA754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*(v15 + 23) < 0)
  {
    operator delete(*v15);
  }

  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::pair<absl::string_view,absl::string_view>>::__init_with_size[abi:ne200100]<std::pair<absl::string_view,absl::string_view> const*,std::pair<absl::string_view,absl::string_view> const*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<std::pair<absl::string_view,absl::string_view>>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1B5ABA7DC(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<absl::string_view,absl::string_view>>::__vallocate[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 59))
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<std::string_view,std::string_view>>>(a1, a2);
  }

  std::vector<int>::__throw_length_error[abi:ne200100]();
}

sentencepiece::ModelProto *std::unique_ptr<sentencepiece::ModelProto>::reset[abi:ne200100](sentencepiece::ModelProto **a1, sentencepiece::ModelProto *a2)
{
  result = *a1;
  *a1 = a2;
  if (result)
  {
    sentencepiece::ModelProto::~ModelProto(result);

    JUMPOUT(0x1B8C85350);
  }

  return result;
}

void absl::StrCat<std::string,char [2],std::string>(void *__src@<X0>, size_t __len@<X1>, void **a3@<X2>, char *a4@<X3>, void **a5@<X4>, std::string *a6@<X8>)
{
  std::string::basic_string[abi:ne200100](&__dst, __src, __len);
  v10 = *(a3 + 23);
  if (v10 >= 0)
  {
    v11 = a3;
  }

  else
  {
    v11 = *a3;
  }

  if (v10 >= 0)
  {
    v12 = *(a3 + 23);
  }

  else
  {
    v12 = a3[1];
  }

  absl::StrCat<char [2],std::string>(v11, v12, a4, a5, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v15 = std::string::append(&__dst, p_p, size);
  *a6 = *v15;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_1B5ABA950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (a20 < 0)
  {
    operator delete(a15);
  }

  _Unwind_Resume(exception_object);
}

void absl::StrCat<char [2],std::string>(void *__src@<X0>, size_t __len@<X1>, char *a3@<X2>, void **a4@<X3>, std::string *a5@<X8>)
{
  std::string::basic_string[abi:ne200100](&__dst, __src, __len);
  v8 = strlen(a3);
  absl::StrCat<std::string>(a3, v8, a4, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v11 = std::string::append(&__dst, p_p, size);
  *a5 = *v11;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_1B5ABAA44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (a20 < 0)
  {
    operator delete(a15);
  }

  _Unwind_Resume(exception_object);
}

void absl::StrCat<std::string>(void *__src@<X0>, size_t __len@<X1>, void **a3@<X2>, std::string *a4@<X8>)
{
  std::string::basic_string[abi:ne200100](&__dst, __src, __len);
  v6 = *(a3 + 23);
  if (v6 >= 0)
  {
    v7 = a3;
  }

  else
  {
    v7 = *a3;
  }

  if (v6 >= 0)
  {
    v8 = *(a3 + 23);
  }

  else
  {
    v8 = a3[1];
  }

  std::string::basic_string[abi:ne200100](__p, v7, v8);
  if ((v13 & 0x80u) == 0)
  {
    v9 = __p;
  }

  else
  {
    v9 = __p[0];
  }

  if ((v13 & 0x80u) == 0)
  {
    v10 = v13;
  }

  else
  {
    v10 = __p[1];
  }

  v11 = std::string::append(&__dst, v9, v10);
  *a4 = *v11;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (v13 < 0)
  {
    operator delete(__p[0]);
  }

  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_1B5ABAB30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (a20 < 0)
  {
    operator delete(a15);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::vector<std::string>>::__construct_one_at_end[abi:ne200100]<std::vector<std::string>&>(uint64_t a1, uint64_t *a2)
{
  v3 = *(a1 + 8);
  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  result = std::vector<std::string>::__init_with_size[abi:ne200100]<std::string*,std::string*>(v3, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  *(a1 + 8) = v3 + 3;
  return result;
}

uint64_t std::vector<std::vector<std::string>>::__emplace_back_slow_path<std::vector<std::string>&>(uint64_t a1, uint64_t *a2)
{
  v2 = 0xAAAAAAAAAAAAAAABLL * ((*(a1 + 8) - *a1) >> 3);
  v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL)
  {
    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  if (0x5555555555555556 * ((*(a1 + 16) - *a1) >> 3) > v3)
  {
    v3 = 0x5555555555555556 * ((*(a1 + 16) - *a1) >> 3);
  }

  if (0xAAAAAAAAAAAAAAABLL * ((*(a1 + 16) - *a1) >> 3) >= 0x555555555555555)
  {
    v6 = 0xAAAAAAAAAAAAAAALL;
  }

  else
  {
    v6 = v3;
  }

  v18 = a1;
  if (v6)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<std::vector<quasar::Token>>>(a1, v6);
  }

  v7 = 24 * v2;
  v14 = 0;
  v15 = v7;
  v16 = 24 * v2;
  v17 = 0;
  *v7 = 0;
  *(v7 + 8) = 0;
  *(v7 + 16) = 0;
  std::vector<std::string>::__init_with_size[abi:ne200100]<std::string*,std::string*>(24 * v2, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  v8 = v16 + 24;
  v9 = *(a1 + 8) - *a1;
  v10 = &v15[-v9];
  memcpy(&v15[-v9], *a1, v9);
  v11 = *a1;
  *a1 = v10;
  *(a1 + 8) = v8;
  v12 = *(a1 + 16);
  *(a1 + 16) = v17;
  v16 = v11;
  v17 = v12;
  v14 = v11;
  v15 = v11;
  std::__split_buffer<std::vector<std::string>>::~__split_buffer(&v14);
  return v8;
}

void sub_1B5ABACEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<std::string>>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<int>>::__construct_one_at_end[abi:ne200100]<std::vector<int>&>(uint64_t a1, uint64_t *a2)
{
  v3 = *(a1 + 8);
  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  result = std::vector<int>::__init_with_size[abi:ne200100]<int *,int *>(v3, *a2, a2[1], (a2[1] - *a2) >> 2);
  *(a1 + 8) = v3 + 3;
  return result;
}

uint64_t std::vector<std::vector<int>>::__emplace_back_slow_path<std::vector<int>&>(uint64_t a1, uint64_t *a2)
{
  v2 = 0xAAAAAAAAAAAAAAABLL * ((*(a1 + 8) - *a1) >> 3);
  v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL)
  {
    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  if (0x5555555555555556 * ((*(a1 + 16) - *a1) >> 3) > v3)
  {
    v3 = 0x5555555555555556 * ((*(a1 + 16) - *a1) >> 3);
  }

  if (0xAAAAAAAAAAAAAAABLL * ((*(a1 + 16) - *a1) >> 3) >= 0x555555555555555)
  {
    v6 = 0xAAAAAAAAAAAAAAALL;
  }

  else
  {
    v6 = v3;
  }

  v18 = a1;
  if (v6)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<std::vector<int>>>(a1, v6);
  }

  v7 = 24 * v2;
  v14 = 0;
  v15 = v7;
  v16 = 24 * v2;
  v17 = 0;
  *v7 = 0;
  *(v7 + 8) = 0;
  *(v7 + 16) = 0;
  std::vector<int>::__init_with_size[abi:ne200100]<int *,int *>(24 * v2, *a2, a2[1], (a2[1] - *a2) >> 2);
  v8 = v16 + 24;
  v9 = *(a1 + 8) - *a1;
  v10 = &v15[-v9];
  memcpy(&v15[-v9], *a1, v9);
  v11 = *a1;
  *a1 = v10;
  *(a1 + 8) = v8;
  v12 = *(a1 + 16);
  *(a1 + 16) = v17;
  v16 = v11;
  v17 = v12;
  v14 = v11;
  v15 = v11;
  std::__split_buffer<std::vector<int>>::~__split_buffer(&v14);
  return v8;
}

void sub_1B5ABAE70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<int>>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

void *std::discrete_distribution<int>::param_type::param_type[abi:ne200100]<std::__wrap_iter<float *>>(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<double>::__init_with_size[abi:ne200100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>(a1, a2, a3, (a3 - a2) >> 2);
  std::discrete_distribution<int>::param_type::__init(a1);
  return a1;
}

void sub_1B5ABAEC4(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::discrete_distribution<int>::param_type::__init(uint64_t a1)
{
  v1 = *a1;
  v2 = *(a1 + 8);
  if (*a1 != v2)
  {
    v4 = v2 - v1;
    if (v4 < 2)
    {
      *(a1 + 8) = v1;

      std::vector<double>::shrink_to_fit(a1);
    }

    else
    {
      v5 = 0.0;
      v6 = *a1;
      do
      {
        v7 = *v6++;
        v5 = v5 + v7;
      }

      while (v6 != v2);
      while (v1 < v2)
      {
        *v1 = *v1 / v5;
        ++v1;
      }

      std::vector<double>::vector[abi:ne200100](&v16, v4 - 1);
      v8 = *a1;
      v9 = *(a1 + 8) - 8;
      v10 = v16;
      if (v9 != *a1)
      {
        v11 = v8 + 1;
        v12 = *v8;
        *v16 = *v8;
        if (v8 + 1 != v9)
        {
          v13 = v10 + 1;
          do
          {
            v14 = *v11++;
            v12 = v12 + v14;
            *v13++ = v12;
          }

          while (v11 != v9);
        }
      }

      *a1 = v10;
      v15 = *(a1 + 16);
      *(a1 + 8) = v17;
      v16 = v8;
      *(&v17 + 1) = v15;
      if (v8)
      {
        *&v17 = v8;
        operator delete(v8);
      }
    }
  }
}

uint64_t std::vector<double>::__init_with_size[abi:ne200100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<long long>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1B5ABB048(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<double>::shrink_to_fit(const void **a1)
{
  v1 = a1[1];
  v2 = *a1;
  v3 = a1[2] - *a1;
  v4 = v1 - *a1;
  if (v3 > v4)
  {
    if (v1 != v2)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<unsigned long>>(a1, v4 >> 3);
    }

    v6 = 0;
    if (v3 >> 3)
    {
      v7 = 8 * (v4 >> 3);
      v8 = a1[1] - v2;
      v9 = v7 - v8;
      memcpy((v7 - v8), v2, v8);
      v6 = *a1;
      *a1 = v9;
      a1[1] = v7;
      a1[2] = 0;
    }

    if (v6)
    {

      operator delete(v6);
    }
  }
}

unint64_t std::discrete_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(int a1, std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this, double **a3)
{
  v5 = *a3;
  v6 = a3[1];
  v7 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this);
  v8 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this);
  if (v6 != v5)
  {
    v9 = v6 - v5;
    do
    {
      v10 = v9 >> 1;
      v11 = &v5[v9 >> 1];
      v13 = *v11;
      v12 = v11 + 1;
      v9 += ~(v9 >> 1);
      if ((v7 + v8 * 4294967300.0) * 5.42101086e-20 < v13)
      {
        v9 = v10;
      }

      else
      {
        v5 = v12;
      }
    }

    while (v9);
    v6 = v5;
  }

  return (v6 - *a3) >> 3;
}

uint64_t absl::StrCat(absl *this)
{
  std::ostringstream::basic_ostringstream[abi:ne200100](&v3);
  MEMORY[0x1B8C84C00](&v3, this);
  std::stringbuf::str();
  v3 = *MEMORY[0x1E69E54E8];
  *(&v3 + *(v3 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v4 = MEMORY[0x1E69E5548] + 16;
  if (v6 < 0)
  {
    operator delete(v5[7].__locale_);
  }

  v4 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v5);
  std::ostream::~ostream();
  return MEMORY[0x1B8C85200](&v7);
}

void sub_1B5ABB338(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream(va);
  _Unwind_Resume(a1);
}

uint64_t sentencepiece::swap(uint64_t this, uint64_t a2, sentencepiece::SentencePieceText_SentencePiece *a3)
{
  if (a2 != this)
  {
    v3 = *(this + 8);
    if (v3)
    {
      v3 = *(v3 & 0xFFFFFFFFFFFFFFFELL);
    }

    v4 = *(a2 + 8);
    if (v4)
    {
      v4 = *(v4 & 0xFFFFFFFFFFFFFFFELL);
    }

    if (v3 == v4)
    {
      return sentencepiece::SentencePieceText_SentencePiece::InternalSwap(this, a2);
    }

    else
    {
      return google::protobuf::internal::GenericSwap(this, a2);
    }
  }

  return this;
}

void *std::map<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>::map[abi:ne200100](void *a1, uint64_t a2, uint64_t a3)
{
  a1[1] = 0;
  v4 = a1 + 1;
  a1[2] = 0;
  *a1 = a1 + 1;
  if (a3)
  {
    v6 = 24 * a3;
    do
    {
      std::__tree<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::__map_value_compare<absl::string_view,std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::less<absl::string_view>,true>,std::allocator<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>>>::__emplace_hint_unique_key_args<absl::string_view,std::pair<absl::string_view const,sentencepiece::SentencePieceProcessor::ExtraOption> const&>(a1, v4, a2);
      a2 += 24;
      v6 -= 24;
    }

    while (v6);
  }

  return a1;
}

uint64_t std::__tree<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::__map_value_compare<absl::string_view,std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::less<absl::string_view>,true>,std::allocator<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>>>::__emplace_hint_unique_key_args<absl::string_view,std::pair<absl::string_view const,sentencepiece::SentencePieceProcessor::ExtraOption> const&>(void *a1, void *a2, uint64_t a3)
{
  v3 = *std::__tree<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::__map_value_compare<absl::string_view,std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::less<absl::string_view>,true>,std::allocator<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>>>::__find_equal<absl::string_view>(a1, a2, &v6, &v5, a3);
  if (!v3)
  {
    operator new();
  }

  return v3;
}

uint64_t *std::__tree<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::__map_value_compare<absl::string_view,std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::less<absl::string_view>,true>,std::allocator<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>>>::__find_equal<absl::string_view>(void *a1, void *a2, void *a3, uint64_t *a4, uint64_t a5)
{
  v9 = a1 + 1;
  if (a1 + 1 != a2 && !std::less<absl::string_view>::operator()[abi:ne200100](a1, a5, (a2 + 4)))
  {
    if (!std::less<absl::string_view>::operator()[abi:ne200100](a1, (a2 + 4), a5))
    {
      *a3 = a2;
      *a4 = a2;
      return a4;
    }

    a4 = a2 + 1;
    v13 = a2[1];
    if (v13)
    {
      v14 = a2[1];
      do
      {
        v15 = v14;
        v14 = *v14;
      }

      while (v14);
    }

    else
    {
      v18 = a2;
      do
      {
        v15 = v18[2];
        v17 = *v15 == v18;
        v18 = v15;
      }

      while (!v17);
    }

    if (v15 != v9)
    {
      if (!std::less<absl::string_view>::operator()[abi:ne200100](a1, a5, (v15 + 4)))
      {
        goto LABEL_28;
      }

      v13 = *a4;
    }

    if (v13)
    {
      *a3 = v15;
      return v15;
    }

    else
    {
      *a3 = a2;
    }

    return a4;
  }

  if (*a1 == a2)
  {
    v12 = a2;
LABEL_16:
    if (*a2)
    {
      *a3 = v12;
      return v12 + 1;
    }

    else
    {
      *a3 = a2;
      return a2;
    }
  }

  v11 = *a2;
  if (*a2)
  {
    do
    {
      v12 = v11;
      v11 = v11[1];
    }

    while (v11);
  }

  else
  {
    v16 = a2;
    do
    {
      v12 = v16[2];
      v17 = *v12 == v16;
      v16 = v12;
    }

    while (v17);
  }

  if (std::less<absl::string_view>::operator()[abi:ne200100](a1, (v12 + 4), a5))
  {
    goto LABEL_16;
  }

LABEL_28:

  return std::__tree<absl::string_view>::__find_equal<absl::string_view>(a1, a3, a5);
}

uint64_t std::__tree<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::__map_value_compare<absl::string_view,std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>,std::less<absl::string_view>,true>,std::allocator<std::__value_type<absl::string_view,sentencepiece::SentencePieceProcessor::ExtraOption>>>::find<absl::string_view>(uint64_t a1, uint64_t a2)
{
  v2 = a1 + 8;
  v3 = *(a1 + 8);
  if (!v3)
  {
    return v2;
  }

  v6 = a1 + 8;
  do
  {
    v7 = std::less<absl::string_view>::operator()[abi:ne200100](a1, v3 + 32, a2);
    if (v7)
    {
      v8 = 8;
    }

    else
    {
      v8 = 0;
    }

    if (!v7)
    {
      v6 = v3;
    }

    v3 = *(v3 + v8);
  }

  while (v3);
  if (v6 == v2 || std::less<absl::string_view>::operator()[abi:ne200100](a1, a2, v6 + 32))
  {
    return v2;
  }

  return v6;
}

void sentencepiece::unigram::Lattice::~Lattice(sentencepiece::unigram::Lattice *this)
{
  *this = &unk_1F2D43EF0;
  sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::Node>::~FreeList(this + 12);
  v3 = (this + 72);
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne200100](&v3);
  v3 = (this + 48);
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne200100](&v3);
  v2 = *(this + 3);
  if (v2)
  {
    *(this + 4) = v2;
    operator delete(v2);
  }
}

{
  sentencepiece::unigram::Lattice::~Lattice(this);

  JUMPOUT(0x1B8C85350);
}

uint64_t sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::Node>::Allocate(void *a1)
{
  v2 = a1[5];
  v3 = a1[6];
  v4 = a1[4];
  if (v4 >= v3)
  {
    v4 = 0;
    ++v2;
    a1[4] = 0;
    a1[5] = v2;
  }

  v5 = a1[1];
  if (v2 == (a1[2] - v5) >> 3)
  {
    is_mul_ok(v3, 0x30uLL);
    operator new[]();
  }

  result = *(v5 + 8 * v2) + 48 * v4;
  a1[4] = v4 + 1;
  return result;
}

void sentencepiece::unigram::Lattice::Clear(sentencepiece::unigram::Lattice *this)
{
  std::vector<std::vector<int>>::clear[abi:ne200100](this + 6);
  std::vector<std::vector<int>>::clear[abi:ne200100](this + 9);
  *(this + 1) = "";
  *(this + 2) = 0;
  *(this + 4) = *(this + 3);

  sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::Node>::Free(this + 96);
}

void sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::Node>::Free(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (v2 + 1 < ((*(a1 + 16) - *(a1 + 8)) >> 3))
  {
    v3 = v2 + 1;
  }

  else
  {
    v3 = (*(a1 + 16) - *(a1 + 8)) >> 3;
  }

  if (v3 >= 1)
  {
    v4 = 0;
    v5 = 8 * v3;
    do
    {
      bzero(*(*(a1 + 8) + v4), 48 * *(a1 + 48));
      v4 += 8;
    }

    while (v5 != v4);
  }

  *(a1 + 32) = 0;
  *(a1 + 40) = 0;
}

void sentencepiece::unigram::Lattice::SetSentence(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  sentencepiece::unigram::Lattice::Clear(a1);
  *(a1 + 8) = a2;
  *(a1 + 16) = a3;
  std::vector<wchar_t const*>::reserve((a1 + 24), a3 + 1);
  for (; a3; a3 -= v6)
  {
    if (a3 >= asc_1B5C6FEAB[*a2 >> 4])
    {
      v6 = asc_1B5C6FEAB[*a2 >> 4];
    }

    else
    {
      v6 = a3;
    }

    v15 = a2;
    std::vector<char const*>::push_back[abi:ne200100](a1 + 24, &v15);
    a2 += v6;
  }

  v15 = a2;
  std::vector<char const*>::push_back[abi:ne200100](a1 + 24, &v15);
  v7 = ((*(a1 + 32) - *(a1 + 24)) >> 3) - 1;
  v8 = v7 & ~(v7 >> 31);
  std::vector<std::vector<float>>::resize((a1 + 48), v8 + 1);
  std::vector<std::vector<float>>::resize((a1 + 72), v8 + 1);
  v9 = 0;
  do
  {
    std::vector<fst::VectorState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>> *,std::allocator<fst::VectorState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>> *>>::reserve((*(a1 + 48) + v9), 0x10uLL);
    std::vector<fst::VectorState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>> *,std::allocator<fst::VectorState<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>,std::allocator<fst::ReverseArc<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>>> *>>::reserve((*(a1 + 72) + v9), 0x10uLL);
    v9 += 24;
  }

  while (24 * v8 + 24 != v9);
  v10 = sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::Node>::Allocate((a1 + 96));
  v11 = *(a1 + 128) + *(a1 + 136) * *(a1 + 144) - 1;
  v15 = v10;
  v10[6] = v11;
  v10[7] = -1;
  v10[4] = 0;
  std::vector<TVertex *>::push_back[abi:ne200100](*(a1 + 72), &v15);
  v12 = sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::Node>::Allocate((a1 + 96));
  v13 = *(a1 + 128) + *(a1 + 136) * *(a1 + 144) - 1;
  v14 = v12;
  v12[6] = v13;
  v12[7] = -1;
  v12[4] = v8;
  std::vector<TVertex *>::push_back[abi:ne200100](*(a1 + 48) + 24 * v8, &v14);
}

uint64_t sentencepiece::unigram::Lattice::Insert(sentencepiece::unigram::Lattice *this, int a2, int a3)
{
  v6 = sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::Node>::Allocate(this + 12);
  v7 = *(this + 32) + *(this + 34) * *(this + 36) - 1;
  *(v6 + 20) = a3;
  *(v6 + 24) = v7;
  v12 = v6;
  *(v6 + 16) = a2;
  v8 = *(this + 3);
  v9 = *(v8 + 8 * (a3 + a2));
  v10 = *(v8 + 8 * a2);
  *v6 = v10;
  *(v6 + 8) = v9 - v10;
  std::vector<TVertex *>::push_back[abi:ne200100](*(this + 6) + 24 * a2, &v12);
  std::vector<TVertex *>::push_back[abi:ne200100](*(this + 9) + 24 * (*(v12 + 20) + a2), &v12);
  return v12;
}

void sentencepiece::unigram::Lattice::Viterbi(sentencepiece::unigram::Lattice *this@<X0>, uint64_t a2@<X8>)
{
  v3 = 0;
  v4 = ((*(this + 4) - *(this + 3)) >> 3) - 1;
  v5 = v4 & ~(v4 >> 31);
  v6 = *(this + 6);
  while (1)
  {
    v7 = (v6 + 24 * v3);
    v8 = *v7;
    v9 = v7[1];
    if (v8 != v9)
    {
      break;
    }

LABEL_14:
    if (++v3 == v5 + 1)
    {
      __p = 0;
      v39 = 0;
      v40 = 0;
      v21 = *(v6 + 24 * v5);
      v22 = *(*v21 + 36);
      while (1)
      {
        v37 = *(*v21 + 40);
        if (!*(v37 + 40))
        {
          break;
        }

        v21 = &v37;
        std::vector<TVertex *>::push_back[abi:ne200100](&__p, &v37);
      }

      v30 = __p;
      v31 = v39;
      v32 = v39 - 8;
      if (__p != v39 && v32 > __p)
      {
        v34 = __p + 8;
        do
        {
          v35 = *(v34 - 1);
          *(v34 - 1) = *v32;
          *v32 = v35;
          v32 -= 8;
          v36 = v34 >= v32;
          v34 += 8;
        }

        while (!v36);
        v30 = __p;
        v31 = v39;
      }

      *a2 = 0;
      *(a2 + 8) = 0;
      *(a2 + 16) = 0;
      std::vector<sentencepiece::unigram::Lattice::Node *>::__init_with_size[abi:ne200100]<sentencepiece::unigram::Lattice::Node **,sentencepiece::unigram::Lattice::Node **>(a2, v30, v31, (v31 - v30) >> 3);
      *(a2 + 24) = v22;
      if (__p)
      {
        v39 = __p;
        operator delete(__p);
      }

      return;
    }
  }

  v10 = (*(this + 9) + 24 * v3);
  v11 = *v10;
  v12 = v10[1];
  while (1)
  {
    v13 = *v8;
    *(*v8 + 40) = 0;
    if (v11 == v12)
    {
      break;
    }

    v14 = 0;
    v15 = 0.0;
    v16 = v11;
    do
    {
      v18 = *v16++;
      v17 = v18;
      v19 = *(v18 + 36) + *(v13 + 32);
      if (v19 > v15 || v14 == 0)
      {
        v14 = v17;
        v15 = v19;
      }
    }

    while (v16 != v12);
    if (!v14)
    {
      break;
    }

    *(v13 + 40) = v14;
    *(v13 + 36) = v15;
    if (++v8 == v9)
    {
      goto LABEL_14;
    }
  }

  if (sentencepiece::logging::GetMinLogLevel(this) <= 2)
  {
    LOBYTE(__p) = 0;
    v23 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "unigram_model.cc", 16);
    v24 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v23, "(", 1);
    v25 = MEMORY[0x1B8C84C00](v24, 176);
    v26 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v25, ") ", 2);
    v27 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v26, "LOG(", 4);
    v28 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v27, "ERROR", 5);
    v29 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v28, ") ", 2);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v29, "Failed to find the best path in Viterbi.", 40);
    sentencepiece::error::Die::~Die(&__p);
  }

  *a2 = 0;
  *(a2 + 8) = 0;
  *(a2 + 24) = 0;
  *(a2 + 16) = 0;
}

void sub_1B5ABBDB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::unigram::Lattice::ForwardAlgorithm(sentencepiece::unigram::Lattice *this@<X0>, float a2@<S0>, uint64_t *a3@<X8>)
{
  v5 = ((*(this + 4) - *(this + 3)) >> 3) - 1;
  std::vector<float>::vector[abi:ne200100](a3, *(this + 16) + *(this + 17) * *(this + 18));
  v6 = 0;
  v25 = *(this + 6);
  v23 = this;
  v24 = (v5 & ~(v5 >> 31)) + 1;
  do
  {
    v7 = (v25 + 24 * v6);
    v8 = *v7;
    v9 = v7[1];
    if (*v7 != v9)
    {
      v10 = *(v23 + 9) + 24 * v6;
      v12 = *v10;
      v11 = *(v10 + 8);
      v13 = *a3;
      do
      {
        if (v12 != v11)
        {
          v14 = *(*v8 + 24);
          v15 = *v12;
          v16 = *(v13 + 4 * v14);
          v17 = v12;
          do
          {
            v18 = *(v13 + 4 * *(*v17 + 24)) + (a2 * *(*v17 + 32));
            if (*v17 != v15)
            {
              if (v18 >= v16)
              {
                v19 = v16;
              }

              else
              {
                v19 = *(v13 + 4 * *(*v17 + 24)) + (a2 * *(*v17 + 32));
              }

              if (v16 >= v18)
              {
                v18 = v16;
              }

              if (v18 <= (v19 + 50.0))
              {
                v20 = v18;
                v21 = exp((v19 - v18));
                v18 = log(v21 + 1.0) + v20;
              }
            }

            *(v13 + 4 * v14) = v18;
            ++v17;
            v16 = v18;
          }

          while (v17 != v11);
        }

        v8 += 8;
      }

      while (v8 != v9);
    }

    ++v6;
  }

  while (v6 != v24);
}

float sentencepiece::unigram::Lattice::CalculateEntropy(sentencepiece::unigram::Lattice *this, float a2)
{
  v5 = *(this + 3);
  v4 = *(this + 4);
  v6 = *(this + 16) + *(this + 17) * *(this + 18);
  LODWORD(v32[0]) = 0;
  std::vector<float>::vector[abi:ne200100](__p, v6);
  v7 = *(this + 16) + *(this + 17) * *(this + 18);
  LODWORD(v30) = 0;
  std::vector<float>::vector[abi:ne200100](v32, v7);
  sentencepiece::unigram::Lattice::ForwardAlgorithm(this, a2, &v30);
  v8 = (((v4 - v5) >> 3) - 1) & ~((((v4 - v5) >> 3) - 1) >> 31);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  v9 = 0;
  *__p = v30;
  v34 = v31;
  v29 = *(this + 6);
  v26 = v8;
  v27 = this;
  v28 = v8 + 1;
  do
  {
    v10 = (v29 + 24 * v9);
    v11 = *v10;
    v12 = v10[1];
    if (*v10 != v12)
    {
      v13 = (*(v27 + 9) + 24 * v9);
      v14 = *v13;
      v15 = v13[1];
      v16 = __p[0];
      v17 = v32[0];
      do
      {
        if (v14 != v15)
        {
          v18 = *(*v11 + 24);
          v19 = v17[v18];
          v20 = v14;
          do
          {
            v21 = *v20++;
            v22 = *(v21 + 24);
            v23 = (v16[v22] + (a2 * *(v21 + 32))) - v16[v18];
            v19 = v19 + (expf(v23) * (v23 + v17[v22]));
            v17[v18] = v19;
          }

          while (v20 != v15);
        }

        v11 += 8;
      }

      while (v11 != v12);
    }

    ++v9;
  }

  while (v9 != v28);
  v24 = *(v32[0] + *(**(v29 + 24 * v26) + 24));
  v32[1] = v32[0];
  operator delete(v32[0]);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  return -v24;
}

void sub_1B5ABC13C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a19)
  {
    operator delete(a19);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::unigram::Lattice::NBest(sentencepiece::unigram::Lattice *this@<X0>, float a2@<S0>, uint64_t a3@<X1>, int a4@<W2>, void *a5@<X8>)
{
  v9 = a5;
  v110 = *MEMORY[0x1E69E9840];
  if (a3 == 1)
  {
    if ((a4 & 1) == 0)
    {
      sentencepiece::unigram::Lattice::Viterbi(this, &v105);
      *v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
      std::vector<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>::__init_with_size[abi:ne200100]<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float> const*,std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float> const*>(v9, &v105, &v107 + 8, 1uLL);
      if (v105)
      {
        *&v106 = v105;
        operator delete(v105);
      }

      return;
    }
  }

  else if (!a3)
  {
    if (sentencepiece::logging::GetMinLogLevel(this) <= 1)
    {
      LOBYTE(v105) = 0;
      v10 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "unigram_model.cc", 16);
      v11 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v10, "(", 1);
      v12 = MEMORY[0x1B8C84C00](v11, 296);
      v13 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v12, ") ", 2);
      v14 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v13, "LOG(", 4);
      v15 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v14, "WARNING", 7);
      v16 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v15, ") ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v16, "nbest_size >= 1. Returns empty result.", 38);
      sentencepiece::error::Die::~Die(&v105);
    }

    *v9 = 0;
    v9[1] = 0;
    v9[2] = 0;
    return;
  }

  v106 = 0u;
  v107 = 0u;
  v105 = &unk_1F2D44050;
  v108 = 0;
  v109 = 512;
  v103 = 0;
  v104 = 0uLL;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  v17 = sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis>::Allocate(&v105);
  v101 = v17;
  v18 = ((*(this + 4) - *(this + 3)) >> 3) - 1;
  *v17 = **(*(this + 6) + 24 * (v18 & ~(v18 >> 31)));
  *(v17 + 8) = 0;
  *(v17 + 20) = 0;
  v19 = *(this + 16) + *(this + 17) * *(this + 18);
  LODWORD(v102[0]) = 0;
  std::vector<float>::vector[abi:ne200100](__p, v19);
  if (a4)
  {
    sentencepiece::unigram::Lattice::ForwardAlgorithm(this, a2, v102);
    v20 = __p[0];
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    *__p = v102[0];
    v100 = *&v102[1];
    RandomGenerator = sentencepiece::random::GetRandomGenerator(v20);
    v22 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(RandomGenerator);
    v23 = logf((vcvts_n_f32_u32(v22, 0x20uLL) + 0.0) + 0.0000001);
    v24 = -logf(-v23);
  }

  else
  {
    sentencepiece::unigram::Lattice::Viterbi(this, v98);
    if (v98[0])
    {
      v98[1] = v98[0];
      operator delete(v98[0]);
    }

    v24 = *(*v17 + 36);
  }

  *(v17 + 16) = v24;
  std::vector<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair *,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair *>>::push_back[abi:ne200100](&v103, &v101);
  v93 = a3;
  v26 = v103;
  v25 = v104;
  std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::HypothesisComparator &,std::__wrap_iter<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis **>>(v103, v104, (v104 - v103) >> 3);
  if (v25 != v26)
  {
    v91 = 10 * a3;
    if (10 * a3 >= 512)
    {
      v27 = 512;
    }

    else
    {
      v27 = 10 * a3;
    }

    if (v27 <= 1)
    {
      v28 = 1;
    }

    else
    {
      v28 = v27;
    }

    v90 = v9;
    v92 = v28;
    do
    {
      v29 = *v26;
      v30 = (v25 - v26) >> 3;
      if (v30 >= 2)
      {
        v31 = 0;
        v32 = v26;
        do
        {
          v33 = v32;
          v32 += 8 * v31 + 8;
          v34 = 2 * v31;
          v31 = (2 * v31) | 1;
          v35 = v34 + 2;
          if (v35 < v30 && *(*v32 + 16) < *(*(v32 + 1) + 16))
          {
            v32 += 8;
            v31 = v35;
          }

          *v33 = *v32;
        }

        while (v31 <= ((v30 - 2) >> 1));
        v36 = v25 - 8;
        if (v32 == v25 - 8)
        {
          *v32 = v29;
        }

        else
        {
          *v32 = *v36;
          *v36 = v29;
          std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::HypothesisComparator &,std::__wrap_iter<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis **>>(v26, (v32 + 8), (v32 + 8 - v26) >> 3);
        }
      }

      v25 = (v104 - 8);
      *&v104 = v104 - 8;
      v37 = *v29;
      v38 = *(this + 9);
      if (*v29 == **v38)
      {
        std::vector<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>::resize(v9, ((v9[1] - *v9) >> 5) + 1);
        v68 = (v29 + 1);
        while (1)
        {
          v69 = *v68;
          v70 = *v68;
          v71 = v70[1];
          v68 = (v70 + 1);
          if (!v71)
          {
            break;
          }

          std::vector<TVertex *>::push_back[abi:ne200100](v9[1] - 32, v69);
        }

        v72 = v9[1];
        *(v72 - 8) = *(v29 + 4);
        if (v93 == (v72 - *v9) >> 5)
        {
          break;
        }

        v26 = v103;
      }

      else
      {
        v39 = (v38[3 * *(v37 + 16) + 1] - v38[3 * *(v37 + 16)]);
        LODWORD(v102[0]) = 0;
        std::vector<float>::vector[abi:ne200100](v97, v39);
        LODWORD(v102[0]) = 0;
        std::vector<float>::vector[abi:ne200100](v96, v39);
        *&v102[0] = 0;
        v40 = std::vector<double>::vector[abi:ne200100](&v94, v39);
        v41 = *(v37 + 16);
        v42 = *(this + 9);
        if (a4)
        {
          v43 = *(v42 + 24 * v41);
          v44 = -100000000.0;
          if (*(v42 + 24 * v41 + 8) != v43)
          {
            v45 = 0;
            v46 = *(__p[0] + *(v37 + 24));
            v44 = -100000000.0;
            do
            {
              v47 = ((*(v29 + 5) + *(__p[0] + *(*(v43 + 8 * v45) + 24))) + (a2 * *(*(v43 + 8 * v45) + 32))) - v46;
              *(v97[0] + v45) = v47;
              v48 = sentencepiece::random::GetRandomGenerator(v40);
              v49 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(v48);
              v50 = logf((vcvts_n_f32_u32(v49, 0x20uLL) + 0.0) + 0.0000001);
              v51 = v47 - logf(-v50);
              *(v96[0] + v45) = v51;
              if (v51 > v44)
              {
                v44 = v51;
              }

              ++v45;
              v52 = *(v37 + 16);
              v42 = *(this + 9);
              v43 = *(v42 + 24 * v52);
            }

            while (v45 < (*(v42 + 24 * v52 + 8) - v43) >> 3);
            v41 = *(v37 + 16);
          }

          v53 = v94;
          if (v95 != v94)
          {
            v54 = *(v29 + 4);
            v55 = v96[0];
            if (((v95 - v94) >> 3) <= 1)
            {
              v56 = 1;
            }

            else
            {
              v56 = (v95 - v94) >> 3;
            }

            do
            {
              v57 = *v55++;
              v58 = expf(v57 - v44);
              v59 = (v54 - v57) + log1pf(-v58);
              v60 = v54 - fmaxf(v59, 0.0);
              v61 = expf(-fabsf(v59));
              *v53++ = (v60 - log1pf(v61));
              --v56;
            }

            while (v56);
            v9 = v90;
          }

          v28 = v92;
        }

        v62 = *(v42 + 24 * v41);
        if (*(v42 + 24 * v41 + 8) == v62)
        {
          v26 = v103;
          v67 = v25 - v103;
        }

        else
        {
          v63 = 0;
          do
          {
            v64 = *(v62 + 8 * v63);
            v65 = sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis>::Allocate(&v105);
            *&v102[0] = v65;
            *v65 = v64;
            if (a4)
            {
              *(v65 + 20) = *(v97[0] + v63);
              v66 = *(v94 + v63);
            }

            else
            {
              *(v65 + 20) = *(v64 + 32) + *(v29 + 5);
              v66 = *(v64 + 36) + *(v29 + 5);
            }

            *(v65 + 16) = v66;
            *(v65 + 8) = v29;
            std::vector<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair *,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair *>>::push_back[abi:ne200100](&v103, v102);
            v26 = v103;
            v25 = v104;
            v67 = v104 - v103;
            v40 = std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::HypothesisComparator &,std::__wrap_iter<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis **>>(v103, v104, (v104 - v103) >> 3);
            ++v63;
            v62 = *(*(this + 9) + 24 * *(v37 + 16));
          }

          while (v63 < (*(*(this + 9) + 24 * *(v37 + 16) + 8) - v62) >> 3);
        }

        if (v67 > 0xC34F8)
        {
          if (sentencepiece::logging::GetMinLogLevel(v40) <= 1)
          {
            LOBYTE(v102[0]) = 0;
            v73 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "unigram_model.cc", 16);
            v74 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v73, "(", 1);
            v75 = MEMORY[0x1B8C84C00](v74, 425);
            v76 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v75, ") ", 2);
            v77 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v76, "LOG(", 4);
            v78 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v77, "WARNING", 7);
            v79 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v78, ") ", 2);
            std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v79, "Too big agenda. shrinking", 25);
            sentencepiece::error::Die::~Die(v102);
          }

          memset(v102, 0, 24);
          if (v91 >= 1)
          {
            for (i = 0; i != v28; ++i)
            {
              v81 = v103;
              std::vector<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair *,std::allocator<sentencepiece::bpe::Model::SampleEncode(absl::string_view,float)::SymbolPair *>>::push_back[abi:ne200100](v102, v103);
              std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::HypothesisComparator &,std::__wrap_iter<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis **>>(*&v102[0], *(&v102[0] + 1), (*(&v102[0] + 1) - *&v102[0]) >> 3);
              v82 = (v25 - v81) >> 3;
              if (v82 >= 2)
              {
                v83 = 0;
                v84 = *v81;
                v85 = v81;
                do
                {
                  v86 = v85;
                  v85 += 8 * v83 + 8;
                  v87 = 2 * v83;
                  v83 = (2 * v83) | 1;
                  v88 = v87 + 2;
                  if (v88 < v82 && *(*v85 + 16) < *(*(v85 + 1) + 16))
                  {
                    v85 += 8;
                    v83 = v88;
                  }

                  *v86 = *v85;
                }

                while (v83 <= ((v82 - 2) >> 1));
                v89 = v25 - 8;
                if (v85 == v25 - 8)
                {
                  *v85 = v84;
                }

                else
                {
                  *v85 = *v89;
                  *v89 = v84;
                  std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::HypothesisComparator &,std::__wrap_iter<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis **>>(v81, (v85 + 8), (v85 + 8 - v81) >> 3);
                }
              }

              v25 = (v104 - 8);
              *&v104 = v104 - 8;
            }

            v26 = v103;
          }

          if (v26)
          {
            *&v104 = v26;
            operator delete(v26);
          }

          v26 = *&v102[0];
          v103 = *&v102[0];
          v104 = *(v102 + 8);
          v25 = *(&v102[0] + 1);
        }

        if (v94)
        {
          v95 = v94;
          operator delete(v94);
        }

        if (v96[0])
        {
          v96[1] = v96[0];
          operator delete(v96[0]);
        }

        if (v97[0])
        {
          v97[1] = v97[0];
          operator delete(v97[0]);
        }
      }
    }

    while (v26 != v25);
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v103)
  {
    operator delete(v103);
  }

  sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis>::~FreeList(&v105);
}

void sub_1B5ABCA44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, void *__p, uint64_t a38)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis>::Allocate(void *a1)
{
  v2 = a1[5];
  v3 = a1[6];
  v4 = a1[4];
  if (v4 >= v3)
  {
    v4 = 0;
    ++v2;
    a1[4] = 0;
    a1[5] = v2;
  }

  v5 = a1[1];
  if (v2 == (a1[2] - v5) >> 3)
  {
    is_mul_ok(v3, 0x18uLL);
    operator new[]();
  }

  result = *(v5 + 8 * v2) + 24 * v4;
  a1[4] = v4 + 1;
  return result;
}

void std::vector<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>::resize(void *a1, unint64_t a2)
{
  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v6 = *a1 + 32 * a2;
      if (v3 != v6)
      {
        v7 = a1[1];
        do
        {
          v9 = *(v7 - 32);
          v7 -= 32;
          v8 = v9;
          if (v9)
          {
            *(v3 - 24) = v8;
            operator delete(v8);
          }

          v3 = v7;
        }

        while (v7 != v6);
      }

      a1[1] = v6;
    }
  }

  else
  {
    v5 = a2 - v4;

    std::vector<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>::__append(a1, v5);
  }
}

void *sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis>::~FreeList(void *a1)
{
  *a1 = &unk_1F2D44050;
  v2 = a1[1];
  v3 = a1[2];
  if (v2 != v3)
  {
    do
    {
      if (*v2)
      {
        MEMORY[0x1B8C85310](*v2, 0x1020C8062D53EE8);
      }

      ++v2;
    }

    while (v2 != v3);
    v2 = a1[1];
  }

  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  return a1;
}

void sentencepiece::unigram::Lattice::Sample(sentencepiece::unigram::Lattice *this@<X0>, float a2@<S0>, unint64_t *a3@<X8>)
{
  if ((((*(this + 4) - *(this + 3)) >> 3) - 1) <= 0)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }

  else
  {
    v6 = *(this + 16) + *(this + 17) * *(this + 18);
    LODWORD(v30[0]) = 0;
    std::vector<float>::vector[abi:ne200100](__p, v6);
    sentencepiece::unigram::Lattice::ForwardAlgorithm(this, a2, v30);
    v7 = __p[0];
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    *__p = *v30;
    v33 = v31;
    RandomGenerator = sentencepiece::random::GetRandomGenerator(v7);
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    v30[0] = 0;
    v30[1] = 0;
    v31 = 0;
    v9 = ((*(this + 4) - *(this + 3)) >> 3) - 1;
    v10 = **(*(this + 6) + 24 * (v9 & ~(v9 >> 31)));
    v11 = *(__p[0] + *(v10 + 24));
    v29 = v10;
    do
    {
      v12 = v30[0];
      v30[1] = v30[0];
      v13 = (*(this + 9) + 24 * *(v29 + 16));
      v14 = *v13;
      v15 = v13[1];
      if (*v13 == v15)
      {
        v17 = v30[0];
      }

      else
      {
        do
        {
          v16 = exp(((*(__p[0] + *(*v14 + 24)) + (a2 * *(*v14 + 32))) - v11));
          *v28 = v16;
          std::vector<float>::push_back[abi:ne200100](v30, v28);
          v14 += 8;
        }

        while (v14 != v15);
        v17 = v30[0];
        v12 = v30[1];
      }

      std::discrete_distribution<int>::param_type::param_type[abi:ne200100]<std::__wrap_iter<float *>>(v28, v17, v12);
      v18 = *(v29 + 16);
      v19 = *(this + 9);
      v20 = *(*(v19 + 24 * v18) + 8 * std::discrete_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(v28, RandomGenerator, v28));
      v29 = v20;
      v21 = ***(this + 9);
      if (v20 != v21)
      {
        v11 = *(__p[0] + *(v20 + 24));
        std::vector<TVertex *>::push_back[abi:ne200100](a3, &v29);
      }

      if (v28[0])
      {
        v28[1] = v28[0];
        operator delete(v28[0]);
      }
    }

    while (v20 != v21);
    v23 = *a3;
    v22 = a3[1];
    if (*a3 != v22)
    {
      v24 = (v22 - 8);
      if (v24 > v23)
      {
        v25 = v23 + 8;
        do
        {
          v26 = *(v25 - 8);
          *(v25 - 8) = *v24;
          *v24-- = v26;
          v27 = v25 >= v24;
          v25 += 8;
        }

        while (!v27);
      }
    }

    if (v30[0])
    {
      v30[1] = v30[0];
      operator delete(v30[0]);
    }

    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
}

void sub_1B5ABCF90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sentencepiece::unigram::Model::PopulateNodes(sentencepiece::unigram::Model *this, sentencepiece::unigram::Lattice *a2)
{
  v4 = *(this + 30);
  v5 = ((*(a2 + 4) - *(a2 + 3)) >> 3) - 1;
  v6 = *(a2 + 1);
  v7 = *(a2 + 2);
  std::vector<Darts::DoubleArrayImpl<void,void,int,void>::result_pair_type,std::allocator<Darts::DoubleArrayImpl<void,void,int,void>::result_pair_type>>::vector[abi:ne200100](&__p, *(this + 34) + 1);
  v44 = v5;
  if (v5 < 1)
  {
    goto LABEL_40;
  }

  v8 = 0;
  v9 = 0;
  v10 = v4 + -10.0;
  v43 = v6 + v7;
  do
  {
    v11 = *(*(a2 + 3) + 8 * v9);
    v12 = __p;
    v13 = (v47 - __p) >> 4;
    v14 = *(*(this + 16) + 16);
    v15 = (*v14 >> 10 << ((*v14 >> 6) & 8));
    if ((v43 - v11) << 32)
    {
      v16 = 0;
      v17 = 0;
      do
      {
        v18 = v11[v16];
        v19 = v15 ^ v18;
        v20 = v14[v19];
        if ((v20 & 0x800000FF) != v18)
        {
          break;
        }

        v15 = v19 ^ (v20 >> 10 << ((v20 >> 6) & 8));
        if ((v20 & 0x100) != 0)
        {
          if (v17 < v13)
          {
            v21 = &v12[16 * v17];
            *v21 = v14[v15] & 0x7FFFFFFF;
            *(v21 + 1) = v16 + 1;
          }

          ++v17;
        }

        ++v16;
      }

      while (v43 - v11 != v16);
    }

    else
    {
      v22 = *v11;
      if (*v11)
      {
        v17 = 0;
        v23 = 1;
        do
        {
          v24 = v15 ^ v22;
          v25 = v14[v24];
          if ((v25 & 0x800000FF) != v22)
          {
            break;
          }

          v15 = v24 ^ (v25 >> 10 << ((v25 >> 6) & 8));
          if ((v25 & 0x100) != 0)
          {
            if (v17 < v13)
            {
              v26 = &v12[16 * v17];
              *v26 = v14[v15] & 0x7FFFFFFF;
              *(v26 + 1) = v23;
            }

            ++v17;
          }

          v22 = v11[v23++];
        }

        while (v22);
      }

      else
      {
        v17 = 0;
      }
    }

    if (v17 >= v13)
    {
      v45 = 1;
      v27 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "unigram_model.cc", 16);
      v28 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v27, "(", 1);
      v29 = MEMORY[0x1B8C84C00](v28, 499);
      v30 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v29, ") [", 3);
      v31 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v30, "(num_nodes) < (trie_results.size())", 35);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v31, "] ", 2);
      sentencepiece::error::Die::~Die(&v45);
    }

    if (!v17)
    {
LABEL_38:
      v42 = sentencepiece::unigram::Lattice::Insert(a2, v9, 1);
      *(v42 + 28) = *(this + 26);
      *(v42 + 32) = v10;
      goto LABEL_39;
    }

    v32 = 0;
    v33 = 0;
    do
    {
      while (1)
      {
        v34 = (__p + 16 * v32);
        v35 = (*(a2 + 3) + v8);
        v36 = -1;
        do
        {
          v37 = *v35++;
          ++v36;
        }

        while (v37 < &v11[*(v34 + 1)]);
        v38 = *v34;
        if (*(*(*(*(this + 1) + 64) + 8 * *v34 + 8) + 60) == 5)
        {
          break;
        }

        v39 = sentencepiece::unigram::Lattice::Insert(a2, v9, v36);
        *(v39 + 28) = v38;
        v40 = *(*(*(this + 1) + 64) + 8 * v38 + 8);
        if (*(v40 + 60) == 4)
        {
          v41 = (*(this + 31) * v36) + -0.1;
        }

        else
        {
          v41 = *(v40 + 56);
        }

        *(v39 + 32) = v41;
        if (!v33)
        {
          v33 = *(v39 + 20) == 1;
          break;
        }

        ++v32;
        v33 = 1;
        if (v32 == v17)
        {
          goto LABEL_39;
        }
      }

      ++v32;
    }

    while (v32 != v17);
    if (!v33)
    {
      goto LABEL_38;
    }

LABEL_39:
    ++v9;
    v8 += 8;
  }

  while (v9 != v44);
LABEL_40:
  if (__p)
  {
    v47 = __p;
    operator delete(__p);
  }
}

void sub_1B5ABD35C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sentencepiece::unigram::Model::PieceToId(uint64_t a1, char *a2, uint64_t a3)
{
  v7 = a2;
  v8 = a3;
  v4 = std::__hash_table<std::__hash_value_type<absl::string_view,int>,std::__unordered_map_hasher<absl::string_view,std::__hash_value_type<absl::string_view,int>,sentencepiece::string_util::string_view_hash,std::equal_to<absl::string_view>,true>,std::__unordered_map_equal<absl::string_view,std::__hash_value_type<absl::string_view,int>,std::equal_to<absl::string_view>,sentencepiece::string_util::string_view_hash,true>,std::allocator<std::__hash_value_type<absl::string_view,int>>>::find<absl::string_view>((a1 + 64), &v7);
  if (v4)
  {
    return *(v4 + 8);
  }

  v6 = 0;
  Darts::DoubleArrayImpl<void,void,int,void>::exactMatchSearch<int>(*(a1 + 128), v7, &v6, v8, 0);
  result = v6;
  if (v6 == -1)
  {
    return *(a1 + 104);
  }

  return result;
}

uint64_t Darts::DoubleArrayImpl<void,void,int,void>::exactMatchSearch<int>(uint64_t result, _BYTE *a2, int *a3, uint64_t a4, uint64_t a5)
{
  v5 = *(result + 16);
  v6 = *(v5 + 4 * a5);
  if (a4)
  {
    while (1)
    {
      v7 = *a2++;
      a5 ^= (v6 >> 10 << ((v6 >> 6) & 8)) ^ v7;
      v6 = *(v5 + 4 * a5);
      if ((v6 & 0x800000FF) != v7)
      {
        break;
      }

      if (!--a4)
      {
        goto LABEL_9;
      }
    }
  }

  else
  {
    v8 = *a2;
    if (*a2)
    {
      v9 = a2 + 1;
      while (1)
      {
        a5 ^= (v6 >> 10 << ((v6 >> 6) & 8)) ^ v8;
        v6 = *(v5 + 4 * a5);
        if ((v6 & 0x800000FF) != v8)
        {
          break;
        }

        v10 = *v9++;
        v8 = v10;
        if (!v10)
        {
          goto LABEL_9;
        }
      }
    }

    else
    {
LABEL_9:
      if ((v6 & 0x100) != 0)
      {
        v11 = *(v5 + 4 * (a5 ^ (v6 >> 10 << ((v6 >> 6) & 8)))) & 0x7FFFFFFF;
        goto LABEL_12;
      }
    }
  }

  v11 = -1;
LABEL_12:
  *a3 = v11;
  return result;
}

void sentencepiece::unigram::Model::BuildTrie(uint64_t *a1, unint64_t *a2)
{
  (*(*a1 + 16))(&v10);
  v4 = v10;
  sentencepiece::util::Status::~Status(&v10);
  if (!v4)
  {
    v5 = a2[1];
    if (*a2 != v5)
    {
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,false>(*a2, v5, &v10, 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((v5 - *a2) >> 3)), 1);
      std::vector<char const*>::vector[abi:ne200100](&v10, 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
      std::vector<int>::vector[abi:ne200100](&v9, 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
      v6 = *a2;
      if (a2[1] != *a2)
      {
        v7 = 0;
        v8 = 0;
        do
        {
          *(v10 + v8) = *(v6 + v7);
          v6 = *a2;
          *(v9 + v8++) = *(*a2 + v7 + 16);
          v7 += 24;
        }

        while (v8 < 0xAAAAAAAAAAAAAAABLL * ((a2[1] - v6) >> 3));
      }

      operator new();
    }

    sentencepiece::util::Status::Status(&v10, 13, "no pieces are loaded.");
    sentencepiece::util::Status::operator=(a1 + 14, &v10);
    sentencepiece::util::Status::~Status(&v10);
  }
}

void sub_1B5ABD87C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  sentencepiece::util::Status::~Status(&a9);
  if (__p)
  {
    a11 = __p;
    operator delete(__p);
  }

  if (a13)
  {
    a14 = a13;
    operator delete(a13);
  }

  if (a16)
  {
    a17 = a16;
    operator delete(a16);
  }

  _Unwind_Resume(a1);
}

sentencepiece::unigram::Model *sentencepiece::unigram::Model::Model(sentencepiece::unigram::Model *this, const sentencepiece::ModelProto *a2)
{
  v4 = sentencepiece::ModelInterface::ModelInterface(this);
  *(v4 + 15) = 0;
  v5 = (v4 + 120);
  *(v4 + 16) = 0;
  *v4 = &unk_1F2D43F10;
  *(v4 + 1) = a2;
  sentencepiece::ModelInterface::InitializePieces(v4);
  v6 = 0x8000007F7FFFFFLL;
  *(this + 15) = 0x8000007F7FFFFFLL;
  v7 = *(this + 1);
  v8 = *(v7 + 64);
  if (v8)
  {
    v9 = v8 + 8;
  }

  else
  {
    v9 = 0;
  }

  v10 = *(v7 + 56);
  if (v10)
  {
    v11 = 8 * v10;
    do
    {
      if (*(*v9 + 60) == 1)
      {
        v12.i32[1] = v6.i32[1];
        v12.i32[0] = *(*v9 + 56);
        v6 = vbsl_s8(vcgt_f32(__PAIR64__(v12.u32[0], v6.u32[0]), v12), vdup_lane_s32(v12, 0), v6);
        *v5 = v6;
      }

      v9 += 8;
      v11 -= 8;
    }

    while (v11);
  }

  __p = 0;
  v22 = 0;
  v23 = 0;
  v13 = *(this + 5);
  if (v13)
  {
    v14 = 0;
    do
    {
      if (v14 >= v23)
      {
        v15 = 0xAAAAAAAAAAAAAAABLL * ((v14 - __p) >> 3);
        v16 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL)
        {
          std::vector<int>::__throw_length_error[abi:ne200100]();
        }

        if (0x5555555555555556 * ((v23 - __p) >> 3) > v16)
        {
          v16 = 0x5555555555555556 * ((v23 - __p) >> 3);
        }

        if (0xAAAAAAAAAAAAAAABLL * ((v23 - __p) >> 3) >= 0x555555555555555)
        {
          v17 = 0xAAAAAAAAAAAAAAALL;
        }

        else
        {
          v17 = v16;
        }

        if (v17)
        {
          std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(&__p, v17);
        }

        v18 = 8 * ((v14 - __p) >> 3);
        *v18 = *(v13 + 1);
        *(v18 + 16) = *(v13 + 8);
        v14 = 24 * v15 + 24;
        memcpy((24 * v15 - (v22 - __p)), __p, v22 - __p);
        v19 = __p;
        __p = (24 * v15 - (v22 - __p));
        v22 = v14;
        v23 = 0;
        if (v19)
        {
          operator delete(v19);
        }
      }

      else
      {
        *v14 = *(v13 + 1);
        *(v14 + 16) = *(v13 + 8);
        v14 += 24;
      }

      v22 = v14;
      v13 = *v13;
    }

    while (v13);
  }

  sentencepiece::unigram::Model::BuildTrie(this, &__p);
  if (__p)
  {
    v22 = __p;
    operator delete(__p);
  }

  return this;
}

void sub_1B5ABDB08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    operator delete(__p);
  }

  v13 = *(v11 + 16);
  *(v11 + 16) = 0;
  if (v13)
  {
    (*(*v13 + 8))(v13);
  }

  sentencepiece::ModelInterface::~ModelInterface(v11);
  _Unwind_Resume(a1);
}

void sentencepiece::unigram::Model::~Model(sentencepiece::unigram::Model *this)
{
  *this = &unk_1F2D43F10;
  v2 = *(this + 16);
  *(this + 16) = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  sentencepiece::ModelInterface::~ModelInterface(this);
}

{
  sentencepiece::unigram::Model::~Model(this);

  JUMPOUT(0x1B8C85350);
}

void sentencepiece::unigram::Model::Encode(sentencepiece::unigram::Model *a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (*(a1 + 27))
  {
    (*(*a1 + 16))(&v23, a1);
    if (v23)
    {
      sentencepiece::util::Status::~Status(&v23);
LABEL_4:
      *a4 = 0;
      *(a4 + 8) = 0;
      *(a4 + 16) = 0;
      return;
    }

    sentencepiece::util::Status::~Status(&v23);
    if (!a3)
    {
      goto LABEL_4;
    }

    v23 = &unk_1F2D43EF0;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v28 = 0u;
    v29 = 0;
    v30 = &unk_1F2D44020;
    v31 = 0u;
    v32 = 0u;
    v33 = 0;
    v34 = 1024;
    sentencepiece::unigram::Lattice::SetSentence(&v23, a2, a3);
    sentencepiece::unigram::Model::PopulateNodes(a1, &v23);
    *a4 = 0;
    *(a4 + 8) = 0;
    *(a4 + 16) = 0;
    sentencepiece::unigram::Lattice::Viterbi(&v23, &v21);
    v8 = v21;
    v9 = v22;
    if (v21 != v22)
    {
      v10 = *(a4 + 8);
      do
      {
        v11 = *v8;
        v12 = *(a4 + 16);
        if (v10 >= v12)
        {
          v13 = 0xAAAAAAAAAAAAAAABLL * ((v10 - *a4) >> 3);
          v14 = v13 + 1;
          if (v13 + 1 > 0xAAAAAAAAAAAAAAALL)
          {
            std::vector<int>::__throw_length_error[abi:ne200100]();
          }

          v15 = 0xAAAAAAAAAAAAAAABLL * ((v12 - *a4) >> 3);
          if (2 * v15 > v14)
          {
            v14 = 2 * v15;
          }

          if (v15 >= 0x555555555555555)
          {
            v16 = 0xAAAAAAAAAAAAAAALL;
          }

          else
          {
            v16 = v14;
          }

          if (v16)
          {
            std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(a4, v16);
          }

          v17 = 24 * v13;
          *v17 = *v11;
          *(v17 + 16) = *(v11 + 28);
          v10 = 24 * v13 + 24;
          v18 = *(a4 + 8) - *a4;
          v19 = v17 - v18;
          memcpy((v17 - v18), *a4, v18);
          v20 = *a4;
          *a4 = v19;
          *(a4 + 8) = v10;
          *(a4 + 16) = 0;
          if (v20)
          {
            operator delete(v20);
          }
        }

        else
        {
          *v10 = *v11;
          *(v10 + 16) = *(v11 + 28);
          v10 += 24;
        }

        *(a4 + 8) = v10;
        ++v8;
      }

      while (v8 != v9);
      v8 = v21;
    }

    if (v8)
    {
      v22 = v8;
      operator delete(v8);
    }

    sentencepiece::unigram::Lattice::~Lattice(&v23);
  }

  else
  {

    sentencepiece::unigram::Model::EncodeOptimized(a1, a2, a3, a4);
  }
}

void sub_1B5ABDED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  v15 = *v13;
  if (*v13)
  {
    *(v13 + 8) = v15;
    operator delete(v15);
  }

  sentencepiece::unigram::Lattice::~Lattice(&a13);
  _Unwind_Resume(a1);
}

void sentencepiece::unigram::Model::EncodeOptimized(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  (*(*a1 + 16))(&v50);
  if (v50)
  {
    sentencepiece::util::Status::~Status(&v50);
LABEL_3:
    *a4 = 0;
    *(a4 + 8) = 0;
    *(a4 + 16) = 0;
    return;
  }

  sentencepiece::util::Status::~Status(&v50);
  if (!a3)
  {
    goto LABEL_3;
  }

  v8 = *(a1 + 120);
  if (a3 << 32 != 0xFFFFFFFF00000000)
  {
    if ((((a3 << 32) + 0x100000000) >> 32) < 0x1555555555555556)
    {
      operator new();
    }

    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  if (a3 <= 0)
  {
    *a4 = 0;
    *(a4 + 8) = 0;
    *(a4 + 16) = 0;
  }

  else
  {
    v9 = 0;
    v10 = a3 & 0x7FFFFFFF;
    do
    {
      v11 = *(12 * v9 + 4);
      v12 = asc_1B5C6FEAB[*(a2 + v9) >> 4];
      if (a3 - v9 < v12)
      {
        v12 = a3 - v9;
      }

      if (v10 <= v9)
      {
        goto LABEL_26;
      }

      v13 = 0;
      v14 = 0;
      v15 = *(*(a1 + 128) + 16);
      v16 = (a2 + v9);
      v17 = v10 - v9;
      v18 = (12 * v9 + 20);
      v19 = 1;
      do
      {
        v20 = *v16++;
        LODWORD(v14) = (*(v15 + 4 * v14) >> 10 << ((*(v15 + 4 * v14) >> 6) & 8)) ^ v14 ^ v20;
        v21 = *(v15 + 4 * v14);
        if ((v21 & 0x800000FF) != v20)
        {
          break;
        }

        if ((v21 & 0x100) != 0)
        {
          v22 = *(v15 + 4 * ((v21 >> 10 << ((v21 >> 6) & 8)) ^ v14)) & 0x7FFFFFFF;
          v23 = *(*(*(a1 + 8) + 64) + 8 * v22 + 8);
          v24 = *(v23 + 60);
          if (v24 != 5)
          {
            if (v24 == 4)
            {
              v25 = (*(a1 + 124) * v19) + -0.1;
            }

            else
            {
              v25 = *(v23 + 56);
            }

            v26 = v25 + v11;
            if (*v18 == -1 || v26 > *(v18 - 1))
            {
              v27 = v26;
              *(v18 - 1) = v27;
              *v18 = v9;
              *(v18 - 2) = v22;
            }

            v13 |= v12 == v19;
          }
        }

        ++v19;
        v18 += 3;
        --v17;
      }

      while (v17);
      if ((v13 & 1) == 0)
      {
LABEL_26:
        v28 = (v8 + -10.0) + v11;
        if (*(12 * (v12 + v9) + 8) == -1 || v28 > *(12 * (v12 + v9) + 4))
        {
          *(12 * (v12 + v9) + 4) = v28;
          *(12 * (v12 + v9) + 8) = v9;
          *(12 * (v12 + v9)) = *(a1 + 104);
        }
      }

      v9 += v12;
    }

    while (v9 < a3);
    v30 = 0;
    *a4 = 0;
    *(a4 + 8) = 0;
    *(a4 + 16) = 0;
    v31 = a3;
    do
    {
      v32 = 12 * v31;
      v33 = *(v32 + 8);
      v34 = v31 - v33;
      if (a3 - v33 >= v34)
      {
        v35 = v34;
      }

      else
      {
        v35 = a3 - v33;
      }

      v36 = a2 + v33;
      v37 = *(a4 + 16);
      if (v30 >= v37)
      {
        v38 = 0xAAAAAAAAAAAAAAABLL * ((v30 - *a4) >> 3);
        v39 = v38 + 1;
        if (v38 + 1 > 0xAAAAAAAAAAAAAAALL)
        {
          std::vector<int>::__throw_length_error[abi:ne200100]();
        }

        v40 = 0xAAAAAAAAAAAAAAABLL * ((v37 - *a4) >> 3);
        if (2 * v40 > v39)
        {
          v39 = 2 * v40;
        }

        if (v40 >= 0x555555555555555)
        {
          v41 = 0xAAAAAAAAAAAAAAALL;
        }

        else
        {
          v41 = v39;
        }

        if (v41)
        {
          std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(a4, v41);
        }

        v42 = 24 * v38;
        *v42 = v36;
        *(v42 + 8) = v35;
        *(v42 + 16) = *v32;
        v30 = 24 * v38 + 24;
        v43 = *(a4 + 8) - *a4;
        v44 = v42 - v43;
        memcpy((v42 - v43), *a4, v43);
        v45 = *a4;
        *a4 = v44;
        *(a4 + 8) = v30;
        *(a4 + 16) = 0;
        if (v45)
        {
          operator delete(v45);
        }
      }

      else
      {
        *v30 = v36;
        *(v30 + 8) = v35;
        *(v30 + 16) = *v32;
        v30 += 24;
      }

      *(a4 + 8) = v30;
      v31 = *(v32 + 8);
    }

    while (v31 > 0);
    v46 = *a4;
    if (*a4 == v30 || (v47 = v30 - 24, v30 - 24 <= v46))
    {
      operator delete(0);
    }

    else
    {
      do
      {
        v50 = *v46;
        v48 = v50;
        *v46 = *v47;
        *v47 = v48;
        v49 = v46[4];
        v46[4] = *(v47 + 16);
        *(v47 + 16) = v49;
        v46 += 6;
        v47 -= 24;
      }

      while (v46 < v47);
    }
  }
}

void sub_1B5ABE374(_Unwind_Exception *a1)
{
  v4 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v4;
    operator delete(v4);
  }

  operator delete(v2);
  _Unwind_Resume(a1);
}

void sentencepiece::unigram::Model::NBestEncode(sentencepiece::unigram::Model *a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(*a1 + 16))(&__p);
  if (__p)
  {
    sentencepiece::util::Status::~Status(&__p);
    goto LABEL_3;
  }

  sentencepiece::util::Status::~Status(&__p);
  if (!a3)
  {
LABEL_3:
    __p = 0;
    v32 = 0uLL;
    std::vector<std::pair<absl::string_view,int>>::__init_with_size[abi:ne200100]<std::pair<absl::string_view,int>*,std::pair<absl::string_view,int>*>(&__p, 0, 0, 0);
    LODWORD(v33[0]) = 0;
    a5[1] = 0;
    a5[2] = 0;
    *a5 = 0;
    std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__init_with_size[abi:ne200100]<std::pair<std::vector<std::pair<absl::string_view,int>>,float> const*,std::pair<std::vector<std::pair<absl::string_view,int>>,float> const*>(a5, &__p, v33 + 8, 1uLL);
    if (__p)
    {
      *&v32 = __p;
      operator delete(__p);
    }

    return;
  }

  __p = &unk_1F2D43EF0;
  v32 = 0u;
  memset(v33, 0, 48);
  if (a4 >= 1024)
  {
    v10 = 1024;
  }

  else
  {
    v10 = a4;
  }

  if (v10 <= 1)
  {
    v11 = 1;
  }

  else
  {
    v11 = v10;
  }

  v33[3] = 0uLL;
  v34 = 0;
  v35 = &unk_1F2D44020;
  v36 = 0uLL;
  v37 = 0uLL;
  v38 = 0;
  v39 = 1024;
  sentencepiece::unigram::Lattice::SetSentence(&__p, a2, a3);
  sentencepiece::unigram::Model::PopulateNodes(a1, &__p);
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  sentencepiece::unigram::Lattice::NBest(&__p, 0.0, v11, 0, &v29);
  v12 = v29;
  for (i = v30; v12 != i; v12 += 32)
  {
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v13 = *v12;
    v14 = *(v12 + 8);
    if (*v12 != v14)
    {
      v15 = 0;
      do
      {
        v16 = *v13;
        if (v15 >= v28)
        {
          v17 = 0xAAAAAAAAAAAAAAABLL * ((v15 - v26) >> 3);
          v18 = v17 + 1;
          if (v17 + 1 > 0xAAAAAAAAAAAAAAALL)
          {
            std::vector<int>::__throw_length_error[abi:ne200100]();
          }

          if (0x5555555555555556 * ((v28 - v26) >> 3) > v18)
          {
            v18 = 0x5555555555555556 * ((v28 - v26) >> 3);
          }

          if (0xAAAAAAAAAAAAAAABLL * ((v28 - v26) >> 3) >= 0x555555555555555)
          {
            v19 = 0xAAAAAAAAAAAAAAALL;
          }

          else
          {
            v19 = v18;
          }

          if (v19)
          {
            std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(&v26, v19);
          }

          v20 = 24 * v17;
          *v20 = *v16;
          *(v20 + 16) = *(v16 + 28);
          v15 = 24 * v17 + 24;
          v21 = (v20 - (v27 - v26));
          memcpy(v21, v26, v27 - v26);
          v22 = v26;
          v26 = v21;
          v27 = v15;
          v28 = 0;
          if (v22)
          {
            operator delete(v22);
          }
        }

        else
        {
          *v15 = *v16;
          *(v15 + 16) = *(v16 + 28);
          v15 += 24;
        }

        v27 = v15;
        ++v13;
      }

      while (v13 != v14);
    }

    v23 = a5[1];
    if (v23 >= a5[2])
    {
      v24 = std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__emplace_back_slow_path<std::vector<std::pair<absl::string_view,int>>&,float const&>(a5, &v26, (v12 + 24));
    }

    else
    {
      std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__construct_one_at_end[abi:ne200100]<std::vector<std::pair<absl::string_view,int>>&,float const&>(a5, &v26, (v12 + 24));
      v24 = (v23 + 32);
    }

    a5[1] = v24;
    if (v26)
    {
      v27 = v26;
      operator delete(v26);
    }
  }

  v26 = &v29;
  std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&v26);
  sentencepiece::unigram::Lattice::~Lattice(&__p);
}

void sub_1B5ABE6F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  a12 = a11;
  std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&a12);
  sentencepiece::unigram::Lattice::~Lattice(&__p);
  _Unwind_Resume(a1);
}

void sentencepiece::unigram::Model::SampleEncode(sentencepiece::unigram::Model *a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>, float a5@<S0>)
{
  (*(*a1 + 16))(&v25);
  if (v25)
  {
    sentencepiece::util::Status::~Status(&v25);
LABEL_3:
    *a4 = 0;
    *(a4 + 8) = 0;
    *(a4 + 16) = 0;
    return;
  }

  sentencepiece::util::Status::~Status(&v25);
  if (!a3)
  {
    goto LABEL_3;
  }

  v25 = &unk_1F2D43EF0;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  v31 = 0;
  v32 = &unk_1F2D44020;
  v33 = 0u;
  v34 = 0u;
  v35 = 0;
  v36 = 1024;
  sentencepiece::unigram::Lattice::SetSentence(&v25, a2, a3);
  sentencepiece::unigram::Model::PopulateNodes(a1, &v25);
  *a4 = 0;
  *(a4 + 8) = 0;
  *(a4 + 16) = 0;
  sentencepiece::unigram::Lattice::Sample(&v25, a5, &v23);
  v10 = v23;
  v11 = v24;
  if (v23 != v24)
  {
    v12 = 0;
    do
    {
      v13 = *v10;
      v14 = *(a4 + 16);
      if (v12 >= v14)
      {
        v15 = 0xAAAAAAAAAAAAAAABLL * ((v12 - *a4) >> 3);
        v16 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL)
        {
          std::vector<int>::__throw_length_error[abi:ne200100]();
        }

        v17 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a4) >> 3);
        if (2 * v17 > v16)
        {
          v16 = 2 * v17;
        }

        if (v17 >= 0x555555555555555)
        {
          v18 = 0xAAAAAAAAAAAAAAALL;
        }

        else
        {
          v18 = v16;
        }

        if (v18)
        {
          std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(a4, v18);
        }

        v19 = 24 * v15;
        *v19 = *v13;
        *(v19 + 16) = *(v13 + 28);
        v12 = 24 * v15 + 24;
        v20 = *(a4 + 8) - *a4;
        v21 = v19 - v20;
        memcpy((v19 - v20), *a4, v20);
        v22 = *a4;
        *a4 = v21;
        *(a4 + 8) = v12;
        *(a4 + 16) = 0;
        if (v22)
        {
          operator delete(v22);
        }
      }

      else
      {
        *v12 = *v13;
        *(v12 + 16) = *(v13 + 28);
        v12 += 24;
      }

      *(a4 + 8) = v12;
      ++v10;
    }

    while (v10 != v11);
    v10 = v23;
  }

  if (v10)
  {
    v24 = v10;
    operator delete(v10);
  }

  sentencepiece::unigram::Lattice::~Lattice(&v25);
}

void sentencepiece::unigram::Model::SampleEncodeAndScore(sentencepiece::unigram::Model *a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, char a5@<W4>, int a6@<W5>, void *a7@<X8>, float a8@<S0>)
{
  (*(*a1 + 16))(&v121);
  if (v121)
  {
    sentencepiece::util::Status::~Status(&v121);
LABEL_3:
    *a7 = 0;
    a7[1] = 0;
    a7[2] = 0;
    return;
  }

  sentencepiece::util::Status::~Status(&v121);
  if (!a3)
  {
    goto LABEL_3;
  }

  *a7 = 0;
  a7[1] = 0;
  a7[2] = 0;
  v121 = &unk_1F2D43EF0;
  v122 = 0u;
  v123 = 0u;
  v124 = 0u;
  v125 = 0u;
  v126 = 0u;
  v127 = 0;
  v128 = &unk_1F2D44020;
  v129 = 0u;
  v130 = 0u;
  v131 = 0;
  v132 = 1024;
  v101 = a7;
  sentencepiece::unigram::Lattice::SetSentence(&v121, a2, a3);
  sentencepiece::unigram::Model::PopulateNodes(a1, &v121);
  sentencepiece::unigram::Lattice::ForwardAlgorithm(&v121, a8, v120);
  v17 = *(v120[0] + *(**(*(&v124 + 1) + 24 * ((((*(&v123 + 1) - v123) >> 3) - 1) & ~((((*(&v123 + 1) - v123) >> 3) - 1) >> 31))) + 24));
  if (a6)
  {
    if ((a5 & 1) == 0 && sentencepiece::logging::GetMinLogLevel(v16) <= 3)
    {
      LOBYTE(__p) = 1;
      v18 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "unigram_model.cc", 16);
      v19 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v18, "(", 1);
      v20 = MEMORY[0x1B8C84C00](v19, 683);
      v21 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v20, ") ", 2);
      v22 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v21, "LOG(", 4);
      v23 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v22, "FATAL", 5);
      v24 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v23, ") ", 2);
      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v24, "include_best not supported for wor false", 40);
      sentencepiece::error::Die::~Die(&__p);
    }

    v97 = a4;
    v117 = 0;
    v118 = 0;
    v119 = 0;
    sentencepiece::unigram::Lattice::Viterbi(&v121, &__p);
    v25 = __p;
    v26 = v104;
    if (__p != v104)
    {
      v27 = v118;
      do
      {
        v28 = *v25;
        if (v27 >= v119)
        {
          v29 = 0xAAAAAAAAAAAAAAABLL * ((v27 - v117) >> 3);
          v30 = v29 + 1;
          if (v29 + 1 > 0xAAAAAAAAAAAAAAALL)
          {
            std::vector<int>::__throw_length_error[abi:ne200100]();
          }

          if (0x5555555555555556 * ((v119 - v117) >> 3) > v30)
          {
            v30 = 0x5555555555555556 * ((v119 - v117) >> 3);
          }

          if (0xAAAAAAAAAAAAAAABLL * ((v119 - v117) >> 3) >= 0x555555555555555)
          {
            v31 = 0xAAAAAAAAAAAAAAALL;
          }

          else
          {
            v31 = v30;
          }

          if (v31)
          {
            std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(&v117, v31);
          }

          v32 = 24 * v29;
          *v32 = *v28;
          *(v32 + 16) = *(v28 + 28);
          v27 = 24 * v29 + 24;
          v33 = (v32 - (v118 - v117));
          memcpy(v33, v117, v118 - v117);
          v34 = v117;
          v117 = v33;
          v118 = v27;
          v119 = 0;
          if (v34)
          {
            operator delete(v34);
          }
        }

        else
        {
          *v27 = *v28;
          *(v27 + 16) = *(v28 + 28);
          v27 += 24;
        }

        v118 = v27;
        ++v25;
      }

      while (v25 != v26);
    }

    v115 = 0;
    a7 = v101;
    v35 = v101[1];
    if (v35 >= v101[2])
    {
      v36 = std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__emplace_back_slow_path<std::vector<std::pair<absl::string_view,int>>&,double>(v101, &v117, &v115);
    }

    else
    {
      std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__construct_one_at_end[abi:ne200100]<std::vector<std::pair<absl::string_view,int>>&,double>(v101, &v117, &v115);
      v36 = (v35 + 32);
    }

    a4 = v97;
    v101[1] = v36;
    if (__p)
    {
      *&v104 = __p;
      operator delete(__p);
    }

    if (v117)
    {
      v118 = v117;
      operator delete(v117);
    }
  }

  if (a5)
  {
    sentencepiece::unigram::Lattice::NBest(&v121, a8, a4 + 1, 1, &v117);
    if (a6)
    {
      std::vector<std::vector<sentencepiece::unigram::Lattice::Node *>>::vector[abi:ne200100](&v115, (v118 - v117) >> 5);
      v38 = v117;
      v37 = v118;
      if (v118 != v117)
      {
        v39 = 0;
        v40 = 0;
        v41 = 0;
        do
        {
          if (&v38[v39] != (v115 + v40))
          {
            std::vector<kaldi::CuWorkspace *>::__assign_with_size[abi:ne200100]<kaldi::CuWorkspace **,kaldi::CuWorkspace **>((v115 + v40), v38[v39].n128_u64[0], v38[v39].n128_u64[1], (v38[v39].n128_u64[1] - v38[v39].n128_u64[0]) >> 3);
            v38 = v117;
            v37 = v118;
          }

          ++v41;
          v40 += 24;
          v39 += 2;
        }

        while (v41 < (v37 - v38) >> 5);
      }

      sentencepiece::unigram::Lattice::Viterbi(&v121, &__p);
      v42 = std::__find[abi:ne200100]<std::vector<sentencepiece::unigram::Lattice::Node *> *,std::vector<sentencepiece::unigram::Lattice::Node *> *,std::vector<sentencepiece::unigram::Lattice::Node *>,std::__identity>(v115, v116, &__p);
      v43 = 0xAAAAAAAAAAAAAAABLL * ((v42 - v115) >> 3);
      if (v43 == (v118 - v117) >> 5)
      {
        v45 = v118 - 2;
        v44 = v118[-2].n128_u64[0];
        if (v44)
        {
          v118[-2].n128_u64[1] = v44;
          operator delete(v44);
        }
      }

      else
      {
        if (sentencepiece::logging::GetMinLogLevel(v42) <= 0)
        {
          LOBYTE(v102) = 0;
          v59 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "unigram_model.cc", 16);
          v60 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v59, "(", 1);
          v61 = MEMORY[0x1B8C84C00](v60, 715);
          v62 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v61, ") ", 2);
          v63 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v62, "LOG(", 4);
          v64 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v63, "INFO", 4);
          v65 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v64, ") ", 2);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v65, "removing best path from samples", 31);
          sentencepiece::error::Die::~Die(&v102);
        }

        v66 = v118;
        v45 = &v117[2 * v43];
        if (&v45[2] != v118)
        {
          do
          {
            v67 = v45 + 2;
            std::vector<int>::__move_assign(v45, v45 + 2);
            v45[1].n128_u32[2] = v45[3].n128_u32[2];
            v68 = v45 + 4;
            v45 += 2;
          }

          while (v68 != v66);
          v66 = v118;
          v45 = v67;
        }

        if (v66 != v45)
        {
          v69 = v66;
          do
          {
            v71 = v69[-2].n128_u64[0];
            v69 -= 2;
            v70 = v71;
            if (v71)
            {
              v66[-2].n128_u64[1] = v70;
              operator delete(v70);
            }

            v66 = v69;
          }

          while (v69 != v45);
        }
      }

      v118 = v45;
      if (__p)
      {
        *&v104 = __p;
        operator delete(__p);
      }

      __p = &v115;
      std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne200100](&__p);
    }

    v72 = v118[-2].n128_u64[0];
    v100 = v118 - 2;
    v73 = v118[-1].n128_f32[2];
    if (v72)
    {
      v118[-2].n128_u64[1] = v72;
      operator delete(v72);
    }

    v118 = v100;
    for (i = v117; i != v100; i += 2)
    {
      __p = 0;
      v104 = 0uLL;
      v76 = i->n128_u64[0];
      v75 = i->n128_i64[1];
      if (i->n128_u64[0] == v75)
      {
        v78 = 0.0;
      }

      else
      {
        v77 = 0;
        v78 = 0.0;
        do
        {
          v79 = *v76;
          v80 = *(*v76 + 32);
          if (v77 >= *(&v104 + 1))
          {
            v81 = 0xAAAAAAAAAAAAAAABLL * ((v77 - __p) >> 3);
            v82 = v81 + 1;
            if (v81 + 1 > 0xAAAAAAAAAAAAAAALL)
            {
              std::vector<int>::__throw_length_error[abi:ne200100]();
            }

            if (0x5555555555555556 * ((*(&v104 + 1) - __p) >> 3) > v82)
            {
              v82 = 0x5555555555555556 * ((*(&v104 + 1) - __p) >> 3);
            }

            if (0xAAAAAAAAAAAAAAABLL * ((*(&v104 + 1) - __p) >> 3) >= 0x555555555555555)
            {
              v83 = 0xAAAAAAAAAAAAAAALL;
            }

            else
            {
              v83 = v82;
            }

            if (v83)
            {
              std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(&__p, v83);
            }

            v84 = 24 * v81;
            *v84 = *v79;
            *(v84 + 16) = *(v79 + 28);
            v77 = 24 * v81 + 24;
            v85 = (v84 - (v104 - __p));
            memcpy(v85, __p, v104 - __p);
            v86 = __p;
            __p = v85;
            v104 = v77;
            if (v86)
            {
              operator delete(v86);
            }
          }

          else
          {
            *v77 = *v79;
            *(v77 + 16) = *(v79 + 28);
            v77 += 24;
          }

          *&v104 = v77;
          v78 = v78 + (a8 * v80);
          ++v76;
        }

        while (v76 != v75);
      }

      *&v115 = v78 - v17;
      v87 = v101[1];
      if (v87 >= v101[2])
      {
        v88 = std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__emplace_back_slow_path<std::vector<std::pair<absl::string_view,int>>&,float const&>(v101, &__p, &v115);
      }

      else
      {
        std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__construct_one_at_end[abi:ne200100]<std::vector<std::pair<absl::string_view,int>>&,float const&>(v101, &__p, &v115);
        v88 = (v87 + 32);
      }

      v101[1] = v88;
      if (__p)
      {
        *&v104 = __p;
        operator delete(__p);
      }
    }

    v89 = *v101;
    v90 = v101[1];
    if (*v101 != v90)
    {
      do
      {
        v91 = *(v89 + 24);
        if (v91 != 0.0)
        {
          v92 = v91 - v73;
          v93 = exp(v92);
          if (v92 <= -10.0)
          {
            v95 = v92 + v93 * -0.5 + v93 * v93 / 24.0 + pow(v93, 4.0) / -2880.0;
          }

          else
          {
            v94 = expm1(-v93);
            v95 = log(-v94);
          }

          v96 = v95;
          *(v89 + 24) = v96;
        }

        v89 += 32;
      }

      while (v89 != v90);
    }

    __p = &v117;
    std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&__p);
  }

  else
  {
    v98 = a4;
    if (a4 > ((a7[1] - *a7) >> 5))
    {
      v99 = a3;
      do
      {
        v104 = 0u;
        v105 = 0u;
        v106 = 0u;
        v107 = 0u;
        v108 = 0u;
        v109 = 0;
        __p = &unk_1F2D43EF0;
        v110 = &unk_1F2D44020;
        v111 = 0u;
        v112 = 0u;
        v113 = 0;
        v114 = 1024;
        sentencepiece::unigram::Lattice::SetSentence(&__p, a2, a3);
        sentencepiece::unigram::Model::PopulateNodes(a1, &__p);
        v117 = 0;
        v118 = 0;
        v119 = 0;
        sentencepiece::unigram::Lattice::Sample(&__p, a8, &v115);
        v47 = v115;
        v46 = v116;
        v48 = 0.0;
        if (v115 != v116)
        {
          v49 = v118;
          do
          {
            v50 = *v47;
            if (v49 >= v119)
            {
              v51 = 0xAAAAAAAAAAAAAAABLL * ((v49 - v117) >> 3);
              v52 = v51 + 1;
              if (v51 + 1 > 0xAAAAAAAAAAAAAAALL)
              {
                std::vector<int>::__throw_length_error[abi:ne200100]();
              }

              if (0x5555555555555556 * ((v119 - v117) >> 3) > v52)
              {
                v52 = 0x5555555555555556 * ((v119 - v117) >> 3);
              }

              if (0xAAAAAAAAAAAAAAABLL * ((v119 - v117) >> 3) >= 0x555555555555555)
              {
                v53 = 0xAAAAAAAAAAAAAAALL;
              }

              else
              {
                v53 = v52;
              }

              if (v53)
              {
                std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(&v117, v53);
              }

              v54 = 24 * v51;
              *v54 = *v50;
              *(v54 + 16) = *(v50 + 28);
              v49 = 24 * v51 + 24;
              v55 = (v54 - (v118 - v117));
              memcpy(v55, v117, v118 - v117);
              v56 = v117;
              v117 = v55;
              v118 = v49;
              v119 = 0;
              if (v56)
              {
                operator delete(v56);
              }
            }

            else
            {
              *v49 = *v50;
              *(v49 + 16) = *(v50 + 28);
              v49 += 24;
            }

            v118 = v49;
            v48 = v48 + (a8 * *(v50 + 32));
            v47 = (v47 + 8);
          }

          while (v47 != v46);
        }

        v102 = v48 - v17;
        v57 = v101[1];
        if (v57 >= v101[2])
        {
          v58 = std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__emplace_back_slow_path<std::vector<std::pair<absl::string_view,int>>&,float const&>(v101, &v117, &v102);
          a3 = v99;
        }

        else
        {
          std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__construct_one_at_end[abi:ne200100]<std::vector<std::pair<absl::string_view,int>>&,float const&>(v101, &v117, &v102);
          a3 = v99;
          v58 = (v57 + 32);
        }

        v101[1] = v58;
        if (v115)
        {
          v116 = v115;
          operator delete(v115);
        }

        if (v117)
        {
          v118 = v117;
          operator delete(v117);
        }

        sentencepiece::unigram::Lattice::~Lattice(&__p);
      }

      while (v98 > (v101[1] - *v101) >> 5);
    }
  }

  if (v120[0])
  {
    v120[1] = v120[0];
    operator delete(v120[0]);
  }

  sentencepiece::unigram::Lattice::~Lattice(&v121);
}

void sub_1B5ABF500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15, int a16, char a17, char *__p, char *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37, uint64_t a38, uint64_t a39, char a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, void **a46)
{
  if (__p)
  {
    a19 = __p;
    operator delete(__p);
  }

  __p = &a37;
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne200100](&__p);
  __p = &a40;
  std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&__p);
  v48 = *(v46 + 200);
  if (v48)
  {
    *(v46 + 208) = v48;
    operator delete(v48);
  }

  sentencepiece::unigram::Lattice::~Lattice(&a46);
  a46 = a15;
  std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&a46);
  _Unwind_Resume(a1);
}

float sentencepiece::unigram::Model::CalculateEntropy(sentencepiece::unigram::Model *a1, unsigned __int8 *a2, uint64_t a3, float a4)
{
  v8 = &unk_1F2D43EF0;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0;
  v15 = &unk_1F2D44020;
  v16 = 0u;
  v17 = 0u;
  v18 = 0;
  v19 = 1024;
  sentencepiece::unigram::Lattice::SetSentence(&v8, a2, a3);
  sentencepiece::unigram::Model::PopulateNodes(a1, &v8);
  v6 = sentencepiece::unigram::Lattice::CalculateEntropy(&v8, a4);
  sentencepiece::unigram::Lattice::~Lattice(&v8);
  return v6;
}

void sub_1B5ABF718(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sentencepiece::unigram::Lattice::~Lattice(va);
  _Unwind_Resume(a1);
}

BOOL sentencepiece::unigram::Model::VerifyOutputsEquivalent(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  strcpy(__s, " ");
  v10 = strlen(__s);
  absl::internal::Splitter::Splitter(&v47, a2, a3, __s, v10, 0);
  v50 = 0;
  v51 = 0;
  __p = 0;
  std::vector<absl::string_view>::__init_with_size[abi:ne200100]<absl::string_view*,absl::string_view*>(&__p, v47, v48, (v48 - v47) >> 4);
  v11 = __p;
  v12 = v50;
  if (__p == v50)
  {
    v14 = 0.0;
    if (__p)
    {
LABEL_11:
      v50 = v11;
      operator delete(v11);
    }
  }

  else
  {
    v13 = *(a1 + 120) + -10.0;
    v14 = 0.0;
    do
    {
      v15 = v11[1];
      v16 = (*(*a1 + 128))(a1, *v11, v15);
      if (v16 == *(a1 + 104))
      {
        v14 = v13 + v14;
      }

      else
      {
        v17 = *(*(*(a1 + 8) + 64) + 8 * v16 + 8);
        if (*(v17 + 60) == 4)
        {
          v18 = (*(a1 + 124) * v15) + -0.1;
        }

        else
        {
          v18 = *(v17 + 56);
        }

        v14 = v18 + v14;
      }

      v11 += 2;
    }

    while (v11 != v12);
    v11 = __p;
    if (__p)
    {
      goto LABEL_11;
    }
  }

  if (v47)
  {
    v48 = v47;
    operator delete(v47);
  }

  strcpy(__s, " ");
  v19 = strlen(__s);
  absl::internal::Splitter::Splitter(&v47, a4, a5, __s, v19, 0);
  v45 = 0;
  v46 = 0;
  v44 = 0;
  std::vector<absl::string_view>::__init_with_size[abi:ne200100]<absl::string_view*,absl::string_view*>(&v44, v47, v48, (v48 - v47) >> 4);
  v20 = v44;
  v21 = v45;
  if (v44 != v45)
  {
    v22 = *(a1 + 120) + -10.0;
    v23 = 0.0;
    do
    {
      v24 = v20[1];
      v25 = (*(*a1 + 128))(a1, *v20, v24);
      if (v25 == *(a1 + 104))
      {
        v23 = v22 + v23;
      }

      else
      {
        v26 = *(*(*(a1 + 8) + 64) + 8 * v25 + 8);
        if (*(v26 + 60) == 4)
        {
          v27 = (*(a1 + 124) * v24) + -0.1;
        }

        else
        {
          v27 = *(v26 + 56);
        }

        v23 = v27 + v23;
      }

      v20 += 2;
    }

    while (v20 != v21);
    v20 = v44;
    if (!v44)
    {
      goto LABEL_25;
    }

    goto LABEL_24;
  }

  v23 = 0.0;
  if (v44)
  {
LABEL_24:
    v45 = v20;
    operator delete(v20);
  }

LABEL_25:
  v28 = v47;
  if (v47)
  {
    v48 = v47;
    operator delete(v47);
  }

  v29 = vabds_f32(v14, v23);
  if (v29 > 0.0000001 && sentencepiece::logging::GetMinLogLevel(v28) <= 1)
  {
    LOBYTE(v47) = 0;
    v30 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "unigram_model.cc", 16);
    v31 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v30, "(", 1);
    v32 = MEMORY[0x1B8C84C00](v31, 807);
    v33 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v32, ") ", 2);
    v34 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v33, "LOG(", 4);
    v35 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v34, "WARNING", 7);
    v36 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v35, ") ", 2);
    v37 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v36, "Two sentence piece sequences are not equivalent! Left: ", 55);
    v38 = absl::operator<<(v37, a2, a3);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v38, ", Score: ", 9);
    v39 = std::ostream::operator<<();
    v40 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v39, ". Right: ", 9);
    v41 = absl::operator<<(v40, a4, a5);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v41, ", Score: ", 9);
    v42 = std::ostream::operator<<();
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v42, ".", 1);
    sentencepiece::error::Die::~Die(&v47);
  }

  return v29 <= 0.0000001;
}

void sub_1B5ABFB14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::vector<sentencepiece::unigram::Lattice::Node *>::__init_with_size[abi:ne200100]<sentencepiece::unigram::Lattice::Node **,sentencepiece::unigram::Lattice::Node **>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<kaldi::CuWorkspace *>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1B5ABFBD0(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::vector<absl::string_view>::__init_with_size[abi:ne200100]<absl::string_view*,absl::string_view*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<absl::string_view>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1B5ABFC4C(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<absl::string_view>::__vallocate[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 60))
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<std::string_view>>(a1, a2);
  }

  std::vector<int>::__throw_length_error[abi:ne200100]();
}

void sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::Node>::~FreeList(void *a1)
{
  sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::Node>::~FreeList(a1);

  JUMPOUT(0x1B8C85350);
}

void *sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::Node>::~FreeList(void *a1)
{
  *a1 = &unk_1F2D44020;
  v2 = a1[1];
  v3 = a1[2];
  if (v2 != v3)
  {
    do
    {
      if (*v2)
      {
        MEMORY[0x1B8C85310](*v2, 0x1070C8005A2B047);
      }

      ++v2;
    }

    while (v2 != v3);
    v2 = a1[1];
  }

  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  return a1;
}

uint64_t std::vector<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>::__init_with_size[abi:ne200100]<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float> const*,std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float> const*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_1B5ABFDD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<fst::IntervalSet<int>>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>::__vallocate[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 59))
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>>(a1, a2);
  }

  std::vector<int>::__throw_length_error[abi:ne200100]();
}

void std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>>(uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 59))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>,std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float> const*,std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float> const*,std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      *(v4 + 8) = 0;
      *(v4 + 16) = 0;
      std::vector<sentencepiece::unigram::Lattice::Node *>::__init_with_size[abi:ne200100]<sentencepiece::unigram::Lattice::Node **,sentencepiece::unigram::Lattice::Node **>(v4, *v6, *(v6 + 8), (*(v6 + 8) - *v6) >> 3);
      *(v4 + 24) = *(v6 + 24);
      v6 += 32;
      v4 = v11 + 32;
      v11 += 32;
    }

    while (v6 != a3);
  }

  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>,std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>*>>::~__exception_guard_exceptions[abi:ne200100](v8);
  return v4;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>,std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>*>>::~__exception_guard_exceptions[abi:ne200100](uint64_t a1)
{
  if ((*(a1 + 24) & 1) == 0)
  {
    std::_AllocatorDestroyRangeReverse<std::allocator<fst::IntervalSet<int>>,fst::IntervalSet<int>*>::operator()[abi:ne200100](a1);
  }

  return a1;
}

void sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis>::~FreeList(void *a1)
{
  sentencepiece::model::FreeList<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis>::~FreeList(a1);

  JUMPOUT(0x1B8C85350);
}

uint64_t std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::HypothesisComparator &,std::__wrap_iter<sentencepiece::unigram::Lattice::NBest(unsigned long,BOOL,float)::Hypothesis **>>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3 >= 2)
  {
    v3 = (a3 - 2) >> 1;
    v4 = (result + 8 * v3);
    v5 = *v4;
    v8 = *(a2 - 8);
    v6 = (a2 - 8);
    v7 = v8;
    v9 = *(v8 + 16);
    if (*(*v4 + 16) < v9)
    {
      do
      {
        v10 = v4;
        *v6 = v5;
        if (!v3)
        {
          break;
        }

        v3 = (v3 - 1) >> 1;
        v4 = (result + 8 * v3);
        v5 = *v4;
        v6 = v10;
      }

      while (*(*v4 + 16) < v9);
      *v10 = v7;
    }
  }

  return result;
}

uint64_t std::vector<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>::__append(uint64_t result, unint64_t a2)
{
  v3 = result;
  v4 = *(result + 8);
  v5 = *(result + 16);
  if (a2 <= (v5 - v4) >> 5)
  {
    if (a2)
    {
      v11 = 32 * a2;
      v12 = v4 + 32 * a2;
      do
      {
        *v4 = 0;
        *(v4 + 8) = 0;
        *(v4 + 24) = 0;
        *(v4 + 16) = 0;
        v4 += 32;
        v11 -= 32;
      }

      while (v11);
      v4 = v12;
    }

    *(result + 8) = v4;
  }

  else
  {
    v6 = v4 - *result;
    v7 = a2 + (v6 >> 5);
    if (v7 >> 59)
    {
      std::vector<int>::__throw_length_error[abi:ne200100]();
    }

    v8 = v6 >> 5;
    v9 = v5 - *result;
    if (v9 >> 4 > v7)
    {
      v7 = v9 >> 4;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFE0)
    {
      v10 = 0x7FFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v7;
    }

    v21[4] = result;
    if (v10)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<std::vector<sentencepiece::unigram::Lattice::Node *>,float>>>(result, v10);
    }

    v13 = 32 * v8;
    v14 = 32 * a2;
    v15 = 32 * v8;
    v16 = 32 * v8 + 32 * a2;
    do
    {
      *v15 = 0;
      *(v15 + 8) = 0;
      *(v15 + 24) = 0;
      *(v15 + 16) = 0;
      v15 += 32;
      v14 -= 32;
    }

    while (v14);
    v17 = *(result + 8) - *result;
    v18 = v13 - v17;
    memcpy((v13 - v17), *result, v17);
    v19 = *v3;
    *v3 = v18;
    v3[1] = v16;
    v20 = v3[2];
    v3[2] = 0;
    v21[2] = v19;
    v21[3] = v20;
    v21[0] = v19;
    v21[1] = v19;
    return std::__split_buffer<fst::IntervalSet<int>>::~__split_buffer(v21);
  }

  return result;
}

void *std::vector<Darts::DoubleArrayImpl<void,void,int,void>::result_pair_type,std::allocator<Darts::DoubleArrayImpl<void,void,int,void>::result_pair_type>>::vector[abi:ne200100](void *result, unint64_t a2)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  if (a2)
  {
    std::vector<Darts::DoubleArrayImpl<void,void,int,void>::result_pair_type,std::allocator<Darts::DoubleArrayImpl<void,void,int,void>::result_pair_type>>::__vallocate[abi:ne200100](result, a2);
  }

  return result;
}

void sub_1B5AC0188(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<Darts::DoubleArrayImpl<void,void,int,void>::result_pair_type,std::allocator<Darts::DoubleArrayImpl<void,void,int,void>::result_pair_type>>::__vallocate[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 60))
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<int,unsigned long>>>(a1, a2);
  }

  std::vector<int>::__throw_length_error[abi:ne200100]();
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,false>(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
LABEL_1:
  v8 = (a2 - 24);
  v72 = (a2 - 8);
  v73 = (a2 - 72);
  v74 = (a2 - 48);
  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (1)
  {
    a1 = v9;
    v11 = v10;
    v12 = a2 - v9;
    v13 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v9) >> 3);
    if (v13 <= 2)
    {
      if (v13 < 2)
      {
        return;
      }

      if (v13 == 2)
      {
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2 - 24, v9))
        {
          v96 = *v9;
          *v9 = *v8;
          *v8 = v96;
          v67 = *(v9 + 16);
          *(v9 + 16) = *(a2 - 8);
          *(a2 - 8) = v67;
        }

        return;
      }

      goto LABEL_10;
    }

    if (v13 == 3)
    {
      v62 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v9 + 24, v9);
      v63 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2 - 24, v9 + 24);
      if (v62)
      {
        if (v63)
        {
          v64 = (v9 + 16);
          v95 = *v9;
          *v9 = *v8;
          v65 = v95;
        }

        else
        {
          v98 = *v9;
          *v9 = *(v9 + 24);
          *(v9 + 24) = v98;
          v64 = (v9 + 40);
          v70 = *(v9 + 16);
          *(v9 + 16) = *(v9 + 40);
          *(v9 + 40) = v70;
          if (!std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v8, v9 + 24))
          {
            return;
          }

          v65 = *(v9 + 24);
          *(v9 + 24) = *v8;
        }

        *v8 = v65;
      }

      else
      {
        if (!v63)
        {
          return;
        }

        v68 = *(v9 + 24);
        *(v9 + 24) = *v8;
        *v8 = v68;
        v69 = *(v9 + 40);
        v72 = (v9 + 40);
        *(v9 + 40) = *(a2 - 8);
        *(a2 - 8) = v69;
        if (!std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v9 + 24, v9))
        {
          return;
        }

        v97 = *v9;
        *v9 = *(v9 + 24);
        *(v9 + 24) = v97;
        v64 = (v9 + 16);
      }

      v71 = *v64;
      *v64 = *v72;
      *v72 = v71;
      return;
    }

    if (v13 == 4)
    {
      break;
    }

    if (v13 == 5)
    {

      std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,0>(v9, v9 + 24, v9 + 48, v9 + 72, a2 - 24, a3);
      return;
    }

LABEL_10:
    if (v12 <= 575)
    {
      if (a5)
      {

        std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(v9, a2, a3);
      }

      else
      {

        std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(v9, a2, a3);
      }

      return;
    }

    if (v11 == 1)
    {
      if (v9 != a2)
      {

        std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,std::pair<absl::string_view,int> *>(v9, a2, a2, a3);
      }

      return;
    }

    v14 = v13 >> 1;
    v15 = v9 + 24 * (v13 >> 1);
    if (v12 >= 0xC01)
    {
      v16 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v9 + 24 * v14, v9);
      v17 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2 - 24, a1 + 24 * v14);
      if (v16)
      {
        if (v17)
        {
          v18 = (a1 + 16);
          v76 = *a1;
          *a1 = *v8;
          goto LABEL_27;
        }

        v82 = *a1;
        *a1 = *v15;
        *v15 = v82;
        v18 = (v15 + 16);
        v26 = *(a1 + 16);
        *(a1 + 16) = *(v15 + 16);
        *(v15 + 16) = v26;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2 - 24, a1 + 24 * v14))
        {
          v76 = *v15;
          *v15 = *v8;
LABEL_27:
          *v8 = v76;
          v23 = (a2 - 8);
LABEL_28:
          v27 = *v18;
          *v18 = *v23;
          *v23 = v27;
        }
      }

      else if (v17)
      {
        v78 = *v15;
        *v15 = *v8;
        *v8 = v78;
        v23 = (v15 + 16);
        v22 = *(v15 + 16);
        *(v15 + 16) = *(a2 - 8);
        *(a2 - 8) = v22;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a1 + 24 * v14, a1))
        {
          v79 = *a1;
          *a1 = *v15;
          *v15 = v79;
          v18 = (a1 + 16);
          goto LABEL_28;
        }
      }

      v28 = a1 + 24 * v14 - 24;
      v29 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v28, a1 + 24);
      v30 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v74, v28);
      if (v29)
      {
        v31 = (a1 + 40);
        if (v30)
        {
          v32 = *(a1 + 24);
          *(a1 + 24) = *v74;
          *v74 = v32;
          goto LABEL_40;
        }

        v86 = *(a1 + 24);
        *(a1 + 24) = *v28;
        *v28 = v86;
        v36 = *v31;
        *v31 = *(a1 + 24 * v14 - 8);
        *(a1 + 24 * v14 - 8) = v36;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v74, v28))
        {
          v87 = *v28;
          *v28 = *v74;
          *v74 = v87;
          v31 = (a1 + 24 * v14 - 8);
LABEL_40:
          v34 = (a2 - 32);
LABEL_41:
          v37 = *v31;
          *v31 = *v34;
          *v34 = v37;
        }
      }

      else if (v30)
      {
        v83 = *v28;
        *v28 = *v74;
        *v74 = v83;
        v34 = (a1 + 24 * v14 - 8);
        v33 = *v34;
        *v34 = *(a2 - 32);
        *(a2 - 32) = v33;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v28, a1 + 24))
        {
          v84 = *(a1 + 24);
          *(a1 + 24) = *v28;
          *v28 = v84;
          v31 = (a1 + 40);
          goto LABEL_41;
        }
      }

      v38 = a1 + 24 * v14 + 24;
      v39 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v38, a1 + 48);
      v40 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v73, v38);
      if (v39)
      {
        v41 = (a1 + 64);
        if (v40)
        {
          v42 = *(a1 + 48);
          *(a1 + 48) = *v73;
          *v73 = v42;
          goto LABEL_50;
        }

        v46 = *(a1 + 48);
        *(a1 + 48) = *v38;
        *v38 = v46;
        v47 = *v41;
        *v41 = *(v38 + 16);
        *(v38 + 16) = v47;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v73, v38))
        {
          v89 = *v38;
          *v38 = *v73;
          *v73 = v89;
          v41 = (v38 + 16);
LABEL_50:
          v44 = (a2 - 56);
LABEL_51:
          v48 = *v41;
          *v41 = *v44;
          *v44 = v48;
        }
      }

      else if (v40)
      {
        v88 = *v38;
        *v38 = *v73;
        *v73 = v88;
        v44 = (v38 + 16);
        v43 = *(v38 + 16);
        *(v38 + 16) = *(a2 - 56);
        *(a2 - 56) = v43;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v38, a1 + 48))
        {
          v45 = *(a1 + 48);
          *(a1 + 48) = *v38;
          *v38 = v45;
          v41 = (a1 + 64);
          goto LABEL_51;
        }
      }

      v49 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v15, v28);
      v50 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v38, v15);
      if (v49)
      {
        if (v50)
        {
          v51 = (v28 + 16);
          v90 = *v28;
          *v28 = *v38;
          goto LABEL_60;
        }

        v93 = *v28;
        *v28 = *v15;
        *v15 = v93;
        v51 = (v15 + 16);
        v54 = *(v28 + 16);
        *(v28 + 16) = *(v15 + 16);
        *(v15 + 16) = v54;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v38, v15))
        {
          v90 = *v15;
          *v15 = *v38;
LABEL_60:
          *v38 = v90;
          v53 = (v38 + 16);
LABEL_61:
          v55 = *v51;
          *v51 = *v53;
          *v53 = v55;
        }
      }

      else if (v50)
      {
        v91 = *v15;
        *v15 = *v38;
        *v38 = v91;
        v53 = (v15 + 16);
        v52 = *(v15 + 16);
        *(v15 + 16) = *(v38 + 16);
        *(v38 + 16) = v52;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v15, v28))
        {
          v92 = *v28;
          *v28 = *v15;
          *v15 = v92;
          v51 = (v28 + 16);
          goto LABEL_61;
        }
      }

      v94 = *a1;
      *a1 = *v15;
      *v15 = v94;
      v21 = (a1 + 16);
      v25 = (v15 + 16);
LABEL_63:
      v56 = *v21;
      *v21 = *v25;
      *v25 = v56;
      goto LABEL_64;
    }

    v19 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v9, v9 + 24 * v14);
    v20 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2 - 24, v9);
    if (v19)
    {
      if (v20)
      {
        v21 = (v15 + 16);
        v77 = *v15;
        *v15 = *v8;
LABEL_37:
        *v8 = v77;
        v25 = (a2 - 8);
        goto LABEL_63;
      }

      v85 = *v15;
      *v15 = *v9;
      *v9 = v85;
      v21 = (v9 + 16);
      v35 = *(v15 + 16);
      *(v15 + 16) = *(v9 + 16);
      *(v9 + 16) = v35;
      if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2 - 24, v9))
      {
        v77 = *v9;
        *v9 = *v8;
        goto LABEL_37;
      }
    }

    else if (v20)
    {
      v80 = *v9;
      *v9 = *v8;
      *v8 = v80;
      v25 = (v9 + 16);
      v24 = *(v9 + 16);
      *(v9 + 16) = *(a2 - 8);
      *(a2 - 8) = v24;
      if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v9, v15))
      {
        v81 = *v15;
        *v15 = *v9;
        *v9 = v81;
        v21 = (v15 + 16);
        goto LABEL_63;
      }
    }

LABEL_64:
    if ((a5 & 1) == 0 && (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a1 - 24, a1) & 1) == 0)
    {
      v9 = std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,std::pair<absl::string_view,int> *,std::__less<void,void> &>(a1, a2, a3);
      goto LABEL_71;
    }

    v58.n128_f64[0] = std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,std::pair<absl::string_view,int> *,std::__less<void,void> &>(a1, a2, a3);
    v59 = v57;
    if ((v60 & 1) == 0)
    {
      goto LABEL_69;
    }

    v61 = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(a1, v57, a3);
    v9 = v59 + 24;
    if (std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(v59 + 24, a2, a3))
    {
      a4 = -v11;
      a2 = v59;
      if (v61)
      {
        return;
      }

      goto LABEL_1;
    }

    v10 = v11 + 1;
    if (!v61)
    {
LABEL_69:
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,false>(a1, v59, a3, -v11, a5 & 1, v58);
      v9 = v59 + 24;
LABEL_71:
      a5 = 0;
      a4 = -v11;
      goto LABEL_2;
    }
  }

  std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,0>(v9, v9 + 24, v9 + 48, a2 - 24, a3);
}

uint64_t std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(a2 + 8);
  v6 = *(a3 + 8);
  if (v6 >= v5)
  {
    v7 = *(a2 + 8);
  }

  else
  {
    v7 = *(a3 + 8);
  }

  if (!v7)
  {
    if (v5 >= v6)
    {
      if (v6 >= v5)
      {
        return *(a2 + 16) < *(a3 + 16);
      }

      return 0;
    }

    return 1;
  }

  v8 = *a3;
  v9 = *a2;
  v10 = memcmp(*a2, *a3, v7);
  if (v10 < 0)
  {
    return 1;
  }

  if (v5 < v6 && v10 == 0)
  {
    return 1;
  }

  result = memcmp(v8, v9, v7);
  if ((result & 0x80000000) != 0)
  {
    return 0;
  }

  if (v6 >= v5 || result)
  {
    return *(a2 + 16) < *(a3 + 16);
  }

  return result;
}

__n128 std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v10 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a5, a2, a1);
  v11 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a5, a3, a2);
  if (v10)
  {
    if (v11)
    {
      v12 = (a1 + 16);
      v13 = *a1;
      *a1 = *a3;
LABEL_9:
      *a3 = v13;
      v16 = (a3 + 16);
      goto LABEL_10;
    }

    v18 = *a1;
    *a1 = *a2;
    *a2 = v18;
    v12 = (a2 + 16);
    v19 = *(a1 + 16);
    *(a1 + 16) = *(a2 + 16);
    *(a2 + 16) = v19;
    if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a5, a3, a2))
    {
      v13 = *a2;
      *a2 = *a3;
      goto LABEL_9;
    }
  }

  else if (v11)
  {
    v14 = *a2;
    *a2 = *a3;
    *a3 = v14;
    v16 = (a2 + 16);
    v15 = *(a2 + 16);
    *(a2 + 16) = *(a3 + 16);
    *(a3 + 16) = v15;
    if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a5, a2, a1))
    {
      v17 = *a1;
      *a1 = *a2;
      *a2 = v17;
      v12 = (a1 + 16);
LABEL_10:
      v20 = *v12;
      *v12 = *v16;
      *v16 = v20;
    }
  }

  if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a5, a4, a3))
  {
    v22 = *a3;
    *a3 = *a4;
    *a4 = v22;
    v23 = *(a3 + 16);
    *(a3 + 16) = *(a4 + 16);
    *(a4 + 16) = v23;
    if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a5, a3, a2))
    {
      v24 = *a2;
      *a2 = *a3;
      *a3 = v24;
      v25 = *(a2 + 16);
      *(a2 + 16) = *(a3 + 16);
      *(a3 + 16) = v25;
      if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a5, a2, a1))
      {
        result = *a1;
        *a1 = *a2;
        *a2 = result;
        v26 = *(a1 + 16);
        *(a1 + 16) = *(a2 + 16);
        *(a2 + 16) = v26;
      }
    }
  }

  return result;
}

__n128 std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,0>(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,0>(a1, a2, a3, a4, a6);
  if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a6, a5, a4))
  {
    v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    v14 = *(a4 + 16);
    *(a4 + 16) = *(a5 + 16);
    *(a5 + 16) = v14;
    if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a6, a4, a3))
    {
      v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      v16 = *(a3 + 16);
      *(a3 + 16) = *(a4 + 16);
      *(a4 + 16) = v16;
      if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a6, a3, a2))
      {
        v17 = *a2;
        *a2 = *a3;
        *a3 = v17;
        v18 = *(a2 + 16);
        *(a2 + 16) = *(a3 + 16);
        *(a3 + 16) = v18;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a6, a2, a1))
        {
          result = *a1;
          *a1 = *a2;
          *a2 = result;
          v19 = a1[1].n128_u32[0];
          a1[1].n128_u32[0] = *(a2 + 16);
          *(a2 + 16) = v19;
        }
      }
    }
  }

  return result;
}

uint64_t std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    v17 = v3;
    v18 = v4;
    v6 = result;
    v7 = result + 24;
    if (result + 24 != a2)
    {
      v9 = 0;
      v10 = result;
      do
      {
        v11 = v10;
        v10 = v7;
        result = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v7, v11);
        if (result)
        {
          v15 = *v10;
          v16 = *(v10 + 16);
          v12 = v9;
          while (1)
          {
            v13 = v6 + v12;
            *(v13 + 24) = *(v6 + v12);
            *(v13 + 40) = *(v6 + v12 + 16);
            if (!v12)
            {
              break;
            }

            v12 -= 24;
            result = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, &v15, v12 + v6);
            if ((result & 1) == 0)
            {
              v14 = v6 + v12 + 24;
              goto LABEL_10;
            }
          }

          v14 = v6;
LABEL_10:
          *v14 = v15;
          *(v14 + 16) = v16;
        }

        v7 = v10 + 24;
        v9 += 24;
      }

      while (v10 + 24 != a2);
    }
  }

  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    v14 = v3;
    v15 = v4;
    v6 = result;
    v7 = result + 24;
    if (result + 24 != a2)
    {
      v9 = result - 24;
      do
      {
        v10 = v6;
        v6 = v7;
        result = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v7, v10);
        if (result)
        {
          v12 = *v6;
          v13 = *(v6 + 16);
          v11 = v9;
          do
          {
            *(v11 + 48) = *(v11 + 24);
            *(v11 + 64) = *(v11 + 40);
            result = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, &v12, v11);
            v11 -= 24;
          }

          while ((result & 1) != 0);
          *(v11 + 48) = v12;
          *(v11 + 64) = v13;
        }

        v7 = v6 + 24;
        v9 += 24;
      }

      while (v6 + 24 != a2);
    }
  }

  return result;
}

unint64_t std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,std::pair<absl::string_view,int> *,std::__less<void,void> &>(unint64_t a1, unint64_t a2, uint64_t a3)
{
  v4 = a2;
  v12 = *a1;
  v13 = *(a1 + 16);
  if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, &v12, a2 - 24))
  {
    v6 = a1;
    do
    {
      v6 += 24;
    }

    while ((std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, &v12, v6) & 1) == 0);
  }

  else
  {
    v7 = a1 + 24;
    do
    {
      v6 = v7;
      if (v7 >= v4)
      {
        break;
      }

      v8 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, &v12, v7);
      v7 = v6 + 24;
    }

    while (!v8);
  }

  if (v6 < v4)
  {
    do
    {
      v4 -= 24;
    }

    while ((std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, &v12, v4) & 1) != 0);
  }

  while (v6 < v4)
  {
    v14 = *v6;
    *v6 = *v4;
    *v4 = v14;
    v9 = *(v6 + 16);
    *(v6 + 16) = *(v4 + 16);
    *(v4 + 16) = v9;
    do
    {
      v6 += 24;
    }

    while (!std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, &v12, v6));
    do
    {
      v4 -= 24;
    }

    while ((std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, &v12, v4) & 1) != 0);
  }

  v10 = (v6 - 24);
  if (v6 - 24 != a1)
  {
    *a1 = *v10;
    *(a1 + 16) = *(v6 - 8);
  }

  *v10 = v12;
  *(v6 - 8) = v13;
  return v6;
}

double std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,std::pair<absl::string_view,int> *,std::__less<void,void> &>(__int128 *a1, unint64_t a2, uint64_t a3)
{
  v6 = 0;
  v14 = *a1;
  v15 = *(a1 + 2);
  do
  {
    v6 += 24;
  }

  while ((std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a1 + v6, &v14) & 1) != 0);
  v7 = a1 + v6;
  if (v6 == 24)
  {
    do
    {
      if (v7 >= a2)
      {
        break;
      }

      a2 -= 24;
    }

    while ((std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2, &v14) & 1) == 0);
  }

  else
  {
    do
    {
      a2 -= 24;
    }

    while (!std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2, &v14));
  }

  v8 = a1 + v6;
  if (v7 < a2)
  {
    v9 = a2;
    do
    {
      v16 = *v8;
      v10 = v16;
      *v8 = *v9;
      *v9 = v10;
      v11 = *(v8 + 16);
      *(v8 + 16) = *(v9 + 16);
      *(v9 + 16) = v11;
      do
      {
        v8 += 24;
      }

      while ((std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v8, &v14) & 1) != 0);
      do
      {
        v9 -= 24;
      }

      while (!std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v9, &v14));
    }

    while (v8 < v9);
  }

  v12 = (v8 - 24);
  if ((v8 - 24) != a1)
  {
    *a1 = *v12;
    *(a1 + 4) = *(v8 - 8);
  }

  result = *&v14;
  *v12 = v14;
  *(v8 - 8) = v15;
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  if (v6 > 2)
  {
    switch(v6)
    {
      case 3:
        v10 = (a2 - 24);
        v11 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a1 + 24, a1);
        v12 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2 - 24, a1 + 24);
        if (v11)
        {
          if (v12)
          {
            v13 = (a1 + 16);
            v14 = *a1;
            *a1 = *v10;
          }

          else
          {
            v28 = *a1;
            *a1 = *(a1 + 24);
            *(a1 + 24) = v28;
            v13 = (a1 + 40);
            v29 = *(a1 + 16);
            *(a1 + 16) = *(a1 + 40);
            *(a1 + 40) = v29;
            if (!std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2 - 24, a1 + 24))
            {
              return 1;
            }

            v14 = *(a1 + 24);
            *(a1 + 24) = *v10;
          }

          *v10 = v14;
          v22 = (a2 - 8);
        }

        else
        {
          if (!v12)
          {
            return 1;
          }

          v20 = *(a1 + 24);
          *(a1 + 24) = *v10;
          *v10 = v20;
          v22 = (a1 + 40);
          v21 = *(a1 + 40);
          *(a1 + 40) = *(a2 - 8);
          *(a2 - 8) = v21;
          if (!std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a1 + 24, a1))
          {
            return 1;
          }

          v23 = *a1;
          *a1 = *(a1 + 24);
          *(a1 + 24) = v23;
          v13 = (a1 + 16);
        }

        v30 = *v13;
        *v13 = *v22;
        *v22 = v30;
        return 1;
      case 4:
        std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,0>(a1, a1 + 24, a1 + 48, a2 - 24, a3);
        break;
      case 5:
        std::__sort5[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,0>(a1, a1 + 24, a1 + 48, a1 + 72, a2 - 24, a3);
        break;
      default:
        goto LABEL_13;
    }

    return 1;
  }

  if (v6 < 2)
  {
    return 1;
  }

  if (v6 == 2)
  {
    v7 = (a2 - 24);
    if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a2 - 24, a1))
    {
      v8 = *a1;
      *a1 = *v7;
      *v7 = v8;
      v9 = *(a1 + 16);
      *(a1 + 16) = *(a2 - 8);
      *(a2 - 8) = v9;
    }

    return 1;
  }

LABEL_13:
  v15 = (a1 + 48);
  v16 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a1 + 24, a1);
  v17 = std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a1 + 48, a1 + 24);
  if (v16)
  {
    if (v17)
    {
      v18 = (a1 + 16);
      v19 = *a1;
      *a1 = *v15;
    }

    else
    {
      v31 = *a1;
      *a1 = *(a1 + 24);
      *(a1 + 24) = v31;
      v18 = (a1 + 40);
      v32 = *(a1 + 16);
      *(a1 + 16) = *(a1 + 40);
      *(a1 + 40) = v32;
      if (!std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a1 + 48, a1 + 24))
      {
        goto LABEL_31;
      }

      v19 = *(a1 + 24);
      *(a1 + 24) = *v15;
    }

    *v15 = v19;
    v26 = (a1 + 64);
    goto LABEL_30;
  }

  if (v17)
  {
    v24 = *(a1 + 24);
    *(a1 + 24) = *v15;
    *v15 = v24;
    v26 = (a1 + 40);
    v25 = *(a1 + 40);
    *(a1 + 40) = *(a1 + 64);
    *(a1 + 64) = v25;
    if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, a1 + 24, a1))
    {
      v27 = *a1;
      *a1 = *(a1 + 24);
      *(a1 + 24) = v27;
      v18 = (a1 + 16);
LABEL_30:
      v33 = *v18;
      *v18 = *v26;
      *v26 = v33;
    }
  }

LABEL_31:
  v34 = a1 + 72;
  if (a1 + 72 == a2)
  {
    return 1;
  }

  v35 = 0;
  v36 = 0;
  while (1)
  {
    if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v34, v15))
    {
      v41 = *v34;
      v42 = *(v34 + 16);
      v37 = v35;
      while (1)
      {
        v38 = a1 + v37;
        *(v38 + 72) = *(a1 + v37 + 48);
        *(v38 + 88) = *(a1 + v37 + 64);
        if (v37 == -48)
        {
          break;
        }

        v37 -= 24;
        if ((std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, &v41, v38 + 24) & 1) == 0)
        {
          v39 = a1 + v37 + 72;
          goto LABEL_39;
        }
      }

      v39 = a1;
LABEL_39:
      *v39 = v41;
      *(v39 + 16) = v42;
      if (++v36 == 8)
      {
        return v34 + 24 == a2;
      }
    }

    v15 = v34;
    v35 += 24;
    v34 += 24;
    if (v34 == a2)
    {
      return 1;
    }
  }
}

uint64_t std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *,std::pair<absl::string_view,int> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 != a2)
  {
    v8 = a2 - a1;
    v9 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
    if (a2 - a1 >= 25)
    {
      v10 = (v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = a1 + 24 * v10;
      do
      {
        std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(a1, a4, v9, v12);
        v12 -= 24;
        --v11;
      }

      while (v11);
    }

    v13 = a2;
    if (a2 != a3)
    {
      v13 = a2;
      do
      {
        if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a4, v13, a1))
        {
          v14 = *v13;
          *v13 = *a1;
          *a1 = v14;
          v15 = *(v13 + 16);
          *(v13 + 16) = *(a1 + 16);
          *(a1 + 16) = v15;
          std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(a1, a4, v9, a1);
        }

        v13 += 24;
      }

      while (v13 != a3);
    }

    if (v8 >= 25)
    {
      v16 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
      v17 = a2 - 24;
      do
      {
        v22 = *a1;
        v18 = *(a1 + 16);
        v19 = std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(a1, a4, v16);
        if (v17 == v19)
        {
          *v19 = v22;
          *(v19 + 16) = v18;
        }

        else
        {
          *v19 = *v17;
          *(v19 + 16) = *(v17 + 16);
          *v17 = v22;
          *(v17 + 16) = v18;
          std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(a1, v19 + 24, a4, 0xAAAAAAAAAAAAAAABLL * ((v19 + 24 - a1) >> 3));
        }

        v17 -= 24;
      }

      while (v16-- > 2);
    }

    return v13;
  }

  return a3;
}

double std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6 = a3 - 2;
  if (a3 >= 2)
  {
    v21 = v4;
    v22 = v5;
    v7 = a4;
    v9 = v6 >> 1;
    if ((v6 >> 1) >= (0xAAAAAAAAAAAAAAABLL * ((a4 - a1) >> 3)))
    {
      v12 = (0x5555555555555556 * ((a4 - a1) >> 3)) | 1;
      v13 = a1 + 24 * v12;
      v14 = 0x5555555555555556 * ((a4 - a1) >> 3) + 2;
      if (v14 < a3 && std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a2, a1 + 24 * v12, v13 + 24))
      {
        v13 += 24;
        v12 = v14;
      }

      if ((std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a2, v13, v7) & 1) == 0)
      {
        v19 = *v7;
        v20 = *(v7 + 16);
        do
        {
          v16 = v13;
          *v7 = *v13;
          *(v7 + 16) = *(v13 + 16);
          if (v9 < v12)
          {
            break;
          }

          v17 = (2 * v12) | 1;
          v13 = a1 + 24 * v17;
          v18 = 2 * v12 + 2;
          if (v18 < a3)
          {
            if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a2, a1 + 24 * v17, v13 + 24))
            {
              v13 += 24;
              v17 = v18;
            }
          }

          v7 = v16;
          v12 = v17;
        }

        while (!std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a2, v13, &v19));
        result = *&v19;
        *v16 = v19;
        *(v16 + 16) = v20;
      }
    }
  }

  return result;
}

uint64_t std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = 0;
  v7 = (a3 - 2) / 2;
  do
  {
    v8 = a1 + 24 * v6;
    v9 = v8 + 24;
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3)
    {
      v12 = v8 + 48;
      if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a2, v8 + 24, v8 + 48))
      {
        v9 = v12;
        v10 = v11;
      }
    }

    *a1 = *v9;
    *(a1 + 16) = *(v9 + 16);
    a1 = v9;
    v6 = v10;
  }

  while (v10 <= v7);
  return v9;
}

double std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<absl::string_view,int> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    v15 = v4;
    v16 = v5;
    v8 = (a4 - 2) >> 1;
    v9 = a1 + 24 * v8;
    v10 = a2 - 24;
    if (std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v9, a2 - 24))
    {
      v13 = *v10;
      v14 = *(v10 + 16);
      do
      {
        v12 = v9;
        *v10 = *v9;
        *(v10 + 16) = *(v9 + 16);
        if (!v8)
        {
          break;
        }

        v8 = (v8 - 1) >> 1;
        v9 = a1 + 24 * v8;
        v10 = v12;
      }

      while ((std::__less<void,void>::operator()[abi:ne200100]<std::pair<absl::string_view,int>,std::pair<absl::string_view,int>>(a3, v9, &v13) & 1) != 0);
      result = *&v13;
      *v12 = v13;
      *(v12 + 16) = v14;
    }
  }

  return result;
}

float std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__construct_one_at_end[abi:ne200100]<std::vector<std::pair<absl::string_view,int>>&,float const&>(uint64_t a1, uint64_t *a2, float *a3)
{
  v5 = *(a1 + 8);
  *v5 = 0;
  *(v5 + 8) = 0;
  *(v5 + 16) = 0;
  std::vector<std::pair<absl::string_view,int>>::__init_with_size[abi:ne200100]<std::pair<absl::string_view,int>*,std::pair<absl::string_view,int>*>(v5, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  result = *a3;
  *(v5 + 24) = *a3;
  *(a1 + 8) = v5 + 32;
  return result;
}

char *std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__emplace_back_slow_path<std::vector<std::pair<absl::string_view,int>>&,float const&>(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  v3 = (*(a1 + 8) - *a1) >> 5;
  v4 = v3 + 1;
  if ((v3 + 1) >> 59)
  {
    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  v8 = *(a1 + 16) - *a1;
  if (v8 >> 4 > v4)
  {
    v4 = v8 >> 4;
  }

  if (v8 >= 0x7FFFFFFFFFFFFFE0)
  {
    v9 = 0x7FFFFFFFFFFFFFFLL;
  }

  else
  {
    v9 = v4;
  }

  v21 = a1;
  if (v9)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<quasar::TextTokenizer::TokenString>>(a1, v9);
  }

  v10 = 32 * v3;
  v17 = 0;
  v18 = v10;
  v19 = v10;
  v20 = 0;
  *v10 = 0;
  *(v10 + 8) = 0;
  *(v10 + 16) = 0;
  std::vector<std::pair<absl::string_view,int>>::__init_with_size[abi:ne200100]<std::pair<absl::string_view,int>*,std::pair<absl::string_view,int>*>(v10, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  *(v10 + 24) = *a3;
  v11 = v19 + 32;
  v12 = *(a1 + 8) - *a1;
  v13 = &v18[-v12];
  memcpy(&v18[-v12], *a1, v12);
  v14 = *a1;
  *a1 = v13;
  *(a1 + 8) = v11;
  v15 = *(a1 + 16);
  *(a1 + 16) = v20;
  v19 = v14;
  v20 = v15;
  v17 = v14;
  v18 = v14;
  std::__split_buffer<fst::IntervalSet<int>>::~__split_buffer(&v17);
  return v11;
}

void sub_1B5AC1DF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<fst::IntervalSet<int>>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

float std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__construct_one_at_end[abi:ne200100]<std::vector<std::pair<absl::string_view,int>>&,double>(uint64_t a1, uint64_t *a2, double *a3)
{
  v5 = *(a1 + 8);
  *v5 = 0;
  *(v5 + 8) = 0;
  *(v5 + 16) = 0;
  std::vector<std::pair<absl::string_view,int>>::__init_with_size[abi:ne200100]<std::pair<absl::string_view,int>*,std::pair<absl::string_view,int>*>(v5, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  result = *a3;
  *(v5 + 24) = result;
  *(a1 + 8) = v5 + 32;
  return result;
}

char *std::vector<std::pair<std::vector<std::pair<absl::string_view,int>>,float>>::__emplace_back_slow_path<std::vector<std::pair<absl::string_view,int>>&,double>(uint64_t a1, uint64_t *a2, double *a3)
{
  v3 = (*(a1 + 8) - *a1) >> 5;
  v4 = v3 + 1;
  if ((v3 + 1) >> 59)
  {
    std::vector<int>::__throw_length_error[abi:ne200100]();
  }

  v8 = *(a1 + 16) - *a1;
  if (v8 >> 4 > v4)
  {
    v4 = v8 >> 4;
  }

  if (v8 >= 0x7FFFFFFFFFFFFFE0)
  {
    v9 = 0x7FFFFFFFFFFFFFFLL;
  }

  else
  {
    v9 = v4;
  }

  v22 = a1;
  if (v9)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<quasar::TextTokenizer::TokenString>>(a1, v9);
  }

  v10 = 32 * v3;
  v18 = 0;
  v19 = v10;
  v20 = v10;
  v21 = 0;
  *v10 = 0;
  *(v10 + 8) = 0;
  *(v10 + 16) = 0;
  std::vector<std::pair<absl::string_view,int>>::__init_with_size[abi:ne200100]<std::pair<absl::string_view,int>*,std::pair<absl::string_view,int>*>(v10, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  v11 = *a3;
  *(v10 + 24) = v11;
  v12 = v20 + 32;
  v13 = *(a1 + 8) - *a1;
  v14 = &v19[-v13];
  memcpy(&v19[-v13], *a1, v13);
  v15 = *a1;
  *a1 = v14;
  *(a1 + 8) = v12;
  v16 = *(a1 + 16);
  *(a1 + 16) = v21;
  v20 = v15;
  v21 = v16;
  v18 = v15;
  v19 = v15;
  std::__split_buffer<fst::IntervalSet<int>>::~__split_buffer(&v18);
  return v12;
}

void sub_1B5AC1F98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<fst::IntervalSet<int>>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<sentencepiece::unigram::Lattice::Node *>>::vector[abi:ne200100](void *result, unint64_t a2)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne200100](result, a2);
  }

  return result;
}

uint64_t std::__find[abi:ne200100]<std::vector<sentencepiece::unigram::Lattice::Node *> *,std::vector<sentencepiece::unigram::Lattice::Node *> *,std::vector<sentencepiece::unigram::Lattice::Node *>,std::__identity>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = a1;
  if (a1 != a2)
  {
    v5 = *a3;
    v6 = *(a3 + 8) - *a3;
    do
    {
      if (*(v3 + 8) - *v3 == v6 && !memcmp(*v3, v5, v6))
      {
        break;
      }

      v3 += 24;
    }

    while (v3 != a2);
  }

  return v3;
}

uint64_t sentencepiece::GetRandomGeneratorSeed(sentencepiece *this)
{
  {
    std::random_device::random_device[abi:ne200100](&v3);
    v1 = arc4random();
    std::random_device::~random_device(&v3);
  }

  return v1;
}

uint64_t sentencepiece::string_util::DecodeUTF8(sentencepiece::string_util *this, const char *a2, char *a3, unint64_t *a4)
{
  v4 = *this;
  if ((v4 & 0x80000000) == 0)
  {
    *a3 = 1;
    return *this;
  }

  v6 = a2 - this;
  if ((a2 - this) >= 2)
  {
    if ((v4 & 0xE0) == 0xC0)
    {
      v7 = *(this + 1);
      if (v7 <= -65)
      {
        v8 = (v4 & 0x1F) << 6;
        if (v8 >= 0x80)
        {
          result = v8 | v7 & 0x3F;
          v9 = 2;
LABEL_8:
          *a3 = v9;
          return result;
        }
      }
    }

    else if (v6 != 2)
    {
      if ((v4 & 0xF0) == 0xE0)
      {
        v10 = *(this + 1);
        if (v10 <= -65)
        {
          v11 = *(this + 2);
          if (v11 <= -65)
          {
            v12 = (v4 & 0xF) << 12;
            v13 = v12 & 0xFFFFF03F | ((v10 & 0x3F) << 6);
            if (v13 >= 0x800 && ((v12 - 57344) < 0x102000 || v13 >> 11 <= 0x1A))
            {
              result = v12 & 0xFFFFF000 | ((v10 & 0x3F) << 6) | v11 & 0x3F;
              v9 = 3;
              goto LABEL_8;
            }
          }
        }
      }

      else if (v6 >= 4 && (v4 & 0xF8) == 0xF0)
      {
        v14 = *(this + 1);
        if (v14 <= -65)
        {
          v15 = *(this + 2);
          if (v15 <= -65)
          {
            v16 = *(this + 3);
            if (v16 <= -65)
            {
              v17 = ((v4 & 7) << 18) | ((v14 & 0x3F) << 12);
              if (v17 >= 0x10000)
              {
                result = v16 & 0x3F | ((v15 & 0x3F) << 6) | v17;
                if (v17 - 57344 < 0x102000 || result >> 11 <= 0x1A)
                {
                  v9 = 4;
                  goto LABEL_8;
                }
              }
            }
          }
        }
      }
    }
  }

  *a3 = 1;
  return 65533;
}

uint64_t sentencepiece::random::GetRandomGenerator(sentencepiece::random *this)
{
  if ((*v1 & 1) == 0)
  {
    sentencepiece::random::GetRandomGenerator(v1);
  }

  return sentencepiece::random::GetRandomGenerator(void)::mt(&sentencepiece::random::GetRandomGenerator(void)::mt);
}

uint64_t sentencepiece::util::StrError(sentencepiece::util *this)
{
  v12 = *MEMORY[0x1E69E9840];
  strerror_r(this, __strerrbuf, 0x3FFuLL);
  std::ostringstream::basic_ostringstream[abi:ne200100](&v6);
  v2 = strlen(__strerrbuf);
  v3 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v6, __strerrbuf, v2);
  v4 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v3, " Error #", 8);
  MEMORY[0x1B8C84C00](v4, this);
  std::stringbuf::str();
  v6 = *MEMORY[0x1E69E54E8];
  *(&v6 + *(v6 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v7 = MEMORY[0x1E69E5548] + 16;
  if (v9 < 0)
  {
    operator delete(v8[7].__locale_);
  }

  v7 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v8);
  std::ostream::~ostream();
  return MEMORY[0x1B8C85200](&v10);
}

_BYTE *sentencepiece::random::GetRandomGenerator(sentencepiece *a1)
{
  sentencepiece::GetRandomGeneratorSeed(a1);
  v1 = sentencepiece::random::GetRandomGenerator(void)::mt(&sentencepiece::random::GetRandomGenerator(void)::mt);
  *v1 = v4;
  do
  {
    v5 = v3(v2);
    *(v5 + 4 * v7) = v6;
  }

  while (v7 != 623);
  *(v3(v2) + 2496) = 0;
  *result = 1;
  return result;
}

sentencepiece::word::Model *sentencepiece::word::Model::Model(sentencepiece::word::Model *this, const sentencepiece::ModelProto *a2)
{
  v4 = sentencepiece::ModelInterface::ModelInterface(this);
  *v4 = &unk_1F2D44080;
  *(v4 + 1) = a2;
  sentencepiece::ModelInterface::InitializePieces(v4);
  return this;
}

void sentencepiece::word::Model::~Model(sentencepiece::word::Model *this)
{
  sentencepiece::ModelInterface::~ModelInterface(this);

  JUMPOUT(0x1B8C85350);
}

void sentencepiece::word::Model::Encode(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  (*(*a1 + 16))(&v22);
  if (v22)
  {
    sentencepiece::util::Status::~Status(&v22);
LABEL_3:
    *a4 = 0;
    *(a4 + 8) = 0;
    *(a4 + 16) = 0;
    return;
  }

  sentencepiece::util::Status::~Status(&v22);
  if (!a3)
  {
    goto LABEL_3;
  }

  *a4 = 0;
  *(a4 + 8) = 0;
  *(a4 + 16) = 0;
  sentencepiece::SplitIntoWords(a2, a3, 0, 0, &v22);
  v8 = v22;
  v9 = v23;
  if (v22 != v23)
  {
    do
    {
      v10 = (*(*a1 + 128))(a1, *v8, v8[1]);
      v12 = *(a4 + 8);
      v11 = *(a4 + 16);
      if (v12 >= v11)
      {
        v14 = 0xAAAAAAAAAAAAAAABLL * ((v12 - *a4) >> 3);
        v15 = v14 + 1;
        if (v14 + 1 > 0xAAAAAAAAAAAAAAALL)
        {
          std::vector<int>::__throw_length_error[abi:ne200100]();
        }

        v16 = 0xAAAAAAAAAAAAAAABLL * ((v11 - *a4) >> 3);
        if (2 * v16 > v15)
        {
          v15 = 2 * v16;
        }

        if (v16 >= 0x555555555555555)
        {
          v17 = 0xAAAAAAAAAAAAAAALL;
        }

        else
        {
          v17 = v15;
        }

        if (v17)
        {
          std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<absl::string_view,int>>>(a4, v17);
        }

        v18 = 24 * v14;
        *v18 = *v8;
        *(v18 + 16) = v10;
        v13 = 24 * v14 + 24;
        v19 = *(a4 + 8) - *a4;
        v20 = v18 - v19;
        memcpy((v18 - v19), *a4, v19);
        v21 = *a4;
        *a4 = v20;
        *(a4 + 8) = v13;
        *(a4 + 16) = 0;
        if (v21)
        {
          operator delete(v21);
        }
      }

      else
      {
        *v12 = *v8;
        *(v12 + 16) = v10;
        v13 = v12 + 24;
      }

      *(a4 + 8) = v13;
      v8 += 2;
    }

    while (v8 != v9);
    v8 = v22;
  }

  if (v8)
  {
    v23 = v8;
    operator delete(v8);
  }
}

void sub_1B5AC27A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    operator delete(__p);
  }

  v13 = *v11;
  if (*v11)
  {
    *(v11 + 8) = v13;
    operator delete(v13);
  }

  _Unwind_Resume(exception_object);
}

void *absl::operator<<(void *a1, uint64_t a2, unint64_t a3)
{
  MEMORY[0x1B8C84B80](v9, a1);
  if (v9[0] != 1)
  {
    goto LABEL_10;
  }

  v5 = a1 + *(*a1 - 24);
  v6 = *(v5 + 3);
  v7 = v6 - a3;
  if (v6 > a3)
  {
    if ((*(v5 + 2) & 0xB0) == 0x20 || !v7)
    {
      goto LABEL_7;
    }
  }

  v7 = 0;
LABEL_7:
  std::ostream::write();
  if (v7)
  {
  }

  *(a1 + *(*a1 - 24) + 24) = 0;
LABEL_10:
  MEMORY[0x1B8C84B90](v9);
  return a1;
}

void absl::anonymous namespace::WritePadding(void *a1, unint64_t a2)
{
  v8 = *MEMORY[0x1E69E9840];
  v3 = (a1 + *(*a1 - 24));
  fmtflags = v3[1].__fmtflags_;
  if (fmtflags == -1)
  {
    std::ios_base::getloc(v3);
    v5 = std::locale::use_facet(v7, MEMORY[0x1E69E5318]);
    fmtflags = (v5->__vftable[2].~facet_0)(v5, 32);
    std::locale::~locale(v7);
    v3[1].__fmtflags_ = fmtflags;
  }

  v7[0] = vdupq_n_s8(fmtflags);
  for (v7[1] = v7[0]; a2; a2 -= v6)
  {
    if (a2 >= 0x20)
    {
      v6 = 32;
    }

    else
    {
      v6 = a2;
    }

    std::ostream::write();
  }
}

uint64_t absl::string_view::find(uint64_t *a1, char *a2, size_t a3, unint64_t a4)
{
  v5 = a1[1];
  if (v5)
  {
    if (v5 >= a4)
    {
      v6 = *a1;
      v7 = (*a1 + a4);
      if (a3)
      {
        if (v5 - a4 >= a3)
        {
          v9 = v6 + v5 - a3 + 1;
          v10 = *a2;
          v11 = memchr((*a1 + a4), v10, v9 - v7);
          if (v11)
          {
            v7 = v11;
            while (memcmp(v7, a2, a3))
            {
              v7 = memchr(v7 + 1, v10, v9 - (v7 + 1));
              result = -1;
              if (!v7)
              {
                return result;
              }
            }

            return &v7[-v6];
          }
        }
      }

      else if (v6)
      {
        return &v7[-v6];
      }
    }
  }

  else if (!(a4 | a3))
  {
    return 0;
  }

  return -1;
}

uint64_t absl::string_view::find_first_of(uint64_t *a1, unsigned __int8 *a2, uint64_t a3, unint64_t a4)
{
  v11 = *MEMORY[0x1E69E9840];
  v4 = a1[1];
  if (v4)
  {
    v5 = a3 == 0;
  }

  else
  {
    v5 = 1;
  }

  if (v5)
  {
    return -1;
  }

  if (a3 == 1)
  {
    if (v4 > a4)
    {
      v7 = *a1;
      v8 = memchr((*a1 + a4), *a2, v4 - a4);
      if (v8)
      {
        return v8 - v7;
      }

      else
      {
        return -1;
      }
    }

    return -1;
  }

  memset(v10, 0, sizeof(v10));
  do
  {
    v9 = *a2++;
    *(v10 + v9) = 1;
    --a3;
  }

  while (a3);
  if (v4 <= a4)
  {
    return -1;
  }

  while ((*(v10 + *(*a1 + a4)) & 1) == 0)
  {
    if (v4 == ++a4)
    {
      return -1;
    }
  }

  return a4;
}

google::protobuf::internal::EpsCopyInputStream *google::protobuf::internal::EpsCopyInputStream::Next(google::protobuf::internal::EpsCopyInputStream *this)
{
  v2 = *(this + 2);
  if (v2)
  {
    v3 = (this + 40);
    if (v2 == (this + 40))
    {
      *v3 = **(this + 1);
      if (*(this + 21) < 1)
      {
LABEL_15:
        if (*(this + 9) == 2)
        {
          *(this + 9) = *(this + 1) - v2;
        }

        v4 = this + 56;
        *(this + 1) = this + 56;
        *(this + 2) = 0;
        *(this + 6) = 0;
      }

      else
      {
        __src = 0;
        while (1)
        {
          if (!(*(**(this + 4) + 16))(*(this + 4), &__src, this + 24))
          {
            *(this + 21) = 0;
            goto LABEL_15;
          }

          v5 = *(this + 6);
          *(this + 21) -= v5;
          if (v5 >= 17)
          {
            break;
          }

          if (v5 >= 1)
          {
            memcpy(this + 56, __src, v5);
            v6 = (this + 72);
            v7 = *(this + 9);
            v4 = v3 + v5;
            *(this + 1) = v3 + v5;
            *(this + 2) = v3;
            if (v7 < 2)
            {
              goto LABEL_20;
            }

            goto LABEL_19;
          }
        }

        v6 = (this + 72);
        v8 = *(this + 9);
        v4 = this + 56;
        v9 = __src;
        *(this + 56) = *__src;
        *(this + 1) = this + 56;
        *(this + 2) = v9;
        if (v8 <= 1)
        {
          goto LABEL_20;
        }

LABEL_19:
        *v6 = 1;
      }
    }

    else
    {
      v4 = v2 + *(this + 6) - 16;
      *(this + 1) = v4;
      *(this + 2) = v3;
      if (*(this + 9) == 1)
      {
        *(this + 9) = 2;
      }

      v3 = v2;
    }

LABEL_20:
    v10 = *(this + 7) + v3 - v4;
    *(this + 7) = v10;
    *this = &v4[v10 & (v10 >> 31)];
  }

  else
  {
    v3 = 0;
    *this = *(this + 1);
    *(this + 20) = 1;
  }

  return v3;
}

google::protobuf::internal::EpsCopyInputStream *google::protobuf::internal::EpsCopyInputStream::NextBuffer(google::protobuf::internal::EpsCopyInputStream *this, int a2, int a3)
{
  v3 = *(this + 2);
  if (!v3)
  {
    return 0;
  }

  v5 = (this + 40);
  if (v3 == (this + 40))
  {
    *v5 = **(this + 1);
    if (*(this + 21) < 1)
    {
LABEL_46:
      if (*(this + 9) == 2)
      {
        *(this + 9) = *(this + 1) - v3;
      }

      *(this + 1) = this + 56;
      *(this + 2) = 0;
      *(this + 6) = 0;
    }

    else
    {
      v6 = a3;
      if ((a3 & 0x80000000) == 0 && a2 <= 15)
      {
        v7 = this + 56;
        v8 = v5 + a2;
        v9 = v8;
        do
        {
          v10 = *v9++;
          v11 = v10;
          if (v10 < 0)
          {
            v11 = v11 + (*v9 << 7) - 128;
            if (*v9 < 0)
            {
              v9 = v8 + 3;
              v16 = -21;
              while (1)
              {
                v11 += (*(v9 - 1) - 1) << (v16 + 35);
                if ((*(v9 - 1) & 0x80000000) == 0)
                {
                  break;
                }

                ++v9;
                v16 += 7;
                if (!v16)
                {
                  goto LABEL_39;
                }
              }
            }

            else
            {
              v9 = v8 + 2;
            }
          }

          if (v9 > v7)
          {
            break;
          }

          if (!v11)
          {
            goto LABEL_46;
          }

          v12 = v11 & 7;
          if (v12 > 2)
          {
            switch(v12)
            {
              case 3:
                ++v6;
                break;
              case 4:
                v15 = __OFSUB__(v6--, 1);
                if (v6 < 0 != v15)
                {
                  goto LABEL_46;
                }

                break;
              case 5:
                v9 += 4;
                break;
              default:
                goto LABEL_39;
            }
          }

          else if (v12)
          {
            if (v12 == 1)
            {
              v9 += 8;
            }

            else
            {
              v13 = *v9;
              if (*v9 < 0)
              {
                SizeFallback = google::protobuf::internal::ReadSizeFallback(v9, v13);
                if (!SizeFallback)
                {
                  break;
                }
              }

              else
              {
                SizeFallback = v9 + 1;
              }

              if (v7 - SizeFallback < v13)
              {
                break;
              }

              v9 = &SizeFallback[v13];
            }
          }

          else
          {
            __src = 0;
            v9 = google::protobuf::internal::VarintParse<unsigned long long>(v9, &__src);
            if (!v9)
            {
              break;
            }
          }

          v8 = v9;
        }

        while (v9 < v7);
      }

LABEL_39:
      __src = 0;
      while (1)
      {
        if (!(*(**(this + 4) + 16))(*(this + 4), &__src, this + 24))
        {
          *(this + 21) = 0;
          goto LABEL_46;
        }

        v17 = *(this + 6);
        *(this + 21) -= v17;
        if (v17 >= 17)
        {
          break;
        }

        if (v17 >= 1)
        {
          memcpy(this + 56, __src, v17);
          v19 = *(this + 9);
          v18 = (this + 72);
          *(v18 - 8) = v5 + v17;
          *(v18 - 7) = v5;
          if (v19 < 2)
          {
            return v5;
          }

          goto LABEL_50;
        }
      }

      v20 = *(this + 9);
      v18 = (this + 72);
      v21 = __src;
      *(v18 - 1) = *__src;
      *(v18 - 8) = v18 - 2;
      *(v18 - 7) = v21;
      if (v20 <= 1)
      {
        return v5;
      }

LABEL_50:
      *v18 = 1;
    }
  }

  else
  {
    *(this + 1) = v3 + *(this + 6) - 16;
    *(this + 2) = v5;
    if (*(this + 9) == 1)
    {
      *(this + 9) = 2;
    }

    return v3;
  }

  return v5;
}

google::protobuf::internal::EpsCopyInputStream *google::protobuf::internal::EpsCopyInputStream::SkipFallback(google::protobuf::internal::EpsCopyInputStream *this, const char *a2, int a3)
{
  v5 = *(this + 2) - a2 + 16;
  while (*(this + 2) && *(this + 7) >= 17)
  {
    result = google::protobuf::internal::EpsCopyInputStream::Next(this);
    if (!result)
    {
      return result;
    }

    a3 -= v5;
    v5 = *(this + 2) - result;
    if (a3 <= v5)
    {
      return (result + a3 + 16);
    }
  }

  return 0;
}

void google::protobuf::internal::WriteVarint(int a1, unint64_t a2, std::string *this)
{
  v5 = (8 * a1);
  if (v5 < 0x80)
  {
    LOBYTE(v6) = 8 * a1;
  }

  else
  {
    do
    {
      std::string::push_back(this, v5 | 0x80);
      v6 = v5 >> 7;
      v7 = v5 >> 14;
      v5 >>= 7;
    }

    while (v7);
  }

  std::string::push_back(this, v6);
  if (a2 < 0x80)
  {
    LOBYTE(v8) = a2;
  }

  else
  {
    do
    {
      std::string::push_back(this, a2 | 0x80);
      v8 = a2 >> 7;
      v9 = a2 >> 14;
      a2 >>= 7;
    }

    while (v9);
  }

  std::string::push_back(this, v8);
}

char *google::protobuf::internal::VarintParseSlow32(google::protobuf::internal *this, const char *a2)
{
  result = this + 3;
  v4 = -21;
  while (1)
  {
    LODWORD(a2) = ((*(result - 1) - 1) << (v4 + 35)) + a2;
    if ((*(result - 1) & 0x80000000) == 0)
    {
      break;
    }

    ++result;
    v4 += 7;
    if (!v4)
    {
      v5 = this + 6;
      v6 = 5;
      result = 0;
      while (*(v5 - 1) < 0)
      {
        ++v5;
        if (!--v6)
        {
          return result;
        }
      }

      return v5;
    }
  }

  return result;
}

uint64_t google::protobuf::internal::VarintParseSlow64(google::protobuf::internal *this, unint64_t a2)
{
  a2 = a2;
  result = this + 3;
  v4 = this + 2;
  v5 = 14;
  while (1)
  {
    v6 = *v4++;
    a2 += (v6 - 1) << v5;
    if ((v6 & 0x80000000) == 0)
    {
      break;
    }

    ++result;
    v5 += 7;
    if (v5 == 70)
    {
      return 0;
    }
  }

  return result;
}

uint64_t google::protobuf::internal::ReadTagFallback(google::protobuf::internal *this, const char *a2)
{
  result = this + 3;
  v4 = this + 2;
  v5 = -21;
  while (1)
  {
    v6 = *v4++;
    LODWORD(a2) = ((v6 - 1) << (v5 + 35)) + a2;
    if ((v6 & 0x80000000) == 0)
    {
      break;
    }

    ++result;
    v5 += 7;
    if (!v5)
    {
      return 0;
    }
  }

  return result;
}

char *google::protobuf::internal::InlineGreedyStringParser(uint64_t a1, google::protobuf::internal *this, uint64_t a3)
{
  v5 = *this;
  if (*this < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(this, *this);
    if (!result)
    {
      return result;
    }

    v6 = result;
    v5 = v8;
  }

  else
  {
    v6 = this + 1;
  }

  return google::protobuf::internal::EpsCopyInputStream::ReadString(a3, v6, v5, a1);
}

google::protobuf::internal::EpsCopyInputStream *google::protobuf::internal::EpsCopyInputStream::ReadString(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (*(a1 + 8) - a2 + 16 < a3)
  {

    return google::protobuf::internal::EpsCopyInputStream::ReadStringFallback();
  }

  else
  {
    v5 = a3;
    MEMORY[0x1B8C84830](a4, a2, a3);
    return (a2 + v5);
  }
}

char *google::protobuf::internal::FixedParser<unsigned int>(unsigned int *a1, google::protobuf::internal *this, google::protobuf::internal::EpsCopyInputStream *a3)
{
  v5 = *this;
  if (*this < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(this, *this);
    if (!result)
    {
      return result;
    }

    v6 = result;
    v5 = v8;
  }

  else
  {
    v6 = this + 1;
  }

  return google::protobuf::internal::EpsCopyInputStream::ReadPackedFixed<unsigned int>(a3, v6, v5, a1);
}

char *google::protobuf::internal::FixedParser<unsigned long long>(unsigned int *a1, google::protobuf::internal *this, google::protobuf::internal::EpsCopyInputStream *a3)
{
  v5 = *this;
  if (*this < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(this, *this);
    if (!result)
    {
      return result;
    }

    v6 = result;
    v5 = v8;
  }

  else
  {
    v6 = this + 1;
  }

  return google::protobuf::internal::EpsCopyInputStream::ReadPackedFixed<unsigned long long>(a3, v6, v5, a1);
}

char *google::protobuf::internal::WireFormatParser<google::protobuf::internal::UnknownFieldLiteParserHelper>(int a1, char *a2, google::protobuf::internal::EpsCopyInputStream *this)
{
  v10 = a2;
  while (1)
  {
    if (google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v10, *(this + 23)))
    {
      return v10;
    }

    v5 = v10 + 1;
    v6 = *v10;
    if (*v10 < 0)
    {
      v6 = v6 + (*v5 << 7) - 128;
      if (*v5 < 0)
      {
        v5 = v10 + 3;
        v8 = -21;
        while (1)
        {
          v6 += (*(v5 - 1) - 1) << (v8 + 35);
          if ((*(v5 - 1) & 0x80000000) == 0)
          {
            break;
          }

          ++v5;
          v8 += 7;
          if (!v8)
          {
            return 0;
          }
        }
      }

      else
      {
        v5 = v10 + 2;
      }
    }

    v10 = v5;
    if (!v6 || (v6 & 7) == 4)
    {
      break;
    }

    v10 = google::protobuf::internal::FieldParser<google::protobuf::internal::UnknownFieldLiteParserHelper>(v6, a1, v5);
    if (!v10)
    {
      return 0;
    }
  }

  *(this + 20) = v6 - 1;
  return v5;
}

google::protobuf::internal *google::protobuf::internal::FieldParser<google::protobuf::internal::UnknownFieldLiteParserHelper>(unint64_t a1, std::string *a2, google::protobuf::internal *this, int32x2_t *a4)
{
  v4 = a1 >> 3;
  if (!(a1 >> 3))
  {
    return 0;
  }

  v5 = this;
  v7 = a1;
  result = 0;
  v9 = v7 & 7;
  if (v9 > 2)
  {
    if (v9 != 3)
    {
      if (v9 == 4)
      {
        google::protobuf::internal::LogMessage::LogMessage(v12, 3, "third_party/protobuf-lite/google/protobuf/parse_context.h", 758);
        v10 = google::protobuf::internal::LogMessage::operator<<(v12, "Can't happen");
        google::protobuf::internal::LogFinisher::operator=(&v11, &v10->__r_.__value_.__l.__data_);
        google::protobuf::internal::LogMessage::~LogMessage(&v12[0].__r_.__value_.__l.__data_);
      }

      else
      {
        if (v9 != 5)
        {
          return result;
        }

        v5 = (this + 4);
        google::protobuf::internal::UnknownFieldLiteParserHelper::AddFixed32(a2, v4, *this);
      }

      return v5;
    }

    result = google::protobuf::internal::UnknownFieldLiteParserHelper::ParseGroup(a2, v4, this, a4);
    if (!result)
    {
      return result;
    }

    return result;
  }

  if (!v9)
  {
    v12[0].__r_.__value_.__r.__words[0] = 0;
    result = google::protobuf::internal::VarintParse<unsigned long long>(this, v12);
    if (!result)
    {
      return result;
    }

    v5 = result;
    google::protobuf::internal::UnknownFieldLiteParserHelper::AddVarint(a2, v4, v12[0].__r_.__value_.__r.__words[0]);
    return v5;
  }

  if (v9 == 1)
  {
    v5 = (this + 8);
    google::protobuf::internal::UnknownFieldLiteParserHelper::AddFixed64(a2, v4, *this);
    return v5;
  }

  result = google::protobuf::internal::UnknownFieldLiteParserHelper::ParseLengthDelimited(a2, v4, this, a4);
  if (result)
  {
    return result;
  }

  return result;
}

void sub_1B5AC36BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  google::protobuf::internal::LogMessage::~LogMessage(va);
  _Unwind_Resume(a1);
}

char *google::protobuf::internal::VarintParse<unsigned long long>(char *a1, unint64_t *a2)
{
  v2 = *a1;
  if ((v2 & 0x8000000000000000) != 0)
  {
    v4 = v2 & 0x7F | (a1[1] << 7);
    if (a1[1] < 0)
    {
      result = a1 + 3;
      v5 = 14;
      while (1)
      {
        v4 += (*(result - 1) - 1) << v5;
        if ((*(result - 1) & 0x80000000) == 0)
        {
          break;
        }

        ++result;
        v5 += 7;
        if (v5 == 70)
        {
          result = 0;
          v4 = 0;
          break;
        }
      }

      *a2 = v4;
    }

    else
    {
      *a2 = v4;
      return a1 + 2;
    }
  }

  else
  {
    *a2 = v2;
    return a1 + 1;
  }

  return result;
}

char *google::protobuf::internal::EpsCopyInputStream::ReadPackedVarint<char const* google::protobuf::internal::VarintParser<int,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(uint64_t a1, google::protobuf::internal *this, unsigned int *a3)
{
  v17 = *MEMORY[0x1E69E9840];
  v5 = *this;
  if ((*this & 0x80000000) == 0)
  {
    result = this + 1;
    goto LABEL_3;
  }

  result = google::protobuf::internal::ReadSizeFallback(this, *this);
  if (result)
  {
    v5 = v13;
    while (1)
    {
LABEL_3:
      v7 = *(a1 + 8);
      v8 = v7 - result;
      if (v5 <= v7 - result)
      {
        v12 = &result[v5];
        result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<int,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(result, v12, a3);
        if (v12 != result)
        {
          return 0;
        }

        return result;
      }

      result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<int,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(result, v7, a3);
      if (!result)
      {
        return result;
      }

      v9 = *(a1 + 8);
      v10 = result - v9;
      v11 = v5 - v8;
      if (v5 - v8 <= 16)
      {
        break;
      }

      if (*(a1 + 28) < 17)
      {
        return 0;
      }

      result = google::protobuf::internal::EpsCopyInputStream::Next(a1);
      if (!result)
      {
        return result;
      }

      v5 = v5 - v8 - v10;
      result += v10;
    }

    v16 = 0;
    v15 = 0;
    v14 = *v9;
    if (google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<int,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(&v14 + v10, &v14 + v11, a3) != &v14 + v11)
    {
      return 0;
    }

    return (*(a1 + 8) + v11);
  }

  return result;
}

char *google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<int,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(char *a1, unint64_t a2, unsigned int *a3)
{
  for (i = a1; i < a2; *a3 = v8)
  {
    v10 = 0;
    i = google::protobuf::internal::VarintParse<unsigned long long>(i, &v10);
    if (!i)
    {
      break;
    }

    v6 = v10;
    v7 = *a3;
    if (v7 == a3[1])
    {
      v8 = v7 + 1;
      google::protobuf::RepeatedField<int>::Reserve(a3, v7 + 1);
      *(*(a3 + 1) + 4 * v7) = v6;
    }

    else
    {
      *(*(a3 + 1) + 4 * v7) = v10;
      v8 = v7 + 1;
    }
  }

  return i;
}

char *google::protobuf::internal::EpsCopyInputStream::ReadPackedVarint<char const* google::protobuf::internal::VarintParser<long long,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(uint64_t a1, google::protobuf::internal *this, unsigned int *a3)
{
  v17 = *MEMORY[0x1E69E9840];
  v5 = *this;
  if ((*this & 0x80000000) == 0)
  {
    result = this + 1;
    goto LABEL_3;
  }

  result = google::protobuf::internal::ReadSizeFallback(this, *this);
  if (result)
  {
    v5 = v13;
    while (1)
    {
LABEL_3:
      v7 = *(a1 + 8);
      v8 = v7 - result;
      if (v5 <= v7 - result)
      {
        v12 = &result[v5];
        result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<long long,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(result, v12, a3);
        if (v12 != result)
        {
          return 0;
        }

        return result;
      }

      result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<long long,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(result, v7, a3);
      if (!result)
      {
        return result;
      }

      v9 = *(a1 + 8);
      v10 = result - v9;
      v11 = v5 - v8;
      if (v5 - v8 <= 16)
      {
        break;
      }

      if (*(a1 + 28) < 17)
      {
        return 0;
      }

      result = google::protobuf::internal::EpsCopyInputStream::Next(a1);
      if (!result)
      {
        return result;
      }

      v5 = v5 - v8 - v10;
      result += v10;
    }

    v16 = 0;
    v15 = 0;
    v14 = *v9;
    if (google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<long long,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(&v14 + v10, &v14 + v11, a3) != &v14 + v11)
    {
      return 0;
    }

    return (*(a1 + 8) + v11);
  }

  return result;
}

char *google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<long long,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(char *a1, unint64_t a2, unsigned int *a3)
{
  for (i = a1; i < a2; *a3 = v8)
  {
    v10 = 0;
    i = google::protobuf::internal::VarintParse<unsigned long long>(i, &v10);
    if (!i)
    {
      break;
    }

    v6 = v10;
    v7 = *a3;
    if (v7 == a3[1])
    {
      v8 = v7 + 1;
      google::protobuf::RepeatedField<long long>::Reserve(a3, v7 + 1);
      *(*(a3 + 1) + 8 * v7) = v6;
    }

    else
    {
      *(*(a3 + 1) + 8 * v7) = v10;
      v8 = v7 + 1;
    }
  }

  return i;
}

char *google::protobuf::internal::EpsCopyInputStream::ReadPackedVarint<char const* google::protobuf::internal::VarintParser<int,true>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(uint64_t a1, google::protobuf::internal *this, unsigned int *a3)
{
  v17 = *MEMORY[0x1E69E9840];
  v5 = *this;
  if ((*this & 0x80000000) == 0)
  {
    result = this + 1;
    goto LABEL_3;
  }

  result = google::protobuf::internal::ReadSizeFallback(this, *this);
  if (result)
  {
    v5 = v13;
    while (1)
    {
LABEL_3:
      v7 = *(a1 + 8);
      v8 = v7 - result;
      if (v5 <= v7 - result)
      {
        v12 = &result[v5];
        result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<int,true>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(result, v12, a3);
        if (v12 != result)
        {
          return 0;
        }

        return result;
      }

      result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<int,true>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(result, v7, a3);
      if (!result)
      {
        return result;
      }

      v9 = *(a1 + 8);
      v10 = result - v9;
      v11 = v5 - v8;
      if (v5 - v8 <= 16)
      {
        break;
      }

      if (*(a1 + 28) < 17)
      {
        return 0;
      }

      result = google::protobuf::internal::EpsCopyInputStream::Next(a1);
      if (!result)
      {
        return result;
      }

      v5 = v5 - v8 - v10;
      result += v10;
    }

    v16 = 0;
    v15 = 0;
    v14 = *v9;
    if (google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<int,true>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(&v14 + v10, &v14 + v11, a3) != &v14 + v11)
    {
      return 0;
    }

    return (*(a1 + 8) + v11);
  }

  return result;
}

char *google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<int,true>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(char *a1, unint64_t a2, unsigned int *a3)
{
  for (i = a1; i < a2; *a3 = v8)
  {
    v10 = 0;
    i = google::protobuf::internal::VarintParse<unsigned long long>(i, &v10);
    if (!i)
    {
      break;
    }

    v6 = -(v10 & 1) ^ (v10 >> 1);
    v7 = *a3;
    if (v7 == a3[1])
    {
      v8 = v7 + 1;
      google::protobuf::RepeatedField<int>::Reserve(a3, v7 + 1);
      *(*(a3 + 1) + 4 * v7) = v6;
    }

    else
    {
      *(*(a3 + 1) + 4 * v7) = v6;
      v8 = v7 + 1;
    }
  }

  return i;
}

char *google::protobuf::internal::EpsCopyInputStream::ReadPackedVarint<char const* google::protobuf::internal::VarintParser<long long,true>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(uint64_t a1, google::protobuf::internal *this, unsigned int *a3)
{
  v17 = *MEMORY[0x1E69E9840];
  v5 = *this;
  if ((*this & 0x80000000) == 0)
  {
    result = this + 1;
    goto LABEL_3;
  }

  result = google::protobuf::internal::ReadSizeFallback(this, *this);
  if (result)
  {
    v5 = v13;
    while (1)
    {
LABEL_3:
      v7 = *(a1 + 8);
      v8 = v7 - result;
      if (v5 <= v7 - result)
      {
        v12 = &result[v5];
        result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<long long,true>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(result, v12, a3);
        if (v12 != result)
        {
          return 0;
        }

        return result;
      }

      result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<long long,true>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(result, v7, a3);
      if (!result)
      {
        return result;
      }

      v9 = *(a1 + 8);
      v10 = result - v9;
      v11 = v5 - v8;
      if (v5 - v8 <= 16)
      {
        break;
      }

      if (*(a1 + 28) < 17)
      {
        return 0;
      }

      result = google::protobuf::internal::EpsCopyInputStream::Next(a1);
      if (!result)
      {
        return result;
      }

      v5 = v5 - v8 - v10;
      result += v10;
    }

    v16 = 0;
    v15 = 0;
    v14 = *v9;
    if (google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<long long,true>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(&v14 + v10, &v14 + v11, a3) != &v14 + v11)
    {
      return 0;
    }

    return (*(a1 + 8) + v11);
  }

  return result;
}

char *google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<long long,true>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(char *a1, unint64_t a2, unsigned int *a3)
{
  for (i = a1; i < a2; *a3 = v8)
  {
    v10 = 0;
    i = google::protobuf::internal::VarintParse<unsigned long long>(i, &v10);
    if (!i)
    {
      break;
    }

    v6 = -(v10 & 1) ^ (v10 >> 1);
    v7 = *a3;
    if (v7 == a3[1])
    {
      v8 = v7 + 1;
      google::protobuf::RepeatedField<long long>::Reserve(a3, v7 + 1);
      *(*(a3 + 1) + 8 * v7) = v6;
    }

    else
    {
      *(*(a3 + 1) + 8 * v7) = v6;
      v8 = v7 + 1;
    }
  }

  return i;
}

char *google::protobuf::internal::EpsCopyInputStream::ReadPackedVarint<char const* google::protobuf::internal::VarintParser<BOOL,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(uint64_t a1, google::protobuf::internal *this, unsigned int *a3)
{
  v17 = *MEMORY[0x1E69E9840];
  v5 = *this;
  if ((*this & 0x80000000) == 0)
  {
    result = this + 1;
    goto LABEL_3;
  }

  result = google::protobuf::internal::ReadSizeFallback(this, *this);
  if (result)
  {
    v5 = v13;
    while (1)
    {
LABEL_3:
      v7 = *(a1 + 8);
      v8 = v7 - result;
      if (v5 <= v7 - result)
      {
        v12 = &result[v5];
        result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<BOOL,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(result, v12, a3);
        if (v12 != result)
        {
          return 0;
        }

        return result;
      }

      result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<BOOL,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(result, v7, a3);
      if (!result)
      {
        return result;
      }

      v9 = *(a1 + 8);
      v10 = result - v9;
      v11 = v5 - v8;
      if (v5 - v8 <= 16)
      {
        break;
      }

      if (*(a1 + 28) < 17)
      {
        return 0;
      }

      result = google::protobuf::internal::EpsCopyInputStream::Next(a1);
      if (!result)
      {
        return result;
      }

      v5 = v5 - v8 - v10;
      result += v10;
    }

    v16 = 0;
    v15 = 0;
    v14 = *v9;
    if (google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<BOOL,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(&v14 + v10, &v14 + v11, a3) != &v14 + v11)
    {
      return 0;
    }

    return (*(a1 + 8) + v11);
  }

  return result;
}

char *google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::VarintParser<BOOL,false>(void *,char const*,google::protobuf::internal::ParseContext *)::{lambda(unsigned long long)#1}>(char *a1, unint64_t a2, unsigned int *a3)
{
  for (i = a1; i < a2; *a3 = v8)
  {
    v10 = 0;
    i = google::protobuf::internal::VarintParse<unsigned long long>(i, &v10);
    if (!i)
    {
      break;
    }

    v6 = v10 != 0;
    v7 = *a3;
    if (v7 == a3[1])
    {
      v8 = v7 + 1;
      google::protobuf::RepeatedField<BOOL>::Reserve(a3, v7 + 1);
      *(*(a3 + 1) + v7) = v6;
    }

    else
    {
      *(*(a3 + 1) + v7) = v6;
      v8 = v7 + 1;
    }
  }

  return i;
}

google::protobuf::internal::EpsCopyInputStream *google::protobuf::internal::EpsCopyInputStream::ReadPackedFixed<unsigned int>(google::protobuf::internal::EpsCopyInputStream *a1, char *a2, int a3, unsigned int *a4)
{
  v5 = a3;
  v6 = a2;
  v7 = *(a1 + 2) - a2 + 16;
  if (v7 >= a3)
  {
LABEL_5:
    google::protobuf::RepeatedField<int>::Reserve(a4, *a4 + (v5 >> 2));
    v12 = *a4;
    v13 = (*(a4 + 1) + 4 * v12);
    *a4 = v12 + (v5 >> 2);
    memcpy(v13, v6, (v5 & 0xFFFFFFFC));
    if (v5 == (v5 & 0xFFFFFFFC))
    {
      return &v6[v5 & 0xFFFFFFFC];
    }

    else
    {
      return 0;
    }
  }

  else
  {
    while (1)
    {
      google::protobuf::RepeatedField<int>::Reserve(a4, *a4 + (v7 >> 2));
      v9 = *a4;
      v10 = (*(a4 + 1) + 4 * v9);
      *a4 = v9 + (v7 >> 2);
      memcpy(v10, v6, (v7 & 0xFFFFFFFC));
      if (*(a1 + 7) < 17)
      {
        return 0;
      }

      result = google::protobuf::internal::EpsCopyInputStream::Next(a1);
      if (!result)
      {
        return result;
      }

      v5 -= v7 & 0xFFFFFFFC;
      v6 = result - (v7 & 3) + 16;
      v7 = *(a1 + 2) - (result - (v7 & 3));
      if (v5 <= v7)
      {
        goto LABEL_5;
      }
    }
  }
}

google::protobuf::internal::EpsCopyInputStream *google::protobuf::internal::EpsCopyInputStream::ReadPackedFixed<unsigned long long>(google::protobuf::internal::EpsCopyInputStream *a1, char *a2, int a3, unsigned int *a4)
{
  v5 = a3;
  v6 = a2;
  v7 = *(a1 + 2) - a2 + 16;
  if (v7 >= a3)
  {
LABEL_5:
    google::protobuf::RepeatedField<long long>::Reserve(a4, *a4 + (v5 >> 3));
    v12 = *a4;
    v13 = (*(a4 + 1) + 8 * v12);
    *a4 = v12 + (v5 >> 3);
    memcpy(v13, v6, (v5 & 0xFFFFFFF8));
    if (v5 == (v5 & 0xFFFFFFF8))
    {
      return &v6[v5 & 0xFFFFFFF8];
    }

    else
    {
      return 0;
    }
  }

  else
  {
    while (1)
    {
      google::protobuf::RepeatedField<long long>::Reserve(a4, *a4 + (v7 >> 3));
      v9 = *a4;
      v10 = (*(a4 + 1) + 8 * v9);
      *a4 = v9 + (v7 >> 3);
      memcpy(v10, v6, (v7 & 0xFFFFFFF8));
      if (*(a1 + 7) < 17)
      {
        return 0;
      }

      result = google::protobuf::internal::EpsCopyInputStream::Next(a1);
      if (!result)
      {
        return result;
      }

      v5 -= v7 & 0xFFFFFFF8;
      v6 = result - (v7 & 7) + 16;
      v7 = *(a1 + 2) - (result - (v7 & 7));
      if (v5 <= v7)
      {
        goto LABEL_5;
      }
    }
  }
}

void google::protobuf::internal::UnknownFieldLiteParserHelper::AddVarint(std::string **this, int a2, unint64_t a3)
{
  v3 = *this;
  if (*this)
  {
    v6 = (8 * a2);
    if (v6 < 0x80)
    {
      LOBYTE(v7) = 8 * a2;
    }

    else
    {
      do
      {
        std::string::push_back(v3, v6 | 0x80);
        v7 = v6 >> 7;
        v8 = v6 >> 14;
        v6 >>= 7;
      }

      while (v8);
    }

    std::string::push_back(v3, v7);
    v9 = *this;
    if (a3 < 0x80)
    {
      LOBYTE(v10) = a3;
    }

    else
    {
      do
      {
        std::string::push_back(v9, a3 | 0x80);
        v10 = a3 >> 7;
        v11 = a3 >> 14;
        a3 >>= 7;
      }

      while (v11);
    }

    std::string::push_back(v9, v10);
  }
}

std::string *google::protobuf::internal::UnknownFieldLiteParserHelper::AddFixed64(std::string *this, int a2, uint64_t a3)
{
  v9[1] = *MEMORY[0x1E69E9840];
  v3 = this->__r_.__value_.__r.__words[0];
  if (this->__r_.__value_.__r.__words[0])
  {
    v5 = this;
    v6 = (8 * a2) | 1u;
    if ((8 * a2) < 0x80)
    {
      LOBYTE(v7) = (8 * a2) | 1;
    }

    else
    {
      do
      {
        std::string::push_back(v3, v6 | 0x80);
        v7 = v6 >> 7;
        v8 = v6 >> 14;
        v6 >>= 7;
      }

      while (v8);
    }

    std::string::push_back(v3, v7);
    v9[0] = a3;
    return std::string::append(*v5, v9, 8uLL);
  }

  return this;
}

google::protobuf::internal::EpsCopyInputStream *google::protobuf::internal::UnknownFieldLiteParserHelper::ParseLengthDelimited(std::string **a1, int a2, std::string::value_type *this, google::protobuf::internal::EpsCopyInputStream *a4)
{
  v7 = *this;
  if (*this < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(this, *this);
    if (!result)
    {
      return result;
    }

    v8 = result;
    v7 = v19;
  }

  else
  {
    v8 = this + 1;
  }

  v9 = *a1;
  if (*a1)
  {
    v10 = (8 * a2) | 2u;
    if ((8 * a2) < 0x80)
    {
      LOBYTE(v11) = (8 * a2) | 2;
    }

    else
    {
      do
      {
        std::string::push_back(v9, v10 | 0x80);
        v11 = v10 >> 7;
        v12 = v10 >> 14;
        v10 >>= 7;
      }

      while (v12);
    }

    std::string::push_back(v9, v11);
    v14 = v7;
    v15 = *a1;
    if (v7 < 0x80)
    {
      LOBYTE(v16) = v7;
    }

    else
    {
      do
      {
        std::string::push_back(v15, v14 | 0x80);
        v16 = v14 >> 7;
        v17 = v14 >> 14;
        v14 >>= 7;
      }

      while (v17);
    }

    std::string::push_back(v15, v16);
    v18 = *a1;

    return google::protobuf::internal::EpsCopyInputStream::AppendString(a4, v8, v7, v18);
  }

  else if (*(a4 + 1) - v8 + 16 >= v7)
  {
    return &v8[v7];
  }

  else
  {

    return google::protobuf::internal::EpsCopyInputStream::SkipFallback(a4, v8, v7);
  }
}

char *google::protobuf::internal::UnknownFieldLiteParserHelper::ParseGroup(std::string **a1, int a2, char *a3, int32x2_t *this)
{
  v7 = *a1;
  v8 = 8 * a2;
  if (*a1)
  {
    v9 = v8 | 3;
    if (v8 < 0x80)
    {
      LOBYTE(v10) = v8 | 3;
    }

    else
    {
      do
      {
        std::string::push_back(v7, v9 | 0x80);
        v10 = v9 >> 7;
        v11 = v9 >> 14;
        v9 >>= 7;
      }

      while (v11);
    }

    std::string::push_back(v7, v10);
  }

  v12 = this[11].i32[0];
  v13 = __OFSUB__(v12--, 1);
  this[11].i32[0] = v12;
  if (v12 < 0 != v13)
  {
    return 0;
  }

  ++this[11].i32[1];
  v14 = google::protobuf::internal::WireFormatParser<google::protobuf::internal::UnknownFieldLiteParserHelper>(a1, a3, this);
  this[11] = vadd_s32(this[11], 0xFFFFFFFF00000001);
  v15 = this[10].i32[0];
  this[10].i32[0] = 0;
  if (v15 != (v8 | 3) || v14 == 0)
  {
    return 0;
  }

  v17 = v14;
  v18 = *a1;
  if (v18)
  {
    v19 = v8 | 4;
    if (v8 < 0x80)
    {
      LOBYTE(v20) = v8 | 4;
    }

    else
    {
      do
      {
        std::string::push_back(v18, v19 | 0x80);
        v20 = v19 >> 7;
        v21 = v19 >> 14;
        v19 >>= 7;
      }

      while (v21);
    }

    std::string::push_back(v18, v20);
  }

  return v17;
}

std::string *google::protobuf::internal::UnknownFieldLiteParserHelper::AddFixed32(std::string *this, int a2, int a3)
{
  v3 = this->__r_.__value_.__r.__words[0];
  if (this->__r_.__value_.__r.__words[0])
  {
    v5 = this;
    v6 = (8 * a2) | 5u;
    if ((8 * a2) < 0x80)
    {
      LOBYTE(v7) = (8 * a2) | 5;
    }

    else
    {
      do
      {
        std::string::push_back(v3, v6 | 0x80);
        v7 = v6 >> 7;
        v8 = v6 >> 14;
        v6 >>= 7;
      }

      while (v8);
    }

    std::string::push_back(v3, v7);
    *__s = a3;
    return std::string::append(*v5, __s, 4uLL);
  }

  return this;
}

google::protobuf::internal::EpsCopyInputStream *google::protobuf::internal::EpsCopyInputStream::AppendString(uint64_t a1, std::string::value_type *__s, int a3, std::string *this)
{
  if (*(a1 + 8) - __s + 16 < a3)
  {

    return google::protobuf::internal::EpsCopyInputStream::AppendStringFallback();
  }

  else
  {
    v5 = a3;
    std::string::append(this, __s, a3);
    return &__s[v5];
  }
}

void OUTLINED_FUNCTION_1_5(uint64_t a1@<X8>)
{
  if (v1 >= 50000000)
  {
    v4 = 50000000;
  }

  else
  {
    v4 = v1;
  }

  std::string::reserve(v2, a1 + v4);
}

std::string *OUTLINED_FUNCTION_3_4(uint64_t a1, uint64_t a2, std::string::size_type a3)
{

  return std::string::append(v3, v4, a3);
}

void *google::protobuf::internal::ArenaImpl::thread_cache(google::protobuf::internal::ArenaImpl *this)
{
  {
    operator new();
  }

  v1 = google::protobuf::internal::ArenaImpl::thread_cache(void)::thread_cache_;

  return google::protobuf::internal::ThreadLocalStorage<google::protobuf::internal::ArenaImpl::ThreadCache>::Get(v1);
}

void sub_1B5AC4958(_Unwind_Exception *a1)
{
  MEMORY[0x1B8C85350](v1, 0x1000C4000313F17);
  _Unwind_Resume(a1);
}

void *google::protobuf::internal::ThreadLocalStorage<google::protobuf::internal::ArenaImpl::ThreadCache>::Get(pthread_key_t *a1)
{
  v2 = pthread_getspecific(*a1);
  if (!v2)
  {
    v2 = operator new(0x40uLL, 0x40uLL);
    *v2 = xmmword_1B5B33370;
    v2[2] = 0;
    pthread_setspecific(*a1, v2);
  }

  return v2;
}

void *google::protobuf::internal::ArenaImpl::NewBuffer(google::protobuf::internal::ArenaImpl *this, uint64_t a2, unint64_t a3)
{
  v5 = *(this + 4);
  if (a2 == -1)
  {
    if (v5)
    {
      v7 = *v5;
    }

    else
    {
      v7 = 256;
    }
  }

  else
  {
    if (v5)
    {
      v6 = *(v5 + 8);
    }

    else
    {
      v6 = 0x2000;
    }

    if (v6 >= 2 * a2)
    {
      v7 = 2 * a2;
    }

    else
    {
      v7 = v6;
    }
  }

  if (a3 >= 0xFFFFFFFFFFFFFFE8)
  {
    google::protobuf::internal::LogMessage::LogMessage(v12, 3, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/third_party/protobuf-lite/arena.cc", 245);
    v8 = google::protobuf::internal::LogMessage::operator<<(v12, "CHECK failed: (min_bytes) <= (std::numeric_limits<size_t>::max() - kBlockHeaderSize): ");
    google::protobuf::internal::LogFinisher::operator=(&v11, &v8->__r_.__value_.__l.__data_);
    google::protobuf::internal::LogMessage::~LogMessage(&v12[0].__r_.__value_.__l.__data_);
    v5 = *(this + 4);
  }

  if (v7 <= a3 + 24)
  {
    v9 = a3 + 24;
  }

  else
  {
    v9 = v7;
  }

  if (v5)
  {
    result = (*(v5 + 16))(v9);
  }

  else
  {
    result = operator new(v9);
  }

  atomic_fetch_add_explicit(this + 2, v9, memory_order_relaxed);
  return result;
}

void sub_1B5AC4AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  google::protobuf::internal::LogMessage::~LogMessage(va);
  _Unwind_Resume(a1);
}

void *google::protobuf::internal::SerialArena::AddCleanupFallback(google::protobuf::internal::SerialArena *this, void *a2, void (*a3)(void *))
{
  result = *(this + 3);
  do
  {
    if (result)
    {
      if ((2 * *result) >= 0x40)
      {
        v7 = 64;
      }

      else
      {
        v7 = 2 * *result;
      }
    }

    else
    {
      v7 = 8;
    }

    v8 = (16 * v7 + 23) & 0xFF0;
    v9 = *(this + 5);
    if (*(this + 6) - v9 < v8)
    {
      result = google::protobuf::internal::SerialArena::AllocateAlignedFallback(this, v8);
      v10 = *(this + 3);
    }

    else
    {
      *(this + 5) = v9 + v8;
      v10 = result;
      result = v9;
    }

    *result = v7;
    result[1] = v10;
    *(this + 3) = result;
    *(this + 7) = result + 2;
    *(this + 8) = &result[2 * v7 + 2];
  }

  while (!v7);
  result[2] = a2;
  result[3] = a3;
  *(this + 7) = result + 4;
  return result;
}

void *google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(atomic_ullong *this, unint64_t a2, void (*a3)(void *))
{
  v6 = google::protobuf::internal::ArenaImpl::thread_cache(this);
  if (*(v6 + 1) == this[3])
  {
    explicit = *(v6 + 2);
    goto LABEL_3;
  }

  v9 = google::protobuf::internal::ArenaImpl::thread_cache(v6);
  explicit = atomic_load_explicit(this + 1, memory_order_acquire);
  if (explicit && *(explicit + 1) == v9)
  {
LABEL_3:

    return google::protobuf::internal::SerialArena::AllocateAlignedAndAddCleanup(explicit, a2, a3);
  }

  return google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanupFallback(this, a2, a3);
}

void *google::protobuf::internal::SerialArena::AllocateAlignedAndAddCleanup(google::protobuf::internal::SerialArena *this, unint64_t a2, void (*a3)(void *))
{
  AlignedFallback = *(this + 5);
  if (*(this + 6) - AlignedFallback < a2)
  {
    AlignedFallback = google::protobuf::internal::SerialArena::AllocateAlignedFallback(this, a2);
  }

  else
  {
    *(this + 5) = AlignedFallback + a2;
  }

  v6 = *(this + 7);
  if (v6 == *(this + 8))
  {
    google::protobuf::internal::SerialArena::AddCleanupFallback(this, AlignedFallback, a3);
  }

  else
  {
    *v6 = AlignedFallback;
    v6[1] = a3;
    *(this + 7) = v6 + 2;
  }

  return AlignedFallback;
}

void *google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanupFallback(google::protobuf::internal::ArenaImpl *this, unint64_t a2, void (*a3)(void *))
{
  v6 = google::protobuf::internal::ArenaImpl::thread_cache(this);
  SerialArenaFallback = google::protobuf::internal::ArenaImpl::GetSerialArenaFallback(this, v6);

  return google::protobuf::internal::SerialArena::AllocateAlignedAndAddCleanup(SerialArenaFallback, a2, a3);
}

void *google::protobuf::internal::ArenaImpl::AllocateAlignedFallback(google::protobuf::internal::ArenaImpl *this, unint64_t a2)
{
  v4 = google::protobuf::internal::ArenaImpl::thread_cache(this);
  SerialArenaFallback = google::protobuf::internal::ArenaImpl::GetSerialArenaFallback(this, v4);
  v6 = *(SerialArenaFallback + 5);
  if (*(SerialArenaFallback + 6) - v6 < a2)
  {

    return google::protobuf::internal::SerialArena::AllocateAlignedFallback(SerialArenaFallback, a2);
  }

  else
  {
    *(SerialArenaFallback + 5) = v6 + a2;
    return v6;
  }
}

char *google::protobuf::internal::ArenaImpl::GetSerialArenaFallback(atomic_ullong *this, void *a2)
{
  v3 = this;
  explicit = atomic_load_explicit(this, memory_order_acquire);
  if (explicit)
  {
    while (*(explicit + 1) != a2)
    {
      explicit = *(explicit + 4);
      if (!explicit)
      {
        goto LABEL_4;
      }
    }
  }

  else
  {
LABEL_4:
    this = google::protobuf::internal::ArenaImpl::NewBuffer(this, -1, 0x48uLL);
    this[3] = v3;
    explicit = (this + 3);
    this[2] = v5;
    *this = xmmword_1B5B3E1B0;
    this[4] = a2;
    this[5] = this;
    this[8] = (this + 12);
    this[9] = this + v5;
    this[6] = 0;
    this[10] = 0;
    this[11] = 0;
    v6 = *v3;
    this[7] = *v3;
    v7 = v6;
    atomic_compare_exchange_strong_explicit(v3, &v7, (this + 3), memory_order_release, memory_order_relaxed);
    if (v7 != v6)
    {
      v8 = v7;
      do
      {
        this[7] = v7;
        atomic_compare_exchange_strong_explicit(v3, &v8, explicit, memory_order_release, memory_order_relaxed);
        v9 = v8 == v7;
        v7 = v8;
      }

      while (!v9);
    }
  }

  v10 = google::protobuf::internal::ArenaImpl::thread_cache(this);
  *(v10 + 2) = explicit;
  v11 = v3[3];
  google::protobuf::internal::ArenaImpl::thread_cache(v10)[1] = v11;
  atomic_store(explicit, v3 + 1);
  return explicit;
}

void *google::protobuf::internal::SerialArena::AllocateAlignedFallback(google::protobuf::internal::SerialArena *this, unint64_t a2)
{
  v4 = *(this + 2);
  v5 = v4[2];
  v8 = this + 40;
  result = *(this + 5);
  v7 = *(v8 + 1);
  do
  {
    v4[1] = result + v5 - v7;
    v9 = google::protobuf::internal::ArenaImpl::NewBuffer(*this, v5, a2);
    *v9 = v4;
    v9[1] = 24;
    v9[2] = v5;
    *(this + 2) = v9;
    result = v9 + 3;
    v7 = v9 + v5;
    *(this + 5) = v9 + 3;
    *(this + 6) = v9 + v5;
    v4 = v9;
  }

  while (v5 - 24 < a2);
  *(this + 5) = result + a2;
  return result;
}

void *google::protobuf::internal::ArenaImpl::AllocateAligned(atomic_ullong *this, unint64_t a2)
{
  v4 = google::protobuf::internal::ArenaImpl::thread_cache(this);
  if (*(v4 + 1) == this[3])
  {
    explicit = *(v4 + 2);
    goto LABEL_3;
  }

  v8 = google::protobuf::internal::ArenaImpl::thread_cache(v4);
  explicit = atomic_load_explicit(this + 1, memory_order_acquire);
  if (explicit && *(explicit + 1) == v8)
  {
LABEL_3:
    v6 = *(explicit + 5);
    if (*(explicit + 6) - v6 < a2)
    {

      return google::protobuf::internal::SerialArena::AllocateAlignedFallback(explicit, a2);
    }

    else
    {
      *(explicit + 5) = v6 + a2;
      return v6;
    }
  }

  return google::protobuf::internal::ArenaImpl::AllocateAlignedFallback(this, a2);
}

uint64_t google::protobuf::internal::ThreadLocalStorage<google::protobuf::internal::ArenaImpl::ThreadCache>::Delete(uint64_t result)
{
  if (result)
  {
    JUMPOUT(0x1B8C85340);
  }

  return result;
}

unint64_t google::protobuf::io::EpsCopyOutputStream::Flush(google::protobuf::io::EpsCopyOutputStream *this, unsigned __int8 *a2)
{
  v4 = (this + 16);
  v5 = this + 32;
  while (1)
  {
    v7 = *this;
    v6 = *(this + 1);
    if (!v6)
    {
      result = v7 - a2 + 16;
      *(this + 1) = a2;
      return result;
    }

    v8 = a2 - v7;
    if (a2 <= v7)
    {
      memcpy(v6, v4, a2 - v4);
      v12 = *this;
      *(this + 1) += a2 - v4;
      return v12 - a2;
    }

    if (!*(this + 6))
    {
      break;
    }

    memcpy(v6, v4, v7 - v4);
    v15 = 0;
    do
    {
      v14 = 0;
      if (((*(**(this + 6) + 16))(*(this + 6), &v14, &v15) & 1) == 0)
      {
        *(this + 56) = 1;
        *this = v5;
        goto LABEL_13;
      }

      v9 = v15;
    }

    while (!v15);
    v10 = v14;
    v11 = *this;
    if (v15 >= 17)
    {
      *v14 = *v11;
      *this = v10 + v9 - 16;
      *(this + 1) = 0;
      goto LABEL_10;
    }

    *v4 = *v11;
    *this = v4 + v9;
    *(this + 1) = v10;
LABEL_13:
    v10 = v4;
LABEL_10:
    a2 = v10 + v8;
    if (*(this + 56))
    {
      return 0;
    }
  }

  result = 0;
  *(this + 56) = 1;
  *this = v5;
  return result;
}

unsigned __int8 *google::protobuf::io::EpsCopyOutputStream::Trim(google::protobuf::io::EpsCopyOutputStream *this, unsigned __int8 *a2)
{
  if ((*(this + 56) & 1) == 0)
  {
    v3 = google::protobuf::io::EpsCopyOutputStream::Flush(this, a2);
    if (v3)
    {
      (*(**(this + 6) + 24))(*(this + 6), v3);
    }

    a2 = this + 16;
    *this = this + 16;
    *(this + 1) = this + 16;
  }

  return a2;
}

unsigned __int8 *google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(google::protobuf::io::EpsCopyOutputStream *this, char *__src, int a3, unsigned __int8 *__dst)
{
  v4 = __dst;
  v5 = a3;
  v7 = *this - __dst + 16;
  if (v7 < a3)
  {
    do
    {
      memcpy(v4, __src, v7);
      v5 -= v7;
      __src += v7;
      v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(this, &v4[v7]);
      v7 = *this - v4 + 16;
    }

    while (v5 > v7);
  }

  memcpy(v4, __src, v5);
  return &v4[v5];
}

unsigned __int8 *google::protobuf::io::EpsCopyOutputStream::WriteAliasedRaw(google::protobuf::io::EpsCopyOutputStream *this, void *__src, uint64_t a3, unsigned __int8 *__dst)
{
  v8 = *this - __dst;
  if (v8 + 16 <= a3)
  {
    v9 = google::protobuf::io::EpsCopyOutputStream::Trim(this, __dst);
    if (((*(**(this + 6) + 40))(*(this + 6), __src, a3) & 1) == 0)
    {
      *(this + 56) = 1;
      v9 = this + 16;
      *this = this + 32;
    }

    return v9;
  }

  if (v8 >= a3)
  {
    memcpy(__dst, __src, a3);
    return &__dst[a3];
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(this, __src, a3, __dst);
}

unsigned __int8 *google::protobuf::io::EpsCopyOutputStream::WriteStringMaybeAliasedOutline(google::protobuf::io::EpsCopyOutputStream *this, int a2, void **a3, unsigned __int8 *a4)
{
  if (*this <= a4)
  {
    a4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(this, a4);
  }

  if (*(a3 + 23) >= 0)
  {
    v7 = *(a3 + 23);
  }

  else
  {
    v7 = *(a3 + 2);
  }

  v8 = 8 * a2;
  if ((8 * a2) > 0x7F)
  {
    *a4 = v8 | 0x82;
    v10 = v8 >> 7;
    if (v8 >> 14)
    {
      v9 = a4 + 2;
      do
      {
        *(v9 - 1) = v10 | 0x80;
        v11 = v10 >> 7;
        ++v9;
        v12 = v10 >> 14;
        v10 >>= 7;
      }

      while (v12);
      *(v9 - 1) = v11;
    }

    else
    {
      a4[1] = v10;
      v9 = a4 + 2;
    }
  }

  else
  {
    *a4 = v8 | 2;
    v9 = a4 + 1;
  }

  if (v7 >= 0x80)
  {
    v17 = v7;
    do
    {
      *v9++ = v17 | 0x80;
      v13 = v17 >> 7;
      v18 = v17 >> 14;
      v17 >>= 7;
    }

    while (v18);
  }

  else
  {
    LOBYTE(v13) = v7;
  }

  *v9 = v13;
  v14 = v9 + 1;
  if (*(a3 + 23) >= 0)
  {
    v15 = a3;
  }

  else
  {
    v15 = *a3;
  }

  return google::protobuf::io::EpsCopyOutputStream::WriteRawMaybeAliased(this, v15, v7, v14);
}

unsigned __int8 *google::protobuf::io::EpsCopyOutputStream::WriteRawMaybeAliased(google::protobuf::io::EpsCopyOutputStream *this, void *a2, uint64_t a3, unsigned __int8 *__dst)
{
  if (*(this + 57) == 1)
  {

    return google::protobuf::io::EpsCopyOutputStream::WriteAliasedRaw(this, a2, a3, __dst);
  }

  else if (*this - __dst < a3)
  {

    return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(this, a2, a3, __dst);
  }

  else
  {
    v6 = a3;
    memcpy(__dst, a2, a3);
    return &__dst[v6];
  }
}

unsigned __int8 *google::protobuf::io::EpsCopyOutputStream::WriteStringOutline(google::protobuf::io::EpsCopyOutputStream *this, int a2, uint64_t a3, unsigned __int8 *a4)
{
  v4 = a4;
  if (*this <= a4)
  {
    v4 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(this, a4);
  }

  if (*(a3 + 23) >= 0)
  {
    LODWORD(v8) = *(a3 + 23);
  }

  else
  {
    v8 = *(a3 + 8);
  }

  v9 = 8 * a2;
  if ((8 * a2) > 0x7F)
  {
    *v4 = v9 | 0x82;
    v11 = v9 >> 7;
    if (v9 >> 14)
    {
      v10 = v4 + 2;
      do
      {
        *(v10 - 1) = v11 | 0x80;
        v12 = v11 >> 7;
        ++v10;
        v13 = v11 >> 14;
        v11 >>= 7;
      }

      while (v13);
      *(v10 - 1) = v12;
    }

    else
    {
      v4[1] = v11;
      v10 = v4 + 2;
    }
  }

  else
  {
    *v4 = v9 | 2;
    v10 = v4 + 1;
  }

  if (v8 >= 0x80)
  {
    v19 = v8;
    do
    {
      *v10++ = v19 | 0x80;
      v14 = v19 >> 7;
      v20 = v19 >> 14;
      v19 >>= 7;
    }

    while (v20);
  }

  else
  {
    LOBYTE(v14) = v8;
  }

  *v10 = v14;
  v15 = v10 + 1;
  if (*(a3 + 23) >= 0)
  {
    v16 = a3;
  }

  else
  {
    v16 = *a3;
  }

  if (*this - v15 < v8)
  {

    return google::protobuf::io::EpsCopyOutputStream::WriteRawFallback(this, v16, v8, v15);
  }

  else
  {
    v17 = v8;
    memcpy(v15, v16, v8);
    return &v15[v17];
  }
}

void google::protobuf::internal::VerifyVersion(google::protobuf::internal *this, google::protobuf::internal *a2, const std::string::value_type *a3, const char *a4)
{
  v27 = *MEMORY[0x1E69E9840];
  if (a2 > 3014000)
  {
    LODWORD(v21) = 3;
    v22 = "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/third_party/protobuf-lite/common.cc";
    v23 = 76;
    memset(&v24, 0, sizeof(v24));
    std::string::append(&v24, "This program requires version ");
    google::protobuf::internal::VersionString(a2, &v18);
    if ((v20 & 0x80u) == 0)
    {
      v7 = &v18;
    }

    else
    {
      v7 = v18;
    }

    if ((v20 & 0x80u) == 0)
    {
      v8 = v20;
    }

    else
    {
      v8 = v19;
    }

    std::string::append(&v24, v7, v8);
    std::string::append(&v24, " of the Protocol Buffer runtime library, but the installed version is ");
    snprintf(__str, 0x80uLL, "%d.%d.%d", 3, 14, 0);
    v26 = 0;
    std::string::basic_string[abi:ne200100]<0>(&__p, __str);
    if ((v17 & 0x80u) == 0)
    {
      p_p = &__p;
    }

    else
    {
      p_p = __p;
    }

    if ((v17 & 0x80u) == 0)
    {
      v10 = v17;
    }

    else
    {
      v10 = v16;
    }

    std::string::append(&v24, p_p, v10);
    std::string::append(&v24, ".  Please update your library.  If you compiled the program yourself, make sure that your headers are from the same version of Protocol Buffers as your link-time library.  (Version verification failed in ");
    std::string::append(&v24, a3);
    std::string::append(&v24, ".)");
    google::protobuf::internal::LogMessage::Finish(&v21);
    if (v17 < 0)
    {
      operator delete(__p);
    }

    if (v20 < 0)
    {
      operator delete(v18);
    }

    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
  }

  if (this < 3014000)
  {
    LODWORD(v21) = 3;
    v22 = "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/third_party/protobuf-lite/common.cc";
    v23 = 87;
    memset(&v24, 0, sizeof(v24));
    std::string::append(&v24, "This program was compiled against version ");
    google::protobuf::internal::VersionString(this, &v18);
    if ((v20 & 0x80u) == 0)
    {
      v11 = &v18;
    }

    else
    {
      v11 = v18;
    }

    if ((v20 & 0x80u) == 0)
    {
      v12 = v20;
    }

    else
    {
      v12 = v19;
    }

    std::string::append(&v24, v11, v12);
    std::string::append(&v24, " of the Protocol Buffer runtime library, which is not compatible with the installed version (");
    snprintf(__str, 0x80uLL, "%d.%d.%d", 3, 14, 0);
    v26 = 0;
    std::string::basic_string[abi:ne200100]<0>(&__p, __str);
    if ((v17 & 0x80u) == 0)
    {
      v13 = &__p;
    }

    else
    {
      v13 = __p;
    }

    if ((v17 & 0x80u) == 0)
    {
      v14 = v17;
    }

    else
    {
      v14 = v16;
    }

    std::string::append(&v24, v13, v14);
    std::string::append(&v24, ").  Contact the program author for an update.  If you compiled the program yourself, make sure that your headers are from the same version of Protocol Buffers as your link-time library.  (Version verification failed in ");
    std::string::append(&v24, a3);
    std::string::append(&v24, ".)");
    google::protobuf::internal::LogMessage::Finish(&v21);
    if (v17 < 0)
    {
      operator delete(__p);
    }

    if (v20 < 0)
    {
      operator delete(v18);
    }

    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1B5AC5964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a17 < 0)
  {
    operator delete(__p);
  }

  if (a23 < 0)
  {
    operator delete(a18);
  }

  if (a32 < 0)
  {
    operator delete(a27);
  }

  _Unwind_Resume(exception_object);
}

uint64_t google::protobuf::internal::LogMessage::LogMessage(uint64_t result, int a2, uint64_t a3, int a4)
{
  *result = a2;
  *(result + 8) = a3;
  *(result + 16) = a4;
  *(result + 32) = 0;
  *(result + 40) = 0;
  *(result + 24) = 0;
  return result;
}

std::string *google::protobuf::internal::LogMessage::operator<<(std::string *a1, const std::string::value_type *a2)
{
  std::string::append(a1 + 1, a2);
  return a1;
}

{
  v3 = *(a2 + 1);
  if (a2[23] >= 0)
  {
    v4 = *(a2 + 23);
  }

  else
  {
    a2 = *a2;
    v4 = v3;
  }

  std::string::append(a1 + 1, a2, v4);
  return a1;
}

_BYTE *google::protobuf::internal::VersionString@<X0>(google::protobuf::internal *this@<X0>, _BYTE *a2@<X8>)
{
  v5 = *MEMORY[0x1E69E9840];
  snprintf(__str, 0x80uLL, "%d.%d.%d", this / 1000000, this / 1000 % 1000, this % 1000);
  __str[127] = 0;
  return std::string::basic_string[abi:ne200100]<0>(a2, __str);
}

void google::protobuf::internal::LogMessage::~LogMessage(void **this)
{
  if (*(this + 47) < 0)
  {
    operator delete(this[3]);
  }
}

uint64_t google::protobuf::internal::DefaultLogHandler(uint64_t result, const char *a2, int a3, uint64_t a4)
{
  if ((result & 0x80000000) == 0)
  {
    v4 = MEMORY[0x1E69E9848];
    if (*(a4 + 23) >= 0)
    {
      v5 = a4;
    }

    else
    {
      v5 = *a4;
    }

    fprintf(*MEMORY[0x1E69E9848], "[libprotobuf %s %s:%d] %s\n", google::protobuf::internal::DefaultLogHandler(google::protobuf::LogLevel,char const*,int,std::string const&)::level_names[result], a2, a3, v5);
    v6 = *v4;

    return fflush(v6);
  }

  return result;
}

std::string *google::protobuf::internal::LogMessage::operator<<(std::string *a1, uint64_t a2)
{
  v5 = *MEMORY[0x1E69E9840];
  snprintf(__str, 0x80uLL, "%lu", a2);
  __str[127] = 0;
  std::string::append(a1 + 1, __str);
  return a1;
}

const char **google::protobuf::internal::LogMessage::Finish(const char **this)
{
  v1 = this;
  if (*this == 3)
  {
    v2 = 3;
  }

  else
  {
    v3 = atomic_load(&google::protobuf::internal::log_silencer_count_);
    if (v3 > 0)
    {
      goto LABEL_6;
    }

    v2 = *this;
  }

  this = google::protobuf::internal::log_handler_(v2, v1[1], *(v1 + 4), (v1 + 3));
LABEL_6:
  if (*v1 == 3)
  {
    exception = __cxa_allocate_exception(0x30uLL);
    google::protobuf::FatalException::FatalException(exception, v1[1], *(v1 + 4), v1 + 3);
  }

  return this;
}

void google::protobuf::FatalException::~FatalException(std::exception *this)
{
  this->__vftable = &unk_1F2D44198;
  if (SHIBYTE(this[5].__vftable) < 0)
  {
    operator delete(this[3].__vftable);
  }

  std::exception::~exception(this);
}

{
  google::protobuf::FatalException::~FatalException(this);

  JUMPOUT(0x1B8C85350);
}

uint64_t google::protobuf::FatalException::what(google::protobuf::FatalException *this)
{
  result = this + 24;
  if (*(this + 47) < 0)
  {
    return *result;
  }

  return result;
}

uint64_t google::protobuf::FatalException::FatalException(uint64_t a1, uint64_t a2, int a3, __int128 *a4)
{
  *a1 = &unk_1F2D44198;
  *(a1 + 8) = a2;
  *(a1 + 16) = a3;
  if (*(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 24), *a4, *(a4 + 1));
  }

  else
  {
    v5 = *a4;
    *(a1 + 40) = *(a4 + 2);
    *(a1 + 24) = v5;
  }

  return a1;
}

uint64_t google::protobuf::internal::GeneratedExtensionFinder::Find(uint64_t a1, int a2, _OWORD *a3)
{
  {
    if (v3)
    {
      v4 = *(a1 + 8);
      v5 = 0x9DDFEA08EB382D69 * ((8 * (v4 & 0x1FFFFFFF) + 8) ^ HIDWORD(v4));
      v6 = 0x9DDFEA08EB382D69 * (HIDWORD(v4) ^ (v5 >> 47) ^ v5);
      v7 = (0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47))) ^ a2;
      v8 = vcnt_s8(v3);
      v8.i16[0] = vaddlv_u8(v8);
      if (v8.u32[0] > 1uLL)
      {
        v9 = v7;
        if (v7 >= *&v3)
        {
          v9 = v7 % *&v3;
        }
      }

      else
      {
        v9 = (*&v3 - 1) & v7;
      }

      if (v10)
      {
        for (i = *v10; i; i = *i)
        {
          v12 = i[1];
          if (v7 == v12)
          {
            if (i[2] == v4 && *(i + 6) == a2)
            {
              v14 = *(i + 3);
              *a3 = *(i + 2);
              a3[1] = v14;
              return 1;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v12 >= *&v3)
              {
                v12 %= *&v3;
              }
            }

            else
            {
              v12 &= *&v3 - 1;
            }

            if (v12 != v9)
            {
              return 0;
            }
          }
        }
      }
    }
  }

  return 0;
}

uint64_t google::protobuf::internal::ExtensionSet::ExtensionSet(uint64_t result, uint64_t a2)
{
  *result = a2;
  *(result + 8) = 0;
  *(result + 16) = 0;
  return result;
}

void google::protobuf::internal::ExtensionSet::~ExtensionSet(google::protobuf::internal::ExtensionSet *this)
{
  if (!*this)
  {
    v2 = *(this + 2);
    if (*(this + 4) >= 0x101u)
    {
      google::protobuf::internal::ExtensionSet::ForEach<std::__map_iterator<std::__tree_iterator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__tree_node<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,void *> *,long>>,google::protobuf::internal::ExtensionSet::~()::$_0>(*v2, (v2 + 8));
    }

    else if (*(this + 5))
    {
      v3 = 32 * *(this + 5);
      v4 = (v2 + 8);
      do
      {
        google::protobuf::internal::ExtensionSet::Extension::Free(v4);
        v4 += 4;
        v3 -= 32;
      }

      while (v3);
    }

    v5 = *(this + 2);
    if (*(this + 4) >= 0x101u)
    {
      google::protobuf::internal::ExtensionSet::~ExtensionSet(v5 == 0, *(this + 2));
    }

    else if (v5)
    {
      MEMORY[0x1B8C85310](*(this + 2), 0x1062C802AB6010CLL);
    }
  }
}

unsigned __int8 *google::protobuf::internal::ExtensionSet::Extension::Clear(unsigned __int8 *this)
{
  v1 = this;
  if (this[9] == 1)
  {
    v2 = google::protobuf::internal::WireFormatLite::kFieldTypeToCppTypeMap[this[8]];
    if (v2 > 5)
    {
      if (v2 <= 8)
      {
LABEL_19:
        **this = 0;
        return this;
      }

      if (v2 == 9)
      {
        v10 = *this;

        return google::protobuf::internal::RepeatedPtrFieldBase::Clear<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(v10);
      }

      else if (v2 == 10)
      {
        v5 = *this;
        v6 = *(*this + 8);
        if (v6 >= 1)
        {
          v7 = (*(v5 + 2) + 8);
          do
          {
            v8 = *v7++;
            this = (*(*v8 + 40))(v8);
            --v6;
          }

          while (v6);
          v5[2] = 0;
        }
      }
    }

    else if (v2 > 2 || v2 == 1 || v2 == 2)
    {
      goto LABEL_19;
    }
  }

  else if ((this[10] & 1) == 0)
  {
    v3 = google::protobuf::internal::WireFormatLite::kFieldTypeToCppTypeMap[this[8]];
    if (v3 == 10)
    {
      v9 = **this;
      if ((this[10] & 0x10) != 0)
      {
        this = (*(v9 + 112))();
      }

      else
      {
        this = (*(v9 + 40))();
      }
    }

    else if (v3 == 9)
    {
      v4 = *this;
      if (*(*this + 23) < 0)
      {
        **v4 = 0;
        v4[1] = 0;
      }

      else
      {
        *v4 = 0;
        *(v4 + 23) = 0;
      }
    }

    v1[10] = v1[10] & 0xF0 | 1;
  }

  return this;
}

void google::protobuf::internal::ExtensionSet::AddInt32(google::protobuf::internal::ExtensionSet *this, int a2, char a3, char a4, int a5, const FieldDescriptor *a6)
{
  v11 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v12 = v11;
  v11[2] = a6;
  if (v13)
  {
    *(v11 + 8) = a3;
    *(v11 + 9) = 1;
    *(v11 + 11) = a4;
    v14 = *this;
    if (!v14)
    {
      operator new();
    }

    if (*(v14 + 24))
    {
      google::protobuf::internal::ExtensionSet::AddInt32(v14);
    }

    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v14, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<int>>);
    *AlignedAndAddCleanup = 0;
    *(AlignedAndAddCleanup + 1) = v14;
    *v12 = AlignedAndAddCleanup;
  }

  else
  {
    AlignedAndAddCleanup = *v11;
  }

  v16 = *AlignedAndAddCleanup;
  if (v16 == AlignedAndAddCleanup[1])
  {
    v17 = v16 + 1;
    google::protobuf::RepeatedField<int>::Reserve(AlignedAndAddCleanup, v16 + 1);
    *(*(AlignedAndAddCleanup + 1) + 4 * v16) = a5;
  }

  else
  {
    *(*(AlignedAndAddCleanup + 1) + 4 * v16) = a5;
    v17 = v16 + 1;
  }

  *AlignedAndAddCleanup = v17;
}

void google::protobuf::internal::ExtensionSet::AddInt64(google::protobuf::internal::ExtensionSet *this, int a2, char a3, char a4, uint64_t a5, const FieldDescriptor *a6)
{
  v11 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v12 = v11;
  v11[2] = a6;
  if (v13)
  {
    *(v11 + 8) = a3;
    *(v11 + 9) = 1;
    *(v11 + 11) = a4;
    v14 = *this;
    if (!v14)
    {
      operator new();
    }

    if (*(v14 + 24))
    {
      google::protobuf::internal::ExtensionSet::AddInt64(v14);
    }

    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v14, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<long long>>);
    *AlignedAndAddCleanup = 0;
    *(AlignedAndAddCleanup + 1) = v14;
    *v12 = AlignedAndAddCleanup;
  }

  else
  {
    AlignedAndAddCleanup = *v11;
  }

  v16 = *AlignedAndAddCleanup;
  if (v16 == AlignedAndAddCleanup[1])
  {
    v17 = v16 + 1;
    google::protobuf::RepeatedField<long long>::Reserve(AlignedAndAddCleanup, v16 + 1);
    *(*(AlignedAndAddCleanup + 1) + 8 * v16) = a5;
  }

  else
  {
    *(*(AlignedAndAddCleanup + 1) + 8 * v16) = a5;
    v17 = v16 + 1;
  }

  *AlignedAndAddCleanup = v17;
}

void google::protobuf::internal::ExtensionSet::AddUInt32(google::protobuf::internal::ExtensionSet *this, int a2, char a3, char a4, int a5, const FieldDescriptor *a6)
{
  v11 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v12 = v11;
  v11[2] = a6;
  if (v13)
  {
    *(v11 + 8) = a3;
    *(v11 + 9) = 1;
    *(v11 + 11) = a4;
    v14 = *this;
    if (!v14)
    {
      operator new();
    }

    if (*(v14 + 24))
    {
      google::protobuf::internal::ExtensionSet::AddUInt32(v14);
    }

    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v14, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<unsigned int>>);
    *AlignedAndAddCleanup = 0;
    *(AlignedAndAddCleanup + 1) = v14;
    *v12 = AlignedAndAddCleanup;
  }

  else
  {
    AlignedAndAddCleanup = *v11;
  }

  v16 = *AlignedAndAddCleanup;
  if (v16 == AlignedAndAddCleanup[1])
  {
    v17 = v16 + 1;
    google::protobuf::RepeatedField<int>::Reserve(AlignedAndAddCleanup, v16 + 1);
    *(*(AlignedAndAddCleanup + 1) + 4 * v16) = a5;
  }

  else
  {
    *(*(AlignedAndAddCleanup + 1) + 4 * v16) = a5;
    v17 = v16 + 1;
  }

  *AlignedAndAddCleanup = v17;
}

void google::protobuf::internal::ExtensionSet::AddUInt64(google::protobuf::internal::ExtensionSet *this, int a2, char a3, char a4, uint64_t a5, const FieldDescriptor *a6)
{
  v11 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v12 = v11;
  v11[2] = a6;
  if (v13)
  {
    *(v11 + 8) = a3;
    *(v11 + 9) = 1;
    *(v11 + 11) = a4;
    v14 = *this;
    if (!v14)
    {
      operator new();
    }

    if (*(v14 + 24))
    {
      google::protobuf::internal::ExtensionSet::AddUInt64(v14);
    }

    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v14, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<unsigned long long>>);
    *AlignedAndAddCleanup = 0;
    *(AlignedAndAddCleanup + 1) = v14;
    *v12 = AlignedAndAddCleanup;
  }

  else
  {
    AlignedAndAddCleanup = *v11;
  }

  v16 = *AlignedAndAddCleanup;
  if (v16 == AlignedAndAddCleanup[1])
  {
    v17 = v16 + 1;
    google::protobuf::RepeatedField<long long>::Reserve(AlignedAndAddCleanup, v16 + 1);
    *(*(AlignedAndAddCleanup + 1) + 8 * v16) = a5;
  }

  else
  {
    *(*(AlignedAndAddCleanup + 1) + 8 * v16) = a5;
    v17 = v16 + 1;
  }

  *AlignedAndAddCleanup = v17;
}

void google::protobuf::internal::ExtensionSet::AddFloat(google::protobuf::internal::ExtensionSet *this, int a2, char a3, char a4, float a5, const FieldDescriptor *a6)
{
  v11 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v12 = v11;
  v11[2] = a6;
  if (v13)
  {
    *(v11 + 8) = a3;
    *(v11 + 9) = 1;
    *(v11 + 11) = a4;
    v14 = *this;
    if (!v14)
    {
      operator new();
    }

    if (*(v14 + 24))
    {
      google::protobuf::internal::ExtensionSet::AddFloat(v14);
    }

    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v14, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<float>>);
    *AlignedAndAddCleanup = 0;
    *(AlignedAndAddCleanup + 1) = v14;
    *v12 = AlignedAndAddCleanup;
  }

  else
  {
    AlignedAndAddCleanup = *v11;
  }

  v16 = *AlignedAndAddCleanup;
  if (v16 == AlignedAndAddCleanup[1])
  {
    v17 = v16 + 1;
    google::protobuf::RepeatedField<int>::Reserve(AlignedAndAddCleanup, v16 + 1);
    *(*(AlignedAndAddCleanup + 1) + 4 * v16) = a5;
  }

  else
  {
    *(*(AlignedAndAddCleanup + 1) + 4 * v16) = a5;
    v17 = v16 + 1;
  }

  *AlignedAndAddCleanup = v17;
}

void google::protobuf::internal::ExtensionSet::AddDouble(google::protobuf::internal::ExtensionSet *this, int a2, char a3, char a4, double a5, const FieldDescriptor *a6)
{
  v11 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v12 = v11;
  v11[2] = a6;
  if (v13)
  {
    *(v11 + 8) = a3;
    *(v11 + 9) = 1;
    *(v11 + 11) = a4;
    v14 = *this;
    if (!v14)
    {
      operator new();
    }

    if (*(v14 + 24))
    {
      google::protobuf::internal::ExtensionSet::AddDouble(v14);
    }

    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v14, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<double>>);
    *AlignedAndAddCleanup = 0;
    *(AlignedAndAddCleanup + 1) = v14;
    *v12 = AlignedAndAddCleanup;
  }

  else
  {
    AlignedAndAddCleanup = *v11;
  }

  v16 = *AlignedAndAddCleanup;
  if (v16 == AlignedAndAddCleanup[1])
  {
    v17 = v16 + 1;
    google::protobuf::RepeatedField<long long>::Reserve(AlignedAndAddCleanup, v16 + 1);
    *(*(AlignedAndAddCleanup + 1) + 8 * v16) = a5;
  }

  else
  {
    *(*(AlignedAndAddCleanup + 1) + 8 * v16) = a5;
    v17 = v16 + 1;
  }

  *AlignedAndAddCleanup = v17;
}

void google::protobuf::internal::ExtensionSet::AddBool(google::protobuf::internal::ExtensionSet *this, int a2, char a3, char a4, char a5, const FieldDescriptor *a6)
{
  v11 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v12 = v11;
  v11[2] = a6;
  if (v13)
  {
    *(v11 + 8) = a3;
    *(v11 + 9) = 1;
    *(v11 + 11) = a4;
    v14 = *this;
    if (!v14)
    {
      operator new();
    }

    if (*(v14 + 24))
    {
      google::protobuf::internal::ExtensionSet::AddBool(v14);
    }

    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v14, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<BOOL>>);
    *AlignedAndAddCleanup = 0;
    *(AlignedAndAddCleanup + 1) = v14;
    *v12 = AlignedAndAddCleanup;
  }

  else
  {
    AlignedAndAddCleanup = *v11;
  }

  v16 = *AlignedAndAddCleanup;
  if (v16 == AlignedAndAddCleanup[1])
  {
    v17 = v16 + 1;
    google::protobuf::RepeatedField<BOOL>::Reserve(AlignedAndAddCleanup, v16 + 1);
    *(*(AlignedAndAddCleanup + 1) + v16) = a5;
  }

  else
  {
    *(*(AlignedAndAddCleanup + 1) + v16) = a5;
    v17 = v16 + 1;
  }

  *AlignedAndAddCleanup = v17;
}

uint64_t google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(google::protobuf::internal::ExtensionSet *this, int a2, int a3, char a4, const FieldDescriptor *a5)
{
  v9 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v10 = v9;
  v9[2] = a5;
  if ((v11 & 1) == 0)
  {
    return *v10;
  }

  *(v9 + 9) = 1;
  *(v9 + 8) = a3;
  *(v9 + 11) = a4;
  v12 = google::protobuf::internal::WireFormatLite::kFieldTypeToCppTypeMap[a3];
  if (v12 > 5)
  {
    if (v12 <= 7)
    {
      if (v12 == 6)
      {
        v13 = *this;
        if (v13)
        {
          if (*(v13 + 24))
          {
            google::protobuf::internal::ExtensionSet::AddFloat(v13);
          }

          v14 = google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<float>>;
          goto LABEL_48;
        }
      }

      else
      {
        v13 = *this;
        if (v13)
        {
          if (*(v13 + 24))
          {
            google::protobuf::internal::ExtensionSet::AddBool(v13);
          }

          v14 = google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<BOOL>>;
          goto LABEL_48;
        }
      }

      goto LABEL_49;
    }

    switch(v12)
    {
      case 8:
        v13 = *this;
        if (!v13)
        {
          goto LABEL_49;
        }

        if (*(v13 + 24))
        {
          goto LABEL_42;
        }

        goto LABEL_43;
      case 9:
        v15 = *this;
        if (v15)
        {
          if (*(v15 + 24))
          {
            google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(v15);
          }

          v16 = google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedPtrField<std::string>>;
          goto LABEL_54;
        }

        break;
      case 10:
        v15 = *this;
        if (v15)
        {
          if (*(v15 + 24))
          {
            google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(v15);
          }

          v16 = google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>>;
LABEL_54:
          AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v15, 0x18uLL, v16);
          AlignedAndAddCleanup[2] = 0;
          *AlignedAndAddCleanup = v15;
          AlignedAndAddCleanup[1] = 0;
          goto LABEL_56;
        }

        break;
      default:
        return *v10;
    }

    operator new();
  }

  if (v12 > 2)
  {
    if (v12 == 3)
    {
      v13 = *this;
      if (v13)
      {
        if (*(v13 + 24))
        {
          google::protobuf::internal::ExtensionSet::AddUInt32(v13);
        }

        v14 = google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<unsigned int>>;
        goto LABEL_48;
      }
    }

    else if (v12 == 4)
    {
      v13 = *this;
      if (v13)
      {
        if (*(v13 + 24))
        {
          google::protobuf::internal::ExtensionSet::AddUInt64(v13);
        }

        v14 = google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<unsigned long long>>;
        goto LABEL_48;
      }
    }

    else
    {
      v13 = *this;
      if (v13)
      {
        if (*(v13 + 24))
        {
          google::protobuf::internal::ExtensionSet::AddDouble(v13);
        }

        v14 = google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<double>>;
        goto LABEL_48;
      }
    }

LABEL_49:
    operator new();
  }

  if (v12 == 1)
  {
    v13 = *this;
    if (!v13)
    {
      goto LABEL_49;
    }

    if (*(v13 + 24))
    {
LABEL_42:
      google::protobuf::internal::ExtensionSet::AddInt32(v13);
    }

LABEL_43:
    v14 = google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<int>>;
LABEL_48:
    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v13, 0x10uLL, v14);
    *AlignedAndAddCleanup = 0;
    AlignedAndAddCleanup[1] = v13;
LABEL_56:
    *v10 = AlignedAndAddCleanup;
    return *v10;
  }

  if (v12 == 2)
  {
    v13 = *this;
    if (v13)
    {
      if (*(v13 + 24))
      {
        google::protobuf::internal::ExtensionSet::AddInt64(v13);
      }

      v14 = google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<long long>>;
      goto LABEL_48;
    }

    goto LABEL_49;
  }

  return *v10;
}

void *google::protobuf::internal::ExtensionSet::MutableString(google::protobuf::internal::ExtensionSet *this, int a2, char a3, const FieldDescriptor *a4)
{
  v7 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v8 = v7;
  v7[2] = a4;
  if (v9)
  {
    *(v7 + 8) = a3;
    *(v7 + 9) = 0;
    v10 = *this;
    if (!v10)
    {
      operator new();
    }

    if (*(v10 + 24))
    {
      google::protobuf::internal::ExtensionSet::MutableString(v10);
    }

    result = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v10, 0x18uLL, google::protobuf::internal::arena_destruct_object<std::string>);
    *result = 0;
    result[1] = 0;
    result[2] = 0;
    *v8 = result;
  }

  else
  {
    result = *v7;
  }

  *(v8 + 10) &= 0xF0u;
  return result;
}

void *google::protobuf::internal::ExtensionSet::AddString(google::protobuf::internal::ExtensionSet *this, int a2, char a3, const FieldDescriptor *a4)
{
  v7 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v8 = v7;
  v7[2] = a4;
  if (v9)
  {
    *(v7 + 8) = a3;
    *(v7 + 9) = 1;
    *(v7 + 11) = 0;
    v10 = *this;
    if (!*this)
    {
      operator new();
    }

    if (*(v10 + 24))
    {
      google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(*this);
    }

    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v10, 0x18uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedPtrField<std::string>>);
    AlignedAndAddCleanup[2] = 0;
    *AlignedAndAddCleanup = v10;
    AlignedAndAddCleanup[1] = 0;
    *v8 = AlignedAndAddCleanup;
  }

  else
  {
    AlignedAndAddCleanup = *v7;
  }

  v12 = AlignedAndAddCleanup[2];
  if (!v12)
  {
    v14 = *(AlignedAndAddCleanup + 3);
LABEL_13:
    google::protobuf::internal::RepeatedPtrFieldBase::Reserve(AlignedAndAddCleanup, v14 + 1);
    v12 = AlignedAndAddCleanup[2];
    v14 = *v12;
    goto LABEL_14;
  }

  v13 = *(AlignedAndAddCleanup + 2);
  v14 = *v12;
  if (v13 < *v12)
  {
    *(AlignedAndAddCleanup + 2) = v13 + 1;
    return *&v12[2 * v13 + 2];
  }

  if (v14 == *(AlignedAndAddCleanup + 3))
  {
    goto LABEL_13;
  }

LABEL_14:
  *v12 = v14 + 1;
  v16 = *AlignedAndAddCleanup;
  if (!*AlignedAndAddCleanup)
  {
    operator new();
  }

  if (*(v16 + 24))
  {
    google::protobuf::internal::ExtensionSet::MutableString(*AlignedAndAddCleanup);
  }

  result = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v16, 0x18uLL, google::protobuf::internal::arena_destruct_object<std::string>);
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  v17 = *(AlignedAndAddCleanup + 2);
  v18 = AlignedAndAddCleanup[2] + 8 * v17;
  *(AlignedAndAddCleanup + 2) = v17 + 1;
  *(v18 + 8) = result;
  return result;
}

uint64_t google::protobuf::internal::ExtensionSet::MutableMessage(google::protobuf::internal::ExtensionSet *this, int a2, char a3, const google::protobuf::MessageLite *a4, const FieldDescriptor *a5)
{
  v9 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v10 = v9;
  v9[2] = a5;
  if (v11)
  {
    *(v9 + 8) = a3;
    *(v9 + 9) = 0;
    *(v9 + 10) &= 0xFu;
    result = (*(*a4 + 32))(a4, *this);
    *v10 = result;
    *(v10 + 10) &= 0xF0u;
  }

  else
  {
    v13 = *(v9 + 10);
    *(v9 + 10) = v13 & 0xF0;
    result = *v9;
    if ((v13 & 0x10) != 0)
    {
      v14 = *(*result + 32);

      return v14();
    }
  }

  return result;
}

uint64_t google::protobuf::internal::ExtensionSet::AddMessage(google::protobuf::internal::ExtensionSet *this, int a2, char a3, const google::protobuf::MessageLite *a4, const FieldDescriptor *a5)
{
  v9 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v10 = v9;
  v9[2] = a5;
  if (v11)
  {
    *(v9 + 8) = a3;
    *(v9 + 9) = 1;
    v12 = *this;
    if (!*this)
    {
      operator new();
    }

    if (*(v12 + 24))
    {
      google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(*this);
    }

    AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v12, 0x18uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>>);
    *(AlignedAndAddCleanup + 2) = 0;
    *AlignedAndAddCleanup = v12;
    *(AlignedAndAddCleanup + 1) = 0;
    *v10 = AlignedAndAddCleanup;
  }

  else
  {
    AlignedAndAddCleanup = *v9;
  }

  v14 = *(AlignedAndAddCleanup + 2);
  if (!v14 || (v15 = AlignedAndAddCleanup[2], v15 >= *v14) || (AlignedAndAddCleanup[2] = v15 + 1, (v16 = *&v14[2 * v15 + 2]) == 0))
  {
    v16 = (*(*a4 + 32))(a4, *this);
    google::protobuf::internal::RepeatedPtrFieldBase::AddAllocatedInternal<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>::TypeHandler>(*v10, v16);
  }

  return v16;
}

unsigned __int8 *google::protobuf::internal::ExtensionSet::Clear(unsigned __int8 *this)
{
  v2 = *(this + 2);
  if (*(this + 4) >= 0x101u)
  {
    v7 = *v2;
    v6 = (v2 + 1);
    v5 = v7;

    return google::protobuf::internal::ExtensionSet::ForEach<std::__map_iterator<std::__tree_iterator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__tree_node<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,void *> *,long>>,google::protobuf::internal::ExtensionSet::Clear(void)::$_0>(v5, v6);
  }

  else if (*(this + 5))
  {
    v3 = 32 * *(this + 5);
    v4 = (v2 + 1);
    do
    {
      this = google::protobuf::internal::ExtensionSet::Extension::Clear(v4);
      v4 += 32;
      v3 -= 32;
    }

    while (v3);
  }

  return this;
}

uint64_t google::protobuf::internal::ExtensionSet::GrowCapacity(uint64_t this, size_t __sz)
{
  v2 = *(this + 8);
  if (v2 <= 0x100 && v2 < __sz)
  {
    v4 = this;
    do
    {
      if (v2)
      {
        LOWORD(v2) = 4 * v2;
      }

      else
      {
        LOWORD(v2) = 1;
      }
    }

    while (v2 < __sz);
    v5 = *(this + 16);
    v6 = *(this + 10);
    v7 = *this;
    if (v2 < 0x101u)
    {
      v8 = 32 * v2;
      if (v7)
      {
        if (*(v7 + 24))
        {
          google::protobuf::internal::ExtensionSet::GrowCapacity(*this);
          v8 = 32 * v2;
        }

        this = google::protobuf::Arena::AllocateAlignedNoHook(v7, v8);
      }

      else
      {
        this = operator new[](32 * v2);
      }

      v9 = this;
      if (v6)
      {
        this = memmove(this, v5, 32 * v6);
      }
    }

    else
    {
      if (!v7)
      {
        operator new();
      }

      if (*(v7 + 24))
      {
        google::protobuf::internal::ExtensionSet::GrowCapacity(*this);
      }

      this = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v7, 0x18uLL, google::protobuf::internal::arena_destruct_object<std::map<int,google::protobuf::internal::ExtensionSet::Extension>>);
      v9 = this;
      *(this + 8) = 0;
      v10 = (this + 8);
      *(this + 16) = 0;
      *this = this + 8;
      if (v6)
      {
        v11 = &v5[32 * v6];
        v12 = v5;
        do
        {
          v15 = *v12;
          v13 = *(v12 + 3);
          v16 = *(v12 + 8);
          v17 = v13;
          this = std::__tree<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__map_value_compare<int,std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::less<int>,true>,std::allocator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>>>::__emplace_hint_unique_key_args<int,std::pair<int const,google::protobuf::internal::ExtensionSet::Extension>>(v9, v10, &v15);
          v10 = this;
          v12 += 32;
        }

        while (v12 != v11);
      }
    }

    if (*v4)
    {
      v14 = 1;
    }

    else
    {
      v14 = v5 == 0;
    }

    if (!v14)
    {
      this = MEMORY[0x1B8C85310](v5, 0x1062C802AB6010CLL);
    }

    *(v4 + 8) = v2;
    *(v4 + 16) = v9;
    if (v2 >= 0x101u)
    {
      *(v4 + 10) = 0;
    }
  }

  return this;
}

uint64_t google::protobuf::internal::anonymous namespace::SizeOfUnion<google::protobuf::internal::ExtensionSet::KeyValue *,std::__map_iterator<std::__tree_iterator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__tree_node<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,void *> *,long>>>(char *a1, char *a2, void *a3, void *a4)
{
  v4 = 0;
  if (a1 != a2 && a3 != a4)
  {
    v4 = 0;
    do
    {
      v5 = *(a3 + 8);
      if (*a1 >= v5)
      {
        if (*a1 == v5)
        {
          a1 += 32;
          v6 = a3[1];
          if (v6)
          {
            do
            {
              a3 = v6;
              v6 = *v6;
            }

            while (v6);
          }

          else
          {
            do
            {
              v7 = a3;
              a3 = a3[2];
            }

            while (*a3 != v7);
          }
        }

        else
        {
          v8 = a3[1];
          if (v8)
          {
            do
            {
              a3 = v8;
              v8 = *v8;
            }

            while (v8);
          }

          else
          {
            do
            {
              v9 = a3;
              a3 = a3[2];
            }

            while (*a3 != v9);
          }
        }
      }

      else
      {
        a1 += 32;
      }

      ++v4;
    }

    while (a1 != a2 && a3 != a4);
  }

  if (a3 == a4)
  {
    v10 = 0;
  }

  else
  {
    v10 = 0;
    do
    {
      v11 = a3[1];
      if (v11)
      {
        do
        {
          v12 = v11;
          v11 = *v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          v12 = a3[2];
          v13 = *v12 == a3;
          a3 = v12;
        }

        while (!v13);
      }

      ++v10;
      a3 = v12;
    }

    while (v12 != a4);
  }

  return v4 + ((a2 - a1) >> 5) + v10;
}

void google::protobuf::internal::ExtensionSet::InternalExtensionMergeFrom(google::protobuf::internal::ExtensionSet *this, int a2, int **a3)
{
  if (*(a3 + 9) != 1)
  {
    if (*(a3 + 10))
    {
      return;
    }

    v14 = *(a3 + 8);
    v15 = google::protobuf::internal::WireFormatLite::kFieldTypeToCppTypeMap[v14];
    if (v15 <= 5)
    {
      if (v15 <= 2)
      {
        if (v15 != 1)
        {
          if (v15 != 2)
          {
            return;
          }

LABEL_52:
          v32 = *a3;
          v33 = a3[2];
          v34 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
          v34[2] = v33;
          if (v35)
          {
            *(v34 + 8) = v14;
            *(v34 + 9) = 0;
          }

          *(v34 + 10) &= 0xF0u;
          *v34 = v32;
          return;
        }
      }

      else if (v15 != 3)
      {
        if (v15 != 4)
        {
          v16 = *a3;
          v17 = a3[2];
          v18 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
          v18[2] = v17;
          if (v19)
          {
            *(v18 + 8) = v14;
            *(v18 + 9) = 0;
          }

          *(v18 + 10) &= 0xF0u;
          *v18 = v16;
          return;
        }

        goto LABEL_52;
      }

LABEL_55:
      v36 = *a3;
      v37 = a3[2];
      v38 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
      v38[2] = v37;
      if (v39)
      {
        *(v38 + 8) = v14;
        *(v38 + 9) = 0;
      }

      *(v38 + 10) &= 0xF0u;
      *v38 = v36;
      return;
    }

    if (v15 <= 7)
    {
      if (v15 == 6)
      {
        v54 = *a3;
        v55 = a3[2];
        v56 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
        v56[2] = v55;
        if (v57)
        {
          *(v56 + 8) = v14;
          *(v56 + 9) = 0;
        }

        *(v56 + 10) &= 0xF0u;
        *v56 = v54;
      }

      else
      {
        v40 = *a3;
        v41 = a3[2];
        v42 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
        v42[2] = v41;
        if (v43)
        {
          *(v42 + 8) = v14;
          *(v42 + 9) = 0;
        }

        *(v42 + 10) &= 0xF0u;
        *v42 = v40;
      }

      return;
    }

    if (v15 == 8)
    {
      goto LABEL_55;
    }

    if (v15 == 9)
    {
      v58 = *a3;
      if (*(*a3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v99, *v58, *(v58 + 1));
      }

      else
      {
        v59 = *v58;
        v99.__r_.__value_.__r.__words[2] = *(v58 + 2);
        *&v99.__r_.__value_.__l.__data_ = v59;
      }

      v95 = google::protobuf::internal::ExtensionSet::MutableString(this, a2, v14, a3[2]);
      v96 = v95;
      if (*(v95 + 23) < 0)
      {
        operator delete(*v95);
      }

      v97 = *&v99.__r_.__value_.__l.__data_;
      v96[2] = v99.__r_.__value_.__r.__words[2];
      *v96 = v97;
      return;
    }

    if (v15 != 10)
    {
      return;
    }

    v22 = a3[2];
    v23 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
    v24 = v23;
    v23[2] = v22;
    if (v25)
    {
      *(v23 + 8) = *(a3 + 8);
      *(v23 + 11) = *(a3 + 11);
      *(v23 + 9) = 0;
      v26 = *(v23 + 10) & 0xF;
      if ((*(a3 + 10) & 0x10) != 0)
      {
        *(v23 + 10) = v26 | 0x10;
        v98 = (*(**a3 + 16))(*a3, *this);
        *v24 = v98;
        (*(*v98 + 104))(v98, *a3);
        goto LABEL_146;
      }

      *(v23 + 10) = v26;
      v27 = (*(**a3 + 32))(*a3, *this);
      *v24 = v27;
LABEL_102:
      (*(*v27 + 64))(v27, *a3);
LABEL_146:
      *(v24 + 10) &= 0xF0u;
      return;
    }

    v62 = *v23;
    v63 = *a3;
    if ((*(a3 + 10) & 0x10) != 0)
    {
      if ((*(v23 + 10) & 0x10) != 0)
      {
        (*(*v62 + 104))(*v23, v63);
        goto LABEL_146;
      }

      v63 = (*(*v63 + 24))(*a3, *v23);
      v64 = *v62;
    }

    else
    {
      v64 = *v62;
      if ((*(v23 + 10) & 0x10) != 0)
      {
        v27 = (*(v64 + 32))(*v23, v63);
        goto LABEL_102;
      }
    }

    (*(v64 + 64))(v62, v63);
    goto LABEL_146;
  }

  v6 = a3[2];
  v7 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
  v9 = v7;
  v7[2] = v6;
  v10 = *(a3 + 8);
  if (v8)
  {
    *(v7 + 8) = v10;
    *(v7 + 11) = *(a3 + 11);
    *(v7 + 9) = 1;
  }

  v11 = google::protobuf::internal::WireFormatLite::kFieldTypeToCppTypeMap[v10];
  if (v11 > 5)
  {
    if (v11 <= 7)
    {
      if (v11 != 6)
      {
        if (v8)
        {
          v30 = *this;
          if (!v30)
          {
            operator new();
          }

          if (*(v30 + 24))
          {
            google::protobuf::internal::ExtensionSet::AddBool(v30);
          }

          AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v30, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<BOOL>>);
          *AlignedAndAddCleanup = 0;
          *(AlignedAndAddCleanup + 1) = v30;
          *v9 = AlignedAndAddCleanup;
        }

        v67 = *a3;
        v68 = **a3;
        if (!v68)
        {
          return;
        }

        v69 = *v9;
        v70 = **v9;
        google::protobuf::RepeatedField<BOOL>::Reserve(v69, v70 + v68);
        v71 = *(v69 + 1);
        *v69 += *v67;
        v72 = *(v67 + 1);
        v73 = *v67;
        v74 = (v71 + v70);
LABEL_130:

        memcpy(v74, v72, v73);
        return;
      }

      if (v8)
      {
        v45 = *this;
        if (!v45)
        {
          operator new();
        }

        if (*(v45 + 24))
        {
          google::protobuf::internal::ExtensionSet::AddFloat(v45);
        }

        v46 = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v45, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<float>>);
        *v46 = 0;
        *(v46 + 1) = v45;
        *v9 = v46;
      }

      v60 = *a3;
      v61 = **a3;
      if (!v61)
      {
        return;
      }

LABEL_114:
      v75 = *v9;
      v76 = **v9;
      google::protobuf::RepeatedField<int>::Reserve(v75, v76 + v61);
      v77 = *(v75 + 1);
      *v75 += *v60;
      v74 = (v77 + 4 * v76);
      v72 = *(v60 + 1);
      v73 = 4 * *v60;
      goto LABEL_130;
    }

    if (v11 != 8)
    {
      if (v11 == 9)
      {
        if (v8)
        {
          v52 = *this;
          if (!v52)
          {
            operator new();
          }

          if (*(v52 + 24))
          {
            google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(v52);
          }

          v53 = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v52, 0x18uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedPtrField<std::string>>);
          *(v53 + 2) = 0;
          *v53 = v52;
          *(v53 + 1) = 0;
          *v9 = v53;
        }

        v88 = *a3;
        v89 = (*a3)[2];
        if (v89)
        {
          v90 = *v9;
          v91 = *(v88 + 2);
          v92 = google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend(v90, v89);
          google::protobuf::internal::RepeatedPtrFieldBase::MergeFromInnerLoop<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(v90, v92, (v91 + 8), v89, **(v90 + 2) - v90[2]);
          v93 = v90[2] + v89;
          v90[2] = v93;
          v94 = *(v90 + 2);
          if (*v94 < v93)
          {
            *v94 = v93;
          }
        }
      }

      else if (v11 == 10)
      {
        if (v8)
        {
          v20 = *this;
          if (!*this)
          {
            operator new();
          }

          if (*(v20 + 24))
          {
            google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(*this);
          }

          v21 = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v20, 0x18uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>>);
          *(v21 + 2) = 0;
          *v21 = v20;
          *(v21 + 1) = 0;
          *v9 = v21;
        }

        v78 = *a3;
        if ((*a3)[2] >= 1)
        {
          v79 = 0;
          do
          {
            v80 = *(*(v78 + 2) + 8 * v79 + 8);
            v81 = *v9;
            v82 = *(*v9 + 2);
            if (!v82 || (v83 = v81[2], v83 >= *v82) || (v81[2] = v83 + 1, (v84 = *&v82[2 * v83 + 2]) == 0))
            {
              v84 = (*(*v80 + 32))(v80, *this);
              google::protobuf::internal::RepeatedPtrFieldBase::AddAllocatedInternal<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>::TypeHandler>(*v9, v84);
            }

            (*(*v84 + 64))(v84, v80);
            ++v79;
          }

          while (v79 < v78[2]);
        }
      }

      return;
    }

    if ((v8 & 1) == 0)
    {
LABEL_97:
      v60 = *a3;
      v61 = **a3;
      if (!v61)
      {
        return;
      }

      goto LABEL_114;
    }

    v44 = *this;
    if (v44)
    {
      if (*(v44 + 24))
      {
LABEL_79:
        google::protobuf::internal::ExtensionSet::AddInt32(v44);
      }

LABEL_80:
      v49 = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v44, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<int>>);
      *v49 = 0;
      *(v49 + 1) = v44;
      *v9 = v49;
      goto LABEL_97;
    }

LABEL_96:
    operator new();
  }

  if (v11 <= 2)
  {
    if (v11 != 1)
    {
      if (v11 == 2)
      {
        if (v8)
        {
          v28 = *this;
          if (!v28)
          {
            operator new();
          }

          if (*(v28 + 24))
          {
            google::protobuf::internal::ExtensionSet::AddInt64(v28);
          }

          v29 = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v28, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<long long>>);
          *v29 = 0;
          *(v29 + 1) = v28;
          *v9 = v29;
        }

        v65 = *a3;
        v66 = **a3;
        if (v66)
        {
          goto LABEL_129;
        }
      }

      return;
    }

    if ((v8 & 1) == 0)
    {
      goto LABEL_97;
    }

    v44 = *this;
    if (v44)
    {
      if (*(v44 + 24))
      {
        goto LABEL_79;
      }

      goto LABEL_80;
    }

    goto LABEL_96;
  }

  if (v11 == 3)
  {
    if (v8)
    {
      v47 = *this;
      if (!v47)
      {
        operator new();
      }

      if (*(v47 + 24))
      {
        google::protobuf::internal::ExtensionSet::AddUInt32(v47);
      }

      v48 = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v47, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<unsigned int>>);
      *v48 = 0;
      *(v48 + 1) = v47;
      *v9 = v48;
    }

    v60 = *a3;
    v61 = **a3;
    if (!v61)
    {
      return;
    }

    goto LABEL_114;
  }

  if (v11 == 4)
  {
    if (v8)
    {
      v50 = *this;
      if (!v50)
      {
        operator new();
      }

      if (*(v50 + 24))
      {
        google::protobuf::internal::ExtensionSet::AddUInt64(v50);
      }

      v51 = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v50, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<unsigned long long>>);
      *v51 = 0;
      *(v51 + 1) = v50;
      *v9 = v51;
    }

    v65 = *a3;
    v66 = **a3;
    if (v66)
    {
      goto LABEL_129;
    }
  }

  else
  {
    if (v8)
    {
      v12 = *this;
      if (!v12)
      {
        operator new();
      }

      if (*(v12 + 24))
      {
        google::protobuf::internal::ExtensionSet::AddDouble(v12);
      }

      v13 = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(v12, 0x10uLL, google::protobuf::internal::arena_destruct_object<google::protobuf::RepeatedField<double>>);
      *v13 = 0;
      *(v13 + 1) = v12;
      *v9 = v13;
    }

    v65 = *a3;
    v66 = **a3;
    if (v66)
    {
LABEL_129:
      v85 = *v9;
      v86 = **v9;
      google::protobuf::RepeatedField<long long>::Reserve(v85, v86 + v66);
      v87 = *(v85 + 1);
      *v85 += *v65;
      v74 = (v87 + 8 * v86);
      v72 = *(v65 + 1);
      v73 = 8 * *v65;
      goto LABEL_130;
    }
  }
}

void sub_1B5AC7F58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void google::protobuf::internal::ExtensionSet::Swap(google::protobuf::internal::ExtensionSet *this, google::protobuf::internal::ExtensionSet *a2)
{
  if (*this == *a2)
  {
    v4 = *(this + 4);
    *(this + 4) = *(a2 + 4);
    *(a2 + 4) = v4;
    v5 = *(this + 5);
    *(this + 5) = *(a2 + 5);
    *(a2 + 5) = v5;
    v6 = *(this + 2);
    *(this + 2) = *(a2 + 2);
    *(a2 + 2) = v6;
  }

  else
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    google::protobuf::internal::ExtensionSet::MergeFrom(&v7, a2);
    google::protobuf::internal::ExtensionSet::Clear(a2);
    google::protobuf::internal::ExtensionSet::MergeFrom(a2, this);
    google::protobuf::internal::ExtensionSet::Clear(this);
    google::protobuf::internal::ExtensionSet::MergeFrom(this, &v7);
    google::protobuf::internal::ExtensionSet::~ExtensionSet(&v7);
  }
}

void sub_1B5AC802C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  google::protobuf::internal::ExtensionSet::~ExtensionSet(va);
  _Unwind_Resume(a1);
}

uint64_t *google::protobuf::internal::ExtensionSet::Insert(google::protobuf::internal::ExtensionSet *this, int a2)
{
  v3 = *(this + 4);
  v4 = *(this + 2);
  if (v3 >= 0x101)
  {
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v14 = a2;
    return std::__tree<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__map_value_compare<int,std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::less<int>,true>,std::allocator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>>>::__emplace_unique_key_args<int,std::pair<int const,google::protobuf::internal::ExtensionSet::Extension>>(v4, &v14) + 5;
  }

  else
  {
    v6 = *(this + 5);
    v7 = &v4[32 * v6];
    if (*(this + 5))
    {
      v8 = *(this + 5);
      do
      {
        v9 = v8 >> 1;
        v10 = &v4[32 * (v8 >> 1)];
        v12 = *v10;
        v11 = (v10 + 8);
        v8 += ~(v8 >> 1);
        if (v12 < a2)
        {
          v4 = v11;
        }

        else
        {
          v8 = v9;
        }
      }

      while (v8);
    }

    if (v4 == v7)
    {
      if (v6 < v3)
      {
LABEL_15:
        *(this + 5) = v6 + 1;
        *v4 = a2;
        *(v4 + 1) = 0;
        result = (v4 + 8);
        *(v4 + 2) = 0;
        *(v4 + 3) = 0;
        return result;
      }
    }

    else
    {
      if (*v4 == a2)
      {
        return (v4 + 8);
      }

      if (v6 < v3)
      {
        memmove(v4 + 32, v4, v7 - v4);
        LOWORD(v6) = *(this + 5);
        goto LABEL_15;
      }
    }

    google::protobuf::internal::ExtensionSet::GrowCapacity(this, v6 + 1);
    return google::protobuf::internal::ExtensionSet::Insert(this, a2);
  }
}

uint64_t google::protobuf::internal::ExtensionSet::IsInitialized(google::protobuf::internal::ExtensionSet *this)
{
  if (*(this + 4) < 0x101u)
  {
    if (*(this + 5))
    {
      v2 = *(this + 2);
      do
      {
        result = google::protobuf::internal::ExtensionSet::Extension::IsInitialized((v2 + 8));
        if ((result & 1) == 0)
        {
          break;
        }

        v2 += 32;
      }

      while (v2 != *(this + 2) + 32 * *(this + 5));
      return result;
    }

    return 1;
  }

  v4 = *(this + 2);
  v7 = *v4;
  v5 = (v4 + 1);
  v6 = v7;
  if (v7 == v5)
  {
    return 1;
  }

  do
  {
    result = google::protobuf::internal::ExtensionSet::Extension::IsInitialized(v6 + 5);
    if (!result)
    {
      break;
    }

    v8 = v6[1];
    if (v8)
    {
      do
      {
        v9 = v8;
        v8 = *v8;
      }

      while (v8);
    }

    else
    {
      do
      {
        v9 = v6[2];
        v10 = *v9 == v6;
        v6 = v9;
      }

      while (!v10);
    }

    v6 = v9;
  }

  while (v9 != v5);
  return result;
}

uint64_t google::protobuf::internal::ExtensionSet::Extension::IsInitialized(uint64_t **this)
{
  if (google::protobuf::internal::WireFormatLite::kFieldTypeToCppTypeMap[*(this + 8)] != 10)
  {
    return 1;
  }

  if (*(this + 9) == 1)
  {
    v2 = *this;
    if (*(*this + 2) >= 1)
    {
      v3 = 0;
      while (1)
      {
        v4 = *(v2[2] + 8 * v3 + 8);
        if (((*(*v4 + 48))(v4) & 1) == 0)
        {
          break;
        }

        ++v3;
        v2 = *this;
        if (v3 >= *(*this + 2))
        {
          return 1;
        }
      }

      return 0;
    }

    return 1;
  }

  if (*(this + 10))
  {
    return 1;
  }

  v6 = **this;
  if ((*(this + 10) & 0x10) != 0)
  {
    return ((*(v6 + 72))() & 1) != 0;
  }

  result = (*(v6 + 48))();
  if (result)
  {
    return 1;
  }

  return result;
}

uint64_t google::protobuf::internal::ExtensionSet::FindExtensionInfoFromFieldNumber(uint64_t a1, int a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, _BYTE *a6)
{
  result = (*(*a4 + 16))(a4, a3, a5);
  if (result)
  {
    v10 = google::protobuf::internal::WireFormatLite::kWireTypeForFieldType[*a5];
    *a6 = 0;
    if (a2 == 2 && (a5[1] & 1) != 0)
    {
      if (v10 > 5)
      {
        google::protobuf::internal::LogMessage::LogMessage(v13, 3, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/third_party/protobuf-lite/extension_set.cc", 82);
        v11 = google::protobuf::internal::LogMessage::operator<<(v13, "can't reach here.");
        google::protobuf::internal::LogFinisher::operator=(&v12, &v11->__r_.__value_.__l.__data_);
        google::protobuf::internal::LogMessage::~LogMessage(&v13[0].__r_.__value_.__l.__data_);
      }

      else
      {
        result = 1;
        if (((1 << v10) & 0x1C) == 0)
        {
          *a6 = 1;
          return result;
        }
      }
    }

    return v10 == a2;
  }

  return result;
}

void sub_1B5AC8424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  google::protobuf::internal::LogMessage::~LogMessage(va);
  _Unwind_Resume(a1);
}

char *google::protobuf::internal::ExtensionSet::ParseField(google::protobuf::internal::ExtensionSet *a1, unint64_t a2, google::protobuf::internal *a3, uint64_t a4, unint64_t *a5, int32x2_t *a6)
{
  v9 = a2;
  v16[0] = &unk_1F2D441D0;
  v16[1] = a4;
  v11 = a2 >> 3;
  v15 = 0;
  if (google::protobuf::internal::ExtensionSet::FindExtensionInfoFromFieldNumber(a1, a2 & 7, a2 >> 3, v16, v14, &v15))
  {
    return google::protobuf::internal::ExtensionSet::ParseFieldWithExtensionInfo<std::string>(a1, v11, v15, v14, a5, a3, a6);
  }

  if (*a5)
  {
    v13 = ((*a5 & 0xFFFFFFFFFFFFFFFELL) + 8);
  }

  else
  {
    v13 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(a5);
  }

  return google::protobuf::internal::UnknownFieldParse(v9, v13, a3, a6);
}

char *google::protobuf::internal::ExtensionSet::ParseFieldWithExtensionInfo<std::string>(google::protobuf::internal::ExtensionSet *this, int a2, int a3, uint64_t a4, unint64_t *a5, google::protobuf::internal *a6, int32x2_t *a7)
{
  v8 = a6;
  v11 = a2;
  v12 = this;
  if (a3)
  {
    switch(*a4)
    {
      case 1:
        v43 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 1, *(a4 + 2), *(a4 + 24));
        v45 = v8;
        v46 = a7;

        goto LABEL_39;
      case 2:
        v19 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 2, *(a4 + 2), *(a4 + 24));
        v21 = v8;
        v22 = a7;

        goto LABEL_15;
      case 3:
        v39 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 3, *(a4 + 2), *(a4 + 24));
        v40 = v8;
        v41 = a7;

        return google::protobuf::internal::PackedInt64Parser(v39, v40, v41);
      case 4:
        v39 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 4, *(a4 + 2), *(a4 + 24));
        v40 = v8;
        v41 = a7;

        return google::protobuf::internal::PackedInt64Parser(v39, v40, v41);
      case 5:
        v31 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 5, *(a4 + 2), *(a4 + 24));
        v32 = v8;
        v33 = a7;

        goto LABEL_22;
      case 6:
        v43 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 6, *(a4 + 2), *(a4 + 24));
        v45 = v8;
        v46 = a7;

        goto LABEL_39;
      case 7:
        v19 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 7, *(a4 + 2), *(a4 + 24));
        v21 = v8;
        v22 = a7;

        goto LABEL_15;
      case 8:
        v50 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 8, *(a4 + 2), *(a4 + 24));

        return google::protobuf::internal::PackedBoolParser(v50, v8, a7);
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        google::protobuf::internal::LogMessage::LogMessage(&v125, 3, "third_party/protobuf-lite/google/protobuf/extension_set_inl.h", 79);
        v13 = google::protobuf::internal::LogMessage::operator<<(&v125, "Non-primitive types can't be packed.");
        google::protobuf::internal::LogFinisher::operator=(&v124, &v13->__r_.__value_.__l.__data_);
        google::protobuf::internal::LogMessage::~LogMessage(&v125.__r_.__value_.__l.__data_);
        goto LABEL_189;
      case 0xD:
        v31 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 13, *(a4 + 2), *(a4 + 24));
        v32 = v8;
        v33 = a7;

LABEL_22:
        result = google::protobuf::internal::PackedInt32Parser(v31, v32, v33);
        break;
      case 0xE:
        v125.__r_.__value_.__r.__words[0] = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 14, *(a4 + 2), *(a4 + 24));
        *&v125.__r_.__value_.__r.__words[1] = *(a4 + 8);
        v126 = a5;
        v127 = v11;
        v8 = google::protobuf::internal::EpsCopyInputStream::ReadPackedVarint<char const* google::protobuf::internal::PackedEnumParserArg<std::string>(void *,char const*,google::protobuf::internal::ParseContext *,BOOL (*)(void const*,int),void const*,google::protobuf::internal::InternalMetadata *,int)::{lambda(unsigned long long)#1}>(a7, v8, &v125);
        goto LABEL_189;
      case 0xF:
        v19 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 15, *(a4 + 2), *(a4 + 24));
        v21 = v8;
        v22 = a7;

LABEL_15:
        result = google::protobuf::internal::PackedFixed32Parser(v19, v21, v22, v20);
        break;
      case 0x10:
        v43 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 16, *(a4 + 2), *(a4 + 24));
        v45 = v8;
        v46 = a7;

LABEL_39:
        result = google::protobuf::internal::PackedFixed64Parser(v43, v45, v46, v44);
        break;
      case 0x11:
        v16 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 17, *(a4 + 2), *(a4 + 24));

        result = google::protobuf::internal::PackedSInt32Parser(v16, v8, a7);
        break;
      case 0x12:
        v54 = google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(this, a2, 18, *(a4 + 2), *(a4 + 24));

        result = google::protobuf::internal::PackedSInt64Parser(v54, v8, a7);
        break;
      default:
        goto LABEL_189;
    }
  }

  else
  {
    switch(*a4)
    {
      case 1:
        v8 = (a6 + 8);
        v52 = *a6;
        if (*(a4 + 1) == 1)
        {
          google::protobuf::internal::ExtensionSet::AddDouble(this, a2, 1, *(a4 + 2), v52, *(a4 + 24));
        }

        else
        {
          v77 = *(a4 + 24);
          v78 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
          v78[2] = v77;
          if (v79)
          {
            *(v78 + 4) = 1;
          }

          *(v78 + 10) &= 0xF0u;
          *v78 = v52;
        }

        goto LABEL_189;
      case 2:
        v8 = (a6 + 4);
        v53 = *a6;
        if (*(a4 + 1) == 1)
        {
          google::protobuf::internal::ExtensionSet::AddFloat(this, a2, 2, *(a4 + 2), v53, *(a4 + 24));
        }

        else
        {
          v80 = *(a4 + 24);
          v81 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
          v81[2] = v80;
          if (v82)
          {
            *(v81 + 4) = 2;
          }

          *(v81 + 10) &= 0xF0u;
          *v81 = v53;
        }

        goto LABEL_189;
      case 3:
        v42 = *a6;
        if (v42 < 0)
        {
          v93 = (*(a6 + 1) << 7) + v42;
          v42 = (v93 - 128);
          if (*(a6 + 1) < 0)
          {
            v8 = google::protobuf::internal::VarintParseSlow64(a6, (v93 - 128));
            if (!v8)
            {
              goto LABEL_189;
            }

            v42 = v108;
          }

          else
          {
            v8 = (a6 + 2);
          }
        }

        else
        {
          v8 = (a6 + 1);
        }

        if (*(a4 + 1) == 1)
        {
          v47 = *(a4 + 2);
          v48 = *(a4 + 24);
          this = v12;
          a2 = v11;
          v49 = 3;
          goto LABEL_172;
        }

        v109 = *(a4 + 24);
        v74 = google::protobuf::internal::ExtensionSet::Insert(v12, v11);
        v74[2] = v109;
        if ((v110 & 1) == 0)
        {
          goto LABEL_176;
        }

        v76 = 3;
        goto LABEL_175;
      case 4:
        v42 = *a6;
        if (v42 < 0)
        {
          v94 = (*(a6 + 1) << 7) + v42;
          v42 = (v94 - 128);
          if (*(a6 + 1) < 0)
          {
            v8 = google::protobuf::internal::VarintParseSlow64(a6, (v94 - 128));
            if (!v8)
            {
              goto LABEL_189;
            }

            v42 = v111;
          }

          else
          {
            v8 = (a6 + 2);
          }
        }

        else
        {
          v8 = (a6 + 1);
        }

        if (*(a4 + 1) == 1)
        {
          v56 = *(a4 + 2);
          v57 = *(a4 + 24);
          this = v12;
          a2 = v11;
          v58 = 4;
          goto LABEL_159;
        }

        v112 = *(a4 + 24);
        v74 = google::protobuf::internal::ExtensionSet::Insert(v12, v11);
        v74[2] = v112;
        if ((v113 & 1) == 0)
        {
          goto LABEL_176;
        }

        v76 = 4;
        goto LABEL_175;
      case 5:
        v34 = *a6;
        if ((v34 & 0x8000000000000000) != 0)
        {
          v92 = (*(a6 + 1) << 7) + v34;
          LODWORD(v34) = v92 - 128;
          if (*(a6 + 1) < 0)
          {
            v8 = google::protobuf::internal::VarintParseSlow64(a6, (v92 - 128));
            if (!v8)
            {
              goto LABEL_189;
            }

            LODWORD(v34) = v105;
          }

          else
          {
            v8 = (a6 + 2);
          }
        }

        else
        {
          v8 = (a6 + 1);
        }

        if (*(a4 + 1) == 1)
        {
          v24 = *(a4 + 2);
          v25 = *(a4 + 24);
          this = v12;
          a2 = v11;
          v26 = 5;
          v97 = v34;
          goto LABEL_146;
        }

        v106 = *(a4 + 24);
        v102 = google::protobuf::internal::ExtensionSet::Insert(v12, v11);
        v102[2] = v106;
        if ((v107 & 1) == 0)
        {
          goto LABEL_188;
        }

        v104 = 5;
        goto LABEL_187;
      case 6:
        v8 = (a6 + 8);
        v42 = *a6;
        if (*(a4 + 1) == 1)
        {
          v56 = *(a4 + 2);
          v57 = *(a4 + 24);
          v58 = 6;
LABEL_159:
          google::protobuf::internal::ExtensionSet::AddUInt64(this, a2, v58, v56, v42, v57);
          goto LABEL_189;
        }

        v83 = *(a4 + 24);
        v74 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
        v74[2] = v83;
        if ((v84 & 1) == 0)
        {
          goto LABEL_176;
        }

        v76 = 6;
        goto LABEL_175;
      case 7:
        v8 = (a6 + 4);
        v23 = *a6;
        if (*(a4 + 1) == 1)
        {
          v63 = *(a4 + 2);
          v64 = *(a4 + 24);
          v65 = 7;
          v66 = v23;
          goto LABEL_139;
        }

        v89 = *(a4 + 24);
        v70 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
        v70[2] = v89;
        if ((v90 & 1) == 0)
        {
          goto LABEL_134;
        }

        v72 = 7;
        goto LABEL_133;
      case 8:
        v51 = *a6;
        if (v51 < 0)
        {
          v95 = (*(a6 + 1) << 7) + v51;
          v51 = (v95 - 128);
          if (*(a6 + 1) < 0)
          {
            v8 = google::protobuf::internal::VarintParseSlow64(a6, (v95 - 128));
            if (!v8)
            {
              goto LABEL_189;
            }

            v51 = v114;
          }

          else
          {
            v8 = (a6 + 2);
          }
        }

        else
        {
          v8 = (a6 + 1);
        }

        if (*(a4 + 1) == 1)
        {
          google::protobuf::internal::ExtensionSet::AddBool(v12, v11, 8, *(a4 + 2), v51 != 0, *(a4 + 24));
        }

        else
        {
          v115 = *(a4 + 24);
          v116 = google::protobuf::internal::ExtensionSet::Insert(v12, v11);
          v116[2] = v115;
          if (v117)
          {
            *(v116 + 4) = 8;
          }

          *(v116 + 10) &= 0xF0u;
          *v116 = v51 != 0;
        }

        goto LABEL_189;
      case 9:
      case 0xC:
        v14 = *(a4 + 1);
        v15 = *(a4 + 24);
        if (v14 == 1)
        {
          v35 = google::protobuf::internal::ExtensionSet::AddString(this, a2, 9, v15);
        }

        else
        {
          v35 = google::protobuf::internal::ExtensionSet::MutableString(this, a2, 9, v15);
        }

        v36 = v35;
        v37 = *v8;
        if (*v8 < 0)
        {
          SizeFallback = google::protobuf::internal::ReadSizeFallback(v8, *v8);
          if (!SizeFallback)
          {
LABEL_108:
            v8 = 0;
            goto LABEL_189;
          }

          v38 = SizeFallback;
          v37 = v68;
        }

        else
        {
          v38 = v8 + 1;
        }

        return google::protobuf::internal::EpsCopyInputStream::ReadString(a7, v38, v37, v36);
      case 0xA:
        v59 = *(a4 + 1);
        v60 = *(a4 + 8);
        v61 = *(a4 + 24);
        if (v59 == 1)
        {
          v62 = google::protobuf::internal::ExtensionSet::AddMessage(this, a2, 10, v60, v61);
        }

        else
        {
          v62 = google::protobuf::internal::ExtensionSet::MutableMessage(this, a2, 10, v60, v61);
        }

        v85 = a7[11].i32[0];
        v86 = __OFSUB__(v85--, 1);
        a7[11].i32[0] = v85;
        if (v85 < 0 != v86)
        {
          goto LABEL_108;
        }

        ++a7[11].i32[1];
        v87 = (*(*v62 + 88))(v62, v8, a7);
        a7[11] = vadd_s32(a7[11], 0xFFFFFFFF00000001);
        v88 = a7[10].i32[0];
        a7[10].i32[0] = 0;
        if (v88 == ((8 * v11) | 3))
        {
          v8 = v87;
        }

        else
        {
          v8 = 0;
        }

        goto LABEL_189;
      case 0xB:
        v27 = *(a4 + 1);
        v28 = *(a4 + 8);
        v29 = *(a4 + 24);
        if (v27 == 1)
        {
          v30 = google::protobuf::internal::ExtensionSet::AddMessage(this, a2, 11, v28, v29);
        }

        else
        {
          v30 = google::protobuf::internal::ExtensionSet::MutableMessage(this, a2, 11, v28, v29);
        }

        return google::protobuf::internal::ParseContext::ParseMessage(a7, v30, v8);
      case 0xD:
        v34 = *a6;
        if ((v34 & 0x8000000000000000) != 0)
        {
          v91 = (*(a6 + 1) << 7) + v34;
          LODWORD(v34) = v91 - 128;
          if (*(a6 + 1) < 0)
          {
            v8 = google::protobuf::internal::VarintParseSlow64(a6, (v91 - 128));
            if (!v8)
            {
              goto LABEL_189;
            }

            LODWORD(v34) = v100;
          }

          else
          {
            v8 = (a6 + 2);
          }
        }

        else
        {
          v8 = (a6 + 1);
        }

        if (*(a4 + 1) == 1)
        {
          v63 = *(a4 + 2);
          v64 = *(a4 + 24);
          this = v12;
          a2 = v11;
          v65 = 13;
          v66 = v34;
LABEL_139:
          google::protobuf::internal::ExtensionSet::AddUInt32(this, a2, v65, v63, v66, v64);
          goto LABEL_189;
        }

        v101 = *(a4 + 24);
        v102 = google::protobuf::internal::ExtensionSet::Insert(v12, v11);
        v102[2] = v101;
        if ((v103 & 1) == 0)
        {
          goto LABEL_188;
        }

        v104 = 13;
        goto LABEL_187;
      case 0xE:
        v34 = *a6;
        if ((v34 & 0x8000000000000000) != 0)
        {
          v96 = (*(a6 + 1) << 7) + v34;
          v34 = (v96 - 128);
          if (*(a6 + 1) < 0)
          {
            v8 = google::protobuf::internal::VarintParseSlow64(a6, (v96 - 128));
            if (!v8)
            {
              goto LABEL_189;
            }

            v34 = v120;
          }

          else
          {
            v8 = (a6 + 2);
          }
        }

        else
        {
          v8 = (a6 + 1);
        }

        if ((*(a4 + 8))(*(a4 + 16), v34))
        {
          if (*(a4 + 1) == 1)
          {
            google::protobuf::internal::ExtensionSet::AddInt32(v12, v11, 14, *(a4 + 2), v34, *(a4 + 24));
          }

          else
          {
            v122 = *(a4 + 24);
            v102 = google::protobuf::internal::ExtensionSet::Insert(v12, v11);
            v102[2] = v122;
            if (v123)
            {
              v104 = 14;
LABEL_187:
              *(v102 + 4) = v104;
            }

LABEL_188:
            *(v102 + 10) &= 0xF0u;
            *v102 = v34;
          }
        }

        else
        {
          if (*a5)
          {
            v121 = ((*a5 & 0xFFFFFFFFFFFFFFFELL) + 8);
          }

          else
          {
            v121 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(a5);
          }

          google::protobuf::internal::WriteVarint(v11, v34, v121);
        }

        goto LABEL_189;
      case 0xF:
        v8 = (a6 + 4);
        v23 = *a6;
        if (*(a4 + 1) == 1)
        {
          v24 = *(a4 + 2);
          v25 = *(a4 + 24);
          v26 = 15;
          goto LABEL_130;
        }

        v69 = *(a4 + 24);
        v70 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
        v70[2] = v69;
        if ((v71 & 1) == 0)
        {
          goto LABEL_134;
        }

        v72 = 15;
        goto LABEL_133;
      case 0x10:
        v8 = (a6 + 8);
        v42 = *a6;
        if (*(a4 + 1) == 1)
        {
          v47 = *(a4 + 2);
          v48 = *(a4 + 24);
          v49 = 16;
          goto LABEL_172;
        }

        v73 = *(a4 + 24);
        v74 = google::protobuf::internal::ExtensionSet::Insert(this, a2);
        v74[2] = v73;
        if ((v75 & 1) == 0)
        {
          goto LABEL_176;
        }

        v76 = 16;
        goto LABEL_175;
      case 0x11:
        v18 = *a6;
        if ((v18 & 0x8000000000000000) != 0)
        {
          v18 = (*(a6 + 1) << 7) + v18 - 128;
          if (*(a6 + 1) < 0)
          {
            v8 = google::protobuf::internal::VarintParseSlow64(a6, v18);
            if (!v8)
            {
              goto LABEL_189;
            }
          }

          else
          {
            v8 = (a6 + 2);
          }
        }

        else
        {
          v8 = (a6 + 1);
        }

        v23 = -(v18 & 1) ^ (v18 >> 1);
        if (*(a4 + 1) == 1)
        {
          v24 = *(a4 + 2);
          v25 = *(a4 + 24);
          this = v12;
          a2 = v11;
          v26 = 17;
LABEL_130:
          v97 = v23;
LABEL_146:
          google::protobuf::internal::ExtensionSet::AddInt32(this, a2, v26, v24, v97, v25);
        }

        else
        {
          v98 = *(a4 + 24);
          v70 = google::protobuf::internal::ExtensionSet::Insert(v12, v11);
          v70[2] = v98;
          if (v99)
          {
            v72 = 17;
LABEL_133:
            *(v70 + 4) = v72;
          }

LABEL_134:
          *(v70 + 10) &= 0xF0u;
          *v70 = v23;
        }

        goto LABEL_189;
      case 0x12:
        v55 = *a6;
        if ((v55 & 0x8000000000000000) != 0)
        {
          v55 = (*(a6 + 1) << 7) + v55 - 128;
          if (*(a6 + 1) < 0)
          {
            v8 = google::protobuf::internal::VarintParseSlow64(a6, v55);
            if (!v8)
            {
              goto LABEL_189;
            }
          }

          else
          {
            v8 = (a6 + 2);
          }
        }

        else
        {
          v8 = (a6 + 1);
        }

        v42 = -(v55 & 1) ^ (v55 >> 1);
        if (*(a4 + 1) == 1)
        {
          v47 = *(a4 + 2);
          v48 = *(a4 + 24);
          this = v12;
          a2 = v11;
          v49 = 18;
LABEL_172:
          google::protobuf::internal::ExtensionSet::AddInt64(this, a2, v49, v47, v42, v48);
        }

        else
        {
          v118 = *(a4 + 24);
          v74 = google::protobuf::internal::ExtensionSet::Insert(v12, v11);
          v74[2] = v118;
          if (v119)
          {
            v76 = 18;
LABEL_175:
            *(v74 + 4) = v76;
          }

LABEL_176:
          *(v74 + 10) &= 0xF0u;
          *v74 = v42;
        }

LABEL_189:
        result = v8;
        break;
      default:
        goto LABEL_189;
    }
  }

  return result;
}

void sub_1B5AC930C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  google::protobuf::internal::LogMessage::~LogMessage(va);
  _Unwind_Resume(a1);
}

unsigned __int8 *google::protobuf::internal::ExtensionSet::_InternalSerialize(google::protobuf::internal::ExtensionSet *this, int a2, signed int a3, unsigned __int8 *a4, google::protobuf::io::EpsCopyOutputStream *a5)
{
  v7 = *(this + 2);
  if (*(this + 4) >= 0x101u)
  {
    v17 = *(v7 + 1);
    v16 = v7 + 2;
    v15 = v17;
    if (v17)
    {
      v18 = v16;
      do
      {
        if (*(v15 + 32) >= a2)
        {
          v18 = v15;
        }

        v15 = *(v15 + 8 * (*(v15 + 32) < a2));
      }

      while (v15);
      if (v18 != v16)
      {
        do
        {
          v19 = *(v18 + 8);
          if (v19 >= a3)
          {
            break;
          }

          a4 = google::protobuf::internal::ExtensionSet::Extension::InternalSerializeFieldWithCachedSizesToArray(v18 + 5, v19, a4, a5);
          v20 = v18[1];
          if (v20)
          {
            do
            {
              v21 = v20;
              v20 = *v20;
            }

            while (v20);
          }

          else
          {
            do
            {
              v21 = v18[2];
              v22 = *v21 == v18;
              v18 = v21;
            }

            while (!v22);
          }

          v18 = v21;
        }

        while (v21 != v16);
      }
    }
  }

  else
  {
    v8 = *(this + 5);
    v9 = &v7[8 * v8];
    while (v8)
    {
      v10 = v8 >> 1;
      v11 = &v7[8 * (v8 >> 1)];
      v13 = *v11;
      v12 = v11 + 8;
      v8 += ~(v8 >> 1);
      if (v13 < a2)
      {
        v7 = v12;
      }

      else
      {
        v8 = v10;
      }
    }

    while (v7 != v9 && *v7 < a3)
    {
      a4 = google::protobuf::internal::ExtensionSet::Extension::InternalSerializeFieldWithCachedSizesToArray(v7 + 1, *v7, a4, a5);
      v7 += 8;
    }
  }

  return a4;
}

unsigned __int8 *google::protobuf::internal::ExtensionSet::Extension::InternalSerializeFieldWithCachedSizesToArray(int **this, unsigned int a2, unsigned __int8 *a3, google::protobuf::io::EpsCopyOutputStream *a4)
{
  v5 = a3;
  if (*(this + 9) == 1)
  {
    if (*(this + 11) == 1)
    {
      if (*(this + 3))
      {
        if (*a4 <= a3)
        {
          v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
        }

        v8 = 8 * a2;
        if (8 * a2 > 0x7F)
        {
          *v5 = v8 | 0x82;
          v29 = v8 >> 7;
          if (v8 >> 14)
          {
            v9 = v5 + 2;
            do
            {
              *(v9 - 1) = v29 | 0x80;
              v30 = v29 >> 7;
              ++v9;
              v31 = v29 >> 14;
              v29 >>= 7;
            }

            while (v31);
            *(v9 - 1) = v30;
          }

          else
          {
            v5[1] = v29;
            v9 = v5 + 2;
          }
        }

        else
        {
          *v5 = v8 | 2;
          v9 = v5 + 1;
        }

        v32 = *(this + 3);
        if (v32 > 0x7F)
        {
          *v9 = v32 | 0x80;
          v33 = v32 >> 7;
          if (v32 >> 14)
          {
            v5 = v9 + 2;
            do
            {
              *(v5 - 1) = v33 | 0x80;
              v34 = v33 >> 7;
              ++v5;
              v35 = v33 >> 14;
              v33 >>= 7;
            }

            while (v35);
            *(v5 - 1) = v34;
          }

          else
          {
            v9[1] = v33;
            v5 = v9 + 2;
          }
        }

        else
        {
          *v9 = v32;
          v5 = v9 + 1;
        }

        switch(*(this + 8))
        {
          case 1:
            v339 = *this;
            if (**this >= 1)
            {
              v340 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v339 = *this;
                }

                *v5 = *(*(v339 + 1) + 8 * v340);
                v5 += 8;
                ++v340;
                v339 = *this;
              }

              while (v340 < **this);
            }

            break;
          case 2:
            v341 = *this;
            if (**this >= 1)
            {
              v342 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v341 = *this;
                }

                *v5 = *(*(v341 + 1) + 4 * v342);
                v5 += 4;
                ++v342;
                v341 = *this;
              }

              while (v342 < **this);
            }

            break;
          case 3:
            v323 = *this;
            if (**this >= 1)
            {
              v324 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v323 = *this;
                }

                v325 = *(*(v323 + 1) + 8 * v324);
                if (v325 > 0x7F)
                {
                  *v5 = v325 | 0x80;
                  v326 = v325 >> 7;
                  if (v325 >> 14)
                  {
                    v5 += 2;
                    do
                    {
                      *(v5 - 1) = v326 | 0x80;
                      v327 = v326 >> 7;
                      ++v5;
                      v328 = v326 >> 14;
                      v326 >>= 7;
                    }

                    while (v328);
                    *(v5 - 1) = v327;
                  }

                  else
                  {
                    v5[1] = v326;
                    v5 += 2;
                  }
                }

                else
                {
                  *v5++ = v325;
                }

                ++v324;
                v323 = *this;
              }

              while (v324 < **this);
            }

            break;
          case 4:
            v331 = *this;
            if (**this >= 1)
            {
              v332 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v331 = *this;
                }

                v333 = *(*(v331 + 1) + 8 * v332);
                if (v333 > 0x7F)
                {
                  *v5 = v333 | 0x80;
                  v334 = v333 >> 7;
                  if (v333 >> 14)
                  {
                    v5 += 2;
                    do
                    {
                      *(v5 - 1) = v334 | 0x80;
                      v335 = v334 >> 7;
                      ++v5;
                      v336 = v334 >> 14;
                      v334 >>= 7;
                    }

                    while (v336);
                    *(v5 - 1) = v335;
                  }

                  else
                  {
                    v5[1] = v334;
                    v5 += 2;
                  }
                }

                else
                {
                  *v5++ = v333;
                }

                ++v332;
                v331 = *this;
              }

              while (v332 < **this);
            }

            break;
          case 5:
            v311 = *this;
            if (**this >= 1)
            {
              v312 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v311 = *this;
                }

                v313 = *(*(v311 + 1) + 4 * v312);
                if (v313 > 0x7F)
                {
                  *v5 = v313 | 0x80;
                  v314 = v313 >> 7;
                  if (v313 >> 14)
                  {
                    v5 += 2;
                    do
                    {
                      *(v5 - 1) = v314 | 0x80;
                      v315 = v314 >> 7;
                      ++v5;
                      v316 = v314 >> 14;
                      v314 >>= 7;
                    }

                    while (v316);
                    *(v5 - 1) = v315;
                  }

                  else
                  {
                    v5[1] = v314;
                    v5 += 2;
                  }
                }

                else
                {
                  *v5++ = v313;
                }

                ++v312;
                v311 = *this;
              }

              while (v312 < **this);
            }

            break;
          case 6:
            v356 = *this;
            if (**this >= 1)
            {
              v357 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v356 = *this;
                }

                *v5 = *(*(v356 + 1) + 8 * v357);
                v5 += 8;
                ++v357;
                v356 = *this;
              }

              while (v357 < **this);
            }

            break;
          case 7:
            v358 = *this;
            if (**this >= 1)
            {
              v359 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v358 = *this;
                }

                *v5 = *(*(v358 + 1) + 4 * v359);
                v5 += 4;
                ++v359;
                v358 = *this;
              }

              while (v359 < **this);
            }

            break;
          case 8:
            v337 = *this;
            if (**this >= 1)
            {
              v338 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v337 = *this;
                }

                *v5++ = *(*(v337 + 1) + v338++);
                v337 = *this;
              }

              while (v338 < **this);
            }

            break;
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
            google::protobuf::internal::LogMessage::LogMessage(v428, 3, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/third_party/protobuf-lite/extension_set.cc", 1966);
            v36 = google::protobuf::internal::LogMessage::operator<<(v428, "Non-primitive types can't be packed.");
            google::protobuf::internal::LogFinisher::operator=(&v427, &v36->__r_.__value_.__l.__data_);
            google::protobuf::internal::LogMessage::~LogMessage(&v428[0].__r_.__value_.__l.__data_);
            break;
          case 0xD:
            v317 = *this;
            if (**this >= 1)
            {
              v318 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v317 = *this;
                }

                v319 = *(*(v317 + 1) + 4 * v318);
                if (v319 > 0x7F)
                {
                  *v5 = v319 | 0x80;
                  v320 = v319 >> 7;
                  if (v319 >> 14)
                  {
                    v5 += 2;
                    do
                    {
                      *(v5 - 1) = v320 | 0x80;
                      v321 = v320 >> 7;
                      ++v5;
                      v322 = v320 >> 14;
                      v320 >>= 7;
                    }

                    while (v322);
                    *(v5 - 1) = v321;
                  }

                  else
                  {
                    v5[1] = v320;
                    v5 += 2;
                  }
                }

                else
                {
                  *v5++ = v319;
                }

                ++v318;
                v317 = *this;
              }

              while (v318 < **this);
            }

            break;
          case 0xE:
            v350 = *this;
            if (**this >= 1)
            {
              v351 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v350 = *this;
                }

                v352 = *(*(v350 + 1) + 4 * v351);
                if (v352 > 0x7F)
                {
                  *v5 = v352 | 0x80;
                  v353 = v352 >> 7;
                  if (v352 >> 14)
                  {
                    v5 += 2;
                    do
                    {
                      *(v5 - 1) = v353 | 0x80;
                      v354 = v353 >> 7;
                      ++v5;
                      v355 = v353 >> 14;
                      v353 >>= 7;
                    }

                    while (v355);
                    *(v5 - 1) = v354;
                  }

                  else
                  {
                    v5[1] = v353;
                    v5 += 2;
                  }
                }

                else
                {
                  *v5++ = v352;
                }

                ++v351;
                v350 = *this;
              }

              while (v351 < **this);
            }

            break;
          case 0xF:
            v309 = *this;
            if (**this >= 1)
            {
              v310 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v309 = *this;
                }

                *v5 = *(*(v309 + 1) + 4 * v310);
                v5 += 4;
                ++v310;
                v309 = *this;
              }

              while (v310 < **this);
            }

            break;
          case 0x10:
            v329 = *this;
            if (**this >= 1)
            {
              v330 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v329 = *this;
                }

                *v5 = *(*(v329 + 1) + 8 * v330);
                v5 += 8;
                ++v330;
                v329 = *this;
              }

              while (v330 < **this);
            }

            break;
          case 0x11:
            v302 = *this;
            if (**this >= 1)
            {
              v303 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v302 = *this;
                }

                v304 = *(*(v302 + 1) + 4 * v303);
                v305 = (2 * v304) ^ (v304 >> 31);
                if (v305 > 0x7F)
                {
                  *v5 = v305 | 0x80;
                  v306 = v305 >> 7;
                  if (v305 >> 14)
                  {
                    v5 += 2;
                    do
                    {
                      *(v5 - 1) = v306 | 0x80;
                      v307 = v306 >> 7;
                      ++v5;
                      v308 = v306 >> 14;
                      v306 >>= 7;
                    }

                    while (v308);
                    *(v5 - 1) = v307;
                  }

                  else
                  {
                    v5[1] = v306;
                    v5 += 2;
                  }
                }

                else
                {
                  *v5++ = v305;
                }

                ++v303;
                v302 = *this;
              }

              while (v303 < **this);
            }

            break;
          case 0x12:
            v343 = *this;
            if (**this >= 1)
            {
              v344 = 0;
              do
              {
                if (*a4 <= v5)
                {
                  v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                  v343 = *this;
                }

                v345 = *(*(v343 + 1) + 8 * v344);
                v346 = (2 * v345) ^ (v345 >> 63);
                if (v346 > 0x7F)
                {
                  *v5 = v346 | 0x80;
                  v347 = v346 >> 7;
                  if (v346 >> 14)
                  {
                    v5 += 2;
                    do
                    {
                      *(v5 - 1) = v347 | 0x80;
                      v348 = v347 >> 7;
                      ++v5;
                      v349 = v347 >> 14;
                      v347 >>= 7;
                    }

                    while (v349);
                    *(v5 - 1) = v348;
                  }

                  else
                  {
                    v5[1] = v347;
                    v5 += 2;
                  }
                }

                else
                {
                  *v5++ = v346;
                }

                ++v344;
                v343 = *this;
              }

              while (v344 < **this);
            }

            break;
          default:
            return v5;
        }
      }
    }

    else
    {
      switch(*(this + 8))
      {
        case 1:
          v11 = *this;
          if (**this >= 1)
          {
            v12 = 0;
            v13 = 8 * a2;
            v14 = (8 * a2) | 0x81;
            v15 = (a2 >> 4) & 0x1FFFFFF;
            v16 = (8 * a2) | 1;
            v17 = (8 * a2) >> 7;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v11 = *this;
              }

              v18 = *(*(v11 + 1) + 8 * v12);
              if (v13 > 0x7F)
              {
                *v5 = v14;
                if (v13 >= 0x4000)
                {
                  v19 = v5 + 2;
                  v20 = v15;
                  do
                  {
                    *(v19 - 1) = v20 | 0x80;
                    v21 = v20 >> 7;
                    v19 = (v19 + 1);
                    v22 = v20 >> 14;
                    v20 >>= 7;
                  }

                  while (v22);
                  *(v19 - 1) = v21;
                }

                else
                {
                  v5[1] = v17;
                  v19 = v5 + 2;
                }
              }

              else
              {
                *v5 = v16;
                v19 = v5 + 1;
              }

              *v19 = v18;
              v5 = (v19 + 1);
              ++v12;
              v11 = *this;
            }

            while (v12 < **this);
          }

          break;
        case 2:
          v202 = *this;
          if (**this >= 1)
          {
            v203 = 0;
            v204 = 8 * a2;
            v205 = (a2 >> 4) & 0x1FFFFFF;
            v206 = (8 * a2) | 5;
            v207 = (8 * a2) >> 7;
            v208 = (8 * a2) | 0x85;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v202 = *this;
              }

              v209 = *(*(v202 + 1) + 4 * v203);
              if (v204 > 0x7F)
              {
                *v5 = v208;
                if (v204 >= 0x4000)
                {
                  v210 = v5 + 2;
                  v211 = v205;
                  do
                  {
                    *(v210 - 1) = v211 | 0x80;
                    v212 = v211 >> 7;
                    v210 = (v210 + 1);
                    v213 = v211 >> 14;
                    v211 >>= 7;
                  }

                  while (v213);
                  *(v210 - 1) = v212;
                }

                else
                {
                  v5[1] = v207;
                  v210 = v5 + 2;
                }
              }

              else
              {
                *v5 = v206;
                v210 = v5 + 1;
              }

              *v210 = v209;
              v5 = (v210 + 1);
              ++v203;
              v202 = *this;
            }

            while (v203 < **this);
          }

          break;
        case 3:
          v149 = *this;
          if (**this >= 1)
          {
            v150 = 0;
            v151 = 8 * a2;
            v152 = (8 * a2) | 0x80;
            v153 = (a2 >> 4) & 0x1FFFFFF;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v149 = *this;
              }

              v154 = *(*(v149 + 1) + 8 * v150);
              if (v151 > 0x7F)
              {
                *v5 = v152;
                if (v151 >= 0x4000)
                {
                  v155 = v5 + 2;
                  v156 = v153;
                  do
                  {
                    *(v155 - 1) = v156 | 0x80;
                    v157 = v156 >> 7;
                    ++v155;
                    v158 = v156 >> 14;
                    v156 >>= 7;
                  }

                  while (v158);
                  *(v155 - 1) = v157;
                }

                else
                {
                  v5[1] = v151 >> 7;
                  v155 = v5 + 2;
                }
              }

              else
              {
                v155 = v5 + 1;
                *v5 = v151;
              }

              if (v154 > 0x7F)
              {
                *v155 = v154 | 0x80;
                v159 = v154 >> 7;
                if (v154 >> 14)
                {
                  v5 = v155 + 2;
                  do
                  {
                    *(v5 - 1) = v159 | 0x80;
                    v160 = v159 >> 7;
                    ++v5;
                    v161 = v159 >> 14;
                    v159 >>= 7;
                  }

                  while (v161);
                  *(v5 - 1) = v160;
                }

                else
                {
                  v155[1] = v159;
                  v5 = v155 + 2;
                }
              }

              else
              {
                *v155 = v154;
                v5 = v155 + 1;
              }

              ++v150;
              v149 = *this;
            }

            while (v150 < **this);
          }

          break;
        case 4:
          v176 = *this;
          if (**this >= 1)
          {
            v177 = 0;
            v178 = 8 * a2;
            v179 = (8 * a2) | 0x80;
            v180 = (a2 >> 4) & 0x1FFFFFF;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v176 = *this;
              }

              v181 = *(*(v176 + 1) + 8 * v177);
              if (v178 > 0x7F)
              {
                *v5 = v179;
                if (v178 >= 0x4000)
                {
                  v182 = v5 + 2;
                  v183 = v180;
                  do
                  {
                    *(v182 - 1) = v183 | 0x80;
                    v184 = v183 >> 7;
                    ++v182;
                    v185 = v183 >> 14;
                    v183 >>= 7;
                  }

                  while (v185);
                  *(v182 - 1) = v184;
                }

                else
                {
                  v5[1] = v178 >> 7;
                  v182 = v5 + 2;
                }
              }

              else
              {
                v182 = v5 + 1;
                *v5 = v178;
              }

              if (v181 > 0x7F)
              {
                *v182 = v181 | 0x80;
                v186 = v181 >> 7;
                if (v181 >> 14)
                {
                  v5 = v182 + 2;
                  do
                  {
                    *(v5 - 1) = v186 | 0x80;
                    v187 = v186 >> 7;
                    ++v5;
                    v188 = v186 >> 14;
                    v186 >>= 7;
                  }

                  while (v188);
                  *(v5 - 1) = v187;
                }

                else
                {
                  v182[1] = v186;
                  v5 = v182 + 2;
                }
              }

              else
              {
                *v182 = v181;
                v5 = v182 + 1;
              }

              ++v177;
              v176 = *this;
            }

            while (v177 < **this);
          }

          break;
        case 5:
          v97 = *this;
          if (**this >= 1)
          {
            v98 = 0;
            v99 = 8 * a2;
            v100 = (8 * a2) | 0x80;
            v101 = (a2 >> 4) & 0x1FFFFFF;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v97 = *this;
              }

              v102 = *(*(v97 + 1) + 4 * v98);
              if (v99 > 0x7F)
              {
                *v5 = v100;
                if (v99 >= 0x4000)
                {
                  v103 = v5 + 2;
                  v104 = v101;
                  do
                  {
                    *(v103 - 1) = v104 | 0x80;
                    v105 = v104 >> 7;
                    ++v103;
                    v106 = v104 >> 14;
                    v104 >>= 7;
                  }

                  while (v106);
                  *(v103 - 1) = v105;
                }

                else
                {
                  v5[1] = v99 >> 7;
                  v103 = v5 + 2;
                }
              }

              else
              {
                v103 = v5 + 1;
                *v5 = v99;
              }

              if (v102 > 0x7F)
              {
                *v103 = v102 | 0x80;
                v107 = v102 >> 7;
                if (v102 >> 14)
                {
                  v5 = v103 + 2;
                  do
                  {
                    *(v5 - 1) = v107 | 0x80;
                    v108 = v107 >> 7;
                    ++v5;
                    v109 = v107 >> 14;
                    v107 >>= 7;
                  }

                  while (v109);
                  *(v5 - 1) = v108;
                }

                else
                {
                  v103[1] = v107;
                  v5 = v103 + 2;
                }
              }

              else
              {
                *v103 = v102;
                v5 = v103 + 1;
              }

              ++v98;
              v97 = *this;
            }

            while (v98 < **this);
          }

          break;
        case 6:
          v231 = *this;
          if (**this >= 1)
          {
            v232 = 0;
            v233 = 8 * a2;
            v234 = (8 * a2) | 0x81;
            v235 = (a2 >> 4) & 0x1FFFFFF;
            v236 = (8 * a2) | 1;
            v237 = (8 * a2) >> 7;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v231 = *this;
              }

              v238 = *(*(v231 + 1) + 8 * v232);
              if (v233 > 0x7F)
              {
                *v5 = v234;
                if (v233 >= 0x4000)
                {
                  v239 = v5 + 2;
                  v240 = v235;
                  do
                  {
                    *(v239 - 1) = v240 | 0x80;
                    v241 = v240 >> 7;
                    v239 = (v239 + 1);
                    v242 = v240 >> 14;
                    v240 >>= 7;
                  }

                  while (v242);
                  *(v239 - 1) = v241;
                }

                else
                {
                  v5[1] = v237;
                  v239 = v5 + 2;
                }
              }

              else
              {
                *v5 = v236;
                v239 = v5 + 1;
              }

              *v239 = v238;
              v5 = (v239 + 1);
              ++v232;
              v231 = *this;
            }

            while (v232 < **this);
          }

          break;
        case 7:
          v257 = *this;
          if (**this >= 1)
          {
            v258 = 0;
            v259 = 8 * a2;
            v260 = (a2 >> 4) & 0x1FFFFFF;
            v261 = (8 * a2) | 5;
            v262 = (8 * a2) >> 7;
            v263 = (8 * a2) | 0x85;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v257 = *this;
              }

              v264 = *(*(v257 + 1) + 4 * v258);
              if (v259 > 0x7F)
              {
                *v5 = v263;
                if (v259 >= 0x4000)
                {
                  v265 = v5 + 2;
                  v266 = v260;
                  do
                  {
                    *(v265 - 1) = v266 | 0x80;
                    v267 = v266 >> 7;
                    v265 = (v265 + 1);
                    v268 = v266 >> 14;
                    v266 >>= 7;
                  }

                  while (v268);
                  *(v265 - 1) = v267;
                }

                else
                {
                  v5[1] = v262;
                  v265 = v5 + 2;
                }
              }

              else
              {
                *v5 = v261;
                v265 = v5 + 1;
              }

              *v265 = v264;
              v5 = (v265 + 1);
              ++v258;
              v257 = *this;
            }

            while (v258 < **this);
          }

          break;
        case 8:
          v190 = *this;
          if (**this >= 1)
          {
            v191 = 0;
            v192 = 8 * a2;
            v193 = (8 * a2) | 0x80;
            v194 = (a2 >> 4) & 0x1FFFFFF;
            v195 = (8 * a2) >> 7;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v190 = *this;
              }

              v196 = *(*(v190 + 1) + v191);
              if (v192 > 0x7F)
              {
                *v5 = v193;
                if (v192 >= 0x4000)
                {
                  v197 = v5 + 2;
                  v198 = v194;
                  do
                  {
                    *(v197 - 1) = v198 | 0x80;
                    v199 = v198 >> 7;
                    ++v197;
                    v200 = v198 >> 14;
                    v198 >>= 7;
                  }

                  while (v200);
                  *(v197 - 1) = v199;
                }

                else
                {
                  v5[1] = v195;
                  v197 = v5 + 2;
                }
              }

              else
              {
                *v5 = v192;
                v197 = v5 + 1;
              }

              *v197 = v196;
              v5 = v197 + 1;
              ++v191;
              v190 = *this;
            }

            while (v191 < **this);
          }

          break;
        case 9:
          v288 = *this;
          if ((*this)[2] >= 1)
          {
            v289 = 0;
            v290 = 8 * a2;
            v291 = (8 * a2) | 2;
            v426 = (8 * a2) | 0x82;
            v292 = -3;
            if (8 * a2 < 0x80)
            {
              v292 = -2;
            }

            v293 = -6;
            if (((a2 >> 25) & 0xF) == 0)
            {
              v293 = -5;
            }

            if (v290 < 0x200000)
            {
              v293 = -4;
            }

            v423 = (a2 >> 4) & 0x1FFFFFF;
            if (v290 >= 0x4000)
            {
              v294 = v293;
            }

            else
            {
              v294 = v292;
            }

            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v288 = *this;
              }

              v295 = *(*(v288 + 2) + 8 * v289 + 8);
              v296 = *(v295 + 23);
              if (v296 < 0 && (v296 = v295[1], v296 > 127) || *a4 + v294 - v5 + 16 < v296)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::WriteStringOutline(a4, a2, v295, v5);
              }

              else
              {
                if (v290 > 0x7F)
                {
                  *v5 = v426;
                  if (v290 >= 0x4000)
                  {
                    v297 = v5 + 2;
                    v298 = v423;
                    do
                    {
                      *(v297 - 1) = v298 | 0x80;
                      v299 = v298 >> 7;
                      ++v297;
                      v300 = v298 >> 14;
                      v298 >>= 7;
                    }

                    while (v300);
                    *(v297 - 1) = v299;
                  }

                  else
                  {
                    v5[1] = v290 >> 7;
                    v297 = v5 + 2;
                  }
                }

                else
                {
                  v297 = v5 + 1;
                  *v5 = v291;
                }

                *v297 = v296;
                v301 = v297 + 1;
                if (*(v295 + 23) < 0)
                {
                  v295 = *v295;
                }

                memcpy(v301, v295, v296);
                v5 = &v301[v296];
              }

              ++v289;
              v288 = *this;
            }

            while (v289 < (*this)[2]);
          }

          break;
        case 0xA:
          v127 = *this;
          if ((*this)[2] >= 1)
          {
            v128 = 0;
            v129 = 8 * a2;
            v425 = (8 * a2) | 0x83;
            v130 = (a2 >> 4) & 0x1FFFFFF;
            v131 = (8 * a2) | 3;
            v132 = (8 * a2) | 4;
            v133 = (8 * a2) >> 7;
            v134 = (8 * a2) | 0x84;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v127 = *this;
              }

              v135 = *(*(v127 + 2) + 8 * v128 + 8);
              if (v129 > 0x7F)
              {
                *v5 = v425;
                if (v129 >= 0x4000)
                {
                  v136 = v5 + 2;
                  v137 = v130;
                  do
                  {
                    *(v136 - 1) = v137 | 0x80;
                    v138 = v137 >> 7;
                    ++v136;
                    v139 = v137 >> 14;
                    v137 >>= 7;
                  }

                  while (v139);
                  *(v136 - 1) = v138;
                }

                else
                {
                  v5[1] = v133;
                  v136 = v5 + 2;
                }
              }

              else
              {
                v136 = v5 + 1;
                *v5 = v131;
              }

              v140 = (*(*v135 + 96))(v135, v136, a4);
              if (*a4 <= v140)
              {
                v140 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v140);
              }

              if (v129 > 0x7F)
              {
                *v140 = v134;
                if (v129 >= 0x4000)
                {
                  v5 = v140 + 2;
                  v141 = v130;
                  do
                  {
                    *(v5 - 1) = v141 | 0x80;
                    v142 = v141 >> 7;
                    ++v5;
                    v143 = v141 >> 14;
                    v141 >>= 7;
                  }

                  while (v143);
                  *(v5 - 1) = v142;
                }

                else
                {
                  v140[1] = v133;
                  v5 = v140 + 2;
                }
              }

              else
              {
                v5 = v140 + 1;
                *v140 = v132;
              }

              ++v128;
              v127 = *this;
            }

            while (v128 < (*this)[2]);
          }

          break;
        case 0xB:
          v269 = *this;
          if ((*this)[2] >= 1)
          {
            v270 = 0;
            v271 = 8 * a2;
            v272 = (a2 >> 4) & 0x1FFFFFF;
            v273 = (8 * a2) | 2;
            v274 = (8 * a2) | 0x82;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v269 = *this;
              }

              v275 = *(*(v269 + 2) + 8 * v270 + 8);
              if (v271 > 0x7F)
              {
                *v5 = v274;
                if (v271 >= 0x4000)
                {
                  v276 = v5 + 2;
                  v277 = v272;
                  do
                  {
                    *(v276 - 1) = v277 | 0x80;
                    v278 = v277 >> 7;
                    ++v276;
                    v279 = v277 >> 14;
                    v277 >>= 7;
                  }

                  while (v279);
                  *(v276 - 1) = v278;
                }

                else
                {
                  v5[1] = v271 >> 7;
                  v276 = v5 + 2;
                }
              }

              else
              {
                v276 = v5 + 1;
                *v5 = v273;
              }

              v280 = (*(*v275 + 80))(v275);
              if (v280 > 0x7F)
              {
                *v276 = v280 | 0x80;
                v282 = v280 >> 7;
                if (v280 >> 14)
                {
                  v281 = v276 + 2;
                  do
                  {
                    *(v281 - 1) = v282 | 0x80;
                    v283 = v282 >> 7;
                    ++v281;
                    v284 = v282 >> 14;
                    v282 >>= 7;
                  }

                  while (v284);
                  *(v281 - 1) = v283;
                }

                else
                {
                  v276[1] = v282;
                  v281 = v276 + 2;
                }
              }

              else
              {
                *v276 = v280;
                v281 = v276 + 1;
              }

              v5 = (*(*v275 + 96))(v275, v281, a4);
              ++v270;
              v269 = *this;
            }

            while (v270 < (*this)[2]);
          }

          break;
        case 0xC:
          v72 = *this;
          if ((*this)[2] >= 1)
          {
            v73 = 0;
            v74 = 8 * a2;
            v75 = (8 * a2) | 2;
            v424 = (8 * a2) | 0x82;
            v76 = -3;
            if (8 * a2 < 0x80)
            {
              v76 = -2;
            }

            v77 = -6;
            if (((a2 >> 25) & 0xF) == 0)
            {
              v77 = -5;
            }

            if (v74 < 0x200000)
            {
              v77 = -4;
            }

            v422 = (a2 >> 4) & 0x1FFFFFF;
            if (v74 >= 0x4000)
            {
              v78 = v77;
            }

            else
            {
              v78 = v76;
            }

            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v72 = *this;
              }

              v79 = *(*(v72 + 2) + 8 * v73 + 8);
              v80 = *(v79 + 23);
              if (v80 < 0 && (v80 = v79[1], v80 > 127) || *a4 + v78 - v5 + 16 < v80)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::WriteStringOutline(a4, a2, v79, v5);
              }

              else
              {
                if (v74 > 0x7F)
                {
                  *v5 = v424;
                  if (v74 >= 0x4000)
                  {
                    v81 = v5 + 2;
                    v82 = v422;
                    do
                    {
                      *(v81 - 1) = v82 | 0x80;
                      v83 = v82 >> 7;
                      ++v81;
                      v84 = v82 >> 14;
                      v82 >>= 7;
                    }

                    while (v84);
                    *(v81 - 1) = v83;
                  }

                  else
                  {
                    v5[1] = v74 >> 7;
                    v81 = v5 + 2;
                  }
                }

                else
                {
                  v81 = v5 + 1;
                  *v5 = v75;
                }

                *v81 = v80;
                v85 = v81 + 1;
                if (*(v79 + 23) < 0)
                {
                  v79 = *v79;
                }

                memcpy(v85, v79, v80);
                v5 = &v85[v80];
              }

              ++v73;
              v72 = *this;
            }

            while (v73 < (*this)[2]);
          }

          break;
        case 0xD:
          v112 = *this;
          if (**this >= 1)
          {
            v113 = 0;
            v114 = 8 * a2;
            v115 = (8 * a2) | 0x80;
            v116 = (a2 >> 4) & 0x1FFFFFF;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v112 = *this;
              }

              v117 = *(*(v112 + 1) + 4 * v113);
              if (v114 > 0x7F)
              {
                *v5 = v115;
                if (v114 >= 0x4000)
                {
                  v118 = v5 + 2;
                  v119 = v116;
                  do
                  {
                    *(v118 - 1) = v119 | 0x80;
                    v120 = v119 >> 7;
                    ++v118;
                    v121 = v119 >> 14;
                    v119 >>= 7;
                  }

                  while (v121);
                  *(v118 - 1) = v120;
                }

                else
                {
                  v5[1] = v114 >> 7;
                  v118 = v5 + 2;
                }
              }

              else
              {
                v118 = v5 + 1;
                *v5 = v114;
              }

              if (v117 > 0x7F)
              {
                *v118 = v117 | 0x80;
                v122 = v117 >> 7;
                if (v117 >> 14)
                {
                  v5 = v118 + 2;
                  do
                  {
                    *(v5 - 1) = v122 | 0x80;
                    v123 = v122 >> 7;
                    ++v5;
                    v124 = v122 >> 14;
                    v122 >>= 7;
                  }

                  while (v124);
                  *(v5 - 1) = v123;
                }

                else
                {
                  v118[1] = v122;
                  v5 = v118 + 2;
                }
              }

              else
              {
                *v118 = v117;
                v5 = v118 + 1;
              }

              ++v113;
              v112 = *this;
            }

            while (v113 < **this);
          }

          break;
        case 0xE:
          v243 = *this;
          if (**this >= 1)
          {
            v244 = 0;
            v245 = 8 * a2;
            v246 = (8 * a2) | 0x80;
            v247 = (a2 >> 4) & 0x1FFFFFF;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v243 = *this;
              }

              v248 = *(*(v243 + 1) + 4 * v244);
              if (v245 > 0x7F)
              {
                *v5 = v246;
                if (v245 >= 0x4000)
                {
                  v249 = v5 + 2;
                  v250 = v247;
                  do
                  {
                    *(v249 - 1) = v250 | 0x80;
                    v251 = v250 >> 7;
                    ++v249;
                    v252 = v250 >> 14;
                    v250 >>= 7;
                  }

                  while (v252);
                  *(v249 - 1) = v251;
                }

                else
                {
                  v5[1] = v245 >> 7;
                  v249 = v5 + 2;
                }
              }

              else
              {
                v249 = v5 + 1;
                *v5 = v245;
              }

              if (v248 > 0x7F)
              {
                *v249 = v248 | 0x80;
                v253 = v248 >> 7;
                if (v248 >> 14)
                {
                  v5 = v249 + 2;
                  do
                  {
                    *(v5 - 1) = v253 | 0x80;
                    v254 = v253 >> 7;
                    ++v5;
                    v255 = v253 >> 14;
                    v253 >>= 7;
                  }

                  while (v255);
                  *(v5 - 1) = v254;
                }

                else
                {
                  v249[1] = v253;
                  v5 = v249 + 2;
                }
              }

              else
              {
                *v249 = v248;
                v5 = v249 + 1;
              }

              ++v244;
              v243 = *this;
            }

            while (v244 < **this);
          }

          break;
        case 0xF:
          v54 = *this;
          if (**this >= 1)
          {
            v55 = 0;
            v56 = 8 * a2;
            v57 = (a2 >> 4) & 0x1FFFFFF;
            v58 = (8 * a2) | 5;
            v59 = (8 * a2) >> 7;
            v60 = (8 * a2) | 0x85;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v54 = *this;
              }

              v61 = *(*(v54 + 1) + 4 * v55);
              if (v56 > 0x7F)
              {
                *v5 = v60;
                if (v56 >= 0x4000)
                {
                  v62 = v5 + 2;
                  v63 = v57;
                  do
                  {
                    *(v62 - 1) = v63 | 0x80;
                    v64 = v63 >> 7;
                    v62 = (v62 + 1);
                    v65 = v63 >> 14;
                    v63 >>= 7;
                  }

                  while (v65);
                  *(v62 - 1) = v64;
                }

                else
                {
                  v5[1] = v59;
                  v62 = v5 + 2;
                }
              }

              else
              {
                *v5 = v58;
                v62 = v5 + 1;
              }

              *v62 = v61;
              v5 = (v62 + 1);
              ++v55;
              v54 = *this;
            }

            while (v55 < **this);
          }

          break;
        case 0x10:
          v163 = *this;
          if (**this >= 1)
          {
            v164 = 0;
            v165 = 8 * a2;
            v166 = (8 * a2) | 0x81;
            v167 = (a2 >> 4) & 0x1FFFFFF;
            v168 = (8 * a2) | 1;
            v169 = (8 * a2) >> 7;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v163 = *this;
              }

              v170 = *(*(v163 + 1) + 8 * v164);
              if (v165 > 0x7F)
              {
                *v5 = v166;
                if (v165 >= 0x4000)
                {
                  v171 = v5 + 2;
                  v172 = v167;
                  do
                  {
                    *(v171 - 1) = v172 | 0x80;
                    v173 = v172 >> 7;
                    v171 = (v171 + 1);
                    v174 = v172 >> 14;
                    v172 >>= 7;
                  }

                  while (v174);
                  *(v171 - 1) = v173;
                }

                else
                {
                  v5[1] = v169;
                  v171 = v5 + 2;
                }
              }

              else
              {
                *v5 = v168;
                v171 = v5 + 1;
              }

              *v171 = v170;
              v5 = (v171 + 1);
              ++v164;
              v163 = *this;
            }

            while (v164 < **this);
          }

          break;
        case 0x11:
          v37 = *this;
          if (**this >= 1)
          {
            v38 = 0;
            v39 = 8 * a2;
            v40 = (8 * a2) | 0x80;
            v41 = (a2 >> 4) & 0x1FFFFFF;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v37 = *this;
              }

              v42 = *(*(v37 + 1) + 4 * v38);
              if (v39 > 0x7F)
              {
                *v5 = v40;
                if (v39 >= 0x4000)
                {
                  v43 = v5 + 2;
                  v44 = v41;
                  do
                  {
                    *(v43 - 1) = v44 | 0x80;
                    v45 = v44 >> 7;
                    ++v43;
                    v46 = v44 >> 14;
                    v44 >>= 7;
                  }

                  while (v46);
                  *(v43 - 1) = v45;
                }

                else
                {
                  v5[1] = v39 >> 7;
                  v43 = v5 + 2;
                }
              }

              else
              {
                v43 = v5 + 1;
                *v5 = v39;
              }

              v47 = (2 * v42) ^ (v42 >> 31);
              if (v47 > 0x7F)
              {
                *v43 = v47 | 0x80;
                v48 = v47 >> 7;
                if (v47 >> 14)
                {
                  v5 = v43 + 2;
                  do
                  {
                    *(v5 - 1) = v48 | 0x80;
                    v49 = v48 >> 7;
                    ++v5;
                    v50 = v48 >> 14;
                    v48 >>= 7;
                  }

                  while (v50);
                  *(v5 - 1) = v49;
                }

                else
                {
                  v43[1] = v48;
                  v5 = v43 + 2;
                }
              }

              else
              {
                *v43 = v47;
                v5 = v43 + 1;
              }

              ++v38;
              v37 = *this;
            }

            while (v38 < **this);
          }

          break;
        case 0x12:
          v215 = *this;
          if (**this >= 1)
          {
            v216 = 0;
            v217 = 8 * a2;
            v218 = (8 * a2) | 0x80;
            v219 = (a2 >> 4) & 0x1FFFFFF;
            do
            {
              if (*a4 <= v5)
              {
                v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v5);
                v215 = *this;
              }

              v220 = *(*(v215 + 1) + 8 * v216);
              if (v217 > 0x7F)
              {
                *v5 = v218;
                if (v217 >= 0x4000)
                {
                  v221 = v5 + 2;
                  v222 = v219;
                  do
                  {
                    *(v221 - 1) = v222 | 0x80;
                    v223 = v222 >> 7;
                    ++v221;
                    v224 = v222 >> 14;
                    v222 >>= 7;
                  }

                  while (v224);
                  *(v221 - 1) = v223;
                }

                else
                {
                  v5[1] = v217 >> 7;
                  v221 = v5 + 2;
                }
              }

              else
              {
                v221 = v5 + 1;
                *v5 = v217;
              }

              v225 = (2 * v220) ^ (v220 >> 63);
              if (v225 > 0x7F)
              {
                *v221 = v225 | 0x80;
                v226 = v225 >> 7;
                if (v225 >> 14)
                {
                  v5 = v221 + 2;
                  do
                  {
                    *(v5 - 1) = v226 | 0x80;
                    v227 = v226 >> 7;
                    ++v5;
                    v228 = v226 >> 14;
                    v226 >>= 7;
                  }

                  while (v228);
                  *(v5 - 1) = v227;
                }

                else
                {
                  v221[1] = v226;
                  v5 = v221 + 2;
                }
              }

              else
              {
                *v221 = v225;
                v5 = v221 + 1;
              }

              ++v216;
              v215 = *this;
            }

            while (v216 < **this);
          }

          break;
        default:
          return v5;
      }
    }

    return v5;
  }

  if (*(this + 10))
  {
    return v5;
  }

  switch(*(this + 8))
  {
    case 1:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v23 = *this;
      v24 = 8 * a2;
      if (8 * a2 <= 0x7F)
      {
        goto LABEL_353;
      }

      *v5 = v24 | 0x81;
      v25 = v24 >> 7;
      if (!(v24 >> 14))
      {
        goto LABEL_605;
      }

      v26 = (v5 + 2);
      do
      {
        *(v26 - 1) = v25 | 0x80;
        v27 = v25 >> 7;
        v26 = (v26 + 1);
        v28 = v25 >> 14;
        v25 >>= 7;
      }

      while (v28);
      goto LABEL_693;
    case 2:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v66 = *this;
      v67 = 8 * a2;
      if (8 * a2 <= 0x7F)
      {
        goto LABEL_394;
      }

      *v5 = v67 | 0x85;
      v68 = v67 >> 7;
      if (!(v67 >> 14))
      {
        goto LABEL_609;
      }

      v69 = (v5 + 2);
      do
      {
        *(v69 - 1) = v68 | 0x80;
        v70 = v68 >> 7;
        v69 = (v69 + 1);
        v214 = v68 >> 14;
        v68 >>= 7;
      }

      while (v214);
      goto LABEL_708;
    case 3:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v110 = *this;
      v162 = 8 * a2;
      if (8 * a2 > 0x7F)
      {
        *v5 = v162 | 0x80;
        v363 = v162 >> 7;
        if (v162 >> 14)
        {
          v53 = v5 + 2;
          do
          {
            *(v53 - 1) = v363 | 0x80;
            v392 = v363 >> 7;
            ++v53;
            v393 = v363 >> 14;
            v363 >>= 7;
          }

          while (v393);
          *(v53 - 1) = v392;
        }

        else
        {
          v5[1] = v363;
          v53 = v5 + 2;
        }
      }

      else
      {
        *v5 = v162;
        v53 = v5 + 1;
      }

      if (v110 <= 0x7F)
      {
        goto LABEL_699;
      }

      *v53 = v110 | 0x80;
      v380 = v110 >> 7;
      if (!(v110 >> 14))
      {
        goto LABEL_701;
      }

      v5 = v53 + 2;
      do
      {
        *(v5 - 1) = v380 | 0x80;
        v381 = v380 >> 7;
        ++v5;
        v394 = v380 >> 14;
        v380 >>= 7;
      }

      while (v394);
      goto LABEL_705;
    case 4:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v110 = *this;
      v189 = 8 * a2;
      if (8 * a2 > 0x7F)
      {
        *v5 = v189 | 0x80;
        v364 = v189 >> 7;
        if (v189 >> 14)
        {
          v53 = v5 + 2;
          do
          {
            *(v53 - 1) = v364 | 0x80;
            v395 = v364 >> 7;
            ++v53;
            v396 = v364 >> 14;
            v364 >>= 7;
          }

          while (v396);
          *(v53 - 1) = v395;
        }

        else
        {
          v5[1] = v364;
          v53 = v5 + 2;
        }
      }

      else
      {
        *v5 = v189;
        v53 = v5 + 1;
      }

      if (v110 <= 0x7F)
      {
        goto LABEL_699;
      }

      *v53 = v110 | 0x80;
      v380 = v110 >> 7;
      if (!(v110 >> 14))
      {
        goto LABEL_701;
      }

      v5 = v53 + 2;
      do
      {
        *(v5 - 1) = v380 | 0x80;
        v381 = v380 >> 7;
        ++v5;
        v397 = v380 >> 14;
        v380 >>= 7;
      }

      while (v397);
      goto LABEL_705;
    case 5:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v110 = *this;
      v111 = 8 * a2;
      if (8 * a2 > 0x7F)
      {
        *v5 = v111 | 0x80;
        v361 = v111 >> 7;
        if (v111 >> 14)
        {
          v53 = v5 + 2;
          do
          {
            *(v53 - 1) = v361 | 0x80;
            v378 = v361 >> 7;
            ++v53;
            v379 = v361 >> 14;
            v361 >>= 7;
          }

          while (v379);
          *(v53 - 1) = v378;
        }

        else
        {
          v5[1] = v361;
          v53 = v5 + 2;
        }
      }

      else
      {
        *v5 = v111;
        v53 = v5 + 1;
      }

      if (v110 <= 0x7F)
      {
        goto LABEL_699;
      }

      *v53 = v110 | 0x80;
      v380 = v110 >> 7;
      if (!(v110 >> 14))
      {
        goto LABEL_701;
      }

      v5 = v53 + 2;
      do
      {
        *(v5 - 1) = v380 | 0x80;
        v381 = v380 >> 7;
        ++v5;
        v382 = v380 >> 14;
        v380 >>= 7;
      }

      while (v382);
      goto LABEL_705;
    case 6:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v23 = *this;
      v24 = 8 * a2;
      if (8 * a2 <= 0x7F)
      {
        goto LABEL_353;
      }

      *v5 = v24 | 0x81;
      v25 = v24 >> 7;
      if (!(v24 >> 14))
      {
        goto LABEL_605;
      }

      v26 = (v5 + 2);
      do
      {
        *(v26 - 1) = v25 | 0x80;
        v27 = v25 >> 7;
        v26 = (v26 + 1);
        v406 = v25 >> 14;
        v25 >>= 7;
      }

      while (v406);
      goto LABEL_693;
    case 7:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v66 = *this;
      v67 = 8 * a2;
      if (8 * a2 <= 0x7F)
      {
        goto LABEL_394;
      }

      *v5 = v67 | 0x85;
      v68 = v67 >> 7;
      if (!(v67 >> 14))
      {
        goto LABEL_609;
      }

      v69 = (v5 + 2);
      do
      {
        *(v69 - 1) = v68 | 0x80;
        v70 = v68 >> 7;
        v69 = (v69 + 1);
        v410 = v68 >> 14;
        v68 >>= 7;
      }

      while (v410);
      goto LABEL_708;
    case 8:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      LOBYTE(v125) = *this;
      v201 = 8 * a2;
      if (8 * a2 > 0x7F)
      {
        *v5 = v201 | 0x80;
        v365 = v201 >> 7;
        if (v201 >> 14)
        {
          v53 = v5 + 2;
          do
          {
            *(v53 - 1) = v365 | 0x80;
            v398 = v365 >> 7;
            ++v53;
            v399 = v365 >> 14;
            v365 >>= 7;
          }

          while (v399);
          *(v53 - 1) = v398;
        }

        else
        {
          v5[1] = v365;
          v53 = v5 + 2;
        }
      }

      else
      {
        *v5 = v201;
        v53 = v5 + 1;
      }

      goto LABEL_680;
    case 9:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v86 = *this;
      v87 = *(*this + 23);
      if (v87 < 0)
      {
        v87 = *(v86 + 1);
        if (v87 > 127)
        {
          goto LABEL_731;
        }
      }

      v88 = *a4;
      v89 = 8 * a2;
      if (8 * a2 < 0x80)
      {
        goto LABEL_453;
      }

      v369 = 2;
      v370 = 3;
      v371 = 4;
      if (v89 >> 28)
      {
        v371 = 5;
      }

      if (v89 >= 0x200000)
      {
        v370 = v371;
      }

      if (v89 >= 0x4000)
      {
        v369 = v370;
      }

      if ((v88 + ~&v5[v369] + 16) < v87)
      {
        goto LABEL_731;
      }

      *v5 = v89 | 0x82;
      v93 = v89 >> 7;
      if (!(v89 >> 14))
      {
        goto LABEL_621;
      }

      v94 = v5 + 2;
      do
      {
        *(v94 - 1) = v93 | 0x80;
        v95 = v93 >> 7;
        ++v94;
        v412 = v93 >> 14;
        v93 >>= 7;
      }

      while (v412);
      goto LABEL_714;
    case 0xA:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v144 = *this;
      v145 = 8 * a2;
      v146 = v145 >> 7;
      v147 = v145 >> 14;
      if (v145 > 0x7F)
      {
        *v5 = v145 | 0x83;
        if (v147)
        {
          v148 = v5 + 2;
          v388 = v145 >> 7;
          do
          {
            *(v148 - 1) = v388 | 0x80;
            v389 = v388 >> 7;
            ++v148;
            v390 = v388 >> 14;
            v388 >>= 7;
          }

          while (v390);
          *(v148 - 1) = v389;
        }

        else
        {
          v5[1] = v146;
          v148 = v5 + 2;
        }
      }

      else
      {
        *v5 = v145 | 3;
        v148 = v5 + 1;
      }

      v53 = (*(*v144 + 96))(v144, v148, a4);
      if (*a4 <= v53)
      {
        v53 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, v53);
      }

      if (v145 <= 0x7F)
      {
        LOBYTE(v125) = v145 | 4;
LABEL_680:
        *v53 = v125;
        return v53 + 1;
      }

      *v53 = v145 | 0x84;
      if (!v147)
      {
        v53[1] = v146;
        return v53 + 2;
      }

      v5 = v53 + 2;
      do
      {
        *(v5 - 1) = v146 | 0x80;
        v386 = v146 >> 7;
        ++v5;
        v391 = v146 >> 14;
        v146 >>= 7;
      }

      while (v391);
      goto LABEL_660;
    case 0xB:
      if ((*(this + 10) & 0x10) != 0)
      {
        v368 = *(**this + 136);

        return v368();
      }

      else
      {
        if (*a4 <= a3)
        {
          v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
        }

        v285 = *this;
        v286 = 8 * a2;
        if (8 * a2 > 0x7F)
        {
          *v5 = v286 | 0x82;
          v411 = v286 >> 7;
          if (v286 >> 14)
          {
            v287 = v5 + 2;
            do
            {
              *(v287 - 1) = v411 | 0x80;
              v414 = v411 >> 7;
              ++v287;
              v415 = v411 >> 14;
              v411 >>= 7;
            }

            while (v415);
            *(v287 - 1) = v414;
          }

          else
          {
            v5[1] = v411;
            v287 = v5 + 2;
          }
        }

        else
        {
          *v5 = v286 | 2;
          v287 = v5 + 1;
        }

        v416 = (*(*v285 + 80))(v285);
        if (v416 > 0x7F)
        {
          *v287 = v416 | 0x80;
          v418 = v416 >> 7;
          if (v416 >> 14)
          {
            v417 = v287 + 2;
            do
            {
              *(v417 - 1) = v418 | 0x80;
              v419 = v418 >> 7;
              ++v417;
              v420 = v418 >> 14;
              v418 >>= 7;
            }

            while (v420);
            *(v417 - 1) = v419;
          }

          else
          {
            v287[1] = v418;
            v417 = v287 + 2;
          }
        }

        else
        {
          *v287 = v416;
          v417 = v287 + 1;
        }

        v421 = *(*v285 + 96);

        return v421(v285, v417, a4);
      }

    case 0xC:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v86 = *this;
      v87 = *(*this + 23);
      if (v87 < 0)
      {
        v87 = *(v86 + 1);
        if (v87 > 127)
        {
          goto LABEL_731;
        }
      }

      v88 = *a4;
      v89 = 8 * a2;
      if (8 * a2 < 0x80)
      {
LABEL_453:
        if (v88 - v5 + 14 >= v87)
        {
          *v5 = v89 | 2;
          v94 = v5 + 1;
LABEL_715:
          *v94 = v87;
          v413 = v94 + 1;
          if (*(v86 + 23) < 0)
          {
            v86 = *v86;
          }

          memcpy(v413, v86, v87);
          return &v413[v87];
        }
      }

      else
      {
        v90 = 2;
        v91 = 3;
        v92 = 4;
        if (v89 >> 28)
        {
          v92 = 5;
        }

        if (v89 >= 0x200000)
        {
          v91 = v92;
        }

        if (v89 >= 0x4000)
        {
          v90 = v91;
        }

        if ((v88 + ~&v5[v90] + 16) >= v87)
        {
          *v5 = v89 | 0x82;
          v93 = v89 >> 7;
          if (v89 >> 14)
          {
            v94 = v5 + 2;
            do
            {
              *(v94 - 1) = v93 | 0x80;
              v95 = v93 >> 7;
              ++v94;
              v96 = v93 >> 14;
              v93 >>= 7;
            }

            while (v96);
LABEL_714:
            *(v94 - 1) = v95;
          }

          else
          {
LABEL_621:
            v5[1] = v93;
            v94 = v5 + 2;
          }

          goto LABEL_715;
        }
      }

LABEL_731:

      return google::protobuf::io::EpsCopyOutputStream::WriteStringOutline(a4, a2, v86, v5);
    case 0xD:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v125 = *this;
      v126 = 8 * a2;
      if (8 * a2 > 0x7F)
      {
        *v5 = v126 | 0x80;
        v362 = v126 >> 7;
        if (v126 >> 14)
        {
          v53 = v5 + 2;
          do
          {
            *(v53 - 1) = v362 | 0x80;
            v383 = v362 >> 7;
            ++v53;
            v384 = v362 >> 14;
            v362 >>= 7;
          }

          while (v384);
          *(v53 - 1) = v383;
        }

        else
        {
          v5[1] = v362;
          v53 = v5 + 2;
        }
      }

      else
      {
        *v5 = v126;
        v53 = v5 + 1;
      }

      if (v125 <= 0x7F)
      {
        goto LABEL_680;
      }

      *v53 = v125 | 0x80;
      v385 = v125 >> 7;
      if (!(v125 >> 14))
      {
        v53[1] = v385;
        return v53 + 2;
      }

      v5 = v53 + 2;
      do
      {
        *(v5 - 1) = v385 | 0x80;
        v386 = v385 >> 7;
        ++v5;
        v387 = v385 >> 14;
        v385 >>= 7;
      }

      while (v387);
LABEL_660:
      *(v5 - 1) = v386;
      return v5;
    case 0xE:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v110 = *this;
      v256 = 8 * a2;
      if (8 * a2 > 0x7F)
      {
        *v5 = v256 | 0x80;
        v367 = v256 >> 7;
        if (v256 >> 14)
        {
          v53 = v5 + 2;
          do
          {
            *(v53 - 1) = v367 | 0x80;
            v407 = v367 >> 7;
            ++v53;
            v408 = v367 >> 14;
            v367 >>= 7;
          }

          while (v408);
          *(v53 - 1) = v407;
        }

        else
        {
          v5[1] = v367;
          v53 = v5 + 2;
        }
      }

      else
      {
        *v5 = v256;
        v53 = v5 + 1;
      }

      if (v110 <= 0x7F)
      {
LABEL_699:
        *v53 = v110;
        return v53 + 1;
      }

      *v53 = v110 | 0x80;
      v380 = v110 >> 7;
      if (!(v110 >> 14))
      {
LABEL_701:
        v53[1] = v380;
        return v53 + 2;
      }

      v5 = v53 + 2;
      do
      {
        *(v5 - 1) = v380 | 0x80;
        v381 = v380 >> 7;
        ++v5;
        v409 = v380 >> 14;
        v380 >>= 7;
      }

      while (v409);
LABEL_705:
      *(v5 - 1) = v381;
      return v5;
    case 0xF:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v66 = *this;
      v67 = 8 * a2;
      if (8 * a2 <= 0x7F)
      {
LABEL_394:
        *v5 = v67 | 5;
        v69 = (v5 + 1);
      }

      else
      {
        *v5 = v67 | 0x85;
        v68 = v67 >> 7;
        if (v67 >> 14)
        {
          v69 = (v5 + 2);
          do
          {
            *(v69 - 1) = v68 | 0x80;
            v70 = v68 >> 7;
            v69 = (v69 + 1);
            v71 = v68 >> 14;
            v68 >>= 7;
          }

          while (v71);
LABEL_708:
          *(v69 - 1) = v70;
        }

        else
        {
LABEL_609:
          v5[1] = v68;
          v69 = (v5 + 2);
        }
      }

      *v69 = v66;
      return (v69 + 1);
    case 0x10:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v23 = *this;
      v24 = 8 * a2;
      if (8 * a2 <= 0x7F)
      {
LABEL_353:
        *v5 = v24 | 1;
        v26 = (v5 + 1);
      }

      else
      {
        *v5 = v24 | 0x81;
        v25 = v24 >> 7;
        if (v24 >> 14)
        {
          v26 = (v5 + 2);
          do
          {
            *(v26 - 1) = v25 | 0x80;
            v27 = v25 >> 7;
            v26 = (v26 + 1);
            v175 = v25 >> 14;
            v25 >>= 7;
          }

          while (v175);
LABEL_693:
          *(v26 - 1) = v27;
        }

        else
        {
LABEL_605:
          v5[1] = v25;
          v26 = (v5 + 2);
        }
      }

      *v26 = v23;
      return (v26 + 1);
    case 0x11:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v51 = *this;
      v52 = 8 * a2;
      if (8 * a2 > 0x7F)
      {
        *v5 = v52 | 0x80;
        v360 = v52 >> 7;
        if (v52 >> 14)
        {
          v53 = v5 + 2;
          do
          {
            *(v53 - 1) = v360 | 0x80;
            v372 = v360 >> 7;
            ++v53;
            v373 = v360 >> 14;
            v360 >>= 7;
          }

          while (v373);
          *(v53 - 1) = v372;
        }

        else
        {
          v5[1] = v360;
          v53 = v5 + 2;
        }
      }

      else
      {
        *v5 = v52;
        v53 = v5 + 1;
      }

      v374 = (2 * v51) ^ (v51 >> 31);
      if (v374 <= 0x7F)
      {
        *v53 = v374;
        return v53 + 1;
      }

      *v53 = v374 | 0x80;
      v375 = v374 >> 7;
      if (!(v374 >> 14))
      {
        v53[1] = v375;
        return v53 + 2;
      }

      v5 = v53 + 2;
      do
      {
        *(v5 - 1) = v375 | 0x80;
        v376 = v375 >> 7;
        ++v5;
        v377 = v375 >> 14;
        v375 >>= 7;
      }

      while (v377);
      *(v5 - 1) = v376;
      return v5;
    case 0x12:
      if (*a4 <= a3)
      {
        v5 = google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(a4, a3);
      }

      v229 = *this;
      v230 = 8 * a2;
      if (8 * a2 > 0x7F)
      {
        *v5 = v230 | 0x80;
        v366 = v230 >> 7;
        if (v230 >> 14)
        {
          v53 = v5 + 2;
          do
          {
            *(v53 - 1) = v366 | 0x80;
            v400 = v366 >> 7;
            ++v53;
            v401 = v366 >> 14;
            v366 >>= 7;
          }

          while (v401);
          *(v53 - 1) = v400;
        }

        else
        {
          v5[1] = v366;
          v53 = v5 + 2;
        }
      }

      else
      {
        *v5 = v230;
        v53 = v5 + 1;
      }

      v402 = (2 * v229) ^ (v229 >> 63);
      if (v402 > 0x7F)
      {
        *v53 = v402 | 0x80;
        v403 = v402 >> 7;
        if (v402 >> 14)
        {
          v5 = v53 + 2;
          do
          {
            *(v5 - 1) = v403 | 0x80;
            v404 = v403 >> 7;
            ++v5;
            v405 = v403 >> 14;
            v403 >>= 7;
          }

          while (v405);
          *(v5 - 1) = v404;
        }

        else
        {
          v53[1] = v403;
          return v53 + 2;
        }
      }

      else
      {
        *v53 = v402;
        return v53 + 1;
      }

      return v5;
    default:
      return v5;
  }
}

void sub_1B5ACBE4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  google::protobuf::internal::LogMessage::~LogMessage(va);
  _Unwind_Resume(a1);
}

uint64_t google::protobuf::internal::ExtensionSet::ByteSize(google::protobuf::internal::ExtensionSet *this)
{
  v7 = 0;
  v1 = *(this + 2);
  if (*(this + 4) >= 0x101u)
  {
    google::protobuf::internal::ExtensionSet::ForEach<std::__map_iterator<std::__tree_iterator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__tree_node<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,void *> *,long>>,google::protobuf::internal::ExtensionSet::ByteSize(void)::$_0>(*v1, v1 + 1, &v7);
    return v7;
  }

  else if (*(this + 5))
  {
    v2 = 0;
    v3 = &v1[8 * *(this + 5)];
    v4 = *(this + 2);
    do
    {
      v5 = *v4;
      v4 += 8;
      v2 += google::protobuf::internal::ExtensionSet::Extension::ByteSize(v1 + 1, v5);
      v1 = v4;
    }

    while (v4 != v3);
  }

  else
  {
    return 0;
  }

  return v2;
}

unint64_t google::protobuf::internal::ExtensionSet::Extension::ByteSize(uint64_t **this, int a2)
{
  if (*(this + 9) == 1)
  {
    if (*(this + 11) == 1)
    {
      switch(*(this + 8))
      {
        case 1:
        case 6:
        case 0x10:
          v7 = 8 * **this;
          goto LABEL_110;
        case 2:
        case 7:
        case 0xF:
          v7 = 4 * **this;
          goto LABEL_110;
        case 3:
          v68 = **this;
          if (v68 < 1)
          {
            goto LABEL_5;
          }

          v7 = 0;
          v69 = (*this)[1];
          do
          {
            v70 = *v69++;
            v7 += (9 * (__clz(v70 | 1) ^ 0x3F) + 73) >> 6;
            --v68;
          }

          while (v68);
          goto LABEL_110;
        case 4:
          v71 = **this;
          if (v71 < 1)
          {
            goto LABEL_5;
          }

          v7 = 0;
          v72 = (*this)[1];
          do
          {
            v73 = *v72++;
            v7 += (9 * (__clz(v73 | 1) ^ 0x3F) + 73) >> 6;
            --v71;
          }

          while (v71);
          goto LABEL_110;
        case 5:
          v51 = **this;
          if (v51 < 1)
          {
            goto LABEL_5;
          }

          v7 = 0;
          v52 = (*this)[1];
          do
          {
            v54 = *v52++;
            v53 = v54;
            if (v54 < 0)
            {
              v55 = 10;
            }

            else
            {
              v55 = (9 * (__clz(v53 | 1) ^ 0x1F) + 73) >> 6;
            }

            v7 += v55;
            --v51;
          }

          while (v51);
          goto LABEL_110;
        case 8:
          v7 = **this;
          goto LABEL_110;
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          google::protobuf::internal::LogMessage::LogMessage(v87, 3, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/third_party/protobuf-lite/extension_set.cc", 1599);
          v3 = google::protobuf::internal::LogMessage::operator<<(v87, "Non-primitive types can't be packed.");
          google::protobuf::internal::LogFinisher::operator=(&v86, &v3->__r_.__value_.__l.__data_);
          google::protobuf::internal::LogMessage::~LogMessage(&v87[0].__r_.__value_.__l.__data_);
          goto LABEL_5;
        case 0xD:
          v19 = **this;
          if (v19 < 1)
          {
            goto LABEL_5;
          }

          v7 = 0;
          v20 = (*this)[1];
          do
          {
            v21 = *v20++;
            v7 += (9 * (__clz(v21 | 1) ^ 0x1F) + 73) >> 6;
            --v19;
          }

          while (v19);
          goto LABEL_110;
        case 0xE:
          v36 = **this;
          if (v36 < 1)
          {
            goto LABEL_5;
          }

          v7 = 0;
          v37 = (*this)[1];
          do
          {
            v39 = *v37++;
            v38 = v39;
            if (v39 < 0)
            {
              v40 = 10;
            }

            else
            {
              v40 = (9 * (__clz(v38 | 1) ^ 0x1F) + 73) >> 6;
            }

            v7 += v40;
            --v36;
          }

          while (v36);
          goto LABEL_110;
        case 0x11:
          v12 = **this;
          if (v12 < 1)
          {
            goto LABEL_5;
          }

          v7 = 0;
          v13 = (*this)[1];
          do
          {
            v14 = *v13++;
            v7 += (9 * (__clz((2 * v14) ^ (v14 >> 31) | 1) ^ 0x1F) + 73) >> 6;
            --v12;
          }

          while (v12);
          goto LABEL_110;
        case 0x12:
          v56 = **this;
          if (v56 < 1)
          {
            goto LABEL_5;
          }

          v7 = 0;
          v57 = (*this)[1];
          do
          {
            v58 = *v57++;
            v7 += (9 * (__clz((2 * v58) ^ (v58 >> 63) | 1) ^ 0x3F) + 73) >> 6;
            --v56;
          }

          while (v56);
LABEL_110:
          *(this + 3) = v7;
          v74 = v7 + ((9 * (__clz((8 * a2) | 3) ^ 0x1F) + 73) >> 6) + ((9 * (__clz(v7 | 1) ^ 0x1F) + 73) >> 6);
          if (v7)
          {
            v4 = v74;
          }

          else
          {
            v4 = 0;
          }

          break;
        default:
LABEL_5:
          v4 = 0;
          *(this + 3) = 0;
          break;
      }
    }

    else
    {
      v5 = ((9 * (__clz((8 * a2) | 1) ^ 0x1F) + 73) >> 6) << (*(this + 8) == 10);
      switch(*(this + 8))
      {
        case 1:
        case 6:
        case 0x10:
          v6 = v5 + 8;
          goto LABEL_13;
        case 2:
        case 7:
        case 0xF:
          v6 = v5 + 4;
LABEL_13:
          v4 = v6 * **this;
          break;
        case 3:
          v62 = **this;
          v4 = v5 * v62;
          if (v62 >= 1)
          {
            v63 = (*this)[1];
            do
            {
              v64 = *v63++;
              v4 += (9 * (__clz(v64 | 1) ^ 0x3F) + 73) >> 6;
              --v62;
            }

            while (v62);
          }

          break;
        case 4:
          v65 = **this;
          v4 = v5 * v65;
          if (v65 >= 1)
          {
            v66 = (*this)[1];
            do
            {
              v67 = *v66++;
              v4 += (9 * (__clz(v67 | 1) ^ 0x3F) + 73) >> 6;
              --v65;
            }

            while (v65);
          }

          break;
        case 5:
          v46 = **this;
          v4 = v5 * v46;
          if (v46 >= 1)
          {
            v47 = (*this)[1];
            do
            {
              v49 = *v47++;
              v48 = v49;
              if (v49 < 0)
              {
                v50 = 10;
              }

              else
              {
                v50 = (9 * (__clz(v48 | 1) ^ 0x1F) + 73) >> 6;
              }

              v4 += v50;
              --v46;
            }

            while (v46);
          }

          break;
        case 8:
          v4 = **this + **this * v5;
          break;
        case 9:
          v81 = *(*this + 2);
          v4 = v5 * v81;
          if (v81 >= 1)
          {
            v82 = ((*this)[2] + 8);
            do
            {
              v83 = *v82++;
              v84 = *(v83 + 23);
              v85 = *(v83 + 8);
              if ((v84 & 0x80u) == 0)
              {
                v85 = v84;
              }

              v4 += v85 + ((9 * (__clz(v85 | 1) ^ 0x1F) + 73) >> 6);
              --v81;
            }

            while (v81);
          }

          break;
        case 0xA:
          v25 = *this;
          v26 = *(*this + 2);
          v4 = v5 * v26;
          if (v26 >= 1)
          {
            v27 = 0;
            do
            {
              v28 = *(*(v25 + 2) + 8 * v27 + 8);
              v4 += (*(*v28 + 72))(v28);
              ++v27;
              v25 = *this;
            }

            while (v27 < *(*this + 2));
          }

          break;
        case 0xB:
          v31 = *this;
          v32 = *(*this + 2);
          v4 = v5 * v32;
          if (v32 >= 1)
          {
            v33 = 0;
            do
            {
              v34 = *(*(v31 + 2) + 8 * v33 + 8);
              v35 = (*(*v34 + 72))(v34);
              v4 += v35 + ((9 * (__clz(v35 | 1) ^ 0x1F) + 73) >> 6);
              ++v33;
              v31 = *this;
            }

            while (v33 < *(*this + 2));
          }

          break;
        case 0xC:
          v76 = *(*this + 2);
          v4 = v5 * v76;
          if (v76 >= 1)
          {
            v77 = ((*this)[2] + 8);
            do
            {
              v78 = *v77++;
              v79 = *(v78 + 23);
              v80 = *(v78 + 8);
              if ((v79 & 0x80u) == 0)
              {
                v80 = v79;
              }

              v4 += v80 + ((9 * (__clz(v80 | 1) ^ 0x1F) + 73) >> 6);
              --v76;
            }

            while (v76);
          }

          break;
        case 0xD:
          v22 = **this;
          v4 = v5 * v22;
          if (v22 >= 1)
          {
            v23 = (*this)[1];
            do
            {
              v24 = *v23++;
              v4 += (9 * (__clz(v24 | 1) ^ 0x1F) + 73) >> 6;
              --v22;
            }

            while (v22);
          }

          break;
        case 0xE:
          v41 = **this;
          v4 = v5 * v41;
          if (v41 >= 1)
          {
            v42 = (*this)[1];
            do
            {
              v44 = *v42++;
              v43 = v44;
              if (v44 < 0)
              {
                v45 = 10;
              }

              else
              {
                v45 = (9 * (__clz(v43 | 1) ^ 0x1F) + 73) >> 6;
              }

              v4 += v45;
              --v41;
            }

            while (v41);
          }

          break;
        case 0x11:
          v15 = **this;
          v4 = v5 * v15;
          if (v15 >= 1)
          {
            v16 = (*this)[1];
            do
            {
              v17 = *v16++;
              v4 += (9 * (__clz((2 * v17) ^ (v17 >> 31) | 1) ^ 0x1F) + 73) >> 6;
              --v15;
            }

            while (v15);
          }

          break;
        case 0x12:
          v59 = **this;
          v4 = v5 * v59;
          if (v59 >= 1)
          {
            v60 = (*this)[1];
            do
            {
              v61 = *v60++;
              v4 += (9 * (__clz((2 * v61) ^ (v61 >> 63) | 1) ^ 0x3F) + 73) >> 6;
              --v59;
            }

            while (v59);
          }

          break;
        default:
          return 0;
      }
    }
  }

  else if (*(this + 10))
  {
    return 0;
  }

  else
  {
    v4 = ((9 * (__clz((8 * a2) | 1) ^ 0x1F) + 73) >> 6) << (*(this + 8) == 10);
    switch(*(this + 8))
    {
      case 1:
      case 6:
      case 0x10:
        v4 += 8;
        return v4;
      case 2:
      case 7:
      case 0xF:
        v4 += 4;
        return v4;
      case 3:
      case 4:
        v8 = *this;
        goto LABEL_94;
      case 5:
      case 0xE:
        v9 = (9 * (__clz(*this | 1) ^ 0x1F) + 73) >> 6;
        if (*this >= 0)
        {
          v10 = v9;
        }

        else
        {
          v10 = 10;
        }

        v4 += v10;
        return v4;
      case 8:
        return ++v4;
      case 9:
      case 0xC:
        v11 = (*this)[1];
        if (*(*this + 23) >= 0)
        {
          v11 = *(*this + 23);
        }

        v4 += v11 + ((9 * (__clz(v11 | 1) ^ 0x1F) + 73) >> 6);
        return v4;
      case 0xA:
        v4 += (*(**this + 72))();
        return v4;
      case 0xB:
        v29 = **this;
        if ((*(this + 10) & 0x10) != 0)
        {
          v30 = (*(v29 + 88))();
        }

        else
        {
          v30 = (*(v29 + 72))();
        }

        v4 += v30 + ((9 * (__clz(v30 | 1) ^ 0x1F) + 73) >> 6);
        return v4;
      case 0xD:
        v18 = *this;
        goto LABEL_70;
      case 0x11:
        v18 = (2 * *this) ^ (*this >> 31);
LABEL_70:
        v4 += (9 * (__clz(v18 | 1) ^ 0x1F) + 73) >> 6;
        break;
      case 0x12:
        v8 = (2 * *this) ^ (*this >> 63);
LABEL_94:
        v4 += (9 * (__clz(v8 | 1) ^ 0x3F) + 73) >> 6;
        break;
      default:
        return v4;
    }
  }

  return v4;
}

void sub_1B5ACC834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  google::protobuf::internal::LogMessage::~LogMessage(va);
  _Unwind_Resume(a1);
}

uint64_t *google::protobuf::internal::ExtensionSet::Extension::Free(uint64_t *this)
{
  v1 = google::protobuf::internal::WireFormatLite::kFieldTypeToCppTypeMap[*(this + 8)];
  if (*(this + 9) == 1)
  {
    if (v1 <= 5)
    {
      if (v1 > 2)
      {
        if (v1 == 3)
        {
          this = *this;
          if (this)
          {
            goto LABEL_43;
          }
        }

        else if (v1 == 4)
        {
          this = *this;
          if (this)
          {
LABEL_43:
            google::protobuf::RepeatedField<BOOL>::~RepeatedField(this);
            goto LABEL_44;
          }
        }

        else
        {
          this = *this;
          if (this)
          {
            goto LABEL_43;
          }
        }

        return this;
      }

      if (v1 != 1)
      {
        if (v1 == 2)
        {
          this = *this;
          if (this)
          {
            goto LABEL_43;
          }
        }

        return this;
      }

LABEL_32:
      this = *this;
      if (this)
      {
        goto LABEL_43;
      }

      return this;
    }

    if (v1 <= 7)
    {
      if (v1 == 6)
      {
        this = *this;
        if (this)
        {
          goto LABEL_43;
        }
      }

      else
      {
        this = *this;
        if (this)
        {
          goto LABEL_43;
        }
      }

      return this;
    }

    if (v1 == 8)
    {
      goto LABEL_32;
    }

    if (v1 != 9)
    {
      if (v1 == 10 && *this)
      {
        google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>::TypeHandler>(*this);
        goto LABEL_44;
      }

      return this;
    }

    this = *this;
    if (!this)
    {
      return this;
    }

    google::protobuf::RepeatedPtrField<std::string>::~RepeatedPtrField(this);
LABEL_44:

    JUMPOUT(0x1B8C85350);
  }

  if (v1 == 10)
  {
    v3 = *(this + 10);
    this = *this;
    if ((v3 & 0x10) != 0)
    {
      if (!this)
      {
        return this;
      }

      v4 = *(*this + 8);
    }

    else
    {
      if (!this)
      {
        return this;
      }

      v4 = *(*this + 8);
    }

    return v4();
  }

  if (v1 == 9)
  {
    v2 = *this;
    if (*this)
    {
      if (*(v2 + 23) < 0)
      {
        operator delete(*v2);
      }

      goto LABEL_44;
    }
  }

  return this;
}

uint64_t *google::protobuf::internal::ExtensionSet::ForEach<std::__map_iterator<std::__tree_iterator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__tree_node<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,void *> *,long>>,google::protobuf::internal::ExtensionSet::~()::$_0>(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    v3 = result;
    do
    {
      result = google::protobuf::internal::ExtensionSet::Extension::Free(v3 + 5);
      v4 = v3[1];
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = *v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          v5 = v3[2];
          v6 = *v5 == v3;
          v3 = v5;
        }

        while (!v6);
      }

      v3 = v5;
    }

    while (v5 != a2);
  }

  return result;
}

unsigned int *google::protobuf::internal::RepeatedPtrFieldBase::AddAllocatedInternal<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>::TypeHandler>(unsigned int *this, uint64_t a2)
{
  v2 = *(this + 2);
  if (!v2)
  {
    return google::protobuf::internal::RepeatedPtrFieldBase::UnsafeArenaAddAllocated<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>::TypeHandler>(this, a2);
  }

  v3 = *v2;
  if (v3 >= this[3])
  {
    return google::protobuf::internal::RepeatedPtrFieldBase::UnsafeArenaAddAllocated<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>::TypeHandler>(this, a2);
  }

  v4 = v2 + 2;
  v5 = this[2];
  if (v5 < v3)
  {
    *&v4[2 * v3] = *&v4[2 * v5];
  }

  *&v4[2 * v5] = a2;
  this[2] = v5 + 1;
  ++**(this + 2);
  return this;
}

unsigned int *google::protobuf::internal::RepeatedPtrFieldBase::UnsafeArenaAddAllocated<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>::TypeHandler>(unsigned int *this, uint64_t a2)
{
  v3 = this;
  v4 = *(this + 2);
  if (!v4)
  {
    v5 = this[3];
    goto LABEL_11;
  }

  v5 = this[2];
  v6 = this[3];
  if (v5 == v6)
  {
LABEL_11:
    this = google::protobuf::internal::RepeatedPtrFieldBase::Reserve(this, v5 + 1);
    goto LABEL_12;
  }

  v7 = *v4;
  if (v7 != v6)
  {
    if (v5 >= v7)
    {
      v9 = v7 + 1;
      goto LABEL_13;
    }

    *&v4[2 * v7 + 2] = *&v4[2 * v5 + 2];
LABEL_12:
    v4 = *(v3 + 2);
    v9 = *v4 + 1;
LABEL_13:
    *v4 = v9;
    goto LABEL_14;
  }

  this = *&v4[2 * v5 + 2];
  if (this)
  {
    v8 = *v3 == 0;
  }

  else
  {
    v8 = 0;
  }

  if (v8)
  {
    this = (*(*this + 8))(this);
    v4 = *(v3 + 2);
  }

LABEL_14:
  v10 = v3[2];
  v3[2] = v10 + 1;
  *&v4[2 * v10 + 2] = a2;
  return this;
}

unsigned __int8 *google::protobuf::internal::ExtensionSet::ForEach<std::__map_iterator<std::__tree_iterator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__tree_node<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,void *> *,long>>,google::protobuf::internal::ExtensionSet::Clear(void)::$_0>(unsigned __int8 *result, unsigned __int8 *a2)
{
  if (result != a2)
  {
    v3 = result;
    do
    {
      result = google::protobuf::internal::ExtensionSet::Extension::Clear(v3 + 40);
      v4 = *(v3 + 1);
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = *v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          v5 = *(v3 + 2);
          v6 = *v5 == v3;
          v3 = v5;
        }

        while (!v6);
      }

      v3 = v5;
    }

    while (v5 != a2);
  }

  return result;
}

google::protobuf::internal::ExtensionSet *google::protobuf::internal::ExtensionSet::ForEach<std::__map_iterator<std::__tree_iterator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__tree_node<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,void *> *,long>>,google::protobuf::internal::ExtensionSet::MergeFrom(google::protobuf::internal::ExtensionSet const&)::$_0>(void *a1, void *a2, google::protobuf::internal::ExtensionSet *this)
{
  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      google::protobuf::internal::ExtensionSet::InternalExtensionMergeFrom(this, *(v5 + 8), v5 + 5);
      v6 = v5[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = *v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          v7 = v5[2];
          v8 = *v7 == v5;
          v5 = v7;
        }

        while (!v8);
      }

      v5 = v7;
    }

    while (v7 != a2);
  }

  return this;
}

google::protobuf::internal *google::protobuf::internal::EpsCopyInputStream::ReadPackedVarint<char const* google::protobuf::internal::PackedEnumParserArg<std::string>(void *,char const*,google::protobuf::internal::ParseContext *,BOOL (*)(void const*,int),void const*,google::protobuf::internal::InternalMetadata *,int)::{lambda(unsigned long long)#1}>(uint64_t a1, google::protobuf::internal *this, __int128 *a3)
{
  v23 = *MEMORY[0x1E69E9840];
  v5 = *this;
  if ((*this & 0x80000000) == 0)
  {
    result = (this + 1);
    goto LABEL_5;
  }

  result = google::protobuf::internal::ReadSizeFallback(this, *this);
  if (result)
  {
    v5 = v7;
    while (1)
    {
LABEL_5:
      v8 = *(a1 + 8);
      v9 = v8 - result;
      if (v5 <= v8 - result)
      {
        v14 = result + v5;
        v15 = a3[1];
        v17 = *a3;
        v18 = v15;
        v19 = *(a3 + 4);
        result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::PackedEnumParserArg<std::string>(void *,char const*,google::protobuf::internal::ParseContext *,BOOL (*)(void const*,int),void const*,google::protobuf::internal::InternalMetadata *,int)::{lambda(unsigned long long)#1}>(result, v14, &v17);
        if (v14 != result)
        {
          return 0;
        }

        return result;
      }

      v10 = a3[1];
      v17 = *a3;
      v18 = v10;
      v19 = *(a3 + 4);
      result = google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::PackedEnumParserArg<std::string>(void *,char const*,google::protobuf::internal::ParseContext *,BOOL (*)(void const*,int),void const*,google::protobuf::internal::InternalMetadata *,int)::{lambda(unsigned long long)#1}>(result, v8, &v17);
      if (!result)
      {
        return result;
      }

      v11 = *(a1 + 8);
      v12 = result - v11;
      v13 = v5 - v9;
      if (v5 - v9 <= 16)
      {
        break;
      }

      if (*(a1 + 28) < 17)
      {
        return 0;
      }

      result = google::protobuf::internal::EpsCopyInputStream::Next(a1);
      if (!result)
      {
        return result;
      }

      v5 = v5 - v9 - v12;
      result = (result + v12);
    }

    v22 = 0;
    v21 = 0;
    v20 = *v11;
    v16 = a3[1];
    v17 = *a3;
    v18 = v16;
    v19 = *(a3 + 4);
    if (google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::PackedEnumParserArg<std::string>(void *,char const*,google::protobuf::internal::ParseContext *,BOOL (*)(void const*,int),void const*,google::protobuf::internal::InternalMetadata *,int)::{lambda(unsigned long long)#1}>((&v20 + v12), &v20 + v13, &v17) != (&v20 + v13))
    {
      return 0;
    }

    return (*(a1 + 8) + v13);
  }

  return result;
}

unsigned __int8 *google::protobuf::internal::ReadPackedVarintArray<char const* google::protobuf::internal::PackedEnumParserArg<std::string>(void *,char const*,google::protobuf::internal::ParseContext *,BOOL (*)(void const*,int),void const*,google::protobuf::internal::InternalMetadata *,int)::{lambda(unsigned long long)#1}>(google::protobuf::internal *this, unint64_t a2, unsigned int **a3)
{
  v3 = this;
  if (this < a2)
  {
    do
    {
      v6 = *v3;
      if ((v6 & 0x8000000000000000) != 0)
      {
        v7 = (v3[1] << 7) + v6;
        v6 = (v7 - 128);
        if (v3[1] < 0)
        {
          v3 = google::protobuf::internal::VarintParseSlow64(v3, (v7 - 128));
          if (!v3)
          {
            return v3;
          }

          v6 = v8;
        }

        else
        {
          v3 += 2;
        }
      }

      else
      {
        ++v3;
      }

      if ((a3[1])(a3[2], v6))
      {
        v9 = *a3;
        v10 = **a3;
        if (v10 == (*a3)[1])
        {
          v11 = v10 + 1;
          google::protobuf::RepeatedField<int>::Reserve(*a3, v10 + 1);
          *(*(v9 + 1) + 4 * v10) = v6;
        }

        else
        {
          *(*(v9 + 1) + 4 * v10) = v6;
          v11 = v10 + 1;
        }

        *v9 = v11;
      }

      else
      {
        v12 = *(a3 + 8);
        v13 = a3[3];
        if (*v13)
        {
          v14 = ((*v13 & 0xFFFFFFFFFFFFFFFELL) + 8);
        }

        else
        {
          v14 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>(v13);
        }

        google::protobuf::internal::WriteVarint(v12, v6, v14);
      }
    }

    while (v3 < a2);
  }

  return v3;
}

char *google::protobuf::internal::EpsCopyInputStream::InitFrom(uint64_t a1, char *__src, int64_t __n)
{
  *(a1 + 84) = 0;
  if (__n >= 17)
  {
    *(a1 + 28) = 16;
    v6 = &__src[__n - 16];
    *a1 = v6;
    *(a1 + 8) = v6;
    *(a1 + 16) = a1 + 40;
    if (*(a1 + 72) != 1)
    {
      return __src;
    }

    v7 = 2;
    v8 = __src;
    goto LABEL_6;
  }

  v8 = (a1 + 40);
  memcpy((a1 + 40), __src, __n);
  *(a1 + 28) = 0;
  *a1 = &v8[__n];
  *(a1 + 8) = &v8[__n];
  *(a1 + 16) = 0;
  if (*(a1 + 72) == 1)
  {
    v7 = __src - v8;
LABEL_6:
    *(a1 + 72) = v7;
  }

  return v8;
}

void *google::protobuf::internal::ExtensionSet::ForEach<std::__map_iterator<std::__tree_iterator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__tree_node<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,void *> *,long>>,google::protobuf::internal::ExtensionSet::ByteSize(void)::$_0>(void *a1, void *a2, void *a3)
{
  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      *a3 += google::protobuf::internal::ExtensionSet::Extension::ByteSize(v5 + 5, *(v5 + 8));
      v6 = v5[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = *v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          v7 = v5[2];
          v8 = *v7 == v5;
          v5 = v7;
        }

        while (!v8);
      }

      v5 = v7;
    }

    while (v7 != a2);
  }

  return a3;
}

void google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<google::protobuf::MessageLite>::TypeHandler>(void *a1)
{
  v2 = a1[2];
  if (v2 && !*a1)
  {
    v3 = v2 + 2;
    v4 = *v2;
    if (v4 >= 1)
    {
      do
      {
        if (*v3)
        {
          (*(**v3 + 8))(*v3);
        }

        ++v3;
        --v4;
      }

      while (v4);
      v2 = a1[2];
    }

    operator delete(v2);
  }

  a1[2] = 0;
}

uint64_t *std::__tree<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__map_value_compare<int,std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::less<int>,true>,std::allocator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>>>::__emplace_unique_key_args<int,std::pair<int const,google::protobuf::internal::ExtensionSet::Extension>>(uint64_t a1, int *a2)
{
  v2 = *(a1 + 8);
  if (!v2)
  {
LABEL_8:
    operator new();
  }

  v3 = *a2;
  while (1)
  {
    while (1)
    {
      v4 = v2;
      v5 = *(v2 + 32);
      if (v3 >= v5)
      {
        break;
      }

      v2 = *v4;
      if (!*v4)
      {
        goto LABEL_8;
      }
    }

    if (v5 >= v3)
    {
      return v4;
    }

    v2 = v4[1];
    if (!v2)
    {
      goto LABEL_8;
    }
  }
}

uint64_t std::__tree<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__map_value_compare<int,std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::less<int>,true>,std::allocator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>>>::__emplace_hint_unique_key_args<int,std::pair<int const,google::protobuf::internal::ExtensionSet::Extension>>(void *a1, uint64_t *a2, int *a3)
{
  v3 = *std::__tree<std::__value_type<quasar::LmeDataFactoryBase::LmeType,std::vector<std::shared_ptr<quasar::LmeContainer>>>,std::__map_value_compare<quasar::LmeDataFactoryBase::LmeType,std::__value_type<quasar::LmeDataFactoryBase::LmeType,std::vector<std::shared_ptr<quasar::LmeContainer>>>,std::less<quasar::LmeDataFactoryBase::LmeType>,true>,std::allocator<std::__value_type<quasar::LmeDataFactoryBase::LmeType,std::vector<std::shared_ptr<quasar::LmeContainer>>>>>::__find_equal<quasar::LmeDataFactoryBase::LmeType>(a1, a2, &v6, &v5, a3);
  if (!v3)
  {
    operator new();
  }

  return v3;
}

uint64_t google::protobuf::internal::ExtensionSet::~ExtensionSet(uint64_t result, uint64_t a2)
{
  if ((result & 1) == 0)
  {
    std::__tree<int>::destroy(a2, *(a2 + 8));

    JUMPOUT(0x1B8C85350);
  }

  return result;
}

uint64_t google::protobuf::internal::ExtensionSet::MutableRawRepeatedField(uint64_t a1)
{
  v1 = OUTLINED_FUNCTION_2_7(a1);
}

{
  v1 = OUTLINED_FUNCTION_2_7(a1);
}

uint64_t google::protobuf::internal::ExtensionSet::GrowCapacity(uint64_t a1)
{
  v1 = OUTLINED_FUNCTION_2_7(a1);
}

{
  v1 = OUTLINED_FUNCTION_2_7(a1);
}

void google::protobuf::internal::DestroyString(void **this, const void *a2)
{
  if (*(this + 23) < 0)
  {
    operator delete(*this);
  }
}

void google::protobuf::internal::InitProtobufDefaultsSlow(google::protobuf::internal *this)
{
  {
    google::protobuf::internal::fixed_address_empty_string = 0;
    unk_1EB90C320 = 0;
    qword_1EB90C328 = 0;
    google::protobuf::internal::OnShutdownRun(google::protobuf::internal::DestroyString, &google::protobuf::internal::fixed_address_empty_string, v1);
    atomic_store(1u, google::protobuf::internal::init_protobuf_defaults_state);
  }
}

uint64_t google::protobuf::internal::GenericSwap(uint64_t a1, uint64_t a2)
{
  v4 = (*(*a1 + 24))(a1);
  (*(*v4 + 64))(v4, a1);
  (*(*a1 + 40))(a1);
  (*(*a1 + 64))(a1, a2);
  (*(*a2 + 40))(a2);
  (*(*a2 + 64))(a2, v4);
  v5 = *(*v4 + 8);

  return v5(v4);
}

void google::protobuf::internal::InitSCCImpl(_DWORD *a1)
{
  {
    google::protobuf::internal::InitSCCImpl();
  }

  v2 = pthread_self();
  v3 = v2;
  if (google::protobuf::internal::InitSCCImpl(google::protobuf::internal::SCCInfoBase *)::runner == v2)
  {
    if (*a1 != 1)
    {
      google::protobuf::internal::LogMessage::LogMessage(v6, 3, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/third_party/protobuf-lite/generated_message_util.cc", 785);
      v4 = google::protobuf::internal::LogMessage::operator<<(v6, "CHECK failed: (scc->visit_status.load(std::memory_order_relaxed)) == (SCCInfoBase::kRunning): ");
      google::protobuf::internal::LogFinisher::operator=(&v5, &v4->__r_.__value_.__l.__data_);
      google::protobuf::internal::LogMessage::~LogMessage(&v6[0].__r_.__value_.__l.__data_);
    }
  }

  else
  {
    if ((atomic_load_explicit(google::protobuf::internal::init_protobuf_defaults_state, memory_order_acquire) & 1) == 0)
    {
      google::protobuf::internal::InitProtobufDefaultsSlow(v2);
    }

    std::mutex::lock(&google::protobuf::internal::InitSCCImpl(google::protobuf::internal::SCCInfoBase *)::mu);
    google::protobuf::internal::InitSCCImpl(google::protobuf::internal::SCCInfoBase *)::runner = v3;
    google::protobuf::internal::InitSCCImpl(google::protobuf::internal::SCCInfoBase *)::runner = 0;

    std::mutex::unlock(&google::protobuf::internal::InitSCCImpl(google::protobuf::internal::SCCInfoBase *)::mu);
  }
}

void sub_1B5ACD96C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  google::protobuf::internal::LogMessage::~LogMessage(va);
  _Unwind_Resume(a1);
}

_DWORD *google::protobuf::internal::anonymous namespace::InitSCC_DFS(_DWORD *result)
{
  if (*result == -1)
  {
    v1 = result;
    *result = 1;
    v2 = result + 6;
    v3 = result[1];
    if (v3 >= 1)
    {
      for (i = 0; i < v3; ++i)
      {
        if (*&v2[2 * i])
        {
          v3 = *(v1 + 1);
        }
      }
    }

    v5 = v3;
    v6 = *(v1 + 2);
    if (v6 >= 1)
    {
      v7 = 0;
      v8 = &v2[2 * v5];
      do
      {
        if (**&v8[2 * v7])
        {
          v6 = *(v1 + 2);
        }

        ++v7;
      }

      while (v7 < v6);
    }

    result = v1[2]();
    atomic_store(0, v1);
  }

  return result;
}

void google::protobuf::internal::InitSCCImpl()
{
  {
    __cxa_atexit(google::protobuf::internal::WrappedMutex::~WrappedMutex, &google::protobuf::internal::InitSCCImpl(google::protobuf::internal::SCCInfoBase *)::mu, &dword_1B501D000);
  }
}

void google::protobuf::MessageLite::LogInitializationErrorMessage(google::protobuf::MessageLite *this)
{
  google::protobuf::internal::LogMessage::LogMessage(v8, 2, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/third_party/protobuf-lite/message_lite.cc", 133);
  memset(&__p, 0, sizeof(__p));
  std::string::append(&__p, "Can't ");
  std::string::append(&__p, "parse");
  std::string::append(&__p, " message of type ");
  (*(*this + 16))(&v9, this);
  if ((v11 & 0x80u) == 0)
  {
    v2 = &v9;
  }

  else
  {
    v2 = v9;
  }

  if ((v11 & 0x80u) == 0)
  {
    v3 = v11;
  }

  else
  {
    v3 = v10;
  }

  std::string::append(&__p, v2, v3);
  if (v11 < 0)
  {
    operator delete(v9);
  }

  std::string::append(&__p, " because it is missing required fields: ");
  (*(*this + 56))(&v9, this);
  if ((v11 & 0x80u) == 0)
  {
    v4 = &v9;
  }

  else
  {
    v4 = v9;
  }

  if ((v11 & 0x80u) == 0)
  {
    v5 = v11;
  }

  else
  {
    v5 = v10;
  }

  std::string::append(&__p, v4, v5);
  if (v11 < 0)
  {
    operator delete(v9);
  }

  v6 = google::protobuf::internal::LogMessage::operator<<(v8, &__p);
  google::protobuf::internal::LogFinisher::operator=(&v9, &v6->__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  google::protobuf::internal::LogMessage::~LogMessage(&v8[0].__r_.__value_.__l.__data_);
}

void sub_1B5ACDC2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  google::protobuf::internal::LogMessage::~LogMessage(&a15);
  _Unwind_Resume(a1);
}

BOOL google::protobuf::MessageLite::AppendPartialToString(uint64_t a1, std::string *a2)
{
  v2 = a2;
  v19 = *MEMORY[0x1E69E9840];
  size = SHIBYTE(a2->__r_.__value_.__r.__words[2]);
  if ((size & 0x8000000000000000) != 0)
  {
    size = a2->__r_.__value_.__l.__size_;
  }

  v5 = (*(*a1 + 72))(a1);
  v6 = v5;
  v7 = v5 >> 31;
  if (v5 >> 31)
  {
    google::protobuf::internal::LogMessage::LogMessage(v15, 2, "/Library/Caches/com.apple.xbs/Sources/EmbeddedAcousticRecognition/libquasar/libsentencepiece/third_party/protobuf-lite/message_lite.cc", 457);
    (*(*a1 + 16))(__p, a1);
    v8 = google::protobuf::internal::LogMessage::operator<<(v15, __p);
    v9 = google::protobuf::internal::LogMessage::operator<<(v8, " exceeded maximum protobuf size of 2GB: ");
    v10 = google::protobuf::internal::LogMessage::operator<<(v9, v6);
    google::protobuf::internal::LogFinisher::operator=(&v12, &v10->__r_.__value_.__l.__data_);
    if (v14 < 0)
    {
      operator delete(__p[0]);
    }

    google::protobuf::internal::LogMessage::~LogMessage(&v15[0].__r_.__value_.__l.__data_);
  }

  else
  {
    std::string::resize(v2, v5 + size, 0);
    if (SHIBYTE(v2->__r_.__value_.__r.__words[2]) < 0)
    {
      v2 = v2->__r_.__value_.__r.__words[0];
    }

    *&v15[0].__r_.__value_.__l.__data_ = v2 + size + v6;
    v16 = 0;
    v17 = 0;
    v18 = google::protobuf::io::CodedOutputStream::default_serialization_deterministic_ & 1;
    (*(*a1 + 96))(a1);
  }

  return v7 == 0;
}

void sub_1B5ACDE28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17)
{
  if (a16 < 0)
  {
    operator delete(__p);
  }

  google::protobuf::internal::LogMessage::~LogMessage(&a17);
  _Unwind_Resume(a1);
}

BOOL google::protobuf::MessageLite::SerializeAsString@<W0>(google::protobuf::MessageLite *this@<X0>, uint64_t a2@<X8>)
{
  *a2 = 0;
  *(a2 + 8) = 0;
  *(a2 + 16) = 0;
  result = google::protobuf::MessageLite::AppendPartialToString(this, a2);
  if (!result)
  {
    if (*(a2 + 23) < 0)
    {
      **a2 = 0;
      *(a2 + 8) = 0;
    }

    else
    {
      *a2 = 0;
      *(a2 + 23) = 0;
    }
  }

  return result;
}

void sub_1B5ACDEB4(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

void google::protobuf::internal::OnShutdownRun(google::protobuf::internal *this, void (*a2)(const void *), const void *a3)
{
  v5 = google::protobuf::internal::ShutdownData::get(this);
  std::mutex::lock((v5 + 24));
  *&v6 = this;
  *(&v6 + 1) = a2;
  std::vector<std::pair<void (*)(void const*),void const*>>::push_back[abi:ne200100](v5, &v6);
  std::mutex::unlock((v5 + 24));
}

uint64_t google::protobuf::internal::ShutdownData::get(google::protobuf::internal::ShutdownData *this)
{
  {
    operator new();
  }

  return google::protobuf::internal::ShutdownData::get(void)::data;
}

void std::vector<std::pair<void (*)(void const*),void const*>>::push_back[abi:ne200100](uint64_t a1, _OWORD *a2)
{
  v5 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v5 >= v4)
  {
    v7 = (v5 - *a1) >> 4;
    v8 = v7 + 1;
    if ((v7 + 1) >> 60)
    {
      std::vector<int>::__throw_length_error[abi:ne200100]();
    }

    v9 = v4 - *a1;
    if (v9 >> 3 > v8)
    {
      v8 = v9 >> 3;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFF0)
    {
      v10 = 0xFFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<void (*)(void const*),void const*>>>(a1, v10);
    }

    v11 = (16 * v7);
    *v11 = *a2;
    v6 = 16 * v7 + 16;
    v12 = *(a1 + 8) - *a1;
    v13 = v11 - v12;
    memcpy(v11 - v12, *a1, v12);
    v14 = *a1;
    *a1 = v13;
    *(a1 + 8) = v6;
    *(a1 + 16) = 0;
    if (v14)
    {
      operator delete(v14);
    }
  }

  else
  {
    *v5 = *a2;
    v6 = (v5 + 1);
  }

  *(a1 + 8) = v6;
}

void std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<void (*)(void const*),void const*>>>(uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 60))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

void google::protobuf::RepeatedField<BOOL>::Reserve(unsigned int *a1, int a2)
{
  v2 = a1[1];
  if (v2 >= a2)
  {
    return;
  }

  if (v2 < 1)
  {
    v4 = *(a1 + 1);
    v5 = 0;
    if (!v2)
    {
      if (a2 < 4)
      {
        goto LABEL_6;
      }

LABEL_10:
      v7 = 2 * v2;
      if (v7 <= a2)
      {
        v6 = a2;
      }

      else
      {
        v6 = v7;
      }

      goto LABEL_13;
    }
  }

  else
  {
    v4 = *(a1 + 1);
    v5 = v4 - 8;
  }

  v4 = *(v4 - 1);
  if (a2 >= 4)
  {
    if (v2 > 0x3FFFFFFF)
    {
      v6 = 0x7FFFFFFF;
      goto LABEL_13;
    }

    goto LABEL_10;
  }

LABEL_6:
  v6 = 4;
LABEL_13:
  if (v4)
  {
    if (v4[24])
    {
      google::protobuf::RepeatedField<BOOL>::Reserve(v4);
    }

    AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(v4, (v6 + 15) & 0xFFFFFFF8);
  }

  else
  {
    AlignedNoHook = operator new(v6 + 8);
  }

  *AlignedNoHook = v4;
  v9 = AlignedNoHook + 1;
  a1[1] = v6;
  *(a1 + 1) = v9;
  v10 = *a1;
  if (v10 >= 1)
  {
    memcpy(v9, v5 + 1, v10);
  }

  if (v5 && !*v5)
  {

    operator delete(v5);
  }
}

uint64_t google::protobuf::RepeatedField<BOOL>::~RepeatedField(uint64_t a1)
{
  if (*(a1 + 4) >= 1)
  {
    v2 = *(a1 + 8);
    v4 = *(v2 - 8);
    v3 = (v2 - 8);
    if (!v4)
    {
      operator delete(v3);
    }
  }

  return a1;
}

void google::protobuf::RepeatedField<int>::Reserve(unsigned int *a1, int a2)
{
  v2 = a1[1];
  if (v2 >= a2)
  {
    return;
  }

  if (v2 < 1)
  {
    v4 = *(a1 + 1);
    v5 = 0;
    if (!v2)
    {
      if (a2 < 4)
      {
        goto LABEL_6;
      }

LABEL_10:
      v7 = 2 * v2;
      if (v7 <= a2)
      {
        v6 = a2;
      }

      else
      {
        v6 = v7;
      }

      goto LABEL_13;
    }
  }

  else
  {
    v4 = *(a1 + 1);
    v5 = v4 - 8;
  }

  v4 = *(v4 - 1);
  if (a2 >= 4)
  {
    if (v2 > 0x3FFFFFFF)
    {
      v6 = 0x7FFFFFFF;
      goto LABEL_13;
    }

    goto LABEL_10;
  }

LABEL_6:
  v6 = 4;
LABEL_13:
  v8 = 4 * v6;
  if (v4)
  {
    v9 = v8 + 15;
    if (v4[24])
    {
      google::protobuf::RepeatedField<BOOL>::Reserve(v4);
    }

    AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(v4, v9 & 0x3FFFFFFF8);
  }

  else
  {
    AlignedNoHook = operator new(v8 + 8);
  }

  *AlignedNoHook = v4;
  v11 = AlignedNoHook + 1;
  a1[1] = v6;
  *(a1 + 1) = v11;
  v12 = *a1;
  if (v12 >= 1)
  {
    memcpy(v11, v5 + 1, 4 * v12);
  }

  if (v5 && !*v5)
  {

    operator delete(v5);
  }
}

void google::protobuf::RepeatedField<long long>::Reserve(unsigned int *a1, int a2)
{
  v2 = a1[1];
  if (v2 >= a2)
  {
    return;
  }

  if (v2 < 1)
  {
    v4 = *(a1 + 1);
    v5 = 0;
    if (!v2)
    {
      if (a2 < 4)
      {
        goto LABEL_6;
      }

LABEL_10:
      v7 = 2 * v2;
      if (v7 <= a2)
      {
        v6 = a2;
      }

      else
      {
        v6 = v7;
      }

      goto LABEL_13;
    }
  }

  else
  {
    v4 = *(a1 + 1);
    v5 = v4 - 8;
  }

  v4 = *(v4 - 1);
  if (a2 >= 4)
  {
    if (v2 > 0x3FFFFFFF)
    {
      v6 = 0x7FFFFFFF;
      goto LABEL_13;
    }

    goto LABEL_10;
  }

LABEL_6:
  v6 = 4;
LABEL_13:
  v8 = 8 * v6;
  if (v4)
  {
    v9 = v8 + 15;
    if (v4[24])
    {
      google::protobuf::RepeatedField<BOOL>::Reserve(v4);
    }

    AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(v4, v9 & 0x7FFFFFFF8);
  }

  else
  {
    AlignedNoHook = operator new(v8 + 8);
  }

  *AlignedNoHook = v4;
  v11 = AlignedNoHook + 1;
  a1[1] = v6;
  *(a1 + 1) = v11;
  v12 = *a1;
  if (v12 >= 1)
  {
    memcpy(v11, v5 + 1, 8 * v12);
  }

  if (v5 && !*v5)
  {

    operator delete(v5);
  }
}

void google::protobuf::internal::RepeatedPtrFieldBase::Destroy<google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(void *a1)
{
  v2 = a1[2];
  if (v2 && !*a1)
  {
    v3 = (v2 + 2);
    v4 = *v2;
    if (v4 >= 1)
    {
      do
      {
        v5 = *v3;
        if (*v3)
        {
          if (*(v5 + 23) < 0)
          {
            operator delete(*v5);
          }

          MEMORY[0x1B8C85350](v5, 0x1012C40EC159624);
        }

        ++v3;
        --v4;
      }

      while (v4);
      v2 = a1[2];
    }

    operator delete(v2);
  }

  a1[2] = 0;
}

unsigned int *google::protobuf::internal::RepeatedPtrFieldBase::Reserve(unsigned int *this, int a2)
{
  v2 = this[2];
  v3 = __OFSUB__(a2, v2);
  v4 = a2 - v2;
  if (!((v4 < 0) ^ v3 | (v4 == 0)))
  {
    return google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend(this, v4);
  }

  return this;
}

unsigned int *google::protobuf::internal::RepeatedPtrFieldBase::InternalExtend(google::protobuf::internal::RepeatedPtrFieldBase *this, int a2)
{
  v2 = *(this + 2);
  v3 = *(this + 3);
  v4 = v2 + a2;
  v5 = *(this + 2);
  if (v3 < v2 + a2)
  {
    v7 = *this;
    v8 = 2 * v3;
    if (2 * v3 <= v4)
    {
      v8 = v4;
    }

    if (v8 <= 4)
    {
      v9 = 4;
    }

    else
    {
      v9 = v8;
    }

    v10 = 8 * v9;
    if (v7)
    {
      v11 = v10 + 15;
      if (*(v7 + 24))
      {
        google::protobuf::RepeatedField<BOOL>::Reserve(*this);
      }

      AlignedNoHook = google::protobuf::Arena::AllocateAlignedNoHook(v7, v11 & 0x7FFFFFFF8);
    }

    else
    {
      AlignedNoHook = operator new(v10 + 8);
    }

    *(this + 2) = AlignedNoHook;
    *(this + 3) = v9;
    if (v5 && (v13 = *v5, v13 >= 1))
    {
      memcpy(AlignedNoHook + 2, v5 + 2, 8 * v13);
      AlignedNoHook = *(this + 2);
      *AlignedNoHook = *v5;
      if (!v7)
      {
        goto LABEL_17;
      }
    }

    else
    {
      *AlignedNoHook = 0;
      if (!v7)
      {
LABEL_17:
        operator delete(v5);
        AlignedNoHook = *(this + 2);
      }
    }

    v2 = *(this + 2);
    v5 = AlignedNoHook;
  }

  return &v5[2 * v2 + 2];
}

uint64_t kaldi::quasar::ShortlistDataInManyFiles::Combine(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  v7 = result;
  do
  {
    v8 = *(v7 - 8);
    v7 -= 3;
    if (v8 == 1)
    {
      result = *v7;
      if (*v7)
      {
        result = MEMORY[0x1B8C85310](result, 0x1000C8077774924);
      }
    }
  }

  while (v7 != a2);
  do
  {
    v9 = *(a3 - 8);
    a3 -= 3;
    if (v9 == 1)
    {
      result = *a3;
      if (*a3)
      {
        result = MEMORY[0x1B8C85310](result, 0x1000C8077774924);
      }
    }
  }

  while (a3 != a4);
  return result;
}

uint64_t std::allocator<kaldi::quasar::ShortlistDataOnDisk>::construct[abi:ne200100]<kaldi::quasar::ShortlistDataOnDisk,std::array<kaldi::MappableVector<int>,3ul>,std::array<kaldi::MappableVector<int>,2ul>>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  v5 = result;
  do
  {
    v6 = *(v5 - 8);
    v5 -= 3;
    if (v6 == 1)
    {
      result = *v5;
      if (*v5)
      {
        result = MEMORY[0x1B8C85310](result, 0x1000C8077774924);
      }
    }
  }

  while (v5 != a2);
  v7 = (a3 + 64);
  v8 = -72;
  v9 = v7;
  do
  {
    v10 = *v9;
    v9 -= 24;
    if (v10 == 1)
    {
      result = *(v7 - 2);
      if (result)
      {
        result = MEMORY[0x1B8C85310](result, 0x1000C8077774924);
      }
    }

    v7 = v9;
    v8 += 24;
  }

  while (v8);
  return result;
}

void kaldi::nnet1::Nnet::Nnet(void *a1)
{
  v2 = a1[40];
  if (v2)
  {
    free(v2);
  }

  a1[39] = 0;
  a1[40] = 0;
  a1[41] = 0;
}

void std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne200100](uint64_t a1)
{
  if (*(a1 + 23) < 0)
  {
    operator delete(*a1);
  }
}

void EarPmLogger()
{
  if (__cxa_guard_acquire(&qword_1EB90B748))
  {
    _MergedGlobals = os_log_create("com.apple.siri", "quasar.pm");

    __cxa_guard_release(&qword_1EB90B748);
  }
}

void TGraph::TGraph(void **a1, void **a2, uint64_t a3)
{
  v5 = *a1;
  if (v5)
  {
    *(a3 + 112) = v5;
    operator delete(v5);
  }

  v6 = *a2;
  if (*a2)
  {
    *(a3 + 88) = v6;

    operator delete(v6);
  }
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<kaldi::CuVector<float>>,kaldi::CuVector<float>*>(uint64_t a1, void *a2)
{
  v3 = a1 - 32;
  v4 = (a1 - 32);
  v5 = (a1 - 32);
  do
  {
    v6 = *v5;
    v5 -= 4;
    result = (*(v6 + 8))(v4);
    v3 -= 32;
    v8 = v4 == a2;
    v4 = v5;
  }

  while (!v8);
  return result;
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<kaldi::CuMatrix<float>>,kaldi::CuMatrix<float>*>(uint64_t a1, void *a2)
{
  v3 = a1 - 48;
  v4 = (a1 - 48);
  v5 = (a1 - 48);
  do
  {
    v6 = *v5;
    v5 -= 6;
    result = (*(v6 + 16))(v4);
    v3 -= 48;
    v8 = v4 == a2;
    v4 = v5;
  }

  while (!v8);
  return result;
}

uint64_t quasar::AppLmData::generateLmeData(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, uint64_t a5)
{
  v9 = *(a1 + 8);
  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v9);
  }

  result = *a2;
  *a2 = 0;
  if (result)
  {
    result = (*(*result + 8))(result);
  }

  *a5 = a3;
  *(a5 + 8) = a4;
  return result;
}

void quasar::AEDBeamSearchDecoder::AEDBeamSearchDecoder(uint64_t a1, void **a2, void **a3, quasar::UttDetectConfig *this)
{
  if (*(a1 + 1263) < 0)
  {
    operator delete(*a2);
  }

  if (*(a1 + 1239) < 0)
  {
    operator delete(*a3);
  }

  quasar::UttDetectConfig::~UttDetectConfig(this);
}

void quasar::artifact::TransitionArtifact(uint64_t a1)
{
  *a1 = &unk_1F2CFAA28;
  if (*(a1 + 31) < 0)
  {
    operator delete(*(a1 + 8));
  }
}

uint64_t quasar::artifact::TransitionArtifact()
{
  OUTLINED_FUNCTION_0();
  return (*(v0 + 8))();
}

{
  OUTLINED_FUNCTION_0();
  return (*(v0 + 8))();
}

void quasar::SpeechRecognizerConfig::SpeechRecognizerConfig(void *a1)
{
  v2 = a1[200];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  v3 = a1[198];
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  v4 = a1[196];
  if (v4)
  {

    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<quasar::SystemConfig>,quasar::SystemConfig*>(uint64_t a1, uint64_t a2)
{
  v3 = a1 - 1560;
  v4 = a1 - 1560;
  do
  {
    result = (*(*v4 + 48))(v4);
    v3 -= 1560;
    v6 = v4 == a2;
    v4 -= 1560;
  }

  while (!v6);
  return result;
}

uint64_t fst::ComposeFstImpl<fst::DefaultCacheStore<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::SequenceComposeFilter<fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>,fst::GenericComposeStateTable<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::IntegerFilterState<signed char>,fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::CompactHashStateTable<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>,fst::ComposeHash<fst::DefaultComposeStateTuple<int,fst::IntegerFilterState<signed char>>>>>>::OrderedExpand<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>,fst::Matcher<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>>>>(uint64_t result)
{
  v1 = *(result + 24);
  if (v1)
  {
    --*v1;
  }

  return result;
}

void quasar::QsrTextSymbolTable::QsrTextSymbolTable(uint64_t a1, void **a2, void **a3)
{
  if (*(a1 + 71) < 0)
  {
    operator delete(*a2);
  }

  if (*(a1 + 47) < 0)
  {
    operator delete(*a3);
  }

  if (*(a1 + 23) < 0)
  {
    v5 = *a1;

    operator delete(v5);
  }
}

uint64_t TClitics::isValidRoot(uint64_t *a1, uint64_t a2)
{
  result = *a1;
  if (result != a2 && result != 0)
  {
    return MEMORY[0x1B8C85310](result, 0x1000C8052888210);
  }

  return result;
}

void ___ZL28_EARSpeechRecognizerExecutorPvPFvS_ES__block_invoke_cold_1()
{
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_5();
  _os_log_fault_impl(v0, v1, v2, v3, v4, 0xCu);
}

uint64_t std::make_unique[abi:ne200100]<quasar::result_handler::VoiceEditingRecoveryHandler,std::unique_ptr<quasar::result_handler::ResultHandler>,std::shared_ptr<EARVoiceEditingClient> &,0>(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  return result;
}

uint64_t std::make_unique[abi:ne200100]<quasar::result_handler::VoiceEditingResultHandler,quasar::result_handler::VoiceEditingResultHandlerConfig &,std::unique_ptr<quasar::result_handler::ResultHandler>,decltype(nullptr),std::shared_ptr<EARVoiceEditingClient> &,0>(uint64_t a1, uint64_t *a2)
{
  v3 = *(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  result = *a2;
  *a2 = 0;
  if (result)
  {
    return (*(*result + 8))(result);
  }

  return result;
}

void buildRegExp(uint64_t *a1, uint64_t a2)
{
  v2 = *a1;
  if (v2 != a2 && v2 != 0)
  {
    OUTLINED_FUNCTION_0_3();
  }
}

_DWORD **quasar::InverseTextNormalizer::getNumTokens(_DWORD **result)
{
  if (*result)
  {
    --**result;
  }

  return result;
}

void quasar::createConstituentDfstsFromSecondPassDecoder(uint64_t a1)
{
  v2 = *a1;
  if (v2)
  {
    *(a1 + 8) = v2;
    operator delete(v2);
  }
}

void std::allocator<quasar::SpeechRequestData>::construct[abi:ne200100]<quasar::SpeechRequestData,std::shared_ptr<quasar::RunAsyncParams> &,decltype(nullptr),decltype(nullptr),std::vector<std::shared_ptr<quasar::LmeContainer>> const&,quasar::Location,std::shared_ptr<kaldi::Timer>,unsigned long>(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  v4 = *(a2 + 8);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }
}

void kaldi::quasar::LogisticRegressionModel::LogisticRegressionModel(void **a1, void **a2, uint64_t a3)
{
  v5 = *a1;
  if (v5)
  {
    *(a3 + 64) = v5;
    operator delete(v5);
  }

  v7 = a2;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v7);
  v6 = *a3;
  if (*a3)
  {
    *(a3 + 8) = v6;
    operator delete(v6);
  }
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<kaldi::quasar::ErrorRegion>,kaldi::quasar::ErrorRegion*>(uint64_t a1, uint64_t (***a2)(void))
{
  v3 = a1 - 328;
  v4 = (a1 - 328);
  do
  {
    result = (**v4)(v4);
    v3 -= 328;
    v6 = v4 == a2;
    v4 -= 41;
  }

  while (!v6);
  return result;
}

uint64_t quasar::ProcessingGraph::createBlock(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  if (result)
  {
    return (*(*result + 8))(result);
  }

  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<kaldi::CuMatrix<float>>,kaldi::CuMatrix<float>*,kaldi::CuMatrix<float>*,kaldi::CuMatrix<float>*>()
{
  OUTLINED_FUNCTION_0_4();
  do
  {
    v4 = *v3;
    v3 -= 6;
    result = (*(v4 + 16))(v1);
    v2 -= 48;
    v6 = v1 == v0;
    v1 = v3;
  }

  while (!v6);
  return result;
}

void SequoiaLogger()
{
  if (__cxa_guard_acquire(&qword_1EB90B758))
  {
    _MergedGlobals_0 = os_log_create("com.apple.MachineTranslation", "framework");

    __cxa_guard_release(&qword_1EB90B758);
  }
}

void kaldi::LatticeFasterOnlineDecoder::LatticeFasterOnlineDecoder(uint64_t a1)
{
  v4 = OUTLINED_FUNCTION_1_2(a1);
  if (v4)
  {
    v1[17] = v4;
    operator delete(v4);
  }

  v5 = *v3;
  if (*v3)
  {
    v1[14] = v5;
    operator delete(v5);
  }

  v6 = *v2;
  if (*v2)
  {
    v1[11] = v6;

    operator delete(v6);
  }
}

void std::allocator<quasar::RecogAudioBuffer>::construct[abi:ne200100]<quasar::RecogAudioBuffer,unsigned long &,int,int,BOOL,char const(&)[1],std::shared_ptr<kaldi::Timer const>,int>(uint64_t a1)
{
  if (*(a1 + 23) < 0)
  {
    operator delete(*a1);
  }
}

void TBoolParam::TBoolParam(uint64_t a1)
{
  v1 = a1 + 224;
  v2 = -48;
  do
  {
    if (*(v1 + 23) < 0)
    {
      operator delete(*v1);
    }

    v1 -= 24;
    v2 += 24;
  }

  while (v2);
}

void kaldi::quasar::CEEncoderDecoderNet::Decode(uint64_t a1, uint64_t a2)
{
  v2 = OUTLINED_FUNCTION_0_5(a1, a2);
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = OUTLINED_FUNCTION_3_1();
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  OUTLINED_FUNCTION_2_1();
}

uint64_t kaldi::quasar::CEStatelessDecoderNet::Decode(uint64_t a1, uint64_t *a2)
{
  result = *a2;
  if (*a2)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  return result;
}

uint64_t kaldi::VectorwiseQuantizedMatrix<signed char>::VectorwiseQuantizedMatrix(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  if (result)
  {
    OUTLINED_FUNCTION_0_6();
  }

  return result;
}

void quasar::copyAndTrimLeft(void *a1)
{
  if (*a1)
  {
    OUTLINED_FUNCTION_0_3();
  }
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<kaldi::CuVector<float>>,kaldi::CuVector<float>*,kaldi::CuVector<float>*,kaldi::CuVector<float>*>(uint64_t a1, void *a2)
{
  v5 = a1 - 32;
  OUTLINED_FUNCTION_0_7();
  do
  {
    v6 = *v3;
    v3 -= 4;
    result = (*(v6 + 8))(v2);
    v5 -= 32;
    v8 = v2 == a2;
    v2 = v3;
  }

  while (!v8);
  return result;
}

uint64_t fst::LatticeDeterminizerPruned<fst::LatticeWeightTpl<float>,int>::LatticeDeterminizerPruned(void **a1, void **a2, uint64_t a3, uint64_t a4)
{
  v7 = *a1;
  if (v7)
  {
    *(a4 + 240) = v7;
    operator delete(v7);
  }

  v8 = *a2;
  if (*a2)
  {
    *(a4 + 208) = v8;
    operator delete(v8);
  }

  return std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(a3);
}

uint64_t fst::LatticeDeterminizerPruned<fst::LatticeWeightTpl<float>,int>::IsIsymbolOrFinal(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  else
  {
    v4 = a1[3];
    if (v4)
    {
      --*v4;
    }
  }

  return result;
}

uint64_t kaldi::quasar::SeevaStepInference::SeevaStepInference(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  if (result)
  {
    return (*(*result + 8))(result);
  }

  return result;
}

uint64_t std::make_unique[abi:ne200100]<quasar::tennessee::internal::ManagedImmutableSortedArrayStlVectorImpl<long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>,std::unique_ptr<std::vector<long long>>,0>(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  return result;
}

uint64_t quasar::tennessee::internal::ImmutableSortedArrayStlVectorImpl<long long,std::vector<long long>,std::unique_ptr<std::vector<long long>>>::ImmutableSortedArrayStlVectorImpl(uint64_t a1, void *a2, uint64_t *a3)
{
  *a2 = a1;
  result = *a3;
  *a3 = 0;
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void boost::algorithm::detail::find_iterator_base<std::__wrap_iter<char const*>>::find_iterator_base<boost::algorithm::detail::token_finderF<boost::algorithm::detail::is_any_ofF<char>>>(void *a1)
{
  if (*a1)
  {
    OUTLINED_FUNCTION_0_8();
  }
}

void std::__optional_copy_base<quasar::corrective_reranking::TargetRange,false>::__optional_copy_base[abi:ne200100](uint64_t a1)
{
  v2 = *a1;
  if (v2)
  {
    *(a1 + 8) = v2;
    operator delete(v2);
  }
}

void sdapi::SDAPIOSLog()
{
  if (__cxa_guard_acquire(&qword_1EB90B768))
  {
    _MergedGlobals_1 = os_log_create("com.apple.siri", "sdapi");
    __cxa_guard_release(&qword_1EB90B768);
  }
}

void kaldi::nnet1::FramePoolingComponent::InitData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *a2;
  if (*a2)
  {
    *(a2 + 8) = v4;
    operator delete(v4);
  }

  v5 = *a3;
  if (*a3)
  {
    *(a3 + 8) = v5;
    operator delete(v5);
  }
}

void quasar::QuasarCLogger()
{
  if (__cxa_guard_acquire(&qword_1EB90B778))
  {
    _MergedGlobals_2 = os_log_create("com.apple.siri", "QuasarC");

    __cxa_guard_release(&qword_1EB90B778);
  }
}

void quasar::QuasarOsLog()
{
  if (__cxa_guard_acquire(&qword_1EB90B788))
  {
    qword_1EB90B780 = os_log_create("com.apple.siri", "quasar");

    __cxa_guard_release(&qword_1EB90B788);
  }
}

uint64_t fst::ArcMapFstImpl<fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>,fst::ToGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)1>>::Expand(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  else
  {
    v4 = a1[3];
    if (v4)
    {
      --*v4;
    }
  }

  return result;
}

uint64_t fst::ArcMapFstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)3>,fst::ToGallicMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)3>>::Expand(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  else
  {
    v4 = a1[3];
    if (v4)
    {
      --*v4;
    }
  }

  return result;
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)3>,fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)3>>::Expand(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  else
  {
    v4 = a1[3];
    if (v4)
    {
      --*v4;
    }
  }

  return result;
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)2>,fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)2>>::Expand(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  else
  {
    v4 = a1[3];
    if (v4)
    {
      --*v4;
    }
  }

  return result;
}

void std::list<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>>::__insert_with_sentinel[abi:ne200100]<std::__list_const_iterator<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,void *>,std::__list_const_iterator<fst::GallicWeight<int,fst::TropicalWeightTpl<float>,(fst::GallicType)2>,void *>>(void *a1)
{
  do
  {
    v2 = *a1;
    std::__list_imp<char *>::clear(a1 + 3);
    operator delete(a1);
    a1 = v2;
  }

  while (v2);
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  else
  {
    v4 = a1[3];
    if (v4)
    {
      --*v4;
    }
  }

  return result;
}

void callBackSync(void *a1)
{
  v2 = a1 + 3;
  v1 = *a1;
  if (v1 != v2 && v1 != 0)
  {
    OUTLINED_FUNCTION_0_3();
  }
}

void quasar::SpeechRecognizerModelLoader::initDecoderIfNeeded(std::__shared_weak_count **a1, std::__shared_weak_count **a2)
{
  v3 = *a1;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  if (*a2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](*a2);
  }
}

uint64_t kaldi::AmFusionEncoderInput::Compute(uint64_t a1, uint64_t *a2)
{
  result = *a2;
  *a2 = 0;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  return result;
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<quasar::AMKeywordDetection>,quasar::AMKeywordDetection*>(uint64_t a1, uint64_t (***a2)(void))
{
  v3 = a1 - 216;
  v4 = (a1 - 216);
  v5 = (a1 - 216);
  do
  {
    v6 = *v5;
    v5 -= 27;
    result = (*v6)(v4);
    v3 -= 216;
    v8 = v4 == a2;
    v4 = v5;
  }

  while (!v8);
  return result;
}

void quasar::OnlineCmnFe::OnlineCmnFe(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2D22958;
  if (*(a2 + 31) < 0)
  {
    OUTLINED_FUNCTION_0_9(a1, a2);
  }
}

uint64_t kaldi::nnet1::DoBackProp(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 128);
  if (v3)
  {
    free(v3);
  }

  *(a2 + 120) = 0;
  *(a2 + 128) = 0;
  *(a2 + 136) = 0;
  v5 = (a2 + 96);
  std::vector<kaldi::CuSubMatrix<float>>::__destroy_vector::operator()[abi:ne200100](&v5);
  kaldi::CuMatrix<float>::~CuMatrix(a2 + 48);
  return kaldi::CuMatrix<float>::~CuMatrix(a2);
}

void setInputFormatHelper(char a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_3_0();
    OUTLINED_FUNCTION_0_11();
    _os_log_impl(v4, v5, v6, v7, v8, 0xCu);
  }

  __cxa_end_catch();
}

void setInputFormatHelper(char a1, void *a2)
{
  if (a1)
  {
    OUTLINED_FUNCTION_0_11();
    _os_log_impl(v3, v4, v5, v6, v7, 2u);
  }

  __cxa_end_catch();
}

void EarLmLogger()
{
  if (__cxa_guard_acquire(&qword_1EB90B798))
  {
    _MergedGlobals_3 = os_log_create("com.apple.siri", "quasar.lm");

    __cxa_guard_release(&qword_1EB90B798);
  }
}

uint64_t fst::LatticeDeterminizer<fst::LatticeWeightTpl<float>,int>::LatticeDeterminizer(void **a1, void **a2, uint64_t a3, uint64_t a4)
{
  v7 = *a1;
  if (v7)
  {
    *(a4 + 200) = v7;
    operator delete(v7);
  }

  v8 = *a2;
  if (*a2)
  {
    *(a4 + 176) = v8;
    operator delete(v8);
  }

  return std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(a3);
}

uint64_t quasar::tennessee::nashville::CreateTextNormalizer(uint64_t *a1, uint64_t *a2)
{
  v4 = *a1;
  *a1 = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  result = *a2;
  *a2 = 0;
  if (result)
  {
    return (*(*result + 8))(result);
  }

  return result;
}

uint64_t std::make_unique[abi:ne200100]<quasar::tennessee::nashville::TextNormalizer<std::unique_ptr<quasar::tennessee::archive::ImmutableArchive>,std::unique_ptr<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>>>,std::unique_ptr<quasar::tennessee::archive::ImmutableArchive>,std::unique_ptr<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>>,quasar::tennessee::nashville::TextNormalizerOptions const&,0>(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  return result;
}

uint64_t quasar::tennessee::nashville::FormatToken(uint64_t *a1, uint64_t a2)
{
  result = *a1;
  if (result != a2 && result != 0)
  {
    return MEMORY[0x1B8C85310](result, 0x1000C8077774924);
  }

  return result;
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<quasar::tennessee::ImmutableVector<std::string>>,quasar::tennessee::ImmutableVector<std::string>*>(uint64_t a1, uint64_t (***a2)(void))
{
  v3 = a1 - 24;
  v4 = (a1 - 24);
  v5 = (a1 - 24);
  do
  {
    v6 = *v5;
    v5 -= 3;
    result = (*v6)(v4);
    v3 -= 24;
    v8 = v4 == a2;
    v4 = v5;
  }

  while (!v8);
  return result;
}

void QuasarCPDecTranslator_new_cold_1()
{
  OUTLINED_FUNCTION_0_2();
  (*(v0 + 16))();
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_6(&dword_1B501D000, v1, v2, "%{public}s", v3, v4, v5, v6, v7);
}

void File::close(const char **a1, unsigned __int8 *a2)
{
  if (*a1)
  {
    v3 = *a1;
  }

  else
  {
    v3 = "";
  }

  perror(v3);
  exit(*a2);
}

void EarArtifactLogger()
{
  if (__cxa_guard_acquire(&qword_1EB90B7A8))
  {
    _MergedGlobals_4 = os_log_create("com.apple.siri", "quasar.artifact");

    __cxa_guard_release(&qword_1EB90B7A8);
  }
}

uint64_t quasar::LmeDataFactory::getLmeData(std::__shared_weak_count **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  v7 = *a1;
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }

  v8 = *a2;
  *a2 = 0;
  if (v8)
  {
    (*(*v8 + 8))(v8);
  }

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a3);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a4);
}

void quasar::LmeDataFactory::getLmeData(uint64_t *a1, quasar::LmePackedUserData *this)
{
  v3 = *a1;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  quasar::LmePackedUserData::~LmePackedUserData(this);
}

void quasar::TextSanitizer::TextSanitizer(void *a1)
{
  v2 = a1[8];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  v3 = a1[6];
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  v4 = a1[4];
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }

  v5 = a1[2];
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v5);
  }
}

void EarGeoLMHelperLogger()
{
  if (__cxa_guard_acquire(&qword_1EB90B7B8))
  {
    _MergedGlobals_5 = os_log_create("com.apple.siri", "quasar.geolm.helper");

    __cxa_guard_release(&qword_1EB90B7B8);
  }
}

uint64_t fst::FstPrinter<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>,int>,int>>::PrintState(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  else
  {
    v4 = a1[3];
    if (v4)
    {
      --*v4;
    }
  }

  return result;
}

uint64_t quasar::tennessee::TennesseeTokenizer::createTennesseeTokenizer(uint64_t a1)
{
  return (*(*a1 + 8))(a1);
}

{
  return (*(*a1 + 8))(a1);
}

void quasar::SpokenFormLine::SpokenFormLine(uint64_t a1, void **a2, void **a3)
{
  if (*(a1 + 55) < 0)
  {
    operator delete(*a2);
  }

  if (*(a1 + 31) < 0)
  {
    operator delete(*a3);
  }
}

void ConvertCXXExceptionToNSException()
{
  v2 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_3_0();
  _os_log_fault_impl(&dword_1B501D000, v0, OS_LOG_TYPE_FAULT, "Quasar executor ObjC exception: %{private}@", v1, 0xCu);
}

{
  OUTLINED_FUNCTION_2_2();
  *v1 = v0;
  (*(v2 + 16))();
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_6(&dword_1B501D000, v3, v4, "Quasar internal C++ exception: %{private}s", v5, v6, v7, v8, v9);
}

{
  OUTLINED_FUNCTION_2_2();
  (*(v0 + 16))();
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_6(&dword_1B501D000, v1, v2, "Quasar internal C++ exception (bad_alloc): %{private}s", v3, v4, v5, v6, v7);
}

void fst::EnumerationFstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,fst::SqueezedFst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,true,false>>::Read(uint64_t *a1)
{
  v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    std::default_delete<fst::EnumerationData const>::operator()[abi:ne200100](a1, v1);
  }

  OUTLINED_FUNCTION_2_3();
}

void fst::SortedMatcher<fst::SqueezedFst<fst::ArcTpl<fst::TropicalWeightTpl<float>,int>,true,false>>::Priority_()
{
  OUTLINED_FUNCTION_4_0();
  if (v2 != v3)
  {
    OUTLINED_FUNCTION_3_2();
  }

  OUTLINED_FUNCTION_0_10(v0, v1);
}

void TParam::TParam()
{
  OUTLINED_FUNCTION_0_12();
  if (v4 < 0)
  {
    operator delete(*v3);
  }

  if (*(v1 + 63) < 0)
  {
    operator delete(*v2);
  }

  if (*(v1 + 39) < 0)
  {
    v5 = *v0;

    operator delete(v5);
  }
}

void TStringParam::TStringParam(uint64_t a1)
{
  v1 = a1 + 1280;
  v2 = -1152;
  do
  {
    if (*(v1 + 23) < 0)
    {
      operator delete(*v1);
    }

    v1 -= 24;
    v2 += 24;
  }

  while (v2);
}

void kaldi::quasar::TorchEncoderDecoder::TorchEncoderDecoder(uint64_t a1, void **a2, void **a3, kaldi::quasar::BPE *this)
{
  if (*(a1 + 3975) < 0)
  {
    operator delete(*a2);
  }

  if (*(a1 + 3951) < 0)
  {
    operator delete(*a3);
  }

  kaldi::quasar::BPE::~BPE(this);
}

void boost::geometry::strategy::distance::comparable::haversine<double,void>::apply<boost::geometry::model::point<double,2ul,boost::geometry::cs::spherical_equatorial<boost::geometry::degree>>,boost::geometry::model::point<double,2ul,boost::geometry::cs::spherical_equatorial<boost::geometry::degree>>>()
{
  {
    OUTLINED_FUNCTION_0_13();
  }
}

uint64_t std::make_unique[abi:ne200100]<quasar::LanguageDetector,std::string,std::unique_ptr<EARAcousticLDModelFactory>,std::unique_ptr<EARContextAwareLDModelFactory>,std::unordered_map<std::string,std::string> &,0>(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  if (result)
  {
    return (*(*result + 16))(result);
  }

  return result;
}

void quasar::KeywordSpottingSyncDecoder::KeywordSpottingSyncDecoder(uint64_t a1, void **a2, void **a3)
{
  if (*(a1 + 111) < 0)
  {
    operator delete(*a2);
  }

  if (*(a1 + 87) < 0)
  {
    operator delete(*a3);
  }
}

void quasar::LmData::loadFromStream(uint64_t a1)
{
  if (*(a1 + 31) < 0)
  {
    operator delete(*(a1 + 8));
  }
}

void std::allocator_traits<std::allocator<std::thread>>::construct[abi:ne200100]<std::thread,quasar::SystemCombinationDecoder::runAsyncTasks(quasar::DecoderPassData &,std::shared_ptr<quasar::DecoderChainOutput> const&,std::shared_ptr<quasar::SpeechRequestData> const&,std::function<BOOL ()(void)> const&,std::shared_ptr<quasar::MultiChainMultiAudioBuffer> const&,std::shared_ptr<quasar::SpeechRecognizerConfig> const&,std::shared_ptr<quasar::SpeechRecognizerModelLoader> const&)::$_0,0>(std::__shared_weak_count **a1, std::__shared_weak_count **a2, uint64_t *a3)
{
  v5 = *a1;
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v5);
  }

  if (*a2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](*a2);
  }

  std::unique_ptr<std::__thread_struct>::~unique_ptr[abi:ne200100](a3);

  JUMPOUT(0x1B8C85350);
}

void quasar::OnlineSeevaDecoder::OnlineSeevaDecoder(uint64_t a1, void **a2, void **a3)
{
  if (*(a1 + 503) < 0)
  {
    operator delete(*a2);
  }

  if (*(a1 + 479) < 0)
  {
    v5 = *a3;

    operator delete(v5);
  }
}

uint64_t kaldi::quasar::ShortlistDataOnDisk::ShortlistDataOnDisk(uint64_t *a1)
{
  for (i = 0; i != -6; i -= 3)
  {
    if (a1[i + 15])
    {
      v3 = a1[i + 13];
      if (v3)
      {
        MEMORY[0x1B8C85310](v3, 0x1000C8077774924);
      }
    }
  }

  for (j = 0; j != -9; j -= 3)
  {
    if (a1[j + 9])
    {
      v5 = a1[j + 7];
      if (v5)
      {
        MEMORY[0x1B8C85310](v5, 0x1000C8077774924);
      }
    }
  }

  result = *a1;
  *a1 = 0;
  if (result)
  {
    return (*(*result + 8))(result);
  }

  return result;
}

void quasar::OnlineSeevaStepDecoder::OnlineSeevaStepDecoder(char *a1, void **a2, void **a3, void **a4)
{
  if (a1[527] < 0)
  {
    operator delete(*a2);
  }

  if (a1[503] < 0)
  {
    operator delete(*a3);
  }

  if (a1[479] < 0)
  {
    v7 = *a4;

    operator delete(v7);
  }
}

void _parseRecipeBoolField()
{
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_0_15();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x12u);
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)3>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)3>>::Expand(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  else
  {
    v4 = a1[3];
    if (v4)
    {
      --*v4;
    }
  }

  return result;
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)2>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)2>>::Expand(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  else
  {
    v4 = a1[3];
    if (v4)
    {
      --*v4;
    }
  }

  return result;
}

uint64_t fst::ArcMapFstImpl<fst::GallicArc<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>,fst::ArcTpl<fst::LogWeightTpl<float>,int>,fst::FromGallicMapper<fst::ArcTpl<fst::LogWeightTpl<float>,int>,(fst::GallicType)4>>::Expand(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  else
  {
    v4 = a1[3];
    if (v4)
    {
      --*v4;
    }
  }

  return result;
}

void std::make_unique[abi:ne200100]<quasar::tennessee::nashville::GenericNashvilleLexicon<std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::Metadata>,quasar::tennessee::unique_vmem_file_flatbuf_ptr<quasar::tennessee::nashville::flatbuf::StringData>,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::IterableCollation<std::string_view,wchar_t>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>,0>(uint64_t *a1)
{
  v2 = OUTLINED_FUNCTION_1_3(a1);
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = v1[1];
  *v1 = &unk_1F2D42438;
  v1[1] = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  OUTLINED_FUNCTION_2_1();
}

void quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(uint64_t *a1)
{
  v1 = OUTLINED_FUNCTION_2_4(a1);
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  OUTLINED_FUNCTION_2_1();
}

{
  v2 = OUTLINED_FUNCTION_1_3(a1);
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = *v1;
  *v1 = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  OUTLINED_FUNCTION_2_1();
}

void quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Create(uint64_t *a1)
{
  v1 = OUTLINED_FUNCTION_2_4(a1);
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  OUTLINED_FUNCTION_2_1();
}

uint64_t quasar::tennessee::GenericLexiconImpl<quasar::tennessee::nashville::flatbuf::TokenInfo,std::string_view,quasar::tennessee::nashville::flatbuf::TokenInfoToUTF8StringViewFunctor,quasar::tennessee::ImmutableSortedArray<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>,std::unique_ptr<quasar::tennessee::Collation<quasar::tennessee::nashville::flatbuf::TokenInfo,quasar::tennessee::nashville::flatbuf::TokenInfo>>>>::GenericLexiconImpl(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t std::make_unique[abi:ne200100]<quasar::tennessee::IndirectSortedIndex<long long,std::string_view>,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>,quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(long long)#1},quasar::tennessee::IndirectSortedIndex<long long,std::string_view>::Load(quasar::tennessee::Lexicon<std::string_view> const&,std::unique_ptr<quasar::tennessee::Collation<std::string_view,std::string_view>>,std::unique_ptr<quasar::tennessee::ImmutableSortedArray<long long,quasar::tennessee::Collation<long long,long long>,std::unique_ptr<quasar::tennessee::Collation<long long,long long>>>>)::{lambda(std::string_view)#1},0>(uint64_t *a1)
{
  result = *a1;
  *a1 = 0;
  if (result)
  {
    OUTLINED_FUNCTION_0();
    return (*(v3 + 8))();
  }

  return result;
}

google::protobuf::internal *google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::SentencePieceText_SentencePiece>(int32x2_t *this, uint64_t a2, google::protobuf::internal *a3)
{
  v5 = *a3;
  if (*a3 < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(a3, v5);
    if (!result)
    {
      return result;
    }

    v6 = result;
  }

  else
  {
    v6 = (a3 + 1);
  }

  v8 = this[1];
  v9 = v5 + v6 - v8.i32[0];
  *this = (*&v8 + (v9 & (v9 >> 31)));
  v10 = this[3].i32[1];
  this[3].i32[1] = v9;
  v8.i32[0] = this[11].i32[0];
  v11 = __OFSUB__(v8.i32[0]--, 1);
  this[11].i32[0] = v8.i32[0];
  if (v8.i32[0] < 0 != v11)
  {
    return 0;
  }

  result = sentencepiece::SentencePieceText_SentencePiece::_InternalParse(a2, v6, this);
  if (!result)
  {
    return result;
  }

  ++this[11].i32[0];
  if (this[10].i32[0])
  {
    return 0;
  }

  v12 = this[3].i32[1] + v10 - v9;
  this[3].i32[1] = v12;
  *this = (*&this[1] + (v12 & (v12 >> 31)));
  return result;
}

google::protobuf::internal *google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::SentencePieceText>(int32x2_t *this, uint64_t a2, google::protobuf::internal *a3)
{
  v5 = *a3;
  if (*a3 < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(a3, v5);
    if (!result)
    {
      return result;
    }

    v6 = result;
  }

  else
  {
    v6 = (a3 + 1);
  }

  v8 = this[1];
  v9 = v5 + v6 - v8.i32[0];
  *this = (*&v8 + (v9 & (v9 >> 31)));
  v10 = this[3].i32[1];
  this[3].i32[1] = v9;
  v8.i32[0] = this[11].i32[0];
  v11 = __OFSUB__(v8.i32[0]--, 1);
  this[11].i32[0] = v8.i32[0];
  if (v8.i32[0] < 0 != v11)
  {
    return 0;
  }

  result = sentencepiece::SentencePieceText::_InternalParse(a2, v6, this);
  if (!result)
  {
    return result;
  }

  ++this[11].i32[0];
  if (this[10].i32[0])
  {
    return 0;
  }

  v12 = this[3].i32[1] + v10 - v9;
  this[3].i32[1] = v12;
  *this = (*&this[1] + (v12 & (v12 >> 31)));
  return result;
}

void sentencepiece::TrainerSpec::_InternalParse(uint64_t a1, google::protobuf::internal *a2, google::protobuf::internal::EpsCopyInputStream *this)
{
  v267 = a2;
  v5 = google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v267, *(this + 23));
  v6 = v267;
  if (v5)
  {
    return;
  }

  while (2)
  {
    v7 = (v6 + 1);
    LODWORD(v8) = *v6;
    if ((*v6 & 0x80000000) == 0)
    {
      goto LABEL_6;
    }

    v8 = (v8 + (*v7 << 7) - 128);
    if ((*v7 & 0x80000000) == 0)
    {
      v7 = (v6 + 2);
LABEL_6:
      v267 = v7;
      goto LABEL_7;
    }

    TagFallback = google::protobuf::internal::ReadTagFallback(v6, v8);
    v267 = TagFallback;
    if (!TagFallback)
    {
      return;
    }

    v7 = TagFallback;
LABEL_7:
    switch(v8 >> 3)
    {
      case 1u:
        if (v8 != 10)
        {
          goto LABEL_254;
        }

        v9 = v7 - 1;
        while (2)
        {
          v267 = (v9 + 1);
          if (!*(a1 + 72))
          {
            v11 = *(a1 + 68);
LABEL_16:
            google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a1 + 56), v11 + 1);
            v10 = *(a1 + 72);
            goto LABEL_17;
          }

          OUTLINED_FUNCTION_12();
          if (v12 != v13)
          {
            OUTLINED_FUNCTION_11();
            *(a1 + 64) = v15;
            v17 = *(v16 + 8);
            goto LABEL_22;
          }

          if (v11 == *(a1 + 68))
          {
            goto LABEL_16;
          }

LABEL_17:
          OUTLINED_FUNCTION_16(v10);
          v20 = *(a1 + 56);
          if (!v20)
          {
            OUTLINED_FUNCTION_17();
          }

          if (*(v20 + 24))
          {
            v26 = OUTLINED_FUNCTION_6_0();
          }

          v21 = OUTLINED_FUNCTION_18(v18, v19, google::protobuf::internal::arena_destruct_object<std::string>);
          OUTLINED_FUNCTION_15(v21);
          OUTLINED_FUNCTION_14();
          *(a1 + 64) = v22;
          v17 = OUTLINED_FUNCTION_13(v23, v24);
LABEL_22:
          v267 = google::protobuf::internal::InlineGreedyStringParser(v17, v14, this);
          if (v267)
          {
            OUTLINED_FUNCTION_10();
            if (!(!v206 & v25) || *v9 != 10)
            {
              goto LABEL_252;
            }

            continue;
          }

          return;
        }

      case 2u:
        if (v8 != 18)
        {
          goto LABEL_254;
        }

        *(a1 + 40) |= 1u;
        v107 = *(a1 + 8);
        if (v107)
        {
          v107 = *(v107 & 0xFFFFFFFFFFFFFFFELL);
        }

        v108 = (a1 + 152);
        goto LABEL_207;
      case 3u:
        if (v8 != 24)
        {
          goto LABEL_254;
        }

        v150 = (v7 + 1);
        v149 = *v7;
        if ((v149 & 0x8000000000000000) == 0)
        {
          goto LABEL_177;
        }

        OUTLINED_FUNCTION_0_17();
        if (v152 < 0)
        {
          v267 = google::protobuf::internal::VarintParseSlow64(v151, v149);
          if (!v267)
          {
            return;
          }
        }

        else
        {
          v150 = (v151 + 2);
LABEL_177:
          v267 = v150;
        }

        if ((v149 - 1) > 3)
        {
          v261 = *(a1 + 8);
          if (v261)
          {
            v262 = ((v261 & 0xFFFFFFFFFFFFFFFELL) + 8);
          }

          else
          {
            v265 = v149;
            v266 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>((a1 + 8));
            v149 = v265;
            v262 = v266;
          }

          google::protobuf::internal::WriteVarint(3, v149, v262);
        }

        else
        {
          *(a1 + 40) |= 0x80000u;
          *(a1 + 248) = v149;
        }

        goto LABEL_252;
      case 4u:
        if (v8 != 32)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_5_0(*(a1 + 40) | 0x100000);
        if ((v170 & 0x80) == 0)
        {
          goto LABEL_212;
        }

        OUTLINED_FUNCTION_1_4();
        if (v173 < 0)
        {
          v245 = google::protobuf::internal::VarintParseSlow64(v172, v170);
          v267 = v245;
          *(a1 + 252) = v246;
          if (!v245)
          {
            return;
          }
        }

        else
        {
          v171 = (v172 + 2);
LABEL_212:
          v267 = v171;
          *(a1 + 252) = v170;
        }

        goto LABEL_252;
      case 5u:
        if (v8 != 42)
        {
          goto LABEL_254;
        }

        v123 = v7 - 1;
        while (1)
        {
          v267 = (v123 + 1);
          if (!*(a1 + 96))
          {
            break;
          }

          OUTLINED_FUNCTION_12();
          if (v12 == v13)
          {
            if (v125 == *(a1 + 92))
            {
LABEL_146:
              google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a1 + 80), v125 + 1);
              v124 = *(a1 + 96);
            }

            OUTLINED_FUNCTION_16(v124);
            v132 = *(a1 + 80);
            if (!v132)
            {
              OUTLINED_FUNCTION_17();
            }

            if (*(v132 + 24))
            {
              v137 = OUTLINED_FUNCTION_6_0();
            }

            v133 = OUTLINED_FUNCTION_18(v130, v131, google::protobuf::internal::arena_destruct_object<std::string>);
            OUTLINED_FUNCTION_15(v133);
            OUTLINED_FUNCTION_14();
            *(a1 + 88) = v134;
            v129 = OUTLINED_FUNCTION_13(v135, v136);
            goto LABEL_152;
          }

          OUTLINED_FUNCTION_11();
          *(a1 + 88) = v127;
          v129 = *(v128 + 8);
LABEL_152:
          v267 = google::protobuf::internal::InlineGreedyStringParser(v129, v126, this);
          if (!v267)
          {
            return;
          }

          OUTLINED_FUNCTION_10();
          if (!(!v206 & v25) || *v123 != 42)
          {
            goto LABEL_252;
          }
        }

        v125 = *(a1 + 92);
        goto LABEL_146;
      case 6u:
        if (v8 != 48)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_5_0(*(a1 + 40) | 0x100);
        if ((v103 & 0x80) == 0)
        {
          goto LABEL_120;
        }

        OUTLINED_FUNCTION_1_4();
        if (v106 < 0)
        {
          v233 = google::protobuf::internal::VarintParseSlow64(v105, v103);
          v267 = v233;
          *(a1 + 216) = v234;
          if (!v233)
          {
            return;
          }
        }

        else
        {
          v104 = (v105 + 2);
LABEL_120:
          v267 = v104;
          *(a1 + 216) = v103;
        }

        goto LABEL_252;
      case 7u:
        if (v8 != 58)
        {
          goto LABEL_254;
        }

        *(a1 + 40) |= 2u;
        v107 = *(a1 + 8);
        if (v107)
        {
          v107 = *(v107 & 0xFFFFFFFFFFFFFFFELL);
        }

        v108 = (a1 + 160);
        goto LABEL_207;
      case 0xAu:
        if (v8 != 85)
        {
          goto LABEL_254;
        }

        *(a1 + 40) |= 0x200000u;
        v84 = *v7;
        v83 = (v7 + 4);
        *(a1 + 256) = v84;
        goto LABEL_159;
      case 0xBu:
        if (v8 != 88)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x400);
        if ((v99 & 0x8000000000000000) == 0)
        {
          goto LABEL_115;
        }

        OUTLINED_FUNCTION_0_17();
        if (v102 < 0)
        {
          v231 = google::protobuf::internal::VarintParseSlow64(v101, v99);
          v267 = v231;
          *(a1 + 224) = v232;
          if (!v231)
          {
            return;
          }
        }

        else
        {
          v100 = (v101 + 2);
LABEL_115:
          v267 = v100;
          *(a1 + 224) = v99;
        }

        goto LABEL_252;
      case 0xCu:
        if (v8 != 96)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_5_0(*(a1 + 40) | 0x200);
        if ((v45 & 0x80) == 0)
        {
          goto LABEL_58;
        }

        OUTLINED_FUNCTION_1_4();
        if (v48 < 0)
        {
          v215 = google::protobuf::internal::VarintParseSlow64(v47, v45);
          v267 = v215;
          *(a1 + 220) = v216;
          if (!v215)
          {
            return;
          }
        }

        else
        {
          v46 = (v47 + 2);
LABEL_58:
          v267 = v46;
          *(a1 + 220) = v45;
        }

        goto LABEL_252;
      case 0xDu:
        if (v8 != 104)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_5_0(*(a1 + 40) | 0x800);
        if ((v90 & 0x80) == 0)
        {
          goto LABEL_106;
        }

        OUTLINED_FUNCTION_1_4();
        if (v93 < 0)
        {
          v227 = google::protobuf::internal::VarintParseSlow64(v92, v90);
          v267 = v227;
          *(a1 + 232) = v228;
          if (!v227)
          {
            return;
          }
        }

        else
        {
          v91 = (v92 + 2);
LABEL_106:
          v267 = v91;
          *(a1 + 232) = v90;
        }

        goto LABEL_252;
      case 0xEu:
        if (v8 != 112)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_5_0(*(a1 + 40) | 0x400000);
        if ((v145 & 0x80) == 0)
        {
          goto LABEL_172;
        }

        OUTLINED_FUNCTION_1_4();
        if (v148 < 0)
        {
          v243 = google::protobuf::internal::VarintParseSlow64(v147, v145);
          v267 = v243;
          *(a1 + 260) = v244;
          if (!v243)
          {
            return;
          }
        }

        else
        {
          v146 = (v147 + 2);
LABEL_172:
          v267 = v146;
          *(a1 + 260) = v145;
        }

        goto LABEL_252;
      case 0xFu:
        if (v8 != 125)
        {
          goto LABEL_254;
        }

        *(a1 + 40) |= 0x800000u;
        v139 = *v7;
        v83 = (v7 + 4);
        *(a1 + 264) = v139;
LABEL_159:
        v267 = v83;
        goto LABEL_252;
      case 0x10u:
        if (v8 != 128)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_5_0(*(a1 + 40) | 0x1000000);
        if ((v58 & 0x80) == 0)
        {
          goto LABEL_72;
        }

        OUTLINED_FUNCTION_1_4();
        if (v61 < 0)
        {
          v221 = google::protobuf::internal::VarintParseSlow64(v60, v58);
          v267 = v221;
          *(a1 + 268) = v222;
          if (!v221)
          {
            return;
          }
        }

        else
        {
          v59 = (v60 + 2);
LABEL_72:
          v267 = v59;
          *(a1 + 268) = v58;
        }

        goto LABEL_252;
      case 0x11u:
        if (v8 != 136)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_5_0(*(a1 + 40) | 0x2000000);
        if ((v174 & 0x80) == 0)
        {
          goto LABEL_217;
        }

        OUTLINED_FUNCTION_1_4();
        if (v177 < 0)
        {
          v247 = google::protobuf::internal::VarintParseSlow64(v176, v174);
          v267 = v247;
          *(a1 + 272) = v248;
          if (!v247)
          {
            return;
          }
        }

        else
        {
          v175 = (v176 + 2);
LABEL_217:
          v267 = v175;
          *(a1 + 272) = v174;
        }

        goto LABEL_252;
      case 0x12u:
        if (v8 != 144)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_5_0(*(a1 + 40) | 0x4000000);
        if ((v178 & 0x80) == 0)
        {
          goto LABEL_222;
        }

        OUTLINED_FUNCTION_1_4();
        if (v181 < 0)
        {
          v249 = google::protobuf::internal::VarintParseSlow64(v180, v178);
          v267 = v249;
          *(a1 + 276) = v250;
          if (!v249)
          {
            return;
          }
        }

        else
        {
          v179 = (v180 + 2);
LABEL_222:
          v267 = v179;
          *(a1 + 276) = v178;
        }

        goto LABEL_252;
      case 0x13u:
        if (v8 != 152)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x10000000);
        if (v190 < 0 && (OUTLINED_FUNCTION_0_17(), v193 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v192, v191);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 284) = v255;
          if (!v256)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 284) = v194;
        }

        goto LABEL_252;
      case 0x14u:
        if (v8 != 160)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_5_0(*(a1 + 40) | 0x8000000);
        if ((v186 & 0x80) == 0)
        {
          goto LABEL_232;
        }

        OUTLINED_FUNCTION_1_4();
        if (v189 < 0)
        {
          v253 = google::protobuf::internal::VarintParseSlow64(v188, v186);
          v267 = v253;
          *(a1 + 280) = v254;
          if (!v253)
          {
            return;
          }
        }

        else
        {
          v187 = (v188 + 2);
LABEL_232:
          v267 = v187;
          *(a1 + 280) = v186;
        }

        goto LABEL_252;
      case 0x15u:
        if (v8 != 168)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x20000000);
        if (v40 < 0 && (OUTLINED_FUNCTION_0_17(), v43 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v42, v41);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 285) = v213;
          if (!v214)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 285) = v44;
        }

        goto LABEL_252;
      case 0x16u:
        if (v8 != 176)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x80000000);
        if (v140 < 0 && (OUTLINED_FUNCTION_0_17(), v143 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v142, v141);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 287) = v241;
          if (!v242)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 287) = v144;
        }

        goto LABEL_252;
      case 0x17u:
        if (v8 != 184)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x40000000);
        if (v195 < 0 && (OUTLINED_FUNCTION_0_17(), v198 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v197, v196);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 286) = v257;
          if (!v258)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 286) = v199;
        }

        goto LABEL_252;
      case 0x18u:
        if (v8 != 192)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x1000);
        if (v53 < 0 && (OUTLINED_FUNCTION_0_17(), v56 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v55, v54);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 236) = v219;
          if (!v220)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 236) = v57;
        }

        goto LABEL_252;
      case 0x19u:
        if (v8 != 200)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x4000);
        if (v118 < 0 && (OUTLINED_FUNCTION_0_17(), v121 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v120, v119);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 238) = v239;
          if (!v240)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 238) = v122;
        }

        goto LABEL_252;
      case 0x1Au:
        if (v8 != 208)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x2000);
        if (v78 < 0 && (OUTLINED_FUNCTION_0_17(), v81 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v80, v79);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 237) = v223;
          if (!v224)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 237) = v82;
        }

        goto LABEL_252;
      case 0x1Eu:
        if (v8 != 242)
        {
          goto LABEL_254;
        }

        v153 = (v7 - 2);
        while (1)
        {
          v267 = (v153 + 1);
          if (!*(a1 + 120))
          {
            break;
          }

          OUTLINED_FUNCTION_12();
          if (v12 == v13)
          {
            if (v155 == *(a1 + 116))
            {
LABEL_188:
              google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a1 + 104), v155 + 1);
              v154 = *(a1 + 120);
            }

            OUTLINED_FUNCTION_16(v154);
            v162 = *(a1 + 104);
            if (!v162)
            {
              OUTLINED_FUNCTION_17();
            }

            if (*(v162 + 24))
            {
              v167 = OUTLINED_FUNCTION_6_0();
            }

            v163 = OUTLINED_FUNCTION_18(v160, v161, google::protobuf::internal::arena_destruct_object<std::string>);
            OUTLINED_FUNCTION_15(v163);
            OUTLINED_FUNCTION_14();
            *(a1 + 112) = v164;
            v159 = OUTLINED_FUNCTION_13(v165, v166);
            goto LABEL_194;
          }

          OUTLINED_FUNCTION_11();
          *(a1 + 112) = v157;
          v159 = *(v158 + 8);
LABEL_194:
          v267 = google::protobuf::internal::InlineGreedyStringParser(v159, v156, this);
          if (!v267)
          {
            return;
          }

          OUTLINED_FUNCTION_10();
          if (!(!v206 & v25) || *v153 != 498)
          {
            goto LABEL_252;
          }
        }

        v155 = *(a1 + 116);
        goto LABEL_188;
      case 0x1Fu:
        if (v8 != 250)
        {
          goto LABEL_254;
        }

        v62 = (v7 - 2);
        break;
      case 0x20u:
        if (v8)
        {
          goto LABEL_254;
        }

        *(a1 + 44) |= 1u;
        if ((*v7 & 0x8000000000000000) != 0 && (OUTLINED_FUNCTION_0_17(), v38 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v37, v36);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 288) = v211;
          if (!v212)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 288) = v39;
        }

        goto LABEL_252;
      case 0x21u:
        if (v8 != 8)
        {
          goto LABEL_254;
        }

        *(a1 + 44) |= 2u;
        if ((*v7 & 0x8000000000000000) != 0 && (OUTLINED_FUNCTION_0_17(), v202 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v201, v200);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 289) = v259;
          if (!v260)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 289) = v203;
        }

        goto LABEL_252;
      case 0x22u:
        if (v8 != 16)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x20000);
        if (v94 < 0 && (OUTLINED_FUNCTION_0_17(), v97 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v96, v95);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 244) = v229;
          if (!v230)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 244) = v98;
        }

        goto LABEL_252;
      case 0x23u:
        if (v8 != 24)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x8000);
        if (v109 < 0 && (OUTLINED_FUNCTION_0_17(), v112 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v111, v110);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 239) = v235;
          if (!v236)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 239) = v113;
        }

        goto LABEL_252;
      case 0x24u:
        if (v8 != 34)
        {
          goto LABEL_254;
        }

        *(a1 + 40) |= 4u;
        v107 = *(a1 + 8);
        if (v107)
        {
          v107 = *(v107 & 0xFFFFFFFFFFFFFFFELL);
        }

        v108 = (a1 + 168);
LABEL_207:
        v169 = google::protobuf::internal::ArenaStringPtr::Mutable(v108, v107, v7);
        goto LABEL_250;
      case 0x28u:
        if (v8 != 64)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_5_0(*(a1 + 40) | 0x10000);
        if ((v114 & 0x80) == 0)
        {
          goto LABEL_133;
        }

        OUTLINED_FUNCTION_1_4();
        if (v117 < 0)
        {
          v237 = google::protobuf::internal::VarintParseSlow64(v116, v114);
          v267 = v237;
          *(a1 + 240) = v238;
          if (!v237)
          {
            return;
          }
        }

        else
        {
          v115 = (v116 + 2);
LABEL_133:
          v267 = v115;
          *(a1 + 240) = v114;
        }

        goto LABEL_252;
      case 0x29u:
        if (v8 != 72)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_7(*(a1 + 44) | 4);
        if ((v29 & 0x80) == 0)
        {
          goto LABEL_33;
        }

        OUTLINED_FUNCTION_1_4();
        if (v32 < 0)
        {
          v209 = google::protobuf::internal::VarintParseSlow64(v31, v29);
          v267 = v209;
          *(a1 + 292) = v210;
          if (!v209)
          {
            return;
          }
        }

        else
        {
          v30 = (v31 + 2);
LABEL_33:
          v267 = v30;
          *(a1 + 292) = v29;
        }

        goto LABEL_252;
      case 0x2Au:
        if (v8 != 80)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_7(*(a1 + 44) | 8);
        if ((v49 & 0x80) == 0)
        {
          goto LABEL_63;
        }

        OUTLINED_FUNCTION_1_4();
        if (v52 < 0)
        {
          v217 = google::protobuf::internal::VarintParseSlow64(v51, v49);
          v267 = v217;
          *(a1 + 296) = v218;
          if (!v217)
          {
            return;
          }
        }

        else
        {
          v50 = (v51 + 2);
LABEL_63:
          v267 = v50;
          *(a1 + 296) = v49;
        }

        goto LABEL_252;
      case 0x2Bu:
        if (v8 != 88)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_7(*(a1 + 44) | 0x10);
        if ((v182 & 0x80) == 0)
        {
          goto LABEL_227;
        }

        OUTLINED_FUNCTION_1_4();
        if (v185 < 0)
        {
          v251 = google::protobuf::internal::VarintParseSlow64(v184, v182);
          v267 = v251;
          *(a1 + 300) = v252;
          if (!v251)
          {
            return;
          }
        }

        else
        {
          v183 = (v184 + 2);
LABEL_227:
          v267 = v183;
          *(a1 + 300) = v182;
        }

        goto LABEL_252;
      case 0x2Cu:
        if (v8 != 98)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_9(*(a1 + 40) | 8);
        if (v33)
        {
          OUTLINED_FUNCTION_8();
        }

        v34 = &sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_unk_surface_;
        v35 = (a1 + 176);
        goto LABEL_249;
      case 0x2Du:
        if (v8 != 106)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_9(*(a1 + 40) | 0x10);
        if (v33)
        {
          OUTLINED_FUNCTION_8();
        }

        v34 = &sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_unk_piece_;
        v35 = (a1 + 184);
        goto LABEL_249;
      case 0x2Eu:
        if (v8 != 114)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_9(*(a1 + 40) | 0x20);
        if (v33)
        {
          OUTLINED_FUNCTION_8();
        }

        v34 = &sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_bos_piece_;
        v35 = (a1 + 192);
        goto LABEL_249;
      case 0x2Fu:
        if (v8 != 122)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_9(*(a1 + 40) | 0x40);
        if (v33)
        {
          OUTLINED_FUNCTION_8();
        }

        v34 = &sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_eos_piece_;
        v35 = (a1 + 200);
        goto LABEL_249;
      case 0x30u:
        if (v8 != 130)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_9(*(a1 + 40) | 0x80);
        if (v33)
        {
          OUTLINED_FUNCTION_8();
        }

        v34 = &sentencepiece::TrainerSpec::_i_give_permission_to_break_this_code_default_pad_piece_;
        v35 = (a1 + 208);
LABEL_249:
        v169 = google::protobuf::internal::ArenaStringPtr::Mutable(v35, v34, v33);
LABEL_250:
        v204 = google::protobuf::internal::InlineGreedyStringParser(v169, v267, this);
        goto LABEL_251;
      case 0x31u:
        if (v8 != 136)
        {
          goto LABEL_254;
        }

        OUTLINED_FUNCTION_4_1(*(a1 + 40) | 0x40000);
        if (v85 < 0 && (OUTLINED_FUNCTION_0_17(), v88 < 0))
        {
          google::protobuf::internal::VarintParseSlow64(v87, v86);
          OUTLINED_FUNCTION_2_5();
          *(a1 + 245) = v225;
          if (!v226)
          {
            return;
          }
        }

        else
        {
          OUTLINED_FUNCTION_3_3();
          *(a1 + 245) = v89;
        }

        goto LABEL_252;
      default:
LABEL_254:
        if (v8)
        {
          v206 = (v8 & 7) == 4;
        }

        else
        {
          v206 = 1;
        }

        if (v206)
        {
          *(this + 20) = v8 - 1;
          return;
        }

        if (v8 < 0x640)
        {
          v207 = *(a1 + 8);
          if (v207)
          {
            v208 = (v207 & 0xFFFFFFFFFFFFFFFELL) + 8;
          }

          else
          {
            v263 = v8;
            v264 = google::protobuf::internal::InternalMetadata::mutable_unknown_fields_slow<std::string>((a1 + 8));
            LODWORD(v8) = v263;
            v208 = v264;
            v7 = v267;
          }

          v204 = google::protobuf::internal::UnknownFieldParse(v8, v208, v7, this);
        }

        else
        {
          v204 = google::protobuf::internal::ExtensionSet::ParseField((a1 + 16), v8, v7, &sentencepiece::_TrainerSpec_default_instance_, (a1 + 8), this);
        }

LABEL_251:
        v267 = v204;
        if (!v204)
        {
          return;
        }

LABEL_252:
        v205 = google::protobuf::internal::EpsCopyInputStream::DoneWithCheck(this, &v267, *(this + 23));
        v6 = v267;
        if (v205)
        {
          return;
        }

        continue;
    }

    break;
  }

  while (1)
  {
    v267 = (v62 + 1);
    if (!*(a1 + 144))
    {
      break;
    }

    OUTLINED_FUNCTION_12();
    if (v12 == v13)
    {
      if (v64 == *(a1 + 140))
      {
LABEL_81:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve((a1 + 128), v64 + 1);
        v63 = *(a1 + 144);
      }

      OUTLINED_FUNCTION_16(v63);
      v71 = *(a1 + 128);
      if (!v71)
      {
        OUTLINED_FUNCTION_17();
      }

      if (*(v71 + 24))
      {
        v76 = OUTLINED_FUNCTION_6_0();
      }

      v72 = OUTLINED_FUNCTION_18(v69, v70, google::protobuf::internal::arena_destruct_object<std::string>);
      OUTLINED_FUNCTION_15(v72);
      OUTLINED_FUNCTION_14();
      *(a1 + 136) = v73;
      v68 = OUTLINED_FUNCTION_13(v74, v75);
      goto LABEL_87;
    }

    OUTLINED_FUNCTION_11();
    *(a1 + 136) = v66;
    v68 = *(v67 + 8);
LABEL_87:
    v267 = google::protobuf::internal::InlineGreedyStringParser(v68, v65, this);
    if (!v267)
    {
      return;
    }

    OUTLINED_FUNCTION_10();
    if (!(!v206 & v25) || *v62 != 506)
    {
      goto LABEL_252;
    }
  }

  v64 = *(a1 + 140);
  goto LABEL_81;
}

google::protobuf::internal *google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::SelfTestData_Sample>(int32x2_t *this, uint64_t a2, google::protobuf::internal *a3)
{
  v5 = *a3;
  if (*a3 < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(a3, v5);
    if (!result)
    {
      return result;
    }

    v6 = result;
  }

  else
  {
    v6 = (a3 + 1);
  }

  v8 = this[1];
  v9 = v5 + v6 - v8.i32[0];
  *this = (*&v8 + (v9 & (v9 >> 31)));
  v10 = this[3].i32[1];
  this[3].i32[1] = v9;
  v8.i32[0] = this[11].i32[0];
  v11 = __OFSUB__(v8.i32[0]--, 1);
  this[11].i32[0] = v8.i32[0];
  if (v8.i32[0] < 0 != v11)
  {
    return 0;
  }

  result = sentencepiece::SelfTestData_Sample::_InternalParse(a2, v6, this);
  if (!result)
  {
    return result;
  }

  ++this[11].i32[0];
  if (this[10].i32[0])
  {
    return 0;
  }

  v12 = this[3].i32[1] + v10 - v9;
  this[3].i32[1] = v12;
  *this = (*&this[1] + (v12 & (v12 >> 31)));
  return result;
}

google::protobuf::internal *google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::ModelProto_SentencePiece>(int32x2_t *this, uint64_t a2, google::protobuf::internal *a3)
{
  v5 = *a3;
  if (*a3 < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(a3, v5);
    if (!result)
    {
      return result;
    }

    v6 = result;
  }

  else
  {
    v6 = (a3 + 1);
  }

  v8 = this[1];
  v9 = v5 + v6 - v8.i32[0];
  *this = (*&v8 + (v9 & (v9 >> 31)));
  v10 = this[3].i32[1];
  this[3].i32[1] = v9;
  v8.i32[0] = this[11].i32[0];
  v11 = __OFSUB__(v8.i32[0]--, 1);
  this[11].i32[0] = v8.i32[0];
  if (v8.i32[0] < 0 != v11)
  {
    return 0;
  }

  result = sentencepiece::ModelProto_SentencePiece::_InternalParse(a2, v6, this);
  if (!result)
  {
    return result;
  }

  ++this[11].i32[0];
  if (this[10].i32[0])
  {
    return 0;
  }

  v12 = this[3].i32[1] + v10 - v9;
  this[3].i32[1] = v12;
  *this = (*&this[1] + (v12 & (v12 >> 31)));
  return result;
}

void google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::TrainerSpec>(google::protobuf::internal::EpsCopyInputStream *this, uint64_t a2, google::protobuf::internal *a3)
{
  v5 = *a3;
  if (*a3 < 0)
  {
    SizeFallback = google::protobuf::internal::ReadSizeFallback(a3, v5);
    if (!SizeFallback)
    {
      return;
    }

    v6 = SizeFallback;
  }

  else
  {
    v6 = (a3 + 1);
  }

  v8 = *(this + 1);
  v9 = v5 + v6 - v8;
  *this = v8 + (v9 & (v9 >> 31));
  v10 = *(this + 7);
  *(this + 7) = v9;
  LODWORD(v8) = *(this + 22);
  v11 = __OFSUB__(v8, 1);
  LODWORD(v8) = v8 - 1;
  *(this + 22) = v8;
  if (v8 < 0 == v11)
  {
    sentencepiece::TrainerSpec::_InternalParse(a2, v6, this);
    if (v12)
    {
      ++*(this + 22);
      if (!*(this + 20))
      {
        v13 = *(this + 7) + v10 - v9;
        *(this + 7) = v13;
        *this = *(this + 1) + (v13 & (v13 >> 31));
      }
    }
  }
}

google::protobuf::internal *google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::NormalizerSpec>(int32x2_t *this, uint64_t a2, google::protobuf::internal *a3)
{
  v5 = *a3;
  if (*a3 < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(a3, v5);
    if (!result)
    {
      return result;
    }

    v6 = result;
  }

  else
  {
    v6 = (a3 + 1);
  }

  v8 = this[1];
  v9 = v5 + v6 - v8.i32[0];
  *this = (*&v8 + (v9 & (v9 >> 31)));
  v10 = this[3].i32[1];
  this[3].i32[1] = v9;
  v8.i32[0] = this[11].i32[0];
  v11 = __OFSUB__(v8.i32[0]--, 1);
  this[11].i32[0] = v8.i32[0];
  if (v8.i32[0] < 0 != v11)
  {
    return 0;
  }

  result = sentencepiece::NormalizerSpec::_InternalParse(a2, v6, this);
  if (!result)
  {
    return result;
  }

  ++this[11].i32[0];
  if (this[10].i32[0])
  {
    return 0;
  }

  v12 = this[3].i32[1] + v10 - v9;
  this[3].i32[1] = v12;
  *this = (*&this[1] + (v12 & (v12 >> 31)));
  return result;
}

google::protobuf::internal *google::protobuf::internal::ParseContext::ParseMessage<sentencepiece::SelfTestData>(int32x2_t *this, uint64_t a2, google::protobuf::internal *a3)
{
  v5 = *a3;
  if (*a3 < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(a3, v5);
    if (!result)
    {
      return result;
    }

    v6 = result;
  }

  else
  {
    v6 = (a3 + 1);
  }

  v8 = this[1];
  v9 = v5 + v6 - v8.i32[0];
  *this = (*&v8 + (v9 & (v9 >> 31)));
  v10 = this[3].i32[1];
  this[3].i32[1] = v9;
  v8.i32[0] = this[11].i32[0];
  v11 = __OFSUB__(v8.i32[0]--, 1);
  this[11].i32[0] = v8.i32[0];
  if (v8.i32[0] < 0 != v11)
  {
    return 0;
  }

  result = sentencepiece::SelfTestData::_InternalParse(a2, v6, this);
  if (!result)
  {
    return result;
  }

  ++this[11].i32[0];
  if (this[10].i32[0])
  {
    return 0;
  }

  v12 = this[3].i32[1] + v10 - v9;
  this[3].i32[1] = v12;
  *this = (*&this[1] + (v12 & (v12 >> 31)));
  return result;
}

uint64_t google::protobuf::internal::EpsCopyInputStream::DoneFallback(google::protobuf::internal::EpsCopyInputStream *this, int a2, int a3)
{
  if (*(this + 7) < a2)
  {
    return 0;
  }

  v4 = a2;
  while (1)
  {
    Buffer = google::protobuf::internal::EpsCopyInputStream::NextBuffer(this, v4, a3);
    if (!Buffer)
    {
      break;
    }

    v7 = *(this + 1);
    v8 = *(this + 7) + Buffer - v7;
    *(this + 7) = v8;
    result = Buffer + v4;
    v4 = result - v7;
    if (result - v7 < 0)
    {
      *this = v7 + (v8 & (v8 >> 31));
      return result;
    }
  }

  if (v4)
  {
    return 0;
  }

  result = *(this + 1);
  *this = result;
  *(this + 20) = 1;
  return result;
}

google::protobuf::internal::EpsCopyInputStream *google::protobuf::internal::EpsCopyInputStream::ReadStringFallback()
{
  OUTLINED_FUNCTION_2_6();
  if (*(v6 + 23) < 0)
  {
    **v1 = 0;
    *(v1 + 8) = 0;
  }

  else
  {
    *v1 = 0;
    *(v1 + 23) = 0;
  }

  v7 = *(v2 + 8);
  if (v7 - v3 + *(v2 + 28) >= v0)
  {
    v8 = *(v1 + 23);
    if (v8 < 0)
    {
      v8 = *(v1 + 8);
    }

    OUTLINED_FUNCTION_1_5(v8);
    v7 = *(v2 + 8);
  }

  v9 = v7 - v3 + 16;
  while (*(v2 + 16))
  {
    OUTLINED_FUNCTION_3_4(v4, v5, v9);
    if (*(v2 + 28) < 17)
    {
      break;
    }

    result = google::protobuf::internal::EpsCopyInputStream::Next(v2);
    if (!result)
    {
      return result;
    }

    OUTLINED_FUNCTION_0_18();
    if (v12 ^ v13 | v11)
    {
      OUTLINED_FUNCTION_3_4(v4, v5, v0);
      return (v3 + v0);
    }
  }

  return 0;
}

google::protobuf::internal::EpsCopyInputStream *google::protobuf::internal::EpsCopyInputStream::AppendStringFallback()
{
  OUTLINED_FUNCTION_2_6();
  v6 = *(v4 + 8);
  if (v6 - v5 + *(v4 + 28) >= v7)
  {
    v8 = *(v1 + 23);
    if (v8 < 0)
    {
      v8 = *(v1 + 8);
    }

    OUTLINED_FUNCTION_1_5(v8);
    v6 = *(v2 + 8);
  }

  v9 = v6 - v3 + 16;
  while (*(v2 + 16))
  {
    OUTLINED_FUNCTION_3_4(v4, v5, v9);
    if (*(v2 + 28) < 17)
    {
      break;
    }

    result = google::protobuf::internal::EpsCopyInputStream::Next(v2);
    if (!result)
    {
      return result;
    }

    OUTLINED_FUNCTION_0_18();
    if (v12 ^ v13 | v11)
    {
      OUTLINED_FUNCTION_3_4(v4, v5, v0);
      return (v3 + v0);
    }
  }

  return 0;
}

char *google::protobuf::internal::ParseContext::ParseMessage<google::protobuf::MessageLite>(uint64_t a1, uint64_t a2, google::protobuf::internal *this)
{
  v5 = *this;
  if (*this < 0)
  {
    result = google::protobuf::internal::ReadSizeFallback(this, v5);
    if (!result)
    {
      return result;
    }

    v6 = result;
  }

  else
  {
    v6 = this + 1;
  }

  v7 = *(a1 + 8);
  v8 = v5 + v6 - v7;
  *a1 = v7 + (v8 & (v8 >> 31));
  v9 = *(a1 + 28);
  *(a1 + 28) = v8;
  LODWORD(v7) = *(a1 + 88);
  v10 = __OFSUB__(v7, 1);
  LODWORD(v7) = v7 - 1;
  *(a1 + 88) = v7;
  if (v7 < 0 == v10)
  {
    result = (*(*a2 + 88))(a2, v6, a1);
    if (!result)
    {
      return result;
    }

    ++*(a1 + 88);
    if (!*(a1 + 80))
    {
      v12 = *(a1 + 28) + v9 - v8;
      *(a1 + 28) = v12;
      *a1 = *(a1 + 8) + (v12 & (v12 >> 31));
      return result;
    }
  }

  return 0;
}

char *google::protobuf::internal::ReadSizeFallback(google::protobuf::internal *this, const char *a2)
{
  result = this + 2;
  v4 = -21;
  while (1)
  {
    LODWORD(a2) = ((*(result - 1) - 1) << (v4 + 28)) + a2;
    if ((*(result - 1) & 0x80000000) == 0)
    {
      break;
    }

    ++result;
    v4 += 7;
    if (!v4)
    {
      v5 = *(this + 4);
      v6 = this + 5;
      if (a2 + (v5 << 28) - 0x10000000 > 0x7FFFFFEF)
      {
        v6 = 0;
      }

      if (v5 <= 7)
      {
        return v6;
      }

      else
      {
        return 0;
      }
    }
  }

  return result;
}

_OWORD *google::protobuf::io::EpsCopyOutputStream::EnsureSpaceFallback(google::protobuf::io::EpsCopyOutputStream *this, unsigned __int8 *a2)
{
  LODWORD(v2) = a2;
  v4 = (this + 16);
  v5 = this + 32;
  while ((*(this + 56) & 1) == 0)
  {
    v6 = *this;
    if (*(this + 6))
    {
      v7 = *(this + 1);
      if (!v7)
      {
        *v4 = *v6;
        *(this + 1) = v6;
        goto LABEL_11;
      }

      memcpy(v7, v4, v6 - v4);
      v14 = 0;
      while (1)
      {
        v13 = 0;
        if (((*(**(this + 6) + 16))(*(this + 6), &v13, &v14) & 1) == 0)
        {
          break;
        }

        v8 = v14;
        if (v14)
        {
          v9 = v13;
          v10 = *this;
          if (v14 >= 17)
          {
            *v13 = *v10;
            v11 = v9 + v8 - 16;
            *this = v11;
            *(this + 1) = 0;
            goto LABEL_13;
          }

          *v4 = *v10;
          v11 = v4 + v8;
          *this = v11;
          *(this + 1) = v9;
          goto LABEL_12;
        }
      }
    }

    *(this + 56) = 1;
LABEL_11:
    *this = v5;
    v11 = v5;
LABEL_12:
    v9 = v4;
LABEL_13:
    v2 = v9 + v2 - v6;
    if (v2 < v11)
    {
      return v2;
    }
  }

  return v4;
}

void google::protobuf::internal::ExtensionSet::MergeFrom(google::protobuf::internal::ExtensionSet *this, const google::protobuf::internal::ExtensionSet *a2)
{
  if (*(this + 4) <= 0x100u)
  {
    v4 = *(a2 + 4);
    v5 = *(this + 2);
    v6 = &v5[32 * *(this + 5)];
    v7 = *(a2 + 2);
    if (v4 > 0x100)
    {
    }

    else
    {
      v8 = 0;
      v9 = v7 + 32 * *(a2 + 5);
      if (*(this + 5) && *(a2 + 5))
      {
        v8 = 0;
        do
        {
          if (*v5 == *v7)
          {
            v10 = v5 + 32;
          }

          else
          {
            v10 = v5;
          }

          if (*v5 < *v7)
          {
            v5 += 32;
          }

          else
          {
            v7 += 32;
            v5 = v10;
          }

          ++v8;
        }

        while (v5 != v6 && v7 != v9);
      }

      v12 = v8 + ((v9 - v7) >> 5) + ((v6 - v5) >> 5);
    }

    google::protobuf::internal::ExtensionSet::GrowCapacity(this, v12);
  }

  v13 = *(a2 + 2);
  if (*(a2 + 4) >= 0x101u)
  {
    v19 = *v13;
    v18 = v13 + 2;
    v17 = v19;

    google::protobuf::internal::ExtensionSet::ForEach<std::__map_iterator<std::__tree_iterator<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,std::__tree_node<std::__value_type<int,google::protobuf::internal::ExtensionSet::Extension>,void *> *,long>>,google::protobuf::internal::ExtensionSet::MergeFrom(google::protobuf::internal::ExtensionSet const&)::$_0>(v17, v18, this);
  }

  else if (*(a2 + 5))
  {
    v14 = &v13[8 * *(a2 + 5)];
    v15 = v13;
    do
    {
      v16 = *v15;
      v15 += 8;
      google::protobuf::internal::ExtensionSet::InternalExtensionMergeFrom(this, v16, v13 + 1);
      v13 = v15;
    }

    while (v15 != v14);
  }
}

uint64_t google::protobuf::internal::MergeFromImpl<false>()
{
  OUTLINED_FUNCTION_2_8();
  v10 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_1_6();
  google::protobuf::internal::EpsCopyInputStream::InitFrom(v8, v2, v3);
  OUTLINED_FUNCTION_8_0();
  v4 = OUTLINED_FUNCTION_10_0();
  v6 = v5(v4);
  result = 0;
  if (v6 && !v9)
  {
    if (v1 & 2) != 0 || ((*(*v0 + 48))(v0))
    {
      return 1;
    }

    else
    {
      google::protobuf::MessageLite::LogInitializationErrorMessage(v0);
      return 0;
    }
  }

  return result;
}

uint64_t google::protobuf::MessageLite::ParseFromArray(google::protobuf::MessageLite *this, const void *a2)
{
  OUTLINED_FUNCTION_9_0();
  OUTLINED_FUNCTION_0();
  (*(v2 + 40))();
  OUTLINED_FUNCTION_7_0();

  return google::protobuf::internal::MergeFromImpl<false>();
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__filename(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x1EEE63A08](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__extension(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x1EEE63A10](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__parent_path(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x1EEE63A18](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__root_directory(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x1EEE63A20](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__stem(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x1EEE63A48](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

void std::length_error::~length_error(std::length_error *this)
{
  MEMORY[0x1EEE63AE0](this);
}

{
  MEMORY[0x1EEE63AE8](this);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return MEMORY[0x1EEE63B20](this, a2);
}

{
  return MEMORY[0x1EEE63B38](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::string *a2)
{
  return MEMORY[0x1EEE63B28](this, a2);
}

{
  return MEMORY[0x1EEE63B40](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::runtime_error *a2)
{
  return MEMORY[0x1EEE63B30](this, a2);
}

{
  return MEMORY[0x1EEE63B48](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
  MEMORY[0x1EEE63B50](this);
}

{
  MEMORY[0x1EEE63B58](this);
}

uint64_t std::istream::get()
{
  return MEMORY[0x1EEE63D98]();
}

{
  return MEMORY[0x1EEE63DA0]();
}

uint64_t std::istream::seekg()
{
  return MEMORY[0x1EEE63DB8]();
}

{
  return MEMORY[0x1EEE63DC0]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x1EEE63E10]();
}

{
  return MEMORY[0x1EEE63E18]();
}

{
  return MEMORY[0x1EEE63E20]();
}

{
  return MEMORY[0x1EEE63E28]();
}

{
  return MEMORY[0x1EEE63E38]();
}

{
  return MEMORY[0x1EEE63E40]();
}

{
  return MEMORY[0x1EEE63E48]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1EEE63EA0]();
}

{
  return MEMORY[0x1EEE63EA8]();
}

{
  return MEMORY[0x1EEE63EB0]();
}

{
  return MEMORY[0x1EEE63EB8]();
}

{
  return MEMORY[0x1EEE63EC8]();
}

{
  return MEMORY[0x1EEE63ED0]();
}

{
  return MEMORY[0x1EEE63ED8]();
}

{
  return MEMORY[0x1EEE63EE0]();
}

{
  return MEMORY[0x1EEE63EE8]();
}

{
  return MEMORY[0x1EEE63EF0]();
}

{
  return MEMORY[0x1EEE63EF8]();
}

{
  return MEMORY[0x1EEE63F00]();
}

{
  return MEMORY[0x1EEE63F08]();
}

uint64_t std::wostream::operator<<()
{
  return MEMORY[0x1EEE63F18]();
}

{
  return MEMORY[0x1EEE63F20]();
}

{
  return MEMORY[0x1EEE63F28]();
}

uint64_t std::ifstream::open()
{
  return MEMORY[0x1EEE63F58]();
}

{
  return MEMORY[0x1EEE63F60]();
}

uint64_t std::ofstream::open()
{
  return MEMORY[0x1EEE63F70]();
}

{
  return MEMORY[0x1EEE63F78]();
}

std::__fs::filesystem::file_time_type std::__fs::filesystem::__last_write_time(const std::__fs::filesystem::path *a1, std::error_code *__ec)
{
  v2 = MEMORY[0x1EEE64188](a1, __ec);
  *(&result.__d_.__rep_ + 1) = v3;
  *&result.__d_.__rep_ = v2;
  return result;
}

void std::ios_base::failure::~failure(std::ios_base::failure *this)
{
  MEMORY[0x1EEE64428](this);
}

{
  MEMORY[0x1EEE64430](this);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return MEMORY[0x1EEE644C8](retstr, __val);
}

{
  return MEMORY[0x1EEE644D8](retstr, __val);
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x1EEE64520](this);
}

{
  MEMORY[0x1EEE64528](this);
}

void operator delete[]()
{
    ;
  }
}

void operator delete(void *__p)
{
    ;
  }
}

void operator delete(void *__p, const std::nothrow_t *a2)
{
    ;
  }
}

void operator delete(void *__p, std::align_val_t a2)
{
    ;
  }
}

void operator delete()
{
    ;
  }
}

void *__cdecl operator new[](size_t __sz)
{
    ;
  }
}

void *__cdecl operator new[](size_t __sz, const std::nothrow_t *a2)
{
    ;
  }
}

void operator new[]()
{
    ;
  }
}

void *__cdecl operator new(size_t __sz)
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, std::align_val_t a2)
{
    ;
  }
}

void operator new()
{
    ;
  }
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x1EEE73578](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}