__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v4 = *a1;
  if (*(*a1 + 24) == 3)
  {
    v5 = *a3;
    *(a2 + 8) = *(a3 + 2);
    *a2 = v5;
  }

  else
  {
    result = *a3;
    *v4 = *a3;
    *(v4 + 24) = 3;
  }

  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v4 = *a1;
  if (*(*a1 + 24) == 4)
  {
    v5 = *a3;
    *(a2 + 8) = *(a3 + 2);
    *a2 = v5;
  }

  else
  {
    result = *a3;
    *v4 = *a3;
    *(v4 + 24) = 4;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *result, _DWORD *a2, _DWORD *a3)
{
  v4 = *result;
  if (*(*result + 24) == 5)
  {
    *a2 = *a3;
  }

  else
  {
    *v4 = *a3;
    v4[6] = 5;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *result, void *a2, void *a3)
{
  v4 = *result;
  if (*(*result + 24) == 6)
  {
    *a2 = *a3;
  }

  else
  {
    *v4 = *a3;
    *(v4 + 24) = 6;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *result, _WORD *a2, _WORD *a3)
{
  v4 = *result;
  if (*(*result + 24) == 7)
  {
    *a2 = *a3;
  }

  else
  {
    *v4 = *a3;
    *(v4 + 24) = 7;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *result, _WORD *a2, _WORD *a3)
{
  v4 = *result;
  if (*(*result + 24) == 8)
  {
    *a2 = *a3;
  }

  else
  {
    *v4 = *a3;
    *(v4 + 24) = 8;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *result, _BYTE *a2, _BYTE *a3)
{
  v4 = *result;
  if (*(*result + 24) == 9)
  {
    *a2 = *a3;
  }

  else
  {
    *v4 = *a3;
    *(v4 + 24) = 9;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10ELm10EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *result, _BYTE *a2, _BYTE *a3)
{
  v4 = *result;
  if (*(*result + 24) == 10)
  {
    *a2 = *a3;
  }

  else
  {
    *v4 = *a3;
    *(v4 + 24) = 10;
  }

  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11ELm11EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *a1, __n128 *a2, __n128 *a3)
{
  v4 = *a1;
  if (*(*a1 + 24) == 11)
  {
    result = *a3;
    a2[1].n128_u64[0] = a3[1].n128_u64[0];
    *a2 = result;
  }

  else
  {
    result = *a3;
    v4[1].n128_u64[0] = a3[1].n128_u64[0];
    *v4 = result;
    v4[1].n128_u32[2] = 11;
  }

  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12ELm12EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *a1, __n128 *a2, __n128 *a3)
{
  v4 = *a1;
  if (*(*a1 + 24) == 12)
  {
    result = *a3;
    a3->n128_u64[0] = 0;
    a3->n128_u64[1] = 0;
    v6 = a2->n128_u64[1];
    *a2 = result;
    if (v6)
    {

      std::__shared_weak_count::__release_shared[abi:ne200100](v6);
    }
  }

  else
  {
    result = *a3;
    *v4 = *a3;
    a3->n128_u64[0] = 0;
    a3->n128_u64[1] = 0;
    *(v4 + 24) = 12;
  }

  return result;
}

MIL::Transform::NameGenerator *MIL::Transform::NameGenerator::NameGenerator(MIL::Transform::NameGenerator *this, const MIL::IRProgram *a2)
{
  v11[4] = *MEMORY[0x277D85DE8];
  *(this + 23) = 4;
  strcpy(this, "tmp_");
  *(this + 3) = 0;
  v3 = this + 24;
  *(this + 4) = 0;
  *(this + 5) = 0;
  v10[0] = this;
  v10[1] = 4;
  v8 = 0;
  v9 = 0;
  __p = 0;
  v11[0] = &unk_2829E9270;
  v11[1] = v10;
  v11[2] = &__p;
  v11[3] = v11;
  MIL::Util::ForEachVariableName(a2, v11);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne200100](v11);
  v4 = SHIBYTE(v9);
  if ((SHIBYTE(v9) & 0x8000000000000000) != 0)
  {
    v4 = v8;
    if (v8)
    {
      p_p = __p;
      goto LABEL_6;
    }
  }

  else if (HIBYTE(v9))
  {
    p_p = &__p;
LABEL_6:
    std::string::__assign_with_sentinel[abi:ne200100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(v3, p_p + v4, p_p + v4, p_p, p_p);
    goto LABEL_8;
  }

  MEMORY[0x21CEAF970](v3, "0");
LABEL_8:
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p);
  }

  return this;
}

void sub_2180B7070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17)
{
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne200100](&a17);
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (*(v17 + 47) < 0)
  {
    operator delete(*v18);
  }

  if (*(v17 + 23) < 0)
  {
    operator delete(*v17);
  }

  _Unwind_Resume(a1);
}

void anonymous namespace::Increment(uint64_t a1)
{
  v1 = *(a1 + 23);
  if ((v1 & 0x80u) == 0)
  {
    v2 = a1;
  }

  else
  {
    v2 = *a1;
  }

  if ((v1 & 0x80u) != 0)
  {
    v1 = *(a1 + 8);
  }

  if (v1)
  {
    while (1)
    {
      v3 = *v2;
      v4 = v3 <= 56;
      v5 = v3 <= 56 ? v3 + 1 : 48;
      *v2 = v5;
      if (v4)
      {
        break;
      }

      ++v2;
      if (!--v1)
      {
        goto LABEL_12;
      }
    }
  }

  else
  {
LABEL_12:
    std::string::push_back(a1, 49);
  }
}

void MIL::Transform::NameGenerator::GenerateTmpName(MIL::Transform::NameGenerator *this@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  v4 = *(this + 23);
  if (v4 < 0)
  {
    v4 = *(this + 1);
  }

  v5 = *(this + 47);
  if (v5 < 0)
  {
    v5 = *(this + 4);
  }

  std::string::reserve(a2, v5 + v4);
  v6 = *(this + 23);
  if (v6 >= 0)
  {
    v7 = this;
  }

  else
  {
    v7 = *this;
  }

  if (v6 >= 0)
  {
    v8 = *(this + 23);
  }

  else
  {
    v8 = *(this + 1);
  }

  std::string::append(a2, v7, v8);
  v9 = this + 24;
  v10 = *(this + 47);
  if (v10 < 0)
  {
    v12 = *(this + 3);
    v11 = &v12[*(this + 4)];
  }

  else
  {
    v11 = &v9[v10];
    v12 = this + 24;
  }

  if (v11 != v12)
  {
    std::string::__init_with_size[abi:ne200100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(__p, v11, v11, v12, v12, v11 - v12);
    if ((v16 & 0x80u) == 0)
    {
      v13 = __p;
    }

    else
    {
      v13 = __p[0];
    }

    if ((v16 & 0x80u) == 0)
    {
      v14 = v16;
    }

    else
    {
      v14 = __p[1];
    }

    std::string::append(a2, v13, v14);
    if (v16 < 0)
    {
      operator delete(__p[0]);
    }
  }
}

void sub_2180B7200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (*(v15 + 23) < 0)
  {
    operator delete(*v15);
  }

  _Unwind_Resume(exception_object);
}

void MIL::Transform::NameGenerator::TakeBack(uint64_t a1, const void **a2)
{
  v4 = *(a2 + 23);
  if ((v4 & 0x80u) == 0)
  {
    v5 = a2;
  }

  else
  {
    v5 = *a2;
  }

  if ((v4 & 0x80u) != 0)
  {
    v4 = a2[1];
  }

  v6 = *(a1 + 23);
  if ((v6 & 0x8000000000000000) != 0)
  {
    v7 = *a1;
    v6 = *(a1 + 8);
  }

  else
  {
    v7 = a1;
  }

  if (v4 < v6 || memcmp(v5, v7, v6))
  {
    return;
  }

  v8 = (a1 + 24);
  v9 = *(a1 + 47);
  if (*(a1 + 47) < 0)
  {
    v11 = *(a1 + 24);
    v10 = *(a1 + 32);
    if (v10 == 1)
    {
      if (*v11 == 48)
      {
        return;
      }

      v12 = v11 + 1;
      goto LABEL_21;
    }
  }

  else
  {
    if (v9 == 1 && *v8 == 48)
    {
      return;
    }

    v10 = *(a1 + 47);
    v11 = (a1 + 24);
  }

  if (!v10)
  {
    goto LABEL_31;
  }

  v12 = &v11[v10];
LABEL_21:
  v13 = v11 + 1;
  do
  {
    v14 = *(v13 - 1);
    v15 = v14 <= 48;
    if (v14 <= 48)
    {
      v16 = 57;
    }

    else
    {
      v16 = v14 - 1;
    }

    *(v13 - 1) = v16;
  }

  while (v15 && v13++ != v12);
  v9 = *(a1 + 47);
LABEL_31:
  if ((v9 & 0x80) != 0)
  {
    v20 = *(a1 + 32);
    if (v20 < 2)
    {
      goto LABEL_39;
    }

    v19 = *(a1 + 24);
    if (*(v19 + v20 - 1) != 48)
    {
      goto LABEL_39;
    }

    v18 = v20 - 1;
    *(a1 + 32) = v18;
  }

  else
  {
    if (v9 < 2 || v8[v9 - 1] != 48)
    {
      goto LABEL_39;
    }

    v18 = v9 - 1;
    *(a1 + 47) = v18 & 0x7F;
    v19 = a1 + 24;
  }

  *(v19 + v18) = 0;
LABEL_39:
  v21 = *(a2 + 23);
  v22 = *a2;
  if (v21 >= 0)
  {
    v22 = a2;
  }

  v23 = *(a1 + 23);
  if (v23 < 0)
  {
    v23 = *(a1 + 8);
  }

  v24 = &v22[v23];
  if (v21 < 0)
  {
    v21 = a2[1];
  }

  v25 = &v21[v22];
  v26 = *(a1 + 47);
  if (v26 < 0)
  {
    v28 = *(a1 + 24);
    v27 = &v28[*(a1 + 32)];
  }

  else
  {
    v27 = &v8[v26];
    v28 = (a1 + 24);
  }

  if (v25 - v24 == v27 - v28)
  {
    if (v24 == v25)
    {
LABEL_55:
      if (v27 == v28)
      {
        return;
      }
    }

    else
    {
      v29 = &v27[v24 - v25];
      while (v27 != v28)
      {
        v30 = *--v27;
        if (*v24 != v30)
        {
          break;
        }

        if (++v24 == v25)
        {
          v27 = v29;
          goto LABEL_55;
        }
      }
    }
  }
}

__n128 std::__function::__func<anonymous namespace::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0,std::allocator<anonymous namespace::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0>,void ()(std::string const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_2829E9270;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<anonymous namespace::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0,std::allocator<anonymous namespace::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0>,void ()(std::string const&)>::operator()(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 23);
  if (v2 >= 0)
  {
    v3 = *(a2 + 23);
  }

  else
  {
    v3 = *(a2 + 8);
  }

  v4 = *(result + 8);
  v5 = *(v4 + 8);
  if (v3 >= v5)
  {
    v6 = result;
    v7 = *v4;
    v8 = v2 >= 0 ? a2 : *a2;
    result = memcmp(v8, v7, v5);
    if (!result)
    {
      v9 = &v8[v5];
      v10 = v3 - v5;
      if (!v10)
      {
        goto LABEL_17;
      }

      do
      {
        if (*v9 != 48)
        {
          v11 = 0;
          while (v9[v11] - 48 < 0xA)
          {
            if (v10 == ++v11)
            {
              goto LABEL_17;
            }
          }

          return result;
        }

        ++v9;
        --v10;
      }

      while (v10);
      v9 = &v8[v3];
LABEL_17:
      v12 = *(v6 + 16);
      v13 = *(v12 + 23);
      if ((v13 & 0x8000000000000000) != 0)
      {
        v14 = *v12;
        v13 = v12[1];
      }

      else
      {
        v14 = v12;
      }

      if (v10 == v13)
      {
        result = memcmp(v9, v14, v10);
        if (result > 0)
        {
LABEL_24:

          JUMPOUT(0x21CEAF980);
        }
      }

      else if (v10 > v13)
      {
        goto LABEL_24;
      }
    }
  }

  return result;
}

uint64_t std::__function::__func<anonymous namespace::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0,std::allocator<anonymous namespace::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0>,void ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void std::string::__assign_with_sentinel[abi:ne200100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::string::__init_with_sentinel[abi:ne200100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(&__p, a2, a3, a4, a5);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  MEMORY[0x21CEAF980](a1, p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2180B773C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void std::string::__init_with_sentinel[abi:ne200100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(std::string *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  while (a3 != a5)
  {
    v8 = *--a3;
    std::string::push_back(this, v8);
  }
}

void sub_2180B77A8(void *a1)
{
  __cxa_begin_catch(a1);
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  __cxa_rethrow();
}

_BYTE *std::string::__init_with_size[abi:ne200100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(_BYTE *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (a6 >= 0x7FFFFFFFFFFFFFF8)
  {
    std::string::__throw_length_error[abi:ne200100]();
  }

  v7 = result;
  if (a6 > 0x16)
  {
    operator new();
  }

  result[23] = a6;
  while (a3 != a5)
  {
    v8 = *--a3;
    *v7++ = v8;
  }

  *v7 = 0;
  return result;
}

uint64_t MIL::Transform::OperationChange::OperationChange(uint64_t a1, uint64_t a2)
{
  *a1 = 0;
  *(a1 + 64) = -1;
  v4 = *(a2 + 64);
  if (v4 != -1)
  {
    v6 = a1;
    (off_2829E9318[v4])(&v6, a2);
    *(a1 + 64) = v4;
  }

  return a1;
}

{
  *a1 = 0;
  *(a1 + 64) = -1;
  v4 = *(a2 + 64);
  if (v4 != -1)
  {
    v6 = a1;
    (off_2829E9340[v4])(&v6, a2);
    *(a1 + 64) = v4;
  }

  return a1;
}

uint64_t MIL::Transform::OperationChange::operator=(uint64_t a1, uint64_t a2)
{
  MIL::Util::OpaqueStorage<128ul,8ul,MIL::Transform::OperationChange::OperationChangeImpl>::operator=(a1, a2);
  return a1;
}

{
  MIL::Util::OpaqueStorage<128ul,8ul,MIL::Transform::OperationChange::OperationChangeImpl>::operator=(a1, a2);
  return a1;
}

uint64_t MIL::Util::OpaqueStorage<128ul,8ul,MIL::Transform::OperationChange::OperationChangeImpl>::operator=(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 64);
  if (*(a1 + 64) != -1 || v3 != -1)
  {
    if (v3 == -1)
    {
    }

    else
    {
      v6 = a1;
      off_2829E9368[v3](&v6, a1, a2);
    }
  }

  return a1;
}

{
  v3 = *(a2 + 64);
  if (*(a1 + 64) != -1 || v3 != -1)
  {
    if (v3 == -1)
    {
    }

    else
    {
      v6 = a1;
      (off_2829E9390[v3])(&v6, a1, a2);
    }
  }

  return a1;
}

void MIL::Transform::OperationChange::~OperationChange(MIL::Transform::OperationChange *this)
{
}

{
}

_BYTE *MIL::Transform::ChangeOperator@<X0>(MIL::Transform *this@<X0>, _BYTE *a2@<X8>)
{
  result = std::string::basic_string[abi:ne200100]<0>(a2, this);
  *(result + 16) = 1;
  return result;
}

__n128 MIL::Transform::ChangeOperator@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  result = *a1;
  *a2 = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  a1->n128_u64[0] = 0;
  a2[4].n128_u32[0] = 1;
  return result;
}

void MIL::Transform::ChangeArgument(char *__s@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  std::string::basic_string[abi:ne200100]<0>(__p, __s);
  *a4 = *__p;
  v7 = v9;
  __p[1] = 0;
  v9 = 0;
  __p[0] = 0;
  *(a4 + 16) = v7;
  *(a4 + 24) = a2;
  MIL::Transform::ArgumentDescription::ArgumentDescription(a4 + 32, a3);
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  *(a4 + 64) = 2;
}

void sub_2180B7BF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(v2 + 23) < 0)
  {
    operator delete(*v2);
  }

  MIL::Builder::BlockBuilder::ReplaceUsesOfInputVariable(va);
  _Unwind_Resume(a1);
}

void MIL::Transform::ReplaceArgument(char *__s@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  std::string::basic_string[abi:ne200100]<0>(__p, __s);
  *a3 = *__p;
  *(a3 + 16) = v6;
  __p[1] = 0;
  v6 = 0;
  __p[0] = 0;
  MIL::Transform::ArgumentDescription::ArgumentDescription(a3 + 24, a2);
  if (SHIBYTE(v6) < 0)
  {
    operator delete(__p[0]);
  }

  *(a3 + 64) = 3;
}

void sub_2180B7C88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(v2 + 23) < 0)
  {
    operator delete(*v2);
  }

  MIL::Builder::BlockBuilder::ReplaceUsesOfInputVariable(va);
  _Unwind_Resume(a1);
}

__n128 MIL::Transform::ReplaceArguments@<Q0>(char *__s@<X0>, __n128 *a2@<X1>, _BYTE *a3@<X8>)
{
  v4 = std::string::basic_string[abi:ne200100]<0>(a3, __s);
  result = *a2;
  *(v4 + 24) = *a2;
  *(v4 + 5) = a2[1].n128_u64[0];
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  a2->n128_u64[0] = 0;
  *(v4 + 16) = 4;
  return result;
}

__n128 MIL::Transform::ReplaceAttribute@<Q0>(char *__s@<X0>, __n128 *a2@<X1>, _BYTE *a3@<X8>)
{
  v4 = std::string::basic_string[abi:ne200100]<0>(a3, __s);
  result = *a2;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  *(v4 + 24) = result;
  *(v4 + 16) = 0;
  return result;
}

void MIL::Transform::OperationChange::OperationChangeImpl::ApplyChange(std::string::size_type a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  v8 = *(a1 + 64);
  if (v8 == 4)
  {
    v9 = a1;
  }

  else
  {
    v9 = 0;
  }

  if (v8 == 4)
  {
    v11 = a2 + 2;
    v10 = *a2;
    v12 = *(a1 + 23);
    if (v12 >= 0)
    {
      v13 = a1;
    }

    else
    {
      v13 = *a1;
    }

    if (v12 >= 0)
    {
      v14 = *(a1 + 23);
    }

    else
    {
      v14 = *(a1 + 8);
    }

    Parameter = MIL::Transform::GetParameter(v10, v13, v14);
    v16 = (*(*Parameter + 16))(Parameter);
    *&v68 = a1;
    v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v11, a1);
    v18 = (v17 + 5);
    v19 = v17[5];
    for (i = v17[6]; i != v19; std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne200100](v18, i))
    {
      i -= 48;
    }

    v17[6] = v19;
    v26 = *(v9 + 24);
    v27 = *(v9 + 32);
    while (v26 != v27)
    {
      MIL::TransformPrivate::ArgumentDescriptionPrivate::CreateIRArgument(&v68, v26, a3, v16, a4);
      std::vector<MIL::TransformPrivate::ArgumentAndType>::push_back[abi:ne200100](v18, &v68);
      if (*(&v69 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](*(&v69 + 1));
      }

      if (*(&v68 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](*(&v68 + 1));
      }

      v26 += 32;
    }

    return;
  }

  if (v8 > 1)
  {
    if (v8 == 2)
    {
      v45 = a2 + 2;
      v44 = *a2;
      v46 = *(a1 + 23);
      if (v46 >= 0)
      {
        v47 = a1;
      }

      else
      {
        v47 = *a1;
      }

      if (v46 >= 0)
      {
        v48 = *(a1 + 23);
      }

      else
      {
        v48 = *(a1 + 8);
      }

      v49 = MIL::Transform::GetParameter(v44, v47, v48);
      v50 = (*(*v49 + 16))(v49);
      MIL::TransformPrivate::ArgumentDescriptionPrivate::CreateIRArgument(&v68, a1 + 32, a3, v50, a4);
      v72.__r_.__value_.__r.__words[0] = a1;
      v51 = std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v45, a1);
      v52 = *(a1 + 24);
      v53 = v51[5];
      if (0xAAAAAAAAAAAAAAABLL * ((v51[6] - v53) >> 4) <= v52)
      {
        std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne200100]();
      }

      v54 = &v53[48 * v52];
      v55 = v68;
      v68 = 0uLL;
      v56 = *(v54 + 1);
      *v54 = v55;
      if (v56)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v56);
      }

      v57 = v69;
      v69 = 0uLL;
      v58 = *(v54 + 3);
      *(v54 + 1) = v57;
      if (v58)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v58);
      }

      v59 = v70;
      v54[40] = v71;
      *(v54 + 4) = v59;
    }

    else
    {
      if (v8 != 3)
      {
        goto LABEL_66;
      }

      v29 = a2 + 2;
      v28 = *a2;
      v30 = *(a1 + 23);
      if (v30 >= 0)
      {
        v31 = a1;
      }

      else
      {
        v31 = *a1;
      }

      if (v30 >= 0)
      {
        v32 = *(a1 + 23);
      }

      else
      {
        v32 = *(a1 + 8);
      }

      v33 = MIL::Transform::GetParameter(v28, v31, v32);
      v34 = (*(*v33 + 16))(v33);
      MIL::TransformPrivate::ArgumentDescriptionPrivate::CreateIRArgument(&v68, a1 + 24, a3, v34, a4);
      v72.__r_.__value_.__r.__words[0] = a1;
      v35 = std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v29, a1);
      v36 = (v35 + 5);
      v37 = v35[5];
      for (j = v35[6]; j != v37; std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne200100](v36, j))
      {
        j -= 48;
      }

      v35[6] = v37;
      std::vector<MIL::TransformPrivate::ArgumentAndType>::push_back[abi:ne200100](v36, &v68);
    }

    v25 = *(&v69 + 1);
    if (!*(&v69 + 1))
    {
      goto LABEL_63;
    }

    goto LABEL_62;
  }

  if (v8)
  {
    if (v8 == 1)
    {
      v21 = *(a1 + 23);
      if (v21 >= 0)
      {
        v22 = a1;
      }

      else
      {
        v22 = *a1;
      }

      if (v21 >= 0)
      {
        v23 = *(a1 + 23);
      }

      else
      {
        v23 = *(a1 + 8);
      }

      MIL::Matching::GetOperatorByQualifiedName(a3, v22, v23, &v68);
      v24 = v68;
      v68 = 0uLL;
      v25 = a2[1];
      *a2 = v24;
      if (!v25)
      {
        return;
      }

LABEL_62:
      std::__shared_weak_count::__release_shared[abi:ne200100](v25);
LABEL_63:
      v43 = *(&v68 + 1);
      if (!*(&v68 + 1))
      {
        return;
      }

      goto LABEL_64;
    }

LABEL_66:
    exception = __cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Trying to visit a std::variant that is in an invalid state");
    __cxa_throw(exception, MEMORY[0x277D82750], MEMORY[0x277D825D8]);
  }

  if (!std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a2 + 10, a1))
  {
    v61 = __cxa_allocate_exception(0x10uLL);
    v62 = (*(**a2 + 16))();
    std::operator+[abi:ne200100]<char,std::char_traits<char>,std::allocator<char>>(": No attribute named ", v62, &v72.__r_.__value_.__l.__data_);
    v63 = *(a1 + 23);
    if (v63 >= 0)
    {
      v64 = a1;
    }

    else
    {
      v64 = *a1;
    }

    if (v63 >= 0)
    {
      v65 = *(a1 + 23);
    }

    else
    {
      v65 = *(a1 + 8);
    }

    v66 = std::string::append(&v72, v64, v65);
    v67 = *&v66->__r_.__value_.__l.__data_;
    *&v69 = *(&v66->__r_.__value_.__l + 2);
    v68 = v67;
    v66->__r_.__value_.__l.__size_ = 0;
    v66->__r_.__value_.__r.__words[2] = 0;
    v66->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(v61, &v68);
    v61->__vftable = (MEMORY[0x277D828F8] + 16);
    __cxa_throw(v61, off_278235F80, MEMORY[0x277D82610]);
  }

  *&v68 = a1;
  v39 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a2 + 10, a1);
  v41 = *(a1 + 24);
  v40 = *(a1 + 32);
  if (v40)
  {
    atomic_fetch_add_explicit(v40 + 1, 1uLL, memory_order_relaxed);
  }

  v42 = v39[6];
  v39[5] = v41;
  v39[6] = v40;
  if (v42)
  {
    v43 = v42;
LABEL_64:
    std::__shared_weak_count::__release_shared[abi:ne200100](v43);
  }
}

void sub_2180B820C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (a24 < 0)
  {
    operator delete(a19);
    if ((v25 & 1) == 0)
    {
LABEL_8:
      _Unwind_Resume(a1);
    }
  }

  else if (!v25)
  {
    goto LABEL_8;
  }

  __cxa_free_exception(v24);
  goto LABEL_8;
}

uint64_t std::vector<MIL::TransformPrivate::ArgumentAndType>::push_back[abi:ne200100](uint64_t *a1, uint64_t a2)
{
  v3 = a1[1];
  if (v3 >= a1[2])
  {
    result = std::vector<MIL::TransformPrivate::ArgumentAndType>::__emplace_back_slow_path<MIL::TransformPrivate::ArgumentAndType>(a1, a2);
  }

  else
  {
    *v3 = *a2;
    *a2 = 0;
    *(a2 + 8) = 0;
    v3[1] = *(a2 + 16);
    *(a2 + 16) = 0;
    *(a2 + 24) = 0;
    v3[2] = *(a2 + 32);
    result = (v3 + 3);
  }

  a1[1] = result;
  return result;
}

const void **std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(void *a1, const void **a2)
{
  v4 = std::__string_hash<char>::operator()[abi:ne200100](a1, a2);
  v5 = v4;
  v6 = a1[1];
  if (!*&v6)
  {
    goto LABEL_18;
  }

  v7 = vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v6)
    {
      v9 = v4 % *&v6;
    }
  }

  else
  {
    v9 = (*&v6 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_18:
    std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= *&v6)
      {
        v12 %= *&v6;
      }
    }

    else
    {
      v12 &= *&v6 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_18;
    }

LABEL_17:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_18;
    }
  }

  if (!std::equal_to<std::string>::operator()[abi:ne200100](a1, v11 + 2, a2))
  {
    goto LABEL_17;
  }

  return v11;
}

void sub_2180B8548(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>>>>::~unique_ptr[abi:ne200100](va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>>>>::~unique_ptr[abi:ne200100](uint64_t a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(a1 + 16) == 1)
    {
      std::__destroy_at[abi:ne200100]<std::pair<std::string const,std::vector<MIL::TransformPrivate::ArgumentAndType>>,0>(v2 + 16);
    }

    operator delete(v2);
  }

  return a1;
}

void std::__destroy_at[abi:ne200100]<std::pair<std::string const,std::vector<MIL::TransformPrivate::ArgumentAndType>>,0>(uint64_t a1)
{
  v2 = (a1 + 24);
  std::vector<MIL::TransformPrivate::ArgumentAndType>::__destroy_vector::operator()[abi:ne200100](&v2);
  if (*(a1 + 23) < 0)
  {
    operator delete(*a1);
  }
}

void std::vector<MIL::TransformPrivate::ArgumentAndType>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne200100](v1, v4);
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  v4 = *(a2 + 8);
  if (v4)
  {

    std::__shared_weak_count::__release_shared[abi:ne200100](v4);
  }
}

uint64_t std::vector<MIL::TransformPrivate::ArgumentAndType>::__emplace_back_slow_path<MIL::TransformPrivate::ArgumentAndType>(uint64_t *a1, uint64_t a2)
{
  v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  v3 = v2 + 1;
  if (v2 + 1 > 0x555555555555555)
  {
    std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
  }

  if (0x5555555555555556 * ((a1[2] - *a1) >> 4) > v3)
  {
    v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 4);
  }

  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL)
  {
    v6 = 0x555555555555555;
  }

  else
  {
    v6 = v3;
  }

  v17 = a1;
  if (v6)
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<MIL::TransformPrivate::ArgumentAndType>>(a1, v6);
  }

  v7 = 48 * v2;
  v14 = 0;
  v15 = v7;
  *(&v16 + 1) = 0;
  *v7 = *a2;
  *a2 = 0;
  *(a2 + 8) = 0;
  *(v7 + 16) = *(a2 + 16);
  *(a2 + 16) = 0;
  *(a2 + 24) = 0;
  *(v7 + 32) = *(a2 + 32);
  *&v16 = 48 * v2 + 48;
  v8 = a1[1];
  v9 = (48 * v2 + *a1 - v8);
  std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<MIL::TransformPrivate::ArgumentAndType>,MIL::TransformPrivate::ArgumentAndType*>(a1, *a1, v8, v9);
  v10 = *a1;
  *a1 = v9;
  v11 = a1[2];
  v13 = v16;
  *(a1 + 1) = v16;
  *&v16 = v10;
  *(&v16 + 1) = v11;
  v14 = v10;
  v15 = v10;
  std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::~__split_buffer(&v14);
  return v13;
}

void sub_2180B88A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

void std::__allocate_at_least[abi:ne200100]<std::allocator<MIL::TransformPrivate::ArgumentAndType>>(uint64_t a1, unint64_t a2)
{
  if (a2 < 0x555555555555556)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

uint64_t std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<MIL::TransformPrivate::ArgumentAndType>,MIL::TransformPrivate::ArgumentAndType*>(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  if (a2 == a3)
  {
    v10 = 1;
  }

  else
  {
    v5 = a2;
    v7 = a2;
    do
    {
      *a4 = *v7;
      *v7 = 0;
      *(v7 + 8) = 0;
      a4[1] = *(v7 + 16);
      *(v7 + 16) = 0;
      *(v7 + 24) = 0;
      a4[2] = *(v7 + 32);
      v7 += 48;
      a4 += 3;
    }

    while (v7 != a3);
    v12 = a4;
    v10 = 1;
    while (v5 != a3)
    {
      std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne200100](a1, v5);
      v5 += 48;
    }
  }

  return std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MIL::TransformPrivate::ArgumentAndType>,MIL::TransformPrivate::ArgumentAndType*>>::~__exception_guard_exceptions[abi:ne200100](v9);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MIL::TransformPrivate::ArgumentAndType>,MIL::TransformPrivate::ArgumentAndType*>>::~__exception_guard_exceptions[abi:ne200100](uint64_t a1)
{
  if ((*(a1 + 24) & 1) == 0)
  {
    std::_AllocatorDestroyRangeReverse<std::allocator<MIL::TransformPrivate::ArgumentAndType>,MIL::TransformPrivate::ArgumentAndType*>::operator()[abi:ne200100](a1);
  }

  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<MIL::TransformPrivate::ArgumentAndType>,MIL::TransformPrivate::ArgumentAndType*>::operator()[abi:ne200100](uint64_t *a1)
{
  v2 = a1[1];
  v1 = a1[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *a1;
    do
    {
      v3 -= 48;
      std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne200100](v5, v3);
    }

    while (v3 != v4);
  }
}

void **std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::~__split_buffer(void **a1)
{
  std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::clear[abi:ne200100](a1);
  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::clear[abi:ne200100](void *a1)
{
  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 48;
    std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne200100](v4, i - 48);
  }
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](uint64_t result)
{
  v1 = result;
  v2 = *(result + 64);
  if (v2 != -1)
  {
    result = (off_2829E92F0[v2])(&v3, result);
  }

  *(v1 + 64) = -1;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne200100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEELNS0_6_TraitE1EE9__destroyB8ne200100EvEUlRT_E_JRNS0_6__baseILSF_1EJS9_SA_SB_SC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 32);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  if (*(a2 + 23) < 0)
  {
    v4 = *a2;

    operator delete(v4);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne200100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEELNS0_6_TraitE1EE9__destroyB8ne200100EvEUlRT_E_JRNS0_6__baseILSF_1EJS9_SA_SB_SC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(a2 + 23) < 0)
  {
    operator delete(*a2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8ne200100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEELNS0_6_TraitE1EE9__destroyB8ne200100EvEUlRT_E_JRNS0_6__baseILSF_1EJS9_SA_SB_SC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  MIL::Transform::ArgumentDescription::~ArgumentDescription((a2 + 32));
  if (*(a2 + 23) < 0)
  {
    v3 = *a2;

    operator delete(v3);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3EEE10__dispatchB8ne200100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEELNS0_6_TraitE1EE9__destroyB8ne200100EvEUlRT_E_JRNS0_6__baseILSF_1EJS9_SA_SB_SC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  MIL::Transform::ArgumentDescription::~ArgumentDescription((a2 + 24));
  if (*(a2 + 23) < 0)
  {
    v3 = *a2;

    operator delete(v3);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4EEE10__dispatchB8ne200100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEELNS0_6_TraitE1EE9__destroyB8ne200100EvEUlRT_E_JRNS0_6__baseILSF_1EJS9_SA_SB_SC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 24);
  std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne200100](&v3);
  if (*(a2 + 23) < 0)
  {
    operator delete(*a2);
  }
}

void std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
      {
        MIL::Transform::ArgumentDescription::~ArgumentDescription((v4 - 32));
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne200100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne200100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlSO_E_JRKNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEEEEDcSN_DpT0_(std::string **a1, __int128 *a2)
{
  v3 = *a1;
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(*a1, *a2, *(a2 + 1));
  }

  else
  {
    v4 = *a2;
    v3->__r_.__value_.__r.__words[2] = *(a2 + 2);
    *&v3->__r_.__value_.__l.__data_ = v4;
  }

  v5 = *(a2 + 4);
  v3[1].__r_.__value_.__r.__words[0] = *(a2 + 3);
  v3[1].__r_.__value_.__l.__size_ = v5;
  if (v5)
  {
    atomic_fetch_add_explicit((v5 + 8), 1uLL, memory_order_relaxed);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne200100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne200100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlSO_E_JRKNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEEEEDcSN_DpT0_(std::string **a1, __int128 *a2)
{
  v2 = *a1;
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *a2, *(a2 + 1));
  }

  else
  {
    v3 = *a2;
    v2->__r_.__value_.__r.__words[2] = *(a2 + 2);
    *&v2->__r_.__value_.__l.__data_ = v3;
  }
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4EEE10__dispatchB8ne200100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne200100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlSO_E_JRKNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEEEEDcSN_DpT0_(std::string **a1, __int128 *a2)
{
  v3 = *a1;
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(*a1, *a2, *(a2 + 1));
  }

  else
  {
    v4 = *a2;
    v3->__r_.__value_.__r.__words[2] = *(a2 + 2);
    *&v3->__r_.__value_.__l.__data_ = v4;
  }

  v3[1].__r_.__value_.__r.__words[0] = 0;
  v3[1].__r_.__value_.__l.__size_ = 0;
  v3[1].__r_.__value_.__r.__words[2] = 0;
  return std::vector<MIL::Transform::ArgumentDescription>::__init_with_size[abi:ne200100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(&v3[1], *(a2 + 3), *(a2 + 4), (*(a2 + 4) - *(a2 + 3)) >> 5);
}

void sub_2180B8E10(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

std::string *std::__construct_at[abi:ne200100]<std::__variant_detail::__union<(std::__variant_detail::_Trait)1,0ul,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,std::in_place_index_t<2ul> const&,anonymous namespace::SingleArgumentChange const&,std::__variant_detail::__union<(std::__variant_detail::_Trait)1,0ul,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>*>(std::string *this, __int128 *a2)
{
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *a2, *(a2 + 1));
  }

  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *(a2 + 2);
    *&this->__r_.__value_.__l.__data_ = v4;
  }

  this[1].__r_.__value_.__r.__words[0] = *(a2 + 3);
  MIL::Transform::ArgumentDescription::ArgumentDescription(&this[1].__r_.__value_.__r.__words[1], (a2 + 2));
  return this;
}

void sub_2180B8E90(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

std::string *std::__construct_at[abi:ne200100]<std::__variant_detail::__union<(std::__variant_detail::_Trait)1,0ul,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,std::in_place_index_t<3ul> const&,anonymous namespace::SingleArgumentReplacement const&,std::__variant_detail::__union<(std::__variant_detail::_Trait)1,0ul,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>*>(std::string *this, __int128 *a2)
{
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *a2, *(a2 + 1));
  }

  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *(a2 + 2);
    *&this->__r_.__value_.__l.__data_ = v4;
  }

  MIL::Transform::ArgumentDescription::ArgumentDescription(&this[1], (a2 + 24));
  return this;
}

void sub_2180B8F08(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::vector<MIL::Transform::ArgumentDescription>::__init_with_size[abi:ne200100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<MIL::Transform::ArgumentDescription>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_2180B8F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<MIL::Transform::ArgumentDescription>::__vallocate[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 59))
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<MIL::Transform::ArgumentDescription>>(a1, a2);
  }

  std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
}

void std::__allocate_at_least[abi:ne200100]<std::allocator<MIL::Transform::ArgumentDescription>>(uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 59))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

MIL::Transform::ArgumentDescription *std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<MIL::Transform::ArgumentDescription>,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(int a1, MIL::Transform::ArgumentDescription *a2, MIL::Transform::ArgumentDescription *a3, MIL::Transform::ArgumentDescription *this)
{
  if (a2 != a3)
  {
    v6 = a2;
    v7 = 0;
    do
    {
      MIL::Transform::ArgumentDescription::ArgumentDescription(this, v6);
      v6 = (v6 + 32);
      this = (this + 32);
      v7 -= 32;
    }

    while (v6 != a3);
  }

  return this;
}

void sub_2180B9090(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    v4 = (v1 - 32);
    do
    {
      MIL::Transform::ArgumentDescription::~ArgumentDescription(v4);
      v4 = (v5 - 32);
      v2 += 32;
    }

    while (v2);
  }

  _Unwind_Resume(exception_object);
}

__n128 std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne200100]<void std::__variant_detail::__ctor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>>::__generic_construct[abi:ne200100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1>>(std::__variant_detail::__ctor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>>&,std::__variant_detail::__move_constructor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1> &&)::{lambda(std::__variant_detail::__move_constructor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1> &)#1} &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement> &&>(uint64_t *a1, __int128 *a2)
{
  v2 = *a1;
  v3 = *a2;
  *(v2 + 16) = *(a2 + 2);
  *v2 = v3;
  *(a2 + 1) = 0;
  *(a2 + 2) = 0;
  *a2 = 0;
  result = *(a2 + 24);
  *(v2 + 24) = result;
  *(a2 + 3) = 0;
  *(a2 + 4) = 0;
  return result;
}

__n128 std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne200100]<void std::__variant_detail::__ctor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>>::__generic_construct[abi:ne200100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1>>(std::__variant_detail::__ctor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>>&,std::__variant_detail::__move_constructor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1> &&)::{lambda(std::__variant_detail::__move_constructor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1> &)#1} &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement> &&>(__n128 **a1, __n128 *a2)
{
  v2 = *a1;
  result = *a2;
  v2[1].n128_u64[0] = a2[1].n128_u64[0];
  *v2 = result;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  a2->n128_u64[0] = 0;
  return result;
}

__n128 std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:ne200100]<void std::__variant_detail::__ctor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>>::__generic_construct[abi:ne200100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1>>(std::__variant_detail::__ctor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>>&,std::__variant_detail::__move_constructor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1> &&)::{lambda(std::__variant_detail::__move_constructor<std::__variant_detail::__traits<anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1> &)#1} &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement> &&>(uint64_t *a1, __int128 *a2)
{
  v2 = *a1;
  v3 = *a2;
  *(v2 + 16) = *(a2 + 2);
  *v2 = v3;
  *(a2 + 1) = 0;
  *(a2 + 2) = 0;
  *a2 = 0;
  *(v2 + 24) = 0;
  *(v2 + 32) = 0;
  *(v2 + 40) = 0;
  result = *(a2 + 24);
  *(v2 + 24) = result;
  *(v2 + 40) = *(a2 + 5);
  *(a2 + 3) = 0;
  *(a2 + 4) = 0;
  *(a2 + 5) = 0;
  return result;
}

uint64_t std::__construct_at[abi:ne200100]<std::__variant_detail::__union<(std::__variant_detail::_Trait)1,0ul,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,std::in_place_index_t<2ul> const&,anonymous namespace::SingleArgumentChange,std::__variant_detail::__union<(std::__variant_detail::_Trait)1,0ul,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>*>(uint64_t a1, __int128 *a2)
{
  v3 = *a2;
  *(a1 + 16) = *(a2 + 2);
  *a1 = v3;
  *(a2 + 1) = 0;
  *(a2 + 2) = 0;
  *a2 = 0;
  *(a1 + 24) = *(a2 + 3);
  MIL::Transform::ArgumentDescription::ArgumentDescription(a1 + 32, a2 + 2);
  return a1;
}

void sub_2180B91A0(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::__construct_at[abi:ne200100]<std::__variant_detail::__union<(std::__variant_detail::_Trait)1,0ul,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>,std::in_place_index_t<3ul> const&,anonymous namespace::SingleArgumentReplacement,std::__variant_detail::__union<(std::__variant_detail::_Trait)1,0ul,anonymous namespace::AttributeReplacement,anonymous namespace::OperatorChange,anonymous namespace::SingleArgumentChange,anonymous namespace::SingleArgumentReplacement,anonymous namespace::VariadicArgumentReplacement>*>(uint64_t a1, __int128 *a2)
{
  v3 = *a2;
  *(a1 + 16) = *(a2 + 2);
  *a1 = v3;
  *(a2 + 1) = 0;
  *(a2 + 2) = 0;
  *a2 = 0;
  MIL::Transform::ArgumentDescription::ArgumentDescription(a1 + 24, a2 + 24);
  return a1;
}

void sub_2180B91FC(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  v4 = *a1;
  if (*(*a1 + 64))
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v12, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }

    else
    {
      v12 = *__str;
    }

    size = __str[1].__r_.__value_.__l.__size_;
    v13[0] = *&__str[1].__r_.__value_.__l.__data_;
    *&v13[1] = size;
    if (size)
    {
      atomic_fetch_add_explicit((size + 8), 1uLL, memory_order_relaxed);
    }

    v11 = *&v12.__r_.__value_.__l.__data_;
    *(v4 + 16) = *(&v12.__r_.__value_.__l + 2);
    *v4 = v11;
    result = v13[0];
    *(v4 + 24) = *v13;
    *(v4 + 64) = 0;
  }

  else
  {
    std::string::operator=(this, __str);
    data = __str[1].__r_.__value_.__l.__data_;
    v7 = __str[1].__r_.__value_.__l.__size_;
    if (v7)
    {
      atomic_fetch_add_explicit((v7 + 8), 1uLL, memory_order_relaxed);
    }

    v9 = this[1].__r_.__value_.__l.__size_;
    this[1].__r_.__value_.__r.__words[0] = data;
    this[1].__r_.__value_.__l.__size_ = v7;
    if (v9)
    {

      std::__shared_weak_count::__release_shared[abi:ne200100](v9);
    }
  }

  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSU_EEEDcSM_DpT0_(__n128 **a1, std::string *this, std::string *__str)
{
  v3 = *a1;
  if ((*a1)[4].n128_u32[0] == 1)
  {

    std::string::operator=(this, __str);
  }

  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v5, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }

    else
    {
      v5 = *__str;
    }

    result = *&v5.__r_.__value_.__l.__data_;
    v3[1].n128_u64[0] = v5.__r_.__value_.__r.__words[2];
    *v3 = result;
    v3[4].n128_u32[0] = 1;
  }

  return result;
}

std::string *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  v4 = *a1;
  if (*(*a1 + 64) == 2)
  {
    std::string::operator=(this, __str);
    this[1].__r_.__value_.__r.__words[0] = __str[1].__r_.__value_.__r.__words[0];

    return MIL::Transform::ArgumentDescription::operator=(&this[1].__r_.__value_.__l.__size_, &__str[1].__r_.__value_.__l.__size_);
  }

  else
  {
    *(v4 + 64) = 2;
  }

  return result;
}

std::string *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  v4 = *a1;
  if (*(*a1 + 64) == 3)
  {
    std::string::operator=(this, __str);

    return MIL::Transform::ArgumentDescription::operator=(&this[1], &__str[1]);
  }

  else
  {
    *(v4 + 64) = 3;
  }

  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  v4 = *a1;
  if (*(*a1 + 64) == 4)
  {
    std::string::operator=(this, __str);
    if (this != __str)
    {
      data = __str[1].__r_.__value_.__l.__data_;
      size = __str[1].__r_.__value_.__l.__size_;

      std::vector<MIL::Transform::ArgumentDescription>::__assign_with_size[abi:ne200100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(&this[1], data, size, (size - data) >> 5);
    }
  }

  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&__p, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }

    else
    {
      __p = *__str;
    }

    v10 = 0uLL;
    v11 = 0;
    std::vector<MIL::Transform::ArgumentDescription>::__init_with_size[abi:ne200100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(&v10, __str[1].__r_.__value_.__l.__data_, __str[1].__r_.__value_.__l.__size_, (__str[1].__r_.__value_.__l.__size_ - __str[1].__r_.__value_.__r.__words[0]) >> 5);
    v8 = *&__p.__r_.__value_.__l.__data_;
    *(v4 + 16) = *(&__p.__r_.__value_.__l + 2);
    *v4 = v8;
    memset(&__p, 0, sizeof(__p));
    *(v4 + 24) = v10;
    *(v4 + 40) = v11;
    v10 = 0uLL;
    v11 = 0;
    *(v4 + 64) = 4;
    v12 = &v10;
    std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne200100](&v12);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_2180B9604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<MIL::Transform::ArgumentDescription>::__assign_with_size[abi:ne200100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(uint64_t a1, MIL::Transform::ArgumentDescription *a2, MIL::Transform::ArgumentDescription *a3, unint64_t a4)
{
  v6 = a2;
  v8 = *a1;
  if (a4 > (*(a1 + 16) - *a1) >> 5)
  {
    std::vector<MIL::Transform::ArgumentDescription>::__vdeallocate(a1);
    if (!(a4 >> 59))
    {
      v9 = *(a1 + 16) - *a1;
      v10 = v9 >> 4;
      if (v9 >> 4 <= a4)
      {
        v10 = a4;
      }

      if (v9 >= 0x7FFFFFFFFFFFFFE0)
      {
        v11 = 0x7FFFFFFFFFFFFFFLL;
      }

      else
      {
        v11 = v10;
      }

      std::vector<MIL::Transform::ArgumentDescription>::__vallocate[abi:ne200100](a1, v11);
    }

    std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
  }

  v12 = *(a1 + 8);
  v13 = v12 - v8;
  if (a4 <= (v12 - v8) >> 5)
  {
    if (a2 != a3)
    {
      do
      {
        MIL::Transform::ArgumentDescription::operator=(v8, v6);
        v6 += 32;
        v8 = (v8 + 32);
      }

      while (v6 != a3);
      v12 = *(a1 + 8);
    }

    while (v12 != v8)
    {
      v12 = (v12 - 32);
      MIL::Transform::ArgumentDescription::~ArgumentDescription(v12);
    }

    *(a1 + 8) = v8;
  }

  else
  {
    if (v12 != v8)
    {
      v14 = v12 - v8;
      v15 = a2;
      do
      {
        MIL::Transform::ArgumentDescription::operator=(v8, v15);
        v15 += 32;
        v8 = (v8 + 32);
        v14 -= 32;
      }

      while (v14);
      v12 = *(a1 + 8);
    }

    *(a1 + 8) = std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<MIL::Transform::ArgumentDescription>,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(a1, (v6 + v13), a3, v12);
  }
}

void std::vector<MIL::Transform::ArgumentDescription>::__vdeallocate(void **a1)
{
  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
      {
        MIL::Transform::ArgumentDescription::~ArgumentDescription((v3 - 32));
      }

      while (v3 != v1);
      v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, __int128 *a3)
{
  v4 = *a1;
  if (*(*a1 + 64))
  {
    v5 = *a3;
    *(v4 + 16) = *(a3 + 2);
    *v4 = v5;
    *a3 = 0;
    *(a3 + 1) = 0;
    *(a3 + 2) = 0;
    *(v4 + 24) = *(a3 + 24);
    *(a3 + 3) = 0;
    *(a3 + 4) = 0;
    *(v4 + 64) = 0;
  }

  else
  {
    if (*(a2 + 23) < 0)
    {
      operator delete(*a2);
    }

    v7 = *a3;
    *(a2 + 16) = *(a3 + 2);
    *a2 = v7;
    *(a3 + 23) = 0;
    *a3 = 0;
    v8 = *(a3 + 24);
    *(a3 + 3) = 0;
    *(a3 + 4) = 0;
    v9 = *(a2 + 32);
    *(a2 + 24) = v8;
    if (v9)
    {

      std::__shared_weak_count::__release_shared[abi:ne200100](v9);
    }
  }
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  v4 = *a1;
  if (*(*a1 + 64) == 1)
  {
    if (*(a2 + 23) < 0)
    {
      operator delete(*a2);
    }

    result = *a3;
    *(a2 + 16) = a3[1].n128_u64[0];
    *a2 = result;
    a3[1].n128_u8[7] = 0;
    a3->n128_u8[0] = 0;
  }

  else
  {
    result = *a3;
    v4[1].n128_u64[0] = a3[1].n128_u64[0];
    *v4 = result;
    a3->n128_u64[0] = 0;
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    v4[4].n128_u32[0] = 1;
  }

  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v4 = *a1;
  if (*(*a1 + 64) == 2)
  {
    if (*(a2 + 23) < 0)
    {
      operator delete(*a2);
    }

    v6 = *a3;
    *(a2 + 16) = *(a3 + 16);
    *a2 = v6;
    *(a3 + 23) = 0;
    *a3 = 0;
    *(a2 + 24) = *(a3 + 24);

    return MIL::Transform::ArgumentDescription::operator=(a2 + 32, a3 + 32);
  }

  else
  {
    *(v4 + 64) = 2;
  }

  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v4 = *a1;
  if (*(*a1 + 64) == 3)
  {
    if (*(a2 + 23) < 0)
    {
      operator delete(*a2);
    }

    v6 = *a3;
    *(a2 + 16) = *(a3 + 16);
    *a2 = v6;
    *(a3 + 23) = 0;
    *a3 = 0;

    return MIL::Transform::ArgumentDescription::operator=(a2 + 24, a3 + 24);
  }

  else
  {
    *(v4 + 64) = 3;
  }

  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne200100INS0_17__move_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, __int128 *a3)
{
  v4 = *a1;
  if (*(*a1 + 64) == 4)
  {
    if (*(a2 + 23) < 0)
    {
      operator delete(*a2);
    }

    v6 = *a3;
    *(a2 + 16) = *(a3 + 2);
    *a2 = v6;
    *(a3 + 23) = 0;
    *a3 = 0;
    std::vector<MIL::Transform::ArgumentDescription>::__vdeallocate((a2 + 24));
    result = *(a3 + 24);
    *(a2 + 24) = result;
    *(a2 + 40) = *(a3 + 5);
    *(a3 + 3) = 0;
    *(a3 + 4) = 0;
    *(a3 + 5) = 0;
  }

  else
  {
    v8 = *a3;
    *(v4 + 16) = *(a3 + 2);
    *v4 = v8;
    *a3 = 0;
    *(a3 + 1) = 0;
    *(a3 + 2) = 0;
    *(v4 + 24) = 0;
    *(v4 + 32) = 0;
    *(v4 + 40) = 0;
    result = *(a3 + 24);
    *(v4 + 24) = result;
    *(v4 + 40) = *(a3 + 5);
    *(a3 + 3) = 0;
    *(a3 + 4) = 0;
    *(a3 + 5) = 0;
    *(v4 + 64) = 4;
  }

  return result;
}

const void *MIL::Transform::GetParameter(uint64_t a1, const void *a2, size_t a3)
{
  v6 = (*(*a1 + 64))(a1);
  if (a3 >= 0x7FFFFFFFFFFFFFF8)
  {
    std::string::__throw_length_error[abi:ne200100]();
  }

  v7 = v6;
  if (a3 >= 0x17)
  {
    operator new();
  }

  *(&__dst.__r_.__value_.__s + 23) = a3;
  if (a3)
  {
    memmove(&__dst, a2, a3);
  }

  __dst.__r_.__value_.__s.__data_[a3] = 0;
  v8 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v7, &__dst.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }

  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, &__dst);
    exception->__vftable = (MEMORY[0x277D828F8] + 16);
    __cxa_throw(exception, off_278235F80, MEMORY[0x277D82610]);
  }

  return v8[5];
}

void sub_2180B9CDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v15 & 1) == 0)
    {
LABEL_6:
      _Unwind_Resume(a1);
    }
  }

  else if (!v15)
  {
    goto LABEL_6;
  }

  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t MIL::Transform::anonymous namespace::MakeNoSuchParameterErrorMessage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::ostringstream::basic_ostringstream[abi:ne200100](&v36);
  v6 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v36, "No such parameter '", 19);
  v7 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v6, a1, a2);
  v8 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v7, "' defined for operator '", 24);
  v9 = (*(*a3 + 16))(a3);
  v10 = *(v9 + 23);
  if (v10 >= 0)
  {
    v11 = v9;
  }

  else
  {
    v11 = *v9;
  }

  if (v10 >= 0)
  {
    v12 = *(v9 + 23);
  }

  else
  {
    v12 = *(v9 + 8);
  }

  v13 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v8, v11, v12);
  std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v13, "'. ", 3);
  if (*((*(*a3 + 64))(a3) + 24))
  {
    __p = 0;
    v34 = 0;
    v35 = 0;
    v14 = (*(*a3 + 64))(a3);
    std::vector<std::string_view>::reserve(&__p, *(v14 + 24));
    v15 = *((*(*a3 + 64))(a3) + 16);
    if (v15)
    {
      do
      {
        v16 = *(v15 + 39);
        if ((v16 & 0x8000000000000000) != 0)
        {
          v17 = v15[2];
          v16 = v15[3];
        }

        else
        {
          v17 = v15 + 2;
        }

        v18 = v34;
        if (v34 >= v35)
        {
          v20 = (v34 - __p) >> 4;
          v21 = v20 + 1;
          if ((v20 + 1) >> 60)
          {
            std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
          }

          v22 = v35 - __p;
          if ((v35 - __p) >> 3 > v21)
          {
            v21 = v22 >> 3;
          }

          if (v22 >= 0x7FFFFFFFFFFFFFF0)
          {
            v23 = 0xFFFFFFFFFFFFFFFLL;
          }

          else
          {
            v23 = v21;
          }

          if (v23)
          {
            std::__allocate_at_least[abi:ne200100]<std::allocator<std::string_view>>(&__p, v23);
          }

          v24 = (16 * v20);
          *v24 = v17;
          v24[1] = v16;
          v19 = (16 * v20 + 16);
          v25 = (16 * v20 - (v34 - __p));
          memcpy(v25, __p, v34 - __p);
          v26 = __p;
          __p = v25;
          v34 = v19;
          v35 = 0;
          if (v26)
          {
            operator delete(v26);
          }
        }

        else
        {
          *v34 = v17;
          *(v18 + 1) = v16;
          v19 = v18 + 16;
        }

        v34 = v19;
        v15 = *v15;
      }

      while (v15);
    }

    else
    {
      v19 = v34;
    }

    v27 = 126 - 2 * __clz((v19 - __p) >> 4);
    if (v19 == __p)
    {
      v28 = 0;
    }

    else
    {
      v28 = v27;
    }

    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,false>(__p, v19, &v41, v28, 1);
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v36, "Valid parameter names are: ", 27);
    v29 = __p;
    if (v34 != __p)
    {
      v30 = 0;
      v31 = 0;
      do
      {
        if (v31)
        {
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v36, ", ", 2);
          v29 = __p;
        }

        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v36, *&v29[v30], *&v29[v30 + 8]);
        ++v31;
        v29 = __p;
        v30 += 16;
      }

      while (v31 < (v34 - __p) >> 4);
    }

    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v36, ".", 1);
    if (__p)
    {
      v34 = __p;
      operator delete(__p);
    }
  }

  else
  {
    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v36, "This operator has no defined parameters.", 40);
  }

  std::stringbuf::str();
  v36 = *MEMORY[0x277D82828];
  *(&v36 + *(v36 - 24)) = *(MEMORY[0x277D82828] + 24);
  v37 = MEMORY[0x277D82878] + 16;
  if (v39 < 0)
  {
    operator delete(v38[7].__locale_);
  }

  v37 = MEMORY[0x277D82868] + 16;
  std::locale::~locale(v38);
  std::ostream::~ostream();
  return MEMORY[0x21CEAFDA0](&v40);
}

void sub_2180BA158(_Unwind_Exception *a1, uint64_t a2, void *__p, uint64_t a4, uint64_t a5, char a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, ...)
{
  va_start(va, a19);
  if (__p)
  {
    operator delete(__p);
  }

  std::ostringstream::~ostringstream(&a6, MEMORY[0x277D82828]);
  MEMORY[0x21CEAFDA0](va);
  _Unwind_Resume(a1);
}

BOOL MIL::Transform::HasWriteEffectAndNoOutputs(MIL::Builder::OperationBuilder **a1)
{
  Operator = MIL::Builder::OperationBuilder::GetOperator(*a1);
  result = 0;
  if ((*(*Operator + 240))(Operator))
  {
    v3 = MIL::Builder::OperationBuilder::GetOperator(*a1);
    v4 = (*(*v3 + 240))(v3);
    if (MIL::IRMemoryEffect::TryAsStateWriteEffect(v4))
    {
      if (!MIL::Builder::OperationBuilder::GetNumOutputs(*a1))
      {
        return 1;
      }
    }
  }

  return result;
}

void *std::vector<std::string_view>::reserve(void *result, unint64_t a2)
{
  if (a2 > (result[2] - *result) >> 4)
  {
    if (!(a2 >> 60))
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<std::string_view>>(result, a2);
    }

    std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
  }

  return result;
}

void std::__allocate_at_least[abi:ne200100]<std::allocator<std::string_view>>(uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 60))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,false>(__int128 *a1, __int128 *a2, uint64_t a3, uint64_t a4, char a5)
{
LABEL_1:
  v8 = a2 - 1;
  v9 = a2 - 2;
  v10 = a2 - 3;
  v11 = a1;
LABEL_2:
  v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    v13 = v12;
    v14 = a2 - v11;
    if (v14 > 2)
    {
      break;
    }

    if (v14 < 2)
    {
      return;
    }

    if (v14 == 2)
    {
      if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a2 - 1), v11))
      {
LABEL_78:
        v63 = *v11;
        *v11 = *v8;
        v34 = v63;
        goto LABEL_79;
      }

      return;
    }

LABEL_10:
    if (v14 <= 23)
    {
      if (a5)
      {

        std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v11, a2, a3);
      }

      else
      {

        std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v11, a2, a3);
      }

      return;
    }

    if (v13 == 1)
    {
      if (v11 != a2)
      {

        std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,std::string_view *>(v11, a2, a2, a3);
      }

      return;
    }

    v15 = &v11[v14 >> 1];
    if (v14 >= 0x81)
    {
      v16 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &v11[v14 >> 1], v11);
      v17 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a2 - 1), v15);
      if (v16)
      {
        if (v17)
        {
          v41 = *a1;
          *a1 = *v8;
          goto LABEL_27;
        }

        v47 = *a1;
        *a1 = *v15;
        *v15 = v47;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a2 - 1), v15))
        {
          v41 = *v15;
          *v15 = *v8;
LABEL_27:
          *v8 = v41;
        }
      }

      else if (v17)
      {
        v43 = *v15;
        *v15 = *v8;
        *v8 = v43;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v15, a1))
        {
          v44 = *a1;
          *a1 = *v15;
          *v15 = v44;
        }
      }

      v20 = v15 - 1;
      v21 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (v15 - 1), (a1 + 1));
      v22 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a2 - 2), (v15 - 1));
      if (v21)
      {
        if (v22)
        {
          v23 = a1[1];
          a1[1] = *v9;
          goto LABEL_39;
        }

        v51 = a1[1];
        a1[1] = *v20;
        *v20 = v51;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a2 - 2), (v15 - 1)))
        {
          v52 = *v20;
          *v20 = *v9;
          v23 = v52;
LABEL_39:
          *v9 = v23;
        }
      }

      else if (v22)
      {
        v48 = *v20;
        *v20 = *v9;
        *v9 = v48;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (v15 - 1), (a1 + 1)))
        {
          v49 = a1[1];
          a1[1] = *v20;
          *v20 = v49;
        }
      }

      v24 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (v15 + 1), (a1 + 2));
      v25 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a2 - 3), (v15 + 1));
      if (v24)
      {
        if (v25)
        {
          v26 = a1[2];
          a1[2] = *v10;
          goto LABEL_48;
        }

        v55 = a1[2];
        a1[2] = v15[1];
        v15[1] = v55;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a2 - 3), (v15 + 1)))
        {
          v56 = v15[1];
          v15[1] = *v10;
          v26 = v56;
LABEL_48:
          *v10 = v26;
        }
      }

      else if (v25)
      {
        v53 = v15[1];
        v15[1] = *v10;
        *v10 = v53;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (v15 + 1), (a1 + 2)))
        {
          v54 = a1[2];
          a1[2] = v15[1];
          v15[1] = v54;
        }
      }

      v27 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v15, (v15 - 1));
      v28 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (v15 + 1), v15);
      if (v27)
      {
        if (v28)
        {
          v57 = *v20;
          *v20 = v15[1];
          goto LABEL_57;
        }

        v60 = *v20;
        *v20 = *v15;
        *v15 = v60;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (v15 + 1), v15))
        {
          v57 = *v15;
          *v15 = v15[1];
LABEL_57:
          v15[1] = v57;
        }
      }

      else if (v28)
      {
        v58 = *v15;
        *v15 = v15[1];
        v15[1] = v58;
        if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v15, (v15 - 1)))
        {
          v59 = *v20;
          *v20 = *v15;
          *v15 = v59;
        }
      }

      v61 = *a1;
      *a1 = *v15;
      *v15 = v61;
      goto LABEL_59;
    }

    v18 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v11, &v11[v14 >> 1]);
    v19 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a2 - 1), a1);
    if (v18)
    {
      if (v19)
      {
        v42 = *v15;
        *v15 = *v8;
LABEL_36:
        *v8 = v42;
        goto LABEL_59;
      }

      v50 = *v15;
      *v15 = *a1;
      *a1 = v50;
      if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a2 - 1), a1))
      {
        v42 = *a1;
        *a1 = *v8;
        goto LABEL_36;
      }
    }

    else if (v19)
    {
      v45 = *a1;
      *a1 = *v8;
      *v8 = v45;
      if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, a1, v15))
      {
        v46 = *v15;
        *v15 = *a1;
        *a1 = v46;
      }
    }

LABEL_59:
    if ((a5 & 1) == 0 && (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a1 - 1), a1) & 1) == 0)
    {
      v11 = std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,std::string_view *,std::__less<void,void> &>(a1, a2, a3);
      goto LABEL_66;
    }

    v29 = std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,std::string_view *,std::__less<void,void> &>(a1, a2, a3);
    if ((v30 & 1) == 0)
    {
      goto LABEL_64;
    }

    v31 = std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, v29, a3);
    v11 = &v29[1];
    if (std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v29 + 1, a2, a3))
    {
      a4 = -v13;
      a2 = v29;
      if (v31)
      {
        return;
      }

      goto LABEL_1;
    }

    v12 = v13 + 1;
    if (!v31)
    {
LABEL_64:
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,false>(a1, v29, a3, -v13, a5 & 1);
      v11 = &v29[1];
LABEL_66:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }

  if (v14 != 3)
  {
    if (v14 == 4)
    {

      std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,0>(v11, v11 + 1, v11 + 2, a2 - 1, a3);
      return;
    }

    if (v14 == 5)
    {
      std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,0>(v11, v11 + 1, v11 + 2, v11 + 3, a3);
      if (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (a2 - 1), (v11 + 3)))
      {
        return;
      }

      v35 = v11[3];
      v11[3] = *v8;
      *v8 = v35;
      if (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (v11 + 3), (v11 + 2)))
      {
        return;
      }

      v36 = v11[2];
      v11[2] = v11[3];
      v11[3] = v36;
      if (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (v11 + 2), (v11 + 1)))
      {
        return;
      }

      v37 = v11[1];
      v11[1] = v11[2];
      v11[2] = v37;
      goto LABEL_93;
    }

    goto LABEL_10;
  }

  v32 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (v11 + 1), v11);
  v33 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v8, (v11 + 1));
  if ((v32 & 1) == 0)
  {
    if (!v33)
    {
      return;
    }

    v39 = v11[1];
    v11[1] = *v8;
    *v8 = v39;
LABEL_93:
    if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, (v11 + 1), v11))
    {
      v64 = *v11;
      *v11 = v11[1];
      v11[1] = v64;
    }

    return;
  }

  if (v33)
  {
    goto LABEL_78;
  }

  v62 = *v11;
  *v11 = v11[1];
  v11[1] = v62;
  if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v8, (v11 + 1)))
  {
    v34 = v11[1];
    v11[1] = *v8;
LABEL_79:
    *v8 = v34;
  }
}

uint64_t std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *a2;
  v4 = *(a2 + 8);
  v5 = *a3;
  v6 = *(a3 + 8);
  if (v6 >= v4)
  {
    v7 = v4;
  }

  else
  {
    v7 = *(a3 + 8);
  }

  v8 = memcmp(v3, v5, v7);
  if (v4 < v6)
  {
    v9 = -1;
  }

  else
  {
    v9 = 1;
  }

  if (v4 == v6)
  {
    v9 = 0;
  }

  if (v8)
  {
    v9 = v8;
  }

  return v9 >> 31;
}

__n128 std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,0>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, uint64_t a5)
{
  v10 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a5, a2, a1);
  v11 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a5, a3, a2);
  if (v10)
  {
    if (v11)
    {
      v12 = *a1;
      *a1 = *a3;
LABEL_9:
      *a3 = v12;
      goto LABEL_10;
    }

    v15 = *a1;
    *a1 = *a2;
    *a2 = v15;
    if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a5, a3, a2))
    {
      v12 = *a2;
      *a2 = *a3;
      goto LABEL_9;
    }
  }

  else if (v11)
  {
    v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a5, a2, a1))
    {
      v14 = *a1;
      *a1 = *a2;
      *a2 = v14;
    }
  }

LABEL_10:
  if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a5, a4, a3))
  {
    v17 = *a3;
    *a3 = *a4;
    *a4 = v17;
    if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a5, a3, a2))
    {
      v18 = *a2;
      *a2 = *a3;
      *a3 = v18;
      if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a5, a2, a1))
      {
        result = *a1;
        *a1 = *a2;
        *a2 = result;
      }
    }
  }

  return result;
}

uint64_t std::__insertion_sort[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(uint64_t result, __int128 *a2, uint64_t a3)
{
  if (result != a2)
  {
    v15 = v3;
    v16 = v4;
    v6 = result;
    v7 = result + 16;
    if ((result + 16) != a2)
    {
      v9 = 0;
      v10 = result;
      do
      {
        v11 = v10;
        v10 = v7;
        result = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v7, v11);
        if (result)
        {
          v14 = *v10;
          v12 = v9;
          while (1)
          {
            *(v6 + v12 + 16) = *(v6 + v12);
            if (!v12)
            {
              break;
            }

            v12 -= 16;
            result = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &v14, v6 + v12);
            if ((result & 1) == 0)
            {
              v13 = (v6 + v12 + 16);
              goto LABEL_10;
            }
          }

          v13 = v6;
LABEL_10:
          *v13 = v14;
        }

        v7 = (v10 + 1);
        v9 += 16;
      }

      while (v10 + 1 != a2);
    }
  }

  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(uint64_t result, __int128 *a2, uint64_t a3)
{
  if (result != a2)
  {
    v13 = v3;
    v14 = v4;
    v6 = result;
    v7 = result + 16;
    if ((result + 16) != a2)
    {
      v9 = result - 16;
      do
      {
        v10 = v6;
        v6 = v7;
        result = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v7, v10);
        if (result)
        {
          v12 = *v6;
          v11 = v9;
          do
          {
            *(v11 + 32) = *(v11 + 16);
            result = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &v12, v11);
            v11 -= 16;
          }

          while ((result & 1) != 0);
          *(v11 + 32) = v12;
        }

        v7 = (v6 + 1);
        v9 += 16;
      }

      while (v6 + 1 != a2);
    }
  }

  return result;
}

__int128 *std::__partition_with_equals_on_left[abi:ne200100]<std::_ClassicAlgPolicy,std::string_view *,std::__less<void,void> &>(__int128 *a1, __int128 *a2, uint64_t a3)
{
  v4 = a2;
  v11 = *a1;
  if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &v11, (a2 - 1)))
  {
    v6 = a1;
    do
    {
      ++v6;
    }

    while ((std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &v11, v6) & 1) == 0);
  }

  else
  {
    v7 = (a1 + 1);
    do
    {
      v6 = v7;
      if (v7 >= v4)
      {
        break;
      }

      v8 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &v11, v7);
      v7 = (v6 + 1);
    }

    while (!v8);
  }

  if (v6 < v4)
  {
    do
    {
      --v4;
    }

    while ((std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &v11, v4) & 1) != 0);
  }

  while (v6 < v4)
  {
    v12 = *v6;
    *v6 = *v4;
    *v4 = v12;
    do
    {
      ++v6;
    }

    while (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &v11, v6));
    do
    {
      --v4;
    }

    while ((std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &v11, v4) & 1) != 0);
  }

  v9 = v6 - 1;
  if (v6 - 1 != a1)
  {
    *a1 = *v9;
  }

  *v9 = v11;
  return v6;
}

__int128 *std::__partition_with_equals_on_right[abi:ne200100]<std::_ClassicAlgPolicy,std::string_view *,std::__less<void,void> &>(__int128 *a1, unint64_t a2, uint64_t a3)
{
  v6 = 0;
  v13 = *a1;
  do
  {
    ++v6;
  }

  while ((std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &a1[v6], &v13) & 1) != 0);
  v7 = &a1[v6];
  v8 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v7 >= a2)
      {
        break;
      }

      a2 -= 16;
    }

    while ((std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, a2, &v13) & 1) == 0);
  }

  else
  {
    do
    {
      a2 -= 16;
    }

    while (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, a2, &v13));
  }

  if (v7 < a2)
  {
    v9 = &a1[v6];
    v10 = a2;
    do
    {
      v14 = *v9;
      v11 = v14;
      *v9 = *v10;
      *v10 = v11;
      do
      {
        ++v9;
      }

      while ((std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v9, &v13) & 1) != 0);
      do
      {
        --v10;
      }

      while (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v10, &v13));
    }

    while (v9 < v10);
    v8 = v9 - 1;
  }

  if (v8 != a1)
  {
    *a1 = *v8;
  }

  *v8 = v13;
  return v8;
}

BOOL std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  v6 = a2 - a1;
  if (v6 > 2)
  {
    switch(v6)
    {
      case 3:
        v7 = a2 - 1;
        v12 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &a1[1], a1);
        v13 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v7, &a1[1]);
        if (v12)
        {
          if (!v13)
          {
            v23 = *a1;
            *a1 = a1[1];
            a1[1] = v23;
            if (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v7, &a1[1]))
            {
              return 1;
            }

            v14 = a1[1];
            a1[1] = *v7;
            goto LABEL_16;
          }

LABEL_15:
          v14 = *a1;
          *a1 = *v7;
LABEL_16:
          *v7 = v14;
          return 1;
        }

        if (!v13)
        {
          return 1;
        }

        v19 = a1[1];
        a1[1] = *v7;
        *v7 = v19;
        break;
      case 4:
        std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,0>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
        return 1;
      case 5:
        v8 = a2 - 1;
        std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a3);
        if (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v8, &a1[3]))
        {
          return 1;
        }

        v9 = a1[3];
        a1[3] = *v8;
        *v8 = v9;
        if (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &a1[3], &a1[2]))
        {
          return 1;
        }

        v10 = a1[2];
        a1[2] = a1[3];
        a1[3] = v10;
        if (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &a1[2], &a1[1]))
        {
          return 1;
        }

        v11 = a1[1];
        a1[1] = a1[2];
        a1[2] = v11;
        break;
      default:
        goto LABEL_17;
    }

    if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &a1[1], a1))
    {
      v20 = *a1;
      *a1 = a1[1];
      a1[1] = v20;
    }

    return 1;
  }

  if (v6 < 2)
  {
    return 1;
  }

  if (v6 == 2)
  {
    v7 = a2 - 1;
    if (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &a2[-1], a1))
    {
      return 1;
    }

    goto LABEL_15;
  }

LABEL_17:
  v15 = a1 + 2;
  v16 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &a1[1], a1);
  v17 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &a1[2], &a1[1]);
  if (v16)
  {
    if (v17)
    {
      v18 = *a1;
      *a1 = *v15;
    }

    else
    {
      v24 = *a1;
      *a1 = a1[1];
      a1[1] = v24;
      if (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &a1[2], &a1[1]))
      {
        goto LABEL_33;
      }

      v18 = a1[1];
      a1[1] = *v15;
    }

    *v15 = v18;
  }

  else if (v17)
  {
    v21 = a1[1];
    a1[1] = *v15;
    *v15 = v21;
    if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, &a1[1], a1))
    {
      v22 = *a1;
      *a1 = a1[1];
      a1[1] = v22;
    }
  }

LABEL_33:
  v25 = a1 + 3;
  if (&a1[3] == a2)
  {
    return 1;
  }

  v26 = 0;
  v27 = 0;
  while (1)
  {
    if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v25, v15))
    {
      v32[0] = *v25;
      v28 = v26;
      while (1)
      {
        v29 = a1 + v28;
        *(a1 + v28 + 48) = *(a1 + v28 + 32);
        if (v28 == -32)
        {
          break;
        }

        v28 -= 16;
        if ((std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v32, (v29 + 16)) & 1) == 0)
        {
          v30 = (a1 + v28 + 48);
          goto LABEL_41;
        }
      }

      v30 = a1;
LABEL_41:
      *v30 = v32[0];
      if (++v27 == 8)
      {
        return &v25[1] == a2;
      }
    }

    v15 = v25;
    v26 += 16;
    if (++v25 == a2)
    {
      return 1;
    }
  }
}

__int128 *std::__partial_sort_impl[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,std::string_view *>(__int128 *a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    v8 = a2 - a1;
    if (v8 >= 2)
    {
      v9 = (v8 - 2) >> 1;
      v10 = v9 + 1;
      v11 = &a1[v9];
      do
      {
        std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, a4, v8, v11--);
        --v10;
      }

      while (v10);
    }

    v12 = a2;
    if (a2 != a3)
    {
      v12 = a2;
      do
      {
        if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a4, v12, a1))
        {
          v13 = *v12;
          *v12 = *a1;
          *a1 = v13;
          std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, a4, v8, a1);
        }

        ++v12;
      }

      while (v12 != a3);
    }

    if (v8 >= 2)
    {
      v14 = a2 - 1;
      do
      {
        v18 = *a1;
        v15 = std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, a4, v8);
        if (v14 == v15)
        {
          *v15 = v18;
        }

        else
        {
          *v15 = *v14;
          *v14 = v18;
          std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, (v15 + 1), a4, v15 + 1 - a1);
        }

        --v14;
      }

      while (v8-- > 2);
    }

    return v12;
  }

  return a3;
}

double std::__sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  v6 = a3 - 2;
  if (a3 >= 2)
  {
    v21 = v4;
    v22 = v5;
    v7 = a4;
    v9 = v6 >> 1;
    if ((v6 >> 1) >= (a4 - a1) >> 4)
    {
      v12 = (a4 - a1) >> 3;
      v13 = v12 + 1;
      v14 = (a1 + 16 * (v12 + 1));
      v15 = v12 + 2;
      if (v12 + 2 < a3 && std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a2, a1 + 16 * (v12 + 1), (v14 + 1)))
      {
        ++v14;
        v13 = v15;
      }

      if ((std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a2, v14, v7) & 1) == 0)
      {
        v20 = *v7;
        do
        {
          v17 = v14;
          *v7 = *v14;
          if (v9 < v13)
          {
            break;
          }

          v18 = (2 * v13) | 1;
          v14 = (a1 + 16 * v18);
          v19 = 2 * v13 + 2;
          if (v19 < a3)
          {
            if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a2, a1 + 16 * v18, (v14 + 1)))
            {
              ++v14;
              v18 = v19;
            }
          }

          v7 = v17;
          v13 = v18;
        }

        while (!std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a2, v14, &v20));
        result = *&v20;
        *v17 = v20;
      }
    }
  }

  return result;
}

_OWORD *std::__floyd_sift_down[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(_OWORD *a1, uint64_t a2, uint64_t a3)
{
  v6 = 0;
  v7 = (a3 - 2) / 2;
  do
  {
    v8 = &a1[v6];
    v9 = v8 + 1;
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3)
    {
      v12 = v8 + 2;
      if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a2, (v8 + 1), (v8 + 2)))
      {
        v9 = v12;
        v10 = v11;
      }
    }

    *a1 = *v9;
    a1 = v9;
    v6 = v10;
  }

  while (v10 <= v7);
  return v9;
}

double std::__sift_up[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6 = a4 - 2;
  if (a4 >= 2)
  {
    v15 = v4;
    v16 = v5;
    v9 = v6 >> 1;
    v10 = (a1 + 16 * (v6 >> 1));
    v11 = (a2 - 16);
    if (std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v10, a2 - 16))
    {
      v14 = *v11;
      do
      {
        v13 = v10;
        *v11 = *v10;
        if (!v9)
        {
          break;
        }

        v9 = (v9 - 1) >> 1;
        v10 = (a1 + 16 * v9);
        v11 = v13;
      }

      while ((std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string_view>(a3, v10, &v14) & 1) != 0);
      result = *&v14;
      *v13 = v14;
    }
  }

  return result;
}

void **MIL::Transform::MatchContext::GetMILContextPtr@<X0>(void **this@<X0>, void *a2@<X8>)
{
  v2 = (*this)[1];
  *a2 = **this;
  a2[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return this;
}

void MIL::Transform::MatchContext::AddOperation(uint64_t **a1, char *a2, uint64_t *a3)
{
  v3 = a3[1];
  if (v3)
  {
    v4 = *a3;
  }

  else
  {
    v4 = 0;
  }

  MIL::Transform::MatchContext::AddOperation(a1, a2, v4, v3);
}

{
  v3 = a3[1];
  if (v3)
  {
    v4 = *a3;
  }

  else
  {
    v4 = 0;
  }

  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, 1, v4, v3);
}

void MIL::Transform::MatchContext::AddOperation(uint64_t **a1, char *a2, uint64_t a3, unint64_t a4)
{
  v4 = 0u;
  v5 = 0u;
  v6 = 1065353216;
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, 1, a3, a4);
}

{
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, 1, a3, a4);
}

void MIL::Transform::MatchContext::AddVariadicParamOperation(uint64_t **a1, char *a2)
{
  MIL::Transform::MatchContext::AddVariadicParamOperation(a1, a2);
}

{
  v2 = 0u;
  v3 = 0u;
  v4 = 1065353216;
  MIL::Transform::MatchContext::MatchContextImpl::AddVariadicParamOperation(*a1, a2);
}

{
  MIL::Transform::MatchContext::MatchContextImpl::AddVariadicParamOperation(*a1, a2);
}

{
  MIL::Transform::MatchContext::MatchContextImpl::AddVariadicParamOperation(*a1, a2);
}

void MIL::Transform::MatchContext::AddOperationWithSpecifiedOpsetName(uint64_t **a1, char *a2, uint64_t *a3)
{
  v3 = *a1;
  v4 = a3[1];
  if (v4)
  {
    v5 = *a3;
  }

  else
  {
    v5 = 0;
  }

  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(v3, a2, 1, v5, v4);
}

void MIL::Transform::MatchContext::MatchContextImpl::AddOperation(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  v19 = *MEMORY[0x277D85DE8];
  memset(v16, 0, sizeof(v16));
  std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::reserve(v16, a5);
  if (a5)
  {
    v9 = 40 * a5;
    v10 = (a4 + 8);
    do
    {
      MIL::Transform::ArgumentDescription::ArgumentDescription(v18, v10);
      v11 = 0;
      v12 = 0;
      v13 = 0;
      std::vector<MIL::Transform::ArgumentDescription>::__init_with_size[abi:ne200100]<MIL::Transform::ArgumentDescription const*,MIL::Transform::ArgumentDescription const*>(&v11, v18, &v19, 1uLL);
      v14 = *(v10 - 1);
      memset(v15, 0, sizeof(v15));
      std::vector<MIL::Transform::ArgumentDescription>::__init_with_size[abi:ne200100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(v15, v11, v12, (v12 - v11) >> 5);
      std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::push_back[abi:ne200100](v16, &v14);
      v17 = v15;
      std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne200100](&v17);
      v17 = &v11;
      std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne200100](&v17);
      MIL::Transform::ArgumentDescription::~ArgumentDescription(v18);
      v10 = (v10 + 40);
      v9 -= 40;
    }

    while (v9);
  }

  MIL::Transform::MatchContext::MatchContextImpl::AddVariadicParamOperation(a1, a2);
}

void sub_2180BBBA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  a12 = &a16;
  std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::__destroy_vector::operator()[abi:ne200100](&a12);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MatchContextImpl::AddVariadicParamOperation(uint64_t *a1, char *__s)
{
  v11 = *MEMORY[0x277D85DE8];
  v3 = *a1;
  v4 = strlen(__s);
  MIL::Matching::GetOperatorByQualifiedName(v3, __s, v4, &v9);
  v6 = 0u;
  v7 = 0u;
  v8 = 1065353216;
  v5[0] = v9;
  v5[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit((v10 + 8), 1uLL, memory_order_relaxed);
  }

  MIL::Builder::OperationBuilder::Make(v5);
}

void sub_2180BC328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, void *a49, uint64_t a50, int a51, __int16 a52, char a53, char a54, uint64_t a55, void *__p, uint64_t a57, int a58, __int16 a59, char a60, char a61)
{
  if (a61 < 0)
  {
    operator delete(__p);
  }

  if (*(v63 - 105) < 0)
  {
    operator delete(*(v63 - 128));
  }

  if (a21 < 0)
  {
    operator delete(a16);
  }

  if (a54 < 0)
  {
    operator delete(a49);
  }

  if (a42 < 0)
  {
    operator delete(a37);
    if ((v62 & 1) == 0)
    {
LABEL_14:
      v65 = *(v63 - 200);
      if (v65)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v65);
      }

      std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table(v63 - 192);
      v66 = *(v63 - 144);
      if (v66)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v66);
      }

      _Unwind_Resume(a1);
    }
  }

  else if (!v62)
  {
    goto LABEL_14;
  }

  __cxa_free_exception(v61);
  goto LABEL_14;
}

void MIL::Transform::MatchContext::AddOperation(uint64_t **a1, void *a2, std::string::size_type *a3)
{
  v3 = a3[1];
  if (v3)
  {
    v4 = *a3;
  }

  else
  {
    v4 = 0;
  }

  MIL::Transform::MatchContext::AddOperation(a1, a2, v4, v3);
}

void MIL::Transform::MatchContext::AddOperation(uint64_t **a1, void *a2, std::string::size_type a3, uint64_t a4)
{
  MIL::Matching::MatchView::MatchView(&v9, a2);
  Operation = MIL::MatchingPrivate::MatchPrivate::GetOperation(&v9);
  MIL::Matching::MatchView::~MatchView(&v9);
  if (MIL::Builder::OperationBuilder::GetNumOutputs(Operation) == 1)
  {
    MIL::Transform::MatchContext::MatchContextImpl::AddOperationFromPrototype(*a1, Operation, a3, a4);
  }

  exception = __cxa_allocate_exception(0x10uLL);
  std::invalid_argument::invalid_argument[abi:ne200100](exception, "Source operation does not have exactly one output. Please use AddMultiOutputOperation() instead.");
  __cxa_throw(exception, off_278235F80, MEMORY[0x277D82610]);
}

void MIL::Transform::MatchContext::MatchContextImpl::AddOperationFromPrototype(uint64_t *a1, MIL::Builder::OperationBuilder *this, std::string::size_type a3, uint64_t a4)
{
  MIL::Builder::OperationBuilder::TryGetOperatorSharedPtr(this, &v12);
  Parameters = MIL::Builder::OperationBuilder::GetParameters(this);
  MIL::Transform::MatchContext::MatchContextImpl::ConvertParamMap(Parameters, &v13);
  MIL::Builder::OperationBuilder::GetBlocks(this, v14);
  Attributes = MIL::Builder::OperationBuilder::GetAttributes(this);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map(&v15, Attributes);
  if (a4)
  {
    v11 = a4 << 7;
    do
    {
      MIL::TransformPrivate::OperationChangePrivate::ApplyChange(&v12, a3, *a1, (a1 + 7));
      a3 += 128;
      v11 -= 128;
    }

    while (v11);
  }

  MIL::Transform::MatchContext::MatchContextImpl::CreateOperationBuilderFromProperties(&v12, v10);
}

void sub_2180BC864(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, void);
  v10 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  v12 = va_arg(va1, void);
  v13 = va_arg(va1, void);
  v14 = va_arg(va1, void);
  v15 = va_arg(va1, void);
  v16 = va_arg(va1, std::__shared_weak_count *);
  v17 = va_arg(va1, void);
  if (a3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a3);
  }

  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table(va);
  if (v16)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v16);
  }

  MIL::TransformPrivate::OperationProperties::~OperationProperties(va1);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::AddMultiOutputOperation(uint64_t **a1, char *a2, uint64_t a3, uint64_t *a4)
{
  v4 = a4[1];
  if (v4)
  {
    v5 = *a4;
  }

  else
  {
    v5 = 0;
  }

  MIL::Transform::MatchContext::AddMultiOutputOperation(a1, a2, a3, v5, v4);
}

{
  v4 = a4[1];
  if (v4)
  {
    v5 = *a4;
  }

  else
  {
    v5 = 0;
  }

  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, a3, v5, v4);
}

void MIL::Transform::MatchContext::AddMultiOutputOperation(uint64_t **a1, char *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  v5 = 0u;
  v6 = 0u;
  v7 = 1065353216;
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, a3, a4, a5);
}

{
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, a3, a4, a5);
}

void MIL::Transform::MatchContext::AddMultiOutputOperation(uint64_t **a1, void *a2, std::string::size_type *a3)
{
  v3 = a3[1];
  if (v3)
  {
    v4 = *a3;
  }

  else
  {
    v4 = 0;
  }

  MIL::Transform::MatchContext::AddMultiOutputOperation(a1, a2, v4, v3);
}

void MIL::Transform::MatchContext::AddMultiOutputOperation(uint64_t **a1, void *a2, std::string::size_type a3, uint64_t a4)
{
  MIL::Matching::MatchView::MatchView(&v8, a2);
  Operation = MIL::MatchingPrivate::MatchPrivate::GetOperation(&v8);
  MIL::Matching::MatchView::~MatchView(&v8);
  MIL::Transform::MatchContext::MatchContextImpl::AddOperationFromPrototype(*a1, Operation, a3, a4);
}

void sub_2180BCADC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MIL::Matching::MatchView::~MatchView(va);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MapOutput(MIL::Transform::MatchContext *this, const MIL::Transform::NewOperationOutput *a2, const MIL::Matching::OutputView *a3)
{
  OperationAndOutputIndex = MIL::MatchingPrivate::MatchPrivate::GetOperationAndOutputIndex(a3, a2);
  v7 = v6;
  v8 = MIL::MatchingPrivate::MatchPrivate::GetOperationAndOutputIndex(a2, v6);
  v9 = *this;
  *&v11 = OperationAndOutputIndex;
  *(&v11 + 1) = v7;
  v12 = v8;
  v13 = v10;
}

void std::vector<anonymous namespace::OutputMapping>::push_back[abi:ne200100](uint64_t a1, _OWORD *a2)
{
  v3 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v3 >= v4)
  {
    v7 = *a1;
    v8 = v3 - *a1;
    v9 = v8 >> 5;
    v10 = (v8 >> 5) + 1;
    if (v10 >> 59)
    {
      std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
    }

    v11 = v4 - v7;
    if (v11 >> 4 > v10)
    {
      v10 = v11 >> 4;
    }

    if (v11 >= 0x7FFFFFFFFFFFFFE0)
    {
      v12 = 0x7FFFFFFFFFFFFFFLL;
    }

    else
    {
      v12 = v10;
    }

    if (v12)
    {
      if (!(v12 >> 59))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    v13 = (32 * v9);
    v14 = a2[1];
    *v13 = *a2;
    v13[1] = v14;
    v6 = 32 * v9 + 32;
    v15 = &v13[-2 * (v8 >> 5)];
    memcpy(v15, v7, v8);
    *a1 = v15;
    *(a1 + 8) = v6;
    *(a1 + 16) = 0;
    if (v7)
    {
      operator delete(v7);
    }
  }

  else
  {
    v5 = a2[1];
    *v3 = *a2;
    v3[1] = v5;
    v6 = (v3 + 2);
  }

  *(a1 + 8) = v6;
}

void MIL::Transform::ProgramTransformer::~ProgramTransformer(MIL::Transform::ProgramTransformer *this)
{
  v1 = *this;
  *this = 0;
  if (v1)
  {
    if (*(v1 + 56) == 1)
    {
      MIL::Matching::Matcher::~Matcher((v1 + 48));
    }

    v2 = *(v1 + 40);
    if (v2)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v2);
    }

    v3 = *(v1 + 24);
    if (v3)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v3);
    }

    v4 = *(v1 + 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v4);
    }

    MEMORY[0x21CEAFEA0](v1, 0x1022C40DEB6DFD1);
  }
}

void sub_2180BCD94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a12);
  }

  MEMORY[0x21CEAFEA0](v12, 0x1022C40DEB6DFD1);
  if (a10)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a10);
  }

  _Unwind_Resume(a1);
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplace(void *a1, uint64_t a2, uint64_t a3)
{
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper::MatchAndReplaceHelper(v7, a1, a1 + 2);
  do
  {
    v9 = 0;
    v6 = a1[4];
    v8[0] = a1;
    v8[1] = v7;
    v8[2] = a2;
    v8[3] = a3;
    v8[4] = &v9;
    MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper &,MIL::Matching::CompiledPattern const&,std::function<void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)> const&)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(v6, v8);
  }

  while ((v9 & 1) != 0);
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper::~MatchAndReplaceHelper(v7);
}

void MIL::Transform::ProgramTransformer::MatchAndReplace(MIL::MILContext ***a1, const MIL::Matching::Pattern *a2, uint64_t a3)
{
  MIL::Matching::CompiledPattern::CompiledPattern(v5, a2, **a1);
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplace(*a1, v5, a3);
  MIL::Matching::CompiledPattern::~CompiledPattern(v5);
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::EliminateDeadNodes(MIL::Builder::ProgramBuilder **this)
{
  result = MIL::Builder::ProgramBuilder::GetFunctions(this[4]);
  for (i = *(result + 16); i; i = *i)
  {
    memset(v15, 0, sizeof(v15));
    v16 = 1065353216;
    MIL::Builder::FunctionBuilder::GetInputs(i[5], &v12);
    for (j = v13; j; j = *j)
    {
      Name = MIL::Builder::Variable::GetName(j[2]);
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(v15, Name);
    }

    std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(&v12);
    v12 = 0u;
    v13 = 0u;
    v14 = 1065353216;
    v6 = (MIL::Builder::FunctionBuilder::GetSpecializations(i[5]) + 16);
    while (1)
    {
      v6 = *v6;
      if (!v6)
      {
        break;
      }

      v7 = v6[6];
      v9 = v6[5];
      v10 = v7;
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetBlockOutsAndWriteEffectOpIns(&v9, v11);
      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::RemoveRedundantOps(this, v6 + 5, v15, v11, &v12);
      v17 = v11;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v17);
      if (v10)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v10);
      }

      if (*(&v13 + 1))
      {
        exception = __cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "found unresolved names! please check your inputs & outputs");
        __cxa_throw(exception, MEMORY[0x277D82760], MEMORY[0x277D82600]);
      }
    }

    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(&v12);
    result = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v15);
  }

  return result;
}

void sub_2180BD068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, void);
  v10 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  v12 = va_arg(va1, void);
  v13 = va_arg(va1, void);
  v14 = va_arg(va1, void);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(va);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(va1);
  _Unwind_Resume(a1);
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ExtractSubProgram(uint64_t a1, const void ***a2, uint64_t *a3, const void **a4)
{
  MIL::Builder::ProgramBuilder::GetFunction(*(a1 + 32), a4, &v53);
  v7 = v53;
  v8 = MIL::Builder::FunctionBuilder::SelectedSpecialization(v53);
  MIL::Builder::FunctionBuilder::GetBlock(v7, v8, &v51);
  MIL::Builder::BlockBuilder::GetOperations(v51, v47);
  v10 = *(&v47[0] + 1);
  for (i = *&v47[0]; i != v10; i += 16)
  {
    v11 = *i;
    v12 = *(i + 8);
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      v50 = v12;
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    else
    {
      v50 = 0;
    }

    v49 = v11;
    v13 = MIL::Transform::HasWriteEffectAndNoOutputs(&v49);
    if (v50)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v50);
    }

    if (v13)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "This ExtractSubProgram function with inputs/outputs arguments is not supported currently for programs with ops that have write-state-effect and no outputs. The other ExtractSubProgram overload with op indices is supported.");
      exception->__vftable = (MEMORY[0x277D828F8] + 16);
      __cxa_throw(exception, off_278235F80, MEMORY[0x277D82610]);
    }

    if (v12)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v12);
    }
  }

  v44 = v47;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne200100](&v44);
  memset(v47, 0, sizeof(v47));
  v48 = 1065353216;
  MIL::Builder::FunctionBuilder::GetInputs(v53, &v44);
  for (j = v46; j; j = *j)
  {
    v15 = j[2];
    Type = MIL::Builder::Variable::TryGetType(v15);
    Name = MIL::Builder::Variable::GetName(v15);
    if (!Type)
    {
      v34 = __cxa_allocate_exception(0x10uLL);
      std::operator+<char>();
      std::runtime_error::runtime_error(v34, v42);
      __cxa_throw(v34, MEMORY[0x277D82760], MEMORY[0x277D82600]);
    }

    *v42 = Name;
    std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v47, Name)[5] = Type;
  }

  v38 = a1;
  v39 = a2;
  std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(&v44);
  MIL::Builder::BlockBuilder::GetOperations(v51, &v44);
  v18 = v44;
  for (k = v45; v18 != k; v18 += 2)
  {
    v20 = *v18;
    v21 = v18[1];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    MIL::Builder::OperationBuilder::GetOutputs(v20, v42);
    v22 = *&v42[8];
    v23 = *v42;
    if (*v42 != *&v42[8])
    {
      do
      {
        v24 = *v23;
        if (!*v23)
        {
          v32 = __cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v32, "invalid operation output variable.");
          __cxa_throw(v32, MEMORY[0x277D82760], MEMORY[0x277D82600]);
        }

        v25 = MIL::Builder::Variable::GetName(*v23);
        v26 = MIL::Builder::Variable::TryGetType(v24);
        v55 = v25;
        std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v47, v25)[5] = v26;
        ++v23;
      }

      while (v23 != v22);
      v23 = *v42;
    }

    if (v23)
    {
      *&v42[8] = v23;
      operator delete(v23);
    }

    if (v21)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v21);
    }
  }

  *v42 = &v44;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne200100](v42);
  if (*a3 == a3[1])
  {
    v36 = __cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v36, "output names cannot be empty");
    v36->__vftable = (MEMORY[0x277D828F8] + 16);
    __cxa_throw(v36, off_278235F80, MEMORY[0x277D82610]);
  }

  std::unordered_set<std::string>::unordered_set<std::__wrap_iter<std::string const*>>(&v44, *v39, v39[1]);
  memset(v42, 0, sizeof(v42));
  v43 = 1065353216;
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::RemoveRedundantOps(v38, &v51, &v44, a3, v42);
  if (*&v42[24])
  {
    v37 = __cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v37, "found unresolved names! please check your inputs & outputs");
    __cxa_throw(v37, MEMORY[0x277D82760], MEMORY[0x277D82600]);
  }

  MIL::Builder::BlockBuilder::UpdateOutputNames(v51, a3);
  MIL::Builder::FunctionBuilder::ClearInputs(v53);
  v27 = *v39;
  v28 = v39[1];
  if (*v39 != v28)
  {
    do
    {
      if (!std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v47, v27))
      {
        v35 = __cxa_allocate_exception(0x10uLL);
        std::operator+<char>();
        std::runtime_error::runtime_error(v35, &v41);
        __cxa_throw(v35, MEMORY[0x277D82760], MEMORY[0x277D82600]);
      }

      v29 = v53;
      if (*(v27 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v40, *v27, v27[1]);
      }

      else
      {
        v30 = *v27;
        v40.__r_.__value_.__r.__words[2] = v27[2];
        *&v40.__r_.__value_.__l.__data_ = v30;
      }

      v41.__r_.__value_.__r.__words[0] = v27;
      v31 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v47, v27);
      MIL::Builder::FunctionBuilder::AddInput(v29, &v40, v31[5]);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v40.__r_.__value_.__l.__data_);
      }

      v27 += 3;
    }

    while (v27 != v28);
  }

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v42);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(&v44);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v47);
  if (v52)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v52);
  }

  if (v54)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v54);
  }
}

void sub_2180BD634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36)
{
  __cxa_free_exception(v36);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(&a23);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(&a31);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(&a36);
  v39 = *(v37 - 128);
  if (v39)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v39);
  }

  v40 = *(v37 - 112);
  if (v40)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v40);
  }

  _Unwind_Resume(a1);
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ExtractSubProgram(uint64_t *a1, unint64_t a2, unint64_t a3, const void **a4)
{
  MIL::Builder::ProgramBuilder::GetFunction(a1[4], a4, &v63);
  v8 = v63;
  v9 = MIL::Builder::FunctionBuilder::SelectedSpecialization(v63);
  MIL::Builder::FunctionBuilder::GetBlock(v8, v9, &v61);
  if (MIL::Builder::BlockBuilder::GetNumOperations(v61) < a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::to_string(&v57, a3);
    v31 = std::string::insert(&v57, 0, "Attempted to extract upto opIdxEnd ");
    v32 = *&v31->__r_.__value_.__l.__data_;
    v58.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
    *&v58.__r_.__value_.__l.__data_ = v32;
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    v33 = std::string::append(&v58, " , but block contains only a total of ");
    v34 = *&v33->__r_.__value_.__l.__data_;
    v59.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
    *&v59.__r_.__value_.__l.__data_ = v34;
    v33->__r_.__value_.__l.__size_ = 0;
    v33->__r_.__value_.__r.__words[2] = 0;
    v33->__r_.__value_.__r.__words[0] = 0;
    NumOperations = MIL::Builder::BlockBuilder::GetNumOperations(v61);
    std::to_string(&v56, NumOperations);
    if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v36 = &v56;
    }

    else
    {
      v36 = v56.__r_.__value_.__r.__words[0];
    }

    if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(v56.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = v56.__r_.__value_.__l.__size_;
    }

    v38 = std::string::append(&v59, v36, size);
    v39 = *&v38->__r_.__value_.__l.__data_;
    v60.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
    *&v60.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    v40 = std::string::append(&v60, " operations.");
    v41 = *&v40->__r_.__value_.__l.__data_;
    v54.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
    *&v54.__r_.__value_.__l.__data_ = v41;
    v40->__r_.__value_.__l.__size_ = 0;
    v40->__r_.__value_.__r.__words[2] = 0;
    v40->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(exception, &v54);
    exception->__vftable = (MEMORY[0x277D828F8] + 16);
    __cxa_throw(exception, off_278235F80, MEMORY[0x277D82610]);
  }

  if (a2 >= a3)
  {
    v42 = __cxa_allocate_exception(0x10uLL);
    v43 = a2;
    v44 = v42;
    std::to_string(&v58, v43);
    v45 = std::string::insert(&v58, 0, "opIdxBegin ");
    v46 = *&v45->__r_.__value_.__l.__data_;
    v59.__r_.__value_.__r.__words[2] = v45->__r_.__value_.__r.__words[2];
    *&v59.__r_.__value_.__l.__data_ = v46;
    v45->__r_.__value_.__l.__size_ = 0;
    v45->__r_.__value_.__r.__words[2] = 0;
    v45->__r_.__value_.__r.__words[0] = 0;
    v47 = std::string::append(&v59, " needs to be strictly less than opIdxEnd ");
    v48 = *&v47->__r_.__value_.__l.__data_;
    v60.__r_.__value_.__r.__words[2] = v47->__r_.__value_.__r.__words[2];
    *&v60.__r_.__value_.__l.__data_ = v48;
    v47->__r_.__value_.__l.__size_ = 0;
    v47->__r_.__value_.__r.__words[2] = 0;
    v47->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v57, a3);
    if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v49 = &v57;
    }

    else
    {
      v49 = v57.__r_.__value_.__r.__words[0];
    }

    if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v50 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v50 = v57.__r_.__value_.__l.__size_;
    }

    v51 = std::string::append(&v60, v49, v50);
    v52 = *&v51->__r_.__value_.__l.__data_;
    v54.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
    *&v54.__r_.__value_.__l.__data_ = v52;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(v44, &v54);
    v44->__vftable = (MEMORY[0x277D828F8] + 16);
    __cxa_throw(v44, off_278235F80, MEMORY[0x277D82610]);
  }

  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetInputsAndOutputs(a1, a4, a2, a3, &v54);
  MIL::Builder::FunctionBuilder::ClearInputs(v63);
  v11 = v54.__r_.__value_.__l.__size_;
  for (i = v54.__r_.__value_.__r.__words[0]; i != v11; i += 24)
  {
    Type = MIL::Builder::BlockBuilder::GetType(v61, i);
    if (Type)
    {
      v13 = v63;
      if (*(i + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, *i, *(i + 8));
      }

      else
      {
        v14 = *i;
        __p.__r_.__value_.__r.__words[2] = *(i + 16);
        *&__p.__r_.__value_.__l.__data_ = v14;
      }

      MIL::Builder::FunctionBuilder::AddInput(v13, &__p, Type);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }

  v15 = MIL::Builder::BlockBuilder::GetNumOperations(v61);
  std::vector<unsigned long>::vector[abi:ne200100](&v60, a2 - a3 + v15);
  v16 = v60.__r_.__value_.__r.__words[0];
  v17 = v60.__r_.__value_.__r.__words[0] + 8 * a2;
  if (a2 << 32)
  {
    v18 = 0;
    v19 = vdupq_n_s64((8 * a2 - 8) >> 3);
    v20 = xmmword_218583C30;
    v21 = vdupq_n_s64(2uLL);
    do
    {
      v22 = vmovn_s64(vcgeq_u64(v19, v20));
      if (v22.i8[0])
      {
        *(v16 + 8 * v18) = v18;
      }

      if (v22.i8[4])
      {
        *(v16 + 8 * v18 + 8) = v18 + 1;
      }

      v18 += 2;
      v20 = vaddq_s64(v20, v21);
    }

    while (((((8 * a2 - 8) >> 3) + 2) & 0x3FFFFFFFFFFFFFFELL) != v18);
  }

  v23 = v60.__r_.__value_.__l.__size_;
  if (v17 != v60.__r_.__value_.__l.__size_)
  {
    v24 = 0;
    v25 = (v60.__r_.__value_.__l.__size_ - v17 - 8) >> 3;
    v26 = vdupq_n_s64(v25);
    v27 = (v17 + 8);
    do
    {
      v28 = vmovn_s64(vcgeq_u64(v26, vorrq_s8(vdupq_n_s64(v24), xmmword_218583C30)));
      if (v28.i8[0])
      {
        *(v27 - 1) = a3 + v24;
      }

      if (v28.i8[4])
      {
        *v27 = a3 + v24 + 1;
      }

      v24 += 2;
      v27 += 2;
    }

    while (((v25 + 2) & 0x3FFFFFFFFFFFFFFELL) != v24);
  }

  if (v23 == v16)
  {
    v29 = 0;
  }

  else
  {
    v29 = v16;
  }

  MIL::Builder::BlockBuilder::RemoveOperations(v61, v29, (v23 - v16) >> 3, 1);
  MIL::Builder::BlockBuilder::UpdateOutputNames(v61, v55);
  MIL::Builder::BlockBuilder::UpdateStateDependencyMap(v61);
  if (v60.__r_.__value_.__r.__words[0])
  {
    v60.__r_.__value_.__l.__size_ = v60.__r_.__value_.__r.__words[0];
    operator delete(v60.__r_.__value_.__l.__data_);
  }

  v60.__r_.__value_.__r.__words[0] = v55;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v60);
  v60.__r_.__value_.__r.__words[0] = &v54;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v60);
  if (v62)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v62);
  }

  if (v64)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v64);
  }
}

void sub_2180BDCE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, void *a31, uint64_t a32, int a33, __int16 a34, char a35, char a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, uint64_t a43, void *a44, uint64_t a45, int a46, __int16 a47, char a48, char a49)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  if (*(v51 - 121) < 0)
  {
    operator delete(*(v51 - 144));
  }

  if (a30 < 0)
  {
    operator delete(a25);
  }

  if (a49 < 0)
  {
    operator delete(a44);
  }

  if (a42 < 0)
  {
    operator delete(a37);
  }

  if (a36 < 0)
  {
    operator delete(a31);
    if ((v50 & 1) == 0)
    {
LABEL_16:
      v53 = *(v51 - 104);
      if (v53)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v53);
      }

      v54 = *(v51 - 88);
      if (v54)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v54);
      }

      _Unwind_Resume(a1);
    }
  }

  else if (!v50)
  {
    goto LABEL_16;
  }

  __cxa_free_exception(v49);
  goto LABEL_16;
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ExtractSubProgram(uint64_t *a1, void *a2, const void **a3)
{
  MIL::Builder::ProgramBuilder::GetFunction(a1[4], a3, &v62);
  v6 = v62;
  v7 = MIL::Builder::FunctionBuilder::SelectedSpecialization(v62);
  MIL::Builder::FunctionBuilder::GetBlock(v6, v7, &v60);
  if (!a2[2])
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "opIndices cannot be empty.");
    exception->__vftable = (MEMORY[0x277D828F8] + 16);
    __cxa_throw(exception, off_278235F80, MEMORY[0x277D82610]);
  }

  v9 = a2 + 1;
  v8 = a2[1];
  if (v8)
  {
    do
    {
      v10 = v8;
      v8 = v8[1];
    }

    while (v8);
  }

  else
  {
    v11 = a2 + 1;
    do
    {
      v10 = v11[2];
      v12 = *v10 == v11;
      v11 = v10;
    }

    while (v12);
  }

  v13 = v10[4];
  if (v13 >= MIL::Builder::BlockBuilder::GetNumOperations(v60))
  {
    v38 = __cxa_allocate_exception(0x10uLL);
    v39 = *v9;
    if (*v9)
    {
      do
      {
        v40 = v39;
        v39 = v39[1];
      }

      while (v39);
    }

    else
    {
      do
      {
        v40 = v9[2];
        v12 = *v40 == v9;
        v9 = v40;
      }

      while (v12);
    }

    std::to_string(&v56, v40[4]);
    v41 = std::string::insert(&v56, 0, "Attempted to extract upto opIdx ");
    v42 = *&v41->__r_.__value_.__l.__data_;
    v57.__r_.__value_.__r.__words[2] = v41->__r_.__value_.__r.__words[2];
    *&v57.__r_.__value_.__l.__data_ = v42;
    v41->__r_.__value_.__l.__size_ = 0;
    v41->__r_.__value_.__r.__words[2] = 0;
    v41->__r_.__value_.__r.__words[0] = 0;
    v43 = std::string::append(&v57, " , but block contains only a total of ");
    v44 = *&v43->__r_.__value_.__l.__data_;
    v58.__r_.__value_.__r.__words[2] = v43->__r_.__value_.__r.__words[2];
    *&v58.__r_.__value_.__l.__data_ = v44;
    v43->__r_.__value_.__l.__size_ = 0;
    v43->__r_.__value_.__r.__words[2] = 0;
    v43->__r_.__value_.__r.__words[0] = 0;
    NumOperations = MIL::Builder::BlockBuilder::GetNumOperations(v60);
    std::to_string(&v55, NumOperations);
    if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v46 = &v55;
    }

    else
    {
      v46 = v55.__r_.__value_.__r.__words[0];
    }

    if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(v55.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = v55.__r_.__value_.__l.__size_;
    }

    v48 = std::string::append(&v58, v46, size);
    v49 = *&v48->__r_.__value_.__l.__data_;
    v59.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
    *&v59.__r_.__value_.__l.__data_ = v49;
    v48->__r_.__value_.__l.__size_ = 0;
    v48->__r_.__value_.__r.__words[2] = 0;
    v48->__r_.__value_.__r.__words[0] = 0;
    v50 = std::string::append(&v59, " operations.");
    v51 = *&v50->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__r.__words[2] = v50->__r_.__value_.__r.__words[2];
    *&v53.__r_.__value_.__l.__data_ = v51;
    v50->__r_.__value_.__l.__size_ = 0;
    v50->__r_.__value_.__r.__words[2] = 0;
    v50->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(v38, &v53);
    v38->__vftable = (MEMORY[0x277D828F8] + 16);
    __cxa_throw(v38, off_278235F80, MEMORY[0x277D82610]);
  }

  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetInputsAndOutputs(a1, a3, a2, &v53);
  MIL::Builder::FunctionBuilder::ClearInputs(v62);
  v15 = v53.__r_.__value_.__l.__size_;
  for (i = v53.__r_.__value_.__r.__words[0]; i != v15; i += 24)
  {
    Type = MIL::Builder::BlockBuilder::GetType(v60, i);
    if (Type)
    {
      v17 = v62;
      if (*(i + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, *i, *(i + 8));
      }

      else
      {
        v18 = *i;
        __p.__r_.__value_.__r.__words[2] = *(i + 16);
        *&__p.__r_.__value_.__l.__data_ = v18;
      }

      MIL::Builder::FunctionBuilder::AddInput(v17, &__p, Type);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }

  v19 = a2[2];
  memset(&v59, 0, sizeof(v59));
  v20 = MIL::Builder::BlockBuilder::GetNumOperations(v60);
  std::vector<unsigned long long>::reserve(&v59, v20 - v19);
  for (j = 0; j < MIL::Builder::BlockBuilder::GetNumOperations(v60); ++j)
  {
    v22 = *v9;
    if (!*v9)
    {
      goto LABEL_27;
    }

    v23 = v9;
    do
    {
      v24 = v22[4];
      v25 = v24 >= j;
      v26 = v24 < j;
      if (v25)
      {
        v23 = v22;
      }

      v22 = v22[v26];
    }

    while (v22);
    if (v23 == v9 || j < v23[4])
    {
LABEL_27:
      v27 = v59.__r_.__value_.__l.__size_;
      if (v59.__r_.__value_.__l.__size_ >= v59.__r_.__value_.__r.__words[2])
      {
        v29 = v59.__r_.__value_.__r.__words[0];
        v30 = v59.__r_.__value_.__l.__size_ - v59.__r_.__value_.__r.__words[0];
        v31 = (v59.__r_.__value_.__l.__size_ - v59.__r_.__value_.__r.__words[0]) >> 3;
        v32 = v31 + 1;
        if ((v31 + 1) >> 61)
        {
          std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
        }

        v33 = v59.__r_.__value_.__r.__words[2] - v59.__r_.__value_.__r.__words[0];
        if ((v59.__r_.__value_.__r.__words[2] - v59.__r_.__value_.__r.__words[0]) >> 2 > v32)
        {
          v32 = v33 >> 2;
        }

        if (v33 >= 0x7FFFFFFFFFFFFFF8)
        {
          v34 = 0x1FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v34 = v32;
        }

        if (v34)
        {
          std::__allocate_at_least[abi:ne200100]<std::allocator<unsigned long long>>(&v59, v34);
        }

        *(8 * v31) = j;
        v28 = 8 * v31 + 8;
        memcpy(0, v29, v30);
        v35 = v59.__r_.__value_.__r.__words[0];
        v59.__r_.__value_.__r.__words[0] = 0;
        *&v59.__r_.__value_.__r.__words[1] = v28;
        if (v35)
        {
          operator delete(v35);
        }
      }

      else
      {
        *v59.__r_.__value_.__l.__size_ = j;
        v28 = v27 + 8;
      }

      v59.__r_.__value_.__l.__size_ = v28;
    }
  }

  if (v59.__r_.__value_.__l.__size_ == v59.__r_.__value_.__r.__words[0])
  {
    v36 = 0;
  }

  else
  {
    v36 = v59.__r_.__value_.__r.__words[0];
  }

  MIL::Builder::BlockBuilder::RemoveOperations(v60, v36, (v59.__r_.__value_.__l.__size_ - v59.__r_.__value_.__r.__words[0]) >> 3, 1);
  MIL::Builder::BlockBuilder::UpdateOutputNames(v60, v54);
  MIL::Builder::BlockBuilder::UpdateStateDependencyMap(v60);
  if (v59.__r_.__value_.__r.__words[0])
  {
    v59.__r_.__value_.__l.__size_ = v59.__r_.__value_.__r.__words[0];
    operator delete(v59.__r_.__value_.__l.__data_);
  }

  v59.__r_.__value_.__r.__words[0] = v54;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v59);
  v59.__r_.__value_.__r.__words[0] = &v53;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne200100](&v59);
  if (v61)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v61);
  }

  if (v63)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v63);
  }
}

void sub_2180BE36C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, void *a31, uint64_t a32, int a33, __int16 a34, char a35, char a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, uint64_t a43, void *a44, uint64_t a45, int a46, __int16 a47, char a48, char a49)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  if (*(v51 - 121) < 0)
  {
    operator delete(*(v51 - 144));
  }

  if (a30 < 0)
  {
    operator delete(a25);
  }

  if (a49 < 0)
  {
    operator delete(a44);
  }

  if (a42 < 0)
  {
    operator delete(a37);
  }

  if (a36 < 0)
  {
    operator delete(a31);
    if ((v50 & 1) == 0)
    {
LABEL_16:
      v53 = *(v51 - 104);
      if (v53)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v53);
      }

      v54 = *(v51 - 88);
      if (v54)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v54);
      }

      _Unwind_Resume(a1);
    }
  }

  else if (!v50)
  {
    goto LABEL_16;
  }

  __cxa_free_exception(v49);
  goto LABEL_16;
}

uint64_t MIL::Transform::ProgramTransformer::FoldConstantNodes(MIL::Transform::ProgramTransformer *this)
{
  v1 = *this;
  v2 = *(*this + 32);
  v4 = v1;
  return MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::FoldConstantNodes(void)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(v2, &v4);
}

void sub_2180BE600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::pair<std::unique_ptr<MIL::IRProgram>,MIL::ValidationResult>::~pair(&a16);
      _Unwind_Resume(a1);
    }
  }

  else if (!v17)
  {
    goto LABEL_6;
  }

  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t MIL::Transform::ProgramTransformer::GetProgramBuilder@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  v2 = *(*this + 40);
  *a2 = *(*this + 32);
  a2[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return this;
}

void *std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::reserve(void *result, unint64_t a2)
{
  if (a2 > (result[2] - *result) >> 5)
  {
    if (!(a2 >> 59))
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>>(result, a2);
    }

    std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
  }

  return result;
}

void **std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::push_back[abi:ne200100](void **result, uint64_t a2)
{
  v3 = result;
  v4 = result[1];
  v5 = result[2];
  if (v4 >= v5)
  {
    v7 = (v4 - *result) >> 5;
    v8 = v7 + 1;
    if ((v7 + 1) >> 59)
    {
      std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
    }

    v9 = v5 - *result;
    if (v9 >> 4 > v8)
    {
      v8 = v9 >> 4;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFE0)
    {
      v10 = 0x7FFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    v16[4] = result;
    if (v10)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>>(result, v10);
    }

    v11 = (32 * v7);
    *v11 = *a2;
    v11[1] = 0;
    v11[2] = 0;
    v11[3] = 0;
    *(v11 + 1) = *(a2 + 8);
    v11[3] = *(a2 + 24);
    *(a2 + 8) = 0;
    *(a2 + 16) = 0;
    *(a2 + 24) = 0;
    v6 = 32 * v7 + 32;
    v12 = result[1] - *result;
    v13 = v11 - v12;
    memcpy(v11 - v12, *result, v12);
    v14 = *v3;
    *v3 = v13;
    v3[1] = v6;
    v15 = v3[2];
    v3[2] = 0;
    v16[2] = v14;
    v16[3] = v15;
    v16[0] = v14;
    v16[1] = v14;
    result = std::__split_buffer<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::~__split_buffer(v16);
  }

  else
  {
    *v4 = *a2;
    v4[1] = 0;
    v4[2] = 0;
    v4[3] = 0;
    *(v4 + 1) = *(a2 + 8);
    v4[3] = *(a2 + 24);
    *(a2 + 8) = 0;
    *(a2 + 16) = 0;
    *(a2 + 24) = 0;
    v6 = (v4 + 4);
  }

  v3[1] = v6;
  return result;
}

void std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>>(uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 59))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

void **std::__split_buffer<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::~__split_buffer(void **a1)
{
  std::__split_buffer<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::clear[abi:ne200100](a1);
  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::__split_buffer<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::clear[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 8);
  for (i = *(a1 + 16); i != v2; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 32;
    v4 = (i - 24);
    std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne200100](&v4);
  }
}

uint64_t std::vector<MIL::Transform::ArgumentDescription>::__init_with_size[abi:ne200100]<MIL::Transform::ArgumentDescription const*,MIL::Transform::ArgumentDescription const*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<MIL::Transform::ArgumentDescription>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_2180BE974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(v9 + 8) = v10;
  std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne200100](&a9);
  _Unwind_Resume(a1);
}

MIL::Transform::ArgumentDescription *std::__uninitialized_allocator_copy_impl[abi:ne200100]<std::allocator<MIL::Transform::ArgumentDescription>,MIL::Transform::ArgumentDescription const*,MIL::Transform::ArgumentDescription const*,MIL::Transform::ArgumentDescription*>(int a1, MIL::Transform::ArgumentDescription *a2, MIL::Transform::ArgumentDescription *a3, MIL::Transform::ArgumentDescription *this)
{
  if (a2 != a3)
  {
    v6 = a2;
    v7 = 0;
    do
    {
      MIL::Transform::ArgumentDescription::ArgumentDescription(this, v6);
      v6 = (v6 + 32);
      this = (this + 32);
      v7 -= 32;
    }

    while (v6 != a3);
  }

  return this;
}

void sub_2180BE9F4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    v4 = (v1 - 32);
    do
    {
      MIL::Transform::ArgumentDescription::~ArgumentDescription(v4);
      v4 = (v5 - 32);
      v2 += 32;
    }

    while (v2);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 32;
        v7 = (v4 - 24);
        std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne200100](&v7);
        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }
}

void MIL::Transform::MatchContext::MatchContextImpl::GetTypedArgument(MIL::IRArgument *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  (*(*a1 + 48))(&v17);
  if (v17)
  {
    v15 = v17;
    v16 = v18;
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    MIL::IRTypedArgument::Make();
  }

  if (!*a2)
  {
    Name = MIL::IRArgument::GetName(a1);
    MIL::Builder::BlockBuilder::GetValue(a3, Name, &v13);
    if (v13)
    {
      if (v14)
      {
        atomic_fetch_add_explicit((v14 + 8), 1uLL, memory_order_relaxed);
      }

      MIL::IRTypedArgument::Make();
    }

    v10 = MIL::IRArgument::GetName(a1);
    Type = MIL::Builder::BlockBuilder::GetType(a3, v10);
    MIL::IRTypedArgument::Make(Type, v12);
  }

  v8 = a2[1];
  *a4 = *a2;
  a4[1] = v8;
  *a2 = 0;
  a2[1] = 0;
  if (v18)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v18);
  }
}

void sub_2180BECD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16)
{
  if (a12)
  {
    MIL::Passes::PropagateValueTypes();
  }

  if (a14)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a14);
  }

  v18 = *(v16 - 40);
  if (v18)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v18);
  }

  _Unwind_Resume(exception_object);
}

void MIL::Transform::MatchContext::MatchContextImpl::InferOutputTypesAndAddOperation(uint64_t a1, uint64_t a2, uint64_t a3, MIL::Builder::OperationBuilder **a4)
{
  memset(v24, 0, 24);
  BlocksRef = MIL::Builder::OperationBuilder::GetBlocksRef(*a4);
  v5 = *BlocksRef;
  v6 = *(BlocksRef + 8);
  if (*BlocksRef != v6)
  {
    do
    {
      __p[0] = 0;
      __p[1] = 0;
      v21 = 0;
      MIL::Builder::BlockBuilder::GetOutputs(*v5, &v22);
      v8 = v22;
      v7 = v23;
      if (v22 != v23)
      {
        do
        {
          Type = MIL::Builder::Variable::TryGetType(*v8);
          v10 = __p[1];
          if (__p[1] >= v21)
          {
            v12 = (__p[1] - __p[0]) >> 3;
            if ((v12 + 1) >> 61)
            {
              std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
            }

            v13 = (v21 - __p[0]) >> 2;
            if (v13 <= v12 + 1)
            {
              v13 = v12 + 1;
            }

            if (v21 - __p[0] >= 0x7FFFFFFFFFFFFFF8)
            {
              v14 = 0x1FFFFFFFFFFFFFFFLL;
            }

            else
            {
              v14 = v13;
            }

            if (v14)
            {
              std::__allocate_at_least[abi:ne200100]<std::allocator<std::string const*>>(__p, v14);
            }

            v15 = (8 * v12);
            *v15 = Type;
            v11 = (8 * v12 + 8);
            v16 = v15 - (__p[1] - __p[0]);
            memcpy(v16, __p[0], __p[1] - __p[0]);
            v17 = __p[0];
            __p[0] = v16;
            __p[1] = v11;
            v21 = 0;
            if (v17)
            {
              operator delete(v17);
            }
          }

          else
          {
            *__p[1] = Type;
            v11 = v10 + 8;
          }

          __p[1] = v11;
          ++v8;
        }

        while (v8 != v7);
        v8 = v22;
      }

      if (v8)
      {
        v23 = v8;
        operator delete(v8);
      }

      std::vector<std::vector<float>>::push_back[abi:ne200100](v24, __p);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }

      v5 += 2;
    }

    while (v5 != v6);
  }

  Operator = MIL::Builder::OperationBuilder::GetOperator(*a4);
  MIL::UnknownLocation::Make(Operator);
}

void sub_2180BF2E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a27 < 0)
  {
    operator delete(__p);
    if ((v34 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream(&a28);
      v37 = *(v35 - 136);
      if (v37)
      {
        *(v35 - 128) = v37;
        operator delete(v37);
      }

      __p = (v35 - 112);
      std::vector<std::vector<unsigned long long>>::__destroy_vector::operator()[abi:ne200100](&__p);
      _Unwind_Resume(a1);
    }
  }

  else if (!v34)
  {
    goto LABEL_6;
  }

  __cxa_free_exception(v33);
  goto LABEL_6;
}

uint64_t std::unordered_set<MIL::IRValueType const*>::unordered_set(uint64_t a1, uint64_t a2)
{
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *(a1 + 32) = *(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, *(a2 + 8));
  for (i = *(a2 + 16); i; i = *i)
  {
    std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::__emplace_unique_key_args<MIL::IRValueType const*,MIL::IRValueType const* const&>(a1, i + 2);
  }

  return a1;
}

const void **std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(void *a1, const void **a2)
{
  v4 = std::__string_hash<char>::operator()[abi:ne200100](a1, a2);
  v5 = v4;
  v6 = a1[1];
  if (!*&v6)
  {
    goto LABEL_18;
  }

  v7 = vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v6)
    {
      v9 = v4 % *&v6;
    }
  }

  else
  {
    v9 = (*&v6 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= *&v6)
      {
        v12 %= *&v6;
      }
    }

    else
    {
      v12 &= *&v6 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_18;
    }

LABEL_17:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_18;
    }
  }

  if (!std::equal_to<std::string>::operator()[abi:ne200100](a1, v11 + 2, a2))
  {
    goto LABEL_17;
  }

  return v11;
}

void sub_2180BF730(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>>>>::~unique_ptr[abi:ne200100](va);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MatchContextImpl::ConvertParamMap(const void ***a1@<X0>, uint64_t a2@<X8>)
{
  *a2 = 0u;
  *(a2 + 16) = 0u;
  *(a2 + 32) = 1065353216;
  v3 = a1 + 1;
  v4 = *a1;
  if (*a1 != (a1 + 1))
  {
    do
    {
      v18 = 0;
      v19 = 0;
      v20 = 0;
      std::vector<MIL::TransformPrivate::ArgumentAndType>::reserve(&v18, (v4[8] - v4[7]) >> 4);
      v5 = v4[7];
      v6 = v4[8];
      while (v5 != v6)
      {
        v7 = *v5;
        v8 = v5[1];
        v13 = *v5;
        v14 = v8;
        if (v8)
        {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        BYTE8(v17) = 0;
        v15 = 0;
        v16 = 0;
        LOBYTE(v17) = 0;
        v9 = v19;
        if (v19 >= v20)
        {
          v19 = std::vector<MIL::TransformPrivate::ArgumentAndType>::__emplace_back_slow_path<MIL::TransformPrivate::ArgumentAndType>(&v18, &v13);
          if (v16)
          {
            std::__shared_weak_count::__release_shared[abi:ne200100](v16);
          }
        }

        else
        {
          *v19 = v7;
          v9[1] = v14;
          v9[2] = 0;
          v13 = 0;
          v14 = 0;
          v9[3] = 0;
          v15 = 0;
          v16 = 0;
          *(v9 + 2) = v17;
          v19 = v9 + 6;
        }

        if (v14)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v14);
        }

        v5 += 2;
      }

      std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::string const&,std::vector<MIL::TransformPrivate::ArgumentAndType>>(a2, v4 + 4);
      v13 = &v18;
      std::vector<MIL::TransformPrivate::ArgumentAndType>::__destroy_vector::operator()[abi:ne200100](&v13);
      v10 = v4[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = *v10;
        }

        while (v10);
      }

      else
      {
        do
        {
          v11 = v4[2];
          v12 = *v11 == v4;
          v4 = v11;
        }

        while (!v12);
      }

      v4 = v11;
    }

    while (v11 != v3);
  }
}

void sub_2180BF8BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  a10 = &a16;
  std::vector<MIL::TransformPrivate::ArgumentAndType>::__destroy_vector::operator()[abi:ne200100](&a10);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::~__hash_table(v16);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MatchContextImpl::CreateOperationBuilderFromProperties(MIL::Transform::MatchContext::MatchContextImpl *this, const MIL::TransformPrivate::OperationProperties *a2)
{
  v2 = *(this + 1);
  v3[0] = *this;
  v3[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  MIL::Builder::OperationBuilder::Make(v3);
}

void sub_2180BFAE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  v31 = *(v29 - 72);
  if (v31)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v31);
  }

  _Unwind_Resume(exception_object);
}

void *std::vector<MIL::TransformPrivate::ArgumentAndType>::reserve(void *result, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((result[2] - *result) >> 4) < a2)
  {
    if (a2 < 0x555555555555556)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<MIL::TransformPrivate::ArgumentAndType>>(result, a2);
    }

    std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
  }

  return result;
}

void sub_2180BFC2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

const void **std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::string const&,std::vector<MIL::TransformPrivate::ArgumentAndType>>(void *a1, const void **a2)
{
  v4 = std::__string_hash<char>::operator()[abi:ne200100](a1, a2);
  v5 = v4;
  v6 = a1[1];
  if (!*&v6)
  {
    goto LABEL_18;
  }

  v7 = vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v6)
    {
      v9 = v4 % *&v6;
    }
  }

  else
  {
    v9 = (*&v6 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_18:
    std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__construct_node_hash<std::string const&,std::vector<MIL::TransformPrivate::ArgumentAndType>>();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= *&v6)
      {
        v12 %= *&v6;
      }
    }

    else
    {
      v12 &= *&v6 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_18;
    }

LABEL_17:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_18;
    }
  }

  if (!std::equal_to<std::string>::operator()[abi:ne200100](a1, v11 + 2, a2))
  {
    goto LABEL_17;
  }

  return v11;
}

void sub_2180BFE90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>>>>::~unique_ptr[abi:ne200100](va);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__deallocate_node(a1, *(a1 + 16));
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    operator delete(v2);
  }

  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = *v2;
      std::__destroy_at[abi:ne200100]<std::pair<std::string const,std::vector<MIL::TransformPrivate::ArgumentAndType>>,0>((v2 + 2));
      operator delete(v2);
      v2 = v3;
    }

    while (v3);
  }
}

void MIL::TransformPrivate::OperationProperties::~OperationProperties(MIL::TransformPrivate::OperationProperties *this)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(this + 80);
  v3 = (this + 56);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne200100](&v3);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::~__hash_table(this + 16);
  v2 = *(this + 1);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper::MatchAndReplaceHelper(uint64_t a1, void *a2, void *a3)
{
  matched = MIL::Transform::MatchContext::MatchContextImpl::MatchContextImpl(a1, a2, a3);
  *(matched + 152) = matched;
  MIL::Matching::Match::Match((matched + 160));
  *(a1 + 544) = 0u;
  *(a1 + 560) = 0u;
  *(a1 + 528) = 0u;
  *(a1 + 600) = 0u;
  *(a1 + 616) = 0u;
  *(a1 + 632) = 0u;
  *(a1 + 656) = 0u;
  *(a1 + 672) = 0u;
  *(a1 + 688) = 0u;
  *(a1 + 704) = 0u;
  *(a1 + 720) = 0u;
  *(a1 + 736) = 0u;
  *(a1 + 184) = 0u;
  *(a1 + 200) = 0u;
  *(a1 + 216) = 0u;
  *(a1 + 232) = 0u;
  *(a1 + 248) = 0u;
  *(a1 + 280) = 0;
  *(a1 + 168) = 0u;
  *(a1 + 264) = 0u;
  *(a1 + 360) = 0;
  *(a1 + 328) = 0u;
  *(a1 + 344) = 0u;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *(a1 + 488) = 0u;
  *(a1 + 504) = 0u;
  *(a1 + 456) = 0u;
  *(a1 + 472) = 0u;
  *(a1 + 424) = 0u;
  *(a1 + 440) = 0u;
  *(a1 + 392) = 0u;
  *(a1 + 408) = 0u;
  *(a1 + 376) = 0u;
  return a1;
}

uint64_t MIL::Transform::MatchContext::MatchContextImpl::MatchContextImpl(uint64_t a1, void *a2, void *a3)
{
  *a1 = *a2;
  v4 = a2[1];
  *(a1 + 8) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 16) = *a3;
  v5 = a3[1];
  *(a1 + 24) = v5;
  if (v5)
  {
    atomic_fetch_add_explicit((v5 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 56) = 0u;
  *(a1 + 32) = 0;
  *(a1 + 40) = 0;
  *(a1 + 48) = 0;
  *(a1 + 72) = 0u;
  *(a1 + 88) = 0u;
  *(a1 + 104) = 0u;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  v7 = 0;
  std::vector<unsigned long long>::push_back[abi:ne200100]((a1 + 128), &v7);
  return a1;
}

void sub_2180C0164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  v13 = *(v11 + 72);
  if (v13)
  {
    v10[17] = v13;
    operator delete(v13);
  }

  v14 = v10[13];
  if (v14)
  {
    v10[14] = v14;
    operator delete(v14);
  }

  v15 = v10[10];
  if (v15)
  {
    v10[11] = v15;
    operator delete(v15);
  }

  a10 = v11;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne200100](&a10);
  v16 = v10[5];
  if (v16)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v16);
  }

  v17 = v10[3];
  if (v17)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v17);
  }

  v18 = v10[1];
  if (v18)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v18);
  }

  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MatchContextImpl::~MatchContextImpl(MIL::Transform::MatchContext::MatchContextImpl *this)
{
  v2 = *(this + 16);
  if (v2)
  {
    *(this + 17) = v2;
    operator delete(v2);
  }

  v3 = *(this + 13);
  if (v3)
  {
    *(this + 14) = v3;
    operator delete(v3);
  }

  v4 = *(this + 10);
  if (v4)
  {
    *(this + 11) = v4;
    operator delete(v4);
  }

  v8 = (this + 56);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne200100](&v8);
  v5 = *(this + 5);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v5);
  }

  v6 = *(this + 3);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v6);
  }

  v7 = *(this + 1);
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v7);
  }
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper &,MIL::Matching::CompiledPattern const&,std::function<void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)> const&)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(MIL::Builder::ProgramBuilder *a1, uint64_t a2)
{
  result = MIL::Builder::ProgramBuilder::GetFunctions(a1);
  for (i = *(result + 16); i; i = *i)
  {
    result = MIL::Builder::FunctionBuilder::GetSpecializations(i[5]);
    for (j = *(result + 16); j; j = *j)
    {
      result = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper &,MIL::Matching::CompiledPattern const&,std::function<void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)> const&)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(j + 5, a2);
    }
  }

  return result;
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper &,MIL::Matching::CompiledPattern const&,std::function<void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)> const&)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(MIL::Builder::BlockBuilder **a1, uint64_t a2)
{
  if (MIL::Builder::BlockBuilder::GetNumOperations(*a1))
  {
    v4 = 0;
    do
    {
      MIL::Builder::BlockBuilder::GetOperation(*a1, v4, &v9);
      MIL::Builder::OperationBuilder::GetBlocks(v9, v8);
      v5 = v8[0];
      v6 = v8[1];
      while (v5 != v6)
      {
        MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper &,MIL::Matching::CompiledPattern const&,std::function<void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)> const&)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(v5, a2);
        v5 += 16;
      }

      v10 = v8;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne200100](&v10);
      if (*(&v9 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](*(&v9 + 1));
      }

      ++v4;
    }

    while (v4 < MIL::Builder::BlockBuilder::GetNumOperations(*a1));
  }

  result = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceWithinBlock(*a2, *(a2 + 8), *(a2 + 16), *(a2 + 24), a1);
  **(a2 + 32) = (**(a2 + 32) | result) & 1;
  return result;
}

void sub_2180C039C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14)
{
  if (a13)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a13);
  }

  _Unwind_Resume(exception_object);
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceWithinBlock(MIL::Transform::ProgramTransformer::ProgramTransformerImpl *a1, uint64_t a2, const MIL::Matching::CompiledPattern *a3, uint64_t a4, uint64_t a5)
{
  v10 = *(a2 + 152);
  v12 = *a5;
  v11 = *(a5 + 8);
  if (v11)
  {
    atomic_fetch_add_explicit((v11 + 8), 1uLL, memory_order_relaxed);
  }

  v13 = *(v10 + 40);
  *(v10 + 32) = v12;
  *(v10 + 40) = v11;
  if (v13)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v13);
  }

  v14 = 0;
  if (MIL::Builder::BlockBuilder::GetNumOperations(*a5))
  {
    v15 = 0;
    do
    {
      MIL::Builder::BlockBuilder::GetOperation(*a5, v15, &v18);
      v16 = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::PrepareMatcher(a1, *a5, v18, a3);
      while (!MIL::Matching::Matcher::FindNextMatch(v16, (a2 + 160), 0x7FFFFFFFFFFFFFFFLL))
      {
        if (MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ProcessMatch(a1, a2, a4, *a5))
        {
          v14 = 1;
          break;
        }
      }

      if (*(&v18 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](*(&v18 + 1));
      }

      ++v15;
    }

    while (v15 < MIL::Builder::BlockBuilder::GetNumOperations(*a5));
  }

  return v14 & 1;
}

void sub_2180C04D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a10);
  }

  _Unwind_Resume(exception_object);
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::PrepareMatcher(MIL::Transform::ProgramTransformer::ProgramTransformerImpl *this, MIL::Builder::BlockBuilder *a2, MIL::Builder::OperationBuilder *a3, const MIL::Matching::CompiledPattern *a4)
{
  v8 = a3;
  v9 = a2;
  v5 = *(this + 56);
  v6 = (this + 48);
  if (v5 == 1)
  {
    MIL::Matching::Matcher::Reset(v6, a2, a3, a4);
  }

  else
  {
    std::optional<MIL::Matching::Matcher>::emplace[abi:ne200100]<MIL::Builder::BlockBuilder *&,MIL::Builder::OperationBuilder *&,MIL::Matching::CompiledPattern const&,void>(v6, &v9, &v8, a4);
  }

  return this + 48;
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ProcessMatch(uint64_t a1, uint64_t a2, uint64_t a3, MIL::Builder::BlockBuilder *a4)
{
  v8 = (a2 + 168);
  *(a2 + 176) = *(a2 + 168);
  v9 = a2 + 160;
  MIL::MatchingPrivate::MatchPrivate::GetAllMatchedOperations((a2 + 160), a2 + 168);
  v10 = *v8;
  v11 = v8[1];
  if (*v8 == v11)
  {
    return 0;
  }

  __p = 0;
  v251 = 0;
  v252 = 0;
  std::vector<MIL::Builder::OperationBuilder *>::__init_with_size[abi:ne200100]<MIL::Builder::OperationBuilder **,MIL::Builder::OperationBuilder **>(&__p, v10, v11, (v11 - v10) >> 3);
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetOperationIndices(&__p, a4, a2 + 192, a2 + 216);
  if (__p)
  {
    v251 = __p;
    operator delete(__p);
  }

  MIL::Transform::MatchContext::MatchContextImpl::PrepareForNewMatch(a2);
  MIL::Matching::Match::GetRootView(v9, &v249);
  v12 = *(a3 + 24);
  if (!v12)
  {
    std::__throw_bad_function_call[abi:ne200100]();
  }

  (*(*v12 + 48))(v12, a2 + 152, &v249);
  MIL::Matching::MatchView::~MatchView(&v249);
  if (*(a2 + 48))
  {
    return 0;
  }

  v240 = **(a2 + 192);
  v14 = *(*(a2 + 200) - 8);
  MIL::Builder::BlockBuilder::GetOperation(a4, v14, &v253);
  v245 = (a2 + 56);
  v15 = *(a2 + 64);
  if (*(a2 + 56) == v15)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Match callback returned an empty replacement. If you want to remove the matched operations from the graph, you must instead add an identity operation, and then run an identity elimination pass. Otherwise, your intent may be ambiguous, as there could be several different options to what is considered the input to the identity operation.");
    goto LABEL_282;
  }

  if (*(a2 + 80) != *(a2 + 88))
  {
    goto LABEL_13;
  }

  v16 = v253.__r_.__value_.__r.__words[0];
  v17 = *(v15 - 16);
  NumOutputs = MIL::Builder::OperationBuilder::GetNumOutputs(v253.__r_.__value_.__l.__data_);
  if (NumOutputs != MIL::Builder::OperationBuilder::GetNumOutputs(v17))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Last replacement operation does not have the same number of outputs as the old operation");
LABEL_282:
    __cxa_throw(exception, MEMORY[0x277D82750], MEMORY[0x277D825D8]);
  }

  if (MIL::Builder::OperationBuilder::GetNumOutputs(v16))
  {
    v19 = 0;
    do
    {
      v254[0].__r_.__value_.__r.__words[0] = v16;
      v254[0].__r_.__value_.__l.__size_ = v19;
      v254[0].__r_.__value_.__r.__words[2] = ((*(a2 + 64) - *(a2 + 56)) >> 4) - 1;
      v254[1].__r_.__value_.__r.__words[0] = v19;
      ++v19;
    }

    while (v19 < MIL::Builder::OperationBuilder::GetNumOutputs(v16));
  }

LABEL_13:
  v243 = v14;
  if (v253.__r_.__value_.__l.__size_)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v253.__r_.__value_.__l.__size_);
  }

  v20 = (*(a2 + 200) - *(a2 + 192)) >> 3;
  *(a2 + 288) = 0;
  *(a2 + 304) = 0;
  std::vector<BOOL>::resize(a2 + 296, v20, 0);
  *(a2 + 328) = *(a2 + 320);
  *(a2 + 272) = *(a2 + 264);
  std::vector<std::string_view>::reserve((a2 + 264), (*(a2 + 88) - *(a2 + 80)) >> 5);
  v21 = *(a2 + 80);
  v22 = *(a2 + 88);
  v241 = a4;
  if (v21 == v22)
  {
    v29 = *(a2 + 272);
  }

  else
  {
    do
    {
      OutputName = MIL::Builder::OperationBuilder::GetOutputName(*v21, *(v21 + 8));
      v24 = *(OutputName + 23);
      if (v24 >= 0)
      {
        v25 = OutputName;
      }

      else
      {
        v25 = *OutputName;
      }

      if (v24 >= 0)
      {
        v26 = *(OutputName + 23);
      }

      else
      {
        v26 = *(OutputName + 8);
      }

      v28 = *(a2 + 272);
      v27 = *(a2 + 280);
      if (v28 >= v27)
      {
        v30 = *(a2 + 264);
        v31 = (v28 - v30) >> 4;
        v32 = v31 + 1;
        if ((v31 + 1) >> 60)
        {
          std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
        }

        v33 = v27 - v30;
        if (v33 >> 3 > v32)
        {
          v32 = v33 >> 3;
        }

        if (v33 >= 0x7FFFFFFFFFFFFFF0)
        {
          v34 = 0xFFFFFFFFFFFFFFFLL;
        }

        else
        {
          v34 = v32;
        }

        if (v34)
        {
          std::__allocate_at_least[abi:ne200100]<std::allocator<std::string_view>>(a2 + 264, v34);
        }

        v35 = (16 * v31);
        *v35 = v25;
        v35[1] = v26;
        v29 = (16 * v31 + 16);
        v36 = *(a2 + 264);
        v37 = *(a2 + 272) - v36;
        v38 = (16 * v31 - v37);
        memcpy(v38, v36, v37);
        v39 = *(a2 + 264);
        *(a2 + 264) = v38;
        *(a2 + 272) = v29;
        *(a2 + 280) = 0;
        if (v39)
        {
          operator delete(v39);
        }

        a4 = v241;
      }

      else
      {
        *v28 = v25;
        v28[1] = v26;
        v29 = (v28 + 2);
      }

      *(a2 + 272) = v29;
      v21 += 32;
    }

    while (v21 != v22);
  }

  v40 = *(a2 + 264);
  v41 = 126 - 2 * __clz(v29 - v40);
  if (v29 == v40)
  {
    v42 = 0;
  }

  else
  {
    v42 = v41;
  }

  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,false>(v40, v29, v254, v42, 1);
  v44 = *(a2 + 56);
  v45 = *(a2 + 64);
  while (v44 != v45)
  {
    v46 = *v44;
    v44 += 2;
    MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AddMatchedDependencies(v46, (a2 + 216), (a2 + 264), a4, (a2 + 288));
  }

  v47 = *(a2 + 320);
  if (*(a2 + 328) != v47)
  {
    v48 = 0;
    do
    {
      v49 = v48 + 1;
      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AddMatchedDependencies(*(*(a2 + 56) + 16 * *(v47 + 8 * v48)), (a2 + 216), (a2 + 264), a4, (a2 + 288));
      v47 = *(a2 + 320);
      v48 = v49;
    }

    while (v49 < (*(a2 + 328) - v47) >> 3);
  }

  v51 = (a2 + 240);
  v50 = *(a2 + 240);
  *(a2 + 248) = v50;
  v52 = *(a2 + 80);
  v53 = *(a2 + 88);
  v54 = (v53 - v52) >> 5;
  if (v54 > (*(a2 + 256) - v50) >> 4)
  {
    if (v54 >> 60)
    {
LABEL_259:
      std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
    }

    v55 = *(a2 + 240);
    v56 = *(a2 + 248) - v55;
    v57 = v254[0].__r_.__value_.__l.__size_ - v56;
    memcpy((v254[0].__r_.__value_.__l.__size_ - v56), v55, v56);
    v58 = *(a2 + 240);
    *(a2 + 240) = v57;
    v59 = *(a2 + 256);
    v43 = *&v254[0].__r_.__value_.__r.__words[2];
    *(a2 + 248) = *&v254[0].__r_.__value_.__r.__words[2];
    v254[0].__r_.__value_.__r.__words[2] = v58;
    v254[1].__r_.__value_.__r.__words[0] = v59;
    v254[0].__r_.__value_.__r.__words[0] = v58;
    v254[0].__r_.__value_.__l.__size_ = v58;
    if (v58)
    {
      operator delete(v58);
      v50 = *(a2 + 248);
    }

    else
    {
      v50 = v43.n128_u64[0];
    }

    v52 = *(a2 + 80);
    v53 = *(a2 + 88);
  }

  for (; v52 != v53; v52 += 2)
  {
    v60 = *(a2 + 256);
    if (v50 >= v60)
    {
      v61 = (v50 - *v51) >> 4;
      if ((v61 + 1) >> 60)
      {
        goto LABEL_259;
      }

      v62 = v60 - *v51;
      v63 = v62 >> 3;
      if (v62 >> 3 <= (v61 + 1))
      {
        v63 = v61 + 1;
      }

      if (v62 >= 0x7FFFFFFFFFFFFFF0)
      {
        v64 = 0xFFFFFFFFFFFFFFFLL;
      }

      else
      {
        v64 = v63;
      }

      *v254[0].__r_.__value_.__r.__words[2] = *v52;
      v254[0].__r_.__value_.__r.__words[2] += 16;
      v65 = *(a2 + 240);
      v66 = *(a2 + 248) - v65;
      v67 = v254[0].__r_.__value_.__l.__size_ - v66;
      memcpy((v254[0].__r_.__value_.__l.__size_ - v66), v65, v66);
      v68 = *(a2 + 240);
      *(a2 + 240) = v67;
      v69 = *(a2 + 256);
      v43 = *&v254[0].__r_.__value_.__r.__words[2];
      *(a2 + 248) = *&v254[0].__r_.__value_.__r.__words[2];
      v254[0].__r_.__value_.__r.__words[2] = v68;
      v254[1].__r_.__value_.__r.__words[0] = v69;
      v254[0].__r_.__value_.__r.__words[0] = v68;
      v254[0].__r_.__value_.__l.__size_ = v68;
      if (v68)
      {
        v246 = v43;
        operator delete(v68);
        v43 = v246;
      }

      v50 = v43.n128_u64[0];
    }

    else
    {
      v43 = *v52;
      *v50++ = *v52;
    }

    *(a2 + 248) = v50;
  }

  v70 = *(a2 + 240);
  v71 = 126 - 2 * __clz(v50 - v70);
  if (v50 == v70)
  {
    v72 = 0;
  }

  else
  {
    v72 = v71;
  }

  v73 = *(a2 + 168);
  if (*(a2 + 176) != v73)
  {
    v74 = 0;
    while (1)
    {
      v75 = v74 - *(a2 + 288);
      if (*(a2 + 304) <= v75)
      {
        break;
      }

      if (((*(*(a2 + 296) + ((v75 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v75) & 1) == 0)
      {
        v76 = *(v73 + 8 * v74);
        if (MIL::Builder::OperationBuilder::GetNumOutputs(v76))
        {
          v77 = 0;
          do
          {
            v78 = *(a2 + 240);
            v79 = *(a2 + 248);
            if (v79 == v78)
            {
              goto LABEL_86;
            }

            v80 = (v79 - v78) >> 4;
            do
            {
              v81 = v80 >> 1;
              v82 = &v78[16 * (v80 >> 1)];
              if (*v82 < v76 || v76 >= *v82 && *(v82 + 1) < v77)
              {
                v78 = v82 + 16;
                v81 = v80 + ~v81;
              }

              v80 = v81;
            }

            while (v81);
            if (v78 == v79 || v76 < *v78 || *v78 >= v76 && v77 < *(v78 + 1))
            {
LABEL_86:
              v83 = MIL::Builder::OperationBuilder::GetOutputName(v76, v77);
              v84 = MIL::Builder::BlockBuilder::GetDataDependenciesByVariableName(a4, v83) + 2;
              while (1)
              {
                v84 = *v84;
                if (!v84)
                {
                  break;
                }

                MIL::Builder::DataDependency::GetConsumer((v84 + 2), v254);
                v85 = v254[0].__r_.__value_.__r.__words[0];
                if (v254[0].__r_.__value_.__l.__size_)
                {
                  std::__shared_weak_count::__release_shared[abi:ne200100](v254[0].__r_.__value_.__l.__size_);
                }

                if (v85)
                {
                  MIL::Builder::DataDependency::GetConsumer((v84 + 2), v254);
                  v86 = *(a2 + 168);
                  v87 = *(a2 + 176);
                  if (v86 != v87)
                  {
                    while (*v86 != v254[0].__r_.__value_.__r.__words[0])
                    {
                      if (++v86 == v87)
                      {
                        v86 = *(a2 + 176);
                        break;
                      }
                    }
                  }

                  if (v254[0].__r_.__value_.__l.__size_)
                  {
                    std::__shared_weak_count::__release_shared[abi:ne200100](v254[0].__r_.__value_.__l.__size_);
                  }

                  if (v86 != v87)
                  {
                    continue;
                  }
                }

                return 0;
              }
            }

            ++v77;
          }

          while (v77 < MIL::Builder::OperationBuilder::GetNumOutputs(v76));
        }
      }

      ++v74;
      v73 = *(a2 + 168);
      if (v74 >= (*(a2 + 176) - v73) >> 3)
      {
        goto LABEL_103;
      }
    }

LABEL_258:
    std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne200100]();
  }

LABEL_103:
  v88 = *(a2 + 320);
  v89 = *(a2 + 328);
  if (v88 != v89)
  {
    v90 = *(a2 + 216);
    v91 = *(a2 + 248);
    v92 = *(a2 + 240);
    do
    {
      if (((*(a2 + 224) - v90) >> 3) <= *v88)
      {
        std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne200100]();
      }

      if (v91 != v92)
      {
        v93 = *(v90 + 8 * *v88);
        v94 = *(a2 + 240);
        v95 = (v91 - v92) >> 4;
        do
        {
          v96 = v95 >> 1;
          v97 = &v94[2 * (v95 >> 1)];
          v99 = *v97;
          v98 = (v97 + 2);
          v95 += ~(v95 >> 1);
          if (v99 < v93)
          {
            v94 = v98;
          }

          else
          {
            v95 = v96;
          }
        }

        while (v95);
        if (v94 != v91 && *v94 == v93)
        {
          std::ostringstream::basic_ostringstream[abi:ne200100](v254);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "One of the operations that has been matched is being used as a dependency ", 74);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "for a newly added operation, and thus must be kept in the graph. ", 65);
          v231 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "On the other hand, its output named '", 37);
          v232 = MIL::Builder::OperationBuilder::GetOutputName(*v94, v94[1]);
          v233 = *(v232 + 23);
          if (v233 >= 0)
          {
            v234 = v232;
          }

          else
          {
            v234 = *v232;
          }

          if (v233 >= 0)
          {
            v235 = *(v232 + 23);
          }

          else
          {
            v235 = *(v232 + 8);
          }

          v236 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v231, v234, v235);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v236, "' has been remapped ", 20);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "to another newly added operation using MatchContext::MapOutput(). ", 66);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "This is currently disallowed.", 29);
          v237 = __cxa_allocate_exception(0x10uLL);
          std::stringbuf::str();
          std::logic_error::logic_error(v237, &v253);
          v237->__vftable = (MEMORY[0x277D828F8] + 16);
          __cxa_throw(v237, off_278235F80, MEMORY[0x277D82610]);
        }
      }

      ++v88;
    }

    while (v88 != v89);
  }

  v100 = *(a2 + 88);
  if (v100 != *(a2 + 80))
  {
    v101 = *(a1 + 16);
    v102 = *(a2 + 88);
    v103 = *(*v245 + 16 * *(v100 - 16));
    v104 = MIL::Builder::OperationBuilder::GetOutputName(v103, *(v100 - 8));
    MIL::Transform::NameGenerator::TakeBack(v101, v104);
    v105 = *(v100 - 8);
    v106 = MIL::Builder::OperationBuilder::GetOutputName(*(v102 - 32), *(v102 - 24));
    if (*(v106 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v254, *v106, *(v106 + 8));
    }

    else
    {
      v107 = *v106;
      v254[0].__r_.__value_.__r.__words[2] = *(v106 + 16);
      *&v254[0].__r_.__value_.__l.__data_ = v107;
    }

    MIL::Builder::OperationBuilder::RenameOutput(v103, v105, v254, &v253);
  }

  *(a2 + 352) = *(a2 + 344);
  std::vector<unsigned long long>::reserve((a2 + 344), (*(a2 + 200) - *(a2 + 192)) >> 3);
  v108 = *(a2 + 192);
  v109 = *(a2 + 200);
  if (v109 != v108)
  {
    v110 = 0;
    v111 = 0;
    do
    {
      v112 = v111 - *(a2 + 288);
      if (*(a2 + 304) <= v112)
      {
        goto LABEL_258;
      }

      if (((*(*(a2 + 296) + ((v112 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v112) & 1) == 0)
      {
        std::vector<unsigned long long>::push_back[abi:ne200100]((a2 + 344), (v108 + v110));
        v108 = *(a2 + 192);
        v109 = *(a2 + 200);
      }

      ++v111;
      v110 += 8;
    }

    while (v111 < (v109 - v108) >> 3);
  }

  v113 = (*(a2 + 64) - *(a2 + 56)) >> 4;
  *(a2 + 368) = 0;
  *(a2 + 384) = 0;
  std::vector<BOOL>::resize(a2 + 376, v113, 0);
  *(a2 + 408) = *(a2 + 400);
  *(a2 + 432) = *(a2 + 424);
  std::vector<MIL::Passes::BlockInfo>::reserve((a2 + 424), (*(a2 + 64) - *(a2 + 56)) >> 4);
  v115 = *(a2 + 80);
  v247 = *(a2 + 88);
  if (v115 != v247)
  {
    v116 = 0;
    while (1)
    {
      {
        MatchedOperationIndex = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetMatchedOperationIndex(*v115, (a2 + 192), a2 + 216);
        v118 = *(a2 + 400);
        if (v116 < (*(a2 + 408) - v118) >> 3)
        {
          break;
        }
      }

LABEL_152:
      v115 += 4;
      if (v115 == v247)
      {
        goto LABEL_153;
      }
    }

    v119 = MatchedOperationIndex;
    while (1)
    {
      v120 = *(v118 + 8 * v116);
      v122 = *(a2 + 432);
      v121 = *(a2 + 440);
      if (v122 >= v121)
      {
        v124 = *(a2 + 424);
        v125 = v122 - v124;
        v126 = (v122 - v124) >> 4;
        v127 = v126 + 1;
        if ((v126 + 1) >> 60)
        {
          std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
        }

        v128 = v121 - v124;
        if (v128 >> 3 > v127)
        {
          v127 = v128 >> 3;
        }

        if (v128 >= 0x7FFFFFFFFFFFFFF0)
        {
          v129 = 0xFFFFFFFFFFFFFFFLL;
        }

        else
        {
          v129 = v127;
        }

        if (v129)
        {
          std::__allocate_at_least[abi:ne200100]<std::allocator<MIL::Passes::BlockInfo>>(a2 + 424, v129);
        }

        v130 = (16 * v126);
        *v130 = v119;
        v130[1] = v120;
        v123 = 16 * v126 + 16;
        memcpy(0, v124, v125);
        v131 = *(a2 + 424);
        *(a2 + 424) = 0;
        *(a2 + 432) = v123;
        *(a2 + 440) = 0;
        if (v131)
        {
          operator delete(v131);
        }
      }

      else
      {
        *v122 = v119;
        *(v122 + 1) = v120;
        v123 = (v122 + 16);
      }

      *(a2 + 432) = v123;
      v132 = *(a2 + 128);
      v133 = (*(a2 + 136) - v132) >> 3;
      if (v133 <= v120 || v133 <= v120 + 1)
      {
        break;
      }

      v134 = *(v132 + 8 * v120);
      v135 = *(v132 + 8 * (v120 + 1));
      if (v135 == v134)
      {
        v136 = 0;
      }

      else
      {
        v136 = (*(a2 + 104) + 8 * v134);
      }

      if (v135 != v134)
      {
        v137 = 8 * v135 - 8 * v134;
        do
        {
          v138 = *v136++;
          v137 -= 8;
        }

        while (v137);
      }

      ++v116;
      v118 = *(a2 + 400);
      if (v116 >= (*(a2 + 408) - v118) >> 3)
      {
        goto LABEL_152;
      }
    }

LABEL_255:
    std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne200100]();
  }

LABEL_153:
  v139 = *(a2 + 64) - *(a2 + 56);
  if (v139)
  {
    v140 = 0;
    v141 = 0;
    v142 = v139 >> 4;
    v143 = *(a2 + 384);
    v144 = *(a2 + 368);
    if (v143 <= -v144)
    {
      v143 = -v144;
    }

    if (v142 <= 1)
    {
      v142 = 1;
    }

    v145 = -v144 - v143;
    while (v145 + v141)
    {
      if (((*(*(a2 + 376) + (((v141 - v144) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v141 - v144)) & 1) == 0)
      {
        std::ostringstream::basic_ostringstream[abi:ne200100](v254);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "Replacement callback has added an operation whose outputs are not used anywhere. ", 81);
        v221 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "(The operation's index is ", 26);
        MEMORY[0x21CEAFB40](v221, v141);
        v222 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, " and the operator name is '", 27);
        v223 = *(a2 + 56);
        if (v141 < (*(a2 + 64) - v223) >> 4)
        {
          v224 = v222;
          Operator = MIL::Builder::OperationBuilder::GetOperator(*(v223 + v140));
          v226 = (*(*Operator + 16))(Operator);
          v227 = *(v226 + 23);
          if (v227 >= 0)
          {
            v228 = v226;
          }

          else
          {
            v228 = *v226;
          }

          if (v227 >= 0)
          {
            v229 = *(v226 + 23);
          }

          else
          {
            v229 = *(v226 + 8);
          }

          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v224, v228, v229);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "'.) You likely meant to do one of the following things:\n", 56);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "    1. Add another operation that consumes this operation's output.\n", 68);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "    2. Use MatchContext::MapOutput() to map the output of this operation to\n", 76);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "       an output of some matched operation.\n", 44);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "    3. Remove the MatchContext::AddOperation()/AddMultiOutputOperation() call\n", 78);
          std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v254, "       that is responsible for adding this operation.\n", 54);
          v230 = __cxa_allocate_exception(0x10uLL);
          std::stringbuf::str();
          std::logic_error::logic_error(v230, &v253);
          v230->__vftable = (MEMORY[0x277D828F8] + 16);
          __cxa_throw(v230, off_278235F80, MEMORY[0x277D82610]);
        }

        std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne200100]();
      }

      ++v141;
      v140 += 16;
      if (v142 == v141)
      {
        goto LABEL_162;
      }
    }

    goto LABEL_258;
  }

LABEL_162:
  v146 = *(a2 + 424);
  v147 = *(a2 + 432);
  v148 = 126 - 2 * __clz(v147 - v146);
  if (v147 == v146)
  {
    v149 = 0;
  }

  else
  {
    v149 = v148;
  }

  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *,false>(v146, v147, v254, v149, 1, v114);
  v150 = *(a2 + 352) - *(a2 + 344);
  if (v150)
  {
    v151 = *(a2 + 344);
  }

  else
  {
    v151 = 0;
  }

  MIL::Builder::BlockBuilder::RemoveOperations(v241, v151, v150 >> 3, 1);
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AdjustInsertionPositionsAfterRemoval((a2 + 344), (a2 + 424));
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetOperationsToInsertAndTheirPositions(v245, a2 + 424, (a2 + 448), (a2 + 472));
  v152 = *(a2 + 456) - *(a2 + 448);
  v153 = v152 >> 4;
  if (v152)
  {
    v154 = *(a2 + 448);
  }

  else
  {
    v154 = 0;
  }

  v155 = *(a2 + 480) - *(a2 + 472);
  if (v155)
  {
    v156 = *(a2 + 472);
  }

  else
  {
    v156 = 0;
  }

  MIL::Builder::BlockBuilder::InsertOperations(v241, v154, v153, v156, v155 >> 3);
  v157 = v240;
  v244 = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AdjustMaxIndex(v243, (*(a2 + 352) - *(a2 + 344)) >> 3, (*(a2 + 480) - *(a2 + 472)) >> 3);
  v158 = v244 - v240;
  if (v244 < v240)
  {
    v239 = __cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v239, "maxIndex must be greater or equal to minIndex");
    __cxa_throw(v239, MEMORY[0x277D82750], MEMORY[0x277D825D8]);
  }

  v159 = (a2 + 496);
  *(a2 + 504) = *(a2 + 496);
  do
  {
    MIL::Builder::BlockBuilder::GetOperation(v241, v157, v254);
    v161 = *(a2 + 504);
    v160 = *(a2 + 512);
    if (v161 >= v160)
    {
      v163 = (v161 - *v159) >> 4;
      v164 = v163 + 1;
      if ((v163 + 1) >> 60)
      {
        std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
      }

      v165 = v160 - *v159;
      if (v165 >> 3 > v164)
      {
        v164 = v165 >> 3;
      }

      if (v165 >= 0x7FFFFFFFFFFFFFF0)
      {
        v166 = 0xFFFFFFFFFFFFFFFLL;
      }

      else
      {
        v166 = v164;
      }

      if (v166)
      {
        std::__allocate_at_least[abi:ne200100]<std::allocator<std::pair<MIL::Builder::OperationBuilder *,unsigned long>>>(a2 + 496, v166);
      }

      v167 = (16 * v163);
      *v167 = v254[0].__r_.__value_.__r.__words[0];
      v167[1] = v157;
      v162 = 16 * v163 + 16;
      v168 = *(a2 + 496);
      v169 = *(a2 + 504) - v168;
      v170 = v167 - v169;
      memcpy(v167 - v169, v168, v169);
      v171 = *(a2 + 496);
      *(a2 + 496) = v170;
      *(a2 + 504) = v162;
      *(a2 + 512) = 0;
      if (v171)
      {
        operator delete(v171);
      }
    }

    else
    {
      *v161 = v254[0].__r_.__value_.__r.__words[0];
      v161[1] = v157;
      v162 = (v161 + 2);
    }

    *(a2 + 504) = v162;
    if (v254[0].__r_.__value_.__l.__size_)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v254[0].__r_.__value_.__l.__size_);
    }

    ++v157;
  }

  while (v157 <= v244);
  v172 = *(a2 + 504);
  v173 = *(a2 + 496);
  v174 = 126 - 2 * __clz((v172 - v173) >> 4);
  if (v172 == v173)
  {
    v175 = 0;
  }

  else
  {
    v175 = v174;
  }

  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *,false>(v173, v172, v254, v175, 1);
  *(a2 + 576) = v241;
  *(a2 + 592) = v159;
  *(a2 + 584) = v240;
  std::vector<unsigned long>::resize((a2 + 624), 1uLL);
  v176 = *(a2 + 600);
  *(a2 + 608) = v176;
  v177 = (v158 + 1);
  if (v158 == -1)
  {
    *(a2 + 648) = v240;
    *(a2 + 664) = *(a2 + 656);
  }

  else
  {
    v178 = *(a2 + 616) - v176;
    if (v177 > v178 >> 4)
    {
      if (!(v177 >> 60))
      {
        v179 = v178 >> 3;
        if (v178 >> 3 <= v177)
        {
          v179 = (v158 + 1);
        }

        if (v178 >= 0x7FFFFFFFFFFFFFF0)
        {
          v180 = 0xFFFFFFFFFFFFFFFLL;
        }

        else
        {
          v180 = v179;
        }

        if (!(v180 >> 60))
        {
          operator new();
        }

        std::__throw_bad_array_new_length[abi:ne200100]();
      }

      std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
    }

    bzero(v176, 16 * v158 + 16);
    *(a2 + 608) = &v176[16 * v177];
    *(a2 + 648) = v240;
    v181 = *(a2 + 656);
    *(a2 + 664) = v181;
    if (*(a2 + 672) - v181 < v177)
    {
      if ((v177 & 0x8000000000000000) == 0)
      {
        operator new();
      }

      std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
    }

    v182 = &v181[v177];
    bzero(v181, v177);
    *(a2 + 664) = v182;
  }

  *(a2 + 712) = *(a2 + 704);
  v183 = *(a2 + 680);
  v184 = v240;
  do
  {
    *(a2 + 688) = v183;
    v242 = v184;
    v183 = *(a2 + 680);
    v185 = *(a2 + 688);
    while (v183 != v185)
    {
      v186 = *(v185 - 8);
      v255 = v186;
      v187 = v186 - *(a2 + 584);
      v188 = *(a2 + 600);
      if (v187 >= (*(a2 + 608) - v188) >> 4)
      {
        std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne200100]();
      }

      v189 = (v188 + 16 * v187);
      v190 = *v189;
      if (!*v189)
      {
        v248 = (v188 + 16 * v187);
        MIL::Builder::BlockBuilder::GetOperation(*(a2 + 576), v186, &v253);
        v191 = v253.__r_.__value_.__r.__words[0];
        v192 = *(a2 + 632);
        v193 = *(a2 + 624);
        Parameters = MIL::BuilderPrivate::OperationBuilderPrivate::GetParameters(v253.__r_.__value_.__l.__data_, v194);
        v190 = (v192 - v193) >> 3;
        v197 = Parameters + 1;
        v196 = *Parameters;
        v198 = v190;
        if (*Parameters != (Parameters + 1))
        {
          v198 = v190;
          do
          {
            for (i = MIL::Builder::BlockBuilder::GetDataDependenciesForConsumerParam(*(a2 + 576), v191, v196 + 4)[2]; i; i = *i)
            {
              MIL::Builder::DataDependency::GetProducer(i + 2, v254);
              if (v254[0].__r_.__value_.__r.__words[0])
              {
                v200 = *(a2 + 592);
                v201 = *v200;
                v202 = v200[1];
                if (v202 != v201)
                {
                  v203 = (v202 - v201) >> 4;
                  do
                  {
                    v204 = v203 >> 1;
                    v205 = &v201[16 * (v203 >> 1)];
                    v207 = *v205;
                    v206 = (v205 + 2);
                    v203 += ~(v203 >> 1);
                    if (v207 < v254[0].__r_.__value_.__r.__words[0])
                    {
                      v201 = v206;
                    }

                    else
                    {
                      v203 = v204;
                    }
                  }

                  while (v203);
                  if (v201 != v202 && *v201 == v254[0].__r_.__value_.__r.__words[0])
                  {
                    std::vector<unsigned long long>::push_back[abi:ne200100]((a2 + 624), v201 + 1);
                    ++v198;
                  }
                }
              }

              if (v254[0].__r_.__value_.__l.__size_)
              {
                std::__shared_weak_count::__release_shared[abi:ne200100](v254[0].__r_.__value_.__l.__size_);
              }
            }

            v208 = v196[1];
            if (v208)
            {
              do
              {
                v209 = v208;
                v208 = *v208;
              }

              while (v208);
            }

            else
            {
              do
              {
                v209 = v196[2];
                v210 = *v209 == v196;
                v196 = v209;
              }

              while (!v210);
            }

            v196 = v209;
          }

          while (v209 != v197);
        }

        std::__sort<std::__less<unsigned long,unsigned long> &,unsigned long *>();
        v189 = v248;
        *v248 = v190;
        v248[1] = v198;
        if (v253.__r_.__value_.__l.__size_)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v253.__r_.__value_.__l.__size_);
          v190 = *v248;
        }
      }

      if (v190 == v189[1])
      {
        v211 = v255 - *(a2 + 648);
        v212 = *(a2 + 656);
        if (*(a2 + 664) - v212 <= v211)
        {
          std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne200100]();
        }

        *(v212 + v211) = 2;
        std::vector<unsigned long long>::push_back[abi:ne200100]((a2 + 704), &v255);
        v185 = *(a2 + 688) - 8;
        *(a2 + 688) = v185;
      }

      else
      {
        *v189 = v190 + 1;
        v185 = *(a2 + 688);
      }

      v183 = *(a2 + 680);
    }

    v184 = v242 + 1;
  }

  while (v242 + 1 <= v244);
  v213 = *(a2 + 712);
  v214 = *(a2 + 704);
  v215 = (v213 - v214) >> 3;
  *(a2 + 736) = *(a2 + 728);
  std::vector<unsigned long long>::reserve((a2 + 728), v215);
  if (v213 != v214)
  {
    v216 = 0;
    if (v215 <= 1)
    {
      v217 = 1;
    }

    else
    {
      v217 = v215;
    }

    do
    {
      v218 = *(a2 + 704);
      if (v216 >= (*(a2 + 712) - v218) >> 3)
      {
        goto LABEL_255;
      }

      v254[0].__r_.__value_.__r.__words[0] = *(v218 + 8 * v216) - v240;
      std::vector<unsigned long long>::push_back[abi:ne200100]((a2 + 728), v254);
    }

    while (v217 != ++v216);
  }

  v219 = *(a2 + 736) - *(a2 + 728);
  if (v219)
  {
    v220 = *(a2 + 728);
  }

  else
  {
    v220 = 0;
  }

  MIL::BuilderPrivate::BlockBuilderPrivate::PermuteOperations(v241, v240, v220, v219 >> 3);
  return 1;
}

void sub_2180C19D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27, uint64_t a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a27 < 0)
  {
    operator delete(__p);
    if ((v34 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream(&a28);
      _Unwind_Resume(a1);
    }
  }

  else if (!v34)
  {
    goto LABEL_6;
  }

  __cxa_free_exception(v33);
  goto LABEL_6;
}

uint64_t std::optional<MIL::Matching::Matcher>::emplace[abi:ne200100]<MIL::Builder::BlockBuilder *&,MIL::Builder::OperationBuilder *&,MIL::Matching::CompiledPattern const&,void>(MIL::Matching::Matcher *a1, MIL::Builder::BlockBuilder **a2, MIL::Builder::OperationBuilder **a3, MIL::Matching::CompiledPattern *a4)
{
  if (*(a1 + 8) == 1)
  {
    MIL::Matching::Matcher::~Matcher(a1);
    *(a1 + 8) = 0;
  }

  result = MIL::Matching::Matcher::Matcher(a1, *a2, *a3, a4);
  *(result + 8) = 1;
  return result;
}

unint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetOperationIndices(uint64_t a1, MIL::Builder::BlockBuilder *this, uint64_t a3, uint64_t a4)
{
  *(a3 + 8) = *a3;
  *(a4 + 8) = *a4;
  v25 = 0;
  result = MIL::Builder::BlockBuilder::GetNumOperations(this);
  if (result)
  {
    do
    {
      MIL::Builder::BlockBuilder::GetOperation(this, v25, &v24);
      v9 = v24;
      if (*(&v24 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](*(&v24 + 1));
      }

      v10 = *a1;
      v11 = *(a1 + 8);
      if (*a1 != v11)
      {
        while (*v10 != v9)
        {
          if (++v10 == v11)
          {
            goto LABEL_22;
          }
        }
      }

      if (v10 != v11)
      {
        std::vector<unsigned long long>::push_back[abi:ne200100](a3, &v25);
        v13 = *(a4 + 8);
        v12 = *(a4 + 16);
        if (v13 >= v12)
        {
          v15 = (v13 - *a4) >> 3;
          if ((v15 + 1) >> 61)
          {
            std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
          }

          v16 = v12 - *a4;
          v17 = v16 >> 2;
          if (v16 >> 2 <= (v15 + 1))
          {
            v17 = v15 + 1;
          }

          if (v16 >= 0x7FFFFFFFFFFFFFF8)
          {
            v18 = 0x1FFFFFFFFFFFFFFFLL;
          }

          else
          {
            v18 = v17;
          }

          if (v18)
          {
            std::__allocate_at_least[abi:ne200100]<std::allocator<std::unique_ptr<MIL::Pass>>>(a4, v18);
          }

          v19 = (8 * v15);
          *v19 = v9;
          v14 = 8 * v15 + 8;
          v20 = *(a4 + 8) - *a4;
          v21 = v19 - v20;
          memcpy(v19 - v20, *a4, v20);
          v22 = *a4;
          *a4 = v21;
          *(a4 + 8) = v14;
          *(a4 + 16) = 0;
          if (v22)
          {
            operator delete(v22);
          }
        }

        else
        {
          *v13 = v9;
          v14 = (v13 + 1);
        }

        *(a4 + 8) = v14;
      }

LABEL_22:
      v23 = ++v25;
      result = MIL::Builder::BlockBuilder::GetNumOperations(this);
    }

    while (v23 < result);
  }

  return result;
}

void MIL::Transform::MatchContext::MatchContextImpl::PrepareForNewMatch(MIL::Transform::MatchContext::MatchContextImpl *this)
{
  *(this + 48) = 0;
  std::vector<std::shared_ptr<MIL::IRBlock>>::clear[abi:ne200100](this + 7);
  *(this + 11) = *(this + 10);
  std::vector<unsigned long>::resize(this + 13, 1uLL);

  std::vector<unsigned long>::resize(this + 16, 1uLL);
}

unint64_t **MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AdjustInsertionPositionsAfterRemoval(unint64_t **result, unint64_t **a2)
{
  v2 = *result;
  v3 = result[1];
  v4 = *a2;
  v5 = a2[1];
  if (*result == v3)
  {
    v6 = 0;
  }

  else
  {
    v6 = 0;
    do
    {
      if (v4 != v5)
      {
        v7 = *v2;
        do
        {
          if (*v4 > v7)
          {
            break;
          }

          *v4 -= v6;
          v4 += 2;
        }

        while (v4 != v5);
      }

      ++v6;
      ++v2;
    }

    while (v2 != v3);
  }

  while (v4 != v5)
  {
    *v4 -= v6;
    v4 += 2;
  }

  return result;
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetOperationsToInsertAndTheirPositions(void *a1, uint64_t a2, uint64_t *a3, const void **a4)
{
  std::vector<std::shared_ptr<MIL::IRBlock>>::clear[abi:ne200100](a3);
  std::vector<std::shared_ptr<MIL::IROperation>>::reserve(a3, (a1[1] - *a1) >> 4);
  a4[1] = *a4;
  std::vector<unsigned long long>::reserve(a4, (a1[1] - *a1) >> 4);
  v8 = *a2;
  v9 = *(a2 + 8);
  while (v8 != v9)
  {
    v10 = v8[1];
    if (v10 >= (a1[1] - *a1) >> 4)
    {
      std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne200100]();
    }

    std::vector<std::shared_ptr<MIL::IROperation>>::push_back[abi:ne200100](a3, (*a1 + 16 * v10));
    std::vector<unsigned long long>::push_back[abi:ne200100](a4, v8);
    v8 += 2;
  }
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AdjustMaxIndex(MIL::Transform::ProgramTransformer::ProgramTransformerImpl *this, unint64_t a2, uint64_t a3)
{
  if (this + 1 < a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "numRemoved is too big");
    goto LABEL_6;
  }

  if (!a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "numInserted is zero");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x277D82750], MEMORY[0x277D825D8]);
  }

  return this + a3 - a2;
}

uint64_t std::vector<MIL::Builder::OperationBuilder *>::__init_with_size[abi:ne200100]<MIL::Builder::OperationBuilder **,MIL::Builder::OperationBuilder **>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<MIL::Builder::OperationBuilder *>::__vallocate[abi:ne200100](result, a4);
  }

  return result;
}

void sub_2180C1F34(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<MIL::Builder::OperationBuilder *>::__vallocate[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 61))
  {
    std::__allocate_at_least[abi:ne200100]<std::allocator<std::unique_ptr<MIL::Pass>>>(a1, a2);
  }

  std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
}

void std::vector<unsigned long>::resize(void *a1, unint64_t a2)
{
  v2 = (a1[1] - *a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
    {
      a1[1] = *a1 + 8 * a2;
    }
  }

  else
  {
    std::vector<unsigned long>::__append(a1, a2 - v2);
  }
}

void std::vector<unsigned long>::__append(uint64_t a1, unint64_t a2)
{
  v5 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (a2 <= (v4 - v5) >> 3)
  {
    if (a2)
    {
      bzero(*(a1 + 8), 8 * a2);
      v5 += 8 * a2;
    }

    *(a1 + 8) = v5;
  }

  else
  {
    v6 = *a1;
    v7 = v5 - *a1;
    v8 = a2 + (v7 >> 3);
    if (v8 >> 61)
    {
      std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
    }

    v9 = v4 - v6;
    if (v9 >> 2 > v8)
    {
      v8 = v9 >> 2;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFF8)
    {
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      std::__allocate_at_least[abi:ne200100]<std::allocator<unsigned long long>>(a1, v10);
    }

    v11 = (8 * (v7 >> 3));
    bzero(v11, 8 * a2);
    memcpy(0, v6, v7);
    v12 = *a1;
    *a1 = 0;
    *(a1 + 8) = &v11[8 * a2];
    *(a1 + 16) = 0;
    if (v12)
    {

      operator delete(v12);
    }
  }
}

void std::vector<BOOL>::resize(uint64_t a1, unint64_t a2, int a3)
{
  v4 = *(a1 + 8);
  v5 = a2 - v4;
  if (a2 <= v4)
  {
    *(a1 + 8) = a2;
    return;
  }

  v7 = *(a1 + 16);
  v8 = v7 << 6;
  if (v7 << 6 < v5 || v4 > (v7 << 6) - v5)
  {
    v20 = 0;
    v21 = 0uLL;
    if ((a2 & 0x8000000000000000) != 0)
    {
      std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
    }

    v10 = v7 << 7;
    if (v10 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0))
    {
      v10 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0;
    }

    if (v8 <= 0x3FFFFFFFFFFFFFFELL)
    {
      v11 = v10;
    }

    else
    {
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    }

    std::vector<BOOL>::reserve(&v20, v11);
    v12 = *a1;
    v13 = *(a1 + 8);
    *&v21 = v13 + v5;
    v22 = v20;
    v23 = 0;
    std::__copy_aligned[abi:ne200100]<std::vector<BOOL>,true>(v12, 0, &v12[v13 >> 6], v13 & 0x3F, &v22, &v18);
    v14 = v18;
    LODWORD(v15) = v19;
    v16 = *a1;
    *a1 = v20;
    v20 = v16;
    v17 = *(a1 + 8);
    *(a1 + 8) = v21;
    v21 = v17;
    if (v16)
    {
      operator delete(v16);
    }

    if (!a3)
    {
      goto LABEL_19;
    }

LABEL_16:
    v20 = v14;
    LODWORD(v21) = v15;
    std::__fill_n_BOOL[abi:ne200100]<true,std::vector<BOOL>>(&v20, v5);
    return;
  }

  v14 = *a1 + 8 * (v4 >> 6);
  v15 = *(a1 + 8) & 0x3FLL;
  *(a1 + 8) = a2;
  if (a3)
  {
    goto LABEL_16;
  }

LABEL_19:
  v20 = v14;
  LODWORD(v21) = v15;
  std::__fill_n_BOOL[abi:ne200100]<false,std::vector<BOOL>>(&v20, v5);
}

void sub_2180C223C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::vector<BOOL>::reserve(uint64_t result, unint64_t a2)
{
  if (a2 > *(result + 16) << 6)
  {
    if ((a2 & 0x8000000000000000) == 0)
    {
      v2 = 0;
      v3 = 0uLL;
      std::vector<BOOL>::__vallocate[abi:ne200100](&v2, a2);
    }

    std::vector<unsigned char>::__throw_length_error[abi:ne200100]();
  }

  return result;
}

void sub_2180C22FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6 = a1[1];
  v7 = v6 + a4;
  a1[1] = v6 + a4;
  if (!v6 || ((v7 - 1) ^ (v6 - 1)) >= 0x40)
  {
    if (v7 >= 0x41)
    {
      v8 = (v7 - 1) >> 6;
    }

    else
    {
      v8 = 0;
    }

    *(*a1 + 8 * v8) = 0;
  }

  v20 = v4;
  v21 = v5;
  v9 = *(a2 + 8);
  v10 = *a3;
  v11 = *(a3 + 8);
  v12 = *a1 + 8 * (v6 >> 6);
  v18 = *a2;
  v19 = v9;
  v16 = v10;
  v17 = v11;
  v14 = v12;
  v15 = v6 & 0x3F;
  std::__copy_move_unwrap_iters[abi:ne200100]<std::__copy_impl,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,0>(&v18, &v16, &v14, &v13);
}

void std::__copy_move_unwrap_iters[abi:ne200100]<std::__copy_impl,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  v5 = *(a1 + 2);
  v6 = *a2;
  v7 = *(a2 + 2);
  v16 = *a1;
  v17 = v5;
  v14 = v6;
  v15 = v7;
  v8 = *(a3 + 2);
  v12 = *a3;
  v13 = v8;
  std::__copy_impl::operator()[abi:ne200100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(&v16, &v14, &v12, &v18);
  v9 = v19;
  v10 = v20;
  v11 = v21;
  *a4 = v18;
  *(a4 + 8) = v9;
  *(a4 + 16) = v10;
  *(a4 + 24) = v11;
}

void std::__copy_impl::operator()[abi:ne200100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  v4 = *a1;
  v5 = *(a1 + 8);
  v6 = *(a3 + 8);
  if (*a1 != *a2 || v5 != *(a2 + 8))
  {
    do
    {
      v8 = *a3;
      v9 = 1 << v6;
      if ((*v4 >> v5))
      {
        v10 = *v8 | v9;
      }

      else
      {
        v10 = *v8 & ~v9;
      }

      *v8 = v10;
      if (v5 == 63)
      {
        v11 = 0;
        *a1 = ++v4;
      }

      else
      {
        v11 = v5 + 1;
      }

      *(a1 + 8) = v11;
      v12 = *(a3 + 8);
      if (v12 == 63)
      {
        v6 = 0;
        *a3 += 8;
        v4 = *a1;
      }

      else
      {
        v6 = v12 + 1;
      }

      *(a3 + 8) = v6;
      v5 = *(a1 + 8);
    }

    while (v4 != *a2 || v5 != *(a2 + 8));
  }

  *a4 = v4;
  *(a4 + 8) = v5;
  *(a4 + 16) = *a3;
  *(a4 + 24) = v6;
}

unint64_t *std::__copy_aligned[abi:ne200100]<std::vector<BOOL>,true>@<X0>(unint64_t *__src@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  v8 = a4 - a2 + 8 * (a3 - __src);
  if (v8 <= 0)
  {
    v16 = *a5;
  }

  else
  {
    v9 = __src;
    __src = *a5;
    if (a2)
    {
      if (v8 >= (64 - a2))
      {
        v10 = 64 - a2;
      }

      else
      {
        v10 = v8;
      }

      v8 -= v10;
      v11 = *v9++;
      *__src = *__src & ~((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v10)) & (-1 << a2)) | v11 & (0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v10)) & (-1 << a2);
      v12 = v10 + *(a5 + 8);
      __src = (__src + ((v12 >> 3) & 0x3FFFFFF8));
      *a5 = __src;
      *(a5 + 8) = v12 & 0x3F;
    }

    if (v8 >= 0)
    {
      v13 = v8;
    }

    else
    {
      v13 = v8 + 63;
    }

    v14 = v13 >> 6;
    if ((v8 + 63) >= 0x7F)
    {
      memmove(__src, v9, 8 * v14);
      __src = *a5;
    }

    v15 = v8 - (v14 << 6);
    v16 = &__src[v14];
    *a5 = v16;
    if (v15 >= 1)
    {
      *v16 = *v16 & ~(0xFFFFFFFFFFFFFFFFLL >> ((v14 << 6) - v8)) | v9[v14] & (0xFFFFFFFFFFFFFFFFLL >> ((v14 << 6) - v8));
      *(a5 + 8) = v15;
    }
  }

  *a6 = v16;
  *(a6 + 8) = *(a5 + 8);
  return __src;
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AddMatchedDependencies(MIL::BuilderPrivate::OperationBuilderPrivate *a1, const MIL::Builder::OperationBuilder *a2, uint64_t *a3, uint64_t a4, MIL::Transform::_anonymous_namespace_::IndexSet *a5)
{
  Parameters = MIL::BuilderPrivate::OperationBuilderPrivate::GetParameters(a1, a2);
  v6 = *Parameters;
  v21 = Parameters + 1;
  if (*Parameters != Parameters + 1)
  {
    do
    {
      v8 = v6[7];
      v7 = v6[8];
      while (v8 != v7)
      {
        v9 = (*(**v8 + 32))();
        if (v9)
        {
          v10 = v9;
          v12 = *a3;
          v11 = a3[1];
          if (v11 == *a3)
          {
            goto LABEL_15;
          }

          v13 = (v11 - *a3) >> 4;
          do
          {
            v14 = v12 + 16 * (v13 >> 1);
            v15 = std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string>(&v26, v14, v10);
            if (v15)
            {
              v13 += ~(v13 >> 1);
            }

            else
            {
              v13 >>= 1;
            }

            if (v15)
            {
              v12 = v14 + 16;
            }
          }

          while (v13);
          if (v12 == v11 || std::__less<void,void>::operator()[abi:ne200100]<std::string,std::string_view>(&v26, v10, v12))
          {
LABEL_15:
            MIL::Builder::BlockBuilder::TryGetOperation(a4, v10, &v26);
            if (v26)
            {
              v16 = *(a2 + 1);
              v17 = *a2;
              if (*a2 != v16)
              {
                while (*v17 != v26)
                {
                  if (++v17 == v16)
                  {
                    v17 = *(a2 + 1);
                    break;
                  }
                }
              }

              if (v16 != v17)
              {
              }
            }

            if (v27)
            {
              std::__shared_weak_count::__release_shared[abi:ne200100](v27);
            }
          }
        }

        v8 += 16;
      }

      v18 = v6[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = *v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          v19 = v6[2];
          v20 = *v19 == v6;
          v6 = v19;
        }

        while (!v20);
      }

      v6 = v19;
    }

    while (v19 != v21);
  }
}

void sub_2180C2800(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a16);
  }

  _Unwind_Resume(exception_object);
}

BOOL MIL::Transform::anonymous namespace::IndexSet::Add(MIL::Transform::_anonymous_namespace_::IndexSet *this, uint64_t a2)
{
  v6 = a2;
  v2 = a2 - *this;
  if (*(this + 2) <= v2)
  {
    std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne200100]();
  }

  v4 = *(*(this + 1) + ((v2 >> 3) & 0x1FFFFFFFFFFFFFF8)) & (1 << v2);
  if (!v4)
  {
    std::vector<unsigned long long>::push_back[abi:ne200100](this + 4, &v6);
    *(*(this + 1) + (((v6 - *this) >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << (v6 - *this);
  }

  return v4 == 0;
}

uint64_t std::__less<void,void>::operator()[abi:ne200100]<std::string,std::string_view>(uint64_t a1, const void **a2, uint64_t a3)
{
  v3 = *(a2 + 23);
  if (v3 >= 0)
  {
    v4 = a2;
  }

  else
  {
    v4 = *a2;
  }

  if (v3 >= 0)
  {
    v5 = *(a2 + 23);
  }

  else
  {
    v5 = a2[1];
  }

  v6 = *a3;
  v7 = *(a3 + 8);
  if (v7 >= v5)
  {
    v8 = v5;
  }

  else
  {
    v8 = *(a3 + 8);
  }

  v9 = memcmp(v4, v6, v8);
  if (v5 < v7)
  {
    v10 = -1;
  }

  else
  {
    v10 = 1;
  }

  if (v5 == v7)
  {
    v10 = 0;
  }

  if (v9)
  {
    v10 = v9;
  }

  return v10 >> 31;
}

uint64_t std::__less<void,void>::operator()[abi:ne200100]<std::string_view,std::string>(uint64_t a1, uint64_t a2, const void **a3)
{
  v3 = *a2;
  v4 = *(a2 + 8);
  v5 = *(a3 + 23);
  if (v5 >= 0)
  {
    v6 = a3;
  }

  else
  {
    v6 = *a3;
  }

  if (v5 >= 0)
  {
    v7 = *(a3 + 23);
  }

  else
  {
    v7 = a3[1];
  }

  if (v7 >= v4)
  {
    v8 = v4;
  }

  else
  {
    v8 = v7;
  }

  v9 = memcmp(v3, v6, v8);
  if (v4 < v7)
  {
    v10 = -1;
  }

  else
  {
    v10 = 1;
  }

  if (v4 == v7)
  {
    v10 = 0;
  }

  if (v9)
  {
    v10 = v9;
  }

  return v10 >> 31;
}

void *std::__split_buffer<anonymous namespace::OldOutput>::__split_buffer(void *result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  result[3] = 0;
  result[4] = a4;
  if (a2)
  {
    if (!(a2 >> 60))
    {
      operator new();
    }

    std::__throw_bad_array_new_length[abi:ne200100]();
  }

  *result = 0;
  result[1] = 16 * a3;
  result[2] = 16 * a3;
  result[3] = 0;
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace::OldOutput *,false>(__n128 *a1, __n128 *a2, uint64_t a3, char a4, __n128 a5)
{
LABEL_1:
  v9 = a2 - 1;
  v10 = a2 - 2;
  v11 = a2 - 3;
  v12 = a1;
  while (1)
  {
    a1 = v12;
    v13 = a2 - v12;
    if (v13 > 2)
    {
      break;
    }

    if (v13 < 2)
    {
      return;
    }

    if (v13 == 2)
    {
      v64 = a2 - 1;
      v68 = a2[-1].n128_u64[0];
      if (v68 >= v12->n128_u64[0])
      {
        if (v12->n128_u64[0] >= v68)
        {
          v69 = a2[-1].n128_u64[1];
          goto LABEL_203;
        }

        return;
      }

LABEL_291:
      v155 = *v12;
      *v12 = *v64;
      *v64 = v155;
      return;
    }

LABEL_9:
    if (v13 <= 23)
    {
      v81 = v12 + 1;
      v83 = v12 == a2 || v81 == a2;
      if (a4)
      {
        if (v83)
        {
          return;
        }

        v84 = 0;
        v85 = v12;
        while (2)
        {
          v86 = v85;
          v85 = v81;
          v87 = v86[1].n128_u64[0];
          if (v87 < v86->n128_u64[0])
          {
            v88 = v86[1].n128_u64[1];
            goto LABEL_221;
          }

          if (v86->n128_u64[0] >= v87)
          {
            v88 = v86[1].n128_u64[1];
            if (v88 < v86->n128_u64[1])
            {
LABEL_221:
              *v85 = *v86;
              v89 = v12;
              if (v86 != v12)
              {
                v90 = v84;
                while (1)
                {
                  v91 = (v12->n128_u64 + v90);
                  v92 = *(v12[-1].n128_u64 + v90);
                  if (v87 >= v92)
                  {
                    if (v92 < v87)
                    {
                      v89 = (v12 + v90);
                      goto LABEL_233;
                    }

                    if (v88 >= *(v91 - 1))
                    {
                      break;
                    }
                  }

                  --v86;
                  *v91 = *(&v12[-1] + v90);
                  v90 -= 16;
                  if (!v90)
                  {
                    v89 = v12;
                    goto LABEL_233;
                  }
                }

                v89 = v86;
              }

LABEL_233:
              v89->n128_u64[0] = v87;
              v89->n128_u64[1] = v88;
            }
          }

          v81 = v85 + 1;
          v84 += 16;
          if (&v85[1] == a2)
          {
            return;
          }

          continue;
        }
      }

      if (v83)
      {
        return;
      }

      while (2)
      {
        v126 = a1;
        a1 = v81;
        v127 = v126[1].n128_u64[0];
        if (v127 >= v126->n128_u64[0])
        {
          if (v126->n128_u64[0] >= v127)
          {
            v128 = v126[1].n128_u64[1];
            if (v128 < v126->n128_u64[1])
            {
              goto LABEL_298;
            }
          }
        }

        else
        {
          v128 = v126[1].n128_u64[1];
          do
          {
            do
            {
LABEL_298:
              v129 = v126;
              v126[1] = *v126;
              v131 = v126[-1].n128_u64[0];
              --v126;
              v130 = v131;
            }

            while (v127 < v131);
          }

          while (v130 >= v127 && v128 < v129[-1].n128_u64[1]);
          v129->n128_u64[0] = v127;
          v129->n128_u64[1] = v128;
        }

        v81 = a1 + 1;
        if (&a1[1] == a2)
        {
          return;
        }

        continue;
      }
    }

    if (!a3)
    {
      if (v12 == a2)
      {
        return;
      }

      v93 = (v13 - 2) >> 1;
      v94 = v93;
      do
      {
        v95 = v94;
        if (v93 >= v94)
        {
          v96 = (2 * v94) | 1;
          v97 = &v12[v96];
          if (2 * v95 + 2 < v13)
          {
            v98 = v97[1].n128_u64[0];
            if (v97->n128_u64[0] < v98 || v98 >= v97->n128_u64[0] && v97->n128_u64[1] < v97[1].n128_u64[1])
            {
              ++v97;
              v96 = 2 * v95 + 2;
            }
          }

          v99 = &v12[v95];
          v100 = v99->n128_u64[0];
          if (v97->n128_u64[0] >= v99->n128_u64[0])
          {
            v101 = v99->n128_u64[1];
            if (v100 < v97->n128_u64[0] || v97->n128_u64[1] >= v101)
            {
              *v99 = *v97;
              if (v93 >= v96)
              {
                while (1)
                {
                  v103 = 2 * v96;
                  v96 = (2 * v96) | 1;
                  v102 = &v12[v96];
                  v104 = v103 + 2;
                  if (v104 < v13)
                  {
                    v105 = v102[1].n128_u64[0];
                    if (v102->n128_u64[0] < v105 || v105 >= v102->n128_u64[0] && v102->n128_u64[1] < v102[1].n128_u64[1])
                    {
                      ++v102;
                      v96 = v104;
                    }
                  }

                  if (v102->n128_u64[0] < v100 || v100 >= v102->n128_u64[0] && v102->n128_u64[1] < v101)
                  {
                    break;
                  }

                  *v97 = *v102;
                  v97 = v102;
                  if (v93 < v96)
                  {
                    goto LABEL_249;
                  }
                }
              }

              v102 = v97;
LABEL_249:
              v102->n128_u64[0] = v100;
              v102->n128_u64[1] = v101;
            }
          }
        }

        v94 = v95 - 1;
      }

      while (v95);
      while (2)
      {
        v107 = 0;
        v154 = *v12;
        v108 = v12;
        do
        {
          v109 = v108;
          v110 = &v108[v107];
          v108 = v110 + 1;
          v111 = 2 * v107;
          v107 = (2 * v107) | 1;
          v112 = v111 + 2;
          if (v112 < v13)
          {
            v113 = v110[2].n128_u64[0];
            v114 = v110[1].n128_u64[0];
            if (v114 < v113 || v113 >= v114 && v110[1].n128_u64[1] < v110[2].n128_u64[1])
            {
              v108 = v110 + 2;
              v107 = v112;
            }
          }

          *v109 = *v108;
        }

        while (v107 <= ((v13 - 2) >> 1));
        if (v108 == --a2)
        {
          *v108 = v154;
        }

        else
        {
          *v108 = *a2;
          *a2 = v154;
          v115 = (v108 - v12 + 16) >> 4;
          v116 = v115 - 2;
          if (v115 >= 2)
          {
            v117 = v116 >> 1;
            v118 = &v12[v116 >> 1];
            v119 = v108->n128_u64[0];
            if (v118->n128_u64[0] < v108->n128_u64[0])
            {
              v106 = v108->n128_u64[1];
              goto LABEL_276;
            }

            if (v119 >= v118->n128_u64[0])
            {
              v106 = v108->n128_u64[1];
              if (v118->n128_u64[1] < v106)
              {
LABEL_276:
                *v108 = *v118;
                if (v116 >= 2)
                {
                  while (1)
                  {
                    v121 = v117 - 1;
                    v117 = (v117 - 1) >> 1;
                    v120 = &v12[v117];
                    if (v120->n128_u64[0] >= v119 && (v119 < v120->n128_u64[0] || v120->n128_u64[1] >= v106))
                    {
                      break;
                    }

                    *v118 = *v120;
                    v118 = &v12[v117];
                    if (v121 <= 1)
                    {
                      goto LABEL_282;
                    }
                  }
                }

                v120 = v118;
LABEL_282:
                v120->n128_u64[0] = v119;
                v120->n128_u64[1] = v106;
              }
            }
          }
        }

        if (v13-- <= 2)
        {
          return;
        }

        continue;
      }
    }

    v14 = &v12[v13 >> 1];
    v15 = v14;
    if (v13 >= 0x81)
    {
      v16 = v14->n128_u64[0];
      if (v14->n128_u64[0] < v12->n128_u64[0] || v12->n128_u64[0] >= v16 && v14->n128_u64[1] < v12->n128_u64[1])
      {
        if (v9->n128_u64[0] < v16 || v16 >= v9->n128_u64[0] && a2[-1].n128_u64[1] < v14->n128_u64[1])
        {
          v133 = *v12;
          *v12 = *v9;
        }

        else
        {
          v139 = *v12;
          *v12 = *v14;
          *v14 = v139;
          if (v9->n128_u64[0] >= v14->n128_u64[0] && (v14->n128_u64[0] < v9->n128_u64[0] || a2[-1].n128_u64[1] >= v14->n128_u64[1]))
          {
            goto LABEL_33;
          }

          v133 = *v14;
          *v14 = *v9;
        }

        *v9 = v133;
        goto LABEL_33;
      }

      if (v9->n128_u64[0] < v16 || v16 >= v9->n128_u64[0] && a2[-1].n128_u64[1] < v14->n128_u64[1])
      {
        v135 = *v14;
        *v14 = *v9;
        *v9 = v135;
        if (v14->n128_u64[0] < v12->n128_u64[0] || v12->n128_u64[0] >= v14->n128_u64[0] && v14->n128_u64[1] < v12->n128_u64[1])
        {
          v136 = *v12;
          *v12 = *v14;
          *v14 = v136;
        }
      }

LABEL_33:
      v18 = v12 + 1;
      v19 = v12[1].n128_u64[0];
      v20 = v14 - 1;
      v21 = v14[-1].n128_u64[0];
      if (v21 < v19 || v19 >= v21 && v14[-1].n128_u64[1] < v12[1].n128_u64[1])
      {
        if (v10->n128_u64[0] < v21 || v21 >= v10->n128_u64[0] && a2[-2].n128_u64[1] < v14[-1].n128_u64[1])
        {
          v22 = *v18;
          *v18 = *v10;
        }

        else
        {
          v24 = *v18;
          *v18 = *v20;
          *v20 = v24;
          if (v10->n128_u64[0] >= v20->n128_u64[0] && (v20->n128_u64[0] < v10->n128_u64[0] || a2[-2].n128_u64[1] >= v14[-1].n128_u64[1]))
          {
            goto LABEL_51;
          }

          v142 = *v20;
          *v20 = *v10;
          v22 = v142;
        }

        *v10 = v22;
        goto LABEL_51;
      }

      if (v10->n128_u64[0] < v21 || v21 >= v10->n128_u64[0] && a2[-2].n128_u64[1] < v14[-1].n128_u64[1])
      {
        v140 = *v20;
        *v20 = *v10;
        *v10 = v140;
        if (v20->n128_u64[0] < v18->n128_u64[0] || v18->n128_u64[0] >= v20->n128_u64[0] && v14[-1].n128_u64[1] < v12[1].n128_u64[1])
        {
          v23 = *v18;
          *v18 = *v20;
          *v20 = v23;
        }
      }

LABEL_51:
      v25 = v12 + 2;
      v26 = v12[2].n128_u64[0];
      v29 = v14[1].n128_u64[0];
      v27 = v14 + 1;
      v28 = v29;
      if (v29 < v26 || v26 >= v28 && v27->n128_u64[1] < v12[2].n128_u64[1])
      {
        if (v11->n128_u64[0] < v28 || v28 >= v11->n128_u64[0] && a2[-3].n128_u64[1] < v27->n128_u64[1])
        {
          v30 = *v25;
          *v25 = *v11;
        }

        else
        {
          v32 = *v25;
          *v25 = *v27;
          *v27 = v32;
          if (v11->n128_u64[0] >= v27->n128_u64[0] && (v27->n128_u64[0] < v11->n128_u64[0] || a2[-3].n128_u64[1] >= v27->n128_u64[1]))
          {
            goto LABEL_64;
          }

          v144 = *v27;
          *v27 = *v11;
          v30 = v144;
        }

        *v11 = v30;
        goto LABEL_64;
      }

      if (v11->n128_u64[0] < v28 || v28 >= v11->n128_u64[0] && a2[-3].n128_u64[1] < v27->n128_u64[1])
      {
        v143 = *v27;
        *v27 = *v11;
        *v11 = v143;
        if (v27->n128_u64[0] < v25->n128_u64[0] || v25->n128_u64[0] >= v27->n128_u64[0] && v27->n128_u64[1] < v12[2].n128_u64[1])
        {
          v31 = *v25;
          *v25 = *v27;
          *v27 = v31;
        }
      }

LABEL_64:
      v33 = v15->n128_u64[0];
      if (v15->n128_u64[0] >= v20->n128_u64[0] && (v20->n128_u64[0] < v33 || v15->n128_u64[1] >= v20->n128_u64[1]))
      {
        if (v27->n128_u64[0] < v33 || v33 >= v27->n128_u64[0] && v27->n128_u64[1] < v15->n128_u64[1])
        {
          v146 = *v15;
          *v15 = *v27;
          *v27 = v146;
          if (v15->n128_u64[0] < v20->n128_u64[0] || v20->n128_u64[0] >= v15->n128_u64[0] && v15->n128_u64[1] < v20->n128_u64[1])
          {
            v147 = *v20;
            *v20 = *v15;
            *v15 = v147;
          }
        }

        goto LABEL_77;
      }

      if (v27->n128_u64[0] < v33 || v33 >= v27->n128_u64[0] && v27->n128_u64[1] < v15->n128_u64[1])
      {
        v145 = *v20;
        *v20 = *v27;
      }

      else
      {
        v148 = *v20;
        *v20 = *v15;
        *v15 = v148;
        if (v27->n128_u64[0] >= v15->n128_u64[0] && (v15->n128_u64[0] < v27->n128_u64[0] || v27->n128_u64[1] >= v15->n128_u64[1]))
        {
          goto LABEL_77;
        }

        v145 = *v15;
        *v15 = *v27;
      }

      *v27 = v145;
LABEL_77:
      v149 = *v12;
      *v12 = *v15;
      a5 = v149;
      *v15 = v149;
      goto LABEL_78;
    }

    v17 = v12->n128_u64[0];
    if (v12->n128_u64[0] >= v15->n128_u64[0] && (v15->n128_u64[0] < v17 || v12->n128_u64[1] >= v15->n128_u64[1]))
    {
      if (v9->n128_u64[0] < v17 || v17 >= v9->n128_u64[0] && a2[-1].n128_u64[1] < v12->n128_u64[1])
      {
        v137 = *v12;
        *v12 = *v9;
        a5 = v137;
        *v9 = v137;
        if (v12->n128_u64[0] < v15->n128_u64[0] || v15->n128_u64[0] >= v12->n128_u64[0] && v12->n128_u64[1] < v15->n128_u64[1])
        {
          v138 = *v15;
          *v15 = *v12;
          a5 = v138;
          *v12 = v138;
        }
      }

      goto LABEL_78;
    }

    if (v9->n128_u64[0] < v17 || v17 >= v9->n128_u64[0] && a2[-1].n128_u64[1] < v12->n128_u64[1])
    {
      v134 = *v15;
      *v15 = *v9;
    }

    else
    {
      v141 = *v15;
      *v15 = *v12;
      a5 = v141;
      *v12 = v141;
      if (v9->n128_u64[0] >= v12->n128_u64[0] && (v12->n128_u64[0] < v9->n128_u64[0] || a2[-1].n128_u64[1] >= v12->n128_u64[1]))
      {
        goto LABEL_78;
      }

      v134 = *v12;
      *v12 = *v9;
    }

    a5 = v134;
    *v9 = v134;
LABEL_78:
    --a3;
    v34 = v12->n128_u64[0];
    if ((a4 & 1) != 0 || (v35 = v12[-1].n128_u64[0], v35 < v34) || (v36 = v12->n128_u64[1], v34 >= v35) && v12[-1].n128_u64[1] < v36)
    {
      v37 = 0;
      v38 = v12->n128_u64[1];
      while (1)
      {
        v39 = v12[v37 + 1].n128_u64[0];
        if (v39 >= v34 && (v34 < v39 || v12[v37 + 1].n128_u64[1] >= v38))
        {
          break;
        }

        ++v37;
      }

      n128_u64 = v12[v37 + 1].n128_u64;
      if (v37 * 16)
      {
        v41 = v9->n128_u64[0];
        for (i = a2 - 1; v41 >= v34 && (v34 < v41 || i->n128_u64[1] >= v38); --i)
        {
          v43 = i[-1].n128_u64[0];
          v41 = v43;
        }
      }

      else
      {
        i = a2;
        if (n128_u64 < a2)
        {
          v44 = v9->n128_u64[0];
          i = a2 - 1;
          if (v9->n128_u64[0] >= v34)
          {
            i = a2 - 1;
            do
            {
              if (v34 >= v44)
              {
                if (n128_u64 >= i || i->n128_u64[1] < v38)
                {
                  break;
                }
              }

              else if (n128_u64 >= i)
              {
                break;
              }

              v45 = i[-1].n128_u64[0];
              --i;
              v44 = v45;
            }

            while (v45 >= v34);
          }
        }
      }

      v12 = n128_u64;
      if (n128_u64 < i)
      {
        v46 = i;
        do
        {
          v150 = *v12;
          *v12 = *v46;
          a5 = v150;
          *v46 = v150;
          do
          {
            do
            {
              v48 = v12[1].n128_u64[0];
              ++v12;
              v47 = v48;
            }

            while (v48 < v34);
          }

          while (v34 >= v47 && v12->n128_u64[1] < v38);
          do
          {
            v50 = v46[-1].n128_u64[0];
            --v46;
            v49 = v50;
          }

          while (v50 >= v34 && (v34 < v49 || v46->n128_u64[1] >= v38));
        }

        while (v12 < v46);
      }

      v51 = v12 - 1;
      if (&v12[-1] != a1)
      {
        a5 = *v51;
        *a1 = *v51;
      }

      v12[-1].n128_u64[0] = v34;
      v12[-1].n128_u64[1] = v38;
      if (n128_u64 < i)
      {
        goto LABEL_117;
      }

      {
        a2 = v12 - 1;
        if (v52)
        {
          return;
        }

        goto LABEL_1;
      }

      if (!v52)
      {
LABEL_117:
        a4 = 0;
      }
    }

    else
    {
      v54 = v9->n128_u64[0];
      if (v34 < v9->n128_u64[0] || v54 >= v34 && v36 < a2[-1].n128_u64[1])
      {
        do
        {
          v56 = v12[1].n128_u64[0];
          ++v12;
          v55 = v56;
        }

        while (v34 >= v56 && (v55 < v34 || v36 >= v12->n128_u64[1]));
      }

      else
      {
          ;
        }
      }

      j = a2;
      if (v12 < a2)
      {
        for (j = a2 - 1; v34 < v54 || v54 >= v34 && v36 < j->n128_u64[1]; --j)
        {
          v58 = j[-1].n128_u64[0];
          v54 = v58;
        }
      }

      while (v12 < j)
      {
        v151 = *v12;
        *v12 = *j;
        a5 = v151;
        *j = v151;
        do
        {
          v60 = v12[1].n128_u64[0];
          ++v12;
          v59 = v60;
        }

        while (v34 >= v60 && (v59 < v34 || v36 >= v12->n128_u64[1]));
        do
        {
          do
          {
            v62 = j[-1].n128_u64[0];
            --j;
            v61 = v62;
          }

          while (v34 < v62);
        }

        while (v61 >= v34 && v36 < j->n128_u64[1]);
      }

      v63 = v12 - 1;
      if (&v12[-1] != a1)
      {
        a5 = *v63;
        *a1 = *v63;
      }

      a4 = 0;
      v12[-1].n128_u64[0] = v34;
      v12[-1].n128_u64[1] = v36;
    }
  }

  if (v13 != 3)
  {
    if (v13 == 4)
    {

      return;
    }

    if (v13 == 5)
    {
      v70 = a2 - 1;
      v71 = a2[-1].n128_u64[0];
      v72 = v12[3].n128_u64[0];
      if (v71 < v72 || v72 >= v71 && a2[-1].n128_u64[1] < v12[3].n128_u64[1])
      {
        v73 = v12[3];
        v12[3] = *v70;
        *v70 = v73;
        v74 = v12[3].n128_u64[0];
        v75 = v12[2].n128_u64[0];
        if (v74 < v75 || v75 >= v74 && v12[3].n128_u64[1] < v12[2].n128_u64[1])
        {
          v76 = v12[2];
          v12[2] = v12[3];
          v12[3] = v76;
          v77 = v12[2].n128_u64[0];
          v78 = v12[1].n128_u64[0];
          if (v77 < v78 || v78 >= v77 && v12[2].n128_u64[1] < v12[1].n128_u64[1])
          {
            v79 = v12[1];
            v12[1] = v12[2];
            v12[2] = v79;
            v80 = v12[1].n128_u64[0];
            if (v80 < v12->n128_u64[0] || v12->n128_u64[0] >= v80 && v12[1].n128_u64[1] < v12->n128_u64[1])
            {
              v153 = *v12;
              *v12 = v12[1];
              v12[1] = v153;
            }
          }
        }
      }

      return;
    }

    goto LABEL_9;
  }

  v64 = v12 + 1;
  v65 = v12[1].n128_u64[0];
  if (v65 < v12->n128_u64[0] || v12->n128_u64[0] >= v65 && v12[1].n128_u64[1] < v12->n128_u64[1])
  {
    v66 = a2[-1].n128_u64[0];
    if (v66 < v65 || v65 >= v66 && a2[-1].n128_u64[1] < v12[1].n128_u64[1])
    {
      v152 = *v12;
      *v12 = *v9;
      v67 = v152;
    }

    else
    {
      v156 = *v12;
      *v12 = *v64;
      *v64 = v156;
      v132 = v12[1].n128_u64[0];
      if (v9->n128_u64[0] >= v132 && (v132 < v9->n128_u64[0] || a2[-1].n128_u64[1] >= v12[1].n128_u64[1]))
      {
        return;
      }

      v67 = *v64;
      *v64 = *v9;
    }

    *v9 = v67;
    return;
  }

  v123 = a2[-1].n128_u64[0];
  if (v123 < v65 || v65 >= v123 && a2[-1].n128_u64[1] < v12[1].n128_u64[1])
  {
    v124 = *v64;
    *v64 = *v9;
    *v9 = v124;
    v125 = v12[1].n128_u64[0];
    if (v125 < v12->n128_u64[0])
    {
      goto LABEL_291;
    }

    if (v12->n128_u64[0] >= v125)
    {
      v69 = v12[1].n128_u64[1];
LABEL_203:
      if (v69 < v12->n128_u64[1])
      {
        goto LABEL_291;
      }
    }
  }
}

__n128 std::__sort4[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace::OldOutput *,0>(__n128 *a1, unint64_t *a2, __n128 *a3, __n128 *a4, __n128 result)
{
  v5 = *a2;
  if (*a2 < a1->n128_u64[0] || a1->n128_u64[0] >= v5 && a2[1] < a1->n128_u64[1])
  {
    if (a3->n128_u64[0] < v5 || v5 >= a3->n128_u64[0] && a3->n128_u64[1] < a2[1])
    {
      result = *a1;
      *a1 = *a3;
    }

    else
    {
      result = *a1;
      *a1 = *a2;
      *a2 = result;
      if (a3->n128_u64[0] >= *a2 && (*a2 < a3->n128_u64[0] || a3->n128_u64[1] >= a2[1]))
      {
        goto LABEL_14;
      }

      result = *a2;
      *a2 = *a3;
    }

    *a3 = result;
  }

  else if (a3->n128_u64[0] < v5 || v5 >= a3->n128_u64[0] && a3->n128_u64[1] < a2[1])
  {
    result = *a2;
    *a2 = *a3;
    *a3 = result;
    if (*a2 < a1->n128_u64[0] || a1->n128_u64[0] >= *a2 && a2[1] < a1->n128_u64[1])
    {
      result = *a1;
      *a1 = *a2;
      *a2 = result;
    }
  }

LABEL_14:
  if (a4->n128_u64[0] < a3->n128_u64[0] || a3->n128_u64[0] >= a4->n128_u64[0] && a4->n128_u64[1] < a3->n128_u64[1])
  {
    result = *a3;
    *a3 = *a4;
    *a4 = result;
    if (a3->n128_u64[0] < *a2 || *a2 >= a3->n128_u64[0] && a3->n128_u64[1] < a2[1])
    {
      result = *a2;
      *a2 = *a3;
      *a3 = result;
      if (*a2 < a1->n128_u64[0] || a1->n128_u64[0] >= *a2 && a2[1] < a1->n128_u64[1])
      {
        result = *a1;
        *a1 = *a2;
        *a2 = result;
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace::OldOutput *>(__n128 *a1, __n128 *a2, __n128 a3)
{
  v5 = a2 - a1;
  if (v5 > 2)
  {
    switch(v5)
    {
      case 3:
        v6 = a1 + 1;
        v21 = a1[1].n128_u64[0];
        v22 = a2 - 1;
        if (v21 < a1->n128_u64[0] || a1->n128_u64[0] >= v21 && a1[1].n128_u64[1] < a1->n128_u64[1])
        {
          v23 = a2[-1].n128_u64[0];
          if (v23 < v21 || v21 >= v23 && a2[-1].n128_u64[1] < a1[1].n128_u64[1])
          {
            v24 = *a1;
            *a1 = *v22;
          }

          else
          {
            v38 = *a1;
            *a1 = *v6;
            *v6 = v38;
            v39 = a1[1].n128_u64[0];
            if (v22->n128_u64[0] >= v39 && (v39 < v22->n128_u64[0] || a2[-1].n128_u64[1] >= a1[1].n128_u64[1]))
            {
              return 1;
            }

            v24 = *v6;
            *v6 = *v22;
          }

          *v22 = v24;
          return 1;
        }

        v31 = a2[-1].n128_u64[0];
        if (v31 >= v21 && (v21 < v31 || a2[-1].n128_u64[1] >= a1[1].n128_u64[1]))
        {
          return 1;
        }

        v32 = *v6;
        *v6 = *v22;
        *v22 = v32;
        v33 = a1[1].n128_u64[0];
        if (v33 >= a1->n128_u64[0])
        {
          if (a1->n128_u64[0] < v33)
          {
            return 1;
          }

          v8 = a1[1].n128_u64[1];
          goto LABEL_7;
        }

LABEL_28:
        v34 = *a1;
        *a1 = *v6;
        *v6 = v34;
        return 1;
      case 4:
        return 1;
      case 5:
        v9 = a2 - 1;
        v10 = a2[-1].n128_u64[0];
        v11 = a1[3].n128_u64[0];
        if (v10 < v11 || v11 >= v10 && a2[-1].n128_u64[1] < a1[3].n128_u64[1])
        {
          v12 = a1[3];
          a1[3] = *v9;
          *v9 = v12;
          v13 = a1[3].n128_u64[0];
          v14 = a1[2].n128_u64[0];
          if (v13 < v14 || v14 >= v13 && a1[3].n128_u64[1] < a1[2].n128_u64[1])
          {
            v15 = a1[2];
            a1[2] = a1[3];
            a1[3] = v15;
            v16 = a1[2].n128_u64[0];
            v17 = a1[1].n128_u64[0];
            if (v16 < v17 || v17 >= v16 && a1[2].n128_u64[1] < a1[1].n128_u64[1])
            {
              v18 = a1[1];
              a1[1] = a1[2];
              a1[2] = v18;
              v19 = a1[1].n128_u64[0];
              if (v19 < a1->n128_u64[0] || a1->n128_u64[0] >= v19 && a1[1].n128_u64[1] < a1->n128_u64[1])
              {
                v20 = *a1;
                *a1 = a1[1];
                a1[1] = v20;
              }
            }
          }
        }

        return 1;
    }

LABEL_20:
    v25 = a1 + 2;
    v26 = a1->n128_u64[0];
    v27 = a1 + 1;
    v28 = a1[1].n128_u64[0];
    if (v28 >= a1->n128_u64[0] && (v26 < v28 || a1[1].n128_u64[1] >= a1->n128_u64[1]))
    {
      v35 = a1[2].n128_u64[0];
      if (v35 < v28 || v28 >= v35 && a1[2].n128_u64[1] < a1[1].n128_u64[1])
      {
        v36 = *v27;
        *v27 = *v25;
        *v25 = v36;
        if (v27->n128_u64[0] < v26 || v26 >= v27->n128_u64[0] && a1[1].n128_u64[1] < a1->n128_u64[1])
        {
          v37 = *a1;
          *a1 = *v27;
          *v27 = v37;
        }
      }

      goto LABEL_47;
    }

    v29 = a1[2].n128_u64[0];
    if (v29 < v28 || v28 >= v29 && a1[2].n128_u64[1] < a1[1].n128_u64[1])
    {
      v30 = *a1;
      *a1 = *v25;
    }

    else
    {
      v40 = *a1;
      *a1 = *v27;
      *v27 = v40;
      v41 = a1[1].n128_u64[0];
      if (v29 >= v41 && (v41 < v29 || a1[2].n128_u64[1] >= a1[1].n128_u64[1]))
      {
        goto LABEL_47;
      }

      v30 = *v27;
      *v27 = *v25;
    }

    *v25 = v30;
LABEL_47:
    v42 = a1 + 3;
    if (&a1[3] == a2)
    {
      return 1;
    }

    v43 = 0;
    v44 = 0;
    while (1)
    {
      v45 = v42->n128_u64[0];
      if (v42->n128_u64[0] >= v25->n128_u64[0])
      {
        if (v25->n128_u64[0] < v45)
        {
          goto LABEL_62;
        }

        v46 = v42->n128_u64[1];
        if (v46 >= v25->n128_u64[1])
        {
          goto LABEL_62;
        }
      }

      else
      {
        v46 = v42->n128_u64[1];
      }

      *v42 = *v25;
      v47 = v43;
      while (1)
      {
        v48 = (a1 + v47);
        v49 = *(a1[1].n128_u64 + v47);
        if (v45 >= v49 && (v49 < v45 || v46 >= v48[1].n128_u64[1]))
        {
          break;
        }

        v48[2] = *(a1 + v47 + 16);
        v47 -= 16;
        if (v47 == -32)
        {
          v50 = a1;
          goto LABEL_61;
        }
      }

      v50 = (a1 + v47 + 32);
LABEL_61:
      v50->n128_u64[0] = v45;
      v50->n128_u64[1] = v46;
      if (++v44 == 8)
      {
        return &v42[1] == a2;
      }

LABEL_62:
      v25 = v42;
      v43 += 16;
      if (++v42 == a2)
      {
        return 1;
      }
    }
  }

  if (v5 < 2)
  {
    return 1;
  }

  if (v5 != 2)
  {
    goto LABEL_20;
  }

  v6 = a2 - 1;
  v7 = a2[-1].n128_u64[0];
  if (v7 < a1->n128_u64[0])
  {
    goto LABEL_28;
  }

  if (a1->n128_u64[0] >= v7)
  {
    v8 = a2[-1].n128_u64[1];
LABEL_7:
    if (v8 >= a1->n128_u64[1])
    {
      return 1;
    }

    goto LABEL_28;
  }

  return 1;
}