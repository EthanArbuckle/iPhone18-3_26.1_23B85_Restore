uint64_t *std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,anonymous namespace::reorderRigBones(FIK::MoCapRig &)::$_0 &,FIK::IKArrayIterator<FIK::MoCapBone>,0>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  v7 = result;
  v8 = *a2;
  v9 = *a3;
  if (*a2 >= *result)
  {
    if (v9 < v8)
    {
      result = std::swap[abi:nn200100]<FIK::MoCapBone>(a2, a3);
      if (*a2 < *v7)
      {
        result = v7;
        v10 = a2;
        goto LABEL_9;
      }
    }
  }

  else
  {
    if (v9 < v8)
    {
LABEL_5:
      v10 = a3;
LABEL_9:
      result = std::swap[abi:nn200100]<FIK::MoCapBone>(result, v10);
      goto LABEL_10;
    }

    result = std::swap[abi:nn200100]<FIK::MoCapBone>(result, a2);
    if (*a3 < *a2)
    {
      result = a2;
      goto LABEL_5;
    }
  }

LABEL_10:
  if (*a4 < *a3)
  {
    result = std::swap[abi:nn200100]<FIK::MoCapBone>(a3, a4);
    if (*a3 < *a2)
    {
      result = std::swap[abi:nn200100]<FIK::MoCapBone>(a2, a3);
      if (*a2 < *v7)
      {

        return std::swap[abi:nn200100]<FIK::MoCapBone>(v7, a2);
      }
    }
  }

  return result;
}

uint64_t std::__partial_sort[abi:nn200100]<std::_ClassicAlgPolicy,anonymous namespace::reorderRigBones(FIK::MoCapRig &)::$_0 &,FIK::IKArrayIterator<FIK::MoCapBone>,FIK::IKArrayIterator<FIK::MoCapBone>>(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  v3 = a2 - result;
  if (a2 != result)
  {
    v5 = a2;
    v6 = result;
    if (v3 >= 545)
    {
      v7 = (0xF0F0F0F0F0F0F0F1 * (v3 >> 5) - 2) >> 1;
      v8 = v7 + 1;
      v9 = (result + 544 * v7);
      do
      {
        v9 -= 68;
        --v8;
      }

      while (v8);
    }

    if (v5 != a3)
    {
      v10 = v5;
      do
      {
        if (*v10 < *v6)
        {
          std::swap[abi:nn200100]<FIK::MoCapBone>(v10, v6);
        }

        v10 += 68;
      }

      while (v10 != a3);
    }

    if (v3 >= 545)
    {
      v11 = 0xF0F0F0F0F0F0F0F1 * (v3 >> 5);
      do
      {
        v80 = *v6;
        IKString::IKString(v81, (v6 + 8), *(v6 + 24));
        IKString::IKString(&v83, (v6 + 32), *(v6 + 48));
        v12 = *(v6 + 80);
        v86 = *(v6 + 64);
        v87 = v12;
        v13 = *(v6 + 96);
        v14 = *(v6 + 112);
        v90 = *(v6 + 128);
        v88 = v13;
        v89 = v14;
        v15 = *(v6 + 160);
        v91 = *(v6 + 144);
        v92 = v15;
        v16 = *(v6 + 192);
        v93 = *(v6 + 176);
        v94 = v16;
        v17 = *(v6 + 224);
        v95 = *(v6 + 208);
        v96 = v17;
        v97 = *(v6 + 240);
        IKString::IKString(&v98, (v6 + 256), *(v6 + 272));
        v18 = 0;
        v101 = *(v6 + 280);
        v19 = *(v6 + 304);
        v102 = *(v6 + 288);
        v20 = *(v6 + 336);
        v104 = *(v6 + 320);
        v103 = v19;
        v105 = v20;
        v21 = *(v6 + 352);
        v107 = *(v6 + 368);
        v106 = v21;
        v108 = *(v6 + 384);
        v22 = *(v6 + 416);
        v109 = *(v6 + 400);
        *(v6 + 416) = 0;
        *(v6 + 424) = 0;
        v23 = *(v6 + 432);
        v24 = *(v6 + 448);
        *(v6 + 432) = 0;
        v110 = v22;
        v111 = v23;
        v112 = v24;
        v113 = *(v6 + 464);
        v114 = *(v6 + 480);
        v25 = *(v6 + 512);
        v115 = *(v6 + 496);
        v116 = v25;
        v26 = v6;
        v117 = *(v6 + 528);
        do
        {
          v27 = v26 + 544 * v18 + 544;
          v28 = (2 * v18) | 1;
          v29 = 2 * v18 + 2;
          if (v29 < v11 && *v27 < *(v27 + 544))
          {
            v27 += 544;
            v28 = v29;
          }

          *v26 = *v27;
          IKString::operator=((v26 + 8), v27 + 8);
          IKString::operator=((v26 + 32), v27 + 32);
          *(v26 + 64) = *(v27 + 64);
          *(v26 + 80) = *(v27 + 80);
          v31 = *(v27 + 96);
          v30 = *(v27 + 112);
          *(v26 + 128) = *(v27 + 128);
          *(v26 + 96) = v31;
          *(v26 + 112) = v30;
          *(v26 + 144) = *(v27 + 144);
          *(v26 + 160) = *(v27 + 160);
          *(v26 + 176) = *(v27 + 176);
          *(v26 + 192) = *(v27 + 192);
          *(v26 + 208) = *(v27 + 208);
          *(v26 + 224) = *(v27 + 224);
          *(v26 + 240) = *(v27 + 240);
          IKString::operator=((v26 + 256), v27 + 256);
          *(v26 + 280) = *(v27 + 280);
          *(v26 + 288) = *(v27 + 288);
          *(v26 + 304) = *(v27 + 304);
          *(v26 + 320) = *(v27 + 320);
          *(v26 + 336) = *(v27 + 336);
          v32 = *(v27 + 368);
          *(v26 + 352) = *(v27 + 352);
          *(v26 + 368) = v32;
          *(v26 + 384) = *(v27 + 384);
          *(v26 + 400) = *(v27 + 400);
          FIK::IKArray<IKString>::operator=((v26 + 416), (v27 + 416));
          *(v26 + 448) = *(v27 + 448);
          *(v26 + 464) = *(v27 + 464);
          *(v26 + 480) = *(v27 + 480);
          *(v26 + 496) = *(v27 + 496);
          *(v26 + 512) = *(v27 + 512);
          *(v26 + 528) = *(v27 + 528);
          v26 = v27;
          v18 = v28;
        }

        while (v28 <= ((v11 - 2) >> 1));
        v33 = v5 - 68;
        if (v27 == v5 - 68)
        {
          *v27 = v80;
          IKString::operator=((v27 + 8), v81);
          IKString::operator=((v27 + 32), &v83);
          *(v27 + 64) = v86;
          *(v27 + 80) = v87;
          v73 = v88;
          v72 = v89;
          *(v27 + 128) = v90;
          *(v27 + 96) = v73;
          *(v27 + 112) = v72;
          *(v27 + 144) = v91;
          *(v27 + 160) = v92;
          *(v27 + 176) = v93;
          *(v27 + 192) = v94;
          *(v27 + 208) = v95;
          *(v27 + 224) = v96;
          *(v27 + 240) = v97;
          IKString::operator=((v27 + 256), &v98);
          *(v27 + 280) = v101;
          *(v27 + 288) = v102;
          *(v27 + 304) = v103;
          *(v27 + 320) = v104;
          *(v27 + 336) = v105;
          v74 = v107;
          *(v27 + 352) = v106;
          *(v27 + 368) = v74;
          *(v27 + 384) = v108;
          *(v27 + 400) = v109;
          v75 = v110;
          v76 = v111;
          v110 = 0uLL;
          *&v111 = 0;
          v77 = *(v27 + 416);
          v78 = *(v27 + 432);
          *(v27 + 416) = v75;
          *(v27 + 432) = v76;
          v118 = v77;
          v119 = v78;
          FIK::IKArray<IKString>::~IKArray(&v118);
          *(v27 + 448) = v112;
          *(v27 + 464) = v113;
          *(v27 + 480) = v114;
          *(v27 + 496) = v115;
          *(v27 + 512) = v116;
          *(v27 + 528) = v117;
        }

        else
        {
          *v27 = *v33;
          IKString::operator=((v27 + 8), (v5 - 67));
          IKString::operator=((v27 + 32), (v5 - 64));
          *(v27 + 64) = *(v5 - 30);
          *(v27 + 80) = *(v5 - 29);
          v35 = *(v5 - 28);
          v34 = *(v5 - 27);
          *(v27 + 128) = *(v5 - 52);
          *(v27 + 96) = v35;
          *(v27 + 112) = v34;
          *(v27 + 144) = *(v5 - 25);
          *(v27 + 160) = *(v5 - 24);
          *(v27 + 176) = *(v5 - 23);
          *(v27 + 192) = *(v5 - 22);
          *(v27 + 208) = *(v5 - 21);
          *(v27 + 224) = *(v5 - 20);
          *(v27 + 240) = *(v5 - 19);
          IKString::operator=((v27 + 256), (v5 - 36));
          *(v27 + 280) = *(v5 - 66);
          *(v27 + 288) = *(v5 - 16);
          *(v27 + 304) = *(v5 - 15);
          *(v27 + 320) = *(v5 - 14);
          *(v27 + 336) = *(v5 - 13);
          v36 = *(v5 - 22);
          *(v27 + 352) = *(v5 - 12);
          *(v27 + 368) = v36;
          *(v27 + 384) = *(v5 - 20);
          *(v27 + 400) = *(v5 - 9);
          FIK::IKArray<IKString>::operator=((v27 + 416), v5 - 8);
          *(v27 + 448) = *(v5 - 6);
          *(v27 + 464) = *(v5 - 5);
          *(v27 + 480) = *(v5 - 8);
          *(v27 + 496) = *(v5 - 3);
          *(v27 + 512) = *(v5 - 2);
          *(v27 + 528) = *(v5 - 1);
          *v33 = v80;
          IKString::operator=(v5 - 67, v81);
          IKString::operator=(v5 - 64, &v83);
          *(v5 - 30) = v86;
          *(v5 - 29) = v87;
          v38 = v88;
          v37 = v89;
          *(v5 - 52) = v90;
          *(v5 - 28) = v38;
          *(v5 - 27) = v37;
          *(v5 - 25) = v91;
          *(v5 - 24) = v92;
          *(v5 - 23) = v93;
          *(v5 - 22) = v94;
          *(v5 - 21) = v95;
          *(v5 - 20) = v96;
          *(v5 - 19) = v97;
          IKString::operator=(v5 - 36, &v98);
          *(v5 - 66) = v101;
          *(v5 - 16) = v102;
          *(v5 - 15) = v103;
          *(v5 - 14) = v104;
          *(v5 - 13) = v105;
          v39 = v107;
          *(v5 - 12) = v106;
          *(v5 - 22) = v39;
          *(v5 - 20) = v108;
          *(v5 - 9) = v109;
          v40 = v110;
          v110 = 0uLL;
          v41 = *(v5 - 16);
          *(v5 - 16) = v40;
          *&v118 = v41;
          v42 = *(v5 - 15);
          *(v5 - 15) = *(&v40 + 1);
          v43 = v111;
          *&v111 = 0;
          *(&v118 + 1) = v42;
          v44 = *(v5 - 7);
          *(v5 - 7) = v43;
          v119 = v44;
          FIK::IKArray<IKString>::~IKArray(&v118);
          *(v5 - 6) = v112;
          *(v5 - 5) = v113;
          *(v5 - 8) = v114;
          *(v5 - 3) = v115;
          *(v5 - 2) = v116;
          *(v5 - 1) = v117;
          v45 = v27 - v6 + 544;
          if (v45 >= 545)
          {
            v46 = (-2 - 0xF0F0F0F0F0F0F0FLL * (v45 >> 5)) >> 1;
            v47 = v6 + 544 * v46;
            if (*v47 < *v27)
            {
              *&v118 = *v27;
              IKString::IKString(&v118 + 1, (v27 + 8), *(v27 + 24));
              IKString::IKString(&v120, (v27 + 32), *(v27 + 48));
              v48 = *(v27 + 80);
              v123 = *(v27 + 64);
              v124 = v48;
              v49 = *(v27 + 96);
              v50 = *(v27 + 112);
              v127 = *(v27 + 128);
              v125 = v49;
              v126 = v50;
              v51 = *(v27 + 160);
              v128 = *(v27 + 144);
              v129 = v51;
              v52 = *(v27 + 192);
              v130 = *(v27 + 176);
              v131 = v52;
              v53 = *(v27 + 224);
              v132 = *(v27 + 208);
              v133 = v53;
              v134 = *(v27 + 240);
              IKString::IKString(&v135, (v27 + 256), *(v27 + 272));
              v138 = *(v27 + 280);
              v54 = *(v27 + 304);
              v139 = *(v27 + 288);
              v55 = *(v27 + 336);
              v141 = *(v27 + 320);
              v140 = v54;
              v142 = v55;
              v56 = *(v27 + 352);
              v144 = *(v27 + 368);
              v143 = v56;
              v145 = *(v27 + 384);
              v57 = *(v27 + 416);
              v146 = *(v27 + 400);
              *(v27 + 416) = 0;
              *(v27 + 424) = 0;
              v58 = *(v27 + 432);
              v59 = *(v27 + 448);
              *(v27 + 432) = 0;
              v147 = v57;
              v148 = v58;
              v149 = v59;
              v150 = *(v27 + 464);
              v151 = *(v27 + 480);
              v60 = *(v27 + 512);
              v152 = *(v27 + 496);
              v153 = v60;
              v154 = *(v27 + 528);
              do
              {
                v61 = v47;
                *v27 = *v47;
                IKString::operator=((v27 + 8), v47 + 8);
                IKString::operator=((v27 + 32), v47 + 32);
                *(v27 + 64) = *(v47 + 64);
                *(v27 + 80) = *(v47 + 80);
                v63 = *(v47 + 96);
                v62 = *(v47 + 112);
                *(v27 + 128) = *(v47 + 128);
                *(v27 + 96) = v63;
                *(v27 + 112) = v62;
                *(v27 + 144) = *(v47 + 144);
                *(v27 + 160) = *(v47 + 160);
                *(v27 + 176) = *(v47 + 176);
                *(v27 + 192) = *(v47 + 192);
                *(v27 + 208) = *(v47 + 208);
                *(v27 + 224) = *(v47 + 224);
                *(v27 + 240) = *(v47 + 240);
                IKString::operator=((v27 + 256), v47 + 256);
                *(v27 + 280) = *(v47 + 280);
                *(v27 + 288) = *(v47 + 288);
                *(v27 + 304) = *(v47 + 304);
                *(v27 + 320) = *(v47 + 320);
                *(v27 + 336) = *(v47 + 336);
                v64 = *(v47 + 368);
                *(v27 + 352) = *(v47 + 352);
                *(v27 + 368) = v64;
                *(v27 + 384) = *(v47 + 384);
                *(v27 + 400) = *(v47 + 400);
                FIK::IKArray<IKString>::operator=((v27 + 416), (v47 + 416));
                *(v27 + 448) = *(v47 + 448);
                *(v27 + 464) = *(v47 + 464);
                *(v27 + 480) = *(v47 + 480);
                *(v27 + 496) = *(v47 + 496);
                *(v27 + 512) = *(v47 + 512);
                *(v27 + 528) = *(v47 + 528);
                if (!v46)
                {
                  break;
                }

                v46 = (v46 - 1) / 2;
                v47 = v6 + 544 * v46;
                v27 = v61;
              }

              while (*v47 < v118);
              *v61 = v118;
              IKString::operator=((v61 + 8), &v118 + 8);
              IKString::operator=((v61 + 32), &v120);
              *(v61 + 64) = v123;
              *(v61 + 80) = v124;
              v66 = v125;
              v65 = v126;
              *(v61 + 128) = v127;
              *(v61 + 96) = v66;
              *(v61 + 112) = v65;
              *(v61 + 144) = v128;
              *(v61 + 160) = v129;
              *(v61 + 176) = v130;
              *(v61 + 192) = v131;
              *(v61 + 208) = v132;
              *(v61 + 224) = v133;
              *(v61 + 240) = v134;
              IKString::operator=((v61 + 256), &v135);
              *(v61 + 280) = v138;
              *(v61 + 288) = v139;
              *(v61 + 304) = v140;
              *(v61 + 320) = v141;
              *(v61 + 336) = v142;
              v67 = v144;
              *(v61 + 352) = v143;
              *(v61 + 368) = v67;
              *(v61 + 384) = v145;
              *(v61 + 400) = v146;
              v68 = v147;
              v69 = v148;
              v147 = 0uLL;
              *&v148 = 0;
              v70 = *(v61 + 416);
              v71 = *(v61 + 432);
              *(v61 + 416) = v68;
              *(v61 + 432) = v69;
              v155[0] = v70;
              v155[1] = v71;
              FIK::IKArray<IKString>::~IKArray(v155);
              *(v61 + 448) = v149;
              *(v61 + 464) = v150;
              *(v61 + 480) = v151;
              *(v61 + 496) = v152;
              *(v61 + 512) = v153;
              *(v61 + 528) = v154;
              FIK::IKArray<IKString>::~IKArray(&v147);
              if (v136)
              {
                (*(*v137 + 24))(v137, v135, 0, 8);
                v135 = 0;
                v136 = 0;
              }

              if (v121)
              {
                (*(*v122 + 24))(v122, v120, 0, 8);
                v120 = 0;
                v121 = 0;
              }

              if (v119)
              {
                (*(**(&v119 + 1) + 24))(*(&v119 + 1), *(&v118 + 1), 0, 8);
              }
            }
          }
        }

        result = FIK::IKArray<IKString>::~IKArray(&v110);
        if (v99)
        {
          result = (*(*v100 + 24))(v100, v98, 0, 8);
          v98 = 0;
          v99 = 0;
        }

        v5 -= 68;
        if (v84)
        {
          result = (*(*v85 + 24))(v85, v83, 0, 8);
          v83 = 0;
          v84 = 0;
        }

        if (v81[1])
        {
          result = (*(*v82 + 24))(v82, v81[0], 0, 8);
        }
      }

      while (v11-- > 2);
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,anonymous namespace::reorderRigBones(FIK::MoCapRig &)::$_0 &,FIK::IKArrayIterator<FIK::MoCapBone>>(uint64_t *a1, uint64_t *a2)
{
  v3 = a1;
  v4 = 0xF0F0F0F0F0F0F0F1 * ((a2 - a1) >> 5);
  if (v4 > 2)
  {
    switch(v4)
    {
      case 3:
        v10 = a2 - 68;
        v11 = *(a1 + 136);
        v12 = *(a2 - 136);
        if (v11 >= *a1)
        {
          if (v12 >= v11)
          {
            return 1;
          }

          std::swap[abi:nn200100]<FIK::MoCapBone>(a1 + 68, v10);
          if (*(v3 + 136) >= *v3)
          {
            return 1;
          }

          v5 = v3 + 68;
          goto LABEL_5;
        }

        if (v12 >= v11)
        {
          std::swap[abi:nn200100]<FIK::MoCapBone>(a1, a1 + 68);
          if (*v10 >= *(v3 + 136))
          {
            return 1;
          }

          a1 = v3 + 68;
        }

        v5 = v10;
        goto LABEL_30;
      case 4:
        return 1;
      case 5:
        v6 = a1 + 68;
        v7 = a1 + 136;
        v8 = a1 + 204;
        v9 = a2 - 68;
        if (*v9 >= *(v3 + 408))
        {
          return 1;
        }

        std::swap[abi:nn200100]<FIK::MoCapBone>(v3 + 204, v9);
        if (*v8 >= *v7)
        {
          return 1;
        }

        std::swap[abi:nn200100]<FIK::MoCapBone>(v3 + 136, v3 + 204);
        if (*v7 >= *v6)
        {
          return 1;
        }

        std::swap[abi:nn200100]<FIK::MoCapBone>(v3 + 68, v3 + 136);
        if (*(v3 + 136) >= *v3)
        {
          return 1;
        }

        a1 = v3;
        v5 = v3 + 68;
        goto LABEL_30;
    }
  }

  else
  {
    if (v4 < 2)
    {
      return 1;
    }

    if (v4 == 2)
    {
      v5 = a2 - 68;
      if (*(a2 - 136) < *a1)
      {
LABEL_5:
        a1 = v3;
LABEL_30:
        std::swap[abi:nn200100]<FIK::MoCapBone>(a1, v5);
      }

      return 1;
    }
  }

  v13 = a1 + 136;
  v14 = *(a1 + 136);
  v15 = *(a1 + 272);
  if (v14 < *a1)
  {
    if (v15 >= v14)
    {
      std::swap[abi:nn200100]<FIK::MoCapBone>(a1, a1 + 68);
      if (*(v3 + 272) >= *(v3 + 136))
      {
        goto LABEL_35;
      }

      a1 = v3 + 68;
    }

    v16 = v3 + 136;
    goto LABEL_34;
  }

  if (v15 < v14)
  {
    std::swap[abi:nn200100]<FIK::MoCapBone>(a1 + 68, a1 + 136);
    if (*(v3 + 136) < *v3)
    {
      v16 = v3 + 68;
      a1 = v3;
LABEL_34:
      std::swap[abi:nn200100]<FIK::MoCapBone>(a1, v16);
    }
  }

LABEL_35:
  v17 = v3 + 204;
  if (v3 + 204 == a2)
  {
    return 1;
  }

  v18 = 0;
  v19 = 0;
  while (1)
  {
    v20 = *v13;
    v13 = v17;
    if (*v17 < v20)
    {
      v46 = *v17;
      IKString::IKString(v47, v17 + 1, v17[3]);
      IKString::IKString(&v49, v13 + 4, v13[6]);
      v21 = *(v13 + 5);
      v52 = *(v13 + 4);
      v53 = v21;
      v22 = *(v13 + 6);
      v23 = *(v13 + 7);
      v56 = v13[16];
      v54 = v22;
      v55 = v23;
      v24 = *(v13 + 10);
      v57 = *(v13 + 9);
      v58 = v24;
      v25 = *(v13 + 12);
      v59 = *(v13 + 11);
      v60 = v25;
      v26 = *(v13 + 14);
      v61 = *(v13 + 13);
      v62 = v26;
      v63 = *(v13 + 15);
      IKString::IKString(&v64, v13 + 32, v13[34]);
      v67 = *(v13 + 70);
      v27 = *(v13 + 19);
      v68 = *(v13 + 18);
      v28 = *(v13 + 21);
      v70 = *(v13 + 20);
      v69 = v27;
      v71 = v28;
      v29 = *(v13 + 22);
      v73 = v13[46];
      v72 = v29;
      v74 = v13[48];
      v30 = *(v13 + 26);
      v75 = *(v13 + 25);
      v13[52] = 0;
      v13[53] = 0;
      v31 = *(v13 + 27);
      v32 = *(v13 + 28);
      v13[54] = 0;
      v76 = v30;
      v77 = v31;
      v78 = v32;
      v79 = *(v13 + 29);
      v80 = v13[60];
      v33 = *(v13 + 32);
      v81 = *(v13 + 31);
      v82 = v33;
      v34 = v18;
      v83 = *(v13 + 33);
      while (1)
      {
        v35 = v3 + v34;
        *(v3 + v34 + 1632) = *(v3 + v34 + 1088);
        IKString::operator=((v3 + v34 + 1640), v3 + v34 + 1096);
        IKString::operator=(v35 + 208, (v35 + 1120));
        *(v35 + 106) = *(v35 + 72);
        *(v35 + 107) = *(v35 + 73);
        *(v35 + 108) = *(v35 + 74);
        *(v35 + 109) = *(v35 + 75);
        *(v35 + 220) = *(v35 + 152);
        *(v35 + 111) = *(v35 + 77);
        *(v35 + 112) = *(v35 + 78);
        *(v35 + 113) = *(v35 + 79);
        *(v35 + 114) = *(v35 + 80);
        *(v35 + 115) = *(v35 + 81);
        *(v35 + 116) = *(v35 + 82);
        *(v35 + 117) = *(v35 + 83);
        IKString::operator=(v35 + 236, (v35 + 1344));
        *(v35 + 478) = *(v35 + 342);
        *(v35 + 120) = *(v35 + 86);
        *(v35 + 121) = *(v35 + 87);
        *(v35 + 122) = *(v35 + 88);
        *(v35 + 123) = *(v35 + 89);
        *(v35 + 124) = *(v35 + 90);
        *(v35 + 250) = *(v35 + 182);
        *(v35 + 252) = *(v35 + 184);
        *(v35 + 127) = *(v35 + 93);
        FIK::IKArray<IKString>::operator=(v35 + 128, v35 + 94);
        *(v35 + 130) = *(v35 + 96);
        *(v35 + 131) = *(v35 + 97);
        *(v35 + 264) = *(v35 + 196);
        *(v35 + 133) = *(v35 + 99);
        *(v35 + 134) = *(v35 + 100);
        *(v35 + 135) = *(v35 + 101);
        if (v34 == -1088)
        {
          break;
        }

        v34 -= 544;
        if (v46 >= *(v35 + 136))
        {
          v36 = v3 + v34 + 1632;
          goto LABEL_43;
        }
      }

      v36 = v3;
LABEL_43:
      *v36 = v46;
      IKString::operator=(v35 + 137, v47);
      IKString::operator=(v35 + 140, &v49);
      *(v36 + 64) = v52;
      *(v35 + 73) = v53;
      v37 = v56;
      v38 = v55;
      *(v35 + 74) = v54;
      *(v35 + 152) = v37;
      *(v35 + 75) = v38;
      *(v36 + 144) = v57;
      *(v36 + 160) = v58;
      *(v36 + 176) = v59;
      *(v36 + 192) = v60;
      *(v36 + 208) = v61;
      *(v36 + 224) = v62;
      *(v36 + 240) = v63;
      IKString::operator=(v35 + 168, &v64);
      *(v36 + 280) = v67;
      *(v36 + 288) = v68;
      *(v35 + 87) = v69;
      *(v36 + 320) = v70;
      *(v35 + 89) = v71;
      v39 = v73;
      *(v35 + 90) = v72;
      *(v35 + 182) = v39;
      *(v36 + 384) = v74;
      *(v36 + 400) = v75;
      v40 = v76;
      v76 = 0uLL;
      v41 = *(v35 + 188);
      *(v35 + 188) = v40;
      v42 = *(v36 + 424);
      *(v36 + 424) = *(&v40 + 1);
      v43 = v77;
      *&v77 = 0;
      v84[0] = v41;
      v84[1] = v42;
      v44 = *(v36 + 432);
      *(v36 + 432) = v43;
      v85 = v44;
      FIK::IKArray<IKString>::~IKArray(v84);
      *(v36 + 448) = v78;
      *(v35 + 97) = v79;
      *(v36 + 480) = v80;
      *(v36 + 496) = v81;
      *(v36 + 512) = v82;
      *(v35 + 101) = v83;
      FIK::IKArray<IKString>::~IKArray(&v76);
      if (v65)
      {
        (*(*v66 + 24))(v66, v64, 0, 8);
        v64 = 0;
        v65 = 0;
      }

      if (v50)
      {
        (*(*v51 + 24))(v51, v49, 0, 8);
        v49 = 0;
        v50 = 0;
      }

      if (v47[1])
      {
        (*(*v48 + 24))(v48, v47[0], 0, 8);
      }

      if (++v19 == 8)
      {
        return v13 + 68 == a2;
      }
    }

    v17 = v13 + 68;
    v18 += 544;
    if (v13 + 68 == a2)
    {
      return 1;
    }
  }
}

uint64_t std::swap[abi:nn200100]<FIK::MoCapBone>(uint64_t *a1, uint64_t *a2)
{
  v35 = *a1;
  IKString::IKString(v36, a1 + 1, a1[3]);
  IKString::IKString(&v38, a1 + 4, a1[6]);
  v4 = *(a1 + 5);
  v41 = *(a1 + 4);
  v42 = v4;
  v5 = *(a1 + 7);
  v43 = *(a1 + 6);
  v44 = v5;
  v45 = a1[16];
  v6 = *(a1 + 10);
  v46 = *(a1 + 9);
  v47 = v6;
  v7 = *(a1 + 12);
  v48 = *(a1 + 11);
  v49 = v7;
  v8 = *(a1 + 14);
  v50 = *(a1 + 13);
  v51 = v8;
  v52 = *(a1 + 15);
  IKString::IKString(&v53, a1 + 32, a1[34]);
  v56 = *(a1 + 70);
  v9 = *(a1 + 19);
  v57 = *(a1 + 18);
  v58 = v9;
  v10 = *(a1 + 21);
  v59 = *(a1 + 20);
  v60 = v10;
  v61 = *(a1 + 22);
  v11 = a1[48];
  v62 = a1[46];
  v63 = v11;
  v12 = *(a1 + 25);
  v13 = *(a1 + 26);
  *(a1 + 26) = 0u;
  v64 = v12;
  v65 = v13;
  v14 = *(a1 + 27);
  v15 = *(a1 + 28);
  a1[54] = 0;
  v66 = v14;
  v67 = v15;
  v68 = *(a1 + 29);
  v69 = a1[60];
  v16 = *(a1 + 32);
  v70 = *(a1 + 31);
  v71 = v16;
  v72 = *(a1 + 33);
  *a1 = *a2;
  IKString::operator=(a1 + 1, (a2 + 1));
  IKString::operator=(a1 + 4, (a2 + 4));
  *(a1 + 4) = *(a2 + 4);
  *(a1 + 5) = *(a2 + 5);
  v18 = *(a2 + 6);
  v17 = *(a2 + 7);
  a1[16] = a2[16];
  *(a1 + 6) = v18;
  *(a1 + 7) = v17;
  *(a1 + 9) = *(a2 + 9);
  *(a1 + 10) = *(a2 + 10);
  *(a1 + 11) = *(a2 + 11);
  *(a1 + 12) = *(a2 + 12);
  *(a1 + 13) = *(a2 + 13);
  *(a1 + 14) = *(a2 + 14);
  *(a1 + 15) = *(a2 + 15);
  IKString::operator=(a1 + 32, (a2 + 32));
  *(a1 + 70) = *(a2 + 70);
  *(a1 + 18) = *(a2 + 18);
  *(a1 + 19) = *(a2 + 19);
  *(a1 + 20) = *(a2 + 20);
  *(a1 + 21) = *(a2 + 21);
  v19 = a2[46];
  *(a1 + 22) = *(a2 + 22);
  a1[46] = v19;
  a1[48] = a2[48];
  *(a1 + 25) = *(a2 + 25);
  FIK::IKArray<IKString>::operator=(a1 + 26, a2 + 26);
  *(a1 + 28) = *(a2 + 28);
  *(a1 + 29) = *(a2 + 29);
  a1[60] = a2[60];
  *(a1 + 31) = *(a2 + 31);
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 33) = *(a2 + 33);
  *a2 = v35;
  IKString::operator=(a2 + 1, v36);
  IKString::operator=(a2 + 4, &v38);
  v20 = v42;
  *(a2 + 4) = v41;
  *(a2 + 5) = v20;
  v21 = v44;
  *(a2 + 6) = v43;
  *(a2 + 7) = v21;
  a2[16] = v45;
  v22 = v47;
  *(a2 + 9) = v46;
  *(a2 + 10) = v22;
  v23 = v49;
  *(a2 + 11) = v48;
  *(a2 + 12) = v23;
  v24 = v51;
  *(a2 + 13) = v50;
  *(a2 + 14) = v24;
  *(a2 + 15) = v52;
  IKString::operator=(a2 + 32, &v53);
  *(a2 + 70) = v56;
  v25 = v63;
  a2[46] = v62;
  v26 = v58;
  *(a2 + 18) = v57;
  *(a2 + 19) = v26;
  v27 = v60;
  *(a2 + 20) = v59;
  *(a2 + 21) = v27;
  *(a2 + 22) = v61;
  a2[48] = v25;
  v28 = v65;
  v65 = 0u;
  v29 = *(a2 + 26);
  v30 = *(a2 + 27);
  *(a2 + 25) = v64;
  *(a2 + 26) = v28;
  v31 = v66;
  *&v66 = 0;
  *(a2 + 27) = v31;
  v73[0] = v29;
  v73[1] = v30;
  FIK::IKArray<IKString>::~IKArray(v73);
  v32 = v68;
  *(a2 + 28) = v67;
  *(a2 + 29) = v32;
  a2[60] = v69;
  v33 = v71;
  *(a2 + 31) = v70;
  *(a2 + 32) = v33;
  *(a2 + 33) = v72;
  result = FIK::IKArray<IKString>::~IKArray(&v65);
  if (v54)
  {
    result = (*(*v55 + 24))(v55, v53, 0, 8);
    v53 = 0;
    v54 = 0;
  }

  if (v39)
  {
    result = (*(*v40 + 24))(v40, v38, 0, 8);
    v38 = 0;
    v39 = 0;
  }

  if (v36[1])
  {
    return (*(*v37 + 24))(v37, v36[0], 0, 8);
  }

  return result;
}

uint64_t std::__sift_down[abi:nn200100]<std::_ClassicAlgPolicy,anonymous namespace::reorderRigBones(FIK::MoCapRig &)::$_0 &,FIK::IKArrayIterator<FIK::MoCapBone>>(uint64_t result, uint64_t a2, void *a3)
{
  v5 = a2 - 2;
  if (a2 >= 2)
  {
    v81 = v3;
    v82 = v4;
    v6 = a3;
    v7 = result;
    v8 = v5 >> 1;
    if ((v5 >> 1) >= (0xF0F0F0F0F0F0F0F1 * ((a3 - result) >> 5)))
    {
      v10 = (0xE1E1E1E1E1E1E1E2 * ((a3 - result) >> 5)) | 1;
      v11 = result + 544 * v10;
      if ((0xE1E1E1E1E1E1E1E2 * ((a3 - result) >> 5) + 2) >= a2)
      {
        v12 = *v11;
      }

      else
      {
        v12 = *v11;
        v13 = *(v11 + 544);
        if (*v11 <= v13)
        {
          v12 = *(v11 + 544);
        }

        if (*v11 < v13)
        {
          v11 += 544;
          v10 = 0xE1E1E1E1E1E1E1E2 * ((a3 - result) >> 5) + 2;
        }
      }

      if (v12 >= *a3)
      {
        v42 = *a3;
        IKString::IKString(v43, a3 + 1, a3[3]);
        IKString::IKString(&v45, v6 + 4, v6[6]);
        v14 = *(v6 + 5);
        v48 = *(v6 + 4);
        v49 = v14;
        v15 = *(v6 + 6);
        v16 = *(v6 + 7);
        v52 = v6[16];
        v50 = v15;
        v51 = v16;
        v17 = *(v6 + 10);
        v53 = *(v6 + 9);
        v54 = v17;
        v18 = *(v6 + 12);
        v55 = *(v6 + 11);
        v56 = v18;
        v19 = *(v6 + 14);
        v57 = *(v6 + 13);
        v58 = v19;
        v59 = *(v6 + 15);
        IKString::IKString(&v60, v6 + 32, v6[34]);
        v63 = *(v6 + 70);
        v20 = *(v6 + 19);
        v64 = *(v6 + 18);
        v65 = v20;
        v21 = *(v6 + 21);
        v66 = *(v6 + 20);
        v67 = v21;
        v22 = v6[46];
        v68 = *(v6 + 22);
        v23 = v6[48];
        v69 = v22;
        v70 = v23;
        v24 = *(v6 + 25);
        v25 = *(v6 + 26);
        v6[52] = 0;
        v6[53] = 0;
        v71 = v24;
        v72 = v25;
        v26 = *(v6 + 27);
        v27 = *(v6 + 28);
        v6[54] = 0;
        v73 = v26;
        v74 = v27;
        v75 = *(v6 + 29);
        v76 = v6[60];
        v28 = *(v6 + 32);
        v77 = *(v6 + 31);
        v78 = v28;
        v79 = *(v6 + 33);
        do
        {
          v29 = v6;
          v6 = v11;
          *v29 = *v11;
          IKString::operator=(v29 + 1, v11 + 8);
          IKString::operator=(v29 + 4, v11 + 32);
          *(v29 + 4) = *(v11 + 64);
          *(v29 + 5) = *(v11 + 80);
          v31 = *(v11 + 96);
          v30 = *(v11 + 112);
          v29[16] = *(v11 + 128);
          *(v29 + 6) = v31;
          *(v29 + 7) = v30;
          *(v29 + 9) = *(v11 + 144);
          *(v29 + 10) = *(v11 + 160);
          *(v29 + 11) = *(v11 + 176);
          *(v29 + 12) = *(v11 + 192);
          *(v29 + 13) = *(v11 + 208);
          *(v29 + 14) = *(v11 + 224);
          *(v29 + 15) = *(v11 + 240);
          IKString::operator=(v29 + 32, v11 + 256);
          *(v29 + 70) = *(v11 + 280);
          *(v29 + 18) = *(v11 + 288);
          *(v29 + 19) = *(v11 + 304);
          *(v29 + 20) = *(v11 + 320);
          *(v29 + 21) = *(v11 + 336);
          v32 = *(v11 + 368);
          *(v29 + 22) = *(v11 + 352);
          v29[46] = v32;
          v29[48] = *(v11 + 384);
          *(v29 + 25) = *(v11 + 400);
          FIK::IKArray<IKString>::operator=(v29 + 26, (v11 + 416));
          *(v29 + 28) = *(v11 + 448);
          *(v29 + 29) = *(v11 + 464);
          v29[60] = *(v11 + 480);
          *(v29 + 31) = *(v11 + 496);
          *(v29 + 32) = *(v11 + 512);
          *(v29 + 33) = *(v11 + 528);
          if (v8 < v10)
          {
            break;
          }

          v11 = v7 + 544 * ((2 * v10) | 1);
          if (2 * v10 + 2 >= a2)
          {
            v33 = *v11;
            v10 = (2 * v10) | 1;
          }

          else
          {
            v33 = *v11;
            v34 = *(v11 + 544);
            if (*v11 <= v34)
            {
              v33 = *(v11 + 544);
            }

            if (*v11 >= v34)
            {
              v10 = (2 * v10) | 1;
            }

            else
            {
              v11 += 544;
              v10 = 2 * v10 + 2;
            }
          }
        }

        while (v33 >= v42);
        *v6 = v42;
        IKString::operator=(v6 + 1, v43);
        IKString::operator=(v6 + 4, &v45);
        *(v6 + 4) = v48;
        *(v6 + 5) = v49;
        v36 = v50;
        v35 = v51;
        v6[16] = v52;
        *(v6 + 6) = v36;
        *(v6 + 7) = v35;
        *(v6 + 9) = v53;
        *(v6 + 10) = v54;
        *(v6 + 11) = v55;
        *(v6 + 12) = v56;
        *(v6 + 13) = v57;
        *(v6 + 14) = v58;
        *(v6 + 15) = v59;
        IKString::operator=(v6 + 32, &v60);
        *(v6 + 70) = v63;
        *(v6 + 18) = v64;
        *(v6 + 19) = v65;
        *(v6 + 20) = v66;
        *(v6 + 21) = v67;
        v37 = v69;
        *(v6 + 22) = v68;
        v6[46] = v37;
        v6[48] = v70;
        *(v6 + 25) = v71;
        v38 = v72;
        v39 = v73;
        v72 = 0uLL;
        *&v73 = 0;
        v40 = *(v6 + 26);
        v41 = *(v6 + 27);
        *(v6 + 26) = v38;
        *(v6 + 27) = v39;
        v80[0] = v40;
        v80[1] = v41;
        FIK::IKArray<IKString>::~IKArray(v80);
        *(v6 + 28) = v74;
        *(v6 + 29) = v75;
        v6[60] = v76;
        *(v6 + 31) = v77;
        *(v6 + 32) = v78;
        *(v6 + 33) = v79;
        result = FIK::IKArray<IKString>::~IKArray(&v72);
        if (v61)
        {
          result = (*(*v62 + 24))(v62, v60, 0, 8);
          v60 = 0;
          v61 = 0;
        }

        if (v46)
        {
          result = (*(*v47 + 24))(v47, v45, 0, 8);
          v45 = 0;
          v46 = 0;
        }

        if (v43[1])
        {
          return (*(*v44 + 24))(v44, v43[0], 0, 8);
        }
      }
    }
  }

  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,anonymous namespace::reorderRigBones(FIK::MoCapRig &)::$_1 &,FIK::IKArrayIterator<FIK::RigBoneBase>,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  v6 = result;
LABEL_2:
  v7 = a2 - 12;
  v108 = a2 - 36;
  v109 = a2 - 24;
  v8 = v6;
  while (1)
  {
    v6 = v8;
    v9 = a2 - v8;
    v10 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 5);
    v11 = v10 - 2;
    if (v10 <= 2)
    {
      if (v10 < 2)
      {
        return result;
      }

      if (v10 == 2)
      {
        v62 = *(a2 - 24);
        v61 = a2 - 12;
        if (v62 >= *v6)
        {
          return result;
        }

LABEL_118:
        v60 = v6;
LABEL_119:
        v59 = v61;
        return std::swap[abi:nn200100]<FIK::RigBoneBase>(v60, v59);
      }

      goto LABEL_10;
    }

    if (v10 == 3)
    {
      v63 = *(v6 + 96);
      v65 = *(a2 - 24);
      v61 = a2 - 12;
      v64 = v65;
      if (v63 >= *v6)
      {
        if (v64 < v63)
        {
          result = std::swap[abi:nn200100]<FIK::RigBoneBase>((v6 + 96), v61);
          if (*(v6 + 96) < *v6)
          {
            v60 = v6;
            v59 = (v6 + 96);
            return std::swap[abi:nn200100]<FIK::RigBoneBase>(v60, v59);
          }
        }
      }

      else
      {
        if (v64 < v63)
        {
          goto LABEL_118;
        }

        result = std::swap[abi:nn200100]<FIK::RigBoneBase>(v6, (v6 + 96));
        if (*v61 < *(v6 + 96))
        {
          v60 = (v6 + 96);
          goto LABEL_119;
        }
      }

      return result;
    }

    if (v10 == 4)
    {
    }

    if (v10 == 5)
    {
      break;
    }

LABEL_10:
    if (v9 <= 2303)
    {
      if (a4)
      {
        if (v6 != a2)
        {
          v66 = (v6 + 96);
          if ((v6 + 96) != a2)
          {
            v67 = 0;
            v68 = v6;
            do
            {
              v69 = v66;
              if (*(v68 + 96) < *v68)
              {
                v119 = *v66;
                IKString::IKString(&v120, (v68 + 104), *(v68 + 120));
                IKString::IKString(&v123, (v68 + 128), *(v68 + 144));
                v70 = *(v68 + 176);
                v126 = *(v68 + 160);
                v127 = v70;
                v71 = v67;
                while (1)
                {
                  v72 = v6 + v71;
                  *(v6 + v71 + 96) = *(v6 + v71);
                  IKString::operator=((v6 + v71 + 104), v6 + v71 + 8);
                  IKString::operator=((v72 + 128), v72 + 32);
                  v73 = *(v6 + v71 + 80);
                  *(v72 + 160) = *(v72 + 64);
                  *(v72 + 176) = v73;
                  if (!v71)
                  {
                    break;
                  }

                  v71 -= 96;
                  if (v119 >= *(v72 - 96))
                  {
                    v74 = v6 + v71 + 96;
                    goto LABEL_132;
                  }
                }

                v74 = v6;
LABEL_132:
                *v74 = v119;
                IKString::operator=((v72 + 8), &v120);
                result = IKString::operator=((v72 + 32), &v123);
                *(v74 + 64) = v126;
                *(v72 + 80) = v127;
                if (v124)
                {
                  result = (*(*v125 + 24))(v125, v123, 0, 8);
                  v123 = 0;
                  v124 = 0;
                }

                if (v121)
                {
                  result = (*(*v122 + 24))(v122, v120, 0, 8);
                }
              }

              v66 = v69 + 12;
              v67 += 96;
              v68 = v69;
            }

            while (v69 + 12 != a2);
          }
        }
      }

      else if (v6 != a2)
      {
        v101 = (v6 + 96);
        if ((v6 + 96) != a2)
        {
          v102 = v6 - 96;
          do
          {
            v103 = v101;
            if (*(v6 + 96) < *v6)
            {
              v119 = *v101;
              IKString::IKString(&v120, (v6 + 104), *(v6 + 120));
              IKString::IKString(&v123, (v6 + 128), *(v6 + 144));
              v104 = *(v6 + 176);
              v126 = *(v6 + 160);
              v127 = v104;
              v105 = v102;
              do
              {
                *(v105 + 192) = *(v105 + 96);
                IKString::operator=((v105 + 200), v105 + 104);
                IKString::operator=((v105 + 224), v105 + 128);
                v106 = *(v105 + 176);
                *(v105 + 256) = *(v105 + 160);
                *(v105 + 272) = v106;
                v107 = *v105;
                v105 -= 96;
              }

              while (v119 < v107);
              *(v105 + 192) = v119;
              IKString::operator=((v105 + 200), &v120);
              result = IKString::operator=((v105 + 224), &v123);
              *(v105 + 256) = v126;
              *(v105 + 272) = v127;
              if (v124)
              {
                result = (*(*v125 + 24))(v125, v123, 0, 8);
                v123 = 0;
                v124 = 0;
              }

              if (v121)
              {
                result = (*(*v122 + 24))(v122, v120, 0, 8);
              }
            }

            v101 = v103 + 12;
            v102 += 96;
            v6 = v103;
          }

          while (v103 + 12 != a2);
        }
      }

      return result;
    }

    if (!a3)
    {
      if (v6 != a2)
      {
        v75 = v11 >> 1;
        v76 = v11 >> 1;
        do
        {
          v77 = v76;
          if (v75 >= v76)
          {
            v78 = (2 * v76) | 1;
            v79 = v6 + 96 * v78;
            if (2 * v76 + 2 >= v10)
            {
              v80 = *v79;
            }

            else
            {
              v80 = *v79;
              v81 = *(v79 + 96);
              if (*v79 <= v81)
              {
                v80 = *(v79 + 96);
              }

              if (*v79 < v81)
              {
                v79 += 96;
                v78 = 2 * v77 + 2;
              }
            }

            v82 = v6 + 96 * v77;
            if (v80 >= *v82)
            {
              v119 = *v82;
              IKString::IKString(&v120, (v82 + 8), *(v82 + 24));
              IKString::IKString(&v123, (v82 + 32), *(v82 + 48));
              v83 = *(v82 + 80);
              v126 = *(v82 + 64);
              v127 = v83;
              do
              {
                v84 = v82;
                v82 = v79;
                *v84 = *v79;
                IKString::operator=((v84 + 8), v79 + 8);
                IKString::operator=((v84 + 32), v79 + 32);
                *(v84 + 64) = *(v79 + 64);
                *(v84 + 80) = *(v79 + 80);
                if (v75 < v78)
                {
                  break;
                }

                v79 = v6 + 96 * ((2 * v78) | 1);
                if (2 * v78 + 2 >= v10)
                {
                  v85 = *v79;
                  v78 = (2 * v78) | 1;
                }

                else
                {
                  v85 = *v79;
                  v86 = *(v79 + 96);
                  if (*v79 <= v86)
                  {
                    v85 = *(v79 + 96);
                  }

                  if (*v79 >= v86)
                  {
                    v78 = (2 * v78) | 1;
                  }

                  else
                  {
                    v79 += 96;
                    v78 = 2 * v78 + 2;
                  }
                }
              }

              while (v85 >= v119);
              *v82 = v119;
              IKString::operator=((v82 + 8), &v120);
              IKString::operator=((v82 + 32), &v123);
              *(v82 + 64) = v126;
              *(v82 + 80) = v127;
              if (v124)
              {
                (*(*v125 + 24))(v125, v123, 0, 8);
                v123 = 0;
                v124 = 0;
              }

              if (v121)
              {
                (*(*v122 + 24))(v122, v120, 0, 8);
              }
            }
          }

          v76 = v77 - 1;
        }

        while (v77);
        v87 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 5);
        do
        {
          v111 = *v6;
          IKString::IKString(v112, (v6 + 8), *(v6 + 24));
          IKString::IKString(&v114, (v6 + 32), *(v6 + 48));
          v88 = 0;
          v89 = *(v6 + 80);
          v117 = *(v6 + 64);
          v118 = v89;
          v90 = v6;
          do
          {
            v91 = v90 + 96 * v88 + 96;
            v92 = (2 * v88) | 1;
            v93 = 2 * v88 + 2;
            if (v93 < v87 && *v91 < *(v91 + 96))
            {
              v91 += 96;
              v92 = v93;
            }

            *v90 = *v91;
            IKString::operator=((v90 + 8), v91 + 8);
            IKString::operator=((v90 + 32), v91 + 32);
            *(v90 + 64) = *(v91 + 64);
            *(v90 + 80) = *(v91 + 80);
            v90 = v91;
            v88 = v92;
          }

          while (v92 <= ((v87 - 2) >> 1));
          v94 = a2 - 12;
          if (v91 == a2 - 12)
          {
            *v91 = v111;
            IKString::operator=((v91 + 8), v112);
            result = IKString::operator=((v91 + 32), &v114);
            *(v91 + 64) = v117;
            *(v91 + 80) = v118;
          }

          else
          {
            *v91 = *(a2 - 12);
            IKString::operator=((v91 + 8), (a2 - 11));
            IKString::operator=((v91 + 32), (a2 - 8));
            *(v91 + 64) = *(a2 - 2);
            *(v91 + 80) = *(a2 - 1);
            *(a2 - 12) = v111;
            IKString::operator=(a2 - 11, v112);
            result = IKString::operator=(a2 - 8, &v114);
            *(a2 - 2) = v117;
            *(a2 - 1) = v118;
            v95 = v91 - v6 + 96;
            if (v95 >= 97)
            {
              v96 = (-2 - 0x5555555555555555 * (v95 >> 5)) >> 1;
              v97 = v6 + 96 * v96;
              if (*v97 < *v91)
              {
                v119 = *v91;
                IKString::IKString(&v120, (v91 + 8), *(v91 + 24));
                IKString::IKString(&v123, (v91 + 32), *(v91 + 48));
                v98 = *(v91 + 80);
                v126 = *(v91 + 64);
                v127 = v98;
                do
                {
                  v99 = v97;
                  *v91 = *v97;
                  IKString::operator=((v91 + 8), v97 + 8);
                  IKString::operator=((v91 + 32), v97 + 32);
                  *(v91 + 64) = *(v97 + 64);
                  *(v91 + 80) = *(v97 + 80);
                  if (!v96)
                  {
                    break;
                  }

                  v96 = (v96 - 1) / 2;
                  v97 = v6 + 96 * v96;
                  v91 = v99;
                }

                while (*v97 < v119);
                *v99 = v119;
                IKString::operator=((v99 + 8), &v120);
                result = IKString::operator=((v99 + 32), &v123);
                *(v99 + 64) = v126;
                *(v99 + 80) = v127;
                if (v124)
                {
                  result = (*(*v125 + 24))(v125, v123, 0, 8);
                  v123 = 0;
                  v124 = 0;
                }

                if (v121)
                {
                  result = (*(*v122 + 24))(v122, v120, 0, 8);
                }
              }
            }
          }

          if (v115)
          {
            result = (*(*v116 + 24))(v116, v114, 0, 8);
            v114 = 0;
            v115 = 0;
          }

          if (v112[1])
          {
            result = (*(*v113 + 24))(v113, v112[0], 0, 8);
          }

          a2 = v94;
        }

        while (v87-- > 2);
      }

      return result;
    }

    v12 = v10 >> 1;
    v13 = (v6 + 96 * (v10 >> 1));
    v14 = *v7;
    if (v10 >= 0x81)
    {
      v15 = *v13;
      if (*v13 >= *v6)
      {
        if (v14 >= v15 || (std::swap[abi:nn200100]<FIK::RigBoneBase>((v6 + 96 * (v10 >> 1)), a2 - 12), *v13 >= *v6))
        {
LABEL_27:
          v21 = v6 + 96 * v12;
          v24 = *(v21 - 96);
          v23 = (v21 - 96);
          v22 = v24;
          v25 = *v109;
          if (v24 >= *(v6 + 96))
          {
            if (v25 >= v22 || (std::swap[abi:nn200100]<FIK::RigBoneBase>(v23, v109), *v23 >= *(v6 + 96)))
            {
LABEL_39:
              v28 = v6 + 96 * v12;
              v31 = *(v28 + 96);
              v30 = (v28 + 96);
              v29 = v31;
              v32 = *v108;
              if (v31 >= *(v6 + 192))
              {
                if (v32 >= v29 || (std::swap[abi:nn200100]<FIK::RigBoneBase>(v30, v108), *v30 >= *(v6 + 192)))
                {
LABEL_48:
                  v35 = *v13;
                  v36 = *v30;
                  if (*v13 >= *v23)
                  {
                    if (v36 >= v35)
                    {
                      goto LABEL_57;
                    }

                    std::swap[abi:nn200100]<FIK::RigBoneBase>((v6 + 96 * (v10 >> 1)), v30);
                    if (*v13 >= *v23)
                    {
                      goto LABEL_57;
                    }

                    v37 = v23;
                    v38 = (v6 + 96 * (v10 >> 1));
                  }

                  else
                  {
                    v37 = v23;
                    if (v36 >= v35)
                    {
                      std::swap[abi:nn200100]<FIK::RigBoneBase>(v23, (v6 + 96 * (v10 >> 1)));
                      if (*v30 >= *v13)
                      {
LABEL_57:
                        v19 = v6;
                        v20 = (v6 + 96 * (v10 >> 1));
                        goto LABEL_58;
                      }

                      v37 = (v6 + 96 * (v10 >> 1));
                    }

                    v38 = v30;
                  }

                  std::swap[abi:nn200100]<FIK::RigBoneBase>(v37, v38);
                  goto LABEL_57;
                }

                v33 = (v6 + 192);
                v34 = v30;
              }

              else
              {
                v33 = (v6 + 192);
                if (v32 >= v29)
                {
                  std::swap[abi:nn200100]<FIK::RigBoneBase>(v33, v30);
                  if (*v108 >= *v30)
                  {
                    goto LABEL_48;
                  }

                  v33 = v30;
                }

                v34 = a2 - 36;
              }

              std::swap[abi:nn200100]<FIK::RigBoneBase>(v33, v34);
              goto LABEL_48;
            }

            v26 = (v6 + 96);
            v27 = v23;
          }

          else
          {
            v26 = (v6 + 96);
            if (v25 >= v22)
            {
              std::swap[abi:nn200100]<FIK::RigBoneBase>(v26, v23);
              if (*v109 >= *v23)
              {
                goto LABEL_39;
              }

              v26 = v23;
            }

            v27 = a2 - 24;
          }

          std::swap[abi:nn200100]<FIK::RigBoneBase>(v26, v27);
          goto LABEL_39;
        }

        v16 = v6;
        v17 = (v6 + 96 * (v10 >> 1));
      }

      else
      {
        v16 = v6;
        if (v14 >= v15)
        {
          std::swap[abi:nn200100]<FIK::RigBoneBase>(v6, (v6 + 96 * (v10 >> 1)));
          if (*v7 >= *v13)
          {
            goto LABEL_27;
          }

          v16 = (v6 + 96 * (v10 >> 1));
        }

        v17 = a2 - 12;
      }

      std::swap[abi:nn200100]<FIK::RigBoneBase>(v16, v17);
      goto LABEL_27;
    }

    v18 = *v6;
    if (*v6 >= *v13)
    {
      if (v14 >= v18)
      {
        goto LABEL_59;
      }

      std::swap[abi:nn200100]<FIK::RigBoneBase>(v6, a2 - 12);
      if (*v6 >= *v13)
      {
        goto LABEL_59;
      }

      v19 = (v6 + 96 * (v10 >> 1));
      v20 = v6;
    }

    else
    {
      v19 = (v6 + 96 * (v10 >> 1));
      if (v14 >= v18)
      {
        std::swap[abi:nn200100]<FIK::RigBoneBase>(v19, v6);
        if (*v7 >= *v6)
        {
          goto LABEL_59;
        }

        v19 = v6;
      }

      v20 = a2 - 12;
    }

LABEL_58:
    std::swap[abi:nn200100]<FIK::RigBoneBase>(v19, v20);
LABEL_59:
    --a3;
    if ((a4 & 1) != 0 || *(v6 - 96) < *v6)
    {
      v119 = *v6;
      IKString::IKString(&v120, (v6 + 8), *(v6 + 24));
      IKString::IKString(&v123, (v6 + 32), *(v6 + 48));
      v39 = 0;
      v40 = *(v6 + 80);
      v126 = *(v6 + 64);
      v127 = v40;
      do
      {
        v41 = *(v6 + v39 + 96);
        v39 += 96;
      }

      while (v41 < v119);
      v42 = v6 + v39;
      v43 = a2;
      if (v39 == 96)
      {
        v43 = a2;
        do
        {
          if (v42 >= v43)
          {
            break;
          }

          v45 = *(v43 - 24);
          v43 -= 12;
        }

        while (v45 >= v119);
      }

      else
      {
        do
        {
          v44 = *(v43 - 24);
          v43 -= 12;
        }

        while (v44 >= v119);
      }

      v8 = v6 + v39;
      if (v42 < v43)
      {
        v46 = v43;
        do
        {
          std::swap[abi:nn200100]<FIK::RigBoneBase>(v8, v46);
          do
          {
            v47 = *(v8 + 96);
            v8 += 96;
          }

          while (v47 < v119);
          do
          {
            v48 = *(v46 - 24);
            v46 -= 12;
          }

          while (v48 >= v119);
        }

        while (v8 < v46);
      }

      if (v8 - 96 != v6)
      {
        *v6 = *(v8 - 96);
        IKString::operator=((v6 + 8), v8 - 88);
        IKString::operator=((v6 + 32), v8 - 64);
        *(v6 + 64) = *(v8 - 32);
        *(v6 + 80) = *(v8 - 16);
      }

      *(v8 - 96) = v119;
      IKString::operator=((v8 - 88), &v120);
      IKString::operator=((v8 - 64), &v123);
      *(v8 - 32) = v126;
      *(v8 - 16) = v127;
      if (v124)
      {
        (*(*v125 + 24))(v125, v123, 0, 8);
        v123 = 0;
        v124 = 0;
      }

      if (v121)
      {
        (*(*v122 + 24))(v122, v120, 0, 8);
      }

      if (v42 < v43)
      {
        goto LABEL_84;
      }

      if (result)
      {
        a2 = (v8 - 96);
        if (!v49)
        {
          goto LABEL_2;
        }

        return result;
      }

      if (!v49)
      {
LABEL_84:
        goto LABEL_85;
      }
    }

    else
    {
      v119 = *v6;
      IKString::IKString(&v120, (v6 + 8), *(v6 + 24));
      IKString::IKString(&v123, (v6 + 32), *(v6 + 48));
      v50 = *(v6 + 80);
      v126 = *(v6 + 64);
      v127 = v50;
      if (v119 >= *v7)
      {
        v52 = v6 + 96;
        do
        {
          v8 = v52;
          if (v52 >= a2)
          {
            break;
          }

          v52 += 96;
        }

        while (v119 >= *v8);
      }

      else
      {
        v8 = v6;
        do
        {
          v51 = *(v8 + 96);
          v8 += 96;
        }

        while (v119 >= v51);
      }

      v53 = a2;
      if (v8 < a2)
      {
        v53 = a2;
        do
        {
          v54 = *(v53 - 24);
          v53 -= 12;
        }

        while (v119 < v54);
      }

      while (v8 < v53)
      {
        std::swap[abi:nn200100]<FIK::RigBoneBase>(v8, v53);
        do
        {
          v55 = *(v8 + 96);
          v8 += 96;
        }

        while (v119 >= v55);
        do
        {
          v56 = *(v53 - 24);
          v53 -= 12;
        }

        while (v119 < v56);
      }

      if (v8 - 96 != v6)
      {
        *v6 = *(v8 - 96);
        IKString::operator=((v6 + 8), v8 - 88);
        IKString::operator=((v6 + 32), v8 - 64);
        *(v6 + 64) = *(v8 - 32);
        *(v6 + 80) = *(v8 - 16);
      }

      *(v8 - 96) = v119;
      IKString::operator=((v8 - 88), &v120);
      result = IKString::operator=((v8 - 64), &v123);
      *(v8 - 32) = v126;
      *(v8 - 16) = v127;
      if (v124)
      {
        result = (*(*v125 + 24))(v125, v123, 0, 8);
        v123 = 0;
        v124 = 0;
      }

      if (v121)
      {
        result = (*(*v122 + 24))(v122, v120, 0, 8);
      }

LABEL_85:
      a4 = 0;
    }
  }

  v58 = *(a2 - 24);
  v57 = a2 - 12;
  if (v58 < *(v6 + 288))
  {
    result = std::swap[abi:nn200100]<FIK::RigBoneBase>((v6 + 288), v57);
    if (*(v6 + 288) < *(v6 + 192))
    {
      result = std::swap[abi:nn200100]<FIK::RigBoneBase>((v6 + 192), (v6 + 288));
      if (*(v6 + 192) < *(v6 + 96))
      {
        result = std::swap[abi:nn200100]<FIK::RigBoneBase>((v6 + 96), (v6 + 192));
        if (*(v6 + 96) < *v6)
        {
          v59 = (v6 + 96);
          v60 = v6;
          return std::swap[abi:nn200100]<FIK::RigBoneBase>(v60, v59);
        }
      }
    }
  }

  return result;
}

uint64_t *std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,anonymous namespace::reorderRigBones(FIK::MoCapRig &)::$_1 &,FIK::IKArrayIterator<FIK::RigBoneBase>,0>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  v7 = result;
  v8 = *a2;
  v9 = *a3;
  if (*a2 >= *result)
  {
    if (v9 < v8)
    {
      result = std::swap[abi:nn200100]<FIK::RigBoneBase>(a2, a3);
      if (*a2 < *v7)
      {
        result = v7;
        v10 = a2;
        goto LABEL_9;
      }
    }
  }

  else
  {
    if (v9 < v8)
    {
LABEL_5:
      v10 = a3;
LABEL_9:
      result = std::swap[abi:nn200100]<FIK::RigBoneBase>(result, v10);
      goto LABEL_10;
    }

    result = std::swap[abi:nn200100]<FIK::RigBoneBase>(result, a2);
    if (*a3 < *a2)
    {
      result = a2;
      goto LABEL_5;
    }
  }

LABEL_10:
  if (*a4 < *a3)
  {
    result = std::swap[abi:nn200100]<FIK::RigBoneBase>(a3, a4);
    if (*a3 < *a2)
    {
      result = std::swap[abi:nn200100]<FIK::RigBoneBase>(a2, a3);
      if (*a2 < *v7)
      {

        return std::swap[abi:nn200100]<FIK::RigBoneBase>(v7, a2);
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,anonymous namespace::reorderRigBones(FIK::MoCapRig &)::$_1 &,FIK::IKArrayIterator<FIK::RigBoneBase>>(uint64_t *a1, uint64_t *a2)
{
  v3 = a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 5);
  if (v4 > 2)
  {
    switch(v4)
    {
      case 3:
        v10 = *(a1 + 24);
        v5 = a2 - 12;
        v11 = *(a2 - 24);
        if (v10 >= *a1)
        {
          if (v11 >= v10)
          {
            return 1;
          }

          std::swap[abi:nn200100]<FIK::RigBoneBase>(a1 + 12, v5);
          if (*(v3 + 24) >= *v3)
          {
            return 1;
          }

          a1 = v3;
          v9 = v3 + 12;
          goto LABEL_17;
        }

        if (v11 >= v10)
        {
          std::swap[abi:nn200100]<FIK::RigBoneBase>(a1, a1 + 12);
          if (*v5 >= *(v3 + 24))
          {
            return 1;
          }

          a1 = v3 + 12;
        }

LABEL_16:
        v9 = v5;
LABEL_17:
        std::swap[abi:nn200100]<FIK::RigBoneBase>(a1, v9);
        return 1;
      case 4:
        return 1;
      case 5:
        v6 = a1 + 36;
        v8 = *(a2 - 24);
        v7 = a2 - 12;
        if (v8 >= *(v3 + 72))
        {
          return 1;
        }

        std::swap[abi:nn200100]<FIK::RigBoneBase>(v3 + 36, v7);
        if (*v6 >= *(v3 + 48))
        {
          return 1;
        }

        std::swap[abi:nn200100]<FIK::RigBoneBase>(v3 + 24, v3 + 36);
        if (*(v3 + 48) >= *(v3 + 24))
        {
          return 1;
        }

        std::swap[abi:nn200100]<FIK::RigBoneBase>(v3 + 12, v3 + 24);
        if (*(v3 + 24) >= *v3)
        {
          return 1;
        }

        v9 = v3 + 12;
        a1 = v3;
        goto LABEL_17;
    }
  }

  else
  {
    if (v4 < 2)
    {
      return 1;
    }

    if (v4 == 2)
    {
      v5 = a2 - 12;
      if (*(a2 - 24) >= *a1)
      {
        return 1;
      }

      goto LABEL_16;
    }
  }

  v13 = a1 + 24;
  v12 = *(a1 + 48);
  v14 = *(a1 + 24);
  if (v14 < *a1)
  {
    if (v12 >= v14)
    {
      std::swap[abi:nn200100]<FIK::RigBoneBase>(a1, a1 + 12);
      if (*(v3 + 48) >= *(v3 + 24))
      {
        goto LABEL_31;
      }

      a1 = v3 + 12;
    }

    v15 = v3 + 24;
    goto LABEL_30;
  }

  if (v12 < v14)
  {
    std::swap[abi:nn200100]<FIK::RigBoneBase>(a1 + 12, a1 + 24);
    if (*(v3 + 24) < *v3)
    {
      a1 = v3;
      v15 = v3 + 12;
LABEL_30:
      std::swap[abi:nn200100]<FIK::RigBoneBase>(a1, v15);
    }
  }

LABEL_31:
  v16 = v3 + 36;
  if (v3 + 36 == a2)
  {
    return 1;
  }

  v17 = 0;
  v18 = 0;
  while (1)
  {
    v19 = *v13;
    v13 = v16;
    if (*v16 < v19)
    {
      v26 = *v16;
      IKString::IKString(v27, v16 + 1, v16[3]);
      IKString::IKString(&v29, v13 + 4, v13[6]);
      v20 = *(v13 + 5);
      v32 = *(v13 + 4);
      v33 = v20;
      v21 = v17;
      while (1)
      {
        v22 = (v3 + v21);
        *(v3 + v21 + 288) = *(v3 + v21 + 192);
        IKString::operator=((v3 + v21 + 296), v3 + v21 + 200);
        IKString::operator=(v22 + 40, (v22 + 28));
        v23 = *(v3 + v21 + 272);
        *(v22 + 22) = *(v22 + 16);
        *(v22 + 23) = v23;
        if (v21 == -192)
        {
          break;
        }

        v21 -= 96;
        if (v26 >= *(v22 + 24))
        {
          v24 = v3 + v21 + 288;
          goto LABEL_39;
        }
      }

      v24 = v3;
LABEL_39:
      *v24 = v26;
      IKString::operator=(v22 + 25, v27);
      IKString::operator=(v22 + 28, &v29);
      *(v24 + 64) = v32;
      *(v22 + 17) = v33;
      if (v30)
      {
        (*(*v31 + 24))(v31, v29, 0, 8);
        v29 = 0;
        v30 = 0;
      }

      if (v27[1])
      {
        (*(*v28 + 24))(v28, v27[0], 0, 8);
      }

      if (++v18 == 8)
      {
        return v13 + 12 == a2;
      }
    }

    v16 = v13 + 12;
    v17 += 96;
    if (v13 + 12 == a2)
    {
      return 1;
    }
  }
}

uint64_t *std::swap[abi:nn200100]<FIK::RigBoneBase>(uint64_t *a1, uint64_t *a2)
{
  v7 = *a1;
  IKString::IKString(v8, a1 + 1, a1[3]);
  IKString::IKString(&v10, a1 + 4, a1[6]);
  v4 = *(a1 + 5);
  v13 = *(a1 + 4);
  v14 = v4;
  *a1 = *a2;
  IKString::operator=(a1 + 1, (a2 + 1));
  IKString::operator=(a1 + 4, (a2 + 4));
  *(a1 + 4) = *(a2 + 4);
  *(a1 + 5) = *(a2 + 5);
  *a2 = v7;
  IKString::operator=(a2 + 1, v8);
  result = IKString::operator=(a2 + 4, &v10);
  v6 = v14;
  *(a2 + 4) = v13;
  *(a2 + 5) = v6;
  if (v11)
  {
    result = (*(*v12 + 24))(v12, v10, 0, 8);
    v10 = 0;
    v11 = 0;
  }

  if (v8[1])
  {
    return (*(*v9 + 24))(v9, v8[0], 0, 8);
  }

  return result;
}

uint64_t anonymous namespace::findIndexOf<std::string_view>(void *__s2, size_t __n, uint64_t a3, uint64_t a4)
{
  v5 = 16 * a4;
  if (a4)
  {
    v8 = a3 + 16 * a4;
    v9 = 16 * a4;
    v10 = a3;
    while (*(v10 + 8) != __n || memcmp(*v10, __s2, __n))
    {
      v10 += 16;
      v9 -= 16;
      if (!v9)
      {
        v10 = v8;
        break;
      }
    }
  }

  else
  {
    v10 = a3;
  }

  if (v10 - a3 == v5)
  {
    return -1;
  }

  else
  {
    return (v10 - a3) >> 4;
  }
}

void *FIK::IKArray<FIK::HelperHierarchyBoneDefinition>::reserve(void *result, unint64_t a2)
{
  if (result[1] < a2)
  {
    v2 = result;
    v3 = result[3];
    v4 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (v4)
    {
      v5 = (*(*v3 + 16))(result[3], 32 * v4, 8);
      v6 = v5;
      if (32 * v4)
      {
        bzero(v5, 32 * v4);
      }
    }

    else
    {
      v6 = 0;
    }

    memcpy(v6, v2[2], 32 * *v2);
    v7 = v2[2];
    result = v2[3];
    v2[1] = v4;
    v2[2] = v6;
    v2[3] = v3;
    if (v7)
    {
      v8 = *(*result + 24);

      return v8();
    }
  }

  return result;
}

uint64_t ikinema::rig::generate_EnrollmentRigV3@<X0>(ikinema::rig *this@<X0>, uint64_t a2@<X8>)
{
  v3 = FIK::defaultAllocator(this);
  FIK::IKRig::IKRig(a2, v3);
  *(a2 + 176) = 0;
  *(a2 + 184) = 0;
  *(a2 + 192) = 0;
  *(a2 + 200) = v3;
  *(a2 + 208) = 0;
  *(a2 + 216) = 0;
  *(a2 + 224) = 0;
  *(a2 + 232) = v3;
  *(a2 + 240) = 0;
  *(a2 + 248) = 0;
  *(a2 + 256) = 0;
  *(a2 + 272) = 0;
  *(a2 + 280) = 0;
  *(a2 + 264) = v3;
  *(a2 + 288) = xmmword_245A01E80;
  *(a2 + 304) = 0;
  *(a2 + 308) = 1065353216;
  *(a2 + 48) = 1;
  IKString::assign(v4, "D9F105BF-D64B-CD22-3582-85B8113257DA", 0x24);
  *(a2 + 24) = 1065353216;
  *(a2 + 28) = 0x500000001;
  *(a2 + 36) = 0;
  *(a2 + 44) = 0;
  *(a2 + 48) = 1;
  *(a2 + 64) = 0x3727C5AC3D178D50;
  *(a2 + 72) = 0x1903DCCCCCDLL;
  *(a2 + 80) = 0x3F80000040800000;
  *(a2 + 88) = 257;
  *(a2 + 90) = 0;
  *(a2 + 100) = 0;
  *(a2 + 92) = 0;
  *(a2 + 108) = 0x3F80000000000000;
  *(a2 + 116) = 256;
  *(a2 + 120) = 1117782016;
  FIK::IKArray<FIK::MoCapTask>::reserve(a2 + 176, 0xBuLL);
  v5 = *(a2 + 16);
  v144 = 0u;
  v145 = v5;
  v146 = 0;
  v147 = 0;
  v148 = v5;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v5;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0uLL;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v6 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v6 - 256), "head_joint_Task", 0xF);
  IKString::assign((v6 - 232), "head_joint", 0xA);
  *(v6 - 208) = 12;
  *(v6 - 52) = 0;
  *(v6 - 204) = 257;
  *(v6 - 202) = 0;
  *(v6 - 201) = 16843009;
  *(v6 - 192) = 0xD0000000DLL;
  *(v6 - 197) = 257;
  *(v6 - 176) = vdupq_n_s32(0x43200000u);
  *(v6 - 160) = vdupq_n_s32(0x42C80000u);
  __asm { FMOV            V0.4S, #4.0 }

  *(v6 - 144) = _Q0;
  *(v6 - 128) = _Q0;
  *(v6 - 112) = 0;
  *(v6 - 104) = 0;
  *(v6 - 99) = 0;
  *(v6 - 88) = 0xBF80000000000005;
  IKString::assign((v6 - 80), "head_joint", 0xA);
  *(v6 - 56) = -1;
  *(v6 - 48) = 0u;
  *(v6 - 32) = xmmword_245A01E80;
  __asm { FMOV            V2.4S, #1.0 }

  v143 = _Q2;
  *(v6 - 16) = _Q2;
  v13 = *(a2 + 16);
  v144 = 0u;
  v145 = v13;
  v146 = 0;
  v147 = 0;
  v148 = v13;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v13;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0;
    *&v163[3] = 0;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v14 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v14 - 256), "hips_joint_Task", 0xF);
  IKString::assign((v14 - 232), "hips_joint", 0xA);
  *(v14 - 208) = 0;
  *(v14 - 52) = 0;
  *(v14 - 204) = 257;
  *(v14 - 202) = 0;
  *(v14 - 201) = 16843009;
  *(v14 - 197) = 257;
  *(v14 - 192) = 0x100000001;
  __asm { FMOV            V1.4S, #30.0 }

  *(v14 - 176) = xmmword_245A04690;
  *(v14 - 160) = _Q1;
  v142 = _Q1;
  *&v16 = 0x4000000040000000;
  *(&v16 + 1) = 0x4000000040000000;
  *(v14 - 144) = v16;
  *(v14 - 128) = v16;
  *(v14 - 112) = 0;
  *(v14 - 104) = 0;
  *(v14 - 88) = 0xBF80000000000005;
  *(v14 - 99) = 0;
  IKString::assign((v14 - 80), "virtualHips", 0xB);
  *(v14 - 56) = -1;
  *(v14 - 48) = 0u;
  *(v14 - 32) = xmmword_245A01E80;
  *(v14 - 16) = v143;
  v17 = *(a2 + 16);
  v144 = 0u;
  v145 = v17;
  v146 = 0;
  v147 = 0;
  v148 = v17;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v17;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0;
    *&v163[3] = 0;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v18 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v18 - 256), "left_arm_joint_Task", 0x13);
  IKString::assign((v18 - 232), "left_arm_joint", 0xE);
  *(v18 - 208) = 14;
  *(v18 - 52) = 0;
  *(v18 - 204) = 1;
  *(v18 - 202) = 0;
  *(v18 - 201) = 16843009;
  *(v18 - 197) = 257;
  *(v18 - 192) = 0xFFFFFFFF00000002;
  *(v18 - 176) = v142;
  *(v18 - 160) = v143;
  *&v19 = 0x4000000040000000;
  *(&v19 + 1) = 0x4000000040000000;
  *(v18 - 144) = v19;
  *(v18 - 128) = v19;
  *(v18 - 112) = 0;
  *(v18 - 104) = 0;
  *(v18 - 88) = 0xBF80000000000005;
  *(v18 - 99) = 0;
  IKString::assign((v18 - 80), "left_arm_joint", 0xE);
  *(v18 - 56) = -1;
  *(v18 - 48) = 0u;
  *(v18 - 32) = xmmword_245A01E80;
  *(v18 - 16) = v143;
  v20 = *(a2 + 16);
  v144 = 0u;
  v145 = v20;
  v146 = 0;
  v147 = 0;
  v148 = v20;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v20;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0;
    *&v163[3] = 0;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v21 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v21 - 256), "left_forearm_joint_Task", 0x17);
  IKString::assign((v21 - 232), "left_forearm_joint", 0x12);
  *(v21 - 208) = 15;
  *(v21 - 52) = 0;
  *(v21 - 204) = 1;
  *(v21 - 202) = 0;
  *(v21 - 201) = 16843009;
  *(v21 - 197) = 257;
  *(v21 - 192) = 0xFFFFFFFF00000002;
  __asm { FMOV            V1.4S, #25.0 }

  v141 = _Q1;
  *(v21 - 176) = _Q1;
  *(v21 - 160) = v143;
  *&v23 = 0x4000000040000000;
  *(&v23 + 1) = 0x4000000040000000;
  *(v21 - 144) = v23;
  *(v21 - 128) = v23;
  *(v21 - 112) = 0;
  *(v21 - 104) = 0;
  *(v21 - 88) = 0xBF80000000000005;
  *(v21 - 99) = 0;
  IKString::assign((v21 - 80), "left_forearm_joint", 0x12);
  *(v21 - 56) = -1;
  *(v21 - 48) = 0u;
  *(v21 - 32) = xmmword_245A01E80;
  *(v21 - 16) = v143;
  v24 = *(a2 + 16);
  v144 = 0u;
  v145 = v24;
  v146 = 0;
  v147 = 0;
  v148 = v24;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v24;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0;
    *&v163[3] = 0;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v25 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v25 - 256), "left_hand_joint_Task", 0x14);
  IKString::assign((v25 - 232), "left_hand_joint", 0xF);
  *(v25 - 208) = 16;
  *(v25 - 52) = 0;
  *(v25 - 204) = 257;
  *(v25 - 202) = 0;
  *(v25 - 201) = 16843009;
  *(v25 - 197) = 257;
  *(v25 - 192) = 0xC0000000CLL;
  *(v25 - 176) = 0u;
  *(v25 - 160) = 0u;
  *&v26 = 0x4000000040000000;
  *(&v26 + 1) = 0x4000000040000000;
  *(v25 - 144) = v26;
  *(v25 - 128) = v26;
  *(v25 - 112) = 0;
  *(v25 - 104) = 0;
  *(v25 - 88) = 0xBF80000000000005;
  *(v25 - 99) = 0;
  IKString::assign((v25 - 80), "left_hand_joint", 0xF);
  *(v25 - 56) = -1;
  *(v25 - 48) = 0u;
  *(v25 - 32) = xmmword_245A01E80;
  *(v25 - 16) = v143;
  v27 = *(a2 + 16);
  v144 = 0u;
  v145 = v27;
  v146 = 0;
  v147 = 0;
  v148 = v27;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v27;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0;
    *&v163[3] = 0;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v28 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v28 - 256), "neck_1_joint_Task", 0x11);
  IKString::assign((v28 - 232), "neck_1_joint", 0xC);
  *(v28 - 208) = 8;
  *(v28 - 52) = 0;
  *(v28 - 204) = 1;
  *(v28 - 202) = 0;
  *(v28 - 201) = 16843009;
  *(v28 - 197) = 257;
  *(v28 - 192) = -4294967287;
  __asm { FMOV            V1.4S, #20.0 }

  v140 = _Q1;
  *(v28 - 176) = _Q1;
  *(v28 - 160) = v143;
  *&v30 = 0x4000000040000000;
  *(&v30 + 1) = 0x4000000040000000;
  *(v28 - 144) = v30;
  *(v28 - 128) = v30;
  *(v28 - 112) = 0;
  *(v28 - 104) = 0;
  *(v28 - 88) = 0xBF80000000000005;
  *(v28 - 99) = 0;
  IKString::assign((v28 - 80), "neck_1_joint", 0xC);
  *(v28 - 56) = -1;
  *(v28 - 48) = 0u;
  *(v28 - 32) = xmmword_245A01E80;
  *(v28 - 16) = v143;
  v31 = *(a2 + 16);
  v144 = 0u;
  v145 = v31;
  v146 = 0;
  v147 = 0;
  v148 = v31;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v31;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0;
    *&v163[3] = 0;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v32 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v32 - 256), "right_arm_joint_Task", 0x14);
  IKString::assign((v32 - 232), "right_arm_joint", 0xF);
  *(v32 - 208) = 18;
  *(v32 - 52) = 0;
  *(v32 - 204) = 1;
  *(v32 - 202) = 0;
  *(v32 - 201) = 16843009;
  *(v32 - 197) = 257;
  *(v32 - 192) = 0xFFFFFFFF00000002;
  *(v32 - 176) = v142;
  *(v32 - 160) = v143;
  *&v33 = 0x4000000040000000;
  *(&v33 + 1) = 0x4000000040000000;
  *(v32 - 144) = v33;
  *(v32 - 128) = v33;
  *(v32 - 112) = 0;
  *(v32 - 104) = 0;
  *(v32 - 88) = 0xBF80000000000005;
  *(v32 - 99) = 0;
  IKString::assign((v32 - 80), "right_arm_joint", 0xF);
  *(v32 - 56) = -1;
  *(v32 - 48) = 0u;
  *(v32 - 32) = xmmword_245A01E80;
  *(v32 - 16) = v143;
  v34 = *(a2 + 16);
  v144 = 0u;
  v145 = v34;
  v146 = 0;
  v147 = 0;
  v148 = v34;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v34;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0;
    *&v163[3] = 0;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v35 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v35 - 256), "right_forearm_joint_Task", 0x18);
  IKString::assign((v35 - 232), "right_forearm_joint", 0x13);
  *(v35 - 208) = 19;
  *(v35 - 52) = 0;
  *(v35 - 204) = 1;
  *(v35 - 202) = 0;
  *(v35 - 201) = 16843009;
  *(v35 - 197) = 257;
  *(v35 - 192) = 0xFFFFFFFF00000002;
  *(v35 - 176) = v141;
  *(v35 - 160) = v143;
  *&v36 = 0x4000000040000000;
  *(&v36 + 1) = 0x4000000040000000;
  *(v35 - 144) = v36;
  *(v35 - 128) = v36;
  *(v35 - 112) = 0;
  *(v35 - 104) = 0;
  *(v35 - 88) = 0xBF80000000000005;
  *(v35 - 99) = 0;
  IKString::assign((v35 - 80), "right_forearm_joint", 0x13);
  *(v35 - 56) = -1;
  *(v35 - 48) = 0u;
  *(v35 - 32) = xmmword_245A01E80;
  *(v35 - 16) = v143;
  v37 = *(a2 + 16);
  v144 = 0u;
  v145 = v37;
  v146 = 0;
  v147 = 0;
  v148 = v37;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v37;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0;
    *&v163[3] = 0;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v38 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v38 - 256), "right_hand_joint_Task", 0x15);
  IKString::assign((v38 - 232), "right_hand_joint", 0x10);
  *(v38 - 208) = 20;
  *(v38 - 52) = 0;
  *(v38 - 204) = 257;
  *(v38 - 202) = 0;
  *(v38 - 201) = 16843009;
  *(v38 - 197) = 257;
  *(v38 - 192) = 0xC0000000CLL;
  *(v38 - 176) = 0u;
  *(v38 - 160) = 0u;
  *&v39 = 0x4000000040000000;
  *(&v39 + 1) = 0x4000000040000000;
  *(v38 - 144) = v39;
  *(v38 - 128) = v39;
  *(v38 - 112) = 0;
  *(v38 - 104) = 0;
  *(v38 - 88) = 0xBF80000000000005;
  *(v38 - 99) = 0;
  IKString::assign((v38 - 80), "right_hand_joint", 0x10);
  *(v38 - 56) = -1;
  *(v38 - 48) = 0u;
  *(v38 - 32) = xmmword_245A01E80;
  *(v38 - 16) = v143;
  v40 = *(a2 + 16);
  v144 = 0u;
  v145 = v40;
  v146 = 0;
  v147 = 0;
  v148 = v40;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v40;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0;
    *&v163[3] = 0;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v41 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v41 - 256), "spine_6_joint_Task", 0x12);
  IKString::assign((v41 - 232), "spine_6_joint", 0xD);
  *(v41 - 208) = 6;
  *(v41 - 52) = 0;
  *(v41 - 204) = 1;
  *(v41 - 202) = 0;
  *(v41 - 201) = 16843009;
  *(v41 - 197) = 257;
  *(v41 - 192) = 0xFFFFFFFF00000007;
  *(v41 - 176) = v140;
  *(v41 - 160) = v143;
  *&v42 = 0x4000000040000000;
  *(&v42 + 1) = 0x4000000040000000;
  *(v41 - 144) = v42;
  *(v41 - 128) = v42;
  *(v41 - 112) = 0;
  *(v41 - 104) = 0;
  *(v41 - 88) = 0xBF80000000000005;
  *(v41 - 99) = 0;
  IKString::assign((v41 - 80), "spine_6_joint", 0xD);
  *(v41 - 56) = -1;
  *(v41 - 48) = 0u;
  *(v41 - 32) = xmmword_245A01E80;
  *(v41 - 16) = v143;
  v43 = *(a2 + 16);
  v144 = 0u;
  v145 = v43;
  v146 = 0;
  v147 = 0;
  v148 = v43;
  *v149 = -1;
  *&v149[4] = 257;
  v149[6] = 0;
  *&v149[7] = 16843009;
  v150 = 257;
  v151 = -1;
  v153 = xmmword_245A02300;
  v154 = xmmword_245A02310;
  v155 = xmmword_245A022D0;
  v156 = 0x4000000040000000;
  v157 = 0x40000000;
  v159 = 0;
  v158 = 0;
  v161 = 0;
  v160 = 0;
  v162 = 5;
  memset(v163, 0, sizeof(v163));
  v164 = v43;
  v165 = -1;
  v166 = 1;
  v167 = 0;
  v168 = 0;
  v169 = xmmword_245A01E80;
  v170 = xmmword_245A01EF0;
  FIK::IKArray<FIK::MoCapTask>::push_back<FIK::MoCapTask,void>((a2 + 176), &v144);
  if (*&v163[3])
  {
    (*(*v164 + 24))(v164, *&v163[1], 0, 8);
    *&v163[1] = 0;
    *&v163[3] = 0;
  }

  if (v147)
  {
    (*(*v148 + 24))(v148, v146, 0, 8);
    v146 = 0;
    v147 = 0;
  }

  if (*(&v144 + 1))
  {
    (*(*v145 + 24))(v145, v144, 0, 8);
  }

  v44 = *(a2 + 192) + (*(a2 + 176) << 8);
  IKString::assign((v44 - 256), "spine_7_joint_Task", 0x12);
  IKString::assign((v44 - 232), "spine_7_joint", 0xD);
  *(v44 - 208) = 7;
  *(v44 - 52) = 0;
  *(v44 - 204) = 1;
  *(v44 - 202) = 0;
  *(v44 - 201) = 16843009;
  *(v44 - 197) = 257;
  *(v44 - 192) = 0xFFFFFFFF00000008;
  *(v44 - 176) = vdupq_n_s32(0x42700000u);
  *(v44 - 160) = v143;
  *&v45 = 0x4000000040000000;
  *(&v45 + 1) = 0x4000000040000000;
  *(v44 - 144) = v45;
  *(v44 - 128) = v45;
  *(v44 - 112) = 0;
  *(v44 - 104) = 0;
  *(v44 - 99) = 0;
  *(v44 - 88) = 0xBF80000000000005;
  IKString::assign((v44 - 80), "spine_7_joint", 0xD);
  *(v44 - 56) = -1;
  *(v44 - 48) = 0u;
  *(v44 - 32) = xmmword_245A01E80;
  *(v44 - 16) = v143;
  FIK::IKArray<FIK::MoCapBone>::reserve(a2 + 208, 0x15uLL);
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v46 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v46 - 190) = 0;
  *(v46 - 188) = 0;
  *(v46 - 192) = 1;
  *(v46 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v46 - 184) = 1;
  *(v46 - 172) = 5;
  *(v46 - 544) = 0xFFFFFFFF00000000;
  IKString::assign((v46 - 536), "hips_joint", 0xA);
  IKString::assign((v46 - 512), &unk_245A04BAE, 0);
  *(v46 - 464) = xmmword_245A01E80;
  *(v46 - 480) = xmmword_245A046A0;
  *(v46 - 448) = 16843009;
  *(v46 - 444) = 256;
  *(v46 - 442) = 1;
  v47 = v46 - 441;
  *v47 = 0;
  *(v47 + 4) = 0;
  *(v46 - 432) = xmmword_245A046B0;
  *(v46 - 416) = 0x3F80000000000000;
  *(v46 - 400) = v143;
  *(v46 - 384) = v143;
  *(v46 - 368) = vdupq_n_s32(0xC3B40000);
  *(v46 - 352) = vdupq_n_s32(0x43B40000u);
  v48 = (v46 - 336);
  *v48 = 0u;
  v48[1] = 0u;
  v48[2] = 0u;
  *(v46 - 256) = 0u;
  *(v46 - 240) = xmmword_245A01E80;
  *(v46 - 224) = 0u;
  *(v46 - 208) = xmmword_245A01E80;
  IKString::assign((v46 - 288), "virtualHips", 0xB);
  *(v46 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v49 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v49 - 190) = 0;
  *(v49 - 188) = 0;
  *(v49 - 192) = 0;
  *(v49 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v49 - 184) = 0;
  *(v49 - 172) = 5;
  *(v49 - 544) = 0xFFFFFFFF00000001;
  IKString::assign((v49 - 536), "spine_1_joint", 0xD);
  IKString::assign((v49 - 512), "hips_joint", 0xA);
  *&v50 = 0x3F0000003F000000;
  *(&v50 + 1) = 0x3F0000003F000000;
  *(v49 - 464) = v50;
  *(v49 - 480) = xmmword_245A046C0;
  v51 = v49 - 448;
  *v51 = 16843009;
  *(v51 + 3) = 16843009;
  *(v49 - 437) = 0;
  *(v49 - 432) = xmmword_245A046D0;
  *(v49 - 416) = 0x3F80000000000000;
  *(v49 - 400) = v50;
  *(v49 - 384) = v143;
  *(v49 - 368) = vdupq_n_s32(0xC3B40000);
  *(v49 - 352) = vdupq_n_s32(0x43B40000u);
  v52 = (v49 - 336);
  *v52 = 0u;
  v52[1] = 0u;
  v52[2] = 0u;
  *(v49 - 256) = 0u;
  *(v49 - 240) = xmmword_245A01E80;
  *(v49 - 224) = 0u;
  *(v49 - 208) = xmmword_245A01E80;
  IKString::assign((v49 - 288), &unk_245A04BAE, 0);
  *(v49 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v53 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v53 - 190) = 0;
  *(v53 - 188) = 0;
  *(v53 - 192) = 0;
  *(v53 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v53 - 184) = 0;
  *(v53 - 172) = 5;
  *(v53 - 544) = 0xFFFFFFFF00000002;
  IKString::assign((v53 - 536), "spine_2_joint", 0xD);
  IKString::assign((v53 - 512), "spine_1_joint", 0xD);
  *(v53 - 464) = xmmword_245A01E80;
  *(v53 - 480) = xmmword_245A040E0;
  v54 = v53 - 448;
  *v54 = 16843009;
  *(v54 + 3) = 16843009;
  *(v53 - 437) = 0;
  *(v53 - 432) = xmmword_245A046E0;
  *(v53 - 416) = 0x3F80000000000000;
  *&v55 = 0x3F0000003F000000;
  *(&v55 + 1) = 0x3F0000003F000000;
  *(v53 - 400) = v55;
  *(v53 - 384) = v143;
  *(v53 - 368) = vdupq_n_s32(0xC3B40000);
  *(v53 - 352) = vdupq_n_s32(0x43B40000u);
  v56 = (v53 - 336);
  *v56 = 0u;
  v56[1] = 0u;
  v56[2] = 0u;
  *(v53 - 256) = 0u;
  *(v53 - 240) = xmmword_245A01E80;
  *(v53 - 224) = 0u;
  *(v53 - 208) = xmmword_245A01E80;
  IKString::assign((v53 - 288), &unk_245A04BAE, 0);
  *(v53 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v57 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v57 - 190) = 0;
  *(v57 - 188) = 0;
  *(v57 - 192) = 0;
  *(v57 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v57 - 184) = 0;
  *(v57 - 172) = 5;
  *(v57 - 544) = 0xFFFFFFFF00000003;
  IKString::assign((v57 - 536), "spine_3_joint", 0xD);
  IKString::assign((v57 - 512), "spine_2_joint", 0xD);
  *(v57 - 464) = xmmword_245A01E80;
  *(v57 - 480) = xmmword_245A04110;
  v58 = v57 - 448;
  *v58 = 16843009;
  *(v58 + 3) = 16843009;
  *(v57 - 437) = 0;
  *(v57 - 432) = xmmword_245A046F0;
  *(v57 - 416) = 0x3F80000000000000;
  *&v59 = 0x3F0000003F000000;
  *(&v59 + 1) = 0x3F0000003F000000;
  *(v57 - 400) = v59;
  *(v57 - 384) = v143;
  *(v57 - 368) = vdupq_n_s32(0xC3B40000);
  *(v57 - 352) = vdupq_n_s32(0x43B40000u);
  v60 = (v57 - 336);
  *v60 = 0u;
  v60[1] = 0u;
  v60[2] = 0u;
  *(v57 - 256) = 0u;
  *(v57 - 240) = xmmword_245A01E80;
  *(v57 - 224) = 0u;
  *(v57 - 208) = xmmword_245A01E80;
  IKString::assign((v57 - 288), &unk_245A04BAE, 0);
  *(v57 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v61 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v61 - 190) = 0;
  *(v61 - 188) = 0;
  *(v61 - 192) = 0;
  *(v61 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v61 - 184) = 0;
  *(v61 - 172) = 5;
  *(v61 - 544) = 0xFFFFFFFF00000004;
  IKString::assign((v61 - 536), "spine_4_joint", 0xD);
  IKString::assign((v61 - 512), "spine_3_joint", 0xD);
  *(v61 - 464) = xmmword_245A01E80;
  *(v61 - 480) = xmmword_245A04700;
  v62 = v61 - 448;
  *v62 = 16843009;
  *(v62 + 3) = 16843009;
  *(v61 - 437) = 0;
  *(v61 - 432) = xmmword_245A04710;
  *(v61 - 416) = 0x3F80000000000000;
  *(v61 - 400) = vdupq_n_s32(0x3F19999Au);
  *(v61 - 384) = v143;
  *(v61 - 368) = vdupq_n_s32(0xC3B40000);
  *(v61 - 352) = vdupq_n_s32(0x43B40000u);
  v63 = (v61 - 336);
  *v63 = 0u;
  v63[1] = 0u;
  v63[2] = 0u;
  *(v61 - 256) = 0u;
  *(v61 - 240) = xmmword_245A01E80;
  *(v61 - 224) = 0u;
  *(v61 - 208) = xmmword_245A01E80;
  IKString::assign((v61 - 288), &unk_245A04BAE, 0);
  *(v61 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v64 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v64 - 190) = 0;
  *(v64 - 188) = 0;
  *(v64 - 192) = 0;
  *(v64 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v64 - 184) = 0;
  *(v64 - 172) = 5;
  *(v64 - 544) = -4294967291;
  IKString::assign((v64 - 536), "spine_5_joint", 0xD);
  IKString::assign((v64 - 512), "spine_4_joint", 0xD);
  *(v64 - 464) = xmmword_245A01E80;
  *(v64 - 480) = xmmword_245A04170;
  v65 = v64 - 448;
  *v65 = 16843009;
  *(v65 + 3) = 16843009;
  *(v64 - 437) = 0;
  *(v64 - 432) = xmmword_245A04720;
  *(v64 - 416) = 0x3F80000000000000;
  *(v64 - 400) = vdupq_n_s32(0x3F333333u);
  *(v64 - 384) = v143;
  *(v64 - 368) = vdupq_n_s32(0xC3B40000);
  *(v64 - 352) = vdupq_n_s32(0x43B40000u);
  v66 = (v64 - 336);
  *v66 = 0u;
  v66[1] = 0u;
  v66[2] = 0u;
  *(v64 - 256) = 0u;
  *(v64 - 240) = xmmword_245A01E80;
  *(v64 - 224) = 0u;
  *(v64 - 208) = xmmword_245A01E80;
  IKString::assign((v64 - 288), &unk_245A04BAE, 0);
  *(v64 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v67 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v67 - 190) = 0;
  *(v67 - 188) = 0;
  *(v67 - 192) = 1;
  *(v67 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v67 - 184) = 1;
  *(v67 - 172) = 5;
  *(v67 - 544) = -4294967290;
  IKString::assign((v67 - 536), "spine_6_joint", 0xD);
  IKString::assign((v67 - 512), "spine_5_joint", 0xD);
  *(v67 - 464) = xmmword_245A04730;
  *(v67 - 480) = xmmword_245A04740;
  v68 = v67 - 448;
  *v68 = 16843009;
  *(v68 + 3) = 16843009;
  *(v67 - 437) = 0;
  *(v67 - 432) = xmmword_245A04750;
  *(v67 - 416) = 0x3F80000000000000;
  *(v67 - 400) = vdupq_n_s32(0x3F333333u);
  *(v67 - 384) = v143;
  *(v67 - 368) = vdupq_n_s32(0xC3B40000);
  *(v67 - 352) = vdupq_n_s32(0x43B40000u);
  v69 = (v67 - 336);
  *v69 = 0u;
  v69[1] = 0u;
  v69[2] = 0u;
  *(v67 - 256) = 0u;
  *(v67 - 240) = xmmword_245A01E80;
  *(v67 - 224) = 0u;
  *(v67 - 208) = xmmword_245A01E80;
  IKString::assign((v67 - 288), "spine_6_joint", 0xD);
  *(v67 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v70 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v70 - 190) = 0;
  *(v70 - 188) = 0;
  *(v70 - 192) = 1;
  *(v70 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v70 - 184) = 1;
  *(v70 - 172) = 5;
  *(v70 - 544) = 0xFFFFFFFF00000007;
  IKString::assign((v70 - 536), "spine_7_joint", 0xD);
  IKString::assign((v70 - 512), "spine_6_joint", 0xD);
  *(v70 - 464) = xmmword_245A04760;
  *(v70 - 480) = xmmword_245A04770;
  v71 = v70 - 448;
  *v71 = 16843009;
  *(v71 + 3) = 16843009;
  *(v70 - 437) = 0;
  *(v70 - 432) = xmmword_245A04780;
  *(v70 - 416) = 0x3F80000000000000;
  *(v70 - 400) = vdupq_n_s32(0x3F4CCCCDu);
  *(v70 - 384) = v143;
  *(v70 - 368) = vdupq_n_s32(0xC3B40000);
  *(v70 - 352) = vdupq_n_s32(0x43B40000u);
  v72 = (v70 - 336);
  *v72 = 0u;
  v72[1] = 0u;
  v72[2] = 0u;
  *(v70 - 256) = 0u;
  *(v70 - 240) = xmmword_245A01E80;
  *(v70 - 224) = 0u;
  *(v70 - 208) = xmmword_245A01E80;
  IKString::assign((v70 - 288), "spine_7_joint", 0xD);
  *(v70 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v73 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v73 - 190) = 0;
  *(v73 - 188) = 0;
  *(v73 - 192) = 1;
  *(v73 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v73 - 184) = 1;
  *(v73 - 172) = 5;
  *(v73 - 544) = 0xFFFFFFFF00000008;
  IKString::assign((v73 - 536), "neck_1_joint", 0xC);
  IKString::assign((v73 - 512), "spine_7_joint", 0xD);
  *(v73 - 464) = xmmword_245A04790;
  *(v73 - 480) = xmmword_245A047A0;
  v74 = v73 - 448;
  *v74 = 16843009;
  *(v74 + 3) = 16843009;
  *(v73 - 437) = 0;
  *(v73 - 432) = xmmword_245A047B0;
  *(v73 - 416) = 0x3F80000000000000;
  *(v73 - 400) = v143;
  *(v73 - 384) = v143;
  *(v73 - 368) = vdupq_n_s32(0xC3B40000);
  *(v73 - 352) = vdupq_n_s32(0x43B40000u);
  v75 = (v73 - 336);
  *v75 = 0u;
  v75[1] = 0u;
  v75[2] = 0u;
  *(v73 - 256) = 0u;
  *(v73 - 240) = xmmword_245A01E80;
  *(v73 - 224) = 0u;
  *(v73 - 208) = xmmword_245A01E80;
  IKString::assign((v73 - 288), "neck_1_joint", 0xC);
  *(v73 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v76 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v76 - 190) = 0;
  *(v76 - 188) = 0;
  *(v76 - 192) = 0;
  *(v76 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v76 - 184) = 0;
  *(v76 - 172) = 5;
  *(v76 - 544) = -4294967287;
  IKString::assign((v76 - 536), "neck_2_joint", 0xC);
  IKString::assign((v76 - 512), "neck_1_joint", 0xC);
  *(v76 - 464) = xmmword_245A047C0;
  *(v76 - 480) = xmmword_245A047D0;
  v77 = v76 - 448;
  *v77 = 16843009;
  *(v77 + 3) = 16843009;
  *(v76 - 437) = 0;
  *(v76 - 432) = xmmword_245A047E0;
  *(v76 - 416) = 0x3F80000000000000;
  *(v76 - 400) = v143;
  *(v76 - 384) = v143;
  *(v76 - 368) = vdupq_n_s32(0xC3B40000);
  *(v76 - 352) = vdupq_n_s32(0x43B40000u);
  v78 = (v76 - 336);
  *v78 = 0u;
  v78[1] = 0u;
  v78[2] = 0u;
  *(v76 - 256) = 0u;
  *(v76 - 240) = xmmword_245A01E80;
  *(v76 - 224) = 0u;
  *(v76 - 208) = xmmword_245A01E80;
  IKString::assign((v76 - 288), &unk_245A04BAE, 0);
  *(v76 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v79 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v79 - 190) = 0;
  *(v79 - 188) = 0;
  *(v79 - 192) = 0;
  *(v79 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v79 - 184) = 0;
  *(v79 - 172) = 5;
  *(v79 - 544) = -4294967286;
  IKString::assign((v79 - 536), "neck_3_joint", 0xC);
  IKString::assign((v79 - 512), "neck_2_joint", 0xC);
  *(v79 - 464) = xmmword_245A047F0;
  *(v79 - 480) = xmmword_245A04800;
  v80 = v79 - 448;
  *v80 = 16843009;
  *(v80 + 3) = 16843009;
  *(v79 - 437) = 0;
  *(v79 - 432) = xmmword_245A047E0;
  *(v79 - 416) = 0x3F80000000000000;
  *(v79 - 400) = v143;
  *(v79 - 384) = v143;
  *(v79 - 368) = vdupq_n_s32(0xC3B40000);
  *(v79 - 352) = vdupq_n_s32(0x43B40000u);
  v81 = (v79 - 336);
  *v81 = 0u;
  v81[1] = 0u;
  v81[2] = 0u;
  *(v79 - 256) = 0u;
  *(v79 - 240) = xmmword_245A01E80;
  *(v79 - 224) = 0u;
  *(v79 - 208) = xmmword_245A01E80;
  IKString::assign((v79 - 288), &unk_245A04BAE, 0);
  *(v79 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v82 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v82 - 190) = 0;
  *(v82 - 188) = 0;
  *(v82 - 192) = 0;
  *(v82 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v82 - 184) = 0;
  *(v82 - 172) = 5;
  *(v82 - 544) = -4294967285;
  IKString::assign((v82 - 536), "neck_4_joint", 0xC);
  IKString::assign((v82 - 512), "neck_3_joint", 0xC);
  *(v82 - 464) = xmmword_245A04810;
  *(v82 - 480) = xmmword_245A04820;
  v83 = v82 - 448;
  *v83 = 16843009;
  *(v83 + 3) = 16843009;
  *(v82 - 437) = 0;
  *(v82 - 432) = xmmword_245A04830;
  *(v82 - 416) = 0x3F80000000000000;
  *(v82 - 400) = v143;
  *(v82 - 384) = v143;
  *(v82 - 368) = vdupq_n_s32(0xC3B40000);
  *(v82 - 352) = vdupq_n_s32(0x43B40000u);
  v84 = (v82 - 336);
  *v84 = 0u;
  v84[1] = 0u;
  v84[2] = 0u;
  *(v82 - 256) = 0u;
  *(v82 - 240) = xmmword_245A01E80;
  *(v82 - 224) = 0u;
  *(v82 - 208) = xmmword_245A01E80;
  IKString::assign((v82 - 288), &unk_245A04BAE, 0);
  *(v82 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v85 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v85 - 190) = 0;
  *(v85 - 188) = 0;
  *(v85 - 192) = 1;
  *(v85 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v85 - 184) = 1;
  *(v85 - 172) = 5;
  *(v85 - 544) = -4294967284;
  IKString::assign((v85 - 536), "head_joint", 0xA);
  IKString::assign((v85 - 512), "neck_4_joint", 0xC);
  *(v85 - 464) = xmmword_245A04840;
  *(v85 - 480) = xmmword_245A04850;
  *(v85 - 448) = 16843009;
  *(v85 - 444) = 256;
  *(v85 - 442) = 1;
  v86 = v85 - 441;
  *v86 = 0;
  *(v86 + 4) = 0;
  *(v85 - 432) = xmmword_245A022E0;
  *(v85 - 416) = 0x3F80000000000000;
  *(v85 - 400) = v143;
  *(v85 - 384) = v143;
  *(v85 - 368) = vdupq_n_s32(0xC3B40000);
  *(v85 - 352) = vdupq_n_s32(0x43B40000u);
  v87 = (v85 - 336);
  *v87 = 0u;
  v87[1] = 0u;
  v87[2] = 0u;
  *(v85 - 256) = 0u;
  *(v85 - 240) = xmmword_245A01E80;
  *(v85 - 224) = 0u;
  *(v85 - 208) = xmmword_245A01E80;
  IKString::assign((v85 - 288), "head_joint", 0xA);
  *(v85 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v88 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v88 - 190) = 0;
  *(v88 - 188) = 0;
  *(v88 - 192) = 0;
  *(v88 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v88 - 184) = 0;
  *(v88 - 172) = 5;
  *(v88 - 544) = -4294967283;
  IKString::assign((v88 - 536), "left_shoulder_1_joint", 0x15);
  IKString::assign((v88 - 512), "spine_7_joint", 0xD);
  *(v88 - 464) = xmmword_245A04860;
  *(v88 - 480) = xmmword_245A042E0;
  *(v88 - 448) = 1;
  v89 = v88 - 446;
  v90 = v88 - 441;
  *v89 = 16843009;
  *(v89 + 4) = 1;
  *v90 = 0;
  *(v90 + 4) = 0;
  *(v88 - 432) = xmmword_245A04870;
  *(v88 - 416) = 0x3F80000000000000;
  *(v88 - 400) = xmmword_245A04880;
  *(v88 - 384) = xmmword_245A04300;
  *(v88 - 368) = vdupq_n_s32(0xC3B40000);
  *(v88 - 352) = vdupq_n_s32(0x43B40000u);
  v91 = (v88 - 336);
  *v91 = 0u;
  v91[1] = 0u;
  v91[2] = 0u;
  *(v88 - 256) = 0u;
  *(v88 - 240) = xmmword_245A01E80;
  *(v88 - 224) = 0u;
  *(v88 - 208) = xmmword_245A01E80;
  IKString::assign((v88 - 288), &unk_245A04BAE, 0);
  *(v88 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v92 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v92 - 190) = 0;
  *(v92 - 188) = 0;
  *(v92 - 192) = 1;
  *(v92 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v92 - 184) = 1;
  *(v92 - 172) = 5;
  *(v92 - 544) = -4294967282;
  IKString::assign((v92 - 536), "left_arm_joint", 0xE);
  IKString::assign((v92 - 512), "left_shoulder_1_joint", 0x15);
  *(v92 - 464) = xmmword_245A04890;
  *(v92 - 480) = xmmword_245A048A0;
  v93 = v92 - 448;
  *v93 = 16843009;
  *(v93 + 3) = 16843009;
  *(v92 - 437) = 0;
  *(v92 - 432) = xmmword_245A048B0;
  *(v92 - 416) = 0x3F80000000000000;
  *(v92 - 400) = xmmword_245A048C0;
  *(v92 - 384) = xmmword_245A04340;
  *(v92 - 368) = vdupq_n_s32(0xC3B40000);
  *(v92 - 352) = vdupq_n_s32(0x43B40000u);
  v94 = (v92 - 336);
  *v94 = 0u;
  v94[1] = 0u;
  v94[2] = 0u;
  *(v92 - 256) = 0u;
  *(v92 - 240) = xmmword_245A01E80;
  *(v92 - 224) = 0u;
  *(v92 - 208) = xmmword_245A01E80;
  IKString::assign((v92 - 288), "left_arm_joint", 0xE);
  *(v92 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v95 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v95 - 190) = 0;
  *(v95 - 188) = 0;
  *(v95 - 192) = 1;
  *(v95 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v95 - 184) = 1;
  *(v95 - 172) = 5;
  *(v95 - 544) = 0xFFFFFFFF0000000FLL;
  IKString::assign((v95 - 536), "left_forearm_joint", 0x12);
  IKString::assign((v95 - 512), "left_arm_joint", 0xE);
  *(v95 - 464) = xmmword_245A048D0;
  *(v95 - 480) = xmmword_245A048E0;
  v96 = v95 - 448;
  *v96 = 16843009;
  *(v96 + 3) = 16843009;
  *(v95 - 437) = 0;
  *(v95 - 432) = xmmword_245A048F0;
  *(v95 - 416) = 0x3F80000000000000;
  *(v95 - 400) = v143;
  *(v95 - 384) = v143;
  *(v95 - 368) = vdupq_n_s32(0xC3B40000);
  *(v95 - 352) = vdupq_n_s32(0x43B40000u);
  v97 = (v95 - 336);
  *v97 = 0u;
  v97[1] = 0u;
  v97[2] = 0u;
  *(v95 - 256) = 0u;
  *(v95 - 240) = xmmword_245A01E80;
  *(v95 - 224) = 0u;
  *(v95 - 208) = xmmword_245A01E80;
  IKString::assign((v95 - 288), "left_forearm_joint", 0x12);
  *(v95 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v98 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v98 - 190) = 0;
  *(v98 - 188) = 0;
  *(v98 - 192) = 1;
  *(v98 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v98 - 184) = 1;
  *(v98 - 172) = 5;
  *(v98 - 544) = 0xFFFFFFFF00000010;
  IKString::assign((v98 - 536), "left_hand_joint", 0xF);
  IKString::assign((v98 - 512), "left_forearm_joint", 0x12);
  *(v98 - 464) = xmmword_245A04900;
  *(v98 - 480) = xmmword_245A04910;
  v99 = v98 - 448;
  *v99 = 16843009;
  *(v99 + 3) = 16843009;
  *(v98 - 437) = 0;
  *(v98 - 432) = xmmword_245A022E0;
  *(v98 - 416) = 0x3F80000000000000;
  *(v98 - 400) = v143;
  *(v98 - 384) = v143;
  *(v98 - 368) = vdupq_n_s32(0xC3B40000);
  *(v98 - 352) = vdupq_n_s32(0x43B40000u);
  v100 = (v98 - 336);
  *v100 = 0u;
  v100[1] = 0u;
  v100[2] = 0u;
  *(v98 - 256) = 0u;
  *(v98 - 240) = xmmword_245A01E80;
  *(v98 - 224) = 0u;
  *(v98 - 208) = xmmword_245A01E80;
  IKString::assign((v98 - 288), "left_hand_joint", 0xF);
  *(v98 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v101 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v101 - 190) = 0;
  *(v101 - 188) = 0;
  *(v101 - 192) = 0;
  *(v101 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v101 - 184) = 0;
  *(v101 - 172) = 5;
  *(v101 - 544) = -4294967279;
  IKString::assign((v101 - 536), "right_shoulder_1_joint", 0x16);
  IKString::assign((v101 - 512), "spine_7_joint", 0xD);
  *(v101 - 464) = xmmword_245A04920;
  *(v101 - 480) = xmmword_245A043C0;
  *(v101 - 448) = 1;
  v102 = v101 - 446;
  v103 = v101 - 441;
  *v102 = 16843009;
  *(v102 + 4) = 1;
  *v103 = 0;
  *(v103 + 4) = 0;
  *(v101 - 432) = xmmword_245A04870;
  *(v101 - 416) = 0x3F80000000000000;
  *(v101 - 400) = xmmword_245A04880;
  *(v101 - 384) = xmmword_245A04300;
  *(v101 - 368) = vdupq_n_s32(0xC3B40000);
  *(v101 - 352) = vdupq_n_s32(0x43B40000u);
  v104 = (v101 - 336);
  *v104 = 0u;
  v104[1] = 0u;
  v104[2] = 0u;
  *(v101 - 256) = 0u;
  *(v101 - 240) = xmmword_245A01E80;
  *(v101 - 224) = 0u;
  *(v101 - 208) = xmmword_245A01E80;
  IKString::assign((v101 - 288), &unk_245A04BAE, 0);
  *(v101 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v105 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v105 - 190) = 0;
  *(v105 - 188) = 0;
  *(v105 - 192) = 1;
  *(v105 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v105 - 184) = 1;
  *(v105 - 172) = 5;
  *(v105 - 544) = -4294967278;
  IKString::assign((v105 - 536), "right_arm_joint", 0xF);
  IKString::assign((v105 - 512), "right_shoulder_1_joint", 0x16);
  *(v105 - 464) = xmmword_245A04930;
  *(v105 - 480) = xmmword_245A04940;
  v106 = v105 - 448;
  *v106 = 16843009;
  *(v106 + 3) = 16843009;
  *(v105 - 437) = 0;
  *(v105 - 432) = xmmword_245A048B0;
  *(v105 - 416) = 0x3F80000000000000;
  *(v105 - 400) = xmmword_245A048C0;
  *(v105 - 384) = xmmword_245A04340;
  *(v105 - 368) = vdupq_n_s32(0xC3B40000);
  *(v105 - 352) = vdupq_n_s32(0x43B40000u);
  v107 = (v105 - 336);
  *v107 = 0u;
  v107[1] = 0u;
  v107[2] = 0u;
  *(v105 - 256) = 0u;
  *(v105 - 240) = xmmword_245A01E80;
  *(v105 - 224) = 0u;
  *(v105 - 208) = xmmword_245A01E80;
  IKString::assign((v105 - 288), "right_arm_joint", 0xF);
  *(v105 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v108 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v108 - 190) = 0;
  *(v108 - 188) = 0;
  *(v108 - 192) = 1;
  *(v108 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v108 - 184) = 1;
  *(v108 - 172) = 5;
  *(v108 - 544) = -4294967277;
  IKString::assign((v108 - 536), "right_forearm_joint", 0x13);
  IKString::assign((v108 - 512), "right_arm_joint", 0xF);
  *(v108 - 464) = xmmword_245A04950;
  *(v108 - 480) = xmmword_245A04960;
  v109 = v108 - 448;
  *v109 = 16843009;
  *(v109 + 3) = 16843009;
  *(v108 - 437) = 0;
  *(v108 - 432) = xmmword_245A04970;
  *(v108 - 416) = 0x3F80000000000000;
  *(v108 - 400) = v143;
  *(v108 - 384) = v143;
  *(v108 - 368) = vdupq_n_s32(0xC3B40000);
  *(v108 - 352) = vdupq_n_s32(0x43B40000u);
  v110 = (v108 - 336);
  *v110 = 0u;
  v110[1] = 0u;
  v110[2] = 0u;
  *(v108 - 256) = 0u;
  *(v108 - 240) = xmmword_245A01E80;
  *(v108 - 224) = 0u;
  *(v108 - 208) = xmmword_245A01E80;
  IKString::assign((v108 - 288), "right_forearm_joint", 0x13);
  *(v108 - 264) = -1;
  FIK::MoCapBone::MoCapBone(&v144, *(a2 + 16));
  FIK::IKArray<FIK::MoCapBone>::push_back<FIK::MoCapBone,void>((a2 + 208), &v144);
  FIK::IKArray<IKString>::~IKArray(v174);
  if (v172)
  {
    (*(*v173 + 24))(v173, v171, 0, 8);
    v171 = 0;
    v172 = 0;
  }

  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v111 = *(a2 + 224) + 544 * *(a2 + 208);
  *(v111 - 190) = 0;
  *(v111 - 188) = 0;
  *(v111 - 192) = 1;
  *(v111 - 180) = 0x3DF5C28F3DCCCCCDLL;
  *(v111 - 184) = 1;
  *(v111 - 172) = 5;
  *(v111 - 544) = -4294967276;
  IKString::assign((v111 - 536), "right_hand_joint", 0x10);
  IKString::assign((v111 - 512), "right_forearm_joint", 0x13);
  *(v111 - 464) = xmmword_245A04900;
  *(v111 - 480) = xmmword_245A04980;
  v112 = v111 - 448;
  *v112 = 16843009;
  *(v112 + 3) = 16843009;
  *(v111 - 437) = 0;
  *(v111 - 432) = xmmword_245A022E0;
  *(v111 - 416) = 0x3F80000000000000;
  *(v111 - 400) = v143;
  *(v111 - 384) = v143;
  *(v111 - 368) = vdupq_n_s32(0xC3B40000);
  *(v111 - 352) = vdupq_n_s32(0x43B40000u);
  v113 = (v111 - 336);
  *v113 = 0u;
  v113[1] = 0u;
  v113[2] = 0u;
  *(v111 - 256) = 0u;
  *(v111 - 240) = xmmword_245A01E80;
  *(v111 - 224) = 0u;
  *(v111 - 208) = xmmword_245A01E80;
  IKString::assign((v111 - 288), "right_hand_joint", 0x10);
  *(v111 - 264) = -1;
  FIK::IKArray<FIK::RigBoneBase>::reserve(a2 + 240, 0xBuLL);
  v114 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v114;
  v147 = 0;
  v148 = 0;
  *v149 = v114;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v115 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v115 - 88), "virtualHips", 0xB);
  IKString::assign((v115 - 64), &unk_245A04BAE, 0);
  *(v115 - 32) = xmmword_245A04990;
  *(v115 - 16) = xmmword_245A01E80;
  v116 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v116;
  v147 = 0;
  v148 = 0;
  *v149 = v116;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v117 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v117 - 88), "spine_6_joint", 0xD);
  IKString::assign((v117 - 64), &unk_245A04BAE, 0);
  *(v117 - 32) = xmmword_245A049B0;
  *(v117 - 16) = xmmword_245A049A0;
  v118 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v118;
  v147 = 0;
  v148 = 0;
  *v149 = v118;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v119 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v119 - 88), "spine_7_joint", 0xD);
  IKString::assign((v119 - 64), &unk_245A04BAE, 0);
  *(v119 - 32) = xmmword_245A049D0;
  *(v119 - 16) = xmmword_245A049C0;
  v120 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v120;
  v147 = 0;
  v148 = 0;
  *v149 = v120;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v121 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v121 - 88), "neck_1_joint", 0xC);
  IKString::assign((v121 - 64), &unk_245A04BAE, 0);
  *(v121 - 32) = xmmword_245A049F0;
  *(v121 - 16) = xmmword_245A049E0;
  v122 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v122;
  v147 = 0;
  v148 = 0;
  *v149 = v122;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v123 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v123 - 88), "head_joint", 0xA);
  IKString::assign((v123 - 64), &unk_245A04BAE, 0);
  *(v123 - 32) = xmmword_245A04A10;
  *(v123 - 16) = xmmword_245A04A00;
  v124 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v124;
  v147 = 0;
  v148 = 0;
  *v149 = v124;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v125 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v125 - 88), "left_arm_joint", 0xE);
  IKString::assign((v125 - 64), &unk_245A04BAE, 0);
  *(v125 - 32) = xmmword_245A04A30;
  *(v125 - 16) = xmmword_245A04A20;
  v126 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v126;
  v147 = 0;
  v148 = 0;
  *v149 = v126;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v127 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v127 - 88), "left_forearm_joint", 0x12);
  IKString::assign((v127 - 64), &unk_245A04BAE, 0);
  *(v127 - 32) = xmmword_245A04A50;
  *(v127 - 16) = xmmword_245A04A40;
  v128 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v128;
  v147 = 0;
  v148 = 0;
  *v149 = v128;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v129 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v129 - 88), "left_hand_joint", 0xF);
  IKString::assign((v129 - 64), &unk_245A04BAE, 0);
  *(v129 - 32) = xmmword_245A04A70;
  *(v129 - 16) = xmmword_245A04A60;
  v130 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v130;
  v147 = 0;
  v148 = 0;
  *v149 = v130;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v131 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v131 - 88), "right_arm_joint", 0xF);
  IKString::assign((v131 - 64), &unk_245A04BAE, 0);
  *(v131 - 32) = xmmword_245A04A90;
  *(v131 - 16) = xmmword_245A04A80;
  v132 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v132;
  v147 = 0;
  v148 = 0;
  *v149 = v132;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v133 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v133 - 88), "right_forearm_joint", 0x13);
  IKString::assign((v133 - 64), &unk_245A04BAE, 0);
  *(v133 - 32) = xmmword_245A04AB0;
  *(v133 - 16) = xmmword_245A04AA0;
  v134 = *(a2 + 16);
  v144 = 0xFFFFFFFFFFFFFFFFLL;
  v145 = 0;
  v146 = v134;
  v147 = 0;
  v148 = 0;
  *v149 = v134;
  v151 = 0;
  v152 = 0;
  v153 = xmmword_245A01E80;
  FIK::IKArray<FIK::RigBoneBase>::push_back<FIK::RigBoneBase,void>((a2 + 240), &v144);
  if (v148)
  {
    (*(**v149 + 24))(*v149, v147, 0, 8);
    v147 = 0;
    v148 = 0;
  }

  if (v145)
  {
    (*(*v146 + 24))(v146, *(&v144 + 1), 0, 8);
  }

  v135 = *(a2 + 256) + 96 * *(a2 + 240);
  IKString::assign((v135 - 88), "right_hand_joint", 0x10);
  IKString::assign((v135 - 64), &unk_245A04BAE, 0);
  *(v135 - 32) = xmmword_245A04AD0;
  *(v135 - 16) = xmmword_245A04AC0;
  *(a2 + 272) = 0u;
  *(a2 + 288) = xmmword_245A01E80;
  *(a2 + 304) = 1;
  *(a2 + 308) = 1065353216;
  result = FIK::Serialisation::fixUpRigIndices(a2);
  v137 = *(a2 + 176);
  if (v137)
  {
    v138 = v137 << 8;
    v139 = (*(a2 + 192) + 208);
    do
    {
      if ((v139[-1].i8[12] & 1) == 0 && (v139[-1].i8[13] & 1) == 0)
      {
        *v139 = vdivq_f32(*v139, vdupq_lane_s32(*(a2 + 308), 0));
      }

      v139 += 16;
      v138 -= 256;
    }

    while (v138);
  }

  return result;
}

double CoreIKACPPenetrationConstraint::setPlaneDefinition(CoreIKConstraint *a1, __n128 *a2, __n128 *a3)
{
  v5 = CoreIKConstraint::interface(a1);
  FIK::FloorLevel::FloorTask::setPlanePosition(v5, a2);

  *&result = FIK::FloorLevel::FloorTask::setPlaneNormal(v5, a3).n128_u64[0];
  return result;
}

uint64_t CoreIKACPSolver::despatchSolve(uint64_t a1)
{
  v1 = (*(**(a1 + 8) + 24))(*(a1 + 8));
  if (v1 > 2)
  {
    return 1;
  }

  else
  {
    return dword_245A04B5C[v1];
  }
}

void *CoreIKACPSolver::despatchGetInputName(FIK::AnimNode **this, uint64_t a2)
{
  v2 = *(FIK::AnimNode::GetRig(this[1]) + 256) + 96 * a2;
  if (*(v2 + 16))
  {
    return *(v2 + 8);
  }

  else
  {
    return &unk_245A04BAE;
  }
}

void *CoreIKACPSolver::despatchGetOutputName(FIK::AnimNode **this, uint64_t a2)
{
  v2 = *(FIK::AnimNode::GetRig(this[1]) + 224) + 544 * a2;
  if (*(v2 + 16))
  {
    return *(v2 + 8);
  }

  else
  {
    return &unk_245A04BAE;
  }
}

void *CoreIKACPSolver::despatchGetOutputParentName(FIK::AnimNode **this, uint64_t a2)
{
  v2 = *(FIK::AnimNode::GetRig(this[1]) + 224) + 544 * a2;
  if (*(v2 + 40))
  {
    return *(v2 + 32);
  }

  else
  {
    return &unk_245A04BAE;
  }
}

uint64_t CoreIKACPSolver::despatchGetConstraint(FIK *a1, char *a2)
{
  v4 = *(a1 + 1);
  v17 = 0;
  v18 = 0;
  v19 = FIK::defaultAllocator(a1);
  v5 = strlen(a2);
  IKString::assign(&v17, a2, v5);
  TaskIndex = FIK::AnimNode::GetTaskIndex(v4, &v17);
  if (v18)
  {
    (*(*v19 + 3))(v19, v17, 0, 8);
  }

  if ((TaskIndex & 0x80000000) != 0)
  {
    v9 = ikinemaLogObject()[1];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      CoreIKACPSolver::despatchGetConstraint(v9, v10, v11, v12, v13, v14, v15, v16);
    }

    return 0;
  }

  else
  {
    v7 = (*(**(a1 + 1) + 48))(*(a1 + 1), TaskIndex);
    return CoreIKConstraint::interface(v7);
  }
}

void *CoreIKACPSlidingSolver::CoreIKACPSlidingSolver(void *a1)
{
  v2 = a1 + 4;
  a1[2] = v2;
  a1[3] = v2;
  *a1 = &unk_28589C6F8;
  a1[1] = v2;
  FIK::FeetSliding::FeetSliding();
  return a1;
}

void *CoreIKACPFilteringSolver::CoreIKACPFilteringSolver(void *a1)
{
  v2 = a1 + 4;
  a1[2] = v2;
  a1[3] = v2;
  *a1 = &unk_28589C7A8;
  a1[1] = v2;
  FIK::FilterNode::FilterNode();
  return a1;
}

float CoreIKACPFilteringSolver::setFilteringSmoothness(CoreIKACPFilteringSolver *this, float a2)
{
  FIK::FilterNode::SetFilterAlpha((this + 32), a2);

  return FIK::FilterNode::GetFilterAlpha((this + 32));
}

void *CoreIKACPPenetrationSolver::CoreIKACPPenetrationSolver(void *a1)
{
  v2 = a1 + 4;
  a1[2] = v2;
  a1[3] = v2;
  *a1 = &unk_28589C858;
  a1[1] = v2;
  FIK::FloorLevel::FloorLevel();
  return a1;
}

uint64_t CoreIKACPPenetrationSolver::getConstraint(uint64_t a1, char *a2)
{
  v15 = 0;
  v16 = 0;
  v17 = FIK::defaultAllocator(a1);
  v4 = strlen(a2);
  IKString::assign(&v15, a2, v4);
  TaskIndex = FIK::AnimNode::GetTaskIndex(a1 + 32, &v15);
  if (v16)
  {
    (*(*v17 + 3))(v17, v15, 0, 8);
  }

  if ((TaskIndex & 0x80000000) == 0)
  {
    return FIK::FloorLevel::GetTaskInstance((a1 + 32), TaskIndex);
  }

  v7 = ikinemaLogObject()[1];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    CoreIKACPPenetrationSolver::getConstraint(v7, v8, v9, v10, v11, v12, v13, v14);
  }

  return 0;
}

unint64_t CoreIKACPPenetrationSolver::getConstraint(CoreIKACPPenetrationSolver *this, unint64_t a2)
{
  v2 = FIK::FloorLevel::constraintByIndex((this + 32), a2);
  if (!v2)
  {
    v3 = ikinemaLogObject()[1];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      CoreIKACPPenetrationSolver::getConstraint(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }

  return v2;
}

void CoreIKACPSlidingSolver::~CoreIKACPSlidingSolver(CoreIKACPSlidingSolver *this)
{
  *this = &unk_28589C6F8;
  v1 = (this + 32);
  *(this + 4) = &unk_28589BCF8;
  FIK::IKArray<FIK::FeetSliding::SlidingTask>::~IKArray(this + 63);
  FIK::AnimNode::~AnimNode(v1);
}

{
  *this = &unk_28589C6F8;
  v1 = (this + 32);
  *(this + 4) = &unk_28589BCF8;
  FIK::IKArray<FIK::FeetSliding::SlidingTask>::~IKArray(this + 63);
  FIK::AnimNode::~AnimNode(v1);

  JUMPOUT(0x245D77F60);
}

void CoreIKACPFilteringSolver::~CoreIKACPFilteringSolver(CoreIKACPFilteringSolver *this)
{
  *this = &unk_28589C7A8;
  v1 = (this + 32);
  *(this + 4) = &unk_28589C0C8;
  FIK::IKArray<FIK::FilterNode::FilteringTask>::~IKArray(this + 64);
  FIK::AnimNode::~AnimNode(v1);
}

{
  *this = &unk_28589C7A8;
  v1 = (this + 32);
  *(this + 4) = &unk_28589C0C8;
  FIK::IKArray<FIK::FilterNode::FilteringTask>::~IKArray(this + 64);
  FIK::AnimNode::~AnimNode(v1);

  JUMPOUT(0x245D77F60);
}

void CoreIKACPPenetrationSolver::~CoreIKACPPenetrationSolver(CoreIKACPPenetrationSolver *this)
{
  *this = &unk_28589C858;
  v1 = (this + 32);
  *(this + 4) = &unk_28589BE98;
  FIK::IKArray<FIK::FloorLevel::FloorTask>::~IKArray(this + 504);
  FIK::AnimNode::~AnimNode(v1);
}

{
  *this = &unk_28589C858;
  v1 = (this + 32);
  *(this + 4) = &unk_28589BE98;
  FIK::IKArray<FIK::FloorLevel::FloorTask>::~IKArray(this + 504);
  FIK::AnimNode::~AnimNode(v1);

  JUMPOUT(0x245D77F60);
}

FIK::AnimNode *CoreIKSolverAlgorithmCount(uint64_t a1)
{
  result = (*(*a1 + 80))(a1);
  if (result)
  {

    return FIK::AnimNode::algorithmCount(result);
  }

  return result;
}

void *CoreIKSolverAlgorithmGetName(uint64_t a1, unint64_t a2)
{
  v3 = (*(*a1 + 80))(a1);
  if (!v3)
  {
    return &unk_245A04BAE;
  }

  v4 = v3;
  if (FIK::AnimNode::algorithmCount(v3) <= a2)
  {
    return &unk_245A04BAE;
  }

  v5 = FIK::AnimNode::algorithmReference(v4, a2);
  return (*(**v5 + 48))(*v5);
}

uint64_t translateResult(unsigned int a1)
{
  if (a1 > 4)
  {
    return 3;
  }

  else
  {
    return dword_245A04B70[a1];
  }
}

uint64_t CoreIKSolverInsertAlgorithm(uint64_t a1, unint64_t a2, _OWORD *a3)
{
  v5 = (*(*a1 + 80))(a1);
  if (v5)
  {
    v6 = v5;
    v7 = a3[1];
    v13[0] = *a3;
    v13[1] = v7;
    v13[2] = a3[2];
    ikinema::UserAlgorithm::create(v13, &v14);
    inserted = FIK::AnimNode::insertAlgorithmBefore(v6, a2, &v14);
    if (inserted > 4)
    {
      v9 = 3;
    }

    else
    {
      v9 = dword_245A04B70[inserted];
    }

    if (v14)
    {
      (*(*v14 + 8))(v14);
      FIK::FIKFree(v14, v11);
    }
  }

  else
  {
    v10 = ikinemaLogObject()[1];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      CoreIKSolverInsertAlgorithm_cold_1(v10);
    }

    return 1;
  }

  return v9;
}

uint64_t CoreIKSolverRemoveAlgorithm(uint64_t a1, unint64_t a2)
{
  v3 = (*(*a1 + 80))(a1);
  if (v3)
  {
    v4 = v3;
    if (FIK::AnimNode::algorithmCount(v3) > a2 && (FIK::AnimNode::removeAlgorithmAt(v4, a2) & 1) != 0)
    {
      return 0;
    }

    else
    {
      return 2;
    }
  }

  else
  {
    v6 = ikinemaLogObject()[1];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      CoreIKSolverRemoveAlgorithm_cold_1(v6);
    }

    return 1;
  }
}

FIK::AnimNode *CoreIKSolverValidateAlgorithms(uint64_t a1)
{
  result = (*(*a1 + 80))(a1);
  if (result)
  {

    return FIK::AnimNode::validateAlgorithms(result);
  }

  return result;
}

uint64_t CoreIKBufferKeyFor(FIK *a1, unint64_t a2, int a3, uint64_t a4)
{
  switch(a3)
  {
    case 3:
      ikinema::BufferDescriptor::create<FIK::Transform>(a1, a2, a4, v6);
      break;
    case 2:
      _ZN7ikinema16BufferDescriptor6createIDv3_fEES0_NSt3__117basic_string_viewIcNS3_11char_traitsIcEEEEm(a1, a2, a4, v6);
      break;
    case 1:
      ikinema::BufferDescriptor::create<float>(a1, a2, a4, v6);
      break;
    default:
      return -1;
  }

  v4 = v8;
  if (v6[1])
  {
    (*(*v7 + 24))(v7, v6[0], 0, 8);
  }

  return v4;
}

uint64_t *ikinema::BufferDescriptor::create<float>@<X0>(FIK *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v8 = *(MEMORY[0x277D827B0] + 8);
  if (v8 < 0)
  {
    v9 = (v8 & 0x7FFFFFFFFFFFFFFFLL);
    v10 = 5381;
    do
    {
      v8 = v10;
      v11 = *v9++;
      v10 = (33 * v10) ^ v11;
    }

    while (v11);
  }

  v15 = 0;
  v16 = 0;
  v17 = FIK::defaultAllocator(a1);
  v12 = strlen(a1);
  IKString::assign(&v15, a1, v12);
  v13 = (33 * ((33 * std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](&v18, a1, a2)) ^ v8)) ^ a3;
  result = IKString::IKString(a4, &v15, v17);
  *(a4 + 24) = vdupq_n_s64(4uLL);
  *(a4 + 40) = a3;
  *(a4 + 48) = v8;
  *(a4 + 56) = v13;
  if (v16)
  {
    return (*(*v17 + 3))(v17, v15, 0, 8);
  }

  return result;
}

uint64_t *_ZN7ikinema16BufferDescriptor6createIDv3_fEES0_NSt3__117basic_string_viewIcNS3_11char_traitsIcEEEEm@<X0>(FIK *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v8 = 0x8000000245A04B68;
  if ((0x8000000245A04B68 & 0x8000000000000000) != 0)
  {
    v9 = (0x8000000245A04B68 & 0x7FFFFFFFFFFFFFFFLL);
    v10 = 5381;
    do
    {
      v8 = v10;
      v11 = *v9++;
      v10 = (33 * v10) ^ v11;
    }

    while (v11);
  }

  v15 = 0;
  v16 = 0;
  v17 = FIK::defaultAllocator(a1);
  v12 = strlen(a1);
  IKString::assign(&v15, a1, v12);
  v13 = (33 * ((33 * std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](&v18, a1, a2)) ^ v8)) ^ a3;
  result = IKString::IKString(a4, &v15, v17);
  *(a4 + 24) = vdupq_n_s64(0x10uLL);
  *(a4 + 40) = a3;
  *(a4 + 48) = v8;
  *(a4 + 56) = v13;
  if (v16)
  {
    return (*(*v17 + 3))(v17, v15, 0, 8);
  }

  return result;
}

uint64_t CoreIKBufferContainerGet(void *a1, uint64_t a2)
{
  if (!*a1)
  {
    return 0;
  }

  v2 = 72 * *a1;
  v3 = (a1[2] + 56);
  while (1)
  {
    v4 = *v3;
    v3 += 9;
    if (v4 == a2)
    {
      break;
    }

    v2 -= 72;
    if (!v2)
    {
      return 0;
    }
  }

  return ikinema::BufferContainer::buffer(a1, a2);
}

uint64_t CoreIKBufferGetType(uint64_t a1)
{
  v1 = *(a1 + 48);
  v2 = *(MEMORY[0x277D827B0] + 8);
  if (v2 < 0)
  {
    v3 = (v2 & 0x7FFFFFFFFFFFFFFFLL);
    v4 = 5381;
    do
    {
      v2 = v4;
      v5 = *v3++;
      v4 = (33 * v4) ^ v5;
    }

    while (v5);
  }

  if (v1 == v2)
  {
    return 1;
  }

  v7 = 0x8000000245A04B68;
  if ((0x8000000245A04B68 & 0x8000000000000000) != 0)
  {
    v8 = (0x8000000245A04B68 & 0x7FFFFFFFFFFFFFFFLL);
    v9 = 5381;
    do
    {
      v7 = v9;
      v10 = *v8++;
      v9 = (33 * v9) ^ v10;
    }

    while (v10);
  }

  if (v1 == v7)
  {
    return 2;
  }

  v11 = "N3FIK9TransformE";
  if (("N3FIK9TransformE" & 0x8000000000000000) != 0)
  {
    v12 = ("N3FIK9TransformE" & 0x7FFFFFFFFFFFFFFFLL);
    v13 = 5381;
    do
    {
      v11 = v13;
      v14 = *v12++;
      v13 = (33 * v13) ^ v14;
    }

    while (v14);
  }

  if (v1 == v11)
  {
    return 3;
  }

  else
  {
    return 0;
  }
}

uint64_t ikinema::Buffer::arrayView<float const>(void *a1)
{
  v2 = *(MEMORY[0x277D827B0] + 8);
  if (v2 < 0)
  {
    v3 = (v2 & 0x7FFFFFFFFFFFFFFFLL);
    v4 = 5381;
    do
    {
      v2 = v4;
      v5 = *v3++;
      v4 = (33 * v4) ^ v5;
    }

    while (v5);
  }

  if (a1[6] != v2)
  {
    ikinema::Buffer::arrayView<float const>();
  }

  result = a1[8];
  v7 = a1[5];
  return result;
}

uint64_t _ZN7ikinema6Buffer9arrayViewIKDv3_fEEN3FIK11IKArrayViewIT_EEv(void *a1)
{
  v2 = 0x8000000245A04B68;
  if ((0x8000000245A04B68 & 0x8000000000000000) != 0)
  {
    v3 = (0x8000000245A04B68 & 0x7FFFFFFFFFFFFFFFLL);
    v4 = 5381;
    do
    {
      v2 = v4;
      v5 = *v3++;
      v4 = (33 * v4) ^ v5;
    }

    while (v5);
  }

  if (a1[6] != v2)
  {
    ikinema::Buffer::arrayView<float const>();
  }

  result = a1[8];
  v7 = a1[5];
  return result;
}

uint64_t ikinema::Buffer::arrayView<FIK::Transform const>(void *a1)
{
  v2 = "N3FIK9TransformE";
  if (("N3FIK9TransformE" & 0x8000000000000000) != 0)
  {
    v3 = ("N3FIK9TransformE" & 0x7FFFFFFFFFFFFFFFLL);
    v4 = 5381;
    do
    {
      v2 = v4;
      v5 = *v3++;
      v4 = (33 * v4) ^ v5;
    }

    while (v5);
  }

  if (a1[6] != v2)
  {
    ikinema::Buffer::arrayView<float const>();
  }

  result = a1[8];
  v7 = a1[5];
  return result;
}

uint64_t CoreIKGetJoints(uint64_t a1)
{
  v1 = (*(*a1 + 88))(a1);

  return CoreIKConstraint::interface(v1);
}

uint64_t CoreIKGetConstraints(uint64_t a1)
{
  v1 = (*(*a1 + 96))(a1);

  return CoreIKConstraint::interface(v1);
}

void *CoreIK::IKSolverRetarget::IKSolverRetarget(void *a1)
{
  *a1 = &unk_28589C968;
  v2 = FIK::RetargetingNode::RetargetingNode(a1 + 2);
  a1[226] = v2;
  a1[227] = v2;
  return a1;
}

uint64_t CoreIK::IKSolverRetarget::despatchGetConstraint(uint64_t a1, const void *a2, size_t a3)
{
  Rig = FIK::AnimNode::GetRig((a1 + 16));
  v7 = FIK::RetargetingNode::constraintsCount((a1 + 16));
  if (v7)
  {
    v8 = v7;
    v9 = 0;
    v10 = (*(Rig + 192) + 8);
    while (1)
    {
      if (a3 == *v10)
      {
        v11 = *(v10 - 1);
        v12 = a3 ? *(v10 - 1) : &unk_245A04BAE;
        if (!memcmp(a2, v12, a3))
        {
          break;
        }
      }

      ++v9;
      v10 += 32;
      if (v8 == v9)
      {
        goto LABEL_9;
      }
    }

    v15 = FIK::RetargetingNode::constraintByIndex((a1 + 16), v9);

    return CoreIKConstraint::interface(v15);
  }

  else
  {
LABEL_9:
    v13 = ikinemaLogObject()[1];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      CoreIK::IKSolverRetarget::despatchGetConstraint(v13);
    }

    return 0;
  }
}

BOOL CoreIK::IKSolverRetarget::despatchSolve(uint64_t a1, _OWORD *a2, uint64_t a3, int a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v15[0] = 0uLL;
  v15[1] = xmmword_245A01E80;
  if (a4)
  {
    v14[0] = 0uLL;
    v14[1] = xmmword_245A01E80;
    v11 = FIK::RetargetingNode::SolveModel(a1 + 16, a2, a3, a5, a6, v14);
  }

  else
  {
    v11 = FIK::RetargetingNode::Solve(a1 + 16, a2, a3, a5, a6, v15);
  }

  v12 = v11;
  if (a8)
  {
    FIK::RetargetingNode::GetModelSpacePose((a1 + 16), a7);
  }

  return v12 == 2;
}

void *CoreIK::IKSolverRetarget::despatchGetInputName(CoreIK::IKSolverRetarget *this, uint64_t a2)
{
  v2 = *(FIK::AnimNode::GetRig((this + 16)) + 256) + 96 * a2;
  if (*(v2 + 16))
  {
    return *(v2 + 8);
  }

  else
  {
    return &unk_245A04BAE;
  }
}

void *CoreIK::IKSolverRetarget::despatchGetOutputName(CoreIK::IKSolverRetarget *this, uint64_t a2)
{
  v2 = *(FIK::AnimNode::GetRig((this + 16)) + 224) + 544 * a2;
  if (*(v2 + 16))
  {
    return *(v2 + 8);
  }

  else
  {
    return &unk_245A04BAE;
  }
}

void *CoreIK::IKSolverRetarget::despatchGetOutputParentName(CoreIK::IKSolverRetarget *this, uint64_t a2)
{
  v2 = *(FIK::AnimNode::GetRig((this + 16)) + 224) + 544 * a2;
  if (*(v2 + 40))
  {
    return *(v2 + 32);
  }

  else
  {
    return &unk_245A04BAE;
  }
}

void CoreIK::IKSolverRetarget::~IKSolverRetarget(CoreIK::IKSolverRetarget *this)
{
  FIK::RetargetingNode::~RetargetingNode((this + 16));
}

{
  FIK::RetargetingNode::~RetargetingNode((this + 16));

  JUMPOUT(0x245D77F60);
}

uint64_t CoreIK::IKSolverRetarget::despatchSolverType(CoreIK::IKSolverRetarget *this)
{
  if (*(FIK::AnimNode::GetRig((this + 16)) + 304))
  {
    return 2;
  }

  else
  {
    return 1;
  }
}

float CoreIK::IKSolverRetarget::despatchSetInputScale(CoreIK::IKSolverRetarget *this, float a2)
{
  FIK::RetargetingNode::setSourceScale(this + 16, a2);

  return FIK::RetargetingNode::sourceScale((this + 16));
}

float CoreIK::IKSolverRetarget::despatchSetOutputScale(CoreIK::IKSolverRetarget *this, float a2)
{
  FIK::RetargetingNode::setOutputScale(this + 16, a2);

  return FIK::RetargetingNode::outputScale((this + 16));
}

uint64_t CoreIKEnrollmentPoseSolveForDataWithHeadPoseV2(uint64_t a1, float a2)
{
  v2 = MEMORY[0x28223BE20](a1, a2);
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v9 = v2;
  v77 = *MEMORY[0x277D85DE8];
  v10 = *(v2 + 64);
  v11 = kdebug_trace();
  EnrollmentRigV2 = ikinema::rig::generate_EnrollmentRigV2(v11, &v40);
  getUserDefaultLoggerPath(EnrollmentRigV2, &v37);
  IKString::IKString(&v57, &v40, v42);
  *v60 = *v43;
  *(&v60[1] + 4) = *(&v43[1] + 4);
  *&v60[5] = *&v43[5];
  *&v60[7] = *&v43[7];
  *&v60[9] = *&v43[9];
  v63 = v46;
  v64 = v47;
  v13 = v48;
  v48 = 0u;
  v65[0] = v13;
  v65[1] = v49;
  v14 = v50;
  v50 = 0u;
  v66[0] = v14;
  v66[1] = v51;
  v15 = v52;
  v16 = v53;
  v52 = 0u;
  v60[11] = v43[11];
  *(v62 + 3) = *(v45 + 3);
  v61 = v44;
  v62[0] = v45[0];
  *&v49 = 0;
  *&v51 = 0;
  *&v53 = 0;
  v67[0] = v15;
  v67[1] = v16;
  v67[2] = v54;
  v67[3] = v55;
  v68 = v56;
  v17 = *v9;
  v18 = *(v9 + 8);
  v32 = *(v9 + 16);
  v19 = *(v9 + 40);
  v20 = *(v9 + 48);
  v21 = *(v9 + 56);
  v33 = *(v9 + 32);
  v34 = v20;
  v35 = v19;
  v36 = v20;
  v22 = *(v9 + 64);
  v30[0] = v21;
  v30[1] = v22;
  if (v38)
  {
    v23 = v37;
  }

  else
  {
    v23 = &unk_245A04BAE;
  }

  v31 = 1;
  FIK::EnrollmentPoseSolver::EnrollmentPoseSolver(v69, &v57, v17, v18, &v32, v30, v23);
  FIK::IKArray<FIK::RigBoneBase>::~IKArray(v67);
  FIK::IKArray<FIK::MoCapBone>::~IKArray(v66);
  FIK::IKArray<FIK::MoCapTask>::~IKArray(v65);
  if (v58)
  {
    (*(*v59 + 24))(v59, v57, 0, 8);
    v57 = 0;
    v58 = 0;
  }

  if (v4 == -1)
  {
    v27 = *ikinemaLogObject();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      CoreIKEnrollmentPoseSolveForDataWithHeadPoseV2_cold_1(v27);
    }

    v26 = 1;
  }

  else
  {
    v24 = FIK::EnrollmentPoseSolver::solve(v69, v8, v6, v4);
    if (v24 == 1)
    {
      v25 = 2;
    }

    else
    {
      v25 = 1;
    }

    if (v24)
    {
      v26 = v25;
    }

    else
    {
      v26 = 0;
    }
  }

  if (v76[1192] == 1)
  {
    FIK::Enrollment::DataLogger::~DataLogger(v76);
  }

  v73 = 0;
  if (v74)
  {
    (*(*v75 + 24))(v75, v74, 0, 8);
  }

  v70[44] = 0;
  if (v71)
  {
    (*(*v72 + 24))(v72, v71, 0, 8);
  }

  FIK::Enrollment::DataPreprocessor::~DataPreprocessor(v70);
  FIK::RetargetingNode::~RetargetingNode(v69);
  if (v38)
  {
    (*(*v39 + 24))(v39, v37, 0, 8);
  }

  FIK::IKArray<FIK::RigBoneBase>::~IKArray(&v52);
  FIK::IKArray<FIK::MoCapBone>::~IKArray(&v50);
  FIK::IKArray<FIK::MoCapTask>::~IKArray(&v48);
  if (v41)
  {
    (*(*v42 + 24))(v42, v40, 0, 8);
    v40 = 0;
    v41 = 0;
  }

  kdebug_trace();
  v28 = *MEMORY[0x277D85DE8];
  return v26;
}

CFIndex CoreIKEnrollmentPoseSolveForDataWithHeadPoseV3(const char **a1, __int128 *a2, unint64_t a3, int a4, const char **a5, float *a6, FIK *a7, unint64_t a8, __n128 a9, __n128 a10)
{
  v94[225] = *MEMORY[0x277D85DE8];
  if (EnrollmentPoseSolverV4UserDefaults::solverVersion(a1) == 4)
  {
    v18 = *MEMORY[0x277D85DE8];

    return CoreIKEnrollmentPoseSolveForDataWithHeadPoseV4(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  }

  else
  {
    v20 = *ikinemaLogObject();
    v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
    if (v21)
    {
      *buf = 136315138;
      v87 = "CoreIKEnrollmentPoseSolveForDataWithHeadPoseV3";
      _os_log_impl(&dword_245976000, v20, OS_LOG_TYPE_DEFAULT, "%s: CoreIKEnrollmentPoseSolveForDataWithHeadPoseV3() called.", buf, 0xCu);
    }

    EnrollmentRigV3 = ikinema::rig::generate_EnrollmentRigV3(v21, &v81);
    getUserDefaultLoggerPath(EnrollmentRigV3, &v77);
    if (v78)
    {
      v23 = v77;
    }

    else
    {
      v23 = &unk_245A04BAE;
    }

    FIK::EnrollmentPoseSolverV2::EnrollmentPoseSolverV2(buf, &v81, v23);
    if (v78)
    {
      (*(*v79 + 24))(v79, v77, 0, 8);
    }

    FIK::IKArray<FIK::RigBoneBase>::~IKArray(&v85);
    FIK::IKArray<FIK::MoCapBone>::~IKArray(&v84);
    FIK::IKArray<FIK::MoCapTask>::~IKArray(&v83);
    if (v81.i64[1])
    {
      (*(*v82.n128_u64[0] + 24))(v82.n128_u64[0], v81.i64[0], 0, 8);
    }

    if (v93)
    {
      FIK::Enrollment::SourceAndTargetDataLogger::exportOriginalSources(&__p, a1, a3, a2, a3);
      FIK::Enrollment::SourceAndTargetDataLogger::exportEnrollmentData(&__p, a5, a8, a6);
      v24 = a9;
      v24.n128_u32[3] = 0;
      v81 = v24;
      v82 = a10;
      FIK::Enrollment::SourceAndTargetDataLogger::exportAtlasData(&__p, &v81);
    }

    if (FIK::EnrollmentPoseSolverV2::inputsAreValidGivenRig(buf, a1, a3, a5, a8))
    {
      FIK::EnrollmentPoseSolverV2::getRigToInputSourceMap(buf, a1, a3, &v77);
      FIK::EnrollmentHelpers::extractTransformsFromPositionsArray(a2, v79, v77, &v74);
      FIK::EnrollmentPoseSolverV2::getRigToInputTargetMap(buf, a5, a8, &v71);
      FIK::EnrollmentHelpers::extractElementsAccordingToMap<FIK::Transform>(a7, v72, v71, &v69);
      FIK::EnrollmentHelpers::extractElementsAccordingToMap<float>(a6, v72, v71, &v66);
      if (v69)
      {
        v25 = v70;
        v26 = 32 * v69;
        v27 = vdupq_n_s32(0x42C80000u);
        do
        {
          *v25 = vmulq_f32(*v25, v27);
          v25 += 2;
          v26 -= 32;
        }

        while (v26);
      }

      if (v74)
      {
        v28 = v75;
        v29 = 32 * v74;
        v30 = vdupq_n_s32(0x42C80000u);
        do
        {
          *v28 = vmulq_f32(*v28, v30);
          v28 += 2;
          v29 -= 32;
        }

        while (v29);
      }

      v31 = v67;
      v32 = v66;
      if (v66)
      {
        v33 = 4 * v66;
        v34 = v67;
        do
        {
          *v34 = *v34 * 100.0;
          ++v34;
          v33 -= 4;
        }

        while (v33);
      }

      FIK::EnrollmentPoseSolverV2::setTargetBoneLengths(buf, v31, v32);
      v35 = &v75[2 * v88];
      v62 = vmulq_f32(a9, vdupq_n_s32(0x42C80000u));
      *v35 = v62;
      v35[1] = a10;
      FIK::EnrollmentPoseSolverV2::computeVirtualHips(buf, v75, &v81);
      f32 = v75[2 * *buf].f32;
      *f32 = v81;
      f32[1] = v82;
      FIK::EnrollmentPoseSolverV2::computeVirtualLeftWrist(buf, v75, v67, &v64);
      v37 = v75[2 * v89].f32;
      *v37 = v64;
      v37[1] = v65;
      FIK::EnrollmentPoseSolverV2::computeVirtualRightWrist(buf, v75, v67, &v64);
      v38 = v75[2 * v90].f32;
      *v38 = v64;
      v38[1] = v65;
      v39 = FIK::EnrollmentPoseSolverV2::solve(buf, v75, v74, v70, v69);
      Rig = FIK::AnimNode::GetRig(v94);
      FIK::PoseConverter::PoseConverter<FIK::MoCapBone>(&v81, *(Rig + 224), *(Rig + 208), v70);
      FIK::PoseConverter::getGlobalTransforms(&v81, &v64);
      v41 = v70;
      v42 = v64;
      v43 = v65;
      v64 = 0uLL;
      *&v65 = 0;
      v69 = v42;
      v70 = v43;
      if (v41)
      {
        (*(**(&v41 + 1) + 24))(*(&v41 + 1), v41, 0, 8);
        *&v64 = 0;
        if (v65)
        {
          (*(**(&v65 + 1) + 24))(*(&v65 + 1), v65, 0, 8);
        }
      }

      FIK::PoseConverter::~PoseConverter(&v81);
      v81 = vsubq_f32(v62, *(v70 + 32 * v91));
      FIK::EnrollmentHelpers::addOffsetToPose(v70, v69, &v81);
      v44 = v70;
      if (v69)
      {
        v45 = 32 * v69;
        v46 = vdupq_n_s32(0x3C23D70Au);
        do
        {
          *v44 = vmulq_f32(*v44, v46);
          v44 += 2;
          v45 -= 32;
        }

        while (v45);
        v44 = v70;
        v47 = v69;
      }

      else
      {
        v47 = 0;
      }

      FIK::EnrollmentHelpers::writeElementsToArray(v44, v47, v72, v71, a7);
      if (v93 == 1)
      {
        v51 = FIK::defaultAllocator(v50);
        v81 = 0uLL;
        v82.n128_u64[0] = 0;
        v82.n128_u64[1] = v51;
        FIK::IKArray<FIK::Segment *>::reserve(&v81, v74);
        v52 = FIK::AnimNode::GetRig(v94);
        v53 = *(v52 + 240);
        if (v53)
        {
          v54 = (*(v52 + 256) + 16);
          v55 = 96 * v53;
          do
          {
            if (*v54)
            {
              v56 = *(v54 - 1);
            }

            else
            {
              v56 = &unk_245A04BAE;
            }

            FIK::IKArray<FIK::Segment *>::reserve(&v81, v81.i64[0] + 1);
            v57 = v81.i64[0];
            *(v82.n128_u64[0] + 8 * v81.i64[0]) = v56;
            v81.i64[0] = v57 + 1;
            v54 += 12;
            v55 -= 96;
          }

          while (v55);
        }

        if ((v93 & 1) == 0)
        {
          v60 = std::__throw_bad_optional_access[abi:nn200100]();
          return EnrollmentPoseSolverV4UserDefaults::solverVersion(v60);
        }

        FIK::Enrollment::SourceAndTargetDataLogger::exportProcessedSources(&__p, v82.n128_u64[0], v81.i64[0], v75, v74);
        FIK::Enrollment::SourceAndTargetDataLogger::exportTargets(&__p, a5, a8, a7, a8);
        v81.i64[0] = 0;
        if (v82.n128_u64[0])
        {
          (*(*v82.n128_u64[1] + 24))(v82.n128_u64[1], v82.n128_u64[0], 0, 8);
        }
      }

      if (v39 == 1)
      {
        v58 = 2;
      }

      else
      {
        v58 = 1;
      }

      if (v39)
      {
        v49 = v58;
      }

      else
      {
        v49 = 0;
      }

      v66 = 0;
      if (v67)
      {
        (*(*v68 + 24))(v68, v67, 0, 8);
      }

      *&v69 = 0;
      if (v70)
      {
        (*(**(&v70 + 1) + 24))(*(&v70 + 1), v70, 0, 8);
      }

      v71 = 0;
      if (v72)
      {
        (*(*v73 + 24))(v73, v72, 0, 8);
      }

      v74 = 0;
      if (v75)
      {
        (*(*v76 + 24))(v76, v75, 0, 8);
      }

      v77 = 0;
      if (v79)
      {
        (*(*v80 + 24))(v80, v79, 0, 8);
      }
    }

    else
    {
      v48 = ikinemaLogObject()[2];
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        CoreIKEnrollmentPoseSolveForDataWithHeadPoseV3_cold_1(v48);
      }

      v49 = 1;
    }

    FIK::RetargetingNode::~RetargetingNode(v94);
    if (v93 == 1 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    v59 = *MEMORY[0x277D85DE8];
    return v49;
  }
}

CFIndex EnrollmentPoseSolverV4UserDefaults::solverVersion(EnrollmentPoseSolverV4UserDefaults *this)
{
  result = forceEnrollmentPoseSolverVersion;
  if (forceEnrollmentPoseSolverVersion == -1)
  {
    v6 = v1;
    v7 = v2;
    v5 = 0;
    result = CFPreferencesGetAppIntegerValue(@"enrollmentSolverVersion", @"com.apple.coreik", &v5);
    if ((result - 3) >= 2 || v5 == 0)
    {
      return 3;
    }

    else
    {
      return result;
    }
  }

  return result;
}

uint64_t CoreIKEnrollmentPoseSolveForDataWithHeadPoseV4(const char **a1, __int128 *a2, unint64_t a3, int a4, const char **a5, float *a6, uint64_t a7, unint64_t a8, __n128 a9, __n128 a10)
{
  v25 = *MEMORY[0x277D85DE8];
  v18 = *ikinemaLogObject();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 136315138;
    v24 = "CoreIKEnrollmentPoseSolveForDataWithHeadPoseV4";
    _os_log_impl(&dword_245976000, v18, OS_LOG_TYPE_DEFAULT, "%s: CoreIKEnrollmentPoseSolveForDataWithHeadPoseV4() called.", buf, 0xCu);
  }

  result = CoreIKEnrollmentPoseSolveForDataWithHeadPoseV4Ex(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, 0.15, 0.1, 0.17453, -0.17453);
  v20 = *MEMORY[0x277D85DE8];
  return result;
}

void getUserDefaultLoggerPath(FIK *a1@<X0>, void *a2@<X8>)
{
  v3 = FIK::defaultAllocator(a1);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = v3;
  v4 = CFPreferencesCopyAppValue(@"selfieLogPath", @"com.apple.coreik");
  if (v4)
  {
    v5 = v4;
    v6 = CFGetTypeID(v4);
    if (v6 == CFStringGetTypeID())
    {
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      v8 = strlen(CStringPtr);
      IKString::assign(a2, CStringPtr, v8);

      CFRelease(v5);
    }
  }
}

void *FIK::EnrollmentHelpers::extractElementsAccordingToMap<FIK::Transform>@<X0>(FIK *a1@<X0>, uint64_t *a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = FIK::defaultAllocator(a1);
  result = FIK::IKArray<FIK::Transform>::IKArray<FIK::Transform,void>(a4, a3, v8);
  if (a3)
  {
    v10 = 0;
    do
    {
      v12 = *a2++;
      v11 = v12;
      if (v12 != -1)
      {
        v13 = (a1 + 32 * v11);
        v14 = (a4[2] + v10);
        *v14 = *v13;
        v14[1] = v13[1];
      }

      v10 += 32;
      --a3;
    }

    while (a3);
  }

  return result;
}

void *FIK::EnrollmentHelpers::extractElementsAccordingToMap<float>@<X0>(FIK *a1@<X0>, uint64_t *a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = FIK::defaultAllocator(a1);
  *a4 = a3;
  result = FIK::IKArray<float>::MemoryBlock::MemoryBlock(a4 + 1, (a3 + 7) & 0xFFFFFFFFFFFFFFF8, v8);
  if (a3)
  {
    v10 = a4[2];
    do
    {
      v12 = *a2++;
      v11 = v12;
      if (v12 != -1)
      {
        *v10 = *(a1 + v11);
      }

      ++v10;
      --a3;
    }

    while (a3);
  }

  return result;
}

void getDefaultTargetLength(void *__s2, size_t __n)
{
  v13 = *MEMORY[0x277D85DE8];
  v4 = &dword_278E8A828;
  v5 = 96;
  while (*(v4 - 1) != __n || memcmp(*(v4 - 2), __s2, __n))
  {
    v4 += 6;
    v5 -= 24;
    if (!v5)
    {
      goto LABEL_9;
    }
  }

  v6 = *ikinemaLogObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v9 = 136315394;
    v10 = "getDefaultTargetLength";
    v11 = 2080;
    v12 = __s2;
    _os_log_impl(&dword_245976000, v6, OS_LOG_TYPE_DEFAULT, "%s: The target length for %s is zero! Using default length...", &v9, 0x16u);
  }

  v7 = *v4;
LABEL_9:
  v8 = *MEMORY[0x277D85DE8];
}

uint64_t CoreIKEnrollmentPoseSolveForDataWithHeadPoseV4Ex(const char **a1, __int128 *a2, unint64_t a3, int a4, const char **a5, float *a6, uint64_t a7, unint64_t a8, __n128 a9, __n128 a10, float a11, float a12, float a13, float a14)
{
  v76 = *MEMORY[0x277D85DE8];
  v25 = *ikinemaLogObject();
  v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
  if (v26)
  {
    buf[0].n128_u32[0] = 136315138;
    *(buf[0].n128_u64 + 4) = "CoreIKEnrollmentPoseSolveForDataWithHeadPoseV4Ex";
    _os_log_impl(&dword_245976000, v25, OS_LOG_TYPE_DEFAULT, "%s: CoreIKEnrollmentPoseSolveForDataWithHeadPoseV4Ex() called.", buf, 0xCu);
  }

  v72[0] = 0;
  v72[1] = 0;
  v73 = 0;
  v74 = FIK::defaultAllocator(v26);
  v69[0] = 0;
  v69[1] = 0;
  v70 = 0;
  v71 = FIK::defaultAllocator(v74);
  FIK::IKArray<FIK::Transform>::reserve(v72, a3);
  v27 = FIK::IKArray<FIK::Enrollment::RaySource>::reserve(v69, a8);
  if (a3)
  {
    v28 = v72[0];
    do
    {
      v30 = *a1++;
      v29 = v30;
      v31 = strlen(v30);
      v32 = *a2++;
      v33 = v32;
      HIDWORD(v33) = 0;
      v60 = v33;
      v27 = FIK::IKArray<FIK::Transform>::reserve(v72, v28 + 1);
      v34 = &v73[2 * v72[0]];
      *v34 = v29;
      *(v34 + 1) = v31;
      v34[1] = v60;
      v28 = ++v72[0];
      --a3;
    }

    while (a3);
  }

  for (; a8; --a8)
  {
    v35 = *a6;
    if (*a6 == 0.0)
    {
      v36 = strlen(*a5);
      getDefaultTargetLength(*a5, v36);
      v35 = v37;
    }

    v38 = *a5++;
    v39 = strlen(v38);
    v27 = FIK::IKArray<FIK::Enrollment::RaySource>::reserve(v69, v69[0] + 1);
    v40 = v70 + 24 * v69[0];
    *v40 = v38;
    *(v40 + 1) = v39;
    *(v40 + 4) = v35;
    ++v69[0];
    ++a6;
  }

  getUserDefaultLoggerPath(v27, &v66);
  v42 = a9;
  v42.n128_u32[3] = 0;
  v61 = v42;
  v62 = a10;
  v43 = v66;
  if (!v67)
  {
    v43 = &unk_245A04BAE;
  }

  FIK::EnrollmentPoseSolverV4::EnrollmentPoseSolverV4(buf, v73, v72[0], v70, v69[0], &v61, a4, 100.0, v41, v43, v67);
  if (a11 <= 0.0 || a12 <= 0.0)
  {
    v61.n128_u8[0] = 0;
    v62.n128_u8[0] = 0;
  }

  else
  {
    v61.n128_u64[0] = __PAIR64__(LODWORD(a12), LODWORD(a11));
    v61.n128_u64[1] = __PAIR64__(LODWORD(a14), LODWORD(a13));
    v62.n128_u8[0] = 1;
  }

  FIK::EnrollmentPoseSolverV4::setNeckCurving(buf, &v61);
  FIK::EnrollmentPoseSolverV4::logInput(buf);
  v44 = FIK::EnrollmentPoseSolverV4::solve(buf);
  FIK::EnrollmentPoseSolverV4::logOutput(buf);
  if (v44 == 2)
  {
    v45 = 1;
  }

  else
  {
    FIK::EnrollmentPoseSolverV4::outputTargetJointPoses(buf, &v61);
    v46 = v64;
    if (v63)
    {
      v47 = v62.n128_u64[0];
      v48 = 4 * v63;
      v49 = v64;
      do
      {
        v50 = *v49++;
        v51 = (v47 + 32 * v50);
        v52 = v51[1];
        v53 = (a7 + 32 * v50);
        *v53 = *v51;
        v53[1] = v52;
        v48 -= 4;
      }

      while (v48);
    }

    if (v44 == 1)
    {
      v54 = 2;
    }

    else
    {
      v54 = 1;
    }

    if (v44)
    {
      v45 = v54;
    }

    else
    {
      v45 = 0;
    }

    v63 = 0;
    if (v46)
    {
      (*(*v65 + 24))(v65, v46, 0, 8);
    }

    v61.n128_u64[0] = 0;
    if (v62.n128_u64[0])
    {
      (*(*v62.n128_u64[1] + 24))(v62.n128_u64[1], v62.n128_u64[0], 0, 8);
    }
  }

  FIK::EnrollmentPoseSolverV4::~EnrollmentPoseSolverV4(buf);
  if (v67)
  {
    (*(*v68 + 24))(v68, v66, 0, 8);
  }

  v69[0] = 0;
  if (v70)
  {
    (*(*v71 + 3))(v71, v70, 0, 8);
  }

  v72[0] = 0;
  if (v73)
  {
    (*(*v74 + 24))(v74, v73, 0, 8);
  }

  v55 = *MEMORY[0x277D85DE8];
  return v45;
}

void FIK::EnrollmentPoseSolverV4::~EnrollmentPoseSolverV4(void **this)
{
  if (*(this + 800) == 1 && *(this + 799) < 0)
  {
    operator delete(this[97]);
  }

  this[90] = 0;
  v2 = this[92];
  if (v2)
  {
    (*(*this[93] + 24))(this[93], v2, 0, 8);
  }

  this[86] = 0;
  v3 = this[88];
  if (v3)
  {
    (*(*this[89] + 24))(this[89], v3, 0, 8);
  }

  this[82] = 0;
  v4 = this[84];
  if (v4)
  {
    (*(*this[85] + 24))(this[85], v4, 0, 8);
  }

  FIK::PoseConverter::~PoseConverter((this + 54));
  FIK::IKArray<FIK::RigBoneBase>::~IKArray((this + 44));
  FIK::IKArray<FIK::MoCapBone>::~IKArray((this + 40));
  FIK::IKArray<FIK::MoCapTask>::~IKArray((this + 36));
  if (this[15])
  {
    (*(*this[16] + 24))(this[16], this[14], 0, 8);
    this[14] = 0;
    this[15] = 0;
  }

  this[4] = 0;
  v5 = this[6];
  if (v5)
  {
    (*(*this[7] + 24))(this[7], v5, 0, 8);
  }

  *this = 0;
  v6 = this[2];
  if (v6)
  {
    (*(*this[3] + 24))(this[3], v6, 0, 8);
  }
}

void *CoreIKCreateAltruisticSolverInstance(ikinema::processedRigs *a1)
{
  v34[11] = *MEMORY[0x277D85DE8];
  BPERigObject = ikinema::processedRigs::getBPERigObject(a1, v30);
  v2 = FIK::defaultAllocator(BPERigObject);
  v3 = FIK::Allocator::create<CoreIK::IKSolverRetarget,FIK::MoCapRig const&>(v2);
  v4 = v3;
  if (!v3)
  {
    goto LABEL_18;
  }

  v5 = (*(*v3 + 80))(v3);
  v6 = (*(*v5 + 64))(v5);
  v13 = 0;
  v14 = 0;
  v15 = FIK::defaultAllocator(v6);
  IKString::assign(&v13, "rawSources", 0xA);
  v7 = FIK::AnimNode::registerBuffer<FIK::Transform>(v5, &v13, v34[0]);
  v8 = v7;
  if (v14)
  {
    v7 = (*(*v15 + 3))(v15, v13, 0, 8);
  }

  ikinema::processedRigs::getBPEHelperHierarchyBoneDefinitions(v7, &v27);
  FIK::createHelperHierarchy(v28, v27, &v13);
  ikinema::BoneNormalisationAlgorithm::create(&v13, v8, v6, &v26);
  v23 = 0;
  if (v24)
  {
    (*(*v25 + 24))(v25, v24, 0, 8);
  }

  v20 = 0;
  if (v21)
  {
    (*(*v22 + 24))(v22, v21, 0, 8);
  }

  v17 = 0;
  if (v18)
  {
    (*(*v19 + 24))(v19, v18, 0, 8);
  }

  v13 = 0;
  if (v15)
  {
    (*(*v16 + 24))(v16, v15, 0, 8);
  }

  if (FIK::AnimNode::insertAlgorithmBefore(v5, 0, &v26))
  {
    v12 = "(false) Algorithm Insert Failed.";
LABEL_22:
    CoreIKCreateAltruisticSolverInstance_cold_1(v12);
    goto LABEL_14;
  }

  (*(*v5 + 56))(v5, v8);
  if ((FIK::AnimNode::validateAlgorithms(v5) & 1) == 0)
  {
    v12 = "(composableSolver->validateAlgorithms()) Failed to validate algorithms.";
    goto LABEL_22;
  }

LABEL_14:
  if (v26)
  {
    (*(*v26 + 8))(v26);
    FIK::FIKFree(v26, v9);
  }

  v27 = 0;
  if (v28)
  {
    (*(*v29 + 24))(v29, v28, 0, 8);
  }

LABEL_18:
  FIK::IKArray<FIK::RigBoneBase>::~IKArray(v34);
  FIK::IKArray<FIK::MoCapBone>::~IKArray(&v33);
  FIK::IKArray<FIK::MoCapTask>::~IKArray(&v32);
  if (v30[1])
  {
    (*(*v31 + 24))(v31, v30[0], 0, 8);
  }

  v10 = *MEMORY[0x277D85DE8];
  return v4;
}

uint64_t CoreIKSolveModelSpaceSource(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  kdebug_trace();
  if (a4)
  {
    v12 = a6;
  }

  else
  {
    v12 = 0;
  }

  if (a5)
  {
    v13 = a6;
  }

  else
  {
    v13 = 0;
  }

  v14 = (*(*a1 + 32))(a1, a2, a3, 1, a4, v12, a5, v13);
  kdebug_trace();
  return v14;
}

uint64_t CoreIKJointCollectionSize(CoreIKConstraint *a1)
{
  v1 = CoreIKConstraint::interface(a1);

  return ikinema::JointCollection::elementCount(v1);
}

uint64_t CoreIKJointCollectionGet(CoreIKConstraint *a1, unint64_t a2)
{
  v3 = CoreIKConstraint::interface(a1);
  v4 = ikinema::JointCollection::element(v3, a2);

  return CoreIKConstraint::interface(v4);
}

uint64_t CoreIKConstraintCollectionSize(CoreIKConstraint *a1)
{
  v1 = CoreIKConstraint::interface(a1);

  return ikinema::ConstraintCollection::elementCount(v1);
}

uint64_t CoreIKConstraintCollectionGet(CoreIKConstraint *a1)
{
  v1 = CoreIKConstraint::interface(a1);
  v2 = ikinema::ConstraintCollection::element(v1);

  return CoreIKConstraint::interface(v2);
}

uint64_t CoreIKSolverAddAlgorithm_UseRotationFromSource(uint64_t a1, uint64_t a2, void *a3, unint64_t a4)
{
  v7 = (*(*a1 + 80))(a1);
  if (v7)
  {
    v8 = v7;
    Rig = FIK::AnimNode::GetRig(v7);
    v10 = (*(*v8 + 64))(v8);
    ikinema::SourceRotatesDependentsAlgorithm::create(Rig, a2, a3, a4, v10, &v16);
    inserted = FIK::AnimNode::insertAlgorithmBefore(v8, 0, &v16);
    v12 = translateResult(inserted);
    if (v16)
    {
      (*(*v16 + 8))(v16);
      FIK::FIKFree(v16, v13);
    }
  }

  else
  {
    v14 = ikinemaLogObject()[1];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      CoreIKSolverAddAlgorithm_UseRotationFromSource_cold_1(v14);
    }

    return 3;
  }

  return v12;
}

uint64_t CoreIKGenericSolverCreate(FIK *a1)
{
  if (*(a1 + 88))
  {
    v1 = ikinemaLogObject()[2];
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      CoreIKGenericSolverCreate_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
    }

    return 0;
  }

  else
  {
    v10 = FIK::defaultAllocator(a1);

    return FIK::Allocator::create<FIK::GenericSolver,FIK::GameRig const&>(v10);
  }
}

uint64_t FIK::Allocator::create<FIK::GenericSolver,FIK::GameRig const&>(uint64_t a1)
{
  result = (*(*a1 + 16))(a1, 544, 16);
  if (result)
  {
    return FIK::GenericSolver::GenericSolver(result);
  }

  return result;
}

uint64_t CoreIKGenericSolverDestroy(FIK *a1)
{
  v2 = FIK::defaultAllocator(a1);

  return FIK::Allocator::destroy<FIK::GenericSolver>(v2, a1);
}

uint64_t FIK::Allocator::destroy<FIK::GenericSolver>(uint64_t result, void (***a2)(void))
{
  if (a2)
  {
    v3 = result;
    (**a2)(a2);
    v4 = *(*v3 + 24);

    return v4(v3, a2, 0, 8);
  }

  return result;
}

uint64_t CoreIKGenericSolverGetJoint(FIK::IKSolver **a1, unsigned int a2)
{
  Segment = FIK::GenericSolver::GetSegment(a1, a2);

  return CoreIKConstraint::interface(Segment);
}

uint64_t CoreIKGenericSolverGetJointNames(FIK::GenericSolver *a1, uint64_t a2)
{
  result = FIK::GenericSolver::GetNumBones(a1);
  if (result)
  {
    v5 = 0;
    v6 = result;
    do
    {
      Segment = FIK::GenericSolver::GetSegment(a1, v5);
      result = (*(*Segment + 936))(Segment);
      *(a2 + 8 * v5++) = result;
    }

    while (v6 != v5);
  }

  return result;
}

uint64_t CoreIKGenericSolverSetRestPose(FIK::GenericSolver *a1, uint64_t a2)
{
  result = FIK::GenericSolver::GetNumBones(a1);
  if (result)
  {
    v5 = 0;
    v6 = result;
    do
    {
      Segment = FIK::GenericSolver::GetSegment(a1, v5);
      result = (*(*Segment + 440))(Segment, a2);
      ++v5;
      a2 += 32;
    }

    while (v6 != v5);
  }

  return result;
}

double CoreIKGenericSolverSetWorldToSolverTransform(uint64_t a1, __n128 a2, __n128 a3)
{
  v4[0] = a2;
  v4[1] = a3;
  *&result = FIK::GenericSolver::SetWorldToSolverTransform(a1, v4).n128_u64[0];
  return result;
}

uint64_t CoreIKGenericConstraintSetTargetParameters(uint64_t a1, __n128 a2, __n128 a3, float a4, float a5)
{
  v6[0] = a2;
  v6[1] = a3;
  return FIK::RTGameTask::SetTargetParams(a1, v6, a4, a5);
}

float CoreIKGenericConstraintGetTargetBlendWeights(FIK::RTGameTask *a1)
{
  Alphas = FIK::RTGameTask::GetAlphas(a1);
  result = *Alphas;
  v3 = *(Alphas + 4);
  return result;
}

uint64_t CoreIKGenericConstraintSetTranslationTargetBlendWeight(uint64_t a1, float a2)
{
  v2 = 1.0;
  if (a2 <= 1.0)
  {
    v2 = a2;
  }

  v3 = a2 < 0.0;
  v4 = 0.0;
  if (!v3)
  {
    v4 = v2;
  }

  return FIK::RTGameTask::SetPositionAlpha(a1, v4);
}

uint64_t CoreIKGenericConstraintSetOrientationTargetBlendWeight(uint64_t a1, float a2)
{
  v2 = 1.0;
  if (a2 <= 1.0)
  {
    v2 = a2;
  }

  v3 = a2 < 0.0;
  v4 = 0.0;
  if (!v3)
  {
    v4 = v2;
  }

  return FIK::RTGameTask::SetRotationAlpha(a1, v4);
}

uint64_t CoreIKGenericConstraintSetTargetBlendWeights(uint64_t a1, float a2, float a3)
{
  v3 = 1.0;
  if (a2 <= 1.0)
  {
    v4 = a2;
  }

  else
  {
    v4 = 1.0;
  }

  if (a2 >= 0.0)
  {
    v5 = v4;
  }

  else
  {
    v5 = 0.0;
  }

  if (a3 <= 1.0)
  {
    v3 = a3;
  }

  if (a3 >= 0.0)
  {
    v6 = v3;
  }

  else
  {
    v6 = 0.0;
  }

  return FIK::RTGameTask::SetAlpha(a1, v5, v6);
}

double CoreIKGenericConstraintSetTargetTranslation(__n128 *a1, __n128 a2)
{
  a2.n128_u32[3] = 0;
  v3 = a2;
  *&result = FIK::RTGameTask::SetPositionTarget(a1, &v3).n128_u64[0];
  return result;
}

double CoreIKGenericConstraintSetTargetOrientation(__n128 *a1, __n128 a2)
{
  v3 = a2;
  *&result = FIK::RTGameTask::SetRotationTarget(a1, &v3).n128_u64[0];
  return result;
}

double CoreIKGenericConstraintSetLookAtTarget(__n128 *a1, __n128 a2)
{
  a2.n128_u32[3] = 0;
  v3 = a2;
  *&result = FIK::RTGameTask::SetLookAtTarget(a1, &v3).n128_u64[0];
  return result;
}

double CoreIKGenericConstraintSetLookAtParameters(uint64_t a1, __n128 a2, float a3)
{
  a2.n128_u32[3] = 0;
  v5 = a2;
  v4 = 0uLL;
  *&result = FIK::RTGameTask::SetLookAtTargetParams(a1, &v5, &v4, a3, 0.0).n128_u64[0];
  return result;
}

__n128 CoreIKGenericConstraintGetLookAtAxis(__n128 *a1)
{
  if (a1[17].n128_u8[9])
  {
    return a1[14];
  }

  result.n128_u64[0] = 0;
  if (a1[17].n128_u8[8] == 1)
  {
    return a1[14];
  }

  return result;
}

__n128 *CoreIKGenericConstraintSetLookAtAxis(__n128 *result, __n128 a2)
{
  if ((result[17].n128_u8[9] & 1) != 0 || result[17].n128_u8[8] == 1)
  {
    result[14] = a2;
  }

  return result;
}

uint64_t CoreIKGenericConstraintSetUseLocalSpaceLookAtAxis(uint64_t result)
{
  if (*(result + 281) == 1)
  {
    *(result + 280) = 1;
  }

  return result;
}

uint64_t CoreIKGenericConstraintGetUseLocalSpaceLookAtAxis(uint64_t a1)
{
  if (*(a1 + 281) == 1)
  {
    v1 = *(a1 + 280);
  }

  else
  {
    v1 = 0;
  }

  return v1 & 1;
}

uint64_t CoreIKGenericConstraintSetUseModelSpaceLookAtAxis(uint64_t result)
{
  if (*(result + 281) == 1)
  {
    *(result + 280) = 0;
  }

  return result;
}

uint64_t CoreIKGenericConstraintGetUseModelSpaceLookAtAxis(uint64_t a1)
{
  if (*(a1 + 281) == 1)
  {
    v1 = *(a1 + 280) ^ 1;
  }

  else
  {
    v1 = 0;
  }

  return v1 & 1;
}

uint64_t CoreIKGenericSolverSolve(FIK::GenericSolver *a1, uint64_t a2, uint64_t a3)
{
  v15[0] = a2;
  v15[1] = a3;
  if (FIK::GenericSolver::GetNumBones(a1) == a3)
  {
    v4 = (*(*a1 + 32))(a1, v15);
    if (v4 == 1)
    {
      v5 = 2;
    }

    else
    {
      v5 = 1;
    }

    if (v4)
    {
      return v5;
    }

    else
    {
      return 0;
    }
  }

  else
  {
    v7 = ikinemaLogObject()[1];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      CoreIKGenericSolverSolve_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }

    return 1;
  }
}

void *CoreIKGenericSolverGetConstraintTargetName(FIK::GenericSolver *a1, unsigned int a2)
{
  TaskInstancePtr = FIK::GenericSolver::GetTaskInstancePtr(a1, a2);
  if (TaskInstancePtr)
  {
    if (*(TaskInstancePtr + 80))
    {
      return *(TaskInstancePtr + 72);
    }
  }

  else
  {
    v4 = ikinemaLogObject()[2];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      CoreIKGenericSolverGetConstraintTargetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

  return &unk_245A04BAE;
}

double CoreIKGenericSolverGetTargetRestPose(uint64_t a1, unint64_t a2)
{
  if (*(a1 + 400) <= a2)
  {
    v5 = ikinemaLogObject()[2];
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    *&v3 = 0;
    if (v6)
    {
      CoreIKGenericSolverGetTargetRestPose_cold_1(v5, v7, v8, v9, v10, v11, v12, v13);
      *&v3 = 0;
    }
  }

  else
  {
    v2 = *(a1 + 416) + (a2 << 8);
    v3 = *(v2 + 64);
    v4 = *(v2 + 80);
  }

  return *&v3;
}

uint64_t CoreIKGenericSolverGetConstraintIndex(uint64_t a1, char *__s)
{
  v4 = strlen(__s);
  v5 = FIK::IKRigUtils::GetTaskIndexByBoneName<FIK::GameRig>(__s, v4, a1 + 192);
  if (v5 == -1)
  {
    v6 = ikinemaLogObject()[2];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      CoreIKGenericSolverGetConstraintIndex_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }

  return v5;
}

float CoreIKGenericSolverGetRetargetingGain(FIK::GenericSolver *a1)
{
  Solver = FIK::GenericSolver::GetSolver(a1);

  return FIK::IKSolver::getRetargetingGain(Solver);
}

float CoreIKGenericSolverSetRetargetingGain(FIK::GenericSolver *a1, float a2)
{
  Solver = FIK::GenericSolver::GetSolver(a1);

  return FIK::IKSolver::setRetargetingGain(Solver, a2);
}

uint64_t CoreIKGenericSolverSetPGain(FIK::GenericSolver *a1, float a2)
{
  Solver = FIK::GenericSolver::GetSolver(a1);

  return FIK::IKSolver::setPGain(Solver, a2);
}

uint64_t CoreIKGenericSolverRigGetLookAtEnabled(uint64_t a1, char *__s)
{
  v4 = strlen(__s);

  return CoreIKRig::getLookAtEnabled(a1, __s, v4);
}

FIK *CoreIKGenericSolverRigSetLookAtEnabled(FIK *a1, char *__s, char a3)
{
  v6 = strlen(__s);

  return CoreIKRig::setLookAtEnabled(a1, __s, v6, a3);
}

double CoreIKGenericSolverRigGetLookAtAxis(uint64_t a1, char *__s)
{
  v4 = strlen(__s);

  *&result = CoreIKRig::getLookAtAxis(a1, __s, v4).n128_u64[0];
  return result;
}

double CoreIKGenericSolverRigSetLookAtAxis(uint64_t a1, char *__s, __n128 a3)
{
  v5 = strlen(__s);

  *&result = CoreIKRig::setLookAtAxis(a1, __s, v5, a3).n128_u64[0];
  return result;
}

uint64_t CoreIKGenericSolverRigIsUsingLocalSpaceLookAtAxis(uint64_t a1, char *__s)
{
  v4 = strlen(__s);

  return CoreIKRig::getUsesLocalSpaceLookAtAxis(a1, __s, v4);
}

FIK *CoreIKGenericSolverRigSetUsesLocalSpaceLookAtAxis(FIK *a1, char *__s)
{
  v4 = strlen(__s);

  return CoreIKRig::setUsesLocalSpaceLookAtAxis(a1, __s, v4);
}

uint64_t CoreIKGenericSolverRigIsUsingModelSpaceLookAtAxis(uint64_t a1, char *__s)
{
  v4 = strlen(__s);

  return CoreIKRig::getUsesModelSpaceLookAtAxis(a1, __s, v4);
}

FIK *CoreIKGenericSolverRigSetUsesModelSpaceLookAtAxis(FIK *a1, char *__s)
{
  v4 = strlen(__s);

  return CoreIKRig::setUsesModelSpaceLookAtAxis(a1, __s, v4);
}

uint64_t CoreIKSolver::destroy(CoreIKSolver *this, CoreIKSolver *a2)
{
  v2 = this;
  if (!this)
  {
    this = CoreIKSolver::destroy();
  }

  v3 = FIK::defaultAllocator(this);

  return FIK::Allocator::destroy<CoreIKACPPenetrationSolver>(v3, v2);
}

uint64_t FIK::Segment::setLimits()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "setLimits", "(axis <= 3) There are 4 valid axes");
}

uint64_t FIK::Segment::setRotationAxis()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "setRotationAxis", "(rotation_axis <= 3) There are 4 valid axes");
}

uint64_t FIK::Segment::setProjectionAxis()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "setProjectionAxis", "(projection_axis <= 2) There are only 3 valid axes");
}

uint64_t FIK::RangeInCircularSpace::expandLeftBy()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "expandLeftBy", "(amount >= 0.0f) Must expand range by a non-negative amount.");
}

uint64_t FIK::RangeInCircularSpace::expandRightBy()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "expandRightBy", "(amount >= 0.0f) Must expand range by a non-negative amount.");
}

uint64_t FIK::EulerLimitsChecker::EulerLimitsChecker()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "EulerLimitsChecker", "(std::min({forwardAxis, leftAxis, upAxis}) == 0) Axis indices must be within [0, 2].");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "EulerLimitsChecker", "(std::max({forwardAxis, leftAxis, upAxis}) == 2) Axis indices must be within [0, 2].");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "EulerLimitsChecker", "(forwardAxis != leftAxis) All axes must be unique.");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "EulerLimitsChecker", "(forwardAxis != upAxis) All axes must be unique.");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "EulerLimitsChecker", "(leftAxis != upAxis) All axes must be unique.");
}

uint64_t IKString::allocateStringBuffer()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "allocateStringBuffer", "(buffer) Unable to allocate memory for string.");
}

BOOL FIK::Solver::CheckSolve(FIK::Solver *this, float *a2, float *a3)
{
  v6 = *(this + 82);
  if (v6)
  {
    v7 = 0;
    v8.i64[0] = 0x7F0000007FLL;
    v8.i64[1] = 0x7F0000007FLL;
    v9 = vnegq_f32(v8);
    while (vaddvq_s32(vabsq_s32(vcgtq_s32(v9, (*(*(this + 55) + 4 * v7) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL))))) >= 4)
    {
      v7 += 4;
      if (v7 >= v6)
      {
        goto LABEL_5;
      }
    }

    return 0;
  }

  else
  {
LABEL_5:
    v10 = *(this + 86);
    if (v11 >= v12)
    {
      v14 = v11;
    }

    else
    {
      v14 = v12;
    }

    *a2 = v14;
    if (*a3 >= v13)
    {
      v13 = *a3;
    }

    *a3 = v13;
    v15 = *a2 / v13;
    *a2 = v15;
    return *a3 <= 100000.0 && v15 <= (*(this + 161) * 3.0);
  }
}

void FIK::Solver::solve(_BYTE *a1)
{
  v6 = *MEMORY[0x277D85DE8];
  v2 = ikinemaLogObject()[1];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v4 = 136315138;
    v5 = "solve";
    _os_log_error_impl(&dword_245976000, v2, OS_LOG_TYPE_ERROR, "%s: Bad solver tuning detected.", &v4, 0xCu);
  }

  *a1 = 0;
  v3 = *MEMORY[0x277D85DE8];
}

void ikinemaLogObject()
{
  if (__cxa_guard_acquire(&_MergedGlobals))
  {
    qword_27EE32D28 = os_log_create("com.apple.coreik", "general");
    qword_27EE32D30 = os_log_create("com.apple.coreik", "solver");
    qword_27EE32D38 = os_log_create("com.apple.coreik", "rig");
    qword_27EE32D40 = os_log_create("com.apple.coreik", "fusion");

    __cxa_guard_release(&_MergedGlobals);
  }
}

void FIK::IKSolver::solve(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "autoTuneBasedOnStability";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Invalid solver input detected.", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

void FIK::SetMemoryRoutines()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "SetMemoryRoutines", "(false) Dynamic memory routines must always be in pairs");
  __break(1u);
}

uint64_t rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>::Accept<rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>>(unsigned int *a1, _BYTE *a2)
{
  v4 = *(a1 + 11);
  switch(v4 & 7)
  {
    case 0:
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::PrettyPrefix(a2);

      return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::WriteNull(a2);
    case 1:
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::PrettyPrefix(a2);
      v7 = a2;
      v8 = 0;
      goto LABEL_26;
    case 2:
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::PrettyPrefix(a2);
      v7 = a2;
      v8 = 1;
LABEL_26:

      return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::WriteBool(v7, v8);
    case 3:
      if (!rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::StartObject(a2))
      {
        return 0;
      }

      if (!*a1)
      {
        goto LABEL_51;
      }

      v9 = *(a1 + 1) + 24;
      while (1)
      {
        v10 = (*(v9 - 2) & 0x1000) != 0 ? (v9 - 24) : *(v9 - 16);
        v11 = (*(v9 - 2) & 0x1000) != 0 ? 21 - *(v9 - 3) : *(v9 - 24);
        rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::PrettyPrefix(a2);
        if (!rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::WriteString(a2, v10, v11) || (rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>::Accept<rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>>(v9, a2) & 1) == 0)
        {
          break;
        }

        v9 += 48;
        if (v9 - 24 == *(a1 + 1) + 48 * *a1)
        {
LABEL_51:

          return rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::EndObject(a2);
        }
      }

      return 0;
    case 4:
      if (!rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::StartArray(a2))
      {
        return 0;
      }

      if (!*a1)
      {
        goto LABEL_48;
      }

      v6 = *(a1 + 1);
      break;
    case 5:
      if ((*(a1 + 11) & 0x1000) != 0)
      {
        v12 = a1;
      }

      else
      {
        v12 = *(a1 + 1);
      }

      if ((*(a1 + 11) & 0x1000) != 0)
      {
        v13 = 21 - *(a1 + 21);
      }

      else
      {
        v13 = *a1;
      }

      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::PrettyPrefix(a2);

      return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::WriteString(a2, v12, v13);
    default:
      if ((*(a1 + 11) & 0x200) != 0)
      {
        v15 = *a1;

        return rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::Double(a2, v15);
      }

      else if ((v4 & 0x20) != 0)
      {
        v16 = *a1;

        return rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::Int(a2, v16);
      }

      else if ((v4 & 0x40) != 0)
      {
        v17 = *a1;

        return rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::Uint(a2, v17);
      }

      else
      {
        v14 = *a1;
        if ((v4 & 0x80) != 0)
        {

          return rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::Int64(a2, v14);
        }

        else
        {

          return rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::Uint64(a2, v14);
        }
      }
  }

  do
  {
    if ((rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>::Accept<rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>>(v6, a2) & 1) == 0)
    {
      return 0;
    }

    v6 += 24;
  }

  while (v6 != *(a1 + 1) + 24 * *a1);
LABEL_48:

  return rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::EndArray(a2);
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::Parse<0u,rapidjson::UTF8<char>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  v7[0] = a2;
  v7[1] = a2;
  v4 = &a2[a3];
  v7[2] = &a2[a3];
  v7[3] = a3;
  v6 = v7;
  if (a3 && *a2 == 239)
  {
    v7[0] = ++a2;
  }

  if (a2 != v4)
  {
    if (*a2 == 187)
    {
      v7[0] = ++a2;
    }

    if (a2 != v4 && *a2 == 191)
    {
      v7[0] = a2 + 1;
    }
  }

  rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::ParseStream<0u,rapidjson::UTF8<char>,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, &v6);
  return a1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::ParseStream<0u,rapidjson::UTF8<char>,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(uint64_t a1, unsigned __int8 ***a2)
{
  v3 = a1 + 40;
  v13 = *(a1 + 40);
  v14 = 0u;
  v15 = 0u;
  v16 = 256;
  v17 = 0;
  v18 = 0;
  v19 = 2;
  v4 = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::Parse<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(&v13, a2, a1);
  *(a1 + 88) = v4;
  *(a1 + 96) = v5;
  if (!v4)
  {
    v6 = *(a1 + 64);
    v7 = (v6 - 24);
    *(a1 + 64) = v6 - 24;
    if (v6 - 24 != a1)
    {
      v8 = *(v6 - 2);
      *(v6 - 2) = 0;
      v9 = *v7;
      v10 = *(v6 - 8);
      *(a1 + 20) = *(v7 + 10);
      *(a1 + 16) = v10;
      *a1 = v9;
      *(a1 + 22) = v8;
    }
  }

  *(a1 + 64) = *(a1 + 56);
  rapidjson::internal::Stack<FIK::RapidJsonAllocator>::ShrinkToFit(v3);
  rapidjson::internal::Stack<FIK::RapidJsonAllocator>::Destroy(&v13, v11);
  return a1;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::Parse<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(uint64_t a1, unsigned __int8 ***a2, uint64_t a3)
{
  *(a1 + 48) = 0;
  *(a1 + 56) = 0;
  rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::SkipWhitespaceAndComments<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, a2);
  if (!*(a1 + 48))
  {
    v6 = *a2;
    v7 = **a2;
    if (v7 == (*a2)[2] || !*v7)
    {
      v10 = 1;
    }

    else
    {
      rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseValue<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(a1, a2, a3);
      if (*(a1 + 48))
      {
        goto LABEL_8;
      }

      rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::SkipWhitespaceAndComments<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, a2);
      if (*(a1 + 48))
      {
        goto LABEL_8;
      }

      v6 = *a2;
      v7 = **a2;
      if (v7 == (*a2)[2] || !*v7)
      {
        goto LABEL_8;
      }

      v10 = 2;
    }

    v11 = v7 - v6[1];
    *(a1 + 48) = v10;
    *(a1 + 56) = v11;
  }

LABEL_8:
  result = *(a1 + 48);
  v9 = *(a1 + 56);
  *(a1 + 24) = *(a1 + 16);
  return result;
}

FIK::RapidJsonAllocator *rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseNull<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(FIK::RapidJsonAllocator *result, void **a2, uint64_t a3)
{
  v4 = *a2;
  v5 = **a2;
  v6 = (*a2)[2];
  if (v5 != v6)
  {
    *v4 = ++v5;
  }

  if (v5 == v6)
  {
    goto LABEL_12;
  }

  if (*v5 != 117)
  {
    v7 = v5;
    goto LABEL_13;
  }

  v7 = v5 + 1;
  *v4 = v5 + 1;
  if (v5 + 1 == v6)
  {
LABEL_12:
    v7 = v6;
LABEL_13:
    v9 = &v7[-v4[1]];
    *(result + 12) = 3;
    *(result + 7) = v9;
    return result;
  }

  if (*v7 != 108)
  {
    goto LABEL_13;
  }

  *v4 = v5 + 2;
  v7 = v6;
  if (v5 + 2 == v6)
  {
    goto LABEL_13;
  }

  v7 = v5 + 2;
  if (v5[2] != 108)
  {
    goto LABEL_13;
  }

  *v4 = v5 + 3;
  v8 = *(a3 + 64);
  if ((*(a3 + 72) - v8) <= 23)
  {
    result = rapidjson::internal::Stack<FIK::RapidJsonAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>>(a3 + 40, 1);
    v8 = *(a3 + 64);
  }

  *(a3 + 64) = v8 + 3;
  *v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  return result;
}

FIK::RapidJsonAllocator *rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseTrue<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(FIK::RapidJsonAllocator *result, void **a2, uint64_t a3)
{
  v4 = *a2;
  v5 = **a2;
  v6 = (*a2)[2];
  if (v5 != v6)
  {
    *v4 = ++v5;
  }

  if (v5 == v6)
  {
    goto LABEL_12;
  }

  if (*v5 != 114)
  {
    v7 = v5;
    goto LABEL_13;
  }

  v7 = v5 + 1;
  *v4 = v5 + 1;
  if (v5 + 1 == v6)
  {
LABEL_12:
    v7 = v6;
LABEL_13:
    v9 = &v7[-v4[1]];
    *(result + 12) = 3;
    *(result + 7) = v9;
    return result;
  }

  if (*v7 != 117)
  {
    goto LABEL_13;
  }

  *v4 = v5 + 2;
  v7 = v6;
  if (v5 + 2 == v6)
  {
    goto LABEL_13;
  }

  v7 = v5 + 2;
  if (v5[2] != 101)
  {
    goto LABEL_13;
  }

  *v4 = v5 + 3;
  v8 = *(a3 + 64);
  if (*(a3 + 72) - v8 <= 23)
  {
    result = rapidjson::internal::Stack<FIK::RapidJsonAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>>(a3 + 40, 1);
    v8 = *(a3 + 64);
  }

  *(a3 + 64) = v8 + 24;
  *(v8 + 8) = 0;
  *(v8 + 16) = 0;
  *v8 = 0;
  *(v8 + 22) = 10;
  return result;
}

FIK::RapidJsonAllocator *rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseFalse<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(FIK::RapidJsonAllocator *result, void **a2, uint64_t a3)
{
  v4 = *a2;
  v5 = **a2;
  v6 = (*a2)[2];
  if (v5 != v6)
  {
    *v4 = ++v5;
  }

  if (v5 == v6)
  {
    goto LABEL_14;
  }

  if (*v5 != 97)
  {
    v7 = v5;
    goto LABEL_15;
  }

  v7 = v5 + 1;
  *v4 = v5 + 1;
  if (v5 + 1 == v6)
  {
    goto LABEL_14;
  }

  if (*v7 != 108)
  {
LABEL_15:
    v9 = &v7[-v4[1]];
    *(result + 12) = 3;
    *(result + 7) = v9;
    return result;
  }

  v7 = v5 + 2;
  *v4 = v5 + 2;
  if (v5 + 2 == v6)
  {
LABEL_14:
    v7 = v6;
    goto LABEL_15;
  }

  if (*v7 != 115)
  {
    goto LABEL_15;
  }

  *v4 = v5 + 3;
  v7 = v6;
  if (v5 + 3 == v6)
  {
    goto LABEL_15;
  }

  v7 = v5 + 3;
  if (v5[3] != 101)
  {
    goto LABEL_15;
  }

  *v4 = v5 + 4;
  v8 = *(a3 + 64);
  if (*(a3 + 72) - v8 <= 23)
  {
    result = rapidjson::internal::Stack<FIK::RapidJsonAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>>(a3 + 40, 1);
    v8 = *(a3 + 64);
  }

  *(a3 + 64) = v8 + 24;
  *(v8 + 8) = 0;
  *(v8 + 16) = 0;
  *v8 = 0;
  *(v8 + 22) = 9;
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseString<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(uint64_t result, unsigned __int8 ***a2, uint64_t a3)
{
  v5 = result;
  v6 = *a2;
  v7 = **a2;
  v8 = (*a2)[2];
  if (v7 != v8)
  {
    *v6 = ++v7;
  }

  v28 = result;
  v29 = 0;
  if (v7 != v8)
  {
    while (1)
    {
      v9 = *v7;
      if (v9 != 92)
      {
        break;
      }

      v13 = v7 - v6[1];
      *v6 = v7 + 1;
      if (v7 + 1 == v8)
      {
        goto LABEL_38;
      }

      v14 = v7[1];
      v10 = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseStringToStream<0u,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::StackStream<char>>(rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream> &,rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::StackStream<char> &)::escape[v14];
      if (v10)
      {
        *v6 = v7 + 2;
LABEL_8:
        v11 = v28;
        v12 = *(v28 + 24);
        if ((*(v28 + 32) - v12) <= 0)
        {
          result = rapidjson::internal::Stack<FIK::RapidJsonAllocator>::Expand<char>(v28, 1);
          v12 = *(v11 + 24);
        }

        *(v11 + 24) = v12 + 1;
        *v12 = v10;
        ++v29;
        goto LABEL_11;
      }

      if (v14 != 117)
      {
LABEL_38:
        v26 = 10;
        goto LABEL_35;
      }

      *v6 = v7 + 2;
      v27 = v13;
      result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseHex4<rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(v5, a2, v13);
      if (*(v5 + 48))
      {
        return result;
      }

      v15 = result;
      if (result >> 11 == 27)
      {
        if (result >> 10 > 0x36)
        {
          goto LABEL_41;
        }

        v16 = *a2;
        v17 = **a2;
        v18 = (*a2)[2];
        if (v17 == v18)
        {
          goto LABEL_41;
        }

        if (*v17 != 92)
        {
          goto LABEL_41;
        }

        *v16 = v17 + 1;
        if (v17 + 1 == v18 || v17[1] != 117)
        {
          goto LABEL_41;
        }

        v19 = result;
        *v16 = v17 + 2;
        result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseHex4<rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(v5, a2, v27);
        if (*(v5 + 48))
        {
          return result;
        }

        if ((result - 57344) <= 0xFFFFFBFF)
        {
LABEL_41:
          *(v5 + 48) = 9;
          v13 = v27;
          goto LABEL_36;
        }

        v15 = result + (v19 << 10) - 56613888;
      }

      result = rapidjson::UTF8<char>::Encode<rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::StackStream<char>>(&v28, v15);
LABEL_11:
      v6 = *a2;
      v7 = **a2;
      v8 = (*a2)[2];
      if (v7 == v8)
      {
        goto LABEL_34;
      }
    }

    if (v9 == 34)
    {
      *v6 = v7 + 1;
      v20 = v28;
      v21 = *(v28 + 24);
      if ((*(v28 + 32) - v21) <= 0)
      {
        result = rapidjson::internal::Stack<FIK::RapidJsonAllocator>::Expand<char>(v28, 1);
        v21 = *(v20 + 24);
      }

      *(v20 + 24) = v21 + 1;
      *v21 = 0;
      v22 = v29;
      v23 = ++v29;
      if (!*(v5 + 48))
      {
        v24 = (*(v28 + 24) - v23);
        *(v28 + 24) = v24;
        result = rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::String(a3, v24, v22, 1);
        if ((result & 1) == 0)
        {
          v25 = **a2 - (*a2)[1];
          *(v5 + 48) = 16;
          *(v5 + 56) = v25;
        }
      }

      return result;
    }

    if (v9 <= 0x1F)
    {
      if (!*v7)
      {
        goto LABEL_34;
      }

      v13 = v7 - v6[1];
      v26 = 12;
      goto LABEL_35;
    }

    *v6 = v7 + 1;
    v10 = *v7;
    goto LABEL_8;
  }

  v7 = v8;
LABEL_34:
  v13 = v7 - v6[1];
  v26 = 11;
LABEL_35:
  *(v5 + 48) = v26;
LABEL_36:
  *(v5 + 56) = v13;
  return result;
}

void rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseObject<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(uint64_t a1, unsigned __int8 ***a2, uint64_t a3)
{
  v6 = **a2;
  if (v6 != (*a2)[2])
  {
    **a2 = v6 + 1;
  }

  if (rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::StartObject(a3))
  {
    rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::SkipWhitespaceAndComments<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, a2);
    if (*(a1 + 48))
    {
      return;
    }

    v7 = **a2;
    if (v7 != (*a2)[2] && *v7 == 125)
    {
      **a2 = v7 + 1;
      v8 = *(a3 + 64);
      *(v8 - 2) = 3;
      *(v8 - 24) = 0;
      *(v8 - 16) = 0;
      return;
    }

    for (i = 1; ; ++i)
    {
      v10 = **a2;
      if (v10 == (*a2)[2] || *v10 != 34)
      {
        v16 = v10 - (*a2)[1];
        v17 = 4;
        goto LABEL_27;
      }

      rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseString<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(a1, a2, a3);
      if (*(a1 + 48))
      {
        return;
      }

      rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::SkipWhitespaceAndComments<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, a2);
      if (*(a1 + 48))
      {
        return;
      }

      v11 = *a2;
      v12 = **a2;
      if (v12 == (*a2)[2] || *v12 != 58)
      {
        v16 = v12 - v11[1];
        v17 = 5;
        goto LABEL_27;
      }

      *v11 = v12 + 1;
      rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::SkipWhitespaceAndComments<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, a2);
      if (*(a1 + 48))
      {
        return;
      }

      rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseValue<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(a1, a2, a3);
      if (*(a1 + 48))
      {
        return;
      }

      rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::SkipWhitespaceAndComments<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, a2);
      if (*(a1 + 48))
      {
        return;
      }

      v13 = *a2;
      v14 = **a2;
      if (v14 == (*a2)[2])
      {
        goto LABEL_26;
      }

      v15 = *v14;
      if (v15 != 44)
      {
        break;
      }

      *v13 = v14 + 1;
      rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::SkipWhitespaceAndComments<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, a2);
      if (*(a1 + 48))
      {
        return;
      }
    }

    if (v15 != 125)
    {
LABEL_26:
      v16 = v14 - v13[1];
      v17 = 6;
      goto LABEL_27;
    }

    *v13 = v14 + 1;
    if (rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::EndObject(a3, i))
    {
      return;
    }
  }

  v16 = **a2 - (*a2)[1];
  v17 = 16;
LABEL_27:
  *(a1 + 48) = v17;
  *(a1 + 56) = v16;
}

void rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseArray<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(uint64_t a1, unsigned __int8 ***a2, uint64_t a3)
{
  v6 = **a2;
  if (v6 != (*a2)[2])
  {
    **a2 = v6 + 1;
  }

  if (rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::StartArray(a3))
  {
    rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::SkipWhitespaceAndComments<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, a2);
    if (!*(a1 + 48))
    {
      v7 = **a2;
      if (v7 == (*a2)[2] || *v7 != 93)
      {
        v9 = 1;
        do
        {
          rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseValue<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(a1, a2, a3);
          if (*(a1 + 48))
          {
            break;
          }

          rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::SkipWhitespaceAndComments<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, a2);
          if (*(a1 + 48))
          {
            break;
          }

          v10 = *a2;
          v11 = **a2;
          if (v11 == (*a2)[2])
          {
            goto LABEL_20;
          }

          v12 = *v11;
          if (v12 != 44)
          {
            if (v12 != 93)
            {
LABEL_20:
              v13 = v11 - v10[1];
              v14 = 7;
              goto LABEL_19;
            }

            *v10 = v11 + 1;
            if (rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::EndArray(a3, v9))
            {
              return;
            }

            goto LABEL_18;
          }

          *v10 = v11 + 1;
          rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::SkipWhitespaceAndComments<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>>(a1, a2);
          ++v9;
        }

        while (!*(a1 + 48));
      }

      else
      {
        **a2 = v7 + 1;
        v8 = *(a3 + 64);
        *(v8 - 2) = 4;
        *(v8 - 24) = 0;
        *(v8 - 16) = 0;
      }
    }
  }

  else
  {
LABEL_18:
    v13 = **a2 - (*a2)[1];
    v14 = 16;
LABEL_19:
    *(a1 + 48) = v14;
    *(a1 + 56) = v13;
  }
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,FIK::RapidJsonAllocator>::ParseNumber<0u,rapidjson::EncodedInputStream<rapidjson::UTF8<char>,rapidjson::MemoryStream>,rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>>(uint64_t result, unsigned __int8 ***a2, uint64_t a3)
{
  v3 = result;
  v4 = *a2;
  v5 = **a2;
  v6 = (*a2)[2];
  if (v5 == v6 || *v5 != 45)
  {
    v8 = 0;
    v7 = **a2;
  }

  else
  {
    v7 = v5 + 1;
    *v4 = v5 + 1;
    v8 = 1;
  }

  v9 = v4[1];
  if (v7 == v6)
  {
    goto LABEL_131;
  }

  v10 = *v7;
  if (v10 == 48)
  {
    v18 = 0;
    v14 = 0;
    v21 = 0;
    v22 = 0;
    v12 = 0;
    v11 = v7 + 1;
    *v4 = v7 + 1;
    v13 = 0.0;
    goto LABEL_57;
  }

  if ((v10 - 49) > 8)
  {
LABEL_131:
    v39 = 3;
    goto LABEL_125;
  }

  v11 = v7 + 1;
  *v4 = v7 + 1;
  v12 = *v7 - 48;
  v13 = 0.0;
  if ((v8 & 1) == 0)
  {
    if (v7 + 1 != v6)
    {
      v14 = 0;
      v15 = v6 - v11;
      while (1)
      {
        v17 = *v11;
        result = v17 - 48;
        if (result > 9)
        {
          goto LABEL_36;
        }

        if (v12 > 0x19999998)
        {
          if (v12 != 429496729)
          {
            goto LABEL_26;
          }

          if (v17 > 0x35)
          {
            v12 = 429496729;
LABEL_26:
            v18 = v12;
            v13 = 0.0;
            if (v8)
            {
              if (v11 != v6)
              {
                v15 = v14 + v6 - v11;
                result = 10;
                while (1)
                {
                  v19 = *v11;
                  if ((v19 - 48) > 9)
                  {
                    break;
                  }

                  if (v18 > 0xCCCCCCCCCCCCCCBLL)
                  {
                    if (v18 != 0xCCCCCCCCCCCCCCCLL)
                    {
                      goto LABEL_48;
                    }

                    if (v19 == 57)
                    {
                      v18 = 0xCCCCCCCCCCCCCCCLL;
                      goto LABEL_48;
                    }
                  }

                  v20 = v11 + 1;
                  *v4 = v11 + 1;
                  v18 = (*v11 - 48) + 10 * v18;
                  ++v14;
                  v11 = v20;
                  if (v20 == v6)
                  {
                    goto LABEL_53;
                  }
                }
              }
            }

            else if (v11 != v6)
            {
              v15 = v14 + v6 - v11;
              result = 10;
              while (1)
              {
                v23 = *v11;
                if (v23 - 48 > 9)
                {
                  break;
                }

                if (v18 > 0x1999999999999998)
                {
                  if (v18 != 0x1999999999999999)
                  {
                    goto LABEL_48;
                  }

                  if (v23 > 0x35)
                  {
                    v18 = 0x1999999999999999;
LABEL_48:
                    v13 = v18;
                    if (v11 != v6)
                    {
                      while (*v11 - 48 <= 9)
                      {
                        v24 = v11 + 1;
                        *v4 = v11 + 1;
                        v13 = (*v11 - 48) + v13 * 10.0;
                        v11 = v24;
                        if (v24 == v6)
                        {
                          v21 = 1;
                          v11 = v24;
                          goto LABEL_56;
                        }
                      }
                    }

                    v21 = 1;
                    goto LABEL_56;
                  }
                }

                v20 = v11 + 1;
                *v4 = v11 + 1;
                v18 = (*v11 - 48) + 10 * v18;
                ++v14;
                v11 = v20;
                if (v20 == v6)
                {
LABEL_53:
                  v21 = 0;
                  v22 = 1;
                  v11 = v20;
                  goto LABEL_54;
                }
              }
            }

            v21 = 0;
LABEL_56:
            v22 = 1;
            goto LABEL_57;
          }
        }

        result = (v11 + 1);
        *v4 = v11 + 1;
        v12 = *v11 + 10 * v12 - 48;
        ++v14;
        v11 = result;
        if (result == v6)
        {
LABEL_38:
          v18 = 0;
          v21 = 0;
          v22 = 0;
          v11 = result;
LABEL_54:
          v14 = v15;
          goto LABEL_57;
        }
      }
    }

LABEL_130:
    v18 = 0;
    v14 = 0;
    goto LABEL_37;
  }

  if (v7 + 1 == v6)
  {
    goto LABEL_130;
  }

  v14 = 0;
  v15 = v6 - v11;
  while (1)
  {
    v16 = *v11;
    result = (v16 - 48);
    if (result > 9)
    {
      break;
    }

    if (v12 > 0xCCCCCCB)
    {
      if (v12 != 214748364)
      {
        goto LABEL_26;
      }

      if (v16 == 57)
      {
        v12 = 214748364;
        goto LABEL_26;
      }
    }

    result = (v11 + 1);
    *v4 = v11 + 1;
    v12 = *v11 + 10 * v12 - 48;
    ++v14;
    v11 = result;
    if (result == v6)
    {
      goto LABEL_38;
    }
  }

LABEL_36:
  v18 = 0;
LABEL_37:
  v21 = 0;
  v22 = 0;
LABEL_57:
  if (v11 == v6 || *v11 != 46)
  {
    v25 = 0;
  }

  else
  {
    v7 = v11 + 1;
    *v4 = v11 + 1;
    if (v11 + 1 == v6 || *v7 - 58 < 0xFFFFFFF6)
    {
      v39 = 14;
      goto LABEL_125;
    }

    v25 = 0;
    if ((v21 & 1) == 0)
    {
      if (!v22)
      {
        v18 = v12;
      }

      v26 = v7 - v6;
      result = 4294967248;
      while (*v7 >= 48)
      {
        if (*v7 > 0x39u || v18 >> 53 != 0)
        {
          break;
        }

        v28 = v7 + 1;
        *v4 = v7 + 1;
        v18 = (*v7 - 48) + 10 * v18;
        --v25;
        if (v18)
        {
          ++v14;
        }

        ++v7;
        if (v28 == v6)
        {
          v7 = v28;
          v25 = v26;
          break;
        }
      }

      v13 = v18;
    }

    if (v7 == v6)
    {
LABEL_82:
      v21 = 1;
      v11 = v7;
    }

    else
    {
      while (1)
      {
        v11 = v7;
        if (*v7 - 48 > 9)
        {
          break;
        }

        ++v7;
        *v4 = v11 + 1;
        if (v14 <= 16)
        {
          v13 = (*v11 - 48) + v13 * 10.0;
          --v25;
          if (v13 > 0.0)
          {
            ++v14;
          }
        }

        if (v7 == v6)
        {
          goto LABEL_82;
        }
      }

      v21 = 1;
    }
  }

  if (v11 == v6 || (*v11 | 0x20) != 0x65)
  {
    if (!v21)
    {
      if (v22)
      {
        if (v8)
        {
          result = rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::Int64(a3, -v18);
          if (result)
          {
            return result;
          }
        }

        else
        {
          result = rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::Uint64(a3, v18);
          if (result)
          {
            return result;
          }
        }
      }

      else if (v8)
      {
        result = rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::Int(a3, -v12);
        if (result)
        {
          return result;
        }
      }

      else
      {
        result = rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::Uint(a3, v12);
        if (result)
        {
          return result;
        }
      }

LABEL_142:
      v39 = 16;
      goto LABEL_124;
    }

    v35 = 0;
  }

  else
  {
    v7 = v11 + 1;
    *v4 = v11 + 1;
    if (!v22)
    {
      v18 = v12;
    }

    if (!v21)
    {
      v13 = v18;
    }

    if (v7 != v6 && ((v29 = *v7, v30 = v29 != 43, v29 == 43) || v29 == 45))
    {
      v7 = v11 + 2;
      *v4 = v11 + 2;
    }

    else
    {
      v30 = 0;
    }

    if (v7 == v6 || *v7 - 48 > 9)
    {
      v39 = 15;
      goto LABEL_125;
    }

    v31 = (v7 + 1);
    *v4 = v7 + 1;
    v32 = *v7 - 48;
    if (v30)
    {
      if (v31 != v6)
      {
        do
        {
          if (*v31 - 48 > 9)
          {
            break;
          }

          v33 = (v31 + 1);
          *v4 = (v31 + 1);
          v32 = *v31 + 10 * v32 - 48;
          if (v32 > (v25 + 2147483639) / 10 && v33 != v6)
          {
            do
            {
              if (*v33 - 48 > 9)
              {
                break;
              }

              *v4 = ++v33;
            }

            while (v33 != v6);
          }

          v31 = v33;
        }

        while (v33 != v6);
      }
    }

    else
    {
      while (v31 != v6 && *v31 - 48 <= 9)
      {
        *v4 = (v31 + 1);
        v32 = *v31++ + 10 * v32 - 48;
        if (v32 > 308 - v25)
        {
          goto LABEL_123;
        }
      }
    }

    if (v30)
    {
      v35 = -v32;
    }

    else
    {
      v35 = v32;
    }
  }

  v36 = v35 + v25;
  if (v36 > -309)
  {
    if ((v36 & 0x80000000) == 0)
    {
      v37 = v13 * rapidjson::internal::Pow10(int)::e[v36];
      goto LABEL_122;
    }

    v38 = -v36;
  }

  else
  {
    v37 = 0.0;
    if (v36 < 0xFFFFFD98)
    {
      goto LABEL_126;
    }

    v13 = v13 / 1.0e308;
    v38 = -308 - v36;
  }

  v37 = v13 / rapidjson::internal::Pow10(int)::e[v38];
LABEL_122:
  if (v37 > 1.79769313e308)
  {
LABEL_123:
    v39 = 13;
LABEL_124:
    v7 = v5;
LABEL_125:
    *(v3 + 48) = v39;
    *(v3 + 56) = v7 - v9;
    return result;
  }

LABEL_126:
  v40 = -v37;
  if (!v8)
  {
    v40 = v37;
  }

  result = rapidjson::GenericDocument<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>,FIK::RapidJsonAllocator>::Double(a3, v40);
  if ((result & 1) == 0)
  {
    goto LABEL_142;
  }

  return result;
}

void FIK::IKRigUtils::updateSourceIndices(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "updateSourceIndices";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Invalid source name for constraint detected.", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

_BYTE *rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::WriteString(_BYTE *result, uint64_t a2, char a3, unsigned __int8 a4)
{
  *result = 92;
  v4 = *(*a2 + 24);
  *(*a2 + 24) = v4 + 1;
  *v4 = a3;
  if (a3 == 117)
  {
    v5 = *(*a2 + 24);
    *(*a2 + 24) = v5 + 1;
    *v5 = 48;
    v6 = *(*a2 + 24);
    *(*a2 + 24) = v6 + 1;
    *v6 = 48;
    LOBYTE(v5) = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::WriteString(char const*,unsigned int)::hexDigits[a4 >> 4];
    v7 = *(*a2 + 24);
    *(*a2 + 24) = v7 + 1;
    *v7 = v5;
    LOBYTE(v5) = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,rapidjson::CrtAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,rapidjson::CrtAllocator,0u>::WriteString(char const*,unsigned int)::hexDigits[a4 & 0xF];
    v8 = *(*a2 + 24);
    *(*a2 + 24) = v8 + 1;
    *v8 = v5;
  }

  return result;
}

void rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>::operator[]<rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>()
{
  {
    rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>::operator[]<rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>(rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>> const&)::buffer = 0;
    unk_27EE32D00 = 0;
    qword_27EE32D08 = 0;
    __cxa_atexit(rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>::~GenericValue, &rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>::operator[]<rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>>(rapidjson::GenericValue<rapidjson::UTF8<char>,rapidjson::MemoryPoolAllocator<FIK::RapidJsonAllocator>> const&)::buffer, &dword_245976000);
  }
}

void FIK::EnrollmentPoseSolver::EnrollmentPoseSolver(os_log_t log, float a2, float a3)
{
  v10 = *MEMORY[0x277D85DE8];
  v4 = 136315650;
  v5 = "verifyRigAssumptions";
  v6 = 2048;
  v7 = a2;
  v8 = 2048;
  v9 = a3;
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Detected offset between hips and head (X: %.4f, Z: %.4f)", &v4, 0x20u);
  v3 = *MEMORY[0x277D85DE8];
}

uint64_t FIK::EnrollmentPoseSolver::EnrollmentPoseSolver()
{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "verifyRigAssumptions", "(atlasSourceIndex != kInvalidRigIndex) Missing Atlas source in rig");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "verifyRigAssumptions", "(isIdentityTransform(atlasTaskOffset)) Detected non-zero offset on top of the Atlas source");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "verifyRigAssumptions", "(isIdentityTransform(rig.source_transform)) Detected non-identity source transform");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "verifyRigAssumptions", "(isSourceScale100) Detected wrong source scale");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "EnrollmentPoseSolver", "(cameraCount != 0) No camera data passed to solver");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "EnrollmentPoseSolver", "(hasLiftedData) No sources with lifted data passed to solver");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "EnrollmentPoseSolver", "(m_solverNode.jointsCount() == jointDefinitions.size()) Input joint definitions count does not match the solver joints count.");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "EnrollmentPoseSolver", "(m_dataProcessor.rigAtlasSourceIndex() != kInvalidRigIndex) The head pose must be present as a source.");
}

void FIK::EnrollmentPoseSolver::setupPreprocessingSources(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "setupPreprocessingSources";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Failed to setup virtual hips compensation", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

uint64_t FIK::EnrollmentPoseSolver::updateTaskWeights()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "updateTaskWeights", "(sourcesValidity.size() == rig.sources.size()) Source validity array does not match rig sources count");
}

uint64_t FIK::Enrollment::VirtualSourceController::Descriptor::addDependentSource()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "addDependentSource", "(!dependentSources.back().empty()) Undefined dependent source name.");
}

void FIK::EnrollmentPoseSolverV2::inputsAreValidGivenRig(uint64_t a1, NSObject *a2)
{
  v7 = *MEMORY[0x277D85DE8];
  v3 = 136315394;
  v4 = "inputsAreValidGivenRig";
  v5 = 2080;
  v6 = a1;
  _os_log_error_impl(&dword_245976000, a2, OS_LOG_TYPE_ERROR, "%s: Rig joint: %s not found in input sources.", &v3, 0x16u);
  v2 = *MEMORY[0x277D85DE8];
}

void FIK::EnrollmentPoseSolverV2::inputsAreValidGivenRig(void *a1, void **a2, os_log_t log)
{
  v9 = *MEMORY[0x277D85DE8];
  if (*a1)
  {
    v3 = *a2;
  }

  else
  {
    v3 = &unk_245A04BAE;
  }

  v5 = 136315394;
  v6 = "inputsAreValidGivenRig";
  v7 = 2080;
  v8 = v3;
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Rig joint: %s not found in input targets.", &v5, 0x16u);
  v4 = *MEMORY[0x277D85DE8];
}

uint64_t FIK::Enrollment::VirtualSourceController::Descriptor::Descriptor()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "Descriptor", "(!controlSource.empty()) Undefined controlling source name.");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "Descriptor", "(!correctionSource.empty()) Undefined correcting source name.");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "Descriptor", "(!hipsSource.empty()) Undefined hips source name.");
}

uint64_t ikinema::Buffer::arrayView<FIK::Transform>()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "arrayView", "(m_descriptor.containsType<std::remove_cv_t<RequestedType>>()) Wrong type requested from buffer.");
}

void FIK::EnrollmentPoseSolverV4::areAllRequiredJointsProvided(uint64_t a1, NSObject *a2)
{
  v7 = *MEMORY[0x277D85DE8];
  v3 = 136315394;
  v4 = "areAllRequiredJointsProvided";
  v5 = 2080;
  v6 = a1;
  _os_log_error_impl(&dword_245976000, a2, OS_LOG_TYPE_ERROR, "%s: Rig joint %s not found in input sources.", &v3, 0x16u);
  v2 = *MEMORY[0x277D85DE8];
}

void FIK::EnrollmentPoseSolverV4::areAllRequiredJointsProvided(uint64_t a1, uint64_t a2, os_log_t log)
{
  v10 = *MEMORY[0x277D85DE8];
  v3 = *(a1 + 336) + 544 * a2;
  if (*(v3 + 16))
  {
    v4 = *(v3 + 8);
  }

  else
  {
    v4 = &unk_245A04BAE;
  }

  v6 = 136315394;
  v7 = "areAllRequiredJointsProvided";
  v8 = 2080;
  v9 = v4;
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Rig joint %s not found in input targets.", &v6, 0x16u);
  v5 = *MEMORY[0x277D85DE8];
}

uint64_t FIK::EnrollmentPoseSolverV4::dbgPrintInputs()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "dbgPrintInputs", "(!m_rigInputData.empty()) dbgPrintInputs() can be called only after setRigInputData() has been called.");
}

uint64_t FIK::EnrollmentPoseSolverV4::rigParentJointIndex()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "rigParentJointIndex", "(parentJointIndex != FIK::kInvalidRigIndex) Parent joint not found in the rig.");
}

uint64_t FIK::EnrollmentPoseSolverV4::RigJointIndices::RigJointIndices()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kHips != FIK::kInvalidRigIndex) Hips not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kSpine6 != FIK::kInvalidRigIndex) Spine 6 not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kSpine7 != FIK::kInvalidRigIndex) Spine 7 not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kLeftShoulder != FIK::kInvalidRigIndex) Left shoulder not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kLeftArm != FIK::kInvalidRigIndex) Left arm not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kLeftForearm != FIK::kInvalidRigIndex) Left forearm not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kLeftHand != FIK::kInvalidRigIndex) Left hand not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kRightShoulder != FIK::kInvalidRigIndex) Right shoulder not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kRightArm != FIK::kInvalidRigIndex) Right arm not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kRightForearm != FIK::kInvalidRigIndex) Right forearm not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kRightHand != FIK::kInvalidRigIndex) Right hand not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kNeck1 != FIK::kInvalidRigIndex) Neck 1 joint not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kNeck2 != FIK::kInvalidRigIndex) Neck 2 joint not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kNeck3 != FIK::kInvalidRigIndex) Neck 3 joint not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kNeck4 != FIK::kInvalidRigIndex) Neck 4 joint not included in rig");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "RigJointIndices", "(kHead != FIK::kInvalidRigIndex) Head joint not included in rig");
}

uint64_t FIK::RTBalanceTask::ConvertTargetWorldToSolver()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "ConvertTargetWorldToSolver", "(SolverTaskPtr != nullptr) The task must be existing");
}

void FIK::TargetSmoothing::smooth()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "smooth", "(false) Unhandled target smoothing mode was used");
  __break(1u);
}

void FIK::estimateBoneRotationFromVelocity()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "estimateBoneRotationFromVelocity", "(false) Unsupported axis.");
  __break(1u);
}

void ikinema::DoSolveAlgorithmImpl::process(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "process";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Solve has failed.", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

void FIK::EnrollmentHelpers::verifyRigEnrolment(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Armspan length out of expected range.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Left forearm length out of expected range.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Right forearm length out of expected range.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Left arm length out of expected range.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Right arm length out of expected range.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Forearms asymmetry detected.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Arms asymmetry detected.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Left arm asymmetry detected.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Right arm asymmetry detected.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Neck length vs shoulder width ratio is irregular.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

uint64_t FIK::Enrollment::LiftedSource::LiftedSource()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "LiftedSource", "(detectionIndex != kInvalidRigIndex) Linking rig source to enrollment keypoint failed");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "LiftedSource", "(cameraIndex != kInvalidRigIndex) Linking rig source to enrollment keypoint failed");
}

uint64_t FIK::Enrollment::VirtualSourceHierarchy::VirtualSourceHierarchy()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "VirtualSourceHierarchy", "(rootSourceIndex != kInvalidRigIndex) Failed to find source in solver sources.");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "VirtualSourceHierarchy", "(sourceIndex != kInvalidRigIndex) Failed to find source in solver sources.");
}

uint64_t FIK::Enrollment::VirtualSourceController::VirtualSourceController()
{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "VirtualSourceController", "(m_controlSourceIndex != kInvalidRigIndex) Failed to find controling source in solver sources.");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "VirtualSourceController", "(m_correctionSourceIndex != kInvalidRigIndex) Failed to find corrective source in solver sources.");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "VirtualSourceController", "(depSourceIndex != kInvalidRigIndex) Failed to find dependent source in solver sources.");
}

uint64_t FIK::Enrollment::getBonePoseInSourceSpace()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "getBonePoseInSourceSpace", "(boneIndex != kInvalidRigIndex) The given source is not driving a bone!");
}

uint64_t FIK::Enrollment::VirtualSourceController::updateDependents()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "checkAndCorrectPose", "(initialGuessDistance > 0) Initial guess was on top of the reference.");
}

uint64_t FIK::GenericSolver::GenericSolver()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 1, "GenericSolver", "(GetNumBones() > 0) The solver must contain bones");
}

uint64_t FIK::GenericSolver::ConfigureSegments()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "ConfigureSegments", "(PoseView.size() == Solver->numSegments()) Input pose must match solver skeleton");
}

void FIK::GenericSolver::extractEstimatedPose(uint8_t *buf, void *a2, os_log_t log)
{
  *buf = 136315138;
  *a2 = "extractEstimatedPose";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: No corresponding task in estimation solver. Cannot set esimtated pose.", buf, 0xCu);
}

uint64_t FIK::GenericSolver::Solve()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "Solve", "(poseView.size() == GetNumBones()) Input animation must match solver skeleton");
}

void FIK::GenericSolver::Solve(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "Solve";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Estimation solver auto-tune failed.", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

uint64_t FIK::GenericSolver::SetBoneProperties()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "SetBoneProperties", "(IKRigUtils::IsValidBoneIndex(boneIndex, IKinemaRig)) Bone index must be valid");
}

uint64_t FIK::Enrollment::Exporter::appendPoseToFile()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "appendPoseToFile", "(m_hasHeaders) setup function not called.");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "appendPoseToFile", "(m_fieldCount == pose.size()) Header/pose size mismatch");
}

void FIK::Enrollment::DataLogger::DataLogger(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to open file for writing task target data", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to open file for writing solved pose data", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

uint64_t FIK::Enrollment::createPath()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "createPath", "(!pathToCreate.empty()) Unable to create empty path");
}

void FIK::Enrollment::DataLogger::exportSources(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to open file for writing raw source data", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

uint64_t FIK::Enrollment::SourceExporter::exportSourceData()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "exportSourceData", "(m_fieldCount == (cameraCount * sourceCount)) Header/pose size mismatch");
}

void FIK::Enrollment::DataLogger::exportEnrollment(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to open file for writing bone lengths data", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void FIK::Enrollment::DataLogger::exportComputedSources(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to open file for writing computed source data", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void FIK::Enrollment::SourceAndTargetDataLogger::exportOriginalSources(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to open file for writing input source data", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void FIK::Enrollment::SourceAndTargetDataLogger::exportToFile(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to open file for exporting pose data", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void FIK::Enrollment::SourceAndTargetDataLogger::exportEnrollmentData(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to open file for writing bone lengths data", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void FIK::Enrollment::SourceAndTargetDataLogger::exportAtlasData(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to open file for writing atlas data", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

uint64_t FIK::RetargetingNode::solveInternal()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "solveInternal", "(m_algorithmsAreValidated) The algorithm pipeline is not valid.");
}

uint64_t FIK::RetargetingNode::adjustTaskOffset()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "adjustTaskOffset", "(taskIndex != kInvalidRigIndex && taskIndex < Rig.tasks_.size()) Invalide task index");
}

uint64_t ikinema::Buffer::create()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "create", "(memoryBlock) Unable to allocate memory for buffer.");
}

void FIK::GameRigBuilder::createGameRig()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "makeTask", "(false) No default task for associated joint type.");
  __break(1u);
}

uint64_t FIK::PoseConverter::GetGlobalTransform()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "GetGlobalTransform", "(Index < Pose.size()) Index must be valid");
}

uint64_t FIK::anonymous namespace::getGlobalJointPosition<FIK::BipedIdentifiers::Joint>()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "getGlobalJointTransform", "(jointIndex != -1) Joint not found");
}

uint64_t FIK::AnimNode::updateSolverBoneLengths()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "updateSolverBoneLengths", "(jointsCount() == newLengths.size()) Invalid size for the joint lengths array.");
}

void FIK::AnimNode::updateSolverBoneLengths()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "updateSolverBoneLengths", "(joint != nullptr) Joint not found.");
  __break(1u);
}

uint64_t FIK::RTGameTask::SetLookAtTarget()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "SetLookAtTarget", "(is_look_at_) Task must be a look-at one");
}

uint64_t FIK::RTGameTask::SetLookAtTargetParams(_BYTE *a1)
{
  v2 = ikinemaLogObject();
  result = ikinemaAssertHandler(*v2, 0, "SetLookAtTargetParams", "(is_look_at_) Task must be a look-at one");
  if ((*a1 & 1) == 0)
  {
    v4 = *ikinemaLogObject();

    return ikinemaAssertHandler(v4, 0, "SetLookAtTarget", "(is_look_at_) Task must be a look-at one");
  }

  return result;
}

uint64_t FIK::RTGameTask::SetImpactPointAndNormal()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "SetImpactPointAndNormal", "(is_raytrace_) Task must be configured as ray casting");
}

uint64_t FIK::IKRigUtils::GetAnimTarget<FIK::GameRig>()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "GetAnimTarget", "(IsValidBoneIndex(BoneIndex, IKinemaRig)) Check if index is valid");
}

uint64_t FIK::RTGameTask::ConvertTargetSpace()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "ConvertTargetSpace", "(!Utils::ContainsNaN(WorldToSolver)) Invalid space transform provided");
}

uint64_t FIK::RTGameTask::GenerateVRTarget()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "GenerateVRTarget", "(!Utils::ContainsNaN(Target)) Invalid task target");
}

void FIK::RTGameTask::DoAlphaBlend()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "DoAlphaBlend", "(false) Unhandled target blend type was used.");
  __break(1u);
}

uint64_t FIK::Enrollment::FrameAdaptor::getRayDirectionForJoint()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "getRayDirectionForJoint", "(rayLength != 0) Ray length is equal to zero");
}

void FIK::Enrollment::SourceDefinition::cameraIndexForName()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "cameraNameToID", "(false) Unknown camera name passed to convertion method");
  __break(1u);
}

uint64_t FIK::Enrollment::DataPreprocessor::generateSolverSources()
{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "generateSolverSources", "(frameSet.version() == ApiVersion::v2) Unexpected API version");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "generateSolverSources", "(m_rigAtlasSourceIndex != kInvalidRigIndex) The head pose must be present as a source.");
}

{
  v0 = ikinemaLogObject();
  return ikinemaAssertHandler(*v0, 0, "generateSolverSources", "(headPose.has_value()) Unable to produce valid pose with missing head pose.");
}

void CoreIKConstraint::setTarget(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Can't set target on a constraint that does not constrain position or orientation", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setTargetTranslation(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Can't set position target on a constraint that does not constrain position", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setTargetOrientation(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Can't set orientation target on a constraint that does not constrain orientation", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getPositionEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setPositionEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getOrientationEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setOrientationEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getPositionAsPole(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setPositionAsPole(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getPositionDoFEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setPositionDoFEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getOrientationDoFEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setOrientationDoFEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getPositionDepth(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setPositionDepth(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getOrientationDepth(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setOrientationDepth(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getPositionWeight(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setPositionWeight(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getOrientationWeight(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setOrientationWeight(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getPositionPrecision(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setPositionPrecision(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::getOrientationPrecision(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKConstraint::setOrientationPrecision(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint has no task.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKFootPlacementSolverCreate_cold_1(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "CoreIKFootPlacementSolverCreate";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Incompatible/invalid rig instance used to create FootPlacementSolver.", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

void ikinema::loadRigFromString(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Trying to load a rig with invalid type.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void ikinema::loadRigFromString()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "loadRigFromString", "(false) We must have handled all rig errors by this point.");
  __break(1u);
}

void logRigFromStringError(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "logRigFromStringError";
  _os_log_fault_impl(&dword_245976000, log, OS_LOG_TYPE_FAULT, "%s: Loading a rig from string returned No such file error.", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

void logRigFromStringError(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Trying to load a rig from an empty string.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to parse a rig from string.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void ikinema::loadRigFromFile(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Unable to parse a rig from file contents.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Trying to load a rig from invalid file path.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Trying to load a rig from an empty file.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void ikinema::loadRigFromFile()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "logRigFromFileError", "(false) This function must not handle success.");
  __break(1u);
}

uint64_t CoreIKRig::createEmpty()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "createEmpty", "(result) Out-of-memory is a non-recoverable condition.");
}

uint64_t CoreIKRig::createFromJson()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "createFromJson", "(result) Out-of-memory is a non-recoverable condition.");
}

uint64_t CoreIKRig::createFromFile()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "createFromFile", "(result) Out-of-memory is a non-recoverable condition.");
}

uint64_t CoreIKRig::destroy()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "destroy", "(rig != nullptr) Can't destroy null object.");
}

void CoreIKRig::sourceJointCount()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "sourceJointCount", "(false) Unhandled rig type.");
  __break(1u);
}

void CoreIKRig::targetJointCount()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "targetJointCount", "(false) Unhandled rig type.");
  __break(1u);
}

void CoreIKRig::sourceJointName(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Invalid source joint index.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::sourceJointName()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "sourceJointName", "(false) Unhandled rig type.");
  __break(1u);
}

void CoreIKRig::targetJointName(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Invalid target joint index.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::targetJointName()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "targetJointName", "(false) Unhandled rig type");
  __break(1u);
}

void CoreIKRig::sourceJointParentName(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Invalid source joint index.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::sourceJointParentName()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "sourceJointParentName", "(false) Unhandled rig type.");
  __break(1u);
}

void CoreIKRig::targetJointParentName(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Invalid target joint index.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::targetJointParentName()
{
  v0 = ikinemaLogObject();
  ikinemaAssertHandler(*v0, 0, "targetJointParentName", "(false) Unhandled rig type.");
  __break(1u);
}

void CoreIKRig::getSourceTransform(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Rig must be of type kCoreIKSolverTypePoseRetarget", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::setSourceTransform(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Rig must be of type kCoreIKSolverTypePoseRetarget", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::getRigidBodySolve(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Rig must be of type kCoreIKSolverTypePoseRetarget", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::setRigidBodySolve(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Rig must be of type kCoreIKSolverTypePoseRetarget", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::getSourceScale(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Rig must be of type kCoreIKSolverTypePoseRetarget", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::setSourceScale(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Rig must be of type kCoreIKSolverTypePoseRetarget", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::updateConstraintWithSettings()
{
  v6 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0_0();
  OUTLINED_FUNCTION_2();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
  v5 = *MEMORY[0x277D85DE8];
}

void getMoCapTask<std::variant<FIK::GameRig,FIK::MoCapRig> const>(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Rig must be of type kCoreIKSolverTypePoseRetarget", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void getMoCapTask<std::variant<FIK::GameRig,FIK::MoCapRig> const>()
{
  v6 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0_0();
  OUTLINED_FUNCTION_2();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
  v5 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::removeConstraint()
{
  v6 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0_0();
  OUTLINED_FUNCTION_2();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
  v5 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::removeJoint(uint64_t a1, uint64_t a2)
{
  v9 = *MEMORY[0x277D85DE8];
  v2 = a1 + (a2 << 8);
  if (*(v2 + 16))
  {
    v3 = *(v2 + 8);
  }

  v7 = 136315394;
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_4(&dword_245976000, v4, v5, "%s: Cannot remove. Joint is not a leaf: %s", v7, v8);
  v6 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  v2 = a1 + 544 * a2;
  if (*(v2 + 16))
  {
    v3 = *(v2 + 8);
  }

  v7 = 136315394;
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_4(&dword_245976000, v4, v5, "%s: Cannot remove. Joint is not a leaf: %s", v7, v8);
  v6 = *MEMORY[0x277D85DE8];
}

void CoreIKRig::removeJoint()
{
  v6 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0_0();
  OUTLINED_FUNCTION_2();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
  v5 = *MEMORY[0x277D85DE8];
}

void getMoCapBone<std::variant<FIK::GameRig,FIK::MoCapRig> const>(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Rig must be of type kCoreIKSolverTypePoseRetarget", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void getMoCapBone<std::variant<FIK::GameRig,FIK::MoCapRig> const>()
{
  v6 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0_0();
  OUTLINED_FUNCTION_2();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
  v5 = *MEMORY[0x277D85DE8];
}

void validateRigHierarchy<FIK::GameRig>(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Multiple constraints have the same target.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIK::createSolverObject<CoreIK::IKSolverGeneric>(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: The requested solver type can't be created from this rig", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

uint64_t CoreIKConstraintGetName_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKConstraintGetName", "(constraint) A null constraint pointer was used.");
}

uint64_t CoreIKConstraintGetBoneName_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKConstraintGetBoneName", "(constraint) A null constraint pointer was used.");
}

uint64_t CoreIKConstraintGetOffset_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKConstraintGetOffset", "(constraint) A null constraint pointer was used.");
}

uint64_t CoreIKConstraintSetOffset_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKConstraintSetOffset", "(constraint) A null constraint pointer was used.");
}

uint64_t CoreIKGetConstraintTarget_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKGetConstraintTarget", "(constraint) A null constraint pointer was used.");
}

uint64_t CoreIKSetConstraintTarget_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKSetConstraintTarget", "(constraint) A null constraint pointer was used.");
}

uint64_t CoreIKSetConstraintTargetTranslation_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKSetConstraintTargetTranslation", "(constraint) A null constraint pointer was used.");
}

uint64_t CoreIKSetConstraintTargetOrientation_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKSetConstraintTargetOrientation", "(constraint) A null constraint pointer was used.");
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn200100]<std::__variant_detail::__visitation::__variant::__value_visitor<CoreIKRigConstraintPositionAsPoleEnabled::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,FIK::GameRig,std::__variant_detail::_Trait::MoCapRig> &>(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Constraint name not in rig", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKSolver::setInputScale(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "setInputScale";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Trying to set invalid input scale", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

void CoreIKSolver::setOutputScale(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "setOutputScale";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Trying to set invalid output scale", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

uint64_t CoreIKDestroyACPPenetrationSolver_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKDestroyACPPenetrationSolver", "(solver != nullptr) Can't destroy null object");
}

void CoreIKACPPenetrationSolverGetTargetRestPose_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: No target joint at input targetIndex in rig.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

uint64_t CoreIKDestroyACPFilteringSolver_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKDestroyACPFilteringSolver", "(solver != nullptr) Can't destroy null object");
}

uint64_t CoreIKDestroyACPSlidingSolver_cold_1()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "CoreIKDestroyACPSlidingSolver", "(solver != nullptr) Can't destroy null object");
}

void CoreIK::IKSolverGeneric::despatchGetConstraint(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: The solver does not contain a constraint with the given name", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

uint64_t CoreIK::IKSolverGeneric::despatchSolve()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "despatchSolve", "(sourcePose.size() == targetPoseLocal.size()) Generic solver expects same source and target sizes");
}

void CoreIKSolver::despatchSetInputScale(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Setting of input scale is not supported by this solver", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKSolver::despatchSetOutputScale(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Setting of output scale is not supported by this solver", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKSolver::despatchGetConstraintCount(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Getting constraint count is not supported by this solver", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKSolver::despatchGetTaskTargetsDebug(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Getting task targets is not supported by this solver", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

uint64_t ikinema::processedRigs::getBPERigObject(_BYTE *a1)
{
  v2 = ikinemaLogObject();
  result = ikinemaAssertHandler(*v2, 0, "getBPERigObject", "(rig && std::holds_alternative<FIK::MoCapRig>(rig.value())) Failed to load mocap rig");
  if ((*a1 & 1) == 0)
  {
    v4 = std::__throw_bad_optional_access[abi:nn200100]();
    return ikinema::processedRigs::getBPERigObject(v4);
  }

  return result;
}

void ikinema::processedRigs::getBPERigObject()
{
  v3 = *MEMORY[0x277D85DE8];
  v2[0] = 136315394;
  OUTLINED_FUNCTION_0_0();
  _os_log_error_impl(&dword_245976000, v0, OS_LOG_TYPE_ERROR, "%s: Unknown target joint %s", v2, 0x16u);
  v1 = *MEMORY[0x277D85DE8];
}

{
  v3 = *MEMORY[0x277D85DE8];
  v2[0] = 136315394;
  OUTLINED_FUNCTION_0_0();
  _os_log_error_impl(&dword_245976000, v0, OS_LOG_TYPE_ERROR, "%s: Unknown source joint %s", v2, 0x16u);
  v1 = *MEMORY[0x277D85DE8];
}

uint64_t anonymous namespace::getSourceIndex()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "getSourceIndex", "(ind != FIK::kInvalidRigIndex) Source does not exist in ARRigInputJoints");
}

uint64_t anonymous namespace::getSourceParent()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "getSourceParent", "(ind != FIK::kInvalidRigIndex) Source does not exist in ARRigInputJoints");
}

uint64_t anonymous namespace::getDistanceBetween()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "getDistanceBetween", "(baseInd != FIK::kInvalidRigIndex) Base must exist in ARRigOutputJoints");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "getDistanceBetween", "(tipInd != FIK::kInvalidRigIndex) Tip must exist in ARRigOutputJoints");
}

uint64_t anonymous namespace::getCumulativeBoneLengthBetween()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "getCumulativeBoneLengthBetween", "(baseInd != FIK::kInvalidRigIndex) Base must exist in ARRigOutputJoints");
}

{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "getCumulativeBoneLengthBetween", "(tipInd != FIK::kInvalidRigIndex) Tip must exist in ARRigOutputJoints");
}

void CoreIKACPSolver::despatchGetConstraint(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: The solver does not containt a constraint with the given name", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKACPPenetrationSolver::getConstraint(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: The solver does not contain a constraint with the given name", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: The solver does not contain a constraint with given index.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKSolverInsertAlgorithm_cold_1(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "CoreIKSolverInsertAlgorithm";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Can't add an algorithm to a non-composable solver", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

void CoreIKSolverRemoveAlgorithm_cold_1(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "CoreIKSolverRemoveAlgorithm";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Can't remove an algorithm from a non-composable solver", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

uint64_t ikinema::Buffer::arrayView<float const>()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "arrayView", "(m_descriptor.containsType<std::remove_cv_t<RequestedType>>()) Wrong type requested from buffer.");
}

void CoreIK::IKSolverRetarget::despatchGetConstraint(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "despatchGetConstraint";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: The solver does not contain a constraint with the given name", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

void CoreIKEnrollmentPoseSolveForDataWithHeadPoseV2_cold_1(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "solveForData";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Solving all frames at once is only allowed in debug builds.", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

void CoreIKEnrollmentPoseSolveForDataWithHeadPoseV3_cold_1(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "CoreIKEnrollmentPoseSolveForDataWithHeadPoseV3";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Enrollment Solve: Inputs do not contain all source and/or targets defined in the rig.", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

void CoreIKSolverAddAlgorithm_UseRotationFromSource_cold_1(os_log_t log)
{
  v4 = *MEMORY[0x277D85DE8];
  v2 = 136315138;
  v3 = "CoreIKSolverAddAlgorithm_UseRotationFromSource";
  _os_log_error_impl(&dword_245976000, log, OS_LOG_TYPE_ERROR, "%s: Can't add an algorithm to a non-composable solver", &v2, 0xCu);
  v1 = *MEMORY[0x277D85DE8];
}

void CoreIKGenericSolverCreate_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Incompatible/invalid rig instance used to create GenericSolver.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKGenericSolverSolve_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Incorrectly sized pose passed to the solve function.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKGenericSolverGetConstraintTargetName_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: No constraint at given constraintIndex", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKGenericSolverGetTargetRestPose_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: Input target index is out of bounds", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

void CoreIKGenericSolverGetConstraintIndex_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9 = *MEMORY[0x277D85DE8];
  OUTLINED_FUNCTION_0(&dword_245976000, a1, a3, "%s: No constraint for input target name in rig.", a5, a6, a7, a8, 2u);
  v8 = *MEMORY[0x277D85DE8];
}

uint64_t CoreIKSolver::destroy()
{
  v0 = *ikinemaLogObject();

  return ikinemaAssertHandler(v0, 0, "destroy", "(solver != nullptr) Can't destroy a null object");
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x2821F77A0]();
}

{
  return MEMORY[0x2821F77A8]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x2821F78F8]();
}

{
  return MEMORY[0x2821F7900]();
}

{
  return MEMORY[0x2821F7918]();
}

void operator delete(void *__p)
{
    ;
  }
}

void operator delete()
{
    ;
  }
}

void operator new()
{
    ;
  }
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x2822043C8](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}