const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(a1 + 16) == 17)
  {

    return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::operator=<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>(a2, a3);
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](a1);
    *a1 = *a3;
    *a3 = 0;
    *(a1 + 16) = 17;
  }

  return result;
}

const void **TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::operator=<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
    {
      CFRelease(v4);
    }

    *a1 = *a2;
    *a2 = 0;
  }

  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(a1 + 16) == 18)
  {

    return TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::operator=<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>(a2, a3);
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](a1);
    *a1 = *a3;
    *a3 = 0;
    *(a1 + 16) = 18;
  }

  return result;
}

const void **TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::operator=<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
    {
      CFRelease(v4);
    }

    *a1 = *a2;
    *a2 = 0;
  }

  return a1;
}

TReferenceCounted **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(uint64_t a1, TReferenceCounted **a2, TReferenceCounted **a3)
{
  if (*(a1 + 16) == 19)
  {

    return TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::operator=<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>(a2, a3);
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](a1);
    *a1 = *a3;
    *a3 = 0;
    *(a1 + 16) = 19;
  }

  return result;
}

TReferenceCounted **TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::operator=<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>(TReferenceCounted **a1, TReferenceCounted **a2)
{
  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
    {
      TReferenceCounted::RemovePtrReference(v4);
    }

    *a1 = *a2;
    *a2 = 0;
  }

  return a1;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *result, _BYTE *a2, _BYTE *a3)
{
  v4 = *result;
  if (*(*result + 16) == 1)
  {
    *a2 = *a3;
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*result);
    *v4 = *a3;
    *(v4 + 16) = 1;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *result, _BYTE *a2, _BYTE *a3)
{
  v4 = *result;
  if (*(*result + 16) == 2)
  {
    *a2 = *a3;
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*result);
    *v4 = *a3;
    *(v4 + 16) = 2;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *result, _WORD *a2, _WORD *a3)
{
  v4 = *result;
  if (*(*result + 16) == 3)
  {
    *a2 = *a3;
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*result);
    *v4 = *a3;
    *(v4 + 16) = 3;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *result, void *a2, void *a3)
{
  v4 = *result;
  if (*(*result + 16) == 5)
  {
    *a2 = *a3;
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*result);
    *v4 = *a3;
    *(v4 + 16) = 5;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *result, _DWORD *a2, _DWORD *a3)
{
  v4 = *result;
  if (*(*result + 16) == 6)
  {
    *a2 = *a3;
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*result);
    *v4 = *a3;
    v4[4] = 6;
  }

  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, void *a2, double *a3)
{
  v4 = *a1;
  if (*(*a1 + 16) == 7)
  {
    result = *a3;
    *a2 = *a3;
  }

  else
  {
    std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*a1);
    result = *a3;
    *v4 = *a3;
    *(v4 + 16) = 7;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *result, _DWORD *a2, _DWORD *a3)
{
  v4 = *result;
  if (*(*result + 16) == 8)
  {
    *a2 = *a3;
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*result);
    *v4 = *a3;
    v4[4] = 8;
  }

  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, __n128 *a2, __n128 *a3)
{
  v4 = *a1;
  if (*(*a1 + 16) == 9)
  {
    result = *a3;
    *a2 = *a3;
  }

  else
  {
    std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*a1);
    result = *a3;
    *v4 = *a3;
    *(v4 + 16) = 9;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm20ELm20EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *result, _DWORD *a2, _DWORD *a3)
{
  v4 = *result;
  if (*(*result + 16) == 20)
  {
    *a2 = *a3;
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*result);
    *v4 = *a3;
    v4[4] = 20;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm22ELm22EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *result, _DWORD *a2, _DWORD *a3)
{
  v4 = *result;
  if (*(*result + 16) == 22)
  {
    *a2 = *a3;
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*result);
    *v4 = *a3;
    v4[4] = 22;
  }

  return result;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm23ELm23EEE10__dispatchB8ne200100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne200100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *result, _DWORD *a2, _DWORD *a3)
{
  v4 = *result;
  if (*(*result + 16) == 23)
  {
    *a2 = *a3;
  }

  else
  {
    result = std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](*result);
    *v4 = *a3;
    v4[4] = 23;
  }

  return result;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<10ul,NSObject * {__strong},NSObject * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(a1 + 16) == 10)
  {
    v5 = *a3;

    objc_storeStrong(location, v5);
  }

  else
  {
    std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](a1);
    *a1 = *a3;
    *(a1 + 16) = 10;
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(a1 + 16) == 12)
  {
    v6 = *a3;

    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v6);
  }

  else
  {
    v8[2] = v3;
    v8[3] = v4;
    v8[0] = a1;
    v8[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(std::__variant_detail::__alt<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>> &,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&)::{unnamed type#1}::operator()(v8);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(std::__variant_detail::__alt<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>> &,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&)::{unnamed type#1}::operator()(uint64_t *a1)
{
  v2 = *a1;
  v1 = a1[1];
  v3 = *v1;
  if (*v1)
  {
    CFRetain(*v1);
  }

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](v2);
  *v2 = v3;
  v5 = 0;
  *(v2 + 16) = 12;
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v5);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(a1 + 16) == 13)
  {
    v6 = *a3;

    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v6);
  }

  else
  {
    v8[2] = v3;
    v8[3] = v4;
    v8[0] = a1;
    v8[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(std::__variant_detail::__alt<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>> &,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&)::{unnamed type#1}::operator()(v8);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(std::__variant_detail::__alt<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>> &,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&)::{unnamed type#1}::operator()(uint64_t *a1)
{
  v2 = *a1;
  v1 = a1[1];
  v3 = *v1;
  if (*v1)
  {
    CFRetain(*v1);
  }

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](v2);
  *v2 = v3;
  v5 = 0;
  *(v2 + 16) = 13;
  return TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TRef(&v5);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(a1 + 16) == 14)
  {
    v6 = *a3;

    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v6);
  }

  else
  {
    v8[2] = v3;
    v8[3] = v4;
    v8[0] = a1;
    v8[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(std::__variant_detail::__alt<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>> &,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&)::{unnamed type#1}::operator()(v8);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(std::__variant_detail::__alt<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>> &,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&)::{unnamed type#1}::operator()(uint64_t *a1)
{
  v2 = *a1;
  v1 = a1[1];
  v3 = *v1;
  if (*v1)
  {
    CFRetain(*v1);
  }

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](v2);
  *v2 = v3;
  v5 = 0;
  *(v2 + 16) = 14;
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v5);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(a1 + 16) == 15)
  {
    v6 = *a3;

    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v6);
  }

  else
  {
    v8[2] = v3;
    v8[3] = v4;
    v8[0] = a1;
    v8[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(std::__variant_detail::__alt<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>> &,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&)::{unnamed type#1}::operator()(v8);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(std::__variant_detail::__alt<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>> &,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&)::{unnamed type#1}::operator()(uint64_t *a1)
{
  v2 = *a1;
  v1 = a1[1];
  v3 = *v1;
  if (*v1)
  {
    CFRetain(*v1);
  }

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](v2);
  *v2 = v3;
  v5 = 0;
  *(v2 + 16) = 15;
  return TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(&v5);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(a1 + 16) == 16)
  {
    v6 = *a3;

    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v6);
  }

  else
  {
    v8[2] = v3;
    v8[3] = v4;
    v8[0] = a1;
    v8[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(std::__variant_detail::__alt<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>> &,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&)::{unnamed type#1}::operator()(v8);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(std::__variant_detail::__alt<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>> &,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&)::{unnamed type#1}::operator()(uint64_t *a1)
{
  v2 = *a1;
  v1 = a1[1];
  v3 = *v1;
  if (*v1)
  {
    CFRetain(*v1);
  }

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](v2);
  *v2 = v3;
  v5 = 0;
  *(v2 + 16) = 16;
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v5);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(a1 + 16) == 17)
  {
    v6 = *a3;

    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v6);
  }

  else
  {
    v8[2] = v3;
    v8[3] = v4;
    v8[0] = a1;
    v8[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(std::__variant_detail::__alt<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>> &,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&)::{unnamed type#1}::operator()(v8);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(std::__variant_detail::__alt<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>> &,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&)::{unnamed type#1}::operator()(uint64_t *a1)
{
  v2 = *a1;
  v1 = a1[1];
  v3 = *v1;
  if (*v1)
  {
    CFRetain(*v1);
  }

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](v2);
  *v2 = v3;
  v5 = 0;
  *(v2 + 16) = 17;
  return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(&v5);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(a1 + 16) == 18)
  {
    v6 = *a3;

    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v6);
  }

  else
  {
    v8[2] = v3;
    v8[3] = v4;
    v8[0] = a1;
    v8[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(std::__variant_detail::__alt<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>> &,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&)::{unnamed type#1}::operator()(v8);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne200100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(std::__variant_detail::__alt<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>> &,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&)::{unnamed type#1}::operator()(uint64_t *a1)
{
  v2 = *a1;
  v1 = a1[1];
  v3 = *v1;
  if (*v1)
  {
    CFRetain(*v1);
  }

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::__destroy[abi:ne200100](v2);
  *v2 = v3;
  v5 = 0;
  *(v2 + 16) = 18;
  return TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TRef(&v5);
}

uint64_t TPropertyValue::As<long long>(uint64_t result, uint64_t a2)
{
  v2 = *(result + 16);
  switch(v2)
  {
    case 0:
      if (v2)
      {
        goto LABEL_48;
      }

      return *a2;
    case 1:
      if (v2 != 1)
      {
        goto LABEL_48;
      }

      return *a2;
    case 2:
      if (v2 != 2)
      {
        goto LABEL_48;
      }

      return *a2;
    case 3:
      if (v2 != 3)
      {
        goto LABEL_48;
      }

      return *a2;
    case 4:
      if (v2 != 4)
      {
        goto LABEL_48;
      }

      return *result;
    case 5:
      if (v2 != 5)
      {
        goto LABEL_48;
      }

      return *result;
    case 6:
      if (v2 != 6)
      {
        goto LABEL_48;
      }

      return *a2;
    case 7:
      if (v2 != 7)
      {
        goto LABEL_48;
      }

      return *a2;
    case 8:
      if (v2 != 8)
      {
        goto LABEL_48;
      }

      return *a2;
    case 9:
      return *a2;
    case 10:
      if (v2 != 10)
      {
        goto LABEL_48;
      }

      return *a2;
    case 11:
      if (v2 != 11)
      {
        goto LABEL_48;
      }

      return *a2;
    case 12:
      if (v2 != 12)
      {
        goto LABEL_48;
      }

      return *a2;
    case 13:
      if (v2 != 13)
      {
        goto LABEL_48;
      }

      return *a2;
    case 14:
      if (v2 != 14)
      {
        goto LABEL_48;
      }

      return *a2;
    case 15:
      if (v2 != 15)
      {
        goto LABEL_48;
      }

      return *a2;
    case 16:
      if (v2 != 16)
      {
        goto LABEL_48;
      }

      return *a2;
    case 17:
      if (v2 != 17)
      {
        goto LABEL_48;
      }

      return *a2;
    case 18:
      if (v2 != 18)
      {
        goto LABEL_48;
      }

      return *a2;
    case 19:
      if (v2 == 19)
      {
        return *a2;
      }

      goto LABEL_48;
    case 20:
      if (v2 != 20)
      {
        goto LABEL_48;
      }

      return *a2;
    case 21:
      if (v2 != 21)
      {
        goto LABEL_48;
      }

      goto LABEL_47;
    case 22:
      if (v2 != 22)
      {
        goto LABEL_48;
      }

      goto LABEL_47;
    case 23:
      if (v2 != 23)
      {
LABEL_48:
        std::__throw_bad_variant_access[abi:ne200100]();
      }

LABEL_47:
      result = *result;
      break;
    default:
      return result;
  }

  return result;
}

unint64_t TPropertyValue::As<unsigned int>(unsigned int *a1, unsigned int *a2)
{
  v2 = a1[4];
  v3 = v2;
  switch(v2)
  {
    case 0:
      if (v2)
      {
        goto LABEL_36;
      }

      v3 = *a2;
      v4 = 0xFFFFE07800000000;
      return v4 | v3;
    case 1:
      if (v2 != 1)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 2:
      if (v2 != 2)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 3:
      if (v2 != 3)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 4:
      if (v2 == 4)
      {
        goto LABEL_29;
      }

      goto LABEL_36;
    case 5:
      if (v2 != 5)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 6:
      if (v2 != 6)
      {
        goto LABEL_36;
      }

      goto LABEL_27;
    case 7:
      if (v2 != 7)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 8:
      if (v2 != 8)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 9:
      goto LABEL_29;
    case 10:
      if (v2 != 10)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 11:
      if (v2 != 11)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 12:
      if (v2 != 12)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 13:
      if (v2 != 13)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 14:
      if (v2 != 14)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 15:
      if (v2 != 15)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 16:
      if (v2 != 16)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 17:
      if (v2 != 17)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 18:
      if (v2 != 18)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 19:
      if (v2 != 19)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 20:
      if (v2 != 20)
      {
        goto LABEL_36;
      }

LABEL_27:
      v4 = 0;
      v3 = *a1;
      break;
    case 21:
      if (v2 != 21)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 22:
      if (v2 != 22)
      {
        goto LABEL_36;
      }

      goto LABEL_29;
    case 23:
      if (v2 != 23)
      {
LABEL_36:
        std::__throw_bad_variant_access[abi:ne200100]();
      }

LABEL_29:
      v4 = 0xFFFFE08E00000000;
      v3 = *a2;
      break;
    default:
      v4 = 0xFFFFFFFF00000000;
      break;
  }

  return v4 | v3;
}

uint64_t *TPropertyValue::As<__CFURL const*>(uint64_t *result, uint64_t **a2)
{
  v2 = *(result + 4);
  switch(v2)
  {
    case 0:
      if (v2)
      {
        goto LABEL_9;
      }

      result = *a2;
      break;
    case 1:
      if (v2 != 1)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 2:
      if (v2 != 2)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 3:
      if (v2 != 3)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 4:
      if (v2 != 4)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 5:
      if (v2 != 5)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 6:
      if (v2 != 6)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 7:
      if (v2 != 7)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 8:
      if (v2 != 8)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 9:
      goto LABEL_7;
    case 10:
      if (v2 != 10)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 11:
      if (v2 != 11)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 12:
      if (v2 != 12)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 13:
      if (v2 != 13)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 14:
      if (v2 == 14)
      {
        goto LABEL_7;
      }

      goto LABEL_9;
    case 15:
      if (v2 != 15)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 16:
      if (v2 != 16)
      {
        goto LABEL_9;
      }

      result = *result;
      break;
    case 17:
      if (v2 != 17)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 18:
      if (v2 != 18)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 19:
      if (v2 != 19)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 20:
      if (v2 != 20)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 21:
      if (v2 != 21)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 22:
      if (v2 != 22)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    case 23:
      if (v2 != 23)
      {
LABEL_9:
        std::__throw_bad_variant_access[abi:ne200100]();
      }

LABEL_7:
      result = *a2;
      break;
    default:
      return result;
  }

  return result;
}

_BYTE *HexDescriptionPrinterGlue<char const*,void>::dump@<X0>(uint64_t a1@<X0>, void *a2@<X1>, _BYTE *a3@<X8>)
{
  v23[19] = *MEMORY[0x1E69E9840];
  v5 = *(a1 + 23);
  if ((v5 & 0x80u) != 0)
  {
    v5 = *(a1 + 8);
  }

  if (v5)
  {
    WidenHexFormatStringSpecifierToLongLong(a1, __p);
    if (v13 >= 0)
    {
      snprintf(__str, 0x64uLL, __p, *a2);
    }

    else
    {
      snprintf(__str, 0x64uLL, __p[0], *a2);
    }

    if (v13 < 0)
    {
      operator delete(__p[0]);
    }

    result = std::string::basic_string[abi:ne200100]<0>(a3, __str);
    goto LABEL_26;
  }

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne200100](__str);
  *(&v15 + *(v15 - 24) + 8) = *(&v15 + *(v15 - 24) + 8) & 0xFFFFFFB5 | 8;
  MEMORY[0x1E692CAE0](&v15, *a2);
  if ((v22 & 0x10) != 0)
  {
    v8 = v21;
    if (v21 < v18)
    {
      v21 = v18;
      v8 = v18;
    }

    locale = v17[4].__locale_;
    goto LABEL_17;
  }

  if ((v22 & 8) != 0)
  {
    locale = v17[1].__locale_;
    v8 = v17[3].__locale_;
LABEL_17:
    v7 = v8 - locale;
    if ((v8 - locale) >= 0x7FFFFFFFFFFFFFF8)
    {
      std::string::__throw_length_error[abi:ne200100]();
    }

    if (v7 >= 0x17)
    {
      operator new();
    }

    a3[23] = v7;
    if (v7)
    {
      memmove(a3, locale, v7);
    }

    goto LABEL_23;
  }

  v7 = 0;
  a3[23] = 0;
LABEL_23:
  a3[v7] = 0;
  *__str = *MEMORY[0x1E69E54D8];
  v10 = *(MEMORY[0x1E69E54D8] + 72);
  *&__str[*(*__str - 24)] = *(MEMORY[0x1E69E54D8] + 64);
  v15 = v10;
  v16 = MEMORY[0x1E69E5548] + 16;
  if (v20 < 0)
  {
    operator delete(v19);
  }

  v16 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v17);
  std::iostream::~basic_iostream();
  result = MEMORY[0x1E692CCA0](v23);
LABEL_26:
  v11 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1E56EE3BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(&a13, MEMORY[0x1E69E54D8]);
  MEMORY[0x1E692CCA0](&a29);
  _Unwind_Resume(a1);
}

void std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::operator()(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a2 = *a3;
  v3 = *(a2 + 8);
  if (v3)
  {
    MEMORY[0x1E692CD10](v3, 0x1000C8077774924);
  }

  operator new[]();
}

uint64_t std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__value_func<void ()(Blob &,unsigned int)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

const void **ShortDescription<TString>@<X0>(TString **a1@<X0>, _BYTE *a2@<X8>)
{
  v5.fString.fRef = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable(&v5, *a1);
  TString::Str(&v5, a2);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v5.fString.fRef);
}

void sub_1E56EE5FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va);
  _Unwind_Resume(a1);
}

void sub_1E56EEB1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  v10 = v9;

  a9.super_class = FINode_ICloudAppLibrary;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1E56EF0B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va);

  _Unwind_Resume(a1);
}

void sub_1E56EF2C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, id);
  v8 = va_arg(va1, id);
  v9 = va_arg(va1, void);
  TNodeEventPtr::~TNodeEventPtr(va);
  TNodeEventPtr::~TNodeEventPtr((v4 + 8));

  TNodeEventPtr::~TNodeEventPtr(va1);
  _Unwind_Resume(a1);
}

void sub_1E56EFCB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, const void *a11, void *a12, uint64_t a13, id location, uint64_t a15, uint64_t a16, id a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28)
{
  TKeyValueObserver::~TKeyValueObserver(&a20);
  objc_destroyWeak((v31 + 8));

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a11);
  objc_destroyWeak((v30 + 8));

  objc_destroyWeak(&location);
  objc_destroyWeak(&a17);

  _Unwind_Resume(a1);
}

void AddProgressObserver(void *a1, uint64_t *a2, uint64_t a3)
{
  v20 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v7 = *a2;
    ;
  }

  a2[1] = v7;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v8 = [&unk_1F5F4A418 countByEnumeratingWithState:&v14 objects:v19 count:16];
  if (v8)
  {
    v9 = *v15;
    do
    {
      v10 = 0;
      do
      {
        if (*v15 != v9)
        {
          objc_enumerationMutation(&unk_1F5F4A418);
        }

        v11 = *(*(&v14 + 1) + 8 * v10);
        v13.fString.fRef = &stru_1F5F42870;
        CFRetain(&stru_1F5F42870);
        TString::SetStringRefAsImmutable(&v13, v11);

        std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100](v18, a3);
        TKeyValueObserver::StartObserving<std::function<void ()(void)>>(a2, v5, &v13, v18, 0);
        std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](v18);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v13.fString.fRef);
        ++v10;
      }

      while (v8 != v10);
      v8 = [&unk_1F5F4A418 countByEnumeratingWithState:&v14 objects:v19 count:16];
    }

    while (v8);
  }

  v12 = *MEMORY[0x1E69E9840];
}

void sub_1E56F02E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, id a24)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((v27 + 40));
  objc_destroyWeak((v28 + 32));
  [DSFileProgress progressChanged:]::$_3::~$_3(&location);

  [DSFileProgress progressChanged:]::$_3::~$_3(&a24);
  objc_destroyWeak((v29 - 112));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((v29 - 104));

  _Unwind_Resume(a1);
}

void OperationTypeFromProgress(NSDictionary *a1@<X0>, TString *a2@<X8>)
{
  v3 = [(NSDictionary *)a1 objectForKeyedSubscript:*MEMORY[0x1E696A858]];
  v4 = objc_cast<NSString,objc_object * {__strong}>(v3);
  theString = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable(&theString, v4);

  if (CFStringGetLength(theString))
  {
    if (operator==(&theString, *MEMORY[0x1E696A840]))
    {
      a2->fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      TString::SetStringRefAsImmutable(a2, @"CopyOperationType");
LABEL_6:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&theString);
      return;
    }

    if (operator==(&theString, *MEMORY[0x1E696A830]))
    {
      a2->fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      TString::SetStringRefAsImmutable(a2, @"AirdropOperationType");
      goto LABEL_6;
    }
  }

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&theString);
  a2->fString.fRef = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable(a2, @"CopyOperationType");
}

void sub_1E56F0548(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va);
  _Unwind_Resume(a1);
}

id TProgressMap::GetProgressDispatchQueue(TProgressMap *this)
{
  if (TProgressMap::GetProgressDispatchQueue(void)::once != -1)
  {
    TProgressMap::GetProgressDispatchQueue();
  }

  v2 = TProgressMap::GetProgressDispatchQueue(void)::progressQueue;

  return v2;
}

__n128 __copy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__3(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((a1 + 32), (a2 + 32));
  *(a1 + 40) = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable((a1 + 40), *(a2 + 40));
  *(a1 + 48) = *(a2 + 48);
  result = *(a2 + 56);
  *(a1 + 56) = result;
  return result;
}

void sub_1E56F077C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  objc_destroyWeak((v1 + 32));
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__3(uint64_t a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((a1 + 40));

  objc_destroyWeak((a1 + 32));
}

id TProgressInfo::CreateProgressDictionary(TProgressInfo *this)
{
  v45 = *MEMORY[0x1E69E9840];
  v29[0] = @"InlineState";
  v28 = [MEMORY[0x1E696AD98] numberWithUnsignedInt:*(this + 17)];
  v30 = v28;
  v29[1] = @"InlinePercentageDone";
  LODWORD(v2) = *(this + 4);
  v31 = [MEMORY[0x1E696AD98] numberWithFloat:v2];
  v29[2] = @"InlineTimeEstimate";
  LODWORD(v3) = *(this + 18);
  v27 = v31;
  v32 = [MEMORY[0x1E696AD98] numberWithFloat:v3];
  v29[3] = @"TotalSize";
  v26 = v32;
  v25 = [MEMORY[0x1E696AD98] numberWithLongLong:*this];
  v33 = v25;
  v29[4] = @"CompletedSize";
  v4 = [MEMORY[0x1E696AD98] numberWithLongLong:*(this + 1)];
  v34 = v4;
  v29[5] = @"DownloadPercentageDone";
  LODWORD(v5) = *(this + 10);
  v6 = [MEMORY[0x1E696AD98] numberWithFloat:v5];
  v35 = v6;
  v29[6] = @"DownloadTotalSize";
  v7 = [MEMORY[0x1E696AD98] numberWithLongLong:*(this + 3)];
  v36 = v7;
  v29[7] = @"DownloadCompletedSize";
  v8 = [MEMORY[0x1E696AD98] numberWithLongLong:*(this + 4)];
  v37 = v8;
  v29[8] = @"UploadPercentageDone";
  LODWORD(v9) = *(this + 16);
  v10 = [MEMORY[0x1E696AD98] numberWithFloat:v9];
  v38 = v10;
  v29[9] = @"UploadTotalSize";
  v11 = [MEMORY[0x1E696AD98] numberWithLongLong:*(this + 6)];
  v39 = v11;
  v29[10] = @"UploadCompletedSize";
  v12 = [MEMORY[0x1E696AD98] numberWithLongLong:*(this + 7)];
  v13 = v12;
  if (*(this + 76))
  {
    v14 = MEMORY[0x1E695E118];
  }

  else
  {
    v14 = MEMORY[0x1E695E110];
  }

  v40 = v12;
  v41 = v14;
  v29[11] = @"InlineCanCancel";
  v29[12] = @"InlineCanPause";
  if (*(this + 77))
  {
    v15 = MEMORY[0x1E695E118];
  }

  else
  {
    v15 = MEMORY[0x1E695E110];
  }

  if (*(this + 78))
  {
    v16 = MEMORY[0x1E695E118];
  }

  else
  {
    v16 = MEMORY[0x1E695E110];
  }

  v42 = v15;
  v43 = v16;
  v29[13] = @"UserDownload";
  v29[14] = @"InlineOperationType";
  v17 = *(this + 10);
  v44 = v17;
  v18 = [MEMORY[0x1E695DF20] dictionaryWithObjects:&v30 forKeys:v29 count:15];

  v19 = *(this + 14);
  if (v19 && (v20 = v19, v21 = [v18 mutableCopy], objc_msgSend(v21, "setObject:forKeyedSubscript:", v20, @"InlineImage"), v20, v21))
  {
    v22 = [v21 copy];
  }

  else
  {
    v22 = v18;
    v21 = 0;
  }

  v23 = *MEMORY[0x1E69E9840];
  return v22;
}

void TProgressMap::NormalizedPathForPath(TString **this@<X0>, TString *a2@<X8>)
{
  a2->fString.fRef = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable(a2, *this);
}

BOOL TProgressMap::HasProgress(TProgressMap *this, const __CFURL *a2)
{
  TCFURLInfo::FileSystemRepresentation(this, 1, &v7);
  TProgressMap::NormalizedPathForPath(&v7, &cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&v7.fString.fRef, &cf);
  CFRetain(&stru_1F5F42870);
  if (cf)
  {
    CFRelease(cf);
  }

  cf = &stru_1F5F42870;
  v2 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  v3 = TProgressMap::ProgressLock(v2);
  os_unfair_lock_lock(v3);
  v4 = TProgressMap::gProgressMap && *(TProgressMap::gProgressMap + 24) && std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, &v7) != 0;
  os_unfair_lock_unlock(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v7.fString.fRef);
  return v4;
}

void sub_1E56F0DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  os_unfair_lock_unlock(v10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

int *TProgressMap::ProgressLock(TProgressMap *this)
{
  {
    TProgressMap::ProgressLock();
  }

  return &TProgressMap::ProgressLock(void)::gProgressLock;
}

uint64_t TProgressMap::GetProgress(TProgressMap *this, const TNodePtr *a2, TProgressInfo *a3)
{
  v5 = TProgressMap::ProgressLock(this);
  os_unfair_lock_lock(v5);
  if (TProgressMap::gProgressMap && *(TProgressMap::gProgressMap + 24))
  {
    theString = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
    ProgressPathForNode(this, &cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&theString, &cf);
    CFRetain(&stru_1F5F42870);
    if (cf)
    {
      CFRelease(cf);
    }

    cf = &stru_1F5F42870;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    Length = CFStringGetLength(theString);
    v7 = Length != 0;
    if (!Length)
    {
      goto LABEL_14;
    }

    v8 = std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, &theString);
    v9 = v8;
    if (v8)
    {
      *&a2->fFINode = *(v8 + 3);
      v10 = *(v8 + 5);
      v11 = *(v8 + 7);
      v12 = *(v8 + 9);
      *(&a2[7].fFINode + 7) = *(v8 + 87);
      *&a2[4].fFINode = v11;
      *&a2[6].fFINode = v12;
      *&a2[2].fFINode = v10;
      if (v8 + 3 != a2)
      {
        TString::SetStringRefAsImmutable(&a2[10], v8[13]);
      }

      v14 = v9[14];
      v13 = v9[15];
      if (v13)
      {
        atomic_fetch_add_explicit(v13 + 1, 1uLL, memory_order_relaxed);
      }

      fFINode = a2[12].fFINode;
      a2[11].fFINode = v14;
      a2[12].fFINode = v13;
      if (fFINode)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](fFINode);
      }

      objc_storeStrong(&a2[13].fFINode, v9[16]);
      objc_storeStrong(&a2[14].fFINode, v9[17]);
LABEL_14:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&theString);
      os_unfair_lock_unlock(v5);
      return v7;
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&theString);
  }

  os_unfair_lock_unlock(v5);
  v16 = TNodeFromFINode(*this);
  v17 = TNode::InfoLock(v16);
  os_unfair_lock_lock(v17);
  v19 = *(v16 + 16);
  v18 = *(v16 + 24);
  if (v18)
  {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  os_unfair_lock_unlock(v17);
  os_unfair_lock_lock((v19 + 108));
  v20 = *(v19 + 127);
  os_unfair_lock_unlock((v19 + 108));
  if ((v20 & 0x100) != 0)
  {
    os_unfair_lock_lock((v19 + 104));
    v21 = *(v19 + 80);
    if (v21)
    {
      os_unfair_lock_lock((v21 + 72));
      v22 = *(v21 + 48);
      os_unfair_lock_unlock((v21 + 72));
      v23 = v22;
    }

    else
    {
      v23 = 0.0;
    }

    os_unfair_lock_unlock((v19 + 104));
    if (v23 >= 100.0)
    {
      v24 = 0;
    }

    else
    {
      v24 = 3;
    }

    if (v23 <= 0.0)
    {
      v24 = 2;
    }

    *&a2[2].fFINode = v23;
    HIDWORD(a2[8].fFINode) = v24;
    LODWORD(a2[9].fFINode) = 0;
    v25 = a2[12].fFINode;
    a2[11].fFINode = 0;
    a2[12].fFINode = 0;
    if (v25)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v25);
    }

    a2->fFINode = 0;
    a2[1].fFINode = 0;
    WORD2(a2[9].fFINode) = 0;
    v27 = a2[10].fFINode;
    v26 = &a2[10];
    if (v27 != @"CopyOperationType")
    {
      TString::SetStringRefAsImmutable(v26, @"CopyOperationType");
    }
  }

  v7 = (v20 >> 8) & 1;
  if (v18)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v18);
  }

  return v7;
}

void sub_1E56F10D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v10);
  }

  _Unwind_Resume(exception_object);
}

void TProgressMap::KeyForMatchingProgressObject(TProgressMap *this@<X0>, TString *a2@<X8>)
{
  v12 = *MEMORY[0x1E69E9840];
  v4 = this;
  v5 = v4;
  if (v4 && TProgressMap::gProgressMap && (fRef = *(TProgressMap::gProgressMap + 16)) != 0)
  {
    while (fRef[16].fString.fRef != v4)
    {
      fRef = fRef->fString.fRef;
      if (!fRef)
      {
        goto LABEL_6;
      }
    }

    v8 = LogObj(5);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = SanitizedPath(fRef + 2);
      v10 = 138543362;
      v11 = v9;
      _os_log_impl(&dword_1E5674000, v8, OS_LOG_TYPE_INFO, "Found path matching progress object %{public}@", &v10, 0xCu);
    }

    a2->fString.fRef = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
    TString::SetStringRefAsImmutable(a2, fRef[2].fString.fRef);
  }

  else
  {
LABEL_6:
    a2->fString.fRef = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
  }

  v7 = *MEMORY[0x1E69E9840];
}

const void **TProgressMap::UpdateExternalProgress(TNodePtr *this, const TNodePtr *a2, const TProgressInfo *a3)
{
  v51 = *MEMORY[0x1E69E9840];
  v5 = HIDWORD(a2[8].fFINode) == 0;
  ProgressPathForNode(this, buf);
  TProgressMap::NormalizedPathForPath(buf, &theString);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(buf);
  if (!CFStringGetLength(theString))
  {
    v6 = LogObj(5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = TNodeFromFINode(this->fFINode);
      if (v7)
      {
        v8 = TNodeFromFINode(this->fFINode);
        v9 = TNode::InfoLock(v8);
        os_unfair_lock_lock(v9);
        v11 = *(v8 + 16);
        v10 = *(v8 + 24);
        if (v10)
        {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        os_unfair_lock_unlock(v9);
        TFSInfo::Name(v11, &v46);
        if (v10)
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](v10);
        }

        v12 = SanitizedStr(&v46);
      }

      else
      {
        v12 = @"nil node";
      }

      v13 = TNodeFromFINode(this->fFINode);
      v15 = TNode::Validate(v13, v14);
      *buf = 138543618;
      *&buf[4] = v12;
      v49 = 1024;
      v50 = v15;
      _os_log_impl(&dword_1E5674000, v6, OS_LOG_TYPE_INFO, "No path found for progress %{public}@ valid=%d", buf, 0x12u);
      if (v7)
      {

        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v46.fString.fRef);
      }
    }

    v17 = TProgressMap::ProgressLock(v16);
    os_unfair_lock_lock(v17);
    TProgressMap::KeyForMatchingProgressObject(a2[13].fFINode, buf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&theString, buf);
    CFRetain(&stru_1F5F42870);
    if (*buf)
    {
      CFRelease(*buf);
    }

    *buf = &stru_1F5F42870;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(buf);
    os_unfair_lock_unlock(v17);
    v5 = 0;
  }

  Length = CFStringGetLength(theString);
  if (Length)
  {
    v19 = TProgressMap::ProgressLock(Length);
    os_unfair_lock_lock(v19);
    if (!TProgressMap::gProgressMap)
    {
      os_unfair_lock_unlock(v19);
      goto LABEL_68;
    }

    v20 = std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, &theString);
    v21 = v20;
    if (v5)
    {
      if (v20)
      {
LABEL_26:
        fFINode_high = HIDWORD(a2[8].fFINode);
        if (fFINode_high)
        {
          v24 = *(v21 + 23);
          v25 = v24 != fFINode_high;
          if (v24 != fFINode_high)
          {
            *(v21 + 23) = fFINode_high;
          }

          v26 = *&a2[2].fFINode;
          if (*(v21 + 10) != v26)
          {
            *(v21 + 10) = v26;
            v25 = 1;
          }

          v27 = *&a2[9].fFINode;
          if (*(v21 + 24) != v27)
          {
            *(v21 + 24) = v27;
            v25 = 1;
          }

          v28 = BYTE5(a2[9].fFINode);
          if (*(v21 + 101) != v28)
          {
            *(v21 + 101) = v28;
            v25 = 1;
          }

          v29 = BYTE4(a2[9].fFINode);
          if (*(v21 + 100) != v29)
          {
            *(v21 + 100) = v29;
            v25 = 1;
          }

          if (v21[3] != a2->fFINode)
          {
            v21[3] = a2->fFINode;
            v25 = 1;
          }

          fFINode = a2[1].fFINode;
          if (v21[4] != fFINode)
          {
            v21[4] = fFINode;
            v25 = 1;
          }

          v31 = a2[3].fFINode;
          if (v21[6] != v31)
          {
            v21[6] = v31;
            v25 = 1;
          }

          v32 = a2[4].fFINode;
          if (v21[7] != v32)
          {
            v21[7] = v32;
            v25 = 1;
          }

          v33 = *&a2[5].fFINode;
          if (*(v21 + 16) != v33)
          {
            *(v21 + 16) = v33;
            v25 = 1;
          }

          v34 = a2[6].fFINode;
          if (v21[9] != v34)
          {
            v21[9] = v34;
            v25 = 1;
          }

          v35 = a2[7].fFINode;
          if (v21[10] != v35)
          {
            v21[10] = v35;
            v25 = 1;
          }

          v36 = *&a2[8].fFINode;
          if (*(v21 + 22) != v36)
          {
            *(v21 + 22) = v36;
            v25 = 1;
          }

          v38 = v21[13];
          v37 = (v21 + 13);
          v39 = &a2[10];
          v40 = v25;
          if (CFEqual(v38, a2[10].fFINode))
          {
            goto LABEL_60;
          }

          if (v37 != v39)
          {
            TString::SetStringRefAsImmutable(v37, *v39);
          }
        }

        else
        {
          std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::erase(TProgressMap::gProgressMap, v21);
        }

        v25 = 1;
LABEL_59:
        v40 = 1;
LABEL_60:
        os_unfair_lock_unlock(v19);
        if (TNodeFromFINode(this->fFINode))
        {
          if (v40)
          {
            TProgressMap::PostProgressChange(&this->fFINode, v41);
          }

          if (HIDWORD(a2[8].fFINode))
          {
            v42 = 0;
          }

          else
          {
            v42 = v25;
          }

          if (v42)
          {
            v43 = TNodeFromFINode(this->fFINode);
            TNode::HandleSync(v43, 268959744);
          }
        }

        goto LABEL_68;
      }

      v22 = a2[13].fFINode;
      if (!v22)
      {
LABEL_56:
        v25 = 0;
        goto LABEL_59;
      }

      TProgressMap::KeyForMatchingProgressObject(v22, buf);
      if (CFStringGetLength(*buf))
      {
        TString::SetStringRefAsImmutable(&theString, *buf);
        v21 = std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, &theString);
      }

      else
      {
        v21 = 0;
      }

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(buf);
    }

    if (v21)
    {
      goto LABEL_26;
    }

    goto LABEL_56;
  }

LABEL_68:
  result = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&theString);
  v45 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1E56F16D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va1);
  os_unfair_lock_unlock(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va);
  _Unwind_Resume(a1);
}

void TProgressMap::PostProgressChange(FINode **this, const TNodePtr *a2)
{
  if (TNodeFromFINode(*this))
  {
    v3 = TNodeFromFINode(*this);
    v4 = TNode::InfoLock(v3);
    os_unfair_lock_lock(v4);
    v6 = *(v3 + 16);
    v5 = *(v3 + 24);
    if (v5)
    {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    os_unfair_lock_unlock(v4);
    os_unfair_lock_lock((v6 + 108));
    v7 = *(v6 + 123);
    os_unfair_lock_unlock((v6 + 108));
    if (v5)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v5);
    }

    if ((v7 & 0x20) == 0)
    {
      v8 = TNodeFromFINode(*this);
      TNode::UpdatePropertySynchronous(v8, 1819240307, 0);
    }

    v9 = TNodeFromFINode(*this);

    TNode::SendNotification(v9, 2, this, 1768845426, 0);
  }
}

void TProgressMap::AddExternalProgress(TProgressMap *this, const TNodePtr *a2, TNodePtr *a3, NSDictionary *a4)
{
  v6 = this;
  v7 = a3;
  if (TNodeFromFINode(a2->fFINode))
  {
    ProgressPathForNode(a2, &v29);
    if (CFStringGetLength(v29.fString.fRef))
    {
      v8 = [(TNodePtr *)v7 objectForKeyedSubscript:*MEMORY[0x1E696A800]];
      v9 = static_cf_cast<__CFString const*,void const*>(v8);

      valuePtr = 0.0;
      if (v9)
      {
        CFNumberGetValue(v9, kCFNumberDoubleType, &valuePtr);
      }

      [(TNodePtr *)v7 objectForKey:*MEMORY[0x1E696A828]];
      objc_claimAutoreleasedReturnValue();
      v14 = 0;
      v15 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      *&v24[3] = 0;
      v25 = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      v26 = 0u;
      v27 = 0u;
      v23 = TProgressInfo::ProgressStateFromProgress(v6, v10);
      [(TProgressMap *)v6 fractionCompleted];
      *&v11 = v11 * 100.0;
      v12 = valuePtr;
      v16 = LODWORD(v11);
      *v24 = v12;
      OperationTypeFromProgress(v7, &cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&v25, &cf);
      CFRetain(&stru_1F5F42870);
      if (cf)
      {
        CFRelease(cf);
      }

      cf = &stru_1F5F42870;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      v14 = [(TProgressMap *)v6 totalUnitCount];
      v15 = [(TProgressMap *)v6 completedUnitCount];
      v24[5] = [(TProgressMap *)v6 isPausable];
      v24[4] = [(TProgressMap *)v6 isCancellable];
      operator new();
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v29.fString.fRef);
  }
}

void sub_1E56F1B18(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((v3 - 72));

  _Unwind_Resume(a1);
}

uint64_t TProgressInfo::ProgressStateFromProgress(TProgressInfo *this, NSProgress *a2)
{
  v2 = this;
  if (([(TProgressInfo *)v2 isFinished]& 1) != 0 || ([(TProgressInfo *)v2 isCancelled]& 1) != 0)
  {
    v3 = 0;
  }

  else if ([(TProgressInfo *)v2 isIndeterminate])
  {
    v3 = 2;
  }

  else
  {
    v3 = 3;
  }

  return v3;
}

const void **TProgressMap::AddProgressForPath(TProgressMap *this, TString **a2, const TString *a3)
{
  TProgressMap::NormalizedPathForPath(a2, &v13);
  v5 = TProgressMap::ProgressLock(v4);
  os_unfair_lock_lock(v5);
  if (!TProgressMap::gProgressMap)
  {
    operator new();
  }

  if (!std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, &v13))
  {
    v6 = TProgressMap::gProgressMap;
    std::pair<TString,TProgressInfo>::pair[abi:ne200100]<true,0>(v8, &v13, this);
    std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::__emplace_unique_key_args<TString,std::pair<TString,TProgressInfo>>(v6, v8);

    if (v10)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v10);
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v9);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v8[0].fString.fRef);
  }

  os_unfair_lock_unlock(v5);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v13.fString.fRef);
}

void sub_1E56F1CD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::pair<TString,TProgressInfo>::~pair(va);
  os_unfair_lock_unlock(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((v3 - 40));
  _Unwind_Resume(a1);
}

void TProgressInfo::~TProgressInfo(TProgressInfo *this)
{
  v2 = *(this + 12);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(this + 10);
}

void ___ZN12TProgressMap24GetProgressDispatchQueueEv_block_invoke()
{
  v0 = dispatch_queue_create("TProgressMap", 0);
  v1 = TProgressMap::GetProgressDispatchQueue(void)::progressQueue;
  TProgressMap::GetProgressDispatchQueue(void)::progressQueue = v0;
}

void TProgressMap::CancelProgress(TProgressMap *this, const TNodePtr *a2)
{
  v4 = TProgressMap::ProgressLock(this);
  os_unfair_lock_lock(v4);
  if (TProgressMap::gProgressMap)
  {
    ProgressPathForNode(this, &v9);
    v5 = std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, &v9);
    v6 = v5;
    if (v5)
    {
      v8 = v5[14];
      v7 = v5[15];
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }

    else
    {
      v7 = 0;
      v8 = 0;
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v9.fString.fRef);
    os_unfair_lock_unlock(v4);
    if (v6 && v8)
    {
      (**v8)(v8, a2);
    }

    if (v7)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v7);
    }
  }

  else
  {

    os_unfair_lock_unlock(v4);
  }
}

void sub_1E56F1EAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v10);
  }

  _Unwind_Resume(exception_object);
}

void TKeyValueObserver::StartObserving<std::function<void ()(void)>>(uint64_t a1, void *a2, const TString *a3, uint64_t a4, uint64_t a5)
{
  v13 = *MEMORY[0x1E69E9840];
  v9 = a2;
  TKeyValueObserver::TKeyValueObserver(v11);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100](v12, a4);
  TKeyValueObserver::StartObserving<std::function<void ()(void)>>(v11, v9, a3, v12, a5);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](v12);
  std::vector<TKeyValueObserver>::push_back[abi:ne200100](a1, v11);
  TKeyValueObserver::~TKeyValueObserver(v11);

  v10 = *MEMORY[0x1E69E9840];
}

void sub_1E56F1FA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](&a14);
  TKeyValueObserver::~TKeyValueObserver(&a9);

  _Unwind_Resume(a1);
}

id ___ZN12TProgressMap32AddSubscriberForExternalProgressERK8TNodePtr_block_invoke(uint64_t a1, void *a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v2 = a2;
  v3 = [v2 kind];
  v4 = [v3 isEqualToString:*MEMORY[0x1E696A888]];

  if (v4)
  {
    v5 = [v2 userInfo];
    v6 = *MEMORY[0x1E696A880];
    v7 = [v5 objectForKeyedSubscript:*MEMORY[0x1E696A880]];
    v8 = static_objc_cast<NSString,objc_object * {__strong}>(v7);

    if (!v8)
    {

      goto LABEL_8;
    }

    HasProgress = TProgressMap::HasProgress(v8, v9);

    if (!HasProgress)
    {
LABEL_8:
      v12 = [v2 userInfo];
      MutableCopyDeep(v12);
      objc_claimAutoreleasedReturnValue();

      v13 = LogObj(5);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        v14 = [v2 userInfo];
        v15 = [v14 objectForKeyedSubscript:v6];
        v16 = static_objc_cast<NSString,objc_object * {__strong}>(v15);
        v17 = SanitizedURL(v16);
        v18 = [v2 userInfo];
        *buf = 138543874;
        *&buf[4] = v17;
        *&buf[12] = 2112;
        *&buf[14] = v2;
        *&buf[22] = 2112;
        v22 = v18;
        _os_log_impl(&dword_1E5674000, v13, OS_LOG_TYPE_INFO, "StartExternalProgress for url %{public}@ %@ %@", buf, 0x20u);
      }

      operator new();
    }
  }

  else
  {
  }

  *buf = MEMORY[0x1E69E9820];
  *&buf[8] = 3321888768;
  *&buf[16] = ___ZL21StartExternalProgressP10NSProgress_block_invoke;
  v22 = &__block_descriptor_33_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__0_e5_v8__0l;
  v11 = [buf copy];

  v19 = *MEMORY[0x1E69E9840];

  return v11;
}

void sub_1E56F2444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  v16 = v12;

  _Unwind_Resume(a1);
}

void TKeyValueObserver::~TKeyValueObserver(TKeyValueObserver *this)
{
  TKeyValueObserver::StopObserving(this);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(this + 4);
}

const void **___ZZ34__DSFileProgress_progressChanged__ENK3__2cvU13block_pointerFvvEEv_block_invoke(uint64_t a1)
{
  v10[0].fFINode = 0;
  v10[1].fFINode = 0;
  v11 = 0;
  v12 = 0uLL;
  v13 = 0;
  v14 = 0uLL;
  memset(v15, 0, 15);
  v16.fString.fRef = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  v17 = 0u;
  *v18 = 0u;
  HIDWORD(v15[0]) = TProgressInfo::ProgressStateFromProgress(*(a1 + 48), v2);
  [*(a1 + 48) fractionCompleted];
  *&v3 = v3 * 100.0;
  v4 = *(a1 + 64);
  v11 = LODWORD(v3);
  *&v15[1] = v4;
  BYTE5(v15[1]) = [*(a1 + 48) isPausable];
  BYTE4(v15[1]) = [*(a1 + 48) isCancellable];
  v10[0].fFINode = [*(a1 + 48) totalUnitCount];
  v10[1].fFINode = [*(a1 + 48) completedUnitCount];
  BYTE4(v15[1]) = [*(a1 + 48) isCancellable];
  if (&v16 != (a1 + 40))
  {
    TString::SetStringRefAsImmutable(&v16, *(a1 + 40));
  }

  objc_storeStrong(v18, *(a1 + 48));
  if (operator==((a1 + 40), @"UbiquityOperationType"))
  {
    if (*(a1 + 56) == 1)
    {
      v12 = *&v10[0].fFINode;
      v13 = v11;
    }

    if (*(a1 + 57) == 1)
    {
      v14 = *&v10[0].fFINode;
      LODWORD(v15[0]) = v11;
    }
  }

  WeakRetained = objc_loadWeakRetained((a1 + 32));
  v6 = TNodeFromFINode(WeakRetained);
  TNodePtr::TNodePtr(&v9, v6);
  TProgressMap::UpdateExternalProgress(&v9, v10, v7);

  if (*(&v17 + 1))
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](*(&v17 + 1));
  }

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v16.fString.fRef);
}

void sub_1E56F271C(_Unwind_Exception *a1, uint64_t a2, void *a3, ...)
{
  va_start(va, a3);

  TProgressInfo::~TProgressInfo(va);
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__2(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((a1 + 32), (a2 + 32));
  *(a1 + 40) = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable((a1 + 40), *(a2 + 40));
  *(a1 + 48) = *(a2 + 48);
  result = *(a2 + 56);
  *(a1 + 56) = result;
  return result;
}

void sub_1E56F27B8(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  objc_destroyWeak((v1 + 32));
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__2(uint64_t a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((a1 + 40));

  objc_destroyWeak((a1 + 32));
}

void std::vector<TKeyValueObserver>::__destroy_vector::operator()[abi:ne200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
      {
        TKeyValueObserver::~TKeyValueObserver((v4 - 40));
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

uint64_t std::pair<TString,TProgressInfo>::pair[abi:ne200100]<true,0>(uint64_t a1, TString **a2, __int128 *a3)
{
  *a1 = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable(a1, *a2);
  v6 = a3[2];
  v7 = a3[3];
  v8 = *(a3 + 63);
  v10 = *a3;
  v9 = a3[1];
  *(a1 + 88) = &stru_1F5F42870;
  *(a1 + 71) = v8;
  *(a1 + 40) = v6;
  *(a1 + 56) = v7;
  *(a1 + 8) = v10;
  *(a1 + 24) = v9;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable((a1 + 88), *(a3 + 10));
  v11 = *(a3 + 12);
  *(a1 + 96) = *(a3 + 11);
  *(a1 + 104) = v11;
  if (v11)
  {
    atomic_fetch_add_explicit((v11 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 112) = *(a3 + 13);
  *(a1 + 120) = *(a3 + 14);
  return a1;
}

void sub_1E56F295C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **std::pair<TString,TProgressInfo>::~pair(uint64_t a1)
{
  v2 = *(a1 + 104);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((a1 + 88));

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a1);
}

void ___ZL21StartExternalProgressP10NSProgress_block_invoke_44(uint64_t a1)
{
  v2 = [*(a1 + 32) userInfo];
  v3 = [v2 objectForKeyedSubscript:*MEMORY[0x1E696A880]];
  v4 = static_objc_cast<NSString,objc_object * {__strong}>(v3);

  NodeForURL(v4, &v26);
  v5 = TNodeFromFINode(v26.super.isa);
  v6 = FINodeFromTNode(v5);
  [*(a1 + 40) setProgressNode:v6];

  **(a1 + 56) = TNodeFromFINode(v26.super.isa) != 0;
  v7 = UseFileProviderFramework();
  v8 = *(a1 + 56);
  if (v7 && *v8 == 1)
  {
    v9 = [*(a1 + 32) userInfo];
    v10 = [v9 objectForKeyedSubscript:*MEMORY[0x1E696A858]];
    v11 = objc_cast<NSString,objc_object * {__strong}>(v10);
    block[0].fString.fRef = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
    TString::SetStringRefAsImmutable(block, v11);

    if ((operator==(&block[0].fString.fRef, *MEMORY[0x1E696A870]) & 1) != 0 || operator==(&block[0].fString.fRef, *MEMORY[0x1E696A848]))
    {
      v12 = [*(a1 + 32) userInfo];
      v13 = [v12 objectForKeyedSubscript:*MEMORY[0x1E696A820]];
      if (v13)
      {
      }

      else
      {
        v14 = TNodeFromFINode(v26.super.isa);
        IsLockFile = TNode::LowLevelIsLockFile(v14);

        if (IsLockFile)
        {
          **(a1 + 56) = 0;
        }
      }
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&block[0].fString.fRef);
    v8 = *(a1 + 56);
  }

  if (*v8 == 1)
  {
    Main = CFRunLoopGetMain();
    v17 = *MEMORY[0x1E695E8D0];
    block[0].fString.fRef = MEMORY[0x1E69E9820];
    block[1].fString.fRef = 3321888768;
    block[2].fString.fRef = ___ZZL21StartExternalProgressP10NSProgressENK3__1clEv_block_invoke;
    block[3].fString.fRef = &__block_descriptor_48_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__1clEvEUlvE__e5_v8__0l;
    v18 = *(a1 + 32);
    v19 = *(a1 + 40);
    v24 = v18;
    v20 = v19;
    v25 = v20;
    v21 = v18;
    CFRunLoopPerformBlock(Main, v17, block);

    TProgressMap::AddExternalProgress(*(a1 + 32), &v26, *(a1 + 48), v22);
  }
}

void sub_1E56F2C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id a16)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__1(void *a1, uint64_t a2)
{
  a1[4] = *(a2 + 32);
  a1[5] = *(a2 + 40);
  result = *(a2 + 48);
  v6 = *(a2 + 56);
  v5 = *(a2 + 64);
  a1[6] = result;
  a1[7] = v6;
  a1[8] = v5;
  if (v5)
  {
    atomic_fetch_add_explicit((v5 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void __destroy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__1(uint64_t a1)
{
  v2 = *(a1 + 64);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  v3 = *(a1 + 32);
}

uint64_t StartExternalProgress(NSProgress *)::$_1::~$_1(uint64_t a1)
{
  v2 = *(a1 + 32);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  return a1;
}

uint64_t StartExternalProgress(NSProgress *)::$_2::~$_2(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  return a1;
}

void NodeForURL(const __CFURL *a1@<X0>, TNodePtr *a2@<X8>)
{
  v3 = 0;
  v4 = a1;
  if (TNode::GetNodeFromURL(&v4, &v3, 0))
  {
    TNodePtr::TNodePtr(a2, 0);
  }

  else
  {
    a2->fFINode = v3;
  }
}

uint64_t ___ZZL21StartExternalProgressP10NSProgressENK3__1clEv_block_invoke(uint64_t a1)
{
  [*(a1 + 40) startObserving:*(a1 + 32)];
  v2 = *(a1 + 32);

  return [v2 acknowledgeWithSuccess:1];
}

id __copy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__1clEvEUlvE_(uint64_t a1, uint64_t a2)
{
  *(a1 + 32) = *(a2 + 32);
  result = *(a2 + 40);
  *(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__1clEvEUlvE_(uint64_t a1)
{
  v2 = *(a1 + 32);
}

void ___ZZL21StartExternalProgressP10NSProgressENK3__2cvU13block_pointerFvvEEv_block_invoke(uint64_t a1)
{
  v2 = TProgressMap::GetProgressDispatchQueue(a1);
  block[0] = MEMORY[0x1E69E9820];
  block[1] = 3321888768;
  block[2] = ___ZZL21StartExternalProgressP10NSProgressENK3__2clEv_block_invoke;
  block[3] = &__block_descriptor_64_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__2clEvEUlvE__e5_v8__0l;
  v3 = *(a1 + 32);
  v4 = *(a1 + 40);
  v5 = *(a1 + 48);
  v10 = v5;
  v6 = *(a1 + 56);
  if (*(&v5 + 1))
  {
    atomic_fetch_add_explicit((*(&v5 + 1) + 8), 1uLL, memory_order_relaxed);
  }

  v7 = v3;
  v8 = v4;
  *&v9 = v7;
  *(&v9 + 1) = v8;
  v12 = v9;
  v13 = v10;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    dispatch_async(v2, block);
    std::__shared_weak_count::__release_shared[abi:ne200100](v6);
  }

  else
  {
    dispatch_async(v2, block);
  }

  if (*(&v13 + 1))
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](*(&v13 + 1));
  }
}

id __copy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__2(void *a1, uint64_t a2)
{
  a1[4] = *(a2 + 32);
  result = *(a2 + 40);
  v6 = *(a2 + 48);
  v5 = *(a2 + 56);
  a1[5] = result;
  a1[6] = v6;
  a1[7] = v5;
  if (v5)
  {
    atomic_fetch_add_explicit((v5 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void __destroy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__2(uint64_t a1)
{
  v2 = *(a1 + 56);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  v3 = *(a1 + 32);
}

void ___ZZL21StartExternalProgressP10NSProgressENK3__2clEv_block_invoke(uint64_t a1)
{
  v33 = *MEMORY[0x1E69E9840];
  if (**(a1 + 48) == 1)
  {
    v2 = *(a1 + 32);
    v1 = *(a1 + 40);
    v3 = v2;
    v4 = v1;
    v5 = LogObj(5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      v6 = [v3 userInfo];
      v7 = [v6 objectForKeyedSubscript:*MEMORY[0x1E696A880]];
      v8 = static_objc_cast<NSString,objc_object * {__strong}>(v7);
      v9 = SanitizedURL(v8);
      v10 = [v3 userInfo];
      *buf = 138543874;
      *&buf[4] = v9;
      *&buf[12] = 2112;
      *&buf[14] = v3;
      *&buf[22] = 2112;
      v24 = v10;
      _os_log_impl(&dword_1E5674000, v5, OS_LOG_TYPE_INFO, "EndExternalProgress for url %{public}@ %@ %@", buf, 0x20u);
    }

    v11 = [v3 kind];
    v12 = IsEqual(v11, *MEMORY[0x1E696A888]);

    if (v12)
    {
      v13 = [v3 userInfo];
      v14 = v13 == 0;

      if (!v14)
      {
        *buf = 0;
        *&buf[8] = 0;
        v24 = 0;
        v25 = 0;
        v26 = 0;
        v27 = 0;
        v28 = 0;
        memset(v29, 0, 15);
        v30 = &stru_1F5F42870;
        CFRetain(&stru_1F5F42870);
        v32 = 0u;
        v31 = 0u;
        *&buf[16] = 1120403456;
        *(v29 + 4) = 0;
        BYTE5(v29[1]) = [v3 isPausable];
        BYTE4(v29[1]) = [v3 isCancellable];
        objc_storeStrong(&v32, v2);
        v15 = [v4 progressNode];
        v16 = TNodeFromFINode(v15);
        TNodePtr::TNodePtr(&v22, v16);
        TProgressMap::UpdateExternalProgress(&v22, buf, v17);

        if (*(&v31 + 1))
        {
          std::__shared_weak_count::__release_shared[abi:ne200100](*(&v31 + 1));
        }

        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v30);
      }
    }

    Main = CFRunLoopGetMain();
    v19 = *MEMORY[0x1E695E8D0];
    *buf = MEMORY[0x1E69E9820];
    *&buf[8] = 3321888768;
    *&buf[16] = ___ZL19EndExternalProgressP10NSProgressP14DSFileProgress_block_invoke;
    v24 = &__block_descriptor_40_ea8_32c63_ZTSKZL19EndExternalProgressP10NSProgressP14DSFileProgressE3__0_e5_v8__0l;
    v20 = v4;
    v25 = v20;
    CFRunLoopPerformBlock(Main, v19, buf);
  }

  v21 = *MEMORY[0x1E69E9840];
}

void sub_1E56F347C(_Unwind_Exception *a1, uint64_t a2, void *a3, ...)
{
  va_start(va, a3);

  TProgressInfo::~TProgressInfo(va);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__2clEvEUlvE_(void *a1, uint64_t a2)
{
  a1[4] = *(a2 + 32);
  result = *(a2 + 40);
  v6 = *(a2 + 48);
  v5 = *(a2 + 56);
  a1[5] = result;
  a1[6] = v6;
  a1[7] = v5;
  if (v5)
  {
    atomic_fetch_add_explicit((v5 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void __destroy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__2clEvEUlvE_(uint64_t a1)
{
  v2 = *(a1 + 56);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  v3 = *(a1 + 32);
}

id __copy_helper_block_ea8_32c63_ZTSKZL19EndExternalProgressP10NSProgressP14DSFileProgressE3__0(uint64_t a1, uint64_t a2)
{
  result = *(a2 + 32);
  *(a1 + 32) = result;
  return result;
}

uint64_t std::__function::__value_func<void ()(void)>::~__value_func[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t std::vector<TKeyValueObserver>::push_back[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 8);
  if (v3 >= *(a1 + 16))
  {
    result = std::vector<TKeyValueObserver>::__emplace_back_slow_path<TKeyValueObserver>(a1, a2);
  }

  else
  {
    result = TKeyValueObserver::TKeyValueObserver(v3, a2) + 40;
  }

  *(a1 + 8) = result;
  return result;
}

void TKeyValueObserver::TKeyValueObserver(TKeyValueObserver *this)
{
  *this = 0u;
  *(this + 1) = 0u;
  *(this + 4) = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
}

void sub_1E56F3D68(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

id objc_cast<NSURL,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v2 = a1;
  }

  else
  {
    v2 = 0;
  }

  return v2;
}

uint64_t std::unordered_set<NSObject *>::unordered_set(uint64_t a1, id *a2, uint64_t a3)
{
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *(a1 + 36) = 1065353216;
  if (a3)
  {
    v5 = 8 * a3;
    do
    {
      std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__emplace_unique_key_args<std::hash,NSObject * const&>(a1, a2++);
      v5 -= 8;
    }

    while (v5);
  }

  return a1;
}

uint64_t **std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__emplace_unique_key_args<std::hash,NSObject * const&>(void *a1, id *a2)
{
  v4 = [*a2 hash];
  v5 = v4;
  v6 = a1[1];
  if (!*&v6)
  {
    goto LABEL_18;
  }

  v7 = vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v6)
    {
      v9 = v4 % *&v6;
    }
  }

  else
  {
    v9 = (*&v6 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= *&v6)
      {
        v12 %= *&v6;
      }
    }

    else
    {
      v12 &= *&v6 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_18;
    }

LABEL_17:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_18;
    }
  }

  if ((std::equal_to<NSObject * {__strong}>::operator()((a1 + 5), v11[2], *a2) & 1) == 0)
  {
    goto LABEL_17;
  }

  return v11;
}

uint64_t std::equal_to<NSObject * {__strong}>::operator()(uint64_t a1, void *a2, void *a3)
{
  v4 = a2;
  v5 = a3;
  if (v4 == v5)
  {
    v6 = 1;
  }

  else
  {
    v6 = [v4 isEqual:v5];
  }

  return v6;
}

uint64_t std::vector<TKeyValueObserver>::__emplace_back_slow_path<TKeyValueObserver>(uint64_t a1, uint64_t a2)
{
  v2 = 0xCCCCCCCCCCCCCCCDLL * ((*(a1 + 8) - *a1) >> 3);
  v3 = v2 + 1;
  if (v2 + 1 > 0x666666666666666)
  {
    std::vector<std::pair<TNodePtr,TNodePtr>>::__throw_length_error[abi:ne200100]();
  }

  if (0x999999999999999ALL * ((*(a1 + 16) - *a1) >> 3) > v3)
  {
    v3 = 0x999999999999999ALL * ((*(a1 + 16) - *a1) >> 3);
  }

  if (0xCCCCCCCCCCCCCCCDLL * ((*(a1 + 16) - *a1) >> 3) >= 0x333333333333333)
  {
    v6 = 0x666666666666666;
  }

  else
  {
    v6 = v3;
  }

  v16 = a1;
  if (v6)
  {
    std::allocator<TKeyValueObserver>::allocate_at_least[abi:ne200100](a1, v6);
  }

  v13 = 0;
  v14 = 40 * v2;
  TKeyValueObserver::TKeyValueObserver(40 * v2, a2);
  v15 = 40 * v2 + 40;
  v7 = *(a1 + 8);
  v8 = 40 * v2 + *a1 - v7;
  std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<TKeyValueObserver>,TKeyValueObserver*>(a1, *a1, v7, v8);
  v9 = *a1;
  *a1 = v8;
  v10 = *(a1 + 16);
  v12 = v15;
  *(a1 + 8) = v15;
  *&v15 = v9;
  *(&v15 + 1) = v10;
  v13 = v9;
  v14 = v9;
  std::__split_buffer<TKeyValueObserver>::~__split_buffer(&v13);
  return v12;
}

void sub_1E56F42F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<TKeyValueObserver>::~__split_buffer(va);
  _Unwind_Resume(a1);
}

void std::allocator<TKeyValueObserver>::allocate_at_least[abi:ne200100](uint64_t a1, unint64_t a2)
{
  if (a2 < 0x666666666666667)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:ne200100]();
}

void std::__uninitialized_allocator_relocate[abi:ne200100]<std::allocator<TKeyValueObserver>,TKeyValueObserver*>(uint64_t a1, TKeyValueObserver *a2, TKeyValueObserver *a3, uint64_t a4)
{
  if (a2 != a3)
  {
    v6 = a2;
    v7 = a2;
    do
    {
      v8 = TKeyValueObserver::TKeyValueObserver(a4, v7);
      v7 = (v7 + 40);
      a4 = v8 + 40;
    }

    while (v7 != a3);
    while (v6 != a3)
    {
      TKeyValueObserver::~TKeyValueObserver(v6);
      v6 = (v6 + 40);
    }
  }
}

uint64_t std::__split_buffer<TKeyValueObserver>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 40;
    TKeyValueObserver::~TKeyValueObserver((i - 40));
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::erase(void *a1, uint64_t *a2)
{
  v2 = *a2;
  std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::remove(a1, a2, &v5);
  v3 = v5;
  v5 = 0;
  if (v3)
  {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TProgressInfo>,void *>>>::operator()[abi:ne200100](&v6, v3);
  }

  return v2;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TProgressInfo>,void *>>>::operator()[abi:ne200100](uint64_t a1, uint64_t a2)
{
  if (*(a1 + 8) == 1)
  {

    v3 = *(a2 + 120);
    if (v3)
    {
      std::__shared_weak_count::__release_shared[abi:ne200100](v3);
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((a2 + 104));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((a2 + 16));
  }

  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void std::__shared_ptr_emplace<TExternalOperationCanceller>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F5F3DD70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E692CD30);
}

uint64_t TExternalOperationCanceller::CancelTaskForProgress(id *this)
{
  if ([this[1] isCancellable])
  {
    [this[1] cancel];
  }

  return 1;
}

void *TExternalOperationCanceller::TaskIsPausable(TExternalOperationCanceller *this)
{
  result = *(this + 1);
  if (result)
  {
    return [result isPausable];
  }

  return result;
}

void TExternalOperationCanceller::~TExternalOperationCanceller(id *this)
{
}

{

  JUMPOUT(0x1E692CD30);
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::__emplace_unique_key_args<TString,std::pair<TString,TProgressInfo>>(void *a1, TString *this)
{
  v4 = FowlerNollVoHash::hash(this, this);
  v5 = v4;
  v6 = a1[1];
  if (!*&v6)
  {
    goto LABEL_18;
  }

  v7 = vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v6)
    {
      v9 = v4 % *&v6;
    }
  }

  else
  {
    v9 = (*&v6 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_18:
    std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::__construct_node_hash<std::pair<TString,TProgressInfo>>();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= *&v6)
      {
        v12 %= *&v6;
      }
    }

    else
    {
      v12 &= *&v6 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_18;
    }

LABEL_17:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_18;
    }
  }

  if (!CFEqual(v11[2], this->fString.fRef))
  {
    goto LABEL_17;
  }

  return v11;
}

void sub_1E56F48A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a10)
  {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TProgressInfo>,void *>>>::operator()[abi:ne200100](&a11, a10);
  }

  _Unwind_Resume(exception_object);
}

void TKeyValueObserver::StartObserving<std::function<void ()(void)>>(TKeyValueObserver *a1, void *a2, const TString *a3, uint64_t a4, uint64_t a5)
{
  v14 = *MEMORY[0x1E69E9840];
  v9 = a2;
  v12 = v9;
  std::unordered_set<NSObject *>::unordered_set(v13, &v12, 1);
  v10 = TKeyValueObserver::CreateObserver(a1, a4, v13, a3);
  std::__hash_table<std::__hash_value_type<unsigned long long,TRecordProgress>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,TRecordProgress>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,TRecordProgress>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,TRecordProgress>>>::~__hash_table(v13);
  TKeyValueObserver::StartObservingPriv(a1, v10, v9, a3, a5);

  v11 = *MEMORY[0x1E69E9840];
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:ne200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

void TBusyFolders::StopObserving(TBusyFolders *this)
{
  block[0] = MEMORY[0x1E69E9820];
  block[1] = 3321888768;
  block[2] = ___ZN12TBusyFolders13StopObservingEv_block_invoke;
  block[3] = &__block_descriptor_40_ea8_32c43_ZTSKZN12TBusyFolders13StopObservingEvE3__0_e5_v8__0l;
  block[4] = this;
  dispatch_async(gSystemNotificationStreamGCDQueue, block);
}

void TSystemNotificationTask::FinalizeSystemNotificationTask(TSystemNotificationTask *this)
{
  std::mutex::lock(&gBusyFoldersLock);
  v1 = TSystemNotificationTask::gSystemNotificationTask;
  if (TSystemNotificationTask::gSystemNotificationTask)
  {
    TBusyFolders::StopObserving(TSystemNotificationTask::gBusyFolders);
    MEMORY[0x1E692CD30](v1, 0xC400A2AC0F1);
  }

  TSystemNotificationTask::gSystemNotificationTask = 0;

  std::mutex::unlock(&gBusyFoldersLock);
}

const void **TSystemNotificationTask::HandleFSEvent(const void **this, const char **a2, int *a3, const unsigned int *a4)
{
  if (this)
  {
    v6 = this;
    v7 = *MEMORY[0x1E695E480];
    do
    {
      v9 = *a3++;
      v8 = v9;
      if (v9 != 64)
      {
        TString::TString(&v15, *a2);
        TString::TString(&cf, "/private/var/tmp/com.apple.chrono/");
        v10 = TString::BeginsWith(&v15, &cf);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
        if (!v10)
        {
          TString::TString(&cf, "/");
          v11 = TString::EndsWith(&v15, &cf);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
          if (!v11)
          {
            fRef = v15.fString.fRef;
            cf = &stru_1F5F42870;
            CFRetain(&stru_1F5F42870);
            MutableCopy = CFStringCreateMutableCopy(v7, 0, fRef);
            CFRelease(&stru_1F5F42870);
            cf = MutableCopy;
            TString::Append(&cf, "/");
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&v15.fString.fRef, &cf);
            CFRetain(&stru_1F5F42870);
            if (cf)
            {
              CFRelease(cf);
            }

            cf = &stru_1F5F42870;
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
          }

          TNode::HandleChange(&v15, (4 * v8) & 0x200 | (((v8 & 0xF) != 0) << 24));
        }

        this = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v15.fString.fRef);
      }

      ++a2;
      v6 = (v6 - 1);
    }

    while (v6);
  }

  return this;
}

void sub_1E56F4DA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

const void **TSystemNotificationTask::StopObservingDirectory(TString **this, const TString *a2)
{
  v2 = a2;
  TString::TString(&v7, "/");
  if (TString::EndsWith(this, &v7))
  {
    v8.fString.fRef = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
    TString::SetStringRefAsImmutable(&v8, *this);
  }

  else
  {
    v4 = *this;
    v8.fString.fRef = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
    MutableCopy = CFStringCreateMutableCopy(*MEMORY[0x1E695E480], 0, v4);
    CFRelease(&stru_1F5F42870);
    v8.fString.fRef = MutableCopy;
    TString::Append(&v8, "/");
  }

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v7.fString.fRef);
  std::mutex::lock(&gBusyFoldersLock);
  TBusyFolders::StopObservingDirectory(TSystemNotificationTask::gBusyFolders, &v8, v2);
  std::mutex::unlock(&gBusyFoldersLock);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v8.fString.fRef);
}

void sub_1E56F4F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

const void **TBusyFolders::StopObservingDirectory(TBusyFolders *this, const TString *a2, char a3)
{
  v6 = gSystemNotificationStreamGCDQueue;
  block[0] = MEMORY[0x1E69E9820];
  block[1] = 3321888768;
  block[2] = ___ZN12TBusyFolders22StopObservingDirectoryERK7TStringb_block_invoke;
  block[3] = &__block_descriptor_56_ea8_32c62_ZTSKZN12TBusyFolders22StopObservingDirectoryERK7TStringbE3__0_e5_v8__0l;
  v8 = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable(&v8, a2->fString.fRef);
  v9 = a3;
  block[4] = this;
  v11.fString.fRef = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable(&v11, v8);
  v12 = v9;
  dispatch_async(v6, block);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v8);

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v11.fString.fRef);
}

void sub_1E56F5050(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((v2 + 40));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((v3 + 8));

  _Unwind_Resume(a1);
}

const void **TSystemNotificationTask::ObservedDirectoryMoved(TString **this, TString **a2, const TString *a3)
{
  TSystemNotificationTask::StartObservingDirectory(a2, a3);

  return TSystemNotificationTask::StopObservingDirectory(this, a3);
}

void CloseFSEventStream(__FSEventStream *a1)
{
  v6 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v2 = LogObj(5);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v4 = 134217984;
      v5 = a1;
      _os_log_impl(&dword_1E5674000, v2, OS_LOG_TYPE_DEFAULT, "Closing FSEvent Stream %p", &v4, 0xCu);
    }

    FSEventStreamStop(a1);
    FSEventStreamInvalidate(a1);
    FSEventStreamRelease(a1);
  }

  v3 = *MEMORY[0x1E69E9840];
}

void ___ZN12TBusyFolders13StopObservingEv_block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  std::mutex::lock(&gBusyFoldersLock);
  v2 = *(v1 + 48);
  if (v2)
  {
    notify_cancel(v2);
  }

  *(v1 + 48) = 0;
  dispatch_assert_queue_V2(gSystemNotificationStreamGCDQueue);
  CloseFSEventStream(*(v1 + 40));
  dispatch_assert_queue_V2(gSystemNotificationStreamGCDQueue);
  *(v1 + 40) = 0;

  std::mutex::unlock(&gBusyFoldersLock);
}

void ___ZN12TBusyFolders22StopObservingDirectoryERK7TStringb_block_invoke(uint64_t a1)
{
  v2 = *(a1 + 32);
  std::mutex::lock(&gBusyFoldersLock);
  v3 = (v2 + 16);
  while (1)
  {
    v3 = *v3;
    if (!v3)
    {
      break;
    }

    if (*(v3 + 36) == 1)
    {
      v4 = *(a1 + 48);
    }

    else
    {
      v4 = 0;
    }

    if (CheckInterestedInPath((a1 + 40), v3 + 2, v4 & 1))
    {
      v5 = *(v3 + 8);
      v6 = __OFSUB__(v5, 1);
      v7 = v5 - 1;
      if (v7 < 0 == v6)
      {
        *(v3 + 8) = v7;
        if (!v7)
        {
          v8 = v3[3];
          v3[3] = 0;
          CloseFSEventStream(v8);
        }
      }

      break;
    }
  }

  std::mutex::unlock(&gBusyFoldersLock);
}

void __copy_helper_block_ea8_32c62_ZTSKZN12TBusyFolders22StopObservingDirectoryERK7TStringbE3__0(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 32);
  *(a1 + 40) = &stru_1F5F42870;
  *(a1 + 32) = v4;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable((a1 + 40), *(a2 + 40));
  *(a1 + 48) = *(a2 + 48);
}

uint64_t std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__deallocate_node(a1, *(a1 + 16));
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    operator delete(v2);
  }

  return a1;
}

void std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__deallocate_node(uint64_t a1, const void **a2)
{
  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = *v2;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2 + 2);
      operator delete(v2);
      v2 = v3;
    }

    while (v3);
  }
}

void make_ref<__CFArray const*,NSArray * {__strong},void>(void *a1@<X0>, void *a2@<X8>)
{
  v4 = a1;
  v3 = static_cf_cast<__CFString const*,void const*>(v4);
  *a2 = v3;
  if (v3)
  {
    CFRetain(v3);
  }
}

const __CFURL *Hash(const void *a1)
{
  v25[2] = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v2 = cf_cast<__CFURL const*,void const*>(a1);
    if (!v2)
    {
      goto LABEL_15;
    }

    v3 = v2;
    error = 0;
    {
      v16 = TString::operator NSString *(MEMORY[0x1E695EAB8]);
      v25[0] = v16;
      v17 = TString::operator NSString *(MEMORY[0x1E695E2B0]);
      v25[1] = v17;
      v18 = [MEMORY[0x1E695DEC8] arrayWithObjects:v25 count:2];
      make_ref<__CFArray const*,NSArray * {__strong},void>(v18, &Hash(void const*)::keys);
    }

    v4 = CFURLCopyResourcePropertiesForKeys(v3, Hash(void const*)::keys, &error);
    theDict = v4;
    if (!v4 || ((Value = CFDictionaryGetValue(v4, *MEMORY[0x1E695EAB8]), v6 = CFDictionaryGetValue(theDict, *MEMORY[0x1E695E2B0]), v7 = v6, Value) ? (v8 = v6 == 0) : (v8 = 1), v8))
    {
      v9 = LogObj(5);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        v10 = v3;
        v3 = SanitizedURL(v10);
        v11 = error;
        *buf = 138543618;
        v22 = v3;
        v23 = 2114;
        v24 = v11;
        _os_log_impl(&dword_1E5674000, v9, OS_LOG_TYPE_ERROR, "Failed to get file resource ID & file ID for URL: %{public}@. error: %{public}@", buf, 0x16u);
      }

      v13 = 1;
    }

    else
    {
      v12 = CFHash(Value);
      v13 = 0;
      v3 = (CFHash(v7) ^ v12);
    }

    TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(&theDict);
    TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(&error);
    if (v13)
    {
LABEL_15:
      v3 = CFHash(a1);
    }
  }

  else
  {
    v3 = 0;
  }

  v14 = *MEMORY[0x1E69E9840];
  return v3;
}

void sub_1E56F568C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(va);
  _Unwind_Resume(a1);
}

void SetWrappedURL(void *a1, const char *a2, uint64_t *a3, int a4)
{
  xdict = a1;
  if (*(a3 + 23) >= 0)
  {
    v7 = a3;
  }

  else
  {
    v7 = *a3;
  }

  v8 = [MEMORY[0x1E695DFF8] fileURLWithFileSystemRepresentation:v7 isDirectory:0 relativeToURL:0];
  v9 = [objc_opt_class() wrapperWithURL:v8 readonly:a4 ^ 1u error:0];
  v10 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v9 requiringSecureCoding:1 error:0];
  v11 = v10;
  if (a2[23] < 0)
  {
    a2 = *a2;
  }

  xpc_dictionary_set_data(xdict, a2, [v10 bytes], objc_msgSend(v10, "length"));
}

void sub_1E56F58DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::mutex::unlock((v10 + 16));

  _Unwind_Resume(a1);
}

void TDSHelperContext::HandleHelperEvent(void *a1, void *a2)
{
  xdict = a2;
  if (MEMORY[0x1E692DC20]() == MEMORY[0x1E69E9E98])
  {
    v3 = xdict;
    if (xdict == MEMORY[0x1E69E9E20])
    {
      v4 = a1[19];
      a1[19] = 0;

      v3 = xdict;
    }

    TDSHelperContext::ReplyReceived(a1, v3);
  }

  else if (xpc_dictionary_get_string(xdict, "request") && a1[19])
  {
    (*(*a1 + 16))(a1);
  }
}

void TDSHelperContext::TDSHelperContext(uint64_t a1)
{
  *a1 = &unk_1F5F3DF00;
  *(a1 + 8) = 850045863;
  *(a1 + 16) = 0u;
  *(a1 + 32) = 0u;
  *(a1 + 48) = 0u;
  *(a1 + 64) = 0;
  *(a1 + 72) = 1018212795;
  *(a1 + 80) = 0u;
  *(a1 + 96) = 0u;
  *(a1 + 112) = 0;
  operator new();
}

void sub_1E56F5B78(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);

  TConditionVariable::~TConditionVariable(v3);
  std::mutex::~mutex(v1);
  _Unwind_Resume(a1);
}

void TDSHelperContext::~TDSHelperContext(TDSHelperContext *this)
{
  *this = &unk_1F5F3DF00;
  TDSHelperContext::Disconnect(this);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(this + 20);
  v2 = *(this + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  std::condition_variable::~condition_variable((this + 72));
  std::mutex::~mutex((this + 8));
}

{
  TDSHelperContext::~TDSHelperContext(this);

  JUMPOUT(0x1E692CD30);
}

void TDSHelperContext::Disconnect(TDSHelperContext *this)
{
  v1 = *(this + 19);
  if (v1)
  {
    *(this + 19) = 0;

    [*(this + 25) clearHelper];
    v3 = *(this + 25);
    *(this + 25) = 0;
  }
}

int64_t TDSHelperContext::LaunchDesktopServicesHelper(TDSHelperContext *this, BOOL a2)
{
  if (*(this + 19))
  {
    return 0;
  }

  v5 = DesktopServicesHelperServiceName();
  v6 = dispatch_get_global_queue(0, 0);
  mach_service = xpc_connection_create_mach_service(v5, v6, 2uLL);
  v8 = *(this + 19);
  *(this + 19) = mach_service;

  if (!*(this + 19))
  {
    return 4294959234;
  }

  v9 = [[DS_TDSHelperConnectionHandler alloc] initWithHelper:this];
  v10 = *(this + 25);
  *(this + 25) = v9;

  v11 = *(this + 25);
  v12 = *(this + 19);
  handler[0] = MEMORY[0x1E69E9820];
  handler[1] = 3221225472;
  handler[2] = ___ZN16TDSHelperContext27LaunchDesktopServicesHelperEbb_block_invoke;
  handler[3] = &unk_1E877F0A8;
  v13 = v11;
  v21 = v13;
  xpc_connection_set_event_handler(v12, handler);
  xpc_connection_resume(*(this + 19));
  v15 = TDSHelperContext::CreateMessageForHelper(v14, "Handshake");
  xpc_dictionary_set_BOOL(v15, "authorizeImmediately", a2);
  v16 = UseFileProviderFramework();
  xpc_dictionary_set_BOOL(v15, "ENABLE_FILE_PROVIDER", v16);
  xpc_dictionary_set_uint64(v15, "processOptions", *(this + 37));
  if (CFStringGetLength(*(this + 20)))
  {
    v17 = TString::c_str(this + 20);
    xpc_dictionary_set_string(v15, "AuthMessage", v17);
  }

  v18 = xpc_connection_send_message_with_reply_sync(*(this + 19), v15);
  if (MEMORY[0x1E692DC20]() == MEMORY[0x1E69E9E80])
  {
    int64 = xpc_dictionary_get_int64(v18, "errorStatus");
  }

  else
  {
    int64 = 4294959234;
  }

  return int64;
}

id TDSHelperContext::CreateMessageForHelper(TDSHelperContext *this, const char *a2)
{
  v3 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v3, "request", a2);
  v4 = UseFileProviderFramework();
  xpc_dictionary_set_BOOL(v3, "UseFileProviderFramework", v4);

  return v3;
}

id TDSHelperContext::SendMessageWithReplySync(uint64_t a1, void *a2)
{
  v2 = xpc_connection_send_message_with_reply_sync(*(a1 + 152), a2);

  return v2;
}

void TDSHelperContext::CancelHelper(xpc_connection_t *this)
{
  if (this[19])
  {
    v2 = TDSHelperContext::CreateMessageForHelper(this, "cancel");
    xpc_connection_send_message(this[19], v2);
  }
}

void TDSHelperContext::PauseHelper(xpc_connection_t *this)
{
  if (this[19])
  {
    v2 = TDSHelperContext::CreateMessageForHelper(this, "pause");
    xpc_connection_send_message(this[19], v2);
  }
}

void TDSHelperContext::ResumeHelper(xpc_connection_t *this)
{
  if (this[19])
  {
    v2 = TDSHelperContext::CreateMessageForHelper(this, "resume");
    xpc_connection_send_message(this[19], v2);
  }
}

void TDSHelperContext::Quit(TDSHelperContext *this)
{
  v1 = *(this + 19);
  if (v1)
  {
    connection = v1;
    v3 = *(this + 19);
    *(this + 19) = 0;

    v5 = TDSHelperContext::CreateMessageForHelper(v4, "exit");
    xpc_connection_send_message(connection, v5);
    [*(this + 25) clearHelper];
    v6 = *(this + 25);
    *(this + 25) = 0;
  }
}

void TDSHelperContext::ReplyReceived(uint64_t a1, void *a2)
{
  v4 = a2;
  std::mutex::lock((a1 + 8));
  if (*(a1 + 144) == 1)
  {
    *(a1 + 144) = 0;
    objc_storeStrong((a1 + 192), a2);
    TConditionVariable::Signal((a1 + 72));
  }

  std::mutex::unlock((a1 + 8));
}

void sub_1E56F6298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::mutex::unlock((v10 + 8));

  _Unwind_Resume(a1);
}

size_t TDSHelperContext::UpdateDestinationSpaceNeeds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const char *a16, const char *a17, uint64_t a18, unint64_t a19, int a20, char a21, char a22, int a23)
{
  *a2 = a3;
  *(a2 + 8) = a4;
  *(a2 + 16) = a5;
  *(a2 + 24) = a6;
  *(a2 + 2168) = a22;
  if (a21)
  {
    *(a2 + 48) = a8;
    *(a2 + 56) = a9;
    *(a2 + 32) = a7;
    *(a2 + 40) = a10;
    *(a2 + 64) = a11;
    *(a2 + 72) = a12;
    *(a2 + 80) = a13;
    *(a2 + 88) = a14;
    if (a16)
    {
      v24 = a16;
    }

    else
    {
      v24 = "";
    }

    *(a2 + 96) = a15;
    strlcpy((a2 + 104), v24, 0x400uLL);
    if (a17)
    {
      v25 = a17;
    }

    else
    {
      v25 = "";
    }

    result = strlcpy((a2 + 1128), v25, 0x400uLL);
  }

  else
  {
    *(a2 + 1128) = 0;
    *(a2 + 32) = 0u;
    *(a2 + 48) = 0u;
    *(a2 + 64) = 0u;
    *(a2 + 80) = 0u;
    *(a2 + 89) = 0u;
  }

  *(a2 + 2152) = a18;
  if (*(a2 + 2160) < a19)
  {
    *(a2 + 2160) = a19;
  }

  *(a2 + 2172) |= a20;
  if (*(a2 + 2176))
  {
    *(a2 + 2176) = a23;
  }

  return result;
}

int64_t TDSHelperContext::OperationSize(TDSHelperContext *a1, char *a2, char *a3, const char *a4, unsigned int a5, char a6, int64_t *a7, BOOL a8, BOOL value, unsigned int a10, unsigned int a11, BOOL *a12, BOOL *a13, int64_t *a14)
{
  v21 = *a7;
  v20 = a7[1];
  v22 = a7[2];
  v49 = a7[269];
  v51 = a7[3];
  v23 = TDSHelperContext::CreateMessageForHelper(a1, "OperationSizing");
  std::string::basic_string[abi:ne200100]<0>(v55, "sourcePath");
  std::string::basic_string[abi:ne200100]<0>(v53, a2);
  SetWrappedURL(v23, v55, v53, 0);
  if (v54 < 0)
  {
    operator delete(v53[0]);
  }

  if (v56 < 0)
  {
    operator delete(v55[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(v55, "destinationPath");
  std::string::basic_string[abi:ne200100]<0>(v53, a3);
  SetWrappedURL(v23, v55, v53, 0);
  if (v54 < 0)
  {
    operator delete(v53[0]);
  }

  if (v56 < 0)
  {
    operator delete(v55[0]);
  }

  xpc_dictionary_set_string(v23, "targetName", a4);
  xpc_dictionary_set_BOOL(v23, "migration", a8);
  xpc_dictionary_set_BOOL(v23, "Coordinate", value);
  xpc_dictionary_set_int64(v23, "requestedOperation", a5);
  xpc_dictionary_set_int64(v23, "conflicts", a10);
  xpc_dictionary_set_int64(v23, "userVisibleItemsTotal", v21);
  xpc_dictionary_set_int64(v23, "FSItemsTotal", v20);
  xpc_dictionary_set_int64(v23, "logicalBytesTotal", v22);
  xpc_dictionary_set_int64(v23, "physicalBytesTotal", v51);
  xpc_dictionary_set_int64(v23, "conflictPhysicalDelta", v49);
  xpc_dictionary_set_BOOL(v23, "canMerge", (a6 & 0x40) == 0);
  xpc_dictionary_set_uint64(v23, "statusChangeInterval", a11);
  v24 = TDSHelperContext::SendMessageAndWait(a1, v23);
  v25 = v24;
  v26 = 4294959293;
  if (v24 != MEMORY[0x1E69E9E20] && v24 && v24 != MEMORY[0x1E69E9E18])
  {
    *a12 = xpc_dictionary_get_BOOL(v24, "containsBackupItems");
    *a13 = xpc_dictionary_get_BOOL(v25, "containsNonBackupItems");
    *a14 = xpc_dictionary_get_int64(v25, "oprecordBytesCompleted");
    int64 = xpc_dictionary_get_int64(v25, "userVisibleItemsCompleted");
    v50 = xpc_dictionary_get_int64(v25, "itemsCompleted");
    v48 = xpc_dictionary_get_int64(v25, "logicalBytesTotal");
    v46 = xpc_dictionary_get_int64(v25, "physicalBytesTotal");
    v44 = xpc_dictionary_get_int64(v25, "mergeSourceNewerConflictsCount");
    v43 = xpc_dictionary_get_int64(v25, "mergeDestinationNewerConflictsCount");
    v42 = xpc_dictionary_get_int64(v25, "mergeDestinationNewerConflictsBytes");
    v41 = xpc_dictionary_get_int64(v25, "mergeSourceItemsNotInDestinationCount");
    v40 = xpc_dictionary_get_int64(v25, "mergeDestinationItemsNotInSourceCount");
    v39 = xpc_dictionary_get_int64(v25, "mergeMatchedFilesCount");
    v38 = xpc_dictionary_get_int64(v25, "mergeMatchedFilesBytes");
    v37 = xpc_dictionary_get_int64(v25, "mergeDiffMetaDataFilesCount");
    v36 = xpc_dictionary_get_int64(v25, "mergePhysicalDelta");
    string = xpc_dictionary_get_string(v25, "mergeFirstSourceConflictPath");
    v28 = xpc_dictionary_get_string(v25, "mergeFirstDestinationConflictPath");
    v29 = xpc_dictionary_get_int64(v25, "conflictPhysicalDelta");
    uint64 = xpc_dictionary_get_uint64(v25, "maxFileSize");
    v31 = xpc_dictionary_get_int64(v25, "conflicts");
    v32 = xpc_dictionary_get_BOOL(v25, "mergeAllowed");
    v33 = xpc_dictionary_get_BOOL(v25, "CopyWillClone");
    v34 = xpc_dictionary_get_int64(v25, "errorStatus");
    TDSHelperContext::UpdateDestinationSpaceNeeds(v34, a7, int64, v50, v48, v46, v44, v43, v42, v41, v40, v39, v38, v37, v36, string, v28, v29, uint64, v31, v32, v33, v34);
    v26 = xpc_dictionary_get_int64(v25, "errorStatus");
  }

  return v26;
}

id TDSHelperContext::SendMessageAndWait(uint64_t a1, void *a2)
{
  v3 = a2;
  if (*(a1 + 152))
  {
    std::mutex::lock((a1 + 8));
    *(a1 + 144) = 1;
    xpc_connection_send_message(*(a1 + 152), v3);
    TConditionVariable::Wait((a1 + 72), (a1 + 8));
    if (!*(a1 + 152))
    {
      [*(a1 + 200) clearHelper];
      v4 = *(a1 + 200);
      *(a1 + 200) = 0;
    }

    v5 = *(a1 + 192);
    std::mutex::unlock((a1 + 8));
  }

  else
  {
    v5 = MEMORY[0x1E69E9E20];
    v6 = MEMORY[0x1E69E9E20];
  }

  return v5;
}

int64_t TDSHelperContext::DeletePath(TDSHelperContext *this, char *a2, BOOL a3, BOOL a4)
{
  v8 = TDSHelperContext::CreateMessageForHelper(this, "DeleteItem");
  std::string::basic_string[abi:ne200100]<0>(v15, "sourcePath");
  std::string::basic_string[abi:ne200100]<0>(__p, a2);
  SetWrappedURL(v8, v15, __p, 1);
  if (v14 < 0)
  {
    operator delete(__p[0]);
  }

  if (v16 < 0)
  {
    operator delete(v15[0]);
  }

  xpc_dictionary_set_uint64(v8, "processOptions", *(this + 37));
  xpc_dictionary_set_BOOL(v8, "deleteLocked", a3);
  xpc_dictionary_set_BOOL(v8, "deleteBusy", a4);
  xpc_dictionary_set_BOOL(v8, "reportProgress", 0);
  v9 = TDSHelperContext::SendMessageAndWait(this, v8);
  v10 = v9;
  if (v9 && MEMORY[0x1E692DC20](v9) == MEMORY[0x1E69E9E80])
  {
    int64 = xpc_dictionary_get_int64(v10, "errorStatus");
  }

  else
  {
    int64 = 4294959293;
  }

  return int64;
}

int64_t TDSHelperContext::RenamePath(xpc_connection_t *this, char *a2, TString *a3, BOOL a4, BOOL a5)
{
  v10 = TDSHelperContext::CreateMessageForHelper(this, "Rename");
  std::string::basic_string[abi:ne200100]<0>(v17, "sourcePath");
  std::string::basic_string[abi:ne200100]<0>(__p, a2);
  SetWrappedURL(v10, v17, __p, 1);
  if (v16 < 0)
  {
    operator delete(__p[0]);
  }

  if (v18 < 0)
  {
    operator delete(v17[0]);
  }

  v11 = TString::c_str(a3);
  xpc_dictionary_set_string(v10, "newName", v11);
  xpc_dictionary_set_BOOL(v10, "changeExtensionHidden", a4);
  xpc_dictionary_set_BOOL(v10, "extensionHidden", a5);
  xpc_dictionary_set_uint64(v10, "processOptions", *(this + 37));
  v12 = xpc_connection_send_message_with_reply_sync(this[19], v10);
  if (MEMORY[0x1E692DC20]() == MEMORY[0x1E69E9E80])
  {
    int64 = xpc_dictionary_get_int64(v12, "errorStatus");
  }

  else
  {
    int64 = 4294959234;
  }

  return int64;
}

int64_t TDSHelperContext::CreateFolder(xpc_connection_t *this, char *a2, const char *a3, char *a4)
{
  *a4 = 0;
  v8 = TDSHelperContext::CreateMessageForHelper(this, "CreateFolder");
  std::string::basic_string[abi:ne200100]<0>(v15, "sourcePath");
  std::string::basic_string[abi:ne200100]<0>(__p, a2);
  SetWrappedURL(v8, v15, __p, 1);
  if (v14 < 0)
  {
    operator delete(__p[0]);
  }

  if (v16 < 0)
  {
    operator delete(v15[0]);
  }

  xpc_dictionary_set_string(v8, "newName", a3);
  v9 = xpc_connection_send_message_with_reply_sync(this[19], v8);
  if (MEMORY[0x1E692DC20]() == MEMORY[0x1E69E9E80])
  {
    int64 = xpc_dictionary_get_int64(v9, "errorStatus");
    if (!int64)
    {
      string = xpc_dictionary_get_string(v9, "resultPath");
      if (string && *string)
      {
        if (strlcpy(a4, string, 0x400uLL) <= 0x3FF)
        {
          int64 = 0;
        }

        else
        {
          int64 = 4294959236;
        }
      }

      else
      {
        int64 = 4294959236;
      }
    }
  }

  else
  {
    int64 = 4294959234;
  }

  return int64;
}

int64_t TDSHelperContext::Deleting(uint64_t a1, char *a2, unsigned int a3, BOOL a4, unsigned int a5, BOOL a6, BOOL a7, void *a8)
{
  v15 = a8;
  v16 = TDSHelperContext::CreateMessageForHelper(v15, "DeleteItem");
  std::string::basic_string[abi:ne200100]<0>(v23, "sourcePath");
  std::string::basic_string[abi:ne200100]<0>(__p, a2);
  SetWrappedURL(v16, v23, __p, 1);
  if (v22 < 0)
  {
    operator delete(__p[0]);
  }

  if (v24 < 0)
  {
    operator delete(v23[0]);
  }

  xpc_dictionary_set_uint64(v16, "processOptions", *(a1 + 148));
  xpc_dictionary_set_BOOL(v16, "deleteLocked", a7);
  xpc_dictionary_set_BOOL(v16, "deleteBusy", a4);
  xpc_dictionary_set_BOOL(v16, "reportProgress", a6);
  xpc_dictionary_set_uint64(v16, "mergeResolution", a3);
  xpc_dictionary_set_uint64(v16, "statusChangeInterval", a5);
  if (v15 && [(TDSHelperContext *)v15 bytes])
  {
    xpc_dictionary_set_data(v16, "scriptingAuditToken", [(TDSHelperContext *)v15 bytes], [(TDSHelperContext *)v15 length]);
  }

  v17 = TDSHelperContext::SendMessageAndWait(a1, v16);
  v18 = v17;
  int64 = 4294959293;
  if (v17 != MEMORY[0x1E69E9E20] && v17 && v17 != MEMORY[0x1E69E9E18])
  {
    int64 = xpc_dictionary_get_int64(v17, "errorStatus");
  }

  return int64;
}

int64_t TDSHelperContext::ChildCreateLock(TDSHelperContext *a1, char *a2, char *a3, const char *a4, uint64_t a5, unsigned int a6, char *a7, BOOL *a8)
{
  *a8 = 0;
  v15 = TDSHelperContext::CreateMessageForHelper(a1, "ChildCreateLock");
  std::string::basic_string[abi:ne200100]<0>(v23, "parentPath");
  std::string::basic_string[abi:ne200100]<0>(__p, a2);
  SetWrappedURL(v15, v23, __p, 1);
  if (v22 < 0)
  {
    operator delete(__p[0]);
  }

  if (v24 < 0)
  {
    operator delete(v23[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(v23, "sourcePath");
  std::string::basic_string[abi:ne200100]<0>(__p, a3);
  SetWrappedURL(v15, v23, __p, 0);
  if (v22 < 0)
  {
    operator delete(__p[0]);
  }

  if (v24 < 0)
  {
    operator delete(v23[0]);
  }

  xpc_dictionary_set_string(v15, "newName", a4);
  xpc_dictionary_set_uint64(v15, "processOptions", a6);
  v16 = TDSHelperContext::SendMessageAndWait(a1, v15);
  v17 = v16;
  int64 = 4294959293;
  if (v16 != MEMORY[0x1E69E9E20])
  {
    if (v16)
    {
      if (v16 != MEMORY[0x1E69E9E18])
      {
        int64 = xpc_dictionary_get_int64(v16, "errorStatus");
        if (!int64)
        {
          *a8 = xpc_dictionary_get_BOOL(v17, "resultIsClone");
          string = xpc_dictionary_get_string(v17, "resultPath");
          if (string && *string && strlcpy(a7, string, 0x400uLL) < 0x400)
          {
            int64 = 0;
          }

          else
          {
            *a7 = 0;
            int64 = 4294959236;
          }
        }
      }
    }
  }

  return int64;
}

int64_t TDSHelperContext::PerformCopyMove(uint64_t a1, TString *a2, TString *a3, TString *a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, uint64_t value, BOOL a10, BOOL a11, void *a12, _DWORD *a13)
{
  v21 = a12;
  v22 = v21;
  if (a6 == 21)
  {
    v23 = "RunSetRootMetadata";
  }

  else
  {
    v23 = "RunCopyMoveOperation";
  }

  v24 = TDSHelperContext::CreateMessageForHelper(v21, v23);
  v25 = v24;
  if (a6 != 21)
  {
    xpc_dictionary_set_int64(v24, "options", a8);
    xpc_dictionary_set_uint64(v25, "maxFileSize", value);
    xpc_dictionary_set_uint64(v25, "statusChangeInterval", a5);
    xpc_dictionary_set_uint64(v25, "mergeResolution", a7);
    xpc_dictionary_set_uint64(v25, "processOptions", *(a1 + 148));
    xpc_dictionary_set_BOOL(v25, "ApplyDoNotTranslocate", a10);
    xpc_dictionary_set_BOOL(v25, "LastRoot", a11);
  }

  std::string::basic_string[abi:ne200100]<0>(v35, "sourcePath");
  v26 = TString::c_str(a2);
  std::string::basic_string[abi:ne200100]<0>(__p, v26);
  SetWrappedURL(v25, v35, __p, 0);
  if (v34 < 0)
  {
    operator delete(__p[0]);
  }

  if (v36 < 0)
  {
    operator delete(v35[0]);
  }

  std::string::basic_string[abi:ne200100]<0>(v35, "destinationPath");
  v27 = TString::c_str(a3);
  std::string::basic_string[abi:ne200100]<0>(__p, v27);
  SetWrappedURL(v25, v35, __p, 1);
  if (v34 < 0)
  {
    operator delete(__p[0]);
  }

  if (v36 < 0)
  {
    operator delete(v35[0]);
  }

  v28 = TString::c_str(a4);
  xpc_dictionary_set_string(v25, "targetName", v28);
  if (v22 && [(TDSHelperContext *)v22 bytes])
  {
    xpc_dictionary_set_data(v25, "scriptingAuditToken", [(TDSHelperContext *)v22 bytes], [(TDSHelperContext *)v22 length]);
  }

  xpc_dictionary_set_int64(v25, "requestedOperation", a6);
  v29 = TDSHelperContext::SendMessageAndWait(a1, v25);
  v30 = v29;
  int64 = 4294959293;
  if (v29 != MEMORY[0x1E69E9E20] && v29 && v29 != MEMORY[0x1E69E9E18])
  {
    *a13 = xpc_dictionary_get_int64(v29, "completedOperation");
    int64 = xpc_dictionary_get_int64(v30, "errorStatus");
  }

  return int64;
}

int64_t TDSHelperContext::FilesCopyChildCreateLock(uint64_t a1, void *a2, void *a3, void *a4, void *a5, int64_t a6, int a7, unsigned int a8, BOOL value, const void **a10, BOOL *a11)
{
  v35 = *MEMORY[0x1E69E9840];
  v30 = a2;
  v29 = a3;
  v17 = a4;
  v28 = a5;
  *a11 = 0;
  v18 = TDSHelperContext::CreateMessageForHelper(v28, "FilesCopyChildCreateLock");
  v31 = [objc_opt_class() wrapperWithURL:v30 readonly:0 error:0];
  v19 = [objc_opt_class() wrapperWithURL:v29 readonly:1 error:0];
  v20 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v31 requiringSecureCoding:1 error:0];
  v21 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v19 requiringSecureCoding:1 error:0];
  xpc_dictionary_set_data(v18, "parentURLWrapper", [v20 bytes], objc_msgSend(v20, "length"));
  xpc_dictionary_set_data(v18, "sourceURLWrapper", [v21 bytes], objc_msgSend(v21, "length"));
  xpc_dictionary_set_string(v18, "newName", [v17 UTF8String]);
  xpc_dictionary_set_uint64(v18, "processOptions", a8);
  xpc_dictionary_set_BOOL(v18, "copyIsDuplication", value);
  *uuid = 0;
  v34 = 0;
  [(TDSHelperContext *)v28 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v18, "GroupUUID", uuid);
  xpc_dictionary_set_int64(v18, "GroupCount", a6);
  xpc_dictionary_set_BOOL(v18, "UseFileProviderFramework", 0);
  v22 = TDSHelperContext::SendMessageAndWait(a1, v18);
  v23 = v22;
  int64 = 4294959293;
  if (v22 != MEMORY[0x1E69E9E20])
  {
    if (v22)
    {
      if (v22 != MEMORY[0x1E69E9E18])
      {
        int64 = xpc_dictionary_get_int64(v22, "errorStatus");
        if (!int64)
        {
          *a11 = xpc_dictionary_get_BOOL(v23, "resultIsClone");
          string = xpc_dictionary_get_string(v23, "resultPath");
          TString::TString(&cf, string);
          if (&cf != a10)
          {
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a10, &cf);
            CFRetain(&stru_1F5F42870);
            if (cf)
            {
              CFRelease(cf);
            }

            cf = &stru_1F5F42870;
          }

          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
          if (CFStringGetLength(*a10))
          {
            int64 = 0;
          }

          else
          {
            int64 = 4294959236;
          }
        }
      }
    }
  }

  v26 = *MEMORY[0x1E69E9840];
  return int64;
}

void sub_1E56F79A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2)
  {
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

int64_t TDSHelperContext::FilesCopyDeleteLock(uint64_t a1, void *a2, void *a3, void *a4)
{
  v20 = *MEMORY[0x1E69E9840];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = TDSHelperContext::CreateMessageForHelper(v9, "FilesCopyDeleteLock");
  v11 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v7 requiringSecureCoding:1 error:0];
  v12 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v8 requiringSecureCoding:1 error:0];
  xpc_dictionary_set_data(v10, "lockURLWrapper", [v11 bytes], objc_msgSend(v11, "length"));
  xpc_dictionary_set_data(v10, "sourceURLWrapper", [v12 bytes], objc_msgSend(v12, "length"));
  *uuid = 0;
  v19 = 0;
  [(TDSHelperContext *)v9 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v10, "GroupUUID", uuid);
  v13 = TDSHelperContext::SendMessageAndWait(a1, v10);
  v14 = v13;
  int64 = 4294959293;
  if (v13 != MEMORY[0x1E69E9E20] && v13 && v13 != MEMORY[0x1E69E9E18])
  {
    int64 = xpc_dictionary_get_int64(v13, "errorStatus");
  }

  v16 = *MEMORY[0x1E69E9840];
  return int64;
}

int64_t TDSHelperContext::FilesCopyDeleteItem(uint64_t a1, void *a2, unsigned int a3, BOOL a4, BOOL a5)
{
  v9 = a2;
  v10 = TDSHelperContext::CreateMessageForHelper(v9, "DeleteItem");
  v11 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v9 requiringSecureCoding:1 error:0];
  xpc_dictionary_set_data(v10, "sourceURLWrapper", [v11 bytes], objc_msgSend(v11, "length"));
  xpc_dictionary_set_uint64(v10, "mergeResolution", a3);
  xpc_dictionary_set_BOOL(v10, "deleteLocked", a4);
  xpc_dictionary_set_BOOL(v10, "deleteBusy", a5);
  xpc_dictionary_set_BOOL(v10, "reportProgress", 0);
  v12 = TDSHelperContext::SendMessageAndWait(a1, v10);
  v13 = v12;
  int64 = 4294959293;
  if (v12 != MEMORY[0x1E69E9E20] && v12 && v12 != MEMORY[0x1E69E9E18])
  {
    int64 = xpc_dictionary_get_int64(v12, "errorStatus");
  }

  return int64;
}

int64_t TDSHelperContext::FilesCopySetRootMetadata(uint64_t a1, void *a2, void *a3, void *a4, unsigned int a5, _DWORD *a6)
{
  v11 = a2;
  v12 = a3;
  v13 = a4;
  v24 = v11;
  v14 = TDSHelperContext::CreateMessageForHelper(v13, "RunFilesCopyRunSetRootMetadata");
  v15 = [objc_opt_class() wrapperWithURL:v11 readonly:1 error:0];
  v23 = a6;
  v16 = [objc_opt_class() wrapperWithURL:v12 readonly:0 error:0];
  v17 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v15 requiringSecureCoding:1 error:0];
  v18 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v16 requiringSecureCoding:1 error:0];
  xpc_dictionary_set_data(v14, "sourceURLWrapper", [v17 bytes], objc_msgSend(v17, "length"));
  xpc_dictionary_set_data(v14, "destinationURLWrapper", [v18 bytes], objc_msgSend(v18, "length"));
  xpc_dictionary_set_string(v14, "targetName", [(TDSHelperContext *)v13 UTF8String]);
  xpc_dictionary_set_int64(v14, "requestedOperation", a5);
  v19 = TDSHelperContext::SendMessageAndWait(a1, v14);
  v20 = v19;
  int64 = 4294959293;
  if (v19 != MEMORY[0x1E69E9E20] && v19 && v19 != MEMORY[0x1E69E9E18])
  {
    *v23 = xpc_dictionary_get_int64(v19, "completedOperation");
    int64 = xpc_dictionary_get_int64(v20, "errorStatus");
  }

  return int64;
}

int64_t TDSHelperContext::FilesCopyOperationSize(uint64_t a1, void *a2, void *a3, void *a4, unsigned int a5, __int16 a6, int64_t *a7, unsigned int a8, void *a9, int64_t *a10)
{
  v61 = *MEMORY[0x1E69E9840];
  v55 = a2;
  v54 = a3;
  v53 = a4;
  v17 = a9;
  v19 = *a7;
  v18 = a7[1];
  v20 = a7[2];
  v50 = a7[3];
  v52 = v17;
  v48 = a7[269];
  v21 = TDSHelperContext::CreateMessageForHelper(v17, "FilesCopyOperationSizing");
  v57 = [objc_opt_class() wrapperWithURL:v55 readonly:1 error:0];
  v56 = [objc_opt_class() wrapperWithURL:v54 readonly:0 error:0];
  v46 = a1;
  v58 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v57 requiringSecureCoding:1 error:0];
  v22 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v56 requiringSecureCoding:1 error:0];
  xpc_dictionary_set_data(v21, "sourceURLWrapper", [v58 bytes], objc_msgSend(v58, "length"));
  xpc_dictionary_set_data(v21, "destinationURLWrapper", [v22 bytes], objc_msgSend(v22, "length"));
  xpc_dictionary_set_string(v21, "targetName", [v53 UTF8String]);
  xpc_dictionary_set_BOOL(v21, "Coordinate", (a6 & 0x2000) != 0);
  xpc_dictionary_set_int64(v21, "requestedOperation", a5);
  xpc_dictionary_set_int64(v21, "conflicts", a8);
  xpc_dictionary_set_int64(v21, "userVisibleItemsTotal", v19);
  xpc_dictionary_set_int64(v21, "FSItemsTotal", v18);
  xpc_dictionary_set_int64(v21, "logicalBytesTotal", v20);
  xpc_dictionary_set_int64(v21, "physicalBytesTotal", v50);
  xpc_dictionary_set_int64(v21, "conflictPhysicalDelta", v48);
  xpc_dictionary_set_BOOL(v21, "canMerge", (a6 & 0x40) == 0);
  *uuid = 0;
  v60 = 0;
  [(TDSHelperContext *)v52 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v21, "GroupUUID", uuid);
  v23 = TDSHelperContext::SendMessageAndWait(v46, v21);
  v24 = v23;
  v25 = 4294959293;
  if (v23 != MEMORY[0x1E69E9E20] && v23 && v23 != MEMORY[0x1E69E9E18])
  {
    *a10 = xpc_dictionary_get_int64(v23, "oprecordBytesCompleted");
    int64 = xpc_dictionary_get_int64(v24, "userVisibleItemsCompleted");
    v49 = xpc_dictionary_get_int64(v24, "itemsCompleted");
    v47 = xpc_dictionary_get_int64(v24, "logicalBytesTotal");
    v45 = xpc_dictionary_get_int64(v24, "physicalBytesTotal");
    v44 = xpc_dictionary_get_int64(v24, "mergeSourceNewerConflictsCount");
    v43 = xpc_dictionary_get_int64(v24, "mergeDestinationNewerConflictsCount");
    v42 = xpc_dictionary_get_int64(v24, "mergeDestinationNewerConflictsBytes");
    v41 = xpc_dictionary_get_int64(v24, "mergeSourceItemsNotInDestinationCount");
    v40 = xpc_dictionary_get_int64(v24, "mergeDestinationItemsNotInSourceCount");
    v39 = xpc_dictionary_get_int64(v24, "mergeMatchedFilesCount");
    v38 = xpc_dictionary_get_int64(v24, "mergeMatchedFilesBytes");
    v37 = xpc_dictionary_get_int64(v24, "mergeDiffMetaDataFilesCount");
    v36 = xpc_dictionary_get_int64(v24, "mergePhysicalDelta");
    string = xpc_dictionary_get_string(v24, "mergeFirstSourceConflictPath");
    v26 = xpc_dictionary_get_string(v24, "mergeFirstDestinationConflictPath");
    v27 = xpc_dictionary_get_int64(v24, "conflictPhysicalDelta");
    uint64 = xpc_dictionary_get_uint64(v24, "maxFileSize");
    v29 = xpc_dictionary_get_int64(v24, "conflicts");
    v30 = xpc_dictionary_get_BOOL(v24, "mergeAllowed");
    v31 = xpc_dictionary_get_BOOL(v24, "CopyWillClone");
    v32 = xpc_dictionary_get_int64(v24, "errorStatus");
    TDSHelperContext::UpdateDestinationSpaceNeeds(v32, a7, int64, v49, v47, v45, v44, v43, v42, v41, v40, v39, v38, v37, v36, string, v26, v27, uint64, v29, v30, v31, v32);
    v25 = xpc_dictionary_get_int64(v24, "errorStatus");
  }

  v33 = *MEMORY[0x1E69E9840];
  return v25;
}

int64_t TDSHelperContext::PerformFilesCopy(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, BOOL a7, BOOL a8, _DWORD *a9)
{
  v51 = *MEMORY[0x1E69E9840];
  v14 = a2;
  v40 = a3;
  v39 = a4;
  v38 = a5;
  v15 = TDSHelperContext::CreateMessageForHelper(v38, "RunFilesCopyOperation");
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator(uuid, v14);
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor(v48, -1, v14);
  v16 = algorithm_extras::distance_or_zero<IDContainerIteratorAdaptor<NSArray<NSURL *>>>(uuid, v48);

  v17 = type_traits_extras::CopyAsHelper<NSArray<FPSandboxingURLWrapper *> * {__strong}>::MakeWithCapacity(v16);
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator(&obj, v14);
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor(v41, -1, v14);
  v18 = v17;
  while (obj != v41[0] || v47 != v41[16])
  {
    v19 = *(v43[1] + 8 * v46);
    v20 = [objc_opt_class() wrapperWithURL:v19 readonly:1 error:0];

    if (v20)
    {
      v21 = v18;
      [v21 addObject:v20];
    }

    v22 = v46;
    if (v46 >= v45 - 1)
    {
      v23 = [obj countByEnumeratingWithState:v43 objects:v44 count:4];
      v22 = -1;
      v45 = v23;
      v46 = -1;
    }

    if (v44[4] != *v43[2])
    {
      objc_enumerationMutation(obj);
      v22 = v46;
    }

    v46 = v22 + 1;
    ++v47;
  }

  v24 = [objc_opt_class() wrapperWithURL:v40 readonly:0 error:0];
  v25 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v18 requiringSecureCoding:1 error:0];
  v26 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v24 requiringSecureCoding:1 error:0];
  v27 = [MEMORY[0x1E696ACC8] archivedDataWithRootObject:v39 requiringSecureCoding:1 error:0];
  xpc_dictionary_set_int64(v15, "requestedOperation", 2);
  v28 = v25;
  xpc_dictionary_set_data(v15, "sourceURLWrappers", [v25 bytes], objc_msgSend(v25, "length"));
  v29 = v26;
  xpc_dictionary_set_data(v15, "destinationURLWrapper", [v26 bytes], objc_msgSend(v26, "length"));
  v30 = v27;
  xpc_dictionary_set_data(v15, "targetNames", [v27 bytes], objc_msgSend(v27, "length"));
  xpc_dictionary_set_uint64(v15, "maxFileSize", a6);
  xpc_dictionary_set_BOOL(v15, "copySync", a7);
  xpc_dictionary_set_BOOL(v15, "copyIsDuplication", a8);
  *uuid = 0;
  v50 = 0;
  [(TDSHelperContext *)v38 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v15, "GroupUUID", uuid);
  v31 = TDSHelperContext::SendMessageAndWait(a1, v15);
  v32 = v31;
  int64 = 4294959293;
  if (v31 != MEMORY[0x1E69E9E20] && v31 && v31 != MEMORY[0x1E69E9E18])
  {
    *a9 = xpc_dictionary_get_int64(v31, "completedOperation");
    int64 = xpc_dictionary_get_int64(v32, "errorStatus");
  }

  v34 = *MEMORY[0x1E69E9840];
  return int64;
}

void TDSHelperContext::HandleMsgFromHelper(uint64_t a1, const char *a2, void *a3)
{
  v5 = a3;
  if (!strcmp(a2, "DeleteItem_Reply") || !strcmp(a2, "ChildCreateLock_Reply") || !strcmp(a2, "RunCopyMoveOperation_Reply") || !strcmp(a2, "OperationSizing_Reply") || !strcmp(a2, "FilesCopyDeleteLock_Reply") || !strcmp(a2, "RunFilesCopyOperation"))
  {
    TDSHelperContext::ReplyReceived(a1, v5);
  }
}

void TConditionVariable::~TConditionVariable(std::condition_variable *this)
{
  v2 = *this[1].__cv_.__opaque;
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  std::condition_variable::~condition_variable(this);
}

uint64_t algorithm_extras::distance_or_zero<IDContainerIteratorAdaptor<NSArray<NSURL *>>>(uint64_t a1, uint64_t a2)
{
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator(v6, a1);
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator(v5, a2);
  v3 = std::distance[abi:ne200100]<IDContainerIteratorAdaptor<NSArray<NSURL *>>>(v6, v5);

  return v3;
}

uint64_t std::distance[abi:ne200100]<IDContainerIteratorAdaptor<NSArray<NSURL *>>>(uint64_t a1, uint64_t a2)
{
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator(&obj, a1);
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator(v7, a2);
  v3 = 0;
  while (obj != v7[0] || v13 != v7[16])
  {
    v4 = v12;
    if (v12 >= v11 - 1)
    {
      v5 = [obj countByEnumeratingWithState:v9 objects:v10 count:4];
      v4 = -1;
      v11 = v5;
      v12 = -1;
    }

    if (v10[4] != *v9[2])
    {
      objc_enumerationMutation(obj);
      v4 = v12;
    }

    v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  *a1 = v4;
  *(a1 + 8) = 0u;
  *(a1 + 104) = 0;
  *(a1 + 112) = -1;
  v5 = (a1 + 112);
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 120) = -1;
  v6 = (a1 + 120);
  *(a1 + 128) = -1;
  if (v4 && [v4 count] && (v7 = *(a2 + 128), v7 < objc_msgSend(*a1, "count")))
  {
    v8 = [*a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(a1 + 112) = v8;
    *(a1 + 104) = **(a1 + 24);
    *v6 = 0;
    *(a1 + 128) = 0;
    v9 = *(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *v5 = [*a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
            v11 = -1;
            *v6 = -1;
          }

          if (*(a1 + 104) != **(a1 + 24))
          {
            objc_enumerationMutation(*a1);
            v11 = *v6;
          }

          v13 = *(a1 + 128) + 1;
          *(a1 + 120) = ++v11;
          *(a1 + 128) = v13;
          ++v12;
        }

        while (*(a2 + 128) > v12);
      }
    }

    else
    {
      *(a1 + 120) = *(a2 + 120);
      *(a1 + 128) = v9;
    }
  }

  else
  {
    *v6 = *(a2 + 120);
  }

  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = v3;
  *a1 = v3;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 120) = -1;
  *(a1 + 104) = 0;
  *(a1 + 112) = -1;
  *(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(a1 + 112) = [*a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(a1 + 104) = **(a1 + 24);
    *(a1 + 120) = 0;
    *(a1 + 128) = 0;
  }

  else
  {
    *(a1 + 128) = 0;
  }

  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  *a1 = v4;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 104) = 0;
  *(a1 + 112) = -1;
  *(a1 + 120) = -1;
  *(a1 + 128) = -1;
  *(a1 + 128) = [v4 count];

  return a1;
}

void TCloneCache::TCloneCache(TCloneCache *this, char a2)
{
  *this = a2;
  *(this + 8) = 0u;
  *(this + 24) = 0u;
  *(this + 10) = 1065353216;
  *(this + 3) = 0u;
  *(this + 4) = 0u;
  *(this + 20) = 1065353216;
}

void TCloneCache::RecordClone(TCloneCache *a1, unint64_t *a2, uint64_t *a3)
{
  if (!TCloneCache::HasCloneID(a1, a2))
  {
    if (*a1 == 1)
    {
      v6 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a1 + 1, a2);
      v8 = *a3;
      v7 = a3[1];
      if (v7)
      {
        atomic_fetch_add_explicit((v7 + 8), 1uLL, memory_order_relaxed);
      }

      v9 = v6[4];
      v6[3] = v8;
      v6[4] = v7;
      if (v9)
      {
        std::__shared_weak_count::__release_shared[abi:ne200100](v9);
      }
    }

    else
    {

      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(a1 + 6, a2);
    }
  }
}

BOOL TCloneCache::HasCloneID(TCloneCache *this, unint64_t *a2)
{
  if (*this == 1)
  {
    v2 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>(this + 1, a2);
    if (v2)
    {
      v4 = v2[3];
      v3 = v2[4];
      if (v3)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        v5 = v4 != 0;
        std::__shared_weak_count::__release_shared[abi:ne200100](v3);
        return v5;
      }
    }

    else
    {
      v4 = 0;
    }

    v6 = v4 == 0;
  }

  else
  {
    v6 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>(this + 6, a2) == 0;
  }

  return !v6;
}

void TCloneCache::RemoveAll(TCloneCache *this)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(this + 6);

  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>>>::clear(this + 8);
}

void std::vector<TString>::__vdeallocate(void **a1)
{
  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
      {
        v3 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3 - 1);
      }

      while (v3 != v1);
      v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

const void *cf_cast<__CFDictionary const*,void const*>(const void *result)
{
  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID())
    {
      return 0;
    }

    else
    {
      v3 = CFGetTypeID(v1);
      if (v3 == CFDictionaryGetTypeID())
      {
        return v1;
      }

      else
      {
        return 0;
      }
    }
  }

  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(void *a1, unint64_t *a2)
{
  v2 = *a2;
  v3 = a1[1];
  if (!*&v3)
  {
    goto LABEL_18;
  }

  v4 = vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v2 >= *&v3)
    {
      v5 = v2 % *&v3;
    }
  }

  else
  {
    v5 = (*&v3 - 1) & v2;
  }

  v6 = *(*a1 + 8 * v5);
  if (!v6 || (v7 = *v6) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v8 = v7[1];
    if (v8 == v2)
    {
      break;
    }

    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *&v3)
      {
        v8 %= *&v3;
      }
    }

    else
    {
      v8 &= *&v3 - 1;
    }

    if (v8 != v5)
    {
      goto LABEL_18;
    }

LABEL_17:
    v7 = *v7;
    if (!v7)
    {
      goto LABEL_18;
    }
  }

  if (v7[2] != v2)
  {
    goto LABEL_17;
  }

  return v7;
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(void *result)
{
  if (result[3])
  {
    v1 = result;
    result = result[2];
    if (result)
    {
      do
      {
        v2 = *result;
        operator delete(result);
        result = v2;
      }

      while (v2);
    }

    v1[2] = 0;
    v3 = v1[1];
    if (v3)
    {
      for (i = 0; i != v3; ++i)
      {
        *(*v1 + 8 * i) = 0;
      }
    }

    v1[3] = 0;
  }

  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>>>::clear(uint64_t a1)
{
  if (*(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo const>>>>::__deallocate_node(a1, *(a1 + 16));
    *(a1 + 16) = 0;
    v2 = *(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
      {
        *(*a1 + 8 * i) = 0;
      }
    }

    *(a1 + 24) = 0;
  }
}

void SlashesToColons(const TString *a1@<X0>, TString *a2@<X8>)
{
  v12 = *MEMORY[0x1E69E9840];
  if (!CFStringGetLength(a1->fString.fRef))
  {
    goto LABEL_13;
  }

  v4 = RetainCF<__CFString const*>(&a1->fString.fRef);
  if (v4)
  {
    v5 = CFAutorelease(v4);
    v4 = static_cf_cast<__CFString const*,void const*>(v5);
  }

  if (!CFStringGetCString(v4, buffer, 1024, 0x8000100u))
  {
    goto LABEL_13;
  }

  v6 = 0;
  for (i = buffer; *i == 47; ++i)
  {
    *i = 58;
    v6 = 1;
LABEL_10:
    ;
  }

  if (*i)
  {
    goto LABEL_10;
  }

  if ((v6 & 1) == 0)
  {
LABEL_13:
    a2->fString.fRef = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
    TString::SetStringRefAsImmutable(a2, a1->fString.fRef);
    goto LABEL_14;
  }

  v8 = CFStringCreateWithCString(0, buffer, 0x8000100u);
  v10 = v8;
  a2->fString.fRef = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable(a2, v8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v10);
LABEL_14:
  v9 = *MEMORY[0x1E69E9840];
}

void sub_1E56F97E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

CFComparisonResult SpotlightStringCompare(const __CFString *a1, const __CFString *a2)
{
  if (a1)
  {
    if (a2)
    {
      return CFStringCompare(a1, a2, 0x81uLL);
    }

    else
    {
      return 1;
    }
  }

  else if (a2)
  {
    return -1;
  }

  else
  {
    return 0;
  }
}

const void **FileSuffixChain@<X0>(TString a1@<0:X0>, TString *a2@<X8>)
{
  a2->fString.fRef = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  FileSuffix(a1.fString.fRef, &v19);
  v4 = *MEMORY[0x1E6982E48];
  v5 = *MEMORY[0x1E695E480];
  while (1)
  {
    theString = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
    TString::SetStringRefAsImmutable(&theString, v19);
    TString::TString(&cf, ".");
    v6 = TString::BeginsWith(&theString, &cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (v6)
    {
      TString::SubStringFrom(&v19, 1, &cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&theString, &cf);
      CFRetain(&stru_1F5F42870);
      if (cf)
      {
        CFRelease(cf);
      }

      cf = &stru_1F5F42870;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }

    if (!CFStringGetLength(theString))
    {
      break;
    }

    v7 = [MEMORY[0x1E6982C40] typeWithFilenameExtension:theString conformingToType:v4];
    v8 = v7;
    if (!v7)
    {
      break;
    }

    if ([v7 isDeclared])
    {

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&theString);
    }

    else
    {
      v9 = objc_alloc(MEMORY[0x1E6963630]);
      v10 = [v8 identifier];
      v11 = [v9 initWithTypeIdentifier:v10 error:0];

      v12 = [v11 bundleRecord];
      v13 = [v12 executableURL];

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&theString);
      if (!v13)
      {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v19);
      }
    }

    Length = CFStringGetLength(a1.fString.fRef->isa);
    v15 = CFStringGetLength(v19);
    TString::SetLength(a1.fString.fRef, Length - v15);
    v16 = v19;
    theString = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
    MutableCopy = CFStringCreateMutableCopy(v5, 0, v16);
    CFRelease(&stru_1F5F42870);
    theString = MutableCopy;
    TString::Append(&theString, a2);
    if (&theString != a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&a2->fString.fRef, &theString);
      CFRetain(&stru_1F5F42870);
      if (theString)
      {
        CFRelease(theString);
      }

      theString = &stru_1F5F42870;
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&theString);
    FileSuffix(a1.fString.fRef, &theString);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&v19, &theString);
    CFRetain(&stru_1F5F42870);
    if (theString)
    {
      CFRelease(theString);
    }

    theString = &stru_1F5F42870;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&theString);
  }

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&theString);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v19);
}

const void **RedactedStr@<X0>(TString *a1@<X0>, TString *a2@<X8>)
{
  if (CFStringGetLength(a1->fString.fRef))
  {
    Length = CFStringGetLength(a1->fString.fRef);
    v51.fString.fRef = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
    TString::SetStringRefAsImmutable(&v51, a1->fString.fRef);
    v5.fString.fRef = &v51;
    FileSuffixChain(v5, &v52);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v51.fString.fRef);
    v6 = Length - CFStringGetLength(v52.fString.fRef);
    if (v6 <= 2 && CFStringGetLength(v52.fString.fRef))
    {
      while (1)
      {
        v7 = v6 + 1;
        if (v6 + 1 >= Length)
        {
          break;
        }

        v8 = v6 < -1 || CFStringGetLength(a1->fString.fRef) <= v7 ? 0 : CFStringGetCharacterAtIndex(a1->fString.fRef, v6 + 1);
        v9 = v6 + 1;
        if (v6++ >= 2)
        {
          v6 = v9;
          if (v8 == 46)
          {
            break;
          }
        }
      }

      TString::SubStringFrom(a1, v7, &v53);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&v52.fString.fRef, &v53.fString.fRef);
      CFRetain(&stru_1F5F42870);
      if (v53.fString.fRef)
      {
        CFRelease(v53.fString.fRef);
      }

      v53.fString.fRef = &stru_1F5F42870;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v53.fString.fRef);
      v6 = v7;
    }

    LODWORD(v40.__r_.__value_.__l.__data_) = 0;
    fRef = a1->fString.fRef;
    v53.fString.fRef = MEMORY[0x1E69E9820];
    v54 = 3321888768;
    v55 = ___ZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRange_block_invoke;
    v56 = &__block_descriptor_40_ea8_32c77_ZTSKZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRangeEUlP8NSStringS3_S3_PbE__e52_v56__0__NSString_8__NSRange_QQ_16__NSRange_QQ_32_B48l;
    v57 = &v40;
    [(__CFString *)fRef enumerateSubstringsInRange:0 options:Length usingBlock:2, &v53];
    data_low = SLODWORD(v40.__r_.__value_.__l.__data_);
    if (data_low - CFStringGetLength(v52.fString.fRef) < 3)
    {
      v35 = CFStringCreateWithBytesNoCopy(*MEMORY[0x1E695E480], "<private>", 9, 0x8000100u, 0, *MEMORY[0x1E695E498]);
      v53.fString.fRef = v35;
      a2->fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      TString::SetStringRefAsImmutable(a2, v35);
      v32 = &v53;
    }

    else
    {
      v50.location = 0;
      v50.length = 0;
      v50.location = [(__CFString *)a1->fString.fRef rangeOfComposedCharacterSequenceAtIndex:0];
      v50.length = v13;
      v49.location = 0;
      v49.length = 0;
      v49.location = [(__CFString *)a1->fString.fRef rangeOfComposedCharacterSequenceAtIndex:v6 - 1];
      v49.length = v14;
      TString::SubString(a1, &v50, &v48);
      TString::SubString(a1, &v49, &v47);
      LODWORD(v40.__r_.__value_.__l.__data_) = 0;
      v15 = a1->fString.fRef;
      v53.fString.fRef = MEMORY[0x1E69E9820];
      v54 = 3321888768;
      v55 = ___ZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRange_block_invoke;
      v56 = &__block_descriptor_40_ea8_32c77_ZTSKZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRangeEUlP8NSStringS3_S3_PbE__e52_v56__0__NSString_8__NSRange_QQ_16__NSRange_QQ_32_B48l;
      v57 = &v40;
      [(__CFString *)v15 enumerateSubstringsInRange:v50.length + v50.location options:v49.location - (v50.length + v50.location) usingBlock:2, &v53];
      data = v40.__r_.__value_.__l.__data_;
      HIBYTE(v55) = 1;
      LOWORD(v53.fString.fRef) = 123;
      v42.fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      if (SHIBYTE(v55) >= 0)
      {
        v17 = &v53;
      }

      else
      {
        v17 = v53.fString.fRef;
      }

      if (SHIBYTE(v55) >= 0)
      {
        v18 = HIBYTE(v55);
      }

      else
      {
        v18 = v54;
      }

      TString::SetFromUTF8(&v42, v17, v18);
      v19 = v48.fString.fRef;
      v43.fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      v20 = *MEMORY[0x1E695E480];
      MutableCopy = CFStringCreateMutableCopy(*MEMORY[0x1E695E480], 0, v19);
      CFRelease(&stru_1F5F42870);
      v43.fString.fRef = MutableCopy;
      TString::Append(&v43, &v42);
      std::to_string(&v40, data);
      v41.fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v22 = &v40;
      }

      else
      {
        v22 = v40.__r_.__value_.__r.__words[0];
      }

      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = v40.__r_.__value_.__l.__size_;
      }

      TString::SetFromUTF8(&v41, v22, size);
      v24 = v43.fString.fRef;
      v44.fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      v25 = CFStringCreateMutableCopy(v20, 0, v24);
      CFRelease(&stru_1F5F42870);
      v44.fString.fRef = v25;
      TString::Append(&v44, &v41);
      v38 = 1;
      LOWORD(__p) = 125;
      v39.fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      TString::SetFromUTF8(&v39, &__p, 1);
      v26 = v44.fString.fRef;
      v45.fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      v27 = CFStringCreateMutableCopy(v20, 0, v26);
      CFRelease(&stru_1F5F42870);
      v45.fString.fRef = v27;
      TString::Append(&v45, &v39);
      v28 = v45.fString.fRef;
      v46.fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      v29 = CFStringCreateMutableCopy(v20, 0, v28);
      CFRelease(&stru_1F5F42870);
      v46.fString.fRef = v29;
      TString::Append(&v46, &v47);
      v30 = v46.fString.fRef;
      a2->fString.fRef = &stru_1F5F42870;
      CFRetain(&stru_1F5F42870);
      v31 = CFStringCreateMutableCopy(v20, 0, v30);
      CFRelease(&stru_1F5F42870);
      a2->fString.fRef = v31;
      TString::Append(a2, &v52);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v46.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v45.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v39.fString.fRef);
      if (v38 < 0)
      {
        operator delete(__p);
      }

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v44.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v41.fString.fRef);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v40.__r_.__value_.__l.__data_);
      }

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v43.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v42.fString.fRef);
      if (SHIBYTE(v55) < 0)
      {
        operator delete(v53.fString.fRef);
      }

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v47.fString.fRef);
      v32 = &v48;
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v32->fString.fRef);
    v34 = &v52;
  }

  else
  {
    v33 = CFStringCreateWithBytesNoCopy(*MEMORY[0x1E695E480], "<empty>", 7, 0x8000100u, 0, *MEMORY[0x1E695E498]);
    v53.fString.fRef = v33;
    a2->fString.fRef = &stru_1F5F42870;
    CFRetain(&stru_1F5F42870);
    TString::SetStringRefAsImmutable(a2, v33);
    v34 = &v53;
  }

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v34->fString.fRef);
}

uint64_t std::unordered_set<TString>::unordered_set(uint64_t a1, TString *this, uint64_t a3)
{
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *(a1 + 32) = 1065353216;
  if (a3)
  {
    v5 = 8 * a3;
    do
    {
      std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__emplace_unique_key_args<TString,TString const&>(a1, this++);
      v5 -= 8;
    }

    while (v5);
  }

  return a1;
}

uint64_t **std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__emplace_unique_key_args<TString,TString const&>(void *a1, TString *this)
{
  v4 = FowlerNollVoHash::hash(this, this);
  v5 = v4;
  v6 = a1[1];
  if (!*&v6)
  {
    goto LABEL_18;
  }

  v7 = vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v6)
    {
      v9 = v4 % *&v6;
    }
  }

  else
  {
    v9 = (*&v6 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_18:
    std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__construct_node_hash<TString const&>();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= *&v6)
      {
        v12 %= *&v6;
      }
    }

    else
    {
      v12 &= *&v6 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_18;
    }

LABEL_17:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_18;
    }
  }

  if (!CFEqual(v11[2], this->fString.fRef))
  {
    goto LABEL_17;
  }

  return v11;
}

void sub_1E56FA5B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::~unique_ptr[abi:ne200100](va);
  _Unwind_Resume(a1);
}

TString *std::__construct_at[abi:ne200100]<TString,TString const&,TString*>(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1F5F42870;
  CFRetain(&stru_1F5F42870);
  TString::SetStringRefAsImmutable(a1, *a2);
  return a1;
}

uint64_t **std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::find<TString>(void *a1, TString *this)
{
  v4 = FowlerNollVoHash::hash(this, this);
  v5 = a1[1];
  if (!*&v5)
  {
    return 0;
  }

  v6 = v4;
  v7 = vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v5)
    {
      v9 = v4 % *&v5;
    }
  }

  else
  {
    v9 = (*&v5 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10)
  {
    return 0;
  }

  for (i = *v10; i; i = *i)
  {
    v12 = i[1];
    if (v6 == v12)
    {
      if (CFEqual(i[2], this->fString.fRef))
      {
        return i;
      }
    }

    else
    {
      if (v8 > 1)
      {
        if (v12 >= *&v5)
        {
          v12 %= *&v5;
        }
      }

      else
      {
        v12 &= *&v5 - 1;
      }

      if (v12 != v9)
      {
        return 0;
      }
    }
  }

  return i;
}

void *TReservationRecord::TReservationRecord(void *result, uint64_t *a2)
{
  v3 = *a2;
  v2 = a2[1];
  *result = 0;
  result[1] = v3;
  result[2] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

uint64_t TReservationRecord::CreateAndAcquireFileCoordinator(TReservationRecord *this, NSFileCoordinator *a2)
{
  v3 = a2;
  if (!*this)
  {
    operator new();
  }

  return 4294959201;
}

TFileCoordinationRecord *std::unique_ptr<TFileCoordinationRecord>::reset[abi:ne200100](TFileCoordinationRecord **a1, TFileCoordinationRecord *a2)
{
  result = *a1;
  *a1 = a2;
  if (result)
  {
    TFileCoordinationRecord::~TFileCoordinationRecord(result);

    JUMPOUT(0x1E692CD30);
  }

  return result;
}

uint64_t __copy_helper_block_ea8_32c62_ZTSKZ49__FINode_fiNodeFromItem_inFPv2Domain_completion__E3__0(void *a1, uint64_t a2)
{
  a1[4] = *(a2 + 32);
  a1[5] = *(a2 + 40);
  result = MEMORY[0x1E692D6D0](*(a2 + 48));
  a1[6] = result;
  return result;
}

void __destroy_helper_block_ea8_32c62_ZTSKZ49__FINode_fiNodeFromItem_inFPv2Domain_completion__E3__0(uint64_t a1)
{
  v2 = *(a1 + 32);
}

void sub_1E56FBAA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va);

  _Unwind_Resume(a1);
}

id objc_cast<ISIcon,NSObject * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v2 = a1;
  }

  else
  {
    v2 = 0;
  }

  return v2;
}

uint64_t FINodeSizingSkipProc(const __CFURL *a1, const __CFURL *a2, void *a3)
{
  v5 = static_objc_cast<DSFileServiceConnection,void *>(a3);
  if (objc_opt_respondsToSelector())
  {
    v6 = [v5 FINodeSizingSkip:a1 forParent:a2];
  }

  else
  {
    v6 = 0;
  }

  return v6;
}

uint64_t FINodeSizingCancelProc(void *a1)
{
  v1 = static_objc_cast<DSFileServiceConnection,void *>(a1);
  if (objc_opt_respondsToSelector())
  {
    v2 = [v1 FINodeSizingCancel];
  }

  else
  {
    v2 = 0;
  }

  return v2;
}

void NodeDisposeNodeRef(CFTypeRef cf)
{
  if (cf)
  {
    CFRelease(cf);
  }
}

void sub_1E56FD6B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va);

  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne200100]<FIProviderDomain * {__strong},FPItem * const {__strong}&,BOOL,std::allocator<TFSInfo>,0>(uint64_t a1, FIProviderDomain **a2, FPItem **a3, unsigned __int8 *a4)
{
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *a1 = &unk_1F5F3D3B8;
  TFSInfo::TFSInfo((a1 + 24), *a2, *a3, *a4);
  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = v3;
  *a1 = v3;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 120) = -1;
  *(a1 + 104) = 0;
  *(a1 + 112) = -1;
  *(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(a1 + 112) = [*a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(a1 + 104) = **(a1 + 24);
    *(a1 + 120) = 0;
    *(a1 + 128) = 0;
  }

  else
  {
    *(a1 + 128) = 0;
  }

  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(a1, a2);
  if (a3 >= 1)
  {
    v5 = *(a1 + 120);
    do
    {
      if (v5 >= *(a1 + 112) - 1)
      {
        v6 = [*a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
        v5 = -1;
        *(a1 + 112) = v6;
        *(a1 + 120) = -1;
      }

      if (*(a1 + 104) != **(a1 + 24))
      {
        objc_enumerationMutation(*a1);
        v5 = *(a1 + 120);
      }

      v7 = *(a1 + 128) + 1;
      *(a1 + 120) = ++v5;
      *(a1 + 128) = v7;
      --a3;
    }

    while (a3);
  }

  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  *a1 = v4;
  *(a1 + 8) = 0u;
  *(a1 + 104) = 0;
  *(a1 + 112) = -1;
  v5 = (a1 + 112);
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 120) = -1;
  v6 = (a1 + 120);
  *(a1 + 128) = -1;
  if (v4 && [v4 count] && (v7 = *(a2 + 128), v7 < objc_msgSend(*a1, "count")))
  {
    v8 = [*a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(a1 + 112) = v8;
    *(a1 + 104) = **(a1 + 24);
    *v6 = 0;
    *(a1 + 128) = 0;
    v9 = *(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *v5 = [*a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
            v11 = -1;
            *v6 = -1;
          }

          if (*(a1 + 104) != **(a1 + 24))
          {
            objc_enumerationMutation(*a1);
            v11 = *v6;
          }

          v13 = *(a1 + 128) + 1;
          *(a1 + 120) = ++v11;
          *(a1 + 128) = v13;
          ++v12;
        }

        while (*(a2 + 128) > v12);
      }
    }

    else
    {
      *(a1 + 120) = *(a2 + 120);
      *(a1 + 128) = v9;
    }
  }

  else
  {
    *v6 = *(a2 + 120);
  }

  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  *a1 = v4;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 104) = 0;
  *(a1 + 112) = -1;
  *(a1 + 120) = -1;
  *(a1 + 128) = -1;
  *(a1 + 128) = [v4 count];

  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPItem *>>::NSForwardIterator<NSArray<FPItem *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = v3;
  *a1 = v3;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 120) = -1;
  *(a1 + 104) = 0;
  *(a1 + 112) = -1;
  *(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(a1 + 112) = [*a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(a1 + 104) = **(a1 + 24);
    *(a1 + 120) = 0;
    *(a1 + 128) = 0;
  }

  else
  {
    *(a1 + 128) = 0;
  }

  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPItem *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  *a1 = v4;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 104) = 0;
  *(a1 + 112) = -1;
  *(a1 + 120) = -1;
  *(a1 + 128) = -1;
  *(a1 + 128) = [v4 count];

  return a1;
}

id __copy_helper_block_ea8_32c54_ZTSKZL30DefaultContainerOfDomainWithIDRK7TStringE3__0(uint64_t a1, uint64_t a2)
{
  result = *(a2 + 32);
  *(a1 + 32) = result;
  return result;
}

id DSLocalizationBundle(void)
{
  if (DSLocalizationBundle(void)::onceToken != -1)
  {
    DSLocalizationBundle();
  }

  v1 = DSLocalizationBundle(void)::bundle;

  return v1;
}

void ___Z20DSLocalizationBundlev_block_invoke()
{
  v0 = [MEMORY[0x1E696AAE8] bundleForClass:objc_opt_class()];
  v1 = DSLocalizationBundle(void)::bundle;
  DSLocalizationBundle(void)::bundle = v0;
}

id DSLocalizedErrorStringForKey(NSString *a1)
{
  v14 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = DSLocalizationBundle();
  v3 = [v2 localizedStringForKey:v1 value:@"X" table:0];

  if ([v3 isEqualToString:@"X"])
  {
    v4 = LogObj(2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = DSLocalizationBundle();
      v6 = [v5 bundlePath];
      *buf = 138543618;
      v11 = v1;
      v12 = 2114;
      v13 = v6;
      _os_log_impl(&dword_1E5674000, v4, OS_LOG_TYPE_ERROR, "Localized key '%{public}@' missing from DesktopServices (bundlePath:%{public}@)", buf, 0x16u);
    }

    v7 = [MEMORY[0x1E696AEC0] stringWithFormat:@"KEY_MISSING(%@)", v1];

    v3 = v7;
  }

  v8 = *MEMORY[0x1E69E9840];

  return v3;
}

void sub_1E56FE068(_Unwind_Exception *a1)
{
  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1E56FEAA0(_Unwind_Exception *a1)
{
  MEMORY[0x1E692CD30](v2, 0x10E1C4078A9A281);

  _Unwind_Resume(a1);
}

void sub_1E56FEE4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  v12 = va_arg(va1, const void *);
  v14 = va_arg(va1, void);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va1);

  _Unwind_Resume(a1);
}

void sub_1E56FF2A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  TRef<__CFUserNotification *,TRetainReleasePolicy<__CFUserNotification *>>::~TRef(va);

  _Unwind_Resume(a1);
}

void sub_1E56FFC54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va);
  _Unwind_Resume(a1);
}

void sub_1E56FFED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va);
  _Unwind_Resume(a1);
}

void sub_1E5700FA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, void *a23, void *a24, void *a25, void *a26, uint64_t a27, void *a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *a34, uint64_t a35, void *a36, void *a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, id a51, uint64_t a52, uint64_t a53, std::__shared_weak_count *a54, id a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, uint64_t a60, uint64_t a61, uint64_t a62, uint64_t a63)
{
  StScopedResourceAccess::~StScopedResourceAccess(&a51);

  if (a54)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a54);
  }

  StScopedResourceAccess::~StScopedResourceAccess(&a55);

  if (a66)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](a66);
  }

  _Unwind_Resume(a1);
}

void sub_1E5701ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *a28, void *a29, uint64_t a30, uint64_t a31, void *a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, id a53, uint64_t a54, id a55)
{
  StScopedResourceAccess::~StScopedResourceAccess(&a53);

  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c102_ZTSKZ89__DSNSHelperContext_copyItemsAtURLs_toURL_options_conflictStrategy_receiveTargets_error__E3__1(__n128 *a1, __n128 *a2)
{
  result = a2[2];
  a1[2] = result;
  return result;
}

void StScopedResourceAccess::StScopedResourceAccess(StScopedResourceAccess *this, NSURL *a2)
{
  v3 = a2;
  *this = v3;
  v4 = [(NSURL *)v3 startAccessingSecurityScopedResource];
  *(this + 8) = v4;
  if (*this != 0 && !v4)
  {
    v5 = LogObj(2);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *v6 = 0;
      _os_log_impl(&dword_1E5674000, v5, OS_LOG_TYPE_ERROR, "Failed to access security-scoped resource.", v6, 2u);
    }
  }
}

void StScopedResourceAccess::~StScopedResourceAccess(id *this)
{
  if (*(this + 8) == 1)
  {
    [*this stopAccessingSecurityScopedResource];
  }
}

const void **TRef<__CFUserNotification *,TRetainReleasePolicy<__CFUserNotification *>>::~TRef(const void **a1)
{
  v2 = *a1;
  if (v2)
  {
    CFRelease(v2);
  }

  return a1;
}

void *Signpost(void)
{
  {
    TSignpostInterval_FIOperation_FetchNodeAsync::TSignpostInterval_FIOperation_FetchNodeAsync(&Signpost(void)::gFetchNodeAsyncSignpost);
  }

  return &Signpost(void)::gFetchNodeAsyncSignpost;
}

void sub_1E5702460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, id a11)
{
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a10);

  _Unwind_Resume(a1);
}

void sub_1E57025E0(_Unwind_Exception *a1)
{
  v5 = v4;

  _Unwind_Resume(a1);
}

id objc_cast<FINode,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v2 = a1;
  }

  else
  {
    v2 = 0;
  }

  return v2;
}

void sub_1E5702984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = FIOperation;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1E5702AFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);

  _Unwind_Resume(a1);
}

void sub_1E5702B88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);

  _Unwind_Resume(a1);
}

uint64_t OperationUniqueNameProc(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  v5 = a1;
  v6 = [MEMORY[0x1E696AEC0] ds_fileNameHasClaimedFileExtension:v5];
  v12 = &unk_1F5F4A388;
  v7 = [v5 fp_stringByDeletingPathBounceNo:&v12 andPathExtension:0 isFolder:v6 ^ 1u];
  v8 = v12;
  v9 = [v7 fp_bouncedNameWithIndex:objc_msgSend(v8 isDir:{"integerValue") + 1, v6 ^ 1u}];

  *a4 = v9;
  v10 = v9;

  return 0;
}

void sub_1E5702FA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(va);
  _Unwind_Resume(a1);
}

void sub_1E570319C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26)
{
  objc_sync_exit(v27);

  _Unwind_Resume(a1);
}

void sub_1E570335C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1E5704D5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, id location)
{
  objc_destroyWeak(&a9);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_1E5705188(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26)
{
  objc_sync_exit(v26);

  _Unwind_Resume(a1);
}

void sub_1E5705A48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, void *a40, id location, uint64_t a42, id a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, uint64_t a60)
{
  objc_destroyWeak(&location);
  std::__shared_weak_count::__release_shared[abi:ne200100](v61);
  std::__shared_weak_count::__release_shared[abi:ne200100](v61);

  _Unwind_Resume(a1);
}

void TSignpostInterval_FIOperation_FetchNodeAsync::Begin<char [30],NSString * {__strong},unsigned long>(std::mutex *a1, uint64_t a2)
{
  v3 = *MEMORY[0x1E69E9840];
  v2 = a2;
  std::mutex::lock(a1);
  operator new();
}

void sub_1E5705C80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne200100](va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

void sub_1E5705FD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  [FIOperation fetchNodesAsyncFor:completion:]::$_21::operator() const(void)::{lambda(FINode *,NSError *)#1}::~NSError((v11 + 32));
  [FIOperation fetchNodesAsyncFor:completion:]::$_21::operator() const(void)::{lambda(FINode *,NSError *)#1}::~NSError(&a9);

  [FIOperation fetchNodesAsyncFor:completion:]::$_21::operator() const(void)::{lambda(FINode *,NSError *)#1}::~NSError((v12 - 104));
  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c59_ZTSKZ45__FIOperation_fetchNodesAsyncFor_completion__E4__21(uint64_t a1, uint64_t a2)
{
  *(a1 + 32) = *(a2 + 32);
  v4 = *(a2 + 40);
  v5 = *(a2 + 48);
  *(a1 + 40) = v4;
  *(a1 + 48) = v5;
  v6 = *(a2 + 64);
  *(a1 + 56) = *(a2 + 56);
  *(a1 + 64) = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 72) = *(a2 + 72);

  objc_copyWeak((a1 + 80), (a2 + 80));
}

void __destroy_helper_block_ea8_32c59_ZTSKZ45__FIOperation_fetchNodesAsyncFor_completion__E4__21(uint64_t a1)
{
  objc_destroyWeak((a1 + 80));

  v2 = *(a1 + 64);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  v3 = *(a1 + 32);
}

void __copy_helper_block_ea8_32c59_ZTSKZ45__FIOperation_fetchNodesAsyncFor_completion__E4__22(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((a1 + 32), (a2 + 32));
  v4 = *(a2 + 48);
  *(a1 + 40) = *(a2 + 40);
  *(a1 + 48) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
  }

  std::__function::__value_func<void ()(std::vector<std::optional<FINode * {__strong}>> const&)>::__value_func[abi:ne200100](a1 + 56, a2 + 56);
  v5 = *(a2 + 96);
  *(a1 + 88) = *(a2 + 88);
  *(a1 + 96) = v5;

  objc_copyWeak((a1 + 104), (a2 + 104));
}

void sub_1E570634C(_Unwind_Exception *a1)
{
  v3 = *(v1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v3);
  }

  objc_destroyWeak((v1 + 32));
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c59_ZTSKZ45__FIOperation_fetchNodesAsyncFor_completion__E4__22(uint64_t a1)
{
  objc_destroyWeak((a1 + 104));

  std::__function::__value_func<void ()(std::vector<std::optional<FINode * {__strong}>> const&)>::~__value_func[abi:ne200100](a1 + 56);
  v2 = *(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne200100](v2);
  }

  objc_destroyWeak((a1 + 32));
}

void sub_1E5706658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26)
{
  objc_sync_exit(v26);

  _Unwind_Resume(a1);
}

void TSignpostInterval_FIOperation_FetchNodeAsync::TSignpostInterval_FIOperation_FetchNodeAsync(TSignpostInterval_FIOperation_FetchNodeAsync *this)
{
  v2 = LogObj(8);
  TString::TString(&v3, "FetchNodeAsync");
  ISignpostInterval::ISignpostInterval(this, v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v3.fString.fRef);
}

void sub_1E5706BC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(va);

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FIOperationRecord *>>::NSForwardIterator<NSArray<FIOperationRecord *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = v3;
  *a1 = v3;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 120) = -1;
  *(a1 + 104) = 0;
  *(a1 + 112) = -1;
  *(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(a1 + 112) = [*a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(a1 + 104) = **(a1 + 24);
    *(a1 + 120) = 0;
    *(a1 + 128) = 0;
  }

  else
  {
    *(a1 + 128) = 0;
  }

  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSArray<FIOperationRecord *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  *a1 = v4;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 104) = 0;
  *(a1 + 112) = -1;
  *(a1 + 120) = -1;
  *(a1 + 128) = -1;
  *(a1 + 128) = [v4 count];

  return a1;
}

void ___ZZ33__FIOperation_createOperationRef_ENK3__6cvU13block_pointerFv15OperationStatusEEv_block_invoke(uint64_t a1, int *a2)
{
  v22 = *MEMORY[0x1E69E9840];
  v4 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  v14[0] = MEMORY[0x1E69E9820];
  v14[1] = 3321888768;
  v14[2] = ___ZZ33__FIOperation_createOperationRef_ENK3__6clE15OperationStatus_block_invoke;
  v14[3] = &__block_descriptor_1128_ea8_32c75_ZTSKZZ33__FIOperation_createOperationRef_ENK3__6clE15OperationStatusEUlvE__e5_v8__0l;
  objc_copyWeak(&to, (a1 + 32));
  v8 = *a2;
  v5 = *(a2 + 262);
  v10 = *(a2 + 258);
  v11 = v5;
  v12 = *(a2 + 266);
  v13 = *(a2 + 135);
  strlcpy(v9, a2 + 4, 0x400uLL);
  objc_copyWeak(&v15, &to);
  v16 = v8;
  v18 = v10;
  v19 = v11;
  v20 = v12;
  v21 = v13;
  strlcpy(v17, v9, 0x400uLL);
  [v4 callOnOperationQueue:v14];
  objc_destroyWeak(&to);

  objc_destroyWeak(&v15);
  v6 = *MEMORY[0x1E69E9840];
}

void sub_1E5706F90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  objc_destroyWeak((v11 + 32));
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

id TNSWeakPtr<FIOperation>::Lock(id *a1)
{
  WeakRetained = objc_loadWeakRetained(a1);
  if ((objc_opt_respondsToSelector() & 1) != 0 && [WeakRetained isTornDown])
  {

    WeakRetained = 0;
  }

  return WeakRetained;
}

void ___ZZ33__FIOperation_createOperationRef_ENK3__6clE15OperationStatus_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  [v2 statusChangedHandlerPriv:a1 + 40];
}

size_t __copy_helper_block_ea8_32c75_ZTSKZZ33__FIOperation_createOperationRef_ENK3__6clE15OperationStatusEUlvE_(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((a1 + 32), (a2 + 32));
  *(a1 + 40) = *(a2 + 40);
  *(a1 + 1072) = *(a2 + 1072);
  *(a1 + 1088) = *(a2 + 1088);
  *(a1 + 1104) = *(a2 + 1104);
  *(a1 + 1120) = *(a2 + 1120);
  return strlcpy((a1 + 44), (a2 + 44), 0x400uLL);
}

void ___ZZ33__FIOperation_createOperationRef_ENK3__7cvU13block_pointerFvvEEv_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3321888768;
  v4[2] = ___ZZ33__FIOperation_createOperationRef_ENK3__7clEv_block_invoke;
  v4[3] = &__block_descriptor_40_ea8_32c59_ZTSKZZ33__FIOperation_createOperationRef_ENK3__7clEvEUlvE__e5_v8__0l;
  objc_copyWeak(&v3, (a1 + 32));
  objc_copyWeak(&v5, &v3);
  [v2 callOnOperationQueue:v4];
  objc_destroyWeak(&v3);

  objc_destroyWeak(&v5);
}

void sub_1E57071EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  objc_destroyWeak((v10 + 32));
  objc_destroyWeak(&a9);

  _Unwind_Resume(a1);
}

void ___ZZ33__FIOperation_createOperationRef_ENK3__7clEv_block_invoke(uint64_t a1)
{
  v1 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  [v1 operationCompleted];
}

void ___ZZ33__FIOperation_createOperationRef_ENK4__10cvU13block_pointerFvP20OperationErrorRecordEEv_block_invoke(uint64_t a1, void *a2)
{
  v4 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  v7[0] = MEMORY[0x1E69E9820];
  v7[1] = 3321888768;
  v7[2] = ___ZZ33__FIOperation_createOperationRef_ENK4__10clEP20OperationErrorRecord_block_invoke;
  v7[3] = &__block_descriptor_48_ea8_32c82_ZTSKZZ33__FIOperation_createOperationRef_ENK4__10clEP20OperationErrorRecordEUlvE__e5_v8__0l;
  objc_copyWeak(&v5, (a1 + 32));
  v6 = a2;
  objc_copyWeak(v8, &v5);
  v8[1] = v6;
  [v4 callOnOperationQueue:v7];
  objc_destroyWeak(&v5);

  objc_destroyWeak(v8);
}

void sub_1E5707360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  objc_destroyWeak((v10 + 32));
  objc_destroyWeak(&a9);

  _Unwind_Resume(a1);
}

void ___ZZ33__FIOperation_createOperationRef_ENK4__10clEP20OperationErrorRecord_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  [v2 warningHandler:*(a1 + 40)];
}

void ___ZZ33__FIOperation_createOperationRef_ENK3__8cvU13block_pointerFvP20OperationErrorRecordPK17OperationIteratorEEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  v9[0] = MEMORY[0x1E69E9820];
  v9[1] = 3321888768;
  v9[2] = ___ZZ33__FIOperation_createOperationRef_ENK3__8clEP20OperationErrorRecordPK17OperationIterator_block_invoke;
  v9[3] = &__block_descriptor_56_ea8_32c102_ZTSKZZ33__FIOperation_createOperationRef_ENK3__8clEP20OperationErrorRecordPK17OperationIteratorEUlvE__e5_v8__0l;
  objc_copyWeak(&v7, (a1 + 32));
  *&v8 = a2;
  *(&v8 + 1) = a3;
  objc_copyWeak(&v10, &v7);
  v11 = v8;
  [v6 callOnOperationQueue:v9];
  objc_destroyWeak(&v7);

  objc_destroyWeak(&v10);
}

void sub_1E5707514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  objc_destroyWeak((v10 + 32));
  objc_destroyWeak(&a9);

  _Unwind_Resume(a1);
}

void ___ZZ33__FIOperation_createOperationRef_ENK3__8clEP20OperationErrorRecordPK17OperationIterator_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  [v2 conflictHandler:*(a1 + 40) conflictIter:*(a1 + 48)];
}

__n128 __copy_helper_block_ea8_32c102_ZTSKZZ33__FIOperation_createOperationRef_ENK3__8clEP20OperationErrorRecordPK17OperationIteratorEUlvE_(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((a1 + 32), (a2 + 32));
  result = *(a2 + 40);
  *(a1 + 40) = result;
  return result;
}

void ___ZZ33__FIOperation_createOperationRef_ENK3__9cvU13block_pointerFvP20OperationErrorRecordPK17OperationIteratorEEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a2 + 1040);
  if (IsUserCancelledErr(v6) || *a2 == -128)
  {
    v7 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
    [v7 markAsCancelled];
  }

  else
  {
    v8 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
    v11[0] = MEMORY[0x1E69E9820];
    v11[1] = 3321888768;
    v11[2] = ___ZZ33__FIOperation_createOperationRef_ENK3__9clEP20OperationErrorRecordPK17OperationIterator_block_invoke;
    v11[3] = &__block_descriptor_56_ea8_32c102_ZTSKZZ33__FIOperation_createOperationRef_ENK3__9clEP20OperationErrorRecordPK17OperationIteratorEUlvE__e5_v8__0l;
    objc_copyWeak(&v9, (a1 + 32));
    *&v10 = a2;
    *(&v10 + 1) = a3;
    objc_copyWeak(&v12, &v9);
    v13 = v10;
    [v8 callOnOperationQueue:v11];
    objc_destroyWeak(&v9);

    objc_destroyWeak(&v12);
  }
}

void sub_1E5707708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  objc_destroyWeak((v11 + 32));
  objc_destroyWeak(&a9);

  _Unwind_Resume(a1);
}

void ___ZZ33__FIOperation_createOperationRef_ENK3__9clEP20OperationErrorRecordPK17OperationIterator_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  [v2 errorHandler:*(a1 + 40) errorIter:*(a1 + 48)];
}

__n128 __copy_helper_block_ea8_32c102_ZTSKZZ33__FIOperation_createOperationRef_ENK3__9clEP20OperationErrorRecordPK17OperationIteratorEUlvE_(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((a1 + 32), (a2 + 32));
  result = *(a2 + 40);
  *(a1 + 40) = result;
  return result;
}

void ___ZZ33__FIOperation_createOperationRef_ENK4__11cvU13block_pointerFv16NodeSuboperationEEv_block_invoke(uint64_t a1, int a2)
{
  v4 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  v7[0] = MEMORY[0x1E69E9820];
  v7[1] = 3321888768;
  v7[2] = ___ZZ33__FIOperation_createOperationRef_ENK4__11clE16NodeSuboperation_block_invoke;
  v7[3] = &__block_descriptor_48_ea8_32c77_ZTSKZZ33__FIOperation_createOperationRef_ENK4__11clE16NodeSuboperationEUlvE__e5_v8__0l;
  objc_copyWeak(&v5, (a1 + 32));
  v6 = a2;
  objc_copyWeak(&v8, &v5);
  v9 = v6;
  [v4 callOnOperationQueue:v7];
  objc_destroyWeak(&v5);

  objc_destroyWeak(&v8);
}

void sub_1E57078C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  objc_destroyWeak((v10 + 32));
  objc_destroyWeak(&a9);

  _Unwind_Resume(a1);
}

void ___ZZ33__FIOperation_createOperationRef_ENK4__11clE16NodeSuboperation_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  [v2 subOperationStartedHandler:*(a1 + 40)];
}

void ___ZZ33__FIOperation_createOperationRef_ENK4__12cvU13block_pointerFv16NodeSuboperationP13OpaqueNodeRefEEv_block_invoke(uint64_t a1, int a2, void *a3)
{
  v5 = a3;
  v6 = v5;
  if (v5)
  {
    NodeDisposeNodeRef(v5);
  }

  v7 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  v12[0] = MEMORY[0x1E69E9820];
  v12[1] = 3321888768;
  v12[2] = ___ZZ33__FIOperation_createOperationRef_ENK4__12clE16NodeSuboperationP13OpaqueNodeRef_block_invoke;
  v12[3] = &__block_descriptor_56_ea8_32c93_ZTSKZZ33__FIOperation_createOperationRef_ENK4__12clE16NodeSuboperationP13OpaqueNodeRefEUlvE__e5_v8__0l;
  objc_copyWeak(&v9, (a1 + 32));
  v10 = a2;
  v8 = v6;
  v11 = v8;
  objc_copyWeak(&v13, &v9);
  v14 = v10;
  v15 = v11;
  [v7 callOnOperationQueue:v12];

  objc_destroyWeak(&v9);
  objc_destroyWeak(&v13);
}

void sub_1E5707AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9, uint64_t a10, id a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
  objc_destroyWeak((v20 + 32));

  objc_destroyWeak(&a9);
  _Unwind_Resume(a1);
}

void ___ZZ33__FIOperation_createOperationRef_ENK4__12clE16NodeSuboperationP13OpaqueNodeRef_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  [v2 subOperationCompletedHandler:*(a1 + 40) targetNode:*(a1 + 48)];
}

id __copy_helper_block_ea8_32c93_ZTSKZZ33__FIOperation_createOperationRef_ENK4__12clE16NodeSuboperationP13OpaqueNodeRefEUlvE_(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((a1 + 32), (a2 + 32));
  *(a1 + 40) = *(a2 + 40);
  result = *(a2 + 48);
  *(a1 + 48) = result;
  return result;
}

void __destroy_helper_block_ea8_32c93_ZTSKZZ33__FIOperation_createOperationRef_ENK4__12clE16NodeSuboperationP13OpaqueNodeRefEUlvE_(uint64_t a1)
{

  objc_destroyWeak((a1 + 32));
}

void ___ZZ27__FIOperation_makeProgress_ENK4__13cvU13block_pointerFvvEEv_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3321888768;
  v4[2] = ___ZZ27__FIOperation_makeProgress_ENK4__13clEv_block_invoke;
  v4[3] = &__block_descriptor_40_ea8_32c54_ZTSKZZ27__FIOperation_makeProgress_ENK4__13clEvEUlvE__e5_v8__0l;
  objc_copyWeak(&v3, (a1 + 32));
  objc_copyWeak(&v5, &v3);
  [v2 callOnOperationQueue:v4];
  objc_destroyWeak(&v3);

  objc_destroyWeak(&v5);
}

void sub_1E5707CAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  objc_destroyWeak((v10 + 32));
  objc_destroyWeak(&a9);

  _Unwind_Resume(a1);
}

void ___ZZ27__FIOperation_makeProgress_ENK4__13clEv_block_invoke(uint64_t a1)
{
  v1 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  if (v1)
  {
    NodeCancelOperation([v1 operationRef]);
  }
}

void ___ZZ27__FIOperation_makeProgress_ENK4__14cvU13block_pointerFvvEEv_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3321888768;
  v4[2] = ___ZZ27__FIOperation_makeProgress_ENK4__14clEv_block_invoke;
  v4[3] = &__block_descriptor_40_ea8_32c54_ZTSKZZ27__FIOperation_makeProgress_ENK4__14clEvEUlvE__e5_v8__0l;
  objc_copyWeak(&v3, (a1 + 32));
  objc_copyWeak(&v5, &v3);
  [v2 callOnOperationQueue:v4];
  objc_destroyWeak(&v3);

  objc_destroyWeak(&v5);
}

void sub_1E5707E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  objc_destroyWeak((v10 + 32));
  objc_destroyWeak(&a9);

  _Unwind_Resume(a1);
}

void ___ZZ27__FIOperation_makeProgress_ENK4__14clEv_block_invoke(uint64_t a1)
{
  v1 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  if (v1)
  {
    NodePauseOperation([v1 operationRef]);
  }
}

void ___ZZ27__FIOperation_makeProgress_ENK4__15cvU13block_pointerFvvEEv_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3321888768;
  v4[2] = ___ZZ27__FIOperation_makeProgress_ENK4__15clEv_block_invoke;
  v4[3] = &__block_descriptor_40_ea8_32c54_ZTSKZZ27__FIOperation_makeProgress_ENK4__15clEvEUlvE__e5_v8__0l;
  objc_copyWeak(&v3, (a1 + 32));
  objc_copyWeak(&v5, &v3);
  [v2 callOnOperationQueue:v4];
  objc_destroyWeak(&v3);

  objc_destroyWeak(&v5);
}

void sub_1E5707F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  objc_destroyWeak((v10 + 32));
  objc_destroyWeak(&a9);

  _Unwind_Resume(a1);
}

void ___ZZ27__FIOperation_makeProgress_ENK4__15clEv_block_invoke(uint64_t a1)
{
  v1 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  if (v1)
  {
    NodeResumeOperation([v1 operationRef]);
  }
}

id ___ZZ27__FIOperation_makeProgress_ENK4__16cvU13block_pointerFU13block_pointerFvvEP10NSProgressEEv_block_invoke(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  v5 = FileURL(v3);
  v6 = 0;
  v20 = v5;
  if (v4 && v5)
  {
    v7 = [(NSProgress *)v3 kind];
    v8 = [v7 isEqualToString:*MEMORY[0x1E696A888]];

    if ((v8 & 1) == 0)
    {
LABEL_6:
      v6 = 0;
      goto LABEL_7;
    }

    v9 = v4;
    objc_sync_enter(v9);
    if (std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::find<NSURL * {__strong}>(v9 + 1, &v20))
    {
      objc_sync_exit(v9);

      goto LABEL_6;
    }

    to = 0;
    v22[0] = 0;
    v17[0] = &v20;
    v11 = std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::__emplace_unique_key_args<NSURL * {__strong},std::piecewise_construct_t const&,std::tuple<NSURL * const {__strong}&>,std::tuple<>>(v9 + 1, &v20);
    v12 = to;
    to = 0;
    v13 = v11[3];
    v11[3] = v12;

    TNSWeakPtr<FINode>::operator=(v11 + 4, v22);
    objc_destroyWeak(v22);

    [v9 setChildProgressHighWaterMark:{objc_msgSend(v9, "childProgressHighWaterMark") + 1}];
    v17[0] = MEMORY[0x1E69E9820];
    v17[1] = 3321888768;
    v17[2] = ___ZZ27__FIOperation_makeProgress_ENK4__16clEP10NSProgress_block_invoke;
    v17[3] = &__block_descriptor_48_ea8_32c66_ZTSKZZ27__FIOperation_makeProgress_ENK4__16clEP10NSProgressEUlvE__e5_v8__0l;
    objc_copyWeak(&to, (a1 + 32));
    v22[0] = v3;
    objc_copyWeak(&v18, &to);
    v19 = v22[0];
    [v9 callOnOperationQueue:v17];

    objc_destroyWeak(&to);
    objc_destroyWeak(&v18);
    objc_sync_exit(v9);

    objc_copyWeak(&from, (a1 + 32));
    v16 = v20;
    to = MEMORY[0x1E69E9820];
    v22[0] = 3321888768;
    v22[1] = ___ZZZ27__FIOperation_makeProgress_ENK4__16clEP10NSProgressENKUlvE0_cvU13block_pointerFvvEEv_block_invoke;
    v22[2] = &__block_descriptor_48_ea8_32c67_ZTSKZZ27__FIOperation_makeProgress_ENK4__16clEP10NSProgressEUlvE0__e5_v8__0l;
    objc_copyWeak(&v23, &from);
    v24 = v16;
    v14 = MEMORY[0x1E692D6D0](&to);

    objc_destroyWeak(&v23);
    v6 = MEMORY[0x1E692D6D0](v14);

    objc_destroyWeak(&from);
  }

LABEL_7:

  return v6;
}

void sub_1E5708304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, id location, void *a20)
{
  objc_destroyWeak((v23 + 32));

  objc_destroyWeak(&location);
  objc_sync_exit(v22);

  _Unwind_Resume(a1);
}

id FileURL(NSProgress *a1)
{
  v1 = a1;
  v2 = [(NSProgress *)v1 fileURL];
  if (!v2)
  {
    v3 = [(NSProgress *)v1 userInfo];
    v4 = [v3 objectForKeyedSubscript:*MEMORY[0x1E696A880]];
    v2 = static_objc_cast<NSString,objc_object * {__strong}>(v4);
  }

  return v2;
}

void ___ZZ27__FIOperation_makeProgress_ENK4__16clEP10NSProgress_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  if (v2)
  {
    v4 = *(a1 + 40);
    v3 = (a1 + 40);
    v5 = FileURL(v4);
    v16[0] = v5;
    v15 = [FINode fiNodeFromURL:v5];
    if (v15)
    {
      v6 = v2;
      objc_sync_enter(v6);
      std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>::pair[abi:ne200100]<NSProgress * const {__strong}&,FINode* {__strong}&,0>(&v13, v3, &v15);
      v16[2] = v16;
      v7 = std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::__emplace_unique_key_args<NSURL * {__strong},std::piecewise_construct_t const&,std::tuple<NSURL * const {__strong}&>,std::tuple<>>(v6 + 1, v16);
      v8 = v13;
      v13 = 0;
      v9 = v7[3];
      v7[3] = v8;

      TNSWeakPtr<FINode>::operator=(v7 + 4, &v14);
      objc_destroyWeak(&v14);

      objc_sync_exit(v6);
      v10 = [v6 progress];
      v11 = *v3;
      v12 = [*v3 byteTotalCount];
      [v10 addChild:v11 withPendingUnitCount:{objc_msgSend(v12, "longLongValue")}];

      v5 = v16[0];
    }
  }
}

id __copy_helper_block_ea8_32c66_ZTSKZZ27__FIOperation_makeProgress_ENK4__16clEP10NSProgressEUlvE_(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((a1 + 32), (a2 + 32));
  result = *(a2 + 40);
  *(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_ea8_32c66_ZTSKZZ27__FIOperation_makeProgress_ENK4__16clEP10NSProgressEUlvE_(uint64_t a1)
{

  objc_destroyWeak((a1 + 32));
}

uint64_t **std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::find<NSURL * {__strong}>(void *a1, const void **a2)
{
  v4 = Hash(*a2);
  v5 = a1[1];
  if (!*&v5)
  {
    return 0;
  }

  v6 = v4;
  v7 = vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v5)
    {
      v9 = v4 % *&v5;
    }
  }

  else
  {
    v9 = (*&v5 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10)
  {
    return 0;
  }

  for (i = *v10; i; i = *i)
  {
    v12 = i[1];
    if (v6 == v12)
    {
      if (std::equal_to<NSURL * {__strong}>::operator()(a1, i[2], *a2))
      {
        return i;
      }
    }

    else
    {
      if (v8 > 1)
      {
        if (v12 >= *&v5)
        {
          v12 = (v12 % *&v5);
        }
      }

      else
      {
        v12 = (v12 & (*&v5 - 1));
      }

      if (v12 != v9)
      {
        return 0;
      }
    }
  }

  return i;
}

{
  v4 = Hash(*a2);
  v5 = a1[1];
  if (!*&v5)
  {
    return 0;
  }

  v6 = v4;
  v7 = vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v5)
    {
      v9 = v4 % *&v5;
    }
  }

  else
  {
    v9 = (*&v5 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10)
  {
    return 0;
  }

  for (i = *v10; i; i = *i)
  {
    v12 = i[1];
    if (v12 == v6)
    {
      if (std::equal_to<NSURL * {__strong}>::operator()(a1, i[2], *a2))
      {
        return i;
      }
    }

    else
    {
      if (v8 > 1)
      {
        if (v12 >= *&v5)
        {
          v12 = (v12 % *&v5);
        }
      }

      else
      {
        v12 = (v12 & (*&v5 - 1));
      }

      if (v12 != v9)
      {
        return 0;
      }
    }
  }

  return i;
}

uint64_t **std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::__emplace_unique_key_args<NSURL * {__strong},std::piecewise_construct_t const&,std::tuple<NSURL * const {__strong}&>,std::tuple<>>(void *a1, const void **a2)
{
  v4 = Hash(*a2);
  v5 = v4;
  v6 = a1[1];
  if (!*&v6)
  {
    goto LABEL_18;
  }

  v7 = vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v6)
    {
      v9 = v4 % *&v6;
    }
  }

  else
  {
    v9 = (*&v6 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_18:
    std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<NSURL * const {__strong}&>,std::tuple<>>();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= *&v6)
      {
        v12 = (v12 % *&v6);
      }
    }

    else
    {
      v12 = (v12 & (*&v6 - 1));
    }

    if (v12 != v9)
    {
      goto LABEL_18;
    }

LABEL_17:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_18;
    }
  }

  if ((std::equal_to<NSURL * {__strong}>::operator()(a1, v11[2], *a2) & 1) == 0)
  {
    goto LABEL_17;
  }

  return v11;
}

void sub_1E5708A00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p)
  {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,void *>>>::operator()[abi:ne200100](&a11, __p);
  }

  _Unwind_Resume(exception_object);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,void *>>>::operator()[abi:ne200100](uint64_t a1, void **__p)
{
  if (*(a1 + 8) == 1)
  {
    std::allocator_traits<std::allocator<std::__hash_node<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,void *>>>::destroy[abi:ne200100]<std::pair<NSURL * const {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,void,0>(*a1, __p + 2);
  }

  if (__p)
  {

    operator delete(__p);
  }
}

void std::allocator_traits<std::allocator<std::__hash_node<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,void *>>>::destroy[abi:ne200100]<std::pair<NSURL * const {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,void,0>(uint64_t a1, void **a2)
{
  objc_destroyWeak(a2 + 2);

  v3 = *a2;
}

id *TNSWeakPtr<FINode>::operator=(id *a1, id *location)
{
  if (a1 != location)
  {
    WeakRetained = objc_loadWeakRetained(location);
    objc_storeWeak(a1, WeakRetained);

    objc_storeWeak(location, 0);
  }

  return a1;
}

uint64_t std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>::pair[abi:ne200100]<NSProgress * const {__strong}&,FINode* {__strong}&,0>(uint64_t a1, id *a2, void **a3)
{
  *a1 = *a2;
  v5 = *a3;
  *(a1 + 8) = 0;
  objc_storeWeak((a1 + 8), v5);
  return a1;
}

void ___ZZZ27__FIOperation_makeProgress_ENK4__16clEP10NSProgressENKUlvE0_cvU13block_pointerFvvEEv_block_invoke(uint64_t a1)
{
  v2 = TNSWeakPtr<FIOperation>::Lock((a1 + 32));
  if (v2)
  {
    obj = v2;
    objc_sync_enter(v2);
    std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::__erase_unique<NSURL * {__strong}>(obj + 1, (a1 + 40));
    objc_sync_exit(obj);
    v2 = obj;
  }
}

void sub_1E5708C58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c67_ZTSKZZ27__FIOperation_makeProgress_ENK4__16clEP10NSProgressEUlvE0_(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((a1 + 32), (a2 + 32));
  result = *(a2 + 40);
  *(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_ea8_32c67_ZTSKZZ27__FIOperation_makeProgress_ENK4__16clEP10NSProgressEUlvE0_(uint64_t a1)
{

  objc_destroyWeak((a1 + 32));
}

uint64_t *std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::__erase_unique<NSURL * {__strong}>(void *a1, const void **a2)
{
  result = std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::find<NSURL * {__strong}>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::erase(a1, result);
    return 1;
  }

  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::__unordered_map_hasher<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::hash<NSURL * {__strong}>,std::equal_to<NSURL * {__strong}>,true>,std::__unordered_map_equal<NSURL * {__strong},std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,std::equal_to<NSURL * {__strong}>,std::hash<NSURL * {__strong}>,true>,std::allocator<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>>>::erase(void *a1, uint64_t *a2)
{
  v2 = *a2;
  std::__hash_table<std::__hash_value_type<TString,TProgressInfo>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TProgressInfo>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TProgressInfo>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TProgressInfo>>>::remove(a1, a2, &__p);
  v3 = __p;
  __p = 0;
  if (v3)
  {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSURL * {__strong},std::pair<NSProgress * {__strong},TNSWeakPtr<FINode>>>,void *>>>::operator()[abi:ne200100](&v6, v3);
  }

  return v2;
}

void ___ZZ35__FIOperation_executeAsFPOperation_ENK3__2cvU13block_pointerFvP11objc_objectP7NSErrorEEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  v20[1] = *MEMORY[0x1E69E9840];
  v5 = a2;
  v6 = a3;
  v7 = v5;
  v8 = v6;
  v9 = objc_cast<FPItem,objc_object * {__strong}>(v7);
  v10 = objc_cast<NSArray<FPItem *>,objc_object * {__strong}>(v7);
  if (!v10 && v9)
  {
    v20[0] = v9;
    v10 = [MEMORY[0x1E695DEC8] arrayWithObjects:v20 count:1];
  }

  v11 = [*(a1 + 32) errorHandler];
  v12 = v11;
  if (v8 && v11)
  {
    v13 = *(a1 + 32);
    v14 = [[FIOperationError alloc] initWithError:v8];
    v15 = (v12)[2](v12, v13, v14);

    if ([v15 resolution] != 1)
    {
      [*(a1 + 32) markAsCancelled];
    }
  }

  v16 = [*(a1 + 32) completionHandler];
  if (v16)
  {
    if ([v10 count])
    {
      v17 = *(a1 + 32);
      v19[0] = &unk_1F5F3E530;
      v19[1] = v17;
      v19[2] = MEMORY[0x1E692D6D0](v16);
      v19[3] = v19;
      [v17 fetchNodesAsyncFor:v10 completion:v19];
      std::__function::__value_func<void ()(std::vector<std::optional<FINode * {__strong}>> const&)>::~__value_func[abi:ne200100](v19);
    }

    else
    {
      v16[2](v16, *(a1 + 32), MEMORY[0x1E695E0F0]);
    }
  }

  [*(a1 + 32) invalidate];
  v18 = *MEMORY[0x1E69E9840];
}

void sub_1E5709078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__function::__value_func<void ()(std::vector<std::optional<FINode * {__strong}>> const&)>::~__value_func[abi:ne200100](&a9);

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c48_ZTSKZ35__FIOperation_executeAsFPOperation_E3__2(uint64_t a1, uint64_t a2)
{
  result = *(a2 + 32);
  *(a1 + 32) = result;
  return result;
}

id objc_cast<FPItem,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v2 = a1;
  }

  else
  {
    v2 = 0;
  }

  return v2;
}

id objc_cast<NSArray<FPItem *>,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v2 = a1;
  }

  else
  {
    v2 = 0;
  }

  return v2;
}

uint64_t **std::__hash_table<std::__hash_value_type<NSString * {__strong},FIProviderDomain * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},FIProviderDomain * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},FIProviderDomain * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},FIProviderDomain * {__strong}>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * {__strong}&&>,std::tuple<>>(void *a1, id *a2)
{
  v4 = [*a2 hash];
  v5 = v4;
  v6 = a1[1];
  if (!*&v6)
  {
    goto LABEL_18;
  }

  v7 = vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v6)
    {
      v9 = v4 % *&v6;
    }
  }

  else
  {
    v9 = (*&v6 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
    {
      break;
    }

    if (v8 > 1)
    {
      if (v12 >= *&v6)
      {
        v12 %= *&v6;
      }
    }

    else
    {
      v12 &= *&v6 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_18;
    }

LABEL_17:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_18;
    }
  }

  if ((std::equal_to<NSString * {__strong}>::operator()(a1, v11[2], *a2) & 1) == 0)
  {
    goto LABEL_17;
  }

  return v11;
}

uint64_t std::equal_to<NSString * {__strong}>::operator()(uint64_t a1, void *a2, void *a3)
{
  v4 = a2;
  v5 = a3;
  if (v4 == v5)
  {
    v6 = 1;
  }

  else
  {
    v6 = [v4 isEqualToString:v5];
  }

  return v6;
}

void std::__shared_ptr_emplace<std::unordered_map<NSString * {__strong},FIProviderDomain * {__strong}> const,std::allocator<std::allocator<std::pair<NSString * const {__strong},FIProviderDomain * {__strong}>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F5F3E5B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E692CD30);
}

void TSignpostInterval_FIOperation_FetchNodeAsync::Begin<char [25],NSString * {__strong},FPItem * {__strong}>(std::mutex *a1, uint64_t a2)
{
  v3 = *MEMORY[0x1E69E9840];
  v2 = a2;
  std::mutex::lock(a1);
  operator new();
}

void sub_1E570993C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne200100](va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

void TSignpostInterval_FIOperation_FetchNodeAsync::Event<char [50],NSString * {__strong},FPItemID * {__strong}>(std::mutex *a1, uint64_t a2)
{
  v3 = *MEMORY[0x1E69E9840];
  v2 = a2;
  std::mutex::lock(a1);
  operator new();
}

void sub_1E5709A40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne200100](va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c88_ZTSKZZ45__FIOperation_fetchNodesAsyncFor_completion__ENK4__21clEvEUlP6FINodeP7NSErrorE_(uint64_t a1, uint64_t a2)
{
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  *(a1 + 48) = *(a2 + 48);
  result = *(a2 + 64);
  *(a1 + 64) = result;
  return result;
}

void __destroy_helper_block_ea8_32c88_ZTSKZZ45__FIOperation_fetchNodesAsyncFor_completion__ENK4__21clEvEUlP6FINodeP7NSErrorE_(uint64_t a1)
{
  v2 = *(a1 + 32);
}

__n128 std::__function::__func<void TSignpostInterval_FIOperation_FetchNodeAsync::Begin<char [25],NSString * {__strong},FPItem * {__strong}>(unsigned long long,char [25],NSString * {__strong},FPItem * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void TSignpostInterval_FIOperation_FetchNodeAsync::Begin<char [25],NSString * {__strong},FPItem * {__strong}>(unsigned long long,char [25],NSString * {__strong},FPItem * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F5F3E630;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<void TSignpostInterval_FIOperation_FetchNodeAsync::Begin<char [25],NSString * {__strong},FPItem * {__strong}>(unsigned long long,char [25],NSString * {__strong},FPItem * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void TSignpostInterval_FIOperation_FetchNodeAsync::Begin<char [25],NSString * {__strong},FPItem * {__strong}>(unsigned long long,char [25],NSString * {__strong},FPItem * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void TSignpostInterval_FIOperation_FetchNodeAsync::Begin<char [25],NSString * {__strong},FPItem * {__strong}>(unsigned long long,char [25],NSString * {__strong},FPItem * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}::operator()(uint64_t a1, void *a2)
{
  v15 = *MEMORY[0x1E69E9840];
  v3 = a2;
  v4 = v3;
  v5 = **a1;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    v6 = *(a1 + 8);
    v7 = *(a1 + 16);
    v8 = *(a1 + 24);
    *&v12 = v6;
    *(&v12 + 1) = strlen(v6);
    FormatDetails<NSString * {__strong},FPItem * {__strong}>(&v12, v7, v8, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      p_p = &__p;
    }

    else
    {
      p_p = __p.__r_.__value_.__r.__words[0];
    }

    *buf = 136446210;
    v14 = p_p;
    _os_signpost_emit_with_name_impl(&dword_1E5674000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "FetchNodeAsync", "%{public}s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  v10 = *MEMORY[0x1E69E9840];
}

void FormatDetails<NSString * {__strong},FPItem * {__strong}>(__int128 *a1@<X0>, void **a2@<X1>, void **a3@<X2>, std::string *a4@<X8>)
{
  memset(&__p, 0, sizeof(__p));
  v12 = *a1;
  do
  {
    v7 = FormatOneDetails<NSString * {__strong}>(&v12, &__p, a2);
    if (v7)
    {
      *(&a4->__r_.__value_.__s + 23) = 0;
      a4->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }

  while (v7 == 0x700000000);
  FormatDetails<FPItem * {__strong}>(&v12, a3, &v11);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v10 = std::string::insert(&v11, 0, p_p, size);
  *a4 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v11.__r_.__value_.__l.__data_);
  }

LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1E5709FCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a24 < 0)
  {
    operator delete(a19);
  }

  _Unwind_Resume(exception_object);
}

void FormatDetails<FPItem * {__strong}>(__int128 *a1@<X0>, void **a2@<X1>, std::string *a3@<X8>)
{
  memset(&__p, 0, sizeof(__p));
  v10 = *a1;
  do
  {
    v5 = FormatOneDetails<FPItem * {__strong}>(&v10, &__p, a2);
    if (v5)
    {
      *(&a3->__r_.__value_.__s + 23) = 0;
      a3->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }

  while (v5 == 0x700000000);
  FormatDetails(&v10, &v9);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v8 = std::string::insert(&v9, 0, p_p, size);
  *a3 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v9.__r_.__value_.__l.__data_);
  }

LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1E570A0E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a24 < 0)
  {
    operator delete(a19);
  }

  _Unwind_Resume(exception_object);
}

void FormatDetails<NSString * {__strong}>(__int128 *a1@<X0>, std::string *a2@<X8>)
{
  memset(&__p, 0, sizeof(__p));
  v8 = *a1;
  do
  {
    v3 = FormatOneDetails<NSString * {__strong}>(&v8, &__p);
    if (v3)
    {
      *(&a2->__r_.__value_.__s + 23) = 0;
      a2->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }

  while (v3 == 0x700000000);
  FormatDetails(&v8, &v7);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v6 = std::string::insert(&v7, 0, p_p, size);
  *a2 = *v6;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v7.__r_.__value_.__l.__data_);
  }

LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1E570A1F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a24 < 0)
  {
    operator delete(a19);
  }

  _Unwind_Resume(exception_object);
}

_BYTE *HexDescriptionPrinterGlue<NSString * {__strong},void>::dump@<X0>(uint64_t a1@<X0>, void *a2@<X1>, _BYTE *a3@<X8>)
{
  v16[19] = *MEMORY[0x1E69E9840];
  v5 = *(a1 + 23);
  if ((v5 & 0x80u) != 0)
  {
    v5 = *(a1 + 8);
  }

  if (v5)
  {
    WidenHexFormatStringSpecifierToLongLong(a1, __p);
    if (v10 >= 0)
    {
      snprintf(__str, 0x64uLL, __p, *a2);
    }

    else
    {
      snprintf(__str, 0x64uLL, __p[0], *a2);
    }

    if (v10 < 0)
    {
      operator delete(__p[0]);
    }

    result = std::string::basic_string[abi:ne200100]<0>(a3, __str);
  }

  else
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne200100](__str);
    *(&v12 + *(v12 - 24) + 8) = *(&v12 + *(v12 - 24) + 8) & 0xFFFFFFB5 | 8;
    MEMORY[0x1E692CAE0](&v12, *a2);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str[abi:ne200100](__str, a3);
    *__str = *MEMORY[0x1E69E54D8];
    v7 = *(MEMORY[0x1E69E54D8] + 72);
    *&__str[*(*__str - 24)] = *(MEMORY[0x1E69E54D8] + 64);
    v12 = v7;
    v13 = MEMORY[0x1E69E5548] + 16;
    if (v15 < 0)
    {
      operator delete(v14[7].__locale_);
    }

    v13 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v14);
    std::iostream::~basic_iostream();
    result = MEMORY[0x1E692CCA0](v16);
  }

  v8 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1E570A474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(va);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  v2 = MEMORY[0x1E69E54D8];
  v3 = *MEMORY[0x1E69E54D8];
  *a1 = *MEMORY[0x1E69E54D8];
  v4 = *(v2 + 72);
  *(a1 + *(v3 - 24)) = *(v2 + 64);
  *(a1 + 16) = v4;
  *(a1 + 24) = MEMORY[0x1E69E5548] + 16;
  if (*(a1 + 111) < 0)
  {
    operator delete(*(a1 + 88));
  }

  *(a1 + 24) = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale((a1 + 32));
  std::iostream::~basic_iostream();
  MEMORY[0x1E692CCA0](a1 + 128);
  return a1;
}

unint64_t FormatOneDetails<FPItem * {__strong}>(const std::string::value_type **a1, std::string *this, void **a3)
{
  v3 = a1[1];
  if (!v3)
  {
    v12 = 0;
    v9 = 1;
    return v12 | v9;
  }

  v7 = *a1;
  v8 = &v3[*a1];
  v9 = 1;
  v10 = *a1;
LABEL_3:
  v11 = 0;
  while (*v10 != asc_1E57B78C0[v11])
  {
    if (++v11 == 3)
    {
      if (++v10 == v8)
      {
        v12 = 0;
        return v12 | v9;
      }

      goto LABEL_3;
    }
  }

  v12 = 0;
  v9 = 1;
  if (v10 != v8)
  {
    v13 = v10 - v7;
    if (v10 - v7 != -1)
    {
      std::string::append(this, v7, v10 - v7);
      v14 = a1[1];
      v15 = v14 >= v13;
      v16 = &v14[-v13];
      if (!v15)
      {
        goto LABEL_93;
      }

      *a1 += v13;
      a1[1] = v16;
      ParseFormat(a1, &v36);
      v17 = v37;
      if (!v37)
      {
        v12 = 0;
        v9 = 2;
        return v12 | v9;
      }

      if (v38 <= 4)
      {
        if ((v38 - 1) < 3)
        {
          goto LABEL_90;
        }

        if (v38 == 4)
        {
          if (v37 <= 0x7FFFFFFFFFFFFFF7)
          {
            if (v37 >= 0x17)
            {
              operator new();
            }

            *(&__dst.__r_.__value_.__s + 23) = v37;
            memmove(&__dst, v36, v37);
            __dst.__r_.__value_.__s.__data_[v17] = 0;
            HexDescriptionPrinterGlue<FPItem * {__strong},void>::dump(&__dst, a3, &__p);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              p_p = &__p;
            }

            else
            {
              p_p = __p.__r_.__value_.__r.__words[0];
            }

            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            }

            else
            {
              size = __p.__r_.__value_.__l.__size_;
            }

            goto LABEL_69;
          }

LABEL_94:
          std::string::__throw_length_error[abi:ne200100]();
        }

        goto LABEL_47;
      }

      if (v38 <= 6)
      {
        if (v38 == 5)
        {
          Description<NSString * {__strong}>(a3, &__dst);
          RedactForPrivacy(&v36, &__dst, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_p = &__p;
          }

          else
          {
            p_p = __p.__r_.__value_.__r.__words[0];
          }

          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }
        }

        else
        {
          Description<NSString * {__strong}>(a3, &__dst);
          RedactForPrivacy(&v36, &__dst, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_p = &__p;
          }

          else
          {
            p_p = __p.__r_.__value_.__r.__words[0];
          }

          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }
        }

LABEL_69:
        std::string::append(this, p_p, size);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }

        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_90:
          v28 = a1[1];
          v29 = &v28[-v37];
          if (v28 >= v37)
          {
            v9 = 0;
            *a1 += v37;
            a1[1] = v29;
            v12 = v38 << 32;
            return v12 | v9;
          }

LABEL_93:
          std::__throw_out_of_range[abi:ne200100]("string_view::substr");
        }

        v25 = __dst.__r_.__value_.__r.__words[0];
LABEL_89:
        operator delete(v25);
        goto LABEL_90;
      }

      if (v38 == 8)
      {
        if (v37 > 0x7FFFFFFFFFFFFFF7)
        {
          goto LABEL_94;
        }

        if (v37 >= 0x17)
        {
          operator new();
        }

        *(&__dst.__r_.__value_.__s + 23) = v37;
        memmove(&__dst, v36, v37);
        __dst.__r_.__value_.__s.__data_[v17] = 0;
        ExtractEmbeddedFormat(&__dst, &__p);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }

        v22 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        v23 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          v22 = __p.__r_.__value_.__l.__size_;
          v23 = __p.__r_.__value_.__r.__words[0];
        }

        v33.__r_.__value_.__r.__words[0] = v23;
        v33.__r_.__value_.__l.__size_ = v22;
        FormatDetails<FPItem * {__strong}>(&__dst, &v33, a3);
        v24 = v37;
        if (v37 > 0x7FFFFFFFFFFFFFF7)
        {
          std::string::__throw_length_error[abi:ne200100]();
        }

        if (v37 >= 0x17)
        {
          operator new();
        }

        v32 = v37;
        if (v37)
        {
          memmove(&v31, v36, v37);
        }

        *(&v31 + v24) = 0;
        ExtendedFormatAdaptor(&v31, &__dst, &v33);
        if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v26 = &v33;
        }

        else
        {
          v26 = v33.__r_.__value_.__r.__words[0];
        }

        if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v27 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v27 = v33.__r_.__value_.__l.__size_;
        }

        std::string::append(this, v26, v27);
        if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v33.__r_.__value_.__l.__data_);
        }

        if (v32 < 0)
        {
          operator delete(v31);
        }

        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
      }

      else
      {
        if (v38 != 7)
        {
LABEL_47:
          Description<NSString * {__strong}>(a3, &__dst);
          RedactForPrivacy(&v36, &__dst, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_p = &__p;
          }

          else
          {
            p_p = __p.__r_.__value_.__r.__words[0];
          }

          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }

          goto LABEL_69;
        }

        DeEscapeFormatFragment(&v36, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v20 = &__p;
        }

        else
        {
          v20 = __p.__r_.__value_.__r.__words[0];
        }

        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v21 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v21 = __p.__r_.__value_.__l.__size_;
        }

        std::string::append(this, v20, v21);
      }

      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_90;
      }

      v25 = __p.__r_.__value_.__r.__words[0];
      goto LABEL_89;
    }
  }

  return v12 | v9;
}

void sub_1E570AAE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  if (a15 < 0)
  {
    operator delete(a10);
  }

  if (a27 < 0)
  {
    operator delete(a22);
  }

  if (a33 < 0)
  {
    operator delete(a28);
  }

  _Unwind_Resume(exception_object);
}

_BYTE *HexDescriptionPrinterGlue<FPItem * {__strong},void>::dump@<X0>(uint64_t a1@<X0>, void *a2@<X1>, _BYTE *a3@<X8>)
{
  v16[19] = *MEMORY[0x1E69E9840];
  v5 = *(a1 + 23);
  if ((v5 & 0x80u) != 0)
  {
    v5 = *(a1 + 8);
  }

  if (v5)
  {
    WidenHexFormatStringSpecifierToLongLong(a1, __p);
    if (v10 >= 0)
    {
      snprintf(__str, 0x64uLL, __p, *a2);
    }

    else
    {
      snprintf(__str, 0x64uLL, __p[0], *a2);
    }

    if (v10 < 0)
    {
      operator delete(__p[0]);
    }

    result = std::string::basic_string[abi:ne200100]<0>(a3, __str);
  }

  else
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne200100](__str);
    *(&v12 + *(v12 - 24) + 8) = *(&v12 + *(v12 - 24) + 8) & 0xFFFFFFB5 | 8;
    MEMORY[0x1E692CAE0](&v12, *a2);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str[abi:ne200100](__str, a3);
    *__str = *MEMORY[0x1E69E54D8];
    v7 = *(MEMORY[0x1E69E54D8] + 72);
    *&__str[*(*__str - 24)] = *(MEMORY[0x1E69E54D8] + 64);
    v12 = v7;
    v13 = MEMORY[0x1E69E5548] + 16;
    if (v15 < 0)
    {
      operator delete(v14[7].__locale_);
    }

    v13 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v14);
    std::iostream::~basic_iostream();
    result = MEMORY[0x1E692CCA0](v16);
  }

  v8 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1E570ADE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(va);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<NSString * {__strong},FIProviderDomain * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},FIProviderDomain * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},FIProviderDomain * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},FIProviderDomain * {__strong}>>>::find<NSString * {__strong}>(void *a1, id *a2)
{
  v4 = [*a2 hash];
  v5 = a1[1];
  if (!*&v5)
  {
    return 0;
  }

  v6 = v4;
  v7 = vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v5)
    {
      v9 = v4 % *&v5;
    }
  }

  else
  {
    v9 = (*&v5 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10)
  {
    return 0;
  }

  for (i = *v10; i; i = *i)
  {
    v12 = i[1];
    if (v12 == v6)
    {
      if (std::equal_to<NSString * {__strong}>::operator()(a1, i[2], *a2))
      {
        return i;
      }
    }

    else
    {
      if (v8 > 1)
      {
        if (v12 >= *&v5)
        {
          v12 %= *&v5;
        }
      }

      else
      {
        v12 &= *&v5 - 1;
      }

      if (v12 != v9)
      {
        return 0;
      }
    }
  }

  return i;
}

__n128 std::__function::__func<void TSignpostInterval_FIOperation_FetchNodeAsync::Event<char [50],NSString * {__strong},FPItemID * {__strong}>(unsigned long long,char [50],NSString * {__strong},FPItemID * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void TSignpostInterval_FIOperation_FetchNodeAsync::Event<char [50],NSString * {__strong},FPItemID * {__strong}>(unsigned long long,char [50],NSString * {__strong},FPItemID * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F5F3E6C0;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<void TSignpostInterval_FIOperation_FetchNodeAsync::Event<char [50],NSString * {__strong},FPItemID * {__strong}>(unsigned long long,char [50],NSString * {__strong},FPItemID * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void TSignpostInterval_FIOperation_FetchNodeAsync::Event<char [50],NSString * {__strong},FPItemID * {__strong}>(unsigned long long,char [50],NSString * {__strong},FPItemID * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void TSignpostInterval_FIOperation_FetchNodeAsync::Event<char [50],NSString * {__strong},FPItemID * {__strong}>(unsigned long long,char [50],NSString * {__strong},FPItemID * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}::operator()(uint64_t a1, void *a2)
{
  v15 = *MEMORY[0x1E69E9840];
  v3 = a2;
  v4 = v3;
  v5 = **a1;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    v6 = *(a1 + 8);
    v7 = *(a1 + 16);
    v8 = *(a1 + 24);
    *&v12 = v6;
    *(&v12 + 1) = strlen(v6);
    FormatDetails<NSString * {__strong},FPItemID * {__strong}>(&v12, v7, v8, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      p_p = &__p;
    }

    else
    {
      p_p = __p.__r_.__value_.__r.__words[0];
    }

    *buf = 136446210;
    v14 = p_p;
    _os_signpost_emit_with_name_impl(&dword_1E5674000, v4, OS_SIGNPOST_EVENT, v5, "FetchNodeAsync", "%{public}s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  v10 = *MEMORY[0x1E69E9840];
}

void FormatDetails<NSString * {__strong},FPItemID * {__strong}>(__int128 *a1@<X0>, void **a2@<X1>, void **a3@<X2>, std::string *a4@<X8>)
{
  memset(&__p, 0, sizeof(__p));
  v12 = *a1;
  do
  {
    v7 = FormatOneDetails<NSString * {__strong}>(&v12, &__p, a2);
    if (v7)
    {
      *(&a4->__r_.__value_.__s + 23) = 0;
      a4->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }

  while (v7 == 0x700000000);
  FormatDetails<FPItemID * {__strong}>(&v12, a3, &v11);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v10 = std::string::insert(&v11, 0, p_p, size);
  *a4 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v11.__r_.__value_.__l.__data_);
  }

LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1E570B22C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a24 < 0)
  {
    operator delete(a19);
  }

  _Unwind_Resume(exception_object);
}

void FormatDetails<FPItemID * {__strong}>(__int128 *a1@<X0>, void **a2@<X1>, std::string *a3@<X8>)
{
  memset(&__p, 0, sizeof(__p));
  v10 = *a1;
  do
  {
    v5 = FormatOneDetails<FPItemID * {__strong}>(&v10, &__p, a2);
    if (v5)
    {
      *(&a3->__r_.__value_.__s + 23) = 0;
      a3->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }

  while (v5 == 0x700000000);
  FormatDetails(&v10, &v9);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v8 = std::string::insert(&v9, 0, p_p, size);
  *a3 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v9.__r_.__value_.__l.__data_);
  }

LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1E570B340(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a24 < 0)
  {
    operator delete(a19);
  }

  _Unwind_Resume(exception_object);
}

unint64_t FormatOneDetails<FPItemID * {__strong}>(const std::string::value_type **a1, std::string *this, void **a3)
{
  v3 = a1[1];
  if (!v3)
  {
    v12 = 0;
    v9 = 1;
    return v12 | v9;
  }

  v7 = *a1;
  v8 = &v3[*a1];
  v9 = 1;
  v10 = *a1;
LABEL_3:
  v11 = 0;
  while (*v10 != asc_1E57B78C0[v11])
  {
    if (++v11 == 3)
    {
      if (++v10 == v8)
      {
        v12 = 0;
        return v12 | v9;
      }

      goto LABEL_3;
    }
  }

  v12 = 0;
  v9 = 1;
  if (v10 != v8)
  {
    v13 = v10 - v7;
    if (v10 - v7 != -1)
    {
      std::string::append(this, v7, v10 - v7);
      v14 = a1[1];
      v15 = v14 >= v13;
      v16 = &v14[-v13];
      if (!v15)
      {
        goto LABEL_93;
      }

      *a1 += v13;
      a1[1] = v16;
      ParseFormat(a1, &v36);
      v17 = v37;
      if (!v37)
      {
        v12 = 0;
        v9 = 2;
        return v12 | v9;
      }

      if (v38 <= 4)
      {
        if ((v38 - 1) < 3)
        {
          goto LABEL_90;
        }

        if (v38 == 4)
        {
          if (v37 <= 0x7FFFFFFFFFFFFFF7)
          {
            if (v37 >= 0x17)
            {
              operator new();
            }

            *(&__dst.__r_.__value_.__s + 23) = v37;
            memmove(&__dst, v36, v37);
            __dst.__r_.__value_.__s.__data_[v17] = 0;
            HexDescriptionPrinterGlue<FPItemID * {__strong},void>::dump(&__dst, a3, &__p);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              p_p = &__p;
            }

            else
            {
              p_p = __p.__r_.__value_.__r.__words[0];
            }

            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            }

            else
            {
              size = __p.__r_.__value_.__l.__size_;
            }

            goto LABEL_69;
          }

LABEL_94:
          std::string::__throw_length_error[abi:ne200100]();
        }

        goto LABEL_47;
      }

      if (v38 <= 6)
      {
        if (v38 == 5)
        {
          Description<NSString * {__strong}>(a3, &__dst);
          RedactForPrivacy(&v36, &__dst, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_p = &__p;
          }

          else
          {
            p_p = __p.__r_.__value_.__r.__words[0];
          }

          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }
        }

        else
        {
          Description<NSString * {__strong}>(a3, &__dst);
          RedactForPrivacy(&v36, &__dst, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_p = &__p;
          }

          else
          {
            p_p = __p.__r_.__value_.__r.__words[0];
          }

          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }
        }

LABEL_69:
        std::string::append(this, p_p, size);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }

        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_90:
          v28 = a1[1];
          v29 = &v28[-v37];
          if (v28 >= v37)
          {
            v9 = 0;
            *a1 += v37;
            a1[1] = v29;
            v12 = v38 << 32;
            return v12 | v9;
          }

LABEL_93:
          std::__throw_out_of_range[abi:ne200100]("string_view::substr");
        }

        v25 = __dst.__r_.__value_.__r.__words[0];
LABEL_89:
        operator delete(v25);
        goto LABEL_90;
      }

      if (v38 == 8)
      {
        if (v37 > 0x7FFFFFFFFFFFFFF7)
        {
          goto LABEL_94;
        }

        if (v37 >= 0x17)
        {
          operator new();
        }

        *(&__dst.__r_.__value_.__s + 23) = v37;
        memmove(&__dst, v36, v37);
        __dst.__r_.__value_.__s.__data_[v17] = 0;
        ExtractEmbeddedFormat(&__dst, &__p);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }

        v22 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        v23 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          v22 = __p.__r_.__value_.__l.__size_;
          v23 = __p.__r_.__value_.__r.__words[0];
        }

        v33.__r_.__value_.__r.__words[0] = v23;
        v33.__r_.__value_.__l.__size_ = v22;
        FormatDetails<FPItemID * {__strong}>(&__dst, &v33, a3);
        v24 = v37;
        if (v37 > 0x7FFFFFFFFFFFFFF7)
        {
          std::string::__throw_length_error[abi:ne200100]();
        }

        if (v37 >= 0x17)
        {
          operator new();
        }

        v32 = v37;
        if (v37)
        {
          memmove(&v31, v36, v37);
        }

        *(&v31 + v24) = 0;
        ExtendedFormatAdaptor(&v31, &__dst, &v33);
        if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v26 = &v33;
        }

        else
        {
          v26 = v33.__r_.__value_.__r.__words[0];
        }

        if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v27 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v27 = v33.__r_.__value_.__l.__size_;
        }

        std::string::append(this, v26, v27);
        if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v33.__r_.__value_.__l.__data_);
        }

        if (v32 < 0)
        {
          operator delete(v31);
        }

        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
      }

      else
      {
        if (v38 != 7)
        {
LABEL_47:
          Description<NSString * {__strong}>(a3, &__dst);
          RedactForPrivacy(&v36, &__dst, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_p = &__p;
          }

          else
          {
            p_p = __p.__r_.__value_.__r.__words[0];
          }

          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }

          goto LABEL_69;
        }

        DeEscapeFormatFragment(&v36, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v20 = &__p;
        }

        else
        {
          v20 = __p.__r_.__value_.__r.__words[0];
        }

        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v21 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v21 = __p.__r_.__value_.__l.__size_;
        }

        std::string::append(this, v20, v21);
      }

      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_90;
      }

      v25 = __p.__r_.__value_.__r.__words[0];
      goto LABEL_89;
    }
  }

  return v12 | v9;
}

void sub_1E570B87C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  if (a15 < 0)
  {
    operator delete(a10);
  }

  if (a27 < 0)
  {
    operator delete(a22);
  }

  if (a33 < 0)
  {
    operator delete(a28);
  }

  _Unwind_Resume(exception_object);
}

_BYTE *HexDescriptionPrinterGlue<FPItemID * {__strong},void>::dump@<X0>(uint64_t a1@<X0>, void *a2@<X1>, _BYTE *a3@<X8>)
{
  v16[19] = *MEMORY[0x1E69E9840];
  v5 = *(a1 + 23);
  if ((v5 & 0x80u) != 0)
  {
    v5 = *(a1 + 8);
  }

  if (v5)
  {
    WidenHexFormatStringSpecifierToLongLong(a1, __p);
    if (v10 >= 0)
    {
      snprintf(__str, 0x64uLL, __p, *a2);
    }

    else
    {
      snprintf(__str, 0x64uLL, __p[0], *a2);
    }

    if (v10 < 0)
    {
      operator delete(__p[0]);
    }

    result = std::string::basic_string[abi:ne200100]<0>(a3, __str);
  }

  else
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne200100](__str);
    *(&v12 + *(v12 - 24) + 8) = *(&v12 + *(v12 - 24) + 8) & 0xFFFFFFB5 | 8;
    MEMORY[0x1E692CAE0](&v12, *a2);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str[abi:ne200100](__str, a3);
    *__str = *MEMORY[0x1E69E54D8];
    v7 = *(MEMORY[0x1E69E54D8] + 72);
    *&__str[*(*__str - 24)] = *(MEMORY[0x1E69E54D8] + 64);
    v12 = v7;
    v13 = MEMORY[0x1E69E5548] + 16;
    if (v15 < 0)
    {
      operator delete(v14[7].__locale_);
    }

    v13 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v14);
    std::iostream::~basic_iostream();
    result = MEMORY[0x1E692CCA0](v16);
  }

  v8 = *MEMORY[0x1E69E9840];
  return result;
}

void sub_1E570BB74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(va);
  _Unwind_Resume(a1);
}

void TSignpostInterval_FIOperation_FetchNodeAsync::End<char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong}>(std::mutex *a1, uint64_t a2)
{
  v3 = *MEMORY[0x1E69E9840];
  v2 = a2;
  std::mutex::lock(a1);
  operator new();
}

void sub_1E570BC74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne200100](va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<void TSignpostInterval_FIOperation_FetchNodeAsync::End<char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong}>(unsigned long long,char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void TSignpostInterval_FIOperation_FetchNodeAsync::End<char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong}>(unsigned long long,char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F5F3E740;
  result = *(a1 + 8);
  v3 = *(a1 + 24);
  *(a2 + 40) = *(a1 + 40);
  *(a2 + 24) = v3;
  *(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<void TSignpostInterval_FIOperation_FetchNodeAsync::End<char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong}>(unsigned long long,char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void TSignpostInterval_FIOperation_FetchNodeAsync::End<char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong}>(unsigned long long,char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void TSignpostInterval_FIOperation_FetchNodeAsync::End<char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong}>(unsigned long long,char [47],NSString * {__strong},FPItemID * {__strong},FINode * {__strong} const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}::operator()(uint64_t a1, void *a2)
{
  v16 = *MEMORY[0x1E69E9840];
  v3 = a2;
  v4 = v3;
  v5 = **a1;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    v6 = *(a1 + 8);
    v7 = *(a1 + 16);
    v9 = *(a1 + 24);
    v8 = *(a1 + 32);
    *&v13 = v6;
    *(&v13 + 1) = strlen(v6);
    FormatDetails<NSString * {__strong},FPItemID * {__strong},FINode * {__strong}>(&v13, v7, v9, v8, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      p_p = &__p;
    }

    else
    {
      p_p = __p.__r_.__value_.__r.__words[0];
    }

    *buf = 136446210;
    v15 = p_p;
    _os_signpost_emit_with_name_impl(&dword_1E5674000, v4, OS_SIGNPOST_INTERVAL_END, v5, "FetchNodeAsync", "%{public}s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  v11 = *MEMORY[0x1E69E9840];
}

void FormatDetails<NSString * {__strong},FPItemID * {__strong},FINode * {__strong}>(__int128 *a1@<X0>, void **a2@<X1>, void **a3@<X2>, void **a4@<X3>, std::string *a5@<X8>)
{
  memset(&__p, 0, sizeof(__p));
  v14 = *a1;
  do
  {
    v9 = FormatOneDetails<NSString * {__strong}>(&v14, &__p, a2);
    if (v9)
    {
      *(&a5->__r_.__value_.__s + 23) = 0;
      a5->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }

  while (v9 == 0x700000000);
  FormatDetails<FPItemID * {__strong},FINode * {__strong}>(&v14, a3, a4, &v13);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v12 = std::string::insert(&v13, 0, p_p, size);
  *a5 = *v12;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v13.__r_.__value_.__l.__data_);
  }

LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1E570BFEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a24 < 0)
  {
    operator delete(a19);
  }

  _Unwind_Resume(exception_object);
}

void FormatDetails<FPItemID * {__strong},FINode * {__strong}>(__int128 *a1@<X0>, void **a2@<X1>, void **a3@<X2>, std::string *a4@<X8>)
{
  memset(&__p, 0, sizeof(__p));
  v12 = *a1;
  do
  {
    v7 = FormatOneDetails<FPItemID * {__strong}>(&v12, &__p, a2);
    if (v7)
    {
      *(&a4->__r_.__value_.__s + 23) = 0;
      a4->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }

  while (v7 == 0x700000000);
  FormatDetails<FINode * {__strong}>(&v12, a3, &v11);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v10 = std::string::insert(&v11, 0, p_p, size);
  *a4 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v11.__r_.__value_.__l.__data_);
  }

LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1E570C108(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a24 < 0)
  {
    operator delete(a19);
  }

  _Unwind_Resume(exception_object);
}

void FormatDetails<FINode * {__strong}>(__int128 *a1@<X0>, void **a2@<X1>, std::string *a3@<X8>)
{
  memset(&__p, 0, sizeof(__p));
  v10 = *a1;
  do
  {
    v5 = FormatOneDetails<FINode * {__strong}>(&v10, &__p, a2);
    if (v5)
    {
      *(&a3->__r_.__value_.__s + 23) = 0;
      a3->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }

  while (v5 == 0x700000000);
  FormatDetails(&v10, &v9);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v8 = std::string::insert(&v9, 0, p_p, size);
  *a3 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v9.__r_.__value_.__l.__data_);
  }

LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1E570C21C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a24 < 0)
  {
    operator delete(a19);
  }

  _Unwind_Resume(exception_object);
}

unint64_t FormatOneDetails<FINode * {__strong}>(const std::string::value_type **a1, std::string *this, void **a3)
{
  v3 = a1[1];
  if (!v3)
  {
    v12 = 0;
    v9 = 1;
    return v12 | v9;
  }

  v7 = *a1;
  v8 = &v3[*a1];
  v9 = 1;
  v10 = *a1;
LABEL_3:
  v11 = 0;
  while (*v10 != asc_1E57B78C0[v11])
  {
    if (++v11 == 3)
    {
      if (++v10 == v8)
      {
        v12 = 0;
        return v12 | v9;
      }

      goto LABEL_3;
    }
  }

  v12 = 0;
  v9 = 1;
  if (v10 != v8)
  {
    v13 = v10 - v7;
    if (v10 - v7 != -1)
    {
      std::string::append(this, v7, v10 - v7);
      v14 = a1[1];
      v15 = v14 >= v13;
      v16 = &v14[-v13];
      if (!v15)
      {
        goto LABEL_93;
      }

      *a1 += v13;
      a1[1] = v16;
      ParseFormat(a1, &v36);
      v17 = v37;
      if (!v37)
      {
        v12 = 0;
        v9 = 2;
        return v12 | v9;
      }

      if (v38 <= 4)
      {
        if ((v38 - 1) < 3)
        {
          goto LABEL_90;
        }

        if (v38 == 4)
        {
          if (v37 <= 0x7FFFFFFFFFFFFFF7)
          {
            if (v37 >= 0x17)
            {
              operator new();
            }

            *(&__dst.__r_.__value_.__s + 23) = v37;
            memmove(&__dst, v36, v37);
            __dst.__r_.__value_.__s.__data_[v17] = 0;
            HexDescriptionPrinterGlue<FINode * {__strong},void>::dump(&__dst, a3, &__p);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              p_p = &__p;
            }

            else
            {
              p_p = __p.__r_.__value_.__r.__words[0];
            }

            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            }

            else
            {
              size = __p.__r_.__value_.__l.__size_;
            }

            goto LABEL_69;
          }

LABEL_94:
          std::string::__throw_length_error[abi:ne200100]();
        }

        goto LABEL_47;
      }

      if (v38 <= 6)
      {
        if (v38 == 5)
        {
          Description<NSString * {__strong}>(a3, &__dst);
          RedactForPrivacy(&v36, &__dst, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_p = &__p;
          }

          else
          {
            p_p = __p.__r_.__value_.__r.__words[0];
          }

          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }
        }

        else
        {
          Description<NSString * {__strong}>(a3, &__dst);
          RedactForPrivacy(&v36, &__dst, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_p = &__p;
          }

          else
          {
            p_p = __p.__r_.__value_.__r.__words[0];
          }

          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }
        }

LABEL_69:
        std::string::append(this, p_p, size);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }

        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_90:
          v28 = a1[1];
          v29 = &v28[-v37];
          if (v28 >= v37)
          {
            v9 = 0;
            *a1 += v37;
            a1[1] = v29;
            v12 = v38 << 32;
            return v12 | v9;
          }

LABEL_93:
          std::__throw_out_of_range[abi:ne200100]("string_view::substr");
        }

        v25 = __dst.__r_.__value_.__r.__words[0];
LABEL_89:
        operator delete(v25);
        goto LABEL_90;
      }

      if (v38 == 8)
      {
        if (v37 > 0x7FFFFFFFFFFFFFF7)
        {
          goto LABEL_94;
        }

        if (v37 >= 0x17)
        {
          operator new();
        }

        *(&__dst.__r_.__value_.__s + 23) = v37;
        memmove(&__dst, v36, v37);
        __dst.__r_.__value_.__s.__data_[v17] = 0;
        ExtractEmbeddedFormat(&__dst, &__p);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }

        v22 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        v23 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          v22 = __p.__r_.__value_.__l.__size_;
          v23 = __p.__r_.__value_.__r.__words[0];
        }

        v33.__r_.__value_.__r.__words[0] = v23;
        v33.__r_.__value_.__l.__size_ = v22;
        FormatDetails<FINode * {__strong}>(&__dst, &v33, a3);
        v24 = v37;
        if (v37 > 0x7FFFFFFFFFFFFFF7)
        {
          std::string::__throw_length_error[abi:ne200100]();
        }

        if (v37 >= 0x17)
        {
          operator new();
        }

        v32 = v37;
        if (v37)
        {
          memmove(&v31, v36, v37);
        }

        *(&v31 + v24) = 0;
        ExtendedFormatAdaptor(&v31, &__dst, &v33);
        if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v26 = &v33;
        }

        else
        {
          v26 = v33.__r_.__value_.__r.__words[0];
        }

        if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v27 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v27 = v33.__r_.__value_.__l.__size_;
        }

        std::string::append(this, v26, v27);
        if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v33.__r_.__value_.__l.__data_);
        }

        if (v32 < 0)
        {
          operator delete(v31);
        }

        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
      }

      else
      {
        if (v38 != 7)
        {
LABEL_47:
          Description<NSString * {__strong}>(a3, &__dst);
          RedactForPrivacy(&v36, &__dst, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            p_p = &__p;
          }

          else
          {
            p_p = __p.__r_.__value_.__r.__words[0];
          }

          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }

          else
          {
            size = __p.__r_.__value_.__l.__size_;
          }

          goto LABEL_69;
        }

        DeEscapeFormatFragment(&v36, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v20 = &__p;
        }

        else
        {
          v20 = __p.__r_.__value_.__r.__words[0];
        }

        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v21 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v21 = __p.__r_.__value_.__l.__size_;
        }

        std::string::append(this, v20, v21);
      }

      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_90;
      }

      v25 = __p.__r_.__value_.__r.__words[0];
      goto LABEL_89;
    }
  }

  return v12 | v9;
}